public string get languag ( boolean us default ) { return ( languag = = null us default default languag : languag ) ; }	public extend void set extend ( string valu , node . page direct n ) { xtend = valu ; page superclass top level class ( i . e . packag ) explicitli import . thi done , compil assum extend class same pkg gener servlet . ( valu . index ( . ) 0 ) n . add import ( valu ) ; }	overrid public void visit ( node . page direct n ) throw jasper except { jsp util . check attribut ( page direct , n , page direct attr , err ) ; jsp . 2 . 10 . 1 attribut attr = n . get attribut ( ) ; ( int i = 0 ; attr = null i attr . get length ( ) ; i ) { string attr = attr . get qname ( i ) ; string valu = attr . get valu ( i ) ; ( languag . equal ( attr ) ) { ( page info . get languag ( fals ) = = null ) { page info . set languag ( valu , n , err , true ) ; } els ( page info . get languag ( fals ) . equal ( valu ) ) { err . jsp error ( n , jsp . error . page . conflict . languag , page info . get languag ( fals ) , valu ) ; } } els ( extend . equal ( attr ) ) { ( page info . get extend ( fals ) = = null ) { page info . set extend ( valu , n ) ; } els ( page info . get extend ( fals ) . equal ( valu ) ) { err . jsp error ( n , jsp . error . page . conflict . extend , page info . get extend ( fals ) , valu ) ; } } els ( content type . equal ( attr ) ) { ( page info . get content type ( ) = = null ) { page info . set content type ( valu ) ; } els ( page info . get content type ( ) . equal ( valu ) ) { err . jsp error ( n , jsp . error . page . conflict . contenttyp , page info . get content type ( ) , valu ) ; } } els ( session . equal ( attr ) ) { ( page info . get session ( ) = = null ) { page info . set session ( valu , n , err ) ; } els ( page info . get session ( ) . equal ( valu ) ) { err . jsp error ( n , jsp . error . page . conflict . session , page info . get session ( ) , valu ) ; } } els ( buffer . equal ( attr ) ) { ( page info . get buffer valu ( ) = = null ) { page info . set buffer valu ( valu , n , err ) ; } els ( page info . get buffer valu ( ) . equal ( valu ) ) { err . jsp error ( n , jsp . error . page . conflict . buffer , page info . get buffer valu ( ) , valu ) ; } } els ( auto flush . equal ( attr ) ) { ( page info . get auto flush ( ) = = null ) { page info . set auto flush ( valu , n , err ) ; } els ( page info . get auto flush ( ) . equal ( valu ) ) { err . jsp error ( n , jsp . error . page . conflict . autoflush , page info . get auto flush ( ) , valu ) ; } } els ( thread safe . equal ( attr ) ) { ( page info . get thread safe ( ) = = null ) { page info . set thread safe ( valu , n , err ) ; } els ( page info . get thread safe ( ) . equal ( valu ) ) { err . jsp error ( n , jsp . error . page . conflict . isthreadsaf , page info . get thread safe ( ) , valu ) ; } } els ( elignor . equal ( attr ) ) { ( page info . get elignor ( ) = = null ) { page info . set elignor ( valu , n , err , true ) ; } els ( page info . get elignor ( ) . equal ( valu ) ) { err . jsp error ( n , jsp . error . page . conflict . iselignor , page info . get elignor ( ) , valu ) ; } } els ( error page . equal ( attr ) ) { ( page info . get error page ( ) = = null ) { page info . set error page ( valu , n , err ) ; } els ( page info . get error page ( ) . equal ( valu ) ) { err . jsp error ( n , jsp . error . page . conflict . iserrorpag , page info . get error page ( ) , valu ) ; } } els ( error page . equal ( attr ) ) { ( page info . get error page ( ) = = null ) { page info . set error page ( valu ) ; } els ( page info . get error page ( ) . equal ( valu ) ) { err . jsp error ( n , jsp . error . page . conflict . errorpag , page info . get error page ( ) , valu ) ; } } els ( info . equal ( attr ) ) { ( page info . get info ( ) = = null ) { page info . set info ( valu ) ; } els ( page info . get info ( ) . equal ( valu ) ) { err . jsp error ( n , jsp . error . page . conflict . info , page info . get info ( ) , valu ) ; } } els ( page encod . equal ( attr ) ) { ( page encod seen ) err . jsp error ( n , jsp . error . page . multi . pageencod ) ; page encod can occur most onc per file page encod seen = true ; string actual = compar page encod ( valu , n ) ; n . get root ( ) . set page encod ( actual ) ; } els ( defer syntax allow liter . equal ( attr ) ) { ( page info . get defer syntax allow liter ( ) = = null ) { page info . set defer syntax allow liter ( valu , n , err , true ) ; } els ( page info . get defer syntax allow liter ( ) . equal ( valu ) ) { err . jsp error ( n , jsp . error . page . conflict . , page info . get defer syntax allow liter ( ) , valu ) ; } } els ( trim direct whitespac . equal ( attr ) ) { ( page info . get trim direct whitespac ( ) = = null ) { page info . set trim direct whitespac ( valu , n , err , true ) ; } els ( page info . get trim direct whitespac ( ) . equal ( valu ) ) { err . jsp error ( n , jsp . error . page . conflict . , page info . get trim direct whitespac ( ) , valu ) ; } } } check bad combin ( page info . get buffer ( ) = = 0 page info . auto flush ( ) ) err . jsp error ( n , jsp . error . page . bad combo ) ; attribut import thi node have been process parser , just add them page info . page info . add import ( n . get import ( ) ) ; }
privat skip until el express ( { { ) reach , allow escap sequenc . return text string up el express string skip until el ( ) { char prev = 0 ; string builder buf = new string builder ( ) ; while ( ha next char ( ) ) { char ch = next char ( ) ; ( prev = = ) { prev = 0 ; ( ch = = ) { buf . append ( ) ; prev = ; } els ( ch = = ( defer syntax allow liter ch = = ) ) { buf . append ( ch ) ; } els error } els ( prev = = ( defer syntax allow liter prev = = ) ) { ( ch = = { ) { thi . type = prev ; prev = 0 ; break ; } buf . append ( prev ) ; prev = 0 ; } ( ch = = ch = = ( defer syntax allow liter ch = = ) ) { prev = ch ; } els { buf . append ( ch ) ; } } ( prev = 0 ) { buf . append ( prev ) ; } return buf . string ( ) ; }	privat return next token el express buffer . token next token ( ) { prev token = cur token ; skip space ( ) ; ( ha next char ( ) ) { char ch = next char ( ) ; ( charact . java identifi start ( ch ) ) { string builder buf = new string builder ( ) ; buf . append ( ch ) ; while ( index express . length ( ) charact . java identifi part ( ch = express . char ( index ) ) ) { buf . append ( ch ) ; next char ( ) ; } return new id ( buf . string ( ) ) ; } ( ch = = ch = = ) { return pars quot char ( ch ) ; } els { now . . . return new char ( ch ) ; } } return null ; }	privat pars string singl doubl quot , allow escap sequenc , ( , ) token pars quot char ( char quot ) { string builder buf = new string builder ( ) ; buf . append ( quot ) ; while ( ha next char ( ) ) { char ch = next char ( ) ; ( ch = = ) { ch = next char ( ) ; ( ch = = ch = = quot ) { buf . append ( ch ) ; } els error } els ( ch = = quot ) { buf . append ( ch ) ; break ; } els { buf . append ( ch ) ; } } return new quot string ( buf . string ( ) ) ; }	privat test id reserv word el boolean elreserv ( string id ) { int i = 0 ; int j = reserv word . length ; while ( i j ) { int k = ( i j ) 2 ; int result = reserv word k . compar ( id ) ; ( result = = 0 ) { return true ; } ( result 0 ) { i = k 1 ; } els { j = k ; } } return fals ; }	privat pars function function invok : : = ( identifi : ) identifi ( ( express ( , express ) ) ) note : current we don t pars argument boolean pars function ( ) { ( ( cur token instanceof id ) elreserv ( cur token . string ( ) ) prev token instanceof char prev token . char ( ) = = . ) { return fals ; } function prefix string s1 = null ; function name string s2 = cur token . string ( ) ; ( ha next ( ) ) { int mark = get index ( ) ; cur token = next token ( ) ; ( cur token . char ( ) = = : ) { ( ha next ( ) ) { token t2 = next token ( ) ; ( t2 instanceof id ) { s1 = s2 ; s2 = t2 . string ( ) ; ( ha next ( ) ) { cur token = next token ( ) ; } } } } ( cur token . char ( ) = = ( ) { elexpr . add ( new elnod . function ( s1 , s2 ) ) ; return true ; } cur token = prev token ; set index ( mark ) ; } return fals ; }	privat pars el express string { . . . } . current onli separ el function everyth els . return elnod . node repres el express todo : can thi refactor us standard el implement elnod . node pars el ( ) { string builder buf = new string builder ( ) ; elexpr = new elnod . node ( ) ; while ( ha next ( ) ) { cur token = next token ( ) ; ( cur token instanceof char ) { ( cur token . char ( ) = = } ) { break ; } buf . append ( cur token . char ( ) ) ; } els { output whatev buffer ( buf . length ( ) 0 ) { elexpr . add ( new elnod . eltext ( buf . string ( ) ) ) ; buf = new string builder ( ) ; } ( pars function ( ) ) { elexpr . add ( new elnod . eltext ( cur token . string ( ) ) ) ; } } } ( buf . length ( ) 0 ) { elexpr . add ( new elnod . eltext ( buf . string ( ) ) ) ; } return elexpr ; }	test public void test compound03 ( ) throw jasper except { do test parser ( { foo } { bar } ) ; }
load class specifi name , search us follow algorithm until find return class . class cannot found , return code class found except code . ul li call code find load class ( string ) code check class ha alreadi been load . ha , same code class code object return . li li code deleg code properti set code true code , call code load class ( ) code method parent class loader , ani . li li call code find class ( ) code find thi class our local defin repositori . li li call code load class ( ) code method our parent class loader , ani . li ul class wa found us abov step , code resolv code flag code true code , thi method call code resolv class ( class ) code result class object . param name binari name class load param resolv code true code resolv class except class found except class wa found overrid public synchron class load class ( string name , boolean resolv ) throw class found except { ( log . debug enabl ( ) ) log . debug ( load class ( name , resolv ) ) ; class clazz = null ; log access stop classload ( start ) { try { throw new illeg state except ( ) ; } catch ( illeg state except e ) { log . info ( sm . get string ( webapp class loader . stop , name ) , e ) ; } } ( 0 ) check our previous load local class cach clazz = find load class0 ( name ) ; ( clazz = null ) { ( log . debug enabl ( ) ) log . debug ( return class from cach ) ; ( resolv ) resolv class ( clazz ) ; return ( clazz ) ; } ( 0 . 1 ) check our previous load class cach clazz = find load class ( name ) ; ( clazz = null ) { ( log . debug enabl ( ) ) log . debug ( return class from cach ) ; ( resolv ) resolv class ( clazz ) ; return ( clazz ) ; } ( 0 . 2 ) try load class system class loader , prevent webapp from overrid j2se class string resourc name = binari name path ( name , fals ) ; ( system . get resourc ( resourc name ) = null ) { try { clazz = system . load class ( name ) ; ( clazz = null ) { ( resolv ) resolv class ( clazz ) ; return ( clazz ) ; } } catch ( class found except e ) { ignor } } ( 0 . 5 ) permiss access thi class when us secur manag ( secur manag = null ) { int i = name . last index ( . ) ; ( i = 0 ) { try { secur manag . check packag access ( name . substr ( 0 , i ) ) ; } catch ( secur except se ) { string error = secur violat , attempt us restrict class : name ; log . info ( error , se ) ; throw new class found except ( error , se ) ; } } } boolean deleg load = deleg filter ( name ) ; ( 1 ) deleg our parent request ( deleg load ) { ( log . debug enabl ( ) ) log . debug ( deleg parent classloader1 parent ) ; class loader loader = parent ; ( loader = = null ) loader = system ; try { clazz = class . name ( name , fals , loader ) ; ( clazz = null ) { ( log . debug enabl ( ) ) log . debug ( load class from parent ) ; ( resolv ) resolv class ( clazz ) ; return ( clazz ) ; } } catch ( class found except e ) { ignor } } ( 2 ) search local repositori ( log . debug enabl ( ) ) log . debug ( search local repositori ) ; try { clazz = find class ( name ) ; ( clazz = null ) { ( log . debug enabl ( ) ) log . debug ( load class from local repositori ) ; ( resolv ) resolv class ( clazz ) ; return ( clazz ) ; } } catch ( class found except e ) { ignor } ( 3 ) deleg parent uncondition ( deleg load ) { ( log . debug enabl ( ) ) log . debug ( deleg parent classload end : parent ) ; class loader loader = parent ; ( loader = = null ) loader = system ; try { clazz = class . name ( name , fals , loader ) ; ( clazz = null ) { ( log . debug enabl ( ) ) log . debug ( load class from parent ) ; ( resolv ) resolv class ( clazz ) ; return ( clazz ) ; } } catch ( class found except e ) { ignor } } throw new class found except ( name ) ; }	find resourc given name . resourc some data ( imag , audio , text , etc . ) can access class code wai independ locat code . name resourc separ path name identifi resourc . resourc cannot found , return code null code . p thi method search accord follow algorithm , return soon find appropri url . resourc cannot found , return code null code . ul li code deleg code properti set code true code , call code get resourc ( ) code method parent class loader , ani . li li call code find resourc ( ) code find thi resourc our local defin repositori . li li call code get resourc ( ) code method parent class loader , ani . li ul param name name resourc return url overrid public url get resourc ( string name ) { ( log . debug enabl ( ) ) log . debug ( get resourc ( name ) ) ; url url = null ; ( 1 ) deleg parent request ( deleg ) { ( log . debug enabl ( ) ) log . debug ( deleg parent classload parent ) ; class loader loader = parent ; ( loader = = null ) loader = system ; url = loader . get resourc ( name ) ; ( url = null ) { ( log . debug enabl ( ) ) log . debug ( return url . string ( ) ) ; return ( url ) ; } } ( 2 ) search local repositori url = find resourc ( name ) ; ( url = null ) { ( log . debug enabl ( ) ) log . debug ( return url . string ( ) ) ; return ( url ) ; } ( 3 ) deleg parent uncondition alreadi attempt ( deleg ) { class loader loader = parent ; ( loader = = null ) loader = system ; url = loader . get resourc ( name ) ; ( url = null ) { ( log . debug enabl ( ) ) log . debug ( return url . string ( ) ) ; return ( url ) ; } } ( 4 ) resourc wa found ( log . debug enabl ( ) ) log . debug ( resourc found , return null ) ; return ( null ) ; }	return copi thi class loader without ani class file transform . thi tool often us java persist api provid inspect entiti class absenc ani instrument , someth can t guarante within context { link class file transform } s { link class file transform transform ( class loader , string , class , protect domain , byte ) transform } method . p return class loader s resourc cach have been clear so class alreadi instrument retain return . return transform free copi thi class loader . overrid public webapp class loader copi without transform ( ) { webapp class loader result = new webapp class loader ( thi . parent ) ; result . resourc = thi . resourc ; result . deleg = thi . deleg ; result . start = thi . start ; result . need convert = thi . need convert ; result . clear refer static = thi . clear refer static ; result . clear refer stop thread = thi . clear refer stop thread ; result . clear refer stop timer thread = thi . clear refer stop timer thread ; result . clear refer log factori releas = thi . clear refer log factori releas ; result . clear refer http client keep aliv thread = thi . clear refer http client keep aliv thread ; result . jar modif time . put all ( thi . jar modif time ) ; result . permiss list . add all ( thi . permiss list ) ; result . loader pc . put all ( thi . loader pc ) ; try { result . start ( ) ; } catch ( lifecycl except e ) { throw new illeg state except ( e ) ; } return result ; }	public class loader run ( ) { return clazz . get class loader ( ) ; }	stop class loader . except lifecycl except lifecycl error occur overrid public void stop ( ) throw lifecycl except { clear refer should done befor set start fals , due possibl side effect clear refer ( ) ; start = fals ; resourc entri . clear ( ) ; jar modif time . clear ( ) ; resourc = null ; parent = null ; permiss list . clear ( ) ; loader pc . clear ( ) ; }
public static void do upgrad ( ws server contain sc , http servlet request req , http servlet respons resp , server endpoint config sec , map string , string path param ) throw servlet except , ioexcept { valid rest header reject request valid fail string kei ; string sub protocol = null ; list extens extens = collect . empti list ( ) ; ( header contain token ( req , constant . connect header name , constant . connect header valu ) ) { resp . send error ( http servlet respons . sc bad request ) ; return ; } ( header contain token ( req , constant . ws version header name , constant . ws version header valu ) ) { resp . set statu ( 426 ) ; resp . set header ( constant . ws version header name , constant . ws version header valu ) ; return ; } kei = req . get header ( constant . ws kei header name ) ; ( kei = = null ) { resp . send error ( http servlet respons . sc bad request ) ; return ; } origin check string origin = req . get header ( origin ) ; ( sec . get configur ( ) . check origin ( origin ) ) { resp . send error ( http servlet respons . sc forbidden ) ; return ; } sub protocol list string sub protocol = get token from header ( req , sec web socket protocol ) ; ( sub protocol . empti ( ) ) { sub protocol = sec . get configur ( ) . get negoti subprotocol ( sec . get subprotocol ( ) , sub protocol ) ; } extens current extens ar support thi implement we got thi far , all good . accept connect . resp . set header ( constant . upgrad header name , constant . upgrad header valu ) ; resp . set header ( constant . connect header name , constant . connect header valu ) ; resp . set header ( handshak respons . sec websocket accept , get web socket accept ( kei ) ) ; ( sub protocol = null ) { resp . set header ( sec web socket protocol , sub protocol ) ; } ( extens . empti ( ) ) { string builder sb = new string builder ( ) ; iter extens iter = extens . iter ( ) ; must least sb . append ( iter . next ( ) ) ; while ( iter . ha next ( ) ) { sb . append ( , ) ; sb . append ( iter . next ( ) . get name ( ) ) ; } resp . set header ( sec web socket extens , sb . string ( ) ) ; } endpoint ep ; try { class clazz = sec . get endpoint class ( ) ; ( endpoint . class . assign from ( clazz ) ) { ep = ( endpoint ) sec . get configur ( ) . get endpoint instanc ( clazz ) ; } els { ep = new pojo endpoint server ( ) ; } } catch ( instanti except e ) { throw new servlet except ( e ) ; } ws handshak request ws request = new ws handshak request ( req ) ; ws handshak respons ws respons = new ws handshak respons ( ) ; ws per session server endpoint config per session server endpoint config = new ws per session server endpoint config ( sec ) ; sec . get configur ( ) . modifi handshak ( per session server endpoint config , ws request , ws respons ) ; ws request . finish ( ) ; add ani addit header ( entri string , list string >> entri : ws respons . get header ( ) . entri set ( ) ) { ( string header valu : entri . get valu ( ) ) { resp . add header ( entri . get kei ( ) , header valu ) ; } } ws http upgrad handler ws handler = req . upgrad ( ws http upgrad handler . class ) ; ws handler . pre init ( ep , per session server endpoint config , sc , ws request , sub protocol , path param , req . secur ( ) ) ; }
public void initi ( servlet servlet , servlet request request , servlet respons respons , string error page url , boolean need session , int buffer size , boolean auto flush ) throw ioexcept { initi state thi . servlet = servlet ; thi . config = servlet . get servlet config ( ) ; thi . context = config . get servlet context ( ) ; thi . error page url = error page url ; thi . request = request ; thi . respons = respons ; initi applic context thi . applic context = jsp applic context impl . get instanc ( context ) ; setup session ( requir ) ( request instanceof http servlet request need session ) thi . session = ( ( http servlet request ) request ) . get session ( ) ; ( need session session = = null ) throw new illeg state except ( page need session none avail ) ; initi initi out . . . depth = 1 ; ( thi . base out = = null ) { thi . base out = new jsp writer impl ( respons , buffer size , auto flush ) ; } els { thi . base out . init ( respons , buffer size , auto flush ) ; } thi . out = base out ; regist name valu per spec set attribut ( out , thi . out ) ; set attribut ( request , request ) ; set attribut ( respons , respons ) ; ( session = null ) set attribut ( session , session ) ; set attribut ( page , servlet ) ; set attribut ( config , config ) ; set attribut ( pagecontext , thi ) ; set attribut ( applic , context ) ; includ = request . get attribut ( request dispatch . includ servlet path ) = null ; }	public void test do forward ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; file app dir = new file ( test webapp ) ; tomcat . add webapp ( null , test , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; byte chunk re = new byte chunk ( ) ; int rc = get url ( http : localhost : get port ( ) test bug5nnnn bug53545 . jsp , re , null ) ; assert . assert equal ( http servlet respons . sc ok , rc ) ; string bodi = re . string ( ) ; assert . assert true ( bodi . contain ( ok ) ) ; assert . assert fals ( bodi . contain ( fail ) ) ; }
public boolean get block statu ( ) { return block statu ; }
privat long get last modifi ( tld resourc path tld resourc path ) { long result = new long 2 ; result 0 = 1 ; result 1 = 1 ; try { url url = servlet context . get resourc ( tld resourc path . get webapp path ( ) ) ; urlconnect conn = url . open connect ( ) ; result 0 = conn . get last modifi ( ) ; ( file . equal ( url . get protocol ( ) ) ) { read last modifi time open input stream so we need make sure close again otherwis tld file lock until gc run . conn . get input stream ( ) . close ( ) ; } jar jar = tld resourc path . get jar ( ) ; ( jar = null ) { result 1 = jar . get last modifi ( tld resourc path . get entri name ( ) ) ; } } catch ( ioexcept e ) { ignor ( shouldn t happen ) } return result ; }
privat synchron close current open log file ( ani ) param renam renam file final name after close void close ( boolean renam ) { ( writer = = null ) { return ; } writer . flush ( ) ; writer . close ( ) ; ( renam renam rotat ) { file new log file = get log file ( true ) ; ( new log file . exist ( ) ) { try { ( current log file . renam ( new log file ) ) { log . error ( sm . get string ( access log valv . renam fail , current log file , new log file ) ) ; } } catch ( throwabl e ) { except util . handl throwabl ( e ) ; log . error ( sm . get string ( access log valv . renam fail , current log file , new log file ) , e ) ; } } els { log . error ( sm . get string ( access log valv . alreadi exist , current log file , new log file ) ) ; } } writer = null ; date stamp = ; current log file = null ; }	protect date format cach initi valu ( ) { return new date format cach ( local cach size , local . get default ( ) , global date cach ) ; }	protect synchron open new log file date specifi code date stamp code . void open ( ) { open current log file rotat need date stamp file name file pathnam = get log file ( rotat renam rotat ) ; charset charset = null ; ( encod = null ) { try { charset = b2cconvert . get charset ( encod ) ; } catch ( unsupport encod except ex ) { log . error ( sm . get string ( access log valv . unsupport encod , encod ) , ex ) ; } } ( charset = = null ) { charset = standard charset . iso 8859 1 ; } try { writer = new print writer ( new buffer writer ( new output stream writer ( new file output stream ( pathnam , true ) , charset ) , 128000 ) , fals ) ; current log file = pathnam ; } catch ( ioexcept e ) { writer = null ; current log file = null ; log . error ( sm . get string ( access log valv . open fail , pathnam ) , e ) ; } }	start thi compon implement requir { link org . apach . catalina . util . lifecycl base start intern ( ) } . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect synchron void start intern ( ) throw lifecycl except { initi date formatt string format = get file date format ( ) ; file date formatt = new simpl date format ( format , local . us ) ; file date formatt . set time zone ( time zone . get default ( ) ) ; date stamp = file date formatt . format ( new date ( system . current time milli ( ) ) ) ; ( rotat renam rotat ) { restor ( ) ; } open ( ) ; set state ( lifecycl state . start ) ; }	stop thi compon implement requir { link org . apach . catalina . util . lifecycl base stop intern ( ) } . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect synchron void stop intern ( ) throw lifecycl except { set state ( lifecycl state . stop ) ; close ( fals ) ; }	execut period task , reload , etc . thi method invok insid classload context thi contain . unexpect throwabl caught log . overrid public synchron void background process ( ) { ( get state ( ) . avail ( ) get enabl ( ) writer = null buffer ) { writer . flush ( ) ; } }	public set directori which we creat log file . param directori new log file directori void set directori ( string directori ) { thi . directori = directori ; }	public set date format date base log rotat . void set file date format ( string file date format ) { string new format ; ( file date format = = null ) { new format = ; } els { new format = file date format ; } thi . file date format = new format ; synchron ( thi ) { file date formatt = new simpl date format ( new format , local . us ) ; file date formatt . set time zone ( time zone . get default ( ) ) ; } }	public set log file suffix . param suffix new log file suffix void set suffix ( string suffix ) { thi . suffix = suffix ; }
privat int do write intern ( byte b , int off , int len ) throw ioexcept { int start = off ; int left = len ; int written ; do { ( endpoint . sslenabl ( ) ) { ( ssl output buffer . remain ( ) = = 0 ) { buffer wa fulli written last time around ssl output buffer . clear ( ) ; ( left ssl output buffer size ) { ssl output buffer . put ( b , start , left ) ; } els { ssl output buffer . put ( b , start , ssl output buffer size ) ; } ssl output buffer . flip ( ) ; } els { buffer still ha data from previou attempt write apr ssl requir exactli same paramet ar pass when re attempt write } written = socket . sendb ( socket , ssl output buffer , ssl output buffer . posit ( ) , ssl output buffer . limit ( ) ) ; ( written 0 ) { ssl output buffer . posit ( ssl output buffer . posit ( ) written ) ; } } els { written = socket . send ( socket , b , start , left ) ; } ( statu . apr statu eagain ( written ) ) { written = 0 ; } els ( written = = statu . apr eof ) { throw new eofexcept ( sm . get string ( apr . client abort ) ) ; } els ( ( os . win32 os . win64 ) ( written = = statu . apr os start syserr 10053 ) ) { 10053 window connect abort throw new eofexcept ( sm . get string ( apr . client abort ) ) ; } els ( written 0 ) { throw new ioexcept ( sm . get string ( apr . write . error , integ . valu ( written ) , long . valu ( socket ) , wrapper ) ) ; } start = written ; left = written ; } while ( written 0 left 0 ) ; ( left 0 ) { endpoint . get poller ( ) . add ( socket , 1 , fals , true ) ; } return len left ; }	privat void do test check close ( class extend http upgrad handler upgrad handler class ) throw except { upgrad connect conn = do upgrad ( upgrad handler class ) ; reader r = conn . get reader ( ) ; int c = r . read ( ) ; assert . assert equal ( 1 , c ) ; }	protect final boolean close requir ( ) { return close requir ; }	protect final void write possibl ( ) throw ioexcept { synchron ( write lock ) { try { write intern ( buffer , 0 , buffer . length ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; thread thread = thread . current thread ( ) ; class loader origin class loader = thread . get context class loader ( ) ; try { thread . set context class loader ( applic loader ) ; listen . error ( t ) ; } final { thread . set context class loader ( origin class loader ) ; } ( t instanceof ioexcept ) { throw t ; } els { throw new ioexcept ( t ) ; } } make sure readi ( ) write possibl ( ) have consist view buffer fire listen when determin listen should fire boolean fire = fals ; synchron ( fire listen lock ) { ( buffer = = null fire listen ) { fire listen = fals ; fire = true ; } } ( fire ) { thread thread = thread . current thread ( ) ; class loader origin class loader = thread . get context class loader ( ) ; try { thread . set context class loader ( applic loader ) ; listen . write possibl ( ) ; } final { thread . set context class loader ( origin class loader ) ; } } } }	overrid protect int do write ( boolean block , byte b , int off , int len ) throw ioexcept { ( close ) { throw new ioexcept ( sm . get string ( apr . close , long . valu ( socket ) ) ) ; } lock read lock = wrapper . get block statu read lock ( ) ; write lock write lock = wrapper . get block statu write lock ( ) ; try { read lock . lock ( ) ; ( wrapper . get block statu ( ) = = block ) { return do write intern ( b , off , len ) ; } } final { read lock . unlock ( ) ; } try { write lock . lock ( ) ; set current set thi socket wrapper . set block statu ( block ) ; ( block ) { socket . timeout set ( socket , endpoint . get so timeout ( ) 1000 ) ; } els { socket . timeout set ( socket , 0 ) ; } downgrad lock try { read lock . lock ( ) ; write lock . unlock ( ) ; return do write intern ( b , off , len ) ; } final { read lock . unlock ( ) ; } } final { except path ( write lock . held current thread ( ) ) { write lock . unlock ( ) ; } } }	public socket state process ( socket wrapper s wrapper , socket statu statu ) { ( wrapper = = null ) { noth do . socket ha been close . return socket state . close ; } s socket = wrapper . get socket ( ) ; ( socket = = null ) { noth do . socket ha been close . return socket state . close ; } processor s processor = connect . get ( socket ) ; ( statu = = socket statu . disconnect processor = = null ) { longer processor associ thi socket . return socket state . close ; } wrapper . set async ( fals ) ; try { ( processor = = null ) { processor = recycl processor . pop ( ) ; } ( processor = = null ) { processor = creat processor ( ) ; } init ssl ( wrapper , processor ) ; socket state state = socket state . close ; iter dispatch type dispatch = null ; do { ( dispatch = null ) { associ processor connect call mai result nest call process ( ) connect . put ( socket , processor ) ; dispatch type next dispatch = dispatch . next ( ) ; state = processor . async dispatch ( next dispatch . get socket statu ( ) ) ; } els ( statu = = socket statu . disconnect processor . comet ( ) ) { do noth here , just wait get recycl don t do thi comet we need gener end event ( see bz 54022 ) } els ( processor . async ( ) state = = socket state . async end ) { state = processor . async dispatch ( statu ) ; } els ( processor . comet ( ) ) { state = processor . event ( statu ) ; } els ( processor . upgrad ( ) ) { state = processor . upgrad dispatch ( statu ) ; } els { state = processor . process ( wrapper ) ; } ( state = socket state . close processor . async ( ) ) { state = processor . async post process ( ) ; } ( state = = socket state . upgrad ) { get http upgrad handler http upgrad handler http upgrad handler = processor . get http upgrad handler ( ) ; releas http11 processor re us releas ( wrapper , processor , fals , fals ) ; creat upgrad processor processor = creat upgrad processor ( wrapper , http upgrad handler ) ; mark connect upgrad wrapper . set upgrad ( true ) ; associ processor connect connect . put ( socket , processor ) ; initialis upgrad handler ( which mai trigger some io us new protocol which why line abov ar necessari ) thi cast should safe . fail error handl surround try catch deal . http upgrad handler . init ( ( web connect ) processor ) ; } ( get log ( ) . debug enabl ( ) ) { get log ( ) . debug ( socket : wrapper , statu : statu , state out : state ) ; } ( dispatch = = null dispatch . ha next ( ) ) { onli return non null iter ar dispatch process . dispatch = wrapper . get iter clear dispatch ( ) ; } } while ( state = = socket state . async end state = = socket state . upgrad dispatch = null state = socket state . close ) ; ( state = = socket state . long ) { middl process request respons . keep socket associ processor . exact requir depend type long poll connect . put ( socket , processor ) ; long poll ( wrapper , processor ) ; } els ( state = = socket state . open ) { keep aliv between request . ok recycl processor . continu poll next request . connect . remov ( socket ) ; releas ( wrapper , processor , fals , true ) ; } els ( state = = socket state . sendfil ) { sendfil progress . fail , socket close . work , socket re ad poller connect . remov ( socket ) ; releas ( wrapper , processor , fals , fals ) ; } els ( state = = socket state . upgrad ) { poller necessari . ( statu = socket statu . open write ) { long poll ( wrapper , processor ) ; } } els { connect close . ok recycl processor . upgrad processor ar recycl . connect . remov ( socket ) ; ( processor . upgrad ( ) ) { processor . get http upgrad handler ( ) . destroi ( ) ; } els { releas ( wrapper , processor , true , fals ) ; } } return state ; } catch ( java . net . socket except e ) { socket except ar normal get log ( ) . debug ( sm . get string ( abstract connect handler . socketexcept . debug ) , e ) ; } catch ( java . io . ioexcept e ) { ioexcept ar normal get log ( ) . debug ( sm . get string ( abstract connect handler . ioexcept . debug ) , e ) ; } abov . catch ( throwabl e ) { except util . handl throwabl ( e ) ; ani other except error odd . here we log error level , so show up even less than verbos log . get log ( ) . error ( sm . get string ( abstract connect handler . error ) , e ) ; } make sure socket processor remov from list current connect connect . remov ( socket ) ; don t try add upgrad processor back pool ( processor = null processor . upgrad ( ) ) { releas ( wrapper , processor , true , fals ) ; } return socket state . close ; }	public final boolean readi ( ) { ( listen = = null ) { throw new illeg state except ( sm . get string ( upgrad . so . can write . ) ) ; } buffer fire listen when determin listen should fire synchron ( fire listen lock ) { boolean result = ( buffer = = null ) ; fire listen = result ; return result ; } }	overrid public final void set write listen ( write listen listen ) { ( listen = = null ) { throw new illeg argument except ( sm . get string ( upgrad . so . write listen . null ) ) ; } ( thi . listen = null ) { throw new illeg argument except ( sm . get string ( upgrad . so . write listen . set ) ) ; } thi . listen = listen ; thi . applic loader = thread . current thread ( ) . get context class loader ( ) ; }	overrid public void close ( ) throw ioexcept { close requir = true ; do close ( ) ; }	overrid public void destroi ( ) { op }	overrid public void error ( throwabl throwabl ) { op }	test public void test set write listen twice ( ) throw except { do test check close ( set write listen twice . class ) ; }
overrid protect boolean break keep aliv loop ( socket wrapper nio channel socket wrapper ) { do sendfil need : add socket sendfil end ( sendfil data = null error ) { ( ( kei attach ) socket wrapper ) . set sendfil data ( sendfil data ) ; sendfil data . keep aliv = keep aliv ; select kei kei = socket wrapper . get socket ( ) . get iochannel ( ) . kei ( socket wrapper . get socket ( ) . get poller ( ) . get selector ( ) ) ; do first write thi thread , might well open socket = socket wrapper . get socket ( ) . get poller ( ) . process sendfil ( kei , ( kei attach ) socket wrapper , true ) ; return true ; } return fals ; }
public set saxpars except get warn ( ) { intern us onli don t worri about immut return warn ; }
public have more class resourc been modifi so reload appropri boolean modifi ( ) { ( log . debug enabl ( ) ) log . debug ( modifi ( ) ) ; ( entri string , resourc entri entri : resourc entri . entri set ( ) ) { long cach last modifi = entri . get valu ( ) . last modifi ; long last modifi = resourc . get class loader resourc ( entri . get kei ( ) ) . get last modifi ( ) ; ( last modifi = cach last modifi ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( webapp class loader . resourc modifi , entri . get kei ( ) , new date ( cach last modifi ) , new date ( last modifi ) ) ) ; return true ; } } check jar have been ad remov web resourc jar = resourc . list resourc ( web inf lib ) ; ( jar . length jar modif time . size ( ) ) { log . info ( sm . get string ( webapp class loader . jar ad , resourc . get context ( ) . get name ( ) ) ) ; return true ; } els ( jar . length jar modif time . size ( ) ) { log . info ( sm . get string ( webapp class loader . jar remov , resourc . get context ( ) . get name ( ) ) ) ; return true ; } ( web resourc jar : jar ) { ( jar . get name ( ) . end ( . jar ) jar . file ( ) jar . can read ( ) ) { long record last modifi = jar modif time . get ( jar . get name ( ) ) ; ( record last modifi = = null ) { jar have been ad remov log . info ( sm . get string ( webapp class loader . jar ad , resourc . get context ( ) . get name ( ) ) ) ; return true ; } ( record last modifi . long valu ( ) = jar . get last modifi ( ) ) { jar ha been chang log . info ( sm . get string ( webapp class loader . jar modifi , resourc . get context ( ) . get name ( ) ) ) ; return true ; } jar modif time . put ( jar . get name ( ) , long . valu ( jar . get last modifi ( ) ) ) ; } } class have been modifi return fals ; }
privat void set up login ( tomcat tomcat ) throw except { must have real doc base webapp just us temp context ctxt = tomcat . add context ( context path login , system . get properti ( java . io . tmpdir ) ) ; ctxt . set session timeout ( short timeout sec ) ; add protect servlet tomcat . add servlet ( ctxt , tester servlet3 , new tester servlet ( ) ) ; ctxt . add servlet map ( uri protect , tester servlet3 ) ; secur collect collect = new secur collect ( ) ; collect . add pattern ( uri protect ) ; secur constraint sc = new secur constraint ( ) ; sc . add auth role ( role ) ; sc . add collect ( collect ) ; ctxt . add constraint ( sc ) ; configur appropri authent login config lc = new login config ( ) ; lc . set auth method ( basic ) ; ctxt . set login config ( lc ) ; ctxt . get pipelin ( ) . add valv ( new basic authent ( ) ) ; }	privat void set up non login ( tomcat tomcat ) throw except { must have real doc base webapp just us temp context ctxt = tomcat . add context ( context path nologin , system . get properti ( java . io . tmpdir ) ) ; ctxt . set session timeout ( long timeout sec ) ; add protect servlet tomcat . add servlet ( ctxt , tester servlet1 , new tester servlet ( ) ) ; ctxt . add servlet map ( uri protect , tester servlet1 ) ; secur collect collection1 = new secur collect ( ) ; collection1 . add pattern ( uri protect ) ; secur constraint sc1 = new secur constraint ( ) ; sc1 . add auth role ( role ) ; sc1 . add collect ( collection1 ) ; ctxt . add constraint ( sc1 ) ; add unprotect servlet tomcat . add servlet ( ctxt , tester servlet2 , new tester servlet ( ) ) ; ctxt . add servlet map ( uri public , tester servlet2 ) ; secur collect collection2 = new secur collect ( ) ; collection2 . add pattern ( uri public ) ; secur constraint sc2 = new secur constraint ( ) ; do add role which signal access permit without sc2 . add collect ( collection2 ) ; ctxt . add constraint ( sc2 ) ; configur authent inherit realm from engin login config lc = new login config ( ) ; lc . set auth method ( none ) ; ctxt . set login config ( lc ) ; ctxt . get pipelin ( ) . add valv ( new non login authent ( ) ) ; }	protect add all save cooki outgo request void add cooki ( map string , list string >> req header ) { ( ( cooki = null ) ( cooki . size ( ) 0 ) ) { req header . put ( browser cooki : , cooki ) ; } }	protect extract save server cooki from incom respons void save cooki ( map string , list string >> resp header ) { we onli save cooki valu , header prefix cooki = resp header . get ( server cooki ) ; }	public void do test basic ( string user , string pwd , string uri , boolean expect reject1 , int expect rc1 , boolean expect reject2 , int expect rc2 ) throw except { first access attempt should challeng map string , list string >> req headers1 = new hash map ( ) ; map string , list string >> resp headers1 = new hash map ( ) ; byte chunk bc = new byte chunk ( ) ; int rc = get url ( http prefix get port ( ) uri , bc , req headers1 , resp headers1 ) ; ( expect reject1 ) { assert equal ( expect rc1 , rc ) ; assert true ( bc . get length ( ) 0 ) ; } els { assert equal ( 200 , rc ) ; assert equal ( ok , bc . string ( ) ) ; return ; } second access attempt should success string credenti = user : pwd ; string base64auth = base64 . encod base64str ( credenti . get byte ( standard charset . iso 8859 1 ) ) ; string auth line = basic base64auth ; list string auth = new arrai list ( ) ; auth . add ( auth line ) ; map string , list string >> req headers2 = new hash map ( ) ; req headers2 . put ( client auth header , auth ) ; map string , list string >> resp headers2 = new hash map ( ) ; bc . recycl ( ) ; rc = get url ( http prefix get port ( ) uri , bc , req headers2 , resp headers2 ) ; ( expect reject2 ) { assert equal ( expect rc2 , rc ) ; assert null ( bc . string ( ) ) ; } els { assert equal ( 200 , rc ) ; assert equal ( ok , bc . string ( ) ) ; save cooki ( resp headers2 ) ; } }	public void do test non login ( string uri , boolean add cooki , boolean expect reject , int expect rc ) throw except { map string , list string >> req header = new hash map ( ) ; ( add cooki ) { add cooki ( req header ) ; } map string , list string >> resp header = new hash map ( ) ; byte chunk bc = new byte chunk ( ) ; int rc = get url ( http prefix get port ( ) uri , bc , req header , resp header ) ; ( expect reject ) { assert equal ( expect rc , rc ) ; assert true ( bc . get length ( ) 0 ) ; } els { assert equal ( 200 , rc ) ; assert equal ( ok , bc . string ( ) ) ; save cooki ( resp header ) ; } }	overrid public void set up ( ) throw except { super . set up ( ) ; creat tomcat server us default memori realm tomcat tomcat = get tomcat instanc ( ) ; associ sing sign valv befor context singl sign sso = new singl sign ( ) ; tomcat . get host ( ) . get pipelin ( ) . add valv ( sso ) ; add test user role realm tomcat . add user ( user , pwd ) ; tomcat . add role ( user , role ) ; setup both non login login webapp set up non login ( tomcat ) ; set up login ( tomcat ) ; tomcat . start ( ) ; }	public void test accept public non login ( ) throw except { do test non login ( context path nologin uri public , fals , fals , 200 ) ; }	logon access protect resourc us basic authent , which establish sso session . immedi try access protect resourc non login webapp while send sso session cooki provid first webapp . thi should success sc ok 200 statu . , wait long enough basic session expir . ( sso session should remain activ becaus non login session ha yet expir ) . try access protect resourc again , befor sso session ha expir . thi should success sc ok 200 statu . final , wait non login session expir try again . . thi should reject sc forbidden 403 statu . ( see bugfix http : issu . apach . org bugzilla show bug . cgi id = 52303 ) test public void test basic expir accept protect cooki ( ) throw except { do test basic ( user , pwd , context path login uri protect , true , 401 , fals , 200 ) ; do test non login ( context path nologin uri protect , true , fals , 200 ) ; wait long enough basic session expir , long enough non login session expiri thread . sleep ( short timeout delai msec ) ; do test non login ( context path nologin uri protect , true , fals , 200 ) ; wait long enough my non login session expir tear down sso session same time . thread . sleep ( long timeout delai msec ) ; do test non login ( context path nologin uri protect , fals , true , 403 ) ; }	logon access protect resourc us basic authent , which establish sso session . immedi try access protect resourc non login webapp while send sso session cooki provid first webapp . thi should success sc ok 200 statu . test public void test basic login accept protect cooki ( ) throw except { do test basic ( user , pwd , context path login uri protect , true , 401 , fals , 200 ) ; do test non login ( context path nologin uri protect , true , fals , 200 ) ; }	logon access protect resourc us basic authent , which establish sso session . immedi try access protect resourc non login webapp , without send sso session cooki . thi should reject sc forbidden 403 statu . test public void test basic login reject protect without cooki ( ) throw except { do test basic ( user , pwd , context path login uri protect , true , 401 , fals , 200 ) ; do test non login ( context path nologin uri protect , fals , true , 403 ) ; }	logon access protect resourc us basic authent , which establish sso session . wait until sso session time out , try re access resourc . thi should reject sc forbidden 401 statu , which follow success re authent . test public void test basic login session timeout ( ) throw except { do test basic ( user , pwd , context path login uri protect , true , 401 , fals , 200 ) ; wait long enough my session expir thread . sleep ( short timeout delai msec ) ; do test basic ( user , pwd , context path login uri protect , true , 401 , fals , 200 ) ; }	try access protect resourc without establish sso session . thi should reject sc forbidden 403 statu . test public void test reject protect non login ( ) throw except { do test non login ( context path nologin uri protect , fals , true , 403 ) ; }
privat void do test constructor string ( context name src ) { do compar ( src , new context name ( src . get base name ( ) ) ) ; do compar ( src , new context name ( src . get displai name ( ) ) ) ; do compar ( src , new context name ( src . get name ( ) ) ) ; }	protect string upload ( http servlet request request , string manag sm client ) throw ioexcept , servlet except { string messag = ; part war part = null ; string filenam = null ; collect part part = request . get part ( ) ; iter part iter = part . iter ( ) ; try { while ( iter . ha next ( ) ) { part part = iter . next ( ) ; ( part . get name ( ) . equal ( deploi war ) war part = = null ) { war part = part ; } els { part . delet ( ) ; } } while ( true ) { ( war part = = null ) { messag = sm client . get string ( html manag servlet . deploi upload file ) ; break ; } filenam = war part . get submit file name ( ) ; ( filenam . lower case ( local . english ) . end ( . war ) ) { messag = sm client . get string ( html manag servlet . deploi upload war , filenam ) ; break ; } get filenam upload name includ path ( filenam . last index ( ) = 0 ) { filenam = filenam . substr ( filenam . last index ( ) 1 ) ; } ( filenam . last index ( ) = 0 ) { filenam = filenam . substr ( filenam . last index ( ) 1 ) ; } identifi app base own host thi context ( ani ) file file = new file ( host . get app base file ( ) , filenam ) ; ( file . exist ( ) ) { messag = sm client . get string ( html manag servlet . deploi upload war exist , filenam ) ; break ; } context name cn = new context name ( filenam ) ; string name = cn . get name ( ) ; ( ( host . find child ( name ) = null ) deploi ( name ) ) { messag = sm client . get string ( html manag servlet . deploi upload server xml , filenam ) ; break ; } ( servic ( name ) ) { add servic ( name ) ; try { war part . write ( file . get absolut path ( ) ) ; perform new deploy check ( name ) ; } final { remov servic ( name ) ; } } break ; } } catch ( except e ) { messag = sm client . get string ( html manag servlet . deploi upload fail , e . get messag ( ) ) ; log ( messag , e ) ; } final { ( war part = null ) { war part . delet ( ) ; } war part = null ; } return messag ; }	protect deploi applic ani directori war file ar found our applic root directori . void deploi app ( string name ) { file app base = host . get app base file ( ) ; file config base = host . get config base file ( ) ; context name cn = new context name ( name ) ; string base name = cn . get base name ( ) ; ( deploy exist ( base name ) ) { return ; } deploi xml descriptor from config base file xml = new file ( config base , base name . xml ) ; ( xml . exist ( ) ) { deploi descriptor ( cn , xml ) ; return ; } deploi war file war = new file ( app base , base name . war ) ; ( war . exist ( ) ) { deploi war ( cn , war ) ; return ; } deploi expand folder file dir = new file ( app base , base name ) ; ( dir . exist ( ) ) deploi directori ( cn , dir ) ; }	protect deploi xml context descriptor . void deploi descriptor ( file config base , string file ) { ( file = = null ) return ; executor servic es = host . get start stop executor ( ) ; list futur >> result = new arrai list ( ) ; ( int i = 0 ; i file . length ; i ) { file context xml = new file ( config base , file i ) ; ( file i . lower case ( local . english ) . end ( . xml ) ) { context name cn = new context name ( file i ) ; ( servic ( cn . get name ( ) ) deploy exist ( cn . get name ( ) ) ) continu ; result . add ( es . submit ( new deploi descriptor ( thi , cn , context xml ) ) ) ; } } ( futur result : result ) { try { result . get ( ) ; } catch ( except e ) { log . error ( sm . get string ( host config . deploi descriptor . thread . error ) , e ) ; } } }	protect deploi directori . void deploi directori ( file app base , string file ) { ( file = = null ) return ; executor servic es = host . get start stop executor ( ) ; list futur >> result = new arrai list ( ) ; ( int i = 0 ; i file . length ; i ) { ( file i . equal ignor case ( meta inf ) ) continu ; ( file i . equal ignor case ( web inf ) ) continu ; file dir = new file ( app base , file i ) ; ( dir . directori ( ) ) { context name cn = new context name ( file i ) ; ( servic ( cn . get name ( ) ) deploy exist ( cn . get name ( ) ) ) continu ; result . add ( es . submit ( new deploi directori ( thi , cn , dir ) ) ) ; } } ( futur result : result ) { try { result . get ( ) ; } catch ( except e ) { log . error ( sm . get string ( host config . deploi dir . thread . error ) , e ) ; } } }	protect deploi war file . void deploi war ( file app base , string file ) { ( file = = null ) return ; executor servic es = host . get start stop executor ( ) ; list futur >> result = new arrai list ( ) ; ( int i = 0 ; i file . length ; i ) { ( file i . equal ignor case ( meta inf ) ) continu ; ( file i . equal ignor case ( web inf ) ) continu ; file war = new file ( app base , file i ) ; ( file i . lower case ( local . english ) . end ( . war ) war . file ( ) invalid war . contain ( file i ) ) { context name cn = new context name ( file i ) ; ( servic ( cn . get name ( ) ) ) { continu ; } ( deploy exist ( cn . get name ( ) ) ) { deploi applic app = deploi . get ( cn . get name ( ) ) ; ( unpack war app = null ) { need check directori should file dir = new file ( app base , cn . get base name ( ) ) ; ( dir . exist ( ) ) { ( app . log dir warn ) { log . warn ( sm . get string ( host config . deploi war . hidden dir , dir . get absolut file ( ) , war . get absolut file ( ) ) ) ; app . log dir warn = true ; } } els { app . log dir warn = fals ; } } continu ; } check war . . . similar sequenc name ( valid context path ( app base , cn . get base name ( ) ) ) { log . error ( sm . get string ( host config . illeg war name , file i ) ) ; invalid war . add ( file i ) ; continu ; } result . add ( es . submit ( new deploi war ( thi , cn , war ) ) ) ; } } ( futur result : result ) { try { result . get ( ) ; } catch ( except e ) { log . error ( sm . get string ( host config . deploi war . thread . error ) , e ) ; } } }	public object name get children ( ) { object name result = new object name children . size ( ) ; iter contain = children . valu ( ) . iter ( ) ; int i = 0 ; while ( . ha next ( ) ) { object next = . next ( ) ; ( next instanceof contain base ) { result i = ( ( contain base ) next ) . get object name ( ) ; } } return result ; }	overrid public string get mbean kei properti ( ) { contain c = thi ; string builder kei properti = new string builder ( ) ; int contain count = 0 ; each contain while ( ( c instanceof engin ) ) { ( c instanceof context ) { kei properti . append ( , context = ) ; context name cn = new context name ( c . get name ( ) ) ; kei properti . append ( cn . get displai name ( ) ) ; } els ( c instanceof host ) { kei properti . append ( , host = ) ; kei properti . append ( c . get name ( ) ) ; } els ( c = = null ) { mai happen unit test some embed scenario kei properti . append ( , contain ) ; kei properti . append ( contain count ) ; kei properti . append ( = null ) ; break ; } els { should never happen . . . kei properti . append ( , contain ) ; kei properti . append ( contain count ) ; kei properti . append ( = ) ; kei properti . append ( c . get name ( ) ) ; } c = c . get parent ( ) ; } return kei properti . string ( ) ; }	public static creat code object name code thi code context resourc link code object . param domain domain which thi name creat param resourc link context resourc link name except malform object name except name cannot creat object name creat object name ( string domain , context resourc link resourc link ) throw malform object name except { object name name = null ; string quot resourc link name = object name . quot ( resourc link . get name ( ) ) ; object contain = resourc link . get name resourc ( ) . get contain ( ) ; ( contain instanceof server ) { name = new object name ( domain : type = resourc link , resourcetyp = global , name = quot resourc link name ) ; } els ( contain instanceof context ) { context context = ( ( context ) contain ) ; context name cn = new context name ( context . get name ( ) ) ; contain host = context . get parent ( ) ; name = new object name ( domain : type = resourc link , resourcetyp = context , host = host . get name ( ) , context = cn . get displai name ( ) , name = quot resourc link name ) ; } return ( name ) ; }	public synchron check old version applic us parallel deploy ar now unus ( have activ session ) undeploi ani ar found . void check undeploi ( ) { need order set name sort set string sort app name = new tree set ( ) ; sort app name . add all ( deploi . kei set ( ) ) ; ( sort app name . size ( ) 2 ) { return ; } iter string iter = sort app name . iter ( ) ; context name previou = new context name ( iter . next ( ) ) ; do { context name current = new context name ( iter . next ( ) ) ; ( current . get path ( ) . equal ( previou . get path ( ) ) ) { current previou ar same path current alwai later version context previou context = ( context ) host . find child ( previou . get name ( ) ) ; context current context = ( context ) host . find child ( previou . get name ( ) ) ; ( previou context = null current context = null current context . get state ( ) . avail ( ) servic ( previou . get name ( ) ) ) { manag manag = previou context . get manag ( ) ; ( manag = null ) { int session count ; ( manag instanceof distribut manag ) { session count = ( ( distribut manag ) manag ) . get activ session full ( ) ; } els { session count = manag . get activ session ( ) ; } ( session count = = 0 ) { ( log . info enabl ( ) ) { log . info ( sm . get string ( host config . undeploi version , previou . get name ( ) ) ) ; } deploi applic app = deploi . get ( previou . get name ( ) ) ; string resourc = app . redeploi resourc . kei set ( ) . arrai ( new string 0 ) ; version unus undeploi complet 1 trick ensur all redeploi resourc ar remov undeploi ( app ) ; delet redeploi resourc ( app , resourc , 1 , true ) ; } } } } previou = current ; } while ( iter . ha next ( ) ) ; }	modif from watch dir war detect see org . apach . catalina . ha . deploi . file chang listen file modifi ( file ) overrid public void file modifi ( file new war ) { try { file deploi war = new file ( get deploi dir file ( ) , new war . get name ( ) ) ; context name cn = new context name ( deploi war . get name ( ) ) ; ( deploi war . exist ( ) deploi war . last modifi ( ) new war . last modifi ( ) ) { ( log . info enabl ( ) ) log . info ( sm . get string ( farm war deploy . alreadi deploi , cn . get name ( ) ) ) ; return ; } ( log . info enabl ( ) ) log . info ( sm . get string ( farm war deploy . mod instal , cn . get name ( ) , deploi war . get absolut path ( ) ) ) ; instal local ( servic ( cn . get name ( ) ) ) { add servic ( cn . get name ( ) ) ; try { copi ( new war , deploi war ) ; check ( cn . get name ( ) ) ; } final { remov servic ( cn . get name ( ) ) ; } } els { log . error ( sm . get string ( farm war deploy . servic deploi , cn . get name ( ) , deploi war . get name ( ) ) ) ; } instal ( cn . get name ( ) , deploi war ) ; } catch ( except x ) { log . error ( sm . get string ( farm war deploy . mod instal fail ) , x ) ; } }	war remov from watch dir see org . apach . catalina . ha . deploi . file chang listen file remov ( file ) overrid public void file remov ( file remov war ) { try { context name cn = new context name ( remov war . get name ( ) ) ; ( log . info enabl ( ) ) log . info ( sm . get string ( farm war deploy . remov local , cn . get name ( ) ) ) ; remov ( cn . get name ( ) , true ) ; } catch ( except x ) { log . error ( sm . get string ( farm war deploy . remov local fail ) , x ) ; } }	public void set up ( ) throw except { cn1 = new context name ( null , null ) ; cn2 = new context name ( , null ) ; cn3 = new context name ( , null ) ; cn4 = new context name ( foo , null ) ; cn5 = new context name ( foo bar , null ) ; cn6 = new context name ( null , ) ; cn7 = new context name ( , b ) ; cn8 = new context name ( , c ) ; cn9 = new context name ( foo , d ) ; cn10 = new context name ( foo bar , e ) ; cn11 = new context name ( root ) ; cn12 = new context name ( foo ) ; cn13 = new context name ( foo bar ) ; cn14 = new context name ( root ) ; cn15 = new context name ( foo d ) ; cn16 = new context name ( foo bar e ) ; cn17 = new context name ( root , null ) ; cn18 = new context name ( root bar ) ; cn19 = new context name ( root bar ) ; cn20 = new context name ( root ) ; }	public void store ( print writer writer , int indent , object context ) throw except { ( context instanceof standard context ) { store descript desc = get registri ( ) . find descript ( context . get class ( ) ) ; ( desc . store separ ( ) ) { url config file = ( ( standard context ) context ) . get config file ( ) ; ( config file = null ) { ( desc . extern allow ( ) ) { ( desc . backup ( ) ) store backup ( ( standard context ) context ) ; els store context separ ( writer , indent , ( standard context ) context ) ; return ; } } els ( desc . extern onli ( ) ) { set config file so configur actual save context context = ( ( standard context ) context ) ; host host = ( host ) context . get parent ( ) ; file config base = host . get config base file ( ) ; context name cn = new context name ( context . get name ( ) ) ; string base name = cn . get base name ( ) ; file xml = new file ( config base , base name . xml ) ; context . set config file ( xml . uri ( ) . url ( ) ) ; ( desc . backup ( ) ) store backup ( ( standard context ) context ) ; els store context separ ( writer , indent , ( standard context ) context ) ; return ; } } } super . store ( writer , indent , context ) ; }	test public void test constructor string ( ) { do test constructor string ( cn1 ) ; do test constructor string ( cn2 ) ; do test constructor string ( cn3 ) ; do test constructor string ( cn4 ) ; do test constructor string ( cn5 ) ; do test constructor string ( cn6 ) ; do test constructor string ( cn7 ) ; do test constructor string ( cn8 ) ; do test constructor string ( cn9 ) ; do test constructor string ( cn10 ) ; do test constructor string ( cn11 ) ; do test constructor string ( cn12 ) ; do test constructor string ( cn13 ) ; do test constructor string ( cn14 ) ; do test constructor string ( cn15 ) ; do test constructor string ( cn16 ) ; do test constructor string ( cn17 ) ; do test constructor string ( cn18 ) ; do test constructor string ( cn19 ) ; do test constructor string ( cn20 ) ; }	test public void test get base name ( ) { assert equal ( root , cn1 . get base name ( ) ) ; assert equal ( root , cn2 . get base name ( ) ) ; assert equal ( root , cn3 . get base name ( ) ) ; assert equal ( foo , cn4 . get base name ( ) ) ; assert equal ( foo bar , cn5 . get base name ( ) ) ; assert equal ( root , cn6 . get base name ( ) ) ; assert equal ( root b , cn7 . get base name ( ) ) ; assert equal ( root c , cn8 . get base name ( ) ) ; assert equal ( foo d , cn9 . get base name ( ) ) ; assert equal ( foo bar e , cn10 . get base name ( ) ) ; assert equal ( root , cn11 . get base name ( ) ) ; assert equal ( foo , cn12 . get base name ( ) ) ; assert equal ( foo bar , cn13 . get base name ( ) ) ; assert equal ( root , cn14 . get base name ( ) ) ; assert equal ( foo d , cn15 . get base name ( ) ) ; assert equal ( foo bar e , cn16 . get base name ( ) ) ; assert equal ( root , cn17 . get base name ( ) ) ; assert equal ( root bar , cn18 . get base name ( ) ) ; assert equal ( root bar , cn19 . get base name ( ) ) ; assert equal ( root , cn20 . get base name ( ) ) ; }	test public void test get displai name ( ) { assert equal ( , cn1 . get displai name ( ) ) ; assert equal ( , cn2 . get displai name ( ) ) ; assert equal ( , cn3 . get displai name ( ) ) ; assert equal ( foo , cn4 . get displai name ( ) ) ; assert equal ( foo bar , cn5 . get displai name ( ) ) ; assert equal ( , cn6 . get displai name ( ) ) ; assert equal ( b , cn7 . get displai name ( ) ) ; assert equal ( c , cn8 . get displai name ( ) ) ; assert equal ( foo d , cn9 . get displai name ( ) ) ; assert equal ( foo bar e , cn10 . get displai name ( ) ) ; assert equal ( , cn11 . get displai name ( ) ) ; assert equal ( foo , cn12 . get displai name ( ) ) ; assert equal ( foo bar , cn13 . get displai name ( ) ) ; assert equal ( , cn14 . get displai name ( ) ) ; assert equal ( foo d , cn15 . get displai name ( ) ) ; assert equal ( foo bar e , cn16 . get displai name ( ) ) ; assert equal ( , cn17 . get displai name ( ) ) ; assert equal ( root bar , cn18 . get displai name ( ) ) ; assert equal ( root bar , cn19 . get displai name ( ) ) ; assert equal ( , cn20 . get displai name ( ) ) ; }	test public void test get name ( ) { assert equal ( , cn1 . get name ( ) ) ; assert equal ( , cn2 . get name ( ) ) ; assert equal ( , cn3 . get name ( ) ) ; assert equal ( foo , cn4 . get name ( ) ) ; assert equal ( foo bar , cn5 . get name ( ) ) ; assert equal ( , cn6 . get name ( ) ) ; assert equal ( b , cn7 . get name ( ) ) ; assert equal ( c , cn8 . get name ( ) ) ; assert equal ( foo d , cn9 . get name ( ) ) ; assert equal ( foo bar e , cn10 . get name ( ) ) ; assert equal ( , cn11 . get name ( ) ) ; assert equal ( foo , cn12 . get name ( ) ) ; assert equal ( foo bar , cn13 . get name ( ) ) ; assert equal ( , cn14 . get name ( ) ) ; assert equal ( foo d , cn15 . get name ( ) ) ; assert equal ( foo bar e , cn16 . get name ( ) ) ; assert equal ( , cn17 . get name ( ) ) ; assert equal ( root bar , cn18 . get name ( ) ) ; assert equal ( root bar , cn19 . get name ( ) ) ; assert equal ( , cn20 . get name ( ) ) ; }	test public void test get path ( ) { assert equal ( , cn1 . get path ( ) ) ; assert equal ( , cn2 . get path ( ) ) ; assert equal ( , cn3 . get path ( ) ) ; assert equal ( foo , cn4 . get path ( ) ) ; assert equal ( foo bar , cn5 . get path ( ) ) ; assert equal ( , cn6 . get path ( ) ) ; assert equal ( , cn7 . get path ( ) ) ; assert equal ( , cn8 . get path ( ) ) ; assert equal ( foo , cn9 . get path ( ) ) ; assert equal ( foo bar , cn10 . get path ( ) ) ; assert equal ( , cn11 . get path ( ) ) ; assert equal ( foo , cn12 . get path ( ) ) ; assert equal ( foo bar , cn13 . get path ( ) ) ; assert equal ( , cn14 . get path ( ) ) ; assert equal ( foo , cn15 . get path ( ) ) ; assert equal ( foo bar , cn16 . get path ( ) ) ; assert equal ( , cn17 . get path ( ) ) ; assert equal ( root bar , cn18 . get path ( ) ) ; assert equal ( root bar , cn19 . get path ( ) ) ; assert equal ( , cn20 . get path ( ) ) ; }	test public void test get version ( ) { assert equal ( , cn1 . get version ( ) ) ; assert equal ( , cn2 . get version ( ) ) ; assert equal ( , cn3 . get version ( ) ) ; assert equal ( , cn4 . get version ( ) ) ; assert equal ( , cn5 . get version ( ) ) ; assert equal ( , cn6 . get version ( ) ) ; assert equal ( b , cn7 . get version ( ) ) ; assert equal ( c , cn8 . get version ( ) ) ; assert equal ( d , cn9 . get version ( ) ) ; assert equal ( e , cn10 . get version ( ) ) ; assert equal ( , cn11 . get version ( ) ) ; assert equal ( , cn12 . get version ( ) ) ; assert equal ( , cn13 . get version ( ) ) ; assert equal ( , cn14 . get version ( ) ) ; assert equal ( d , cn15 . get version ( ) ) ; assert equal ( e , cn16 . get version ( ) ) ; assert equal ( , cn17 . get version ( ) ) ; assert equal ( , cn18 . get version ( ) ) ; assert equal ( , cn19 . get version ( ) ) ; assert equal ( , cn20 . get version ( ) ) ; }	static creat code object name code thi code loader code object . param domain domain which thi name creat param loader loader name except malform object name except name cannot creat object name creat object name ( string domain , loader loader ) throw malform object name except { object name name = null ; context context = loader . get context ( ) ; context name cn = new context name ( context . get name ( ) ) ; contain host = context . get parent ( ) ; name = new object name ( domain : type = loader , host = host . get name ( ) , context = cn . get displai name ( ) ) ; return name ; }
public void set up ( ) throw except { cn1 = new context name ( null , null ) ; cn2 = new context name ( , null ) ; cn3 = new context name ( , null ) ; cn4 = new context name ( foo , null ) ; cn5 = new context name ( foo bar , null ) ; cn6 = new context name ( null , ) ; cn7 = new context name ( , b ) ; cn8 = new context name ( , c ) ; cn9 = new context name ( foo , d ) ; cn10 = new context name ( foo bar , e ) ; cn11 = new context name ( root ) ; cn12 = new context name ( foo ) ; cn13 = new context name ( foo bar ) ; cn14 = new context name ( root ) ; cn15 = new context name ( foo d ) ; cn16 = new context name ( foo bar e ) ; }	test public void test constructor string ( ) { do test constructor string ( cn1 ) ; do test constructor string ( cn2 ) ; do test constructor string ( cn3 ) ; do test constructor string ( cn4 ) ; do test constructor string ( cn5 ) ; do test constructor string ( cn6 ) ; do test constructor string ( cn7 ) ; do test constructor string ( cn8 ) ; do test constructor string ( cn9 ) ; do test constructor string ( cn10 ) ; do test constructor string ( cn11 ) ; do test constructor string ( cn12 ) ; do test constructor string ( cn13 ) ; do test constructor string ( cn14 ) ; do test constructor string ( cn15 ) ; do test constructor string ( cn16 ) ; }	test public void test get base name ( ) { assert equal ( root , cn1 . get base name ( ) ) ; assert equal ( root , cn2 . get base name ( ) ) ; assert equal ( root , cn3 . get base name ( ) ) ; assert equal ( foo , cn4 . get base name ( ) ) ; assert equal ( foo bar , cn5 . get base name ( ) ) ; assert equal ( root , cn6 . get base name ( ) ) ; assert equal ( root b , cn7 . get base name ( ) ) ; assert equal ( root c , cn8 . get base name ( ) ) ; assert equal ( foo d , cn9 . get base name ( ) ) ; assert equal ( foo bar e , cn10 . get base name ( ) ) ; assert equal ( root , cn11 . get base name ( ) ) ; assert equal ( foo , cn12 . get base name ( ) ) ; assert equal ( foo bar , cn13 . get base name ( ) ) ; assert equal ( root , cn14 . get base name ( ) ) ; assert equal ( foo d , cn15 . get base name ( ) ) ; assert equal ( foo bar e , cn16 . get base name ( ) ) ; }	test public void test get displai name ( ) { assert equal ( , cn1 . get displai name ( ) ) ; assert equal ( , cn2 . get displai name ( ) ) ; assert equal ( , cn3 . get displai name ( ) ) ; assert equal ( foo , cn4 . get displai name ( ) ) ; assert equal ( foo bar , cn5 . get displai name ( ) ) ; assert equal ( , cn6 . get displai name ( ) ) ; assert equal ( b , cn7 . get displai name ( ) ) ; assert equal ( c , cn8 . get displai name ( ) ) ; assert equal ( foo d , cn9 . get displai name ( ) ) ; assert equal ( foo bar e , cn10 . get displai name ( ) ) ; assert equal ( , cn11 . get displai name ( ) ) ; assert equal ( foo , cn12 . get displai name ( ) ) ; assert equal ( foo bar , cn13 . get displai name ( ) ) ; assert equal ( , cn14 . get displai name ( ) ) ; assert equal ( foo d , cn15 . get displai name ( ) ) ; assert equal ( foo bar e , cn16 . get displai name ( ) ) ; }	test public void test get name ( ) { assert equal ( , cn1 . get name ( ) ) ; assert equal ( , cn2 . get name ( ) ) ; assert equal ( , cn3 . get name ( ) ) ; assert equal ( foo , cn4 . get name ( ) ) ; assert equal ( foo bar , cn5 . get name ( ) ) ; assert equal ( , cn6 . get name ( ) ) ; assert equal ( b , cn7 . get name ( ) ) ; assert equal ( c , cn8 . get name ( ) ) ; assert equal ( foo d , cn9 . get name ( ) ) ; assert equal ( foo bar e , cn10 . get name ( ) ) ; assert equal ( , cn11 . get name ( ) ) ; assert equal ( foo , cn12 . get name ( ) ) ; assert equal ( foo bar , cn13 . get name ( ) ) ; assert equal ( , cn14 . get name ( ) ) ; assert equal ( foo d , cn15 . get name ( ) ) ; assert equal ( foo bar e , cn16 . get name ( ) ) ; }	test public void test get path ( ) { assert equal ( , cn1 . get path ( ) ) ; assert equal ( , cn2 . get path ( ) ) ; assert equal ( , cn3 . get path ( ) ) ; assert equal ( foo , cn4 . get path ( ) ) ; assert equal ( foo bar , cn5 . get path ( ) ) ; assert equal ( , cn6 . get path ( ) ) ; assert equal ( , cn7 . get path ( ) ) ; assert equal ( , cn8 . get path ( ) ) ; assert equal ( foo , cn9 . get path ( ) ) ; assert equal ( foo bar , cn10 . get path ( ) ) ; assert equal ( , cn11 . get path ( ) ) ; assert equal ( foo , cn12 . get path ( ) ) ; assert equal ( foo bar , cn13 . get path ( ) ) ; assert equal ( , cn14 . get path ( ) ) ; assert equal ( foo , cn15 . get path ( ) ) ; assert equal ( foo bar , cn16 . get path ( ) ) ; }	test public void test get version ( ) { assert equal ( , cn1 . get version ( ) ) ; assert equal ( , cn2 . get version ( ) ) ; assert equal ( , cn3 . get version ( ) ) ; assert equal ( , cn4 . get version ( ) ) ; assert equal ( , cn5 . get version ( ) ) ; assert equal ( , cn6 . get version ( ) ) ; assert equal ( b , cn7 . get version ( ) ) ; assert equal ( c , cn8 . get version ( ) ) ; assert equal ( d , cn9 . get version ( ) ) ; assert equal ( e , cn10 . get version ( ) ) ; assert equal ( , cn11 . get version ( ) ) ; assert equal ( , cn12 . get version ( ) ) ; assert equal ( , cn13 . get version ( ) ) ; assert equal ( , cn14 . get version ( ) ) ; assert equal ( d , cn15 . get version ( ) ) ; assert equal ( e , cn16 . get version ( ) ) ; }
public void recycl ( ) { content type = null ; content languag = null ; local = default local ; charact encod = constant . default charact encod ; charset set = fals ; content length = 1 ; statu = 200 ; messag = null ; commit = fals ; commit time = 1 ; error except = null ; header . clear ( ) ; listen = null ; updat counter content written = 0 ; }
protect scan tld defin lt ; jsp config gt ; . void scan jsp config ( ) throw ioexcept , saxexcept { jsp config descriptor jsp config descriptor = context . get jsp config descriptor ( ) ; ( jsp config descriptor = = null ) { return ; } collect taglib descriptor descriptor = jsp config descriptor . get taglib ( ) ; ( taglib descriptor descriptor : descriptor ) { string taglib uri = descriptor . get taglib uri ( ) ; string resourc path = descriptor . get taglib locat ( ) ; handl . ( resourc path . start ( ) ) { resourc path = web inf resourc path ; } ( uri tld resourc path map . contain kei ( taglib uri ) ) { log . warn ( local . get messag ( msg . webxml skip , resourc path , taglib uri ) ) ; continu ; } ( log . trace enabl ( ) ) { log . trace ( local . get messag ( msg . webxml add , resourc path , taglib uri ) ) ; } url url = context . get resourc ( resourc path ) ; tld resourc path tld resourc path ; ( resourc path . end ( . jar ) ) { path point jar file , tld presum insid meta inf taglib . tld tld resourc path = new tld resourc path ( url , resourc path , meta inf taglib . tld ) ; } els { tld resourc path = new tld resourc path ( url , resourc path ) ; } pars tld store us uri suppli descriptor taglib xml tld = tld parser . pars ( tld resourc path ) ; uri tld resourc path map . put ( taglib uri , tld resourc path ) ; tld resourc path taglib xml map . put ( tld resourc path , tld ) ; ( tld . get listen ( ) = null ) { listen . add all ( tld . get listen ( ) ) ; } } }
privat method us initi classpath compil . string init class path ( ) { string builder cpath = new string builder ( ) ; string sep = system . get properti ( path . separ ) ; ( parent class loader instanceof urlclass loader ) { url url = ( ( urlclass loader ) parent class loader ) . get url ( ) ; ( int i = 0 ; i url . length ; i ) { protocol url s classpath . ( url i . get protocol ( ) . equal ( file ) ) { cpath . append ( url i . get file ( ) sep ) ; } } } cpath . append ( option . get scratch dir ( ) sep ) ; string cp = ( string ) context . get attribut ( constant . servlet classpath ) ; ( cp = = null cp . equal ( ) ) { cp = option . get class path ( ) ; } string path = cpath . string ( ) cp ; ( log . debug enabl ( ) ) { log . debug ( compil classpath initi : path ) ; } return path ; }
protect static convert arrai string comma delimit string string list comma delimit string ( list string string list ) { ( string list = = null ) { return ; } string builder result = new string builder ( ) ; ( iter string = string list . iter ( ) ; . ha next ( ) ; ) { object element = . next ( ) ; ( element = null ) { result . append ( element ) ; ( . ha next ( ) ) { result . append ( , ) ; } } } return result . string ( ) ; }	protect static string list comma delimit string ( list string string list ) { ( string list = = null ) { return ; } string builder result = new string builder ( ) ; ( iter string = string list . iter ( ) ; . ha next ( ) ; ) { object element = . next ( ) ; ( element = null ) { result . append ( element ) ; ( . ha next ( ) ) { result . append ( , ) ; } } } return result . string ( ) ; }
privat map string , web xml scan fragment ( web xml parser web xml parser ) throw jasper except { standard jar scanner scanner = new standard jar scanner ( ) ; todo enabl thi mean initi classload first jsp c scanner . set scan class path ( fals ) ; todo configur filter rule from ant rather system properti scanner . set jar scan filter ( new standard jar scan filter ( ) ) ; fragment jar scanner callback callback = new fragment jar scanner callback ( web xml parser , fals ) ; scanner . scan ( jar scan type . pluggabl , thi , callback ) ; ( callback . ok ( ) ) { throw new jasper except ( local . get messag ( jspc . error . invalid fragment ) ) ; } return callback . get fragment ( ) ; }	protect scan web inf lib jar each found add ani meta inf web fragment . xml result map . web fragment . xml file pars befor ad map . everi jar ad code null code us web fragment . xml wa found . ani jar known contain fragment skip . return map jar name process web fragment ( ani ) map string , web xml process jar web fragment ( ) { jar scanner jar scanner = context . get jar scanner ( ) ; boolean deleg = fals ; ( context instanceof standard context ) { deleg = ( ( standard context ) context ) . get deleg ( ) ; } fragment jar scanner callback callback = new fragment jar scanner callback ( web xml parser , deleg ) ; jar scanner . scan ( jar scan type . pluggabl , context . get servlet context ( ) , callback ) ; ( callback . ok ( ) ) { ok = fals ; } return callback . get fragment ( ) ; }	protect scan web . xml file appli web applic merg them us rule defin spec . global web . xml file , where duplic configur , most specif level win . ie applic s web . xml take preced over host level global web . xml file . void web config ( ) { anyth everyth can overrid global host default . thi implement two part handl web fragment get ad after everyth els so everyth els take prioriti mark servlet overrid so sci configur can replac configur from default rule annot scan ar clear cut might think . tomcat implement follow process : per srv . 1 . 6 . 2 , tomcat scan annot regardless which servlet spec version declar web . xml . eg ha confirm thi expect behaviour . per http : java . net jira brows servlet spec 36 , main web . xml mark metadata complet , jar ar still process sci . metadata complet = true absolut order specifi , jar exclud from order ar also exclud from sci process . sci ha handl type annot all class ( except those jar exclud from absolut order ) need scan check thei match . set web xml default = new hash set ( ) ; default . add ( get default web xml fragment ( ) ) ; web xml web xml = creat web xml ( ) ; pars context level web . xml input sourc context web xml = get context web xml sourc ( ) ; ( web xml parser . pars web xml ( context web xml , web xml , fals ) ) { ok = fals ; } servlet context s context = context . get servlet context ( ) ; order import here step 1 . identifi all jar packag applic those provid contain . ani applic jar have web fragment . xml pars thi point . web fragment . xml file ar ignor contain provid jar . map string , web xml fragment = process jar web fragment ( ) ; step 2 . order fragment . set web xml order fragment = null ; order fragment = web xml . order web fragment ( web xml , fragment , s context ) ; step 3 . look servlet contain initi implement ( ok ) { process servlet contain initi ( s context ) ; } ( web xml . metadata complet ( ) type initi map . size ( ) 0 ) { handl type match ( ok ) { web resourc web resourc = context . get resourc ( ) . list resourc ( web inf class ) ; ( web resourc web resourc : web resourc ) { process annot web resourc ( web resourc , web xml , web xml . metadata complet ( ) ) ; } } contain fragment ) ( ok ) { process annot ( order fragment , web xml . metadata complet ( ) ) ; } cach , us , longer requir so clear java class cach . clear ( ) ; } ( web xml . metadata complet ( ) ) { file . ( ok ) { ok = web xml . merg ( order fragment ) ; } step 7 . appli global default have merg default befor jsp convers sinc default provid jsp servlet definit . web xml . merg ( default ) ; step 8 . convert explicitli mention jsp servlet ( ok ) { convert jsp ( web xml ) ; } step 9 . appli merg web . xml context ( ok ) { configur context ( web xml ) ; } } els { web xml . merg ( default ) ; convert jsp ( web xml ) ; configur context ( web xml ) ; } step 9a . make merg web . xml avail other compon , specif jasper , save those compon from have re gener . todo us servlet contain initi jasper string merg web xml = web xml . xml ( ) ; s context . set attribut ( org . apach . tomcat . util . scan . constant . merg web xml , merg web xml ) ; ( context . get log effect web xml ( ) ) { log . info ( web . xml : n merg web xml ) ; } step 10 . look static resourc packag jar ( ok ) { spec doe defin order . us order jar follow remain jar set web xml resourc jar = new link hash set ( ) ; ( order fragment = null ) { ( web xml fragment : order fragment ) { resourc jar . add ( fragment ) ; } } ( web xml fragment : fragment . valu ( ) ) { ( resourc jar . contain ( fragment ) ) { resourc jar . add ( fragment ) ; } } process resourc jar ( resourc jar ) ; see also standard context . resourc start ( ) web inf class meta inf resourc configur } context ( ok ) { ( map . entri servlet contain initi , set class >> entri : initi class map . entri set ( ) ) { ( entri . get valu ( ) . empti ( ) ) { context . add servlet contain initi ( entri . get kei ( ) , null ) ; } els { context . add servlet contain initi ( entri . get kei ( ) , entri . get valu ( ) ) ; } } } }	overrid public void scan ( jar urlconnect jar conn , string webapp path , boolean webapp ) throw ioexcept { url url = jar conn . get url ( ) ; url resourc url = jar conn . get jar file url ( ) ; jar jar = null ; input stream = null ; web xml fragment = new web xml ( ) ; fragment . set webapp jar ( webapp ) ; fragment . set deleg ( deleg ) ; try { file ( webapp ) { jar = jar factori . new instanc ( url ) ; = jar . get input stream ( fragment locat ) ; } ( = = null ) { web . xml , normal jar impact distribut fragment . set distribut ( true ) ; } els { input sourc sourc = new input sourc ( jar : resourc url . string ( ) fragment locat ) ; sourc . set byte stream ( ) ; ( web xml parser . pars web xml ( sourc , fragment , true ) ) { ok = fals ; } } } final { ( jar = null ) { jar . close ( ) ; } fragment . set url ( url ) ; ( fragment . get name ( ) = = null ) { fragment . set name ( fragment . get url ( ) . string ( ) ) ; } fragment . set jar name ( extract jar file name ( url ) ) ; fragment . put ( fragment . get name ( ) , fragment ) ; } }
privat sslengin creat sslengin ( map string , object user properti ) throw deploy except { try { creat ssl context sslcontext ssl context = sslcontext . get instanc ( tl ) ; trust store string ssl trust store valu = ( string ) user properti . get ( ssl truststor properti ) ; ( ssl trust store valu = null ) { string ssl trust store pwd valu = ( string ) user properti . get ( ssl truststor pwd properti ) ; ( ssl trust store pwd valu = = null ) { ssl trust store pwd valu = ssl truststor pwd default ; } file kei store file = new file ( ssl trust store valu ) ; kei store ks = kei store . get instanc ( jk ) ; try ( input stream = new file input stream ( kei store file ) ) { ks . load ( , ssl trust store pwd valu . char arrai ( ) ) ; } trust manag factori tmf = trust manag factori . get instanc ( trust manag factori . get default algorithm ( ) ) ; tmf . init ( ks ) ; ssl context . init ( null , tmf . get trust manag ( ) , null ) ; } els { ssl context . init ( null , null , null ) ; } sslengin engin = ssl context . creat sslengin ( ) ; string ssl protocol valu = ( string ) user properti . get ( ssl protocol properti ) ; ( ssl protocol valu = null ) { engin . set enabl protocol ( ssl protocol valu . split ( , ) ) ; } engin . set us client mode ( true ) ; return engin ; } catch ( except e ) { throw new deploy except ( sm . get string ( ws web socket contain . ssl engin fail ) , e ) ; } }

public send buffer sink . call append ( ) when limit reach . you can also call explicitli forc data written . throw ioexcept void flush buffer ( ) throw ioexcept { assert out = null ( out = = null ) { throw new ioexcept ( buffer overflow , sink limit buff . length ) ; } out . real write byte ( buff , start , end start ) ; end = start ; }	convert char byte , send data client . param buf char buffer written respons param off offset param len length throw ioexcept underli ioexcept occur overrid public void real write char ( char buf , int off , int len ) throw ioexcept { output char chunk . set char ( buf , off , len ) ; while ( output char chunk . get length ( ) 0 ) { conv . convert ( output char chunk , bb ) ; ( bb . get length ( ) = = 0 ) { break out loop more char ar need produc ani output break ; } ( output char chunk . get length ( ) 0 ) { bb . flush buffer ( ) ; } } }
privat web resourc list resourc ( string path , boolean valid ) { ( valid ) { path = valid ( path ) ; } string resourc = list ( path , fals ) ; web resourc result = new web resourc resourc . length ; ( int i = 0 ; i resourc . length ; i ) { ( path . char ( path . length ( ) 1 ) = = ) { result i = get resourc ( path resourc i , fals , fals ) ; } els { result i = get resourc ( path resourc i , fals , fals ) ; } } return result ; }	overrid public string get canon path ( ) { return null ; }	overrid public set string list web app path ( string path ) { check path ( path ) ; string web app mount = get web app mount ( ) ; resourc set string result = new resourc set ( ) ; ( path . start ( web app mount ) ) { file f = file ( path . substr ( web app mount . length ( ) ) , true ) ; ( f = null ) { file list = f . list file ( ) ; ( list = null ) { ( file entri : list ) { string builder sb = new string builder ( path ) ; ( path . char ( path . length ( ) 1 ) = ) { sb . append ( ) ; } sb . append ( entri . get name ( ) ) ; ( entri . directori ( ) ) { sb . append ( ) ; } result . add ( sb . string ( ) ) ; } } } } els { ( path . end ( ) ) { path = path ; } ( web app mount . start ( path ) ) { int i = web app mount . index ( , path . length ( ) ) ; ( i = = 1 ) { result . add ( web app mount ) ; } els { result . add ( web app mount . substr ( 0 , i 1 ) ) ; } } } result . set lock ( true ) ; return result ; }	test public final void test write ( ) { input stream = new byte arrai input stream ( test . get byte ( ) ) ; ( writeabl ( ) ) { assert . assert true ( resourc root . write ( get mount ( ) new test , , fals ) ) ; file file = new file ( get base dir ( ) , new test ) ; assert . assert true ( file . exist ( ) ) ; assert . assert true ( file . delet ( ) ) ; } els { assert . assert fals ( resourc root . write ( get mount ( ) new test , , fals ) ) ; } }
return princip ha been authent thi request . overrid public princip get user princip ( ) { ( user princip instanceof tomcat princip ) { return ( ( tomcat princip ) user princip ) . get user princip ( ) ; } return user princip ; }
initi access thi user databas . except except ani except thrown dure open overrid public void open ( ) throw except { synchron ( group ) { synchron ( user ) { eras ani previou group user user . clear ( ) ; group . clear ( ) ; role . clear ( ) ; construct reader xml input file ( exist ) file file = new file ( pathnam ) ; ( file . absolut ( ) ) { file = new file ( system . get properti ( global . catalina base prop ) , pathnam ) ; } ( file . exist ( ) ) { return ; } construct digest read xml input file digest digest = new digest ( ) ; try { digest . set featur ( http : apach . org xml featur allow java encod , true ) ; } catch ( except e ) { log . warn ( sm . get string ( memori user databas . xml featur encod ) , e ) ; } digest . add factori creat ( tomcat user group , new memori group creation factori ( thi ) , true ) ; digest . add factori creat ( tomcat user role , new memori role creation factori ( thi ) , true ) ; digest . add factori creat ( tomcat user user , new memori user creation factori ( thi ) , true ) ; pars xml input file load thi databas file input stream fi = null ; try { fi = new file input stream ( file ) ; digest . pars ( fi ) ; } final { ( fi = null ) { try { fi . close ( ) ; } catch ( ioexcept ioe ) { ignor } } } } } }
protect synchron return princip associ given user name . princip get princip ( dir context context , string usernam , gsscredenti gss credenti ) throw name except { user user = null ; list string role = null ; hashtabl , preserv environ = null ; try { ( gss credenti = null us deleg credenti ( ) ) { preserv current context environ paramet preserv environ = context . get environ ( ) ; set up context context . add environ ( context . secur authent , gssapi ) ; context . add environ ( javax . secur . sasl . server . authent , true ) ; context . add environ ( javax . secur . sasl . qop , auth conf ) ; note : subject alreadi set spnego authent so need subject . do ( ) here } user = get user ( context , usernam ) ; ( user = null ) { role = get role ( context , user ) ; } } final { restor environ paramet ( context , context . secur authent , preserv environ ) ; restor environ paramet ( context , javax . secur . sasl . server . authent , preserv environ ) ; restor environ paramet ( context , javax . secur . sasl . qop , preserv environ ) ; } ( user = null ) { return new gener princip ( user . get user name ( ) , user . get password ( ) , role , null , null , gss credenti ) ; } return null ; }	public void set time limit ( int time limit ) { thi . time limit = time limit ; }	public void set us deleg credenti ( boolean us deleg credenti ) { thi . us deleg credenti = us deleg credenti ; }
privat web resourc get resourc ( string path , boolean do state check , boolean us class loader resourc ) { ( do state check ) { check state ( ) ; } ( cach allow ( ) ) { return cach . get resourc ( path , us class loader resourc ) ; } els { return get resourc intern ( path , us class loader resourc ) ; } }	privat void check path ( string path ) { ( path = = null path . length ( ) = = 0 path . start ( ) ) { throw new illeg argument except ( sm . get string ( standard root . invalid path , path ) ) ; } }	privat web resourc list resourc ( string path , boolean do state check ) { ( do state check ) { check state ( ) ; } string resourc = list ( path , fals ) ; web resourc result = new web resourc resourc . length ; ( int i = 0 ; i resourc . length ; i ) { ( path . char ( path . length ( ) 1 ) = = ) { result i = get resourc ( path resourc i , fals , fals ) ; } els { result i = get resourc ( path resourc i , fals , fals ) ; } } return result ; }	overrid public set string list web app path ( string path ) { check state ( ) ; set becaus we don t want duplic hash set string result = new hash set ( ) ; ( arrai list web resourc set list : all resourc ) { ( web resourc set web resourc set : list ) { ( web resourc set . get class loader onli ( ) ) { result . add all ( web resourc set . list web app path ( path ) ) ; } } } ( result . size ( ) = = 0 ) { return null ; } return result ; }	overrid public web resourc get class loader resourc ( string path ) { check path ( path ) ; return get resourc ( web inf class path , true ) ; }	overrid public web resourc get resourc ( string path ) { return get resourc ( path , true , fals ) ; }	overrid public boolean mkdir ( string path ) { check state ( ) ; ( pre resourc exist ( path ) ) { return fals ; } return main . mkdir ( path ) ; }	overrid public boolean write ( string path , input stream , boolean overwrit ) { check state ( ) ; ( overwrit pre resourc exist ( path ) ) { return fals ; } return main . write ( path , , overwrit ) ; }	overrid public void set context ( context context ) { thi . context = context ; }
privat void do test bug53677 ( boolean flush ) throw except { tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctxt = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; tomcat . add servlet ( ctxt , larg header servlet , new larg header servlet ( flush ) ) ; ctxt . add servlet map ( test , larg header servlet ) ; tomcat . start ( ) ; byte chunk respons bodi = new byte chunk ( ) ; map string , list string >> respons header = new hash map ( ) ; int rc = get url ( http : localhost : get port ( ) test , respons bodi , respons header ) ; assert equal ( http servlet respons . sc intern server error , rc ) ; ( respons bodi . get length ( ) 0 ) { 0 standard error page handlign ha been trigger assert fals ( respons bodi . string ( ) . contain ( fail ) ) ; } }	send action connector . param action code type action param param action paramet overrid public final void action ( action code action code , object param ) { ( action code = = action code . close ) { transact client try { finish ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . commit ) { ( respons . commit ( ) ) return ; valid write respons header try { prepar respons ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } try { flush ( fals ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . ack ) { op ajp } els ( action code = = action code . client flush ) { ( respons . commit ( ) ) { valid write respons header try { prepar respons ( ) ; } catch ( ioexcept e ) { set error flag error = true ; return ; } } try { flush ( true ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . disabl swallow input ) { todo : do swallow request input make sure we ar close connect error = true ; } els ( action code = = action code . reset ) { op } els ( action code = = action code . req ssl attribut ) { ( certif . null ( ) ) { byte chunk cert data = certif . get byte chunk ( ) ; x509certif jsse cert = null ; byte arrai input stream bai = new byte arrai input stream ( cert data . get byte ( ) , cert data . get start ( ) , cert data . get length ( ) ) ; fill element . try { certif factori cf ; ( client cert provid = = null ) { cf = certif factori . get instanc ( x . 509 ) ; } els { cf = certif factori . get instanc ( x . 509 , client cert provid ) ; } while ( bai . avail ( ) 0 ) { x509certif cert = ( x509certif ) cf . gener certif ( bai ) ; ( jsse cert = = null ) { jsse cert = new x509certif 1 ; jsse cert 0 = cert ; } els { x509certif temp = new x509certif jsse cert . length 1 ; system . arraycopi ( jsse cert , 0 , temp , 0 , jsse cert . length ) ; temp jsse cert . length = cert ; jsse cert = temp ; } } } catch ( java . secur . cert . certif except e ) { get log ( ) . error ( sm . get string ( ajpprocessor . cert . fail ) , e ) ; return ; } catch ( provid except e ) { get log ( ) . error ( sm . get string ( ajpprocessor . cert . fail ) , e ) ; return ; } request . set attribut ( sslsupport . certif kei , jsse cert ) ; } } els ( action code = = action code . req ssl certif ) { op . can t forc new ssl handshak client when us ajp revers proxi control connect . } els ( action code = = action code . req host attribut ) { get remot host name us dn resolut ( request . remot host ( ) . null ( ) ) { try { request . remot host ( ) . set string ( inet address . get name ( request . remot addr ( ) . string ( ) ) . get host name ( ) ) ; } catch ( ioexcept iex ) { ignor } } } els ( action code = = action code . req host addr attribut ) { op automat popul dure prepar request ( ) } els ( action code = = action code . req local name attribut ) { op automat popul dure prepar request ( ) } els ( action code = = action code . req local addr attribut ) { copi from local name now , which should simpli address request . local addr ( ) . set string ( request . local name ( ) . string ( ) ) ; } els ( action code = = action code . req remoteport attribut ) { op thi inform avail when us ajp protocol } els ( action code = = action code . req localport attribut ) { op automat popul dure prepar request ( ) } els ( action code = = action code . req set bodi replai ) { set given byte content byte chunk bc = ( byte chunk ) param ; int length = bc . get length ( ) ; bodi byte . set byte ( bc . get byte ( ) , bc . get start ( ) , length ) ; request . set content length ( length ) ; first = fals ; empti = fals ; replai = true ; end stream = fals ; } els ( action code = = action code . async start ) { async state machin . async start ( ( async context callback ) param ) ; } els ( action code = = action code . async complet ) { socket wrapper . clear dispatch ( ) ; ( async state machin . async complet ( ) ) { endpoint . process socket ( socket wrapper , socket statu . open read , true ) ; } } els ( action code = = action code . async dispatch ) { ( async state machin . async dispatch ( ) ) { endpoint . process socket ( socket wrapper , socket statu . open read , true ) ; } } els ( action code = = action code . async dispatch ) { async state machin . async dispatch ( ) ; } els ( action code = = action code . async settimeout ) { ( param = = null ) return ; long timeout = ( ( long ) param ) . long valu ( ) ; socket wrapper . set timeout ( timeout ) ; } els ( action code = = action code . async timeout ) { atom boolean result = ( atom boolean ) param ; result . set ( async state machin . async timeout ( ) ) ; } els ( action code = = action code . async run ) { async state machin . async run ( ( runnabl ) param ) ; } els ( action code = = action code . async error ) { async state machin . async error ( ) ; } els ( action code = = action code . async start ) { ( ( atom boolean ) param ) . set ( async state machin . async start ( ) ) ; } els ( action code = = action code . async dispatch ) { ( ( atom boolean ) param ) . set ( async state machin . async dispatch ( ) ) ; } els ( action code = = action code . async async ) { ( ( atom boolean ) param ) . set ( async state machin . async ( ) ) ; } els ( action code = = action code . async timingout ) { ( ( atom boolean ) param ) . set ( async state machin . async time out ( ) ) ; } els ( action code = = action code . async error ) { ( ( atom boolean ) param ) . set ( async state machin . async error ( ) ) ; } els ( action code = = action code . upgrad ) { http connect onli . unsupport ajp . throw new unsupport oper except ( sm . get string ( ajpprocessor . httpupgrad . notsupport ) ) ; } els ( action code = = action code . comet begin ) { http connect onli . unsupport ajp . throw new unsupport oper except ( sm . get string ( ajpprocessor . comet . notsupport ) ) ; } els ( action code = = action code . comet end ) { http connect onli . unsupport ajp . throw new unsupport oper except ( sm . get string ( ajpprocessor . comet . notsupport ) ) ; } els ( action code = = action code . comet close ) { http connect onli . unsupport ajp . throw new unsupport oper except ( sm . get string ( ajpprocessor . comet . notsupport ) ) ; } els ( action code = = action code . comet settimeout ) { http connect onli . unsupport ajp . throw new unsupport oper except ( sm . get string ( ajpprocessor . comet . notsupport ) ) ; } els ( action code = = action code . avail ) { ( avail ( ) ) { request . set avail ( 1 ) ; } els { request . set avail ( 0 ) ; } } els ( action code = = action code . nb read interest ) { ( end stream ) { regist event ( true , fals ) ; } } els ( action code = = action code . nb write interest ) { atom boolean readi = ( atom boolean ) param ; boolean result = buffer write . size ( ) = = 0 respons msg po = = 1 ; readi . set ( result ) ; ( result ) { regist event ( fals , true ) ; } } els ( action code = = action code . request bodi fulli read ) { atom boolean result = ( atom boolean ) param ; result . set ( end stream ) ; } els ( action code = = action code . dispatch read ) { socket wrapper . add dispatch ( dispatch type . non block read ) ; } els ( action code = = action code . dispatch write ) { socket wrapper . add dispatch ( dispatch type . non block write ) ; } }	send action connector . param action code type action param param action paramet overrid public final void action ( action code action code , object param ) { ( action code = = action code . close ) { end process current request try { get output buffer ( ) . end request ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . commit ) { commit current respons ( respons . commit ( ) ) { return ; } valid write respons header try { prepar respons ( ) ; get output buffer ( ) . commit ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . ack ) { yet , client specifi expect 100 continu ) ( ( respons . commit ( ) ) expect ) { return ; } get input buffer ( ) . set swallow input ( true ) ; try { get output buffer ( ) . send ack ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . client flush ) { try { get output buffer ( ) . flush ( ) ; } catch ( ioexcept e ) { set error flag error = true ; respons . set error except ( e ) ; } } els ( action code = = action code . disabl swallow input ) { do swallow request input make sure we ar close connect error = true ; get input buffer ( ) . set swallow input ( fals ) ; } els ( action code = = action code . reset ) { reset respons note : thi must call befor respons commit get output buffer ( ) . reset ( ) ; } els ( action code = = action code . req set bodi replai ) { byte chunk bodi = ( byte chunk ) param ; input filter save bodi = new save request input filter ( bodi ) ; save bodi . set request ( request ) ; suppress warn ( uncheck ) abstract input buffer s intern buffer = ( abstract input buffer s ) request . get input buffer ( ) ; intern buffer . add activ filter ( save bodi ) ; } els ( action code = = action code . async start ) { async state machin . async start ( ( async context callback ) param ) ; } els ( action code = = action code . async dispatch ) { async state machin . async dispatch ( ) ; } els ( action code = = action code . async timeout ) { atom boolean result = ( atom boolean ) param ; result . set ( async state machin . async timeout ( ) ) ; } els ( action code = = action code . async run ) { async state machin . async run ( ( runnabl ) param ) ; } els ( action code = = action code . async error ) { async state machin . async error ( ) ; } els ( action code = = action code . async start ) { ( ( atom boolean ) param ) . set ( async state machin . async start ( ) ) ; } els ( action code = = action code . async dispatch ) { ( ( atom boolean ) param ) . set ( async state machin . async dispatch ( ) ) ; } els ( action code = = action code . async async ) { ( ( atom boolean ) param ) . set ( async state machin . async ( ) ) ; } els ( action code = = action code . async timingout ) { ( ( atom boolean ) param ) . set ( async state machin . async time out ( ) ) ; } els ( action code = = action code . async error ) { ( ( atom boolean ) param ) . set ( async state machin . async error ( ) ) ; } els ( action code = = action code . upgrad ) { http upgrad handler = ( http upgrad handler ) param ; stop further http output get output buffer ( ) . finish = true ; } els ( action code = = action code . avail ) { request . set avail ( input buffer . avail ( ) ) ; } els ( action code = = action code . nb write interest ) { atom boolean readi = ( atom boolean ) param ; try { readi . set ( get output buffer ( ) . readi ( ) ) ; } catch ( ioexcept e ) { get log ( ) . debug ( readi ( ) fail , e ) ; error = true ; } } els ( action code = = action code . nb read interest ) { regist event ( true , fals ) ; } els ( action code = = action code . request bodi fulli read ) { atom boolean result = ( atom boolean ) param ; result . set ( get input buffer ( ) . finish ( ) ) ; } els ( action code = = action code . dispatch read ) { socket wrapper . add dispatch ( dispatch type . non block read ) ; } els ( action code = = action code . dispatch write ) { socket wrapper . add dispatch ( dispatch type . non block write ) ; } els ( action code = = action code . dispatch execut ) { get endpoint ( ) . execut non block dispatch ( socket wrapper ) ; } els { action intern ( action code , param ) ; } }	overrid public void action ( action code action code , object param ) { ( spdy context . debug ) { system . err . println ( action code ) ; } todo : async ( action code = = action code . commit ) { mayb commit ( ) ; } els ( action code = = action code . client flush ) { mayb commit ( ) ; try { flush ( true ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . disabl swallow input ) { todo : do swallow request input make sure we ar close connect error = true ; } els ( action code = = action code . close ) { ( out close ) { return ; } out close = true ; close end process current request , stop ani further transact client mayb commit ( ) ; spdy stream . send data frame ( empti , 0 , 0 , true ) ; } els ( action code = = action code . req ssl attribut ) { ( certif . null ( ) ) { byte chunk cert data = certif . get byte chunk ( ) ; x509certif jsse cert = null ; byte arrai input stream bai = new byte arrai input stream ( cert data . get byte ( ) , cert data . get start ( ) , cert data . get length ( ) ) ; fill element . try { certif factori cf ; ( client cert provid = = null ) { cf = certif factori . get instanc ( x . 509 ) ; } els { cf = certif factori . get instanc ( x . 509 , client cert provid ) ; } while ( bai . avail ( ) 0 ) { x509certif cert = ( x509certif ) cf . gener certif ( bai ) ; ( jsse cert = = null ) { jsse cert = new x509certif 1 ; jsse cert 0 = cert ; } els { x509certif temp = new x509certif jsse cert . length 1 ; system . arraycopi ( jsse cert , 0 , temp , 0 , jsse cert . length ) ; temp jsse cert . length = cert ; jsse cert = temp ; } } } catch ( java . secur . cert . certif except e ) { get log ( ) . error ( sm . get string ( ajpprocessor . cert . fail ) , e ) ; return ; } catch ( provid except e ) { get log ( ) . error ( sm . get string ( ajpprocessor . cert . fail ) , e ) ; return ; } request . set attribut ( sslsupport . certif kei , jsse cert ) ; } } els ( action code = = action code . req host attribut ) { get remot host name us dn resolut ( request . remot host ( ) . null ( ) ) { try { request . remot host ( ) . set string ( inet address . get name ( request . remot addr ( ) . string ( ) ) . get host name ( ) ) ; } catch ( ioexcept iex ) { ignor } } } els ( action code = = action code . req localport attribut ) { string configur = ( string ) endpoint . get attribut ( proxi port ) ; int local port = 0 ; ( configur = null ) { local port = integ . pars int ( configur ) ; } els { local port = endpoint . get port ( ) ; } request . set local port ( local port ) ; } els ( action code = = action code . req local addr attribut ) { inet address local address = endpoint . get address ( ) ; string local ip = local address = = null null : local address . get host address ( ) ; ( local ip = = null ) { local ip = ( string ) endpoint . get attribut ( proxi ip ) ; } ( local ip = = null ) { local ip = 127 . 0 . 0 . 1 ; } request . local addr ( ) . set string ( local ip ) ; } els ( action code = = action code . req host addr attribut ) { inet address local address = endpoint . get address ( ) ; string local h = local address = = null null : local address . get canon host name ( ) ; ( local h = = null ) { local h = ( string ) endpoint . get attribut ( proxi name ) ; } ( local h = = null ) { local h = localhost ; } request . local addr ( ) . set string ( local h ) ; } els ( action code = = action code . req set bodi replai ) { set given byte content byte chunk bc = ( byte chunk ) param ; int length = bc . get length ( ) ; bodi byte . set byte ( bc . get byte ( ) , bc . get start ( ) , length ) ; request . set content length ( length ) ; first = fals ; empti = fals ; replai = true ; } els ( action code = = action code . async start ) { async state machin . async start ( ( async context callback ) param ) ; } els ( action code = = action code . async dispatch ) { async state machin . async dispatch ( ) ; } els ( action code = = action code . async timeout ) { atom boolean result = ( atom boolean ) param ; result . set ( async state machin . async timeout ( ) ) ; } els ( action code = = action code . async run ) { async state machin . async run ( ( runnabl ) param ) ; } els ( action code = = action code . async error ) { async state machin . async error ( ) ; } els ( action code = = action code . async start ) { ( ( atom boolean ) param ) . set ( async state machin . async start ( ) ) ; } els ( action code = = action code . async dispatch ) { ( ( atom boolean ) param ) . set ( async state machin . async dispatch ( ) ) ; } els ( action code = = action code . async async ) { ( ( atom boolean ) param ) . set ( async state machin . async ( ) ) ; } els ( action code = = action code . async timingout ) { ( ( atom boolean ) param ) . set ( async state machin . async time out ( ) ) ; } els ( action code = = action code . async error ) { ( ( atom boolean ) param ) . set ( async state machin . async error ( ) ) ; } els { todo : action intern ( action code , param ) ; } }	servic method . overrid public void servic ( org . apach . coyot . request req , org . apach . coyot . respons re ) throw except { request request = ( request ) req . get note ( adapt note ) ; respons respons = ( respons ) re . get note ( adapt note ) ; ( request = = null ) { creat object request = connector . creat request ( ) ; request . set coyot request ( req ) ; respons = connector . creat respons ( ) ; respons . set coyot respons ( re ) ; link object request . set respons ( respons ) ; respons . set request ( request ) ; set note req . set note ( adapt note , request ) ; re . set note ( adapt note , respons ) ; set queri string encod req . get paramet ( ) . set queri string encod ( connector . get uriencod ( ) ) ; } ( connector . get xpower ( ) ) { respons . add header ( x power , power ) ; } boolean comet = fals ; boolean async = fals ; try { pars set catalina configur specif request paramet req . get request processor ( ) . set worker thread name ( thread name . get ( ) ) ; boolean post pars success = post pars request ( req , request , re , respons ) ; ( post pars success ) { check valv we support async request . set async support ( connector . get servic ( ) . get contain ( ) . get pipelin ( ) . async support ( ) ) ; call contain connector . get servic ( ) . get contain ( ) . get pipelin ( ) . get first ( ) . invok ( request , respons ) ; ( request . comet ( ) ) { ( respons . close ( ) respons . error ( ) ) { ( request . get avail ( ) ( request . get content length ( ) 0 ( request . paramet pars ( ) ) ) ) { invok read event right awai ar avail byte ( event ( req , re , socket statu . open read ) ) { comet = true ; re . action ( action code . comet begin , null ) ; } } els { comet = true ; re . action ( action code . comet begin , null ) ; } } els { clear filter chain , otherwis reset elsewher sinc thi comet request request . set filter chain ( null ) ; } } } async context impl async con impl = ( async context impl ) request . get async context ( ) ; ( async con impl = null ) { async = true ; read listen read listen = req . get read listen ( ) ; ( read listen = null ) { possibl all data mai have been read dure servic ( ) method so thi need check here class loader old cl = thread . current thread ( ) . get context class loader ( ) ; class loader new cl = request . get context ( ) . get loader ( ) . get class loader ( ) ; try { thread . current thread ( ) . set context class loader ( new cl ) ; ( request . finish ( ) ) { req . get read listen ( ) . all data read ( ) ; } } final { thread . current thread ( ) . set context class loader ( old cl ) ; } } } els ( comet ) { request . finish request ( ) ; respons . finish respons ( ) ; ( post pars success request . get map data ( ) . context = null ) { log onli process wa invok . post pars request ( ) fail , ha alreadi log . context null thi wa start comet request fail ha alreadi been log . request . get map data ( ) . context . log access ( request , respons , system . current time milli ( ) req . get start time ( ) , fals ) ; } } } catch ( ioexcept e ) { ignor } final { req . get request processor ( ) . set worker thread name ( null ) ; recycl wrapper request respons ( comet async ) { request . recycl ( ) ; respons . recycl ( ) ; } els { clear convert so minimum amount memori us thi processor request . clear encod ( ) ; respons . clear encod ( ) ; } } }
overrid protect void init intern ( ) throw lifecycl except { super . init intern ( ) ; kerbero configur file locat string krb5conf = system . get properti ( constant . krb5 conf properti ) ; ( krb5conf = = null ) { system properti set , us tomcat default file krb5conf file = new file ( contain . get catalina base ( ) , constant . default krb5 conf ) ; system . set properti ( constant . krb5 conf properti , krb5conf file . get absolut path ( ) ) ; } jaa configur file locat string jaa conf = system . get properti ( constant . jaa conf properti ) ; ( jaa conf = = null ) { system properti set , us tomcat default file jaa conf file = new file ( contain . get catalina base ( ) , constant . default jaa conf ) ; system . set properti ( constant . jaa conf properti , jaa conf file . get absolut path ( ) ) ; } thi properti must fals spnego work system . set properti ( constant . us subject cred onli properti , fals ) ; }
initi endpoint . overrid public void bind ( ) throw except { creat root apr memori pool try { root pool = pool . creat ( 0 ) ; } catch ( unsatisfi link error e ) { throw new except ( sm . get string ( endpoint . init . notavail ) ) ; } creat pool server socket server sock pool = pool . creat ( root pool ) ; creat apr address bound string address str = null ; ( get address ( ) = null ) { address str = get address ( ) . get host address ( ) ; } int famili = socket . apr inet ; ( librari . apr have ipv6 ) { ( address str = = null ) { ( os . bsd os . win32 os . win64 ) famili = socket . apr unspec ; } els ( address str . index ( : ) = 0 ) { famili = socket . apr unspec ; } } long inet address = address . info ( address str , famili , get port ( ) , 0 , root pool ) ; creat apr server socket server sock = socket . creat ( address . get info ( inet address ) . famili , socket . sock stream , socket . apr proto tcp , root pool ) ; ( os . unix ) { socket . opt set ( server sock , socket . apr so reuseaddr , 1 ) ; } deal firewal tend drop inact socket socket . opt set ( server sock , socket . apr so keepal , 1 ) ; bind server socket int ret = socket . bind ( server sock , inet address ) ; ( ret = 0 ) { throw new except ( sm . get string ( endpoint . init . bind , ret , error . strerror ( ret ) ) ) ; } start listen server socket ret = socket . listen ( server sock , get backlog ( ) ) ; ( ret = 0 ) { throw new except ( sm . get string ( endpoint . init . listen , ret , error . strerror ( ret ) ) ) ; } ( os . win32 os . win64 ) { window set reuseaddr flag after bind listen socket . opt set ( server sock , socket . apr so reuseaddr , 1 ) ; } system which don t support caus major problem ( us send file set ) { us sendfil = librari . apr ha sendfil ; } els ( us sendfil librari . apr ha sendfil ) { us sendfil = fals ; } initi thread count default acceptor ( acceptor thread count = = 0 ) { fixm : doesn t seem work well multipl accept thread acceptor thread count = 1 ; } other platform thi call noop return apr enotimpl . ( defer accept ) { ( socket . opt set ( server sock , socket . apr tcp defer accept , 1 ) = = statu . apr enotimpl ) { defer accept = fals ; } } initi ssl need ( sslenabl ( ) ) { ( sslcertif file = = null ) { thi requir throw new except ( sm . get string ( endpoint . apr . ssl cert file ) ) ; } ssl protocol int valu = ssl . ssl protocol none ; ( sslprotocol = = null sslprotocol . length ( ) = = 0 ) { valu = ssl . ssl protocol all ; } els { ( string protocol : sslprotocol . split ( ) ) { protocol = protocol . trim ( ) ; ( sslv2 . equal ignor case ( protocol ) ) { valu = ssl . ssl protocol sslv2 ; } els ( sslv3 . equal ignor case ( protocol ) ) { valu = ssl . ssl protocol sslv3 ; } els ( tlsv1 . equal ignor case ( protocol ) ) { valu = ssl . ssl protocol tlsv1 ; } els ( all . equal ignor case ( protocol ) ) { valu = ssl . ssl protocol all ; } els { requir throw new except ( sm . get string ( endpoint . apr . invalid ssl protocol , sslprotocol ) ) ; } } } creat ssl context ssl context = sslcontext . make ( root pool , valu , ssl . ssl mode server ) ; ( sslinsecur renegoti ) { boolean legaci reneg support = fals ; try { legaci reneg support = ssl . ha op ( ssl . ssl op allow unsaf legaci renegoti ) ; ( legaci reneg support ) sslcontext . set option ( ssl context , ssl . ssl op allow unsaf legaci renegoti ) ; } catch ( unsatisfi link error e ) { ignor } ( legaci reneg support ) { open ssl doe support unsaf legaci renegoti . log . warn ( sm . get string ( endpoint . warn . insecur reneg , ssl . version string ( ) ) ) ; } } set cipher order : client ( default ) server ( sslhonor cipher order ) { boolean order cipher support = fals ; try { order cipher support = ssl . ha op ( ssl . ssl op cipher server prefer ) ; ( order cipher support ) sslcontext . set option ( ssl context , ssl . ssl op cipher server prefer ) ; } catch ( unsatisfi link error e ) { ignor } ( order cipher support ) { open ssl doe support cipher order . log . warn ( sm . get string ( endpoint . warn . honor cipher order , ssl . version string ( ) ) ) ; } } disabl compress request ( ssldisabl compress ) { boolean disabl compress support = fals ; try { disabl compress support = ssl . ha op ( ssl . ssl op compress ) ; ( disabl compress support ) sslcontext . set option ( ssl context , ssl . ssl op compress ) ; } catch ( unsatisfi link error e ) { ignor } ( disabl compress support ) { open ssl doe support cipher order . log . warn ( sm . get string ( endpoint . warn . disabl compress , ssl . version string ( ) ) ) ; } } list cipher client permit negoti sslcontext . set cipher suit ( ssl context , sslcipher suit ) ; load server kei certif sslcontext . set certif ( ssl context , sslcertif file , sslcertif kei file , sslpassword , ssl . ssl aidx rsa ) ; set certif chain file sslcontext . set certif chain file ( ssl context , sslcertif chain file , fals ) ; support client certif sslcontext . set cacertif ( ssl context , sslcacertif file , sslcacertif path ) ; set revoc sslcontext . set carevoc ( ssl context , sslcarevoc file , sslcarevoc path ) ; client certif verif valu = ssl . ssl cverifi none ; ( option . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi option ; } els ( requir . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi requir ; } els ( option ca . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi option ca ; } sslcontext . set verifi ( ssl context , valu , sslverifi depth ) ; now , sendfil support ssl ( us sendfil ) { us sendfil = fals ; ( us send file set ) { log . warn ( sm . get string ( endpoint . apr . sendfil ssl ) ) ; } } } }
privat static valid xml view against tag librari valid class all import tag librari . void valid xml view ( page data xml view , compil compil ) throw jasper except { string builder err msg = null ; error dispatch err disp = compil . get error dispatch ( ) ; ( iter tag librari info iter = compil . get page info ( ) . get taglib ( ) . iter ( ) ; iter . ha next ( ) ; ) { object o = iter . next ( ) ; ( ( o instanceof tag librari info impl ) ) continu ; tag librari info impl tli = ( tag librari info impl ) o ; valid messag error = tli . valid ( xml view ) ; ( ( error = null ) ( error . length = 0 ) ) { ( err msg = = null ) { err msg = new string builder ( ) ; } err msg . append ( h3 ) ; err msg . append ( local . get messag ( jsp . error . tlv . invalid . page , tli . get short name ( ) , compil . get page info ( ) . get jsp file ( ) ) ) ; err msg . append ( h3 ) ; ( int i = 0 ; i error . length ; i ) { ( error i = null ) { err msg . append ( p ) ; err msg . append ( error i . get id ( ) ) ; err msg . append ( : ) ; err msg . append ( error i . get messag ( ) ) ; err msg . append ( p ) ; } } } } ( err msg = null ) { err disp . jsp error ( err msg . string ( ) ) ; } }	privat preprocess attribut can express . express delimit ar strip . p valu null , check ar ani name attribut subel tree node , so , construct jsp attribut out child name attribut node . node . jsp attribut get jsp attribut ( tag attribut info tai , string q name , string uri , string local name , string valu , node n , boolean dynam ) throw jasper except { node . jsp attribut result = null ; valid attribut valu xml ) . ( valu = null ) { ( n . get root ( ) . xml syntax ( ) valu . start ( = ) ) { result = new node . jsp attribut ( tai , q name , uri , local name , valu . substr ( 2 , valu . length ( ) 1 ) , true , null , dynam ) ; } els ( n . get root ( ) . xml syntax ( ) valu . start ( = ) ) { result = new node . jsp attribut ( tai , q name , uri , local name , valu . substr ( 3 , valu . length ( ) 2 ) , true , null , dynam ) ; } els ( page info . elignor ( ) ) { result = new node . jsp attribut ( tai , q name , uri , local name , valu , fals , null , dynam ) ; } els { attribut can contain express scriptlet express ; thu , we want run through express interpret valid express syntax string contain express ( s ) elnod . node el = elpars . pars ( valu , page info . defer syntax allow liter ( ) ) ; ( el . contain el ( ) ) { valid function ( el , n ) ; result = new node . jsp attribut ( tai , q name , uri , local name , valu , fals , el , dynam ) ; elcontext impl ctx = new elcontext impl ( express factori ) ; ctx . set function mapper ( get function mapper ( el ) ) ; try { result . valid el ( thi . page info . get express factori ( ) , ctx ) ; } catch ( elexcept e ) { thi . err . jsp error ( n . get start ( ) , jsp . error . invalid . express , valu , e . string ( ) ) ; } } els { result = new node . jsp attribut ( tai , q name , uri , local name , valu , fals , null , dynam ) ; } } } els { valu null . check ani name attribut subnod might contain valu thi attribut . otherwis , attribut wasn t found so we return null . node . name attribut name attribut node = n . get name attribut node ( q name ) ; ( name attribut node = null ) { result = new node . jsp attribut ( name attribut node , tai , dynam ) ; } } return result ; }	public void run ( ) throw except { do handl page except ( t ) ; return null ; }	public static object proprietari evalu ( final string express , final class expect type , final page context page context , final protect function mapper function map , final boolean escap ) throw elexcept { object ret valu ; final express factori expr factori = jspf . get jsp applic context ( page context . get servlet context ( ) ) . get express factori ( ) ; ( secur util . packag protect enabl ( ) ) { try { ret valu = access control . do privileg ( new privileg except action object ( ) { overrid public object run ( ) throw except { elcontext impl ctx = ( elcontext impl ) page context . get elcontext ( ) ; ctx . set function mapper ( function map ) ; valu express ve = expr factori . creat valu express ( ctx , express , expect type ) ; return ve . get valu ( ctx ) ; } } ) ; } catch ( privileg action except ex ) { except real ex = ex . get except ( ) ; ( real ex instanceof elexcept ) { throw ( elexcept ) real ex ; } els { throw new elexcept ( real ex ) ; } } } els { elcontext impl ctx = ( elcontext impl ) page context . get elcontext ( ) ; ctx . set function mapper ( function map ) ; valu express ve = expr factori . creat valu express ( ctx , express , expect type ) ; ret valu = ve . get valu ( ctx ) ; } ( escap ret valu = null ) { ret valu = xml escap ( ret valu . string ( ) ) ; } return ret valu ; }	test public void test bug55198 ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; file app dir = new file ( test webapp ) ; app dir rel server home tomcat . add webapp ( null , test , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; byte chunk re = get url ( http : localhost : get port ( ) test bug5nnnn bug55198 . jsp ) ; string result = re . string ( ) ; assert . assert true ( result . contain ( quot ; bar quot ; ) result . contain ( 034 ; bar 034 ; ) ) ; assert . assert true ( result . contain ( quot ; foo quot ; ) result . contain ( 034 ; foo 034 ; ) ) ; }
privat static void valid encod ( class extend encod encod ) throw deploy except { ( class extend encod encod : encod ) { need instanti decod ensur valid deploy can fail suppress warn ( unus ) encod instanc ; try { encod . new instanc ( ) ; } catch ( instanti except illeg access except e ) { throw new deploy except ( sm . get string ( server contain . encod fail , encod . get name ( ) ) , e ) ; } } }	privat void clear handler ( throwabl t ) { set result mark thi ( partial ) messag complet which mean next mai sent which could updat valu handler . therefor , keep local copi befor signal end ( partial ) messag . send handler sh = handler ; handler = null ; ( sh = null ) { ( t = = null ) { sh . result ( new send result ( ) ) ; } els { sh . result ( new send result ( t ) ) ; } } }	protect long get timeout expiri ( ) { return timeout expiri ; }	overrid protect void do close ( ) { ( handler = null ) { clear handler ( new eofexcept ( ) ) ; } try { so . close ( ) ; } catch ( ioexcept e ) { ( log . info enabl ( ) ) { log . info ( sm . get string ( ws remot endpoint server . close fail ) , e ) ; } } ws write timeout . unregist ( thi ) ; }	overrid protect void do write ( send handler handler , byte buffer . . . buffer ) { thi . handler = handler ; thi . buffer = buffer ; write possibl ( ) ; }	protect void timeout ( ) { ( handler = null ) { clear handler ( new socket timeout except ( ) ) ; } close ( ) ; }	overrid public int compar ( templat path match tpm1 , templat path match tpm2 ) { return tpm1 . get uri templat ( ) . get normal path ( ) . compar ( tpm2 . get uri templat ( ) . get normal path ( ) ) ; }	public void background process ( ) { thi method get call onc second . background process count ; ( background process count = process period ) { background process count = 0 ; long now = system . current time milli ( ) ; iter ws remot endpoint impl server iter = endpoint . iter ( ) ; while ( iter . ha next ( ) ) { ws remot endpoint impl server endpoint = iter . next ( ) ; ( endpoint . get timeout expiri ( ) now ) { endpoint . timeout ( ) ; } els { endpoint break ; } } } }	public void close authent session ( string http session id ) { set ws session ws session = authent session . remov ( http session id ) ; ( ws session = null ws session . empti ( ) ) { ( ws session ws session : ws session ) { try { ws session . close ( authent http session close ) ; } catch ( ioexcept e ) { ani ioexcept dure close have been caught error method call . } } } }	overrid public void context destroi ( servlet context event sce ) { servlet context sc = sce . get servlet context ( ) ; object obj = sc . get attribut ( constant . server contain servlet context attribut ) ; ( obj instanceof ws server contain ) { ( ( ws server contain ) obj ) . destroi ( ) ; } }	overrid public void write possibl ( ) { ws remot endpoint server . write possibl ( ) ; }	public void write possibl ( ) { boolean complet = true ; try { thi fals call back when true while ( so . readi ( ) ) { complet = true ; ( byte buffer buffer : buffer ) { ( buffer . ha remain ( ) ) { complet = fals ; so . write ( buffer . arrai ( ) , buffer . arrai offset ( ) , buffer . limit ( ) ) ; buffer . posit ( buffer . limit ( ) ) ; break ; } } ( complet ) { ws write timeout . unregist ( thi ) ; clear handler ( null ) ; ( close ) { close ( ) ; } break ; } } } catch ( ioexcept ioe ) { ws write timeout . unregist ( thi ) ; clear handler ( ioe ) ; close ( ) ; } ( complet ) { async write progress long timeout = get send timeout ( ) ; ( timeout 0 ) { regist timeout thread timeout expiri = timeout system . current time milli ( ) ; ws write timeout . regist ( thi ) ; } } }
privat follow workaround until problem ar resolv . input stream get resourc stream ( string uri ) throw file found except { uri absolut ( uri . start ( file : ) ) { return new file input stream ( new file ( uri . substr ( 5 ) ) ) ; } els { try { see file exist filesystem string real = ctxt . get real path ( uri ) ; ( real = = null ) { return ctxt . get resourc stream ( uri ) ; } els { return new file input stream ( real ) ; } } catch ( file found except ex ) { context return ctxt . get resourc stream ( uri ) ; } } }	overrid public string string ( ) { string writer sw = new string writer ( ) ; print writer out = new print writer ( sw ) ; print ( tlibvers , tlibvers , out ) ; print ( jspversion , jspversion , out ) ; print ( shortnam , shortnam , out ) ; print ( urn , urn , out ) ; print ( info , info , out ) ; print ( uri , uri , out ) ; print ( tag librari valid , tag librari valid , out ) ; ( int i = 0 ; i tag . length ; i ) out . println ( tag i . string ( ) ) ; ( int i = 0 ; i tag file . length ; i ) out . println ( tag file i . string ( ) ) ; ( int i = 0 ; i function . length ; i ) out . println ( function i . string ( ) ) ; return sw . string ( ) ; }
thread get thread ( ) { get current thread group thread group tg = thread . current thread ( ) . get thread group ( ) ; find root thread group while ( tg . get parent ( ) = null ) { tg = tg . get parent ( ) ; } int thread count guess = tg . activ count ( ) 50 ; thread thread = new thread thread count guess ; int thread count actual = tg . enumer ( thread ) ; make sure we don t miss ani thread while ( thread count actual = = thread count guess ) { thread count guess = 2 ; thread = new thread thread count guess ; note tg . enumer ( thread ) silent ignor ani thread can t fit arrai thread count actual = tg . enumer ( thread ) ; } return thread ; }
privat static thi method duplic code org . apach . el . util . reflect util . when make chang keep code sync . wrapper resolv ambigu wrapper ( set wrapper candid , class param type ) { identifi which paramet isn t exact match wrapper w = candid . iter ( ) . next ( ) ; int non match index = 0 ; class non match class = null ; ( int i = 0 ; i param type . length ; i ) { ( w . get paramet type ( ) i = param type i ) { non match index = i ; non match class = param type i ; break ; } } ( non match class = = null ) { null alwai ambigu return null ; } ( wrapper c : candid ) { ( c . get paramet type ( ) non match index = = param type non match index ) { result ambigu return null ; } } can t null class super class = non match class . get superclass ( ) ; while ( super class = null ) { ( wrapper c : candid ) { ( c . get paramet type ( ) non match index . equal ( super class ) ) { found match return c ; } } super class = super class . get superclass ( ) ; } treat instanc number special case wrapper match = null ; ( number . class . assign from ( non match class ) ) { ( wrapper c : candid ) { class candid type = c . get paramet type ( ) non match index ; ( number . class . assign from ( candid type ) candid type . primit ( ) ) { ( match = = null ) { match = c ; } els { match still ambigu match = null ; break ; } } } } return match ; }	overrid public void set valu ( elcontext context , object base , object properti , object valu ) { ( context = = null ) { throw new null pointer except ( ) ; } ( base = null base . get class ( ) . arrai ( ) ) { context . set properti resolv ( base , properti ) ; ( thi . read onli ) { throw new properti writabl except ( util . messag ( context , resolv writeabl , base . get class ( ) . get name ( ) ) ) ; } int idx = coerc ( properti ) ; check bound ( base , idx ) ; ( valu = null base . get class ( ) . get compon type ( ) . assign from ( valu . get class ( ) ) ) { throw new class cast except ( util . messag ( context , object assign , valu . get class ( ) . get name ( ) , base . get class ( ) . get compon type ( ) . get name ( ) ) ) ; } arrai . set ( base , idx , valu ) ; } }	test except thrown valu from correspond type . test ( expect = class cast except . class ) public void test set value07 ( ) { arrai elresolv resolv = new arrai elresolv ( ) ; elcontext context = new standard elcontext ( elmanag . get express factori ( ) ) ; string base = new string { element } ; resolv . set valu ( context , base , new integ ( 0 ) , new integ ( 1 ) ) ; }
public static set messag handler result get messag handler ( messag handler listen , endpoint config endpoint config ) { class target = util . get messag type ( listen ) ; never more than 2 type set messag handler result result = new hash set ( 2 ) ; frame handl code ( string . class . assign from ( target ) ) { messag handler result result = new messag handler result ( listen , messag handler result type . text ) ; result . add ( result ) ; } els ( byte buffer . class . assign from ( target ) ) { messag handler result result = new messag handler result ( listen , messag handler result type . binari ) ; result . add ( result ) ; } els ( pong messag . class . assign from ( target ) ) { messag handler result result = new messag handler result ( listen , messag handler result type . pong ) ; result . add ( result ) ; rel simpl case handler need wrap decod convert type expect frame handl code } els ( byte . class . assign from ( target ) ) { messag handler result result = new messag handler result ( new pojo messag handler whole binari ( listen , get messag method ( listen ) , null , endpoint config , null , new object 1 , 0 , true , 1 , fals , 1 ) , messag handler result type . binari ) ; result . add ( result ) ; } els ( input stream . class . assign from ( target ) ) { messag handler result result = new messag handler result ( new pojo messag handler whole binari ( listen , get messag method ( listen ) , null , endpoint config , null , new object 1 , 0 , true , 1 , true , 1 ) , messag handler result type . binari ) ; result . add ( result ) ; } els ( reader . class . assign from ( target ) ) { messag handler result result = new messag handler result ( new pojo messag handler whole text ( listen , get messag method ( listen ) , null , endpoint config , null , new object 1 , 0 , true , 1 , 1 ) , messag handler result type . text ) ; result . add ( result ) ; } els { more complex case listen requir decod decod match decod match ; try { list class extend decod >> decod = endpoint config . get decod ( ) ; suppress warn ( uncheck ) list decod entri decod entri = get decod ( decod . arrai ( new class decod . size ( ) ) ) ; decod match = new decod match ( target , decod entri ) ; } catch ( deploy except e ) { throw new illeg argument except ( e ) ; } method m = get messag method ( listen ) ; ( decod match . get binari decod ( ) . size ( ) 0 ) { messag handler result result = new messag handler result ( new pojo messag handler whole binari ( listen , m , null , endpoint config , decod match . get binari decod ( ) , new object 1 , 0 , fals , 1 , fals , 1 ) , messag handler result type . binari ) ; result . add ( result ) ; } ( decod match . get text decod ( ) . size ( ) 0 ) { messag handler result result = new messag handler result ( new pojo messag handler whole text ( listen , m , null , endpoint config , decod match . get text decod ( ) , new object 1 , 0 , fals , 1 , 1 ) , messag handler result type . text ) ; result . add ( result ) ; } } ( result . size ( ) = = 0 ) { throw new illeg argument except ( sm . get string ( ws session . unknown handler , listen , target ) ) ; } return result ; }	overrid public set messag handler get messag handler ( ) { check state ( ) ; set messag handler result = new hash set ( ) ; ( binari messag handler = null ) { result . add ( binari messag handler ) ; } ( text messag handler = null ) { result . add ( text messag handler ) ; } ( pong messag handler = null ) { result . add ( pong messag handler ) ; } return result ; }
privat int test event ( string name , int count ) throw interrupt except { int i = count ; while ( i 50 ) { ( server . life cycl event call ( name ) ) { break ; } i ; thread . sleep ( 100 ) ; } assert . assert true ( server . life cycl event call ( name ) ) ; return i ; }	privat static gener paramet , return either class us type unknown , index type definit class object get type paramet ( class clazz , type arg type ) { ( arg type instanceof class ) { return arg type ; } els { type variabl tv = clazz . get type paramet ( ) ; ( int i = 0 ; i tv . length ; i ) { ( tv i . equal ( arg type ) ) { return integ . valu ( i ) ; } } return null ; } }	overrid public boolean decod ( byte buffer bb ) { bb . mark ( ) ; ( bb . get ( ) = = 0x12 bb . get ( ) = = 0x34 ) { return true ; } bb . reset ( ) ; return fals ; }	overrid public void do someth ( boolean thing ) { op }	test public void test annot end point ( ) throw except { set up util class server server = new server ( ) ; singleton configur . set instanc ( server ) ; server config listen . set pojo clazz ( server . class ) ; tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; ctx . add applic listen ( new applic listen ( server config listen . class . get name ( ) , fals ) ) ; tomcat . add servlet ( ctx , default , new default servlet ( ) ) ; ctx . add servlet map ( , default ) ; web socket contain ws contain = contain provid . get web socket contain ( ) ; tomcat . start ( ) ; client client = new client ( ) ; uri uri = new uri ( ws : localhost : get port ( ) path annot ep ) ; session session = ws contain . connect server ( client , uri ) ; msg string msg1 = new msg string ( ) ; msg1 . set data ( messag ) ; session . get basic remot ( ) . send object ( msg1 ) ; should take veri long int i = 0 ; while ( i 20 ) { ( server . receiv . size ( ) 0 client . receiv . size ( ) 0 ) { break ; } thread . sleep ( 100 ) ; } check messag were receiv assert . assert equal ( 1 , server . receiv . size ( ) ) ; assert . assert equal ( 1 , client . receiv . size ( ) ) ; check correct messag were receiv assert . assert equal ( messag , ( ( msg string ) server . receiv . peek ( ) ) . get data ( ) ) ; assert . assert equal ( messag , ( ( msg string ) client . receiv . peek ( ) ) . get data ( ) ) ; session . close ( ) ; should take veri long some failur have been seen i = test event ( msg string encod . class . get name ( ) : init , 0 ) ; i = test event ( msg string decod . class . get name ( ) : init , i ) ; i = test event ( msg byte encod . class . get name ( ) : init , i ) ; i = test event ( msg byte decod . class . get name ( ) : init , i ) ; i = test event ( msg string encod . class . get name ( ) : destroi , i ) ; i = test event ( msg string decod . class . get name ( ) : destroi , i ) ; i = test event ( msg byte encod . class . get name ( ) : destroi , i ) ; i = test event ( msg byte decod . class . get name ( ) : destroi , i ) ; }	test public void test get encod type gener multipl subclass swap ( ) { assert . assert equal ( string . class , util . get encod type ( gener multipl sub sub swap encod . class ) ) ; }	privat static t object get gener type ( class t type , class extend t clazz ) { look see thi class implement gener messag handler interfac get all interfac type interfac = clazz . get gener interfac ( ) ; ( type ifac : interfac ) { onli need check interfac us gener ( ifac instanceof parameter type ) { parameter type pi = ( parameter type ) ifac ; look messag handler interfac ( pi . get raw type ( ) instanceof class ) { ( type . assign from ( ( class ) pi . get raw type ( ) ) ) { return get type paramet ( clazz , pi . get actual type argument ( ) 0 ) ; } } } } interfac found thi class . look superclass . suppress warn ( uncheck ) class extend t super clazz = ( class extend t ) clazz . get superclass ( ) ; object result = get gener type ( type , super clazz ) ; ( result instanceof class ) { messag handler return result ; } els ( result instanceof integ ) { superclass implement interfac defin unknown type messag handler map unknown type gener type defin thi class parameter type super class type = ( parameter type ) clazz . get gener superclass ( ) ; return get type paramet ( clazz , super class type . get actual type argument ( ) ( ( integ ) result ) . int valu ( ) ) ; } els { error log further up call stack return null ; } }
protect creat configur digest we us startup . digest creat start digest ( ) { long t1 = system . current time milli ( ) ; initi digest digest digest = new digest ( ) ; digest . set valid ( fals ) ; digest . set rule valid ( true ) ; hash map class , list string >> fake attribut = new hash map ( ) ; arrai list string attr = new arrai list ( ) ; attr . add ( class name ) ; fake attribut . put ( object . class , attr ) ; digest . set fake attribut ( fake attribut ) ; digest . set class loader ( standard server . class . get class loader ( ) ) ; configur action we us digest . add object creat ( server , org . apach . catalina . core . standard server , class name ) ; digest . add set properti ( server ) ; digest . add set next ( server , set server , org . apach . catalina . server ) ; digest . add object creat ( server global name resourc , org . apach . catalina . deploi . name resourc impl ) ; digest . add set properti ( server global name resourc ) ; digest . add set next ( server global name resourc , set global name resourc , org . apach . catalina . deploi . name resourc impl ) ; digest . add object creat ( server listen , must specifi element null , class name ) ; digest . add set properti ( server listen ) ; digest . add set next ( server listen , add lifecycl listen , org . apach . catalina . lifecycl listen ) ; digest . add object creat ( server servic , org . apach . catalina . core . standard servic , class name ) ; digest . add set properti ( server servic ) ; digest . add set next ( server servic , add servic , org . apach . catalina . servic ) ; digest . add object creat ( server servic listen , must specifi element null , class name ) ; digest . add set properti ( server servic listen ) ; digest . add set next ( server servic listen , add lifecycl listen , org . apach . catalina . lifecycl listen ) ; executor digest . add object creat ( server servic executor , org . apach . catalina . core . standard thread executor , class name ) ; digest . add set properti ( server servic executor ) ; digest . add set next ( server servic executor , add executor , org . apach . catalina . executor ) ; digest . add rule ( server servic connector , new connector creat rule ( ) ) ; digest . add rule ( server servic connector , new set all properti rule ( new string { executor } ) ) ; digest . add set next ( server servic connector , add connector , org . apach . catalina . connector . connector ) ; digest . add object creat ( server servic connector listen , must specifi element null , class name ) ; digest . add set properti ( server servic connector listen ) ; digest . add set next ( server servic connector listen , add lifecycl listen , org . apach . catalina . lifecycl listen ) ; add rule set nest element digest . add rule set ( new name rule set ( server global name resourc ) ) ; digest . add rule set ( new engin rule set ( server servic ) ) ; digest . add rule set ( new host rule set ( server servic engin ) ) ; digest . add rule set ( new context rule set ( server servic engin host ) ) ; add cluster rule set ( digest , server servic engin host cluster ) ; digest . add rule set ( new name rule set ( server servic engin host context ) ) ; when engin found , set parent class loader . digest . add rule ( server servic engin , new set parent class loader rule ( parent class loader ) ) ; add cluster rule set ( digest , server servic engin cluster ) ; long t2 = system . current time milli ( ) ; ( log . debug enabl ( ) ) { log . debug ( digest server . xml creat ( t2 t1 ) ) ; } return ( digest ) ; }	protect creat configur digest we us shutdown . digest creat stop digest ( ) { initi digest digest digest = new digest ( ) ; configur rule we need shut down digest . add object creat ( server , org . apach . catalina . core . standard server , class name ) ; digest . add set properti ( server ) ; digest . add set next ( server , set server , org . apach . catalina . server ) ; return ( digest ) ; }	public void stop server ( string argument ) { ( argument = null ) { argument ( argument ) ; } server s = get server ( ) ; ( s = = null ) { creat execut our digest digest digest = creat stop digest ( ) ; digest . set class loader ( thread . current thread ( ) . get context class loader ( ) ) ; file file = config file ( ) ; file input stream fi = null ; try { input sourc = new input sourc ( file . uri ( ) . url ( ) . string ( ) ) ; fi = new file input stream ( file ) ; . set byte stream ( fi ) ; digest . push ( thi ) ; digest . pars ( ) ; } catch ( except e ) { log . error ( catalina . stop : , e ) ; system . exit ( 1 ) ; } final { ( fi = null ) { try { fi . close ( ) ; } catch ( ioexcept e ) { ignor } } } } els { server object alreadi present . must run servic try { s . stop ( ) ; } catch ( lifecycl except e ) { log . error ( catalina . stop : , e ) ; } return ; } stop exist server s = get server ( ) ; ( s . get port ( ) 0 ) { socket socket = null ; output stream stream = null ; try { socket = new socket ( s . get address ( ) , s . get port ( ) ) ; stream = socket . get output stream ( ) ; string shutdown = s . get shutdown ( ) ; ( int i = 0 ; i shutdown . length ( ) ; i ) { stream . write ( shutdown . char ( i ) ) ; } stream . flush ( ) ; } catch ( connect except ce ) { log . error ( sm . get string ( catalina . stop server . connect except , s . get address ( ) , string . valu ( s . get port ( ) ) ) ) ; log . error ( catalina . stop : , ce ) ; system . exit ( 1 ) ; } catch ( ioexcept e ) { log . error ( catalina . stop : , e ) ; system . exit ( 1 ) ; } final { ( stream = null ) { try { stream . close ( ) ; } catch ( ioexcept e ) { ignor } } ( socket = null ) { try { socket . close ( ) ; } catch ( ioexcept e ) { ignor } } } } els { log . error ( sm . get string ( catalina . stop server ) ) ; system . exit ( 1 ) ; } }
protect check none match condit satisfi . param request servlet request we ar process param respons servlet respons we ar creat param resourc resourc return boolean true resourc meet specifi condit , fals condit satisfi , which case request process stop boolean check none match ( http servlet request request , http servlet respons respons , web resourc resourc ) throw ioexcept { string e tag = resourc . get etag ( ) ; string header valu = request . get header ( none match ) ; ( header valu = null ) { boolean condit satisfi = fals ; ( header valu . equal ( ) ) { string token comma token = new string token ( header valu , , ) ; while ( condit satisfi comma token . ha more token ( ) ) { string current token = comma token . next token ( ) ; ( current token . trim ( ) . equal ( e tag ) ) condit satisfi = true ; } } els { condit satisfi = true ; } ( condit satisfi ) { back . ( ( get . equal ( request . get method ( ) ) ) ( head . equal ( request . get method ( ) ) ) ) { respons . set statu ( http servlet respons . sc modifi ) ; respons . set header ( etag , e tag ) ; return fals ; } respons . send error ( http servlet respons . sc precondit fail ) ; return fals ; } } return true ; }	protect serv specifi resourc , option includ data content . param request servlet request we ar process param respons servlet respons we ar creat param content should content includ param encod encod us necessari access sourc charact rather than byte except ioexcept input output error occur except servlet except servlet specifi error occur void serv resourc ( http servlet request request , http servlet respons respons , boolean content , string encod ) throw ioexcept , servlet except { boolean serv content = content ; identifi request resourc path string path = get rel path ( request ) ; ( debug 0 ) { ( serv content ) log ( default servlet . serv resourc : serv resourc path header data ) ; els log ( default servlet . serv resourc : serv resourc path header onli ) ; } web resourc resourc = resourc . get resourc ( path ) ; ( resourc . exist ( ) ) { check we re includ so we can return appropri miss resourc name error string request uri = ( string ) request . get attribut ( request dispatch . includ request uri ) ; ( request uri = = null ) { request uri = request . get request uri ( ) ; } els { srv . 9 . 3 sai we must throw fnfe throw new file found except ( sm . get string ( default servlet . miss resourc , request uri ) ) ; } respons . send error ( http servlet respons . sc found , request uri ) ; return ; } end , return found ( resourc . file ( ) ) { ( path . end ( ) ( path . end ( ) ) ) { check we re includ so we can return appropri miss resourc name error string request uri = ( string ) request . get attribut ( request dispatch . includ request uri ) ; ( request uri = = null ) { request uri = request . get request uri ( ) ; } respons . send error ( http servlet respons . sc found , request uri ) ; return ; } } boolean error = respons . get statu ( ) = http servlet respons . sc bad request ; satisfi . ( resourc . file ( ) ) { check header boolean includ = ( request . get attribut ( request dispatch . includ context path ) = null ) ; ( includ error check header ( request , respons , resourc ) ) { return ; } } find content type . string content type = resourc . get mime type ( ) ; ( content type = = null ) { content type = get servlet context ( ) . get mime type ( resourc . get name ( ) ) ; resourc . set mime type ( content type ) ; } arrai list rang rang = null ; long content length = 1l ; ( resourc . directori ( ) ) { suppress them ( list ) { respons . send error ( http servlet respons . sc found , request . get request uri ( ) ) ; return ; } content type = text html ; charset = utf 8 ; } els { ( error ) { ( us accept rang ) { accept rang header respons . set header ( accept rang , byte ) ; } pars rang specifi rang = pars rang ( request , respons , resourc ) ; etag header respons . set header ( etag , resourc . get etag ( ) ) ; last modifi header respons . set header ( last modifi , resourc . get last modifi http ( ) ) ; } get content length content length = resourc . get content length ( ) ; ( silent ) when set output buffer size ( content length = = 0l ) { serv content = fals ; } } servlet output stream ostream = null ; print writer writer = null ; ( serv content ) { try retriev servlet output stream try { ostream = respons . get output stream ( ) ; } catch ( illeg state except e ) { try serv text file ( ( content type = = null ) ( content type . start ( text ) ) ( content type . end ( xml ) ) ( content type . contain ( javascript ) ) ) { writer = respons . get writer ( ) ; cannot reliabl serv partial content writer rang = full ; } els { throw e ; } } } check see filter , valv wrapper ha written some content . ha , disabl rang request set content length sinc neither can done reliabl . servlet respons r = respons ; long content written = 0 ; while ( r instanceof servlet respons wrapper ) { r = ( ( servlet respons wrapper ) r ) . get respons ( ) ; } ( r instanceof respons facad ) { content written = ( ( respons facad ) r ) . get content written ( ) ; } ( content written 0 ) { rang = full ; } ( resourc . directori ( ) error ( ( rang = = null rang . empti ( ) ) request . get header ( rang ) = = null ) rang = = full ) { set appropri output header ( content type = null ) { ( debug 0 ) log ( default servlet . serv file : content type = content type ) ; respons . set content type ( content type ) ; } ( resourc . file ( ) content length = 0 ( serv content ostream = null ) ) { ( debug 0 ) log ( default servlet . serv file : content length = content length ) ; written respons . ( content written = = 0 ) { respons . set content length long ( content length ) ; } } input stream render result = null ; ( resourc . directori ( ) ) { ( serv content ) { serv directori browser render result = render ( get path prefix ( request ) , resourc ) ; } } copi input stream our output stream ( request ) ( serv content ) { try { respons . set buffer size ( output ) ; } catch ( illeg state except e ) { silent catch } ( ostream = null ) { ( check sendfil ( request , respons , resourc , content length , null ) ) copi ( resourc , render result , ostream ) ; } els { copi ( resourc , render result , writer , encod ) ; } } } els { ( ( rang = = null ) ( rang . empti ( ) ) ) return ; partial content respons . respons . set statu ( http servlet respons . sc partial content ) ; ( rang . size ( ) = = 1 ) { rang rang = rang . get ( 0 ) ; respons . add header ( content rang , byte rang . start rang . end rang . length ) ; long length = rang . end rang . start 1 ; respons . set content length long ( length ) ; ( content type = null ) { ( debug 0 ) log ( default servlet . serv file : content type = content type ) ; respons . set content type ( content type ) ; } ( serv content ) { try { respons . set buffer size ( output ) ; } catch ( illeg state except e ) { silent catch } ( ostream = null ) { ( check sendfil ( request , respons , resourc , rang . end rang . start 1 , rang ) ) copi ( resourc , ostream , rang ) ; } els { we should get here throw new illeg state except ( ) ; } } } els { respons . set content type ( multipart byterang ; boundari = mime separ ) ; ( serv content ) { try { respons . set buffer size ( output ) ; } catch ( illeg state except e ) { silent catch } ( ostream = null ) { copi ( resourc , ostream , rang . iter ( ) , content type ) ; } els { we should get here throw new illeg state except ( ) ; } } } } }	overrid public boolean respons bodi ok ( ) { return true ; }	initi thi servlet . overrid public void init ( ) throw servlet except { ( get servlet config ( ) . get init paramet ( debug ) = null ) debug = integ . pars int ( get servlet config ( ) . get init paramet ( debug ) ) ; ( get servlet config ( ) . get init paramet ( input ) = null ) input = integ . pars int ( get servlet config ( ) . get init paramet ( input ) ) ; ( get servlet config ( ) . get init paramet ( output ) = null ) output = integ . pars int ( get servlet config ( ) . get init paramet ( output ) ) ; list = boolean . pars boolean ( get servlet config ( ) . get init paramet ( list ) ) ; ( get servlet config ( ) . get init paramet ( readonli ) = null ) read onli = boolean . pars boolean ( get servlet config ( ) . get init paramet ( readonli ) ) ; ( get servlet config ( ) . get init paramet ( sendfil size ) = null ) sendfil size = integ . pars int ( get servlet config ( ) . get init paramet ( sendfil size ) ) 1024 ; file encod = get servlet config ( ) . get init paramet ( file encod ) ; global xslt file = get servlet config ( ) . get init paramet ( global xslt file ) ; context xslt file = get servlet config ( ) . get init paramet ( context xslt file ) ; local xslt file = get servlet config ( ) . get init paramet ( local xslt file ) ; readm file = get servlet config ( ) . get init paramet ( readm file ) ; ( get servlet config ( ) . get init paramet ( us accept rang ) = null ) us accept rang = boolean . pars boolean ( get servlet config ( ) . get init paramet ( us accept rang ) ) ; saniti check specifi buffer size ( input 256 ) input = 256 ; ( output 256 ) output = 256 ; ( debug 0 ) { log ( default servlet . init : input buffer size = input , output buffer size = output ) ; } load web resourc resourc = ( web resourc root ) get servlet context ( ) . get attribut ( global . resourc attr ) ; ( resourc = = null ) { throw new unavail except ( resourc ) ; } }	public void test get special ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; string context path = exampl ; file app dir = new file ( get build directori ( ) , webapp context path ) ; app dir rel server home tomcat . add webapp ( null , exampl , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; final byte chunk re = new byte chunk ( ) ; int rc = get url ( http : localhost : get port ( ) context path web inf web . xml , re , null ) ; assert equal ( http servlet respons . sc found , rc ) ; rc = get url ( http : localhost : get port ( ) context path web inf doesntexistanywher , re , null ) ; assert equal ( http servlet respons . sc found , rc ) ; rc = get url ( http : localhost : get port ( ) context path web inf , re , null ) ; assert equal ( http servlet respons . sc found , rc ) ; rc = get url ( http : localhost : get port ( ) context path meta inf manifest . mf , re , null ) ; assert equal ( http servlet respons . sc found , rc ) ; rc = get url ( http : localhost : get port ( ) context path meta inf doesntexistanywher , re , null ) ; assert equal ( http servlet respons . sc found , rc ) ; }
protect string next file ( ) { ( fullstop ) arg po ; ( arg po = arg . length ) { return null ; } els { return arg arg po ; } }	protect void init web xml ( ) { try { ( webxml level = inc webxml ) { mapout = open webxml writer ( new file ( webxml file ) ) ; servletout = new char arrai writer ( ) ; mappingout = new char arrai writer ( ) ; } els { mapout = null ; servletout = null ; mappingout = null ; } ( webxml level = all webxml ) { mapout . write ( local . get messag ( jspc . webxml . header ) ) ; mapout . flush ( ) ; } els ( ( webxml level = inc webxml ) add web xml map ) { mapout . write ( local . get messag ( jspc . webinc . header ) ) ; mapout . flush ( ) ; } } catch ( ioexcept ioe ) { mapout = null ; servletout = null ; mappingout = null ; } }
public return true valu string liter known translat time . boolean liter ( ) { return express ( el = null ) name attribut ; }
public static void releas ( class loader class loader ) { iter urlstream handler factori iter = instanc . user factori . iter ( ) ; while ( iter . ha next ( ) ) { class loader factori loader = iter . next ( ) . get class ( ) . get class loader ( ) ; while ( factori loader = null ) { ( class loader . equal ( factori loader ) ) { iter . remov ( ) ; break ; } factori loader = factori loader . get parent ( ) ; } } }	public static tomcat urlstream handler factori get instanc ( ) { return instanc ; }	public static regist thi factori jvm . mai call more than onc . implement ensur registr onli occur onc . void regist ( ) { call thi method load thi class which turn trigger all necessari registr . }	public static releas refer ani user provid factori have been load us provid class loader . call dure web applic stop prevent memori leak . void releas ( class loader class loader ) { iter urlstream handler factori iter = instanc . user factori . iter ( ) ; while ( iter . ha next ( ) ) { class loader factori loader = iter . next ( ) . get class ( ) . get class loader ( ) ; while ( factori loader = null ) { ( class loader . equal ( factori loader ) ) { iter . remov ( ) ; break ; } factori loader = factori loader . get parent ( ) ; } } }
final thi servlet . overrid public void destroi ( ) { action necessari }
protect find specifi resourc local repositori . return load resourc , null resourc isn t found resourc entri find resourc intern ( string name , string path ) { ( start ) { log . info ( sm . get string ( webapp class loader . stop , name ) ) ; return null ; } ( ( name = = null ) ( path = = null ) ) return null ; resourc entri entri = resourc entri . get ( name ) ; ( entri = null ) return entri ; int content length = 1 ; input stream binari stream = null ; boolean class resourc = path . end ( . class ) ; int jar file length = jar file . length ; web resourc resourc = null ; boolean file need convert = fals ; ( repositori path = null ) { string full path = repositori path path ; resourc = resourc . get resourc ( full path ) ; ( resourc . exist ( ) ) { content length = ( int ) resourc . get content length ( ) ; entri = new resourc entri ( ) ; entri . sourc = resourc . get url ( ) ; entri . code base = entri . sourc ; entri . last modifi = resourc . get last modifi ( ) ; binari stream = resourc . get input stream ( ) ; ( need convert ) { ( path . end ( . properti ) ) { file need convert = true ; } } note : onli sync constant object need synchron ( all permiss ) { int j ; long result2 = new long last modifi date . length 1 ; ( j = 0 ; j last modifi date . length ; j ) { result2 j = last modifi date j ; } result2 last modifi date . length = entri . last modifi ; last modifi date = result2 ; string result = new string path . length 1 ; ( j = 0 ; j path . length ; j ) { result j = path j ; } result path . length = full path ; path = result ; } } } ( ( entri = = null ) ( found resourc . contain kei ( name ) ) ) return null ; jar entri jar entri = null ; synchron ( jar file ) { try { ( open jar ( ) ) { return null ; } ( int i = 0 ; ( entri = = null ) ( i jar file length ) ; i ) { jar entri = jar file i . get jar entri ( path ) ; ( jar entri = null ) { entri = new resourc entri ( ) ; try { entri . code base = get uri ( jar real file i ) ; string jar fake url = entri . code base . string ( ) ; jar fake url = jar : jar fake url path ; entri . sourc = new url ( jar fake url ) ; entri . last modifi = jar real file i . last modifi ( ) ; } catch ( malform urlexcept e ) { return null ; } content length = ( int ) jar entri . get size ( ) ; try { entri . manifest = jar file i . get manifest ( ) ; binari stream = jar file i . get input stream ( jar entri ) ; } catch ( ioexcept e ) { return null ; } extract resourc contain jar workdir ( anti jarlock ( path . end ( . class ) ) ) { byte buf = new byte 1024 ; file resourc file = new file ( loader dir , jar entri . get name ( ) ) ; ( resourc file . exist ( ) ) { enumer jar entri entri = jar file i . entri ( ) ; while ( entri . ha more element ( ) ) { jar entri jar entry2 = entri . next element ( ) ; ( ( jar entry2 . directori ( ) ) ( jar entry2 . get name ( ) . end ( . class ) ) ) { resourc file = new file ( loader dir , jar entry2 . get name ( ) ) ; try { ( resourc file . get canon path ( ) . start ( canon loader dir ) ) { throw new illeg argument except ( sm . get string ( webapp class loader . illeg jar path , jar entry2 . get name ( ) ) ) ; } } catch ( ioexcept ioe ) { throw new illeg argument except ( sm . get string ( webapp class loader . valid error jar path , jar entry2 . get name ( ) ) , ioe ) ; } file parent file = resourc file . get parent file ( ) ; ( parent file . mkdir ( ) parent file . exist ( ) ) { ignor error ( like ioexcept below ) } file output stream os = null ; input stream = null ; try { = jar file i . get input stream ( jar entry2 ) ; os = new file output stream ( resourc file ) ; while ( true ) { int n = . read ( buf ) ; ( n = 0 ) { break ; } os . write ( buf , 0 , n ) ; } resourc file . set last modifi ( jar entry2 . get time ( ) ) ; } catch ( ioexcept e ) { ignor } final { try { ( = null ) { . close ( ) ; } } catch ( ioexcept e ) { ignor } try { ( os = null ) { os . close ( ) ; } } catch ( ioexcept e ) { ignor } } } } } } } } ( entri = = null ) { synchron ( found resourc ) { found resourc . put ( name , name ) ; } return null ; } onli cach binari content some content avail either : ) class file sinc binari content onli cach until class ha been load b ) file need convers address encod issu ( see below ) all other case do cach content prevent excess memori usag larg resourc ar present ( see http : issu . apach . org bugzilla show bug . cgi id = 53081 ) . ( binari stream = null ( class resourc file need convert ) ) { byte binari content = new byte content length ; int po = 0 ; try { while ( true ) { int n = binari stream . read ( binari content , po , binari content . length po ) ; ( n = 0 ) break ; po = n ; } } catch ( ioexcept e ) { log . error ( sm . get string ( webapp class loader . read error , name ) , e ) ; return null ; } ( file need convert ) { workaround certain file platform us ebcdic encod , when thei ar read through file input stream . see commit messag rev . 303915 detail http : svn . apach . org viewvc view = revis revis = 303915 string str = new string ( binari content , 0 , po ) ; try { binari content = str . get byte ( standard charset . utf 8 ) ; } catch ( except e ) { return null ; } } entri . binari content = binari content ; associ input stream ha been fulli read ( jar entri = null ) { entri . certif = jar entri . get certif ( ) ; } } } final { ( binari stream = null ) { try { binari stream . close ( ) ; } catch ( ioexcept e ) { ignor } } } } add entri local resourc repositori synchron ( resourc entri ) { ensur all thread which mai race load particular class all end up same resourc entri instanc resourc entri entry2 = resourc entri . get ( name ) ; ( entry2 = = null ) { resourc entri . put ( name , entri ) ; } els { entri = entry2 ; } } return entri ; }	protect find specifi class local repositori . return load class , null class isn t found class find class intern ( string name ) throw class found except { ( valid ( name ) ) throw new class found except ( name ) ; string temp path = name . replac ( . , ) ; string class path = temp path . class ; resourc entri entri = null ; ( secur manag = null ) { privileg action resourc entri dp = new privileg find resourc name ( name , class path ) ; entri = access control . do privileg ( dp ) ; } els { entri = find resourc intern ( name , class path ) ; } ( entri = = null ) throw new class found except ( name ) ; class clazz = entri . load class ; ( clazz = null ) return clazz ; synchron ( thi ) { clazz = entri . load class ; ( clazz = null ) return clazz ; ( entri . binari content = = null ) throw new class found except ( name ) ; look up packag string packag name = null ; int po = name . last index ( . ) ; ( po = 1 ) packag name = name . substr ( 0 , po ) ; packag pkg = null ; ( packag name = null ) { pkg = get packag ( packag name ) ; defin packag ( null ) ( pkg = = null ) { try { ( entri . manifest = = null ) { defin packag ( packag name , null , null , null , null , null , null , null ) ; } els { defin packag ( packag name , entri . manifest , entri . code base ) ; } } catch ( illeg argument except e ) { ignor : normal error due dual definit packag } pkg = get packag ( packag name ) ; } } ( secur manag = null ) { check seal ( pkg = null ) { boolean seal check = true ; ( pkg . seal ( ) ) { seal check = pkg . seal ( entri . code base ) ; } els { seal check = ( entri . manifest = = null ) packag seal ( packag name , entri . manifest ) ; } ( seal check ) throw new secur except ( seal violat load name : packag packag name seal . ) ; } } try { clazz = defin class ( name , entri . binari content , 0 , entri . binari content . length , new code sourc ( entri . code base , entri . certif ) ) ; } catch ( unsupport class version error ucv ) { throw new unsupport class version error ( ucv . get local messag ( ) sm . get string ( webapp class loader . wrong version , name ) ) ; } entri . load class = clazz ; entri . binari content = null ; entri . sourc = null ; entri . code base = null ; entri . manifest = null ; entri . certif = null ; } return clazz ; }	protect check specifi jar file , return code true code doe contain ani trigger class . param file jar file check except ioexcept input output error occur boolean valid jar file ( file file ) throw ioexcept { ( trigger = = null ) return ( true ) ; jar file jar file = null ; try { jar file = new jar file ( file ) ; ( int i = 0 ; i trigger . length ; i ) { class clazz = null ; try { ( parent = null ) { clazz = parent . load class ( trigger i ) ; } els { clazz = class . name ( trigger i ) ; } } catch ( except e ) { clazz = null ; } ( clazz = = null ) continu ; string name = trigger i . replac ( . , ) . class ; ( log . debug enabl ( ) ) log . debug ( check name ) ; jar entri jar entri = jar file . get jar entri ( name ) ; ( jar entri = null ) { log . info ( valid jar file ( file ) jar load . see servlet spec 2 . 3 , section 9 . 7 . 2 . offend class : name ) ; return fals ; } } return true ; } final { ( jar file = null ) { try { jar file . close ( ) ; } catch ( ioexcept ioe ) { ignor } } } }	find specifi class our local repositori , possibl . found , throw code class found except code . param name name class load except class found except class wa found overrid public class find class ( string name ) throw class found except { ( log . debug enabl ( ) ) log . debug ( find class ( name ) ) ; cannot load anyth from local repositori class loader stop ( start ) { throw new class found except ( name ) ; } ( 1 ) permiss defin thi class when us secur manag ( secur manag = null ) { int i = name . last index ( . ) ; ( i = 0 ) { try { ( log . trace enabl ( ) ) log . trace ( secur manag . check packag definit ) ; secur manag . check packag definit ( name . substr ( 0 , i ) ) ; } catch ( except se ) { ( log . trace enabl ( ) ) log . trace ( except class found except , se ) ; throw new class found except ( name , se ) ; } } } ask our superclass locat thi class , possibl ( throw class found except found ) class clazz = null ; try { ( log . trace enabl ( ) ) log . trace ( find class intern ( name ) ) ; try { clazz = find class intern ( name ) ; } catch ( class found except cnfe ) { ( log . debug enabl ( ) ) log . debug ( return class found except ) ; throw cnfe ; } catch ( access control except ac ) { log . warn ( webapp class loader . find class intern ( name ) secur except : ac . get messag ( ) , ac ) ; throw new class found except ( name , ac ) ; } catch ( runtim except e ) { ( log . trace enabl ( ) ) log . trace ( runtim except rethrown , e ) ; throw e ; } } catch ( class found except e ) { ( log . trace enabl ( ) ) log . trace ( pass class found except ) ; throw e ; } return class we have locat ( log . trace enabl ( ) ) log . debug ( return class clazz ) ; ( log . trace enabl ( ) ) { class loader cl ; ( global . secur enabl ) { cl = access control . do privileg ( new privileg get class loader ( clazz ) ) ; } els { cl = clazz . get class loader ( ) ; } log . debug ( load cl . string ( ) ) ; } return ( clazz ) ; }	find resourc given name . resourc some data ( imag , audio , text , etc . ) can access class code wai independ locat code . name resourc separ path name identifi resourc . resourc cannot found , return code null code . p thi method search accord follow algorithm , return soon find appropri url . resourc cannot found , return code null code . ul li code deleg code properti set code true code , call code get resourc ( ) code method parent class loader , ani . li li call code find resourc ( ) code find thi resourc our local defin repositori . li li call code get resourc ( ) code method parent class loader , ani . li ul param name name resourc return url overrid public url get resourc ( string name ) { ( log . debug enabl ( ) ) log . debug ( get resourc ( name ) ) ; url url = null ; ( 1 ) deleg parent request ( deleg ) { ( log . debug enabl ( ) ) log . debug ( deleg parent classload parent ) ; class loader loader = parent ; ( loader = = null ) loader = system ; url = loader . get resourc ( name ) ; ( url = null ) { ( log . debug enabl ( ) ) log . debug ( return url . string ( ) ) ; return ( url ) ; } } ( 2 ) search local repositori url = find resourc ( name ) ; ( url = null ) { jar ( anti jarlock ) { resourc entri entri = resourc entri . get ( name ) ; try { string repositori = entri . code base . string ( ) ; ( ( repositori . end ( . jar ) ) ( ( name . end ( . class ) ) ) ) { copi binari content work directori present file resourc file = new file ( loader dir , name ) ; url = get uri ( resourc file ) ; } } catch ( except e ) { ignor } } ( log . debug enabl ( ) ) log . debug ( return url . string ( ) ) ; return ( url ) ; } ( 3 ) deleg parent uncondition alreadi attempt ( deleg ) { class loader loader = parent ; ( loader = = null ) loader = system ; url = loader . get resourc ( name ) ; ( url = null ) { ( log . debug enabl ( ) ) log . debug ( return url . string ( ) ) ; return ( url ) ; } } ( 4 ) resourc wa found ( log . debug enabl ( ) ) log . debug ( resourc found , return null ) ; return ( null ) ; }	public set clear refer http client keep aliv thread featur thi context . param clear refer http client keep aliv thread new flag valu void set clear refer http client keep aliv thread ( boolean clear refer http client keep aliv thread ) { thi . clear refer http client keep aliv thread = clear refer http client keep aliv thread ; }

compil load tagfil . class load tag file ( compil compil , string tag file path , tag info tag info , page info parent page info ) throw jasper except { jar resourc tag jar resouc = null ; ( tag file path . start ( meta inf ) ) { tag jar resouc = compil . get compil context ( ) . get tld locat ( tag info . get tag librari ( ) . get uri ( ) ) . get jar resourc ( ) ; } string wrapper uri ; ( tag jar resouc = = null ) { wrapper uri = tag file path ; } els { wrapper uri = tag jar resouc . get entri ( tag file path ) . string ( ) ; } jsp compil context ctxt = compil . get compil context ( ) ; jsp runtim context rctxt = ctxt . get runtim context ( ) ; jsp servlet wrapper wrapper = rctxt . get wrapper ( wrapper uri ) ; synchron ( rctxt ) { ( wrapper = = null ) { wrapper = new jsp servlet wrapper ( ctxt . get servlet context ( ) , ctxt . get option ( ) , tag file path , tag info , ctxt . get runtim context ( ) , tag jar resouc ) ; rctxt . add wrapper ( wrapper uri , wrapper ) ; us same classload classpath compil tag file wrapper . get jsp engin context ( ) . set class loader ( ctxt . get class loader ( ) ) ; wrapper . get jsp engin context ( ) . set class path ( ctxt . get class path ( ) ) ; } els { make sure jsp compil context get latest tag info tag file . tag info instanc wa creat last time tag file wa scan direct , tag file mai have been modifi sinc . wrapper . get jsp engin context ( ) . set tag info ( tag info ) ; } class tag clazz ; int trip count = wrapper . inc trip count ( ) ; try { ( trip count 0 ) { when trip count greater than zero , circular depend exist . circularli depend tag file compil prototyp mode , avoid infinit recurs . jsp servlet wrapper temp wrapper = new jsp servlet wrapper ( ctxt . get servlet context ( ) , ctxt . get option ( ) , tag file path , tag info , ctxt . get runtim context ( ) , ctxt . get tag file jar resourc ( tag file path ) ) ; us same classload classpath compil tag file temp wrapper . get jsp engin context ( ) . set class loader ( ctxt . get class loader ( ) ) ; temp wrapper . get jsp engin context ( ) . set class path ( ctxt . get class path ( ) ) ; tag clazz = temp wrapper . load tag file prototyp ( ) ; temp vector . add ( temp wrapper . get jsp engin context ( ) . get compil ( ) ) ; } els { tag clazz = wrapper . load tag file ( ) ; } } final { wrapper . dec trip count ( ) ; } can onli obtain from tag instanc . try { object tag = tag clazz . new instanc ( ) ; ( tag instanceof jsp sourc depend ) { iter entri string , long >> iter = ( ( jsp sourc depend ) tag ) . get depend ( ) . entri set ( ) . iter ( ) ; while ( iter . ha next ( ) ) { entri string , long entri = iter . next ( ) ; parent page info . add depend ( entri . get kei ( ) , entri . get valu ( ) ) ; } } } catch ( except e ) { ignor error } return tag clazz ; } }

protect url rewrit . param path path which ha rewritten string rewrit url ( string path ) { return url encod . encod ( path ) ; }	protect copi content specifi input stream specifi output stream , ensur both stream ar close befor return ( even face except ) . param resourc sourc resourc param input stream read sourc resourc from param writer writer write except ioexcept input output error occur void copi ( web resourc resourc , input stream , print writer writer ) throw ioexcept { ioexcept except = null ; input stream resourc input stream = null ; ( resourc . file ( ) ) { resourc input stream = resourc . get input stream ( ) ; } els { resourc input stream = ; } reader reader ; ( file encod = = null ) { reader = new input stream reader ( resourc input stream ) ; } els { reader = new input stream reader ( resourc input stream , file encod ) ; } copi input stream output stream except = copi rang ( reader , writer ) ; clean up reader reader . close ( ) ; rethrow ani except ha occur ( except = null ) throw except ; }	protect copi content specifi input stream specifi output stream , ensur both stream ar close befor return ( even face except ) . param resourc sourc resourc param input stream read sourc resourc from param writer writer write except ioexcept input output error occur void copi ( web resourc resourc , input stream , print writer writer ) throw ioexcept { ioexcept except = null ; input stream resourc input stream = null ; ( resourc . file ( ) ) { resourc input stream = resourc . get input stream ( ) ; } els { resourc input stream = ; } reader reader ; ( file encod = = null ) { reader = new input stream reader ( resourc input stream ) ; } els { reader = new input stream reader ( resourc input stream , file encod ) ; } copi input stream output stream except = copi rang ( reader , writer ) ; clean up reader reader . close ( ) ; rethrow ani except ha occur ( except = null ) throw except ; }	process get request specifi resourc . param request servlet request we ar process param respons servlet respons we ar creat except ioexcept input output error occur except servlet except servlet specifi error occur overrid protect void do get ( http servlet request request , http servlet respons respons ) throw ioexcept , servlet except { serv request resourc , includ data content serv resourc ( request , respons , true ) ; }	process head request specifi resourc . param request servlet request we ar process param respons servlet respons we ar creat except ioexcept input output error occur except servlet except servlet specifi error occur overrid protect void do head ( http servlet request request , http servlet respons respons ) throw ioexcept , servlet except { serv request resourc , without data content serv resourc ( request , respons , fals ) ; }	protect serv specifi resourc , option includ data content . param request servlet request we ar process param respons servlet respons we ar creat param content should content includ except ioexcept input output error occur except servlet except servlet specifi error occur void serv resourc ( http servlet request request , http servlet respons respons , boolean content ) throw ioexcept , servlet except { boolean serv content = content ; identifi request resourc path string path = get rel path ( request ) ; ( debug 0 ) { ( serv content ) log ( default servlet . serv resourc : serv resourc path header data ) ; els log ( default servlet . serv resourc : serv resourc path header onli ) ; } web resourc resourc = resourc . get resourc ( path ) ; ( resourc . exist ( ) ) { check we re includ so we can return appropri miss resourc name error string request uri = ( string ) request . get attribut ( request dispatch . includ request uri ) ; ( request uri = = null ) { request uri = request . get request uri ( ) ; } els { srv . 9 . 3 sai we must throw fnfe throw new file found except ( sm . get string ( default servlet . miss resourc , request uri ) ) ; } respons . send error ( http servlet respons . sc found , request uri ) ; return ; } end , return found ( resourc . file ( ) ) { ( path . end ( ) ( path . end ( ) ) ) { check we re includ so we can return appropri miss resourc name error string request uri = ( string ) request . get attribut ( request dispatch . includ request uri ) ; ( request uri = = null ) { request uri = request . get request uri ( ) ; } respons . send error ( http servlet respons . sc found , request uri ) ; return ; } } boolean error = respons . get statu ( ) = http servlet respons . sc bad request ; satisfi . ( resourc . file ( ) ) { check header boolean includ = ( request . get attribut ( request dispatch . includ context path ) = null ) ; ( includ error check header ( request , respons , resourc ) ) { return ; } } find content type . string content type = resourc . get mime type ( ) ; ( content type = = null ) { content type = get servlet context ( ) . get mime type ( resourc . get name ( ) ) ; resourc . set mime type ( content type ) ; } arrai list rang rang = null ; long content length = 1l ; ( resourc . directori ( ) ) { suppress them ( list ) { respons . send error ( http servlet respons . sc found , request . get request uri ( ) ) ; return ; } content type = text html ; charset = utf 8 ; } els { ( error ) { ( us accept rang ) { accept rang header respons . set header ( accept rang , byte ) ; } pars rang specifi rang = pars rang ( request , respons , resourc ) ; etag header respons . set header ( etag , resourc . get etag ( ) ) ; last modifi header respons . set header ( last modifi , resourc . get last modifi http ( ) ) ; } get content length content length = resourc . get content length ( ) ; ( silent ) when set output buffer size ( content length = = 0l ) { serv content = fals ; } } servlet output stream ostream = null ; print writer writer = null ; ( serv content ) { try retriev servlet output stream try { ostream = respons . get output stream ( ) ; } catch ( illeg state except e ) { try serv text file ( ( content type = = null ) ( content type . start ( text ) ) ( content type . end ( xml ) ) ( content type . contain ( javascript ) ) ) { writer = respons . get writer ( ) ; cannot reliabl serv partial content writer rang = full ; } els { throw e ; } } } check see filter , valv wrapper ha written some content . ha , disabl rang request set content length sinc neither can done reliabl . servlet respons r = respons ; long content written = 0 ; while ( r instanceof servlet respons wrapper ) { r = ( ( servlet respons wrapper ) r ) . get respons ( ) ; } ( r instanceof respons facad ) { content written = ( ( respons facad ) r ) . get content written ( ) ; } ( content written 0 ) { rang = full ; } ( resourc . directori ( ) error ( ( rang = = null rang . empti ( ) ) request . get header ( rang ) = = null ) rang = = full ) { set appropri output header ( content type = null ) { ( debug 0 ) log ( default servlet . serv file : content type = content type ) ; respons . set content type ( content type ) ; } ( resourc . file ( ) content length = 0 ( serv content ostream = null ) ) { ( debug 0 ) log ( default servlet . serv file : content length = content length ) ; written respons . ( content written = = 0 ) { respons . set content length long ( content length ) ; } } input stream render result = null ; ( resourc . directori ( ) ) { ( serv content ) { serv directori browser render result = render ( get path prefix ( request ) , resourc ) ; } } copi input stream our output stream ( request ) ( serv content ) { try { respons . set buffer size ( output ) ; } catch ( illeg state except e ) { silent catch } ( ostream = null ) { ( check sendfil ( request , respons , resourc , content length , null ) ) copi ( resourc , render result , ostream ) ; } els { copi ( resourc , render result , writer ) ; } } } els { ( ( rang = = null ) ( rang . empti ( ) ) ) return ; partial content respons . respons . set statu ( http servlet respons . sc partial content ) ; ( rang . size ( ) = = 1 ) { rang rang = rang . get ( 0 ) ; respons . add header ( content rang , byte rang . start rang . end rang . length ) ; long length = rang . end rang . start 1 ; respons . set content length long ( length ) ; ( content type = null ) { ( debug 0 ) log ( default servlet . serv file : content type = content type ) ; respons . set content type ( content type ) ; } ( serv content ) { try { respons . set buffer size ( output ) ; } catch ( illeg state except e ) { silent catch } ( ostream = null ) { ( check sendfil ( request , respons , resourc , rang . end rang . start 1 , rang ) ) copi ( resourc , ostream , rang ) ; } els { we should get here throw new illeg state except ( ) ; } } } els { respons . set content type ( multipart byterang ; boundari = mime separ ) ; ( serv content ) { try { respons . set buffer size ( output ) ; } catch ( illeg state except e ) { silent catch } ( ostream = null ) { copi ( resourc , ostream , rang . iter ( ) , content type ) ; } els { we should get here throw new illeg state except ( ) ; } } } } }
us event updat connect state . param request servlet request process param respons servlet respons creat except ioexcept input output error occur except servlet except servlet error occur overrid public void event ( request request , respons respons , comet event event ) throw ioexcept , servlet except { perform request boolean ok = fals ; try { get next ( ) . event ( request , respons , event ) ; ok = true ; } final { ( ok respons . close ( ) ( event . get event type ( ) = = comet event . event type . end ) ( event . get event type ( ) = = comet event . event type . error ( event . get event sub type ( ) = = comet event . event sub type . timeout ) ) ) { remov connect from webapp reload track comet request . remov ( request ) ; remov connect from session expir track note : can t get session ha been invalid ok sinc session listen have done clean up http session session = request . get session ( fals ) ; ( session = null ) { synchron ( session ) { request req = null ; try { req = ( request ) session . get attribut ( comet request attribut ) ; } catch ( illeg state except ) { ignor session ha been invalid listen have clean up } ( req = null ) { boolean found = fals ; ( int i = 0 ; found ( i req . length ) ; i ) { found = ( req i = = request ) ; } ( found ) { ( req . length 1 ) { request new connect info = new request req . length 1 ; int po = 0 ; ( int i = 0 ; i req . length ; i ) { ( req i = request ) { new connect info po = req i ; } } try { session . set attribut ( comet request attribut , new connect info ) ; } catch ( illeg state except ) { ignor session ha been invalid listen have clean up } } els { try { session . remov attribut ( comet request attribut ) ; } catch ( illeg state except ) { ignor session ha been invalid listen have clean up } } } } } } } } }	regist request track , whenev need . param request servlet request process param respons servlet respons creat except ioexcept input output error occur except servlet except servlet error occur overrid public void invok ( request request , respons respons ) throw ioexcept , servlet except { perform request get next ( ) . invok ( request , respons ) ; ( request . comet ( ) respons . close ( ) ) { start track thi connect , sinc thi begin event , comet mode http session session = request . get session ( true ) ; track connect webapp reload comet request . add ( request ) ; track connect session expir synchron ( session ) { request request = ( request ) session . get attribut ( comet request attribut ) ; ( request = = null ) { request = new request 1 ; request 0 = request ; session . set attribut ( comet request attribut , request ) ; } els { request new request = new request request . length 1 ; ( int i = 0 ; i request . length ; i ) { new request i = request i ; } new request request . length = request ; session . set attribut ( comet request attribut , new request ) ; } } } }	overrid public void session destroi ( http session event se ) { close all comet connect associ thi session request req = ( request ) se . get session ( ) . get attribut ( comet request attribut ) ; ( req = null ) { ( int i = 0 ; i req . length ; i ) { request req = req i ; try { comet event impl event = req . get event ( ) ; event . set event type ( comet event . event type . end ) ; event . set event sub type ( comet event . event sub type . session end ) ; ( ( comet processor ) req . get wrapper ( ) . get servlet ( ) ) . event ( event ) ; event . close ( ) ; } catch ( except e ) { req . get wrapper ( ) . get parent ( ) . get logger ( ) . warn ( sm . get string ( comet connect manag valv . listen event ) , e ) ; } } } }
public static produc string repres call el interpret . param express string contain zero more { } express param expect type expect type interpret result param fnmapvar variabl point function map . param xml escap true result should do xml escap return string repres call el interpret . string interpret call ( boolean tag file , string express , class expect type , string fnmapvar , boolean xml escap ) { determin which context object us . string jsp ctxt = null ; ( tag file ) { jsp ctxt = thi . get jsp context ( ) ; } els { jsp ctxt = jspx page context ; } determin whether us expect type s textual name , s primit , name correspond box type . string target type = expect type . get canon name ( ) ; string primit convert method = null ; ( expect type . primit ( ) ) { ( expect type . equal ( boolean . type ) ) { target type = boolean . class . get name ( ) ; primit convert method = boolean valu ; } els ( expect type . equal ( byte . type ) ) { target type = byte . class . get name ( ) ; primit convert method = byte valu ; } els ( expect type . equal ( charact . type ) ) { target type = charact . class . get name ( ) ; primit convert method = char valu ; } els ( expect type . equal ( short . type ) ) { target type = short . class . get name ( ) ; primit convert method = short valu ; } els ( expect type . equal ( integ . type ) ) { target type = integ . class . get name ( ) ; primit convert method = int valu ; } els ( expect type . equal ( long . type ) ) { target type = long . class . get name ( ) ; primit convert method = long valu ; } els ( expect type . equal ( float . type ) ) { target type = float . class . get name ( ) ; primit convert method = float valu ; } els ( expect type . equal ( doubl . type ) ) { target type = doubl . class . get name ( ) ; primit convert method = doubl valu ; } } ( primit convert method = null ) { xml escap = fals ; } build up base call interpret . xxx we us proprietari call interpret now current standard machineri ineffici requir lot wrapper adapt . thi should all clear up onc el interpret move out jstl own project . futur , thi should replac code call express evalu . pars express ( ) cach result express object . interpret call would simpli select pre cach express evalu . note page context impl implement variabl resolv gener servlet simpl tag implement function mapper , so machineri alreadi place ( mroth ) . target type = java sourc type ( target type ) ; string builder call = new string builder ( ( target type ) org . apach . jasper . runtim . page context impl . proprietari evalu ( gener . quot ( express ) , target type . class , ( javax . servlet . jsp . page context ) jsp ctxt , fnmapvar , xml escap ) ) ; add primit convert method we need . ( primit convert method = null ) { call . insert ( 0 , ( ) ; call . append ( ) . primit convert method ( ) ) ; } return call . string ( ) ; }
protect creat jdbc connect tri connect databas . param now timestamp when thi wa call param us argument us return pool connect ha been connect throw sqlexcept pool connect creat connect ( long now , pool connect us , string usernam , string password ) throw sqlexcept { connect where avail we ll creat pool connect con = creat ( fals ) ; ( usernam = null ) con . get attribut ( ) . put ( pool connect . prop user , usernam ) ; ( password = null ) con . get attribut ( ) . put ( pool connect . prop password , password ) ; boolean error = fals ; try { connect valid connect con . lock ( ) ; con . connect ( ) ; ( con . valid ( pool connect . valid init ) ) { need lock new , content con . set timestamp ( now ) ; ( get pool properti ( ) . log abandon ( ) ) { con . set stack trace ( get thread dump ( ) ) ; } ( busi . offer ( con ) ) { log . debug ( connect doesn t fit busi arrai , connect traceabl . ) ; } return con ; } els { valid fail , make sure we disconnect clean up error = true ; } end } catch ( except e ) { error = true ; ( log . debug enabl ( ) ) log . debug ( unabl creat new jdbc connect . , e ) ; ( e instanceof sqlexcept ) { throw ( sqlexcept ) e ; } els { sqlexcept ex = new sqlexcept ( e . get messag ( ) ) ; ex . init caus ( e ) ; throw ex ; } } final { con can never null here ( error ) { releas ( con ) ; } con . unlock ( ) ; } catch return null ; }	{ inherit doc } overrid public string get valid queri ( ) { return get pool properti ( ) . get valid queri ( ) ; }	{ inherit doc } overrid public string get valid queri ( ) { return valid queri ; }	overrid public string get valid queri ( ) { return get pool properti ( ) . get valid queri ( ) ; }	public valid connect . param valid action action us . { link valid borrow } , { link valid idl } , { link valid init } { link valid return } param sql sql us dure valid . { link pool configur set init sql ( string ) } ha been call non null valu action { link valid init } init sql us valid . return true connect wa valid successfulli . return true even valid wa perform , when { link pool configur set valid interv ( long ) } ha been call posit valu . p fals valid fail . caller should close connect fals return sinc session could have been left unknown state dure initi . boolean valid ( int valid action , string sql ) { ( thi . discard ( ) ) { return fals ; } ( do valid ( valid action ) ) { valid requir , init sql prop set return true ; } don t bother valid alreadi have recent enough long now = system . current time milli ( ) ; ( valid action = valid init pool properti . get valid interv ( ) 0 ( now thi . last valid ) pool properti . get valid interv ( ) ) { return true ; } ( pool properti . get valid ( ) = null ) { ( pool properti . get valid ( ) . valid ( connect , valid action ) ) { thi . last valid = now ; return true ; } els { ( get pool properti ( ) . get log valid error ( ) ) { log . error ( custom valid through pool properti . get valid ( ) fail . ) ; } return fals ; } } string queri = sql ; ( valid action = = valid init pool properti . get init sql ( ) = null ) { queri = pool properti . get init sql ( ) ; } ( queri = = null ) { queri = pool properti . get valid queri ( ) ; } statement stmt = null ; try { stmt = connect . creat statement ( ) ; stmt . execut ( queri ) ; stmt . close ( ) ; thi . last valid = now ; return true ; } catch ( except ex ) { ( get pool properti ( ) . get log valid error ( ) ) { log . warn ( sql valid error , ex ) ; } els ( log . debug enabl ( ) ) { log . debug ( unabl valid object : , ex ) ; } ( stmt = null ) try { stmt . close ( ) ; } catch ( except ignore2 ) { noop } } return fals ; }	public static pool configur pars pool properti ( properti properti ) { pool configur pool properti = new pool properti ( ) ; string valu = null ; valu = properti . get properti ( prop defaultautocommit ) ; ( valu = null ) { pool properti . set default auto commit ( boolean . valu ( valu ) ) ; } valu = properti . get properti ( prop defaultreadonli ) ; ( valu = null ) { pool properti . set default read onli ( boolean . valu ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { int level = unknown transactionisol ; ( none . equal ignor case ( valu ) ) { level = connect . transact none ; } els ( read commit . equal ignor case ( valu ) ) { level = connect . transact read commit ; } els ( read uncommit . equal ignor case ( valu ) ) { level = connect . transact read uncommit ; } els ( repeat read . equal ignor case ( valu ) ) { level = connect . transact repeat read ; } els ( serializ . equal ignor case ( valu ) ) { level = connect . transact serializ ; } els { try { level = integ . pars int ( valu ) ; } catch ( number format except e ) { system . err . println ( could pars default transact isol : valu ) ; system . err . println ( warn : default transact isol set ) ; system . err . println ( us default valu databas driver ) ; level = unknown transactionisol ; } } pool properti . set default transact isol ( level ) ; } valu = properti . get properti ( prop defaultcatalog ) ; ( valu = null ) { pool properti . set default catalog ( valu ) ; } valu = properti . get properti ( prop driverclassnam ) ; ( valu = null ) { pool properti . set driver class name ( valu ) ; } valu = properti . get properti ( prop maxact ) ; ( valu = null ) { pool properti . set max activ ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop maxidl ) ; ( valu = null ) { pool properti . set max idl ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop minidl ) ; ( valu = null ) { pool properti . set min idl ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop initials ) ; ( valu = null ) { pool properti . set initi size ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop maxwait ) ; ( valu = null ) { pool properti . set max wait ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop testonborrow ) ; ( valu = null ) { pool properti . set test borrow ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop testonreturn ) ; ( valu = null ) { pool properti . set test return ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop testonconnect ) ; ( valu = null ) { pool properti . set test connect ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set time between evict run milli ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set num test per evict run ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set min evict idl time milli ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop testwhileidl ) ; ( valu = null ) { pool properti . set test while idl ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop password ) ; ( valu = null ) { pool properti . set password ( valu ) ; } valu = properti . get properti ( prop url ) ; ( valu = null ) { pool properti . set url ( valu ) ; } valu = properti . get properti ( prop usernam ) ; ( valu = null ) { pool properti . set usernam ( valu ) ; } valu = properti . get properti ( prop validationqueri ) ; ( valu = null ) { pool properti . set valid queri ( valu ) ; } valu = properti . get properti ( prop valid class name ) ; ( valu = null ) { pool properti . set valid class name ( valu ) ; } valu = properti . get properti ( prop validationinterv ) ; ( valu = null ) { pool properti . set valid interv ( long . pars long ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set access underli connect allow ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop removeabandon ) ; ( valu = null ) { pool properti . set remov abandon ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set remov abandon timeout ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop logabandon ) ; ( valu = null ) { pool properti . set log abandon ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop poolpreparedstat ) ; ( valu = null ) { log . warn ( prop poolpreparedstat valid set , have effect . ) ; } valu = properti . get properti ( prop maxopenpreparedstat ) ; ( valu = null ) { log . warn ( prop maxopenpreparedstat valid set , have effect . ) ; } valu = properti . get properti ( prop connectionproperti ) ; ( valu = null ) { properti p = get properti ( valu ) ; pool properti . set db properti ( p ) ; } els { pool properti . set db properti ( new properti ( ) ) ; } ( pool properti . get usernam ( ) = null ) { pool properti . get db properti ( ) . set properti ( user , pool properti . get usernam ( ) ) ; } ( pool properti . get password ( ) = null ) { pool properti . get db properti ( ) . set properti ( password , pool properti . get password ( ) ) ; } valu = properti . get properti ( prop initsql ) ; ( valu = null ) { pool properti . set init sql ( valu ) ; } valu = properti . get properti ( prop interceptor ) ; ( valu = null ) { pool properti . set jdbc interceptor ( valu ) ; } valu = properti . get properti ( prop jmx enabl ) ; ( valu = null ) { pool properti . set jmx enabl ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop fair queue ) ; ( valu = null ) { pool properti . set fair queue ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop us equal ) ; ( valu = null ) { pool properti . set us equal ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( object name ) ; ( valu = null ) { pool properti . set name ( object name . quot ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set abandon when percentag full ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop maxag ) ; ( valu = null ) { pool properti . set max ag ( long . pars long ( valu ) ) ; } valu = properti . get properti ( prop us con lock ) ; ( valu = null ) { pool properti . set us lock ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop datasourc ) ; ( valu = null ) { thi should never happen throw new illeg argument except ( can t set data sourc properti string , thi must javax . sql . data sourc object . ) ; } valu = properti . get properti ( prop datasourc jndi ) ; ( valu = null ) { pool properti . set data sourc jndi ( valu ) ; } valu = properti . get properti ( prop suspect timeout ) ; ( valu = null ) { pool properti . set suspect timeout ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop altern usernam allow ) ; ( valu = null ) { pool properti . set altern usernam allow ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop commitonreturn ) ; ( valu = null ) { pool properti . set commit return ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop rollbackonreturn ) ; ( valu = null ) { pool properti . set rollback return ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set us dispos connect facad ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop logvalidationerror ) ; ( valu = null ) { pool properti . set log valid error ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop propagateinterruptst ) ; ( valu = null ) { pool properti . set propag interrupt state ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set ignor except pre load ( boolean . pars boolean ( valu ) ) ; } return pool properti ; }	overrid public void set valid queri ( string valid queri ) { get pool properti ( ) . set valid queri ( valid queri ) ; }	{ inherit doc } overrid public void set valid class name ( string class name ) { thi . pool properti . set valid class name ( class name ) ; }
protect return code valid code flag thi session without ani expir check . boolean valid intern ( ) { return ( thi . valid thi . expir ) ; }	return code valid code flag thi session . overrid public boolean valid ( ) { ( thi . expir ) { return true ; } ( thi . valid ) { return fals ; } ( activ check access count . get ( ) 0 ) { return true ; } ( max inact interv 0 ) { long time now = system . current time milli ( ) ; int time idl ; ( last access start ) { time idl = ( int ) ( ( time now last access time ) 1000l ) ; } els { time idl = ( int ) ( ( time now thi access time ) 1000l ) ; } ( primari session ( ) ) { ( time idl = max inact interv ) { expir ( true ) ; } } els { ( time idl = ( 2 max inact interv ) ) { session ha been idl twice long allow , primari session ha probabl crash , other request ar come . why we do thi . otherwis we would have memori leak expir ( true , fals ) ; } } } return ( thi . valid ) ; }	return code valid code flag thi session . overrid public boolean valid ( ) { ( thi . expir ) { return true ; } ( thi . valid ) { return fals ; } ( activ check access count . get ( ) 0 ) { return true ; } ( max inact interv 0 ) { long time now = system . current time milli ( ) ; int time idl ; ( last access start ) { time idl = ( int ) ( ( time now last access time ) 1000l ) ; } els { time idl = ( int ) ( ( time now thi access time ) 1000l ) ; } ( time idl = max inact interv ) { expir ( true ) ; } } return ( thi . valid ) ; }	public perform intern process requir invalid thi session , without trigger except session ha alreadi expir . param notifi should we notifi listen about demis thi session void expir ( boolean notifi ) { check see expir progress ha previous been call ( expir valid ) return ; synchron ( thi ) { doubl check lock expir valid need volatil ( expir valid ) return ; ( manag = = null ) return ; mark thi session expir expir = true ; notifi interest applic event listen fixm assum we call listen revers order context context = manag . get context ( ) ; call expir ( ) mai have been trigger webapp . make sure webapp s class loader set when call listen class loader old tccl = null ; ( context . get loader ( ) = null context . get loader ( ) . get class loader ( ) = null ) { old tccl = thread . current thread ( ) . get context class loader ( ) ; ( global . secur enabl ) { privileg action void pa = new privileg set tccl ( context . get loader ( ) . get class loader ( ) ) ; access control . do privileg ( pa ) ; } els { thread . current thread ( ) . set context class loader ( context . get loader ( ) . get class loader ( ) ) ; } } try { ( notifi ) { object listen = context . get applic lifecycl listen ( ) ; ( listen = null listen . length 0 ) { http session event event = new http session event ( get session ( ) ) ; ( int i = 0 ; i listen . length ; i ) { int j = ( listen . length 1 ) i ; ( ( listen j instanceof http session listen ) ) continu ; http session listen listen = ( http session listen ) listen j ; try { context . fire contain event ( befor session destroi , listen ) ; listen . session destroi ( event ) ; context . fire contain event ( after session destroi , listen ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; try { context . fire contain event ( after session destroi , listen ) ; } catch ( except e ) { ignor } manag . get context ( ) . get logger ( ) . error ( sm . get string ( standard session . session event ) , t ) ; } } } } } final { ( old tccl = null ) { ( global . secur enabl ) { privileg action void pa = new privileg set tccl ( old tccl ) ; access control . do privileg ( pa ) ; } els { thread . current thread ( ) . set context class loader ( old tccl ) ; } } } ( activ check ) { access count . set ( 0 ) ; } set valid ( fals ) ; remov thi session from our manag s activ session manag . remov ( thi , true ) ; notifi interest session event listen ( notifi ) { fire session event ( session . session destroi event , null ) ; } call logout method ( princip instanceof tomcat princip ) { tomcat princip gp = ( tomcat princip ) princip ; try { gp . logout ( ) ; } catch ( except e ) { manag . get context ( ) . get logger ( ) . error ( sm . get string ( standard session . logoutfail ) , e ) ; } } we have complet expir thi session expir = fals ; unbind ani object associ thi session string kei = kei ( ) ; ( int i = 0 ; i kei . length ; i ) remov attribut intern ( kei i , notifi ) ; } }	public void expir ( boolean notifi , boolean notifi cluster ) { ( expir ) return ; string expir id = get id intern ( ) ; ( notifi cluster expir id = null manag = null manag instanceof delta manag ) { delta manag dmanag = ( delta manag ) manag ; catalina cluster cluster = dmanag . get cluster ( ) ; cluster messag msg = dmanag . request complet ( expir id , true ) ; ( msg = null ) { cluster . send ( msg ) ; } } super . expir ( notifi ) ; ( notifi cluster ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( delta session . notifi , ( ( cluster manag ) manag ) . get name ( ) , boolean . valu ( primari session ( ) ) , expir id ) ) ; ( manag instanceof delta manag ) { ( ( delta manag ) manag ) . session expir ( expir id ) ; } } }
protect trust manag get trust manag ( string keystor type , string keystor provid , string algorithm ) throw except { string crlf = endpoint . get crl file ( ) ; string class name = endpoint . get trust manag class name ( ) ; ( class name = null class name . length ( ) 0 ) { class loader class loader = get class ( ) . get class loader ( ) ; class clazz = class loader . load class ( class name ) ; ( ( trust manag . class . assign from ( clazz ) ) ) { throw new instanti except ( sm . get string ( jsse . invalid trust manag class name , class name ) ) ; } object trust manag object = clazz . new instanc ( ) ; trust manag trust manag = ( trust manag ) trust manag object ; return new trust manag { trust manag } ; } trust manag tm = null ; kei store trust store = get trust store ( keystor type , keystor provid ) ; ( trust store = null endpoint . get trust manag class name ( ) = null ) { ( crlf = = null ) { trust manag factori tmf = trust manag factori . get instanc ( algorithm ) ; tmf . init ( trust store ) ; tm = tmf . get trust manag ( ) ; } els { trust manag factori tmf = trust manag factori . get instanc ( algorithm ) ; cert path paramet param = get paramet ( algorithm , crlf , trust store ) ; manag factori paramet mfp = new cert path trust manag paramet ( param ) ; tmf . init ( mfp ) ; tm = tmf . get trust manag ( ) ; } } return tm ; }
protect initi connect pool call from constructor param properti pool properti properti us initi pool throw sqlexcept initi fail void init ( pool configur properti ) throw sqlexcept { pool properti = properti ; make sure pool properli configur ( properti . get max activ ( ) 1 ) { log . warn ( max activ smaller than 1 , set max activ : pool properti . default max activ ) ; properti . set max activ ( pool properti . default max activ ) ; } ( properti . get max activ ( ) properti . get initi size ( ) ) { log . warn ( initi size larger than max activ , set initi size : properti . get max activ ( ) ) ; properti . set initi size ( properti . get max activ ( ) ) ; } ( properti . get min idl ( ) properti . get max activ ( ) ) { log . warn ( min idl larger than max activ , set min idl : properti . get max activ ( ) ) ; properti . set min idl ( properti . get max activ ( ) ) ; } ( properti . get max idl ( ) properti . get max activ ( ) ) { log . warn ( max idl larger than max activ , set max idl : properti . get max activ ( ) ) ; properti . set max idl ( properti . get max activ ( ) ) ; } ( properti . get max idl ( ) properti . get min idl ( ) ) { log . warn ( max idl smaller than min idl , set max idl : properti . get min idl ( ) ) ; properti . set max idl ( properti . get min idl ( ) ) ; } make space 10 extra case we flow over bit busi = new arrai block queue ( properti . get max activ ( ) , fals ) ; make space 10 extra case we flow over bit ( properti . fair queue ( ) ) { idl = new fair block queue ( ) ; idl = new multi lock fair block queue pool connect ( ) ; idl = new link transfer queue pool connect ( ) ; idl = new arrai block queue pool connect ( properti . get max activ ( ) , fals ) ; } els { idl = new arrai block queue ( properti . get max activ ( ) , properti . fair queue ( ) ) ; } initi pool cleaner ( properti ) ; creat jmx mbean ( thi . get pool properti ( ) . jmx enabl ( ) ) creat mbean ( ) ; pars creat initi set interceptor . let them know pool ha start . interceptor get ani connect . pool properti . interceptor definit proxi = get pool properti ( ) . get jdbc interceptor arrai ( ) ; ( int i = 0 ; i proxi . length ; i ) { try { ( log . debug enabl ( ) ) { log . debug ( creat interceptor instanc class : proxi i . get interceptor class ( ) ) ; } jdbc interceptor interceptor = proxi i . get interceptor class ( ) . new instanc ( ) ; interceptor . set properti ( proxi i . get properti ( ) ) ; interceptor . pool start ( thi ) ; } catch ( except x ) { log . error ( unabl inform interceptor pool start . , x ) ; ( jmx pool = null ) jmx pool . notifi ( org . apach . tomcat . jdbc . pool . jmx . connect pool . notifi init , get stack trace ( x ) ) ; close ( true ) ; sqlexcept ex = new sqlexcept ( ) ; ex . init caus ( x ) ; throw ex ; } } initi pool initi set member pool connect initi pool = new pool connect pool properti . get initi size ( ) ; try { ( int i = 0 ; i initi pool . length ; i ) { don t wait , should content initi pool i = thi . borrow connect ( 0 , null , null ) ; } } catch ( sqlexcept x ) { ( jmx pool = null ) jmx pool . notifi ( org . apach . tomcat . jdbc . pool . jmx . connect pool . notifi init , get stack trace ( x ) ) ; close ( true ) ; throw x ; } final { return member idl pool ( int i = 0 ; i initi pool . length ; i ) { ( initi pool i = null ) { try { thi . return connect ( initi pool i ) ; } catch ( except x ) { noop } } end } } catch close = fals ; }	public static pool configur pars pool properti ( properti properti ) { pool configur pool properti = new pool properti ( ) ; string valu = null ; valu = properti . get properti ( prop defaultautocommit ) ; ( valu = null ) { pool properti . set default auto commit ( boolean . valu ( valu ) ) ; } valu = properti . get properti ( prop defaultreadonli ) ; ( valu = null ) { pool properti . set default read onli ( boolean . valu ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { int level = unknown transactionisol ; ( none . equal ignor case ( valu ) ) { level = connect . transact none ; } els ( read commit . equal ignor case ( valu ) ) { level = connect . transact read commit ; } els ( read uncommit . equal ignor case ( valu ) ) { level = connect . transact read uncommit ; } els ( repeat read . equal ignor case ( valu ) ) { level = connect . transact repeat read ; } els ( serializ . equal ignor case ( valu ) ) { level = connect . transact serializ ; } els { try { level = integ . pars int ( valu ) ; } catch ( number format except e ) { system . err . println ( could pars default transact isol : valu ) ; system . err . println ( warn : default transact isol set ) ; system . err . println ( us default valu databas driver ) ; level = unknown transactionisol ; } } pool properti . set default transact isol ( level ) ; } valu = properti . get properti ( prop defaultcatalog ) ; ( valu = null ) { pool properti . set default catalog ( valu ) ; } valu = properti . get properti ( prop driverclassnam ) ; ( valu = null ) { pool properti . set driver class name ( valu ) ; } valu = properti . get properti ( prop maxact ) ; ( valu = null ) { pool properti . set max activ ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop maxidl ) ; ( valu = null ) { pool properti . set max idl ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop minidl ) ; ( valu = null ) { pool properti . set min idl ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop initials ) ; ( valu = null ) { pool properti . set initi size ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop maxwait ) ; ( valu = null ) { pool properti . set max wait ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop testonborrow ) ; ( valu = null ) { pool properti . set test borrow ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop testonreturn ) ; ( valu = null ) { pool properti . set test return ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop testonconnect ) ; ( valu = null ) { pool properti . set test connect ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set time between evict run milli ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set num test per evict run ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set min evict idl time milli ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop testwhileidl ) ; ( valu = null ) { pool properti . set test while idl ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop password ) ; ( valu = null ) { pool properti . set password ( valu ) ; } valu = properti . get properti ( prop url ) ; ( valu = null ) { pool properti . set url ( valu ) ; } valu = properti . get properti ( prop usernam ) ; ( valu = null ) { pool properti . set usernam ( valu ) ; } valu = properti . get properti ( prop validationqueri ) ; ( valu = null ) { pool properti . set valid queri ( valu ) ; } valu = properti . get properti ( prop valid class name ) ; ( valu = null ) { pool properti . set valid class name ( valu ) ; } valu = properti . get properti ( prop validationinterv ) ; ( valu = null ) { pool properti . set valid interv ( long . pars long ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set access underli connect allow ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop removeabandon ) ; ( valu = null ) { pool properti . set remov abandon ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set remov abandon timeout ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop logabandon ) ; ( valu = null ) { pool properti . set log abandon ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop poolpreparedstat ) ; ( valu = null ) { log . warn ( prop poolpreparedstat valid set , have effect . ) ; } valu = properti . get properti ( prop maxopenpreparedstat ) ; ( valu = null ) { log . warn ( prop maxopenpreparedstat valid set , have effect . ) ; } valu = properti . get properti ( prop connectionproperti ) ; ( valu = null ) { properti p = get properti ( valu ) ; pool properti . set db properti ( p ) ; } els { pool properti . set db properti ( new properti ( ) ) ; } ( pool properti . get usernam ( ) = null ) { pool properti . get db properti ( ) . set properti ( user , pool properti . get usernam ( ) ) ; } ( pool properti . get password ( ) = null ) { pool properti . get db properti ( ) . set properti ( password , pool properti . get password ( ) ) ; } valu = properti . get properti ( prop initsql ) ; ( valu = null ) { pool properti . set init sql ( valu ) ; } valu = properti . get properti ( prop interceptor ) ; ( valu = null ) { pool properti . set jdbc interceptor ( valu ) ; } valu = properti . get properti ( prop jmx enabl ) ; ( valu = null ) { pool properti . set jmx enabl ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop fair queue ) ; ( valu = null ) { pool properti . set fair queue ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop us equal ) ; ( valu = null ) { pool properti . set us equal ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( object name ) ; ( valu = null ) { pool properti . set name ( object name . quot ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set abandon when percentag full ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop maxag ) ; ( valu = null ) { pool properti . set max ag ( long . pars long ( valu ) ) ; } valu = properti . get properti ( prop us con lock ) ; ( valu = null ) { pool properti . set us lock ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop datasourc ) ; ( valu = null ) { thi should never happen throw new illeg argument except ( can t set data sourc properti string , thi must javax . sql . data sourc object . ) ; } valu = properti . get properti ( prop datasourc jndi ) ; ( valu = null ) { pool properti . set data sourc jndi ( valu ) ; } valu = properti . get properti ( prop suspect timeout ) ; ( valu = null ) { pool properti . set suspect timeout ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop altern usernam allow ) ; ( valu = null ) { pool properti . set altern usernam allow ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop commitonreturn ) ; ( valu = null ) { pool properti . set commit return ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop rollbackonreturn ) ; ( valu = null ) { pool properti . set rollback return ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set us dispos connect facad ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop logvalidationerror ) ; ( valu = null ) { pool properti . set log valid error ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop propagateinterruptst ) ; ( valu = null ) { pool properti . set propag interrupt state ( boolean . pars boolean ( valu ) ) ; } return pool properti ; }	{ inherit doc } overrid public void set propag interrupt state ( boolean propag interrupt state ) { get pool properti ( ) . set propag interrupt state ( propag interrupt state ) ; }	{ inherit doc } overrid public void set propag interrupt state ( boolean propag interrupt state ) { thi . propag interrupt state = propag interrupt state ; }	{ inherit doc } overrid public void set propag interrupt state ( boolean propag interrupt state ) { get pool properti ( ) . set propag interrupt state ( propag interrupt state ) ; }
privat thread safe wai retriev connect from pool param wait time wait , overrid max wait from properti , set 1 you wish us max wait , 0 you wish wait time . return pool connect throw sqlexcept pool connect borrow connect ( int wait , string usernam , string password ) throw sqlexcept { ( close ( ) ) { throw new sqlexcept ( connect pool close . ) ; } end get current time stamp long now = system . current time milli ( ) ; see avail immedi pool connect con = idl . poll ( ) ; while ( true ) { ( con = null ) { configur connect return pool connect result = borrow connect ( now , con , usernam , password ) ; null should never return , wa previou impl . ( result = null ) return result ; } new connect ( size . get ( ) get pool properti ( ) . get max activ ( ) ) { atom duplic check ( size . add get ( 1 ) get pool properti ( ) . get max activ ( ) ) { we got here , two thread pass through first size . decrement get ( ) ; } els { creat connect , we re below limit return creat connect ( now , con , usernam , password ) ; } } end calcul wait time thi iter long max wait = wait ; pass wait time 1 , mean we should us pool properti valu ( wait = = 1 ) { max wait = ( get pool properti ( ) . get max wait ( ) = 0 ) long . max valu : get pool properti ( ) . get max wait ( ) ; } long timetowait = math . max ( 0 , max wait ( system . current time milli ( ) now ) ) ; waitcount . increment get ( ) ; try { retriev exist connect con = idl . poll ( timetowait , time unit . millisecond ) ; } catch ( interrupt except ex ) { ( get pool properti ( ) . get propag interrupt state ( ) ) { thread . current thread ( ) . interrupt ( ) ; } els { thread . interrupt ( ) ; } sqlexcept sx = new sqlexcept ( pool wait interrupt . ) ; sx . init caus ( ex ) ; throw sx ; } final { waitcount . decrement get ( ) ; } ( max wait = = 0 con = = null ) { wait , return we have ( jmx pool = null ) { jmx pool . notifi ( org . apach . tomcat . jdbc . pool . jmx . connect pool . pool empti , pool empti wait . ) ; } throw new pool exhaust except ( thread . current thread ( ) . get name ( ) wait : pool empti . unabl fetch connect , none avail busi . size ( ) us . ) ; } we didn t get connect , let see we time out ( con = = null ) { ( ( system . current time milli ( ) now ) = max wait ) { ( jmx pool = null ) { jmx pool . notifi ( org . apach . tomcat . jdbc . pool . jmx . connect pool . pool empti , pool empti timeout . ) ; } throw new pool exhaust except ( thread . current thread ( ) . get name ( ) timeout : pool empti . unabl fetch connect ( max wait 1000 ) second , none avail size : size . get ( ) ; busi : busi . size ( ) ; idl : idl . size ( ) ; lastwait : timetowait . ) ; } els { timeout , let try again continu ; } } } while }	protect close pool all disconnect all idl connect activ connect close upon { link java . sql . connect close close } method call underli connect instead return pool param forc true even close activ connect void close ( boolean forc ) { ar we alreadi close ( thi . close ) return ; prevent other thread from enter thi . close = true ; stop background thread ( pool cleaner = null ) { pool cleaner . stop run ( ) ; } releas all idl connect block queue pool connect pool = ( idl . size ( ) 0 ) idl : ( forc busi : idl ) ; while ( pool . size ( ) 0 ) { try { retriev next connect pool connect con = pool . poll ( 1000 , time unit . millisecond ) ; close retriev next , avail while ( con = null ) { close connect ( pool = = idl ) releas ( con ) ; els abandon ( con ) ; ( pool . size ( ) 0 ) { con = pool . poll ( 1000 , time unit . millisecond ) ; } els { break ; } } while } catch ( interrupt except ex ) { ( get pool properti ( ) . get propag interrupt state ( ) ) { thread . current thread ( ) . interrupt ( ) ; } els { thread . interrupt ( ) ; } } ( pool . size ( ) = = 0 forc pool = busi ) pool = busi ; } ( thi . get pool properti ( ) . jmx enabl ( ) ) thi . jmx pool = null ; pool properti . interceptor definit proxi = get pool properti ( ) . get jdbc interceptor arrai ( ) ; ( int i = 0 ; i proxi . length ; i ) { try { jdbc interceptor interceptor = proxi i . get interceptor class ( ) . new instanc ( ) ; interceptor . set properti ( proxi i . get properti ( ) ) ; interceptor . pool close ( thi ) ; } catch ( except x ) { log . debug ( unabl inform interceptor pool closur . , x ) ; } } }
send action connector . param action code type action param param action paramet overrid protect void action intern ( action code action code , object param ) { ( action code = = action code . async complet ) { socket wrapper . clear dispatch ( ) ; ( async state machin . async complet ( ) ) { ( ( apr endpoint ) endpoint ) . process socket async ( thi . socket wrapper , socket statu . open read ) ; } } els ( action code = = action code . async settimeout ) { ( param = = null ) return ; long timeout = ( ( long ) param ) . long valu ( ) ; socket wrapper . set timeout ( timeout ) ; } els ( action code = = action code . async dispatch ) { ( async state machin . async dispatch ( ) ) { ( ( apr endpoint ) endpoint ) . process socket async ( thi . socket wrapper , socket statu . open read ) ; } } }	send action connector . param action code type action param param action paramet overrid protect void action intern ( action code action code , object param ) { ( action code = = action code . async complet ) { socket wrapper . clear dispatch ( ) ; ( async state machin . async complet ( ) ) { ( ( nio endpoint ) endpoint ) . dispatch event ( socket wrapper . get socket ( ) , socket statu . open read , true ) ; } } els ( action code = = action code . async settimeout ) { ( param = = null ) return ; long timeout = ( ( long ) param ) . long valu ( ) ; final kei attach ka = ( kei attach ) socket wrapper . get socket ( ) . get attach ( fals ) ; ( keep aliv timeout 0 ) { ka . set timeout ( timeout ) ; } } els ( action code = = action code . async dispatch ) { ( async state machin . async dispatch ( ) ) { ( ( nio endpoint ) endpoint ) . dispatch event ( socket wrapper . get socket ( ) , socket statu . open read , true ) ; } } }	send action connector . param action code type action param param action paramet overrid protect void action intern ( action code action code , object param ) { ( action code = = action code . async complet ) { socket wrapper . clear dispatch ( ) ; ( async state machin . async complet ( ) ) { ( ( jio endpoint ) endpoint ) . process socket async ( thi . socket wrapper , socket statu . open read ) ; } } els ( action code = = action code . async settimeout ) { ( param = = null ) return ; long timeout = ( ( long ) param ) . long valu ( ) ; we ar piggi back worker thread , set timeout socket wrapper . set timeout ( timeout ) ; } els ( action code = = action code . async dispatch ) { ( async state machin . async dispatch ( ) ) { ( ( jio endpoint ) endpoint ) . process socket async ( thi . socket wrapper , socket statu . open read ) ; } } }	overrid public socket state async dispatch ( socket statu statu ) { request info rp = request . get request processor ( ) ; try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; error = get adapt ( ) . async dispatch ( request , respons , statu ) ; } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; get log ( ) . error ( sm . get string ( http11processor . request . process ) , t ) ; error = true ; } rp . set stage ( org . apach . coyot . constant . stage end ) ; ( async ( ) ) { ( error ) { request . updat counter ( ) ; return socket state . close ; } els { return socket state . long ; } } els { request . updat counter ( ) ; ( error ) { return socket state . close ; } els { return socket state . open ; } } }	send action connector . param action code type action param param action paramet overrid public final void action ( action code action code , object param ) { ( action code = = action code . close ) { transact client try { finish ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . commit ) { ( respons . commit ( ) ) return ; valid write respons header try { prepar respons ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } try { flush ( fals ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . ack ) { op ajp } els ( action code = = action code . client flush ) { ( respons . commit ( ) ) { valid write respons header try { prepar respons ( ) ; } catch ( ioexcept e ) { set error flag error = true ; return ; } } try { flush ( true ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . disabl swallow input ) { todo : do swallow request input make sure we ar close connect error = true ; } els ( action code = = action code . reset ) { op } els ( action code = = action code . req ssl attribut ) { ( certif . null ( ) ) { byte chunk cert data = certif . get byte chunk ( ) ; x509certif jsse cert = null ; byte arrai input stream bai = new byte arrai input stream ( cert data . get byte ( ) , cert data . get start ( ) , cert data . get length ( ) ) ; fill element . try { certif factori cf ; ( client cert provid = = null ) { cf = certif factori . get instanc ( x . 509 ) ; } els { cf = certif factori . get instanc ( x . 509 , client cert provid ) ; } while ( bai . avail ( ) 0 ) { x509certif cert = ( x509certif ) cf . gener certif ( bai ) ; ( jsse cert = = null ) { jsse cert = new x509certif 1 ; jsse cert 0 = cert ; } els { x509certif temp = new x509certif jsse cert . length 1 ; system . arraycopi ( jsse cert , 0 , temp , 0 , jsse cert . length ) ; temp jsse cert . length = cert ; jsse cert = temp ; } } } catch ( java . secur . cert . certif except e ) { get log ( ) . error ( sm . get string ( ajpprocessor . cert . fail ) , e ) ; return ; } catch ( provid except e ) { get log ( ) . error ( sm . get string ( ajpprocessor . cert . fail ) , e ) ; return ; } request . set attribut ( sslsupport . certif kei , jsse cert ) ; } } els ( action code = = action code . req ssl certif ) { op . can t forc new ssl handshak client when us ajp revers proxi control connect . } els ( action code = = action code . req host attribut ) { get remot host name us dn resolut ( request . remot host ( ) . null ( ) ) { try { request . remot host ( ) . set string ( inet address . get name ( request . remot addr ( ) . string ( ) ) . get host name ( ) ) ; } catch ( ioexcept iex ) { ignor } } } els ( action code = = action code . req host addr attribut ) { op automat popul dure prepar request ( ) } els ( action code = = action code . req local name attribut ) { op automat popul dure prepar request ( ) } els ( action code = = action code . req local addr attribut ) { copi from local name now , which should simpli address request . local addr ( ) . set string ( request . local name ( ) . string ( ) ) ; } els ( action code = = action code . req remoteport attribut ) { op thi inform avail when us ajp protocol } els ( action code = = action code . req localport attribut ) { op automat popul dure prepar request ( ) } els ( action code = = action code . req set bodi replai ) { set given byte content byte chunk bc = ( byte chunk ) param ; int length = bc . get length ( ) ; bodi byte . set byte ( bc . get byte ( ) , bc . get start ( ) , length ) ; request . set content length ( length ) ; first = fals ; empti = fals ; replai = true ; end stream = fals ; } els ( action code = = action code . async start ) { async state machin . async start ( ( async context callback ) param ) ; } els ( action code = = action code . async dispatch ) { async state machin . async dispatch ( ) ; } els ( action code = = action code . async timeout ) { atom boolean result = ( atom boolean ) param ; result . set ( async state machin . async timeout ( ) ) ; } els ( action code = = action code . async run ) { async state machin . async run ( ( runnabl ) param ) ; } els ( action code = = action code . async error ) { async state machin . async error ( ) ; } els ( action code = = action code . async start ) { ( ( atom boolean ) param ) . set ( async state machin . async start ( ) ) ; } els ( action code = = action code . async dispatch ) { ( ( atom boolean ) param ) . set ( async state machin . async dispatch ( ) ) ; } els ( action code = = action code . async async ) { ( ( atom boolean ) param ) . set ( async state machin . async ( ) ) ; } els ( action code = = action code . async timingout ) { ( ( atom boolean ) param ) . set ( async state machin . async time out ( ) ) ; } els ( action code = = action code . async error ) { ( ( atom boolean ) param ) . set ( async state machin . async error ( ) ) ; } els ( action code = = action code . upgrad ) { http connect onli . unsupport ajp . throw new unsupport oper except ( sm . get string ( ajpprocessor . httpupgrad . notsupport ) ) ; } els ( action code = = action code . comet begin ) { http connect onli . unsupport ajp . throw new unsupport oper except ( sm . get string ( ajpprocessor . comet . notsupport ) ) ; } els ( action code = = action code . comet end ) { http connect onli . unsupport ajp . throw new unsupport oper except ( sm . get string ( ajpprocessor . comet . notsupport ) ) ; } els ( action code = = action code . comet close ) { http connect onli . unsupport ajp . throw new unsupport oper except ( sm . get string ( ajpprocessor . comet . notsupport ) ) ; } els ( action code = = action code . comet settimeout ) { http connect onli . unsupport ajp . throw new unsupport oper except ( sm . get string ( ajpprocessor . comet . notsupport ) ) ; } els ( action code = = action code . avail ) { ajp what chang would requir support . ( end stream ) { request . set avail ( 1 ) ; } } els ( action code = = action code . nb write interest ) { until true non block io implement , assum alwai possibl write data . atom boolean readi = ( atom boolean ) param ; readi . set ( true ) ; } els ( action code = = action code . nb read interest ) { op . requir until true non block io implement . } els ( action code = = action code . request bodi fulli read ) { atom boolean result = ( atom boolean ) param ; result . set ( end stream ) ; } els ( action code = = action code . dispatch read ) { socket wrapper . add dispatch ( dispatch type . non block read ) ; } els ( action code = = action code . dispatch write ) { socket wrapper . add dispatch ( dispatch type . non block write ) ; } els { action intern ( action code , param ) ; } }	recycl processor , readi next request which mai same connect differ connect . param socket close indic socket about close allow processor perform ani addit clean up mai requir overrid public void recycl ( boolean socket close ) { async state machin . recycl ( ) ; recycl request object first = true ; end stream = fals ; empti = true ; replai = fals ; finish = fals ; request . recycl ( ) ; respons . recycl ( ) ; certif . recycl ( ) ; swallow respons = fals ; byte written = 0 ; }
protect creat our directori context configur . return java . util . hashtabl configur directori context . hashtabl string , string get directori context environ ( ) { hashtabl string , string env = new hashtabl ( ) ; configur our directori context environ . ( contain log . debug enabl ( ) connect attempt = = 0 ) contain log . debug ( connect url connect url ) ; }	overrid protect princip get princip ( string usernam , gsscredenti gss credenti ) { dir context context = null ; princip princip = null ; try { ensur we have directori context avail context = open ( ) ; time befor give up . try { authent specifi usernam possibl princip = get princip ( context , usernam , gss credenti ) ; } catch ( commun except e ) { log except so we know s . contain log . warn ( sm . get string ( jndi realm . except ) , e ) ; close connect so we know reopen . ( context = null ) close ( context ) ; open new directori context . context = open ( ) ; try authent again . princip = get princip ( context , usernam , gss credenti ) ; } catch ( servic unavail except e ) { log except so we know s . contain log . warn ( sm . get string ( jndi realm . except ) , e ) ; close connect so we know reopen . ( context = null ) close ( context ) ; open new directori context . context = open ( ) ; try authent again . princip = get princip ( context , usernam , gss credenti ) ; } releas thi context releas ( context ) ; return authent princip ( ani ) return ( princip ) ; } catch ( name except e ) { log problem poster contain log . error ( sm . get string ( jndi realm . except ) , e ) ; close connect so get reopen next time ( context = null ) close ( context ) ; return authent thi request return ( null ) ; } }	return princip associ specifi usernam credenti , ; otherwis return code null code . ar ani error jdbc connect , execut queri anyth we return null ( don t authent ) . thi event also log , connect close so subsequ request automat re open . param usernam usernam princip look up param credenti password other credenti us authent thi usernam overrid public princip authent ( string usernam , string credenti ) { dir context context = null ; princip princip = null ; try { ensur we have directori context avail context = open ( ) ; time befor give up . try { authent specifi usernam possibl princip = authent ( context , usernam , credenti ) ; } catch ( null pointer except e ) { bz 42449 kludg sun s ldap provid broken ssl log except so we know s . contain log . warn ( sm . get string ( jndi realm . except ) , e ) ; close connect so we know reopen . ( context = null ) close ( context ) ; open new directori context . context = open ( ) ; try authent again . princip = authent ( context , usernam , credenti ) ; } catch ( commun except e ) { log except so we know s . contain log . warn ( sm . get string ( jndi realm . except ) , e ) ; close connect so we know reopen . ( context = null ) close ( context ) ; open new directori context . context = open ( ) ; try authent again . princip = authent ( context , usernam , credenti ) ; } catch ( servic unavail except e ) { log except so we know s . contain log . warn ( sm . get string ( jndi realm . except ) , e ) ; close connect so we know reopen . ( context = null ) close ( context ) ; open new directori context . context = open ( ) ; try authent again . princip = authent ( context , usernam , credenti ) ; } releas thi context releas ( context ) ; return authent princip ( ani ) return ( princip ) ; } catch ( name except e ) { log problem poster contain log . error ( sm . get string ( jndi realm . except ) , e ) ; close connect so get reopen next time ( context = null ) close ( context ) ; return authent thi request ( contain log . debug enabl ( ) ) contain log . debug ( return null princip . ) ; return ( null ) ; } }
privat void valid cpong ( tester ajp messag messag ) throw except { first two byte should alwai ab assert . assert equal ( ( byte ) , messag . buf 0 ) ; assert . assert equal ( ( byte ) b , messag . buf 1 ) ; cpong should have messag length 1 thi effect check next two byte assert . assert equal ( 1 , messag . get len ( ) ) ; data should valu 9 assert . assert equal ( 9 , messag . buf 4 ) ; }	protect when commit respons , we have valid set header , well setup respons filter . void prepar respons ( ) throw ioexcept { respons . set commit ( true ) ; respons messag . reset ( ) ; respons messag . append byte ( constant . jk ajp13 send header ) ; http header content respons messag . append int ( respons . get statu ( ) ) ; string messag = null ; ( org . apach . coyot . constant . us custom statu msg header http messag . safe http header ( respons . get messag ( ) ) ) { messag = respons . get messag ( ) ; } ( messag = = null ) { messag = http messag . get instanc ( respons . get local ( ) ) . get messag ( respons . get statu ( ) ) ; } ( messag = = null ) { mod jk httpd 2 . x fail null statu messag bug 45026 messag = integ . string ( respons . get statu ( ) ) ; } tmp mb . set string ( messag ) ; respons messag . append byte ( tmp mb ) ; special header mime header header = respons . get mime header ( ) ; string content type = respons . get content type ( ) ; ( content type = null ) { header . set valu ( content type ) . set string ( content type ) ; } string content languag = respons . get content languag ( ) ; ( content languag = null ) { header . set valu ( content languag ) . set string ( content languag ) ; } long content length = respons . get content length long ( ) ; ( content length = 0 ) { header . set valu ( content length ) . set long ( content length ) ; } other header int num header = header . size ( ) ; respons messag . append int ( num header ) ; ( int i = 0 ; i num header ; i ) { messag byte h n = header . get name ( i ) ; int h c = constant . get respons ajp index ( h n . string ( ) ) ; ( h c 0 ) { respons messag . append int ( h c ) ; } els { respons messag . append byte ( h n ) ; } messag byte h v = header . get valu ( i ) ; respons messag . append byte ( h v ) ; } write buffer respons messag . end ( ) ; output ( respons messag . get buffer ( ) , 0 , respons messag . get len ( ) ) ; }	public int do read ( byte chunk chunk , request req ) throw ioexcept { ( end stream ) { return 1 ; } ( first req . get content length long ( ) 0 ) { handl special first bodi chunk ( receiv ( ) ) { return 0 ; } } els ( empti ) { ( refil read buffer ( ) ) { return 1 ; } } byte chunk bc = bodi byte . get byte chunk ( ) ; chunk . set byte ( bc . get buffer ( ) , bc . get start ( ) , bc . get length ( ) ) ; empti = true ; return chunk . get length ( ) ; }	recycl processor , readi next request which mai same connect differ connect . param socket close indic socket about close allow processor perform ani addit clean up mai requir overrid public void recycl ( boolean socket close ) { async state machin . recycl ( ) ; recycl request object first = true ; end stream = fals ; empti = true ; replai = fals ; finish = fals ; request . recycl ( ) ; respons . recycl ( ) ; certif . recycl ( ) ; byte written = 0 ; }	test public void test keep aliv ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; tomcat . get connector ( ) . set properti ( connect timeout , 1 ) ; tomcat . start ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; tomcat . add servlet ( ctx , hello world , new hello world servlet ( ) ) ; ctx . add servlet map ( , hello world ) ; simpl ajp client ajp client = new simpl ajp client ( ) ; ajp client . set port ( get port ( ) ) ; ajp client . connect ( ) ; valid cpong ( ajp client . cping ( ) ) ; tester ajp messag forward messag = ajp client . creat forward messag ( ) ; complet messag extra header requir . forward messag . end ( ) ; two request ( int i = 0 ; i 2 ; i ) { tester ajp messag respons header = ajp client . send messag ( forward messag ) ; expect 3 packet : header , bodi , end valid respons header ( respons header , 200 ) ; tester ajp messag respons bodi = ajp client . read messag ( ) ; valid respons bodi ( respons bodi , hello world servlet . respons text ) ; valid respons end ( ajp client . read messag ( ) , true ) ; give connect plenti time time out thread . sleep ( 2000 ) ; doubl check connect still open valid cpong ( ajp client . cping ( ) ) ; } ajp client . disconnect ( ) ; }	test public void test simpl post ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; us normal tomcat root context file root = new file ( test webapp ) ; tomcat . add webapp ( , root . get absolut path ( ) ) ; tomcat . start ( ) ; simpl ajp client ajp client = new simpl ajp client ( ) ; ajp client . set port ( get port ( ) ) ; ajp client . connect ( ) ; valid cpong ( ajp client . cping ( ) ) ; tester ajp messag forward messag = ajp client . creat forward messag ( echo param . jsp , 4 ) ; forward messag . add header ( 0x a008 , 9 ) ; forward messag . add header ( 0x a007 , applic x www form urlencod ) ; forward messag . end ( ) ; tester ajp messag bodi messag = ajp client . creat bodi messag ( test = data . get byte ( ) ) ; tester ajp messag respons header = ajp client . send messag ( forward messag , bodi messag ) ; expect 3 messag : header , bodi , end valid respons header ( respons header , 200 ) ; skip bodi tester ajp messag respons bodi = ajp client . read messag ( ) ; valid respons bodi ( respons bodi , test data ) ; valid respons end ( ajp client . read messag ( ) , true ) ; doubl check connect still open valid cpong ( ajp client . cping ( ) ) ; ajp client . disconnect ( ) ; }
privat void silenc ( host host , string ctx ) { string base = org . apach . catalina . core . contain base . default . ; ( host = = null ) { base = get host ( ) . get name ( ) ; } els { base = host . get name ( ) ; } base = . ; base = ctx ; base = ; logger . get logger ( base ) . set level ( level . warn ) ; }	public see add webapp ( string , string ) context add webapp ( host host , string url , string name , string path ) { silenc ( host , url ) ; context ctx = new standard context ( ) ; ctx . set name ( name ) ; ctx . set path ( url ) ; ctx . set doc base ( path ) ; ctx . add lifecycl listen ( new default web xml listen ( ) ) ; context config ctx cfg = new context config ( ) ; ctx . add lifecycl listen ( ctx cfg ) ; prevent from look ( find ll have dup error ) ctx cfg . set default web xml ( default web xml path ( ) ) ; ( host = = null ) { get host ( ) . add child ( ctx ) ; } els { host . add child ( ctx ) ; } return ctx ; }	overrid public string get servlet class ( ) { return exist . get class ( ) . get name ( ) ; }	public hostnam default host , default localhost . void set hostnam ( string s ) { hostnam = s ; }	test public void test bug53301 ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp org . apach . catalina . context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; init count init count = new init count ( ) ; tomcat . add servlet ( ctx , init count , init count ) ; ctx . add servlet map ( , init count ) ; tomcat . start ( ) ; byte chunk re = get url ( http : localhost : get port ( ) ) ; assert equal ( ok , re . string ( ) ) ; assert equal ( 1 , init count . get call count ( ) ) ; }
protect compar session get compar ( string sort ) { compar session compar = null ; ( creation time . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session . get creation time ( ) ) ; } } ; } els ( id . equal ignor case ( sort ) ) { compar = new base session compar string ( ) { overrid public compar string get compar object ( session session ) { return session . get id ( ) ; } } ; } els ( last access time . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session . get last access time ( ) ) ; } } ; } els ( max inact interv . equal ignor case ( sort ) ) { compar = new base session compar integ ( ) { overrid public compar integ get compar object ( session session ) { return integ . valu ( session . get max inact interv ( ) ) ; } } ; } els ( new . equal ignor case ( sort ) ) { compar = new base session compar boolean ( ) { overrid public compar boolean get compar object ( session session ) { return boolean . valu ( session . get session ( ) . new ( ) ) ; } } ; } els ( local . equal ignor case ( sort ) ) { compar = new base session compar string ( ) { overrid public compar string get compar object ( session session ) { return jsp helper . guess displai local from session ( session ) ; } } ; } els ( user . equal ignor case ( sort ) ) { compar = new base session compar string ( ) { overrid public compar string get compar object ( session session ) { return jsp helper . guess displai user from session ( session ) ; } } ; } els ( us time . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session util . get us time session ( session ) ) ; } } ; } els ( inact time . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session util . get inact time session ( session ) ) ; } } ; } els ( ttl . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session util . get ttlfor session ( session ) ) ; } } ; } todo : complet thi ttl , etc . return compar ; }
public static media type pars media type ( string reader input ) throw ioexcept { type ( requir ) string type = read token ( input ) ; ( type = = null type . length ( ) = = 0 ) { return null ; } ( skip constant ( input , ) = = skip constant result . found ) { return null ; } subtyp ( requir ) string subtyp = read token ( input ) ; ( subtyp = = null subtyp . length ( ) = = 0 ) { return null ; } link hash map string , string paramet = new link hash map ( ) ; skip constant result look semi colon = skip constant ( input , ; ) ; ( look semi colon = = skip constant result . found ) { return null ; } while ( look semi colon = = skip constant result . found ) { string attribut = read token ( input ) ; ( skip constant ( input , = ) = = skip constant result . found ) { string valu = read token quot string ( input , true ) ; paramet . put ( attribut . lower case ( local . english ) , valu ) ; } els { paramet . put ( attribut . lower case ( local . english ) , ) ; } look semi colon = skip constant ( input , ; ) ; ( look semi colon = = skip constant result . found ) { return null ; } } return new media type ( type , subtyp , paramet ) ; }	test public void test bug53353 ( ) throw ioexcept { string input = text html ; utf 8 ; charset = utf 8 ; string reader sr = new string reader ( input ) ; media type m = http parser . pars media type ( sr ) ; check type assert equal ( text , m . get type ( ) ) ; assert equal ( html , m . get subtyp ( ) ) ; check paramet assert true ( m . get paramet count ( ) = = 2 ) ; assert equal ( , m . get paramet valu ( utf 8 ) ) ; assert equal ( utf 8 , m . get charset ( ) ) ; note : invalid input filter out assert equal ( text html ; charset = utf 8 , m . string ( ) ) ; assert equal ( utf 8 , m . get charset ( ) ) ; }
overrid public object get valu ( evalu context ctx ) throw elexcept { function mapper fn mapper = ctx . get function mapper ( ) ; quickli valid again thi request ( fn mapper = = null ) { throw new elexcept ( messag factori . get ( error . fn mapper . null ) ) ; } method m = fn mapper . resolv function ( thi . prefix , thi . local name ) ; ( m = = null thi . prefix . length ( ) = = 0 ) { todo : do we need think about preced variou wai lambda express mai obtain from someth parser think function object obj = null ; ( ctx . lambda argument ( thi . local name ) ) { obj = ctx . get lambda argument ( thi . local name ) ; } ( obj = = null ) { variabl mapper var mapper = ctx . get variabl mapper ( ) ; ( var mapper = null ) { obj = var mapper . resolv variabl ( thi . local name ) ; ( obj instanceof valu express ) { see thi return lambda express obj = ( ( valu express ) obj ) . get valu ( ctx ) ; } } } ( obj = = null ) { obj = ctx . get elresolv ( ) . get valu ( ctx , null , thi . local name ) ; } ( obj instanceof lambda express ) { build argument int i = 0 ; while ( obj instanceof lambda express i jjt get num children ( ) ) { node arg = jjt get child ( i ) ; obj = ( ( lambda express ) obj ) . invok ( ( ( ast method paramet ) arg ) . get paramet ( ctx ) ) ; i ; } ( i jjt get num children ( ) ) { were too mani set paramet throw new elexcept ( messag factori . get ( error . lambda . too mani method paramet set ) ) ; } return obj ; } } ( m = = null ) { throw new elexcept ( messag factori . get ( error . fn mapper . method , thi . get output name ( ) ) ) ; } singl set method paramet ( thi . jjt get num children ( ) = 1 ) { throw new elexcept ( messag factori . get ( error . funciton . too mani method paramet set , get output name ( ) ) ) ; } node paramet = jjt get child ( 0 ) ; class param type = m . get paramet type ( ) ; object param = null ; object result = null ; int num param = paramet . jjt get num children ( ) ; ( num param 0 ) { param = new object num param ; try { ( int i = 0 ; i num param ; i ) { param i = paramet . jjt get child ( i ) . get valu ( ctx ) ; param i = coerc type ( param i , param type i ) ; } } catch ( elexcept el ) { throw new elexcept ( messag factori . get ( error . function , thi . get output name ( ) ) , el ) ; } } try { result = m . invok ( null , param ) ; } catch ( illeg access except iae ) { throw new elexcept ( messag factori . get ( error . function , thi . get output name ( ) ) , iae ) ; } catch ( invoc target except ) { throwabl caus = . get caus ( ) ; ( caus instanceof thread death ) { throw ( thread death ) caus ; } ( caus instanceof virtual machin error ) { throw ( virtual machin error ) caus ; } throw new elexcept ( messag factori . get ( error . function , thi . get output name ( ) ) , caus ) ; } return result ; }
public boolean finish ( ) { return avail ( ) = = 0 ; }	public return true attempt ha been made read request bodi all request bodi ha been read boolean finish ( ) { atom boolean result = new atom boolean ( fals ) ; coyot request . action ( action code . request bodi fulli read , result ) ; return result . get ( ) ; }	overrid public void complet ( async event event ) throw ioexcept { log . info ( complet ) ; }	overrid public void error ( throwabl throwabl ) { log . info ( read listen . error ) ; throwabl . print stack trace ( ) ; }	public void set avail ( int avail ) { thi . avail = avail ; }	public void set read listen ( read listen listen ) { coyot request . set read listen ( listen ) ; requir . ( finish ( ) readi ( ) ) { coyot request . action ( action code . dispatch read , null ) ; } }	test public void test non block write error ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp standard context ctx = ( standard context ) tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; tester access log valv alv = new tester access log valv ( ) ; ctx . get pipelin ( ) . add valv ( alv ) ; nbwrite servlet servlet = new nbwrite servlet ( ) ; string servlet name = nbwrite servlet . class . get name ( ) ; tomcat . add servlet ( ctx , servlet name , servlet ) ; ctx . add servlet map ( , servlet name ) ; tomcat . get connector ( ) . set properti ( socket . tx buf size , 1024 ) ; tomcat . start ( ) ; socket factori factori = socket factori . get default ( ) ; socket s = factori . creat socket ( localhost , get port ( ) ) ; byte chunk result = new byte chunk ( ) ; output stream os = s . get output stream ( ) ; os . write ( ( get http 1 . 1 r n host : localhost : get port ( ) r n connect : close r n r n ) . get byte ( standard charset . iso 8859 1 ) ) ; os . flush ( ) ; input stream = s . get input stream ( ) ; byte buffer = new byte 8192 ; int read = 0 ; int read sinc last paus = 0 ; int read total = 0 ; while ( read = 1 read total write size 2 ) { long start = system . current time milli ( ) ; read = . read ( buffer ) ; long end = system . current time milli ( ) ; log . info ( client read read byte ( end start ) ms ) ; ( read 0 ) { result . append ( buffer , 0 , read ) ; } read sinc last paus = read ; read total = read ; ( read sinc last paus write size 16 ) { read sinc last paus = 0 ; thread . sleep ( write paus ms ) ; } } os . close ( ) ; . close ( ) ; s . close ( ) ; string result string = result . string ( ) ; log . info ( client read result string . length ( ) byte ) ; int line start = 0 ; int line end = result string . index ( n , 0 ) ; string line = result string . substr ( line start , line end 1 ) ; assert . assert equal ( http 1 . 1 200 ok r n , line ) ; try { allow listen finish up thread . sleep ( 1000 ) ; } catch ( except e ) { } assert . assert true ( error listen should have been invok . , servlet . wlisten . error invok ) ; todo figur out why non block write nio connector appear slower linux alv . valid access log ( 1 , 500 , write paus ms 7 , write paus ms 7 30 1000 ) ; }
privat map string , segment get segment ( ) { return segment ; }	public map string , string match ( uri templat candid ) { map string , string result = new hash map ( ) ; should happen safeti ( candid . get segment count ( ) = get segment count ( ) ) { return null ; } iter segment candid segment = candid . get segment ( ) . valu ( ) . iter ( ) ; iter segment target segment = segment . valu ( ) . iter ( ) ; while ( candid segment . ha next ( ) ) { segment candid segment = candid segment . next ( ) ; segment target segment = target segment . next ( ) ; ( target segment . get paramet index ( ) = = 1 ) { paramet valu must match ( target segment . get valu ( ) . equal ( candid segment . get valu ( ) ) ) { match . stop here return null ; } } els { paramet result . put ( target segment . get valu ( ) , candid segment . get valu ( ) ) ; } } return result ; }	test ( expect = java . lang . illeg argument except . class ) public void test duplic ( ) throw except { suppress warn ( unus ) uri templat t = new uri templat ( { var } { var } ) ; }	test public void test spec example2 03 ( ) throw except { uri templat t = new uri templat ( { var } ) ; map string , string result = t . match ( new uri templat ( ) ) ; assert . assert null ( result ) ; }	test public void test spec example2 04 ( ) throw except { uri templat t = new uri templat ( { var } ) ; map string , string result = t . match ( new uri templat ( b c ) ) ; assert . assert null ( result ) ; }
protect synchron return princip associ given user name . princip get princip ( dir context context , string usernam , gsscredenti gss credenti ) throw name except { user user = null ; list string role = null ; try { ( gss credenti = null us deleg credenti ( ) ) { set up context context . add environ ( context . secur authent , gssapi ) ; context . add environ ( javax . secur . sasl . server . authent , true ) ; context . add environ ( javax . secur . sasl . qop , auth conf ) ; note : subject alreadi set spnego authent so need subject . do ( ) here } user = get user ( context , usernam ) ; ( user = null ) { role = get role ( context , user ) ; } } final { try { context . remov from environ ( context . secur authent ) ; } catch ( name except e ) { ignor } try { context . remov from environ ( javax . secur . sasl . server . authent ) ; } catch ( name except e ) { ignor } try { context . remov from environ ( javax . secur . sasl . qop ) ; } catch ( name except e ) { ignor } } ( user = null ) { return new gener princip ( user . get user name ( ) , user . get password ( ) , role , null , null , gss credenti ) ; } return null ; }
load return session associ specifi session identifi from thi store , without remov . store session , return code null code . param id session identifi session load except class found except deseri error occur except ioexcept input output error occur overrid public session load ( string id ) throw class found except , ioexcept { open input stream specifi pathnam , ani file file = file ( id ) ; ( file = = null ) { return ( null ) ; } ( file . exist ( ) ) { return ( null ) ; } ( manag . get context ( ) . get logger ( ) . debug enabl ( ) ) { manag . get context ( ) . get logger ( ) . debug ( sm . get string ( get store name ( ) . load , id , file . get absolut path ( ) ) ) ; } file input stream fi = null ; buffer input stream bi = null ; object input stream oi = null ; loader loader = null ; class loader class loader = null ; try { fi = new file input stream ( file . get absolut path ( ) ) ; bi = new buffer input stream ( fi ) ; context context = manag . get context ( ) ; ( context = null ) loader = context . get loader ( ) ; ( loader = null ) class loader = loader . get class loader ( ) ; ( class loader = null ) oi = new custom object input stream ( bi , class loader ) ; els oi = new object input stream ( bi ) ; } catch ( file found except e ) { ( manag . get context ( ) . get logger ( ) . debug enabl ( ) ) manag . get context ( ) . get logger ( ) . debug ( persist data file found ) ; return ( null ) ; } catch ( ioexcept e ) { ( bi = null ) { try { bi . close ( ) ; } catch ( ioexcept f ) { ignor } } ( fi = null ) { try { fi . close ( ) ; } catch ( ioexcept f ) { ignor } } throw e ; } try { standard session session = ( standard session ) manag . creat empti session ( ) ; session . read object data ( oi ) ; session . set manag ( manag ) ; return ( session ) ; } final { close input stream try { oi . close ( ) ; } catch ( ioexcept f ) { ignor } } }	load session associ id code id code . session found code null code return . param id valu type code string code return store code session code except class found except error occur except ioexcept input output error occur overrid public session load ( string id ) throw class found except , ioexcept { result set rst = null ; standard session session = null ; loader loader = null ; class loader class loader = null ; object input stream oi = null ; buffer input stream bi = null ; org . apach . catalina . context context = manag . get context ( ) ; synchron ( thi ) { int number tri = 2 ; while ( number tri 0 ) { connect conn = get connect ( ) ; ( conn = = null ) { return ( null ) ; } try { ( prepar load sql = = null ) { string load sql = select session id col , session data col from session tabl where session id col = session app col = ; prepar load sql = conn . prepar statement ( load sql ) ; } prepar load sql . set string ( 1 , id ) ; prepar load sql . set string ( 2 , get name ( ) ) ; rst = prepar load sql . execut queri ( ) ; ( rst . next ( ) ) { bi = new buffer input stream ( rst . get binari stream ( 2 ) ) ; ( context = null ) { loader = context . get loader ( ) ; } ( loader = null ) { class loader = loader . get class loader ( ) ; } ( class loader = null ) { oi = new custom object input stream ( bi , class loader ) ; } els { oi = new object input stream ( bi ) ; } ( manag . get context ( ) . get logger ( ) . debug enabl ( ) ) { manag . get context ( ) . get logger ( ) . debug ( sm . get string ( get store name ( ) . load , id , session tabl ) ) ; } session = ( standard session ) manag . creat empti session ( ) ; session . read object data ( oi ) ; session . set manag ( manag ) ; } els ( manag . get context ( ) . get logger ( ) . debug enabl ( ) ) { manag . get context ( ) . get logger ( ) . debug ( get store name ( ) : persist data object found ) ; } break out after final block number tri = 0 ; } catch ( sqlexcept e ) { manag . get context ( ) . get logger ( ) . error ( sm . get string ( get store name ( ) . sqlexcept , e ) ) ; ( db connect = null ) close ( db connect ) ; } final { try { ( rst = null ) { rst . close ( ) ; } } catch ( sqlexcept e ) { ignor } ( oi = null ) { try { oi . close ( ) ; } catch ( ioexcept e ) { ignor } } releas ( conn ) ; } number tri ; } } return ( session ) ; }

protect valid usag secur role name web applic deploy descriptor . ani problem ar found , issu warn messag ( backward compat ) add miss role . ( make problem fatal instead , simpli set code ok code instanc variabl code fals code well ) . void valid secur role ( ) { check role name us secur constraint element secur constraint constraint = context . find constraint ( ) ; ( int i = 0 ; i constraint . length ; i ) { string role = constraint i . find auth role ( ) ; ( int j = 0 ; j role . length ; j ) { ( . equal ( role j ) context . find secur role ( role j ) ) { log . info ( sm . get string ( context config . role . auth , role j ) ) ; context . add secur role ( role j ) ; } } } check role name us servlet element contain wrapper = context . find children ( ) ; ( int i = 0 ; i wrapper . length ; i ) { wrapper wrapper = ( wrapper ) wrapper i ; string run = wrapper . get run ( ) ; ( ( run = null ) context . find secur role ( run ) ) { log . info ( sm . get string ( context config . role . runa , run ) ) ; context . add secur role ( run ) ; } string name = wrapper . find secur refer ( ) ; ( int j = 0 ; j name . length ; j ) { string link = wrapper . find secur refer ( name j ) ; ( ( link = null ) context . find secur role ( link ) ) { log . info ( sm . get string ( context config . role . link , link ) ) ; context . add secur role ( link ) ; } } } }
privat configur from code log manag code properti . void configur ( ) { timestamp ts = new timestamp ( system . current time milli ( ) ) ; string ts string = ts . string ( ) . substr ( 0 , 19 ) ; date = ts string . substr ( 0 , 10 ) ; allow class overrid string class name = thi . get class ( ) . get name ( ) ; class loader cl = thread . current thread ( ) . get context class loader ( ) ; retriev configur log file name rotat = boolean . pars boolean ( get properti ( class name . rotat , true ) ) ; ( directori = = null ) directori = get properti ( class name . directori , log ) ; ( prefix = = null ) prefix = get properti ( class name . prefix , juli . ) ; ( suffix = = null ) suffix = get properti ( class name . suffix , . log ) ; string s buffer size = get properti ( class name . buffer size , string . valu ( buffer size ) ) ; try { buffer size = integ . pars int ( s buffer size ) ; } catch ( number format except ignor ) { op } get encod log file string encod = get properti ( class name . encod , null ) ; ( encod = null encod . length ( ) 0 ) { try { set encod ( encod ) ; } catch ( unsupport encod except ex ) { ignor } } get log level handler set level ( level . pars ( get properti ( class name . level , level . all ) ) ) ; get filter configur string filter name = get properti ( class name . filter , null ) ; ( filter name = null ) { try { set filter ( ( filter ) cl . load class ( filter name ) . new instanc ( ) ) ; } catch ( except e ) { ignor } } set formatt string formatt name = get properti ( class name . formatt , null ) ; ( formatt name = null ) { try { set formatt ( ( formatt ) cl . load class ( formatt name ) . new instanc ( ) ) ; } catch ( except e ) { ignor fallback default set formatt ( new simpl formatt ( ) ) ; } } els { set formatt ( new simpl formatt ( ) ) ; } set error manag set error manag ( new error manag ( ) ) ; }
public get time thi context wa start . return time ( millisecond sinc januari 1 , 1970 , 00 : 00 : 00 ) when thi context wa start long get start time ( ) { return start time ; }
return password associ given princip s user name . overrid protect synchron string get password ( string usernam ) { look up user s credenti string db credenti = null ; prepar statement stmt = null ; result set rs = null ; number tri number attempt connect databas dure thi login attempt ( we need open databas ) thi need rewritten better pool support , exist code need signatur chang sinc prepar statement need cach connect . code below try twice sqlexcept so connect mai try open again . normal condit ( includ invalid login abov onli us onc . int number tri = 2 ; while ( number tri 0 ) { try { ensur we have open databas connect open ( ) ; stmt = credenti ( db connect , usernam ) ; rs = stmt . execut queri ( ) ; db connect . commit ( ) ; ( rs . next ( ) ) { db credenti = rs . get string ( 1 ) ; } ( db credenti = null ) { db credenti = db credenti . trim ( ) ; } return db credenti ; } catch ( sqlexcept e ) { log problem poster contain log . error ( sm . get string ( jdbc realm . except ) , e ) ; } final { ( rs = null ) { try { rs . close ( ) ; } catch ( sqlexcept e ) { contain log . warn ( sm . get string ( jdbc realm . abnorm close result set ) ) ; } } } close connect so get reopen next time ( db connect = null ) { close ( db connect ) ; } number tri ; } return ( null ) ; }
privat void send close messag ( close reason close reason ) { 125 maximum size payload control messag byte buffer msg = byte buffer . alloc ( 125 ) ; msg . put short ( ( short ) close reason . get close code ( ) . get code ( ) ) ; string reason = close reason . get reason phrase ( ) ; ( reason = null reason . length ( ) 0 ) { append close reason truncat ( msg , reason ) ; } msg . flip ( ) ; try { ws remot endpoint . start messag block ( constant . opcod close , msg , true ) ; } catch ( ioexcept ioe ) { fail send close messag . close socket let caller deal except log . error ( sm . get string ( ws session . send close fail ) , ioe ) ; ws remot endpoint . close ( ) ; local endpoint . error ( thi , ioe ) ; } final { web socket contain . unregist session ( local endpoint , thi ) ; } }
privat extract jar name , present , from url string get jar name ( url url ) { string name = null ; string path = url . get path ( ) ; int end = path . index ( constant . jar ext ) ; ( end = 1 ) { int start = path . last index ( , end ) ; name = path . substr ( start 1 , end 4 ) ; } els ( scan all directori ( ) ) { int start = path . last index ( ) ; name = path . substr ( start 1 ) ; } return name ; }	privat sinc class loader hierarchi can get complic , thi method attempt appli follow rule : class loader web applic class loader unless load thi class ( standard jar scanner ) parent class loader load thi class . thi should mean : webapp class loader applic class loader share class loader applic class loader server class loader applic class loader common class loader applic class loader system class loader applic class loader bootstrap class loader applic class loader boolean webapp class loader ( class loader class loader ) { class loader non webapp loader = standard jar scanner . class . get class loader ( ) ; while ( non webapp loader = null ) { ( non webapp loader = = class loader ) { return fals ; } non webapp loader = non webapp loader . get parent ( ) ; } return true ; }	privat scan url jar option extens look all file all directori . void process ( jar scanner callback callback , url url , boolean webapp ) throw ioexcept { ( log . trace enabl ( ) ) { log . trace ( sm . get string ( jar scan . jar url start , url ) ) ; } urlconnect conn = url . open connect ( ) ; ( conn instanceof jar urlconnect ) { callback . scan ( ( jar urlconnect ) conn , webapp ) ; } els { string url str = url . string ( ) ; ( url str . start ( file : ) url str . start ( jndi : ) url str . start ( http : ) url str . start ( http : ) ) { ( url str . end ( constant . jar ext ) ) { url jar url = new url ( jar : url str ) ; callback . scan ( ( jar urlconnect ) jar url . open connect ( ) , webapp ) ; } els { file f ; try { f = new file ( url . uri ( ) ) ; ( f . file ( ) scan all file ) { treat thi file jar url jar url = new url ( jar : url str ) ; callback . scan ( ( jar urlconnect ) jar url . open connect ( ) , webapp ) ; } els ( f . directori ( ) scan all directori ) { file metainf = new file ( f . get absolut file ( ) file . separ meta inf ) ; ( metainf . directori ( ) ) { callback . scan ( f , webapp ) ; } } } catch ( urisyntax except e ) { wrap except re throw ioexcept ioe = new ioexcept ( ) ; ioe . init caus ( e ) ; throw ioe ; } } } } }	scan provid servlet context class loader jar file . each jar file found pass callback handler process . param scan type type jar scan perform . thi pass filter which us determin how filter result param context servlet context us locat access web inf lib param callback handler process ani jar found overrid public void scan ( jar scan type scan type , servlet context context , jar scanner callback callback ) { ( log . trace enabl ( ) ) { log . trace ( sm . get string ( jar scan . webinflib start ) ) ; } scan web inf lib set string dir list = context . get resourc path ( constant . web inf lib ) ; ( dir list = null ) { iter string = dir list . iter ( ) ; while ( . ha next ( ) ) { string path = . next ( ) ; ( path . end ( constant . jar ext ) jar scan filter . check ( scan type , path . substr ( path . last index ( ) 1 ) ) ) { need scan thi jar ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jar scan . webinflib jar scan , path ) ) ; } url url = null ; try { file url ar alwai faster work so us them avail . string real path = context . get real path ( path ) ; ( real path = = null ) { url = context . get resourc ( path ) ; } els { url = ( new file ( real path ) ) . uri ( ) . url ( ) ; } process ( callback , url , true ) ; } catch ( ioexcept e ) { log . warn ( sm . get string ( jar scan . webinflib fail , url ) , e ) ; } } els { ( log . trace enabl ( ) ) { log . trace ( sm . get string ( jar scan . webinflib jar scan , path ) ) ; } } } } scan web inf class ( scan all directori ) { try { url url = context . get resourc ( web inf class meta inf ) ; ( url = null ) { try { callback . scan web inf class ( ) ; } catch ( ioexcept e ) { log . warn ( sm . get string ( jar scan . webinfclass fail ) , e ) ; } } } catch ( malform urlexcept e ) { ignor } } scan classpath ( scan class path ) { ( log . trace enabl ( ) ) { log . trace ( sm . get string ( jar scan . classload start ) ) ; } class loader stop loader = null ; ( scan bootstrap class path ) { stop when we reach bootstrap class loader stop loader = class loader . get system class loader ( ) . get parent ( ) ; } class loader class loader = context . get class loader ( ) ; need scan web applic class loader we have alreadi scan web inf lib web inf class class loader = class loader . get parent ( ) ; jar ar treat applic provid until common class loader reach . boolean webapp = true ; while ( class loader = null class loader = stop loader ) { ( class loader instanceof urlclass loader ) { ( webapp ) { webapp = webapp class loader ( class loader ) ; } url url = ( ( urlclass loader ) class loader ) . get url ( ) ; ( int i = 0 ; i url . length ; i ) { extract jar name found string jar name = get jar name ( url i ) ; skip jar known interest ( jar name = null jar scan filter . check ( scan type , jar name ) ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jar scan . classload jar scan , url i ) ) ; } try { process ( callback , url i , webapp ) ; } catch ( ioexcept ioe ) { log . warn ( sm . get string ( jar scan . classload fail , url i ) , ioe ) ; } } els { ( log . trace enabl ( ) ) { log . trace ( sm . get string ( jar scan . classload jar scan , url i ) ) ; } } } } class loader = class loader . get parent ( ) ; } } }
privat invok tag plugin given custom tag , plugin exist custom tag s tag handler . given custom tag node manipul plugin . void invok plugin ( node . custom tag n ) { tag plugin tag plugin = tag plugin . get ( n . get tag handler class ( ) . get name ( ) ) ; ( tag plugin = = null ) { return ; } tag plugin context tag plugin context = new tag plugin context impl ( n , page info ) ; n . set tag plugin context ( tag plugin context ) ; tag plugin . do tag ( tag plugin context ) ; }	privat void load tag plugin ( error dispatch err , input stream ) throw jasper except { tree node root = ( new parser util ( ) ) . pars xmldocument ( tag plugin xml , ) ; ( root = = null ) { return ; } ( tag plugin root elem . equal ( root . get name ( ) ) ) { err . jsp error ( jsp . error . plugin . wrong root element , tag plugin xml , tag plugin root elem ) ; } tag plugin = new hash map ( ) ; iter tree node plugin list = root . find children ( tag plugin ) ; while ( plugin list . ha next ( ) ) { tree node plugin node = plugin list . next ( ) ; tree node tag class node = plugin node . find child ( tag class ) ; ( tag class node = = null ) { error return ; } string tag class = tag class node . get bodi ( ) . trim ( ) ; tree node plugin class node = plugin node . find child ( plugin class ) ; ( plugin class node = = null ) { error return ; } string plugin class str = plugin class node . get bodi ( ) ; tag plugin tag plugin = null ; try { class plugin class = ctxt . get class loader ( ) . load class ( plugin class str ) ; tag plugin = ( tag plugin ) plugin class . new instanc ( ) ; } catch ( except e ) { throw new jasper except ( e ) ; } ( tag plugin = = null ) { return ; } tag plugin . put ( tag class , tag plugin ) ; } initi = true ; }	public void appli ( node . node page , error dispatch err , page info page info ) throw jasper except { init ( err ) ; ( tag plugin = = null tag plugin . size ( ) = = 0 ) { return ; } thi . page info = page info ; page . visit ( new node . visitor ( ) { overrid } }
protect servlet contain initi get servlet contain initi ( string class name ) throw ioexcept { servlet contain initi sci = null ; try { class clazz = class . name ( class name , true , context . get loader ( ) . get class loader ( ) ) ; sci = ( servlet contain initi ) clazz . new instanc ( ) ; } catch ( class found except e ) { log . error ( sm . get string ( context config . invalid sci , class name ) , e ) ; throw new ioexcept ( e ) ; } catch ( instanti except e ) { log . error ( sm . get string ( context config . invalid sci , class name ) , e ) ; throw new ioexcept ( e ) ; } catch ( illeg access except e ) { log . error ( sm . get string ( context config . invalid sci , class name ) , e ) ; throw new ioexcept ( e ) ; } return sci ; }	protect web xml creat web xml ( ) { return new web xml ( ) ; }	protect extract name servlet contain initi . param resourc where name defin return class name throw ioexcept list servlet contain initi get servlet contain initi ( input stream ) throw ioexcept { list servlet contain initi initi = new arrai list ( ) ; ( = null ) { string line = null ; try { buffer reader br = new buffer reader ( new input stream reader ( , utf 8 ) ) ; while ( ( line = br . read line ( ) ) = null ) { line = line . trim ( ) ; ( line . length ( ) 0 ) { int i = line . index ( ) ; ( i 1 ) { ( i = = 0 ) { continu ; } line = line . substr ( 0 , i ) . trim ( ) ; } initi . add ( get servlet contain initi ( line ) ) ; } } } catch ( unsupport encod except e ) { should never happen utf 8 doe ignor return null } } return initi ; }	protect scan web . xml file appli web applic merg them us rule defin spec . global web . xml file , where duplic configur , most specif level win . ie applic s web . xml take preced over host level global web . xml file . void web config ( ) { anyth everyth can overrid global host default . thi implement two part handl web fragment get ad after everyth els so everyth els take prioriti mark servlet overrid so sci configur can replac configur from default rule annot scan ar clear cut might think . tomcat implement follow process : per srv . 1 . 6 . 2 , tomcat scan annot regardless which servlet spec version declar web . xml . eg ha confirm thi expect behaviour . per http : java . net jira brows servlet spec 36 , main web . xml mark metadata complet , jar ar still process sci . metadata complet = true absolut order specifi , jar exclud from order ar also exclud from sci process . sci ha handl type annot all class ( except those jar exclud from absolut order ) need scan check thei match . set web xml default = new hash set ( ) ; default . add ( get default web xml fragment ( ) ) ; web xml web xml = creat web xml ( ) ; pars context level web . xml input sourc context web xml = get context web xml sourc ( ) ; ( web xml parser . pars web xml ( context web xml , web xml , fals ) ) { ok = fals ; } servlet context s context = context . get servlet context ( ) ; order import here step 1 . identifi all jar packag applic those provid contain . ani applic jar have web fragment . xml pars thi point . web fragment . xml file ar ignor contain provid jar . map string , web xml fragment = process jar web fragment ( ) ; step 2 . order fragment . set web xml order fragment = null ; order fragment = web xml . order web fragment ( web xml , fragment , s context ) ; step 3 . look servlet contain initi implement ( ok ) { process servlet contain initi ( order fragment ) ; } ( web xml . metadata complet ( ) type initi map . size ( ) 0 ) { step 4 . process web inf class annot ( ok ) { web resourc web resourc = context . get resourc ( ) . list resourc ( web inf class ) ; ( web resourc web resourc : web resourc ) { process annot web resourc ( web resourc , web xml , web xml . metadata complet ( ) ) ; } } those fragment we ar go us ( ok ) { process annot ( order fragment , web xml . metadata complet ( ) ) ; } cach , us , longer requir so clear java class cach . clear ( ) ; } ( web xml . metadata complet ( ) ) { file . ( ok ) { ok = web xml . merg ( order fragment ) ; } step 7 . appli global default have merg default befor jsp convers sinc default provid jsp servlet definit . web xml . merg ( default ) ; step 8 . convert explicitli mention jsp servlet ( ok ) { convert jsp ( web xml ) ; } step 9 . appli merg web . xml context ( ok ) { configur context ( web xml ) ; } } els { web xml . merg ( default ) ; convert jsp ( web xml ) ; configur context ( web xml ) ; } step 9a . make merg web . xml avail other compon , specif jasper , save those compon from have re gener . todo us servlet contain initi jasper string merg web xml = web xml . xml ( ) ; s context . set attribut ( org . apach . tomcat . util . scan . constant . merg web xml , merg web xml ) ; ( context . get log effect web xml ( ) ) { log . info ( web . xml : n merg web xml ) ; } step 10 . look static resourc packag jar ( ok ) { spec doe defin order . us order jar follow remain jar set web xml resourc jar = new link hash set ( ) ; ( order fragment = null ) { ( web xml fragment : order fragment ) { resourc jar . add ( fragment ) ; } } ( web xml fragment : fragment . valu ( ) ) { ( resourc jar . contain ( fragment ) ) { resourc jar . add ( fragment ) ; } } process resourc jar ( resourc jar ) ; see also standard context . resourc start ( ) web inf class meta inf resourc configur } context ( ok ) { ( map . entri servlet contain initi , set class >> entri : initi class map . entri set ( ) ) { ( entri . get valu ( ) . empti ( ) ) { context . add servlet contain initi ( entri . get kei ( ) , null ) ; } els { context . add servlet contain initi ( entri . get kei ( ) , entri . get valu ( ) ) ; } } } }
privat int do write intern ( boolean block , byte b , int off , int len ) throw ioexcept { channel . get buf handler ( ) . get write buffer ( ) . clear ( ) ; channel . get buf handler ( ) . get write buffer ( ) . put ( b , off , len ) ; channel . get buf handler ( ) . get write buffer ( ) . flip ( ) ; int written = 0 ; nio endpoint . kei attach att = ( nio endpoint . kei attach ) channel . get attach ( fals ) ; ( att = = null ) { throw new ioexcept ( kei must cancel ) ; } long write timeout = att . get timeout ( ) ; selector selector = null ; try { selector = pool . get ( ) ; } catch ( ioexcept x ) { ignor } try { written = pool . write ( channel . get buf handler ( ) . get write buffer ( ) , channel , selector , write timeout , block ) ; } final { ( selector = null ) { pool . put ( selector ) ; } } ( written len ) { channel . get poller ( ) . add ( channel , select kei . op write ) ; } return written ; }	privat synchron param bytebuff byte buffer param flip boolean return int throw ioexcept int write socket ( byte buffer bytebuff , boolean block , boolean flip ) throw ioexcept { ( flip ) { bytebuff . flip ( ) ; flip = true ; } int written = 0 ; nio endpoint . kei attach att = ( nio endpoint . kei attach ) socket . get attach ( fals ) ; ( att = = null ) throw new ioexcept ( kei must cancel ) ; long write timeout = att . get timeout ( ) ; selector selector = null ; try { selector = pool . get ( ) ; } catch ( ioexcept x ) { ignor } try { written = pool . write ( bytebuff , socket , selector , write timeout , block ) ; make sure we ar flush do { ( socket . flush ( true , selector , write timeout ) ) break ; } while ( true ) ; } final { ( selector = null ) pool . put ( selector ) ; } ( block bytebuff . remain ( ) = = 0 ) { block write must empti buffer remain = = 0 we did empti bytebuff . clear ( ) ; flip = fals ; } write registr . return written ; }	public sendfil data get sendfil data ( ) { return thi . sendfil data ; }	overrid protect void do flush ( ) throw ioexcept { nio endpoint . kei attach att = ( nio endpoint . kei attach ) channel . get attach ( fals ) ; ( att = = null ) { throw new ioexcept ( kei must cancel ) ; } long write timeout = att . get timeout ( ) ; selector selector = null ; try { selector = pool . get ( ) ; } catch ( ioexcept x ) { ignor } try { do { ( channel . flush ( true , selector , write timeout ) ) { break ; } } while ( true ) ; } final { ( selector = null ) { pool . put ( selector ) ; } } }	protect method overrid protect void output ( byte src , int offset , int length ) throw ioexcept { nio endpoint . kei attach att = ( nio endpoint . kei attach ) socket . get attach ( fals ) ; ( att = = null ) throw new ioexcept ( kei must cancel ) ; byte buffer write buffer = socket . get buf handler ( ) . get write buffer ( ) ; write buffer . put ( src , offset , length ) ; write buffer . flip ( ) ; long write timeout = att . get timeout ( ) ; selector selector = null ; try { selector = pool . get ( ) ; } catch ( ioexcept x ) { ignor } try { pool . write ( write buffer , socket , selector , write timeout , true ) ; } final { write buffer . clear ( ) ; ( selector = null ) pool . put ( selector ) ; } }	public void reset ( poller poller , nio channel channel , long so timeout ) { thi . socket = channel ; thi . poller = poller ; last access = system . current time milli ( ) ; set comet ( fals ) ; set timeout ( so timeout ) ; error = fals ; sendfil data = null ; ( read latch = null ) { try { ( int i = 0 ; i ( int ) read latch . get count ( ) ; i ) { read latch . count down ( ) ; } } catch ( except ignor ) { } } read latch = null ; ( write latch = null ) { try { ( int i = 0 ; i ( int ) write latch . get count ( ) ; i ) { write latch . count down ( ) ; } } catch ( except ignor ) { } } write latch = null ; comet notifi = fals ; sendfil data = null ; keep aliv left = 100 ; async = fals ; }
privat void regist authent session ( ws session ws session , string http session id ) { set ws session ws session = authent session . get ( http session id ) ; ( ws session = = null ) { ws session = collect . new set from map ( new concurr hash map ws session , boolean ( ) ) ; authent session . put absent ( http session id , ws session ) ; ws session = authent session . get ( http session id ) ; } ws session . add ( ws session ) ; }
public set string get includ coda ( ) { return includ coda ; }	public set string get includ prelud ( ) { return includ prelud ; }	public boolean get el ignor ( ) { return el ignor ; }	test public void test bug51584 ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; file app dir = new file ( test webapp fragment ) ; tomcat . add webapp ( null , test , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; further test requir . bug trigger infinit loop context start so test crash befor reach thi point fail }	public void test webapp ( ) throw except { file app dir = new file ( test webapp ) ; jsp cservlet context context = new jsp cservlet context ( null , app dir . uri ( ) . url ( ) ) ; assert . assert equal ( 3 , context . get effect major version ( ) ) ; assert . assert equal ( 1 , context . get effect minor version ( ) ) ; jsp config descriptor jsp config descriptor = context . get jsp config descriptor ( ) ; assert . assert true ( jsp config descriptor . get taglib ( ) . empti ( ) ) ; collect jsp properti group descriptor properti group = jsp config descriptor . get jsp properti group ( ) ; assert . assert equal ( 1 , properti group . size ( ) ) ; jsp properti group descriptor group descriptor = properti group . iter ( ) . next ( ) ; assert . assert equal ( text plain , group descriptor . get default content type ( ) ) ; collect string url pattern = group descriptor . get url pattern ( ) ; assert . assert equal ( 2 , url pattern . size ( ) ) ; iter string iter = url pattern . iter ( ) ; assert . assert equal ( bug49nnn bug49726a . jsp , iter . next ( ) ) ; assert . assert equal ( bug49nnn bug49726b . jsp , iter . next ( ) ) ; }
privat void process web dot xml ( ) { veri , veri unlik just case . . . ( ctxt . get effect major version ( ) 2 ) { default elignor = true ; default defer syntax allow liter = true ; return ; } ( ctxt . get effect major version ( ) = = 2 ) { ( ctxt . get effect minor version ( ) 5 ) { default defer syntax allow liter = true ; } ( ctxt . get effect minor version ( ) 4 ) { default elignor = true ; return ; } } jsp config descriptor jsp config = ctxt . get jsp config descriptor ( ) ; ( jsp config = = null ) { return ; } jsp properti = new vector ( ) ; collect jsp properti group descriptor jsp properti group = jsp config . get jsp properti group ( ) ; ( jsp properti group descriptor jsp properti group : jsp properti group ) { collect string url pattern = jsp properti group . get url pattern ( ) ; ( url pattern . size ( ) = = 0 ) { continu ; } match logic easier . ( string url pattern : url pattern ) { string path = null ; string extens = null ; ( url pattern . index ( ) 0 ) { exact match path = url pattern ; } els { int i = url pattern . last index ( ) ; string file ; ( i = 0 ) { path = url pattern . substr ( 0 , i 1 ) ; file = url pattern . substr ( i 1 ) ; } els { file = url pattern ; } pattern must , form . jsp ( file . equal ( ) ) { extens = ; } els ( file . start ( . ) ) { extens = file . substr ( file . index ( . ) 1 ) ; } url pattern ar reconstruct follow : path = null , extens = = null : foo bar . ext path = = null , extens = null : . ext path = null , extens = = : foo boolean star = . equal ( extens ) ; ( ( path = = null ( extens = = null star ) ) ( path = null star ) ) { ( log . warn enabl ( ) ) { log . warn ( local . get messag ( jsp . warn . bad . urlpattern . propertygroup , url pattern ) ) ; } continu ; } } vector string includ prelud = new vector ( ) ; includ prelud . add all ( jsp properti group . get includ prelud ( ) ) ; vector string includ coda = new vector ( ) ; includ coda . add all ( jsp properti group . get includ coda ( ) ) ; jsp properti properti = new jsp properti ( jsp properti group . get xml ( ) , jsp properti group . get el ignor ( ) , jsp properti group . get script invalid ( ) , jsp properti group . get page encod ( ) , includ prelud , includ coda , jsp properti group . get defer syntax allow liter ( ) , jsp properti group . get trim direct whitespac ( ) , jsp properti group . get default content type ( ) , jsp properti group . get buffer ( ) , jsp properti group . get error undeclar namespac ( ) ) ; jsp properti group properti group = new jsp properti group ( path , extens , properti ) ; jsp properti . add element ( properti group ) ; } } }

protect void init servlet context ( ) throw ioexcept , jasper except { todo : should we us ant project s log print writer log = new print writer ( system . out ) ; url resourc base = new file ( uri root ) . get canon file ( ) . uri ( ) . url ( ) ; context = new jsp cservlet context ( log , resourc base ) ; rctxt = new jsp runtim context ( context , thi ) ; jsp config = new jsp config ( context ) ; tag plugin manag = new tag plugin manag ( context ) ; }
public boolean pars web xml ( input sourc sourc , web xml dest , boolean fragment ) { boolean ok = true ; ( sourc = = null ) { return ok ; } xml error handler handler = new xml error handler ( ) ; digest digest ; web rule set rule set ; ( fragment ) { digest = web fragment digest ; rule set = web fragment rule set ; } els { digest = web digest ; rule set = web rule set ; } digest . push ( dest ) ; digest . set error handler ( handler ) ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( web xml parser . applic start , sourc . get system id ( ) ) ) ; } try { digest . pars ( sourc ) ; ( handler . get warn ( ) . size ( ) 0 handler . get error ( ) . size ( ) 0 ) { ok = fals ; handler . log find ( log , sourc . get system id ( ) ) ; } } catch ( saxpars except e ) { log . error ( sm . get string ( web xml parser . applic pars , sourc . get system id ( ) ) , e ) ; log . error ( sm . get string ( web xml parser . applic posit , e . get line number ( ) , e . get column number ( ) ) ) ; ok = fals ; } catch ( except e ) { log . error ( sm . get string ( web xml parser . applic pars , sourc . get system id ( ) ) , e ) ; ok = fals ; } final { input stream = sourc . get byte stream ( ) ; ( = null ) { try { . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } } digest . reset ( ) ; rule set . recycl ( ) ; } return ok ; }
privat void do run ( select kei kei , kei attach ka ) { boolean launch = fals ; try { int handshak = 1 ; try { ( kei = null ) { ( socket . handshak complet ( ) ) { handshak = 0 ; } els { handshak = socket . handshak ( kei . readabl ( ) , kei . writabl ( ) ) ; handshak process read write from socket . statu mai therefor open write onc handshak complet . howev , handshak happen when socket open so statu must alwai open read after complet . ok alwai set thi onli us handshak complet . statu = socket statu . open read ; } } } catch ( ioexcept x ) { handshak = 1 ; ( log . debug enabl ( ) ) log . debug ( error dure ssl handshak , x ) ; } catch ( cancel kei except ckx ) { handshak = 1 ; } ( handshak = = 0 ) { socket state state = socket state . open ; kei can t null thi block ( statu = = null ) { state = handler . process ( ka , socket statu . open read ) ; } els { state = handler . process ( ka , statu ) ; } ( state = = socket state . close ) { close socket pool try { ( ka = null ) ka . set comet ( fals ) ; socket . get poller ( ) . cancel kei ( kei , socket statu . error ) ; ( run paus ) { nio channel . push ( socket ) ; } socket = null ; ( run paus ka = null ) { kei cach . push ( ka ) ; } ka = null ; } catch ( except x ) { log . error ( , x ) ; } } els ( state = = socket state . long ka = null ka . async ( ) ka . interest op ( ) 0 ) { we ar async , we ar interest oper ka . get poller ( ) . add ( socket , ka . interest op ( ) ) ; } } els ( handshak = = 1 ) { ( kei = null ) { socket . get poller ( ) . cancel kei ( kei , socket statu . disconnect ) ; } ( run paus ) { nio channel . push ( socket ) ; } socket = null ; ( run paus ka = null ) { kei cach . push ( ka ) ; } ka = null ; } els { ka . get poller ( ) . add ( socket , handshak ) ; } } catch ( cancel kei except cx ) { socket . get poller ( ) . cancel kei ( kei , null ) ; } catch ( out memori error oom ) { try { oom parachut data = null ; log . error ( , oom ) ; ( socket = null ) { socket . get poller ( ) . cancel kei ( kei , socket statu . error ) ; } releas cach ( ) ; } catch ( throwabl oomt ) { try { system . err . println ( oom parachut msg ) ; oomt . print stack trace ( ) ; } catch ( throwabl let hope we dont get here ) { except util . handl throwabl ( let hope we dont get here ) ; } } } catch ( throwabl t ) { log . error ( , t ) ; ( socket = null ) { socket . get poller ( ) . cancel kei ( kei , socket statu . error ) ; } } final { ( launch ) { try { get executor ( ) . execut ( new socket processor ( socket , socket statu . open read ) ) ; } catch ( null pointer except npe ) { ( run ) { log . error ( sm . get string ( endpoint . launch . fail ) , npe ) ; } } } socket = null ; statu = null ; return cach ( run paus ) { processor cach . push ( thi ) ; } } }	overrid public final socket state upgrad dispatch ( socket statu statu ) throw ioexcept { ( statu = = socket statu . open read ) { upgrad servlet input stream . data avail ( ) ; } els ( statu = = socket statu . open write ) { upgrad servlet output stream . write possibl ( ) ; } els { unexpect state return socket state . close ; } ( upgrad servlet input stream . close requir ( ) upgrad servlet output stream . close requir ( ) ) { return socket state . close ; } return socket state . upgrad ; }
privat void clear handler ( throwabl t ) { send handler sh = handler ; handler = null ; ( t = = null ) { sh . result ( new send result ( ) ) ; } els { sh . result ( new send result ( t ) ) ; } }	protect void timeout ( ) { clear handler ( new socket timeout except ( ) ) ; close ( ) ; }
privat when commit respons , we have valid set header , well setup respons filter . void prepar respons ( ) { boolean entiti bodi = true ; content delimit = fals ; output filter output filter = get output buffer ( ) . get filter ( ) ; ( http09 = = true ) { http 0 . 9 get output buffer ( ) . add activ filter ( output filter constant . ident filter ) ; return ; } int statu code = respons . get statu ( ) ; ( statu code 200 statu code = = 204 statu code = = 205 statu code = = 304 ) { entiti bodi get output buffer ( ) . add activ filter ( output filter constant . void filter ) ; entiti bodi = fals ; content delimit = true ; } messag byte method mb = request . method ( ) ; ( method mb . equal ( head ) ) { entiti bodi get output buffer ( ) . add activ filter ( output filter constant . void filter ) ; content delimit = true ; } sendfil support boolean send sendfil = fals ; ( get endpoint ( ) . get us sendfil ( ) ) { send sendfil = prepar sendfil ( output filter ) ; } check compress boolean compress = fals ; boolean us compress = fals ; ( entiti bodi ( compress level 0 ) send sendfil ) { compress = compress ( ) ; ( compress ) { us compress = us compress ( ) ; } chang content length 1 forc chunk ( us compress ) { respons . set content length ( 1 ) ; } } mime header header = respons . get mime header ( ) ; ( entiti bodi ) { respons . set content length ( 1 ) ; } sc content respons mai includ entiti header ( entiti bodi statu code = = http servlet respons . sc content ) { string content type = respons . get content type ( ) ; ( content type = null ) { header . set valu ( content type ) . set string ( content type ) ; } string content languag = respons . get content languag ( ) ; ( content languag = null ) { header . set valu ( content languag ) . set string ( content languag ) ; } } long content length = respons . get content length long ( ) ; boolean connect close present = fals ; ( content length = 1 ) { header . set valu ( content length ) . set long ( content length ) ; get output buffer ( ) . add activ filter ( output filter constant . ident filter ) ; content delimit = true ; } els { respons code support entiti bodi we re http 1 . 1 we chunk unless we have connect : close header connect close present = connect close ( header ) ; ( entiti bodi http11 connect close present ) { get output buffer ( ) . add activ filter ( output filter constant . chunk filter ) ; content delimit = true ; header . add valu ( constant . transferencod ) . set string ( constant . chunk ) ; } els { get output buffer ( ) . add activ filter ( output filter constant . ident filter ) ; } } ( us compress ) { get output buffer ( ) . add activ filter ( output filter constant . gzip filter ) ; header . set valu ( content encod ) . set string ( gzip ) ; } might compress , set vari header ( compress ) { make proxi happi via vari ( from mod deflat ) messag byte vari = header . get valu ( vari ) ; ( vari = = null ) { add new vari header header . set valu ( vari ) . set string ( accept encod ) ; } els ( vari . equal ( ) ) { action requir } els { merg current header header . set valu ( vari ) . set string ( vari . get string ( ) , accept encod ) ; } } add date header header . set valu ( date ) . set string ( fast http date format . get current date ( ) ) ; fixm : add transfer encod header ( ( entiti bodi ) ( content delimit ) ) { mark close connect after request , add connect : close header keep aliv = fals ; } we know request bad thi earli , add connect : close header . keep aliv = keep aliv statu drop connect ( statu code ) ; ( keep aliv ) { avoid ad close header twice ( connect close present ) { header . add valu ( constant . connect ) . set string ( constant . close ) ; } } els ( http11 error ) { header . add valu ( constant . connect ) . set string ( constant . keepal ) ; } build respons header get output buffer ( ) . send statu ( ) ; add server header ( server = null ) { alwai overrid anyth app might set header . set valu ( server ) . set string ( server ) ; } els ( header . get valu ( server ) = = null ) { app didn t set header , us default get output buffer ( ) . write ( constant . server byte ) ; } int size = header . size ( ) ; ( int i = 0 ; i size ; i ) { get output buffer ( ) . send header ( header . get name ( i ) , header . get valu ( i ) ) ; } get output buffer ( ) . end header ( ) ; }
receiv notif start element . thi method assign given tag attribut 3 bucket : xmln attribut repres ( standard custom ) tag librari . xmln attribut do repres tag librari . all remain attribut . each xmln attribut repres custom tag librari , correspond tag librari info object ad set custom tag librari . overrid public void start element ( string uri , string local name , string q name , attribut attr ) throw saxexcept { attribut impl taglib attr = null ; attribut impl non taglib attr = null ; attribut impl non taglib xmln attr = null ; process char ( ) ; check prefix ( uri , q name , attr ) ; ( direct onli ( jsp uri . equal ( uri ) local name . start ( direct action ) ) ) { return ; } string current prefix = get prefix ( current . get qname ( ) ) ; jsp : text must have ani subel ( jsp uri . equal ( uri ) text action . equal ( current . get local name ( ) ) jsp . equal ( current prefix ) ) { throw new saxpars except ( local . get messag ( jsp . error . text . ha subel ) , locat ) ; } start mark = new mark ( ctxt , path , locat . get line number ( ) , locat . get column number ( ) ) ; ( attr = null ) { notic due bug underli sax parser , attribut must enumer descend order . boolean taglib = fals ; ( int i = attr . get length ( ) 1 ; i = 0 ; i ) { taglib = fals ; string attr qname = attr . get qname ( i ) ; ( attr qname . start ( xmln ) ) { ( non taglib attr = = null ) { non taglib attr = new attribut impl ( ) ; } non taglib attr . add attribut ( attr . get uri ( i ) , attr . get local name ( i ) , attr . get qname ( i ) , attr . get type ( i ) , attr . get valu ( i ) ) ; } els { ( attr qname . start ( xmln : jsp ) ) { taglib = true ; } els { string attr uri = attr . get valu ( i ) ; taglib info thi uri alreadi establish start prefix map taglib = page info . ha taglib ( attr uri ) ; } ( taglib ) { ( taglib attr = = null ) { taglib attr = new attribut impl ( ) ; } taglib attr . add attribut ( attr . get uri ( i ) , attr . get local name ( i ) , attr . get qname ( i ) , attr . get type ( i ) , attr . get valu ( i ) ) ; } els { ( non taglib xmln attr = = null ) { non taglib xmln attr = new attribut impl ( ) ; } non taglib xmln attr . add attribut ( attr . get uri ( i ) , attr . get local name ( i ) , attr . get qname ( i ) , attr . get type ( i ) , attr . get valu ( i ) ) ; } } } } node node = null ; ( tag depend pend jsp uri . equal ( uri ) local name . equal ( bodi action ) ) { tag depend pend = fals ; tag depend nest ; current = pars standard action ( q name , local name , non taglib attr , non taglib xmln attr , taglib attr , start mark ) ; return ; } ( tag depend pend jsp uri . equal ( uri ) local name . equal ( attribut action ) ) { current = pars standard action ( q name , local name , non taglib attr , non taglib xmln attr , taglib attr , start mark ) ; return ; } ( tag depend pend ) { tag depend pend = fals ; tag depend nest ; } ( tag depend nest 0 ) { node = new node . uninterpret tag ( q name , local name , non taglib attr , non taglib xmln attr , taglib attr , start mark , current ) ; } els ( jsp uri . equal ( uri ) ) { node = pars standard action ( q name , local name , non taglib attr , non taglib xmln attr , taglib attr , start mark ) ; } els { node = pars custom action ( q name , local name , uri , non taglib attr , non taglib xmln attr , taglib attr , start mark , current ) ; ( node = = null ) { node = new node . uninterpret tag ( q name , local name , non taglib attr , non taglib xmln attr , taglib attr , start mark , current ) ; } els { custom action string bodi type = get bodi type ( ( node . custom tag ) node ) ; ( scriptless bodi node = = null bodi type . equal ignor case ( tag info . bodi content scriptless ) ) { scriptless bodi node = node ; } } } }
privat void process web dot xml ( ) { veri , veri unlik just case . . . ( ctxt . get major version ( ) 2 ) { default elignor = true ; default defer syntax allow liter = true ; return ; } ( ctxt . get major version ( ) = = 2 ) { ( ctxt . get minor version ( ) 5 ) { default defer syntax allow liter = true ; } ( ctxt . get minor version ( ) 4 ) { default elignor = true ; return ; } } jsp config descriptor jsp config = ctxt . get jsp config descriptor ( ) ; ( jsp config = = null ) { return ; } collect jsp properti group descriptor jsp properti group = jsp config . get jsp properti group ( ) ; ( jsp properti group descriptor jsp properti group : jsp properti group ) { collect string url pattern = jsp properti group . get url pattern ( ) ; ( url pattern . size ( ) = = 0 ) { continu ; } match logic easier . ( string url pattern : url pattern ) { string path = null ; string extens = null ; ( url pattern . index ( ) 0 ) { exact match path = url pattern ; } els { int i = url pattern . last index ( ) ; string file ; ( i = 0 ) { path = url pattern . substr ( 0 , i 1 ) ; file = url pattern . substr ( i 1 ) ; } els { file = url pattern ; } pattern must , form . jsp ( file . equal ( ) ) { extens = ; } els ( file . start ( . ) ) { extens = file . substr ( file . index ( . ) 1 ) ; } url pattern ar reconstruct follow : path = null , extens = = null : foo bar . ext path = = null , extens = null : . ext path = null , extens = = : foo boolean star = . equal ( extens ) ; ( ( path = = null ( extens = = null star ) ) ( path = null star ) ) { ( log . warn enabl ( ) ) { log . warn ( local . get messag ( jsp . warn . bad . urlpattern . propertygroup , url pattern ) ) ; } continu ; } } vector string includ prelud = new vector ( ) ; includ prelud . add all ( jsp properti group . get includ prelud ( ) ) ; vector string includ coda = new vector ( ) ; includ coda . add all ( jsp properti group . get includ coda ( ) ) ; jsp properti properti = new jsp properti ( jsp properti group . get xml ( ) , jsp properti group . get el ignor ( ) , jsp properti group . get script invalid ( ) , jsp properti group . get page encod ( ) , includ prelud , includ coda , jsp properti group . get defer syntax allow liter ( ) , jsp properti group . get trim direct whitespac ( ) , jsp properti group . get default content type ( ) , jsp properti group . get buffer ( ) , jsp properti group . get error undeclar namespac ( ) ) ; jsp properti group properti group = new jsp properti group ( path , extens , properti ) ; jsp properti . add element ( properti group ) ; } } }
public return entiti resolv us sax parser . return return entiti resolv us sax parser . entiti resolv get entiti resolv ( ) { return entiti resolv ; }	resolv request extern entiti . param public id public identifi entiti referenc param system id system identifi entiti referenc except saxexcept pars except occur overrid public input sourc resolv entiti ( string public id , string system id ) throw saxexcept { ( sax log . debug enabl ( ) ) { sax log . debug ( resolv entiti ( public id , system id ) ) ; } ( public id = null ) thi . public id = public id ; ha thi system identifi been regist string entiti url = null ; ( public id = null ) { entiti url = entiti valid . get ( public id ) ; } ( entiti url = = null ) { ( system id = = null ) { cannot resolv ( log . debug enabl ( ) ) { log . debug ( cannot resolv entiti : public id ) ; } return ( null ) ; } els { try resolv us system id ( log . debug enabl ( ) ) { log . debug ( try resolv us system id system id ) ; } entiti url = system id ; } } return input sourc our altern url ( log . debug enabl ( ) ) { log . debug ( resolv altern dtd entiti url ) ; } try { return ( new input sourc ( entiti url ) ) ; } catch ( except e ) { throw creat saxexcept ( e ) ; } }	public return xmlreader us pars input document . fix me : bug jaxp xerc prevent us parser contain schema dtd . except saxexcept xmlreader can instanti xmlreader get xmlreader ( ) throw saxexcept { ( reader = = null ) { reader = get parser ( ) . get xmlreader ( ) ; } reader . set dtdhandler ( thi ) ; reader . set content handler ( thi ) ; ( entiti resolv = = null ) { reader . set entiti resolv ( thi ) ; } els { reader . set entiti resolv ( entiti resolv ) ; } reader . set error handler ( thi ) ; return reader ; }	overrid public set string add servlet secur ( servlet registr . dynam registr , servlet secur element servlet secur element ) { set string conflict = new hash set ( ) ; collect string url pattern = registr . get map ( ) ; ( string url pattern : url pattern ) { boolean found conflict = fals ; secur constraint secur constraint = find constraint ( ) ; ( secur constraint secur constraint : secur constraint ) { secur collect collect = secur constraint . find collect ( ) ; ( secur collect collect : collect ) { ( collect . find pattern ( url pattern ) ) { . permit have mixtur ( collect . from descriptor ( ) ) { skip thi pattern found conflict = true ; conflict . add ( url pattern ) ; break ; } els { need overwrit constraint thi pattern collect . remov pattern ( url pattern ) ; collect now empti , remov ( collect . find pattern ( ) . length = = 0 ) { secur constraint . remov collect ( collect ) ; } } } } constraint now ha collect remov ( secur constraint . find collect ( ) . length = = 0 ) { remov constraint ( secur constraint ) ; } onc conflict ha been found ( found conflict ) { break ; } } pattern did conflict , add new constraint ( s ) . ( found conflict ) { secur constraint new secur constraint = secur constraint . creat constraint ( servlet secur element , url pattern ) ; ( secur constraint secur constraint : new secur constraint ) { add constraint ( secur constraint ) ; } check constraint uncov method ( new secur constraint ) ; } } return conflict ; }	public boolean metadata complet ( ) { return metadata complet ; }	public string get public id ( ) { return public id ; }	test public void test pars public id version22 ( ) { web xml webxml = new web xml ( ) ; webxml . set public id ( org . apach . catalina . startup . constant . web dtd public id 22 ) ; assert . assert equal ( 2 , webxml . get major version ( ) ) ; assert . assert equal ( 2 , webxml . get minor version ( ) ) ; assert . assert equal ( 2 . 2 , webxml . get version ( ) ) ; }	test public void test pars public id version23 ( ) { web xml webxml = new web xml ( ) ; webxml . set public id ( org . apach . catalina . startup . constant . web dtd public id 23 ) ; assert . assert equal ( 2 , webxml . get major version ( ) ) ; assert . assert equal ( 3 , webxml . get minor version ( ) ) ; assert . assert equal ( 2 . 3 , webxml . get version ( ) ) ; }	test public void test pars public id version24 ( ) { web xml webxml = new web xml ( ) ; webxml . set public id ( org . apach . catalina . startup . constant . web schema public id 24 ) ; assert . assert equal ( 2 , webxml . get major version ( ) ) ; assert . assert equal ( 4 , webxml . get minor version ( ) ) ; assert . assert equal ( 2 . 4 , webxml . get version ( ) ) ; }	test public void test pars public id version25 ( ) { web xml webxml = new web xml ( ) ; webxml . set public id ( org . apach . catalina . startup . constant . web schema public id 25 ) ; assert . assert equal ( 2 , webxml . get major version ( ) ) ; assert . assert equal ( 5 , webxml . get minor version ( ) ) ; assert . assert equal ( 2 . 5 , webxml . get version ( ) ) ; }	test public void test pars public id version30 ( ) { web xml webxml = new web xml ( ) ; webxml . set public id ( org . apach . catalina . startup . constant . web schema public id 30 ) ; assert . assert equal ( 3 , webxml . get major version ( ) ) ; assert . assert equal ( 0 , webxml . get minor version ( ) ) ; assert . assert equal ( 3 . 0 , webxml . get version ( ) ) ; }	test public void test pars public id version31 ( ) { web xml webxml = new web xml ( ) ; webxml . set public id ( org . apach . catalina . startup . constant . web schema public id 31 ) ; assert . assert equal ( 3 , webxml . get major version ( ) ) ; assert . assert equal ( 1 , webxml . get minor version ( ) ) ; assert . assert equal ( 3 . 1 , webxml . get version ( ) ) ; }	public void test pars version ( ) { web xml webxml = new web xml ( ) ; default assert . assert equal ( 3 , webxml . get major version ( ) ) ; assert . assert equal ( 0 , webxml . get minor version ( ) ) ; both get chang webxml . set version ( 2 . 5 ) ; assert . assert equal ( 2 , webxml . get major version ( ) ) ; assert . assert equal ( 5 , webxml . get minor version ( ) ) ; reset webxml . set version ( 0 . 0 ) ; assert . assert equal ( 0 , webxml . get major version ( ) ) ; assert . assert equal ( 0 , webxml . get minor version ( ) ) ; null input should ignor webxml . set version ( null ) ; assert . assert equal ( 0 , webxml . get major version ( ) ) ; assert . assert equal ( 0 , webxml . get minor version ( ) ) ; major onli webxml . set version ( 3 ) ; assert . assert equal ( 3 , webxml . get major version ( ) ) ; assert . assert equal ( 0 , webxml . get minor version ( ) ) ; minor digit reset webxml . set version ( 0 . 0 ) ; webxml . set version ( 3 . ) ; assert . assert equal ( 3 , webxml . get major version ( ) ) ; assert . assert equal ( 0 , webxml . get minor version ( ) ) ; minor onli reset webxml . set version ( 0 . 0 ) ; webxml . set version ( . 5 ) ; assert . assert equal ( 0 , webxml . get major version ( ) ) ; assert . assert equal ( 5 , webxml . get minor version ( ) ) ; lead train zero reset webxml . set version ( 0 . 0 ) ; webxml . set version ( 002 . 500 ) ; assert . assert equal ( 2 , webxml . get major version ( ) ) ; assert . assert equal ( 500 , webxml . get minor version ( ) ) ; }


protect extract name servlet contain initi . param resourc where name defin return class name throw ioexcept servlet contain initi get servlet contain initi ( input stream ) throw ioexcept { string class name = null ; ( = null ) { string line = null ; try { buffer reader br = new buffer reader ( new input stream reader ( , utf 8 ) ) ; line = br . read line ( ) ; ( line = null line . trim ( ) . length ( ) 0 ) { class name = line . trim ( ) ; } } catch ( unsupport encod except e ) { should never happen utf 8 doe ignor return null } } servlet contain initi sci = null ; try { class clazz = class . name ( class name , true , context . get loader ( ) . get class loader ( ) ) ; sci = ( servlet contain initi ) clazz . new instanc ( ) ; } catch ( class found except e ) { log . error ( sm . get string ( context config . invalid sci , class name ) , e ) ; throw new ioexcept ( e ) ; } catch ( instanti except e ) { log . error ( sm . get string ( context config . invalid sci , class name ) , e ) ; throw new ioexcept ( e ) ; } catch ( illeg access except e ) { log . error ( sm . get string ( context config . invalid sci , class name ) , e ) ; throw new ioexcept ( e ) ; } return sci ; }	protect scan jar servlet contain initi implement . implement ad web fragment . xml prioriti order . void process servlet contain initi ( set web xml fragment ) { ( web xml fragment : fragment ) { url url = fragment . get url ( ) ; jar jar = null ; input stream = null ; servlet contain initi sci = null ; try { ( jar . equal ( url . get protocol ( ) ) ) { jar = jar factori . new instanc ( url ) ; = jar . get input stream ( sci locat ) ; } els ( file . equal ( url . get protocol ( ) ) ) { string path = url . get path ( ) ; file file = new file ( path , sci locat ) ; ( file . exist ( ) ) { = new file input stream ( file ) ; } } ( = null ) { sci = get servlet contain initi ( ) ; } } catch ( ioexcept ioe ) { log . error ( sm . get string ( context config . servlet contain initi fail , url , context . get name ( ) ) ) ; ok = fals ; return ; } final { ( = null ) { try { . close ( ) ; } catch ( ioexcept e ) { ignor } } ( jar = null ) { jar . close ( ) ; } } ( sci = = null ) { continu ; } initi class map . put ( sci , new hash set class >> ( ) ) ; handl type ht = null ; try { ht = sci . get class ( ) . get annot ( handl type . class ) ; } catch ( except e ) { ( log . debug enabl ( ) ) { log . info ( sm . get string ( context config . sci . debug , url ) , e ) ; } els { log . info ( sm . get string ( context config . sci . info , url ) ) ; } } ( ht = null ) { class type = ht . valu ( ) ; ( type = null ) { ( class type : type ) { ( type . annot ( ) ) { handl type annot = true ; } els { handl type non annot = true ; } set servlet contain initi sci = type initi map . get ( type ) ; ( sci = = null ) { sci = new hash set ( ) ; type initi map . put ( type , sci ) ; } sci . add ( sci ) ; } } } } }
overrid public void run ( ) { long written = 0 ; try { ( int i = offset ; i offset length ; i ) { byte buffer src = src i ; while ( src . ha remain ( ) ) { socket write buffer . clear ( ) ; encrypt data sslengin result r = ssl engin . wrap ( src , socket write buffer ) ; written = r . byte consum ( ) ; statu s = r . get statu ( ) ; ( s = = statu . ok s = = statu . buffer overflow ) { need write out byte mai need read from sourc again empti } els { statu . close unexpect throw new illeg state except ( sm . get string ( async channel wrapper secur . statu wrap ) ) ; } check task ( r . get handshak statu ( ) = = handshak statu . need task ) { runnabl runnabl = ssl engin . get deleg task ( ) ; while ( runnabl = null ) { runnabl . run ( ) ; runnabl = ssl engin . get deleg task ( ) ; } } socket write buffer . flip ( ) ; do write futur integ f = socket channel . write ( socket write buffer ) ; integ socket write = f . get ( ) ; ( socket write . int valu ( ) = r . byte produc ( ) ) { throw new ioexcept ( sm . get string ( async channel wrapper secur . write fail , integ . valu ( socket write . int valu ( ) ) , integ . valu ( r . byte produc ( ) ) ) ) ; } } } ( write . compar set ( true , fals ) ) { futur . complet ( long . valu ( written ) ) ; } els { futur . fail ( new illeg state except ( sm . get string ( async channel wrapper secur . wrong state write ) ) ) ; } } catch ( except e ) { futur . fail ( e ) ; } }
public recycl void recycl ( ) { byte read = 0 ; content length = 1 ; content type mb = null ; char encod = null ; header . recycl ( ) ; server name mb . recycl ( ) ; server port = 1 ; local port = 1 ; remot port = 1 ; avail = 0 ; cooki . recycl ( ) ; paramet . recycl ( ) ; unpars urimb . recycl ( ) ; uri mb . recycl ( ) ; decod uri mb . recycl ( ) ; queri mb . recycl ( ) ; method mb . recycl ( ) ; proto mb . recycl ( ) ; scheme mb . recycl ( ) ; instanc id . recycl ( ) ; remot user . recycl ( ) ; auth type . recycl ( ) ; attribut . clear ( ) ; listen = null ; start time = 1 ; }
privat static object build arg ( pojo path param path param , map string , string path paramet , session session , endpoint config config , throwabl throwabl , close reason close reason ) throw decod except { object result = new object path param . length ; ( int i = 0 ; i path param . length ; i ) { class type = path param i . get type ( ) ; ( type . equal ( session . class ) ) { result i = session ; } els ( type . equal ( endpoint config . class ) ) { result i = config ; } els ( type . equal ( throwabl . class ) ) { result i = throwabl ; } els ( type . equal ( close reason . class ) ) { result i = close reason ; } els { string name = path param i . get name ( ) ; string valu = path paramet . get ( name ) ; try { result i = util . coerc type ( type , valu ) ; } catch ( except e ) { throw new decod except ( valu , sm . get string ( pojo method map . decod path param fail , valu , type ) , e ) ; } } } return result ; }
privat void pars header ( string line , map string , list string >> header ) { treat header singl valu default . int index = line . index ( : ) ; ( index = = 1 ) { log . warn ( sm . get string ( ws web socket contain . invalid header , line ) ) ; return ; } string header name = line . substr ( 0 , index ) . trim ( ) . lower case ( ) ; todo handl known multi valu header string header valu = line . substr ( index 1 ) . trim ( ) ; list string valu = header . get ( header name ) ; ( valu = = null ) { valu = new arrai list ( 1 ) ; header . put ( header name , valu ) ; } valu . add ( header valu ) ; }	overrid public session connect server ( endpoint endpoint , client endpoint config client endpoint configur , uri path ) throw deploy except { boolean secur = fals ; string scheme = path . get scheme ( ) ; ( ( ws . equal ignor case ( scheme ) wss . equal ignor case ( scheme ) ) ) { throw new deploy except ( sm . get string ( ws web socket contain . path wrong scheme , scheme ) ) ; } string host = path . get host ( ) ; ( host = = null ) { throw new deploy except ( sm . get string ( ws web socket contain . path host ) ) ; } int port = path . get port ( ) ; map string , list string >> req header = creat request header ( host , port , client endpoint configur . get prefer subprotocol ( ) , client endpoint configur . get extens ( ) ) ; client endpoint configur . get configur ( ) . befor request ( req header ) ; byte buffer request = creat request ( path , req header ) ; socket address sa ; ( port = = 1 ) { ( ws . equal ignor case ( scheme ) ) { sa = new inet socket address ( host , 80 ) ; } els ( wss . equal ignor case ( scheme ) ) { sa = new inet socket address ( host , 443 ) ; secur = true ; } els { throw new deploy except ( sm . get string ( ws web socket contain . invalid scheme ) ) ; } } els { ( wss . equal ignor case ( scheme ) ) { secur = true ; } sa = new inet socket address ( host , port ) ; } asynchron socket channel socket channel ; try { socket channel = asynchron socket channel . open ( asynchron channel group ) ; } catch ( ioexcept ioe ) { throw new deploy except ( sm . get string ( ws web socket contain . asynchron socket channel fail ) , ioe ) ; } futur void f connect = socket channel . connect ( sa ) ; async channel wrapper channel ; ( secur ) { sslengin ssl engin = creat sslengin ( client endpoint configur . get user properti ( ) ) ; channel = new async channel wrapper secur ( socket channel , ssl engin ) ; } els { channel = new async channel wrapper non secur ( socket channel ) ; } byte buffer respons ; string sub protocol ; try { f connect . get ( ) ; futur void f handshak = channel . handshak ( ) ; f handshak . get ( ) ; int write = request . limit ( ) ; futur integ f write = channel . write ( request ) ; integ thi write = f write . get ( ) ; write = thi write . int valu ( ) ; while ( write 0 ) { f write = channel . write ( request ) ; thi write = f write . get ( ) ; write = thi write . int valu ( ) ; } same size ws frame input buffer respons = byte buffer . alloc ( max binari messag buffer size ) ; handshak respons handshak respons = process respons ( respons , channel ) ; client endpoint configur . get configur ( ) . after respons ( handshak respons ) ; sub protocol list string valu = handshak respons . get header ( ) . get ( constant . ws protocol header name ) ; ( valu = = null valu . size ( ) = = 0 ) { sub protocol = null ; } els ( valu . size ( ) = = 1 ) { sub protocol = valu . get ( 0 ) ; } els { throw new deploy except ( sm . get string ( sec web socket protocol ) ) ; } } catch ( execut except interrupt except sslexcept eofexcept e ) { throw new deploy except ( sm . get string ( ws web socket contain . http request fail ) , e ) ; } switch web socket ws remot endpoint impl client ws remot endpoint client = new ws remot endpoint impl client ( channel ) ; ws session ws session = new ws session ( endpoint , ws remot endpoint client , thi , null , null , null , null , null , sub protocol , collect . empti map , fals , client endpoint configur ) ; endpoint . open ( ws session , client endpoint configur ) ; regist session ( endpoint , ws session ) ; object creation trigger input process suppress warn ( unus ) ws frame client ws frame client = new ws frame client ( respons , channel , ws session ) ; return ws session ; }
provid equival { link add endpoint ( server endpoint config ) } publish plain old java object ( pojo ) have been annot web socket endpoint . param pojo annot pojo overrid public void add endpoint ( class pojo ) throw deploy except { server endpoint annot = pojo . get annot ( server endpoint . class ) ; ( annot = = null ) { throw new deploy except ( sm . get string ( server contain . miss annot , pojo . get name ( ) ) ) ; } string path = annot . valu ( ) ; valid encod valid encod ( annot . encod ( ) ) ; method map pojo method map method map = new pojo method map ( pojo , annot . decod ( ) , path ) ; server endpoint config server endpoint config sec ; class extend configur configur clazz = annot . configur ( ) ; configur configur = null ; ( configur clazz . equal ( configur . class ) ) { try { configur = annot . configur ( ) . new instanc ( ) ; } catch ( instanti except illeg access except e ) { throw new deploy except ( sm . get string ( server contain . configur fail , annot . configur ( ) . get name ( ) , pojo . get class ( ) . get name ( ) ) , e ) ; } } sec = server endpoint config . builder . creat ( pojo , path ) . decod ( arrai . list ( annot . decod ( ) ) ) . encod ( arrai . list ( annot . encod ( ) ) ) . configur ( configur ) . build ( ) ; sec . get user properti ( ) . put ( pojo endpoint server . pojo method map kei , method map ) ; add endpoint ( sec ) ; }

process pipelin http request us specifi input output stream . param socket wrapper socket from which http request read http respons written . throw ioexcept error dure i o oper overrid public socket state process ( socket wrapper s socket wrapper ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set up i o set socket wrapper ( socket wrapper ) ; get input buffer ( ) . init ( socket wrapper , endpoint ) ; get output buffer ( ) . init ( socket wrapper , endpoint ) ; flag error = fals ; keep aliv = true ; comet = fals ; open socket = fals ; sendfil progress = fals ; read complet = true ; ( endpoint . get us poll ( ) ) { kept aliv = fals ; } els { kept aliv = socket wrapper . kept aliv ( ) ; } ( disabl keep aliv ( ) ) { socket wrapper . set keep aliv left ( 0 ) ; } while ( error keep aliv comet async ( ) http upgrad handler = = null endpoint . paus ( ) ) { pars request header try { set request line read timeout ( ) ; ( get input buffer ( ) . pars request line ( kept aliv ) ) { ( handl incomplet request line read ( ) ) { break ; } } ( endpoint . paus ( ) ) { 503 servic unavail respons . set statu ( 503 ) ; error = true ; } els { time request process . ( request . get start time ( ) 0 ) { request . set start time ( system . current time milli ( ) ) ; } kept aliv = true ; set thi everi time case limit ha been chang via jmx request . get mime header ( ) . set limit ( endpoint . get max header count ( ) ) ; current onli nio ever return fals here ( get input buffer ( ) . pars header ( ) ) { we ve read part request , don t recycl instead associ socket open socket = true ; read complet = fals ; break ; } ( disabl upload timeout ) { set socket timeout ( connect upload timeout ) ; } } } catch ( ioexcept e ) { ( get log ( ) . debug enabl ( ) ) { get log ( ) . debug ( sm . get string ( http11processor . header . pars ) , e ) ; } error = true ; break ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; user data helper . mode log mode = user data helper . get next mode ( ) ; ( log mode = null ) { string messag = sm . get string ( http11processor . header . pars ) ; switch ( log mode ) { case info debug : messag = sm . get string ( http11processor . fall debug ) ; fall through case info : get log ( ) . info ( messag ) ; break ; case debug : get log ( ) . debug ( messag ) ; } } 400 bad request respons . set statu ( 400 ) ; get adapt ( ) . log ( request , respons , 0 ) ; error = true ; } ( error ) { set up filter , pars some request header rp . set stage ( org . apach . coyot . constant . stage prepar ) ; try { prepar request ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; ( get log ( ) . debug enabl ( ) ) { get log ( ) . debug ( sm . get string ( http11processor . request . prepar ) , t ) ; } 400 intern server error respons . set statu ( 400 ) ; get adapt ( ) . log ( request , respons , 0 ) ; error = true ; } } ( max keep aliv request = = 1 ) { keep aliv = fals ; } els ( max keep aliv request 0 socket wrapper . decrement keep aliv ( ) = 0 ) { keep aliv = fals ; } process request adapt ( error ) { try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; get adapt ( ) . servic ( request , respons ) ; commit , so we can t try set header . ( keep aliv error ) { avoid check twice . error = respons . get error except ( ) = null ( async ( ) statu drop connect ( respons . get statu ( ) ) ) ; } set comet timeout ( socket wrapper ) ; } catch ( interrupt ioexcept e ) { error = true ; } catch ( header too larg except e ) { error = true ; anywai safe ( respons . commit ( ) ) { respons . reset ( ) ; respons . set statu ( 500 ) ; respons . set header ( connect , close ) ; } } catch ( throwabl t ) { except util . handl throwabl ( t ) ; get log ( ) . error ( sm . get string ( http11processor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; get adapt ( ) . log ( request , respons , 0 ) ; error = true ; } } finish handl request rp . set stage ( org . apach . coyot . constant . stage endinput ) ; ( async ( ) comet ) { ( error ) { we know we ar close connect , don t drain input . thi wai upload 100gb file doesn t tie up thread servlet ha reject . get input buffer ( ) . set swallow input ( fals ) ; } end request ( ) ; } rp . set stage ( org . apach . coyot . constant . stage endoutput ) ; error , updat statist counter ( error ) { respons . set statu ( 500 ) ; } request . updat counter ( ) ; ( async ( ) comet error ) { get input buffer ( ) . next request ( ) ; get output buffer ( ) . next request ( ) ; } ( disabl upload timeout ) { set socket timeout ( endpoint . get so timeout ( ) ) ; } rp . set stage ( org . apach . coyot . constant . stage keepal ) ; ( break keep aliv loop ( socket wrapper ) ) { break ; } } rp . set stage ( org . apach . coyot . constant . stage end ) ; ( error endpoint . paus ( ) ) { return socket state . close ; } els ( async ( ) comet ) { return socket state . long ; } els ( upgrad ( ) ) { return socket state . upgrad ; } els { ( sendfil progress ) { return socket state . sendfil ; } els { ( open socket ) { ( read complet ) { return socket state . open ; } els { return socket state . long ; } } els { return socket state . close ; } } } }
privat boolean process data control ( ) throw ioexcept { ( append payload messag ( control buffer binari ) ) { return fals ; } control buffer binari . flip ( ) ; ( op code = = constant . opcod close ) { open = fals ; string reason = null ; int code = close code . normal closur . get code ( ) ; ( control buffer binari . remain ( ) = = 1 ) { control buffer binari . clear ( ) ; payload must zero greater than 2 throw new ws ioexcept ( new close reason ( close code . protocol error , sm . get string ( ws frame . byte close code ) ) ) ; } ( control buffer binari . remain ( ) 1 ) { code = control buffer binari . get short ( ) ; ( control buffer binari . remain ( ) 0 ) { coder result cr = utf8decod control . decod ( control buffer binari , control buffer text , true ) ; ( cr . error ( ) ) { control buffer binari . clear ( ) ; control buffer text . clear ( ) ; throw new ws ioexcept ( new close reason ( close code . protocol error , sm . get string ( ws frame . invalid utf8clos ) ) ) ; } overflow output buffer big enough . underflow all data pass decod singl call . control buffer text . flip ( ) ; reason = control buffer text . string ( ) ; } } ws session . close ( new close reason ( util . get close code ( code ) , reason ) ) ; } els ( op code = = constant . opcod ping ) { ( ws session . open ( ) ) { ws session . get basic remot ( ) . send pong ( control buffer binari ) ; } } els ( op code = = constant . opcod pong ) { messag handler . whole pong messag mh pong = ws session . get pong messag handler ( ) ; ( mh pong = null ) { mh pong . messag ( new ws pong messag ( control buffer binari ) ) ; } } els { should have caught thi earlier just case . . . control buffer binari . clear ( ) ; throw new ws ioexcept ( new close reason ( close code . protocol error , sm . get string ( ws frame . invalid op code , integ . valu ( op code ) ) ) ) ; } control buffer binari . clear ( ) ; new frame ( ) ; return true ; }	suppress warn ( uncheck ) privat void send messag binari ( byte buffer msg , boolean last ) throw ws ioexcept { messag handler mh = ws session . get binari messag handler ( ) ; ( mh = null ) { ( mh instanceof wrap messag handler ) { long max messag size = ( ( wrap messag handler ) mh ) . get max messag size ( ) ; ( max messag size 1 msg . remain ( ) max messag size ) { throw new ws ioexcept ( new close reason ( close code . too big , sm . get string ( ws frame . messag too big , long . valu ( msg . remain ( ) ) , long . valu ( max messag size ) ) ) ) ; } } ( mh instanceof messag handler . partial ) { ( ( messag handler . partial byte buffer ) mh ) . messag ( msg , last ) ; } els { caller ensur last = = true thi branch us ( ( messag handler . whole byte buffer ) mh ) . messag ( msg ) ; } } }	suppress warn ( uncheck ) privat void send messag text ( boolean last ) throw ws ioexcept { messag handler mh = ws session . get text messag handler ( ) ; ( mh = null ) { ( mh instanceof wrap messag handler ) { long max messag size = ( ( wrap messag handler ) mh ) . get max messag size ( ) ; ( max messag size 1 messag buffer text . remain ( ) max messag size ) { throw new ws ioexcept ( new close reason ( close code . too big , sm . get string ( ws frame . messag too big , long . valu ( messag buffer text . remain ( ) ) , long . valu ( max messag size ) ) ) ) ; } } ( mh instanceof messag handler . partial ) { ( ( messag handler . partial string ) mh ) . messag ( messag buffer text . string ( ) , last ) ; } els { caller ensur last = = true thi branch us ( ( messag handler . whole string ) mh ) . messag ( messag buffer text . string ( ) ) ; } messag buffer text . clear ( ) ; } }

overrid protect void set request line read timeout ( ) throw ioexcept { when data buffer thi first request thi connect timeout ar us first read thi request mai need differ timeout take account time spent wait process thread . thi littl hacki better than expos socket timeout info input buffer ( input buffer . last valid = = 0 socket . get last access ( ) 1 ) { int first read timeout ; ( keep aliv timeout = = 1 ) { first read timeout = 0 ; } els { long queue time = system . current time milli ( ) socket . get last access ( ) ; ( queue time = keep aliv timeout ) { queu longer than timeout might data so us shortest possibl timeout first read timeout = 1 ; } els { cast safe sinc queue time must less than keep aliv timeout which int first read timeout = keep aliv timeout ( int ) queue time ; } } socket . get socket ( ) . set so timeout ( first read timeout ) ; block io so fill ( ) alwai block ( input buffer . fill ( true ) ) { throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } onc first byte ha been read , standard timeout should us so restor here . socket . get socket ( ) . set so timeout ( endpoint . get so timeout ( ) ) ; } }
protect perform actual jaa authent princip authent ( string usernam , callback handler callback handler ) { establish login context us authent try { login context login context = null ; ( app name = = null ) app name = tomcat ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . begin login , usernam , app name ) ) ; what login modul contain class loader class loader ocl = null ; ( us context class loader ( ) ) { ocl = thread . current thread ( ) . get context class loader ( ) ; thread . current thread ( ) . set context class loader ( thi . get class ( ) . get class loader ( ) ) ; } try { login context = new login context ( app name , callback handler ) ; } catch ( throwabl e ) { except util . handl throwabl ( e ) ; log . error ( sm . get string ( jaa realm . unexpect error ) , e ) ; return ( null ) ; } final { ( us context class loader ( ) ) { thread . current thread ( ) . set context class loader ( ocl ) ; } } ( log . debug enabl ( ) ) log . debug ( login context creat usernam ) ; negoti login via thi login context subject subject = null ; try { login context . login ( ) ; subject = login context . get subject ( ) ; ( subject = = null ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . fail login , usernam ) ) ; return ( null ) ; } } catch ( account expir except e ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . account expir , usernam ) ) ; return ( null ) ; } catch ( credenti expir except e ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . credenti expir , usernam ) ) ; return ( null ) ; } catch ( fail login except e ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . fail login , usernam ) ) ; return ( null ) ; } catch ( login except e ) { log . warn ( sm . get string ( jaa realm . login except , usernam ) , e ) ; return ( null ) ; } catch ( throwabl e ) { except util . handl throwabl ( e ) ; log . error ( sm . get string ( jaa realm . unexpect error ) , e ) ; return ( null ) ; } ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . login context creat , usernam ) ) ; return appropri princip thi authent subject princip princip = creat princip ( usernam , subject , login context ) ; ( princip = = null ) { log . debug ( sm . get string ( jaa realm . authent failur , usernam ) ) ; return ( null ) ; } ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jaa realm . authent success , usernam ) ) ; } return ( princip ) ; } catch ( throwabl t ) { log . error ( error , t ) ; return null ; } }	prepar begin activ us public method thi compon implement requir { link org . apach . catalina . util . lifecycl base start intern ( ) } . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect void start intern ( ) throw lifecycl except { need call after load configur , case us context class loader appear after them xml config pars class name ( user class name , user class ) ; pars class name ( role class name , role class ) ; super . start intern ( ) ; }
privat perform block read timeout desir param timeout boolean we want us timeout data param block true system should perform block read , fals otherwis return boolean true data wa read , fals data read , eofexcept eof reach throw ioexcept socket except occur throw eofexcept end stream reach int read socket ( boolean timeout , boolean block ) throw ioexcept { int n read = 0 ; socket . get buf handler ( ) . get read buffer ( ) . clear ( ) ; ( block ) { selector selector = null ; try { selector = pool . get ( ) ; } catch ( ioexcept x ) { ignor } try { nio endpoint . kei attach att = ( nio endpoint . kei attach ) socket . get attach ( fals ) ; ( att = = null ) throw new ioexcept ( kei must cancel . ) ; n read = pool . read ( socket . get buf handler ( ) . get read buffer ( ) , socket , selector , att . get timeout ( ) ) ; } catch ( eofexcept eof ) { n read = 1 ; } final { ( selector = null ) pool . put ( selector ) ; } } els { n read = socket . read ( socket . get buf handler ( ) . get read buffer ( ) ) ; } ( n read 0 ) { socket . get buf handler ( ) . get read buffer ( ) . flip ( ) ; socket . get buf handler ( ) . get read buffer ( ) . limit ( n read ) ; expand ( n read po ) ; socket . get buf handler ( ) . get read buffer ( ) . get ( buf , po , n read ) ; last valid = po n read ; return n read ; } els ( n read = = 1 ) { return fals ; throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } els { return 0 ; } }
privat void merg paramet ( ) { ( ( queri param string = = null ) ( queri param string . length ( ) 1 ) ) return ; hash map string , string queri paramet = new hash map ( ) ; string encod = get charact encod ( ) ; ( encod = = null ) encod = iso 8859 1 ; request util . pars paramet ( queri paramet , queri param string , encod ) ; iter string kei = paramet . kei set ( ) . iter ( ) ; while ( kei . ha next ( ) ) { string kei = kei . next ( ) ; object valu = queri paramet . get ( kei ) ; ( valu = = null ) { queri paramet . put ( kei , paramet . get ( kei ) ) ; continu ; } queri paramet . put ( kei , merg valu ( valu , paramet . get ( kei ) ) ) ; } paramet = queri paramet ; }
protect print out partial servlet stack trace ( truncat last occurr javax . servlet . ) . string get partial servlet stack trace ( throwabl t ) { string builder trace = new string builder ( ) ; trace . append ( t . string ( ) ) . append ( n ) ; stack trace element element = t . get stack trace ( ) ; int po = element . length ; ( int i = 0 ; i element . length ; i ) { ( ( element i . get class name ( ) . start ( org . apach . catalina . core . applic filter chain ) ) ( element i . get method name ( ) . equal ( intern do filter ) ) ) { po = i ; } } ( int i = 0 ; i po ; i ) { ( ( element i . get class name ( ) . start ( org . apach . catalina . core . ) ) ) { trace . append ( t ) . append ( element i . string ( ) ) . append ( n ) ; } } return trace . string ( ) ; }
privat jmxconnector server creat server ( string server name , int rmi registri port , int rmi server port , hash map string , object env , mbean server mbean server ) { creat rmi registri try { locat registri . creat registri ( rmi registri port ) ; } catch ( remot except e ) { log . error ( sm . get string ( jmx remot lifecycl listen . creat registri fail , server name , integ . string ( rmi registri port ) ) , e ) ; return null ; } build connect string fix port string builder url = new string builder ( ) ; url . append ( servic : jmx : rmi : localhost : ) ; url . append ( rmi server port ) ; url . append ( jndi rmi : localhost : ) ; url . append ( rmi registri port ) ; url . append ( jmxrmi ) ; jmxservic url servic url ; try { servic url = new jmxservic url ( url . string ( ) ) ; } catch ( malform urlexcept e ) { log . error ( sm . get string ( jmx remot lifecycl listen . invalid url , server name , url . string ( ) ) , e ) ; return null ; } start jmx server connect string jmxconnector server cs = null ; try { cs = jmxconnector server factori . new jmxconnector server ( servic url , env , mbean server ) ; cs . start ( ) ; log . info ( sm . get string ( jmx remot lifecycl listen . start , integ . string ( rmi registri port ) , integ . string ( rmi server port ) , server name ) ) ; } catch ( ioexcept e ) { log . error ( sm . get string ( jmx remot lifecycl listen . creat server fail , server name ) , e ) ; } return cs ; }	privat void destroi server ( string server name , jmxconnector server connector server ) { ( connector server = null ) { try { connector server . stop ( ) ; } catch ( ioexcept e ) { log . error ( sm . get string ( jmx remot lifecycl listen . destroi server fail , server name ) , e ) ; } } }	overrid public socket creat socket ( string host , int port ) throw ioexcept { ( factori = = null ) { return new socket ( forc host , port ) ; } els { return factori . creat socket ( forc host , port ) ; } }	overrid public void lifecycl event ( lifecycl event event ) { when server start , configur jmx rmi ( lifecycl . start event = = event . get type ( ) ) { configur us standard jmx system properti init ( ) ; prevent attack guess rmi object id system . set properti ( java . rmi . server . random id , true ) ; creat environ hash map string , object env = new hash map ( ) ; rmiclient socket factori csf = null ; rmiserv socket factori ssf = null ; configur ssl rmi connect requir ( rmi ssl ) { csf = new ssl rmiclient socket factori ( ) ; ssf = new ssl rmiserv socket factori ( cipher , protocol , client auth ) ; } forc us local port requir ( us local port ) { csf = new rmi client localhost socket factori ( csf ) ; } popul env properti us creat server ( csf = null ) { env . put ( rmiconnector server . rmi client socket factori attribut , csf ) ; } ( ssf = null ) { env . put ( rmiconnector server . rmi server socket factori attribut , ssf ) ; } configur authent ( authent ) { env . put ( jmx . remot . x . password . file , password file ) ; env . put ( jmx . remot . x . access . file , access file ) ; env . put ( jmx . remot . x . login . config , login modul name ) ; } creat platform server cs platform = creat server ( platform , rmi registri port platform , rmi server port platform , env , manag factori . get platform mbean server ( ) ) ; } els ( lifecycl . stop event = = event . get type ( ) ) { destroi server ( platform , cs platform ) ; } }
overrid public byte buffer encod ( msg byte msg ) throw encod except { byte data = msg . get data ( ) ; byte buffer repli = byte buffer . alloc ( 2 data . length ) ; repli . put ( ( byte ) 0x12 ) ; repli . put ( ( byte ) 0x34 ) ; repli . put ( data ) ; return repli ; }	overrid public msg byte decod ( byte buffer bb ) throw decod except { msg byte result = new msg byte ( ) ; bb . posit ( bb . posit ( ) 2 ) ; byte data = new byte bb . limit ( ) bb . posit ( ) ; bb . get ( data ) ; result . set data ( data ) ; return result ; }	overrid public void messag ( msg string ) { receiv . add ( ) ; try { msg string msg = new msg string ( ) ; msg . set data ( messag ) ; session . get basic remot ( ) . send object ( msg ) ; } catch ( ioexcept encod except e ) { e . print stack trace ( ) ; } }	public void test programmat end point ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; ctx . add applic listen ( new applic listen ( programat server endpoint config . class . get name ( ) , fals ) ) ; tomcat . add servlet ( ctx , default , new default servlet ( ) ) ; ctx . add servlet map ( , default ) ; web socket contain ws contain = contain provid . get web socket contain ( ) ; tomcat . start ( ) ; client client = new client ( ) ; uri uri = new uri ( ws : localhost : get port ( ) path programmat ep ) ; session session = ws contain . connect server ( client , uri ) ; msg string msg1 = new msg string ( ) ; msg1 . set data ( messag ) ; session . get basic remot ( ) . send object ( msg1 ) ; should take veri long int i = 0 ; while ( i 20 ) { ( msg string messag handler . receiv . size ( ) 0 client . receiv . size ( ) 0 ) { break ; } thread . sleep ( 100 ) ; i ; } check messag were receiv assert . assert equal ( 1 , msg string messag handler . receiv . size ( ) ) ; assert . assert equal ( 1 , client . receiv . size ( ) ) ; check correct messag were receiv assert . assert equal ( messag , ( ( msg string ) msg string messag handler . receiv . peek ( ) ) . get data ( ) ) ; assert . assert equal ( messag , ( ( msg string ) client . receiv . peek ( ) ) . get data ( ) ) ; session . close ( ) ; }
protect creat access log element implement access log element creat access log element ( char pattern ) { switch ( pattern ) { case : return new remot addr element ( ) ; case : return new local addr element ( ) ; case b : return new byte sent element ( true ) ; case b : return new byte sent element ( fals ) ; case d : return new elaps time element ( true ) ; case h : return new host element ( ) ; case h : return new protocol element ( ) ; case l : return new logic user name element ( ) ; case m : return new method element ( ) ; case p : return new local port element ( ) ; case q : return new queri element ( ) ; case r : return new request element ( ) ; case s : return new http statu code element ( ) ; case s : return new session id element ( ) ; case t : return new date time element ( ) ; case t : return new elaps time element ( fals ) ; case u : return new user element ( ) ; case u : return new request uriel ( ) ; case v : return new local server name element ( ) ; case i : return new thread name element ( ) ; default : return new string element ( pattern ) ; } }	protect access log element creat log element ( ) { list access log element list = new arrai list ( ) ; boolean replac = fals ; string builder buf = new string builder ( ) ; ( int i = 0 ; i pattern . length ( ) ; i ) { char ch = pattern . char ( i ) ; ( replac ) { code process { , behavior . . . i do encount close } i ignor { ( { = = ch ) { string builder name = new string builder ( ) ; int j = i 1 ; ( ; j pattern . length ( ) } = pattern . char ( j ) ; j ) { name . append ( pattern . char ( j ) ) ; } ( j 1 pattern . length ( ) ) { 1 wa account } which we increment now j ; list . add ( creat access log element ( name . string ( ) , pattern . char ( j ) ) ) ; i = j ; sinc we walk more than charact } els { d oh end string pretend we never did thi do process old wai list . add ( creat access log element ( ch ) ) ; } } els { list . add ( creat access log element ( ch ) ) ; } replac = fals ; } els ( ch = = ) { replac = true ; list . add ( new string element ( buf . string ( ) ) ) ; buf = new string builder ( ) ; } els { buf . append ( ch ) ; } } ( buf . length ( ) 0 ) { list . add ( new string element ( buf . string ( ) ) ) ; } return list . arrai ( new access log element 0 ) ; }	public void recycl ( ) { content type = null ; content languag = null ; local = default local ; charact encod = constant . default charact encod ; charset set = fals ; content length = 1 ; statu = 200 ; messag = null ; commit = fals ; error except = null ; header . clear ( ) ; listen = null ; updat counter content written = 0 ; }	public signal we re done header , bodi follow . ani implement need notifi context manag , allow interceptor fix header . void send header ( ) { action ( action code . commit , thi ) ; commit = true ; }	public void set commit ( boolean v ) { thi . commit = v ; }
stop nest compon ( { link executor } s , { link connector } s { link contain } s ) implement requir { link org . apach . catalina . util . lifecycl base stop intern ( ) } . except lifecycl except thi compon detect fatal error need report overrid protect void stop intern ( ) throw lifecycl except { paus connector first synchron ( connector lock ) { ( connector connector : connector ) { try { connector . paus ( ) ; } catch ( except e ) { log . error ( sm . get string ( standard servic . connector . paus fail , connector ) , e ) ; } } } ( log . info enabl ( ) ) log . info ( sm . get string ( standard servic . stop . name , thi . name ) ) ; set state ( lifecycl state . stop ) ; stop our defin contain second ( contain = null ) { synchron ( contain ) { contain . stop ( ) ; } } now stop connector synchron ( connector lock ) { ( connector connector : connector ) { ( lifecycl state . start . equal ( connector . get state ( ) ) ) { stop ( e . g . via jmx call ) continu ; } try { connector . stop ( ) ; } catch ( except e ) { log . error ( sm . get string ( standard servic . connector . stop fail , connector ) , e ) ; } } } mapper listen . stop ( ) ; synchron ( executor ) { ( executor executor : executor ) { executor . stop ( ) ; } } }	public start new server instanc . void start ( ) { ( get server ( ) = = null ) { load ( ) ; } ( get server ( ) = = null ) { log . fatal ( cannot start server . server instanc configur . ) ; return ; } long t1 = system . nano time ( ) ; start new server try { get server ( ) . start ( ) ; } catch ( lifecycl except e ) { log . error ( catalina . start : , e ) ; } long t2 = system . nano time ( ) ; ( log . info enabl ( ) ) { log . info ( server startup ( ( t2 t1 ) 1000000 ) ms ) ; } regist shutdown hook ( us shutdown hook ) { ( shutdown hook = = null ) { shutdown hook = new catalina shutdown hook ( ) ; } runtim . get runtim ( ) . add shutdown hook ( shutdown hook ) ; juli us , disabl juli s shutdown hook sinc shutdown hook run parallel log messag mai lost juli s hook complet befor catalina shutdown hook ( ) log manag log manag = log manag . get log manag ( ) ; ( log manag instanceof class loader log manag ) { ( ( class loader log manag ) log manag ) . set us shutdown hook ( fals ) ; } } ( await ) { await ( ) ; stop ( ) ; } }
privat encod find encod ( object obj ) { ( encod entri entri : encod entri ) { ( entri . get clazz ( ) . assign from ( obj . get class ( ) ) ) { return entri . get encod ( ) ; } } return null ; }	overrid protect void do write ( send handler handler , byte buffer . . . data ) { long timeout = get send timeout ( ) ; ( timeout 1 ) { timeout = long . max valu ; } send handler complet handler sh2ch = new send handler complet handler ( handler ) ; channel . write ( data , 0 , data . length , timeout , time unit . millisecond , null , sh2ch ) ; }	protect void set encod ( list class extend encod >> encod ) throw deploy except { encod entri . clear ( ) ; ( class extend encod encod clazz : encod ) { encod instanc ; try { instanc = encod clazz . new instanc ( ) ; } catch ( instanti except illeg access except e ) { throw new deploy except ( sm . get string ( ws remot endpoint . invalid encod , encod clazz . get name ( ) ) , e ) ; } encod entri entri = new encod entri ( util . get encod type ( encod clazz ) , instanc ) ; encod entri . add ( entri ) ; } }	protect void set session ( ws session ws session ) { thi . ws session = ws session ; }	messag public msg byte rx ( msg byte ) { receiv . add ( ) ; echo messag back return ; }	overrid public session connect server ( endpoint endpoint , client endpoint config client endpoint configur , uri path ) throw deploy except { boolean secur = fals ; string scheme = path . get scheme ( ) ; ( ( ws . equal ignor case ( scheme ) wss . equal ignor case ( scheme ) ) ) { throw new deploy except ( sm . get string ( ws web socket contain . path wrong scheme , scheme ) ) ; } string host = path . get host ( ) ; ( host = = null ) { throw new deploy except ( sm . get string ( ws web socket contain . path host ) ) ; } int port = path . get port ( ) ; map string , list string >> req header = creat request header ( host , port , client endpoint configur . get prefer subprotocol ( ) ) ; client endpoint configur . get configur ( ) . befor request ( req header ) ; byte buffer request = creat request ( path , req header ) ; socket address sa ; ( port = = 1 ) { ( ws . equal ignor case ( scheme ) ) { sa = new inet socket address ( host , 80 ) ; } els ( wss . equal ignor case ( scheme ) ) { sa = new inet socket address ( host , 443 ) ; secur = true ; } els { throw new deploy except ( sm . get string ( ws web socket contain . invalid scheme ) ) ; } } els { ( wss . equal ignor case ( scheme ) ) { secur = true ; } sa = new inet socket address ( host , port ) ; } asynchron socket channel socket channel ; try { socket channel = asynchron socket channel . open ( asynchron channel group ) ; } catch ( ioexcept ioe ) { throw new deploy except ( sm . get string ( ws web socket contain . asynchron socket channel fail ) , ioe ) ; } futur void f connect = socket channel . connect ( sa ) ; async channel wrapper channel ; ( secur ) { sslengin ssl engin = creat sslengin ( client endpoint configur . get user properti ( ) ) ; channel = new async channel wrapper secur ( socket channel , ssl engin ) ; } els { channel = new async channel wrapper non secur ( socket channel ) ; } byte buffer respons ; string sub protocol ; try { f connect . get ( ) ; futur void f handshak = channel . handshak ( ) ; f handshak . get ( ) ; int write = request . limit ( ) ; futur integ f write = channel . write ( request ) ; integ thi write = f write . get ( ) ; write = thi write . int valu ( ) ; while ( write 0 ) { f write = channel . write ( request ) ; thi write = f write . get ( ) ; write = thi write . int valu ( ) ; } same size ws frame input buffer respons = byte buffer . alloc ( max binari messag buffer size ) ; handshak respons handshak respons = process respons ( respons , channel ) ; client endpoint configur . get configur ( ) . after respons ( handshak respons ) ; sub protocol list string valu = handshak respons . get header ( ) . get ( constant . ws protocol header name ) ; ( valu = = null valu . size ( ) = = 0 ) { sub protocol = null ; } els ( valu . size ( ) = = 1 ) { sub protocol = valu . get ( 0 ) ; } els { throw new deploy except ( sm . get string ( sec web socket protocol ) ) ; } } catch ( execut except interrupt except sslexcept eofexcept e ) { throw new deploy except ( sm . get string ( ws web socket contain . http request fail ) , e ) ; } switch web socket ws remot endpoint impl client ws remot endpoint client = new ws remot endpoint impl client ( channel ) ; ws session ws session = new ws session ( endpoint , ws remot endpoint client , thi , null , null , null , null , sub protocol , collect . empti map , fals , client endpoint configur . get encod ( ) , client endpoint configur . get user properti ( ) ) ; endpoint . open ( ws session , client endpoint configur ) ; regist session ( endpoint . get class ( ) , ws session ) ; object creation trigger input process suppress warn ( unus ) ws frame client ws frame client = new ws frame client ( respons , channel , ws session ) ; return ws session ; }	overrid public string encod ( msg string msg ) throw encod except { return msg string : msg . get data ( ) ; }	public msg byte rx ( msg byte ) { receiv . add ( ) ; echo messag back return ; }	overrid public void init ( web connect connect ) { ( ep = = null ) { throw new illeg state except ( sm . get string ( ws http upgrad handler . pre init ) ) ; } thi . connect = connect ; servlet input stream si ; servlet output stream so ; try { si = connect . get input stream ( ) ; so = connect . get output stream ( ) ; } catch ( ioexcept e ) { throw new illeg state except ( e ) ; } need call open us web applic s class loader creat frame us applic s class loader so can pick up applic specif config from server contain impl thread t = thread . current thread ( ) ; class loader cl = t . get context class loader ( ) ; t . set context class loader ( applic class loader ) ; try { ws remot endpoint impl server ws remot endpoint server = new ws remot endpoint impl server ( so , web socket contain ) ; ws session = new ws session ( ep , ws remot endpoint server , web socket contain , handshak request . get request uri ( ) , handshak request . get paramet map ( ) , handshak request . get queri string ( ) , handshak request . get user princip ( ) , sub protocol , path paramet , secur , endpoint config . get encod ( ) , endpoint config . get user properti ( ) ) ; ws frame server ws frame = new ws frame server ( si , ws session ) ; si . set read listen ( new ws read listen ( thi , ws frame ) ) ; so . set write listen ( new ws write listen ( thi , ws remot endpoint server ) ) ; ep . open ( ws session , endpoint config ) ; web socket contain . regist session ( ep . get class ( ) , ws session ) ; } catch ( deploy except e ) { throw new illeg argument except ( e ) ; } final { t . set context class loader ( cl ) ; } }	public void write possibl ( ) { boolean complet = true ; try { thi fals call back when true while ( so . readi ( ) ) { complet = true ; ( byte buffer buffer : buffer ) { ( buffer . ha remain ( ) ) { complet = fals ; so . write ( buffer . arrai ( ) , buffer . arrai offset ( ) , buffer . limit ( ) ) ; buffer . posit ( buffer . limit ( ) ) ; break ; } } ( complet ) { ws write timeout . unregist ( thi ) ; ( close ) { close ( ) ; } set result mark thi ( partial ) messag complet which mean next mai sent which could updat valu handler . therefor , keep local copi befor signal end ( partial ) messag . send handler sh = handler ; handler = null ; sh . result ( new send result ( ) ) ; break ; } } } catch ( ioexcept ioe ) { ws write timeout . unregist ( thi ) ; close ( ) ; send handler sh = handler ; handler = null ; sh . result ( new send result ( ioe ) ) ; } ( complet ) { async write progress long timeout = get send timeout ( ) ; ( timeout 0 ) { regist timeout thread timeout expiri = timeout system . current time milli ( ) ; ws write timeout . regist ( thi ) ; } } }	public void test ( ) throw except { set up util class server server = new server ( ) ; singleton configur . set instanc ( server ) ; server config listen . set pojo clazz ( server . class ) ; tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; ctx . add applic listen ( new applic listen ( server config listen . class . get name ( ) , fals ) ) ; tomcat . add servlet ( ctx , default , new default servlet ( ) ) ; ctx . add servlet map ( , default ) ; web socket contain ws contain = contain provid . get web socket contain ( ) ; tomcat . start ( ) ; client client = new client ( ) ; uri uri = new uri ( ws : localhost : get port ( ) ) ; session session = ws contain . connect server ( client , uri ) ; msg string msg1 = new msg string ( ) ; msg1 . set data ( messag ) ; session . get basic remot ( ) . send object ( msg1 ) ; should take veri long int i = 0 ; while ( i 20 ) { ( server . receiv . size ( ) 0 client . receiv . size ( ) 0 ) { break ; } thread . sleep ( 100 ) ; } check messag were receiv assert . assert equal ( 1 , server . receiv . size ( ) ) ; assert . assert equal ( 1 , client . receiv . size ( ) ) ; check correct messag were receiv assert . assert equal ( messag , ( ( msg string ) server . receiv . peek ( ) ) . get data ( ) ) ; assert . assert equal ( messag , ( ( msg string ) client . receiv . peek ( ) ) . get data ( ) ) ; }
privat static object build arg ( pojo path param path param , map string , string path paramet , session session , endpoint config config , throwabl throwabl , close reason close reason ) throw decod except { object result = new object path param . length ; ( int i = 0 ; i path param . length ; i ) { class type = path param i . get type ( ) ; ( type . equal ( session . class ) ) { result i = session ; } els ( type . equal ( endpoint config . class ) ) { result i = config ; } els ( type . equal ( throwabl . class ) ) { result i = throwabl ; } els ( type . equal ( close reason . class ) ) { result i = close reason ; } els { string name = path param i . get name ( ) ; string valu = path paramet . get ( name ) ; try { result i = util . coerc type ( type , valu ) ; } catch ( except e ) { throw new decod except ( valu , sm . get string ( pojo method map . decod path param fail , valu , type ) , e ) ; } } } return result ; }
public boolean authent ( request request , http servlet respons respons ) throw ioexcept { have we alreadi authent someon princip princip = request . get user princip ( ) ; string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( princip = null ) { ( log . debug enabl ( ) ) { log . debug ( alreadi authent princip . get name ( ) ) ; } associ session ani exist sso session ( sso id = null ) { associ ( sso id , request . get session intern ( true ) ) ; } return ( true ) ; } sso session against which we can try reauthent ( sso id = null ) { ( log . debug enabl ( ) ) { log . debug ( sso id sso id set ; attempt reauthent ) ; } try reauthent us data cach sso . thi fail , either origin sso logon wa digest ssl ( which we can t reauthent ourselv becaus cach usernam password ) , realm deni user s reauthent some reason . either case we have prompt user logon ( reauthent from sso ( sso id , request ) ) { return true ; } } valid ani credenti alreadi includ thi request string usernam = null ; string password = null ; messag byte author = request . get coyot request ( ) . get mime header ( ) . get valu ( author ) ; ( author = null ) { author . byte ( ) ; byte chunk author bc = author . get byte chunk ( ) ; ( author bc . start ignor case ( basic , 0 ) ) { author bc . set offset ( author bc . get offset ( ) 6 ) ; byte decod = base64 . decod base64 ( author bc . get buffer ( ) , author bc . get offset ( ) , author bc . get length ( ) ) ; get usernam password int colon = 1 ; ( int i = 0 ; i decod . length ; i ) { ( decod i = = : ) { colon = i ; break ; } } ( colon 0 ) { usernam = new string ( decod , b2cconvert . iso 8859 1 ) ; } els { usernam = new string ( decod , 0 , colon , b2cconvert . iso 8859 1 ) ; password = new string ( decod , colon 1 , decod . length colon 1 , b2cconvert . iso 8859 1 ) ; } author bc . set offset ( author bc . get offset ( ) 6 ) ; } princip = context . get realm ( ) . authent ( usernam , password ) ; ( princip = null ) { regist ( request , respons , princip , http servlet request . basic auth , usernam , password ) ; return ( true ) ; } } string builder valu = new string builder ( 16 ) ; valu . append ( basic realm = ) ; valu . append ( get realm name ( context ) ) ; valu . append ( ) ; respons . set header ( auth header name , valu . string ( ) ) ; respons . send error ( http servlet respons . sc unauthor ) ; return ( fals ) ; }	overrid protect string get auth method ( ) { return http servlet request . basic auth ; }	thi same test accept protect basic ( abov ) , except us excess white space after authent method . access challeng 401 sc unauthor , permit onc authent . rfc2617 doe defin separ syntax between auth scheme basic credenti token . tomcat toler ani amount white space ( within limit http header size ) return sc ok . test public void test auth method extra space ( ) throw except { do test basic ( context path login uri protect , credenti , cooki , http servlet respons . sc unauthor ) ; do test basic ( context path login uri protect , space base64 , cooki , http servlet respons . sc ok ) ; }	thi same test accept protect basic ( abov ) , except us white space around password credenti . request reject 401 sc unauthor statu . todo : rfc2617 doe defin separ syntax between auth scheme basic credenti token . tomcat should toler ani reason amount white space return sc ok . test public void test password extra space ( ) throw except { do test basic ( context path login uri protect , credenti , cooki , http servlet respons . sc unauthor ) ; do test basic ( context path login uri protect , space password , cooki , http servlet respons . sc unauthor ) ; }	thi same test accept protect basic ( abov ) , except us white space around usernam credenti . request reject 401 sc unauthor statu . todo : rfc2617 doe defin separ syntax between auth scheme basic credenti token . tomcat should toler ani reason amount white space return sc ok . test public void test user extra space ( ) throw except { do test basic ( context path login uri protect , credenti , cooki , http servlet respons . sc unauthor ) ; do test basic ( context path login uri protect , space usernam , cooki , http servlet respons . sc unauthor ) ; }
privat scan url jar option extens look all file all directori . void process ( jar scanner callback callback , url url , boolean webapp ) throw ioexcept { ( log . trace enabl ( ) ) { log . trace ( sm . get string ( jar scan . jar url start , url ) ) ; } urlconnect conn = url . open connect ( ) ; ( conn instanceof jar urlconnect ) { callback . scan ( ( jar urlconnect ) conn , webapp ) ; } els { string url str = url . string ( ) ; ( url str . start ( file : ) url str . start ( jndi : ) ) { ( url str . end ( constant . jar ext ) ) { url jar url = new url ( jar : url str ) ; callback . scan ( ( jar urlconnect ) jar url . open connect ( ) , webapp ) ; } els { file f ; try { f = new file ( url . uri ( ) ) ; ( f . file ( ) scan all file ) { treat thi file jar url jar url = new url ( jar : url str ) ; callback . scan ( ( jar urlconnect ) jar url . open connect ( ) , webapp ) ; } els ( f . directori ( ) scan all directori ) { file metainf = new file ( f . get absolut file ( ) file . separ meta inf ) ; ( metainf . directori ( ) ) { callback . scan ( f , webapp ) ; } } } catch ( urisyntax except e ) { wrap except re throw ioexcept ioe = new ioexcept ( ) ; ioe . init caus ( e ) ; throw ioe ; } } } } }
start thi compon implement requir { link org . apach . catalina . util . lifecycl base start intern ( ) } . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect synchron void start intern ( ) throw lifecycl except { ( log . debug enabl ( ) ) log . debug ( start get base name ( ) ) ; send j2ee . state . start notif ( thi . get object name ( ) = null ) { notif notif = new notif ( j2ee . state . start , thi . get object name ( ) , sequenc number . get increment ( ) ) ; broadcast . send notif ( notif ) ; } set configur ( fals ) ; boolean ok = true ; ensur name resourc follow correct lifecycl ( name resourc = null ) { name resourc . start ( ) ; } add miss compon necessari ( get resourc ( ) = = null ) { ( 1 ) requir loader ( log . debug enabl ( ) ) log . debug ( configur default resourc ) ; try { set resourc ( new standard root ( thi ) ) ; } catch ( illeg argument except e ) { log . error ( error initi resourc : e . get messag ( ) ) ; ok = fals ; } } ( ok ) { ( resourc start ( ) ) { log . error ( error resourc start ( ) ) ; ok = fals ; } } ( get loader ( ) = = null ) { webapp loader webapp loader = new webapp loader ( get parent class loader ( ) ) ; webapp loader . set deleg ( get deleg ( ) ) ; set loader ( webapp loader ) ; } initi charact set mapper get charset mapper ( ) ; post work directori post work directori ( ) ; valid requir extens boolean depend check = true ; try { depend check = extens valid . valid applic ( get resourc ( ) , thi ) ; } catch ( ioexcept ioe ) { log . error ( error depend check , ioe ) ; depend check = fals ; } ( depend check ) { do make applic avail depenc check fail ok = fals ; } read catalina . us name environ variabl string us name properti = system . get properti ( catalina . us name ) ; ( ( us name properti = null ) ( us name properti . equal ( fals ) ) ) { us name = fals ; } ( ok us name ( ) ) { ( get name context listen ( ) = = null ) { name context listen ncl = new name context listen ( ) ; ncl . set name ( get name context name ( ) ) ; ncl . set except fail write ( get jndi except fail write ( ) ) ; add lifecycl listen ( ncl ) ; set name context listen ( ncl ) ; } } standard contain startup ( log . debug enabl ( ) ) log . debug ( process standard contain startup ) ; bind thread class loader old ccl = bind thread ( ) ; try { ( ok ) { start our subordin compon , ani loader loader = get loader ( ) ; ( ( loader = null ) ( loader instanceof lifecycl ) ) ( ( lifecycl ) loader ) . start ( ) ; sinc loader just start , webapp classload now creat . set class loader properti ( anti jarlock , get anti jarlock ( ) ) ; set class loader properti ( clear refer static , get clear refer static ( ) ) ; set class loader properti ( clear refer stop thread , get clear refer stop thread ( ) ) ; set class loader properti ( clear refer stop timer thread , get clear refer stop timer thread ( ) ) ; set class loader properti ( clear refer http client keep aliv thread , get clear refer http client keep aliv thread ( ) ) ; call unbind thread bind thread row , we setup current thread ccl webapp classload unbind thread ( old ccl ) ; old ccl = bind thread ( ) ; initi logger again . other compon might have us too earli , so should reset . logger = null ; get logger ( ) ; cluster cluster = get cluster intern ( ) ; ( ( cluster = null ) ( cluster instanceof lifecycl ) ) ( ( lifecycl ) cluster ) . start ( ) ; realm realm = get realm intern ( ) ; ( ( realm = null ) ( realm instanceof lifecycl ) ) ( ( lifecycl ) realm ) . start ( ) ; notifi our interest lifecycl listen fire lifecycl event ( lifecycl . configur start event , null ) ; start our child contain , alreadi start ( contain child : find children ( ) ) { ( child . get state ( ) . avail ( ) ) { child . start ( ) ; } } ani ( pipelin instanceof lifecycl ) { ( ( lifecycl ) pipelin ) . start ( ) ; } acquir cluster manag manag context manag = null ; manag manag = get manag ( ) ; ( manag = = null ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( standard context . cluster . manag , boolean . valu ( ( get cluster ( ) = null ) ) , boolean . valu ( distribut ) ) ) ; } ( ( get cluster ( ) = null ) distribut ) { try { context manag = get cluster ( ) . creat manag ( get name ( ) ) ; } catch ( except ex ) { log . error ( standard context . cluster fail , ex ) ; ok = fals ; } } els { context manag = new standard manag ( ) ; } } configur default manag none wa specifi ( context manag = null ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( standard context . manag , context manag . get class ( ) . get name ( ) ) ) ; } set manag ( context manag ) ; } ( manag = null ( get cluster ( ) = null ) distribut ) { let cluster know context distribut ha own manag get cluster ( ) . regist manag ( manag ) ; } } } final { unbind thread unbind thread ( old ccl ) ; } ( get configur ( ) ) { log . error ( error get configur ) ; ok = fals ; } we put resourc servlet context ( ok ) get servlet context ( ) . set attribut ( global . resourc attr , get resourc ( ) ) ; bind thread old ccl = bind thread ( ) ; ( ok ) { ( get instanc manag ( ) = = null ) { javax . name . context context = null ; ( us name ( ) get name context listen ( ) = null ) { context = get name context listen ( ) . get env context ( ) ; } map string , map string , string >> inject map = build inject map ( get ignor annot ( ) new name resourc ( ) : get name resourc ( ) ) ; set instanc manag ( new default instanc manag ( context , inject map , thi , thi . get class ( ) . get class loader ( ) ) ) ; get servlet context ( ) . set attribut ( instanc manag . class . get name ( ) , get instanc manag ( ) ) ; } } try { creat context attribut requir ( ok ) { get servlet context ( ) . set attribut ( jar scanner . class . get name ( ) , get jar scanner ( ) ) ; } set up context init param merg paramet ( ) ; call servlet contain initi ( map . entri servlet contain initi , set class >> entri : initi . entri set ( ) ) { try { entri . get kei ( ) . startup ( entri . get valu ( ) , get servlet context ( ) ) ; } catch ( servlet except e ) { log . error ( sm . get string ( standard context . sci fail ) , e ) ; ok = fals ; break ; } } configur call applic event listen ( ok ) { ( listen start ( ) ) { log . error ( error listen start ) ; ok = fals ; } } try { start manag manag manag = get manag ( ) ; ( ( manag = null ) ( manag instanceof lifecycl ) ) { ( ( lifecycl ) get manag ( ) ) . start ( ) ; } } catch ( except e ) { log . error ( error manag . start ( ) , e ) ; ok = fals ; } configur call applic filter ( ok ) { ( filter start ( ) ) { log . error ( error filter start ) ; ok = fals ; } } load initi all load startup servlet ( ok ) { load startup ( find children ( ) ) ; } start contain background processor thread super . thread start ( ) ; } final { unbind thread unbind thread ( old ccl ) ; } set avail statu depend upon startup success ( ok ) { ( log . debug enabl ( ) ) log . debug ( start complet ) ; } els { log . error ( sm . get string ( standard context . start fail , get name ( ) ) ) ; } start time = system . current time milli ( ) ; send j2ee . state . run notif ( ok ( thi . get object name ( ) = null ) ) { notif notif = new notif ( j2ee . state . run , thi . get object name ( ) , sequenc number . get increment ( ) ) ; broadcast . send notif ( notif ) ; } file startup ( get loader ( ) instanceof webapp loader ) { ( ( webapp loader ) get loader ( ) ) . close jar ( true ) ; } reiniti someth went wrong ( ok ) { set state ( lifecycl state . fail ) ; } els { set state ( lifecycl state . start ) ; } }
privat check see given attribut valu repres runtim el express . boolean express ( node n , string valu , boolean check defer ) { boolean runtim express = ( ( n . get root ( ) . xml syntax ( ) valu . start ( = ) ) ( n . get root ( ) . xml syntax ( ) valu . start ( = ) ) ) ; boolean el express = fals ; ( runtim express page info . elignor ( ) ) { iter elnod node = elpars . pars ( valu , page info . defer syntax allow liter ( ) ) . iter ( ) ; while ( node . ha next ( ) ) { elnod node = node . next ( ) ; ( node instanceof elnod . root ) { ( ( ( elnod . root ) node ) . get type ( ) = = ) { el express = true ; } els ( check defer page info . defer syntax allow liter ( ) ( ( elnod . root ) node ) . get type ( ) = = ) { el express = true ; } } } } return runtim express el express ; }
public member exclud from set ( member mbr , member set ) { arrai list member result = new arrai list ( ) ; ( int i = 0 ; i set . length ; i ) { boolean includ = true ; ( int j = 0 ; j mbr . length ; j ) ( mbr j . equal ( set i ) ) includ = fals ; ( includ ) result . add ( set i ) ; } return result . arrai ( new member result . size ( ) ) ; }
privat check see resourc current write lock . param path path resourc param header http header which wa includ request return boolean true resourc lock ( appropri lock token ha been found least non share lock which ar present resourc ) . boolean lock ( string path , string header ) { check resourc lock lock info lock = resourc lock . get ( path ) ; enumer string token list = null ; ( ( lock = null ) ( lock . ha expir ( ) ) ) { resourc lock . remov ( path ) ; } els ( lock = null ) { least token lock must have been given token list = lock . token . element ( ) ; boolean token match = fals ; while ( token list . ha more element ( ) ) { string token = token list . next element ( ) ; ( header . index ( token ) = 1 ) token match = true ; } ( token match ) return true ; } check inherit collect lock enumer lock info collect lock list = collect lock . element ( ) ; while ( collect lock list . ha more element ( ) ) { lock = collect lock list . next element ( ) ; ( lock . ha expir ( ) ) { collect lock . remov element ( lock ) ; } els ( path . start ( lock . path ) ) { token list = lock . token . element ( ) ; boolean token match = fals ; while ( token list . ha more element ( ) ) { string token = token list . next element ( ) ; ( header . index ( token ) = 1 ) token match = true ; } ( token match ) return true ; } } return fals ; }
privat void do test basic ( string uri , basic credenti credenti , boolean us cooki , int expect rc ) throw except { map string , list string >> req header = new hash map ( ) ; map string , list string >> resp header = new hash map ( ) ; ( us cooki ( cooki = null ) ) { req header . put ( client cooki header : , cooki ) ; } els { ( credenti = null ) { list string auth = new arrai list ( ) ; auth . add ( credenti . get credenti ( ) ) ; req header . put ( client auth header , auth ) ; } } byte chunk bc = new byte chunk ( ) ; int rc = get url ( http prefix get port ( ) uri , bc , req header , resp header ) ; ( expect rc = http servlet respons . sc ok ) { assert equal ( expect rc , rc ) ; assert true ( bc . get length ( ) 0 ) ; ( expect rc = = http servlet respons . sc unauthor ) { server should identifi accept method ( s ) boolean method found = fals ; list string auth header = resp header . get ( server auth header ) ; ( string auth header : auth header ) { ( auth header . index ( nice method ) 1 ) { method found = true ; } } assert true ( method found ) ; } } els { assert equal ( ok , bc . string ( ) ) ; list string new cooki = resp header . get ( server cooki header ) ; ( new cooki = null ) { harvest cooki whenev server send some new cooki = new cooki ; } } }	test public void test session expiri contain ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; ctx . add applic listen ( new applic listen ( tester echo server . config . class . get name ( ) , fals ) ) ; tomcat . add servlet ( ctx , default , new default servlet ( ) ) ; ctx . add servlet map ( , default ) ; tomcat . start ( ) ; need access implement method configur unit test ws web socket contain ws contain = ( ws web socket contain ) contain provid . get web socket contain ( ) ; 5 second timeout ws contain . set default max session idl timeout ( 5000 ) ; ws contain . set process period ( 1 ) ; connect echo server basic ( ws contain , endpoint . class ) ; connect echo server basic ( ws contain , endpoint . class ) ; session s3a = connect echo server basic ( ws contain , endpoint . class ) ; check all three session ar open set session set = s3a . get open session ( ) ; assert . assert equal ( 3 , set . size ( ) ) ; int count = 0 ; boolean open = true ; while ( open count 8 ) { count ; thread . sleep ( 1000 ) ; open = fals ; ( session session : set ) { ( session . open ( ) ) { open = true ; } } } ( open ) { ( session session : set ) { ( session . open ( ) ) { system . err . println ( session id session . get id ( ) open ) ; } } assert . fail ( were open session ) ; } }
get valu specifi properti classload local configur . param name properti name overrid public string get properti ( string name ) { class loader class loader = thread . current thread ( ) . get context class loader ( ) ; string prefix = thi . prefix . get ( ) ; ( prefix = null ) { name = prefix name ; } class loader log info info = get class loader info ( class loader ) ; string result = info . prop . get properti ( name ) ; properti . ( ( result = = null ) ( info . prop . empti ( ) ) ) { class loader current = class loader . get parent ( ) ; while ( current = null ) { info = class loader logger . get ( current ) ; ( info = null ) { result = info . prop . get properti ( name ) ; ( ( result = null ) ( info . prop . empti ( ) ) ) { break ; } } current = current . get parent ( ) ; } ( result = = null ) { result = super . get properti ( name ) ; } } simpl properti replac ( mostli folder name ) ( result = null ) { result = replac ( result ) ; } return result ; }
overrid public boolean commit ( ) { return fals ; }	overrid public void add date header ( string name , long valu ) { noop }	overrid public void set date header ( string name , long valu ) { noop }	overrid public void set int header ( string name , int valu ) { noop }	overrid public int get statu ( ) { return 1 ; }
execut request oper . except build except error occur overrid public void execut ( ) throw build except { super . execut ( ) ; ( path = = null ) { throw new build except ( must specifi path attribut ) ; } ( ( war = = null ) ( local war = = null ) ( config = = null ) ( tag = = null ) ) { throw new build except ( must specifi either war , local war , config , tag attribut ) ; } build input stream war upload , ani buffer input stream stream = null ; string content type = null ; int content length = 1 ; ( war = null ) { ( war . start ( file : ) ) { try { url url = new url ( war ) ; urlconnect conn = url . open connect ( ) ; content length = conn . get content length ( ) ; stream = new buffer input stream ( conn . get input stream ( ) , 1024 ) ; } catch ( ioexcept e ) { throw new build except ( e ) ; } } els { try { file input stream fs input = new file input stream ( war ) ; long size = fs input . get channel ( ) . size ( ) ; ( size integ . max valu ) throw new unsupport oper except ( deploi task doe support war file greater than 2 gb ) ; content length = ( int ) size ; stream = new buffer input stream ( fs input , 1024 ) ; } catch ( ioexcept e ) { throw new build except ( e ) ; } } content type = applic octet stream ; } build url string builder sb = new string builder ( deploi path = ) ; try { sb . append ( urlencod . encod ( thi . path , get charset ( ) ) ) ; ( ( war = = null ) ( config = null ) ) { sb . append ( config = ) ; sb . append ( urlencod . encod ( config , get charset ( ) ) ) ; } ( ( war = = null ) ( local war = null ) ) { sb . append ( war = ) ; sb . append ( urlencod . encod ( local war , get charset ( ) ) ) ; } ( updat ) { sb . append ( updat = true ) ; } ( tag = null ) { sb . append ( tag = ) ; sb . append ( urlencod . encod ( tag , get charset ( ) ) ) ; } } catch ( unsupport encod except e ) { throw new build except ( invalid charset attribut : get charset ( ) ) ; } execut ( sb . string ( ) , stream , content type , content length ) ; }	public void set local war ( string local war ) { thi . local war = local war ; }
public regist authent princip authent type our request , current session ( ) , our singl sign valv , . set appropri cooki return . param request servlet request we ar process param respons servlet respons we ar gener param princip authent princip regist param auth type authent type regist param usernam usernam us authent ( ani ) param password password us authent ( ani ) void regist ( request request , http servlet respons respons , princip princip , string auth type , string usernam , string password ) { ( log . debug enabl ( ) ) { string name = ( princip = = null ) none : princip . get name ( ) ; log . debug ( authent name type auth type ) ; } cach authent inform our request request . set auth type ( auth type ) ; request . set user princip ( princip ) ; session session = request . get session intern ( fals ) ; ( session = null ) { ( chang session id authent ) { manag manag = request . get context ( ) . get manag ( ) ; manag . chang session id ( session ) ; request . chang session id ( session . get id ( ) ) ; } } els ( alwai us session ) { session = request . get session intern ( true ) ; } cach authent inform our session , ani ( cach ) { ( session = null ) { session . set auth type ( auth type ) ; session . set princip ( princip ) ; ( usernam = null ) { session . set note ( constant . sess usernam note , usernam ) ; } els { session . remov note ( constant . sess usernam note ) ; } ( password = null ) { session . set note ( constant . sess password note , password ) ; } els { session . remov note ( constant . sess password note ) ; } } } construct cooki return client ( sso = = null ) { return ; } onli creat new sso entri sso did alreadi set note exist entri ( would do subsequ request digest ssl authent context ) string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( sso id = = null ) { construct cooki return client sso id = session id gener . gener session id ( ) ; cooki cooki = new cooki ( constant . singl sign cooki , sso id ) ; cooki . set max ag ( 1 ) ; cooki . set path ( ) ; bugzilla 41217 cooki . set secur ( request . secur ( ) ) ; bugzilla 34724 string sso domain = sso . get cooki domain ( ) ; ( sso domain = null ) { cooki . set domain ( sso domain ) ; } configur http onli sso cooki us same rule session cooki ( request . get servlet context ( ) . get session cooki config ( ) . http onli ( ) request . get context ( ) . get us http onli ( ) ) { cooki . set http onli ( true ) ; } respons . add cooki ( cooki ) ; regist thi princip our sso valv sso . regist ( sso id , princip , auth type , usernam , password ) ; request . set note ( constant . req ssoid note , sso id ) ; } els { ( princip = = null ) { regist programmat logout sso . deregist ( sso id ) ; return ; } els { updat sso session latest authent data sso . updat ( sso id , princip , auth type , usernam , password ) ; } } sso entri never clear we don t associ session ( session = = null ) { session = request . get session intern ( true ) ; } sso . associ ( sso id , session ) ; }
privat handshak statu check result ( sslengin result result , boolean wrap ) throw sslexcept { ( result . get statu ( ) = statu . ok ) { throw new sslexcept ( todo ) ; } ( wrap result . byte consum ( ) = 0 ) { throw new sslexcept ( todo ) ; } ( wrap result . byte produc ( ) = 0 ) { throw new sslexcept ( todo ) ; } return result . get handshak statu ( ) ; }	overrid public void run ( ) { long written = 0 ; try { ( int i = offset ; i offset length ; i ) { byte buffer src = src i ; while ( src . ha remain ( ) ) { socket write buffer . clear ( ) ; encrypt data sslengin result r = ssl engin . wrap ( src , socket write buffer ) ; written = r . byte consum ( ) ; statu s = r . get statu ( ) ; ( s = = statu . ok s = = statu . buffer overflow ) { need write out byte mai need read from sourc again empti } els { todo throw new illeg state except ( ) ; } check task ( r . get handshak statu ( ) = = handshak statu . need task ) { runnabl runnabl = ssl engin . get deleg task ( ) ; while ( runnabl = null ) { runnabl . run ( ) ; runnabl = ssl engin . get deleg task ( ) ; } } socket write buffer . flip ( ) ; do write futur integ f = socket channel . write ( socket write buffer ) ; integ socket write = f . get ( ) ; ( socket write . int valu ( ) = r . byte produc ( ) ) { throw new ioexcept ( ) ; } } } ( write . compar set ( true , fals ) ) { futur . complet ( long . valu ( written ) ) ; } els { todo futur . fail ( new illeg state except ( ) ) ; } } catch ( except e ) { futur . fail ( e ) ; } }
privat void pars part ( ) { return immedi part have alreadi been pars ( part = null part pars except = null ) { return ; } multipart config element mce = get wrapper ( ) . get multipart config element ( ) ; ( mce = = null ) { ( get context ( ) . get allow casual multipart pars ( ) ) { mce = new multipart config element ( null , connector . get max post size ( ) , connector . get max post size ( ) , connector . get max post size ( ) ) ; } els { part = collect . empti list ( ) ; return ; } } paramet paramet = coyot request . get paramet ( ) ; paramet . set limit ( get connector ( ) . get max paramet count ( ) ) ; boolean success = fals ; try { file locat ; string locat str = mce . get locat ( ) ; ( locat str = = null locat str . length ( ) = = 0 ) { locat = ( ( file ) context . get servlet context ( ) . get attribut ( servlet context . tempdir ) ) ; } els { rel , rel tempdir locat = new file ( locat str ) ; ( locat . absolut ( ) ) { locat = new file ( ( file ) context . get servlet context ( ) . get attribut ( servlet context . tempdir ) , locat str ) . get absolut file ( ) ; } } ( locat . directori ( ) ) { part pars except = new ioexcept ( sm . get string ( coyot request . upload locat invalid , locat ) ) ; return ; } creat new file upload handler disk file item factori factori = new disk file item factori ( ) ; try { factori . set repositori ( locat . get canon file ( ) ) ; } catch ( ioexcept ioe ) { part pars except = ioe ; return ; } factori . set size threshold ( mce . get file size threshold ( ) ) ; servlet file upload upload = new servlet file upload ( ) ; upload . set file item factori ( factori ) ; upload . set file size max ( mce . get max file size ( ) ) ; upload . set size max ( mce . get max request size ( ) ) ; part = new arrai list ( ) ; try { list file item item = upload . pars request ( new servlet request context ( thi ) ) ; int max post size = get connector ( ) . get max post size ( ) ; int post size = 0 ; string enc = get charact encod ( ) ; charset charset = null ; ( enc = null ) { try { charset = b2cconvert . get charset ( enc ) ; } catch ( unsupport encod except e ) { ignor } } ( file item item : item ) { applic part part = new applic part ( item , mce ) ; part . add ( part ) ; ( part . get submit file name ( ) = = null ) { string name = part . get name ( ) ; string valu = null ; try { string encod = paramet . get encod ( ) ; ( encod = = null ) { ( enc = = null ) { encod = paramet . default encod ; } els { encod = enc ; } } valu = part . get string ( encod ) ; } catch ( unsupport encod except uee ) { try { valu = part . get string ( paramet . default encod ) ; } catch ( unsupport encod except e ) { should possibl } } ( max post size 0 ) { accur close enough . ( charset = = null ) { name length post size = name . get byte ( ) . length ; } els { post size = name . get byte ( charset ) . length ; } ( valu = null ) { equal sign post size ; valu length post size = part . get size ( ) ; } valu separ post size ; ( post size max post size ) { throw new illeg state except ( sm . get string ( coyot request . max post size exceed ) ) ; } } paramet . add paramet ( name , valu ) ; } } success = true ; } catch ( invalid content type except e ) { part pars except = new servlet except ( e ) ; } catch ( file upload base . size except e ) { check swallow input ( ) ; part pars except = new illeg state except ( e ) ; } catch ( file upload except e ) { part pars except = new ioexcept ( e ) ; } catch ( illeg state except e ) { check swallow input ( ) ; part pars except = e ; } } final { ( part pars except = null success ) { paramet . set pars fail ( true ) ; } } }	overrid public void write ( string file name ) throw ioexcept { file file = new file ( file name ) ; ( file . absolut ( ) ) { file = new file ( mce . get locat ( ) , file name ) ; } try { file item . write ( file ) ; } catch ( except e ) { throw new ioexcept ( e ) ; } }
privat void load tag plugin ( error dispatch err , input stream ) throw jasper except { tree node root = ( new parser util ( ) ) . pars xmldocument ( tag plugin xml , ) ; ( root = = null ) { return ; } ( tag plugin root elem . equal ( root . get name ( ) ) ) { err . jsp error ( jsp . error . plugin . wrong root element , tag plugin xml , tag plugin root elem ) ; } tag plugin = new hash map ( ) ; iter tree node plugin list = root . find children ( tag plugin ) ; while ( plugin list . ha next ( ) ) { tree node plugin node = plugin list . next ( ) ; tree node tag class node = plugin node . find child ( tag class ) ; ( tag class node = = null ) { error return ; } string tag class = tag class node . get bodi ( ) . trim ( ) ; tree node plugin class node = plugin node . find child ( plugin class ) ; ( plugin class node = = null ) { error return ; } string plugin class str = plugin class node . get bodi ( ) ; tag plugin tag plugin = null ; try { class plugin class = class . name ( plugin class str ) ; tag plugin = ( tag plugin ) plugin class . new instanc ( ) ; } catch ( except e ) { throw new jasper except ( e ) ; } ( tag plugin = = null ) { return ; } tag plugin . put ( tag class , tag plugin ) ; } initi = true ; }
overrid public void accept ( object socket ) { spdy connect socket ch = new spdy connect socket ( ctx , ( socket ) socket ) ; ctx . get executor ( ) . execut ( ch . input thread ) ; ch . block socket ( ) ; }
public void start ( ) throw except { super . start ( ) ; spdy context = new spdy context ( ) ; spdy context . set tl comprress ( fals , fals ) ; spdy context . set handler ( new spdy handler ( ) { overrid public void stream ( spdy connect con , spdy stream ch ) throw ioexcept { spdy processor sp = new spdy processor ( con , endpoint ) ; sp . set adapt ( get adapt ( ) ) ; sp . syn stream ( ch ) ; } } ) ; spdy context . set net support ( new net support socket ( ) ) ; spdy context . set executor ( endpoint . get executor ( ) ) ; }	overrid public void start ( ) throw except { super . start ( ) ; spdy context = new spdy context ( ) ; spdy context . set tl comprress ( fals , fals ) ; spdy context . set handler ( new spdy handler ( ) { overrid } }
test case new line start request . rfc2616 doe permit ani , tomcat toler them thei ar present . test public void test new line excess ( ) { new line client client = new new line client ( 10000 ) ; connect close fast enough , write request fail respons won t read . except e = client . do request ( ) ; ( e = = null ) { assert true ( client . response400 ( ) ) ; } assert fals ( client . respons bodi ok ( ) ) ; }	read request line . thi function meant us dure http request header pars . do attempt read request bodi us . throw ioexcept except occur dure underli socket read oper , given buffer big enough accommod whole line . return true data properli fed ; fals data avail immedi thread should freed overrid public boolean pars request line ( boolean us avail data onli ) throw ioexcept { check state ( pars request line ) return true ; ( pars request line phase = = 0 ) { byte chr = 0 ; do { read new byte need ( po = last valid ) { ( us avail data onli ) { return fals ; } do simpl read short timeout ( fill ( true , fals ) ) { return fals ; } } chr = buf po ; } while ( ( chr = = constant . cr ) ( chr = = constant . lf ) ) ; po ; pars request line start = po ; pars request line phase = 2 ; ( log . debug enabl ( ) ) { log . debug ( receiv new string ( buf , po , last valid po , default charset ) ) ; } } ( pars request line phase = = 2 ) { read method name method name alwai us ascii boolean space = fals ; while ( space ) { read new byte need ( po = last valid ) { ( request line pars fill ( true , fals ) ) return fals ; } spec sai cr lf method name ( buf po = = constant . cr buf po = = constant . lf ) { throw new illeg argument except ( sm . get string ( iib . invalidmethod ) ) ; } ( buf po = = constant . sp buf po = = constant . ht ) { space = true ; request . method ( ) . set byte ( buf , pars request line start , po pars request line start ) ; } po ; } pars request line phase = 3 ; } ( pars request line phase = = 3 ) { spec sai singl sp also toler multipl ht boolean space = true ; while ( space ) { read new byte need ( po = last valid ) { ( request line pars fill ( true , fals ) ) return fals ; } ( buf po = = constant . sp buf po = = constant . ht ) { po ; } els { space = fals ; } } pars request line start = po ; pars request line phase = 4 ; } ( pars request line phase = = 4 ) { mark current buffer posit int end = 0 ; read uri boolean space = fals ; while ( space ) { read new byte need ( po = last valid ) { ( request line pars fill ( true , fals ) ) return fals ; } ( buf po = = constant . sp buf po = = constant . ht ) { space = true ; end = po ; } els ( ( buf po = = constant . cr ) ( buf po = = constant . lf ) ) { http 0 . 9 style request pars request line eol = true ; space = true ; end = po ; } els ( ( buf po = = constant . question ) ( pars request line qpo = = 1 ) ) { pars request line qpo = po ; } po ; } request . unpars uri ( ) . set byte ( buf , pars request line start , end pars request line start ) ; ( pars request line qpo = 0 ) { request . queri string ( ) . set byte ( buf , pars request line qpo 1 , end pars request line qpo 1 ) ; request . request uri ( ) . set byte ( buf , pars request line start , pars request line qpo pars request line start ) ; } els { request . request uri ( ) . set byte ( buf , pars request line start , end pars request line start ) ; } pars request line phase = 5 ; } ( pars request line phase = = 5 ) { spec sai singl sp also toler multipl ht boolean space = true ; while ( space ) { read new byte need ( po = last valid ) { ( request line pars fill ( true , fals ) ) return fals ; } ( buf po = = constant . sp buf po = = constant . ht ) { po ; } els { space = fals ; } } pars request line start = po ; pars request line phase = 6 ; } ( pars request line phase = = 6 ) { mark current buffer posit end = 0 ; while ( pars request line eol ) { read new byte need ( po = last valid ) { ( request line pars fill ( true , fals ) ) return fals ; } ( buf po = = constant . cr ) { end = po ; } els ( buf po = = constant . lf ) { ( end = = 0 ) end = po ; pars request line eol = true ; } po ; } ( ( end pars request line start ) 0 ) { request . protocol ( ) . set byte ( buf , pars request line start , end pars request line start ) ; } els { request . protocol ( ) . set string ( ) ; } pars request line = fals ; pars request line phase = 0 ; pars request line eol = fals ; pars request line start = 0 ; return true ; } throw new illeg state except ( invalid request line pars phase : pars request line phase ) ; }
privat void do test ( string resourc method , string redirect method , boolean us continu ) throw except { form auth client client = new form auth client ( ) ; first request authent resourc client . set us continu ( us continu ) ; client . do resourc request ( resourc method ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; second request login page client . set us continu ( us continu ) ; client . do login request ( ) ; assert true ( client . response302 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; third request follow redirect client . do resourc request ( redirect method ) ; ( post . equal ( redirect method ) ) { client . set us continu ( us continu ) ; } assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; subsequ request direct resourc ( int i = 0 ; i 5 ; i ) { client . set us continu ( us continu ) ; client . do resourc request ( resourc method ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; } }	privat void assert contain ( string bodi , string expect ) { ( bodi . contain ( expect ) ) { fail ( respons bodi check failur . n expect contain substr : expect n actual : bodi ) ; } }	privat void do login request ( ) throw except { string builder request head = new string builder ( 128 ) ; request head . append ( post ) . append ( protect locat ) . append ( login page ) . append ( http 1 . 1 ) . append ( crlf ) ; request head . append ( host : localhost ) . append ( crlf ) ; request head . append ( connect : close ) . append ( crlf ) ; ( get us continu ( ) ) { request head . append ( expect : 100 continu ) . append ( crlf ) ; } ( session id = null ) { request head . append ( cooki : jsessionid = ) . append ( session id ) . append ( crlf ) ; } request head . append ( content type : applic x www form urlencod ) . append ( crlf ) ; request head . append ( content length : 35 ) . append ( crlf ) ; request head . append ( crlf ) ; string request = new string 2 ; request 0 = request head . string ( ) ; request 1 = j usernam = tomcat j password = tomcat ; do request ( request ) ; }	privat void do request ( string request ) throw except { set request ( request ) ; connect ( ) ; process request ( ) ; string new session id = get session id ( ) ; ( new session id = null ) { session id = new session id ; } disconnect ( ) ; request count ; }	privat void do resourc request ( string method ) throw except { string builder request head = new string builder ( 128 ) ; string request tail ; request head . append ( method ) . append ( ) . append ( protect locat ) . append ( protect page ) ; ( get . equal ( method ) ) { request head . append ( role = bar ) ; } request head . append ( http 1 . 1 ) . append ( crlf ) ; request head . append ( host : localhost ) . append ( crlf ) ; request head . append ( connect : close ) . append ( crlf ) ; ( get us continu ( ) ) { request head . append ( expect : 100 continu ) . append ( crlf ) ; } ( session id = null ) { request head . append ( cooki : jsessionid = ) . append ( session id ) . append ( crlf ) ; } ( post . equal ( method ) ) { request head . append ( content type : applic x www form urlencod ) . append ( crlf ) ; request head . append ( content length : 8 ) . append ( crlf ) ; request head . append ( crlf ) ; request tail = role = bar ; } els { request tail = crlf ; } string request = new string 2 ; request 0 = request head . string ( ) ; request 1 = request tail ; do request ( request ) ; }	privat void do test ( string resourc method , string redirect method , boolean us continu ) throw except { form auth client client = new form auth client ( ) ; first request authent resourc client . set us continu ( us continu ) ; client . do resourc request ( resourc method ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; second request login page client . set us continu ( us continu ) ; client . do login request ( ) ; assert true ( client . response302 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; third request follow redirect client . do resourc request ( redirect method ) ; ( post . equal ( redirect method ) ) { client . set us continu ( us continu ) ; } assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; subsequ request direct resourc ( int i = 0 ; i 5 ; i ) { client . set us continu ( us continu ) ; client . do resourc request ( resourc method ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; } }	overrid public boolean respons bodi ok ( ) { ( request count = = 1 ) { first request should result login page assert contain ( get respons bodi ( ) , titl login page exampl titl ) ; return true ; } els ( request count = = 2 ) { second request should result redirect return true ; } els { subsequ request should result protect page role paramet should have reach page string bodi = get respons bodi ( ) ; assert contain ( bodi , titl protect page exampl titl ) ; assert contain ( bodi , input type = text name = role valu = bar ) ; return true ; } }	public void test get ( ) throw except { do test ( get , get , fals ) ; }	test public void test post continu ( ) throw except { do test ( post , get , fals ) ; }	bug 49779 test public void test post continu post redirect ( ) throw except { do test ( post , post , fals ) ; }	test public void test post continu ( ) throw except { do test ( post , get , true ) ; }	bug 49779 test public void test post continu post redirect ( ) throw except { do test ( post , post , true ) ; }

public void test bug48692 ( ) { bug48692client client = new bug48692client ( ) ; make sure get work properli client . do request ( get , foo = bar , null , null , fals ) ; assert true ( non 200 respons get request , client . response200 ( ) ) ; assert equal ( incorrect respons get request , foo = bar , client . get respons bodi ( ) ) ; client . reset ( ) ; make sure post work properli post separ get post paramet client . do request ( post , foo = bar , applic x www form urlencod , bar = baz , true ) ; assert true ( non 200 respons post request , client . response200 ( ) ) ; assert equal ( incorrect respons post request , bar = baz , foo = bar , client . get respons bodi ( ) ) ; client . reset ( ) ; post overlap get post paramet client . do request ( post , foo = bar bar = foo , applic x www form urlencod , bar = baz foo = baz , true ) ; assert true ( non 200 respons post request , client . response200 ( ) ) ; assert equal ( incorrect respons post request , bar = baz , bar = foo , foo = bar , foo = baz , client . get respons bodi ( ) ) ; client . reset ( ) ; put without post style pars client . do request ( put , foo = bar bar = foo , applic x www form urlencod , bar = baz foo = baz , fals ) ; assert true ( non 200 respons put nopars request , client . response200 ( ) ) ; assert equal ( incorrect respons put request , bar = foo , foo = bar , client . get respons bodi ( ) ) ; client . reset ( ) ; put post style pars client . do request ( put , foo = bar bar = foo , applic x www form urlencod , bar = baz foo = baz , true ) ; assert true ( non 200 respons put request , client . response200 ( ) ) ; assert equal ( incorrect respons put pars request , bar = baz , bar = foo , foo = bar , foo = baz , client . get respons bodi ( ) ) ; client . reset ( ) ; privat except do request ( string method , string queri string , string content type , string request bodi , boolean allow bodi ) { }	http urlconnect get connect ( ) throw ioexcept { final string queri = http : localhost : get port ( ) ; url post url ; post url = new url ( queri ) ; http urlconnect conn = ( http urlconnect ) post url . open connect ( ) ; conn . set request method ( post ) ; conn . set do input ( true ) ; conn . set do output ( true ) ; conn . set us cach ( fals ) ; conn . set allow user interact ( fals ) ; return conn ; }	privat void pars part ( ) { return immedi part have alreadi been pars ( part = null part pars except = null ) { return ; } multipart config element mce = get wrapper ( ) . get multipart config element ( ) ; ( mce = = null ) { ( get context ( ) . get allow casual multipart pars ( ) ) { mce = new multipart config element ( null , connector . get max post size ( ) , connector . get max post size ( ) , connector . get max post size ( ) ) ; } els { part = collect . empti list ( ) ; return ; } } paramet paramet = coyot request . get paramet ( ) ; paramet . set limit ( get connector ( ) . get max paramet count ( ) ) ; boolean success = fals ; try { file locat ; string locat str = mce . get locat ( ) ; ( locat str = = null locat str . length ( ) = = 0 ) { locat = ( ( file ) context . get servlet context ( ) . get attribut ( servlet context . tempdir ) ) ; } els { rel , rel tempdir locat = new file ( locat str ) ; ( locat . absolut ( ) ) { locat = new file ( ( file ) context . get servlet context ( ) . get attribut ( servlet context . tempdir ) , locat str ) . get absolut file ( ) ; } } ( locat . directori ( ) ) { part pars except = new ioexcept ( sm . get string ( coyot request . upload locat invalid , locat ) ) ; return ; } creat new file upload handler disk file item factori factori = new disk file item factori ( ) ; try { factori . set repositori ( locat . get canon file ( ) ) ; } catch ( ioexcept ioe ) { part pars except = ioe ; return ; } factori . set size threshold ( mce . get file size threshold ( ) ) ; servlet file upload upload = new servlet file upload ( ) ; upload . set file item factori ( factori ) ; upload . set file size max ( mce . get max file size ( ) ) ; upload . set size max ( mce . get max request size ( ) ) ; part = new arrai list ( ) ; try { list file item item = upload . pars request ( new servlet request context ( thi ) ) ; int max post size = get connector ( ) . get max post size ( ) ; int post size = 0 ; string enc = get charact encod ( ) ; charset charset = null ; ( enc = null ) { try { charset = b2cconvert . get charset ( enc ) ; } catch ( unsupport encod except e ) { ignor } } ( file item item : item ) { applic part part = new applic part ( item , mce ) ; part . add ( part ) ; ( part . get submit file name ( ) = = null ) { string name = part . get name ( ) ; string valu = null ; try { string encod = paramet . get encod ( ) ; ( encod = = null ) { encod = paramet . default encod ; } valu = part . get string ( encod ) ; } catch ( unsupport encod except uee ) { try { valu = part . get string ( paramet . default encod ) ; } catch ( unsupport encod except e ) { should possibl } } ( max post size 0 ) { accur close enough . ( charset = = null ) { name length post size = name . get byte ( ) . length ; } els { post size = name . get byte ( charset ) . length ; } ( valu = null ) { equal sign post size ; valu length post size = part . get size ( ) ; } valu separ post size ; ( post size max post size ) { throw new illeg state except ( sm . get string ( coyot request . max post size exceed ) ) ; } } paramet . add paramet ( name , valu ) ; } } success = true ; } catch ( invalid content type except e ) { part pars except = new servlet except ( e ) ; } catch ( file upload base . size except e ) { check swallow input ( ) ; part pars except = new illeg state except ( e ) ; } catch ( file upload except e ) { part pars except = new ioexcept ( e ) ; } catch ( illeg state except e ) { check swallow input ( ) ; part pars except = e ; } } final { ( part pars except = null success ) { paramet . set pars fail ( true ) ; } } }	test case http : issu . apach . org bugzilla show bug . cgi id = 48692 put request should abl fetch request paramet come from request bodi ( when properli configur us new pars bodi method set ) . test public void test bug48692 ( ) { bug48692client client = new bug48692client ( ) ; make sure get work properli client . do request ( get , foo = bar , null , null , fals ) ; assert true ( non 200 respons get request , client . response200 ( ) ) ; assert equal ( incorrect respons get request , foo = bar , client . get respons bodi ( ) ) ; client . reset ( ) ; make sure post work properli post separ get post paramet client . do request ( post , foo = bar , applic x www form urlencod , bar = baz , true ) ; assert true ( non 200 respons post request , client . response200 ( ) ) ; assert equal ( incorrect respons post request , bar = baz , foo = bar , client . get respons bodi ( ) ) ; client . reset ( ) ; post overlap get post paramet client . do request ( post , foo = bar bar = foo , applic x www form urlencod , bar = baz foo = baz , true ) ; assert true ( non 200 respons post request , client . response200 ( ) ) ; assert equal ( incorrect respons post request , bar = baz , bar = foo , foo = bar , foo = baz , client . get respons bodi ( ) ) ; client . reset ( ) ; put without post style pars client . do request ( put , foo = bar bar = foo , applic x www form urlencod , bar = baz foo = baz , fals ) ; assert true ( non 200 respons put nopars request , client . response200 ( ) ) ; assert equal ( incorrect respons put request , bar = foo , foo = bar , client . get respons bodi ( ) ) ; client . reset ( ) ; put post style pars client . do request ( put , foo = bar bar = foo , applic x www form urlencod , bar = baz foo = baz , true ) ; assert true ( non 200 respons put request , client . response200 ( ) ) ; assert equal ( incorrect respons put pars request , bar = baz , bar = foo , foo = bar , foo = baz , client . get respons bodi ( ) ) ; client . reset ( ) ; privat except do request ( string method , string queri string , string content type , string request bodi , boolean allow bodi ) { }	test public void test bug49424no chunk ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; context root = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; tomcat . add servlet ( root , bug37794 , new bug37794servlet ( ) ) ; root . add servlet map ( , bug37794 ) ; tomcat . start ( ) ; http urlconnect conn = get connect ( ) ; input stream = conn . get input stream ( ) ; assert null ( ) ; }	test public void test bug49424with chunk ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; context root = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; tomcat . add servlet ( root , bug37794 , new bug37794servlet ( ) ) ; root . add servlet map ( , bug37794 ) ; tomcat . start ( ) ; http urlconnect conn = get connect ( ) ; conn . set chunk stream mode ( 8 1024 ) ; input stream = conn . get input stream ( ) ; assert null ( ) ; }
privat void do test uri decod ( string path , string encod , string expect path info ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; tomcat . get connector ( ) . set uriencod ( encod ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; path info servlet servlet = new path info servlet ( ) ; tomcat . add servlet ( ctx , servlet , servlet ) ; ctx . add servlet map ( , servlet ) ; tomcat . start ( ) ; int rc = get url ( http : localhost : get port ( ) path , new byte chunk ( ) , null ) ; assert . assert equal ( http servlet respons . sc ok , rc ) ; assert . assert equal ( expect path info , servlet . get path info ( ) ) ; }
protect void remov wrapper ( context version context , string path ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( mapper . remov wrapper , context . name , path ) ) ; } synchron ( context ) { ( path . end ( ) ) { wildcard wrapper string name = path . substr ( 0 , path . length ( ) 2 ) ; map wrapper old wrapper = context . wildcard wrapper ; ( old wrapper . length = = 0 ) { return ; } map wrapper new wrapper = new map wrapper old wrapper . length 1 ; ( remov map ( old wrapper , new wrapper , name ) ) { recalcul nest context . nest = 0 ; ( int i = 0 ; i new wrapper . length ; i ) { int slash count = slash count ( new wrapper i . name ) ; ( slash count context . nest ) { context . nest = slash count ; } } context . wildcard wrapper = new wrapper ; } } els ( path . start ( . ) ) { extens wrapper string name = path . substr ( 2 ) ; map wrapper old wrapper = context . extens wrapper ; ( old wrapper . length = = 0 ) { return ; } map wrapper new wrapper = new map wrapper old wrapper . length 1 ; ( remov map ( old wrapper , new wrapper , name ) ) { context . extens wrapper = new wrapper ; } } els ( path . equal ( ) ) { default wrapper context . default wrapper = null ; } els { exact wrapper string name = path ; map wrapper old wrapper = context . exact wrapper ; ( old wrapper . length = = 0 ) { return ; } map wrapper new wrapper = new map wrapper old wrapper . length 1 ; ( remov map ( old wrapper , new wrapper , name ) ) { context . exact wrapper = new wrapper ; } } } }
overrid public map string , extend servlet registr get servlet registr ( ) { map string , applic servlet registr result = new hash map ( ) ; contain wrapper = context . find children ( ) ; ( contain wrapper : wrapper ) { result . put ( ( ( wrapper ) wrapper ) . get name ( ) , new applic servlet registr ( ( wrapper ) wrapper , context ) ) ; } return result ; }	test ( expect = illeg argument except . class ) public void test add servlet servlet name empti string ( ) { get servlet context ( ) . add servlet ( , ( servlet ) null ) ; }
overrid public void set comment ( string comment ) { thi . comment = comment ; }	overrid public void set domain ( string domain ) { thi . domain = domain ; }	overrid public void set http onli ( boolean http onli ) { thi . http onli = http onli ; }	overrid public void set max ag ( int max ag ) { thi . max ag = max ag ; }	overrid public void set name ( string name ) { thi . name = name ; }	overrid public void set path ( string path ) { thi . path = path ; }	overrid public void set secur ( boolean secur ) { thi . secur = secur ; }
privat static skip constant result skip constant ( string reader input , string constant ) throw ioexcept { int len = constant . length ( ) ; int c = input . read ( ) ; skip lw while ( c = = 32 c = = 9 ) { c = input . read ( ) ; } ( int i = 0 ; i len ; i ) { ( i = = 0 c = = 1 ) { return skip constant result . eof ; } ( c = constant . char ( i ) ) { input . skip ( ( i 1 ) ) ; return skip constant result . found ; } ( i = ( len 1 ) ) { c = input . read ( ) ; } } return skip constant result . found ; }	privat static lhex can read unambigu without surround quot so thi pars method lhex permit option surround doubl quot . some buggi client ( libwww perl digest auth ) ar known send quot lhex when specif requir just lhex . p lhex ar , liter , lower case hexadecim digit . thi implement allow upper case digit well , convert return valu lower case . return sequenc lhex ( minu ani surround quot ) ani wa found , code null code data other lhex wa found string read lhex ( string reader input ) throw ioexcept { string builder result = new string builder ( ) ; boolean quot = fals ; int c = input . read ( ) ; skip lw while ( c = = 32 c = = 9 ) { c = input . read ( ) ; } ( c = = ) { quot = true ; } els ( c = = 1 hex ( c ) ) { return null ; } els { ( = c c = f ) { c = ( ) ; } result . append ( ( char ) c ) ; } c = input . read ( ) ; while ( c = 1 hex ( c ) ) { ( = c c = f ) { c = ( ) ; } result . append ( ( char ) c ) ; c = input . read ( ) ; } ( quot ) { ( c = ) { return null ; } } els { skip back so non hex charact avail next read input . skip ( 1 ) ; } ( c = 1 result . length ( ) = = 0 ) { return null ; } els { return result . string ( ) ; } }	privat static return quot string wa found , null data other than quot string wa found null end data wa reach befor quot string wa termin string read quot string ( string reader input , boolean return quot ) throw ioexcept { int c = input . read ( ) ; skip lw while ( c = = 32 c = = 9 ) { c = input . read ( ) ; } ( c = ) { return null ; } string builder result = new string builder ( ) ; ( return quot ) { result . append ( ) ; } c = input . read ( ) ; while ( c = ) { ( c = = 1 ) { return null ; } els ( c = = ) { c = input . read ( ) ; ( return quot ) { result . append ( ) ; } result . append ( c ) ; } els { result . append ( ( char ) c ) ; } c = input . read ( ) ; } ( return quot ) { result . append ( ) ; } return result . string ( ) ; }	privat static token can read unambigu without surround quot so thi pars method token permit option surround doubl quot . thi defin ani rfc . special case handl data from buggi client ( known buggi client digest auth includ microsoft ie 8 amp ; 9 , appl safari osx i os ) add quot valu should token . return token wa found , null data other than token quot token wa found null end data wa reach befor quot token wa termin string read quot token ( string reader input ) throw ioexcept { string builder result = new string builder ( ) ; boolean quot = fals ; int c = input . read ( ) ; skip lw while ( c = = 32 c = = 9 ) { c = input . read ( ) ; } ( c = = ) { quot = true ; } els ( c = = 1 token ( c ) ) { return null ; } els { result . append ( ( char ) c ) ; } c = input . read ( ) ; while ( c = 1 token ( c ) ) { result . append ( ( char ) c ) ; c = input . read ( ) ; } ( quot ) { ( c = ) { return null ; } } els { skip back so non token charact avail next read input . skip ( 1 ) ; } ( c = 1 result . length ( ) = = 0 ) { return null ; } els { return result . string ( ) ; } }	privat static return token wa found , empti string data wa avail read code null code data other than token wa found string read token ( string reader input ) throw ioexcept { string builder result = new string builder ( ) ; int c = input . read ( ) ; skip lw while ( c = = 32 c = = 9 ) { c = input . read ( ) ; } while ( c = 1 token ( c ) ) { result . append ( ( char ) c ) ; c = input . read ( ) ; } skip back so non token charact avail next read input . skip ( 1 ) ; ( c = 1 result . length ( ) = = 0 ) { return null ; } els { return result . string ( ) ; } }	privat static string read token quot string ( string reader input , boolean return quot ) throw ioexcept { us mark reset skip ( 1 ) fail when read last charact input input . mark ( 1 ) ; int c = input . read ( ) ; go back so first charact avail read again input . reset ( ) ; ( c = = ) { return read quot string ( input , return quot ) ; } els { return read token ( input ) ; } }	privat static boolean hex ( int c ) { fast correct valu , slower incorrect try { return hex c ; } catch ( arrai index out bound except ex ) { return fals ; } }	privat void do test ( paramet . . . paramet ) throw ioexcept { string builder sb = new string builder ( ) ; sb . append ( type ) ; ( paramet p : paramet ) { sb . append ( p . string ( ) ) ; } string reader sr = new string reader ( sb . string ( ) ) ; media type m = http parser . pars media type ( sr ) ; check all expect paramet ar present assert true ( m . get paramet count ( ) = = paramet . length ) ; check type assert equal ( type . trim ( ) , m . get type ( ) ) ; assert equal ( subtyp . trim ( ) , m . get subtyp ( ) ) ; check paramet ( int i = 0 ; i paramet . length ; i ) { assert equal ( paramet i . get valu ( ) . trim ( ) , m . get paramet valu ( paramet i . get name ( ) . trim ( ) ) ) ; } }	overrid public string string ( ) { string builder sb = new string builder ( ) ; sb . append ( ; ) ; sb . append ( name ) ; sb . append ( = ) ; sb . append ( valu ) ; return sb . string ( ) ; }
thread get thread ( ) { get current thread group thread group tg = thread . current thread ( ) . get thread group ( ) ; find root thread group while ( tg . get parent ( ) = null ) { tg = tg . get parent ( ) ; } int thread count guess = tg . activ count ( ) 50 ; thread thread = new thread thread count guess ; int thread count actual = tg . enumer ( thread ) ; make sure we don t miss ani thread while ( thread count actual = = thread count guess ) { thread count guess = 2 ; thread = new thread thread count guess ; note tg . enumer ( thread ) silent ignor ani thread can t fit arrai thread count actual = tg . enumer ( thread ) ; } return thread ; }
overrid public void do filter ( servlet request request , servlet respons respons , filter chain chain ) throw ioexcept , servlet except { thi filter onli need handl web socket upgrad request ( ( request instanceof http servlet request ) ( respons instanceof http servlet respons ) header contain token ( ( http servlet request ) request , constant . upgrad header name , constant . upgrad header valu ) ) { http request includ valid upgrad request web socket chain . do filter ( request , respons ) ; return ; } http request upgrad header web socket present valid rest header reject request valid fail http servlet request req = ( http servlet request ) request ; http servlet respons resp = ( http servlet respons ) respons ; string kei ; string sub protocol = null ; list extens extens = collect . empti list ( ) ; ( header contain token ( req , constant . connect header name , constant . connect header valu ) ) { resp . send error ( http servlet respons . sc bad request ) ; return ; } ( header contain token ( req , constant . ws version header name , constant . ws version header valu ) ) { resp . set statu ( 426 ) ; resp . set header ( constant . ws version header name , constant . ws version header valu ) ; return ; } kei = req . get header ( constant . ws kei header name ) ; ( kei = = null ) { resp . send error ( http servlet respons . sc bad request ) ; return ; } need endpoint instanc progress thi further ws server contain sc = ws server contain . get server contain ( ) ; string path ; string path info = req . get path info ( ) ; ( path info = = null ) { path = req . get servlet path ( ) ; } els { path = req . get servlet path ( ) path info ; } ws map result map result = sc . find map ( path ) ; ( map result = = null ) { endpoint regist request path . let applic handl ( might redirect forward exampl ) chain . do filter ( request , respons ) ; return ; } server endpoint config sec = map result . get config ( ) ; origin check string origin = req . get header ( origin ) ; ( sec . get configur ( ) . check origin ( origin ) ) { resp . send error ( http servlet respons . sc forbidden ) ; return ; } sub protocol list string sub protocol = get token from header ( req , sec web socket protocol ) ; ( sub protocol . empti ( ) ) { sub protocol = sec . get configur ( ) . get negoti subprotocol ( sec . get subprotocol ( ) , sub protocol ) ; } extens current extens ar support thi implement we got thi far , all good . accept connect . resp . set header ( constant . upgrad header name , constant . upgrad header valu ) ; resp . set header ( constant . connect header name , constant . connect header valu ) ; resp . set header ( handshak respons . sec websocket accept , get web socket accept ( kei ) ) ; ( sub protocol = null ) { resp . set header ( sec web socket protocol , sub protocol ) ; } ( extens . empti ( ) ) { string builder sb = new string builder ( ) ; iter extens iter = extens . iter ( ) ; must least sb . append ( iter . next ( ) ) ; while ( iter . ha next ( ) ) { sb . append ( , ) ; sb . append ( iter . next ( ) . get name ( ) ) ; } resp . set header ( sec web socket extens , sb . string ( ) ) ; } endpoint ep ; try { class clazz = sec . get endpoint class ( ) ; ( endpoint . class . assign from ( clazz ) ) { ep = ( endpoint ) sec . get configur ( ) . get endpoint instanc ( clazz ) ; } els { ep = new pojo endpoint server ( ) ; } } catch ( instanti except e ) { throw new servlet except ( e ) ; } ws handshak request ws request = new ws handshak request ( req ) ; ws handshak respons ws respons = new ws handshak respons ( ) ; sec . get configur ( ) . modifi handshak ( sec , ws request , ws respons ) ; ws request . finish ( ) ; add ani addit header ( entri string , list string >> entri : ws respons . get header ( ) . entri set ( ) ) { ( string header valu : entri . get valu ( ) ) { resp . add header ( entri . get kei ( ) , header valu ) ; } } ws http upgrad handler ws handler = req . upgrad ( ws http upgrad handler . class ) ; ws handler . pre init ( ep , sec , sc , ws request , sub protocol , map result . get path param ( ) , req . secur ( ) ) ; }
privat gener code collect pseudo code : void do collect ( tag plugin context ctxt ) { ctxt . gener import ( java . util . ) ; gener iter ( ctxt ) ; string item v = ctxt . get temporari variabl name ( ) ; ctxt . gener java sourc ( object item v = ) ; ctxt . gener attribut ( item ) ; ctxt . gener java sourc ( ; ) ; string index v = null , begin v = null , end v = null , step v = null ; ( ha begin ) { begin v = ctxt . get temporari variabl name ( ) ; ctxt . gener java sourc ( int begin v = ) ; ctxt . gener attribut ( begin ) ; ctxt . gener java sourc ( ; ) ; } ( ha end ) { index v = ctxt . get temporari variabl name ( ) ; ctxt . gener java sourc ( int index v = 0 ; ) ; end v = ctxt . get temporari variabl name ( ) ; ctxt . gener java sourc ( int end v = ) ; ctxt . gener attribut ( end ) ; ctxt . gener java sourc ( ; ) ; } ( ha step ) { step v = ctxt . get temporari variabl name ( ) ; ctxt . gener java sourc ( int step v = ) ; ctxt . gener attribut ( step ) ; ctxt . gener java sourc ( ; ) ; } string iter v = ctxt . get temporari variabl name ( ) ; ctxt . gener java sourc ( iter iter v = null ; ) ; object ctxt . gener java sourc ( ( item v instanceof object ) ) ; ctxt . gener java sourc ( iter v = iter ( ( object ) item v ) ; ) ; boolean ctxt . gener java sourc ( els ( item v instanceof boolean ) ) ; ctxt . gener java sourc ( iter v = iter ( ( boolean ) item v ) ; ) ; byte ctxt . gener java sourc ( els ( item v instanceof byte ) ) ; ctxt . gener java sourc ( iter v = iter ( ( byte ) item v ) ; ) ; char ctxt . gener java sourc ( els ( item v instanceof char ) ) ; ctxt . gener java sourc ( iter v = iter ( ( char ) item v ) ; ) ; short ctxt . gener java sourc ( els ( item v instanceof short ) ) ; ctxt . gener java sourc ( iter v = iter ( ( short ) item v ) ; ) ; int ctxt . gener java sourc ( els ( item v instanceof int ) ) ; ctxt . gener java sourc ( iter v = iter ( ( int ) item v ) ; ) ; long ctxt . gener java sourc ( els ( item v instanceof long ) ) ; ctxt . gener java sourc ( iter v = iter ( ( long ) item v ) ; ) ; float ctxt . gener java sourc ( els ( item v instanceof float ) ) ; ctxt . gener java sourc ( iter v = iter ( ( float ) item v ) ; ) ; doubl ctxt . gener java sourc ( els ( item v instanceof doubl ) ) ; ctxt . gener java sourc ( iter v = iter ( ( doubl ) item v ) ; ) ; collect ctxt . gener java sourc ( els ( item v instanceof collect ) ) ; ctxt . gener java sourc ( iter v = ( ( collect ) item v ) . iter ( ) ; ) ; iter ctxt . gener java sourc ( els ( item v instanceof iter ) ) ; ctxt . gener java sourc ( iter v = ( iter ) item v ; ) ; enumer ctxt . gener java sourc ( els ( item v instanceof enumer ) ) ; ctxt . gener java sourc ( iter v = iter ( ( enumer ) item v ) ; ) ; map ctxt . gener java sourc ( els ( item v instanceof map ) ) ; ctxt . gener java sourc ( iter v = ( ( map ) item v ) . entri set ( ) . iter ( ) ; ) ; null ctxt . gener java sourc ( ( iter v = null ) { ) ; ( ha begin ) { string t v = ctxt . get temporari variabl name ( ) ; ctxt . gener java sourc ( ( int t v = begin v ; t v 0 iter v . ha next ( ) ; t v ) ) ; ctxt . gener java sourc ( iter v . next ( ) ; ) ; } ctxt . gener java sourc ( while ( iter v . ha next ( ) ) { ) ; ( ha var ) { ctxt . gener java sourc ( jspx page context . set attribut ( ) ; ctxt . gener attribut ( var ) ; ctxt . gener java sourc ( , iter v . next ( ) ) ; ) ; } ctxt . gener bodi ( ) ; ( ha step ) { string t v = ctxt . get temporari variabl name ( ) ; ctxt . gener java sourc ( ( int t v = step v 1 ; t v 0 iter v . ha next ( ) ; t v ) ) ; ctxt . gener java sourc ( iter v . next ( ) ; ) ; } ( ha end ) { ( ha step ) { ctxt . gener java sourc ( index v = step v ; ) ; } els { ctxt . gener java sourc ( index v ; ) ; } ( ha begin ) { ctxt . gener java sourc ( ( begin v index v end v ) ) ; } els { ctxt . gener java sourc ( ( index v end v ) ) ; } ctxt . gener java sourc ( break ; ) ; } while ctxt . gener java sourc ( } ) ; null ctxt . gener java sourc ( } ) ; }	public void test bug54242 ( ) throw except { byte chunk re = new byte chunk ( ) ; int rc = get url ( http : localhost : get port ( ) test bug5nnnn bug54242 . jsp , re , null ) ; assert . assert equal ( http servlet respons . sc ok , rc ) ; string bodi = re . string ( ) ; assert . assert true ( bodi . contain ( ok 1 ) ) ; assert . assert true ( bodi . contain ( ok 2 ) ) ; assert . assert fals ( bodi . contain ( fail ) ) ; }
privat void process char ( ) throw saxexcept { ( char buffer = = null direct onli ) { return ; } jsp . 6 . 1 . 1 : all textual node have onli white space ar drop from document , except node jsp : text element , ani lead trail white space onli textual node jsp : attribut whose trim attribut set fals , which ar kept verbatim . jsp . 6 . 2 . 3 defin white space charact . boolean all space = true ; ( ( current instanceof node . jsp text ) ( current instanceof node . name attribut ) ) { ( int i = 0 ; i char buffer . length ( ) ; i ) { char ch = char buffer . char ( i ) ; ( ( ch = = ch = = n ch = = r ch = = t ) ) { all space = fals ; break ; } } } ( all space tag depend pend ) { tag depend pend = fals ; tag depend nest ; } ( tag depend nest 0 ) { ( char buffer . length ( ) 0 ) { suppress warn ( unus ) node unus = new node . templat text ( char buffer . string ( ) , start mark , current ) ; } start mark = new mark ( ctxt , path , locat . get line number ( ) , locat . get column number ( ) ) ; char buffer = null ; return ; } ( ( current instanceof node . jsp text ) ( current instanceof node . name attribut ) all space ) { int line = start mark . get line number ( ) ; int column = start mark . get column number ( ) ; char arrai writer ttext = new char arrai writer ( ) ; int last ch = 0 , el type = 0 ; ( int i = 0 ; i char buffer . length ( ) ; i ) { int ch = char buffer . char ( i ) ; ( ch = = n ) { column = 1 ; line ; } els { column ; } ( ( last ch = = last ch = = ) ch = = { ) { el type = last ch ; ( ttext . size ( ) 0 ) { suppress warn ( unus ) node unus = new node . templat text ( ttext . string ( ) , start mark , current ) ; ttext . reset ( ) ; we subtract two from column number account , { we ve alreadi pars start mark = new mark ( ctxt , path , line , column 2 ) ; } follow { { first unquot } i ; boolean singl q = fals ; boolean doubl q = fals ; last ch = 0 ; ( ; ; i ) { ( i = char buffer . length ( ) ) { throw new saxpars except ( local . get messag ( jsp . error . untermin , ( char ) el type { ) , locat ) ; } ch = char buffer . char ( i ) ; ( ch = = n ) { column = 1 ; line ; } els { column ; } ( last ch = = ( singl q doubl q ) ) { ttext . write ( ch ) ; last ch = 0 ; continu ; } ( ch = = } ) { suppress warn ( unus ) node unus = new node . elexpress ( ( char ) el type , ttext . string ( ) , start mark , current ) ; ttext . reset ( ) ; start mark = new mark ( ctxt , path , line , column ) ; break ; } ( ch = = ) doubl q = doubl q ; } } } } }	public void test bug47977 ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; file app dir = new file ( test webapp 3 . 0 ) ; app dir rel server home tomcat . add webapp ( null , test , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; int rc = get url ( http : localhost : get port ( ) test bug47977 . jspx , new byte chunk ( ) , null ) ; assert equal ( http servlet respons . sc intern server error , rc ) ; }	test public void test bug48827 ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; file app dir = new file ( test webapp 3 . 0 ) ; app dir rel server home tomcat . add webapp ( null , test , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; except e = null ; try { get url ( http : localhost : get port ( ) test bug48nnn bug48827 . jspx ) ; } catch ( ioexcept ioe ) { e = ioe ; } should fail assert null ( e ) ; }
privat void do test timeout error dispatch ( boolean async error , error page async mode mode ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; timeout servlet timeout = new timeout servlet ( null , null ) ; wrapper w1 = tomcat . add servlet ( ctx , time , timeout ) ; w1 . set async support ( true ) ; ctx . add servlet map ( async , time ) ; non async servlet non async = new non async servlet ( ) ; wrapper w2 = tomcat . add servlet ( ctx , non async , non async ) ; w2 . set async support ( true ) ; ctx . add servlet map ( error nonasync , non async ) ; async error page async error page = new async error page ( mode ) ; wrapper w3 = tomcat . add servlet ( ctx , async error page , async error page ) ; w3 . set async support ( true ) ; ctx . add servlet map ( error async , async error page ) ; ( async error = null ) { error page ep = new error page ( ) ; ep . set error code ( 500 ) ; ( async error . boolean valu ( ) ) { ep . set locat ( error async ) ; } els { ep . set locat ( error nonasync ) ; } ctx . add error page ( ep ) ; } ctx . add applic listen ( track request listen . class . get name ( ) ) ; tester access log valv alv = new tester access log valv ( ) ; ctx . get pipelin ( ) . add valv ( alv ) ; tester access log valv alv global = new tester access log valv ( ) ; tomcat . get host ( ) . get pipelin ( ) . add valv ( alv global ) ; tomcat . start ( ) ; byte chunk re = new byte chunk ( ) ; try { get url ( http : localhost : get port ( ) async , re , null ) ; } catch ( ioexcept ioe ) { ignor expect some error condit } string builder expect = new string builder ( ) ; ( async error = = null ) { error handler just get 500 respons expect . append ( request initi timeout servlet get ) ; note : error handler respons reset lost } ( async error = null ) { ( async error . boolean valu ( ) ) { expect . append ( async error page get ) ; ( mode = = error page async mode . complet ) { expect . append ( op ) ; } els ( mode = = error page async mode . complet ) { expect . append ( complet ) ; } els ( mode = = error page async mode . dispatch ) { expect . append ( dispatch non async servlet get ) ; } } els { expect . append ( non async servlet get ) ; } } expect . append ( request destroi ) ; assert . assert equal ( expect . string ( ) , re . string ( ) ) ; check access log alv global . valid access log ( 1 , 500 , timeout servlet . async timeout , timeout servlet . async timeout timeout margin request time ) ; alv . valid access log ( 1 , 500 , timeout servlet . async timeout , timeout servlet . async timeout timeout margin request time ) ; }	public boolean timeout ( ) { atom boolean result = new atom boolean ( ) ; request . get coyot request ( ) . action ( action code . async timeout , result ) ; ( result . get ( ) ) { class loader old cl = thread . current thread ( ) . get context class loader ( ) ; class loader new cl = request . get context ( ) . get loader ( ) . get class loader ( ) ; try { thread . current thread ( ) . set context class loader ( new cl ) ; list async listen wrapper listen copi = new arrai list ( ) ; listen copi . add all ( listen ) ; ( async listen wrapper listen : listen copi ) { try { listen . fire timeout ( event ) ; } catch ( ioexcept ioe ) { log . warn ( timeout ( ) fail listen type listen . get class ( ) . get name ( ) , ioe ) ; } } request . get coyot request ( ) . action ( action code . async timingout , result ) ; return result . get ( ) ; } final { thread . current thread ( ) . set context class loader ( old cl ) ; } } return true ; }	overrid public void fire complet ( ) { list async listen wrapper listen copi = new arrai list ( ) ; listen copi . add all ( listen ) ; class loader old cl ; ( global . secur enabl ) { privileg action class loader pa = new privileg get tccl ( ) ; old cl = access control . do privileg ( pa ) ; } els { old cl = thread . current thread ( ) . get context class loader ( ) ; } class loader new cl = context . get loader ( ) . get class loader ( ) ; try { ( global . secur enabl ) { privileg action void pa = new privileg set tccl ( new cl ) ; access control . do privileg ( pa ) ; } els { thread . current thread ( ) . set context class loader ( new cl ) ; } ( async listen wrapper listen : listen copi ) { try { listen . fire complet ( event ) ; } catch ( ioexcept ioe ) { log . warn ( complet ( ) fail listen type listen . get class ( ) . get name ( ) , ioe ) ; } } } final { ( global . secur enabl ) { privileg action void pa = new privileg set tccl ( old cl ) ; access control . do privileg ( pa ) ; } els { thread . current thread ( ) . set context class loader ( old cl ) ; } } }	public void set error state ( throwabl t , boolean fire error ) { ( t = null ) request . set attribut ( request dispatch . error except , t ) ; request . get coyot request ( ) . action ( action code . async error , null ) ; ( fire error ) { async event error event = new async event ( event . get async context ( ) , event . get suppli request ( ) , event . get suppli respons ( ) , t ) ; list async listen wrapper listen copi = new arrai list ( ) ; listen copi . add all ( listen ) ; ( async listen wrapper listen : listen copi ) { try { listen . fire error ( error event ) ; } catch ( ioexcept ioe ) { log . warn ( error ( ) fail listen type listen . get class ( ) . get name ( ) , ioe ) ; } } } atom boolean result = new atom boolean ( ) ; request . get coyot request ( ) . action ( action code . async error , result ) ; ( result . get ( ) ) { srv . 2 . 3 . 3 . 3 ( search error dispatch ) ( servlet respons instanceof http servlet respons ) { ( ( http servlet respons ) servlet respons ) . set statu ( http servlet respons . sc intern server error ) ; } host host = ( host ) context . get parent ( ) ; valv std host valv = host . get pipelin ( ) . get basic ( ) ; ( std host valv instanceof standard host valv ) { ( ( standard host valv ) std host valv ) . throwabl ( request , request . get respons ( ) , t ) ; } request . get coyot request ( ) . action ( action code . async error , result ) ; ( result . get ( ) ) { still error state . error page did call complet ( ) dispatch ( ) . complet async process . complet ( ) ; } } }	public void set start ( context context , servlet request request , servlet respons respons , boolean origin request respons ) { thi . request . get coyot request ( ) . action ( action code . async start , thi ) ; thi . context = context ; thi . servlet request = request ; thi . servlet respons = respons ; thi . ha origin request respons = origin request respons ; thi . event = new async event ( thi , request , respons ) ; list async listen wrapper listen copi = new arrai list ( ) ; listen copi . add all ( listen ) ; ( async listen wrapper listen : listen copi ) { try { listen . fire start async ( event ) ; } catch ( ioexcept ioe ) { log . warn ( start async ( ) fail listen type listen . get class ( ) . get name ( ) , ioe ) ; } } listen . clear ( ) ; }	test public void test commit complet ( ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; async statu servlet async statu servlet = new async statu servlet ( http servlet respons . sc bad request ) ; wrapper wrapper = tomcat . add servlet ( ctx , async statu servlet , async statu servlet ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( async statu servlet , async statu servlet ) ; tester access log valv alv = new tester access log valv ( ) ; ctx . get pipelin ( ) . add valv ( alv ) ; tomcat . start ( ) ; string builder url = new string builder ( 48 ) ; url . append ( http : localhost : ) ; url . append ( get port ( ) ) ; url . append ( async statu servlet ) ; int rc = get url ( url . string ( ) , new byte chunk ( ) , null ) ; assert equal ( http servlet respons . sc bad request , rc ) ; without thi test mai complet befor access log ha chanc log request thread . sleep ( request time ) ; check access log alv . valid access log ( 1 , http servlet respons . sc bad request , 0 , request time ) ; }
privat set appropri context attribut our work directori . void post work directori ( ) { acquir ( calcul ) work directori path string work dir = get work dir ( ) ; ( work dir = = null work dir . length ( ) = = 0 ) { retriev our parent ( normal host ) name string host name = null ; string engin name = null ; string host work dir = null ; contain parent host = get parent ( ) ; ( parent host = null ) { host name = parent host . get name ( ) ; ( parent host instanceof standard host ) { host work dir = ( ( standard host ) parent host ) . get work dir ( ) ; } contain parent engin = parent host . get parent ( ) ; ( parent engin = null ) { engin name = parent engin . get name ( ) ; } } ( ( host name = = null ) ( host name . length ( ) 1 ) ) host name = ; ( ( engin name = = null ) ( engin name . length ( ) 1 ) ) engin name = ; string temp = get name ( ) ; ( temp . start ( ) ) temp = temp . substr ( 1 ) ; temp = temp . replac ( , ) ; temp = temp . replac ( , ) ; ( temp . length ( ) 1 ) temp = context name . root name ; ( host work dir = null ) { work dir = host work dir file . separ temp ; } els { work dir = work file . separ engin name file . separ host name file . separ temp ; } set work dir ( work dir ) ; } creat thi directori necessari file dir = new file ( work dir ) ; ( dir . absolut ( ) ) { string catalina home path = null ; try { catalina home path = get catalina base ( ) . get canon path ( ) ; dir = new file ( catalina home path , work dir ) ; } catch ( ioexcept e ) { log . warn ( sm . get string ( standard context . work creat except , work dir , catalina home path , get name ( ) ) , e ) ; } } ( dir . mkdir ( ) dir . directori ( ) ) { log . warn ( sm . get string ( standard context . work creat fail , dir , get name ( ) ) ) ; } set appropri servlet context attribut ( context = = null ) { get servlet context ( ) ; } context . set attribut ( servlet context . tempdir , dir ) ; context . set attribut read onli ( servlet context . tempdir ) ; }
public ws map result find map ( string path ) { check exact match . simpl case ar templat . server endpoint config sec = config exact match map . get ( path ) ; ( sec = null ) { return new ws map result ( sec , collect . empti map ) ; } exact match . need look templat match . uri templat path uri templat = new uri templat ( path ) ; number segment ha match integ kei = integ . valu ( path uri templat . get segment count ( ) ) ; sort set templat path match templat match = config templat match map . get ( kei ) ; list alphabet order normalis templat . correct match first match . map string , string path param = null ; ( templat path match templat match : templat match ) { path param = templat match . get uri templat ( ) . match ( path uri templat ) ; ( path param = null ) { sec = templat match . get config ( ) ; break ; } } ( sec = = null ) { match return null ; } ( pojo endpoint server . class . assign from ( sec . get endpoint class ( ) ) ) { need make path param avail pojo sec . get user properti ( ) . put ( pojo endpoint server . pojo path param kei , path param ) ; } return new ws map result ( sec , path param ) ; }	overrid public void do filter ( servlet request request , servlet respons respons , filter chain chain ) throw ioexcept , servlet except { thi filter onli need handl web socket upgrad request ( ( request instanceof http servlet request ) ( respons instanceof http servlet respons ) header contain token ( ( http servlet request ) request , constant . upgrad header name , constant . upgrad header valu ) ) { note http request includ valid upgrad request web socket chain . do filter ( request , respons ) ; return ; } http request upgrad header web socket present valid rest header reject request valid fail http servlet request req = ( http servlet request ) request ; http servlet respons resp = ( http servlet respons ) respons ; string kei ; string sub protocol = null ; list extens extens = collect . empti list ( ) ; ( header contain token ( req , constant . connect header name , constant . connect header valu ) ) { resp . send error ( http servlet respons . sc bad request ) ; return ; } ( header contain token ( req , constant . ws version header name , constant . ws version header valu ) ) { resp . set statu ( 426 ) ; resp . set header ( constant . ws version header name , constant . ws version header valu ) ; return ; } kei = req . get header ( constant . ws kei header name ) ; ( kei = = null ) { resp . send error ( http servlet respons . sc bad request ) ; return ; } need endpoint instanc progress thi further ws server contain sc = ws server contain . get server contain ( ) ; string path ; string path info = req . get path info ( ) ; ( path info = = null ) { path = req . get servlet path ( ) ; } els { path = req . get servlet path ( ) path info ; } ws map result map result = sc . find map ( path ) ; server endpoint config sec = map result . get config ( ) ; origin check string origin = req . get header ( origin ) ; ( sec . get configur ( ) . check origin ( origin ) ) { resp . send error ( http servlet respons . sc forbidden ) ; return ; } sub protocol list string sub protocol = get token from header ( req , sec web socket protocol ) ; ( sub protocol . empti ( ) ) { sub protocol = sec . get configur ( ) . get negoti subprotocol ( sec . get subprotocol ( ) , sub protocol ) ; } extens current extens ar support thi implement we got thi far , all good . accept connect . resp . set header ( constant . upgrad header name , constant . upgrad header valu ) ; resp . set header ( constant . connect header name , constant . connect header valu ) ; resp . set header ( handshak respons . sec websocket accept , get web socket accept ( kei ) ) ; ( sub protocol = null ) { resp . set header ( sec web socket protocol , sub protocol ) ; } ( extens . empti ( ) ) { string builder sb = new string builder ( ) ; iter extens iter = extens . iter ( ) ; must least sb . append ( iter . next ( ) ) ; while ( iter . ha next ( ) ) { sb . append ( , ) ; sb . append ( iter . next ( ) . get name ( ) ) ; } resp . set header ( sec web socket extens , sb . string ( ) ) ; } endpoint ep ; try { class clazz = sec . get endpoint class ( ) ; ( endpoint . class . assign from ( clazz ) ) { ep = ( endpoint ) sec . get configur ( ) . get endpoint instanc ( clazz ) ; } els { ep = new pojo endpoint server ( ) ; } } catch ( instanti except e ) { throw new servlet except ( e ) ; } ws handshak request ws request = new ws handshak request ( req ) ; ws handshak respons ws respons = new ws handshak respons ( ) ; sec . get configur ( ) . modifi handshak ( sec , ws request , ws respons ) ; ws request . finish ( ) ; add ani addit header ( entri string , list string >> entri : ws respons . get header ( ) . entri set ( ) ) { ( string header valu : entri . get valu ( ) ) { resp . add header ( entri . get kei ( ) , header valu ) ; } } ws http upgrad handler ws handler = req . upgrad ( ws http upgrad handler . class ) ; ws handler . pre init ( ep , sec , sc , ws request , sub protocol , map result . get path param ( ) , req . secur ( ) ) ; }	public void set servlet context ( servlet context servlet context ) { ( thi . servlet context = = servlet context ) { return ; } thi . servlet context = servlet context ; configur servlet context wide default string valu = servlet context . get init paramet ( constant . binari buffer size servlet context init param ) ; ( valu = null ) { set default max binari messag buffer size ( integ . pars int ( valu ) ) ; } valu = servlet context . get init paramet ( constant . text buffer size servlet context init param ) ; ( valu = null ) { set default max text messag buffer size ( integ . pars int ( valu ) ) ; } filter registr fr = servlet context . add filter ( ws filter . class . get name ( ) , ws filter . class ) ; fr . add map url pattern ( null , fals , ) ; }
close public void end ( ) { try { session . close ( ) ; } catch ( ioexcept e ) { todo auto gener catch block e . print stack trace ( ) ; } connect . remov ( thi ) ; string messag = string . format ( s s , nicknam , ha disconnect . ) ; broadcast ( messag ) ; }
privat sslengin creat sslengin ( map string , object user properti ) throw deploy except { try { creat ssl context sslcontext ssl context = sslcontext . get instanc ( tl ) ; trust store string ssl trust store valu = ( string ) user properti . get ( ssl truststor properti ) ; ( ssl trust store valu = null ) { string ssl trust store pwd valu = ( string ) user properti . get ( ssl truststor pwd properti ) ; ( ssl trust store pwd valu = = null ) { ssl trust store pwd valu = ssl truststor pwd default ; } file kei store file = new file ( ssl trust store valu ) ; kei store ks = kei store . get instanc ( jk ) ; try ( input stream = new file input stream ( kei store file ) ) { ks . load ( , ssl trust store pwd valu . char arrai ( ) ) ; } trust manag factori tmf = trust manag factori . get instanc ( trust manag factori . get default algorithm ( ) ) ; tmf . init ( ks ) ; ssl context . init ( null , tmf . get trust manag ( ) , null ) ; } els { ssl context . init ( null , null , null ) ; } sslengin engin = ssl context . creat sslengin ( ) ; string ssl protocol valu = ( string ) user properti . get ( ssl protocol properti ) ; ( ssl protocol valu = null ) { engin . set enabl protocol ( ssl protocol valu . split ( , ) ) ; } engin . set us client mode ( true ) ; return engin ; } catch ( except e ) { throw new deploy except ( todo , e ) ; } }	overrid public session connect server ( endpoint endpoint , client endpoint config client endpoint configur , uri path ) throw deploy except { boolean secur = fals ; string scheme = path . get scheme ( ) ; ( ( ws . equal ignor case ( scheme ) wss . equal ignor case ( scheme ) ) ) { throw new deploy except ( sm . get string ( ws web socket contain . path wrong scheme , scheme ) ) ; } string host = path . get host ( ) ; ( host = = null ) { throw new deploy except ( sm . get string ( ws web socket contain . path host ) ) ; } int port = path . get port ( ) ; map string , list string >> req header = creat request header ( host , port , client endpoint configur . get prefer subprotocol ( ) ) ; client endpoint configur . get configur ( ) . befor request ( req header ) ; byte buffer request = creat request ( path , req header ) ; socket address sa ; ( port = = 1 ) { ( ws . equal ignor case ( scheme ) ) { sa = new inet socket address ( host , 80 ) ; } els ( wss . equal ignor case ( scheme ) ) { sa = new inet socket address ( host , 443 ) ; secur = true ; } els { throw new deploy except ( sm . get string ( ws web socket contain . invalid scheme ) ) ; } } els { ( wss . equal ignor case ( scheme ) ) { secur = true ; } sa = new inet socket address ( host , port ) ; } asynchron socket channel socket channel ; try { socket channel = asynchron socket channel . open ( ) ; } catch ( ioexcept ioe ) { throw new deploy except ( todo , ioe ) ; } futur void f connect = socket channel . connect ( sa ) ; async channel wrapper channel ; ( secur ) { sslengin ssl engin = creat sslengin ( client endpoint configur . get user properti ( ) ) ; channel = new async channel wrapper secur ( socket channel , ssl engin ) ; } els { channel = new async channel wrapper non secur ( socket channel ) ; } byte buffer respons ; string sub protocol ; try { f connect . get ( ) ; futur void f handshak = channel . handshak ( ) ; f handshak . get ( ) ; int write = request . limit ( ) ; futur integ f write = channel . write ( request ) ; integ thi write = f write . get ( ) ; write = thi write . int valu ( ) ; while ( write 0 ) { f write = channel . write ( request ) ; thi write = f write . get ( ) ; write = thi write . int valu ( ) ; } same size ws frame input buffer respons = byte buffer . alloc ( max binari messag buffer size ) ; handshak respons handshak respons = process respons ( respons , channel ) ; client endpoint configur . get configur ( ) . after respons ( handshak respons ) ; sub protocol list string valu = handshak respons . get header ( ) . get ( constant . ws protocol header name ) ; ( valu = = null valu . size ( ) = = 0 ) { sub protocol = null ; } els ( valu . size ( ) = = 1 ) { sub protocol = valu . get ( 0 ) ; } els { throw new deploy except ( sm . get string ( sec web socket protocol ) ) ; } } catch ( execut except interrupt except sslexcept e ) { throw new deploy except ( sm . get string ( ws web socket contain . http request fail ) , e ) ; } switch web socket ws remot endpoint impl client ws remot endpoint client = new ws remot endpoint impl client ( channel ) ; ws session ws session = new ws session ( endpoint , ws remot endpoint client , thi , null , null , null , null , sub protocol , collect . empti map , fals , client endpoint configur . get encod ( ) , client endpoint configur . get user properti ( ) ) ; endpoint . open ( ws session , client endpoint configur ) ; regist session ( endpoint . get class ( ) , ws session ) ; object creation trigger input process suppress warn ( unus ) ws frame client ws frame client = new ws frame client ( respons , channel , ws session ) ; return ws session ; }	{ inherit doc } default valu 10 which mean session expir ar process everi 10 second . overrid public int get process period ( ) { return process period ; }
public uri templat get uri templat ( ) { return uri templat ; }	provid equival { link add endpoint ( server endpoint config ) } publish plain old java object ( pojo ) have been annot web socket endpoint . param pojo annot pojo overrid public void add endpoint ( class pojo ) throw deploy except { server endpoint annot = pojo . get annot ( server endpoint . class ) ; ( annot = = null ) { throw new deploy except ( sm . get string ( server contain . miss annot , pojo . get name ( ) ) ) ; } string path = annot . valu ( ) ; uri templat uri templat uri templat = new uri templat ( path ) ; method map pojo method map method map = new pojo method map ( pojo , annot . decod ( ) , path ) ; server endpoint config server endpoint config sec ; class extend configur configur clazz = annot . configur ( ) ; configur configur = null ; ( configur clazz . equal ( configur . class ) ) { try { configur = annot . configur ( ) . new instanc ( ) ; } catch ( instanti except illeg access except e ) { throw new illeg state except ( sm . get string ( server contain . configur fail , annot . configur ( ) . get name ( ) , pojo . get class ( ) . get name ( ) ) , e ) ; } } sec = server endpoint config . builder . creat ( pojo , path ) . decod ( arrai . list ( annot . decod ( ) ) ) . encod ( arrai . list ( annot . encod ( ) ) ) . configur ( configur ) . build ( ) ; sec . get user properti ( ) . put ( pojo endpoint server . pojo method map kei , method map ) ; ( uri templat . ha paramet ( ) ) { integ kei = integ . valu ( uri templat . get segment count ( ) ) ; sort set templat path match templat match = config templat match map . get ( kei ) ; ( templat match = = null ) { templat match = new tree set ( new templat path match compar ( ) ) ; config templat match map . put ( kei , templat match ) ; } templat match . add ( new templat path match ( sec , uri templat ) ) ; } els { exact match config exact match map . put ( path , sec ) ; } }	publish provid endpoint implement specifi path specifi configur . { link set servlet context ( servlet context ) } must call befor call thi method . param sec configur us when creat endpoint instanc throw deploy except overrid public void add endpoint ( server endpoint config sec ) throw deploy except { ( servlet context = = null ) { throw new deploy except ( sm . get string ( server contain . servlet context miss ) ) ; } string path = sec . get path ( ) ; uri templat uri templat = new uri templat ( path ) ; ( uri templat . ha paramet ( ) ) { integ kei = integ . valu ( uri templat . get segment count ( ) ) ; sort set templat path match templat match = config templat match map . get ( kei ) ; ( templat match = = null ) { templat match = new tree set ( ) ; config templat match map . put ( kei , templat match ) ; } templat match . add ( new templat path match ( sec , uri templat ) ) ; } els { exact match config exact match map . put ( path , sec ) ; } }
public void syn stream ( spdy stream str ) throw ioexcept { thi . spdy stream = str ; spdy frame frame = str . req frame ; we need make copi frame buffer reus . we us wrap method mime header which should lighter mem some case . request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage prepar ) ; request receiv . mime header mime header = request . get mime header ( ) ; set thi everi time case limit ha been chang via jmx mime header . set limit ( endpoint . get max header count ( ) ) ; ( int i = 0 ; i frame . nv count ; i ) { int name len = frame . read16 ( ) ; ( name len frame . remain ( ) ) { throw new ioexcept ( name too long ) ; } kei buffer . set byte ( frame . data , frame . off , name len ) ; ( kei buffer . equal ( method ) ) { frame . advanc ( name len ) ; int valu len = frame . read16 ( ) ; ( valu len frame . remain ( ) ) { throw new ioexcept ( name too long ) ; } request . method ( ) . set byte ( frame . data , frame . off , valu len ) ; frame . advanc ( valu len ) ; } els ( kei buffer . equal ( url ) ) { frame . advanc ( name len ) ; int valu len = frame . read16 ( ) ; ( valu len frame . remain ( ) ) { throw new ioexcept ( name too long ) ; } request . request uri ( ) . set byte ( frame . data , frame . off , valu len ) ; ( spdy context . debug ) { system . err . println ( url = request . request uri ( ) ) ; } frame . advanc ( valu len ) ; } els ( kei buffer . equal ( version ) ) { frame . advanc ( name len ) ; int valu len = frame . read16 ( ) ; ( valu len frame . remain ( ) ) { throw new ioexcept ( name too long ) ; } frame . advanc ( valu len ) ; } els { messag byte valu = mime header . add valu ( frame . data , frame . off , name len ) ; frame . advanc ( name len ) ; int valu len = frame . read16 ( ) ; ( valu len frame . remain ( ) ) { throw new ioexcept ( name too long ) ; } valu . set byte ( frame . data , frame . off , valu len ) ; frame . advanc ( valu len ) ; } } request ( ) ; }
overrid public void scan ( file file ) throw ioexcept { input stream stream = null ; web xml fragment = new web xml ( ) ; try { file fragment file = new file ( file , fragment locat ) ; ( fragment file . file ( ) ) { stream = new file input stream ( fragment file ) ; input sourc sourc = new input sourc ( fragment file . uri ( ) . url ( ) . string ( ) ) ; sourc . set byte stream ( stream ) ; pars web xml ( sourc , fragment , true ) ; } } final { fragment . set url ( file . uri ( ) . url ( ) ) ; ( fragment . get name ( ) = = null ) { fragment . set name ( fragment . get url ( ) . string ( ) ) ; } fragment . set jar name ( file . get name ( ) ) ; fragment . put ( fragment . get name ( ) , fragment ) ; } }
protect void do get ( http servlet request req , http servlet respons resp ) throw servlet except , ioexcept { inform requir send server handshak messag string kei ; string sub protocol = null ; list extens extens = collect . empti list ( ) ; ( header contain token ( req , constant . upgrad header name , constant . upgrad header valu ) ) { resp . send error ( http servlet respons . sc bad request ) ; return ; } ( header contain token ( req , constant . connect header name , constant . connect header valu ) ) { resp . send error ( http servlet respons . sc bad request ) ; return ; } ( header contain token ( req , constant . ws version header name , constant . ws version header valu ) ) { resp . set statu ( 426 ) ; resp . set header ( constant . ws version header name , constant . ws version header valu ) ; return ; } kei = req . get header ( constant . ws kei header name ) ; ( kei = = null ) { resp . send error ( http servlet respons . sc bad request ) ; return ; } need endpoint instanc progress thi further ws server contain sc = ws server contain . get server contain ( ) ; map string , string path paramet = sc . get path paramet ( req . get servlet path ( ) , req . get path info ( ) ) ; server endpoint config sec = sc . get server endpoint configur ( req . get servlet path ( ) , path paramet ) ; origin check string origin = req . get header ( origin ) ; ( sec . get configur ( ) . check origin ( origin ) ) { resp . send error ( http servlet respons . sc forbidden ) ; return ; } sub protocol list string sub protocol = get token from header ( req , sec web socket protocol ) ; ( sub protocol . empti ( ) ) { sub protocol = sec . get configur ( ) . get negoti subprotocol ( sec . get subprotocol ( ) , sub protocol ) ; } extens current extens ar support thi implement we got thi far , all good . accept connect . resp . set header ( constant . upgrad header name , constant . upgrad header valu ) ; resp . set header ( constant . connect header name , constant . connect header valu ) ; resp . set header ( handshak respons . sec websocket accept , get web socket accept ( kei ) ) ; ( sub protocol = null ) { resp . set header ( sec web socket protocol , sub protocol ) ; } ( extens . empti ( ) ) { string builder sb = new string builder ( ) ; iter extens iter = extens . iter ( ) ; must least sb . append ( iter . next ( ) ) ; while ( iter . ha next ( ) ) { sb . append ( , ) ; sb . append ( iter . next ( ) . get name ( ) ) ; } resp . set header ( sec web socket extens , sb . string ( ) ) ; } endpoint ep ; try { class clazz = sec . get endpoint class ( ) ; ( endpoint . class . assign from ( clazz ) ) { ep = ( endpoint ) sec . get endpoint class ( ) . new instanc ( ) ; } els { ep = new pojo endpoint server ( ) ; } } catch ( instanti except illeg access except e ) { throw new servlet except ( e ) ; } ws handshak request ws request = new ws handshak request ( req ) ; ws handshak respons ws respons = new ws handshak respons ( ) ; sec . get configur ( ) . modifi handshak ( sec , ws request , ws respons ) ; ws request . finish ( ) ; add ani addit header ( entri string , list string >> entri : ws respons . get header ( ) . entri set ( ) ) { ( string header valu : entri . get valu ( ) ) { resp . add header ( entri . get kei ( ) , header valu ) ; } } ws http upgrad handler ws handler = req . upgrad ( ws http upgrad handler . class ) ; ws handler . pre init ( ep , sec , sc , ws request , sub protocol , path paramet , req . secur ( ) ) ; }
privat boolean process data control ( ) throw ioexcept { ( append payload messag ( control buffer binari ) ) { return fals ; } control buffer binari . flip ( ) ; ( op code = = constant . opcod close ) { close = true ; string reason = null ; int code = close code . normal closur . get code ( ) ; ( control buffer binari . remain ( ) = = 1 ) { control buffer binari . clear ( ) ; payload must zero greater than 2 throw new ws ioexcept ( new close reason ( close code . protocol error , sm . get string ( ws frame . byte close code ) ) ) ; } ( control buffer binari . remain ( ) 1 ) { code = control buffer binari . get short ( ) ; ( control buffer binari . remain ( ) 0 ) { coder result cr = utf8decod control . decod ( control buffer binari , control buffer text , true ) ; ( cr . error ( ) ) { control buffer binari . clear ( ) ; control buffer text . clear ( ) ; throw new ws ioexcept ( new close reason ( close code . protocol error , sm . get string ( ws frame . invalid utf8clos ) ) ) ; } overflow output buffer big enough . underflow all data pass decod singl call . control buffer text . flip ( ) ; reason = control buffer text . string ( ) ; } } ws session . close ( new close reason ( util . get close code ( code ) , reason ) ) ; } els ( op code = = constant . opcod ping ) { ( ws session . open ( ) ) { ws session . get basic remot ( ) . send pong ( control buffer binari ) ; } } els ( op code = = constant . opcod pong ) { messag handler . whole pong messag mh pong = ws session . get pong messag handler ( ) ; ( mh pong = null ) { mh pong . messag ( new ws pong messag ( control buffer binari ) ) ; } } els { should have caught thi earlier just case . . . control buffer binari . clear ( ) ; throw new ws ioexcept ( new close reason ( close code . protocol error , sm . get string ( ws frame . invalid op code , integ . valu ( op code ) ) ) ) ; } control buffer binari . clear ( ) ; new frame ( ) ; return true ; }	privat void process socket read ( ) throw ioexcept { while ( respons . ha remain ( ) ) { int remain = respons . remain ( ) ; int copi = math . min ( remain , input buffer . length write po ) ; copi remain byte read http phase input buffer us frame process respons . get ( input buffer , write po , copi ) ; write po = copi ; process data we have process input buffer ( ) ; } respons . clear ( ) ; get some more data channel . read ( respons , null , handler ) ; }	protect static long byte arrai long ( byte b , int start , int len ) throw ioexcept { ( len 8 ) { throw new ioexcept ( sm . get string ( ws frame . byte long fail , long . valu ( len ) ) ) ; } int shift = 0 ; long result = 0 ; ( int i = start len 1 ; i = start ; i ) { result = result ( ( b i 0x ff ) << shift ) ; shift = 8 ; } return result ; }	protect void process input buffer ( ) throw ioexcept { while ( true ) { ws session . updat last activ ( ) ; ( state = = state . new frame ) { ( close ) { throw new ioexcept ( sm . get string ( ws frame . close ) ) ; } ( process initi header ( ) ) { break ; } } ( state = = state . partial header ) { ( process remain header ( ) ) { break ; } } ( state = = state . data ) { ( process data ( ) ) { break ; } } } }	public call when data servlet input stream process . void data avail ( ) throw ioexcept { synchron ( connect read lock ) { while ( si . readi ( ) ) { fill up input buffer much data we can int read = si . read ( input buffer , write po , input buffer . length write po ) ; ( read = = 0 ) { return ; } ( read = = 1 ) { throw new eofexcept ( ) ; } write po = read ; process input buffer ( ) ; } } }
public void test max cach size ( ) throw except { init ( ) ; config ( true , fals , 100 ) ; connect con1 = datasourc . get connect ( ) ; connect con2 = datasourc . get connect ( ) ; ( int i = 0 ; i 120 ; i ) { connect ar close below suppress warn ( resourc ) connect con = ( i 2 = = 0 ) con1 : con2 ; prepar statement ps = con . prepar statement ( select i ) ; ps . close ( ) ; } assert . assert equal ( 100 , interceptor . get cach size ( ) . get ( ) ) ; con1 . close ( ) ; con2 . close ( ) ; }	overrid public void close invok ( ) { should we cach boolean should close = true ; ( cach size . get ( ) max cach size ) { cach proxi so we don t reus facad cach statement proxi = new cach statement ( get deleg ( ) , get sql ( ) ) ; try { creat new facad object actual proxi = get constructor ( ) . new instanc ( new object { proxi } ) ; proxi . set actual proxi ( actual proxi ) ; proxi . set connect ( get connect ( ) ) ; proxi . set constructor ( get constructor ( ) ) ; ( cach statement ( proxi ) ) { proxi . cach = true ; should close = fals ; } } catch ( except x ) { remov statement ( proxi ) ; } } close = true ; deleg = null ; ( should close ) { super . close invok ( ) ; } }	test public void test prepar statement cache2 ( ) throw except { init ( ) ; config ( fals , fals , 100 ) ; connect con = datasourc . get connect ( ) ; prepar statement ps1 = con . prepar statement ( select 1 ) ; prepar statement ps2 = con . prepar statement ( select 1 ) ; assert . assert equal ( 0 , interceptor . get cach size ( ) . get ( ) ) ; ps1 . close ( ) ; assert . assert true ( ps1 . close ( ) ) ; assert . assert equal ( 0 , interceptor . get cach size ( ) . get ( ) ) ; prepar statement ps3 = con . prepar statement ( select 1 ) ; assert . assert equal ( 0 , interceptor . get cach size ( ) . get ( ) ) ; ps2 . close ( ) ; assert . assert true ( ps2 . close ( ) ) ; ps3 . close ( ) ; assert . assert true ( ps3 . close ( ) ) ; assert . assert equal ( 0 , interceptor . get cach size ( ) . get ( ) ) ; }
overrid public string string ( ) { string builder buf = new string builder ( connect pool ) ; try { string field = data sourc factori . all properti ; ( int i = 0 ; i field . length ; i ) { final string prefix = new string { get , } ; ( int j = 0 ; j prefix . length ; j ) { string name = prefix j field i . substr ( 0 , 1 ) . upper case ( local . english ) field i . substr ( 1 ) ; method m = null ; try { m = get class ( ) . get method ( name ) ; } catch ( method except nm ) { continu ; } buf . append ( field i ) ; buf . append ( = ) ; buf . append ( m . invok ( thi , new object 0 ) ) ; buf . append ( ; ) ; break ; } } } catch ( except x ) { shouldn ; t happen x . print stack trace ( ) ; } return buf . string ( ) ; }
privat void send close messag ( close reason close reason ) { 125 maximum size payload control messag byte buffer msg = byte buffer . alloc ( 125 ) ; msg . put short ( ( short ) close reason . get close code ( ) . get code ( ) ) ; string reason = close reason . get reason phrase ( ) ; ( reason = null reason . length ( ) 0 ) { msg . put ( reason . get byte ( utf8 ) ) ; } msg . flip ( ) ; try { ws remot endpoint . start messag block ( constant . opcod close , msg , true ) ; } catch ( ioexcept ioe ) { fail send close messag . close socket let caller deal except log . error ( sm . get string ( ws session . send close fail ) , ioe ) ; ws remot endpoint . close ( ) ; local endpoint . error ( thi , ioe ) ; } final { web socket contain . unregist session ( local endpoint . get class ( ) , thi ) ; fire close event thread t = thread . current thread ( ) ; class loader cl = t . get context class loader ( ) ; t . set context class loader ( applic class loader ) ; try { local endpoint . close ( thi , close reason ) ; } final { t . set context class loader ( cl ) ; } } }	protect void expir ( ) { long timeout = max idl timeout ; ( timeout 1 ) { return ; } ( system . current time milli ( ) last activ timeout ) { try { close ( new close reason ( close code . go awai , sm . get string ( ws session . timeout ) ) ) ; } catch ( ioexcept e ) { log . warn ( sm . get string ( ws session . expir fail ) , e ) ; } } }	overrid public map string , string get path paramet ( ) { return path paramet ; }	overrid public map string , object get user properti ( ) { return user properti ; }	overrid public list extens get negoti extens ( ) { return collect . empti list ; }	overrid public string get protocol version ( ) { return constant . ws version header valu ; }	overrid public string get queri string ( ) { return queri string ; }	overrid public map string , list string >> get request paramet map ( ) { return request paramet map ; }	overrid public web socket contain get contain ( ) { return web socket contain ; }	overrid public boolean secur ( ) { return secur ; }	overrid public int get max binari messag buffer size ( ) { return max binari messag buffer size ; }	overrid public remot endpoint . basic get basic remot ( ) { return remot endpoint basic ; }	overrid public long get max idl timeout ( ) { return max idl timeout ; }	overrid public set messag handler get messag handler ( ) { set messag handler result = new hash set ( ) ; ( binari messag handler = null ) { result . add ( binari messag handler ) ; } ( text messag handler = null ) { result . add ( text messag handler ) ; } ( pong messag handler = null ) { result . add ( pong messag handler ) ; } return result ; }	overrid public void close ( close reason close reason ) throw ioexcept { doubl check lock . ok becaus state volatil ( state = state . open ) { return ; } synchron ( state lock ) { ( state = state . open ) { return ; } state = state . close ; send close messag ( close reason ) ; } }	overrid public void remov messag handler ( messag handler listen ) { ( listen = = null ) { return ; } ( listen . equal ( text messag handler ) ) { text messag handler = null ; } els ( listen . equal ( binari messag handler ) ) { binari messag handler = null ; } els ( listen . equal ( pong messag handler ) ) { pong messag handler = null ; } becom problem throw new illeg state except ( sm . get string ( ws session . remov handler fail , listen ) ) ; }	overrid public void set max binari messag buffer size ( int max ) { thi . max binari messag buffer size = max ; }	overrid public void set max idl timeout ( long timeout ) { thi . max idl timeout = timeout ; }	overrid public void set max text messag buffer size ( int max ) { thi . max text messag buffer size = max ; }	test public void test session expiri contain ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; ctx . add applic listen ( tester echo server . config . class . get name ( ) ) ; tomcat . start ( ) ; need access implement method configur unit test ws web socket contain ws contain = ( ws web socket contain ) contain provid . get web socket contain ( ) ; 5 second timeout ws contain . set default max session idl timeout ( 5000 ) ; ws contain . set process period ( 1 ) ; connect echo server basic ( ws contain , endpoint . class ) ; connect echo server basic ( ws contain , endpoint . class ) ; session s3a = connect echo server basic ( ws contain , endpoint . class ) ; check all three session ar open set session set = s3a . get open session ( ) ; assert . assert equal ( 3 , set . size ( ) ) ; int count = 0 ; set = s3a . get open session ( ) ; while ( set . size ( ) 0 count 8 ) { count ; thread . sleep ( 1000 ) ; set = s3a . get open session ( ) ; } ( set . size ( ) 0 ) { assert . fail ( were set . size ( ) open session ) ; } }	test public void test session expiri session ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; ctx . add applic listen ( tester echo server . config . class . get name ( ) ) ; tomcat . start ( ) ; need access implement method configur unit test ws web socket contain ws contain = ( ws web socket contain ) contain provid . get web socket contain ( ) ; 5 second timeout ws contain . set default max session idl timeout ( 5000 ) ; ws contain . set process period ( 1 ) ; session s1a = connect echo server basic ( ws contain , endpoint . class ) ; s1a . set max idl timeout ( 3000 ) ; session s2a = connect echo server basic ( ws contain , endpoint . class ) ; s2a . set max idl timeout ( 6000 ) ; session s3a = connect echo server basic ( ws contain , endpoint . class ) ; s3a . set max idl timeout ( 9000 ) ; check all three session ar open set session set = s3a . get open session ( ) ; int expect = 3 ; while ( expect 0 ) { assert . assert equal ( expect , set . size ( ) ) ; int count = 0 ; while ( set . size ( ) = = expect count 5 ) { count ; thread . sleep ( 1000 ) ; set = s3a . get open session ( ) ; } expect ; } assert . assert equal ( 0 , set . size ( ) ) ; }	call when close messag receiv . should onli ever happen onc . void close ( close reason close reason ) { boolean send close messag = fals ; synchron ( state lock ) { ( state = = state . open ) { send close messag = true ; } state = state . close ; ( send close messag ) { send close messag ( close reason ) ; } close socket ws remot endpoint . close ( ) ; } }
suppress warn ( { uncheck , rawtyp } ) public void send object complet ( object obj , send handler complet ) { encod encod = find encod ( obj ) ; try { ( encod instanceof encod . text ) { string msg = ( ( encod . text ) encod ) . encod ( obj ) ; send string complet ( msg , complet ) ; } els ( encod instanceof encod . text stream ) { writer w = get send writer ( ) ; ( ( encod . text stream ) encod ) . encod ( obj , w ) ; } els ( encod instanceof encod . binari ) { byte buffer msg = ( ( encod . binari ) encod ) . encod ( obj ) ; send byte complet ( msg , complet ) ; } els ( encod instanceof encod . binari stream ) { output stream os = get send stream ( ) ; ( ( encod . binari stream ) encod ) . encod ( obj , os ) ; } els { throw new encod except ( obj , sm . get string ( ws remot endpoint . encod , obj . get class ( ) ) ) ; } } catch ( encod except ioexcept e ) { send result sr = new send result ( e ) ; complet . result ( sr ) ; } }
privat static object coerc type ( class type , string valu ) { ( type . equal ( string . class ) ) { return valu ; } els ( type . equal ( boolean . class ) type . equal ( boolean . class ) ) { return boolean . valu ( valu ) ; } els ( type . equal ( byte . class ) type . equal ( byte . class ) ) { return byte . valu ( valu ) ; } els ( valu . length ( ) = = 1 ( type . equal ( char . class ) type . equal ( charact . class ) ) ) { return charact . valu ( valu . char ( 0 ) ) ; } els ( type . equal ( doubl . class ) type . equal ( doubl . class ) ) { return doubl . valu ( valu ) ; } els ( type . equal ( float . class ) type . equal ( float . class ) ) { return float . valu ( valu ) ; } els ( type . equal ( int . class ) type . equal ( integ . class ) ) { return integ . valu ( valu ) ; } els ( type . equal ( long . class ) type . equal ( long . class ) ) { return long . valu ( valu ) ; } els ( type . equal ( short . class ) type . equal ( short . class ) ) { return short . valu ( valu ) ; } els { throw new illeg argument except ( sm . get string ( pojo method map . invalid type , valu , type . get name ( ) ) ) ; } }	overrid protect object decod ( byte buffer messag ) throw decod except { ( decod decod : decod ) { ( decod instanceof binari ) { ( ( ( binari ) decod ) . decod ( messag ) ) { return ( ( binari ) decod ) . decod ( messag ) ; } } els { byte arrai = new byte messag . limit ( ) messag . posit ( ) ; messag . get ( arrai ) ; byte arrai input stream bai = new byte arrai input stream ( arrai ) ; try { return ( ( binari stream ) decod ) . decod ( bai ) ; } catch ( ioexcept ioe ) { throw new decod except ( messag , sm . get string ( pojo messag handler whole . decod io fail ) , ioe ) ; } } } return null ; }	overrid protect object decod ( string messag ) throw decod except { ( decod decod : decod ) { ( decod instanceof text ) { ( ( ( text ) decod ) . decod ( messag ) ) { return ( ( text ) decod ) . decod ( messag ) ; } } els { string reader r = new string reader ( messag ) ; try { return ( ( text stream ) decod ) . decod ( r ) ; } catch ( ioexcept ioe ) { throw new decod except ( messag , sm . get string ( pojo messag handler whole . decod io fail ) , ioe ) ; } } } return null ; }	public messag handler get messag handler ( object pojo , map string , string path paramet , session session , endpoint config config ) { object param = new object m . get paramet type ( ) . length ; ( map . entri integ , pojo path param entri : index path param . entri set ( ) ) { pojo path param path param = entri . get valu ( ) ; string valu string = path paramet . get ( path param . get name ( ) ) ; object valu = null ; ( valu string = null ) { valu = coerc type ( path param . get type ( ) , valu string ) ; } param entri . get kei ( ) . int valu ( ) = valu ; } messag handler mh = null ; ( index boolean = = 1 ) { basic ( index string = 1 ) { mh = new pojo messag handler whole text ( pojo , m , session , config , param , index string , fals , index session ) ; } els ( index byte arrai = 1 ) { mh = new pojo messag handler whole binari ( pojo , m , session , config , param , index byte arrai , true , index session ) ; } els ( index byte buffer = 1 ) { mh = new pojo messag handler whole binari ( pojo , m , session , config , param , index byte buffer , fals , index session ) ; } els { mh = new pojo messag handler whole pong ( pojo , m , session , param , index pong , fals , index session ) ; } } els { async ( index string = 1 ) { mh = new pojo messag handler partial text ( pojo , m , session , param , index string , fals , index boolean , index session ) ; } els ( index byte arrai = 1 ) { mh = new pojo messag handler partial binari ( pojo , m , session , param , index byte arrai , true , index boolean , index session ) ; } els { mh = new pojo messag handler partial binari ( pojo , m , session , param , index byte buffer , fals , index boolean , index session ) ; } } return mh ; }	privat static object coerc type ( class type , string valu ) { ( type . equal ( string . class ) ) { return valu ; } els ( type . equal ( boolean . class ) type . equal ( boolean . class ) ) { return boolean . valu ( valu ) ; } els ( type . equal ( byte . class ) type . equal ( byte . class ) ) { return byte . valu ( valu ) ; } els ( valu . length ( ) = = 1 ( type . equal ( char . class ) type . equal ( charact . class ) ) ) { return charact . valu ( valu . char ( 0 ) ) ; } els ( type . equal ( doubl . class ) type . equal ( doubl . class ) ) { return doubl . valu ( valu ) ; } els ( type . equal ( float . class ) type . equal ( float . class ) ) { return float . valu ( valu ) ; } els ( type . equal ( int . class ) type . equal ( integ . class ) ) { return integ . valu ( valu ) ; } els ( type . equal ( long . class ) type . equal ( long . class ) ) { return long . valu ( valu ) ; } els ( type . equal ( short . class ) type . equal ( short . class ) ) { return short . valu ( valu ) ; } els { throw new illeg argument except ( sm . get string ( pojo method map . invalid type , valu , type . get name ( ) ) ) ; } }	public object get close arg ( map string , string path paramet , session session ) { return build arg ( close param , path paramet , session , null ) ; }	privat static object build arg ( pojo path param path param , map string , string path paramet , session session , throwabl throwabl ) { object result = new object path param . length ; ( int i = 0 ; i path param . length ; i ) { class type = path param i . get type ( ) ; ( type . equal ( session . class ) ) { result i = session ; } els ( type . equal ( throwabl . class ) ) { result i = throwabl ; } els { string name = path param i . get name ( ) ; string valu = path paramet . get ( name ) ; ( valu = = null ) { result i = null ; } els { result i = coerc type ( type , valu ) ; } } } return result ; }	public object get open arg ( map string , string path paramet , session session ) { return build arg ( open param , path paramet , session , null ) ; }	overrid public final void close ( session session , close reason close reason ) { ( method map . get close ( ) = null ) { try { method map . get close ( ) . invok ( pojo , method map . get close arg ( path paramet , session ) ) ; } catch ( illeg access except illeg argument except invoc target except e ) { log . error ( sm . get string ( pojo endpoint base . close fail , pojo . get class ( ) . get name ( ) ) , e ) ; } } trigger destroi method ani associ decod set messag handler messag handler = session . get messag handler ( ) ; ( messag handler messag handler : messag handler ) { ( messag handler instanceof pojo messag handler whole base ) { ( ( pojo messag handler whole base ) messag handler ) . close ( ) ; } } }	overrid public final void messag ( t messag ) { can thi messag decod object payload ; try { payload = decod ( messag ) ; } catch ( decod except de ) { session except se = new session except ( sm . get string ( pojo messag handler whole . decod fail ) , de , session ) ; ( ( ws session ) session ) . get local ( ) . error ( session , se ) ; return ; } ( payload = = null ) { byte buffer ( unwrap ) { byte buffer bb = ( byte buffer ) messag ; byte arrai = new byte bb . remain ( ) ; bb . get ( arrai ) ; payload = arrai ; } els { payload = messag ; } } object paramet = param . clone ( ) ; ( index session = 1 ) { paramet index session = session ; } paramet index payload = payload ; object result ; try { result = method . invok ( pojo , paramet ) ; } catch ( illeg access except invoc target except e ) { throw new illeg argument except ( ) ; } process result ( result ) ; }	overrid public final void messag ( t messag , boolean last ) { object paramet = param . clone ( ) ; ( index boolean = 1 ) { paramet index boolean = boolean . valu ( last ) ; } ( index session = 1 ) { paramet index session = session ; } ( unwrap ) { paramet index payload = ( ( byte buffer ) messag ) . arrai ( ) ; } els { paramet index payload = messag ; } object result ; try { result = method . invok ( pojo , paramet ) ; } catch ( illeg access except invoc target except e ) { throw new illeg argument except ( e ) ; } process result ( result ) ; }
privat session connect echo server basic ( web socket contain ws contain , class extend endpoint clazz ) throw except { return ws contain . connect server ( clazz , client endpoint config . builder . creat ( ) . build ( ) , new uri ( http : localhost : get port ( ) tester echo server . config . path basic ) ) ; }	privat void do buffer test ( boolean text buffer , boolean server buffer , boolean text messag , boolean pass ) throw except { tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; ctx . add applic listen ( tester echo server . config . class . get name ( ) ) ; web socket contain ws contain = contain provid . get web socket contain ( ) ; ( server buffer ) { ( text buffer ) { ctx . add paramet ( org . apach . tomcat . websocket . server . constant . text buffer size servlet context init param , 1024 ) ; } els { ctx . add paramet ( org . apach . tomcat . websocket . server . constant . binari buffer size servlet context init param , 1024 ) ; } } els { ( text buffer ) { ws contain . set default max text messag buffer size ( 1024 ) ; } els { ws contain . set default max binari messag buffer size ( 1024 ) ; } } tomcat . start ( ) ; session ws session = ws contain . connect server ( tester programmat endpoint . class , client endpoint config . builder . creat ( ) . build ( ) , new uri ( http : localhost : get port ( ) tester echo server . config . path basic ) ) ; basic handler handler ; count down latch latch = new count down latch ( 1 ) ; ws session . get user properti ( ) . put ( latch , latch ) ; ( text messag ) { handler = new basic text ( latch ) ; } els { handler = new basic binari ( latch ) ; } ws session . add messag handler ( handler ) ; ( text messag ) { ws session . get basic remot ( ) . send text ( messag text 4k ) ; } els { ws session . get basic remot ( ) . send binari ( byte buffer . wrap ( messag binari 4k ) ) ; } boolean latch result = handler . get latch ( ) . await ( 10 , time unit . second ) ; assert . assert true ( latch result ) ; list messag = handler . get messag ( ) ; ( pass ) { assert . assert equal ( 1 , messag . size ( ) ) ; ( text messag ) { assert . assert equal ( messag text 4k , messag . get ( 0 ) ) ; } els { assert . assert equal ( byte buffer . wrap ( messag binari 4k ) , messag . get ( 0 ) ) ; } } els { assert . assert fals ( ws session . open ( ) ) ; } }	privat void do test write timeout client ( boolean set timeout contain ) throw except { tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; ctx . add applic listen ( block config . class . get name ( ) ) ; web socket contain ws contain = contain provid . get web socket contain ( ) ; set async timeout ( set timeout contain ) { ws contain . set async send timeout ( timeout ms ) ; } tomcat . start ( ) ; session ws session = ws contain . connect server ( tester programmat endpoint . class , client endpoint config . builder . creat ( ) . build ( ) , new uri ( http : localhost : get port ( ) block config . path ) ) ; ( set timeout contain ) { ws session . get async remot ( ) . set send timeout ( timeout ms ) ; } long last send = 0 ; should send quickli until network buffer fill up block until timeout kick except except = null ; try { while ( true ) { futur void f = ws session . get async remot ( ) . send binari ( byte buffer . wrap ( messag binari 4k ) ) ; last send = system . current time milli ( ) ; f . get ( ) ; } } catch ( except e ) { except = e ; } long timeout = system . current time milli ( ) last send ; string msg = time out wa timeout ms ; check correct time pass assert . assert true ( msg , timeout = timeout ms margin ) ; check timeout wasn t too long assert . assert true ( msg , timeout timeout ms 2 ) ; assert . assert null ( except ) ; }	privat void do test write timeout server ( boolean set timeout contain ) throw except { note : ar all sort horribl us static thi test becaus api us class test realli need access instanc which simpli isn t possibl . timout contain = set timeout contain ; tomcat tomcat = get tomcat instanc ( ) ; ( get protocol ( ) . equal ( http11protocol . class . get name ( ) ) ) { thi never work bio return ; } must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; ctx . add applic listen ( ws listen . class . get name ( ) ) ; ctx . add applic listen ( constant tx config . class . get name ( ) ) ; web socket contain ws contain = contain provid . get web socket contain ( ) ; tomcat . start ( ) ; session ws session = ws contain . connect server ( tester programmat endpoint . class , client endpoint config . builder . creat ( ) . build ( ) , new uri ( http : localhost : get port ( ) constant tx config . path ) ) ; ws session . add messag handler ( new block binari handler ( ) ) ; int loop = 0 ; while ( loop 15 ) { thread . sleep ( 1000 ) ; ( constant tx endpoint . get run ( ) ) { break ; } loop ; } check right except wa thrown assert . assert null ( constant tx endpoint . get except ( ) ) ; assert . assert equal ( execut except . class , constant tx endpoint . get except ( ) . get class ( ) ) ; assert . assert null ( constant tx endpoint . get except ( ) . get caus ( ) ) ; assert . assert equal ( socket timeout except . class , constant tx endpoint . get except ( ) . get caus ( ) . get class ( ) ) ; check correct time pass assert . assert true ( constant tx endpoint . get timeout ( ) = timeout ms ) ; check timeout wasn t too long assert . assert true ( constant tx endpoint . get timeout ( ) timeout ms 2 ) ; }	privat void do test writer ( class clazz ) throw except { tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; ctx . add applic listen ( tester echo server . config . class . get name ( ) ) ; web socket contain ws contain = contain provid . get web socket contain ( ) ; tomcat . start ( ) ; session ws session ; uri uri = new uri ( http : localhost : get port ( ) tester echo server . config . path async ) ; ( endpoint . class . assign from ( clazz ) ) { suppress warn ( uncheck ) class extend endpoint endpoint clazz = ( class extend endpoint ) clazz ; ws session = ws contain . connect server ( endpoint clazz , builder . creat ( ) . build ( ) , uri ) ; } els { ws session = ws contain . connect server ( clazz , uri ) ; } count down latch latch = new count down latch ( 1 ) ; ws session . get user properti ( ) . put ( latch , latch ) ; async handler handler = new async text ( latch ) ; ws session . add messag handler ( handler ) ; writer w = ws session . get basic remot ( ) . get send writer ( ) ; ( int i = 0 ; i 8 ; i ) { w . write ( test messag 5k ) ; } w . close ( ) ; boolean latch result = handler . get latch ( ) . await ( 10 , time unit . second ) ; assert . assert true ( latch result ) ; list string messag = ( list string ) handler . get messag ( ) ; int offset = 0 ; int i = 0 ; ( string messag : messag ) { first mai fragment assert . assert equal ( sequenc . substr ( offset , s len ) , messag . substr ( 0 , s len offset ) ) ; i = s len offset ; while ( i s len messag . length ( ) ) { ( sequenc . equal ( messag . substr ( i , i s len ) ) ) { assert . fail ( ) ; } i = s len ; } offset = messag . length ( ) i ; ( sequenc . substr ( 0 , offset ) . equal ( messag . substr ( i ) ) ) { assert . fail ( ) ; } } }	overrid public session connect server ( endpoint endpoint , client endpoint config client endpoint configur , uri path ) throw deploy except { string scheme = path . get scheme ( ) ; ( ( http . equal ignor case ( scheme ) http . equal ignor case ( scheme ) ) ) { throw new deploy except ( sm . get string ( ws web socket contain . path wrong scheme , scheme ) ) ; } string host = path . get host ( ) ; ( host = = null ) { throw new deploy except ( sm . get string ( ws web socket contain . path host ) ) ; } int port = path . get port ( ) ; map string , list string >> req header = creat request header ( host , port ) ; client endpoint configur . get configur ( ) . befor request ( req header ) ; byte buffer request = creat request ( path . get raw path ( ) , req header ) ; socket address sa ; ( port = = 1 ) { ( http . equal ignor case ( scheme ) ) { sa = new inet socket address ( host , 80 ) ; } els { sa = new inet socket address ( host , 443 ) ; throw new deploy except ( todo : http ) ; } } els { sa = new inet socket address ( host , port ) ; } asynchron socket channel channel ; try { channel = asynchron socket channel . open ( ) ; } catch ( ioexcept ioe ) { throw new deploy except ( todo , ioe ) ; } futur void f connect = channel . connect ( sa ) ; byte buffer respons ; string sub protocol ; try { f connect . get ( ) ; int write = request . limit ( ) ; futur integ f write = channel . write ( request ) ; integ thi write = f write . get ( ) ; write = thi write . int valu ( ) ; while ( write 0 ) { f write = channel . write ( request ) ; thi write = f write . get ( ) ; write = thi write . int valu ( ) ; } same size ws frame input buffer respons = byte buffer . alloc ( max binari messag buffer size ) ; handshak respons handshak respons = process respons ( respons , channel ) ; client endpoint configur . get configur ( ) . after respons ( handshak respons ) ; sub protocol list string valu = handshak respons . get header ( ) . get ( constant . ws protocol header name ) ; ( valu = = null valu . size ( ) = = 0 ) { sub protocol = null ; } els ( valu . size ( ) = = 1 ) { sub protocol = valu . get ( 0 ) ; } els { throw new deploy except ( sm . get string ( sec web socket protocol ) ) ; } } catch ( execut except interrupt except e ) { throw new deploy except ( sm . get string ( ws web socket contain . http request fail ) , e ) ; } switch web socket ws remot endpoint impl client ws remot endpoint client = new ws remot endpoint impl client ( channel ) ; ws session ws session = new ws session ( endpoint , ws remot endpoint client , thi , null , sub protocol , collect . empti map , fals , client endpoint configur . get encod ( ) ) ; endpoint . open ( ws session , client endpoint configur ) ; regist session ( endpoint . get class ( ) , ws session ) ; object creation trigger input process suppress warn ( unus ) ws frame client ws frame client = new ws frame client ( respons , channel , ws session ) ; return ws session ; }	public void test ( ) throw except { set up util class server server = new server ( ) ; singleton configur . set instanc ( server ) ; server config listen . set pojo clazz ( server . class ) ; tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; ctx . add applic listen ( server config listen . class . get name ( ) ) ; web socket contain ws contain = contain provid . get web socket contain ( ) ; tomcat . start ( ) ; client client = new client ( ) ; uri uri = new uri ( http : localhost : get port ( ) ) ; session session = ws contain . connect server ( client , uri ) ; msg string msg1 = new msg string ( ) ; msg1 . set data ( messag ) ; session . get basic remot ( ) . send object ( msg1 ) ; should take veri long int i = 0 ; while ( i 20 ) { ( server . receiv . size ( ) 0 client . receiv . size ( ) 0 ) { break ; } thread . sleep ( 100 ) ; } check messag were receiv assert . assert equal ( 1 , server . receiv . size ( ) ) ; assert . assert equal ( 1 , client . receiv . size ( ) ) ; check correct messag were receiv assert . assert equal ( messag , ( ( msg string ) server . receiv . peek ( ) ) . get data ( ) ) ; assert . assert equal ( messag , ( ( msg string ) client . receiv . peek ( ) ) . get data ( ) ) ; }	public void test ( ) throw except { set up util class server server = new server ( ) ; singleton configur . set instanc ( server ) ; server config listen . set pojo clazz ( server . class ) ; tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; ctx . add applic listen ( server config listen . class . get name ( ) ) ; web socket contain ws contain = contain provid . get web socket contain ( ) ; tomcat . start ( ) ; client client = new client ( ) ; uri uri = new uri ( http : localhost : get port ( ) param param two param three ) ; session session = ws contain . connect server ( client , uri ) ; session . get basic remot ( ) . send text ( op ) ; session . close ( ) ; give server 5s close int count = 0 ; while ( count 50 ) { ( server . close ( ) ) { break ; } count ; thread . sleep ( 100 ) ; } ( count = = 50 ) { assert . fail ( server did process close event within 5 second client send close messag ) ; } check error list string error = server . get error ( ) ; ( string error : error ) { system . err . println ( error ) ; } assert . assert equal ( found error , 0 , error . size ( ) ) ; }	public void test connect server endpoint ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; ctx . add applic listen ( tester echo server . config . class . get name ( ) ) ; tomcat . start ( ) ; web socket contain ws contain = contain provid . get web socket contain ( ) ; session ws session = ws contain . connect server ( tester programmat endpoint . class , client endpoint config . builder . creat ( ) . build ( ) , new uri ( http : localhost : get port ( ) tester echo server . config . path async ) ) ; count down latch latch = new count down latch ( 1 ) ; basic text handler = new basic text ( latch ) ; ws session . add messag handler ( handler ) ; ws session . get basic remot ( ) . send text ( messag string 1 ) ; boolean latch result = handler . get latch ( ) . await ( 10 , time unit . second ) ; assert . assert true ( latch result ) ; list string messag = handler . get messag ( ) ; assert . assert equal ( 1 , messag . size ( ) ) ; assert . assert equal ( messag string 1 , messag . get ( 0 ) ) ; }	test ( expect = javax . websocket . deploy except . class ) public void test connect server endpoint host ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; ctx . add applic listen ( tester echo server . config . class . get name ( ) ) ; tomcat . start ( ) ; web socket contain ws contain = contain provid . get web socket contain ( ) ; ws contain . connect server ( tester programmat endpoint . class , client endpoint config . builder . creat ( ) . build ( ) , new uri ( http : tester echo server . config . path async ) ) ; }
public string get paramet valu ( string paramet ) { return paramet . get ( paramet . lower case ( local . us ) ) ; }	overrid public string string ( ) { string builder buf = new string builder ( connect pool ) ; try { string field = data sourc factori . all properti ; ( int i = 0 ; i field . length ; i ) { final string prefix = new string { get , } ; ( int j = 0 ; j prefix . length ; j ) { string name = prefix j field i . substr ( 0 , 1 ) . upper case ( local . us ) field i . substr ( 1 ) ; method m = null ; try { m = get class ( ) . get method ( name ) ; } catch ( method except nm ) { continu ; } buf . append ( field i ) ; buf . append ( = ) ; buf . append ( m . invok ( thi , new object 0 ) ) ; buf . append ( ; ) ; break ; } } } catch ( except x ) { shouldn ; t happen x . print stack trace ( ) ; } return buf . string ( ) ; }	public static charset get charset ( string enc ) throw unsupport encod except { encod name should all ascii string lower case enc = enc . lower case ( local . us ) ; return get charset lower ( lower case enc ) ; }	public static media type pars media type ( string reader input ) throw ioexcept { type ( requir ) string type = read token ( input ) ; ( type = = null type . length ( ) = = 0 ) { return null ; } ( skip constant ( input , ) = = skip constant result . found ) { return null ; } subtyp ( requir ) string subtyp = read token ( input ) ; ( subtyp = = null subtyp . length ( ) = = 0 ) { return null ; } link hash map string , string paramet = new link hash map ( ) ; skip constant result look semi colon = skip constant ( input , ; ) ; ( look semi colon = = skip constant result . found ) { return null ; } while ( look semi colon = = skip constant result . found ) { string attribut = read token ( input ) ; ( skip constant ( input , = ) = = skip constant result . found ) { string valu = read token quot string ( input , true ) ; paramet . put ( attribut . lower case ( local . us ) , valu ) ; } els { paramet . put ( attribut . lower case ( local . us ) , ) ; } look semi colon = skip constant ( input , ; ) ; ( look semi colon = = skip constant result . found ) { return null ; } } return new media type ( type , subtyp , paramet ) ; }	public set uri encod us uri . param uriencod new uri charact encod . void set uriencod ( string uriencod ) { thi . uriencod = uriencod ; ( uriencod = = null ) { uriencod lower = null ; } els { thi . uriencod lower = uriencod . lower case ( local . us ) ; } set properti ( u riencod , uriencod ) ; }

protect param filenam name file ( possibl more lead path segment ) read param path locat filenam rel input sourc get web xml sourc ( string filenam , string path ) { file file = new file ( filenam ) ; ( file . absolut ( ) ) { file = new file ( path , filenam ) ; } input stream stream = null ; input sourc sourc = null ; try { ( file . exist ( ) ) { us get resourc get resourc stream stream = get class ( ) . get class loader ( ) . get resourc stream ( filenam ) ; ( stream = null ) { sourc = new input sourc ( get class ( ) . get class loader ( ) . get resourc ( filenam ) . uri ( ) . string ( ) ) ; } } els { sourc = new input sourc ( file . get absolut file ( ) . uri ( ) . string ( ) ) ; stream = new file input stream ( file ) ; } ( stream = null sourc = null ) { sourc . set byte stream ( stream ) ; } } catch ( except e ) { log . error ( sm . get string ( context config . default error , filenam , file ) , e ) ; } return sourc ; }	protect scan web inf lib jar each found add ani meta inf web fragment . xml result map . web fragment . xml file pars befor ad map . everi jar ad code null code us web fragment . xml wa found . ani jar known contain fragment skip . return map jar name process web fragment ( ani ) map string , web xml process jar web fragment ( ) { jar scanner jar scanner = context . get jar scanner ( ) ; fragment jar scanner callback callback = new fragment jar scanner callback ( ) ; jar scanner . scan ( context . get servlet context ( ) , context . get loader ( ) . get class loader ( ) , callback , pluggabl jar skip ) ; return callback . get fragment ( ) ; }	overrid public void scan ( file file ) throw ioexcept { input stream stream = null ; web xml fragment = new web xml ( ) ; try { file fragment file = new file ( file , fragment locat ) ; ( fragment file . file ( ) ) { stream = new file input stream ( fragment file ) ; input sourc sourc = new input sourc ( fragment file . uri ( ) . url ( ) . string ( ) ) ; sourc . set byte stream ( stream ) ; pars web xml ( sourc , fragment , true ) ; } } final { ( stream = null ) { try { stream . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } } fragment . set url ( file . uri ( ) . url ( ) ) ; ( fragment . get name ( ) = = null ) { fragment . set name ( fragment . get url ( ) . string ( ) ) ; } fragment . set jar name ( file . get name ( ) ) ; fragment . put ( fragment . get name ( ) , fragment ) ; } }	protect map string , string process annot web init param ( element valu ev ) { map string , string result = new hash map ( ) ; ( ev instanceof arrai element valu ) { element valu arrai valu = ( ( arrai element valu ) ev ) . get element valu arrai ( ) ; ( element valu valu : arrai valu ) { ( valu instanceof annot element valu ) { element valu pair evp = ( ( annot element valu ) valu ) . get annot entri ( ) . get element valu pair ( ) ; string init param name = null ; string init param valu = null ; ( element valu pair evp : evp ) { ( name . equal ( evp . get name string ( ) ) ) { init param name = evp . get valu ( ) . stringifi valu ( ) ; } els ( valu . equal ( evp . get name string ( ) ) ) { init param valu = evp . get valu ( ) . stringifi valu ( ) ; } els { ignor } } result . put ( init param name , init param valu ) ; } } } return result ; }
privat void pars part ( ) { return immedi part have alreadi been pars ( part = null part pars except = null ) { return ; } multipart config element mce = get wrapper ( ) . get multipart config element ( ) ; ( mce = = null ) { ( get context ( ) . get allow casual multipart pars ( ) ) { mce = new multipart config element ( null , connector . get max post size ( ) , connector . get max post size ( ) , connector . get max post size ( ) ) ; } els { part = collect . empti list ( ) ; return ; } } paramet paramet = coyot request . get paramet ( ) ; paramet . set limit ( get connector ( ) . get max paramet count ( ) ) ; boolean success = fals ; try { file locat ; string locat str = mce . get locat ( ) ; ( locat str = = null locat str . length ( ) = = 0 ) { locat = ( ( file ) context . get servlet context ( ) . get attribut ( servlet context . tempdir ) ) ; } els { rel , rel tempdir locat = new file ( locat str ) ; ( locat . absolut ( ) ) { locat = new file ( ( file ) context . get servlet context ( ) . get attribut ( servlet context . tempdir ) , locat str ) . get absolut file ( ) ; } } ( locat . directori ( ) ) { part pars except = new ioexcept ( sm . get string ( coyot request . upload locat invalid , locat ) ) ; return ; } creat new file upload handler disk file item factori factori = new disk file item factori ( ) ; try { factori . set repositori ( locat . get canon file ( ) ) ; } catch ( ioexcept ioe ) { part pars except = ioe ; return ; } factori . set size threshold ( mce . get file size threshold ( ) ) ; servlet file upload upload = new servlet file upload ( ) ; upload . set file item factori ( factori ) ; upload . set file size max ( mce . get max file size ( ) ) ; upload . set size max ( mce . get max request size ( ) ) ; part = new arrai list ( ) ; try { list file item item = upload . pars request ( thi ) ; int max post size = get connector ( ) . get max post size ( ) ; int post size = 0 ; string enc = get charact encod ( ) ; charset charset = null ; ( enc = null ) { try { charset = b2cconvert . get charset ( enc ) ; } catch ( unsupport encod except e ) { ignor } } ( file item item : item ) { applic part part = new applic part ( item , mce ) ; part . add ( part ) ; ( part . get filenam ( ) = = null ) { string name = part . get name ( ) ; string valu = null ; try { string encod = paramet . get encod ( ) ; ( encod = = null ) { encod = paramet . default encod ; } valu = part . get string ( encod ) ; } catch ( unsupport encod except uee ) { try { valu = part . get string ( paramet . default encod ) ; } catch ( unsupport encod except e ) { should possibl } } ( max post size 0 ) { accur close enough . ( charset = = null ) { name length post size = name . get byte ( ) . length ; } els { post size = name . get byte ( charset ) . length ; } ( valu = null ) { equal sign post size ; valu length post size = part . get size ( ) ; } valu separ post size ; ( post size max post size ) { throw new illeg state except ( sm . get string ( coyot request . max post size exceed ) ) ; } } paramet . add paramet ( name , valu ) ; } } success = true ; } catch ( invalid content type except e ) { part pars except = new servlet except ( e ) ; } catch ( file upload base . size except e ) { check swallow input ( ) ; part pars except = new illeg state except ( e ) ; } catch ( file upload except e ) { part pars except = new ioexcept ( e ) ; } catch ( illeg state except e ) { check swallow input ( ) ; part pars except = e ; } } final { ( part pars except = null success ) { paramet . set pars fail ( true ) ; } } }	protect string upload ( http servlet request request , string manag sm client ) throw ioexcept , servlet except { string messag = ; part war part = null ; string filenam = null ; collect part part = request . get part ( ) ; iter part iter = part . iter ( ) ; try { while ( iter . ha next ( ) ) { part part = iter . next ( ) ; ( part . get name ( ) . equal ( deploi war ) war part = = null ) { war part = part ; } els { part . delet ( ) ; } } while ( true ) { ( war part = = null ) { messag = sm client . get string ( html manag servlet . deploi upload file ) ; break ; } filenam = extract filenam ( war part . get header ( content disposit ) ) ; ( filenam . lower case ( local . english ) . end ( . war ) ) { messag = sm client . get string ( html manag servlet . deploi upload war , filenam ) ; break ; } get filenam upload name includ path ( filenam . last index ( ) = 0 ) { filenam = filenam . substr ( filenam . last index ( ) 1 ) ; } ( filenam . last index ( ) = 0 ) { filenam = filenam . substr ( filenam . last index ( ) 1 ) ; } identifi app base own host thi context ( ani ) file file = new file ( host . get app base file ( ) , filenam ) ; ( file . exist ( ) ) { messag = sm client . get string ( html manag servlet . deploi upload war exist , filenam ) ; break ; } context name cn = new context name ( filenam ) ; string name = cn . get name ( ) ; ( ( host . find child ( name ) = null ) deploi ( name ) ) { messag = sm client . get string ( html manag servlet . deploi upload server xml , filenam ) ; break ; } ( servic ( name ) ) { add servic ( name ) ; try { war part . write ( file . get absolut path ( ) ) ; perform new deploy check ( name ) ; } final { remov servic ( name ) ; } } break ; } } catch ( except e ) { messag = sm client . get string ( html manag servlet . deploi upload fail , e . get messag ( ) ) ; log ( messag , e ) ; } final { ( war part = null ) { war part . delet ( ) ; } war part = null ; } return messag ; }	public string get string ( string encod ) throw unsupport encod except { return file item . get string ( encod ) ; }
start thi compon implement requir { link org . apach . catalina . util . lifecycl base start intern ( ) } . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect synchron void start intern ( ) throw lifecycl except { initi date formatt string format = get file date format ( ) ; ( format = = null ) { format = ; set file date format ( format ) ; } file date formatt = new simpl date format ( format , local . us ) ; file date formatt . set time zone ( time zone . get default ( ) ) ; date stamp = file date formatt . format ( new date ( system . current time milli ( ) ) ) ; ( rotat renam rotat ) { restor ( ) ; } open ( ) ; set state ( lifecycl state . start ) ; }	public log specifi messag log file , switch file date ha chang sinc previou log call . param messag messag log void log ( char arrai writer messag ) { ( rotat ) { onli do logfil switch check onc second , max . long systim = system . current time milli ( ) ; ( ( systim rotat last check ) 1000 ) { synchron ( thi ) { ( ( systim rotat last check ) 1000 ) { rotat last check = systim ; string ts date ; check chang date ts date = file date formatt . format ( new date ( systim ) ) ; date ha chang , switch log file ( date stamp . equal ( ts date ) ) { close ( true ) ; date stamp = ts date ; open ( ) ; } } } } } case someth extern rotat file instead ( check exist ) { synchron ( thi ) { ( current log file = null current log file . exist ( ) ) { try { close ( fals ) ; } catch ( throwabl e ) { except util . handl throwabl ( e ) ; log . info ( sm . get string ( access log valv . close fail ) , e ) ; } make sure date correct date stamp = file date formatt . format ( new date ( system . current time milli ( ) ) ) ; open ( ) ; } } } log thi messag try { synchron ( thi ) { ( writer = null ) { messag . write ( writer ) ; writer . println ( ) ; ( buffer ) { writer . flush ( ) ; } } } } catch ( ioexcept ioe ) { log . warn ( sm . get string ( access log valv . write fail , messag . string ( ) ) , ioe ) ; } }	overrid public void log ( request request , respons respons , long time ) { ( get state ( ) . avail ( ) get enabl ( ) log element = = null condit = null null = request . get request ( ) . get attribut ( condit ) condit = null null = = request . get request ( ) . get attribut ( condit ) ) { return ; } xxx thi bit silli , we want have start stop time durat consist . would better keep start stop simpli request respons object remov time ( durat ) from interfac . long start = request . get coyot request ( ) . get start time ( ) ; date date = get date ( start time ) ; char arrai writer result = char arrai writer . pop ( ) ; ( result = = null ) { result = new char arrai writer ( 128 ) ; } ( int i = 0 ; i log element . length ; i ) { log element i . add element ( result , date , request , respons , time ) ; } log ( result ) ; ( result . size ( ) = max log messag buffer size ) { result . reset ( ) ; char arrai writer . push ( result ) ; } }	public set date format date base log rotat . void set file date format ( string file date format ) { thi . file date format = file date format ; }
overrid public string get enabl protocol ( sslcontext context ) { string request protocol = endpoint . get ssl enabl protocol arrai ( ) ; ( ( request protocol = = null ) ( request protocol . length = = 0 ) ) { return context . get default sslparamet ( ) . get protocol ( ) ; } list string protocol = new arrai list ( arrai . list ( request protocol ) ) ; protocol . retain all ( arrai . list ( context . get support sslparamet ( ) . get protocol ( ) ) ) ; ( protocol . empti ( ) ) { log . warn ( sm . get string ( jsse . request protocol support , arrai . list ( request protocol ) ) ) ; } ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jsse . enabl protocol , protocol ) ) ; ( protocol . size ( ) = request protocol . length ) { list string skip = new arrai list ( arrai . list ( request protocol ) ) ; skip . remov all ( protocol ) ; log . debug ( sm . get string ( jsse . unsupport protocol , skip ) ) ; } } return protocol . arrai ( new string protocol . size ( ) ) ; }	public string get enabl cipher ( ) { return enabl cipher ; }

privat write provid byte payload new web socket frame . param buffer byte includ payload . param final fragment do byte repres final fragment web socket messag throw ioexcept void do write byte ( byte buffer buffer , boolean final fragment ) throw ioexcept { ( close ) { throw new ioexcept ( sm . get string ( outbound . close ) ) ; } work out first byte int first = 0x00 ; ( final fragment ) { first = first 0x80 ; } ( first frame ) { ( text . boolean valu ( ) ) { first = first 0x1 ; } els { first = first 0x2 ; } } continu frame op code 0 output stream . write ( first ) ; ( buffer . limit ( ) 126 ) { output stream . write ( buffer . limit ( ) ) ; } els ( buffer . limit ( ) 65536 ) { output stream . write ( 126 ) ; output stream . write ( buffer . limit ( ) >> 8 ) ; output stream . write ( buffer . limit ( ) 0x ff ) ; } els { never more than 2 31 1 output stream . write ( 127 ) ; output stream . write ( 0 ) ; output stream . write ( 0 ) ; output stream . write ( 0 ) ; output stream . write ( 0 ) ; output stream . write ( buffer . limit ( ) >> 24 ) ; output stream . write ( buffer . limit ( ) >> 16 ) ; output stream . write ( buffer . limit ( ) >> 8 ) ; output stream . write ( buffer . limit ( ) 0x ff ) ; } write content output stream . write ( buffer . arrai ( ) , 0 , buffer . limit ( ) ) ; output stream . flush ( ) ; reset ( final fragment ) { text = null ; first frame = true ; } els { first frame = fals ; } bb . clear ( ) ; }
protect restor origin request from inform store our session . origin request longer present ( becaus session time out ) , return code fals code ; otherwis , return code true code . param request request restor param session session contain save inform boolean restor request ( request request , session session ) throw ioexcept { retriev remov save request object from our session save request save = ( save request ) session . get note ( constant . form request note ) ; session . remov note ( constant . form request note ) ; session . remov note ( constant . form princip note ) ; ( save = = null ) { return fals ; } modifi our current request reflect origin request . clear cooki ( ) ; iter cooki cooki = save . get cooki ( ) ; while ( cooki . ha next ( ) ) { request . add cooki ( cooki . next ( ) ) ; } string method = save . get method ( ) ; mime header rmh = request . get coyot request ( ) . get mime header ( ) ; rmh . recycl ( ) ; boolean cachabl = get . equal ignor case ( method ) head . equal ignor case ( method ) ; iter string name = save . get header name ( ) ; while ( name . ha next ( ) ) { string name = name . next ( ) ; bz 43687 ( ( modifi sinc . equal ignor case ( name ) ( cachabl none match . equal ignor case ( name ) ) ) ) { iter string valu = save . get header valu ( name ) ; while ( valu . ha next ( ) ) { rmh . add valu ( name ) . set string ( valu . next ( ) ) ; } } } request . clear local ( ) ; iter local local = save . get local ( ) ; while ( local . ha next ( ) ) { request . add local ( local . next ( ) ) ; } request . get coyot request ( ) . get paramet ( ) . recycl ( ) ; request . get coyot request ( ) . get paramet ( ) . set queri string encod ( request . get connector ( ) . get uriencod ( ) ) ; swallow ani request bodi sinc we replac byte buffer = new byte 4096 ; input stream = request . creat input stream ( ) ; while ( . read ( buffer ) = 0 ) { ignor request bodi } byte chunk bodi = save . get bodi ( ) ; ( bodi = null ) { request . get coyot request ( ) . action ( action code . req set bodi replai , bodi ) ; set content type messag byte content type = messag byte . new instanc ( ) ; content type specifi , us default post string save content type = save . get content type ( ) ; ( save content type = = null post . equal ignor case ( method ) ) { save content type = applic x www form urlencod ; } content type . set string ( save content type ) ; request . get coyot request ( ) . set content type ( content type ) ; } request . get coyot request ( ) . method ( ) . set string ( method ) ; return true ; }
privat write provid byte payload new web socket frame . param buffer byte includ payload . param final fragment do byte repres final fragment web socket messag throw ioexcept void do write byte ( byte buffer buffer , boolean final fragment ) throw ioexcept { work out first byte int first = 0x00 ; ( final fragment ) { first = first 0x80 ; } ( first frame ) { ( text . boolean valu ( ) ) { first = first 0x1 ; } els { first = first 0x2 ; } } continu frame op code 0 output stream . write ( first ) ; ( buffer . limit ( ) 126 ) { output stream . write ( buffer . limit ( ) ) ; } els ( buffer . limit ( ) 65536 ) { output stream . write ( 126 ) ; output stream . write ( buffer . limit ( ) >> 8 ) ; output stream . write ( buffer . limit ( ) 0x ff ) ; } els { never more than 2 31 1 output stream . write ( 127 ) ; output stream . write ( 0 ) ; output stream . write ( 0 ) ; output stream . write ( 0 ) ; output stream . write ( 0 ) ; output stream . write ( buffer . limit ( ) >> 24 ) ; output stream . write ( buffer . limit ( ) >> 16 ) ; output stream . write ( buffer . limit ( ) >> 8 ) ; output stream . write ( buffer . limit ( ) 0x ff ) ; } write content output stream . write ( buffer . arrai ( ) , 0 , buffer . limit ( ) ) ; output stream . flush ( ) ; reset ( final fragment ) { text = null ; first frame = true ; } els { first frame = fals ; } bb . clear ( ) ; }	public synchron send close messag client param statu must valid statu code zero send code param data option messag . messag defin , valid statu code must provid . throw ioexcept error occur write client void close ( int statu , byte buffer data ) throw ioexcept { ( close ) { return ; } close = true ; output stream . write ( 0x88 ) ; ( statu = = 0 ) { output stream . write ( 0 ) ; } els ( data = = null data . posit ( ) = = data . limit ( ) ) { output stream . write ( 2 ) ; output stream . write ( statu >> 8 ) ; output stream . write ( statu ) ; } els { output stream . write ( 2 data . limit ( ) data . posit ( ) ) ; output stream . write ( statu >> 8 ) ; output stream . write ( statu ) ; output stream . write ( data . arrai ( ) , data . posit ( ) , data . limit ( ) data . posit ( ) ) ; } output stream . flush ( ) ; bb = null ; cb = null ; output stream = null ; }
public static write vm state . mode 0 gener html . mode 1 gener xml . void write vmstate ( print writer writer , int mode ) throw except { sort map string , memori pool mxbean memori pool mbean = new tree map ( ) ; ( memori pool mxbean mbean : manag factori . get memori pool mxbean ( ) ) { string sort kei = mbean . get type ( ) : mbean . get name ( ) ; memori pool mbean . put ( sort kei , mbean ) ; } ( mode = = 0 ) { writer . print ( h1 jvm h1 ) ; writer . print ( p ) ; writer . print ( free memori : ) ; writer . print ( format size ( long . valu ( runtim . get runtim ( ) . free memori ( ) ) , true ) ) ; writer . print ( total memori : ) ; writer . print ( format size ( long . valu ( runtim . get runtim ( ) . total memori ( ) ) , true ) ) ; writer . print ( max memori : ) ; writer . print ( format size ( long . valu ( runtim . get runtim ( ) . max memori ( ) ) , true ) ) ; writer . print ( p ) ; writer . write ( tabl border = 0 thead tr th memori pool th th type th th initi th th total th th maximum th th us th tr thead tbodi ) ; ( memori pool mxbean memori pool mbean : memori pool mbean . valu ( ) ) { memori usag usag = memori pool mbean . get usag ( ) ; writer . write ( tr td ) ; writer . print ( memori pool mbean . get name ( ) ) ; writer . write ( td td ) ; writer . print ( memori pool mbean . get type ( ) ) ; writer . write ( td td ) ; writer . print ( format size ( long . valu ( usag . get init ( ) ) , true ) ) ; writer . write ( td td ) ; writer . print ( format size ( long . valu ( usag . get commit ( ) ) , true ) ) ; writer . write ( td td ) ; writer . print ( format size ( long . valu ( usag . get max ( ) ) , true ) ) ; writer . write ( td td ) ; writer . print ( format size ( long . valu ( usag . get us ( ) ) , true ) ) ; ( usag . get max ( ) 0 ) { writer . write ( ( ( usag . get us ( ) 100 usag . get max ( ) ) ) ) ; } writer . write ( td tr ) ; } writer . write ( tbodi tabl ) ; } els ( mode = = 1 ) { writer . write ( jvm ) ; writer . write ( memori ) ; writer . write ( free = runtim . get runtim ( ) . free memori ( ) ) ; writer . write ( total = runtim . get runtim ( ) . total memori ( ) ) ; writer . write ( max = runtim . get runtim ( ) . max memori ( ) ) ; ( memori pool mxbean memori pool mbean : memori pool mbean . valu ( ) ) { memori usag usag = memori pool mbean . get usag ( ) ; writer . write ( memorypool ) ; writer . write ( name = memori pool mbean . get name ( ) ) ; writer . write ( type = memori pool mbean . get type ( ) ) ; writer . write ( usag init = usag . get init ( ) ) ; writer . write ( usag commit = usag . get commit ( ) ) ; writer . write ( usag max = usag . get max ( ) ) ; writer . write ( usag us = usag . get init ( ) ) ; } writer . write ( jvm ) ; } }
privat set appropri context attribut our class path . thi requir onli becaus jasper depend . void set class path ( ) { valid our current state inform ( context = = null ) return ; servlet context servlet context = context . get servlet context ( ) ; ( servlet context = = null ) return ; string builder classpath = new string builder ( ) ; assembl class path inform from our class loader chain class loader loader = get class loader ( ) ; while ( loader = null ) { ( build class path ( servlet context , classpath , loader ) ) { break ; } loader = loader . get parent ( ) ; } thi . classpath = classpath . string ( ) ; store assembl class path servlet context attribut servlet context . set attribut ( global . class path attr , classpath . string ( ) ) ; }
protect charact convers uri . void convert uri ( messag byte uri , request request ) throw except { byte chunk bc = uri . get byte chunk ( ) ; int length = bc . get length ( ) ; char chunk cc = uri . get char chunk ( ) ; cc . alloc ( length , 1 ) ; string enc = connector . get uriencod ( ) ; ( enc = null ) { b2cconvert conv = request . get uriconvert ( ) ; try { ( conv = = null ) { conv = new b2cconvert ( enc ) ; request . set uriconvert ( conv ) ; } } catch ( ioexcept e ) { ignor log . error ( invalid uri encod ; us http default ) ; connector . set uriencod ( null ) ; } ( conv = null ) { try { conv . convert ( bc , cc ) ; uri . set char ( cc . get buffer ( ) , cc . get start ( ) , cc . get length ( ) ) ; return ; } catch ( ioexcept e ) { log . error ( invalid uri charact encod ; try ascii ) ; cc . recycl ( ) ; } } } default encod : fast convers byte bbuf = bc . get buffer ( ) ; char cbuf = cc . get buffer ( ) ; int start = bc . get start ( ) ; ( int i = 0 ; i length ; i ) { cbuf i = ( char ) ( bbuf i start 0xff ) ; } uri . set char ( cbuf , 0 , length ) ; }

protect handl receiv chang session id other node param msg param sender throw ioexcept void handl chang session id ( session messag msg , member sender ) throw ioexcept { counter receiv evt chang session id ; delta session session = ( delta session ) find session ( msg . get session id ( ) ) ; ( session = null ) { string new session id = deseri session id ( msg . get session ( ) ) ; session . set primari session ( fals ) ; session . set id ( new session id , fals ) ; ( notifi contain listen replic ) { get context ( ) . fire contain event ( context . chang session id event , new string { msg . get session id ( ) , new session id } ) ; } } }	default behavior thi method return get session ( ) wrap request object . overrid public http session get session ( ) { return thi . get http servlet request ( ) . get session ( ) ; }	overrid public http session get session ( ) { ( request = = null ) { throw new illeg state except ( sm . get string ( request facad . null request ) ) ; } return get session ( true ) ; }	overrid public http session get session ( ) { return get request ( ) . get session ( ) ; }	public configur set instanti applic event listen thi context . return code true code all listen wre initi successfulli , code fals code otherwis . boolean listen start ( ) { ( log . debug enabl ( ) ) log . debug ( configur applic event listen ) ; instanti requir listen string listen = find applic listen ( ) ; object result = new object listen . length ; boolean ok = true ; ( int i = 0 ; i result . length ; i ) { ( get logger ( ) . debug enabl ( ) ) get logger ( ) . debug ( configur event listen class listen i ) ; try { result i = instanc manag . new instanc ( listen i ) ; } catch ( throwabl t ) { t = except util . unwrap invoc target except ( t ) ; except util . handl throwabl ( t ) ; get logger ( ) . error ( sm . get string ( standard context . applic listen , listen i ) , t ) ; ok = fals ; } } ( ok ) { get logger ( ) . error ( sm . get string ( standard context . applic skip ) ) ; return ( fals ) ; } sort listen two arrai arrai list object event listen = new arrai list ( ) ; arrai list object lifecycl listen = new arrai list ( ) ; ( int i = 0 ; i result . length ; i ) { ( ( result i instanceof servlet context attribut listen ) ( result i instanceof servlet request attribut listen ) ( result i instanceof servlet request listen ) ( result i instanceof http session attribut listen ) ) { event listen . add ( result i ) ; } ( ( result i instanceof servlet context listen ) ( result i instanceof http session listen ) ) { lifecycl listen . add ( result i ) ; } } listen mai have been ad servlet context initi . put them after we know about . ( object event listen : get applic event listen ( ) ) { event listen . add ( event listen ) ; } set applic event listen ( event listen . arrai ( ) ) ; ( object lifecycl listen : get applic lifecycl listen ( ) ) { lifecycl listen . add ( lifecycl listen ) ; } set applic lifecycl listen ( lifecycl listen . arrai ( ) ) ; send applic start event ( get logger ( ) . debug enabl ( ) ) get logger ( ) . debug ( send applic start event ) ; ensur context null get servlet context ( ) ; context . set new servlet context listen allow ( fals ) ; object instanc = get applic lifecycl listen ( ) ; ( instanc = = null instanc . length = = 0 ) return ( ok ) ; servlet context event event = new servlet context event ( get servlet context ( ) ) ; ( int i = 0 ; i instanc . length ; i ) { ( instanc i = = null ) continu ; ( ( instanc i instanceof servlet context listen ) ) continu ; servlet context listen listen = ( servlet context listen ) instanc i ; try { fire contain event ( befor context initi , listen ) ; listen . context initi ( event ) ; fire contain event ( after context initi , listen ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; fire contain event ( after context initi , listen ) ; get logger ( ) . error ( sm . get string ( standard context . listen start , instanc i . get class ( ) . get name ( ) ) , t ) ; ok = fals ; } } return ( ok ) ; }	overrid public t extend event listen t creat listen ( class t c ) throw servlet except { try { t listen = ( t ) context . get instanc manag ( ) . new instanc ( c . get name ( ) ) ; ( listen instanceof servlet context listen listen instanceof servlet context attribut listen listen instanceof servlet request listen listen instanceof servlet request attribut listen listen instanceof http session listen listen instanceof http session attribut listen ) { return listen ; } throw new illeg argument except ( sm . get string ( applic context . add listen . iae . wrong type , listen . get class ( ) . get name ( ) ) ) ; } catch ( illeg access except e ) { throw new servlet except ( e ) ; } catch ( invoc target except e ) { except util . handl throwabl ( e . get caus ( ) ) ; throw new servlet except ( e ) ; } catch ( name except e ) { throw new servlet except ( e ) ; } catch ( instanti except e ) { throw new servlet except ( e ) ; } catch ( class found except e ) { throw new servlet except ( e ) ; } }	chang session id current session new randomli gener session id . param session session chang session id overrid public void chang session id ( session session ) { string old id = session . get id intern ( ) ; session . set id ( gener session id ( ) , fals ) ; string new id = session . get id intern ( ) ; context . fire contain event ( context . chang session id event , new string { old id , new id } ) ; }	public chang id session thi request associ . ar sever thing mai trigger id chang . includ move between node cluster session fixat prevent dure authent process . param new session id session chang session id void chang session id ( string new session id ) { doubl check sure ( request session id = null request session id . length ( ) 0 ) { request session id = new session id ; } ( context = null context . get servlet context ( ) . get effect session track mode ( ) . contain ( session track mode . cooki ) ) { return ; } ( respons = null ) { cooki new cooki = applic session cooki config . creat session cooki ( context , new session id , secur ) ; respons . add session cooki intern ( new cooki ) ; } }
test public void test bug54220set found ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; tomcat . add servlet ( ctx , bug54220 , new bug54220servlet ( true ) ) ; ctx . add servlet map ( , bug54220 ) ; tomcat . start ( ) ; byte chunk re = new byte chunk ( ) ; int rc = get url ( http : localhost : get port ( ) , re , null ) ; assert . assert null ( re . string ( ) ) ; assert . assert equal ( http servlet respons . sc found , rc ) ; }	protect print out error report . param request request process param respons respons gener param throwabl except occur ( which possibl wrap root caus except void report ( request request , respons respons , throwabl throwabl ) { do noth non http respons int statu code = respons . get statu ( ) ; do noth anyth ha been written alreadi ( statu code 400 respons . get content written ( ) 0 respons . error ( ) ) { return ; } string messag = request util . filter ( respons . get messag ( ) ) ; ( messag = = null ) { ( throwabl = null ) { string except messag = throwabl . get messag ( ) ; ( except messag = null except messag . length ( ) 0 ) { messag = request util . filter ( ( new scanner ( except messag ) ) . next line ( ) ) ; } } ( messag = = null ) { messag = ; } } do noth report specifi statu code string report = null ; try { report = sm . get string ( http . statu code ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } ( report = = null ) { return ; } string builder sb = new string builder ( ) ; sb . append ( html head titl ) ; sb . append ( server info . get server info ( ) ) . append ( ) ; sb . append ( sm . get string ( error report valv . error report ) ) ; sb . append ( titl ) ; sb . append ( style ) ; sb . append ( org . apach . catalina . util . tomcat css . tomcat css ) ; sb . append ( style ) ; sb . append ( head bodi ) ; sb . append ( h1 ) ; sb . append ( sm . get string ( error report valv . statu header , statu code , messag ) ) . append ( h1 ) ; sb . append ( hr size = 1 noshad = noshad ) ; sb . append ( p b type b ) ; ( throwabl = null ) { sb . append ( sm . get string ( error report valv . except report ) ) ; } els { sb . append ( sm . get string ( error report valv . statu report ) ) ; } sb . append ( p ) ; sb . append ( p b ) ; sb . append ( sm . get string ( error report valv . messag ) ) ; sb . append ( b u ) ; sb . append ( messag ) . append ( u p ) ; sb . append ( p b ) ; sb . append ( sm . get string ( error report valv . descript ) ) ; sb . append ( b u ) ; sb . append ( report ) ; sb . append ( u p ) ; ( throwabl = null ) { string stack trace = get partial servlet stack trace ( throwabl ) ; sb . append ( p b ) ; sb . append ( sm . get string ( error report valv . except ) ) ; sb . append ( b pre ) ; sb . append ( request util . filter ( stack trace ) ) ; sb . append ( pre p ) ; int loop = 0 ; throwabl root caus = throwabl . get caus ( ) ; while ( root caus = null ( loop 10 ) ) { stack trace = get partial servlet stack trace ( root caus ) ; sb . append ( p b ) ; sb . append ( sm . get string ( error report valv . root caus ) ) ; sb . append ( b pre ) ; sb . append ( request util . filter ( stack trace ) ) ; sb . append ( pre p ) ; case root caus somehow heavili nest root caus = root caus . get caus ( ) ; loop ; } sb . append ( p b ) ; sb . append ( sm . get string ( error report valv . note ) ) ; sb . append ( b u ) ; sb . append ( sm . get string ( error report valv . root caus log , server info . get server info ( ) ) ) ; sb . append ( u p ) ; } sb . append ( hr size = 1 noshad = noshad ) ; sb . append ( h3 ) . append ( server info . get server info ( ) ) . append ( h3 ) ; sb . append ( bodi html ) ; try { try { respons . set content type ( text html ) ; respons . set charact encod ( utf 8 ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; ( contain . get logger ( ) . debug enabl ( ) ) { contain . get logger ( ) . debug ( statu . set content type , t ) ; } } writer writer = respons . get report ( ) ; ( writer = null ) { writer null , s indic respons ha been hard commit alreadi , which should never happen writer . write ( sb . string ( ) ) ; } } catch ( ioexcept e ) { ignor } catch ( illeg state except e ) { ignor } }
privat return attribut valu , option url encod . valu runtim express , result express itself , string . result el express , we insert call interpret . result name attribut we insert gener variabl name . otherwis result string liter , quot escap . param attr jsp attribut object param encod true url encod param expect type expect type el evalu ( ignor attribut aren t el express ) string attribut valu ( node . jsp attribut attr , boolean encod , class expect type ) { string v = attr . get valu ( ) ; ( attr . name attribut ( ) ( v = = null ) ) return ; ( attr . express ( ) ) { ( encod ) { return org . apach . jasper . runtim . jsp runtim librari . urlencod ( string . valu ( v ) , request . get charact encod ( ) ) ; } return v ; } els ( attr . elinterpret input ( ) ) { v = jsp util . interpret call ( thi . tag file , v , expect type , attr . get el ( ) . get map name ( ) , fals ) ; ( encod ) { return org . apach . jasper . runtim . jsp runtim librari . urlencod ( v , request . get charact encod ( ) ) ; } return v ; } els ( attr . name attribut ( ) ) { return attr . get name attribut node ( ) . get temporari variabl name ( ) ; } els { ( encod ) { return org . apach . jasper . runtim . jsp runtim librari . urlencod ( quot ( v ) , request . get charact encod ( ) ) ; } return quot ( v ) ; } }	suppress warn ( null ) privat string evalu attribut ( tag handler info handler info , node . jsp attribut attr , node . custom tag n , string tag handler var ) throw jasper except { string attr valu = attr . get valu ( ) ; ( attr valu = = null ) { ( attr . name attribut ( ) ) { ( n . check attribut jsp fragment ( attr . get name ( ) ) ) { xxx need gener temporari variabl here attr valu = gener name attribut jsp fragment ( attr . get name attribut node ( ) , tag handler var ) ; } els { attr valu = gener name attribut valu ( attr . get name attribut node ( ) ) ; } } els { return null ; } } string local name = attr . get local name ( ) ; method m = null ; class c = null ; ( attr . dynam ( ) ) { c = object class ; } els { m = handler info . get setter method ( local name ) ; ( m = = null ) { err . jsp error ( n , jsp . error . unabl . find method , attr . get name ( ) ) ; } c = m . get paramet type ( ) ; xxx assert ( c . length 0 ) } ( attr . express ( ) ) { do noth } els ( attr . name attribut ( ) ) { ( n . check attribut jsp fragment ( attr . get name ( ) ) attr . dynam ( ) ) { attr valu = convert string ( c 0 , attr valu , local name , handler info . get properti editor class ( local name ) , true ) ; } } els ( attr . elinterpret input ( ) ) { result buffer string builder sb = new string builder ( 64 ) ; tag attribut info tai = attr . get tag attribut info ( ) ; gener el context refer sb . append ( get jsp context var ( ) ) ; sb . append ( . get elcontext ( ) ) ; string el context = sb . string ( ) ; ( attr . get el ( ) = null attr . get el ( ) . get map name ( ) = null ) { sb . set length ( 0 ) ; sb . append ( new org . apach . jasper . el . elcontext wrapper ( ) ; sb . append ( el context ) ; sb . append ( , ) ; sb . append ( attr . get el ( ) . get map name ( ) ) ; sb . append ( ) ) ; el context = sb . string ( ) ; } reset buffer sb . set length ( 0 ) ; creat our mark sb . append ( n . get start ( ) . string ( ) ) ; sb . append ( ) ; sb . append ( attr valu ) ; sb . append ( ) ; string mark = sb . string ( ) ; reset buffer sb . set length ( 0 ) ; depend type ( attr . defer input ( ) ( ( tai = null ) valu express . class . get name ( ) . equal ( tai . get type name ( ) ) ) ) { sb . append ( new org . apach . jasper . el . jsp valu express ( ) ; sb . append ( quot ( mark ) ) ; sb . append ( , ) ; sb . append ( get express factori var ( ) ) ; sb . append ( . creat valu express ( ) ; ( attr . get el ( ) = null ) { optim sb . append ( el context ) ; sb . append ( , ) ; } sb . append ( quot ( attr valu ) ) ; sb . append ( , ) ; sb . append ( jsp util . java sourc type from tld ( attr . get expect type name ( ) ) ) ; sb . append ( ) ) ) ; should express evalu befor pass setter boolean evalu = fals ; ( tai = null tai . can request time ( ) ) { jsp . 2 . 3 . 2 evalu = true ; } ( attr . defer input ( ) ) { jsp . 2 . 3 . 3 evalu = fals ; } ( attr . defer input ( ) tai = null tai . can request time ( ) ) { jsp . 2 . 3 . 5 evalu = attr valu . contain ( { ) ; } ( evalu ) { sb . append ( . get valu ( ) ; sb . append ( get jsp context var ( ) ) ; sb . append ( . get elcontext ( ) ) ; sb . append ( ) ) ; } attr valu = sb . string ( ) ; } els ( attr . defer method input ( ) ( ( tai = null ) method express . class . get name ( ) . equal ( tai . get type name ( ) ) ) ) { sb . append ( new org . apach . jasper . el . jsp method express ( ) ; sb . append ( quot ( mark ) ) ; sb . append ( , ) ; sb . append ( get express factori var ( ) ) ; sb . append ( . creat method express ( ) ; sb . append ( el context ) ; sb . append ( , ) ; sb . append ( quot ( attr valu ) ) ; sb . append ( , ) ; sb . append ( jsp util . java sourc type from tld ( attr . get expect type name ( ) ) ) ; sb . append ( , ) ; sb . append ( new java . lang . class { ) ; string p = attr . get paramet type name ( ) ; ( int i = 0 ; i p . length ; i ) { sb . append ( jsp util . java sourc type from tld ( p i ) ) ; sb . append ( , ) ; } ( p . length 0 ) { sb . set length ( sb . length ( ) 1 ) ; } sb . append ( } ) ) ) ; attr valu = sb . string ( ) ; } els { run attr valu through express interpret string map name = ( attr . get el ( ) = null ) attr . get el ( ) . get map name ( ) : null ; attr valu = jsp util . interpret call ( thi . tag file , attr valu , c 0 , map name , fals ) ; } } els { attr valu = convert string ( c 0 , attr valu , local name , handler info . get properti editor class ( local name ) , fals ) ; } return attr valu ; }	privat gener end part static portion servlet . void gener postambl ( ) { out . pop indent ( ) ; out . printil ( } catch ( java . lang . throwabl t ) { ) ; out . push indent ( ) ; out . printil ( ( ( t instanceof javax . servlet . jsp . skip page except ) ) { ) ; out . push indent ( ) ; out . printil ( out = jspx out ; ) ; out . printil ( ( out = null out . get buffer size ( ) = 0 ) ) ; out . push indent ( ) ; out . printil ( try { out . clear buffer ( ) ; } catch ( java . io . ioexcept e ) { } ) ; out . pop indent ( ) ; out . printil ( ( jspx page context = null ) jspx page context . handl page except ( t ) ; ) ; out . printil ( els throw new servlet except ( t ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; out . pop indent ( ) ; out . printil ( } final { ) ; out . push indent ( ) ; out . printil ( jspx factori . releas page context ( jspx page context ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; close servic method out . pop indent ( ) ; out . printil ( } ) ; gener method , helper class , etc . gen common postambl ( ) ; }	overrid public void visit ( node . elexpress n ) throw jasper except { n . set begin java line ( out . get java line ( ) ) ; ( page info . elignor ( ) ( n . get el ( ) = null ) ) { out . printil ( out . write ( jsp util . interpret call ( thi . tag file , n . get type ( ) { n . get text ( ) } , string . class , n . get el ( ) . get map name ( ) , fals ) ) ; ) ; } els { out . printil ( out . write ( quot ( n . get type ( ) { n . get text ( ) } ) ) ; ) ; } n . set end java line ( out . get java line ( ) ) ; }
protect pars end chunk data . void pars end chunk ( ) throw ioexcept { handl option trailer header while ( pars header ( ) ) { loop until we run out header } }	read byte . return filter doe request length control , thi valu signific ; should number byte consum from buffer , up until end current request bodi , buffer length , whichev greater . filter doe do request bodi length control , return valu should 1 . overrid public int do read ( byte chunk chunk , request req ) throw ioexcept { ( end chunk ) return 1 ; ( need crlfpars ) { need crlfpars = fals ; pars crlf ( fals ) ; } ( remain = 0 ) { ( pars chunk header ( ) ) { throw new ioexcept ( invalid chunk header ) ; } ( end chunk ) { pars end chunk ( ) ; return 1 ; } } int result = 0 ; ( po = last valid ) { read byte ( ) ; } ( remain ( last valid po ) ) { result = last valid po ; remain = remain result ; chunk . set byte ( buf , po , result ) ; po = last valid ; } els { result = remain ; chunk . set byte ( buf , po , remain ) ; po = po remain ; remain = 0 ; we need crlf ( ( po 1 ) = last valid ) { we call pars crlf we overrun buffer here so we defer next call bz 11117 need crlfpars = true ; } els { pars crlf immedi pars crlf ( fals ) ; } } return result ; }
privat static string digest ( string input ) { return md5encod . encod ( concurr messag digest . digest md5 ( input . get byte ( ) ) ) ; }	protect gener uniqu token . token gener accord follow pattern . nonc token = base64 ( md5 ( client ip : time stamp : privat kei ) ) . param request http servlet request string gener nonc ( request request ) { long current time = system . current time milli ( ) ; string ip time kei = request . get remot addr ( ) : current time : get kei ( ) ; byte buffer = concurr messag digest . digest md5 ( ip time kei . get byte ( b2cconvert . iso 8859 1 ) ) ; string nonc = current time : md5encod . encod ( buffer ) ; nonc info info = new nonc info ( current time , get nonc count window size ( ) ) ; synchron ( nonc ) { nonc . put ( nonc , info ) ; } return nonc ; }
public return code true code servlet class repres thi compon implement code singl thread model code interfac . boolean singl thread model ( ) { instanc = null , must have alreadi load ( singl thread model instanc = null ) { return singl thread model ; } expect . alloc ( ) alreadi ha necessari logic so re us . try { servlet s = alloc ( ) ; dealloc ( s ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } return ( singl thread model ) ; }
background thread listen incom tcp ip connect hand them off appropri processor . overrid public void run ( ) { int maintain = 0 ; loop until we receiv shutdown command while ( run ) { loop endpoint paus while ( paus ) { try { thread . sleep ( 1000 ) ; } catch ( interrupt except e ) { ignor } } check timeout poller empti while ( connect count 1 add list . size ( ) 1 ) { reset maintain time . try { ( get so timeout ( ) 0 run ) { maintain ( ) ; } synchron ( thi ) { thi . wait ( 10000 ) ; } } catch ( interrupt except e ) { ignor } catch ( throwabl t ) { except util . handl throwabl ( t ) ; get log ( ) . warn ( sm . get string ( endpoint . timeout . err ) ) ; } } try { add socket which ar wait poller ( add list . size ( ) 0 ) { synchron ( thi ) { duplic anoth list , so sync minim add list . duplic ( local add list ) ; add list . clear ( ) ; } socket info info = local add list . get ( ) ; while ( info = null ) { ( info . read ( ) info . write ( ) ) { apr socket wrapper wrapper = connect . get ( long . valu ( info . socket ) ) ; boolean comet = wrapper . comet ( ) ; store timeout ( comet ) { remov from poller ( info . socket ) ; } wrapper . poller flag = wrapper . poller flag ( info . read ( ) poll . apr pollin : 0 ) ( info . write ( ) poll . apr pollout : 0 ) ; ( add poller ( info . socket , wrapper . poller flag ) ) { awai ( comet ( comet process socket ( info . socket , socket statu . error ) ) ) { destroi socket ( info . socket ) ; } } els { timeout . add ( info . socket , system . current time milli ( ) info . timeout ) ; } } els { should never happen . timeout . remov ( info . socket ) ; destroi socket ( info . socket ) ; get log ( ) . warn ( sm . get string ( endpoint . apr . poll add invalid , info ) ) ; } info = local add list . get ( ) ; } } poll specifi interv ( int i = 0 ; i poller . length ; i ) { flag ask realloc pool boolean reset = fals ; arrai list long skip = null ; int rv = 0 ; iter each poller , need poll empti poller ( poller space i actual poller size ) { rv = poll . poll ( poller i , poller time , desc , true ) ; } ( rv 0 ) { poller space i = rv ; connect count = rv ; ( int n = 0 ; n rv ; n ) { timeout . remov ( desc n 2 1 ) ; apr socket wrapper wrapper = connect . get ( long . valu ( desc n 2 1 ) ) ; wrapper . poller flag = wrapper . poller flag ( ( int ) desc n 2 ) ; ( wrapper . poller flag = 0 ) { add ( desc n 2 1 , 1 , wrapper . poller flag ) ; } check fail socket hand thi socket off worker ( wrapper . comet ( ) ) { event process either read write depend what poller return ( ( ( desc n 2 poll . apr pollhup ) = = poll . apr pollhup ) ( ( desc n 2 poll . apr pollerr ) = = poll . apr pollerr ) ( ( desc n 2 poll . apr pollnval ) = = poll . apr pollnval ) ) { ( process socket ( desc n 2 1 , socket statu . error ) ) { close socket clear pool destroi socket ( desc n 2 1 ) ; } } els ( ( desc n 2 poll . apr pollin ) = = poll . apr pollin ) { ( process socket ( desc n 2 1 , socket statu . open read ) ) { close socket clear pool destroi socket ( desc n 2 1 ) ; } } els ( ( desc n 2 poll . apr pollout ) = = poll . apr pollout ) { ( process socket ( desc n 2 1 , socket statu . open write ) ) { close socket clear pool destroi socket ( desc n 2 1 ) ; } } els { unknown event get log ( ) . warn ( sm . get string ( endpoint . apr . poll unknown event , long . valu ( desc n 2 ) ) ) ; ( process socket ( desc n 2 1 , socket statu . error ) ) { close socket clear pool destroi socket ( desc n 2 1 ) ; } } } els ( ( ( desc n 2 poll . apr pollhup ) = = poll . apr pollhup ) ( ( desc n 2 poll . apr pollerr ) = = poll . apr pollerr ) ( ( desc n 2 poll . apr pollnval ) = = poll . apr pollnval ) ) { close socket clear pool destroi socket ( desc n 2 1 ) ; } els ( ( ( desc n 2 poll . apr pollin ) = = poll . apr pollin ) ( ( desc n 2 poll . apr pollout ) = = poll . apr pollout ) ) { boolean error = fals ; ( ( ( desc n 2 poll . apr pollin ) = = poll . apr pollin ) process socket ( desc n 2 1 , socket statu . open read ) ) { error = true ; close socket clear pool destroi socket ( desc n 2 1 ) ; } ( error ( ( desc n 2 poll . apr pollout ) = = poll . apr pollout ) process socket ( desc n 2 1 , socket statu . open write ) ) { close socket clear pool destroi socket ( desc n 2 1 ) ; } } els { unknown event get log ( ) . warn ( sm . get string ( endpoint . apr . poll unknown event , long . valu ( desc n 2 ) ) ) ; close socket clear pool destroi socket ( desc n 2 1 ) ; } } } els ( rv 0 ) { int errn = rv ; ani non timeup interrupt error critic ( ( errn = statu . timeup ) ( errn = statu . eintr ) ) { ( errn statu . apr os start usererr ) { errn = statu . apr os start usererr ; } get log ( ) . error ( sm . get string ( endpoint . apr . poll error , integ . valu ( errn ) , error . strerror ( errn ) ) ) ; destroi realloc poller reset = true ; } } ( reset ) { realloc current poller int count = poll . pollset ( poller i , desc ) ; long new poller = alloc poller ( actual poller size , pool , 1 ) ; don t restor connect now , sinc i have test poller space i = actual poller size ; connect count = count ; poll . destroi ( poller i ) ; poller i = new poller ; } } process socket timeout ( get so timeout ( ) 0 maintain 1000 run ) { thi work us onli timeout mechan everyth , non event poller might bit faster us old maintain . maintain = 0 ; maintain ( ) ; } } catch ( throwabl t ) { except util . handl throwabl ( t ) ; ( maintain = = 0 ) { get log ( ) . warn ( sm . get string ( endpoint . timeout . error ) , t ) ; } els { get log ( ) . warn ( sm . get string ( endpoint . poll . error ) , t ) ; } } } synchron ( thi ) { thi . notifi all ( ) ; } }	public void duplic ( socket list copi ) { copi . size = size ; copi . po = po ; system . arraycopi ( socket , 0 , copi . socket , 0 , size ) ; system . arraycopi ( timeout , 0 , copi . timeout , 0 , size ) ; system . arraycopi ( flag , 0 , copi . flag , 0 , size ) ; }	public poller get poller ( ) { return poller ; }	public void duplic ( socket list copi ) { copi . size = size ; copi . po = po ; system . arraycopi ( socket , 0 , copi . socket , 0 , size ) ; system . arraycopi ( timeout , 0 , copi . timeout , 0 , size ) ; system . arraycopi ( flag , 0 , copi . flag , 0 , size ) ; }	protect log get log ( ) { return log ; }	start apr endpoint , creat acceptor , poller sendfil thread . overrid public void start intern ( ) throw except { ( run ) { run = true ; paus = fals ; creat worker collect ( get executor ( ) = = null ) { creat executor ( ) ; } initi connect latch ( ) ; start poller thread poller = new poller ( ) ; poller . init ( ) ; thread poller thread = new thread ( poller , get name ( ) poller ) ; poller thread . set prioriti ( thread prioriti ) ; poller thread . set daemon ( true ) ; poller thread . start ( ) ; start sendfil thread ( us sendfil ) { sendfil = new sendfil ( ) ; sendfil . init ( ) ; thread sendfil thread = new thread ( sendfil , get name ( ) sendfil ) ; sendfil thread . set prioriti ( thread prioriti ) ; sendfil thread . set daemon ( true ) ; sendfil thread . start ( ) ; } start acceptor thread ( ) ; start async timeout thread thread timeout thread = new thread ( new async timeout ( ) , get name ( ) async timeout ) ; timeout thread . set prioriti ( thread prioriti ) ; timeout thread . set daemon ( true ) ; timeout thread . start ( ) ; } }	stop endpoint . thi caus all process thread stop . overrid public void stop intern ( ) { releas connect latch ( ) ; ( paus ) { paus ( ) ; } ( run ) { run = fals ; unlock accept ( ) ; ( abstract endpoint . acceptor acceptor : acceptor ) { long wait left = 10000 ; while ( wait left 0 acceptor . get state ( ) = acceptor state . end server sock = 0 ) { try { thread . sleep ( 50 ) ; } catch ( interrupt except e ) { ignor } wait left = 50 ; } ( wait left = = 0 ) { log . warn ( sm . get string ( endpoint . warn . unlock acceptor fail , acceptor . get thread name ( ) ) ) ; hard socket close . ( server sock = 0 ) { socket . shutdown ( server sock , socket . apr shutdown read ) ; server sock = 0 ; } } } try { poller . destroi ( ) ; } catch ( except e ) { ignor } poller = null ; connect . clear ( ) ; ( us sendfil ) { try { sendfil . destroi ( ) ; } catch ( except e ) { ignor } sendfil = null ; } } shutdown executor ( ) ; }
privat void check thread local leak ( ) { thread thread = get thread ( ) ; try { make field thread class store thread local access field thread local field = thread . class . get declar field ( thread local ) ; thread local field . set access ( true ) ; field inherit thread local field = thread . class . get declar field ( inherit thread local ) ; inherit thread local field . set access ( true ) ; make underli arrai thread load . thread local map . entri object access class tlm class = class . name ( java . lang . thread local thread local map ) ; field tabl field = tlm class . get declar field ( tabl ) ; tabl field . set access ( true ) ; method expung stale entri method = tlm class . get declar method ( expung stale entri ) ; expung stale entri method . set access ( true ) ; ( int i = 0 ; i thread . length ; i ) { object thread local map ; ( thread i = null ) { clear first map thread local map = thread local field . get ( thread i ) ; ( null = thread local map ) { expung stale entri method . invok ( thread local map ) ; check thread local map leak ( thread local map , tabl field ) ; } clear second map thread local map = inherit thread local field . get ( thread i ) ; ( null = thread local map ) { expung stale entri method . invok ( thread local map ) ; check thread local map leak ( thread local map , tabl field ) ; } } } } catch ( secur except e ) { log . warn ( sm . get string ( webapp class loader . check thread local leak fail , get context name ( ) ) , e ) ; } catch ( field except e ) { log . warn ( sm . get string ( webapp class loader . check thread local leak fail , get context name ( ) ) , e ) ; } catch ( class found except e ) { log . warn ( sm . get string ( webapp class loader . check thread local leak fail , get context name ( ) ) , e ) ; } catch ( illeg argument except e ) { log . warn ( sm . get string ( webapp class loader . check thread local leak fail , get context name ( ) ) , e ) ; } catch ( illeg access except e ) { log . warn ( sm . get string ( webapp class loader . check thread local leak fail , get context name ( ) ) , e ) ; } catch ( invoc target except e ) { log . warn ( sm . get string ( webapp class loader . check thread local leak fail , get context name ( ) ) , e ) ; } catch ( method except e ) { log . warn ( sm . get string ( webapp class loader . check thread local leak fail , get context name ( ) ) , e ) ; } }

privat elcontext impl el context ; overrid public elcontext get elcontext ( ) { instead decor return thi . invok jsp ctxt . get elcontext ( ) ; ( thi . el context = null ) { jsp factori jsp fact = jsp factori . get default factori ( ) ; servlet context servlet context = thi . get servlet context ( ) ; jsp applic context impl jsp ctx = ( jsp applic context impl ) jsp fact . get jsp applic context ( servlet context ) ; thi . el context = jsp ctx . creat elcontext ( thi ) ; } return thi . el context ; }	overrid public http session get session ( ) { return invok jsp ctxt . get session ( ) ; }	overrid public jsp writer get out ( ) { return invok jsp ctxt . get out ( ) ; }	overrid public object find attribut ( string name ) { ( name = = null ) { throw new null pointer except ( local . get messag ( jsp . error . attribut . null name ) ) ; } object o = page attribut . get ( name ) ; ( o = = null ) { o = invok jsp ctxt . get attribut ( name , request scope ) ; ( o = = null ) { ( get session ( ) = null ) { o = invok jsp ctxt . get attribut ( name , session scope ) ; } ( o = = null ) { o = invok jsp ctxt . get attribut ( name , applic scope ) ; } } } return o ; }	overrid public object get attribut ( string name , int scope ) { ( name = = null ) { throw new null pointer except ( local . get messag ( jsp . error . attribut . null name ) ) ; } ( scope = = page scope ) { return page attribut . get ( name ) ; } return invok jsp ctxt . get attribut ( name , scope ) ; }	overrid public servlet context get servlet context ( ) { return invok jsp ctxt . get servlet context ( ) ; }	overrid public servlet respons get respons ( ) { return invok jsp ctxt . get respons ( ) ; }	overrid public enumer string get attribut name scope ( int scope ) { ( scope = = page scope ) { return collect . enumer ( page attribut . kei set ( ) ) ; } return invok jsp ctxt . get attribut name scope ( scope ) ; }	overrid public void remov attribut ( string name ) { ( name = = null ) { throw new null pointer except ( local . get messag ( jsp . error . attribut . null name ) ) ; } page attribut . remov ( name ) ; invok jsp ctxt . remov attribut ( name , request scope ) ; ( get session ( ) = null ) { invok jsp ctxt . remov attribut ( name , session scope ) ; } invok jsp ctxt . remov attribut ( name , applic scope ) ; }	overrid public void remov attribut ( string name , int scope ) { ( name = = null ) { throw new null pointer except ( local . get messag ( jsp . error . attribut . null name ) ) ; } ( scope = = page scope ) { page attribut . remov ( name ) ; } els { invok jsp ctxt . remov attribut ( name , scope ) ; } }	overrid public void set attribut ( string name , object valu , int scope ) { ( name = = null ) { throw new null pointer except ( local . get messag ( jsp . error . attribut . null name ) ) ; } ( scope = = page scope ) { ( valu = null ) { page attribut . put ( name , valu ) ; } els { remov attribut ( name , page scope ) ; } } els { invok jsp ctxt . set attribut ( name , valu , scope ) ; } }
send messag destin specifi param destin member destin . length 1 param msg serializ messag send param option int sender option , option can trigger guarante level differ interceptor react messag see class document code channel code object . br return uniqu id uniqu id wa assign thi messag throw channel except error occur process messag see org . apach . catalina . tribe . channel overrid public uniqu id send ( member destin , serializ msg , int option ) throw channel except { return send ( destin , msg , option , null ) ; }	send heartbeat through interceptor stack . br invok thi method from applic period basi you have turn off intern heartbeat code channel . set heartbeat ( fals ) code overrid public void heartbeat ( ) { super . heartbeat ( ) ; iter object i = membership listen . iter ( ) ; while ( i . ha next ( ) ) { object o = i . next ( ) ; ( o instanceof heartbeat ) ( ( heartbeat ) o ) . heartbeat ( ) ; } i = channel listen . iter ( ) ; while ( i . ha next ( ) ) { object o = i . next ( ) ; ( o instanceof heartbeat ) ( ( heartbeat ) o ) . heartbeat ( ) ; } }
process given javac compil error . param detail arrai javac error detail instanc correspond compil error overrid public void javac error ( javac error detail detail ) throw jasper except { ( detail = = null ) { return ; } object arg = null ; string builder buf = new string builder ( ) ; ( int i = 0 ; i detail . length ; i ) { ( detail i . get jsp begin line number ( ) = 0 ) { arg = new object { integ . valu ( detail i . get jsp begin line number ( ) ) , detail i . get jsp file name ( ) } ; buf . append ( constant . newlin ) ; buf . append ( constant . newlin ) ; buf . append ( local . get messag ( jsp . error . singl . line . number , arg ) ) ; buf . append ( constant . newlin ) ; buf . append ( detail i . get error messag ( ) ) ; buf . append ( constant . newlin ) ; buf . append ( detail i . get jsp extract ( ) ) ; } els { arg = new object { integ . valu ( detail i . get java line number ( ) ) } ; buf . append ( constant . newlin ) ; buf . append ( constant . newlin ) ; buf . append ( local . get messag ( jsp . error . java . line . number , arg ) ) ; buf . append ( constant . newlin ) ; buf . append ( detail i . get error messag ( ) ) ; } } buf . append ( constant . newlin ) ; buf . append ( constant . newlin ) ; buf . append ( stacktrac : ) ; throw new jasper except ( local . get messag ( jsp . error . unabl . compil ) : buf ) ; }
protect return role associ given user name param db connect databas connect us param usernam usernam which role should retriev arrai list string get role ( connect db connect , string usernam ) { ( all role mode = all role mode . strict mode role store defin ( ) ) { been defin so don t spend cycl look return null ; } result set rs = null ; prepar statement stmt = null ; arrai list string list = null ; try { stmt = role ( db connect , usernam ) ; rs = stmt . execut queri ( ) ; list = new arrai list ( ) ; while ( rs . next ( ) ) { string role = rs . get string ( 1 ) ; ( role = null ) { list . add ( role . trim ( ) ) ; } } return list ; } catch ( sqlexcept e ) { contain log . error ( sm . get string ( data sourc realm . get role . except , usernam ) ) ; } final { try { ( rs = null ) { rs . close ( ) ; } ( stmt = null ) { stmt . close ( ) ; } } catch ( sqlexcept e ) { contain log . error ( sm . get string ( data sourc realm . get role . except , usernam ) ) ; } } return null ; }	protect return password associ given princip s user name . param db connect databas connect us param usernam usernam which password should retriev string get password ( connect db connect , string usernam ) { result set rs = null ; prepar statement stmt = null ; string db credenti = null ; try { stmt = credenti ( db connect , usernam ) ; rs = stmt . execut queri ( ) ; ( rs . next ( ) ) { db credenti = rs . get string ( 1 ) ; } return ( db credenti = null ) db credenti . trim ( ) : null ; } catch ( sqlexcept e ) { contain log . error ( sm . get string ( data sourc realm . get password . except , usernam ) ) ; } final { try { ( rs = null ) { rs . close ( ) ; } ( stmt = null ) { stmt . close ( ) ; } } catch ( sqlexcept e ) { contain log . error ( sm . get string ( data sourc realm . get password . except , usernam ) ) ; } } return null ; }
protect void do get ( http servlet request req , http servlet respons resp ) throw servlet except , ioexcept { resp . set content type ( text plain ) ; resp . get writer ( ) . print ( env entri : env entri ) ; }	protect make sure annot cach ha been popul provid class . param clazz clazz popul annot param inject map inject thi class from xml deploy descriptor throw illeg access except inject target inaccess throw javax . name . name except valu cannot look up jndi throw java . lang . reflect . invoc target except inject fail void popul annot cach ( class clazz , map string , string inject ) throw illeg access except , invoc target except , name except { list annot cach entri annot = null ; while ( clazz = null ) { annot cach entri annot arrai = null ; synchron ( annot cach ) { annot arrai = annot cach . get ( clazz ) ; } ( annot arrai = = null ) { ( annot = = null ) { annot = new arrai list ( ) ; } els { annot . clear ( ) ; } ( context = null ) { initi field annot resourc inject jndi enabl field field = introspect . get declar field ( clazz ) ; ( field field : field ) { ( inject = null inject . contain kei ( field . get name ( ) ) ) { annot . add ( new annot cach entri ( field . get name ( ) , null , inject . get ( field . get name ( ) ) , annot cach entri type . field ) ) ; } els ( field . annot present ( resourc . class ) ) { resourc annot = field . get annot ( resourc . class ) ; annot . add ( new annot cach entri ( field . get name ( ) , null , annot . name ( ) , annot cach entri type . field ) ) ; } els ( field . annot present ( ejb . class ) ) { ejb annot = field . get annot ( ejb . class ) ; annot . add ( new annot cach entri ( field . get name ( ) , null , annot . name ( ) , annot cach entri type . field ) ) ; } els ( field . annot present ( web servic ref . class ) ) { web servic ref annot = field . get annot ( web servic ref . class ) ; annot . add ( new annot cach entri ( field . get name ( ) , null , annot . name ( ) , annot cach entri type . field ) ) ; } els ( field . annot present ( persist context . class ) ) { persist context annot = field . get annot ( persist context . class ) ; annot . add ( new annot cach entri ( field . get name ( ) , null , annot . name ( ) , annot cach entri type . field ) ) ; } els ( field . annot present ( persist unit . class ) ) { persist unit annot = field . get annot ( persist unit . class ) ; annot . add ( new annot cach entri ( field . get name ( ) , null , annot . name ( ) , annot cach entri type . field ) ) ; } } } initi method annot method method = introspect . get declar method ( clazz ) ; method post construct = null ; string post construct from xml = post construct method . get ( clazz . get name ( ) ) ; method pre destroi = null ; string pre destroi from xml = pre destroi method . get ( clazz . get name ( ) ) ; ( method method : method ) { ( context = null ) { resourc inject onli jndi enabl ( inject = null introspect . valid setter ( method ) ) { string field name = introspect . get properti name ( method ) ; ( inject . contain kei ( field name ) ) { annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , inject . get ( method . get name ( ) ) , annot cach entri type . setter ) ) ; break ; } } ( method . annot present ( resourc . class ) ) { resourc annot = method . get annot ( resourc . class ) ; annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , annot . name ( ) , annot cach entri type . setter ) ) ; } els ( method . annot present ( ejb . class ) ) { ejb annot = method . get annot ( ejb . class ) ; annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , annot . name ( ) , annot cach entri type . setter ) ) ; } els ( method . annot present ( web servic ref . class ) ) { web servic ref annot = method . get annot ( web servic ref . class ) ; annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , annot . name ( ) , annot cach entri type . setter ) ) ; } els ( method . annot present ( persist context . class ) ) { persist context annot = method . get annot ( persist context . class ) ; annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , annot . name ( ) , annot cach entri type . setter ) ) ; } els ( method . annot present ( persist unit . class ) ) { persist unit annot = method . get annot ( persist unit . class ) ; annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , annot . name ( ) , annot cach entri type . setter ) ) ; } } post construct = find post construct ( post construct , post construct from xml , method ) ; pre destroi = find pre destroi ( pre destroi , pre destroi from xml , method ) ; } ( post construct = null ) { annot . add ( new annot cach entri ( post construct . get name ( ) , post construct . get paramet type ( ) , null , annot cach entri type . post construct ) ) ; } els ( post construct from xml = null ) { throw new illeg argument except ( post construct method post construct from xml class clazz . get name ( ) declar deploy descriptor cannot found . ) ; } ( pre destroi = null ) { annot . add ( new annot cach entri ( pre destroi . get name ( ) , pre destroi . get paramet type ( ) , null , annot cach entri type . pre destroi ) ) ; } els ( pre destroi from xml = null ) { throw new illeg argument except ( pre destroi method pre destroi from xml class clazz . get name ( ) declar deploy descriptor cannot found . ) ; } ( annot . empti ( ) ) { us common object save memori annot arrai = annot empti ; } els { annot arrai = annot . arrai ( new annot cach entri annot . size ( ) ) ; } synchron ( annot cach ) { annot cach . put ( clazz , annot arrai ) ; } } clazz = clazz . get superclass ( ) ; } }	test public void test bug54379 ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; file app dir = new file ( test webapp 3 . 0 fragment ) ; context context = tomcat . add webapp ( null , test , app dir . get absolut path ( ) ) ; tomcat . add servlet ( context , test servlet , org . apach . catalina . startup . tester servlet life cycl method ) ; context . add servlet map ( test servlet , test servlet ) ; tomcat . enabl name ( ) ; tomcat . start ( ) ; assert page contain ( test test servlet , post construct1 ( ) ) ; }	test public void test bug54448 ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; file app dir = new file ( test webapp 3 . 0 fragment ) ; context context = tomcat . add webapp ( null , test , app dir . get absolut path ( ) ) ; tomcat . add servlet ( context , test servlet , org . apach . catalina . startup . tester servlet annot ) ; context . add servlet map ( test servlet , test servlet ) ; tomcat . enabl name ( ) ; tomcat . start ( ) ; assert page contain ( test test servlet , env entri : 1 ) ; }
privat class convert primit type ( class clazz ) { ( clazz . equal ( char . class ) ) { return charact . class ; } els ( clazz . equal ( int . class ) ) { return integ . class ; } els ( clazz . equal ( boolean . class ) ) { return boolean . class ; } els ( clazz . equal ( doubl . class ) ) { return doubl . class ; } els ( clazz . equal ( byte . class ) ) { return byte . class ; } els ( clazz . equal ( short . class ) ) { return short . class ; } els ( clazz . equal ( long . class ) ) { return long . class ; } els ( clazz . equal ( float . class ) ) { return float . class ; } els { return clazz ; } }	static string get type ( resourc annot , string default type ) { string type = annot . type ( ) . get canon name ( ) ; ( type = = null type . equal ( java . lang . object ) ) { ( default type = null ) { type = default type ; } } return type ; }	protect static void add resourc ( context context , resourc annot , string default name , string default type ) { string name = get name ( annot , default name ) ; string type = get type ( annot , default type ) ; ( type . equal ( java . lang . string ) type . equal ( java . lang . charact ) type . equal ( java . lang . integ ) type . equal ( java . lang . boolean ) type . equal ( java . lang . doubl ) type . equal ( java . lang . byte ) type . equal ( java . lang . short ) type . equal ( java . lang . long ) type . equal ( java . lang . float ) ) { env ref element context environ resourc = new context environ ( ) ; resourc . set name ( name ) ; resourc . set type ( type ) ; resourc . set descript ( annot . descript ( ) ) ; resourc . set valu ( annot . map name ( ) ) ; context . get name resourc ( ) . add environ ( resourc ) ; } els ( type . equal ( javax . xml . rpc . servic ) ) { servic ref element context servic servic = new context servic ( ) ; servic . set name ( name ) ; servic . set wsdlfile ( annot . map name ( ) ) ; servic . set type ( type ) ; servic . set descript ( annot . descript ( ) ) ; context . get name resourc ( ) . add servic ( servic ) ; } els ( type . equal ( javax . sql . data sourc ) type . equal ( javax . jm . connect factori ) type . equal ( javax . jm . queue connect factori ) type . equal ( javax . jm . topic connect factori ) type . equal ( javax . mail . session ) type . equal ( java . net . url ) type . equal ( javax . resourc . cci . connect factori ) type . equal ( org . omg . corba 2 3 . orb ) type . end ( connect factori ) ) { resourc ref element context resourc resourc = new context resourc ( ) ; resourc . set name ( name ) ; resourc . set type ( type ) ; ( annot . authent type ( ) = = resourc . authent type . contain ) { resourc . set auth ( contain ) ; } } }	protect static void load field annot ( context context , class class class ) { initi annot field field = introspect . get declar field ( class class ) ; ( field = null field . length 0 ) { ( field field : field ) { ( field . annot present ( resourc . class ) ) { resourc annot = field . get annot ( resourc . class ) ; string default name = class class . get name ( ) separ field . get name ( ) ; string default type = field . get type ( ) . get canon name ( ) ; add resourc ( context , annot , default name , default type ) ; } } } }	protect static void load method annot ( context context , class class class ) { initi annot method method = introspect . get declar method ( class class ) ; ( method = null method . length 0 ) { ( method method : method ) { ( method . annot present ( resourc . class ) ) { resourc annot = method . get annot ( resourc . class ) ; ( introspect . valid setter ( method ) ) { throw new illeg argument except ( sm . get string ( web annot set . invalid inject ) ) ; } string default name = class class . get name ( ) separ introspect . get properti name ( method ) ; string default type = ( method . get paramet type ( ) 0 ) . get canon name ( ) ; add resourc ( context , annot , default name , default type ) ; } } } }	public static attempt load class us given contain s class loader . class cannot load , debug level log messag written contain s log null return . class load class ( context context , string class name ) { class loader cl = context . get loader ( ) . get class loader ( ) ; log log = context . get logger ( ) ; class clazz = null ; try { clazz = cl . load class ( class name ) ; } catch ( class found except e ) { log . debug ( sm . get string ( introspect . class load fail ) , e ) ; } catch ( class def found error e ) { log . debug ( sm . get string ( introspect . class load fail ) , e ) ; } catch ( class format error e ) { log . debug ( sm . get string ( introspect . class load fail ) , e ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . debug ( sm . get string ( introspect . class load fail ) , t ) ; } return clazz ; }	test public void test bug54379 ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; file app dir = new file ( test webapp 3 . 0 fragment ) ; context context = tomcat . add webapp ( null , test , app dir . get absolut path ( ) ) ; tomcat . add servlet ( context , test servlet , org . apach . catalina . startup . tester servlet life cycl method ) ; context . add servlet map ( test servlet , test servlet ) ; tomcat . enabl name ( ) ; tomcat . start ( ) ; assert page contain ( test test servlet , post construct1 ( ) ) ; }
public void set sslverifi depth ( int sslverifi depth ) { ( ( apr endpoint ) endpoint ) . set sslverifi depth ( sslverifi depth ) ; }	public boolean get sslhonor cipher order ( ) { return sslhonor cipher order ; }	initi endpoint . overrid public void bind ( ) throw except { creat root apr memori pool try { root pool = pool . creat ( 0 ) ; } catch ( unsatisfi link error e ) { throw new except ( sm . get string ( endpoint . init . notavail ) ) ; } creat pool server socket server sock pool = pool . creat ( root pool ) ; creat apr address bound string address str = null ; ( get address ( ) = null ) { address str = get address ( ) . get host address ( ) ; } int famili = socket . apr inet ; ( librari . apr have ipv6 ) { ( address str = = null ) { ( os . bsd os . win32 os . win64 ) famili = socket . apr unspec ; } els ( address str . index ( : ) = 0 ) { famili = socket . apr unspec ; } } long inet address = address . info ( address str , famili , get port ( ) , 0 , root pool ) ; creat apr server socket server sock = socket . creat ( address . get info ( inet address ) . famili , socket . sock stream , socket . apr proto tcp , root pool ) ; ( os . unix ) { socket . opt set ( server sock , socket . apr so reuseaddr , 1 ) ; } deal firewal tend drop inact socket socket . opt set ( server sock , socket . apr so keepal , 1 ) ; bind server socket int ret = socket . bind ( server sock , inet address ) ; ( ret = 0 ) { throw new except ( sm . get string ( endpoint . init . bind , ret , error . strerror ( ret ) ) ) ; } start listen server socket ret = socket . listen ( server sock , get backlog ( ) ) ; ( ret = 0 ) { throw new except ( sm . get string ( endpoint . init . listen , ret , error . strerror ( ret ) ) ) ; } ( os . win32 os . win64 ) { window set reuseaddr flag after bind listen socket . opt set ( server sock , socket . apr so reuseaddr , 1 ) ; } sendfil usag system which don t support caus major problem ( us sendfil librari . apr ha sendfil ) { us sendfil = fals ; } initi thread count default acceptor ( acceptor thread count = = 0 ) { fixm : doesn t seem work well multipl accept thread acceptor thread count = 1 ; } other platform thi call noop return apr enotimpl . ( defer accept ) { ( socket . opt set ( server sock , socket . apr tcp defer accept , 1 ) = = statu . apr enotimpl ) { defer accept = fals ; } } initi ssl need ( sslenabl ( ) ) { ( sslcertif file = = null ) { thi requir throw new except ( sm . get string ( endpoint . apr . ssl cert file ) ) ; } ssl protocol int valu = ssl . ssl protocol none ; ( sslprotocol = = null sslprotocol . length ( ) = = 0 ) { valu = ssl . ssl protocol all ; } els { ( string protocol : sslprotocol . split ( ) ) { protocol = protocol . trim ( ) ; ( sslv2 . equal ignor case ( protocol ) ) { valu = ssl . ssl protocol sslv2 ; } els ( sslv3 . equal ignor case ( protocol ) ) { valu = ssl . ssl protocol sslv3 ; } els ( tlsv1 . equal ignor case ( protocol ) ) { valu = ssl . ssl protocol tlsv1 ; } els ( all . equal ignor case ( protocol ) ) { valu = ssl . ssl protocol all ; } els { requir throw new except ( sm . get string ( endpoint . apr . invalid ssl protocol , sslprotocol ) ) ; } } } creat ssl context ssl context = sslcontext . make ( root pool , valu , ssl . ssl mode server ) ; ( sslinsecur renegoti ) { boolean legaci reneg support = fals ; try { legaci reneg support = ssl . ha op ( ssl . ssl op allow unsaf legaci renegoti ) ; ( legaci reneg support ) sslcontext . set option ( ssl context , ssl . ssl op allow unsaf legaci renegoti ) ; } catch ( unsatisfi link error e ) { ignor } ( legaci reneg support ) { open ssl doe support unsaf legaci renegoti . log . warn ( sm . get string ( endpoint . warn . insecur reneg , ssl . version string ( ) ) ) ; } } set cipher order : client ( default ) server ( sslhonor cipher order ) { boolean order cipher support = fals ; try { order cipher support = ssl . ha op ( ssl . ssl op cipher server prefer ) ; ( order cipher support ) sslcontext . set option ( ssl context , ssl . ssl op cipher server prefer ) ; } catch ( unsatisfi link error e ) { ignor } ( order cipher support ) { open ssl doe support cipher order . log . warn ( sm . get string ( endpoint . warn . honor cipher order , ssl . version string ( ) ) ) ; } } list cipher client permit negoti sslcontext . set cipher suit ( ssl context , sslcipher suit ) ; load server kei certif sslcontext . set certif ( ssl context , sslcertif file , sslcertif kei file , sslpassword , ssl . ssl aidx rsa ) ; set certif chain file sslcontext . set certif chain file ( ssl context , sslcertif chain file , fals ) ; support client certif sslcontext . set cacertif ( ssl context , sslcacertif file , sslcacertif path ) ; set revoc sslcontext . set carevoc ( ssl context , sslcarevoc file , sslcarevoc path ) ; client certif verif valu = ssl . ssl cverifi none ; ( option . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi option ; } els ( requir . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi requir ; } els ( option ca . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi option ca ; } sslcontext . set verifi ( ssl context , valu , sslverifi depth ) ; now , sendfil support ssl us sendfil = fals ; } }
return princip associ specifi usernam , which match digest calcul us given paramet us method describ rfc 2069 ; otherwis return code null code . param usernam usernam princip look up param client digest digest which ha been submit client param nonc uniqu ( supposedli uniqu ) token which ha been us thi request param realm realm name param md5a2 second md5 digest us calcul digest : md5 ( method : uri ) overrid public princip authent ( string usernam , string client digest , string nonc , string nc , string cnonc , string qop , string realm , string md5a2 ) { digest auth , digest ar alwai lower case string md5a1 = get digest ( usernam , realm ) . lower case ( local . english ) ; ( md5a1 = = null ) return null ; string server digest valu ; ( qop = = null ) { server digest valu = md5a1 : nonc : md5a2 ; } els { server digest valu = md5a1 : nonc : nc : cnonc : qop : md5a2 ; } byte valu byte = null ; try { valu byte = server digest valu . get byte ( get digest charset ( ) ) ; } catch ( unsupport encod except uee ) { log . error ( illeg digest encod : get digest encod ( ) , uee ) ; throw new illeg argument except ( uee . get messag ( ) ) ; } string server digest = null ; bugzilla 32137 synchron ( md5helper ) { server digest = md5encod . encod ( md5helper . digest ( valu byte ) ) ; } ( log . debug enabl ( ) ) { log . debug ( digest : client digest usernam : usernam client sigest : client digest nonc : nonc nc : nc cnonc : cnonc qop : qop realm : realm md5a2 : md5a2 server digest : server digest ) ; } ( server digest . equal ( client digest ) ) { return get princip ( usernam ) ; } return null ; }
protect initi classload need given compil context . param clctxt compil context throw ioexcept error occur void init class loader ( jsp compil context clctxt ) throw ioexcept { class path = get class path ( ) ; class loader jspc loader = get class ( ) . get class loader ( ) ; ( jspc loader instanceof ant class loader ) { class path = file . path separ ( ( ant class loader ) jspc loader ) . get classpath ( ) ; } turn class path url arrai list url url = new arrai list ( ) ; string token token = new string token ( class path , file . path separ ) ; while ( token . ha more token ( ) ) { string path = token . next token ( ) ; try { file lib file = new file ( path ) ; url . add ( lib file . uri ( ) . url ( ) ) ; } catch ( ioexcept ioe ) { therefor we have permiss freak uot throw new runtim except ( ioe . string ( ) ) ; } } file webapp base = new file ( uri root ) ; ( webapp base . exist ( ) ) { file class = new file ( webapp base , web inf class ) ; try { ( class . exist ( ) ) { class path = class path file . path separ class . get canon path ( ) ; url . add ( class . get canon file ( ) . uri ( ) . url ( ) ) ; } } catch ( ioexcept ioe ) { therefor we have permiss freak out throw new runtim except ( ioe . string ( ) ) ; } file lib = new file ( webapp base , web inf lib ) ; ( lib . exist ( ) lib . directori ( ) ) { string lib = lib . list ( ) ; ( int i = 0 ; i lib . length ; i ) { ( lib i . length ( ) 5 ) continu ; string ext = lib i . substr ( lib i . length ( ) 4 ) ; ( . jar . equal ignor case ( ext ) ) { ( . tld . equal ignor case ( ext ) ) { log . warn ( tld file should place web inf lib ) ; } continu ; } try { file lib file = new file ( lib , lib i ) ; class path = class path file . path separ lib file . get absolut path ( ) ; url . add ( lib file . get absolut file ( ) . uri ( ) . url ( ) ) ; } catch ( ioexcept ioe ) { therefor we have permiss freak out throw new runtim except ( ioe . string ( ) ) ; } } } } what thi url . add ( new file ( clctxt . get real path ( ) ) . get canon file ( ) . uri ( ) . url ( ) ) ; url url = new url url . size ( ) ; url . arrai ( url ) ; loader = new urlclass loader ( url , thi . get class ( ) . get class loader ( ) ) ; }	overrid public class loader get class loader ( ) { return null ; }
privat configur given ssl server socket request cipher suit , protocol version , need client authent void init server socket ( server socket ssocket ) { sslserver socket socket = ( sslserver socket ) ssocket ; ( enabl cipher = null ) { socket . set enabl cipher suit ( enabl cipher ) ; } string request protocol = endpoint . get ssl enabl protocol arrai ( ) ; set enabl protocol ( socket , get enabl protocol ( socket , request protocol ) ) ; we don t know client auth need after pars request we mai re handshak configur client auth ( socket ) ; }	protect load collect crl . collect extend crl get crl ( string crlf ) throw ioexcept , crlexcept , certif except { file crl file = new file ( crlf ) ; ( crl file . absolut ( ) ) { crl file = new file ( system . get properti ( constant . catalina base prop ) , crlf ) ; } collect extend crl crl = null ; input stream = null ; try { certif factori cf = certif factori . get instanc ( x . 509 ) ; = new file input stream ( crl file ) ; crl = cf . gener crl ( ) ; } catch ( ioexcept iex ) { throw iex ; } catch ( crlexcept crle ) { throw crle ; } catch ( certif except ce ) { throw ce ; } final { ( = null ) { try { . close ( ) ; } catch ( except ex ) { ignor } } } return crl ; }	protect sslengin creat sslengin ( ) { sslengin engin = ssl context . creat sslengin ( ) ; ( fals . equal ( get client auth ( ) ) ) { engin . set need client auth ( fals ) ; engin . set want client auth ( fals ) ; } els ( true . equal ( get client auth ( ) ) ye . equal ( get client auth ( ) ) ) { engin . set need client auth ( true ) ; } els ( want . equal ( get client auth ( ) ) ) { engin . set want client auth ( true ) ; } engin . set us client mode ( fals ) ; ( get cipher arrai ( ) . length 0 ) engin . set enabl cipher suit ( get cipher arrai ( ) ) ; ( get ssl enabl protocol arrai ( ) . length 0 ) engin . set enabl protocol ( get ssl enabl protocol arrai ( ) ) ; handler . creat sslengin ( engin ) ; return engin ; }	protect string get enabl protocol ( sslserver socket socket , string request protocol ) { string support protocol = socket . get support protocol ( ) ; string enabl protocol = null ; ( request protocol = null request protocol . length 0 ) { vector string vec = null ; ( string protocol : request protocol ) { check see request protocol among support protocol , i . e . , mai enabl ( int i = 0 ; support protocol = null i support protocol . length ; i ) { ( support protocol i . equal ( protocol ) ) { ( vec = = null ) { vec = new vector ( ) ; } vec . add element ( protocol ) ; break ; } } } ( vec = null ) { enabl protocol = new string vec . size ( ) ; vec . copi ( enabl protocol ) ; } } return enabl protocol ; }	overrid public string get cipher us ( ) { sslcontext ssl context = get sslcontext ( ) ; ( ssl context = null ) { sslengin engin = get sslcontext ( ) . creat sslengin ( ) ; ( get cipher arrai ( ) . length 0 ) { engin . set enabl cipher suit ( get cipher arrai ( ) ) ; } return engin . get enabl cipher suit ( ) ; } els { return new string 0 ; } }	public kei manag wrap ( kei manag manag ) { ( manag = = null ) return null ; kei manag result = new kei manag manag . length ; ( int i = 0 ; i result . length ; i ) { ( manag i instanceof x509kei manag get kei alia ( ) = null ) { result i = new nio x509kei manag ( ( x509kei manag ) manag i , get kei alia ( ) ) ; } els { result i = manag i ; } } return result ; }	public string get enabl cipher ( ) { return enabl cipher ; }	public void set sslcontext ( sslcontext c ) { ssl context = c ; }	read keystor initi ssl socket factori . void init ( ) throw ioexcept { try { string client auth str = endpoint . get client auth ( ) ; ( true . equal ignor case ( client auth str ) ye . equal ignor case ( client auth str ) ) { requir client auth = true ; } els ( want . equal ignor case ( client auth str ) ) { want client auth = true ; } sslcontext context = creat sslcontext ( ) ; context . init ( get kei manag ( ) , get trust manag ( ) , null ) ; configur ssl session cach sslsession context session context = context . get server session context ( ) ; ( session context = null ) { configur session context ( session context ) ; } creat proxi ssl proxi = context . get server socket factori ( ) ; determin which cipher suit enabl string request cipher = endpoint . get cipher ( ) ; enabl cipher = get enabl cipher ( request cipher , ssl proxi . get support cipher suit ( ) ) ; allow unsaf legaci renegoti = true . equal ( endpoint . get allow unsaf legaci renegoti ( ) ) ; check ssl config ok check config ( ) ; } catch ( except e ) { ( e instanceof ioexcept ) throw ( ioexcept ) e ; throw new ioexcept ( e . get messag ( ) , e ) ; } }
public map string , string get servlet map ( ) { return servlet map ; }	test public void test lifecycl method web fragment conflict ( ) { web xml webxml = new web xml ( ) ; web xml fragment1 = new web xml ( ) ; fragment1 . add post construct method ( , ) ; fragment1 . add pre destroi method ( b , ) ; web xml fragment2 = new web xml ( ) ; fragment2 . add post construct method ( , b ) ; set web xml fragment = new hash set ( ) ; fragment . add ( fragment1 ) ; fragment . add ( fragment2 ) ; assert . assert fals ( webxml . merg ( fragment ) ) ; assert . assert equal ( 0 , webxml . get post construct method ( ) . size ( ) ) ; web xml fragment3 = new web xml ( ) ; fragment3 . add pre destroi method ( b , b ) ; fragment . remov ( fragment2 ) ; fragment . add ( fragment3 ) ; assert . assert fals ( webxml . merg ( fragment ) ) ; assert . assert equal ( 0 , webxml . get pre destroi method ( ) . size ( ) ) ; }
public static gener sub set web fragment . xml file process order fragment must process per rule servlet spec . param applic applic web . xml file param fragment map fragment name web fragment param servlet context servlet context fragment ar associ return order list web fragment . xml file process set web xml order web fragment ( web xml applic , map string , web xml fragment , servlet context servlet context ) { set web xml order fragment = new link hash set ( ) ; boolean absolut order = ( applic . get absolut order ( ) = null ) ; boolean order present = fals ; ( absolut order ) { order present = true ; onli those fragment list should process set string request order = applic . get absolut order ( ) ; ( string request name : request order ) { ( web xml . order other . equal ( request name ) ) { add all fragment name explicitli thi point ( entri string , web xml entri : fragment . entri set ( ) ) { ( request order . contain ( entri . get kei ( ) ) ) { web xml fragment = entri . get valu ( ) ; ( fragment = null ) { order fragment . add ( fragment ) ; } } } } els { web xml fragment = fragment . get ( request name ) ; ( fragment = null ) { order fragment . add ( fragment ) ; } els { log . warn ( sm . get string ( web xml . wrong fragment name , request name ) ) ; } } } } els { next stage simpler . ( web xml fragment : fragment . valu ( ) ) { iter string befor = fragment . get befor order ( ) . iter ( ) ; while ( befor . ha next ( ) ) { order present = true ; string befor entri = befor . next ( ) ; ( befor entri . equal ( order other ) ) { web xml befor fragment = fragment . get ( befor entri ) ; ( befor fragment = = null ) { befor . remov ( ) ; } els { befor fragment . add after order ( fragment . get name ( ) ) ; } } } iter string after = fragment . get after order ( ) . iter ( ) ; while ( after . ha next ( ) ) { order present = true ; string after entri = after . next ( ) ; ( after entri . equal ( order other ) ) { web xml after fragment = fragment . get ( after entri ) ; ( after fragment = = null ) { after . remov ( ) ; } els { after fragment . add befor order ( fragment . get name ( ) ) ; } } } } stage doesn t have . ( web xml fragment : fragment . valu ( ) ) { ( fragment . get befor order ( ) . contain ( order other ) ) { make befor other explicit ( fragment . get after order ( ) , fragment ) ; } ( fragment . get after order ( ) . contain ( order other ) ) { make after other explicit ( fragment . get befor order ( ) , fragment ) ; } } stage 3 . separ three group set web xml befor set = new hash set ( ) ; set web xml other set = new hash set ( ) ; set web xml after set = new hash set ( ) ; ( web xml fragment : fragment . valu ( ) ) { ( fragment . get befor order ( ) . contain ( order other ) ) { befor set . add ( fragment ) ; fragment . get befor order ( ) . remov ( order other ) ; } els ( fragment . get after order ( ) . contain ( order other ) ) { after set . add ( fragment ) ; fragment . get after order ( ) . remov ( order other ) ; } els { other set . add ( fragment ) ; } } stage 4 . decoupl group so order requir each fragment group onli refer other fragment group . order requir outsid group handl process group order . note : onli after order requir ar consid . thi ok becaus process stage 1 . decoupl other group ( befor set ) ; decoupl other group ( other set ) ; decoupl other group ( after set ) ; stage 5 . order each group note : onli after order requir ar consid . thi ok becaus process stage 1 . order fragment ( order fragment , befor set ) ; order fragment ( order fragment , other set ) ; order fragment ( order fragment , after set ) ; } avoid npe when unit test ( servlet context = null ) { publish order fragment list string order jar file name = null ; ( order present ) { order jar file name = new arrai list ( ) ; ( web xml fragment : order fragment ) { order jar file name . add ( fragment . get jar name ( ) ) ; } } servlet context . set attribut ( servlet context . order lib , order jar file name ) ; } return order fragment ; }	protect make sure annot cach ha been popul provid class . param clazz clazz popul annot param inject map inject thi class from xml deploy descriptor throw illeg access except inject target inaccess throw javax . name . name except valu cannot look up jndi throw java . lang . reflect . invoc target except inject fail void popul annot cach ( class clazz , map string , string inject ) throw illeg access except , invoc target except , name except { list annot cach entri annot = null ; while ( clazz = null ) { annot cach entri annot arrai = null ; synchron ( annot cach ) { annot arrai = annot cach . get ( clazz ) ; } ( annot arrai = = null ) { ( annot = = null ) { annot = new arrai list ( ) ; } els { annot . clear ( ) ; } ( context = null ) { initi field annot resourc inject jndi enabl field field = introspect . get declar field ( clazz ) ; ( field field : field ) { ( inject = null inject . contain kei ( field . get name ( ) ) ) { annot . add ( new annot cach entri ( field . get name ( ) , null , inject . get ( field . get name ( ) ) , annot cach entri type . field ) ) ; } els ( field . annot present ( resourc . class ) ) { resourc annot = field . get annot ( resourc . class ) ; annot . add ( new annot cach entri ( field . get name ( ) , null , annot . name ( ) , annot cach entri type . field ) ) ; } els ( field . annot present ( ejb . class ) ) { ejb annot = field . get annot ( ejb . class ) ; annot . add ( new annot cach entri ( field . get name ( ) , null , annot . name ( ) , annot cach entri type . field ) ) ; } els ( field . annot present ( web servic ref . class ) ) { web servic ref annot = field . get annot ( web servic ref . class ) ; annot . add ( new annot cach entri ( field . get name ( ) , null , annot . name ( ) , annot cach entri type . field ) ) ; } els ( field . annot present ( persist context . class ) ) { persist context annot = field . get annot ( persist context . class ) ; annot . add ( new annot cach entri ( field . get name ( ) , null , annot . name ( ) , annot cach entri type . field ) ) ; } els ( field . annot present ( persist unit . class ) ) { persist unit annot = field . get annot ( persist unit . class ) ; annot . add ( new annot cach entri ( field . get name ( ) , null , annot . name ( ) , annot cach entri type . field ) ) ; } } } initi method annot method method = introspect . get declar method ( clazz ) ; method post construct = null ; method pre destroi = null ; ( method method : method ) { ( context = null ) { resourc inject onli jndi enabl ( inject = null introspect . valid setter ( method ) ) { string field name = introspect . get properti name ( method ) ; ( inject . contain kei ( field name ) ) { annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , inject . get ( method . get name ( ) ) , annot cach entri type . setter ) ) ; break ; } } ( method . annot present ( resourc . class ) ) { resourc annot = method . get annot ( resourc . class ) ; annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , annot . name ( ) , annot cach entri type . setter ) ) ; } els ( method . annot present ( ejb . class ) ) { ejb annot = method . get annot ( ejb . class ) ; annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , annot . name ( ) , annot cach entri type . setter ) ) ; } els ( method . annot present ( web servic ref . class ) ) { web servic ref annot = method . get annot ( web servic ref . class ) ; annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , annot . name ( ) , annot cach entri type . setter ) ) ; } els ( method . annot present ( persist context . class ) ) { persist context annot = method . get annot ( persist context . class ) ; annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , annot . name ( ) , annot cach entri type . setter ) ) ; } els ( method . annot present ( persist unit . class ) ) { persist unit annot = method . get annot ( persist unit . class ) ; annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , annot . name ( ) , annot cach entri type . setter ) ) ; } } ( method . annot present ( post construct . class ) ) { ( ( post construct = null ) ( method . get paramet type ( ) . length = 0 ) ( modifi . static ( method . get modifi ( ) ) ) ( method . get except type ( ) . length 0 ) ( method . get return type ( ) . get name ( ) . equal ( void ) ) ) { throw new illeg argument except ( invalid post construct annot ) ; } post construct = method ; } ( method . annot present ( pre destroi . class ) ) { ( ( pre destroi = null method . get paramet type ( ) . length = 0 ) ( modifi . static ( method . get modifi ( ) ) ) ( method . get except type ( ) . length 0 ) ( method . get return type ( ) . get name ( ) . equal ( void ) ) ) { throw new illeg argument except ( invalid pre destroi annot ) ; } pre destroi = method ; } } ( post construct = null ) { annot . add ( new annot cach entri ( post construct . get name ( ) , post construct . get paramet type ( ) , null , annot cach entri type . post construct ) ) ; } ( pre destroi = null ) { annot . add ( new annot cach entri ( pre destroi . get name ( ) , pre destroi . get paramet type ( ) , null , annot cach entri type . pre destroi ) ) ; } ( annot . empti ( ) ) { us common object save memori annot arrai = annot empti ; } els { annot arrai = annot . arrai ( new annot cach entri annot . size ( ) ) ; } synchron ( annot cach ) { annot cach . put ( clazz , annot arrai ) ; } } clazz = clazz . get superclass ( ) ; } }	privat static field get field ( final class clazz , final annot cach entri entri ) { field result = null ; ( global . secur enabl ) { result = access control . do privileg ( new privileg action field ( ) { overrid public field run ( ) { field result = null ; try { result = clazz . get declar field ( entri . get access object name ( ) ) ; } catch ( field except e ) { should never happen . basi don t log . } return result ; } } ) ; } els { try { result = clazz . get declar field ( entri . get access object name ( ) ) ; } catch ( field except e ) { should never happen . basi don t log . } } return result ; }	public gener web . xml string form match represent store thi object . return complet content web . xml string string xml ( ) { string builder sb = new string builder ( 2048 ) ; todo variou , icon , descript etc element ar skip mainli becaus thei ar ignor when web . xml pars see abov declar sb . append ( xml version = 1 . 0 encod = utf 8 n ) ; root element sb . append ( web app xmln = http : java . sun . com xml ns javae n ) ; sb . append ( xmln : xsi = ) ; sb . append ( http : www . w3 . org 2001 xmlschema instanc n ) ; sb . append ( xsi : schema locat = ) ; sb . append ( http : java . sun . com xml ns javae http : java . sun . com xml ns javae web app 3 0 . xsd n ) ; sb . append ( version = ) ; sb . append ( get version ( ) ) ; sb . append ( n ) ; sb . append ( metadata complet = true n n ) ; append element ( sb , indent2 , displai name , displai name ) ; ( distribut ( ) ) { sb . append ( distribut n n ) ; } ( map . entri string , string entri : context param . entri set ( ) ) { sb . append ( context param n ) ; append element ( sb , indent4 , param name , entri . get kei ( ) ) ; append element ( sb , indent4 , param valu , entri . get valu ( ) ) ; sb . append ( context param n ) ; } sb . append ( n ) ; ( map . entri string , filter def entri : filter . entri set ( ) ) { filter def filter def = entri . get valu ( ) ; sb . append ( filter n ) ; append element ( sb , indent4 , descript , filter def . get descript ( ) ) ; append element ( sb , indent4 , displai name , filter def . get displai name ( ) ) ; append element ( sb , indent4 , filter name , filter def . get filter name ( ) ) ; append element ( sb , indent4 , filter class , filter def . get filter class ( ) ) ; append element ( sb , indent4 , async support , filter def . get async support ( ) ) ; ( map . entri string , string param : filter def . get paramet map ( ) . entri set ( ) ) { sb . append ( init param n ) ; append element ( sb , indent6 , param name , param . get kei ( ) ) ; append element ( sb , indent6 , param valu , param . get valu ( ) ) ; sb . append ( init param n ) ; } sb . append ( filter n ) ; } sb . append ( n ) ; ( filter map filter map : filter map ) { sb . append ( filter map n ) ; append element ( sb , indent4 , filter name , filter map . get filter name ( ) ) ; ( filter map . get match all servlet name ( ) ) { sb . append ( servlet name servlet name n ) ; } els { ( string servlet name : filter map . get servlet name ( ) ) { append element ( sb , indent4 , servlet name , servlet name ) ; } } ( filter map . get match all url pattern ( ) ) { sb . append ( url pattern url pattern n ) ; } els { ( string url pattern : filter map . get urlpattern ( ) ) { append element ( sb , indent4 , url pattern , url pattern ) ; } } ( string dispatch : filter map . get dispatch name ( ) ) { append element ( sb , indent4 , dispatch , dispatch ) ; } sb . append ( filter map n ) ; } sb . append ( n ) ; ( string listen : listen ) { sb . append ( listen n ) ; append element ( sb , indent4 , listen class , listen ) ; sb . append ( listen n ) ; } sb . append ( n ) ; ( map . entri string , servlet def entri : servlet . entri set ( ) ) { servlet def servlet def = entri . get valu ( ) ; sb . append ( servlet n ) ; append element ( sb , indent4 , descript , servlet def . get descript ( ) ) ; append element ( sb , indent4 , displai name , servlet def . get displai name ( ) ) ; append element ( sb , indent4 , servlet name , entri . get kei ( ) ) ; append element ( sb , indent4 , servlet class , servlet def . get servlet class ( ) ) ; append element ( sb , indent4 , jsp file , servlet def . get jsp file ( ) ) ; ( map . entri string , string param : servlet def . get paramet map ( ) . entri set ( ) ) { sb . append ( init param n ) ; append element ( sb , indent6 , param name , param . get kei ( ) ) ; append element ( sb , indent6 , param valu , param . get valu ( ) ) ; sb . append ( init param n ) ; } append element ( sb , indent4 , load startup , servlet def . get load startup ( ) ) ; append element ( sb , indent4 , enabl , servlet def . get enabl ( ) ) ; append element ( sb , indent4 , async support , servlet def . get async support ( ) ) ; ( servlet def . get run ( ) = null ) { sb . append ( run n ) ; append element ( sb , indent6 , role name , servlet def . get run ( ) ) ; sb . append ( run n ) ; } ( secur role ref role ref : servlet def . get secur role ref ( ) ) { sb . append ( secur role ref n ) ; append element ( sb , indent6 , role name , role ref . get name ( ) ) ; append element ( sb , indent6 , role link , role ref . get link ( ) ) ; sb . append ( secur role ref n ) ; } multipart def multipart def = servlet def . get multipart def ( ) ; ( multipart def = null ) { sb . append ( multipart config n ) ; append element ( sb , indent6 , locat , multipart def . get locat ( ) ) ; append element ( sb , indent6 , max file size , multipart def . get max file size ( ) ) ; append element ( sb , indent6 , max request size , multipart def . get max request size ( ) ) ; append element ( sb , indent6 , file size threshold , multipart def . get file size threshold ( ) ) ; sb . append ( multipart config n ) ; } sb . append ( servlet n ) ; } sb . append ( n ) ; ( map . entri string , string entri : servlet map . entri set ( ) ) { sb . append ( servlet map n ) ; append element ( sb , indent4 , servlet name , entri . get valu ( ) ) ; append element ( sb , indent4 , url pattern , entri . get kei ( ) ) ; sb . append ( servlet map n ) ; } sb . append ( n ) ; ( session config = null ) { sb . append ( session config n ) ; append element ( sb , indent4 , session timeout , session config . get session timeout ( ) ) ; sb . append ( cooki config n ) ; append element ( sb , indent6 , name , session config . get cooki name ( ) ) ; append element ( sb , indent6 , domain , session config . get cooki domain ( ) ) ; append element ( sb , indent6 , path , session config . get cooki path ( ) ) ; append element ( sb , indent6 , comment , session config . get cooki comment ( ) ) ; append element ( sb , indent6 , http onli , session config . get cooki http onli ( ) ) ; append element ( sb , indent6 , secur , session config . get cooki secur ( ) ) ; append element ( sb , indent6 , max ag , session config . get cooki max ag ( ) ) ; sb . append ( cooki config n ) ; ( session track mode stm : session config . get session track mode ( ) ) { append element ( sb , indent4 , track mode , stm . name ( ) ) ; } sb . append ( session config n n ) ; } ( map . entri string , string entri : mime map . entri set ( ) ) { sb . append ( mime map n ) ; append element ( sb , indent4 , extens , entri . get kei ( ) ) ; append element ( sb , indent4 , mime type , entri . get valu ( ) ) ; sb . append ( mime map n ) ; } sb . append ( n ) ; ( welcom file . size ( ) 0 ) { sb . append ( welcom file list n ) ; ( string welcom file : welcom file ) { append element ( sb , indent4 , welcom file , welcom file ) ; } sb . append ( welcom file list n n ) ; } ( error page error page : error page . valu ( ) ) { sb . append ( error page n ) ; ( error page . get except type ( ) = = null ) { append element ( sb , indent4 , error code , integ . string ( error page . get error code ( ) ) ) ; } els { append element ( sb , indent4 , except type , error page . get except type ( ) ) ; } append element ( sb , indent4 , locat , error page . get locat ( ) ) ; sb . append ( error page n ) ; } sb . append ( n ) ; ( taglib . size ( ) 0 jsp properti group . size ( ) 0 ) { sb . append ( jsp config n ) ; ( map . entri string , string entri : taglib . entri set ( ) ) { sb . append ( taglib n ) ; append element ( sb , indent6 , taglib uri , entri . get kei ( ) ) ; append element ( sb , indent6 , taglib locat , entri . get valu ( ) ) ; sb . append ( taglib n ) ; } ( jsp properti group jpg : jsp properti group ) { sb . append ( jsp properti group n ) ; ( string url pattern : jpg . get url pattern ( ) ) { append element ( sb , indent6 , url pattern , url pattern ) ; } append element ( sb , indent6 , el ignor , jpg . get el ignor ( ) ) ; append element ( sb , indent6 , page encod , jpg . get page encod ( ) ) ; append element ( sb , indent6 , script invalid , jpg . get script invalid ( ) ) ; append element ( sb , indent6 , xml , jpg . get xml ( ) ) ; ( string prelud : jpg . get includ prelud ( ) ) { append element ( sb , indent6 , includ prelud , prelud ) ; } ( string coda : jpg . get includ coda ( ) ) { append element ( sb , indent6 , includ coda , coda ) ; } append element ( sb , indent6 , defer syntax allow liter , jpg . get defer syntax ( ) ) ; append element ( sb , indent6 , trim direct whitespac , jpg . get trim whitespac ( ) ) ; append element ( sb , indent6 , default content type , jpg . get default content type ( ) ) ; append element ( sb , indent6 , buffer , jpg . get buffer ( ) ) ; append element ( sb , indent6 , error undeclar namespac , jpg . get error undeclar namespac ( ) ) ; sb . append ( jsp properti group n ) ; } sb . append ( jsp config n n ) ; } ( secur constraint constraint : secur constraint ) { sb . append ( secur constraint n ) ; append element ( sb , indent4 , displai name , constraint . get displai name ( ) ) ; ( secur collect collect : constraint . find collect ( ) ) { sb . append ( web resourc collect n ) ; append element ( sb , indent6 , web resourc name , collect . get name ( ) ) ; append element ( sb , indent6 , descript , collect . get descript ( ) ) ; ( string url pattern : collect . find pattern ( ) ) { append element ( sb , indent6 , url pattern , url pattern ) ; } ( string method : collect . find method ( ) ) { append element ( sb , indent6 , http method , method ) ; } ( string method : collect . find omit method ( ) ) { append element ( sb , indent6 , http method omiss , method ) ; } sb . append ( web resourc collect n ) ; } ( constraint . find auth role ( ) . length 0 ) { sb . append ( auth constraint n ) ; ( string role : constraint . find auth role ( ) ) { append element ( sb , indent6 , role name , role ) ; } sb . append ( auth constraint n ) ; } ( constraint . get user constraint ( ) = null ) { sb . append ( user data constraint n ) ; append element ( sb , indent6 , transport guarante , constraint . get user constraint ( ) ) ; sb . append ( user data constraint n ) ; } sb . append ( secur constraint n ) ; } sb . append ( n ) ; ( login config = null ) { sb . append ( login config n ) ; append element ( sb , indent4 , auth method , login config . get auth method ( ) ) ; append element ( sb , indent4 , realm name , login config . get realm name ( ) ) ; ( login config . get error page ( ) = null login config . get login page ( ) = null ) { sb . append ( form login config n ) ; append element ( sb , indent6 , form login page , login config . get login page ( ) ) ; append element ( sb , indent6 , form error page , login config . get error page ( ) ) ; sb . append ( form login config n ) ; } sb . append ( login config n n ) ; } ( string role name : secur role ) { sb . append ( secur role n ) ; append element ( sb , indent4 , role name , role name ) ; sb . append ( secur role n ) ; } ( context environ env entri : env entri . valu ( ) ) { sb . append ( env entri n ) ; append element ( sb , indent4 , descript , env entri . get descript ( ) ) ; append element ( sb , indent4 , env entri name , env entri . get name ( ) ) ; append element ( sb , indent4 , env entri type , env entri . get type ( ) ) ; append element ( sb , indent4 , env entri valu , env entri . get valu ( ) ) ; todo map name ( inject target target : env entri . get inject target ( ) ) { sb . append ( inject target n ) ; append element ( sb , indent6 , inject target class , target . get target class ( ) ) ; append element ( sb , indent6 , inject target name , target . get target name ( ) ) ; sb . append ( inject target n ) ; } todo lookup name sb . append ( env entri n ) ; } sb . append ( n ) ; ( context ejb ejb ref : ejb ref . valu ( ) ) { sb . append ( ejb ref n ) ; append element ( sb , indent4 , descript , ejb ref . get descript ( ) ) ; append element ( sb , indent4 , ejb ref name , ejb ref . get name ( ) ) ; append element ( sb , indent4 , ejb ref type , ejb ref . get type ( ) ) ; append element ( sb , indent4 , home , ejb ref . get home ( ) ) ; append element ( sb , indent4 , remot , ejb ref . get remot ( ) ) ; append element ( sb , indent4 , ejb link , ejb ref . get link ( ) ) ; todo map name ( inject target target : ejb ref . get inject target ( ) ) { sb . append ( inject target n ) ; append element ( sb , indent6 , inject target class , target . get target class ( ) ) ; append element ( sb , indent6 , inject target name , target . get target name ( ) ) ; sb . append ( inject target n ) ; } todo lookup name sb . append ( ejb ref n ) ; } sb . append ( n ) ; ( context local ejb ejb local ref : ejb local ref . valu ( ) ) { sb . append ( ejb local ref n ) ; append element ( sb , indent4 , descript , ejb local ref . get descript ( ) ) ; append element ( sb , indent4 , ejb ref name , ejb local ref . get name ( ) ) ; append element ( sb , indent4 , ejb ref type , ejb local ref . get type ( ) ) ; append element ( sb , indent4 , local home , ejb local ref . get home ( ) ) ; append element ( sb , indent4 , local , ejb local ref . get local ( ) ) ; append element ( sb , indent4 , ejb link , ejb local ref . get link ( ) ) ; todo map name ( inject target target : ejb local ref . get inject target ( ) ) { sb . append ( inject target n ) ; append element ( sb , indent6 , inject target class , target . get target class ( ) ) ; append element ( sb , indent6 , inject target name , target . get target name ( ) ) ; sb . append ( inject target n ) ; } todo lookup name sb . append ( ejb local ref n ) ; } sb . append ( n ) ; ( context servic servic ref : servic ref . valu ( ) ) { sb . append ( servic ref n ) ; append element ( sb , indent4 , descript , servic ref . get descript ( ) ) ; append element ( sb , indent4 , displai name , servic ref . get displaynam ( ) ) ; append element ( sb , indent4 , servic ref name , servic ref . get name ( ) ) ; append element ( sb , indent4 , servic interfac , servic ref . get interfac ( ) ) ; append element ( sb , indent4 , servic ref type , servic ref . get type ( ) ) ; append element ( sb , indent4 , wsdl file , servic ref . get wsdlfile ( ) ) ; append element ( sb , indent4 , jaxrpc map file , servic ref . get jaxrpcmappingfil ( ) ) ; string qname = servic ref . get serviceqnam namespac uri ( ) ; ( qname = null ) { qname = qname : ; } qname = qname servic ref . get serviceqnam localpart ( ) ; append element ( sb , indent4 , servic qname , qname ) ; iter string endpoint iter = servic ref . get serviceendpoint ( ) ; while ( endpoint iter . ha next ( ) ) { string endpoint = endpoint iter . next ( ) ; sb . append ( port compon ref n ) ; append element ( sb , indent6 , servic endpoint interfac , endpoint ) ; append element ( sb , indent6 , port compon link , servic ref . get properti ( endpoint ) ) ; sb . append ( port compon ref n ) ; } iter string handler iter = servic ref . get handler ( ) ; while ( handler iter . ha next ( ) ) { string handler = handler iter . next ( ) ; sb . append ( handler n ) ; context handler ch = servic ref . get handler ( handler ) ; append element ( sb , indent6 , handler name , ch . get name ( ) ) ; append element ( sb , indent6 , handler class , ch . get handlerclass ( ) ) ; sb . append ( handler n ) ; } todo map name ( inject target target : servic ref . get inject target ( ) ) { sb . append ( inject target n ) ; append element ( sb , indent6 , inject target class , target . get target class ( ) ) ; append element ( sb , indent6 , inject target name , target . get target name ( ) ) ; sb . append ( inject target n ) ; } todo lookup name sb . append ( servic ref n ) ; } sb . append ( n ) ; ( context resourc resourc ref : resourc ref . valu ( ) ) { sb . append ( resourc ref n ) ; append element ( sb , indent4 , descript , resourc ref . get descript ( ) ) ; append element ( sb , indent4 , re ref name , resourc ref . get name ( ) ) ; append element ( sb , indent4 , re type , resourc ref . get type ( ) ) ; append element ( sb , indent4 , re auth , resourc ref . get auth ( ) ) ; append element ( sb , indent4 , re share scope , resourc ref . get scope ( ) ) ; todo map name ( inject target target : resourc ref . get inject target ( ) ) { sb . append ( inject target n ) ; append element ( sb , indent6 , inject target class , target . get target class ( ) ) ; append element ( sb , indent6 , inject target name , target . get target name ( ) ) ; sb . append ( inject target n ) ; } todo lookup name sb . append ( resourc ref n ) ; } sb . append ( n ) ; ( context resourc env ref resourc env ref : resourc env ref . valu ( ) ) { sb . append ( resourc env ref n ) ; append element ( sb , indent4 , descript , resourc env ref . get descript ( ) ) ; append element ( sb , indent4 , resourc env ref name , resourc env ref . get name ( ) ) ; append element ( sb , indent4 , resourc env ref type , resourc env ref . get type ( ) ) ; todo map name ( inject target target : resourc env ref . get inject target ( ) ) { sb . append ( inject target n ) ; append element ( sb , indent6 , inject target class , target . get target class ( ) ) ; append element ( sb , indent6 , inject target name , target . get target name ( ) ) ; sb . append ( inject target n ) ; } todo lookup name sb . append ( resourc env ref n ) ; } sb . append ( n ) ; ( messag destin ref mdr : messag destin ref . valu ( ) ) { sb . append ( messag destin ref n ) ; append element ( sb , indent4 , descript , mdr . get descript ( ) ) ; append element ( sb , indent4 , messag destin ref name , mdr . get name ( ) ) ; append element ( sb , indent4 , messag destin type , mdr . get type ( ) ) ; append element ( sb , indent4 , messag destin usag , mdr . get usag ( ) ) ; append element ( sb , indent4 , messag destin link , mdr . get link ( ) ) ; todo map name ( inject target target : mdr . get inject target ( ) ) { sb . append ( inject target n ) ; append element ( sb , indent6 , inject target class , target . get target class ( ) ) ; append element ( sb , indent6 , inject target name , target . get target name ( ) ) ; sb . append ( inject target n ) ; } todo lookup name sb . append ( messag destin ref n ) ; } sb . append ( n ) ; ( messag destin md : messag destin . valu ( ) ) { sb . append ( messag destin n ) ; append element ( sb , indent4 , descript , md . get descript ( ) ) ; append element ( sb , indent4 , displai name , md . get displai name ( ) ) ; append element ( sb , indent4 , messag destin name , md . get name ( ) ) ; todo map name sb . append ( messag destin n ) ; } sb . append ( n ) ; ( local encod map . size ( ) 0 ) { sb . append ( local encod map list n ) ; ( map . entri string , string entri : local encod map . entri set ( ) ) { sb . append ( local encod map n ) ; append element ( sb , indent6 , local , entri . get kei ( ) ) ; append element ( sb , indent6 , encod , entri . get valu ( ) ) ; sb . append ( local encod map n ) ; } sb . append ( local encod map list n ) ; } sb . append ( web app ) ; return sb . string ( ) ; }	overrid public boolean fire request destroi event ( servlet request request ) { object instanc = get applic event listen ( ) ; ( ( instanc = null ) ( instanc . length 0 ) ) { servlet request event event = new servlet request event ( get servlet context ( ) , request ) ; ( int i = 0 ; i instanc . length ; i ) { int j = ( instanc . length 1 ) i ; ( instanc j = = null ) continu ; ( ( instanc j instanceof servlet request listen ) ) continu ; servlet request listen listen = ( servlet request listen ) instanc j ; try { listen . request destroi ( event ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; get logger ( ) . error ( sm . get string ( standard context . request listen . request init , instanc j . get class ( ) . get name ( ) ) , t ) ; request . set attribut ( request dispatch . error except , t ) ; return fals ; } } } return true ; }	overrid public boolean get add webinf class resourc ( ) { return fals ; }	test case bug 49711 : http servlet request . get part doe work filter . test public void test bug49711 ( ) { bug49711client client = new bug49711client ( ) ; make sure non multipart work properli client . do request ( regular , fals , fals ) ; assert equal ( incorrect respons get request , part = 0 , client . get respons bodi ( ) ) ; client . reset ( ) ; make sure regular multipart work properli send multipart request client . do request ( multipart , fals , true ) ; assert equal ( regular multipart doesn t work , part = 1 , client . get respons bodi ( ) ) ; client . reset ( ) ; make casual multipart request regular servlet w o config we expect part avail send multipart request client . do request ( regular , fals , true ) ; assert equal ( incorrect respons non configur casual multipart request , multipart request should ignor part = 0 , client . get respons bodi ( ) ) ; client . reset ( ) ; make casual multipart request regular servlet w config we expect server pars part , even though multipart config send multipart request client . do request ( regular , true , true ) ; assert equal ( incorrect respons configur casual multipart request , part = 1 , client . get respons bodi ( ) ) ; client . reset ( ) ; }	privat static t boolean merg map ( map string , t fragment map , map string , t main map , map string , t temp map , web xml fragment , string map name ) { ( entri string , t entri : fragment map . entri set ( ) ) { final string kei = entri . get kei ( ) ; ( main map . contain kei ( kei ) ) { defin main web . xml t valu = entri . get valu ( ) ; ( temp map . contain kei ( kei ) ) { ( valu = null valu . equal ( temp map . get ( kei ) ) ) { log . error ( sm . get string ( web xml . merg conflict string , map name , kei , fragment . get name ( ) , fragment . get url ( ) ) ) ; return fals ; } } els { temp map . put ( kei , valu ) ; } } } return true ; }	public static attempt load class us given contain s class loader . class cannot load , debug level log messag written contain s log null return . class load class ( context context , string class name ) { class loader cl = context . get loader ( ) . get class loader ( ) ; log log = context . get logger ( ) ; class clazz = null ; try { clazz = cl . load class ( class name ) ; } catch ( class found except e ) { log . debug ( sm . get string ( introspect . class load fail ) , e ) ; } catch ( class def found error e ) { log . debug ( sm . get string ( introspect . class load fail ) , e ) ; } catch ( class format error e ) { log . debug ( sm . get string ( introspect . class load fail ) , e ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . debug ( sm . get string ( introspect . class load fail ) , t ) ; } return clazz ; }	public string get jar name ( ) { return jar name ; }	p add set rule instanc defin thi rule set specifi code digest code instanc , associ them our namespac uri ( ani ) . thi method should onli call digest instanc . p param digest digest instanc which new rule instanc should ad . overrid public void add rule instanc ( digest digest ) { digest . add rule ( full prefix , new set public id rule ( set public id ) ) ; digest . add rule ( full prefix , new ignor annot rule ( ) ) ; digest . add rule ( full prefix , new version rule ( ) ) ; requir both fragment non fragment digest . add rule ( full prefix absolut order , absolut order ) ; digest . add rule ( full prefix order , rel order ) ; ( fragment ) { web fragment . xml digest . add rule ( full prefix name , name ) ; digest . add call method ( full prefix order after name , add after order , 0 ) ; digest . add call method ( full prefix order after other , add after order other ) ; digest . add call method ( full prefix order befor name , add befor order , 0 ) ; digest . add call method ( full prefix order befor other , add befor order other ) ; } els { web . xml digest . add call method ( full prefix absolut order name , add absolut order , 0 ) ; digest . add call method ( full prefix absolut order other , add absolut order other ) ; } digest . add call method ( full prefix context param , add context param , 2 ) ; digest . add call param ( full prefix context param param name , 0 ) ; digest . add call param ( full prefix context param param valu , 1 ) ; digest . add call method ( full prefix displai name , set displai name , 0 ) ; digest . add rule ( full prefix distribut , new set distribut rule ( ) ) ; configur name rule ( digest ) ; digest . add object creat ( full prefix error page , org . apach . catalina . deploi . error page ) ; digest . add set next ( full prefix error page , add error page , org . apach . catalina . deploi . error page ) ; digest . add call method ( full prefix error page error code , set error code , 0 ) ; digest . add call method ( full prefix error page except type , set except type , 0 ) ; digest . add call method ( full prefix error page locat , set locat , 0 ) ; digest . add object creat ( full prefix filter , org . apach . catalina . deploi . filter def ) ; digest . add set next ( full prefix filter , add filter , org . apach . catalina . deploi . filter def ) ; digest . add call method ( full prefix filter descript , set descript , 0 ) ; digest . add call method ( full prefix filter displai name , set displai name , 0 ) ; digest . add call method ( full prefix filter filter class , set filter class , 0 ) ; digest . add call method ( full prefix filter filter name , set filter name , 0 ) ; digest . add call method ( full prefix filter icon larg icon , set larg icon , 0 ) ; digest . add call method ( full prefix filter icon small icon , set small icon , 0 ) ; digest . add call method ( full prefix filter async support , set async support , 0 ) ; digest . add call method ( full prefix filter init param , add init paramet , 2 ) ; digest . add call param ( full prefix filter init param param name , 0 ) ; digest . add call param ( full prefix filter init param param valu , 1 ) ; digest . add object creat ( full prefix filter map , org . apach . catalina . deploi . filter map ) ; digest . add set next ( full prefix filter map , add filter map , org . apach . catalina . deploi . filter map ) ; digest . add call method ( full prefix filter map filter name , set filter name , 0 ) ; digest . add call method ( full prefix filter map servlet name , add servlet name , 0 ) ; digest . add call method ( full prefix filter map url pattern , add urlpattern , 0 ) ; digest . add call method ( full prefix filter map dispatch , set dispatch , 0 ) ; digest . add call method ( full prefix listen listen class , add listen , 0 ) ; digest . add rule ( full prefix jsp config , jsp config ) ; digest . add object creat ( full prefix jsp config jsp properti group , org . apach . catalina . deploi . jsp properti group ) ; digest . add set next ( full prefix jsp config jsp properti group , add jsp properti group , org . apach . catalina . deploi . jsp properti group ) ; digest . add call method ( full prefix jsp config jsp properti group defer syntax allow liter , set defer syntax , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group el ignor , set el ignor , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group includ coda , add includ coda , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group includ prelud , add includ prelud , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group xml , set xml , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group page encod , set page encod , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group script invalid , set script invalid , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group trim direct whitespac , set trim whitespac , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group url pattern , add url pattern , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group default content type , set default content type , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group buffer , set buffer , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group error undeclar namespac , set error undeclar namespac , 0 ) ; digest . add rule ( full prefix login config , login config ) ; digest . add object creat ( full prefix login config , org . apach . catalina . deploi . login config ) ; digest . add set next ( full prefix login config , set login config , org . apach . catalina . deploi . login config ) ; digest . add call method ( full prefix login config auth method , set auth method , 0 ) ; digest . add call method ( full prefix login config realm name , set realm name , 0 ) ; digest . add call method ( full prefix login config form login config form error page , set error page , 0 ) ; digest . add call method ( full prefix login config form login config form login page , set login page , 0 ) ; digest . add call method ( full prefix mime map , add mime map , 2 ) ; digest . add call param ( full prefix mime map extens , 0 ) ; digest . add call param ( full prefix mime map mime type , 1 ) ; digest . add object creat ( full prefix secur constraint , org . apach . catalina . deploi . secur constraint ) ; digest . add set next ( full prefix secur constraint , add secur constraint , org . apach . catalina . deploi . secur constraint ) ; digest . add rule ( full prefix secur constraint auth constraint , new set auth constraint rule ( ) ) ; digest . add call method ( full prefix secur constraint auth constraint role name , add auth role , 0 ) ; digest . add call method ( full prefix secur constraint displai name , set displai name , 0 ) ; digest . add call method ( full prefix secur constraint user data constraint transport guarante , set user constraint , 0 ) ; digest . add object creat ( full prefix secur constraint web resourc collect , org . apach . catalina . deploi . secur collect ) ; digest . add set next ( full prefix secur constraint web resourc collect , add collect , org . apach . catalina . deploi . secur collect ) ; digest . add call method ( full prefix secur constraint web resourc collect http method , add method , 0 ) ; digest . add call method ( full prefix secur constraint web resourc collect http method omiss , add omit method , 0 ) ; digest . add call method ( full prefix secur constraint web resourc collect url pattern , add pattern , 0 ) ; digest . add call method ( full prefix secur constraint web resourc collect web resourc name , set name , 0 ) ; digest . add call method ( full prefix secur role role name , add secur role , 0 ) ; digest . add rule ( full prefix servlet , new servlet def creat rule ( ) ) ; digest . add set next ( full prefix servlet , add servlet , org . apach . catalina . deploi . servlet def ) ; digest . add call method ( full prefix servlet init param , add init paramet , 2 ) ; digest . add call param ( full prefix servlet init param param name , 0 ) ; digest . add call param ( full prefix servlet init param param valu , 1 ) ; digest . add call method ( full prefix servlet jsp file , set jsp file , 0 ) ; digest . add call method ( full prefix servlet load startup , set load startup , 0 ) ; digest . add call method ( full prefix servlet run role name , set run , 0 ) ; digest . add object creat ( full prefix servlet secur role ref , org . apach . catalina . deploi . secur role ref ) ; digest . add set next ( full prefix servlet secur role ref , add secur role ref , org . apach . catalina . deploi . secur role ref ) ; digest . add call method ( full prefix servlet secur role ref role link , set link , 0 ) ; digest . add call method ( full prefix servlet secur role ref role name , set name , 0 ) ; digest . add call method ( full prefix servlet servlet class , set servlet class , 0 ) ; digest . add call method ( full prefix servlet servlet name , set servlet name , 0 ) ; digest . add object creat ( full prefix servlet multipart config , org . apach . catalina . deploi . multipart def ) ; digest . add set next ( full prefix servlet multipart config , set multipart def , org . apach . catalina . deploi . multipart def ) ; digest . add call method ( full prefix servlet multipart config locat , set locat , 0 ) ; digest . add call method ( full prefix servlet multipart config max file size , set max file size , 0 ) ; digest . add call method ( full prefix servlet multipart config max request size , set max request size , 0 ) ; digest . add call method ( full prefix servlet multipart config file size threshold , set file size threshold , 0 ) ; digest . add call method ( full prefix servlet async support , set async support , 0 ) ; digest . add call method ( full prefix servlet enabl , set enabl , 0 ) ; digest . add rule ( full prefix servlet map , new call method multi rule ( add servlet map , 2 , 0 ) ) ; digest . add call param ( full prefix servlet map servlet name , 1 ) ; digest . add rule ( full prefix servlet map url pattern , new call param multi rule ( 0 ) ) ; digest . add rule ( full prefix session config , session config ) ; digest . add object creat ( full prefix session config , org . apach . catalina . deploi . session config ) ; digest . add set next ( full prefix session config , set session config , org . apach . catalina . deploi . session config ) ; digest . add call method ( full prefix session config session timeout , set session timeout , 0 ) ; digest . add call method ( full prefix session config cooki config name , set cooki name , 0 ) ; digest . add call method ( full prefix session config cooki config domain , set cooki domain , 0 ) ; digest . add call method ( full prefix session config cooki config path , set cooki path , 0 ) ; digest . add call method ( full prefix session config cooki config comment , set cooki comment , 0 ) ; digest . add call method ( full prefix session config cooki config http onli , set cooki http onli , 0 ) ; digest . add call method ( full prefix session config cooki config secur , set cooki secur , 0 ) ; digest . add call method ( full prefix session config cooki config max ag , set cooki max ag , 0 ) ; digest . add call method ( full prefix session config track mode , add session track mode , 0 ) ; taglib pre servlet 2 . 4 digest . add rule ( full prefix taglib , new taglib locat rule ( fals ) ) ; digest . add call method ( full prefix taglib , add taglib , 2 ) ; digest . add call param ( full prefix taglib taglib locat , 1 ) ; digest . add call param ( full prefix taglib taglib uri , 0 ) ; taglib servlet 2 . 4 onward digest . add rule ( full prefix jsp config taglib , new taglib locat rule ( true ) ) ; digest . add call method ( full prefix jsp config taglib , add taglib , 2 ) ; digest . add call param ( full prefix jsp config taglib taglib locat , 1 ) ; digest . add call param ( full prefix jsp config taglib taglib uri , 0 ) ; digest . add call method ( full prefix welcom file list welcom file , add welcom file , 0 ) ; digest . add call method ( full prefix local encod map list local encod map , add local encod map , 2 ) ; digest . add call param ( full prefix local encod map list local encod map local , 0 ) ; digest . add call param ( full prefix local encod map list local encod map encod , 1 ) ; }	overrid public void bodi ( string namespac , string name , string text ) throw except { super . bodi ( namespac , name , text ) ; ( ( web xml ) digest . peek ( ) ) . set name ( text ) ; }	public configur { link context } us store web . xml represent . param context context configur void configur context ( context context ) { far possibl , process alphabet order so easi check everyth present some valid depend correct public id context . set public id ( public id ) ; everyth els order context . set effect major version ( get major version ( ) ) ; context . set effect minor version ( get minor version ( ) ) ; ( entri string , string entri : context param . entri set ( ) ) { context . add paramet ( entri . get kei ( ) , entri . get valu ( ) ) ; } context . set displai name ( displai name ) ; context . set distribut ( distribut ) ; ( context local ejb ejb local ref : ejb local ref . valu ( ) ) { context . get name resourc ( ) . add local ejb ( ejb local ref ) ; } ( context ejb ejb ref : ejb ref . valu ( ) ) { context . get name resourc ( ) . add ejb ( ejb ref ) ; } ( context environ environ : env entri . valu ( ) ) { context . get name resourc ( ) . add environ ( environ ) ; } ( error page error page : error page . valu ( ) ) { context . add error page ( error page ) ; } ( filter def filter : filter . valu ( ) ) { ( filter . get async support ( ) = = null ) { filter . set async support ( fals ) ; } context . add filter def ( filter ) ; } ( filter map filter map : filter map ) { context . add filter map ( filter map ) ; } ( jsp properti group jsp properti group : jsp properti group ) { jsp properti group descriptor descriptor = new applic jsp properti group descriptor ( jsp properti group ) ; context . get jsp config descriptor ( ) . get jsp properti group ( ) . add ( descriptor ) ; } ( string listen : listen ) { context . add applic listen ( listen ) ; } ( entri string , string entri : local encod map . entri set ( ) ) { context . add local encod map paramet ( entri . get kei ( ) , entri . get valu ( ) ) ; } prevent iae ( login config = null ) { context . set login config ( login config ) ; } ( messag destin ref mdr : messag destin ref . valu ( ) ) { context . get name resourc ( ) . add messag destin ref ( mdr ) ; } messag destin were ignor tomcat 6 , so ignor here context . set ignor annot ( metadata complet ) ; ( entri string , string entri : mime map . entri set ( ) ) { context . add mime map ( entri . get kei ( ) , entri . get valu ( ) ) ; } name just us order ( context resourc env ref resourc : resourc env ref . valu ( ) ) { context . get name resourc ( ) . add resourc env ref ( resourc ) ; } ( context resourc resourc : resourc ref . valu ( ) ) { context . get name resourc ( ) . add resourc ( resourc ) ; } ( secur constraint constraint : secur constraint ) { context . add constraint ( constraint ) ; } ( string role : secur role ) { context . add secur role ( role ) ; } ( context servic servic : servic ref . valu ( ) ) { context . get name resourc ( ) . add servic ( servic ) ; } ( servlet def servlet : servlet . valu ( ) ) { wrapper wrapper = context . creat wrapper ( ) ; jsp file get pass jsp servlet init param ( servlet . get load startup ( ) = null ) { wrapper . set load startup ( servlet . get load startup ( ) . int valu ( ) ) ; } ( servlet . get enabl ( ) = null ) { wrapper . set enabl ( servlet . get enabl ( ) . boolean valu ( ) ) ; } wrapper . set name ( servlet . get servlet name ( ) ) ; map string , string param = servlet . get paramet map ( ) ; ( entri string , string entri : param . entri set ( ) ) { wrapper . add init paramet ( entri . get kei ( ) , entri . get valu ( ) ) ; } wrapper . set run ( servlet . get run ( ) ) ; set secur role ref role ref = servlet . get secur role ref ( ) ; ( secur role ref role ref : role ref ) { wrapper . add secur refer ( role ref . get name ( ) , role ref . get link ( ) ) ; } wrapper . set servlet class ( servlet . get servlet class ( ) ) ; multipart def multipartdef = servlet . get multipart def ( ) ; ( multipartdef = null ) { ( multipartdef . get max file size ( ) = null multipartdef . get max request size ( ) = null multipartdef . get file size threshold ( ) = null ) { wrapper . set multipart config element ( new multipart config element ( multipartdef . get locat ( ) , long . pars long ( multipartdef . get max file size ( ) ) , long . pars long ( multipartdef . get max request size ( ) ) , integ . pars int ( multipartdef . get file size threshold ( ) ) ) ) ; } els { wrapper . set multipart config element ( new multipart config element ( multipartdef . get locat ( ) ) ) ; } } ( servlet . get async support ( ) = null ) { wrapper . set async support ( servlet . get async support ( ) . boolean valu ( ) ) ; } wrapper . set overrid ( servlet . overrid ( ) ) ; context . add child ( wrapper ) ; } ( entri string , string entri : servlet map . entri set ( ) ) { context . add servlet map ( entri . get kei ( ) , entri . get valu ( ) ) ; } ( session config = null ) { ( session config . get session timeout ( ) = null ) { context . set session timeout ( session config . get session timeout ( ) . int valu ( ) ) ; } session cooki config scc = context . get servlet context ( ) . get session cooki config ( ) ; scc . set name ( session config . get cooki name ( ) ) ; scc . set domain ( session config . get cooki domain ( ) ) ; scc . set path ( session config . get cooki path ( ) ) ; scc . set comment ( session config . get cooki comment ( ) ) ; ( session config . get cooki http onli ( ) = null ) { scc . set http onli ( session config . get cooki http onli ( ) . boolean valu ( ) ) ; } ( session config . get cooki secur ( ) = null ) { scc . set secur ( session config . get cooki secur ( ) . boolean valu ( ) ) ; } ( session config . get cooki max ag ( ) = null ) { scc . set max ag ( session config . get cooki max ag ( ) . int valu ( ) ) ; } ( session config . get session track mode ( ) . size ( ) 0 ) { context . get servlet context ( ) . set session track mode ( session config . get session track mode ( ) ) ; } } ( entri string , string entri : taglib . entri set ( ) ) { taglib descriptor descriptor = new applic taglib descriptor ( entri . get valu ( ) , entri . get kei ( ) ) ; context . get jsp config descriptor ( ) . get taglib ( ) . add ( descriptor ) ; } context doesn t us version directli ( string welcom file : welcom file ) { follow result welcom file so don t add context welcom file list welcom file welcom file list ( welcom file = null welcom file . length ( ) 0 ) { context . add welcom file ( welcom file ) ; } } do thi last depend servlet ( jsp properti group jsp properti group : jsp properti group ) { string jsp servlet name = context . find servlet map ( . jsp ) ; ( jsp servlet name = = null ) { jsp servlet name = jsp ; } ( context . find child ( jsp servlet name ) = null ) { ( string url pattern : jsp properti group . get url pattern ( ) ) { context . add servlet map ( url pattern , jsp servlet name , true ) ; } } els { ( log . debug enabl ( ) ) { ( string url pattern : jsp properti group . get url pattern ( ) ) { log . debug ( skipe url pattern , servlet jsp servlet name ) ; } } } } }	overrid public boolean get add webinf class resourc ( ) { return fals ; }	test public void test bug54262 ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; file app dir = new file ( test webapp 3 . 0 fragment empti absolut order ) ; tomcat . add webapp ( null , test , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; assert page contain ( test resourc . jsp , resourc . jsp resourc . jar ) ; assert page contain ( test resourc hello world exampl , null , http servlet respons . sc found ) ; }	test public void test pars public id version22 ( ) { web xml webxml = new web xml ( ) ; webxml . set public id ( org . apach . catalina . startup . constant . web dtd public id 22 ) ; assert equal ( 2 , webxml . get major version ( ) ) ; assert equal ( 2 , webxml . get minor version ( ) ) ; assert equal ( 2 . 2 , webxml . get version ( ) ) ; }	test public void test pars public id version23 ( ) { web xml webxml = new web xml ( ) ; webxml . set public id ( org . apach . catalina . startup . constant . web dtd public id 23 ) ; assert equal ( 2 , webxml . get major version ( ) ) ; assert equal ( 3 , webxml . get minor version ( ) ) ; assert equal ( 2 . 3 , webxml . get version ( ) ) ; }	test public void test pars public id version24 ( ) { web xml webxml = new web xml ( ) ; webxml . set public id ( org . apach . catalina . startup . constant . web schema public id 24 ) ; assert equal ( 2 , webxml . get major version ( ) ) ; assert equal ( 4 , webxml . get minor version ( ) ) ; assert equal ( 2 . 4 , webxml . get version ( ) ) ; }	test public void test pars public id version25 ( ) { web xml webxml = new web xml ( ) ; webxml . set public id ( org . apach . catalina . startup . constant . web schema public id 25 ) ; assert equal ( 2 , webxml . get major version ( ) ) ; assert equal ( 5 , webxml . get minor version ( ) ) ; assert equal ( 2 . 5 , webxml . get version ( ) ) ; }	test public void test pars public id version30 ( ) { web xml webxml = new web xml ( ) ; webxml . set public id ( org . apach . catalina . startup . constant . web schema public id 30 ) ; assert equal ( 3 , webxml . get major version ( ) ) ; assert equal ( 0 , webxml . get minor version ( ) ) ; assert equal ( 3 . 0 , webxml . get version ( ) ) ; }	public void test pars version ( ) { web xml webxml = new web xml ( ) ; default assert equal ( 3 , webxml . get major version ( ) ) ; assert equal ( 0 , webxml . get minor version ( ) ) ; both get chang webxml . set version ( 2 . 5 ) ; assert equal ( 2 , webxml . get major version ( ) ) ; assert equal ( 5 , webxml . get minor version ( ) ) ; reset webxml . set version ( 0 . 0 ) ; assert equal ( 0 , webxml . get major version ( ) ) ; assert equal ( 0 , webxml . get minor version ( ) ) ; null input should ignor webxml . set version ( null ) ; assert equal ( 0 , webxml . get major version ( ) ) ; assert equal ( 0 , webxml . get minor version ( ) ) ; major onli webxml . set version ( 3 ) ; assert equal ( 3 , webxml . get major version ( ) ) ; assert equal ( 0 , webxml . get minor version ( ) ) ; minor digit reset webxml . set version ( 0 . 0 ) ; webxml . set version ( 3 . ) ; assert equal ( 3 , webxml . get major version ( ) ) ; assert equal ( 0 , webxml . get minor version ( ) ) ; minor onli reset webxml . set version ( 0 . 0 ) ; webxml . set version ( . 5 ) ; assert equal ( 0 , webxml . get major version ( ) ) ; assert equal ( 5 , webxml . get minor version ( ) ) ; lead train zero reset webxml . set version ( 0 . 0 ) ; webxml . set version ( 002 . 500 ) ; assert equal ( 2 , webxml . get major version ( ) ) ; assert equal ( 500 , webxml . get minor version ( ) ) ; }	test public void test recycl ( ) throw except { name pars ( new web xml ( ) , web fragment 2name . xml , true , fals ) ; pars ( new web xml ( ) , web fragment 1name . xml , true , true ) ; pars ( new web xml ( ) , web fragment 2name . xml , true , fals ) ; pars ( new web xml ( ) , web fragment 1name . xml , true , true ) ; rel order pars ( new web xml ( ) , web fragment 2order . xml , true , fals ) ; pars ( new web xml ( ) , web fragment 1order . xml , true , true ) ; pars ( new web xml ( ) , web fragment 2order . xml , true , fals ) ; pars ( new web xml ( ) , web fragment 1order . xml , true , true ) ; absolut order pars ( new web xml ( ) , web 2order . xml , fals , fals ) ; pars ( new web xml ( ) , web 1order . xml , fals , true ) ; pars ( new web xml ( ) , web 2order . xml , fals , fals ) ; pars ( new web xml ( ) , web 1order . xml , fals , true ) ; }
privat pars string builder take out command token . call from code request handler code param cmd valu type string builder return valu type string , null none string pars cmd ( string builder cmd ) { int first letter = 1 ; int last letter = 1 ; ( int i = 0 ; i cmd . length ( ) ; i ) { char c = cmd . char ( i ) ; ( charact . letter ( c ) ) { ( first letter = = 1 ) { first letter = i ; } last letter = i ; } els ( space ( c ) ) { ( last letter 1 ) { break ; } } els { break ; } } string command = null ; ( first letter = 1 ) { command = cmd . substr ( first letter , last letter 1 ) ; } return command ; }
privat void do close ( int statu ) { need call close us web applic s class loader thread t = thread . current thread ( ) ; class loader cl = t . get context class loader ( ) ; t . set context class loader ( applic class loader ) ; try { close ( statu ) ; } final { t . set context class loader ( cl ) ; } }	protect intend overridden sub class wish notifi when outbound connect close . default implement op . param statu statu code close reason . void close ( int statu ) { op }	public final socket state data ( ) { must start start messag ( which mai consist multipl frame ) ws input stream ws = new ws input stream ( input stream , get ws outbound ( ) ) ; try { ws frame frame = ws . next frame ( fals ) ; while ( frame = null ) { todo user defin extens mai defin valu rsv ( frame . get rsv ( ) 0 ) { close outbound connect ( constant . statu protocol error , null ) ; return socket state . close ; } byte op code = frame . get op code ( ) ; ( op code = = constant . opcod binari ) { do binari data ( ws ) ; } els ( op code = = constant . opcod text ) { input stream reader r = new input stream reader ( ws , new utf8decod ( ) ) ; do text data ( r ) ; } els ( op code = = constant . opcod close ) { close outbound connect ( frame ) ; return socket state . close ; } els ( op code = = constant . opcod ping ) { get ws outbound ( ) . pong ( frame . get pai load ( ) ) ; } els ( op code = = constant . opcod pong ) { op } els { unknown op code close outbound connect ( constant . statu protocol error , null ) ; return socket state . close ; } frame = ws . next frame ( fals ) ; } } catch ( malform input except mie ) { invalid utf 8 try { close outbound connect ( constant . statu bad data , null ) ; } catch ( ioexcept e ) { todo } return socket state . close ; } catch ( unmapp charact except uc ) { invalid utf 8 try { close outbound connect ( constant . statu bad data , null ) ; } catch ( ioexcept e ) { todo } return socket state . close ; } catch ( ioexcept ioe ) { might work try anywai . try { close outbound connect ( constant . statu protocol error , null ) ; } catch ( ioexcept e ) { todo } return socket state . close ; } return socket state . upgrad ; }
privat http servlet request test remot ip filter ( filter def filter def , request request ) throw lifecycl except , ioexcept , servlet except { tomcat tomcat = get tomcat instanc ( ) ; context root = tomcat . add context ( , temp dir ) ; remot ip filter remot ip filter = new remot ip filter ( ) ; filter def . set filter class ( remot ip filter . class . get name ( ) ) ; filter def . set filter ( remot ip filter ) ; filter def . set filter name ( remot ip filter . class . get name ( ) ) ; root . add filter def ( filter def ) ; filter map filter map = new filter map ( ) ; filter map . set filter name ( remot ip filter . class . get name ( ) ) ; filter map . add urlpattern ( ) ; root . add filter map ( filter map ) ; get tomcat instanc ( ) . start ( ) ; mock filter chain filter chain = new mock filter chain ( ) ; test remot ip filter . do filter ( request , new respons ( ) , filter chain ) ; return filter chain . get request ( ) ; }	public void do filter ( http servlet request request , http servlet respons respons , filter chain chain ) throw ioexcept , servlet except { ( intern proxi = null intern proxi . matcher ( request . get remot addr ( ) ) . match ( ) ) { string remot ip = null ; java 6 , proxi header valu should declar java . util . dequ link list string proxi header valu = new link list ( ) ; string builder concat remot ip header valu = new string builder ( ) ; ( enumer string e = request . get header ( remot ip header ) ; e . ha more element ( ) ; ) { ( concat remot ip header valu . length ( ) 0 ) { concat remot ip header valu . append ( , ) ; } concat remot ip header valu . append ( e . next element ( ) ) ; } string remot ip header valu = comma delimit list string arrai ( concat remot ip header valu . string ( ) ) ; int idx ; loop remot ip header valu find first trust remot ip build proxi chain ( idx = remot ip header valu . length 1 ; idx = 0 ; idx ) { string current remot ip = remot ip header valu idx ; remot ip = current remot ip ; ( intern proxi . matcher ( current remot ip ) . match ( ) ) { do noth , intern proxi ip ar append } els ( trust proxi = null trust proxi . matcher ( current remot ip ) . match ( ) ) { proxi header valu . add first ( current remot ip ) ; } els { decrement idx becaus break statement doesn t do idx ; break ; } } continu loop remot ip header valu build new valu remot ip header link list string new remot ip header valu = new link list ( ) ; ( ; idx = 0 ; idx ) { string current remot ip = remot ip header valu idx ; new remot ip header valu . add first ( current remot ip ) ; } xforward request x request = new xforward request ( request ) ; ( remot ip = null ) { x request . set remot addr ( remot ip ) ; x request . set remot host ( remot ip ) ; ( proxi header valu . size ( ) = = 0 ) { x request . remov header ( proxi header ) ; } els { string comma delimit list proxi = list comma delimit string ( proxi header valu ) ; x request . set header ( proxi header , comma delimit list proxi ) ; } ( new remot ip header valu . size ( ) = = 0 ) { x request . remov header ( remot ip header ) ; } els { string comma delimit remot ip header valu = list comma delimit string ( new remot ip header valu ) ; x request . set header ( remot ip header , comma delimit remot ip header valu ) ; } } ( protocol header = null ) { string protocol header valu = request . get header ( protocol header ) ; ( protocol header valu = = null ) { don t modifi secur , scheme server port attribut request } els ( protocol header http valu . equal ignor case ( protocol header valu ) ) { x request . set secur ( true ) ; x request . set scheme ( http ) ; set port ( x request , http server port ) ; } els { x request . set secur ( fals ) ; x request . set scheme ( http ) ; set port ( x request , http server port ) ; } } ( log . debug enabl ( ) ) { log . debug ( incom request request . get request uri ( ) origin remot addr request . get remot addr ( ) , origin remot host = request . get remot host ( ) , origin secur = request . secur ( ) , origin scheme = request . get scheme ( ) , origin remot ip header = concat remot ip header valu , origin protocol header = ( protocol header = = null null : request . get header ( protocol header ) ) seen new remot addr = x request . get remot addr ( ) , new remot host = x request . get remot host ( ) , new scheme = x request . get scheme ( ) , new secur = x request . secur ( ) , new remot ip header = x request . get header ( remot ip header ) , new proxi header = x request . get header ( proxi header ) ) ; } ( request attribut enabl ) { request . set attribut ( access log . remot addr attribut , request . get remot addr ( ) ) ; request . set attribut ( access log . remot host attribut , request . get remot host ( ) ) ; request . set attribut ( access log . protocol attribut , request . get protocol ( ) ) ; request . set attribut ( access log . server port attribut , integ . valu ( request . get server port ( ) ) ) ; } chain . do filter ( x request , respons ) ; } els { ( log . debug enabl ( ) ) { log . debug ( skip remot ip filter request request . get request uri ( ) origin remot addr request . get remot addr ( ) ) ; } chain . do filter ( request , respons ) ; } }	overrid public void set attribut ( string name , object valu ) { noop . prevent npe dure test . }	public void invok ( request request , respons respons ) throw ioexcept , servlet except { thi . remot host = request . get remot host ( ) ; thi . remot addr = request . get remot addr ( ) ; thi . scheme = request . get scheme ( ) ; thi . secur = request . secur ( ) ; thi . server port = request . get server port ( ) ; }	test public void test comma delimit list string arrai mix space char ( ) { string actual = remot ip valv . comma delimit list string arrai ( element1 , element2 , t element3 ) ; string expect = new string { element1 , element2 , element3 } ; assert arrai equal ( expect , actual ) ; }
overrid public void lifecycl event ( lifecycl event event ) { ( event . get type ( ) . equal ( lifecycl . after start event ) ) { object obj = event . get sourc ( ) ; ( obj instanceof wrapper ) { regist wrapper ( ( wrapper ) obj ) ; } els ( obj instanceof context ) { regist context ( ( context ) obj ) ; } els ( obj instanceof host ) { regist host ( ( host ) obj ) ; } } els ( event . get type ( ) . equal ( lifecycl . befor stop event ) ) { object obj = event . get sourc ( ) ; ( obj instanceof wrapper ) { unregist wrapper ( ( wrapper ) obj ) ; } els ( obj instanceof context ) { context c = ( context ) obj ; registr place prevent 404 s dure reload ( c . get paus ( ) ) { unregist context ( c ) ; } } els ( obj instanceof host ) { unregist host ( ( host ) obj ) ; } } }
public static onli us when known encod name lower case . charset get charset lower ( string lower case enc ) throw unsupport encod except { charset charset = encod charset cach . get ( lower case enc ) ; ( charset = = null ) { pre popul cach mean thi must invalid throw new unsupport encod except ( sm . get string ( b2c convert . unknown encod , lower case enc ) ) ; } return charset ; }	public convert buffer byte char . param bb input byte buffer param cb output char buffer param limit number byte convert throw ioexcept void convert ( byte chunk bb , char chunk cb , int limit ) throw ioexcept { ii . set byte chunk ( bb ) ; try { read from reader int bb length befor read = 0 ; while ( limit 0 ) { int size = limit buffer size limit : buffer size ; bb length befor read = bb . get length ( ) ; int cnt = conv . read ( result , 0 , size ) ; ( cnt = 0 ) { end stream we mai bad state ( log . debug enabl ( ) ) { log . debug ( b2cconvert : eof ) ; } return ; } ( log . debug enabl ( ) ) { log . debug ( b2cconvert : convert : new string ( result , 0 , cnt ) ) ; } cb . append ( result , 0 , cnt ) ; limit = limit ( bb length befor read bb . get length ( ) ) ; } } catch ( ioexcept ex ) { ( log . debug enabl ( ) ) { log . debug ( b2cconvert : reset convert ex . string ( ) ) ; } reset ( ) ; throw ex ; } }	public void reset ( ) throw ioexcept { destroi reader ii ii = new intermedi input stream ( ) ; conv = new read convertor ( ii , get charset ( encod ) ) ; }
overrid public t extend servlet t creat servlet ( class t c ) throw servlet except { try { t servlet = ( t ) context . get instanc manag ( ) . new instanc ( c . get name ( ) ) ; context . dynam servlet creat ( servlet ) ; return servlet ; } catch ( illeg access except e ) { throw new servlet except ( e ) ; } catch ( invoc target except e ) { except util . handl throwabl ( e . get caus ( ) ) ; throw new servlet except ( e ) ; } catch ( name except e ) { throw new servlet except ( e ) ; } catch ( instanti except e ) { throw new servlet except ( e ) ; } catch ( class found except e ) { throw new servlet except ( e ) ; } }	overrid public t extend filter t creat filter ( class t c ) throw servlet except { try { t filter = ( t ) context . get instanc manag ( ) . new instanc ( c . get name ( ) ) ; return filter ; } catch ( illeg access except e ) { throw new servlet except ( e ) ; } catch ( invoc target except e ) { except util . handl throwabl ( e . get caus ( ) ) ; throw new servlet except ( e ) ; } catch ( name except e ) { throw new servlet except ( e ) ; } catch ( instanti except e ) { throw new servlet except ( e ) ; } catch ( class found except e ) { throw new servlet except ( e ) ; } }	public void set filter name ( string filter name ) { thi . filter name = filter name ; }	public void set servlet name ( string servlet name ) { thi . servlet name = servlet name ; }	test public void test bug53467 ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; file app dir = new file ( test webapp 3 . 0 ) ; app dir rel server home tomcat . add webapp ( null , test , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; byte chunk re = new byte chunk ( ) ; int rc = get url ( http : localhost : get port ( ) test bug5nnnn bug53467 . jsp , re , null ) ; assert . assert equal ( http servlet respons . sc ok , rc ) ; assert . assert true ( re . string ( ) . contain ( p ok p ) ) ; }
privat void do test overrid default servlet sci ( string servlet name ) throw except { tomcat tomcat = get tomcat instanc ( ) ; file app dir = new file ( test webapp 3 . 0 ) ; standard context ctxt = ( standard context ) tomcat . add context ( null , test , app dir . get absolut path ( ) ) ; ctxt . set default web xml ( new file ( conf web . xml ) . get absolut path ( ) ) ; ctxt . add lifecycl listen ( new context config ( ) ) ; ctxt . add servlet contain initi ( new custom default servlet sci ( servlet name ) , null ) ; tomcat . start ( ) ; byte chunk re = new byte chunk ( ) ; int rc = get url ( http : localhost : get port ( ) test , re , null ) ; check return code assert equal ( http servlet respons . sc ok , rc ) ; check context assert equal ( ok custom default servlet , re . string ( ) ) ; }	public void startup ( set class >> c , servlet context ctx ) throw servlet except { servlet s = new custom default servlet ( ) ; servlet registr . dynam r = ctx . add servlet ( servlet name , s ) ; r . add map ( ) ; }	public void add absolut order ( string fragment name ) { ( absolut order = = null ) { absolut order = new link hash set ( ) ; } absolut order . add ( fragment name ) ; }	public set string get absolut order ( ) { return absolut order ; }	overrid public void begin ( string namespac , string name , attribut attribut ) throw except { ( login config set ) { throw new illeg argument except ( login config element limit 1 occurr ) ; } login config set = true ; }	public void set overrid ( boolean overrid ) { thi . overrid = overrid ; }	test public void test bug51396 ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; file app dir = new file ( test webapp 3 . 0 fragment ) ; app dir rel server home tomcat . add webapp ( null , test , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; byte chunk bc = new byte chunk ( ) ; int rc = get url ( http : localhost : get port ( ) test bug51396 . jsp , bc , null ) ; assert equal ( http servlet respons . sc ok , rc ) ; assert true ( bc . string ( ) . contain ( p ok p ) ) ; }	test public void test bug53574 ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; file app dir = new file ( test webapp 3 . 0 ) ; tomcat . add webapp ( null , test , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; byte chunk re = new byte chunk ( ) ; int rc = get url ( http : localhost : get port ( ) test bug53574 , re , null ) ; assert . assert equal ( http servlet respons . sc ok , rc ) ; string bodi = re . string ( ) ; assert . assert true ( bodi . contain ( ok ) ) ; }
suppress warn ( null ) privat static method resolv ambigu method ( set method candid , class param type ) { identifi which paramet isn t exact match method m = candid . iter ( ) . next ( ) ; int non match index = 0 ; class non match class = null ; ( int i = 0 ; i param type . length ; i ) { ( m . get paramet type ( ) i = param type i ) { non match index = i ; non match class = param type i ; break ; } } ( method c : candid ) { ( c . get paramet type ( ) non match index = = param type non match index ) { result ambigu return null ; } } can t null non match class = non match class . get superclass ( ) ; while ( non match class = null ) { ( method c : candid ) { ( c . get paramet type ( ) non match index . equal ( non match class ) ) { found match return c ; } } non match class = non match class . get superclass ( ) ; } return null ; }	privat static src alwai object boolean assign from ( class src , class target ) { class target class ; ( target . primit ( ) ) { ( target = = boolean . type ) { target class = boolean . class ; } els ( target = = charact . type ) { target class = charact . class ; } els ( target = = byte . type ) { target class = byte . class ; } els ( target = = short . type ) { target class = short . class ; } els ( target = = integ . type ) { target class = integ . class ; } els ( target = = long . type ) { target class = long . class ; } els ( target = = float . type ) { target class = float . class ; } els { target class = doubl . class ; } } els { target class = target ; } return target class . assign from ( src ) ; }	protect static final string param string ( class type ) { ( type = null ) { string builder sb = new string builder ( ) ; ( int i = 0 ; i type . length ; i ) { sb . append ( type i . get name ( ) ) . append ( , ) ; } ( sb . length ( ) 2 ) { sb . set length ( sb . length ( ) 2 ) ; } return sb . string ( ) ; } return null ; }	return method base criteria param base object own method param properti name method param param type paramet type us param param valu paramet valu return method specifi throw method found except suppress warn ( null ) public static method get method ( object base , object properti , class param type , object param valu ) throw method found except { ( base = = null properti = = null ) { throw new method found except ( messag factori . get ( error . method . notfound , base , properti , param string ( param type ) ) ) ; } string method name = ( properti instanceof string ) ( string ) properti : properti . string ( ) ; int param count ; ( param type = = null ) { param count = 0 ; } els { param count = param type . length ; } method method = base . get class ( ) . get method ( ) ; map method , integ candid = new hash map ( ) ; ( method m : method ) { ( m . get name ( ) . equal ( method name ) ) { method name doesn t match continu ; } class m param type = m . get paramet type ( ) ; int m param count ; ( m param type = = null ) { m param count = 0 ; } els { m param count = m param type . length ; } check number paramet ( ( param count = = m param count ( m . var arg ( ) param count = m param count ) ) ) { method ha wrong number paramet continu ; } check paramet match int exact match = 0 ; boolean match = fals ; ( int i = 0 ; i m param count ; i ) { can t null ( m param type i . equal ( param type i ) ) { exact match ; } els ( i = = ( m param count 1 ) m . var arg ( ) ) { class var type = m param type i . get compon type ( ) ; ( int j = i ; j param count ; j ) { ( assign from ( param type j , var type ) ) { ( param valu = = null ) { match = true ; break ; } els { ( coercibl from ( param valu j , var type ) ) { match = true ; break ; } } } don t treat var arg match exact match , can lead var arg method match when result should ambigu } } els ( assign from ( param type i , m param type i ) ) { ( param valu = = null ) { match = true ; break ; } els { ( coercibl from ( param valu i , m param type i ) ) { match = true ; break ; } } } } ( match ) { continu ; } return ( exact match = = param count ) { return m ; } candid . put ( m , integ . valu ( exact match ) ) ; } look method ha highest number paramet where type match exactli int best match = 0 ; method match = null ; boolean multipl = fals ; ( map . entri method , integ entri : candid . entri set ( ) ) { ( entri . get valu ( ) . int valu ( ) best match match = = null ) { best match = entri . get valu ( ) . int valu ( ) ; match = entri . get kei ( ) ; multipl = fals ; } els ( entri . get valu ( ) . int valu ( ) = = best match ) { multipl = true ; } } ( multipl ) { ( best match = = param count 1 ) { onli paramet exact match try us super class match = resolv ambigu method ( candid . kei set ( ) , param type ) ; } els { match = null ; } ( match = = null ) { match ambigu so throw except throw new method found except ( messag factori . get ( error . method . ambigu , base , properti , param string ( param type ) ) ) ; } } handl case where match all wa found ( match = = null ) { throw new method found except ( messag factori . get ( error . method . notfound , base , properti , param string ( param type ) ) ) ; } return match ; }
public synchron remov ani element list return content . void remov ( final entri element ) { ( element . get valid ( ) ) { return ; } entri next = element . get next ( ) ; entri prev = element . get previou ( ) ; ( next = null ) { next . set previou ( prev ) ; } els { last = prev ; } ( prev = null ) { prev . set next ( next ) ; } els { first = next ; } size ; element . set valid ( fals ) ; }
public static synchron boolean valid applic ( web resourc root resourc , context context ) throw ioexcept { string app name = context . get name ( ) ; arrai list manifest resourc app manifest resourc = new arrai list ( ) ; therefor valid ( resourc = = null ) return fals ; find manifest web applic input stream input stream = null ; try { web resourc resourc = resourc . get resourc ( meta inf manifest . mf ) ; ( resourc . file ( ) ) { input stream = resourc . get input stream ( ) ; manifest manifest = new manifest ( input stream ) ; input stream . close ( ) ; input stream = null ; manifest resourc mre = new manifest resourc ( sm . get string ( extens valid . web applic manifest ) , manifest , manifest resourc . war ) ; app manifest resourc . add ( mre ) ; } } final { ( input stream = null ) { try { input stream . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } } } try { web resourc jar = resourc . list resourc ( web inf lib ) ; ( web resourc jar : jar ) { ( jar . get name ( ) . lower case ( local . english ) . end ( . jar ) jar . file ( ) ) { input stream = jar . get input stream ( ) ; manifest jmanifest = get manifest ( input stream ) ; ( jmanifest = null ) { manifest resourc mre = new manifest resourc ( jar . get name ( ) , jmanifest , manifest resourc . applic ) ; app manifest resourc . add ( mre ) ; } } } } final { ( input stream = null ) { try { input stream . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } } } return valid manifest resourc ( app name , app manifest resourc ) ; }
public static main method entri point when start tomcat via provid script . param arg command line argument process void main ( string arg ) { ( daemon = = null ) { don t set daemon until init ( ) ha complet bootstrap bootstrap = new bootstrap ( ) ; try { bootstrap . init ( ) ; } catch ( throwabl t ) { handl throwabl ( t ) ; t . print stack trace ( ) ; return ; } daemon = bootstrap ; } try { string command = start ; ( arg . length 0 ) { command = arg arg . length 1 ; } ( command . equal ( startd ) ) { arg arg . length 1 = start ; daemon . load ( arg ) ; daemon . start ( ) ; } els ( command . equal ( stopd ) ) { arg arg . length 1 = stop ; daemon . stop ( ) ; } els ( command . equal ( start ) ) { daemon . set await ( true ) ; daemon . load ( arg ) ; daemon . start ( ) ; } els ( command . equal ( stop ) ) { daemon . stop server ( arg ) ; } els ( command . equal ( configtest ) ) { daemon . load ( arg ) ; ( null = = daemon . get server ( ) ) { system . exit ( 1 ) ; } system . exit ( 0 ) ; } els { log . warn ( bootstrap : command command doe exist . ) ; } } catch ( throwabl t ) { unwrap except clearer error report ( t instanceof invoc target except t . get caus ( ) = null ) { t = t . get caus ( ) ; } handl throwabl ( t ) ; t . print stack trace ( ) ; system . exit ( 1 ) ; } }
write portion string . param s string written param off offset from which start read charact param len number charact written overrid public void write ( string s , int off , int len ) throw ioexcept { ensur open ( ) ; ( buffer size = = 0 ) { init out ( ) ; out . write ( s , off , len ) ; return ; } int b = off , t = off len ; while ( b t ) { int d = min ( buffer size next char , t b ) ; s . get char ( b , b d , cb , next char ) ; b = d ; next char = d ; ( next char = buffer size ) ( auto flush ) flush buffer ( ) ; els buffer overflow ( ) ; } }
connect pool mbean exist , regist dure thi oper . br { inherit doc } overrid public object name pre regist ( mbean server server , object name name ) throw except { try { thi . onam = creat object name ( name ) ; ( onam = null ) regist jmx ( ) ; } catch ( malform object name except x ) { log . error ( unabl creat object name jdbc pool . , x ) ; } return name ; }
protect close pool all disconnect all idl connect activ connect close upon { link java . sql . connect close close } method call underli connect instead return pool param forc true even close activ connect void close ( boolean forc ) { ar we alreadi close ( thi . close ) return ; prevent other thread from enter thi . close = true ; stop background thread ( pool cleaner = null ) { pool cleaner . stop run ( ) ; } releas all idl connect block queue pool connect pool = ( idl . size ( ) 0 ) idl : ( forc busi : idl ) ; while ( pool . size ( ) 0 ) { try { retriev next connect pool connect con = pool . poll ( 1000 , time unit . millisecond ) ; close retriev next , avail while ( con = null ) { close connect ( pool = = idl ) releas ( con ) ; els abandon ( con ) ; ( pool . size ( ) 0 ) { con = pool . poll ( 1000 , time unit . millisecond ) ; } els { break ; } } while } catch ( interrupt except ex ) { ( get pool properti ( ) . get propag interrupt state ( ) ) { thread . current thread ( ) . interrupt ( ) ; } els { thread . interrupt ( ) ; } } ( pool . size ( ) = = 0 forc pool = busi ) pool = busi ; } ( thi . get pool properti ( ) . jmx enabl ( ) ) thi . jmx pool = null ; pool properti . interceptor definit proxi = get pool properti ( ) . get jdbc interceptor arrai ( ) ; ( int i = 0 ; i proxi . length ; i ) { try { proxi i . get interceptor class ( ) . new instanc ( ) . pool close ( thi ) ; } catch ( except x ) { log . debug ( unabl inform interceptor pool closur . , x ) ; } } }
public void test bug53071 ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; tomcat . add servlet ( ctx , error servlet , new error servlet ( ) ) ; ctx . add servlet map ( , error servlet ) ; tomcat . start ( ) ; byte chunk re = get url ( http : localhost : get port ( ) ) ; assert . assert true ( re . string ( ) . contain ( p b messag b u error servlet . error text u p ) ) ; }	protect print out error report . param request request process param respons respons gener param throwabl except occur ( which possibl wrap root caus except void report ( request request , respons respons , throwabl throwabl ) { do noth non http respons int statu code = respons . get statu ( ) ; do noth anyth ha been written alreadi ( ( statu code 400 ) ( respons . get content written ( ) 0 ) ) { return ; } string messag = request util . filter ( respons . get messag ( ) ) ; ( messag = = null ) { ( throwabl = null ) { string except messag = throwabl . get messag ( ) ; ( except messag = null except messag . length ( ) 0 ) { messag = request util . filter ( ( new scanner ( except messag ) ) . next line ( ) ) ; } } ( messag = = null ) { messag = ; } } do noth report specifi statu code string report = null ; try { report = sm . get string ( http . statu code ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } ( report = = null ) { return ; } string builder sb = new string builder ( ) ; sb . append ( html head titl ) ; sb . append ( server info . get server info ( ) ) . append ( ) ; sb . append ( sm . get string ( error report valv . error report ) ) ; sb . append ( titl ) ; sb . append ( style ) ; sb . append ( org . apach . catalina . util . tomcat css . tomcat css ) ; sb . append ( style ) ; sb . append ( head bodi ) ; sb . append ( h1 ) ; sb . append ( sm . get string ( error report valv . statu header , statu code , messag ) ) . append ( h1 ) ; sb . append ( hr size = 1 noshad = noshad ) ; sb . append ( p b type b ) ; ( throwabl = null ) { sb . append ( sm . get string ( error report valv . except report ) ) ; } els { sb . append ( sm . get string ( error report valv . statu report ) ) ; } sb . append ( p ) ; sb . append ( p b ) ; sb . append ( sm . get string ( error report valv . messag ) ) ; sb . append ( b u ) ; sb . append ( messag ) . append ( u p ) ; sb . append ( p b ) ; sb . append ( sm . get string ( error report valv . descript ) ) ; sb . append ( b u ) ; sb . append ( report ) ; sb . append ( u p ) ; ( throwabl = null ) { string stack trace = get partial servlet stack trace ( throwabl ) ; sb . append ( p b ) ; sb . append ( sm . get string ( error report valv . except ) ) ; sb . append ( b pre ) ; sb . append ( request util . filter ( stack trace ) ) ; sb . append ( pre p ) ; int loop = 0 ; throwabl root caus = throwabl . get caus ( ) ; while ( root caus = null ( loop 10 ) ) { stack trace = get partial servlet stack trace ( root caus ) ; sb . append ( p b ) ; sb . append ( sm . get string ( error report valv . root caus ) ) ; sb . append ( b pre ) ; sb . append ( request util . filter ( stack trace ) ) ; sb . append ( pre p ) ; case root caus somehow heavili nest root caus = root caus . get caus ( ) ; loop ; } sb . append ( p b ) ; sb . append ( sm . get string ( error report valv . note ) ) ; sb . append ( b u ) ; sb . append ( sm . get string ( error report valv . root caus log , server info . get server info ( ) ) ) ; sb . append ( u p ) ; } sb . append ( hr size = 1 noshad = noshad ) ; sb . append ( h3 ) . append ( server info . get server info ( ) ) . append ( h3 ) ; sb . append ( bodi html ) ; try { try { respons . set content type ( text html ) ; respons . set charact encod ( utf 8 ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; ( contain . get logger ( ) . debug enabl ( ) ) { contain . get logger ( ) . debug ( statu . set content type , t ) ; } } writer writer = respons . get report ( ) ; ( writer = null ) { writer null , s indic respons ha been hard commit alreadi , which should never happen writer . write ( sb . string ( ) ) ; } } catch ( ioexcept e ) { ignor } catch ( illeg state except e ) { ignor } }
public static timer get pool timer ( ) { return pool clean timer ; }	public static timer get pool timer ( ) { return pool clean timer ; }


escap buffer cannot null suppress warn ( null ) public static string escap xml ( string buffer ) { int start = 0 ; int length = buffer . length ( ) ; char arrai buffer = buffer . char arrai ( ) ; string builder escap buffer = null ; ( int i = 0 ; i length ; i ) { char c = arrai buffer i ; ( c = highest special ) { char escap = special charact represent c ; ( escap = null ) { creat string builder hold escap xml string ( start = = 0 ) { escap buffer = new string builder ( length 5 ) ; } add unescap portion ( start i ) { escap buffer . append ( arrai buffer , start , i start ) ; } start = i 1 ; add escap xml escap buffer . append ( escap ) ; } } } xml escap wa necessari ( start = = 0 ) { return buffer ; } add rest unescap portion ( start length ) { escap buffer . append ( arrai buffer , start , length start ) ; } return escap buffer . string ( ) ; }	public static strip servlet session id from tt url tt . session id encod url path paramet begin jsessionid = . we thu remov anyth we find between ; jsessionid = ( inclus ) either eo subsequ ; ( exclus ) . taken from org . apach . taglib . standard . tag . common . core . import support string strip session ( string url ) { string builder u = new string builder ( url ) ; int session start ; while ( ( session start = u . string ( ) . index ( ; constant . session paramet name = ) ) = 1 ) { int session end = u . string ( ) . index ( ; , session start 1 ) ; ( session end = = 1 ) session end = u . string ( ) . index ( , session start 1 ) ; ( still session end = = 1 ) session end = u . length ( ) ; u . delet ( session start , session end ) ; } return u . string ( ) ; }	public static boolean output ( jsp writer out , string valu , string default valu , boolean escap xml ) throw ioexcept { string v = valu = null valu : default valu ; ( v = null ) { ( escap xml ) { v = org . apach . jasper . tagplugin . jstl . util . escap xml ( v ) ; } out . write ( v ) ; return true ; } els { return fals ; } }	public void do tag ( tag plugin context ctxt ) { two data member ar indic whether correspond attribut specifi boolean ha default = fals , ha escap xml = fals ; ha default = ctxt . attribut specifi ( default ) ; ha escap xml = ctxt . attribut specifi ( escap xml ) ; str val name , str escap xml name str def name ar two variabl name stand valu , escap xml default attribut string str val name = ctxt . get temporari variabl name ( ) ; string str def name = ctxt . get temporari variabl name ( ) ; string str escap xml name = ctxt . get temporari variabl name ( ) ; string str skip bodi name = ctxt . get temporari variabl name ( ) ; accord tag file , valu attribut mandatori . ctxt . gener java sourc ( string str val name = null ; ) ; ctxt . gener java sourc ( ( ) ; ctxt . gener attribut ( valu ) ; ctxt . gener java sourc ( = null ) { ) ; ctxt . gener java sourc ( str val name = ( ) ; ctxt . gener attribut ( valu ) ; ctxt . gener java sourc ( ) . string ( ) ; ) ; ctxt . gener java sourc ( } ) ; initi str def name null . default ha been specifi , assign valu ; ctxt . gener java sourc ( string str def name = null ; n ) ; ( ha default ) { ctxt . gener java sourc ( ( ) ; ctxt . gener attribut ( default ) ; ctxt . gener java sourc ( = null ) { ) ; ctxt . gener java sourc ( str def name = ( ) ; ctxt . gener attribut ( default ) ; ctxt . gener java sourc ( ) . string ( ) ; ) ; ctxt . gener java sourc ( } ) ; } initi str escap xml name true ; escap xml specifi , assign valu ; ctxt . gener java sourc ( boolean str escap xml name = true ; ) ; ( ha escap xml ) { ctxt . gener java sourc ( str escap xml name = ) ; ctxt . gener attribut ( escap xml ) ; ctxt . gener java sourc ( ; ) ; } main part . ctxt . gener java sourc ( boolean str skip bodi name = org . apach . jasper . tagplugin . jstl . core . out . output ( out , str val name , str def name , str escap xml name ) ; ) ; ctxt . gener java sourc ( ( str skip bodi name ) { ) ; ctxt . gener bodi ( ) ; ctxt . gener java sourc ( } ) ; }	test public void test bug54144 ( ) throw except { byte chunk re = new byte chunk ( ) ; int rc = get url ( http : localhost : get port ( ) test bug54144 . jsp , re , null ) ; assert . assert equal ( http servlet respons . sc ok , rc ) ; string bodi = re . string ( ) ; assert . assert true ( bodi . contain ( ok 1 ) ) ; assert . assert true ( bodi . contain ( ok 2 ) ) ; assert . assert true ( bodi . contain ( ok 3 ) ) ; assert . assert fals ( bodi . contain ( fail ) ) ; }
public static write vm state . mode 0 gener html . mode 1 gener xml . void write vmstate ( print writer writer , int mode ) throw except { ( mode = = 0 ) { writer . print ( h1 jvm h1 ) ; writer . print ( p ) ; writer . print ( free memori : ) ; writer . print ( format size ( long . valu ( runtim . get runtim ( ) . free memori ( ) ) , true ) ) ; writer . print ( total memori : ) ; writer . print ( format size ( long . valu ( runtim . get runtim ( ) . total memori ( ) ) , true ) ) ; writer . print ( max memori : ) ; writer . print ( format size ( long . valu ( runtim . get runtim ( ) . max memori ( ) ) , true ) ) ; writer . print ( p ) ; } els ( mode = = 1 ) { writer . write ( jvm ) ; writer . write ( memori ) ; writer . write ( free = runtim . get runtim ( ) . free memori ( ) ) ; writer . write ( total = runtim . get runtim ( ) . total memori ( ) ) ; writer . write ( max = runtim . get runtim ( ) . max memori ( ) ) ; writer . write ( jvm ) ; } }
p add set rule instanc defin thi rule set specifi code digest code instanc , associ them our namespac uri ( ani ) . thi method should onli call digest instanc . p param digest digest instanc which new rule instanc should ad . overrid public void add rule instanc ( digest digest ) { digest . add object creat ( prefix realm , must specifi element , null , class name ) ; digest . add set properti ( prefix realm ) ; digest . add set next ( prefix realm , set realm , org . apach . catalina . realm ) ; digest . add object creat ( prefix realm realm , must specifi element null , class name ) ; digest . add set properti ( prefix realm realm ) ; digest . add set next ( prefix realm realm , add realm , org . apach . catalina . realm ) ; }
protect receiv standard http request from public code servic code method dispatch them code do code i method i method defin thi class . thi method http specif version { link javax . servlet . servlet servic } method . s need overrid thi method . param req { link http servlet request } object contain request client made servlet param resp { link http servlet respons } object contain respons servlet return client except ioexcept input output error occur while servlet handl http request except servlet except http request cannot handl see javax . servlet . servlet servic void servic ( http servlet request req , http servlet respons resp ) throw servlet except , ioexcept { string method = req . get method ( ) ; ( method . equal ( method get ) ) { long last modifi = get last modifi ( req ) ; ( last modifi = = 1 ) { servlet doesn t support modifi sinc , reason go through further expens logic do get ( req , resp ) ; } els { long modifi sinc = req . get date header ( header ifmodsinc ) ; ( modifi sinc ( last modifi 1000 1000 ) ) { servlet mod time later , call do get ( ) round down nearest second proper compar modifi sinc 1 alwai less mayb set last modifi ( resp , last modifi ) ; do get ( req , resp ) ; } els { resp . set statu ( http servlet respons . sc modifi ) ; } } } els ( method . equal ( method head ) ) { long last modifi = get last modifi ( req ) ; mayb set last modifi ( resp , last modifi ) ; do head ( req , resp ) ; } els ( method . equal ( method post ) ) { do post ( req , resp ) ; } els ( method . equal ( method put ) ) { do put ( req , resp ) ; } els ( method . equal ( method delet ) ) { do delet ( req , resp ) ; } els ( method . equal ( method option ) ) { do option ( req , resp ) ; } els ( method . equal ( method trace ) ) { do trace ( req , resp ) ; } els { note thi mean servlet support whatev method wa request , anywher thi server . string err msg = l string . get string ( http . method implement ) ; object err arg = new object 1 ; err arg 0 = method ; err msg = messag format . format ( err msg , err arg ) ; resp . send error ( http servlet respons . sc implement , err msg ) ; } }
public string get respons bodi ( ) { return respons bodi ; }	public void process request ( boolean want bodi ) throw ioexcept , interrupt except { send request ( ) ; read respons ( want bodi ) ; }	public void send request ( ) throw interrupt except , ioexcept { send request boolean first = true ; ( string request part : request ) { ( first ) { first = fals ; } els { thread . sleep ( request paus ) ; } writer . write ( request part ) ; writer . flush ( ) ; } }	public void set request ( string request ) { request = request ; }
overrid public void dispatch ( servlet context context , string path ) { ( log . debug enabl ( ) ) { log debug ( dispatch ) ; } check ( ) ; ( request . get attribut ( async request uri ) = = null ) { request . set attribut ( async request uri , request . get request uri ( ) request . get queri string ( ) ) ; request . set attribut ( async context path , request . get context path ( ) ) ; request . set attribut ( async servlet path , request . get servlet path ( ) ) ; request . set attribut ( async queri string , request . get queri string ( ) ) ; } final request dispatch request dispatch = context . get request dispatch ( path ) ; ( ( request dispatch instanceof async dispatch ) ) { throw new unsupport oper except ( sm . get string ( async context impl . async dispatch ) ) ; } final async dispatch applic dispatch = ( async dispatch ) request dispatch ; final http servlet request servlet request = ( http servlet request ) get request ( ) ; final http servlet respons servlet respons = ( http servlet respons ) get respons ( ) ; runnabl run = new runnabl ( ) { overrid } }
privat void do test timeout ( boolean complet timeout , string dispatch url ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; creat folder trigger redirect file foo = new file ( doc base , async ) ; add delet tear down ( foo ) ; ( foo . mkdir ( ) foo . directori ( ) ) { fail ( unabl creat async directori doc base ) ; } context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; timeout servlet timeout = new timeout servlet ( complet timeout , dispatch url ) ; wrapper wrapper = tomcat . add servlet ( ctx , time , timeout ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( async , time ) ; ( dispatch url = null ) { non async servlet non async = new non async servlet ( ) ; tomcat . add servlet ( ctx , nonasync , non async ) ; ctx . add servlet map ( dispatch url , nonasync ) ; } ctx . add applic listen ( track request listen . class . get name ( ) ) ; tester access log valv alv = new tester access log valv ( ) ; ctx . get pipelin ( ) . add valv ( alv ) ; tester access log valv alv global = new tester access log valv ( ) ; tomcat . get host ( ) . get pipelin ( ) . add valv ( alv global ) ; tomcat . start ( ) ; byte chunk re = new byte chunk ( ) ; try { get url ( http : localhost : get port ( ) async , re , null ) ; } catch ( ioexcept ioe ) { ignor expect some error condit } string builder expect = new string builder ( request initi ) ; expect . append ( timeout servlet get timeout ) ; ( complet timeout ) { ( dispatch url = = null ) { expect . append ( complet ) ; expect . append ( request destroi ) ; } els { error further output complet sinc complet event would fire dure post process sinc error never happen . } } els { ( dispatch url = = null ) { expect . append ( error ) ; } els { expect . append ( non async servlet get ) ; } expect . append ( complet ) ; expect . append ( request destroi ) ; } assert equal ( expect . string ( ) , re . string ( ) ) ; check access log ( complet timeout dispatch url = null ) { thi error written host level access log valv onli alv global . valid access log ( 1 , 500 , 0 , timeout servlet . async timeout timeout margin request time ) ; alv . valid access log ( 0 , 500 , 0 , 0 ) ; } els { alv global . valid access log ( 1 , 200 , timeout servlet . async timeout , timeout servlet . async timeout timeout margin request time ) ; alv . valid access log ( 1 , 200 , timeout servlet . async timeout , timeout servlet . async timeout timeout margin request time ) ; } }	privat handl http statu code ( correspond messag ) gener while process specifi request produc specifi respons . ani except occur dure gener error report ar log swallow . param request request process param respons respons gener void statu ( request request , respons respons ) { int statu code = respons . get statu ( ) ; handl custom error page thi statu code context context = request . get context ( ) ; ( context = = null ) { return ; } onli look error page when error ( ) set . error ( ) set when respons . send error ( ) invok . thi allow custom error page without reli default from web . xml . ( respons . error ( ) ) { return ; } error page error page = context . find error page ( statu code ) ; ( error page = = null ) { look default error page error page = context . find error page ( 0 ) ; } ( error page = null ) { respons . set app commit ( fals ) ; request . set attribut ( request dispatch . error statu code , integ . valu ( statu code ) ) ; string messag = respons . get messag ( ) ; ( messag = = null ) { messag = ; } request . set attribut ( request dispatch . error messag , messag ) ; request . set attribut ( global . dispatch request path attr , error page . get locat ( ) ) ; request . set attribut ( global . dispatch type attr , dispatch type . error ) ; wrapper wrapper = request . get wrapper ( ) ; ( wrapper = null ) { request . set attribut ( request dispatch . error servlet name , wrapper . get name ( ) ) ; } request . set attribut ( request dispatch . error request uri , request . get request uri ( ) ) ; ( custom ( request , respons , error page ) ) { try { respons . flush buffer ( ) ; } catch ( client abort except e ) { ignor } catch ( ioexcept e ) { contain . get logger ( ) . warn ( except process error page , e ) ; } } } }	test public void test bug53843 ( ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; bug53843servlet servlet = new bug53843servlet ( ) ; wrapper = tomcat . add servlet ( ctx , servlet , servlet ) ; . set async support ( true ) ; tomcat . add servlet ( ctx , servlet b , new bug53843servlet b ( ) ) ; ctx . add servlet map ( servlet , servlet ) ; ctx . add servlet map ( servlet b , servlet b ) ; tomcat . start ( ) ; string builder url = new string builder ( 48 ) ; url . append ( http : localhost : ) ; url . append ( get port ( ) ) ; url . append ( servlet ) ; byte chunk bodi = new byte chunk ( ) ; int rc = get url ( url . string ( ) , bodi , null ) ; assert equal ( http servlet respons . sc ok , rc ) ; assert equal ( ok , bodi . string ( ) ) ; assert true ( servlet . async when expect ( ) ) ; }	public boolean timeout ( ) throw ioexcept { atom boolean result = new atom boolean ( ) ; request . get coyot request ( ) . action ( action code . async timeout , result ) ; ( result . get ( ) ) { class loader old cl = thread . current thread ( ) . get context class loader ( ) ; class loader new cl = request . get context ( ) . get loader ( ) . get class loader ( ) ; try { thread . current thread ( ) . set context class loader ( new cl ) ; boolean listen invok = fals ; list async listen wrapper listen copi = new arrai list ( ) ; listen copi . add all ( listen ) ; ( async listen wrapper listen : listen copi ) { listen . fire timeout ( event ) ; listen invok = true ; } ( listen invok ) { request . get coyot request ( ) . action ( action code . async timingout , result ) ; return result . get ( ) ; } els { listen , contain call complet complet ( ) ; } } final { thread . current thread ( ) . set context class loader ( old cl ) ; } } return true ; }	select appropri child context process thi request , base specifi request uri . match context can found , return appropri http error . param request request process param respons respons produc except ioexcept input output error occur except servlet except servlet error occur overrid public final void invok ( request request , respons respons ) throw ioexcept , servlet except { select context us thi request context context = request . get context ( ) ; ( context = = null ) { respons . send error ( http servlet respons . sc intern server error , sm . get string ( standard host . context ) ) ; return ; } bind context cl current thread ( context . get loader ( ) = null ) { thi should eventu move engin , s gener . ( global . secur enabl ) { privileg action void pa = new privileg set tccl ( context . get loader ( ) . get class loader ( ) ) ; access control . do privileg ( pa ) ; } els { thread . current thread ( ) . set context class loader ( context . get loader ( ) . get class loader ( ) ) ; } } ( request . async support ( ) ) { request . set async support ( context . get pipelin ( ) . async support ( ) ) ; } don t fire listen dure async process request init listen throw except , request abort boolean async start = request . async ( ) ; ( async start context . fire request init event ( request ) ) { ask thi context process thi request try { context . get pipelin ( ) . get first ( ) . invok ( request , respons ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; request . set attribut ( request dispatch . error except , t ) ; throwabl ( request , respons , t ) ; } place ( ( request . async ( ) ( async start request . get attribut ( request dispatch . error except ) = null ) ) ) { run request . ( context . get state ( ) . avail ( ) ) { error page process respons . set suspend ( fals ) ; throwabl t = ( throwabl ) request . get attribut ( request dispatch . error except ) ; ( t = null ) { throwabl ( request , respons , t ) ; } els { statu ( request , respons ) ; } context . fire request destroi event ( request ) ; } } } strict interpret specif ( access session ) { request . get session ( fals ) ; } restor context classload ( global . secur enabl ) { privileg action void pa = new privileg set tccl ( my classload ) ; access control . do privileg ( pa ) ; } els { thread . current thread ( ) . set context class loader ( my classload ) ; } }	public synchron boolean async dispatch ( ) { boolean do dispatch = fals ; ( state = = async state . start ) { state = async state . must dispatch ; } els ( state = = async state . start state = = async state . time out ) { state = async state . dispatch ; do dispatch = true ; } els { throw new illeg state except ( sm . get string ( async state machin . invalid async state , async dispatch ( ) , state ) ) ; } return do dispatch ; }	public void set error state ( throwabl t ) { ( t = null ) request . set attribut ( request dispatch . error except , t ) ; request . get coyot request ( ) . action ( action code . async error , null ) ; async event error event = new async event ( event . get async context ( ) , event . get suppli request ( ) , event . get suppli respons ( ) , t ) ; list async listen wrapper listen copi = new arrai list ( ) ; listen copi . add all ( listen ) ; ( async listen wrapper listen : listen copi ) { try { listen . fire error ( error event ) ; } catch ( ioexcept ioe ) { log . warn ( start async ( ) fail listen type listen . get class ( ) . get name ( ) , ioe ) ; } } }	test public void test async start complet ( ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; minimis paus dure test tomcat . get connector ( ) . set attribut ( connect timeout , integ . valu ( 3000 ) ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; async start complet servlet servlet = new async start complet servlet ( ) ; wrapper wrapper = tomcat . add servlet ( ctx , servlet , servlet ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( , servlet ) ; tester access log valv alv = new tester access log valv ( ) ; ctx . get pipelin ( ) . add valv ( alv ) ; tomcat . start ( ) ; call servlet first time byte chunk bc1 = get url ( http : localhost : get port ( ) echo = run1 ) ; assert equal ( ok run1 , bc1 . string ( ) ) ; call servlet second time request paramet byte chunk bc2 = get url ( http : localhost : get port ( ) echo = run2 ) ; assert equal ( ok run2 , bc2 . string ( ) ) ; check access log alv . valid access log ( 2 , 200 , async start complet servlet . async timeout , async start complet servlet . async timeout timeout margin request time ) ; }	test public void test listen ( ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; track servlet track = new track servlet ( ) ; wrapper wrapper = tomcat . add servlet ( ctx , track , track ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( stage1 , track ) ; timeout servlet timeout = new timeout servlet ( true , null ) ; wrapper wrapper2 = tomcat . add servlet ( ctx , timeout , timeout ) ; wrapper2 . set async support ( true ) ; ctx . add servlet map ( stage2 , timeout ) ; tester access log valv alv = new tester access log valv ( ) ; ctx . get pipelin ( ) . add valv ( alv ) ; tomcat . start ( ) ; string builder url = new string builder ( 48 ) ; url . append ( http : localhost : ) ; url . append ( get port ( ) ) ; url . append ( stage1 ) ; byte chunk re = get url ( url . string ( ) ) ; assert equal ( dispatch servlet get dispatch servlet get start async timeout servlet get start async timeout complet , re . string ( ) ) ; check access log alv . valid access log ( 1 , 200 , timeout servlet . async timeout , timeout servlet . async timeout timeout margin request time ) ; }	test public void test timeout listen complet dispatch ( ) throw except { should trigger error can t do both do test timeout ( true , nonasync ) ; }	test public void test timeout listen complet dispatch ( ) throw except { should work do test timeout ( true , null ) ; }	test public void test timeout listen complet dispatch ( ) throw except { should work do test timeout ( fals , nonasync ) ; }	test public void test timeout listen complet dispatch ( ) throw except { should trigger error must do other do test timeout ( fals , null ) ; }
public synchron send pong messag client param data option messag . throw ioexcept error occur write client void pong ( byte buffer data ) throw ioexcept { ( close ) { throw new ioexcept ( sm . get string ( outbound . close ) ) ; } do flush ( true ) ; upgrad outbound . write ( 0x8a ) ; ( data = = null ) { upgrad outbound . write ( 0 ) ; } els { upgrad outbound . write ( data . limit ( ) data . posit ( ) ) ; upgrad outbound . write ( data . arrai ( ) , data . posit ( ) , data . limit ( ) data . posit ( ) ) ; } upgrad outbound . flush ( ) ; }
public set specifi environ entri name context . void add environ ( context environ env ) { object valu = null ; instanti new instanc correct object type , initi . string type = env . get type ( ) ; try { ( type . equal ( java . lang . string ) ) { valu = env . get valu ( ) ; } els ( type . equal ( java . lang . byte ) ) { ( env . get valu ( ) = = null ) { valu = byte . valu ( ( byte ) 0 ) ; } els { valu = byte . decod ( env . get valu ( ) ) ; } } els ( type . equal ( java . lang . short ) ) { ( env . get valu ( ) = = null ) { valu = short . valu ( ( short ) 0 ) ; } els { valu = short . decod ( env . get valu ( ) ) ; } } els ( type . equal ( java . lang . integ ) ) { ( env . get valu ( ) = = null ) { valu = integ . valu ( 0 ) ; } els { valu = integ . decod ( env . get valu ( ) ) ; } } els ( type . equal ( java . lang . long ) ) { ( env . get valu ( ) = = null ) { valu = long . valu ( 0 ) ; } els { valu = long . decod ( env . get valu ( ) ) ; } } els ( type . equal ( java . lang . boolean ) ) { valu = boolean . valu ( env . get valu ( ) ) ; } els ( type . equal ( java . lang . doubl ) ) { ( env . get valu ( ) = = null ) { valu = doubl . valu ( 0 ) ; } els { valu = doubl . valu ( env . get valu ( ) ) ; } } els ( type . equal ( java . lang . float ) ) { ( env . get valu ( ) = = null ) { valu = float . valu ( 0 ) ; } els { valu = float . valu ( env . get valu ( ) ) ; } } els ( type . equal ( java . lang . charact ) ) { ( env . get valu ( ) = = null ) { valu = charact . valu ( ( char ) 0 ) ; } els { ( env . get valu ( ) . length ( ) = = 1 ) { valu = charact . valu ( env . get valu ( ) . char ( 0 ) ) ; } els { throw new illeg argument except ( ) ; } } } els { logger . error ( sm . get string ( name . invalid env entri type , env . get name ( ) ) ) ; } } catch ( number format except e ) { logger . error ( sm . get string ( name . invalid env entri valu , env . get name ( ) ) ) ; } catch ( illeg argument except e ) { logger . error ( sm . get string ( name . invalid env entri valu , env . get name ( ) ) ) ; } bind object appropri name ( valu = null ) { try { ( logger . debug enabl ( ) ) logger . debug ( ad environ entri env . get name ( ) ) ; creat subcontext ( env ctx , env . get name ( ) ) ; env ctx . bind ( env . get name ( ) , valu ) ; } catch ( name except e ) { logger . error ( sm . get string ( name . invalid env entri valu , e ) ) ; } } }	overrid public void context initi ( servlet context event sce ) { javax . name . context init ctx ; try { init ctx = new initi context ( ) ; javax . name . context env ctx = ( javax . name . context ) init ctx . lookup ( java : comp env ) ; string valu = ( string ) env ctx . lookup ( jndi name ) ; ( jndi valu . equal ( valu ) ) { throw new runtim except ( ) ; } } catch ( name except e ) { throw new runtim except ( e ) ; } }	public void test bug49132 ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp org . apach . catalina . context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; enabl jndi disabl default tomcat . enabl name ( ) ; context environ environ = new context environ ( ) ; environ . set type ( jndi valu . get class ( ) . get name ( ) ) ; environ . set name ( jndi name ) ; environ . set valu ( jndi valu ) ; ctx . get name resourc ( ) . add environ ( environ ) ; ctx . add applic listen ( bug49132listen . class . get name ( ) ) ; tomcat . start ( ) ; assert equal ( lifecycl state . start , ctx . get state ( ) ) ; }
public void set store deleg credenti ( boolean store deleg credenti ) { thi . store deleg credenti = store deleg credenti ; }
public static gener sub set web fragment . xml file process order fragment must process per rule servlet spec . param applic applic web . xml file param fragment map fragment name web fragment return order list web fragment . xml file process set web xml order web fragment ( web xml applic , map string , web xml fragment ) { set web xml order fragment = new link hash set ( ) ; boolean absolut order = ( applic . get absolut order ( ) = null ) ; ( absolut order ) { onli those fragment list should process set string request order = applic . get absolut order ( ) ; ( string request name : request order ) { ( web xml . order other . equal ( request name ) ) { add all fragment name explicitli thi point ( entri string , web xml entri : fragment . entri set ( ) ) { ( request order . contain ( entri . get kei ( ) ) ) { web xml fragment = entri . get valu ( ) ; ( fragment = null ) { order fragment . add ( fragment ) ; } } } } els { web xml fragment = fragment . get ( request name ) ; ( fragment = null ) { order fragment . add ( fragment ) ; } els { log . warn ( sm . get string ( web xml . wrong fragment name , request name ) ) ; } } } } els { list string order = new link list ( ) ; start ad all fragment order doesn t matter order . add all ( fragment . kei set ( ) ) ; thei specifi other ( web xml fragment : fragment . valu ( ) ) { string name = fragment . get name ( ) ; ( fragment . get befor order ( ) . contain ( web xml . order other ) ) { move begin order . remov ( name ) ; order . add ( 0 , name ) ; } els ( fragment . get after order ( ) . contain ( web xml . order other ) ) { move end order . remov ( name ) ; order . add ( name ) ; } } now appli remain order ( web xml fragment : fragment . valu ( ) ) { string name = fragment . get name ( ) ; ( string befor : fragment . get befor order ( ) ) { ( befor . equal ( web xml . order other ) order . contain ( befor ) order . index ( befor ) order . index ( name ) ) { order . remov ( name ) ; order . add ( order . index ( befor ) , name ) ; } } ( string after : fragment . get after order ( ) ) { ( after . equal ( web xml . order other ) order . contain ( after ) order . index ( after ) order . index ( name ) ) { order . remov ( name ) ; order . add ( order . index ( after ) 1 , name ) ; } } } error indic circular refer ( web xml fragment : fragment . valu ( ) ) { string name = fragment . get name ( ) ; ( string befor : fragment . get befor order ( ) ) { ( befor . equal ( web xml . order other ) order . contain ( befor ) order . index ( befor ) order . index ( name ) ) { throw new illeg argument except ( sm . get string ( web xml . merg conflict order ) ) ; } } ( string after : fragment . get after order ( ) ) { ( after . equal ( web xml . order other ) order . contain ( after ) order . index ( after ) order . index ( name ) ) { throw new illeg argument except ( sm . get string ( web xml . merg conflict order ) ) ; } } } build order list ( string name : order ) { order fragment . add ( fragment . get ( name ) ) ; } } return order fragment ; }	public void set up ( ) throw except { app = new web xml ( ) ; = new web xml ( ) ; . set name ( ) ; b = new web xml ( ) ; b . set name ( b ) ; c = new web xml ( ) ; c . set name ( c ) ; d = new web xml ( ) ; d . set name ( d ) ; e = new web xml ( ) ; e . set name ( e ) ; f = new web xml ( ) ; f . set name ( f ) ; fragment = new hash map ( ) ; fragment . put ( , ) ; fragment . put ( b , b ) ; fragment . put ( c , c ) ; fragment . put ( d , d ) ; fragment . put ( e , e ) ; fragment . put ( f , f ) ; }	test public void test order web fragment absolut other end ( ) { app . add absolut order ( b ) ; app . add absolut order ( d ) ; app . add absolut order ( web xml . order other ) ; set web xml other = new hash set ( ) ; other . add ( ) ; other . add ( c ) ; other . add ( e ) ; other . add ( f ) ; set web xml order = web xml . order web fragment ( app , fragment ) ; iter web xml iter = order . iter ( ) ; assert equal ( b , iter . next ( ) ) ; assert equal ( d , iter . next ( ) ) ; while ( other . size ( ) 0 ) { web xml o = iter . next ( ) ; assert true ( other . contain ( o ) ) ; other . remov ( o ) ; } assert fals ( iter . ha next ( ) ) ; }	test public void test order web fragment relative1 ( ) { first exampl from servlet spec . add after order other ( ) ; . add after order ( c ) ; b . add befor order other ( ) ; c . add after order other ( ) ; f . add befor order other ( ) ; f . add befor order ( b ) ; set web xml order = web xml . order web fragment ( app , fragment ) ; iter web xml iter = order . iter ( ) ; assert equal ( f , iter . next ( ) ) ; assert equal ( b , iter . next ( ) ) ; assert equal ( d , iter . next ( ) ) ; assert equal ( e , iter . next ( ) ) ; assert equal ( c , iter . next ( ) ) ; assert equal ( , iter . next ( ) ) ; }	test public void test order web fragment relative2 ( ) { second exampl us fragment id fragment . add after order other ( ) ; . add befor order ( c ) ; b . add befor order other ( ) ; d . add after order other ( ) ; e . add befor order other ( ) ; set web xml order = web xml . order web fragment ( app , fragment ) ; iter web xml iter = order . iter ( ) ; number order ar possibl algorithm determinist thi order valid . thi fail after chang algorithm , check see new order also valid . assert equal ( b , iter . next ( ) ) ; assert equal ( e , iter . next ( ) ) ; assert equal ( f , iter . next ( ) ) ; assert equal ( , iter . next ( ) ) ; assert equal ( c , iter . next ( ) ) ; assert equal ( d , iter . next ( ) ) ; }	test public void test order web fragment relative3 ( ) { third exampl from spec . add after order ( b ) ; c . add befor order other ( ) ; fragment . remov ( e ) ; fragment . remov ( f ) ; set web xml order = web xml . order web fragment ( app , fragment ) ; iter web xml iter = order . iter ( ) ; number order ar possibl algorithm determinist thi order valid . thi fail after chang algorithm , check see new order also valid . assert equal ( c , iter . next ( ) ) ; assert equal ( d , iter . next ( ) ) ; assert equal ( b , iter . next ( ) ) ; assert equal ( , iter . next ( ) ) ; }	test public void test order web fragmentsrel circular ( ) { . add befor order ( b ) ; b . add befor order ( ) ; except except = null ; try { web xml . order web fragment ( app , fragment ) ; } catch ( except e1 ) { except = e1 ; } assert true ( except instanceof illeg argument except ) ; }
privat when commit respons , we have valid set header , well setup respons filter . void prepar respons ( ) { boolean entiti bodi = true ; content delimit = fals ; output filter output filter = get output buffer ( ) . get filter ( ) ; ( http09 = = true ) { http 0 . 9 get output buffer ( ) . add activ filter ( output filter constant . ident filter ) ; return ; } int statu code = respons . get statu ( ) ; ( ( statu code = = 204 ) ( statu code = = 205 ) ( statu code = = 304 ) ) { entiti bodi get output buffer ( ) . add activ filter ( output filter constant . void filter ) ; entiti bodi = fals ; content delimit = true ; } messag byte method mb = request . method ( ) ; ( method mb . equal ( head ) ) { entiti bodi get output buffer ( ) . add activ filter ( output filter constant . void filter ) ; content delimit = true ; } sendfil support boolean send sendfil = fals ; ( get endpoint ( ) . get us sendfil ( ) ) { send sendfil = prepar sendfil ( output filter ) ; } check compress boolean compress = fals ; boolean us compress = fals ; ( entiti bodi ( compress level 0 ) send sendfil ) { compress = compress ( ) ; ( compress ) { us compress = us compress ( ) ; } chang content length 1 forc chunk ( us compress ) { respons . set content length ( 1 ) ; } } mime header header = respons . get mime header ( ) ; ( entiti bodi ) { respons . set content length ( 1 ) ; } els { string content type = respons . get content type ( ) ; ( content type = null ) { header . set valu ( content type ) . set string ( content type ) ; } string content languag = respons . get content languag ( ) ; ( content languag = null ) { header . set valu ( content languag ) . set string ( content languag ) ; } } long content length = respons . get content length long ( ) ; boolean connect close present = fals ; ( content length = 1 ) { header . set valu ( content length ) . set long ( content length ) ; get output buffer ( ) . add activ filter ( output filter constant . ident filter ) ; content delimit = true ; } els { respons code support entiti bodi we re http 1 . 1 we chunk unless we have connect : close header connect close present = connect close ( header ) ; ( entiti bodi http11 connect close present ) { get output buffer ( ) . add activ filter ( output filter constant . chunk filter ) ; content delimit = true ; header . add valu ( constant . transferencod ) . set string ( constant . chunk ) ; } els { get output buffer ( ) . add activ filter ( output filter constant . ident filter ) ; } } ( us compress ) { get output buffer ( ) . add activ filter ( output filter constant . gzip filter ) ; header . set valu ( content encod ) . set string ( gzip ) ; } might compress , set vari header ( compress ) { make proxi happi via vari ( from mod deflat ) messag byte vari = header . get valu ( vari ) ; ( vari = = null ) { add new vari header header . set valu ( vari ) . set string ( accept encod ) ; } els ( vari . equal ( ) ) { action requir } els { merg current header header . set valu ( vari ) . set string ( vari . get string ( ) , accept encod ) ; } } add date header header . set valu ( date ) . set string ( fast http date format . get current date ( ) ) ; fixm : add transfer encod header ( ( entiti bodi ) ( content delimit ) ) { mark close connect after request , add connect : close header keep aliv = fals ; } we know request bad thi earli , add connect : close header . keep aliv = keep aliv statu drop connect ( statu code ) ; ( keep aliv ) { avoid ad close header twice ( connect close present ) { header . add valu ( constant . connect ) . set string ( constant . close ) ; } } els ( http11 error ) { header . add valu ( constant . connect ) . set string ( constant . keepal ) ; } build respons header get output buffer ( ) . send statu ( ) ; add server header ( server = null ) { alwai overrid anyth app might set header . set valu ( server ) . set string ( server ) ; } els ( header . get valu ( server ) = = null ) { app didn t set header , us default get output buffer ( ) . write ( constant . server byte ) ; } int size = header . size ( ) ; ( int i = 0 ; i size ; i ) { get output buffer ( ) . send header ( header . get name ( i ) , header . get valu ( i ) ) ; } get output buffer ( ) . end header ( ) ; }
privat static string xml escap ( string s ) { ( s = = null ) return null ; string builder sb = new string builder ( ) ; ( int i = 0 ; i s . length ( ) ; i ) { char c = s . char ( i ) ; ( c = = ) { sb . append ( lt ; ) ; } els ( c = = ) { sb . append ( gt ; ) ; } els ( c = = ) { apo ; sb . append ( 039 ; ) ; } els ( c = = ) { sb . append ( amp ; ) ; } els ( c = = ) { quot ; sb . append ( 034 ; ) ; } els { sb . append ( c ) ; } } return sb . string ( ) ; }	void do handl page except ( throwabl t ) throw ioexcept , servlet except { ( error page url = null error page url . equal ( ) ) { set request attribut . do set javax . servlet . error . except attribut here ( instead , set gener servlet code error page ) order prevent error report valv , which invok part forward request error page , from throw respons ha been commit ( respons have been commit error page jsp page ) . request . set attribut ( page context . except , t ) ; request . set attribut ( request dispatch . error statu code , new integ ( http servlet respons . sc intern server error ) ) ; request . set attribut ( request dispatch . error request uri , ( ( http servlet request ) request ) . get request uri ( ) ) ; request . set attribut ( request dispatch . error servlet name , config . get servlet name ( ) ) ; try { forward ( error page url ) ; } catch ( illeg state except ) { includ ( error page url ) ; } error page could insid includ . object new except = request . get attribut ( request dispatch . error except ) ; t = = null mean attribut wa set . ( ( new except = null ) ( new except = = t ) ) { request . remov attribut ( request dispatch . error except ) ; } now clear error code prevent doubl handl . request . remov attribut ( request dispatch . error statu code ) ; request . remov attribut ( request dispatch . error request uri ) ; request . remov attribut ( request dispatch . error servlet name ) ; request . remov attribut ( page context . except ) ; } els { get stack trace real problem ( t instanceof ioexcept ) throw ( ioexcept ) t ; ( t instanceof servlet except ) throw ( servlet except ) t ; ( t instanceof runtim except ) throw ( runtim except ) t ; throwabl root caus = null ; ( t instanceof jsp except ) { root caus = ( ( jsp except ) t ) . get caus ( ) ; } els ( t instanceof elexcept ) { root caus = ( ( elexcept ) t ) . get caus ( ) ; } ( root caus = null ) { throw new servlet except ( t . get class ( ) . get name ( ) : t . get messag ( ) , root caus ) ; } throw new servlet except ( t ) ; } }

public socket state process ( socket wrapper s socket , socket statu statu ) { processor s processor = connect . remov ( socket . get socket ( ) ) ; ( statu = = socket statu . disconnect processor = = null ) { ar object associ thi connect return socket state . close ; } socket . set async ( fals ) ; try { ( processor = = null ) { processor = recycl processor . pop ( ) ; } ( processor = = null ) { processor = creat processor ( ) ; } init ssl ( socket , processor ) ; socket state state = socket state . close ; do { ( statu = = socket statu . disconnect ) { do noth here , just wait get recycl } els ( processor . async ( ) state = = socket state . async end ) { state = processor . async dispatch ( statu ) ; } els ( processor . comet ( ) ) { state = processor . event ( statu ) ; } els ( processor . upgrad ( ) ) { state = processor . upgrad dispatch ( ) ; } els { state = processor . process ( socket ) ; } ( state = socket state . close processor . async ( ) ) { state = processor . async post process ( ) ; } ( state = = socket state . upgrad ) { get upgrad inbound handler upgrad inbound inbound = processor . get upgrad inbound ( ) ; releas http11 processor re us releas ( socket , processor , fals , fals ) ; creat light weight upgrad processor processor = creat upgrad processor ( socket , inbound ) ; inbound . upgrad complet ( ) ; } } while ( state = = socket state . async end state = = socket state . upgrad ) ; ( state = = socket state . long ) { middl process request respons . keep socket associ processor . exact requir depend type long poll long poll ( socket , processor ) ; } els ( state = = socket state . open ) { keep aliv between request . ok recycl processor . continu poll next request . releas ( socket , processor , fals , true ) ; } els ( state = = socket state . sendfil ) { sendfil progress . fail , socket close . work , socket re ad poller releas ( socket , processor , fals , fals ) ; } els ( state = = socket state . upgrad ) { need keep connect associ processor long poll ( socket , processor ) ; } els { processor ar recycl . ( processor . upgrad ( ) ) { releas ( socket , processor , true , fals ) ; } } return state ; } catch ( java . net . socket except e ) { socket except ar normal get log ( ) . debug ( sm . get string ( abstract connect handler . socketexcept . debug ) , e ) ; } catch ( java . io . ioexcept e ) { ioexcept ar normal get log ( ) . debug ( sm . get string ( abstract connect handler . ioexcept . debug ) , e ) ; } abov . catch ( throwabl e ) { except util . handl throwabl ( e ) ; ani other except error odd . here we log error level , so show up even less than verbos log . get log ( ) . error ( sm . get string ( abstract connect handler . error ) , e ) ; } don t try add upgrad processor back pool ( processor = null processor . upgrad ( ) ) { releas ( socket , processor , true , fals ) ; } return socket state . close ; }
privat param c target class which coerc given string param s string valu param attr name name attribut whose valu suppli param prop editor class properti editor given attribut param name attribut true given attribut name attribut ( , specifi us jsp : attribut standard action ) , fals otherwis string convert string ( class c , string s , string attr name , class prop editor class , boolean name attribut ) { string quot = s ; ( name attribut ) { quot = quot ( s ) ; } ( prop editor class = null ) { string class name = c . get canon name ( ) ; return ( class name ) org . apach . jasper . runtim . jsp runtim librari . get valu from bean info properti editor ( class name . class , attr name , quot , prop editor class . get canon name ( ) . class ) ; } els ( c = = string . class ) { return quot ; } els ( c = = boolean . class ) { return jsp util . coerc primit boolean ( s , name attribut ) ; } els ( c = = boolean . class ) { return jsp util . coerc boolean ( s , name attribut ) ; } els ( c = = byte . class ) { return jsp util . coerc primit byte ( s , name attribut ) ; } els ( c = = byte . class ) { return jsp util . coerc byte ( s , name attribut ) ; } els ( c = = char . class ) { return jsp util . coerc char ( s , name attribut ) ; } els ( c = = charact . class ) { return jsp util . coerc charact ( s , name attribut ) ; } els ( c = = doubl . class ) { return jsp util . coerc primit doubl ( s , name attribut ) ; } els ( c = = doubl . class ) { return jsp util . coerc doubl ( s , name attribut ) ; } els ( c = = float . class ) { return jsp util . coerc primit float ( s , name attribut ) ; } els ( c = = float . class ) { return jsp util . coerc float ( s , name attribut ) ; } els ( c = = int . class ) { return jsp util . coerc int ( s , name attribut ) ; } els ( c = = integ . class ) { return jsp util . coerc integ ( s , name attribut ) ; } els ( c = = short . class ) { return jsp util . coerc primit short ( s , name attribut ) ; } els ( c = = short . class ) { return jsp util . coerc short ( s , name attribut ) ; } els ( c = = long . class ) { return jsp util . coerc primit long ( s , name attribut ) ; } els ( c = = long . class ) { return jsp util . coerc long ( s , name attribut ) ; } els ( c = = object . class ) { return new string ( quot ) ; } els { string class name = c . get canon name ( ) ; return ( class name ) org . apach . jasper . runtim . jsp runtim librari . get valu from properti editor manag ( class name . class , attr name , quot ) ; } }
public void do tag ( tag plugin context ctxt ) { flag indic whether attribut have been specifi boolean ha valu = fals , ha var = fals , ha scope = fals , ha target = fals ; scope name string str scope ; id scope int i scope ; initi flag ha valu = ctxt . attribut specifi ( valu ) ; ha var = ctxt . attribut specifi ( var ) ; ha scope = ctxt . attribut specifi ( scope ) ; ha target = ctxt . attribut specifi ( target ) ; temp variabl name string result name = ctxt . get temporari variabl name ( ) ; string target name = ctxt . get temporari variabl name ( ) ; string properti name = ctxt . get temporari variabl name ( ) ; initi result which assign var target . properti ctxt . gener java sourc ( object result name = null ; ) ; ( ha valu ) { ctxt . gener java sourc ( result name = ) ; ctxt . gener attribut ( valu ) ; ctxt . gener java sourc ( ; ) ; } els { ctxt . dont us tag plugin ( ) ; return ; } initi str scope ( ha scope ) { str scope = ctxt . get constant attribut ( scope ) ; } els { str scope = page ; } get i scope accord str scope i scope = util . get scope ( str scope ) ; attribut var ha been specifi assign result var ; ( ha var ) { string str var = ctxt . get constant attribut ( var ) ; ctxt . gener java sourc ( ( null = result name ) { ) ; ctxt . gener java sourc ( page context . set attribut ( str var , result name , i scope ) ; ) ; ctxt . gener java sourc ( } els { ) ; ( ha scope ) { ctxt . gener java sourc ( page context . remov attribut ( str var , i scope ) ; ) ; } els { ctxt . gener java sourc ( page context . remov attribut ( str var ) ; ) ; } ctxt . gener java sourc ( } ) ; els assign result target . properti } els ( ha target ) { gener temp variabl name string pd name = ctxt . get temporari variabl name ( ) ; string success flag name = ctxt . get temporari variabl name ( ) ; string index = ctxt . get temporari variabl name ( ) ; string method name = ctxt . get temporari variabl name ( ) ; initi properti ctxt . gener java sourc ( string properti name = null ; ) ; ctxt . gener java sourc ( ( ) ; ctxt . gener attribut ( properti ) ; ctxt . gener java sourc ( = null ) { ) ; ctxt . gener java sourc ( properti name = ( ) ; ctxt . gener attribut ( properti ) ; ctxt . gener java sourc ( ) . string ( ) ; ) ; ctxt . gener java sourc ( } ) ; initi target ctxt . gener java sourc ( object target name = ) ; ctxt . gener attribut ( target ) ; ctxt . gener java sourc ( ; ) ; target ok ctxt . gener java sourc ( ( target name = null ) { ) ; target map , put result map kei properti ctxt . gener java sourc ( ( target name instanceof java . util . map ) { ) ; ctxt . gener java sourc ( ( null = result name ) { ) ; ctxt . gener java sourc ( ( ( java . util . map ) target name ) . put ( properti name , result name ) ; ) ; ctxt . gener java sourc ( } els { ) ; ctxt . gener java sourc ( ( ( java . util . map ) target name ) . remov ( properti name ) ; ) ; ctxt . gener java sourc ( } ) ; els assign result target . properti ctxt . gener java sourc ( } els { ) ; ctxt . gener java sourc ( try { ) ; get all properti target ctxt . gener java sourc ( java . bean . properti descriptor pd name = java . bean . introspector . get bean info ( target name . get class ( ) ) . get properti descriptor ( ) ; ) ; success flag impli whether assign success ctxt . gener java sourc ( boolean success flag name = fals ; ) ; find right properti ctxt . gener java sourc ( ( int index = 0 ; index pd name . length ; index ) { ) ; ctxt . gener java sourc ( ( pd name index . get name ( ) . equal ( properti name ) ) { ) ; get set method ; ctxt . gener java sourc ( java . lang . reflect . method method name = pd name index . get write method ( ) ; ) ; ctxt . gener java sourc ( ( null = = method name ) { ) ; ctxt . gener java sourc ( throw new jsp except ( setter method lt ; set gt ; properti properti name ) ; ) ; ctxt . gener java sourc ( } ) ; invok method through reflect ctxt . gener java sourc ( ( result name = null ) { ) ; ctxt . gener java sourc ( method name . invok ( target name , new object { ( method name . get paramet type ( ) 0 ) . cast ( result name ) } ) ; ) ; ctxt . gener java sourc ( } els { ) ; ctxt . gener java sourc ( method name . invok ( target name , new object { null } ) ; ) ; ctxt . gener java sourc ( } ) ; ctxt . gener java sourc ( success flag name = true ; ) ; ctxt . gener java sourc ( } ) ; ctxt . gener java sourc ( } ) ; ctxt . gener java sourc ( ( success flag name ) { ) ; ctxt . gener java sourc ( throw new jsp except ( invalid properti lt ; set gt ; : properti name ) ; ) ; ctxt . gener java sourc ( } ) ; ctxt . gener java sourc ( } ) ; catch el except throw jsp except ctxt . gener java sourc ( catch ( illeg access except ex ) { ) ; ctxt . gener java sourc ( throw new jsp except ( ex ) ; ) ; ctxt . gener java sourc ( } catch ( java . bean . introspect except ex ) { ) ; ctxt . gener java sourc ( throw new jsp except ( ex ) ; ) ; ctxt . gener java sourc ( } catch ( java . lang . reflect . invoc target except ex ) { ) ; ctxt . gener java sourc ( ( ex . get caus ( ) instanceof thread death ) { ) ; ctxt . gener java sourc ( throw ( thread death ) ex . get caus ( ) ; ) ; ctxt . gener java sourc ( } ) ; ctxt . gener java sourc ( ( ex . get caus ( ) instanceof virtual machin error ) { ) ; ctxt . gener java sourc ( throw ( virtual machin error ) ex . get caus ( ) ; ) ; ctxt . gener java sourc ( } ) ; ctxt . gener java sourc ( throw new jsp except ( ex ) ; ) ; ctxt . gener java sourc ( } ) ; ctxt . gener java sourc ( } ) ; ctxt . gener java sourc ( } els { ) ; ctxt . gener java sourc ( throw new jsp except ( ) ; ) ; ctxt . gener java sourc ( } ) ; } }	privat node . jsp attribut get node attribut ( string attribut ) { node . jsp attribut attr = node . get jsp attribut ( ) ; ( int i = 0 ; attr = null i attr . length ; i ) { ( attr i . get name ( ) . equal ( attribut ) ) { return attr i ; } } return null ; }	protect string gener java ( ) throw except { string smap str = null ; long t1 , t2 , t3 , t4 ; t1 = t2 = t3 = t4 = 0 ; ( log . debug enabl ( ) ) { t1 = system . current time milli ( ) ; } setup page info area page info = new page info ( new bean repositori ( ctxt . get class loader ( ) , err dispatch ) , ctxt . get jsp file ( ) ) ; jsp config jsp config = option . get jsp config ( ) ; jsp config . jsp properti jsp properti = jsp config . find jsp properti ( ctxt . get jsp file ( ) ) ; current uri match pattern specifi jsp properti group web . xml , initi page info those properti . ( jsp properti . elignor ( ) = null ) { page info . set elignor ( jsp util . boolean valu ( jsp properti . elignor ( ) ) ) ; } ( jsp properti . script invalid ( ) = null ) { page info . set script invalid ( jsp util . boolean valu ( jsp properti . script invalid ( ) ) ) ; } ( jsp properti . get includ prelud ( ) = null ) { page info . set includ prelud ( jsp properti . get includ prelud ( ) ) ; } ( jsp properti . get includ coda ( ) = null ) { page info . set includ coda ( jsp properti . get includ coda ( ) ) ; } ( jsp properti . defer syntax allow liter ( ) = null ) { page info . set defer syntax allow liter ( jsp util . boolean valu ( jsp properti . defer syntax allow liter ( ) ) ) ; } ( jsp properti . trim direct whitespac ( ) = null ) { page info . set trim direct whitespac ( jsp util . boolean valu ( jsp properti . trim direct whitespac ( ) ) ) ; } been pars ( jsp properti . get buffer ( ) = null ) { page info . set buffer valu ( jsp properti . get buffer ( ) , null , err dispatch ) ; } ( jsp properti . error undeclar namespac ( ) = null ) { page info . set error undeclar namespac ( jsp util . boolean valu ( jsp properti . error undeclar namespac ( ) ) ) ; } ( ctxt . tag file ( ) ) { try { doubl librari version = doubl . pars doubl ( ctxt . get tag info ( ) . get tag librari ( ) . get requir version ( ) ) ; ( librari version 2 . 0 ) { page info . set elignor ( true , null , err dispatch , true ) ; } ( librari version 2 . 1 ) { page info . set defer syntax allow liter ( true , null , err dispatch , true ) ; } } catch ( number format except ex ) { err dispatch . jsp error ( ex ) ; } } ctxt . check output dir ( ) ; string java file name = ctxt . get servlet java file name ( ) ; servlet writer writer = null ; try { set elignor chang behaviour parser subtl wai . add fun , elignor can set ani file form part translat unit so set file includ toward end translat unit can chang how parser should have behav when pars content up point where elignor wa set . arghh previou attempt hack around thi have onli provid partial solut . we now us two pass pars translat unit . first just pars direct second pars whole translat unit onc we know how elignor ha been set . todo ar some possibl optimis thi process . pars file parser control parser ctl = new parser control ( ctxt , thi ) ; pass 1 direct node . node direct = parser ctl . pars direct ( ctxt . get jsp file ( ) ) ; valid . valid direct ( thi , direct ) ; pass 2 whole translat unit page node = parser ctl . pars ( ctxt . get jsp file ( ) ) ; leav thi until now sinc can onli set onc bug 49726 ( page info . get content type ( ) = = null jsp properti . get default content type ( ) = null ) { page info . set content type ( jsp properti . get default content type ( ) ) ; } ( ctxt . prototyp mode ( ) ) { gener prototyp . java file tag file writer = setup context writer ( java file name ) ; gener . gener ( writer , thi , page node ) ; writer . close ( ) ; writer = null ; return null ; } valid process attribut don t re valid direct we valid pass 1 valid . valid ex direct ( thi , page node ) ; ( log . debug enabl ( ) ) { t2 = system . current time milli ( ) ; } collect page info collector . collect ( thi , page node ) ; compil ( necessari ) load tag file referenc thi compil unit . tfp = new tag file processor ( ) ; tfp . load tag file ( thi , page node ) ; ( log . debug enabl ( ) ) { t3 = system . current time milli ( ) ; } determin which custom tag need declar which script var script variabl . set ( page node , err dispatch ) ; optim tag plugin tag plugin manag tag plugin manag = option . get tag plugin manag ( ) ; tag plugin manag . appli ( page node , err dispatch , page info ) ; optim : concaten contigu templat text . text optim . concaten ( thi , page node ) ; gener static function mapper code . elfunct mapper . map ( page node ) ; gener servlet . java file writer = setup context writer ( java file name ) ; gener . gener ( writer , thi , page node ) ; writer . close ( ) ; writer = null ; writer onli us dure compil , derefer jsp compil context when done allow gc d save memori . ctxt . set writer ( null ) ; ( log . debug enabl ( ) ) { t4 = system . current time milli ( ) ; log . debug ( gener java file name total = ( t4 t1 ) gener = ( t4 t3 ) valid = ( t2 t1 ) ) ; } } catch ( except e ) { ( writer = null ) { try { writer . close ( ) ; writer = null ; } catch ( except e1 ) { do noth } } remov gener . java file file file = new file ( java file name ) ; ( file . exist ( ) ) { ( file . delet ( ) ) { log . warn ( local . get messag ( jsp . warn . compil . javafil . delet . fail , file . get absolut path ( ) ) ) ; } } throw e ; } final { ( writer = null ) { try { writer . close ( ) ; } catch ( except e2 ) { do noth } } } jsr45 support ( option . smap suppress ( ) ) { smap str = smap util . gener smap ( ctxt , page node ) ; } ani proto type . java . class file wa gener , prototyp . java mai have been replac current compil ( tag file self referenc ) , . class file need remov , make sure javac would gener . class again from new . java file just gener . tfp . remov proto type file ( ctxt . get class file name ( ) ) ; return smap str ; }
protect void perform basic check ( ) { updat all aliv time member member = super . get member ( ) ; ( int i = 0 ; member = null i member . length ; i ) { ( membership . member aliv ( ( member impl ) member i ) ) { we don t have thi our membership , check see he she aliv ( member aliv ( member i ) ) { log . warn ( member ad , even though we werent notifi : member i ) ; super . member ad ( member i ) ; } els { membership . remov member ( ( member impl ) member i ) ; } end } end } check suspect member thei ar still aliv , , simpli issu member disappear messag member impl kei = remov suspect . kei set ( ) . arrai ( new member impl remov suspect . size ( ) ) ; ( int i = 0 ; i kei . length ; i ) { member impl m = kei i ; ( membership . get member ( m ) = null ( member aliv ( m ) ) ) { membership . remov member ( m ) ; super . member disappear ( m ) ; remov suspect . remov ( m ) ; ( log . info enabl ( ) ) log . info ( suspect member , confirm dead . m ) ; } end } check add suspect member thei ar aliv now , thei ar , simpli issu member ad messag kei = add suspect . kei set ( ) . arrai ( new member impl add suspect . size ( ) ) ; ( int i = 0 ; i kei . length ; i ) { member impl m = kei i ; ( membership . get member ( m ) = = null ( member aliv ( m ) ) ) { membership . member aliv ( m ) ; super . member ad ( m ) ; add suspect . remov ( m ) ; ( log . info enabl ( ) ) log . info ( suspect member , confirm aliv . m ) ; } end } }	protect void perform forc check ( ) { updat all aliv time member member = super . get member ( ) ; ( int i = 0 ; member = null i member . length ; i ) { ( member aliv ( member i ) ) { ( membership . member aliv ( ( member impl ) member i ) ) super . member ad ( member i ) ; add suspect . remov ( member i ) ; } els { ( membership . get member ( member i ) = null ) { membership . remov member ( ( member impl ) member i ) ; remov suspect . remov ( member i ) ; super . member disappear ( member i ) ; } } end } }	overrid public void member disappear ( member member ) { ( membership = = null ) setup membership ( ) ; boolean notifi = fals ; boolean shutdown = arrai . equal ( member . get command ( ) , member . shutdown payload ) ; ( shutdown ) ( log . info enabl ( ) ) log . info ( receiv member disappear member messag . verifi . ) ; synchron ( membership ) { ( membership . contain ( member ) ) { ( log . info enabl ( ) ) log . info ( verif complet . member alreadi disappear member ) ; return ; } payload shutdown messag ( shutdown member aliv ( member ) ) { correct , we need maintain map membership . remov member ( ( member impl ) member ) ; remov suspect . remov ( member ) ; notifi = true ; } els { add member suspect remov suspect . put ( member , long . valu ( system . current time milli ( ) ) ) ; } } ( notifi ) { ( log . info enabl ( ) ) log . info ( verif complet . member disappear member ) ; super . member disappear ( member ) ; } els { ( log . info enabl ( ) ) log . info ( verif complet . member still aliv member ) ; } }
protect after read request header , we have setup request filter . void prepar request ( ) { translat http method code string . byte method code = request header messag . get byte ( ) ; ( method code = constant . sc m jk store ) { string method name = constant . get method code ( method code 1 ) ; request . method ( ) . set string ( method name ) ; } request header messag . get byte ( request . protocol ( ) ) ; request header messag . get byte ( request . request uri ( ) ) ; request header messag . get byte ( request . remot addr ( ) ) ; request header messag . get byte ( request . remot host ( ) ) ; request header messag . get byte ( request . local name ( ) ) ; request . set local port ( request header messag . get int ( ) ) ; boolean ssl = request header messag . get byte ( ) = 0 ; ( ssl ) { request . scheme ( ) . set string ( http ) ; } decod header mime header header = request . get mime header ( ) ; set thi everi time case limit ha been chang via jmx header . set limit ( endpoint . get max header count ( ) ) ; int h count = request header messag . get int ( ) ; ( int i = 0 ; i h count ; i ) { string h name = null ; header name ar encod either integ code start 0x a0 , normal string ( which case first two byte ar length ) . int isc = request header messag . peek int ( ) ; int h id = isc 0x ff ; messag byte v mb = null ; isc = 0x ff00 ; ( 0x a000 = = isc ) { advanc read posit request header messag . get int ( ) ; h name = constant . get header code ( h id 1 ) ; v mb = header . add valu ( h name ) ; } els { reset h id header current read happen 7 8 byte long , code below think s content type header content length header sc req content type = 7 , sc req content length = 8 lead unexpect behaviour . see bug 5861 more inform . h id = 1 ; request header messag . get byte ( tmp mb ) ; byte chunk bc = tmp mb . get byte chunk ( ) ; v mb = header . add valu ( bc . get buffer ( ) , bc . get start ( ) , bc . get length ( ) ) ; } request header messag . get byte ( v mb ) ; ( h id = = constant . sc req content length ( h id = = 1 tmp mb . equal ignor case ( content length ) ) ) { just read content length header , so set long cl = v mb . get long ( ) ; ( cl integ . max valu ) request . set content length ( ( int ) cl ) ; } els ( h id = = constant . sc req content type ( h id = = 1 tmp mb . equal ignor case ( content type ) ) ) { just read content type header , so set byte chunk bchunk = v mb . get byte chunk ( ) ; request . content type ( ) . set byte ( bchunk . get byte ( ) , bchunk . get offset ( ) , bchunk . get length ( ) ) ; } } decod extra attribut boolean secret = fals ; byte attribut code ; while ( ( attribut code = request header messag . get byte ( ) ) = constant . sc ar done ) { switch ( attribut code ) { case constant . sc req attribut : request header messag . get byte ( tmp mb ) ; string n = tmp mb . string ( ) ; request header messag . get byte ( tmp mb ) ; string v = tmp mb . string ( ) ; ajp13 miss forward remot port . allow ajp connector add thi info via privat request attribut . we accept forward data remot port , remov from public list request attribut . ( n . equal ( constant . sc req remot port ) ) { try { request . set remot port ( integ . pars int ( v ) ) ; } catch ( number format except nfe ) { ignor invalid valu } } els { request . set attribut ( n , v ) ; } break ; case constant . sc context : request header messag . get byte ( tmp mb ) ; noth break ; case constant . sc servlet path : request header messag . get byte ( tmp mb ) ; noth break ; case constant . sc remot user : ( tomcat authent ) { ignor server request header messag . get byte ( tmp mb ) ; } els { request header messag . get byte ( request . get remot user ( ) ) ; } break ; case constant . sc auth type : ( tomcat authent ) { ignor server request header messag . get byte ( tmp mb ) ; } els { request header messag . get byte ( request . get auth type ( ) ) ; } break ; case constant . sc queri string : request header messag . get byte ( request . queri string ( ) ) ; break ; case constant . sc jvm rout : request header messag . get byte ( request . instanc id ( ) ) ; break ; case constant . sc ssl cert : request . scheme ( ) . set string ( http ) ; ssl certif extract lazi , move jk coyot handler request header messag . get byte ( certif ) ; break ; case constant . sc ssl cipher : request . scheme ( ) . set string ( http ) ; request header messag . get byte ( tmp mb ) ; request . set attribut ( sslsupport . cipher suit kei , tmp mb . string ( ) ) ; break ; case constant . sc ssl session : request . scheme ( ) . set string ( http ) ; request header messag . get byte ( tmp mb ) ; request . set attribut ( sslsupport . session id kei , tmp mb . string ( ) ) ; break ; case constant . sc ssl kei size : request . set attribut ( sslsupport . kei size kei , integ . valu ( request header messag . get int ( ) ) ) ; break ; case constant . sc store method : request header messag . get byte ( request . method ( ) ) ; break ; case constant . sc secret : request header messag . get byte ( tmp mb ) ; ( requir secret = null ) { secret = true ; ( tmp mb . equal ( requir secret ) ) { respons . set statu ( 403 ) ; error = true ; } } break ; default : ignor unknown attribut backward compat break ; } } check secret wa submit requir ( ( requir secret = null ) secret ) { respons . set statu ( 403 ) ; error = true ; } check full uri ( includ protocol : host : port ) byte chunk uri bc = request . request uri ( ) . get byte chunk ( ) ; ( uri bc . start ignor case ( http , 0 ) ) { int po = uri bc . index ( : , 0 , 3 , 4 ) ; int uri bcstart = uri bc . get start ( ) ; int slash po = 1 ; ( po = 1 ) { byte uri b = uri bc . get byte ( ) ; slash po = uri bc . index ( , po 3 ) ; ( slash po = = 1 ) { slash po = uri bc . get length ( ) ; set uri request . request uri ( ) . set byte ( uri b , uri bcstart po 1 , 1 ) ; } els { request . request uri ( ) . set byte ( uri b , uri bcstart slash po , uri bc . get length ( ) slash po ) ; } messag byte host mb = header . set valu ( host ) ; host mb . set byte ( uri b , uri bcstart po 3 , slash po po 3 ) ; } } messag byte valu mb = request . get mime header ( ) . get valu ( host ) ; pars host ( valu mb ) ; ( error ) { get adapt ( ) . log ( request , respons , 0 ) ; } }
protect access log element creat log element ( ) { list access log element list = new arrai list ( ) ; boolean replac = fals ; string builder buf = new string builder ( ) ; ( int i = 0 ; i pattern . length ( ) ; i ) { char ch = pattern . char ( i ) ; ( replac ) { code process { , behavior . . . i do encount close } i ignor { ( { = = ch ) { string builder name = new string builder ( ) ; int j = i 1 ; ( ; j pattern . length ( ) } = pattern . char ( j ) ; j ) { name . append ( pattern . char ( j ) ) ; } ( j 1 pattern . length ( ) ) { 1 wa account } which we increment now j ; list . add ( creat access log element ( name . string ( ) , pattern . char ( j ) ) ) ; i = j ; sinc we walk more than charact } els { d oh end string pretend we never did thi do process old wai list . add ( creat access log element ( ch ) ) ; } } els { list . add ( creat access log element ( ch ) ) ; } replac = fals ; } els ( ch = = ) { replac = true ; list . add ( new string element ( buf . string ( ) ) ) ; buf = new string builder ( ) ; } els { buf . append ( ch ) ; } } ( buf . length ( ) 0 ) { list . add ( new string element ( buf . string ( ) ) ) ; } return list . arrai ( new access log element 0 ) ; }
skip until given string match stream . when return , context posit past end match . param s string match . return non null code mark code instanc ( posit immedi befor search string ) found , strong null strong otherwis . mark skip until ( string limit ) throw jasper except { mark ret = mark ( ) ; int limlen = limit . length ( ) ; char first char = limit . char ( 0 ) ; boolean result = null ; mark restart = null ; skip : while ( ( result = index ( first char , ret ) ) = null ) { ( result . boolean valu ( ) ) { ( restart = null ) { restart . init ( current , singl file ) ; } els { restart = mark ( ) ; } ( int i = 1 ; i limlen ; i ) { ( peek char ( ) = = limit . char ( i ) ) { next char ( ) ; } els { set current ( restart ) ; continu skip ; } } return ret ; } } return null ; }
enumer name bound name context , along object bound them . param name name context list return enumer bind thi context . each element enumer type bind . except name except name except encount overrid public final name enumer bind list bind ( string name ) throw name except { ( alias . empti ( ) ) { alia result result = find alia ( name ) ; ( result . dir context = null ) { return result . dir context . list bind ( result . alia name ) ; } } next do standard lookup list name entri bind = do list bind ( name ) ; check altern locat list name entri alt bind = null ; ( dir context alt dir context : alt dir context ) { ( alt dir context instanceof base dir context ) { alt bind = ( ( base dir context ) alt dir context ) . do list bind ( meta inf resourc name ) ; } ( alt bind = null ) { ( bind = = null ) { bind = alt bind ; } els { bind . add all ( alt bind ) ; } } } ( bind = null ) { return new name context bind enumer ( bind . iter ( ) , thi ) ; } realli found throw new name found except ( sm . get string ( resourc . found , name ) ) ; }	enumer name bound name context , along object bound them . content ani subcontext ar includ . p bind ad remov from thi context , effect enumer previous return undefin . param name name context list return enumer bind thi context . each element enumer type bind . except name except name except encount overrid protect list name entri do list bind ( string name ) throw name except { file file = file ( name ) ; ( file = = null ) return null ; return list ( file ) ; }	enumer name bound name context , along object bound them . content ani subcontext ar includ . p bind ad remov from thi context , effect enumer previous return undefin . param str name name context list return enumer bind thi context . each element enumer type bind . except name except name except encount overrid protect list name entri do list bind ( string str name ) throw name except { name name = get escap jndi name ( str name ) ; ( name . empti ( ) ) return list ( entri ) ; entri entri = tree lookup ( name ) ; ( entri = = null ) return null ; return list ( entri ) ; }
public static static version { link init webapp default ( string ) } param ctx context set default void init webapp default ( context ctx ) { default servlet wrapper servlet = add servlet ( ctx , default , org . apach . catalina . servlet . default servlet ) ; servlet . set load startup ( 1 ) ; jsp servlet ( class name avoid load all dep ) servlet = add servlet ( ctx , jsp , org . apach . jasper . servlet . jsp servlet ) ; servlet . add init paramet ( fork , fals ) ; servlet . set load startup ( 3 ) ; servlet map ctx . add servlet map ( , default ) ; ctx . add servlet map ( . jsp , jsp ) ; ctx . add servlet map ( . jspx , jsp ) ; session ctx . set session timeout ( 30 ) ; mime map ( int i = 0 ; i default mime map . length ; ) { ctx . add mime map ( default mime map i , default mime map i ) ; } welcom file ctx . add welcom file ( index . html ) ; ctx . add welcom file ( index . htm ) ; ctx . add welcom file ( index . jsp ) ; }
protect synchron check resourc redeploy reload . void check resourc ( deploi applic app ) { string resourc = app . redeploi resourc . kei set ( ) . arrai ( new string 0 ) ; ( int i = 0 ; i resourc . length ; i ) { file resourc = new file ( resourc i ) ; ( log . debug enabl ( ) ) log . debug ( check context app . name redeploi resourc resourc ) ; ( resourc . exist ( ) ) { long last modifi = app . redeploi resourc . get ( resourc i ) . long valu ( ) ; ( ( resourc . directori ( ) ) resourc . last modifi ( ) last modifi ) { undeploi applic ( log . info enabl ( ) ) log . info ( sm . get string ( host config . undeploi , app . name ) ) ; contain context = host . find child ( app . name ) ; try { host . remov child ( context ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . warn ( sm . get string ( host config . context . remov , app . name ) , t ) ; } delet other redeploi resourc ( int j = i 1 ; j resourc . length ; j ) { try { file current = new file ( resourc j ) ; current = current . get canon file ( ) ; never delet per host context . xml default ( constant . host context xml . equal ( current . get name ( ) ) ) { continu ; } host s config base ( ( current . get absolut path ( ) . start ( host . get app base file ( ) . get absolut path ( ) file . separ ) ) ( current . get absolut path ( ) . start ( host . get config base file ( ) . get absolut path ( ) ) ) ) { ( log . debug enabl ( ) ) log . debug ( delet current ) ; expand war . delet ( current ) ; } } catch ( ioexcept e ) { log . warn ( sm . get string ( host config . canonic , app . name ) , e ) ; } } deploi . remov ( app . name ) ; return ; } } els { temporarili eg renam dure text editor save try { thread . sleep ( 500 ) ; } catch ( interrupt except e1 ) { ignor } recheck resourc see wa realli delet ( resourc . exist ( ) ) { continu ; } long last modifi = app . redeploi resourc . get ( resourc i ) . long valu ( ) ; ( last modifi = = 0l ) { continu ; } undeploi applic ( log . info enabl ( ) ) log . info ( sm . get string ( host config . undeploi , app . name ) ) ; contain context = host . find child ( app . name ) ; try { host . remov child ( context ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . warn ( sm . get string ( host config . context . remov , app . name ) , t ) ; } delet all redeploi resourc ( int j = i 1 ; j resourc . length ; j ) { try { file current = new file ( resourc j ) ; current = current . get canon file ( ) ; never delet per host context . xml default ( constant . host context xml . equal ( current . get name ( ) ) ) { continu ; } config base ( ( current . get absolut path ( ) . start ( host . get app base file ( ) . get absolut path ( ) file . separ ) ) ( current . get absolut path ( ) . start ( host . get config base file ( ) . get absolut path ( ) ) ) ) { ( log . debug enabl ( ) ) log . debug ( delet current ) ; expand war . delet ( current ) ; } } catch ( ioexcept e ) { log . warn ( sm . get string ( host config . canonic , app . name ) , e ) ; } } delet reload resourc well ( remov ani remain . xml descriptor ) string resources2 = app . reload resourc . kei set ( ) . arrai ( new string 0 ) ; ( int j = 0 ; j resources2 . length ; j ) { try { file current = new file ( resources2 j ) ; current = current . get canon file ( ) ; never delet per host context . xml default ( constant . host context xml . equal ( current . get name ( ) ) ) { continu ; } config base ( ( current . get absolut path ( ) . start ( host . get app base file ( ) . get absolut path ( ) file . separ ) ) ( ( current . get absolut path ( ) . start ( host . get config base file ( ) . get absolut path ( ) ) ( current . get absolut path ( ) . end ( . xml ) ) ) ) ) { ( log . debug enabl ( ) ) log . debug ( delet current ) ; expand war . delet ( current ) ; } } catch ( ioexcept e ) { log . warn ( sm . get string ( host config . canonic , app . name ) , e ) ; } } deploi . remov ( app . name ) ; return ; } } resourc = app . reload resourc . kei set ( ) . arrai ( new string 0 ) ; ( int i = 0 ; i resourc . length ; i ) { file resourc = new file ( resourc i ) ; ( log . debug enabl ( ) ) log . debug ( check context app . name reload resourc resourc ) ; long last modifi = app . reload resourc . get ( resourc i ) . long valu ( ) ; ( ( resourc . exist ( ) last modifi = 0l ) ( resourc . last modifi ( ) = last modifi ) ) { reload applic ( log . info enabl ( ) ) log . info ( sm . get string ( host config . reload , app . name ) ) ; context context = ( context ) host . find child ( app . name ) ; ( context . get state ( ) . avail ( ) ) { reload catch log except context . reload ( ) ; } els { web . xml ) we ll still get try start try { context . start ( ) ; } catch ( except e ) { log . warn ( sm . get string ( host config . context . restart , app . name ) , e ) ; } } updat time app . reload resourc . put ( resourc i , long . valu ( resourc . last modifi ( ) ) ) ; app . timestamp = system . current time milli ( ) ; return ; } } }	protect check statu all webapp . void check ( ) { ( host . get auto deploi ( ) ) { check resourc modif trigger redeploy deploi applic app = deploi . valu ( ) . arrai ( new deploi applic 0 ) ; ( int i = 0 ; i app . length ; i ) { ( servic ( app i . name ) ) check resourc ( app i ) ; } hotdeploi applic deploi app ( ) ; } }	public check statu specif webapp , us stuff like manag webapp . void check ( string name ) { deploi applic app = deploi . get ( name ) ; ( app = null ) { check resourc ( app ) ; } els { deploi app ( name ) ; } }
mark mark ( ) { return new mark ( current ) ; }	skip until given string match stream . when return , context posit past end match . param s string match . return non null code mark code instanc ( posit immedi befor search string ) found , strong null strong otherwis . mark skip until ( string limit ) throw jasper except { mark ret = null ; int limlen = limit . length ( ) ; int ch ; skip : ( ret = mark ( ) , ch = next char ( ) ; ch = 1 ; ret = mark ( ) , ch = next char ( ) ) { ( ch = = limit . char ( 0 ) ) { mark restart = mark ( ) ; ( int i = 1 ; i limlen ; i ) { ( peek char ( ) = = limit . char ( i ) ) next char ( ) ; els { reset ( restart ) ; continu skip ; } } return ret ; } } return null ; }	skip until given string match stream , ignor char initi escap . when return , context posit past end match . param s string match . return non null code mark code instanc ( posit immedi befor search string ) found , strong null strong otherwis . mark skip until ignor esc ( string limit ) throw jasper except { mark ret = null ; int limlen = limit . length ( ) ; int ch ; doesn t matter int prev = x ; skip : ( ret = mark ( ) , ch = next char ( ) ; ch = 1 ; ret = mark ( ) , prev = ch , ch = next char ( ) ) { ( ch = = prev = = ) { doubl escap char anymor ch = 0 ; } } }	string get text ( mark start , mark stop ) throw jasper except { mark oldstart = mark ( ) ; reset ( start ) ; char arrai writer caw = new char arrai writer ( ) ; while ( stop . equal ( mark ( ) ) ) caw . write ( next char ( ) ) ; caw . close ( ) ; reset ( oldstart ) ; return caw . string ( ) ; }	search stream match string param string string match return strong true strong found , current posit stream posit after search string , strong fals strong otherwis , posit stream unchang . boolean match ( string string ) throw jasper except { mark mark = mark ( ) ; int ch = 0 ; int i = 0 ; do { ch = next char ( ) ; ( ( ( char ) ch ) = string . char ( i ) ) { reset ( mark ) ; return fals ; } } while ( i string . length ( ) ) ; return true ; }	boolean match etag ( string tag name ) throw jasper except { mark mark = mark ( ) ; ( match ( tag name ) ) return fals ; skip space ( ) ; ( next char ( ) = = ) return true ; reset ( mark ) ; return fals ; }	boolean match etag without less than ( string tag name ) throw jasper except { mark mark = mark ( ) ; ( match ( tag name ) ) return fals ; skip space ( ) ; ( next char ( ) = = ) return true ; reset ( mark ) ; return fals ; }	look ahead see ar option space follow given string . so , true return those space charact ar skip . , fals return posit restor where we were befor . boolean match option space follow ( string s ) throw jasper except { mark mark = mark ( ) ; skip space ( ) ; boolean result = match ( s ) ; ( result ) { reset ( mark ) ; } return result ; }	int next char ( ) throw jasper except { ( ha more input ( ) ) return 1 ; int ch = current . stream current . cursor ; current . cursor ; ( ch = = n ) { current . line ; current . col = 0 ; } els { current . col ; } return ch ; }	privat pars util current charact token delimit delimit ar current defin = , gt ; , lt ; , , ani ani space charact defin code space code . return boolean . boolean delimit ( ) throw jasper except { ( space ( ) ) { int ch = peek char ( ) ; look singl char work delimit : ( ch = = = ch = = ch = = ch = = ch = = ) { return true ; } look end comment end tag : ( ch = = ) { mark mark = mark ( ) ; ( ( ( ch = next char ( ) ) = = ) ( ( ch = = ) ( next char ( ) = = ) ) ) { reset ( mark ) ; return true ; } els { reset ( mark ) ; return fals ; } } return fals ; } els { return true ; } }	void reset ( mark mark ) { current = new mark ( mark ) ; }
privat void close outbound connect ( ws frame frame ) throw ioexcept { try { get ws outbound ( ) . close ( frame ) ; } final { do close ( constant . opcod close ) ; } }
privat secur constraint result arrai ( arrai list secur constraint result ) { ( result = = null ) { return null ; } secur constraint arrai = new secur constraint result . size ( ) ; result . arrai ( arrai ) ; return arrai ; }
protect list resourc which ar member collect . param file collect return vector contain name entri object list name entri list ( file file ) { list name entri entri = new arrai list name entri ( ) ; ( file . directori ( ) ) return entri ; string name = file . list ( ) ; ( name = = null ) { some io error occur bad file permiss . prevent npe arrai . sort ( name ) log . warn ( sm . get string ( file resourc . list null , file . get absolut path ( ) ) ) ; return entri ; } sort alphabet arrai . sort ( name ) ; name entri entri = null ; ( int i = 0 ; i name . length ; i ) { file current file = new file ( file , name i ) ; object object = null ; ( current file . directori ( ) ) { file dir context temp context = new file dir context ( env ) ; temp context . set doc base ( file . get path ( ) ) ; temp context . set allow link ( get allow link ( ) ) ; object = temp context ; } els { object = new file resourc ( current file ) ; } entri = new name entri ( name i , object , name entri . entri ) ; entri . add ( entri ) ; } return entri ; }
protect render html list current activ context our virtual host , memori server statu inform . param request request param respons respons param messag messag displai void list ( http servlet request request , http servlet respons respons , string messag , string manag sm client ) throw ioexcept { ( debug = 1 ) log ( list : list context virtual host host . get name ( ) ) ; print writer writer = respons . get writer ( ) ; html header section writer . print ( constant . html header section ) ; bodi header section object arg = new object 2 ; arg 0 = request . get context path ( ) ; arg 1 = sm client . get string ( html manag servlet . titl ) ; writer . print ( messag format . format ( constant . bodi header section , arg ) ) ; messag section arg = new object 3 ; arg 0 = sm client . get string ( html manag servlet . messag label ) ; ( messag = = null messag . length ( ) = = 0 ) { arg 1 = ok ; } els { arg 1 = request util . filter ( messag ) ; } writer . print ( messag format . format ( constant . messag section , arg ) ) ; manag section arg = new object 9 ; arg 0 = sm client . get string ( html manag servlet . manag ) ; arg 1 = respons . encod url ( request . get context path ( ) html list ) ; arg 2 = sm client . get string ( html manag servlet . list ) ; arg 3 = respons . encod url ( request . get context path ( ) sm client . get string ( html manag servlet . help html manag file ) ) ; arg 4 = sm client . get string ( html manag servlet . help html manag ) ; arg 5 = respons . encod url ( request . get context path ( ) sm client . get string ( html manag servlet . help manag file ) ) ; arg 6 = sm client . get string ( html manag servlet . help manag ) ; arg 7 = respons . encod url ( request . get context path ( ) statu ) ; arg 8 = sm client . get string ( statu servlet . titl ) ; writer . print ( messag format . format ( constant . manag section , arg ) ) ; app header section arg = new object 7 ; arg 0 = sm client . get string ( html manag servlet . app titl ) ; arg 1 = sm client . get string ( html manag servlet . app path ) ; arg 2 = sm client . get string ( html manag servlet . app version ) ; arg 3 = sm client . get string ( html manag servlet . app name ) ; arg 4 = sm client . get string ( html manag servlet . app avail ) ; arg 5 = sm client . get string ( html manag servlet . app session ) ; arg 6 = sm client . get string ( html manag servlet . app task ) ; writer . print ( messag format . format ( app header section , arg ) ) ; app row section creat sort map deploi applic context name . contain children = host . find children ( ) ; string context name = new string children . length ; ( int i = 0 ; i children . length ; i ) context name i = children i . get name ( ) ; arrai . sort ( context name ) ; string app start = sm client . get string ( html manag servlet . app start ) ; string app stop = sm client . get string ( html manag servlet . app stop ) ; string app reload = sm client . get string ( html manag servlet . app reload ) ; string app undeploi = sm client . get string ( html manag servlet . app undeploi ) ; string app expir = sm client . get string ( html manag servlet . app expir ) ; string version = i sm client . get string ( html manag servlet . version ) i ; boolean highlight = true ; boolean deploi = true ; string highlight color = null ; ( string context name : context name ) { context ctxt = ( context ) host . find child ( context name ) ; ( ctxt = null ) { bugzilla 34818 , altern row color highlight = highlight ; ( highlight ) { highlight color = c3f3c3 ; } els { highlight color = ffffff ; } string context path = ctxt . get path ( ) ; string displai path = context path ; ( displai path . equal ( ) ) { displai path = ; } string builder tmp = new string builder ( ) ; tmp . append ( path = ) ; tmp . append ( url encod . encod ( displai path ) ) ; ( ctxt . get webapp version ( ) . length ( ) 0 ) { tmp . append ( version = ) ; tmp . append ( url encod . encod ( ctxt . get webapp version ( ) ) ) ; } string path version = tmp . string ( ) ; try { deploi = deploi ( context name ) ; } catch ( except e ) { assum fals failur safeti deploi = fals ; } arg = new object 7 ; arg 0 = href = url encod . encod ( displai path ) request util . filter ( displai path ) ; ( . equal ( ctxt . get webapp version ( ) ) ) { arg 1 = version ; } els { arg 1 = request util . filter ( ctxt . get webapp version ( ) ) ; } ( ctxt . get displai name ( ) = = null ) { arg 2 = nbsp ; ; } els { arg 2 = request util . filter ( ctxt . get displai name ( ) ) ; } arg 3 = boolean . valu ( ctxt . get avail ( ) ) ; arg 4 = request util . filter ( respons . encod url ( request . get context path ( ) html session path version ) ) ; manag manag = ctxt . get manag ( ) ; ( manag instanceof distribut manag show proxi session ) { arg 5 = integ . valu ( ( ( distribut manag ) manag ) . get activ session full ( ) ) ; } els ( ctxt . get manag ( ) = null ) { arg 5 = integ . valu ( manag . get activ session ( ) ) ; } els { arg 5 = integ . valu ( 0 ) ; } arg 6 = highlight color ; writer . print ( messag format . format ( app row detail section , arg ) ) ; arg = new object 14 ; arg 0 = request util . filter ( respons . encod url ( request . get context path ( ) html start path version ) ) ; arg 1 = app start ; arg 2 = request util . filter ( respons . encod url ( request . get context path ( ) html stop path version ) ) ; arg 3 = app stop ; arg 4 = request util . filter ( respons . encod url ( request . get context path ( ) html reload path version ) ) ; arg 5 = app reload ; arg 6 = request util . filter ( respons . encod url ( request . get context path ( ) html undeploi path version ) ) ; arg 7 = app undeploi ; arg 8 = request util . filter ( respons . encod url ( request . get context path ( ) html expir path version ) ) ; arg 9 = app expir ; arg 10 = sm client . get string ( html manag servlet . expir . explain ) ; ( manag = = null ) { arg 11 = sm client . get string ( html manag servlet . manag ) ; } els { arg 11 = integ . valu ( ctxt . get manag ( ) . get max inact interv ( ) 60 ) ; } arg 12 = sm client . get string ( html manag servlet . expir . unit ) ; arg 13 = highlight color ; ( ctxt . get name ( ) . equal ( thi . context . get name ( ) ) ) { writer . print ( messag format . format ( manag app row button section , arg ) ) ; } els ( ctxt . get avail ( ) deploi ) { writer . print ( messag format . format ( start deploi app row button section , arg ) ) ; } els ( ctxt . get avail ( ) deploi ) { writer . print ( messag format . format ( start nondeploi app row button section , arg ) ) ; } els ( ctxt . get avail ( ) deploi ) { writer . print ( messag format . format ( stop deploi app row button section , arg ) ) ; } els { writer . print ( messag format . format ( stop nondeploi app row button section , arg ) ) ; } } } deploi section arg = new object 7 ; arg 0 = sm client . get string ( html manag servlet . deploi titl ) ; arg 1 = sm client . get string ( html manag servlet . deploi server ) ; arg 2 = respons . encod url ( request . get context path ( ) html deploi ) ; arg 3 = sm client . get string ( html manag servlet . deploi path ) ; arg 4 = sm client . get string ( html manag servlet . deploi config ) ; arg 5 = sm client . get string ( html manag servlet . deploi war ) ; arg 6 = sm client . get string ( html manag servlet . deploi button ) ; writer . print ( messag format . format ( deploi section , arg ) ) ; arg = new object 4 ; arg 0 = sm client . get string ( html manag servlet . deploi upload ) ; arg 1 = respons . encod url ( request . get context path ( ) html upload ) ; arg 2 = sm client . get string ( html manag servlet . deploi upload file ) ; arg 3 = sm client . get string ( html manag servlet . deploi button ) ; writer . print ( messag format . format ( upload section , arg ) ) ; diagnost section arg = new object 5 ; arg 0 = sm client . get string ( html manag servlet . diagnost titl ) ; arg 1 = sm client . get string ( html manag servlet . diagnost leak ) ; arg 2 = respons . encod url ( request . get context path ( ) html findleak ) ; arg 3 = sm client . get string ( html manag servlet . diagnost leak warn ) ; arg 4 = sm client . get string ( html manag servlet . diagnost leak button ) ; writer . print ( messag format . format ( diagnost section , arg ) ) ; server header section arg = new object 9 ; arg 0 = sm client . get string ( html manag servlet . server titl ) ; arg 1 = sm client . get string ( html manag servlet . server version ) ; arg 2 = sm client . get string ( html manag servlet . server jvmversion ) ; arg 3 = sm client . get string ( html manag servlet . server jvmvendor ) ; arg 4 = sm client . get string ( html manag servlet . server osnam ) ; arg 5 = sm client . get string ( html manag servlet . server osvers ) ; arg 6 = sm client . get string ( html manag servlet . server osarch ) ; arg 7 = sm . get string ( html manag servlet . server hostnam ) ; arg 8 = sm . get string ( html manag servlet . server ipaddress ) ; writer . print ( messag format . format ( constant . server header section , arg ) ) ; server row section arg = new object 8 ; arg 0 = server info . get server info ( ) ; arg 1 = system . get properti ( java . runtim . version ) ; arg 2 = system . get properti ( java . vm . vendor ) ; arg 3 = system . get properti ( os . name ) ; arg 4 = system . get properti ( os . version ) ; arg 5 = system . get properti ( os . arch ) ; try { inet address address = inet address . get local host ( ) ; arg 6 = address . get host name ( ) ; arg 7 = address . get host address ( ) ; } catch ( unknown host except e ) { arg 6 = ; arg 7 = ; } writer . print ( messag format . format ( constant . server row section , arg ) ) ; html tail section writer . print ( constant . html tail section ) ; finish up respons writer . flush ( ) ; writer . close ( ) ; }
protect pars header chunk . chunk header can look like a10crlf f23 ; chunk extens ignor crlf letter befor crlf after trailer mark , must valid hex digit , we should pars valid header accord spec boolean pars chunk header ( ) throw ioexcept { int result = 0 ; boolean eol = fals ; boolean read digit = fals ; boolean trailer = fals ; while ( eol ) { ( po = last valid ) { ( read byte ( ) = 0 ) return fals ; } ( buf po = = constant . cr ) { fixm : improv pars check crlf } els ( buf po = = constant . lf ) { eol = true ; } els ( buf po = = constant . semi colon ) { trailer = true ; } els ( trailer ) { don t read data after trailer ( hex util . get dec ( buf po ) = 1 ) { read digit = true ; result = 16 ; result = hex util . get dec ( buf po ) ; } els { chunk header return fals ; } } po ; } ( read digit ) return fals ; ( result = = 0 ) end chunk = true ; remain = result ; ( remain 0 ) return fals ; return true ; }	public static int get dec ( int index ) { return dec index ; }
protect scan jar contain web fragment . xml file us configur thi applic see thei also contain static resourc . static resourc ar found , add them context . resourc ar ad web fragment . xml prioriti order . void process resourc jar ( set web xml fragment ) { ( web xml fragment : fragment ) { url url = fragment . get url ( ) ; jar jar = null ; try { note : ignor file url now sinc onli jar url accept ( jar . equal ( url . get protocol ( ) ) ) { jar = jar factori . new instanc ( url ) ; ( jar . entri exist ( meta inf resourc ) ) { context . add resourc jar url ( url ) ; } } els ( file . equal ( url . get protocol ( ) ) ) { file dir context file dir context = new file dir context ( ) ; file dir context . set doc base ( new file ( url . uri ( ) ) . get absolut path ( ) ) ; try { file dir context . lookup ( meta inf resourc ) ; lookup succeed ( context instanceof standard context ) { ( ( standard context ) context ) . add resourc dir context ( file dir context ) ; } } catch ( name except e ) { found , ignor } } } catch ( ioexcept ioe ) { log . error ( sm . get string ( context config . resourc jar fail , url , context . get name ( ) ) ) ; } catch ( urisyntax except e ) { log . error ( sm . get string ( context config . resourc jar fail , url , context . get name ( ) ) ) ; } final { ( jar = null ) { jar . close ( ) ; } } } }
overrid public void add map servlet name ( enum set dispatch type dispatch type , boolean match after , string . . . servlet name ) { filter map filter map = new filter map ( ) ; filter map . set filter name ( filter def . get filter name ( ) ) ; ( dispatch type = null ) { ( dispatch type dispatch type : dispatch type ) { filter map . set dispatch ( dispatch type . name ( ) ) ; } } ( servlet name = null ) { ( string servlet name : servlet name ) { filter map . add servlet name ( servlet name ) ; } ( match after ) { context . add filter map befor ( filter map ) ; } els { context . add filter map ( filter map ) ; } } els error }	overrid public collect string get url pattern map ( ) { collect string result = new hash set ( ) ; filter map filter map = context . find filter map ( ) ; ( filter map filter map : filter map ) { ( filter map . get filter name ( ) . equal ( filter def . get filter name ( ) ) ) { ( string url pattern : filter map . get urlpattern ( ) ) { result . add ( url pattern ) ; } } } return result ; }
keep call deflat until run dry . default implement onli doe onc can therefor hold onto data when thei need flush out . overrid protect void deflat ( ) throw ioexcept { int len ; do { len = def . deflat ( buf , 0 , buf . length ) ; ( len 0 ) { out . write ( buf , 0 , len ) ; } } while ( len = 0 ) ; }
privat static digest creat tld digest ( boolean namespac awar , boolean valid ) { digest digest = null ; ( namespac awar valid ) { ( tld digest 0 = = null ) { tld digest 0 = digest factori . new digest ( valid , namespac awar , new tld rule set ( ) ) ; tld digest 0 . get parser ( ) ; } digest = tld digest 0 ; } els ( namespac awar valid ) { ( tld digest 1 = = null ) { tld digest 1 = digest factori . new digest ( valid , namespac awar , new tld rule set ( ) ) ; tld digest 1 . get parser ( ) ; } digest = tld digest 1 ; } els ( namespac awar valid ) { ( tld digest 2 = = null ) { tld digest 2 = digest factori . new digest ( valid , namespac awar , new tld rule set ( ) ) ; tld digest 2 . get parser ( ) ; } digest = tld digest 2 ; } els { ( tld digest 3 = = null ) { tld digest 3 = digest factori . new digest ( valid , namespac awar , new tld rule set ( ) ) ; tld digest 3 . get parser ( ) ; } digest = tld digest 3 ; } return digest ; }	protect scan web inf lib jar each found add ani meta inf web fragment . xml result map . web fragment . xml file pars befor ad map . everi jar ad code null code us web fragment . xml wa found . ani jar known contain fragment skip . return map jar name process web fragment ( ani ) map string , web xml process jar web fragment ( ) { jar scanner jar scanner = context . get jar scanner ( ) ; fragment jar scanner callback callback = new fragment jar scanner callback ( ) ; jar scanner . scan ( context . get servlet context ( ) , context . get loader ( ) . get class loader ( ) , callback , null ) ; return callback . get fragment ( ) ; }	public determin provid uri known taglib uri . boolean known webxml taglib uri ( string uri ) { return webxml taglib uri . contain ( uri ) ; }	public static set list jar ar known contain ani tld . param jar name list comma separ name jar file ar known contain ani tld void set tld jar ( string jar name ) { ( jar name = = null ) { tld jar = null ; } els { ( tld jar = = null ) { tld jar = new hash set string ( ) ; } els { tld jar . clear ( ) ; } string token token = new string token ( jar name , , ) ; while ( token . ha more element ( ) ) { tld jar . add ( token . next token ( ) ) ; } } }
overrid public final void recycl ( boolean socket close ) { ( get input buffer ( ) = null ) { get input buffer ( ) . recycl ( ) ; } ( get output buffer ( ) = null ) { get output buffer ( ) . recycl ( ) ; } ( async state machin = null ) { async state machin . recycl ( ) ; } upgrad inbound = null ; remot addr = null ; remot host = null ; local addr = null ; local name = null ; remot port = 1 ; local port = 1 ; recycl intern ( ) ; }	overrid public void recycl intern ( ) { socket = null ; comet = fals ; sendfil data = null ; want write possibl = fals ; }
overrid public collect string get url pattern ( ) { collect string result = new hash set ( ) ; ( jsp properti group . get url pattern ( ) = null ) { result . add ( jsp properti group . get url pattern ( ) ) ; } return result ; }	public gener web . xml string form match represent store thi object . return complet content web . xml string string xml ( ) { string builder sb = new string builder ( 2048 ) ; todo variou , icon , descript etc element ar skip mainli becaus thei ar ignor when web . xml pars see abov declar sb . append ( xml version = 1 . 0 encod = utf 8 n ) ; root element sb . append ( web app xmln = http : java . sun . com xml ns javae n ) ; sb . append ( xmln : xsi = ) ; sb . append ( http : www . w3 . org 2001 xmlschema instanc n ) ; sb . append ( xsi : schema locat = ) ; sb . append ( http : java . sun . com xml ns javae web app 3 0 . xsd n ) ; sb . append ( version = ) ; sb . append ( get version ( ) ) ; sb . append ( n ) ; sb . append ( metadata complet = true n n ) ; append element ( sb , indent2 , displai name , displai name ) ; ( distribut ( ) ) { sb . append ( distribut n n ) ; } ( map . entri string , string entri : context param . entri set ( ) ) { sb . append ( context param n ) ; append element ( sb , indent4 , param name , entri . get kei ( ) ) ; append element ( sb , indent4 , param value , entri . get valu ( ) ) ; sb . append ( context param n ) ; } sb . append ( n ) ; ( map . entri string , filter def entri : filter . entri set ( ) ) { filter def filter def = entri . get valu ( ) ; sb . append ( filter n ) ; append element ( sb , indent4 , descript , filter def . get descript ( ) ) ; append element ( sb , indent4 , displai name , filter def . get displai name ( ) ) ; append element ( sb , indent4 , filter name , filter def . get filter name ( ) ) ; append element ( sb , indent4 , filter class , filter def . get filter class ( ) ) ; append element ( sb , indent4 , async support , filter def . get async support ( ) ) ; ( map . entri string , string param : filter def . get paramet map ( ) . entri set ( ) ) { sb . append ( init param n ) ; append element ( sb , indent6 , param name , param . get kei ( ) ) ; append element ( sb , indent6 , param valu , param . get valu ( ) ) ; sb . append ( init param n ) ; } sb . append ( filter n ) ; } sb . append ( n ) ; ( filter map filter map : filter map ) { sb . append ( filter map n ) ; append element ( sb , indent4 , filter name , filter map . get filter name ( ) ) ; ( filter map . get match all servlet name ( ) ) { sb . append ( servlet name servlet name n ) ; } els { ( string servlet name : filter map . get servlet name ( ) ) { append element ( sb , indent4 , servlet name , servlet name ) ; } } ( filter map . get match all url pattern ( ) ) { sb . append ( url pattern url pattern n ) ; } els { ( string url pattern : filter map . get urlpattern ( ) ) { append element ( sb , indent4 , url pattern , url pattern ) ; } } ( string dispatch : filter map . get dispatch name ( ) ) { append element ( sb , indent4 , dispatch , dispatch ) ; } sb . append ( filter map n ) ; } sb . append ( n ) ; ( string listen : listen ) { sb . append ( listen n ) ; append element ( sb , indent4 , listen class , listen ) ; sb . append ( listen n ) ; } sb . append ( n ) ; ( map . entri string , servlet def entri : servlet . entri set ( ) ) { servlet def servlet def = entri . get valu ( ) ; sb . append ( servlet n ) ; append element ( sb , indent4 , descript , servlet def . get descript ( ) ) ; append element ( sb , indent4 , displai name , servlet def . get displai name ( ) ) ; append element ( sb , indent4 , servlet name , entri . get kei ( ) ) ; append element ( sb , indent4 , servlet class , servlet def . get servlet class ( ) ) ; append element ( sb , indent4 , jsp file , servlet def . get jsp file ( ) ) ; ( map . entri string , string param : servlet def . get paramet map ( ) . entri set ( ) ) { sb . append ( init param n ) ; append element ( sb , indent6 , param name , param . get kei ( ) ) ; append element ( sb , indent6 , param valu , param . get valu ( ) ) ; sb . append ( init param n ) ; } append element ( sb , indent4 , load startup , servlet def . get load startup ( ) ) ; append element ( sb , indent4 , enabl , servlet def . get enabl ( ) ) ; append element ( sb , indent4 , async support , servlet def . get async support ( ) ) ; ( servlet def . get run ( ) = null ) { sb . append ( run n ) ; append element ( sb , indent6 , role name , servlet def . get run ( ) ) ; sb . append ( run n ) ; } ( secur role ref role ref : servlet def . get secur role ref ( ) ) { sb . append ( secur role ref n ) ; append element ( sb , indent6 , role name , role ref . get name ( ) ) ; append element ( sb , indent6 , role link , role ref . get link ( ) ) ; sb . append ( secur role ref n ) ; } multipart def multipart def = servlet def . get multipart def ( ) ; ( multipart def = null ) { sb . append ( multipart config n ) ; append element ( sb , indent6 , locat , multipart def . get locat ( ) ) ; append element ( sb , indent6 , max file size , multipart def . get max file size ( ) ) ; append element ( sb , indent6 , max request size , multipart def . get max request size ( ) ) ; append element ( sb , indent6 , file size threshold , multipart def . get file size threshold ( ) ) ; sb . append ( multipart config n ) ; } sb . append ( servlet n ) ; } sb . append ( n ) ; ( map . entri string , string entri : servlet map . entri set ( ) ) { sb . append ( servlet map n ) ; append element ( sb , indent4 , servlet name , entri . get valu ( ) ) ; append element ( sb , indent4 , url pattern , entri . get kei ( ) ) ; sb . append ( servlet map n ) ; } sb . append ( n ) ; ( session config = null ) { sb . append ( session config n ) ; append element ( sb , indent4 , session timeout , session config . get session timeout ( ) ) ; sb . append ( cooki config n ) ; append element ( sb , indent6 , name , session config . get cooki name ( ) ) ; append element ( sb , indent6 , domain , session config . get cooki domain ( ) ) ; append element ( sb , indent6 , path , session config . get cooki path ( ) ) ; append element ( sb , indent6 , comment , session config . get cooki comment ( ) ) ; append element ( sb , indent6 , http onli , session config . get cooki http onli ( ) ) ; append element ( sb , indent6 , secur , session config . get cooki secur ( ) ) ; append element ( sb , indent6 , max ag , session config . get cooki max ag ( ) ) ; sb . append ( cooki config n ) ; ( session track mode stm : session config . get session track mode ( ) ) { append element ( sb , indent4 , track mode , stm . name ( ) ) ; } sb . append ( session config n n ) ; } ( map . entri string , string entri : mime map . entri set ( ) ) { sb . append ( mime map n ) ; append element ( sb , indent4 , extens , entri . get kei ( ) ) ; append element ( sb , indent4 , mime type , entri . get valu ( ) ) ; sb . append ( mime map n ) ; } sb . append ( n ) ; ( welcom file . size ( ) 0 ) { sb . append ( welcom file list n ) ; ( string welcom file : welcom file ) { append element ( sb , indent4 , welcom file , welcom file ) ; } sb . append ( welcom file list n n ) ; } ( error page error page : error page . valu ( ) ) { sb . append ( error page n ) ; ( error page . get except type ( ) = = null ) { append element ( sb , indent4 , error code , integ . string ( error page . get error code ( ) ) ) ; } els { append element ( sb , indent4 , except type , error page . get except type ( ) ) ; } append element ( sb , indent4 , locat , error page . get locat ( ) ) ; sb . append ( error page n ) ; } sb . append ( n ) ; ( taglib . size ( ) 0 jsp properti group . size ( ) 0 ) { sb . append ( jsp config n ) ; ( map . entri string , string entri : taglib . entri set ( ) ) { sb . append ( taglib n ) ; append element ( sb , indent6 , taglib uri , entri . get kei ( ) ) ; append element ( sb , indent6 , taglib locat , entri . get valu ( ) ) ; sb . append ( taglib n ) ; } ( jsp properti group jpg : jsp properti group ) { sb . append ( jsp properti group n ) ; append element ( sb , indent6 , url pattern , jpg . get url pattern ( ) ) ; append element ( sb , indent6 , el ignor , jpg . get el ignor ( ) ) ; append element ( sb , indent6 , script invalid , jpg . get script invalid ( ) ) ; append element ( sb , indent6 , page encod , jpg . get page encod ( ) ) ; ( string prelud : jpg . get includ prelud ( ) ) { append element ( sb , indent6 , includ prelud , prelud ) ; } ( string coda : jpg . get includ coda ( ) ) { append element ( sb , indent6 , includ coda , coda ) ; } append element ( sb , indent6 , xml , jpg . get xml ( ) ) ; append element ( sb , indent6 , defer syntax allow liter , jpg . get defer syntax ( ) ) ; append element ( sb , indent6 , trim direct whitespac , jpg . get trim whitespac ( ) ) ; append element ( sb , indent6 , default content type , jpg . get default content type ( ) ) ; append element ( sb , indent6 , buffer , jpg . get buffer ( ) ) ; append element ( sb , indent6 , error undeclar namespac , jpg . get error undeclar namespac ( ) ) ; sb . append ( jsp properti group n ) ; } sb . append ( jsp config n n ) ; } ( secur constraint constraint : secur constraint ) { sb . append ( secur constraint n ) ; append element ( sb , indent4 , displai name , constraint . get displai name ( ) ) ; ( secur collect collect : constraint . find collect ( ) ) { sb . append ( web resourc collect n ) ; append element ( sb , indent6 , web resourc name , collect . get name ( ) ) ; append element ( sb , indent6 , descript , collect . get descript ( ) ) ; ( string url pattern : collect . find pattern ( ) ) { append element ( sb , indent6 , url pattern , url pattern ) ; } ( string method : collect . find method ( ) ) { append element ( sb , indent6 , http method , method ) ; } ( string method : collect . find omit method ( ) ) { append element ( sb , indent6 , http method omiss , method ) ; } sb . append ( web resourc collect n ) ; } ( constraint . find auth role ( ) . length 0 ) { sb . append ( auth constraint n ) ; ( string role : constraint . find auth role ( ) ) { append element ( sb , indent6 , role name , role ) ; } sb . append ( auth constraint n ) ; } ( constraint . get user constraint ( ) = null ) { sb . append ( user data constraint n ) ; append element ( sb , indent6 , transport guarante , constraint . get user constraint ( ) ) ; sb . append ( user data constraint n ) ; } sb . append ( secur constraint n ) ; } sb . append ( n ) ; ( login config = null ) { sb . append ( login config n ) ; append element ( sb , indent4 , auth method , login config . get auth method ( ) ) ; append element ( sb , indent4 , realm name , login config . get realm name ( ) ) ; ( login config . get error page ( ) = null login config . get login page ( ) = null ) { sb . append ( form login config n ) ; append element ( sb , indent6 , form login page , login config . get login page ( ) ) ; append element ( sb , indent6 , form error page , login config . get error page ( ) ) ; sb . append ( form login config n ) ; } sb . append ( login config n n ) ; } ( string role name : secur role ) { sb . append ( secur role n ) ; append element ( sb , indent4 , role name , role name ) ; sb . append ( secur role n ) ; } ( context environ env entri : env entri . valu ( ) ) { sb . append ( env entri n ) ; append element ( sb , indent4 , descript , env entri . get descript ( ) ) ; append element ( sb , indent4 , env entri name , env entri . get name ( ) ) ; append element ( sb , indent4 , env entri type , env entri . get type ( ) ) ; append element ( sb , indent4 , env entri valu , env entri . get valu ( ) ) ; todo map name ( inject target target : env entri . get inject target ( ) ) { sb . append ( inject target n ) ; append element ( sb , indent6 , inject target class , target . get target class ( ) ) ; append element ( sb , indent6 , inject target name , target . get target name ( ) ) ; sb . append ( inject target n ) ; } todo lookup name sb . append ( env entri n ) ; } sb . append ( n ) ; ( context ejb ejb ref : ejb ref . valu ( ) ) { sb . append ( ejb ref n ) ; append element ( sb , indent4 , descript , ejb ref . get descript ( ) ) ; append element ( sb , indent4 , ejb ref name , ejb ref . get name ( ) ) ; append element ( sb , indent4 , ejb ref type , ejb ref . get type ( ) ) ; append element ( sb , indent4 , home , ejb ref . get home ( ) ) ; append element ( sb , indent4 , remot , ejb ref . get remot ( ) ) ; append element ( sb , indent4 , ejb link , ejb ref . get link ( ) ) ; todo map name ( inject target target : ejb ref . get inject target ( ) ) { sb . append ( inject target n ) ; append element ( sb , indent6 , inject target class , target . get target class ( ) ) ; append element ( sb , indent6 , inject target name , target . get target name ( ) ) ; sb . append ( inject target n ) ; } todo lookup name sb . append ( ejb ref n ) ; } sb . append ( n ) ; ( context local ejb ejb local ref : ejb local ref . valu ( ) ) { sb . append ( ejb local ref n ) ; append element ( sb , indent4 , descript , ejb local ref . get descript ( ) ) ; append element ( sb , indent4 , ejb ref name , ejb local ref . get name ( ) ) ; append element ( sb , indent4 , ejb ref type , ejb local ref . get type ( ) ) ; append element ( sb , indent4 , local home , ejb local ref . get home ( ) ) ; append element ( sb , indent4 , local , ejb local ref . get local ( ) ) ; append element ( sb , indent4 , ejb link , ejb local ref . get link ( ) ) ; todo map name ( inject target target : ejb local ref . get inject target ( ) ) { sb . append ( inject target n ) ; append element ( sb , indent6 , inject target class , target . get target class ( ) ) ; append element ( sb , indent6 , inject target name , target . get target name ( ) ) ; sb . append ( inject target n ) ; } todo lookup name sb . append ( ejb local ref n ) ; } sb . append ( n ) ; ( context servic servic ref : servic ref . valu ( ) ) { sb . append ( servic ref n ) ; append element ( sb , indent4 , descript , servic ref . get descript ( ) ) ; append element ( sb , indent4 , displai name , servic ref . get displaynam ( ) ) ; append element ( sb , indent4 , servic ref name , servic ref . get name ( ) ) ; append element ( sb , indent4 , servic interfac , servic ref . get interfac ( ) ) ; append element ( sb , indent4 , servic ref type , servic ref . get type ( ) ) ; append element ( sb , indent4 , wsdl file , servic ref . get wsdlfile ( ) ) ; append element ( sb , indent4 , jaxrpc map file , servic ref . get jaxrpcmappingfil ( ) ) ; string qname = servic ref . get serviceqnam namespac uri ( ) ; ( qname = null ) { qname = qname : ; } qname = qname servic ref . get serviceqnam localpart ( ) ; append element ( sb , indent4 , servic qname , qname ) ; iter string endpoint iter = servic ref . get serviceendpoint ( ) ; while ( endpoint iter . ha next ( ) ) { string endpoint = endpoint iter . next ( ) ; sb . append ( port compon ref n ) ; append element ( sb , indent6 , servic endpoint interfac , endpoint ) ; append element ( sb , indent6 , port compon link , servic ref . get properti ( endpoint ) ) ; sb . append ( port compon ref n ) ; } iter string handler iter = servic ref . get handler ( ) ; while ( handler iter . ha next ( ) ) { string handler = handler iter . next ( ) ; sb . append ( handler n ) ; context handler ch = servic ref . get handler ( handler ) ; append element ( sb , indent6 , handler name , ch . get name ( ) ) ; append element ( sb , indent6 , handler class , ch . get handlerclass ( ) ) ; sb . append ( handler n ) ; } todo map name ( inject target target : servic ref . get inject target ( ) ) { sb . append ( inject target n ) ; append element ( sb , indent6 , inject target class , target . get target class ( ) ) ; append element ( sb , indent6 , inject target name , target . get target name ( ) ) ; sb . append ( inject target n ) ; } todo lookup name sb . append ( servic ref n ) ; } sb . append ( n ) ; ( context resourc resourc ref : resourc ref . valu ( ) ) { sb . append ( resourc ref n ) ; append element ( sb , indent4 , descript , resourc ref . get descript ( ) ) ; append element ( sb , indent4 , re ref name , resourc ref . get name ( ) ) ; append element ( sb , indent4 , re type , resourc ref . get type ( ) ) ; append element ( sb , indent4 , re auth , resourc ref . get auth ( ) ) ; append element ( sb , indent4 , re share scope , resourc ref . get scope ( ) ) ; todo map name ( inject target target : resourc ref . get inject target ( ) ) { sb . append ( inject target n ) ; append element ( sb , indent6 , inject target class , target . get target class ( ) ) ; append element ( sb , indent6 , inject target name , target . get target name ( ) ) ; sb . append ( inject target n ) ; } todo lookup name sb . append ( resourc ref n ) ; } sb . append ( n ) ; ( context resourc env ref resourc env ref : resourc env ref . valu ( ) ) { sb . append ( resourc env ref n ) ; append element ( sb , indent4 , descript , resourc env ref . get descript ( ) ) ; append element ( sb , indent4 , resourc env ref name , resourc env ref . get name ( ) ) ; append element ( sb , indent4 , resourc env ref type , resourc env ref . get type ( ) ) ; todo map name ( inject target target : resourc env ref . get inject target ( ) ) { sb . append ( inject target n ) ; append element ( sb , indent6 , inject target class , target . get target class ( ) ) ; append element ( sb , indent6 , inject target name , target . get target name ( ) ) ; sb . append ( inject target n ) ; } todo lookup name sb . append ( resourc env ref n ) ; } sb . append ( n ) ; ( messag destin ref mdr : messag destin ref . valu ( ) ) { sb . append ( messag destin ref n ) ; append element ( sb , indent4 , descript , mdr . get descript ( ) ) ; append element ( sb , indent4 , messag destin ref name , mdr . get name ( ) ) ; append element ( sb , indent4 , messag destin type , mdr . get type ( ) ) ; append element ( sb , indent4 , messag destin usag , mdr . get usag ( ) ) ; append element ( sb , indent4 , messag destin link , mdr . get link ( ) ) ; todo map name ( inject target target : mdr . get inject target ( ) ) { sb . append ( inject target n ) ; append element ( sb , indent6 , inject target class , target . get target class ( ) ) ; append element ( sb , indent6 , inject target name , target . get target name ( ) ) ; sb . append ( inject target n ) ; } todo lookup name sb . append ( messag destin ref n ) ; } sb . append ( n ) ; ( messag destin md : messag destin . valu ( ) ) { sb . append ( messag destin n ) ; append element ( sb , indent4 , descript , md . get descript ( ) ) ; append element ( sb , indent4 , displai name , md . get displai name ( ) ) ; append element ( sb , indent4 , messag destin name , md . get name ( ) ) ; todo map name sb . append ( messag destin n ) ; } sb . append ( n ) ; ( local encod map . size ( ) 0 ) { sb . append ( local encod map list n ) ; ( map . entri string , string entri : local encod map . entri set ( ) ) { sb . append ( local encod map n ) ; append element ( sb , indent6 , local , entri . get kei ( ) ) ; append element ( sb , indent6 , encod , entri . get valu ( ) ) ; sb . append ( local encod map n ) ; } sb . append ( local encod map list n ) ; } sb . append ( web app ) ; return sb . string ( ) ; }	p add set rule instanc defin thi rule set specifi code digest code instanc , associ them our namespac uri ( ani ) . thi method should onli call digest instanc . p param digest digest instanc which new rule instanc should ad . overrid public void add rule instanc ( digest digest ) { digest . add rule ( full prefix , new set public id rule ( set public id ) ) ; digest . add rule ( full prefix , new ignor annot rule ( ) ) ; digest . add rule ( full prefix , new version rule ( ) ) ; requir both fragment non fragment digest . add rule ( full prefix absolut order , absolut order ) ; digest . add rule ( full prefix order , rel order ) ; ( fragment ) { web fragment . xml digest . add rule ( full prefix name , name ) ; digest . add call method ( full prefix order after name , add after order , 0 ) ; digest . add call method ( full prefix order after other , add after order other ) ; digest . add call method ( full prefix order befor name , add befor order , 0 ) ; digest . add call method ( full prefix order befor other , add befor order other ) ; } els { web . xml digest . add call method ( full prefix absolut order name , add absolut order , 0 ) ; digest . add call method ( full prefix absolut order other , add absolut order other ) ; } digest . add call method ( full prefix context param , add context param , 2 ) ; digest . add call param ( full prefix context param param name , 0 ) ; digest . add call param ( full prefix context param param valu , 1 ) ; digest . add call method ( full prefix displai name , set displai name , 0 ) ; digest . add rule ( full prefix distribut , new set distribut rule ( ) ) ; configur name rule ( digest ) ; digest . add object creat ( full prefix error page , org . apach . catalina . deploi . error page ) ; digest . add set next ( full prefix error page , add error page , org . apach . catalina . deploi . error page ) ; digest . add call method ( full prefix error page error code , set error code , 0 ) ; digest . add call method ( full prefix error page except type , set except type , 0 ) ; digest . add call method ( full prefix error page locat , set locat , 0 ) ; digest . add object creat ( full prefix filter , org . apach . catalina . deploi . filter def ) ; digest . add set next ( full prefix filter , add filter , org . apach . catalina . deploi . filter def ) ; digest . add call method ( full prefix filter descript , set descript , 0 ) ; digest . add call method ( full prefix filter displai name , set displai name , 0 ) ; digest . add call method ( full prefix filter filter class , set filter class , 0 ) ; digest . add call method ( full prefix filter filter name , set filter name , 0 ) ; digest . add call method ( full prefix filter icon larg icon , set larg icon , 0 ) ; digest . add call method ( full prefix filter icon small icon , set small icon , 0 ) ; digest . add call method ( full prefix filter async support , set async support , 0 ) ; digest . add call method ( full prefix filter init param , add init paramet , 2 ) ; digest . add call param ( full prefix filter init param param name , 0 ) ; digest . add call param ( full prefix filter init param param valu , 1 ) ; digest . add object creat ( full prefix filter map , org . apach . catalina . deploi . filter map ) ; digest . add set next ( full prefix filter map , add filter map , org . apach . catalina . deploi . filter map ) ; digest . add call method ( full prefix filter map filter name , set filter name , 0 ) ; digest . add call method ( full prefix filter map servlet name , add servlet name , 0 ) ; digest . add call method ( full prefix filter map url pattern , add urlpattern , 0 ) ; digest . add call method ( full prefix filter map dispatch , set dispatch , 0 ) ; digest . add call method ( full prefix listen listen class , add listen , 0 ) ; digest . add rule ( full prefix jsp config , jsp config ) ; digest . add object creat ( full prefix jsp config jsp properti group , org . apach . catalina . deploi . jsp properti group ) ; digest . add set next ( full prefix jsp config jsp properti group , add jsp properti group , org . apach . catalina . deploi . jsp properti group ) ; digest . add call method ( full prefix jsp config jsp properti group defer syntax allow liter , set defer syntax , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group el ignor , set el ignor , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group includ coda , add includ coda , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group includ prelud , add includ prelud , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group xml , set xml , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group page encod , set page encod , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group script invalid , set script invalid , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group trim direct whitespac , set trim whitespac , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group url pattern , set url pattern , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group default content type , set default content type , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group buffer , set buffer , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group error undeclar namespac , set error undeclar namespac , 0 ) ; digest . add rule ( full prefix login config , login config ) ; digest . add object creat ( full prefix login config , org . apach . catalina . deploi . login config ) ; digest . add set next ( full prefix login config , set login config , org . apach . catalina . deploi . login config ) ; digest . add call method ( full prefix login config auth method , set auth method , 0 ) ; digest . add call method ( full prefix login config realm name , set realm name , 0 ) ; digest . add call method ( full prefix login config form login config form error page , set error page , 0 ) ; digest . add call method ( full prefix login config form login config form login page , set login page , 0 ) ; digest . add call method ( full prefix mime map , add mime map , 2 ) ; digest . add call param ( full prefix mime map extens , 0 ) ; digest . add call param ( full prefix mime map mime type , 1 ) ; digest . add object creat ( full prefix secur constraint , org . apach . catalina . deploi . secur constraint ) ; digest . add set next ( full prefix secur constraint , add secur constraint , org . apach . catalina . deploi . secur constraint ) ; digest . add rule ( full prefix secur constraint auth constraint , new set auth constraint rule ( ) ) ; digest . add call method ( full prefix secur constraint auth constraint role name , add auth role , 0 ) ; digest . add call method ( full prefix secur constraint displai name , set displai name , 0 ) ; digest . add call method ( full prefix secur constraint user data constraint transport guarante , set user constraint , 0 ) ; digest . add object creat ( full prefix secur constraint web resourc collect , org . apach . catalina . deploi . secur collect ) ; digest . add set next ( full prefix secur constraint web resourc collect , add collect , org . apach . catalina . deploi . secur collect ) ; digest . add call method ( full prefix secur constraint web resourc collect http method , add method , 0 ) ; digest . add call method ( full prefix secur constraint web resourc collect http method omiss , add omit method , 0 ) ; digest . add call method ( full prefix secur constraint web resourc collect url pattern , add pattern , 0 ) ; digest . add call method ( full prefix secur constraint web resourc collect web resourc name , set name , 0 ) ; digest . add call method ( full prefix secur role role name , add secur role , 0 ) ; digest . add rule ( full prefix servlet , new servlet def creat rule ( ) ) ; digest . add set next ( full prefix servlet , add servlet , org . apach . catalina . deploi . servlet def ) ; digest . add call method ( full prefix servlet init param , add init paramet , 2 ) ; digest . add call param ( full prefix servlet init param param name , 0 ) ; digest . add call param ( full prefix servlet init param param valu , 1 ) ; digest . add call method ( full prefix servlet jsp file , set jsp file , 0 ) ; digest . add call method ( full prefix servlet load startup , set load startup , 0 ) ; digest . add call method ( full prefix servlet run role name , set run , 0 ) ; digest . add object creat ( full prefix servlet secur role ref , org . apach . catalina . deploi . secur role ref ) ; digest . add set next ( full prefix servlet secur role ref , add secur role ref , org . apach . catalina . deploi . secur role ref ) ; digest . add call method ( full prefix servlet secur role ref role link , set link , 0 ) ; digest . add call method ( full prefix servlet secur role ref role name , set name , 0 ) ; digest . add call method ( full prefix servlet servlet class , set servlet class , 0 ) ; digest . add call method ( full prefix servlet servlet name , set servlet name , 0 ) ; digest . add object creat ( full prefix servlet multipart config , org . apach . catalina . deploi . multipart def ) ; digest . add set next ( full prefix servlet multipart config , set multipart def , org . apach . catalina . deploi . multipart def ) ; digest . add call method ( full prefix servlet multipart config locat , set locat , 0 ) ; digest . add call method ( full prefix servlet multipart config max file size , set max file size , 0 ) ; digest . add call method ( full prefix servlet multipart config max request size , set max request size , 0 ) ; digest . add call method ( full prefix servlet multipart config file size threshold , set file size threshold , 0 ) ; digest . add call method ( full prefix servlet async support , set async support , 0 ) ; digest . add call method ( full prefix servlet enabl , set enabl , 0 ) ; digest . add rule ( full prefix servlet map , new call method multi rule ( add servlet map , 2 , 0 ) ) ; digest . add call param ( full prefix servlet map servlet name , 1 ) ; digest . add rule ( full prefix servlet map url pattern , new call param multi rule ( 0 ) ) ; digest . add rule ( full prefix session config , session config ) ; digest . add object creat ( full prefix session config , org . apach . catalina . deploi . session config ) ; digest . add set next ( full prefix session config , set session config , org . apach . catalina . deploi . session config ) ; digest . add call method ( full prefix session config session timeout , set session timeout , 0 ) ; digest . add call method ( full prefix session config cooki config name , set cooki name , 0 ) ; digest . add call method ( full prefix session config cooki config domain , set cooki domain , 0 ) ; digest . add call method ( full prefix session config cooki config path , set cooki path , 0 ) ; digest . add call method ( full prefix session config cooki config comment , set cooki comment , 0 ) ; digest . add call method ( full prefix session config cooki config http onli , set cooki http onli , 0 ) ; digest . add call method ( full prefix session config cooki config secur , set cooki secur , 0 ) ; digest . add call method ( full prefix session config cooki config max ag , set cooki max ag , 0 ) ; digest . add call method ( full prefix session config track mode , add session track mode , 0 ) ; taglib pre servlet 2 . 4 digest . add rule ( full prefix taglib , new taglib locat rule ( fals ) ) ; digest . add call method ( full prefix taglib , add taglib , 2 ) ; digest . add call param ( full prefix taglib taglib locat , 1 ) ; digest . add call param ( full prefix taglib taglib uri , 0 ) ; taglib servlet 2 . 4 onward digest . add rule ( full prefix jsp config taglib , new taglib locat rule ( true ) ) ; digest . add call method ( full prefix jsp config taglib , add taglib , 2 ) ; digest . add call param ( full prefix jsp config taglib taglib locat , 1 ) ; digest . add call param ( full prefix jsp config taglib taglib uri , 0 ) ; digest . add call method ( full prefix welcom file list welcom file , add welcom file , 0 ) ; digest . add call method ( full prefix local encod map list local encod map , add local encod map , 2 ) ; digest . add call param ( full prefix local encod map list local encod map local , 0 ) ; digest . add call param ( full prefix local encod map list local encod map encod , 1 ) ; }	public configur { link context } us store web . xml represent . param context context configur void configur context ( context context ) { far possibl , process alphabet order so easi check everyth present some valid depend correct public id context . set public id ( public id ) ; everyth els order context . set effect major version ( get major version ( ) ) ; context . set effect minor version ( get minor version ( ) ) ; ( entri string , string entri : context param . entri set ( ) ) { context . add paramet ( entri . get kei ( ) , entri . get valu ( ) ) ; } context . set displai name ( displai name ) ; context . set distribut ( distribut ) ; ( context local ejb ejb local ref : ejb local ref . valu ( ) ) { context . get name resourc ( ) . add local ejb ( ejb local ref ) ; } ( context ejb ejb ref : ejb ref . valu ( ) ) { context . get name resourc ( ) . add ejb ( ejb ref ) ; } ( context environ environ : env entri . valu ( ) ) { context . get name resourc ( ) . add environ ( environ ) ; } ( error page error page : error page . valu ( ) ) { context . add error page ( error page ) ; } ( filter def filter : filter . valu ( ) ) { ( filter . get async support ( ) = = null ) { filter . set async support ( fals ) ; } context . add filter def ( filter ) ; } ( filter map filter map : filter map ) { context . add filter map ( filter map ) ; } ( jsp properti group jsp properti group : jsp properti group ) { jsp properti group descriptor descriptor = new applic jsp properti group descriptor ( jsp properti group ) ; context . get jsp config descriptor ( ) . get jsp properti group ( ) . add ( descriptor ) ; } ( string listen : listen ) { context . add applic listen ( listen ) ; } ( entri string , string entri : local encod map . entri set ( ) ) { context . add local encod map paramet ( entri . get kei ( ) , entri . get valu ( ) ) ; } prevent iae ( login config = null ) { context . set login config ( login config ) ; } ( messag destin ref mdr : messag destin ref . valu ( ) ) { context . get name resourc ( ) . add messag destin ref ( mdr ) ; } messag destin were ignor tomcat 6 , so ignor here context . set ignor annot ( metadata complet ) ; ( entri string , string entri : mime map . entri set ( ) ) { context . add mime map ( entri . get kei ( ) , entri . get valu ( ) ) ; } name just us order ( context resourc env ref resourc : resourc env ref . valu ( ) ) { context . get name resourc ( ) . add resourc env ref ( resourc ) ; } ( context resourc resourc : resourc ref . valu ( ) ) { context . get name resourc ( ) . add resourc ( resourc ) ; } ( secur constraint constraint : secur constraint ) { context . add constraint ( constraint ) ; } ( string role : secur role ) { context . add secur role ( role ) ; } ( context servic servic : servic ref . valu ( ) ) { context . get name resourc ( ) . add servic ( servic ) ; } ( servlet def servlet : servlet . valu ( ) ) { wrapper wrapper = context . creat wrapper ( ) ; jsp file get pass jsp servlet init param ( servlet . get load startup ( ) = null ) { wrapper . set load startup ( servlet . get load startup ( ) . int valu ( ) ) ; } ( servlet . get enabl ( ) = null ) { wrapper . set enabl ( servlet . get enabl ( ) . boolean valu ( ) ) ; } wrapper . set name ( servlet . get servlet name ( ) ) ; map string , string param = servlet . get paramet map ( ) ; ( entri string , string entri : param . entri set ( ) ) { wrapper . add init paramet ( entri . get kei ( ) , entri . get valu ( ) ) ; } wrapper . set run ( servlet . get run ( ) ) ; set secur role ref role ref = servlet . get secur role ref ( ) ; ( secur role ref role ref : role ref ) { wrapper . add secur refer ( role ref . get name ( ) , role ref . get link ( ) ) ; } wrapper . set servlet class ( servlet . get servlet class ( ) ) ; multipart def multipartdef = servlet . get multipart def ( ) ; ( multipartdef = null ) { ( multipartdef . get max file size ( ) = null multipartdef . get max request size ( ) = null multipartdef . get file size threshold ( ) = null ) { wrapper . set multipart config element ( new multipart config element ( multipartdef . get locat ( ) , long . pars long ( multipartdef . get max file size ( ) ) , long . pars long ( multipartdef . get max request size ( ) ) , integ . pars int ( multipartdef . get file size threshold ( ) ) ) ) ; } els { wrapper . set multipart config element ( new multipart config element ( multipartdef . get locat ( ) ) ) ; } } ( servlet . get async support ( ) = null ) { wrapper . set async support ( servlet . get async support ( ) . boolean valu ( ) ) ; } wrapper . set overrid ( servlet . overrid ( ) ) ; context . add child ( wrapper ) ; } ( entri string , string entri : servlet map . entri set ( ) ) { context . add servlet map ( entri . get kei ( ) , entri . get valu ( ) ) ; } ( session config = null ) { ( session config . get session timeout ( ) = null ) { context . set session timeout ( session config . get session timeout ( ) . int valu ( ) ) ; } session cooki config scc = context . get servlet context ( ) . get session cooki config ( ) ; scc . set name ( session config . get cooki name ( ) ) ; scc . set domain ( session config . get cooki domain ( ) ) ; scc . set path ( session config . get cooki path ( ) ) ; scc . set comment ( session config . get cooki comment ( ) ) ; ( session config . get cooki http onli ( ) = null ) { scc . set http onli ( session config . get cooki http onli ( ) . boolean valu ( ) ) ; } ( session config . get cooki secur ( ) = null ) { scc . set secur ( session config . get cooki secur ( ) . boolean valu ( ) ) ; } ( session config . get cooki max ag ( ) = null ) { scc . set max ag ( session config . get cooki max ag ( ) . int valu ( ) ) ; } ( session config . get session track mode ( ) . size ( ) 0 ) { context . get servlet context ( ) . set session track mode ( session config . get session track mode ( ) ) ; } } ( entri string , string entri : taglib . entri set ( ) ) { taglib descriptor descriptor = new applic taglib descriptor ( entri . get valu ( ) , entri . get kei ( ) ) ; context . get jsp config descriptor ( ) . get taglib ( ) . add ( descriptor ) ; } context doesn t us version directli ( string welcom file : welcom file ) { follow result welcom file so don t add context welcom file list welcom file welcom file list ( welcom file = null welcom file . length ( ) 0 ) { context . add welcom file ( welcom file ) ; } } do thi last depend servlet ( jsp properti group jsp properti group : jsp properti group ) { string jsp servlet name = context . find servlet map ( . jsp ) ; ( jsp servlet name = = null ) { jsp servlet name = jsp ; } ( context . find child ( jsp servlet name ) = null ) { context . add servlet map ( jsp properti group . get url pattern ( ) , jsp servlet name , true ) ; } els { ( log . debug enabl ( ) ) log . debug ( skipe jsp properti group . get url pattern ( ) , servlet jsp servlet name ) ; } } }	public boolean get trim whitespac ( ) { return trim whitespac ; }	public string get url pattern ( ) { return thi . url pattern ; }
public determin compil necessari check time stamp jsp page correspond . class . java file . page ha depend , check also extend depend , so . thi method can overridden subclass compil . param check class true , check against . class file , fals , check against . java file . boolean out date ( boolean check class ) { ( jsw = null ( ctxt . get option ( ) . get modif test interv ( ) 0 ) ) { ( jsw . get last modif test ( ) ( ctxt . get option ( ) . get modif test interv ( ) 1000 ) system . current time milli ( ) ) { return fals ; } jsw . set last modif test ( system . current time milli ( ) ) ; } long jsp real last modifi = ctxt . get last modifi ( ctxt . get jsp file ( ) ) ; ( jsp real last modifi . long valu ( ) 0 ) { someth went wrong assum modif return true ; } long target last modifi = 0 ; file target file ; ( check class ) { target file = new file ( ctxt . get class file name ( ) ) ; } els { target file = new file ( ctxt . get servlet java file name ( ) ) ; } ( target file . exist ( ) ) { return true ; } target last modifi = target file . last modifi ( ) ; ( check class jsw = null ) { jsw . set servlet class last modifi time ( target last modifi ) ; } ( target last modifi = jsp real last modifi . long valu ( ) ) { ( log . debug enabl ( ) ) { log . debug ( compil : outdat : target file target last modifi ) ; } return true ; } direct ) have been chang . ( jsw = = null ) { return fals ; } map string , long depend = jsw . get depend ( ) ; ( depend = = null ) { return fals ; } iter entri string , long >> = depend . entri set ( ) . iter ( ) ; while ( . ha next ( ) ) { entri string , long includ = . next ( ) ; try { string kei = includ . get kei ( ) ; url includ url ; ( kei . start ( jar : ) ) { includ url = new url ( kei ) ; } els { includ url = ctxt . get resourc ( includ . get kei ( ) ) ; } ( includ url = = null ) { return true ; } urlconnect iuc = includ url . open connect ( ) ; long includ last modifi = 0 ; ( iuc instanceof jar urlconnect ) { includ last modifi = ( ( jar urlconnect ) iuc ) . get jar entri ( ) . get time ( ) ; } els { includ last modifi = iuc . get last modifi ( ) ; } iuc . get input stream ( ) . close ( ) ; ( includ last modifi = includ . get valu ( ) . long valu ( ) ) { return true ; } } catch ( except e ) { ( log . debug enabl ( ) ) log . debug ( problem access resourc . treat outdat . , e ) ; return true ; } } return fals ; }
privat void do dispatch ( servlet request request , servlet respons respons ) throw servlet except , ioexcept { set up handl specifi request respons state state = new state ( request , respons , true ) ; creat wrap respons us thi request wrap respons ( state ) ; applic http request wrequest = ( applic http request ) wrap request ( state ) ; string context path = context . get path ( ) ; ( request uri = null ) wrequest . set attribut ( request dispatch . includ request uri , request uri ) ; ( context path = null ) wrequest . set attribut ( request dispatch . includ context path , context path ) ; ( servlet path = null ) wrequest . set attribut ( request dispatch . includ servlet path , servlet path ) ; ( path info = null ) wrequest . set attribut ( request dispatch . includ path info , path info ) ; ( queri string = null ) { wrequest . set attribut ( request dispatch . includ queri string , queri string ) ; wrequest . set queri param ( queri string ) ; } wrequest . set attribut ( global . dispatch type attr , dispatch type . async ) ; wrequest . set attribut ( global . dispatch request path attr , get combin path ( ) ) ; wrequest . set context path ( context path ) ; wrequest . set request uri ( request uri ) ; wrequest . set servlet path ( servlet path ) ; wrequest . set path info ( path info ) ; ( queri string = null ) { wrequest . set queri string ( queri string ) ; wrequest . set queri param ( queri string ) ; } invok ( state . outer request , state . outer respons , state ) ; }
creat bind new context . creat new context given name bind target context ( name all termin atom compon name ) . all intermedi context target context must alreadi exist . param name name context creat ; mai empti return newli creat context except javax . name . name alreadi bound except name alreadi bound except javax . name . invalid attribut except creation sub context requir specif mandatori attribut except name except name except encount overrid public context creat subcontext ( name name ) throw name except { return get bound context ( ) . creat subcontext ( pars name ( name ) ) ; }	retriev name object . param name name object look up return object bound name except name except name except encount overrid public object lookup ( string name ) throw name except { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( selector context . method us string , lookup , name ) ) ; } execut lookup context return get bound context ( ) . lookup ( pars name ( name ) ) ; }	public read input stream , line time . start offset , read byte arrai , until read certain number byte reach newlin charact , which read arrai well . p thi method return 1 reach end input stream befor read maximum number byte . param b arrai byte which data read param off integ specifi charact which thi method begin read param len integ specifi maximum number byte read return integ specifi actual number byte read , 1 end stream reach except ioexcept input output except ha occur int read line ( byte b , int off , int len ) throw ioexcept { ( len = 0 ) { return 0 ; } int count = 0 , c ; while ( ( c = read ( ) ) = 1 ) { b off = ( byte ) c ; count ; ( c = = n count = = len ) { break ; } } return count 0 count : 1 ; }	bind name object . all intermedi context target context ( name all termin atom compon name ) must alreadi exist . param name name bind ; mai empti param obj object bind ; possibl null except javax . name . name alreadi bound except name alreadi bound except javax . name . invalid attribut except object did suppli all mandatori attribut except name except name except encount overrid public void bind ( name name , object obj ) throw name except { get bound context ( ) . bind ( pars name ( name ) , obj ) ; }	bind name object . param name name bind ; mai empti param obj object bind ; possibl null except javax . name . name alreadi bound except name alreadi bound except javax . name . invalid attribut except object did suppli all mandatori attribut except name except name except encount overrid public void bind ( string name , object obj ) throw name except { get bound context ( ) . bind ( pars name ( name ) , obj ) ; }	destroi name context remov from namespac . param name name context destroi ; mai empti except javax . name name found except intermedi context doe exist except javax . name . context except name bound doe name context , doe name context appropri type overrid public void destroi subcontext ( string name ) throw name except { get bound context ( ) . destroi subcontext ( pars name ( name ) ) ; }	public write code doubl code valu client , follow carriag return line feed ( crlf ) . param d code doubl code valu write client except ioexcept input output except occur void println ( doubl d ) throw ioexcept { print ( d ) ; println ( ) ; }	bind name object , overwrit ani exist bind . all intermedi context target context ( name all termin atom compon name ) must alreadi exist . p object dir context , ani exist attribut associ name ar replac those object . otherwis , ani exist attribut associ name remain unchang . param name name bind ; mai empti param obj object bind ; possibl null except javax . name . invalid attribut except object did suppli all mandatori attribut except name except name except encount overrid public void rebind ( name name , object obj ) throw name except { get bound context ( ) . rebind ( pars name ( name ) , obj ) ; }
privat synchron int write socket ( byte buffer bytebuff , boolean block , boolean flip ) throw ioexcept { ( flip ) { bytebuff . flip ( ) ; flip = true ; } int written = 0 ; nio endpoint . kei attach att = ( nio endpoint . kei attach ) socket . get attach ( fals ) ; ( att = = null ) throw new ioexcept ( kei must cancel ) ; long write timeout = att . get timeout ( ) ; selector selector = null ; try { selector = pool . get ( ) ; } catch ( ioexcept x ) { ignor } try { written = pool . write ( bytebuff , socket , selector , write timeout , block ) ; make sure we ar flush do { ( socket . flush ( true , selector , write timeout ) ) break ; } while ( true ) ; } final { ( selector = null ) pool . put ( selector ) ; } ( block bytebuff . remain ( ) = = 0 ) { block write must empti buffer remain = = 0 we did empti bytebuff . clear ( ) ; flip = fals ; } total = written ; system . out . println ( success write ( written total ) ; return written ; }	send acknowledg . overrid public void send ack ( ) throw ioexcept { ( commit ) { socket . send ( socket , constant . ack byte , 0 , constant . ack byte . length ) 0 socket . get buf handler ( ) . get write buffer ( ) . put ( constant . ack byte , 0 , constant . ack byte . length ) ; write socket ( socket . get buf handler ( ) . get write buffer ( ) , true , true ) ; } }
protect scan web . xml file appli web applic merg them us rule defin spec . global web . xml file , where duplic configur , most specif level win . ie applic s web . xml take preced over host level global web . xml file . void web config ( ) { anyth everyth can overrid global host default . thi implement two part handl web fragment get ad after everyth els so everyth els take prioriti mark servlet overrid so sci configur can replac configur from default rule annot scan ar clear cut might think . tomcat implement follow process : per srv . 1 . 6 . 2 , tomcat scan annot regardless which servlet spec version declar web . xml . eg ha confirm thi expect behaviour . per http : java . net jira brows servlet spec 36 , main web . xml mark metadata complet , jar ar still process sci . tbd . metadata complet = true absolut order specifi , ar jar exclud from order also exclud from sci process current assumpt thei ar . sci ha handl type annot all class ( except those jar exclud from absolut order ) need scan check thei match . set web xml default = new hash set ( ) ; default . add ( get default web xml fragment ( ) ) ; web xml web xml = creat web xml ( ) ; pars context level web . xml input sourc context web xml = get context web xml sourc ( ) ; pars web xml ( context web xml , web xml , fals ) ; servlet context s context = context . get servlet context ( ) ; order import here step 1 . identifi all jar packag applic jar have web fragment . xml pars thi point . map string , web xml fragment = process jar web fragment ( ) ; step 2 . order fragment . set web xml order fragment = null ; order fragment = web xml . order web fragment ( web xml , fragment ) ; step 3 . look servlet contain initi implement ( ok ) { process servlet contain initi ( order fragment ) ; } ( web xml . metadata complet ( ) type initi map . size ( ) 0 ) { step 4 . process web inf class annot ( ok ) { hack requir eclips s serv modul without publish featur sinc thi back web inf class multipl locat rather than . name enumer bind list bind = null ; try { try { list bind = context . get resourc ( ) . list bind ( web inf class ) ; } catch ( name found except ignor ) { safe ignor } while ( list bind = null list bind . ha more element ( ) ) { bind bind = list bind . next element ( ) ; ( bind . get object ( ) instanceof file dir context ) { file web inf class dir = new file ( ( ( file dir context ) bind . get object ( ) ) . get doc base ( ) ) ; process annot file ( web inf class dir , web xml , web xml . metadata complet ( ) ) ; } els { string resourc = web inf class bind . get name ( ) ; try { url url = s context . get resourc ( resourc ) ; process annot url ( url , web xml , web xml . metadata complet ( ) ) ; } catch ( malform urlexcept e ) { log . error ( sm . get string ( context config . webinf class url , resourc ) , e ) ; } } } } catch ( name except e ) { log . error ( sm . get string ( context config . webinf class url , web inf class ) , e ) ; } } those fragment we ar go us ( ok ) { process annot ( order fragment , web xml . metadata complet ( ) ) ; } cach , us , longer requir so clear java class cach . clear ( ) ; } ( web xml . metadata complet ( ) ) { file . ( ok ) { ok = web xml . merg ( order fragment ) ; } step 7 . appli global default have merg default befor jsp convers sinc default provid jsp servlet definit . web xml . merg ( default ) ; step 8 . convert explicitli mention jsp servlet ( ok ) { convert jsp ( web xml ) ; } step 9 . appli merg web . xml context ( ok ) { web xml . configur context ( context ) ; step 9a . make merg web . xml avail other compon , specif jasper , save those compon from have re gener . todo us servlet contain initi jasper string merg web xml = web xml . xml ( ) ; s context . set attribut ( org . apach . tomcat . util . scan . constant . merg web xml , merg web xml ) ; ( context . get log effect web xml ( ) ) { log . info ( web . xml : n merg web xml ) ; } } } els { web xml . merg ( default ) ; web xml . configur context ( context ) ; } step 10 . look static resourc packag jar ( ok ) { spec doe defin order . us order jar follow remain jar set web xml resourc jar = new link hash set ( ) ; ( order fragment = null ) { ( web xml fragment : order fragment ) { resourc jar . add ( fragment ) ; } } ( web xml fragment : fragment . valu ( ) ) { ( resourc jar . contain ( fragment ) ) { resourc jar . add ( fragment ) ; } } process resourc jar ( resourc jar ) ; see also standard context . resourc start ( ) web inf class meta inf resourc configur } context ( ok ) { ( map . entri servlet contain initi , set class >> entri : initi class map . entri set ( ) ) { ( entri . get valu ( ) . empti ( ) ) { context . add servlet contain initi ( entri . get kei ( ) , null ) ; } els { context . add servlet contain initi ( entri . get kei ( ) , entri . get valu ( ) ) ; } } } }	test public void test bug51396 ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; file app dir = new file ( test webapp 3 . 0 fragment ) ; app dir rel server home tomcat . add webapp ( null , test , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; byte chunk bc = new byte chunk ( ) ; int rc = get url ( http : localhost : get port ( ) test bug51396 . jsp , bc , null ) ; assert equal ( http servlet respons . sc ok , rc ) ; assert true ( bc . string ( ) . contain ( p ok p ) ) ; }
void do forward ( string rel url path ) throw servlet except , ioexcept { jsp . 4 . 5 buffer wa flush , throw illeg state except try { out . clear ( ) ; } catch ( ioexcept ex ) { illeg state except = new illeg state except ( local . get messag ( jsp . error . attempt clear flush buffer ) ) ; . init caus ( ex ) ; throw ; } make sure respons object wrapper includ while ( respons instanceof servlet respons wrapper includ ) { respons = ( ( servlet respons wrapper includ ) respons ) . get respons ( ) ; } final string path = get absolut path rel context ( rel url path ) ; string includ uri = ( string ) request . get attribut ( request dispatch . includ servlet path ) ; ( includ uri = null ) request . remov attribut ( request dispatch . includ servlet path ) ; try { context . get request dispatch ( path ) . forward ( request , respons ) ; } final { ( includ uri = null ) request . set attribut ( request dispatch . includ servlet path , includ uri ) ; } }
overrid protect object do lookup ( string name ) { object ret super = super . do lookup ( name ) ; ( ret super = null map resourc path = = null ) { return ret super ; } perform lookup us extra resourc path ( map . entri string , list string >> map : map resourc path . entri set ( ) ) { string path = map . get kei ( ) ; list string dir list = map . get valu ( ) ; ( name . equal ( path ) ) { ( string resourc dir : dir list ) { file f = new file ( resourc dir ) ; ( f . exist ( ) f . can read ( ) ) { ( f . file ( ) ) { return new file resourc ( f ) ; } els { never goe here , f directori super implement alreadi return valu } } } } path = ; ( name . start ( path ) ) { string re = name . substr ( path . length ( ) ) ; ( string resourc dir : dir list ) { file f = new file ( resourc dir re ) ; ( f . exist ( ) f . can read ( ) ) { ( f . file ( ) ) { return new file resourc ( f ) ; } els { never goe here , f directori super implement alreadi return valu } } } } } return ret super ; }
public void set sslverifi depth ( int sslverifi depth ) { ( ( apr endpoint ) endpoint ) . set sslverifi depth ( sslverifi depth ) ; }	public boolean get sslinsecur renegoti ( ) { return sslinsecur renegoti ; }	initi endpoint . overrid public void bind ( ) throw except { creat root apr memori pool try { root pool = pool . creat ( 0 ) ; } catch ( unsatisfi link error e ) { throw new except ( sm . get string ( endpoint . init . notavail ) ) ; } creat pool server socket server sock pool = pool . creat ( root pool ) ; creat apr address bound string address str = null ; ( get address ( ) = null ) { address str = get address ( ) . get host address ( ) ; } int famili = socket . apr inet ; ( librari . apr have ipv6 ) { ( address str = = null ) { ( os . bsd os . win32 os . win64 ) famili = socket . apr unspec ; } els ( address str . index ( : ) = 0 ) { famili = socket . apr unspec ; } } long inet address = address . info ( address str , famili , get port ( ) , 0 , root pool ) ; creat apr server socket server sock = socket . creat ( address . get info ( inet address ) . famili , socket . sock stream , socket . apr proto tcp , root pool ) ; ( os . unix ) { socket . opt set ( server sock , socket . apr so reuseaddr , 1 ) ; } deal firewal tend drop inact socket socket . opt set ( server sock , socket . apr so keepal , 1 ) ; bind server socket int ret = socket . bind ( server sock , inet address ) ; ( ret = 0 ) { throw new except ( sm . get string ( endpoint . init . bind , ret , error . strerror ( ret ) ) ) ; } start listen server socket ret = socket . listen ( server sock , get backlog ( ) ) ; ( ret = 0 ) { throw new except ( sm . get string ( endpoint . init . listen , ret , error . strerror ( ret ) ) ) ; } ( os . win32 os . win64 ) { window set reuseaddr flag after bind listen socket . opt set ( server sock , socket . apr so reuseaddr , 1 ) ; } sendfil usag system which don t support caus major problem ( us sendfil librari . apr ha sendfil ) { us sendfil = fals ; } initi thread count default acceptor , poller sendfil ( acceptor thread count = = 0 ) { fixm : doesn t seem work well multipl accept thread acceptor thread count = 1 ; } ( poller thread count = = 0 ) { ( ( os . win32 os . win64 ) ( get max connect ( ) 1024 ) ) { maximum per poller get reason perform 1024 poller thread count = get max connect ( ) 1024 ; adjust poller size so won t reach limit set max connect ( get max connect ( ) ( get max connect ( ) 1024 ) ) ; } els { explicit poller size limit poller thread count = 1 ; } } ( sendfil thread count = = 0 ) { ( ( os . win32 os . win64 ) ( sendfil size 1024 ) ) { maximum per poller get reason perform 1024 sendfil thread count = sendfil size 1024 ; adjust poller size so won t reach limit sendfil size = sendfil size ( sendfil size 1024 ) ; } els { explicit poller size limit fixm : default per cpu sendfil thread count = 1 ; } } other platform thi call noop return apr enotimpl . ( defer accept ) { ( socket . opt set ( server sock , socket . apr tcp defer accept , 1 ) = = statu . apr enotimpl ) { defer accept = fals ; } } initi ssl need ( sslenabl ( ) ) { ( sslcertif file = = null ) { thi requir throw new except ( sm . get string ( endpoint . apr . ssl cert file ) ) ; } ssl protocol int valu = ssl . ssl protocol none ; ( sslprotocol = = null sslprotocol . length ( ) = = 0 ) { valu = ssl . ssl protocol all ; } els { ( string protocol : sslprotocol . split ( ) ) { protocol = protocol . trim ( ) ; ( sslv2 . equal ignor case ( protocol ) ) { valu = ssl . ssl protocol sslv2 ; } els ( sslv3 . equal ignor case ( protocol ) ) { valu = ssl . ssl protocol sslv3 ; } els ( tlsv1 . equal ignor case ( protocol ) ) { valu = ssl . ssl protocol tlsv1 ; } els ( all . equal ignor case ( protocol ) ) { valu = ssl . ssl protocol all ; } els { requir throw new except ( sm . get string ( endpoint . apr . invalid ssl protocol , sslprotocol ) ) ; } } } creat ssl context ssl context = sslcontext . make ( root pool , valu , ssl . ssl mode server ) ; ( sslinsecur renegoti ) { boolean legaci reneg support = fals ; try { legaci reneg support = ssl . ha op ( ssl . ssl op allow unsaf legaci renegoti ) ; ( legaci reneg support ) sslcontext . set option ( ssl context , ssl . ssl op allow unsaf legaci renegoti ) ; } catch ( unsatisfi link error e ) { ignor } ( legaci reneg support ) { open ssl doe support unsaf legaci renegoti . log . warn ( sm . get string ( endpoint . warn . insecur reneg , ssl . version string ( ) ) ) ; } } list cipher client permit negoti sslcontext . set cipher suit ( ssl context , sslcipher suit ) ; load server kei certif sslcontext . set certif ( ssl context , sslcertif file , sslcertif kei file , sslpassword , ssl . ssl aidx rsa ) ; set certif chain file sslcontext . set certif chain file ( ssl context , sslcertif chain file , fals ) ; support client certif sslcontext . set cacertif ( ssl context , sslcacertif file , sslcacertif path ) ; set revoc sslcontext . set carevoc ( ssl context , sslcarevoc file , sslcarevoc path ) ; client certif verif valu = ssl . ssl cverifi none ; ( option . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi option ; } els ( requir . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi requir ; } els ( option ca . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi option ca ; } sslcontext . set verifi ( ssl context , valu , sslverifi depth ) ; now , sendfil support ssl us sendfil = fals ; } }
protect void do get ( http servlet request req , http servlet respons resp ) throw servlet except , ioexcept { inform requir send server handshak messag string kei ; string sub protocol = null ; list string extens = collect . empti list ( ) ; ( header contain token ( req , upgrad , websocket ) ) { resp . send error ( http servlet respons . sc bad request ) ; return ; } ( header contain token ( req , connect , upgrad ) ) { resp . send error ( http servlet respons . sc bad request ) ; return ; } ( header contain token ( req , sec websocket version , 13 ) ) { resp . set statu ( 426 ) ; resp . set header ( sec web socket version , 13 ) ; return ; } kei = req . get header ( sec web socket kei ) ; ( kei = = null ) { resp . send error ( http servlet respons . sc bad request ) ; return ; } string origin = req . get header ( origin ) ; ( verifi origin ( origin ) ) { resp . send error ( http servlet respons . sc forbidden ) ; return ; } list string sub protocol = get token from header ( req , sec web socket protocol client ) ; ( sub protocol . empti ( ) ) { sub protocol = select sub protocol ( sub protocol ) ; } todo read client handshak sec web socket extens todo extens requir abil specifi someth ( api tbd ) can pass tomcat intern process extens data present when frame fragment . we got thi far , all good . accept connect . resp . set header ( upgrad , websocket ) ; resp . set header ( connect , upgrad ) ; resp . set header ( sec web socket accept , get web socket accept ( kei ) ) ; ( sub protocol = null ) { resp . set header ( sec web socket protocol , sub protocol ) ; } ( extens . empti ( ) ) { todo } ws http servlet request wrapper wrapper = new ws http servlet request wrapper ( req ) ; stream inbound inbound = creat web socket inbound ( sub protocol , wrapper ) ; wrapper . invalid ( ) ; small hack until servlet api provid wai do thi . servlet request inner = req ; unwrap request while ( inner instanceof servlet request wrapper ) { inner = ( ( servlet request wrapper ) inner ) . get request ( ) ; } ( inner instanceof request facad ) { ( ( request facad ) inner ) . do upgrad ( inbound ) ; } els { resp . send error ( http servlet respons . sc intern server error , sm . get string ( servlet . req upgrad fail ) ) ; } }
protect void send ping messag ( member member ) { ( member = = null member . length = = 0 ) return ; gener uniqu id channel data data = new channel data ( true ) ; data . set address ( get local member ( fals ) ) ; data . set timestamp ( system . current time milli ( ) ) ; data . set option ( get option flag ( ) ) ; try { super . send messag ( member , data , null ) ; } catch ( channel except x ) { log . warn ( unabl send tcp ping . , x ) ; } }
protect void send ping ( ) { ( failur detector . get ( ) = null ) { we have refer failur detector piggi back failur detector . get ( ) . check member ( true ) ; } els { static membership interceptor smi = static member . get ( ) ; ( static onli smi = null ) { send ping messag ( smi . get member ( ) ) ; } els { send ping messag ( get member ( ) ) ; } } }
privat set servlet contain initi get sci class ( string class name ) { ( map . entri class , set servlet contain initi >> entri : type initi map . entri set ( ) ) { class clazz = entri . get kei ( ) ; ( clazz . annot ( ) ) { ( clazz . get name ( ) . equal ( class name ) ) { return entri . get valu ( ) ; } } } return collect . empti set ( ) ; }	public long get host time stamp ( ) { return host time stamp ; }	public long get host time stamp ( ) { return host time stamp ; }
remov . . . sequenc from absolut url . code borrow heavili from coyot adapt . normal ( ) void normal ( char chunk cc ) { strip queri string fragment first do thi wai make normal logic lot simpler int truncat = cc . index ( ) ; ( truncat = = 1 ) { truncat = cc . index ( ) ; } char truncat cc = null ; ( truncat 1 ) { truncat cc = arrai . copi rang ( cc . get buffer ( ) , cc . get start ( ) truncat , cc . get end ( ) ) ; cc . set end ( cc . get start ( ) truncat ) ; } ( cc . end ( . ) cc . end ( . . ) ) { try { cc . append ( ) ; } catch ( ioexcept e ) { throw new illeg argument except ( cc . string ( ) , e ) ; } } char c = cc . get char ( ) ; int start = cc . get start ( ) ; int end = cc . get end ( ) ; int index = 0 ; int start index = 0 ; scheme : host : port ( int i = 0 ; i 3 ; i ) { start index = cc . index ( , start index 1 ) ; } remov . index = start index ; while ( true ) { index = cc . index ( . , 0 , 3 , index ) ; ( index 0 ) { break ; } copi char ( c , start index , start index 2 , end start index 2 ) ; end = end 2 ; cc . set end ( end ) ; } remov . . index = start index ; int po ; while ( true ) { index = cc . index ( . . , 0 , 4 , index ) ; ( index 0 ) { break ; } prevent from go outsid our context ( index = = start index ) { throw new illeg argument except ( ) ; } int index2 = 1 ; ( po = start index 1 ; ( po = 0 ) ( index2 0 ) ; po ) { ( c po = = ( byte ) ) { index2 = po ; } } copi char ( c , start index2 , start index 3 , end start index 3 ) ; end = end index2 index 3 ; cc . set end ( end ) ; index = index2 ; } add queri string ( present ) back ( truncat cc = null ) { try { cc . append ( truncat cc , 0 , truncat cc . length ) ; } catch ( ioexcept ioe ) { throw new illeg argument except ( ioe ) ; } } }	encod session identifi associ thi respons specifi url , necessari . param url url encod overrid public string encod url ( string url ) { string absolut = absolut ( url ) ; ( encod ( absolut ) ) { w3c spec clearli said ( url . equal ignor case ( ) ) { url = absolut ; } els ( url . equal ( absolut ) ha path ( url ) ) { url = ; } return ( encod ( url , request . get session intern ( ) . get id intern ( ) ) ) ; } els { return ( url ) ; } }	test public void test bug53062p ( ) throw except { request req = new tester mock request ( ) ; respons resp = new respons ( ) ; resp . set request ( req ) ; string result = resp . absolut ( . . . . . . . ) ; assert . assert equal ( http : localhost : 8080 level1 . . . . , result ) ; }
public perform block read us bytebuff data read code selector code paramet null , perform busi read could take up lot cpu cycl . param buf byte buffer buffer contain data , we read until we have read least byte we time out param socket socket channel socket write data param read timeout long timeout thi read oper millisecond , 1 mean timeout return int return number byte read throw eofexcept read return 1 throw socket timeout except read time out throw ioexcept io except occur underli socket logic int read ( byte buffer buf , nio channel socket , long read timeout ) throw ioexcept { select kei kei = socket . get iochannel ( ) . kei ( socket . get poller ( ) . get selector ( ) ) ; ( kei = = null ) throw new ioexcept ( kei longer regist ) ; kei refer refer = new kei refer ( ) ; kei attach att = ( kei attach ) kei . attach ( ) ; int read = 0 ; boolean timedout = fals ; assum we can read int keycount = 1 ; start timeout timer long time = system . current time milli ( ) ; try { while ( timedout ) { ( keycount 0 ) { onli read we were regist read read = socket . read ( buf ) ; ( read = = 1 ) throw new eofexcept ( ) ; ( read 0 ) break ; } try { ( att . get read latch ( ) = = null att . get read latch ( ) . get count ( ) = = 0 ) att . start read latch ( 1 ) ; poller . add ( att , select kei . op read , refer ) ; ( read timeout 0 ) { att . await read latch ( long . max valu , time unit . millisecond ) ; } els { att . await read latch ( read timeout , time unit . millisecond ) ; } } catch ( interrupt except ignor ) { thread . interrupt ( ) ; } ( att . get read latch ( ) = null att . get read latch ( ) . get count ( ) 0 ) { we got interrupt , we haven t receiv notif from poller . keycount = 0 ; } els { latch countdown ha happen keycount = 1 ; att . reset read latch ( ) ; } ( read timeout = 0 ( keycount = = 0 ) ) timedout = ( system . current time milli ( ) time ) = read timeout ; } while ( timedout ) throw new socket timeout except ( ) ; } final { poller . remov ( att , select kei . op read ) ; ( timedout refer . kei = null ) { poller . cancel kei ( refer . kei ) ; } refer . kei = null ; } return read ; }	public perform block write us bytebuff data written code selector code paramet null , perform busi write could take up lot cpu cycl . param buf byte buffer buffer contain data , we write long code ( buf . ha remain ( ) = = true ) code param socket socket channel socket write data param write timeout long timeout thi write oper millisecond , 1 mean timeout return int return number byte written throw eofexcept write return 1 throw socket timeout except write time out throw ioexcept io except occur underli socket logic int write ( byte buffer buf , nio channel socket , long write timeout ) throw ioexcept { select kei kei = socket . get iochannel ( ) . kei ( socket . get poller ( ) . get selector ( ) ) ; ( kei = = null ) throw new ioexcept ( kei longer regist ) ; kei refer refer = new kei refer ( ) ; kei attach att = ( kei attach ) kei . attach ( ) ; int written = 0 ; boolean timedout = fals ; assum we can write int keycount = 1 ; start timeout timer long time = system . current time milli ( ) ; try { while ( ( timedout ) buf . ha remain ( ) ) { ( keycount 0 ) { onli write we were regist write write data int cnt = socket . write ( buf ) ; ( cnt = = 1 ) throw new eofexcept ( ) ; written = cnt ; ( cnt 0 ) { reset our timeout timer time = system . current time milli ( ) ; we successfulli wrote , try again without selector continu ; } } try { ( att . get write latch ( ) = = null att . get write latch ( ) . get count ( ) = = 0 ) att . start write latch ( 1 ) ; poller . add ( att , select kei . op write , refer ) ; ( write timeout 0 ) { att . await write latch ( long . max valu , time unit . millisecond ) ; } els { att . await write latch ( write timeout , time unit . millisecond ) ; } } catch ( interrupt except ignor ) { thread . interrupt ( ) ; } ( att . get write latch ( ) = null att . get write latch ( ) . get count ( ) 0 ) { we got interrupt , we haven t receiv notif from poller . keycount = 0 ; } els { latch countdown ha happen keycount = 1 ; att . reset write latch ( ) ; } ( write timeout 0 ( keycount = = 0 ) ) timedout = ( system . current time milli ( ) time ) = write timeout ; } while ( timedout ) throw new socket timeout except ( ) ; } final { poller . remov ( att , select kei . op write ) ; ( timedout refer . kei = null ) { poller . cancel kei ( refer . kei ) ; } refer . kei = null ; } return written ; }	public execut given command some time futur . command mai execut new thread , pool thread , call thread , discret tt executor tt implement . thread ar avail , ad work queue . work queue full , system wait specifi time throw reject execut except queue still full after . param command runnabl task throw reject execut except thi task cannot accept execut queue full throw null pointer except command unit null void execut ( runnabl command , long timeout , time unit unit ) { submit count . increment get ( ) ; try { super . execut ( command ) ; } catch ( reject execut except rx ) { ( super . get queue ( ) instanceof task queue ) { final task queue queue = ( task queue ) super . get queue ( ) ; try { ( queue . forc ( command , timeout , unit ) ) { submit count . decrement get ( ) ; throw new reject execut except ( queue capac full . ) ; } } catch ( interrupt except x ) { submit count . decrement get ( ) ; thread . interrupt ( ) ; throw new reject execut except ( x ) ; } } els { submit count . decrement get ( ) ; throw rx ; } } }	overrid public void publish ( log record record ) { ( loggabl ( record ) ) { return ; } log entri entri = new log entri ( record , thi ) ; boolean ad = fals ; try { while ( ad queue . offer ( entri ) ) { switch ( overflow drop type ) { case overflow drop last : { remov last ad element queue . poll last ( ) ; break ; } case overflow drop first : { remov first element queue queue . poll first ( ) ; break ; } case overflow drop flush : { ad = queue . offer ( entri , 1000 , time unit . millisecond ) ; break ; } case overflow drop current : { ad = true ; break ; } } switch } while } catch ( interrupt except x ) { allow thread interrupt back out publish oper after thi we clear flag thread . interrupt ( ) ; } }	overrid public void run ( ) { while ( do run ) { try { thread . sleep ( sleep time ) ; channel . heartbeat ( ) ; } catch ( interrupt except x ) { interrupt ( ) ; } catch ( except x ) { log . error ( unabl send heartbeat through tribe interceptor stack . try sleep again . , x ) ; } catch } while }	public void messag receiv ( channel messag msg ) { catch incom boolean process = true ; ( ok process ( msg . get option ( ) ) ) { check see ping messag , so , process = fals process = ( ( msg . get messag ( ) . get length ( ) = tcp ping data . length ) ( arrai . equal ( tcp ping data , msg . get messag ( ) . get byte ( ) ) ) ) ; } ignor messag , doesnt have flag set ( process ) super . messag receiv ( msg ) ; els ( log . debug enabl ( ) ) log . debug ( receiv tcp ping packet : msg ) ; }	public long get recoveri sleep time ( ) { return recoveri sleep time ; }	overrid public void run ( ) { while ( run ) { try { log entri entri = queue . poll ( logger sleep time , time unit . millisecond ) ; ( entri = null ) entri . flush ( ) ; } catch ( interrupt except x ) { thread . interrupt ( ) ; } catch ( except x ) { x . print stack trace ( ) ; } } while }	public = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = void start elect ( boolean forc ) throw channel except { synchron ( elect mutex ) { member impl local = ( member impl ) get local member ( fals ) ; member impl other = membership . get member ( ) ; fire interceptor event ( new coordin event ( coordin event . evt start elect , thi , elect init ) ) ; ( other . length = = 0 ) { thi . view id = new uniqu id ( uuidgener . random uuid ( fals ) ) ; thi . view = new membership ( local , absolut order . comp , true ) ; thi . handl view conf ( thi . creat elect msg ( local , other , local ) , view ) ; onli member , need elect return ; } ( suggestedview id = null ) { ( view = null arrai . diff ( view , suggest view , local ) . length = = 0 arrai . diff ( suggest view , view , local ) . length = = 0 ) { suggestedview id = null ; suggest view = null ; fire interceptor event ( new coordin event ( coordin event . evt elect abandon , thi , elect abandon , run elect match view ) ) ; } els { fire interceptor event ( new coordin event ( coordin event . evt elect abandon , thi , elect abandon , elect run ) ) ; } elect alreadi run , i m allow have two them return ; } ( view = null arrai . diff ( view , membership , local ) . length = = 0 arrai . diff ( membership , view , local ) . length = = 0 ) { fire interceptor event ( new coordin event ( coordin event . evt elect abandon , thi , elect abandon , view match membership ) ) ; alreadi have thi view instal return ; } int prio = absolut order . comp . compar ( local , other 0 ) ; am i leader my view member impl leader = ( prio 0 ) local : other 0 ; ( local . equal ( leader ) forc ) { coordin messag msg = creat elect msg ( local , other , leader ) ; suggestedview id = msg . get id ( ) ; suggest view = new membership ( local , absolut order . comp , true ) ; arrai . fill ( suggest view , msg . get member ( ) ) ; fire interceptor event ( new coordin event ( coordin event . evt process elect , thi , elect , send request ) ) ; send elect msg ( local , other 0 , msg ) ; } els { try { coord msg receiv . set ( fals ) ; fire interceptor event ( new coordin event ( coordin event . evt wait msg , thi , elect , wait request ) ) ; elect mutex . wait ( wait coord msg timeout ) ; } catch ( interrupt except x ) { thread . interrupt ( ) ; } ( suggestedview id = = null ( coord msg receiv . get ( ) ) ) { messag arriv , send coord msg fire interceptor event ( new coordin event ( coordin event . evt wait msg , thi , elect , wait time out . ) ) ; start elect ( true ) ; fire interceptor event ( new coordin event ( coordin event . evt elect abandon , thi , elect abandon , wait time out . ) ) ; } els { fire interceptor event ( new coordin event ( coordin event . evt elect abandon , thi , elect abandon , receiv messag ) ) ; } } end } }	stop endpoint . thi caus all process thread stop . overrid public void stop intern ( ) { releas connect latch ( ) ; ( paus ) { paus ( ) ; } ( run ) { run = fals ; unlock accept ( ) ; ( abstract endpoint . acceptor acceptor : acceptor ) { long wait left = 10000 ; while ( wait left 0 acceptor . get state ( ) = acceptor state . end server sock = 0 ) { try { thread . sleep ( 50 ) ; } catch ( interrupt except e ) { ignor clean interrupt flag thread . interrupt ( ) ; } wait left = 50 ; } ( wait left = = 0 ) { log . warn ( sm . get string ( endpoint . warn . unlock acceptor fail , acceptor . get thread name ( ) ) ) ; hard socket close . ( server sock = 0 ) { socket . shutdown ( server sock , socket . apr shutdown read ) ; server sock = 0 ; } } } ( int i = 0 ; i poller . length ; i ) { try { poller i . destroi ( ) ; } catch ( except e ) { ignor } } poller = null ; ( int i = 0 ; i comet poller . length ; i ) { try { comet poller i . destroi ( ) ; } catch ( except e ) { ignor } } comet poller = null ; ( us sendfil ) { ( int i = 0 ; i sendfil . length ; i ) { try { sendfil i . destroi ( ) ; } catch ( except e ) { ignor } } sendfil = null ; } } shutdown executor ( ) ; }
protect termin current transact given connect . param con return code true code connect tx termin succeed otherwis code fals code boolean termin transact ( pool connect con ) { try { ( con . get pool properti ( ) . get default auto commit ( ) = = boolean . fals ) { ( thi . get pool properti ( ) . get rollback return ( ) ) { boolean autocommit = con . get connect ( ) . get auto commit ( ) ; ( autocommit ) con . get connect ( ) . rollback ( ) ; } els ( thi . get pool properti ( ) . get commit return ( ) ) { boolean autocommit = con . get connect ( ) . get auto commit ( ) ; ( autocommit ) con . get connect ( ) . commit ( ) ; } } return true ; } catch ( sqlexcept x ) { log . warn ( unabl termin transact , connect close . , x ) ; return fals ; } }

send cluster messag member param msg messag transfer param dest receiv member see org . apach . catalina . ha . catalina cluster send ( org . apach . catalina . ha . cluster messag , org . apach . catalina . tribe . member ) overrid public void send ( cluster messag msg , member dest ) { try { msg . set address ( get local member ( ) ) ; ( dest = null ) { ( get local member ( ) . equal ( dest ) ) { channel . send ( new member { dest } , msg , channel send option ) ; } els log . error ( unabl send messag local member msg ) ; } els { member destmemb = channel . get member ( ) ; ( destmemb . length 0 ) channel . send ( destmemb , msg , channel send option ) ; } } }
suppress warn ( uncheck ) overrid public enumer string get attribut name ( ) { set string name = new hash set string ( ) ; name . add all ( attribut . kei set ( ) ) ; return new multi enumer string ( new enumer { super . get attribut name ( ) , collect . enumer ( name ) } ) ; }	overrid public boolean set init paramet ( string name , string valu ) { ( paramet . contain kei ( name ) ) { return fals ; } paramet . put ( name , valu ) ; return true ; }	remov context attribut specifi name , ani . param name name context attribut remov overrid public void remov attribut ( string name ) { object valu = null ; boolean found = fals ; check read onli attribut ( read onli attribut . contain kei ( name ) ) return ; found = attribut . contain kei ( name ) ; ( found ) { valu = attribut . get ( name ) ; attribut . remov ( name ) ; } els { return ; } notifi interest applic event listen object listen = context . get applic event listen ( ) ; ( ( listen = = null ) ( listen . length = = 0 ) ) return ; servlet context attribut event event = new servlet context attribut event ( context . get servlet context ( ) , name , valu ) ; ( int i = 0 ; i listen . length ; i ) { ( ( listen i instanceof servlet context attribut listen ) ) continu ; servlet context attribut listen listen = ( servlet context attribut listen ) listen i ; try { context . fire contain event ( befor context attribut remov , listen ) ; listen . attribut remov ( event ) ; context . fire contain event ( after context attribut remov , listen ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; context . fire contain event ( after context attribut remov , listen ) ; fixm should we do anyth besid log log ( sm . get string ( applic context . attribut event ) , t ) ; } } }
return extens which mime map ar defin . ar none , zero length arrai return . overrid public string find mime map ( ) { synchron ( mime map ) { string result = new string mime map . size ( ) ; return ( mime map . kei set ( ) . arrai ( result ) ) ; } }	add new mime map , replac ani exist map specifi extens . param extens filenam extens map param mime type correspond mime type overrid public void add mime map ( string extens , string mime type ) { synchron ( mime map ) { mime map . put ( extens , mime type ) ; } fire contain event ( add mime map , extens ) ; }
privat handl http statu code ( correspond messag ) gener while process specifi request produc specifi respons . ani except occur dure gener error report ar log swallow . param request request process param respons respons gener void statu ( request request , respons respons ) { int statu code = respons . get statu ( ) ; handl custom error page thi statu code context context = request . get context ( ) ; ( context = = null ) { return ; } onli look error page when error ( ) set . error ( ) set when respons . send error ( ) invok . thi allow custom error page without reli default from web . xml . ( respons . error ( ) ) { return ; } error page error page = context . find error page ( statu code ) ; ( error page = null ) { respons . set app commit ( fals ) ; request . set attribut ( request dispatch . error statu code , integ . valu ( statu code ) ) ; string messag = respons . get messag ( ) ; ( messag = = null ) { messag = ; } request . set attribut ( request dispatch . error messag , messag ) ; request . set attribut ( applic filter factori . dispatch request path attr , error page . get locat ( ) ) ; request . set attribut ( applic filter factori . dispatch type attr , dispatch type . error ) ; wrapper wrapper = request . get wrapper ( ) ; ( wrapper = null ) { request . set attribut ( request dispatch . error servlet name , wrapper . get name ( ) ) ; } request . set attribut ( request dispatch . error request uri , request . get request uri ( ) ) ; ( custom ( request , respons , error page ) ) { try { respons . flush buffer ( ) ; } catch ( client abort except e ) { ignor } catch ( ioexcept e ) { contain . get logger ( ) . warn ( except process error page , e ) ; } } } }
return url resourc map specifi path . path must begin interpret rel current context root . param path path desir resourc except malform urlexcept path given correct form overrid public url get resourc ( string path ) throw malform urlexcept { ( path = = null path . start ( ) get resourc requir slash ) throw new malform urlexcept ( sm . get string ( applic context . request dispatch . iae , path ) ) ; string norm path = request util . normal ( path ) ; ( norm path = = null ) return ( null ) ; dir context resourc = context . get resourc ( ) ; ( resourc = null ) { string full path = context . get path ( ) norm path ; string host name = context . get parent ( ) . get name ( ) ; try { resourc . lookup ( norm path ) ; uri uri = new uri ( jndi , get jndiuri ( host name , full path ) , null ) ; return new url ( null , uri . string ( ) , new dir context urlstream handler ( resourc ) ) ; } catch ( name except e ) { ignor } catch ( except e ) { unexpect log ( sm . get string ( applic context . lookup . error , path , get context path ( ) ) , e ) ; } } return ( null ) ; }	public void test bug53257 ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; file app dir = new file ( test webapp 3 . 0 ) ; app dir rel server home tomcat . add webapp ( null , test , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; byte chunk re = get url ( http : localhost : get port ( ) test bug53257 index . jsp ) ; string result = re . string ( ) ; string line = result . split ( n ) ; ( string line : line ) { ( line . start ( fail ) ) { assert . fail ( line ) ; } } }
public creat object name connect pool mbean object regist param origin object name data sourc return object name connect pool mbean throw malform object name except object name creat object name ( object name origin ) throw malform object name except { string domain = connect pool . pool jmx domain ; hashtabl string , string properti = origin . get kei properti list ( ) ; string orig domain = origin . get domain ( ) ; properti . put ( type , connect pool ) ; properti . put ( class , thi . get class ( ) . get name ( ) ) ; ( origin . get kei properti ( path ) = null ) { properti . put ( engin , orig domain ) ; } object name name = new object name ( domain , properti ) ; return name ; }
protect void configur name rule ( digest digest ) { ejb local ref digest . add object creat ( full prefix ejb local ref , org . apach . catalina . deploi . context local ejb ) ; digest . add set next ( full prefix ejb local ref , add ejb local ref , org . apach . catalina . deploi . context local ejb ) ; digest . add call method ( full prefix ejb local ref descript , set descript , 0 ) ; digest . add call method ( full prefix ejb local ref ejb link , set link , 0 ) ; digest . add call method ( full prefix ejb local ref ejb ref name , set name , 0 ) ; digest . add call method ( full prefix ejb local ref ejb ref type , set type , 0 ) ; digest . add call method ( full prefix ejb local ref local , set local , 0 ) ; digest . add call method ( full prefix ejb local ref local home , set home , 0 ) ; configur inject rule ( digest , web app ejb local ref ) ; ejb ref digest . add object creat ( full prefix ejb ref , org . apach . catalina . deploi . context ejb ) ; digest . add set next ( full prefix ejb ref , add ejb ref , org . apach . catalina . deploi . context ejb ) ; digest . add call method ( full prefix ejb ref descript , set descript , 0 ) ; digest . add call method ( full prefix ejb ref ejb link , set link , 0 ) ; digest . add call method ( full prefix ejb ref ejb ref name , set name , 0 ) ; digest . add call method ( full prefix ejb ref ejb ref type , set type , 0 ) ; digest . add call method ( full prefix ejb ref home , set home , 0 ) ; digest . add call method ( full prefix ejb ref remot , set remot , 0 ) ; configur inject rule ( digest , web app ejb ref ) ; env entri digest . add object creat ( full prefix env entri , org . apach . catalina . deploi . context environ ) ; digest . add set next ( full prefix env entri , add env entri , org . apach . catalina . deploi . context environ ) ; digest . add call method ( full prefix env entri descript , set descript , 0 ) ; digest . add call method ( full prefix env entri env entri name , set name , 0 ) ; digest . add call method ( full prefix env entri env entri type , set type , 0 ) ; digest . add call method ( full prefix env entri env entri valu , set valu , 0 ) ; configur inject rule ( digest , web app env entri ) ; resourc env ref digest . add object creat ( full prefix resourc env ref , org . apach . catalina . deploi . context resourc env ref ) ; digest . add set next ( full prefix resourc env ref , add resourc env ref , org . apach . catalina . deploi . context resourc env ref ) ; digest . add call method ( full prefix resourc env ref resourc env ref name , set name , 0 ) ; digest . add call method ( full prefix resourc env ref resourc env ref type , set type , 0 ) ; configur inject rule ( digest , web app resourc env ref ) ; messag destin digest . add object creat ( full prefix messag destin , org . apach . catalina . deploi . messag destin ) ; digest . add set next ( full prefix messag destin , add messag destin , org . apach . catalina . deploi . messag destin ) ; digest . add call method ( full prefix messag destin descript , set descript , 0 ) ; digest . add call method ( full prefix messag destin displai name , set displai name , 0 ) ; digest . add call method ( full prefix messag destin icon larg icon , set larg icon , 0 ) ; digest . add call method ( full prefix messag destin icon small icon , set small icon , 0 ) ; digest . add call method ( full prefix messag destin messag destin name , set name , 0 ) ; messag destin ref digest . add object creat ( full prefix messag destin ref , org . apach . catalina . deploi . messag destin ref ) ; digest . add set next ( full prefix messag destin ref , add messag destin ref , org . apach . catalina . deploi . messag destin ref ) ; digest . add call method ( full prefix messag destin ref descript , set descript , 0 ) ; digest . add call method ( full prefix messag destin ref messag destin link , set link , 0 ) ; digest . add call method ( full prefix messag destin ref messag destin ref name , set name , 0 ) ; digest . add call method ( full prefix messag destin ref messag destin type , set type , 0 ) ; digest . add call method ( full prefix messag destin ref messag destin usag , set usag , 0 ) ; configur inject rule ( digest , web app messag destin ref ) ; resourc ref digest . add object creat ( full prefix resourc ref , org . apach . catalina . deploi . context resourc ) ; digest . add set next ( full prefix resourc ref , add resourc ref , org . apach . catalina . deploi . context resourc ) ; digest . add call method ( full prefix resourc ref descript , set descript , 0 ) ; digest . add call method ( full prefix resourc ref re auth , set auth , 0 ) ; digest . add call method ( full prefix resourc ref re ref name , set name , 0 ) ; digest . add call method ( full prefix resourc ref re share scope , set scope , 0 ) ; digest . add call method ( full prefix resourc ref re type , set type , 0 ) ; configur inject rule ( digest , web app resourc ref ) ; servic ref digest . add object creat ( full prefix servic ref , org . apach . catalina . deploi . context servic ) ; digest . add set next ( full prefix servic ref , add servic ref , org . apach . catalina . deploi . context servic ) ; digest . add call method ( full prefix servic ref descript , set descript , 0 ) ; digest . add call method ( full prefix servic ref displai name , set displaynam , 0 ) ; digest . add call method ( full prefix servic ref icon larg icon , set larg icon , 0 ) ; digest . add call method ( full prefix servic ref icon small icon , set small icon , 0 ) ; digest . add call method ( full prefix servic ref servic ref name , set name , 0 ) ; digest . add call method ( full prefix servic ref servic interfac , set interfac , 0 ) ; digest . add call method ( full prefix servic ref servic ref type , set type , 0 ) ; digest . add call method ( full prefix servic ref wsdl file , set wsdlfile , 0 ) ; digest . add call method ( full prefix servic ref jaxrpc map file , set jaxrpcmappingfil , 0 ) ; digest . add rule ( full prefix servic ref servic qname , new servic qname rule ( ) ) ; digest . add rule ( full prefix servic ref port compon ref , new call method multi rule ( add portcompon , 2 , 1 ) ) ; digest . add call param ( full prefix servic ref port compon ref servic endpoint interfac , 0 ) ; digest . add rule ( full prefix servic ref port compon ref port compon link , new call param multi rule ( 1 ) ) ; digest . add object creat ( full prefix servic ref handler , org . apach . catalina . deploi . context handler ) ; digest . add rule ( full prefix servic ref handler , new set next rule ( add handler , org . apach . catalina . deploi . context handler ) ) ; digest . add call method ( full prefix servic ref handler handler name , set name , 0 ) ; digest . add call method ( full prefix servic ref handler handler class , set handlerclass , 0 ) ; digest . add call method ( full prefix servic ref handler init param , set properti , 2 ) ; digest . add call param ( full prefix servic ref handler init param param name , 0 ) ; digest . add call param ( full prefix servic ref handler init param param valu , 1 ) ; digest . add rule ( full prefix servic ref handler soap header , new soap header rule ( ) ) ; digest . add call method ( full prefix servic ref handler soap role , add soap role , 0 ) ; digest . add call method ( full prefix servic ref handler port name , add port name , 0 ) ; configur inject rule ( digest , web app servic ref ) ; }	test public void test bug52830 ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; tomcat . enabl name ( ) ; must have real doc base just us temp standard context ctx = ( standard context ) tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; creat resourc context environ env = new context environ ( ) ; env . set name ( boolean ) ; env . set type ( boolean . class . get name ( ) ) ; env . set valu ( true ) ; ctx . get name resourc ( ) . add environ ( env ) ; map test servlet bug52830servlet bug52830servlet = new bug52830servlet ( ) ; tomcat . add servlet ( ctx , bug52830servlet , bug52830servlet ) ; ctx . add servlet map ( , bug52830servlet ) ; tomcat . start ( ) ; byte chunk bc = new byte chunk ( ) ; int rc = get url ( http : localhost : get port ( ) , bc , null ) ; assert equal ( 200 , rc ) ; assert true ( bc . string ( ) . contain ( truetru ) ) ; }	overrid public void begin ( string namespac , string name , attribut attribut ) throw except { ( login config set ) { throw new illeg argument except ( login config element limit 1 occurr ) ; } login config set = true ; }
page context intern get page context ( servlet servlet , servlet request request , servlet respons respons , string error page url , boolean need session , int buffer size , boolean autoflush ) { try { page context pc ; ( us pool ) { page context pool pool = local pool . get ( ) ; ( pool = = null ) { pool = new page context pool ( ) ; local pool . set ( pool ) ; } pc = pool . get ( ) ; ( pc = = null ) { pc = new page context impl ( ) ; } } els { pc = new page context impl ( ) ; } pc . initi ( servlet , request , respons , error page url , need session , buffer size , autoflush ) ; return pc ; } catch ( throwabl ex ) { except util . handl throwabl ( ex ) ; log . fatal ( except initi page context , ex ) ; return null ; } }	privat gener end part static portion servlet . void gener postambl ( ) { out . pop indent ( ) ; out . printil ( } catch ( java . lang . throwabl t ) { ) ; out . push indent ( ) ; out . printil ( ( ( t instanceof javax . servlet . jsp . skip page except ) ) { ) ; out . push indent ( ) ; out . printil ( out = jspx out ; ) ; out . printil ( ( out = null out . get buffer size ( ) = 0 ) ) ; out . push indent ( ) ; out . printil ( try { out . clear buffer ( ) ; } catch ( java . io . ioexcept e ) { } ) ; out . pop indent ( ) ; out . printil ( ( jspx page context = null ) jspx page context . handl page except ( t ) ; ) ; out . printil ( els log ( t . get messag ( ) , t ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; out . pop indent ( ) ; out . printil ( } final { ) ; out . push indent ( ) ; out . printil ( jspx factori . releas page context ( jspx page context ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; close servic method out . pop indent ( ) ; out . printil ( } ) ; gener method , helper class , etc . gen common postambl ( ) ; }
protect void deregist jmx ( ) { try { ( mbean . remov ( pool name ) = null ) { object name onam = get object name ( get class ( ) , pool name ) ; manag factori . get platform mbean server ( ) . unregist mbean ( onam ) ; } } catch ( mbean registr except e ) { log . debug ( jmx deregistr fail . , e ) ; } catch ( instanc found except e ) { log . debug ( jmx deregistr fail . , e ) ; } catch ( malform object name except e ) { log . warn ( jmx deregistr fail . , e ) ; } catch ( runtim oper except e ) { log . warn ( jmx deregistr fail . , e ) ; } }	public creat object name connect pool mbean object regist param origin object name data sourc return object name connect pool mbean throw malform object name except object name creat object name ( object name origin ) throw malform object name except { string domain = tomcat . jdbc ; hashtabl string , string properti = origin . get kei properti list ( ) ; string orig domain = origin . get domain ( ) ; properti . put ( type , connect pool ) ; properti . put ( class , thi . get class ( ) . get name ( ) ) ; ( origin . get kei properti ( path ) = null ) { properti . put ( engin , orig domain ) ; } object name name = new object name ( domain , properti ) ; return name ; }	public void test slow sql jmx ( ) throw except { int count = 1 ; thi . init ( ) ; thi . datasourc . set max activ ( 1 ) ; thi . datasourc . set jdbc interceptor ( slow queri report jmx . class . get name ( ) ( threshold = 50 , notifi pool = fals ) ) ; connect con = thi . datasourc . get connect ( ) ; string slow sql = select count ( 1 ) from test where val1 like ewq eq ; ( int i = 0 ; i count ; i ) { statement st = con . creat statement ( ) ; result set rs = st . execut queri ( slow sql ) ; rs . close ( ) ; st . close ( ) ; } map string , slow queri report . queri stat map = slow queri report . get pool stat ( datasourc . get pool ( ) . get name ( ) ) ; assert null ( map ) ; assert equal ( 1 , map . size ( ) ) ; string kei = map . kei set ( ) . iter ( ) . next ( ) ; slow queri report . queri stat stat = map . get ( kei ) ; system . out . println ( stat : stat ) ; client listen listen = new client listen ( ) ; connect pool pool = datasourc . get pool ( ) ; manag factori . get platform mbean server ( ) . add notif listen ( slow queri report jmx . get object name ( slow queri report jmx . class , pool . get name ( ) ) , listen , null , null ) ; ( int i = 0 ; i count ; i ) { prepar statement st = con . prepar statement ( slow sql ) ; result set rs = st . execut queri ( ) ; rs . close ( ) ; st . close ( ) ; } system . out . println ( stat : stat ) ; ( int i = 0 ; i count ; i ) { callabl statement st = con . prepar call ( slow sql ) ; result set rs = st . execut queri ( ) ; rs . close ( ) ; st . close ( ) ; } system . out . println ( stat : stat ) ; assert equal ( expect have receiv ( 2 count ) notif . , 2 count , listen . notif count ) ; con . close ( ) ; tear down ( ) ; make sure we actual did clean up when pool close assert null ( slow queri report . get pool stat ( pool . get name ( ) ) ) ; }
overrid protect void init intern ( ) throw lifecycl except { super . init intern ( ) ; initi adapt adapt = new coyot adapt ( thi ) ; protocol handler . set adapt ( adapt ) ; make sure pars bodi method set ha default ( null = = pars bodi method set ) { set pars bodi method ( get pars bodi method ( ) ) ; } try { protocol handler . init ( ) ; } catch ( except e ) { throw new lifecycl except ( sm . get string ( coyot connector . protocol handler initi fail ) , e ) ; } initi mapper listen mapper listen . init ( ) ; }	properti ar pass through end point overrid public executor get executor ( ) { return endpoint . get executor ( ) ; }
privat method read ( elcontext ctx ) { ( thi . read = = null ) { thi . read = get method ( thi . owner , descriptor . get read method ( ) ) ; ( thi . read = = null ) { throw new properti found except ( messag ( ctx , properti readabl , new object { type . get name ( ) , descriptor . get name ( ) } ) ) ; } } return thi . read ; }	privat method write ( elcontext ctx ) { ( thi . write = = null ) { thi . write = get method ( thi . owner , descriptor . get write method ( ) ) ; ( thi . write = = null ) { throw new properti found except ( messag ( ctx , properti writabl , new object { type . get name ( ) , descriptor . get name ( ) } ) ) ; } } return thi . write ; }
return set contain listen associ thi contain . thi contain ha regist contain listen , zero length arrai return . overrid public contain listen find contain listen ( ) { lock read = listen lock . read lock ( ) ; read . lock ( ) ; try { contain listen result = new contain listen listen . size ( ) ; return listen . arrai ( result ) ; } final { read . unlock ( ) ; } }	public void run ( ) { add child intern ( child ) ; return null ; }	add contain event listen thi compon . param listen listen add overrid public void add contain listen ( contain listen listen ) { lock write = listen lock . write lock ( ) ; write . lock ( ) ; try { listen . add ( listen ) ; } final { write . unlock ( ) ; } }	notifi all contain event listen particular event ha occur thi contain . default implement perform thi notif synchron us call thread . param type event type param data event data overrid public void fire contain event ( string type , object data ) { implement note ar two option here . 1 ) take copi listen fire event outsid read lock 2 ) don t take copi fire event insid read lock approach 2 ha been us here sinc hold read lock onli prevent write prefer creat lot arrai object . sinc write occur start stop ( unless extern manag tool us ) hold read lock rel long time should issu . lock read = listen lock . read lock ( ) ; read . lock ( ) ; try { ( listen . size ( ) 1 ) return ; contain event event = new contain event ( thi , type , data ) ; ( contain listen listen : listen ) { listen . contain event ( event ) ; } } final { read . unlock ( ) ; } }	remov contain event listen from thi compon . param listen listen remov overrid public void remov contain listen ( contain listen listen ) { lock write = listen lock . write lock ( ) ; write . lock ( ) ; try { listen . remov ( listen ) ; } final { write . unlock ( ) ; } }
process pipelin http request us specifi input output stream . throw ioexcept error dure i o oper overrid public socket state event ( socket statu statu ) throw ioexcept { request info rp = request . get request processor ( ) ; try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; error = adapt . event ( request , respons , statu ) ; } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( sm . get string ( http11processor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } rp . set stage ( org . apach . coyot . constant . stage end ) ; ( error ) { return socket state . close ; } els ( comet ) { input buffer . next request ( ) ; output buffer . next request ( ) ; return socket state . open ; } els { return socket state . long ; } }	process pipelin http request us specifi input output stream . throw ioexcept error dure i o oper overrid public socket state event ( socket statu statu ) throw ioexcept { long so timeout = endpoint . get so timeout ( ) ; request info rp = request . get request processor ( ) ; final nio endpoint . kei attach attach = ( nio endpoint . kei attach ) socket . get socket ( ) . get attach ( fals ) ; try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; error = adapt . event ( request , respons , statu ) ; ( error ) { ( attach = null ) { attach . set comet ( comet ) ; ( comet ) { integ comettimeout = ( integ ) request . get attribut ( org . apach . coyot . constant . comet timeout attr ) ; ( comettimeout = null ) { attach . set timeout ( comettimeout . long valu ( ) ) ; } } els { reset timeout ( keep aliv ) { attach . set timeout ( keep aliv timeout ) ; } els { attach . set timeout ( so timeout ) ; } } } } } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( sm . get string ( http11processor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } rp . set stage ( org . apach . coyot . constant . stage end ) ; ( error ) { return socket state . close ; } els ( comet ) { ( keep aliv ) { input buffer . next request ( ) ; output buffer . next request ( ) ; return socket state . open ; } els { return socket state . close ; } } els { return socket state . long ; } }
public boolean valid ( request request , string author ) { valid author credenti format ( author = = null ) { return fals ; } ( author . start ( digest ) ) { return fals ; } author = author . substr ( 7 ) . trim ( ) ; bugzilla 37132 : http : issu . apach . org bugzilla show bug . cgi id = 37132 string token = author . split ( , ( = ( : ) ) ) ; method = request . get method ( ) ; string opaqu = null ; ( int i = 0 ; i token . length ; i ) { string current token = token i ; ( current token . length ( ) = = 0 ) { continu ; } int equal sign = current token . index ( = ) ; ( equal sign 0 ) { return fals ; } string current token name = current token . substr ( 0 , equal sign ) . trim ( ) ; string current token valu = current token . substr ( equal sign 1 ) . trim ( ) ; ( usernam . equal ( current token name ) ) { user name = remov quot ( current token valu ) ; } ( realm . equal ( current token name ) ) { realm name = remov quot ( current token valu , true ) ; } ( nonc . equal ( current token name ) ) { nonc = remov quot ( current token valu ) ; } ( nc . equal ( current token name ) ) { nc = remov quot ( current token valu ) ; } ( cnonc . equal ( current token name ) ) { cnonc = remov quot ( current token valu ) ; } ( qop . equal ( current token name ) ) { qop = remov quot ( current token valu ) ; } ( uri . equal ( current token name ) ) { uri = remov quot ( current token valu ) ; } ( respons . equal ( current token name ) ) { respons = remov quot ( current token valu ) ; } ( opaqu . equal ( current token name ) ) { opaqu = remov quot ( current token valu ) ; } } ( ( user name = = null ) ( realm name = = null ) ( nonc = = null ) ( uri = = null ) ( respons = = null ) ) { return fals ; } valid uri should match request line sent client ( valid uri ) { string uri queri ; string queri = request . get queri string ( ) ; ( queri = = null ) { uri queri = request . get request uri ( ) ; } els { uri queri = request . get request uri ( ) queri ; } ( uri . equal ( uri queri ) ) { return fals ; } } valid realm name string lc realm = get realm name ( request . get context ( ) ) ; ( lc realm . equal ( realm name ) ) { return fals ; } valid opaqu string ( thi . opaqu . equal ( opaqu ) ) { return fals ; } valid nonc int i = nonc . index ( : ) ; ( i 0 ( i 1 ) = = nonc . length ( ) ) { return fals ; } long nonc time ; try { nonc time = long . pars long ( nonc . substr ( 0 , i ) ) ; } catch ( number format except nfe ) { return fals ; } string md5client ip time kei = nonc . substr ( i 1 ) ; long current time = system . current time milli ( ) ; ( ( current time nonc time ) nonc valid ) { nonc stale = true ; return fals ; } string server ip time kei = request . get remot addr ( ) : nonc time : kei ; byte buffer = null ; synchron ( md5helper ) { buffer = md5helper . digest ( server ip time kei . get byte ( b2cconvert . iso 8859 1 ) ) ; } string md5server ip time kei = md5encod . encod ( buffer ) ; ( md5server ip time kei . equal ( md5client ip time kei ) ) { return fals ; } valid qop ( qop = null qop . equal ( qop ) ) { return fals ; } check presenc nc nonc consist presenc qop ( qop = = null ) { ( cnonc = null nc = null ) { return fals ; } } els { ( cnonc = = null nc = = null ) { return fals ; } ( nc . length ( ) = 8 ) { return fals ; } long count ; try { count = long . pars long ( nc , 16 ) ; } catch ( number format except nfe ) { return fals ; } nonc info info ; synchron ( cnonc ) { info = cnonc . get ( cnonc ) ; } ( info = = null ) { info = new nonc info ( ) ; } els { ( count = info . get count ( ) ) { return fals ; } } info . set count ( count ) ; info . set timestamp ( current time ) ; synchron ( cnonc ) { cnonc . put ( cnonc , info ) ; } } return true ; }
protect scan jar servlet contain initi implement . implement ad web fragment . xml prioriti order . void process servlet contain initi ( set web xml fragment ) { ( web xml fragment : fragment ) { url url = fragment . get url ( ) ; jar jar = null ; input stream = null ; servlet contain initi sci = null ; try { ( jar . equal ( url . get protocol ( ) ) ) { jar = jar factori . new instanc ( url ) ; = jar . get input stream ( sci locat ) ; } els ( file . equal ( url . get protocol ( ) ) ) { string path = url . get path ( ) ; file file = new file ( path , sci locat ) ; ( file . exist ( ) ) { = new file input stream ( file ) ; } } ( = null ) { sci = get servlet contain initi ( ) ; } } catch ( ioexcept ioe ) { log . error ( sm . get string ( context config . servlet contain initi fail , url , context . get name ( ) ) ) ; ok = fals ; return ; } final { ( = null ) { try { . close ( ) ; } catch ( ioexcept e ) { ignor } } ( jar = null ) { jar . close ( ) ; } } ( sci = = null ) { continu ; } initi class map . put ( sci , new hash set class >> ( ) ) ; handl type ht = sci . get class ( ) . get annot ( handl type . class ) ; ( ht = null ) { class type = ht . valu ( ) ; ( type = null ) { ( class type : type ) { ( type . annot ( ) ) { handl type annot = true ; } els { handl type non annot = true ; } set servlet contain initi sci = type initi map . get ( type ) ; ( sci = = null ) { sci = new hash set servlet contain initi ( ) ; type initi map . put ( type , sci ) ; } sci . add ( sci ) ; } } } } }
protect static write processor state . void write processor state ( print writer writer , object name p name , mbean server m bean server , int mode ) throw except { integ stage valu = ( integ ) m bean server . get attribut ( p name , stage ) ; int stage = stage valu . int valu ( ) ; boolean full statu = true ; boolean show request = true ; string stage str = null ; switch ( stage ) { case ( 1 ) : stage str = p ; full statu = fals ; break ; case ( 2 ) : stage str = p ; full statu = fals ; break ; case ( 3 ) : stage str = s ; break ; case ( 4 ) : stage str = f ; break ; case ( 5 ) : stage str = f ; break ; case ( 7 ) : stage str = r ; full statu = fals ; break ; case ( 6 ) : stage str = k ; full statu = true ; show request = fals ; break ; case ( 0 ) : stage str = r ; full statu = fals ; break ; default : unknown stage stage str = ; full statu = fals ; } ( mode = = 0 ) { writer . write ( td strong ) ; writer . write ( stage str ) ; writer . write ( strong td ) ; ( full statu ) { writer . write ( td ) ; writer . print ( format time ( m bean server . get attribut ( p name , request process time ) , fals ) ) ; writer . write ( td ) ; writer . write ( td ) ; ( show request ) { writer . print ( format size ( m bean server . get attribut ( p name , request byte sent ) , fals ) ) ; } els { writer . write ( ) ; } writer . write ( td ) ; writer . write ( td ) ; ( show request ) { writer . print ( format size ( m bean server . get attribut ( p name , request byte receiv ) , fals ) ) ; } els { writer . write ( ) ; } writer . write ( td ) ; writer . write ( td ) ; writer . print ( filter ( m bean server . get attribut ( p name , remot addr ) ) ) ; writer . write ( td ) ; writer . write ( td nowrap ) ; writer . write ( filter ( m bean server . get attribut ( p name , virtual host ) ) ) ; writer . write ( td ) ; writer . write ( td nowrap ) ; ( show request ) { writer . write ( filter ( m bean server . get attribut ( p name , method ) ) ) ; writer . write ( ) ; writer . write ( filter ( m bean server . get attribut ( p name , current uri ) ) ) ; string queri string = ( string ) m bean server . get attribut ( p name , current queri string ) ; ( ( queri string = null ) ( queri string . equal ( ) ) ) { writer . write ( ) ; writer . print ( request util . filter ( queri string ) ) ; } writer . write ( ) ; writer . write ( filter ( m bean server . get attribut ( p name , protocol ) ) ) ; } els { writer . write ( ) ; } writer . write ( td ) ; } els { writer . write ( td td td td td td td td td td td td ) ; } } els ( mode = = 1 ) { writer . write ( worker ) ; writer . write ( stage = stage str ) ; ( full statu ) { writer . write ( request process time = m bean server . get attribut ( p name , request process time ) ) ; writer . write ( request byte sent = ) ; ( show request ) { writer . write ( m bean server . get attribut ( p name , request byte sent ) ) ; } els { writer . write ( 0 ) ; } writer . write ( ) ; writer . write ( request byte receiv = ) ; ( show request ) { writer . write ( m bean server . get attribut ( p name , request byte receiv ) ) ; } els { writer . write ( 0 ) ; } writer . write ( ) ; writer . write ( remot addr = filter ( m bean server . get attribut ( p name , remot addr ) ) ) ; writer . write ( virtual host = filter ( m bean server . get attribut ( p name , virtual host ) ) ) ; ( show request ) { writer . write ( method = filter ( m bean server . get attribut ( p name , method ) ) ) ; writer . write ( current uri = filter ( m bean server . get attribut ( p name , current uri ) ) ) ; string queri string = ( string ) m bean server . get attribut ( p name , current queri string ) ; ( ( queri string = null ) ( queri string . equal ( ) ) ) { writer . write ( current queri string = request util . filter ( queri string ) ) ; } els { writer . write ( current queri string = 63 ; ) ; } writer . write ( protocol = filter ( m bean server . get attribut ( p name , protocol ) ) ) ; } els { writer . write ( method = 63 ; ) ; writer . write ( current uri = 63 ; ) ; writer . write ( current queri string = 63 ; ) ; writer . write ( protocol = 63 ; ) ; } } els { writer . write ( request process time = 0 ) ; writer . write ( request byte sent = 0 ) ; writer . write ( request byte reciev = 0 ) ; writer . write ( remot addr = 63 ; ) ; writer . write ( virtual host = 63 ; ) ; writer . write ( method = 63 ; ) ; writer . write ( current uri = 63 ; ) ; writer . write ( current queri string = 63 ; ) ; writer . write ( protocol = 63 ; ) ; } writer . write ( ) ; } }
overrid public void call ( ) throw lifecycl except { child . start ( ) ; return null ; }
public static pool configur pars pool properti ( properti properti ) { pool configur pool properti = new pool properti ( ) ; string valu = null ; valu = properti . get properti ( prop defaultautocommit ) ; ( valu = null ) { pool properti . set default auto commit ( boolean . valu ( valu ) ) ; } valu = properti . get properti ( prop defaultreadonli ) ; ( valu = null ) { pool properti . set default read onli ( boolean . valu ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { int level = unknown transactionisol ; ( none . equal ignor case ( valu ) ) { level = connect . transact none ; } els ( read commit . equal ignor case ( valu ) ) { level = connect . transact read commit ; } els ( read uncommit . equal ignor case ( valu ) ) { level = connect . transact read uncommit ; } els ( repeat read . equal ignor case ( valu ) ) { level = connect . transact repeat read ; } els ( serializ . equal ignor case ( valu ) ) { level = connect . transact serializ ; } els { try { level = integ . pars int ( valu ) ; } catch ( number format except e ) { system . err . println ( could pars default transact isol : valu ) ; system . err . println ( warn : default transact isol set ) ; system . err . println ( us default valu databas driver ) ; level = unknown transactionisol ; } } pool properti . set default transact isol ( level ) ; } valu = properti . get properti ( prop defaultcatalog ) ; ( valu = null ) { pool properti . set default catalog ( valu ) ; } valu = properti . get properti ( prop driverclassnam ) ; ( valu = null ) { pool properti . set driver class name ( valu ) ; } valu = properti . get properti ( prop maxact ) ; ( valu = null ) { pool properti . set max activ ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop maxidl ) ; ( valu = null ) { pool properti . set max idl ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop minidl ) ; ( valu = null ) { pool properti . set min idl ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop initials ) ; ( valu = null ) { pool properti . set initi size ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop maxwait ) ; ( valu = null ) { pool properti . set max wait ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop testonborrow ) ; ( valu = null ) { pool properti . set test borrow ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop testonreturn ) ; ( valu = null ) { pool properti . set test return ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop testonconnect ) ; ( valu = null ) { pool properti . set test connect ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set time between evict run milli ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set num test per evict run ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set min evict idl time milli ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop testwhileidl ) ; ( valu = null ) { pool properti . set test while idl ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop password ) ; ( valu = null ) { pool properti . set password ( valu ) ; } valu = properti . get properti ( prop url ) ; ( valu = null ) { pool properti . set url ( valu ) ; } valu = properti . get properti ( prop usernam ) ; ( valu = null ) { pool properti . set usernam ( valu ) ; } valu = properti . get properti ( prop validationqueri ) ; ( valu = null ) { pool properti . set valid queri ( valu ) ; } valu = properti . get properti ( prop valid class name ) ; ( valu = null ) { pool properti . set valid class name ( valu ) ; } valu = properti . get properti ( prop validationinterv ) ; ( valu = null ) { pool properti . set valid interv ( long . pars long ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set access underli connect allow ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop removeabandon ) ; ( valu = null ) { pool properti . set remov abandon ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set remov abandon timeout ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop logabandon ) ; ( valu = null ) { pool properti . set log abandon ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop poolpreparedstat ) ; ( valu = null ) { log . warn ( prop poolpreparedstat valid set , have effect . ) ; } valu = properti . get properti ( prop maxopenpreparedstat ) ; ( valu = null ) { log . warn ( prop maxopenpreparedstat valid set , have effect . ) ; } valu = properti . get properti ( prop connectionproperti ) ; ( valu = null ) { properti p = get properti ( valu ) ; pool properti . set db properti ( p ) ; } els { pool properti . set db properti ( new properti ( ) ) ; } ( pool properti . get usernam ( ) = null ) { pool properti . get db properti ( ) . set properti ( user , pool properti . get usernam ( ) ) ; } ( pool properti . get password ( ) = null ) { pool properti . get db properti ( ) . set properti ( password , pool properti . get password ( ) ) ; } valu = properti . get properti ( prop initsql ) ; ( valu = null ) { pool properti . set init sql ( valu ) ; } valu = properti . get properti ( prop interceptor ) ; ( valu = null ) { pool properti . set jdbc interceptor ( valu ) ; } valu = properti . get properti ( prop jmx enabl ) ; ( valu = null ) { pool properti . set jmx enabl ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop fair queue ) ; ( valu = null ) { pool properti . set fair queue ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop us equal ) ; ( valu = null ) { pool properti . set us equal ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( object name ) ; ( valu = null ) { pool properti . set name ( object name . quot ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set abandon when percentag full ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop maxag ) ; ( valu = null ) { pool properti . set max ag ( long . pars long ( valu ) ) ; } valu = properti . get properti ( prop us con lock ) ; ( valu = null ) { pool properti . set us lock ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop datasourc ) ; ( valu = null ) { thi should never happen throw new illeg argument except ( can t set data sourc properti string , thi must javax . sql . data sourc object . ) ; } valu = properti . get properti ( prop datasourc jndi ) ; ( valu = null ) { pool properti . set data sourc jndi ( valu ) ; } valu = properti . get properti ( prop suspect timeout ) ; ( valu = null ) { pool properti . set suspect timeout ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop altern usernam allow ) ; ( valu = null ) { pool properti . set altern usernam allow ( boolean . pars boolean ( valu ) ) ; } return pool properti ; }
public void do test lookup ( boolean us singleton resourc ) throw except { tomcat tomcat = get tomcat instanc ( ) ; tomcat . enabl name ( ) ; must have real doc base just us temp standard context ctx = ( standard context ) tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; creat resourc context resourc cr = new context resourc ( ) ; cr . set name ( list foo ) ; cr . set type ( org . apach . name . resourc . tester object ) ; cr . set properti ( factori , org . apach . name . resourc . tester factori ) ; cr . set singleton ( us singleton resourc ) ; ctx . get name resourc ( ) . add resourc ( cr ) ; map test servlet bug49994servlet bug49994servlet = new bug49994servlet ( ) ; tomcat . add servlet ( ctx , bug49994servlet , bug49994servlet ) ; ctx . add servlet map ( , bug49994servlet ) ; tomcat . start ( ) ; byte chunk bc = get url ( http : localhost : get port ( ) ) ; string expect ; ( us singleton resourc ) { expect = equal ; } els { expect = notequ ; } assert equal ( expect , bc . string ( ) ) ; }	public set current alia configur from string . string should form alia path1 = doc base1 , alia path2 = doc base2 where alia path n must includ lead doc base n must absolut path either . war file directori . ani call thi method replac current set alias . void set alias ( string alias ) { overwrit whatev current set alias . clear ( ) ; ( alias = = null alias . length ( ) = = 0 ) return ; string kvp = alias . split ( , ) ; ( string kvp : kvp ) { string kv = kvp . split ( = ) ; ( kv . length = 2 kv 0 . length ( ) = = 0 kv 1 . length ( ) = = 0 ) throw new illeg argument except ( sm . get string ( resourc . invalid alia map , kvp ) ) ; ( kv 0 . equal ( ) ) { throw new illeg argument except ( sm . get string ( resourc . invalid alia allow , kv 0 ) ) ; } file alia loc = new file ( kv 1 ) ; ( alia loc . exist ( ) ) { throw new illeg argument except ( sm . get string ( resourc . invalid alia exist , kv 1 ) ) ; } base dir context context ; ( kv 1 . end ( . war ) ( alia loc . directori ( ) ) ) { context = new wardir context ( ) ; } els ( alia loc . directori ( ) ) { context = new file dir context ( ) ; } els { throw new illeg argument except ( sm . get string ( resourc . invalid alia file , kv 1 ) ) ; } context . set doc base ( kv 1 ) ; add alia ( kv 0 , context ) ; } }
protect valid configur previous idl connect param now timestamp param con connect valid configur return con throw sqlexcept valid error happen pool connect borrow connect ( long now , pool connect con , string usernam , string password ) throw sqlexcept { we have connect , let set up flag see we need nullifi boolean set null = fals ; try { con . lock ( ) ; boolean usercheck = con . check user ( usernam , password ) ; ( con . releas ( ) ) { return null ; } ( con . discard ( ) con . initi ( ) ) { attempt connect con . connect ( ) ; } ( usercheck ) { ( ( con . discard ( ) ) con . valid ( pool connect . valid borrow ) ) { set timestamp con . set timestamp ( now ) ; ( get pool properti ( ) . log abandon ( ) ) { set stack trace thi pool con . set stack trace ( get thread dump ( ) ) ; } ( busi . offer ( con ) ) { log . debug ( connect doesn t fit busi arrai , connect traceabl . ) ; } return con ; } } connect shouldn t have poll again . try { con . reconnect ( ) ; ( con . valid ( pool connect . valid init ) ) { set timestamp con . set timestamp ( now ) ; ( get pool properti ( ) . log abandon ( ) ) { set stack trace thi pool con . set stack trace ( get thread dump ( ) ) ; } ( busi . offer ( con ) ) { log . debug ( connect doesn t fit busi arrai , connect traceabl . ) ; } return con ; } els { valid fail . releas ( con ) ; set null = true ; throw new sqlexcept ( fail valid newli establish connect . ) ; } } catch ( except x ) { releas ( con ) ; set null = true ; ( x instanceof sqlexcept ) { throw ( sqlexcept ) x ; } els { sqlexcept ex = new sqlexcept ( x . get messag ( ) ) ; ex . init caus ( x ) ; throw ex ; } } } final { con . unlock ( ) ; ( set null ) { con = null ; } } }	protect void connect us driver ( ) throw sqlexcept { try { ( driver = = null ) driver = ( java . sql . driver ) class . name ( pool properti . get driver class name ( ) , true , pool connect . class . get class loader ( ) ) . new instanc ( ) ; } catch ( java . lang . except cn ) { ( log . debug enabl ( ) ) { log . debug ( unabl instanti jdbc driver . , cn ) ; } sqlexcept ex = new sqlexcept ( cn . get messag ( ) ) ; ex . init caus ( cn ) ; throw ex ; } string driver url = pool properti . get url ( ) ; string usr = null ; string pwd = null ; ( get attribut ( ) . contain kei ( prop user ) ) { usr = ( string ) get attribut ( ) . get ( prop user ) ; } els { usr = pool properti . get usernam ( ) ; get attribut ( ) . put ( prop user , usr ) ; } ( get attribut ( ) . contain kei ( prop password ) ) { pwd = ( string ) get attribut ( ) . get ( prop password ) ; } els { pwd = pool properti . get password ( ) ; get attribut ( ) . put ( prop password , pwd ) ; } properti properti = pool util . clone ( pool properti . get db properti ( ) ) ; ( usr = null ) properti . set properti ( prop user , usr ) ; ( pwd = null ) properti . set properti ( prop password , pwd ) ; try { connect = driver . connect ( driver url , properti ) ; } catch ( except x ) { ( log . debug enabl ( ) ) { log . debug ( unabl connect databas . , x ) ; } ( parent . jmx pool = null ) { parent . jmx pool . notifi ( org . apach . tomcat . jdbc . pool . jmx . connect pool . notifi connect , connect pool . get stack trace ( x ) ) ; } ( x instanceof sqlexcept ) { throw ( sqlexcept ) x ; } els { sqlexcept ex = new sqlexcept ( x . get messag ( ) ) ; ex . init caus ( x ) ; throw ex ; } } ( connect = = null ) { throw new sqlexcept ( driver : driver return null url : driver url ) ; } }
protect add given file extens list extens handl jsp file . param extens extens add , e . g . myjsp void add extens ( final string extens ) { ( extens = null ) { ( extens = = null ) { extens = new vector string ( ) ; } extens . add ( extens ) ; } }	public static void main ( string arg ) { ( arg . length = = 0 ) { system . out . println ( local . get messag ( jspc . usag ) ) ; } els { jsp c jspc = new jsp c ( ) ; try { jspc . set arg ( arg ) ; ( jspc . help need ) { system . out . println ( local . get messag ( jspc . usag ) ) ; } els { jspc . execut ( ) ; } } catch ( jasper except je ) { system . err . println ( je ) ; ( jspc . die level = die level ) { system . exit ( jspc . die level ) ; } } } }	public execut compil . throw jasper except error occur void execut ( ) throw jasper except { ( log . debug enabl ( ) ) { log . debug ( execut ( ) start page . size ( ) page . ) ; } try { ( uri root = = null ) { ( page . size ( ) = = 0 ) { throw new jasper except ( local . get messag ( jsp . error . jspc . miss target ) ) ; } string first jsp = page . get ( 0 ) ; file first jsp f = new file ( first jsp ) ; ( first jsp f . exist ( ) ) { throw new jasper except ( local . get messag ( jspc . error . file doe exist , first jsp ) ) ; } locat uri root ( first jsp f ) ; } ( uri root = = null ) { throw new jasper except ( local . get messag ( jsp . error . jspc . uriroot ) ) ; } file uri root f = new file ( uri root ) ; ( uri root f . directori ( ) ) { throw new jasper except ( local . get messag ( jsp . error . jspc . uriroot dir ) ) ; } ( context = = null ) { init servlet context ( ) ; } explicit page , we ll process all . jsp webapp ( page . size ( ) = = 0 ) { scan file ( uri root f ) ; } init web xml ( ) ; iter string iter = page . iter ( ) ; while ( iter . ha next ( ) ) { string nextjsp = iter . next ( ) . string ( ) ; file fjsp = new file ( nextjsp ) ; ( fjsp . absolut ( ) ) { fjsp = new file ( uri root f , nextjsp ) ; } ( fjsp . exist ( ) ) { ( log . warn enabl ( ) ) { log . warn ( local . get messag ( jspc . error . file doe exist , fjsp . string ( ) ) ) ; } continu ; } string s = fjsp . get absolut path ( ) ; ( s . start ( uri root ) ) { nextjsp = s . substr ( uri root . length ( ) ) ; } ( nextjsp . start ( . file . separ char ) ) { nextjsp = nextjsp . substr ( 2 ) ; } process file ( nextjsp ) ; } complet web xml ( ) ; ( add web xml map ) { merg web xml ( ) ; } } catch ( ioexcept ioe ) { throw new jasper except ( ioe ) ; } catch ( jasper except je ) { throwabl root caus = je ; while ( root caus instanceof jasper except ( ( jasper except ) root caus ) . get root caus ( ) = null ) { root caus = ( ( jasper except ) root caus ) . get root caus ( ) ; } ( root caus = je ) { root caus . print stack trace ( ) ; } throw je ; } final { ( loader = null ) { log factori . releas ( loader ) ; } } }	public locat all jsp file webapp . us explicit jsp ar specifi . void scan file ( file base ) throw jasper except { stack string dir = new stack string ( ) ; dir . push ( base . string ( ) ) ; make sure default extens ar alwai includ ( ( get extens ( ) = = null ) ( get extens ( ) . size ( ) 2 ) ) { add extens ( jsp ) ; add extens ( jspx ) ; } while ( dir . empti ( ) ) { string s = dir . pop ( ) ; file f = new file ( s ) ; ( f . exist ( ) f . directori ( ) ) { string file = f . list ( ) ; string ext ; ( int i = 0 ; ( file = null ) i file . length ; i ) { file f2 = new file ( s , file i ) ; ( f2 . directori ( ) ) { dir . push ( f2 . get path ( ) ) ; } els { string path = f2 . get path ( ) ; string uri = path . substr ( uri root . length ( ) ) ; ext = file i . substr ( file i . last index ( . ) 1 ) ; ( get extens ( ) . contain ( ext ) jsp config . jsp page ( uri ) ) { page . add ( path ) ; } } } } } }
construct return new session object , base default set specifi thi manag s properti . session id specifi us session id . new session cannot creat ani reason , return code null code . param session id session id which should us creat new session ; code null code , new session id gener except illeg state except new session cannot instanti ani reason overrid public session creat session ( string session id ) { ( ( max activ session = 0 ) ( get activ session ( ) = max activ session ) ) { reject session ; throw new illeg state except ( sm . get string ( manag base . creat session . ) ) ; } recycl creat session instanc session session = creat empti session ( ) ; initi properti new session return session . set new ( true ) ; session . set valid ( true ) ; session . set creation time ( system . current time milli ( ) ) ; session . set max inact interv ( thi . max inact interv ) ; string id = session id ; ( id = = null ) { id = gener session id ( ) ; } session . set id ( id ) ; session counter ; session time time = new session time ( session . get creation time ( ) , 0 ) ; synchron ( session creation time ) { session creation time . add ( time ) ; session creation time . poll ( ) ; } return ( session ) ; }
protect map string , string process annot web init param ( element valu ev ) { map string , string result = new hash map string , string ( ) ; ( ev instanceof arrai element valu ) { element valu arrai valu = ( ( arrai element valu ) ev ) . get element valu arrai ( ) ; ( element valu valu : arrai valu ) { ( valu instanceof annot element valu ) { element valu pair evp = ( ( annot element valu ) valu ) . get annot entri ( ) . get element valu pair ( ) ; string init param name = null ; string init param valu = null ; ( element valu pair evp : evp ) { ( name . equal ( evp . get name string ( ) ) ) { init param name = evp . get valu ( ) . stringifi valu ( ) ; } els ( valu . equal ( evp . get name string ( ) ) ) { init param valu = evp . get valu ( ) . stringifi valu ( ) ; } els { ignor } } result . put ( init param name , init param valu ) ; } } } return result ; }
privat void close outbound connect ( ws frame frame ) throw ioexcept { try { get ws outbound ( ) . close ( frame ) ; } final { close ( constant . opcod close ) ; } }	privat void close outbound connect ( int statu , byte buffer data ) throw ioexcept { try { get ws outbound ( ) . close ( statu , data ) ; } final { close ( statu ) ; } }	overrid public final socket state data ( ) throw ioexcept { must start start messag ( which mai consist multipl frame ) ws input stream ws = new ws input stream ( processor , get ws outbound ( ) ) ; try { ws frame frame = ws . next frame ( true ) ; while ( frame = null ) { todo user defin extens mai defin valu rsv ( frame . get rsv ( ) 0 ) { close outbound connect ( constant . statu protocol error , null ) ; return socket state . close ; } byte op code = frame . get op code ( ) ; ( op code = = constant . opcod binari ) { binari data ( ws ) ; } els ( op code = = constant . opcod text ) { input stream reader r = new input stream reader ( ws , new utf8decod ( ) ) ; text data ( r ) ; } els ( op code = = constant . opcod close ) { close outbound connect ( frame ) ; return socket state . close ; } els ( op code = = constant . opcod ping ) { get ws outbound ( ) . pong ( frame . get pai load ( ) ) ; } els ( op code = = constant . opcod pong ) { op } els { unknown op code close outbound connect ( constant . statu protocol error , null ) ; return socket state . close ; } frame = ws . next frame ( fals ) ; } } catch ( malform input except mie ) { invalid utf 8 close outbound connect ( constant . statu bad data , null ) ; return socket state . close ; } catch ( unmapp charact except uc ) { invalid utf 8 close outbound connect ( constant . statu bad data , null ) ; return socket state . close ; } catch ( ioexcept ioe ) { given someth must have gone reach thi point , thi might work try anywai . close outbound connect ( constant . statu protocol error , null ) ; return socket state . close ; } return socket state . upgrad ; }	test public void test detect wrong version ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; file app dir = new file ( get build directori ( ) , webapp exampl ) ; tomcat . add webapp ( null , exampl , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; web socket client client = new web socket client ( get port ( ) ) ; send web socket handshak client . writer . write ( get exampl websocket echo stream http 1 . 1 crlf ) ; client . writer . write ( host : foo crlf ) ; client . writer . write ( upgrad : websocket crlf ) ; client . writer . write ( connect : upgrad crlf ) ; client . writer . write ( sec web socket version : 8 crlf ) ; client . writer . write ( sec web socket kei : todo crlf ) ; client . writer . write ( crlf ) ; client . writer . flush ( ) ; make sure we got upgrad respons string respons line = client . reader . read line ( ) ; assert true ( respons line . start ( http 1 . 1 426 ) ) ; swallow header list string headerlin = new arrai list string ( ) ; string respons header line = client . reader . read line ( ) ; while ( respons header line . equal ( ) ) { headerlin . add ( respons header line ) ; respons header line = client . reader . read line ( ) ; } assert true ( headerlin . contain ( sec web socket version : 13 ) ) ; finish socket client . close ( ) ; }	test public void test kei ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; file app dir = new file ( get build directori ( ) , webapp exampl ) ; tomcat . add webapp ( null , exampl , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; web socket client client = new web socket client ( get port ( ) ) ; send web socket handshak client . writer . write ( get exampl websocket echo stream http 1 . 1 crlf ) ; client . writer . write ( host : foo crlf ) ; client . writer . write ( upgrad : websocket crlf ) ; client . writer . write ( connect : upgrad crlf ) ; client . writer . write ( sec web socket version : 13 crlf ) ; client . writer . write ( sec web socket kei : todo crlf ) ; client . writer . write ( crlf ) ; client . writer . flush ( ) ; make sure we got upgrad respons string respons line = client . reader . read line ( ) ; assert true ( respons line . start ( http 1 . 1 101 ) ) ; swallow header string accept = null ; string respons header line = client . reader . read line ( ) ; while ( respons header line . equal ( ) ) { ( respons header line . start ( sec web socket accept : ) ) { accept = respons header line . substr ( respons header line . index ( : ) 2 ) ; break ; } respons header line = client . reader . read line ( ) ; } assert true ( accept = null ) ; messag digest sha1help = messag digest . get instanc ( sha1 ) ; sha1help . reset ( ) ; sha1help . updat ( todo . get byte ( b2cconvert . iso 8859 1 ) ) ; string sourc = base64 . encod ( sha1help . digest ( ws accept ) ) ; assert equal ( sourc , accept ) ; sha1help . reset ( ) ; sha1help . updat ( tod . get byte ( b2cconvert . iso 8859 1 ) ) ; sourc = base64 . encod ( sha1help . digest ( ws accept ) ) ; assert fals ( sourc . equal ( accept ) ) ; finish socket client . close ( ) ; }
privat void do test basic ( string user , string pwd , string uri , boolean expect reject1 , int expect rc1 , boolean expect reject2 , int expect rc2 ) throw except { first access attempt should challeng map string , list string >> req headers1 = new hash map string , list string >> ( ) ; map string , list string >> resp headers1 = new hash map string , list string >> ( ) ; byte chunk bc = new byte chunk ( ) ; int rc = get url ( http prefix get port ( ) uri , bc , req headers1 , resp headers1 ) ; ( expect reject1 ) { assert equal ( expect rc1 , rc ) ; assert true ( bc . get length ( ) 0 ) ; } els { assert equal ( 200 , rc ) ; assert equal ( ok , bc . string ( ) ) ; return ; } second access attempt should sucess string credenti = user : pwd ; byte credenti byte = byte chunk . convert byte ( credenti ) ; string base64auth = base64 . encod ( credenti byte ) ; string auth line = basic base64auth ; list string auth = new arrai list string ( ) ; auth . add ( auth line ) ; map string , list string >> req headers2 = new hash map string , list string >> ( ) ; req headers2 . put ( client auth header , auth ) ; map string , list string >> resp headers2 = new hash map string , list string >> ( ) ; bc . recycl ( ) ; rc = get url ( http prefix get port ( ) uri , bc , req headers2 , resp headers2 ) ; ( expect reject2 ) { assert equal ( expect rc2 , rc ) ; assert true ( bc . get length ( ) 0 ) ; } els { assert equal ( 200 , rc ) ; assert equal ( ok , bc . string ( ) ) ; } }	try access protect resourc webapp ha basic login method defin . access challeng , authent permit . test public void test accept protect basic ( ) throw except { do test basic ( user , pwd , context path login uri protect , true , 401 , fals , 200 ) ; }	try access unprotect resourc webapp ha basic login method defin . thi should permit without challeng . test public void test accept public basic ( ) throw except { do test basic ( user , pwd , context path login uri public , fals , 200 , fals , 200 ) ; }	logon access protect resourc webapp us basic authent . try access protect resourc differ webapp doe have login method . thi should reject sc forbidden 403 statu , confirm ha been cross authent between webapp . test public void test basic login reject protect ( ) throw except { do test basic ( user , pwd , context path login uri protect , true , 401 , fals , 200 ) ; do test non login ( context path nologin uri protect , true , 403 ) ; }	logon access protect resourc webapp us basic authent . wait until session time out , re access resourc . thi should reject sc forbidden 401 statu , which can follow success re authent . test public void test basic login session timeout ( ) throw except { do test basic ( user , pwd , context path login uri protect , true , 401 , fals , 200 ) ; wait long enough session abov expir thread . sleep ( long timeout delai msec ) ; do test basic ( user , pwd , context path login uri protect , true , 401 , fals , 200 ) ; }
privat void do forward ( servlet request request , servlet respons respons ) throw servlet except , ioexcept { reset ani output ha been buffer , keep header cooki ( respons . commit ( ) ) { throw new illeg state except ( sm . get string ( applic dispatch . forward . ) ) ; } try { respons . reset buffer ( ) ; } catch ( illeg state except e ) { throw e ; } set up handl specifi request respons state state = new state ( request , respons , fals ) ; ( wrap same object ) { check srv . 8 . 2 srv . 14 . 2 . 5 . 1 complianc check same object ( request , respons ) ; } wrap respons ( state ) ; handl http name dispatch forward ( ( servlet path = = null ) ( path info = = null ) ) { applic http request wrequest = ( applic http request ) wrap request ( state ) ; http servlet request hrequest = state . hrequest ; wrequest . set request uri ( hrequest . get request uri ( ) ) ; wrequest . set context path ( hrequest . get context path ( ) ) ; wrequest . set servlet path ( hrequest . get servlet path ( ) ) ; wrequest . set path info ( hrequest . get path info ( ) ) ; wrequest . set queri string ( hrequest . get queri string ( ) ) ; process request ( request , respons , state ) ; } els handl http path base forward { applic http request wrequest = ( applic http request ) wrap request ( state ) ; string context path = context . get path ( ) ; http servlet request hrequest = state . hrequest ; ( hrequest . get attribut ( request dispatch . forward request uri ) = = null ) { wrequest . set attribut ( request dispatch . forward request uri , hrequest . get request uri ( ) ) ; wrequest . set attribut ( request dispatch . forward context path , hrequest . get context path ( ) ) ; wrequest . set attribut ( request dispatch . forward servlet path , hrequest . get servlet path ( ) ) ; wrequest . set attribut ( request dispatch . forward path info , hrequest . get path info ( ) ) ; wrequest . set attribut ( request dispatch . forward queri string , hrequest . get queri string ( ) ) ; } wrequest . set context path ( context path ) ; wrequest . set request uri ( request uri ) ; wrequest . set servlet path ( servlet path ) ; wrequest . set path info ( path info ) ; ( queri string = null ) { wrequest . set queri string ( queri string ) ; wrequest . set queri param ( queri string ) ; } process request ( request , respons , state ) ; } thi real close order support error process ( wrapper . get logger ( ) . debug enabl ( ) ) wrapper . get logger ( ) . debug ( disabl respons futher output ) ; ( respons instanceof respons facad ) { ( ( respons facad ) respons ) . finish ( ) ; } els { mai longer instanc request facad ( wrapper . get logger ( ) . debug enabl ( ) ) { wrapper . get logger ( ) . debug ( respons vehicul us wrapper : respons . get class ( ) . get name ( ) ) ; } close anywai try { print writer writer = respons . get writer ( ) ; writer . close ( ) ; } catch ( illeg state except e ) { try { servlet output stream stream = respons . get output stream ( ) ; stream . close ( ) ; } catch ( illeg state except f ) { ignor } catch ( ioexcept f ) { ignor } } catch ( ioexcept e ) { ignor } } }	privat void do test bug51197 ( boolean thread ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; async error servlet async error servlet = new async error servlet ( http servlet respons . sc bad request , thread ) ; wrapper wrapper = tomcat . add servlet ( ctx , async error servlet , async error servlet ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( async error servlet , async error servlet ) ; tester access log valv alv = new tester access log valv ( ) ; ctx . get pipelin ( ) . add valv ( alv ) ; tomcat . start ( ) ; string builder url = new string builder ( 48 ) ; url . append ( http : localhost : ) ; url . append ( get port ( ) ) ; url . append ( async error servlet ) ; byte chunk re = new byte chunk ( ) ; int rc = get url ( url . string ( ) , re , null ) ; assert equal ( http servlet respons . sc bad request , rc ) ; test servlet write content thi case . ( thread ) { assert equal ( 0 , re . get length ( ) ) ; } els { assert true ( re . get length ( ) 0 ) ; } without thi test mai complet befor access log ha chanc log request thread . sleep ( request time ) ; check access log alv . valid access log ( 1 , http servlet respons . sc bad request , 0 , request time ) ; }
overrid public synchron servlet load servlet ( ) throw servlet except { ( singl thread model ) { servlet instanc ; try { instanc = exist . get class ( ) . new instanc ( ) ; } catch ( instanti except e ) { throw new servlet except ( e ) ; } catch ( illeg access except e ) { throw new servlet except ( e ) ; } instanc . init ( facad ) ; return instanc ; } els { ( init ) { exist . init ( facad ) ; init = true ; } return exist ; } }	public void do get ( http servlet request req , http servlet respons re ) throw ioexcept { re . get writer ( ) . write ( hello world ) ; }	public static void init webapp default ( context ctx ) { default servlet wrapper servlet = add servlet ( ctx , default , org . apach . catalina . servlet . default servlet ) ; servlet . set load startup ( 1 ) ; jsp servlet ( class name avoid load all dep ) servlet = add servlet ( ctx , jsp , org . apach . jasper . servlet . jsp servlet ) ; servlet . add init paramet ( fork , fals ) ; servlet . set load startup ( 3 ) ; servlet map ctx . add servlet map ( , default ) ; ctx . add servlet map ( . jsp , jsp ) ; ctx . add servlet map ( . jspx , jsp ) ; session ctx . set session timeout ( 30 ) ; mime map ( int i = 0 ; i default mime map . length ; ) { ctx . add mime map ( default mime map i , default mime map i ) ; } welcom file ctx . add welcom file ( index . html ) ; ctx . add welcom file ( index . htm ) ; ctx . add welcom file ( index . jsp ) ; }	test public void test bug50826 ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; string context path = exampl ; file app dir = new file ( get build directori ( ) , webapp context path ) ; app dir rel server home tomcat . add webapp ( null , exampl , app dir . get absolut path ( ) ) ; except e = null ; try { tomcat . destroi ( ) ; } catch ( except ex ) { ex . print stack trace ( ) ; e = ex ; } assert null ( e ) ; }
p add set rule instanc defin thi rule set specifi code digest code instanc , associ them our namespac uri ( ani ) . thi method should onli call digest instanc . p param digest digest instanc which new rule instanc should ad . overrid public void add rule instanc ( digest digest ) { digest . add rule ( full prefix , new set public id rule ( set public id ) ) ; digest . add rule ( full prefix , new ignor annot rule ( ) ) ; digest . add rule ( full prefix , new version rule ( ) ) ; requir both fragment non fragment digest . add rule ( full prefix absolut order , absolut order ) ; digest . add rule ( full prefix order , rel order ) ; ( fragment ) { web fragment . xml digest . add rule ( full prefix name , name ) ; digest . add call method ( full prefix order after name , add after order , 0 ) ; digest . add call method ( full prefix order after other , add after order other ) ; digest . add call method ( full prefix order befor name , add befor order , 0 ) ; digest . add call method ( full prefix order befor other , add befor order other ) ; } els { web . xml digest . add call method ( full prefix absolut order name , add absolut order , 0 ) ; digest . add call method ( full prefix absolut order other , add absolut order other ) ; } digest . add call method ( full prefix context param , add context param , 2 ) ; digest . add call param ( full prefix context param param name , 0 ) ; digest . add call param ( full prefix context param param valu , 1 ) ; digest . add call method ( full prefix displai name , set displai name , 0 ) ; digest . add rule ( full prefix distribut , new set distribut rule ( ) ) ; configur name rule ( digest ) ; digest . add object creat ( full prefix error page , org . apach . catalina . deploi . error page ) ; digest . add set next ( full prefix error page , add error page , org . apach . catalina . deploi . error page ) ; digest . add call method ( full prefix error page error code , set error code , 0 ) ; digest . add call method ( full prefix error page except type , set except type , 0 ) ; digest . add call method ( full prefix error page locat , set locat , 0 ) ; digest . add object creat ( full prefix filter , org . apach . catalina . deploi . filter def ) ; digest . add set next ( full prefix filter , add filter , org . apach . catalina . deploi . filter def ) ; digest . add call method ( full prefix filter descript , set descript , 0 ) ; digest . add call method ( full prefix filter displai name , set displai name , 0 ) ; digest . add call method ( full prefix filter filter class , set filter class , 0 ) ; digest . add call method ( full prefix filter filter name , set filter name , 0 ) ; digest . add call method ( full prefix filter icon larg icon , set larg icon , 0 ) ; digest . add call method ( full prefix filter icon small icon , set small icon , 0 ) ; digest . add call method ( full prefix filter async support , set async support , 0 ) ; digest . add call method ( full prefix filter init param , add init paramet , 2 ) ; digest . add call param ( full prefix filter init param param name , 0 ) ; digest . add call param ( full prefix filter init param param valu , 1 ) ; digest . add object creat ( full prefix filter map , org . apach . catalina . deploi . filter map ) ; digest . add set next ( full prefix filter map , add filter map , org . apach . catalina . deploi . filter map ) ; digest . add call method ( full prefix filter map filter name , set filter name , 0 ) ; digest . add call method ( full prefix filter map servlet name , add servlet name , 0 ) ; digest . add call method ( full prefix filter map url pattern , add urlpattern , 0 ) ; digest . add call method ( full prefix filter map dispatch , set dispatch , 0 ) ; digest . add call method ( full prefix listen listen class , add listen , 0 ) ; digest . add rule ( full prefix jsp config , jsp config ) ; digest . add object creat ( full prefix jsp config jsp properti group , org . apach . catalina . deploi . jsp properti group ) ; digest . add set next ( full prefix jsp config jsp properti group , add jsp properti group , org . apach . catalina . deploi . jsp properti group ) ; digest . add call method ( full prefix jsp config jsp properti group defer syntax allow liter , set defer syntax , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group el ignor , set el ignor , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group includ coda , add includ coda , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group includ prelud , add includ prelud , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group xml , set xml , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group page encod , set page encod , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group script invalid , set script invalid , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group trim direct whitespac , set trim whitespac , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group url pattern , set url pattern , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group default content type , set default content type , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group buffer , set buffer , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group error undeclar namespac , set error undeclar namespac , 0 ) ; digest . add rule ( full prefix login config , login config ) ; digest . add object creat ( full prefix login config , org . apach . catalina . deploi . login config ) ; digest . add set next ( full prefix login config , set login config , org . apach . catalina . deploi . login config ) ; digest . add call method ( full prefix login config auth method , set auth method , 0 ) ; digest . add call method ( full prefix login config realm name , set realm name , 0 ) ; digest . add call method ( full prefix login config form login config form error page , set error page , 0 ) ; digest . add call method ( full prefix login config form login config form login page , set login page , 0 ) ; digest . add call method ( full prefix mime map , add mime map , 2 ) ; digest . add call param ( full prefix mime map extens , 0 ) ; digest . add call param ( full prefix mime map mime type , 1 ) ; digest . add object creat ( full prefix secur constraint , org . apach . catalina . deploi . secur constraint ) ; digest . add set next ( full prefix secur constraint , add secur constraint , org . apach . catalina . deploi . secur constraint ) ; digest . add rule ( full prefix secur constraint auth constraint , new set auth constraint rule ( ) ) ; digest . add call method ( full prefix secur constraint auth constraint role name , add auth role , 0 ) ; digest . add call method ( full prefix secur constraint displai name , set displai name , 0 ) ; digest . add call method ( full prefix secur constraint user data constraint transport guarante , set user constraint , 0 ) ; digest . add object creat ( full prefix secur constraint web resourc collect , org . apach . catalina . deploi . secur collect ) ; digest . add set next ( full prefix secur constraint web resourc collect , add collect , org . apach . catalina . deploi . secur collect ) ; digest . add call method ( full prefix secur constraint web resourc collect http method , add method , 0 ) ; digest . add call method ( full prefix secur constraint web resourc collect http method omiss , add omit method , 0 ) ; digest . add call method ( full prefix secur constraint web resourc collect url pattern , add pattern , 0 ) ; digest . add call method ( full prefix secur constraint web resourc collect web resourc name , set name , 0 ) ; digest . add call method ( full prefix secur role role name , add secur role , 0 ) ; digest . add rule ( full prefix servlet , new servlet def creat rule ( ) ) ; digest . add set next ( full prefix servlet , add servlet , org . apach . catalina . deploi . servlet def ) ; digest . add call method ( full prefix servlet init param , add init paramet , 2 ) ; digest . add call param ( full prefix servlet init param param name , 0 ) ; digest . add call param ( full prefix servlet init param param valu , 1 ) ; digest . add call method ( full prefix servlet jsp file , set jsp file , 0 ) ; digest . add call method ( full prefix servlet load startup , set load startup , 0 ) ; digest . add call method ( full prefix servlet run role name , set run , 0 ) ; digest . add call method ( full prefix servlet secur role ref , add secur role ref , 2 ) ; digest . add call param ( full prefix servlet secur role ref role link , 1 ) ; digest . add call param ( full prefix servlet secur role ref role name , 0 ) ; digest . add call method ( full prefix servlet servlet class , set servlet class , 0 ) ; digest . add call method ( full prefix servlet servlet name , set servlet name , 0 ) ; digest . add object creat ( full prefix servlet multipart config , org . apach . catalina . deploi . multipart def ) ; digest . add set next ( full prefix servlet multipart config , set multipart def , org . apach . catalina . deploi . multipart def ) ; digest . add call method ( full prefix servlet multipart config locat , set locat , 0 ) ; digest . add call method ( full prefix servlet multipart config max file size , set max file size , 0 ) ; digest . add call method ( full prefix servlet multipart config max request size , set max request size , 0 ) ; digest . add call method ( full prefix servlet multipart config file size threshold , set file size threshold , 0 ) ; digest . add call method ( full prefix servlet async support , set async support , 0 ) ; digest . add call method ( full prefix servlet enabl , set enabl , 0 ) ; digest . add rule ( full prefix servlet map , new call method multi rule ( add servlet map , 2 , 0 ) ) ; digest . add call param ( full prefix servlet map servlet name , 1 ) ; digest . add rule ( full prefix servlet map url pattern , new call param multi rule ( 0 ) ) ; digest . add rule ( full prefix session config , session config ) ; digest . add object creat ( full prefix session config , org . apach . catalina . deploi . session config ) ; digest . add set next ( full prefix session config , set session config , org . apach . catalina . deploi . session config ) ; digest . add call method ( full prefix session config session timeout , set session timeout , 0 ) ; digest . add call method ( full prefix session config cooki config name , set cooki name , 0 ) ; digest . add call method ( full prefix session config cooki config domain , set cooki domain , 0 ) ; digest . add call method ( full prefix session config cooki config path , set cooki path , 0 ) ; digest . add call method ( full prefix session config cooki config comment , set cooki comment , 0 ) ; digest . add call method ( full prefix session config cooki config http onli , set cooki http onli , 0 ) ; digest . add call method ( full prefix session config cooki config secur , set cooki secur , 0 ) ; digest . add call method ( full prefix session config cooki config max ag , set cooki max ag , 0 ) ; digest . add call method ( full prefix session config track mode , add session track mode , 0 ) ; taglib pre servlet 2 . 4 digest . add rule ( full prefix taglib , new taglib locat rule ( fals ) ) ; digest . add call method ( full prefix taglib , add taglib , 2 ) ; digest . add call param ( full prefix taglib taglib locat , 1 ) ; digest . add call param ( full prefix taglib taglib uri , 0 ) ; taglib servlet 2 . 4 onward digest . add rule ( full prefix jsp config taglib , new taglib locat rule ( true ) ) ; digest . add call method ( full prefix jsp config taglib , add taglib , 2 ) ; digest . add call param ( full prefix jsp config taglib taglib locat , 1 ) ; digest . add call param ( full prefix jsp config taglib taglib uri , 0 ) ; digest . add call method ( full prefix welcom file list welcom file , add welcom file , 0 ) ; digest . add call method ( full prefix local encod map list local encod map , add local encod map , 2 ) ; digest . add call param ( full prefix local encod map list local encod map local , 0 ) ; digest . add call param ( full prefix local encod map list local encod map encod , 1 ) ; }	public add secur role ref set secur role ref associ thi servlet . void add secur role ref ( secur role ref secur role ref ) { secur role ref . add ( secur role ref ) ; }
overrid protect void init intern ( ) throw lifecycl except { block queue runnabl start stop queue = new link block queue runnabl ( ) ; start stop executor = new thread pool executor ( get start stop thread intern ( ) , get start stop thread intern ( ) , 10 , time unit . second , start stop queue ) ; start stop executor . allow core thread time out ( true ) ; super . init intern ( ) ; }	overrid public void call ( ) throw lifecycl except { child . start ( ) ; return null ; }

privat when commit respons , we have valid set header , well setup respons filter . void prepar respons ( ) { boolean entiti bodi = true ; content delimit = fals ; output filter output filter = get output buffer ( ) . get filter ( ) ; ( http09 = = true ) { http 0 . 9 get output buffer ( ) . add activ filter ( output filter constant . ident filter ) ; return ; } int statu code = respons . get statu ( ) ; ( ( statu code = = 204 ) ( statu code = = 205 ) ( statu code = = 304 ) ) { entiti bodi get output buffer ( ) . add activ filter ( output filter constant . void filter ) ; entiti bodi = fals ; content delimit = true ; } messag byte method mb = request . method ( ) ; ( method mb . equal ( head ) ) { entiti bodi get output buffer ( ) . add activ filter ( output filter constant . void filter ) ; content delimit = true ; } sendfil support boolean send sendfil = fals ; ( get endpoint ( ) . get us sendfil ( ) ) { send sendfil = prepar sendfil ( output filter ) ; } check compress boolean compress = fals ; boolean us compress = fals ; ( entiti bodi ( compress level 0 ) send sendfil ) { compress = compress ( ) ; ( compress ) { us compress = us compress ( ) ; } chang content length 1 forc chunk ( us compress ) { respons . set content length ( 1 ) ; } } mime header header = respons . get mime header ( ) ; ( entiti bodi ) { respons . set content length ( 1 ) ; } els { string content type = respons . get content type ( ) ; ( content type = null ) { header . set valu ( content type ) . set string ( content type ) ; } string content languag = respons . get content languag ( ) ; ( content languag = null ) { header . set valu ( content languag ) . set string ( content languag ) ; } } long content length = respons . get content length long ( ) ; ( content length = 1 ) { header . set valu ( content length ) . set long ( content length ) ; get output buffer ( ) . add activ filter ( output filter constant . ident filter ) ; content delimit = true ; } els { ( entiti bodi http11 ) { get output buffer ( ) . add activ filter ( output filter constant . chunk filter ) ; content delimit = true ; header . add valu ( constant . transferencod ) . set string ( constant . chunk ) ; } els { get output buffer ( ) . add activ filter ( output filter constant . ident filter ) ; } } ( us compress ) { get output buffer ( ) . add activ filter ( output filter constant . gzip filter ) ; header . set valu ( content encod ) . set string ( gzip ) ; } might compress , set vari header ( compress ) { make proxi happi via vari ( from mod deflat ) messag byte vari = header . get valu ( vari ) ; ( vari = = null ) { add new vari header header . set valu ( vari ) . set string ( accept encod ) ; } els ( vari . equal ( ) ) { action requir } els { merg current header header . set valu ( vari ) . set string ( vari . get string ( ) , accept encod ) ; } } add date header header . set valu ( date ) . set string ( fast http date format . get current date ( ) ) ; fixm : add transfer encod header ( ( entiti bodi ) ( content delimit ) ) { mark close connect after request , add connect : close header keep aliv = fals ; } we know request bad thi earli , add connect : close header . keep aliv = keep aliv statu drop connect ( statu code ) ; ( keep aliv ) { header . add valu ( constant . connect ) . set string ( constant . close ) ; } els ( http11 error ) { header . add valu ( constant . connect ) . set string ( constant . keepal ) ; } build respons header get output buffer ( ) . send statu ( ) ; add server header ( server = null ) { alwai overrid anyth app might set header . set valu ( server ) . set string ( server ) ; } els ( header . get valu ( server ) = = null ) { app didn t set header , us default get output buffer ( ) . write ( constant . server byte ) ; } int size = header . size ( ) ; ( int i = 0 ; i size ; i ) { get output buffer ( ) . send header ( header . get name ( i ) , header . get valu ( i ) ) ; } get output buffer ( ) . end header ( ) ; }	protect after read request header , we have setup request filter . void prepar request ( ) { http11 = true ; http09 = fals ; content delimit = fals ; expect = fals ; prepar request intern ( ) ; ( endpoint . sslenabl ( ) ) { request . scheme ( ) . set string ( http ) ; } messag byte protocol mb = request . protocol ( ) ; ( protocol mb . equal ( constant . http 11 ) ) { http11 = true ; protocol mb . set string ( constant . http 11 ) ; } els ( protocol mb . equal ( constant . http 10 ) ) { http11 = fals ; keep aliv = fals ; protocol mb . set string ( constant . http 10 ) ; } els ( protocol mb . equal ( ) ) { http 0 . 9 http09 = true ; http11 = fals ; keep aliv = fals ; } els { unsupport protocol http11 = fals ; error = true ; send 505 ; unsupport http version ( get log ( ) . debug enabl ( ) ) { get log ( ) . debug ( sm . get string ( http11processor . request . prepar ) unsupport http version protocol mb ) ; } respons . set statu ( 505 ) ; } messag byte method mb = request . method ( ) ; ( method mb . equal ( constant . get ) ) { method mb . set string ( constant . get ) ; } els ( method mb . equal ( constant . post ) ) { method mb . set string ( constant . post ) ; } mime header header = request . get mime header ( ) ; check connect header messag byte connect valu mb = header . get valu ( connect ) ; ( connect valu mb = null ) { byte chunk connect valu bc = connect valu mb . get byte chunk ( ) ; ( find byte ( connect valu bc , constant . close byte ) = 1 ) { keep aliv = fals ; } els ( find byte ( connect valu bc , constant . keepal byte ) = 1 ) { keep aliv = true ; } } messag byte expect mb = null ; ( http11 ) { expect mb = header . get valu ( expect ) ; } ( ( expect mb = null ) ( expect mb . index ignor case ( 100 continu , 0 ) = 1 ) ) { get input buffer ( ) . set swallow input ( fals ) ; expect = true ; } check user agent header ( ( restrict user agent = null ) ( ( http11 ) ( keep aliv ) ) ) { messag byte user agent valu mb = header . get valu ( user agent ) ; keep aliv flag accordingli ( user agent valu mb = null ) { string user agent valu = user agent valu mb . string ( ) ; ( restrict user agent = null restrict user agent . matcher ( user agent valu ) . match ( ) ) { http11 = fals ; keep aliv = fals ; } } } check full uri ( includ protocol : host : port ) byte chunk uri bc = request . request uri ( ) . get byte chunk ( ) ; ( uri bc . start ignor case ( http , 0 ) ) { int po = uri bc . index ( : , 0 , 3 , 4 ) ; int uri bcstart = uri bc . get start ( ) ; int slash po = 1 ; ( po = 1 ) { byte uri b = uri bc . get byte ( ) ; slash po = uri bc . index ( , po 3 ) ; ( slash po = = 1 ) { slash po = uri bc . get length ( ) ; set uri request . request uri ( ) . set byte ( uri b , uri bcstart po 1 , 1 ) ; } els { request . request uri ( ) . set byte ( uri b , uri bcstart slash po , uri bc . get length ( ) slash po ) ; } messag byte host mb = header . set valu ( host ) ; host mb . set byte ( uri b , uri bcstart po 3 , slash po po 3 ) ; } } input filter setup input filter input filter = get input buffer ( ) . get filter ( ) ; pars transfer encod header messag byte transfer encod valu mb = null ; ( http11 ) { transfer encod valu mb = header . get valu ( transfer encod ) ; } ( transfer encod valu mb = null ) { string transfer encod valu = transfer encod valu mb . string ( ) ; pars comma separ list . ident code ar ignor int start po = 0 ; int comma po = transfer encod valu . index ( , ) ; string encod name = null ; while ( comma po = 1 ) { encod name = transfer encod valu . substr ( start po , comma po ) . lower case ( local . english ) . trim ( ) ; ( add input filter ( input filter , encod name ) ) { unsupport transfer encod error = true ; 501 unimpl respons . set statu ( 501 ) ; } start po = comma po 1 ; comma po = transfer encod valu . index ( , , start po ) ; } encod name = transfer encod valu . substr ( start po ) . lower case ( local . english ) . trim ( ) ; ( add input filter ( input filter , encod name ) ) { unsupport transfer encod error = true ; 501 unimpl ( get log ( ) . debug enabl ( ) ) { get log ( ) . debug ( sm . get string ( http11processor . request . prepar ) unsupport transfer encod encod name ) ; } respons . set statu ( 501 ) ; } } pars content length header long content length = request . get content length long ( ) ; ( content length = 0 content delimit ) { get input buffer ( ) . add activ filter ( input filter constant . ident filter ) ; content delimit = true ; } messag byte valu mb = header . get valu ( host ) ; check host header ( http11 ( valu mb = = null ) ) { error = true ; 400 bad request ( get log ( ) . debug enabl ( ) ) { get log ( ) . debug ( sm . get string ( http11processor . request . prepar ) host header miss ) ; } respons . set statu ( 400 ) ; } pars host ( valu mb ) ; ( content delimit ) { s content length ( broken http 1 . 0 http 1 . 1 ) , assum client broken didn t send bodi get input buffer ( ) . add activ filter ( input filter constant . void filter ) ; content delimit = true ; } advertis sendfil support through request attribut ( endpoint . get us sendfil ( ) ) { request . set attribut ( org . apach . coyot . constant . sendfil support attr , boolean . true ) ; } advertis comet support through request attribut ( endpoint . get us comet ( ) ) { request . set attribut ( org . apach . coyot . constant . comet support attr , boolean . true ) ; } advertis comet timeout support ( endpoint . get us comet timeout ( ) ) { request . set attribut ( org . apach . coyot . constant . comet timeout support attr , boolean . true ) ; } ( error ) { adapt . log ( request , respons , 0 ) ; } }	public void test pipelin ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctxt = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; add protect servlet tomcat . add servlet ( ctxt , tester servlet , new tester servlet ( ) ) ; ctxt . add servlet map ( foo , tester servlet ) ; tomcat . start ( ) ; string request part1 = get foo http 1 . 1 simpl http client . crlf ; string request part2 = host : ani simpl http client . crlf simpl http client . crlf ; final client client = new client ( tomcat . get connector ( ) . get local port ( ) ) ; client . set request ( new string { request part1 , request part2 } ) ; client . set request paus ( 1000 ) ; client . set us content length ( true ) ; client . connect ( ) ; runnabl send = new runnabl ( ) { overrid public void run ( ) { try { client . send request ( ) ; client . send request ( ) ; } catch ( interrupt except e ) { throw new runtim except ( e ) ; } catch ( ioexcept e ) { throw new runtim except ( e ) ; } } } ; thread t = new thread ( send ) ; t . start ( ) ; sleep 1500 ms which should mean all request 1 ha been sent half request 2 thread . sleep ( 1500 ) ; now read first respons client . read respons ( true ) ; assert fals ( client . response50x ( ) ) ; assert true ( client . response200 ( ) ) ; assert equal ( ok , client . get respons bodi ( ) ) ; read second respons . need sleep , read block until data process client . read respons ( true ) ; assert fals ( client . response50x ( ) ) ; assert true ( client . response200 ( ) ) ; assert equal ( ok , client . get respons bodi ( ) ) ; }
protect make sure annot cach ha been popul provid class . param clazz clazz popul annot param inject map inject thi class from xml deploy descriptor throw illeg access except inject target inaccess throw javax . name . name except valu cannot look up jndi throw java . lang . reflect . invoc target except inject fail void popul annot cach ( class clazz , map string , string inject ) throw illeg access except , invoc target except , name except { list annot cach entri annot = null ; while ( clazz = null ) { annot cach entri annot arrai = null ; synchron ( annot cach ) { annot arrai = annot cach . get ( clazz ) ; } ( annot arrai = = null ) { ( annot = = null ) { annot = new arrai list annot cach entri ( ) ; } els { annot . clear ( ) ; } ( context = null ) { initi field annot resourc inject jndi enabl field field = null ; ( global . secur enabl ) { final class clazz2 = clazz ; field = access control . do privileg ( new privileg action field ( ) { overrid public field run ( ) { return clazz2 . get declar field ( ) ; } } ) ; } els { field = clazz . get declar field ( ) ; } ( field field : field ) { ( inject = null inject . contain kei ( field . get name ( ) ) ) { annot . add ( new annot cach entri ( field . get name ( ) , null , inject . get ( field . get name ( ) ) , annot cach entri type . field ) ) ; } els ( field . annot present ( resourc . class ) ) { resourc annot = field . get annot ( resourc . class ) ; annot . add ( new annot cach entri ( field . get name ( ) , null , annot . name ( ) , annot cach entri type . field ) ) ; } els ( field . annot present ( ejb . class ) ) { ejb annot = field . get annot ( ejb . class ) ; annot . add ( new annot cach entri ( field . get name ( ) , null , annot . name ( ) , annot cach entri type . field ) ) ; } els ( field . annot present ( web servic ref . class ) ) { web servic ref annot = field . get annot ( web servic ref . class ) ; annot . add ( new annot cach entri ( field . get name ( ) , null , annot . name ( ) , annot cach entri type . field ) ) ; } els ( field . annot present ( persist context . class ) ) { persist context annot = field . get annot ( persist context . class ) ; annot . add ( new annot cach entri ( field . get name ( ) , null , annot . name ( ) , annot cach entri type . field ) ) ; } els ( field . annot present ( persist unit . class ) ) { persist unit annot = field . get annot ( persist unit . class ) ; annot . add ( new annot cach entri ( field . get name ( ) , null , annot . name ( ) , annot cach entri type . field ) ) ; } } } initi method annot method method = null ; ( global . secur enabl ) { final class clazz2 = clazz ; method = access control . do privileg ( new privileg action method ( ) { overrid public method run ( ) { return clazz2 . get declar method ( ) ; } } ) ; } els { method = clazz . get declar method ( ) ; } method post construct = null ; method pre destroi = null ; ( method method : method ) { string method name = method . get name ( ) ; ( context = null ) { resourc inject onli jndi enabl ( inject = null method name . start ( set ) method name . length ( ) 3 method . get paramet type ( ) . length = = 1 method . get return type ( ) . get name ( ) . equal ( void ) ) { string field name = charact . lower case ( method name . char ( 3 ) ) method name . substr ( 4 ) ; ( inject . contain kei ( field name ) ) { annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , inject . get ( method . get name ( ) ) , annot cach entri type . setter ) ) ; break ; } } ( method . annot present ( resourc . class ) ) { resourc annot = method . get annot ( resourc . class ) ; annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , annot . name ( ) , annot cach entri type . setter ) ) ; } els ( method . annot present ( ejb . class ) ) { ejb annot = method . get annot ( ejb . class ) ; annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , annot . name ( ) , annot cach entri type . setter ) ) ; } els ( method . annot present ( web servic ref . class ) ) { web servic ref annot = method . get annot ( web servic ref . class ) ; annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , annot . name ( ) , annot cach entri type . setter ) ) ; } els ( method . annot present ( persist context . class ) ) { persist context annot = method . get annot ( persist context . class ) ; annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , annot . name ( ) , annot cach entri type . setter ) ) ; } els ( method . annot present ( persist unit . class ) ) { persist unit annot = method . get annot ( persist unit . class ) ; annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , annot . name ( ) , annot cach entri type . setter ) ) ; } } ( method . annot present ( post construct . class ) ) { ( ( post construct = null ) ( method . get paramet type ( ) . length = 0 ) ( modifi . static ( method . get modifi ( ) ) ) ( method . get except type ( ) . length 0 ) ( method . get return type ( ) . get name ( ) . equal ( void ) ) ) { throw new illeg argument except ( invalid post construct annot ) ; } post construct = method ; } ( method . annot present ( pre destroi . class ) ) { ( ( pre destroi = null method . get paramet type ( ) . length = 0 ) ( modifi . static ( method . get modifi ( ) ) ) ( method . get except type ( ) . length 0 ) ( method . get return type ( ) . get name ( ) . equal ( void ) ) ) { throw new illeg argument except ( invalid pre destroi annot ) ; } pre destroi = method ; } } ( post construct = null ) { annot . add ( new annot cach entri ( post construct . get name ( ) , post construct . get paramet type ( ) , null , annot cach entri type . post construct ) ) ; } ( pre destroi = null ) { annot . add ( new annot cach entri ( pre destroi . get name ( ) , pre destroi . get paramet type ( ) , null , annot cach entri type . pre destroi ) ) ; } ( annot . empti ( ) ) { us common object save memori annot arrai = annot empti ; } els { annot arrai = annot . arrai ( new annot cach entri annot . size ( ) ) ; } synchron ( annot cach ) { annot cach . put ( clazz , annot arrai ) ; } } clazz = clazz . get superclass ( ) ; } }	public static string get name ( method setter ) { string builder name = new string builder ( setter . get name ( ) ) ; remov set name . delet ( 0 , 3 ) ; lowercas first char name . set char ( 0 , charact . lower case ( name . char ( 0 ) ) ) ; return name . string ( ) ; }
protect make sure annot cach ha been popul provid class . param clazz clazz popul annot param inject map inject thi class from xml deploy descriptor throw illeg access except inject target inaccess throw javax . name . name except valu cannot look up jndi throw java . lang . reflect . invoc target except inject fail void popul annot cach ( class clazz , map string , string inject ) throw illeg access except , invoc target except , name except { list annot cach entri annot = null ; while ( clazz = null ) { annot cach entri annot arrai = null ; synchron ( annot cach ) { annot arrai = annot cach . get ( clazz ) ; } ( annot arrai = = null ) { ( annot = = null ) { annot = new arrai list annot cach entri ( ) ; } els { annot . clear ( ) ; } ( context = null ) { initi field annot resourc inject jndi enabl field field = null ; ( global . secur enabl ) { final class clazz2 = clazz ; field = access control . do privileg ( new privileg action field ( ) { overrid public field run ( ) { return clazz2 . get declar field ( ) ; } } ) ; } els { field = clazz . get declar field ( ) ; } ( field field : field ) { ( inject = null inject . contain kei ( field . get name ( ) ) ) { annot . add ( new annot cach entri ( field . get name ( ) , null , inject . get ( field . get name ( ) ) , annot cach entri type . field ) ) ; } els ( field . annot present ( resourc . class ) ) { resourc annot = field . get annot ( resourc . class ) ; annot . add ( new annot cach entri ( field . get name ( ) , null , annot . name ( ) , annot cach entri type . field ) ) ; } els ( field . annot present ( ejb . class ) ) { ejb annot = field . get annot ( ejb . class ) ; annot . add ( new annot cach entri ( field . get name ( ) , null , annot . name ( ) , annot cach entri type . field ) ) ; } els ( field . annot present ( web servic ref . class ) ) { web servic ref annot = field . get annot ( web servic ref . class ) ; annot . add ( new annot cach entri ( field . get name ( ) , null , annot . name ( ) , annot cach entri type . field ) ) ; } els ( field . annot present ( persist context . class ) ) { persist context annot = field . get annot ( persist context . class ) ; annot . add ( new annot cach entri ( field . get name ( ) , null , annot . name ( ) , annot cach entri type . field ) ) ; } els ( field . annot present ( persist unit . class ) ) { persist unit annot = field . get annot ( persist unit . class ) ; annot . add ( new annot cach entri ( field . get name ( ) , null , annot . name ( ) , annot cach entri type . field ) ) ; } } } initi method annot method method = null ; ( global . secur enabl ) { final class clazz2 = clazz ; method = access control . do privileg ( new privileg action method ( ) { overrid public method run ( ) { return clazz2 . get declar method ( ) ; } } ) ; } els { method = clazz . get declar method ( ) ; } method post construct = null ; method pre destroi = null ; ( method method : method ) { string method name = method . get name ( ) ; ( context = null ) { resourc inject onli jndi enabl ( inject = null method name . start ( set ) method name . length ( ) 3 ) { string field name = charact . lower case ( method name . char ( 3 ) ) method name . substr ( 4 ) ; ( inject . contain kei ( field name ) ) { annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , inject . get ( method . get name ( ) ) , annot cach entri type . setter ) ) ; break ; } } ( method . annot present ( resourc . class ) ) { resourc annot = method . get annot ( resourc . class ) ; annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , annot . name ( ) , annot cach entri type . setter ) ) ; } els ( method . annot present ( ejb . class ) ) { ejb annot = method . get annot ( ejb . class ) ; annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , annot . name ( ) , annot cach entri type . setter ) ) ; } els ( method . annot present ( web servic ref . class ) ) { web servic ref annot = method . get annot ( web servic ref . class ) ; annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , annot . name ( ) , annot cach entri type . setter ) ) ; } els ( method . annot present ( persist context . class ) ) { persist context annot = method . get annot ( persist context . class ) ; annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , annot . name ( ) , annot cach entri type . setter ) ) ; } els ( method . annot present ( persist unit . class ) ) { persist unit annot = method . get annot ( persist unit . class ) ; annot . add ( new annot cach entri ( method . get name ( ) , method . get paramet type ( ) , annot . name ( ) , annot cach entri type . setter ) ) ; } } ( method . annot present ( post construct . class ) ) { ( ( post construct = null ) ( method . get paramet type ( ) . length = 0 ) ( modifi . static ( method . get modifi ( ) ) ) ( method . get except type ( ) . length 0 ) ( method . get return type ( ) . get name ( ) . equal ( void ) ) ) { throw new illeg argument except ( invalid post construct annot ) ; } post construct = method ; } ( method . annot present ( pre destroi . class ) ) { ( ( pre destroi = null method . get paramet type ( ) . length = 0 ) ( modifi . static ( method . get modifi ( ) ) ) ( method . get except type ( ) . length 0 ) ( method . get return type ( ) . get name ( ) . equal ( void ) ) ) { throw new illeg argument except ( invalid pre destroi annot ) ; } pre destroi = method ; } } ( post construct = null ) { annot . add ( new annot cach entri ( post construct . get name ( ) , post construct . get paramet type ( ) , null , annot cach entri type . post construct ) ) ; } ( pre destroi = null ) { annot . add ( new annot cach entri ( pre destroi . get name ( ) , pre destroi . get paramet type ( ) , null , annot cach entri type . pre destroi ) ) ; } ( annot . empti ( ) ) { us common object save memori annot arrai = annot empti ; } els { annot arrai = annot . arrai ( new annot cach entri annot . size ( ) ) ; } synchron ( annot cach ) { annot cach . put ( clazz , annot arrai ) ; } } clazz = clazz . get superclass ( ) ; } }
protect find class given name ha previous been load cach thi class loader , return class object . thi class ha been cach , return code null code . param name name resourc return class find load class0 ( string name ) { resourc entri entri = resourc entri . get ( name ) ; ( entri = null ) { return entri . load class ; } fixm find load resourc ( ) return ( null ) ; }	protect find specifi resourc local repositori . return load resourc , null resourc isn t found resourc entri find resourc intern ( string name , string path ) { ( start ) { log . info ( sm . get string ( webapp class loader . stop , name ) ) ; return null ; } ( ( name = = null ) ( path = = null ) ) return null ; resourc entri entri = resourc entri . get ( name ) ; ( entri = null ) return entri ; int content length = 1 ; input stream binari stream = null ; int jar file length = jar file . length ; int repositori length = repositori . length ; int i ; resourc resourc = null ; boolean file need convert = fals ; ( i = 0 ; ( entri = = null ) ( i repositori length ) ; i ) { try { string full path = repositori i path ; object lookup result = resourc . lookup ( full path ) ; ( lookup result instanceof resourc ) { resourc = ( resourc ) lookup result ; } note : get except here mean resourc wa found resourc attribut attribut = ( resourc attribut ) resourc . get attribut ( full path ) ; content length = ( int ) attribut . get content length ( ) ; string canon path = attribut . get canon path ( ) ; ( canon path = null ) { we creat resourc entri base inform return dir context rather than just us path repositori . thi allow have smart dir context implement virtual docbas ( e . g . eclips wtp ) entri = find resourc intern ( new file ( canon path ) , ) ; } els { probabl resourc filesystem ( e . g . packag war ) entri = find resourc intern ( file i , path ) ; } entri . last modifi = attribut . get last modifi ( ) ; ( resourc = null ) { try { binari stream = resourc . stream content ( ) ; } catch ( ioexcept e ) { return null ; } ( need convert ) { ( path . end ( . properti ) ) { file need convert = true ; } } note : onli sync constant object need synchron ( all permiss ) { int j ; long result2 = new long last modifi date . length 1 ; ( j = 0 ; j last modifi date . length ; j ) { result2 j = last modifi date j ; } result2 last modifi date . length = entri . last modifi ; last modifi date = result2 ; string result = new string path . length 1 ; ( j = 0 ; j path . length ; j ) { result j = path j ; } result path . length = full path ; path = result ; } } } catch ( name except e ) { ignor } } ( ( entri = = null ) ( found resourc . contain kei ( name ) ) ) return null ; jar entri jar entri = null ; synchron ( jar file ) { try { ( open jar ( ) ) { return null ; } ( i = 0 ; ( entri = = null ) ( i jar file length ) ; i ) { jar entri = jar file i . get jar entri ( path ) ; ( jar entri = null ) { entri = new resourc entri ( ) ; try { entri . code base = get url ( jar real file i , fals ) ; string jar fake url = get uri ( jar real file i ) . string ( ) ; jar fake url = jar : jar fake url path ; entri . sourc = new url ( jar fake url ) ; entri . last modifi = jar real file i . last modifi ( ) ; } catch ( malform urlexcept e ) { return null ; } content length = ( int ) jar entri . get size ( ) ; try { entri . manifest = jar file i . get manifest ( ) ; binari stream = jar file i . get input stream ( jar entri ) ; } catch ( ioexcept e ) { return null ; } extract resourc contain jar workdir ( anti jarlock ( path . end ( . class ) ) ) { byte buf = new byte 1024 ; file resourc file = new file ( loader dir , jar entri . get name ( ) ) ; ( resourc file . exist ( ) ) { enumer jar entri entri = jar file i . entri ( ) ; while ( entri . ha more element ( ) ) { jar entri jar entry2 = entri . next element ( ) ; ( ( jar entry2 . directori ( ) ) ( jar entry2 . get name ( ) . end ( . class ) ) ) { resourc file = new file ( loader dir , jar entry2 . get name ( ) ) ; try { ( resourc file . get canon path ( ) . start ( canon loader dir ) ) { throw new illeg argument except ( sm . get string ( webapp class loader . illeg jar path , jar entry2 . get name ( ) ) ) ; } } catch ( ioexcept ioe ) { throw new illeg argument except ( sm . get string ( webapp class loader . valid error jar path , jar entry2 . get name ( ) ) , ioe ) ; } file parent file = resourc file . get parent file ( ) ; ( parent file . mkdir ( ) parent file . exist ( ) ) { ignor error ( like ioexcept below ) } file output stream os = null ; input stream = null ; try { = jar file i . get input stream ( jar entry2 ) ; os = new file output stream ( resourc file ) ; while ( true ) { int n = . read ( buf ) ; ( n = 0 ) { break ; } os . write ( buf , 0 , n ) ; } resourc file . set last modifi ( jar entry2 . get time ( ) ) ; } catch ( ioexcept e ) { ignor } final { try { ( = null ) { . close ( ) ; } } catch ( ioexcept e ) { ignor } try { ( os = null ) { os . close ( ) ; } } catch ( ioexcept e ) { ignor } } } } } } } } ( entri = = null ) { synchron ( found resourc ) { found resourc . put ( name , name ) ; } return null ; } ( binari stream = null ) { byte binari content = new byte content length ; int po = 0 ; try { while ( true ) { int n = binari stream . read ( binari content , po , binari content . length po ) ; ( n = 0 ) break ; po = n ; } } catch ( ioexcept e ) { log . error ( sm . get string ( webapp class loader . read error , name ) , e ) ; return null ; } ( file need convert ) { workaround certain file platform us ebcdic encod , when thei ar read through file input stream . see commit messag rev . 303915 detail http : svn . apach . org viewvc view = revis revis = 303915 string str = new string ( binari content , 0 , po ) ; try { binari content = str . get byte ( charset utf8 ) ; } catch ( except e ) { return null ; } } entri . binari content = binari content ; associ input stream ha been fulli read ( jar entri = null ) { entri . certif = jar entri . get certif ( ) ; } } } final { ( binari stream = null ) { try { binari stream . close ( ) ; } catch ( ioexcept e ) { ignor } } } } add entri local resourc repositori synchron ( resourc entri ) { ensur all thread which mai race load particular class all end up same resourc entri instanc resourc entri entry2 = resourc entri . get ( name ) ; ( entry2 = = null ) { resourc entri . put ( name , entri ) ; } els { entri = entry2 ; } } return entri ; }
privat object new instanc ( object instanc , class clazz ) throw illeg access except , invoc target except , name except { ( ignor annot ) { map string , string inject = inject map . get ( clazz . get name ( ) ) ; popul annot cach ( clazz , inject ) ; process annot ( instanc , inject ) ; post construct ( instanc , clazz ) ; } return instanc ; }
privat void close pollset ( long pollset ) { int rv = poll . pollset ( pollset , desc ) ; ( rv 0 ) { ( int n = 0 ; n rv ; n ) { ( comet ) { process socket ( desc n 2 1 , socket statu . stop ) ; } els { destroi socket ( desc n 2 1 , true ) ; } } } }	overrid protect void long poll ( socket wrapper long socket , processor long processor ) { connect . put ( socket . get socket ( ) , processor ) ; ( processor . async ( ) ) { async socket . set async ( true ) ; } els ( processor . comet ( ) proto . endpoint . run ( ) ) { ( ( apr endpoint ) proto . endpoint ) . get comet poller ( ) . add ( socket . get socket ( ) . long valu ( ) , fals ) ; } els { upgrad ( ( apr endpoint ) proto . endpoint ) . get poller ( ) . add ( socket . get socket ( ) . long valu ( ) , fals ) ; } }	protect intend overridden sub class wish notifi when outbound connect close . default implement op . param statu statu code close reason . void close ( int statu ) { op }	public add specifi socket associ pool poller . socket ad temporari arrai , poll first after maximum amount time equal poll time ( most case , latenc much lower , howev ) . param socket add poller void add ( long socket , boolean keep aliv ) { synchron ( thi ) { most poll time befor poll ( add count = add socket . length ) { can t do anyth : close socket right awai ( comet ) { process socket ( socket , socket statu . error ) ; } els { destroi socket ( socket ) ; } return ; } add socket add count = socket ; ( keep aliv ) { add socket timeout add count = get keep aliv timeout ( ) ; } els { add socket timeout add count = get so timeout ( ) ; } add count ; todo : interrupt poll thi . notifi ( ) ; } }	expect us handler onc processor longer requir . overrid public void releas ( socket wrapper long socket , processor long processor , boolean socket close , boolean add poller ) { processor . recycl ( socket close ) ; recycl processor . offer ( processor ) ; ( add poller ) { ( ( apr endpoint ) proto . endpoint ) . get poller ( ) . add ( socket . get socket ( ) . long valu ( ) , true ) ; } }	expect us handler onc processor longer requir . param socket param processor param socket close us http param add poller overrid public void releas ( socket wrapper long socket , processor long processor , boolean socket close , boolean add poller ) { processor . recycl ( socket close ) ; recycl processor . offer ( processor ) ; ( add poller proto . endpoint . run ( ) ) { ( ( apr endpoint ) proto . endpoint ) . get poller ( ) . add ( socket . get socket ( ) . long valu ( ) , true ) ; } }	protect log get log ( ) { return log ; }
public static set timer task get pool cleaner ( ) { return collect . timer task unmodifi set ( cleaner ) ; }	protect creat new pool connect object . connect nor valid . return pool connect object pool connect creat ( boolean increment counter ) { ( increment counter ) size . increment get ( ) ; pool connect con = new pool connect ( get pool properti ( ) , thi ) ; return con ; }	protect determin connect should close upon return pool . param con connect param action valid action should perform return true connect should close boolean should close ( pool connect con , int action ) { ( con . discard ( ) ) return true ; ( close ( ) ) return true ; ( con . valid ( action ) ) return true ; ( termin transact ( con ) ) return true ; ( get pool properti ( ) . get max ag ( ) 0 ) { return ( system . current time milli ( ) con . get last connect ( ) ) get pool properti ( ) . get max ag ( ) ; } els { return fals ; } }	protect initi connect pool call from constructor param properti pool properti properti us initi pool throw sqlexcept initi fail void init ( pool configur properti ) throw sqlexcept { pool properti = properti ; make sure pool properli configur ( properti . get max activ ( ) 1 ) { log . warn ( max activ smaller than 1 , set max activ : pool properti . default max activ ) ; properti . set max activ ( pool properti . default max activ ) ; } ( properti . get max activ ( ) properti . get initi size ( ) ) { log . warn ( initi size larger than max activ , set initi size : properti . get max activ ( ) ) ; properti . set initi size ( properti . get max activ ( ) ) ; } ( properti . get min idl ( ) properti . get max activ ( ) ) { log . warn ( min idl larger than max activ , set min idl : properti . get max activ ( ) ) ; properti . set min idl ( properti . get max activ ( ) ) ; } ( properti . get max idl ( ) properti . get max activ ( ) ) { log . warn ( max idl larger than max activ , set max idl : properti . get max activ ( ) ) ; properti . set max idl ( properti . get max activ ( ) ) ; } ( properti . get max idl ( ) properti . get min idl ( ) ) { log . warn ( max idl smaller than min idl , set max idl : properti . get min idl ( ) ) ; properti . set max idl ( properti . get min idl ( ) ) ; } make space 10 extra case we flow over bit busi = new arrai block queue pool connect ( properti . get max activ ( ) , fals ) ; make space 10 extra case we flow over bit ( properti . fair queue ( ) ) { idl = new fair block queue pool connect ( ) ; idl = new multi lock fair block queue pool connect ( ) ; } els { idl = new arrai block queue pool connect ( properti . get max activ ( ) , properti . fair queue ( ) ) ; } initi pool cleaner ( properti ) ; creat jmx mbean ( thi . get pool properti ( ) . jmx enabl ( ) ) creat mbean ( ) ; pars creat initi set interceptor . let them know pool ha start . interceptor get ani connect . pool properti . interceptor definit proxi = get pool properti ( ) . get jdbc interceptor arrai ( ) ; ( int i = 0 ; i proxi . length ; i ) { try { ( log . debug enabl ( ) ) { log . debug ( creat interceptor instanc class : proxi i . get interceptor class ( ) ) ; } jdbc interceptor interceptor = proxi i . get interceptor class ( ) . new instanc ( ) ; interceptor . set properti ( proxi i . get properti ( ) ) ; interceptor . pool start ( thi ) ; } catch ( except x ) { log . error ( unabl inform interceptor pool start . , x ) ; ( jmx pool = null ) jmx pool . notifi ( org . apach . tomcat . jdbc . pool . jmx . connect pool . notifi init , get stack trace ( x ) ) ; close ( true ) ; sqlexcept ex = new sqlexcept ( ) ; ex . init caus ( x ) ; throw ex ; } } initi pool initi set member pool connect initi pool = new pool connect pool properti . get initi size ( ) ; try { ( int i = 0 ; i initi pool . length ; i ) { don t wait , should content initi pool i = thi . borrow connect ( 0 , null , null ) ; } } catch ( sqlexcept x ) { ( jmx pool = null ) jmx pool . notifi ( org . apach . tomcat . jdbc . pool . jmx . connect pool . notifi init , get stack trace ( x ) ) ; close ( true ) ; throw x ; } final { return member idl pool ( int i = 0 ; i initi pool . length ; i ) { ( initi pool i = null ) { try { thi . return connect ( initi pool i ) ; } catch ( except x ) { noop } } end } } catch close = fals ; }	public iter through idl connect resiz idl pool base paramet { link pool properti max idl } , { link pool properti min idl } , { link pool properti min evict idl time milli } void check idl ( ) { try { ( idl . size ( ) = = 0 ) return ; long now = system . current time milli ( ) ; iter pool connect unlock = idl . iter ( ) ; while ( ( idl . size ( ) = get pool properti ( ) . get min idl ( ) ) unlock . ha next ( ) ) { pool connect con = unlock . next ( ) ; boolean set null = fals ; try { con . lock ( ) ; con been taken out , we can t clean up ( busi . contain ( con ) ) continu ; long time = con . get timestamp ( ) ; ( ( con . get releas time ( ) 0 ) ( ( now time ) con . get releas time ( ) ) ( get size ( ) get pool properti ( ) . get min idl ( ) ) ) { releas ( con ) ; idl . remov ( con ) ; set null = true ; } els { do noth } end } final { con . unlock ( ) ; ( set null ) con = null ; } } while } catch ( concurr modif except e ) { log . debug ( check idl fail . , e ) ; } catch ( except e ) { log . warn ( check idl fail , retri . , e ) ; } }	{ inherit doc } overrid public void set propag interrupt state ( boolean propag interrupt state ) { get pool properti ( ) . set propag interrupt state ( propag interrupt state ) ; }	{ inherit doc } overrid public void set propag interrupt state ( boolean propag interrupt state ) { get pool properti ( ) . set propag interrupt state ( propag interrupt state ) ; }
protect void do get ( http servlet request req , http servlet respons resp ) throw servlet except , ioexcept { inform requir send server handshak messag string kei ; string sub protocol = null ; list string extens = collect . empti list ( ) ; ( header contain token ( req , upgrad , websocket ) ) { resp . send error ( http servlet respons . sc bad request ) ; return ; } ( header contain token ( req , connect , upgrad ) ) { resp . send error ( http servlet respons . sc bad request ) ; return ; } ( header contain token ( req , sec websocket version , 13 ) ) { resp . set statu ( 426 ) ; resp . set header ( sec web socket version , 13 ) ; return ; } kei = req . get header ( sec web socket kei ) ; ( kei = = null ) { resp . send error ( http servlet respons . sc bad request ) ; return ; } string origin = req . get header ( origin ) ; ( verifi origin ( origin ) ) { resp . send error ( http servlet respons . sc forbidden ) ; return ; } list string sub protocol = get token from header ( req , sec web socket protocol client ) ; ( sub protocol . empti ( ) ) { sub protocol = select sub protocol ( sub protocol ) ; } todo read client handshak sec web socket extens todo extens requir abil specifi someth ( api tbd ) can pass tomcat intern process extens data present when frame fragment . we got thi far , all good . accept connect . resp . set header ( upgrad , websocket ) ; resp . set header ( connect , upgrad ) ; resp . set header ( sec web socket accept , get web socket accept ( kei ) ) ; ( sub protocol = null ) { resp . set header ( sec web socket protocol , sub protocol ) ; } ( extens . empti ( ) ) { todo } small hack until servlet api provid wai do thi . stream inbound inbound = creat web socket inbound ( sub protocol ) ; ( ( request facad ) req ) . do upgrad ( inbound ) ; }
public int get max thread ( ) { ( run executor = null ) { ( executor instanceof java . util . concurr . thread pool executor ) { return ( ( java . util . concurr . thread pool executor ) executor ) . get maximum pool size ( ) ; } els ( executor instanceof resiz executor ) { return ( ( resiz executor ) executor ) . get max thread ( ) ; } els { return 1 ; } } els { return max thread ; } }	public method overrid public void bind ( ) throw except { initi thread count default acceptor ( acceptor thread count = = 0 ) { acceptor thread count = 1 ; } initi max connect ( get max connect ( ) = = 0 ) { user hasn t set valu us default set max connect ( get max thread ( ) ) ; } ( server socket factori = = null ) { ( sslenabl ( ) ) { server socket factori = handler . get ssl implement ( ) . get server socket factori ( thi ) ; } els { server socket factori = new default server socket factori ( thi ) ; } } ( server socket = = null ) { try { ( get address ( ) = = null ) { server socket = server socket factori . creat socket ( get port ( ) , get backlog ( ) ) ; } els { server socket = server socket factori . creat socket ( get port ( ) , get backlog ( ) , get address ( ) ) ; } } catch ( bind except orig ) { string msg ; ( get address ( ) = = null ) msg = orig . get messag ( ) null : get port ( ) ; els msg = orig . get messag ( ) get address ( ) . string ( ) : get port ( ) ; bind except = new bind except ( msg ) ; . init caus ( orig ) ; throw ; } } }
protect void remov attribut intern ( string name , boolean notifi , boolean add delta request ) { try { lock ( ) ; remov thi attribut from our collect object valu = attribut . get ( name ) ; ( valu = = null ) return ; super . remov attribut intern ( name , notifi ) ; ( add delta request delta request = null exclud ( name ) ) { delta request . remov attribut ( name ) ; } } final { unlock ( ) ; } }	public string get type desc ( ) { switch ( msgtype ) { case msg backup : return msg backup ; case msg retriev backup : return msg retriev backup ; case msg proxi : return msg proxi ; case msg remov : return msg remov ; case msg state : return msg state ; case msg start : return msg start ; case msg stop : return msg stop ; case msg init : return msg init ; case msg state copi : return msg state copi ; case msg copi : return msg copi ; default : return unknown ; } }	overrid public string string ( ) { string builder buf = new string builder ( map entri kei : ) ; buf . append ( get kei ( ) ) . append ( ; ) ; buf . append ( valu : ) . append ( get valu ( ) ) . append ( ; ) ; buf . append ( primari : ) . append ( primari ( ) ) . append ( ; ) ; buf . append ( backup : ) . append ( backup ( ) ) . append ( ; ) ; buf . append ( proxi : ) . append ( proxi ( ) ) . append ( ; ) ; return buf . string ( ) ; }	overrid public long get version ( ) { return version ; }	suppress warn ( uncheck ) overrid public void messag receiv ( serializ msg , member sender ) { ( ( msg instanceof map messag ) ) return ; map messag mapmsg = ( map messag ) msg ; ( log . trace enabl ( ) ) { log . trace ( map mapnam receiv messag : mapmsg ) ; } try { mapmsg . deseri ( get extern loader ( ) ) ; } catch ( ioexcept x ) { log . error ( unabl deseri map messag . , x ) ; return ; } catch ( class found except x ) { log . error ( unabl deseri map messag . , x ) ; return ; } ( log . trace enabl ( ) ) log . trace ( map messag receiv from : sender . get name ( ) msg : mapmsg ) ; ( mapmsg . get msg type ( ) = = map messag . msg start ) { map member ad ( mapmsg . get primari ( ) ) ; } ( mapmsg . get msg type ( ) = = map messag . msg stop ) { member disappear ( mapmsg . get primari ( ) ) ; } ( mapmsg . get msg type ( ) = = map messag . msg proxi ) { map entri k , v entri = inner map . get ( mapmsg . get kei ( ) ) ; ( entri = = null ) { entri = new map entri k , v ( ( k ) mapmsg . get kei ( ) , ( v ) mapmsg . get valu ( ) ) ; entri . set backup ( fals ) ; entri . set proxi ( true ) ; entri . set backup node ( mapmsg . get backup node ( ) ) ; entri . set primari ( mapmsg . get primari ( ) ) ; inner map . put ( entri . get kei ( ) , entri ) ; } els { entri . set proxi ( true ) ; entri . set backup ( fals ) ; entri . set backup node ( mapmsg . get backup node ( ) ) ; entri . set primari ( mapmsg . get primari ( ) ) ; } } ( mapmsg . get msg type ( ) = = map messag . msg remov ) { inner map . remov ( mapmsg . get kei ( ) ) ; } ( mapmsg . get msg type ( ) = = map messag . msg backup mapmsg . get msg type ( ) = = map messag . msg copi ) { map entri k , v entri = inner map . get ( mapmsg . get kei ( ) ) ; ( entri = = null ) { entri = new map entri k , v ( ( k ) mapmsg . get kei ( ) , ( v ) mapmsg . get valu ( ) ) ; entri . set backup ( mapmsg . get msg type ( ) = = map messag . msg backup ) ; entri . set proxi ( fals ) ; entri . set backup node ( mapmsg . get backup node ( ) ) ; entri . set primari ( mapmsg . get primari ( ) ) ; ( mapmsg . get valu ( ) = null mapmsg . get valu ( ) instanceof replic map entri ) { ( ( replic map entri ) mapmsg . get valu ( ) ) . set owner ( get map owner ( ) ) ; } } els { entri . set backup ( mapmsg . get msg type ( ) = = map messag . msg backup ) ; entri . set proxi ( fals ) ; entri . set backup node ( mapmsg . get backup node ( ) ) ; entri . set primari ( mapmsg . get primari ( ) ) ; ( entri . get valu ( ) instanceof replic map entri ) { replic map entri diff = ( replic map entri ) entri . get valu ( ) ; ( mapmsg . diff ( ) ) { try { diff . lock ( ) ; diff . appli diff ( mapmsg . get diff valu ( ) , 0 , mapmsg . get diff valu ( ) . length ) ; } catch ( except x ) { log . error ( unabl appli diff kei : entri . get kei ( ) , x ) ; } final { diff . unlock ( ) ; } } els { ( mapmsg . get valu ( ) = null ) entri . set valu ( ( v ) mapmsg . get valu ( ) ) ; ( ( replic map entri ) entri . get valu ( ) ) . set owner ( get map owner ( ) ) ; } end } els ( mapmsg . get valu ( ) instanceof replic map entri ) { replic map entri re = ( replic map entri ) mapmsg . get valu ( ) ; re . set owner ( get map owner ( ) ) ; entri . set valu ( ( v ) re ) ; } els { ( mapmsg . get valu ( ) = null ) entri . set valu ( ( v ) mapmsg . get valu ( ) ) ; } end } end inner map . put ( entri . get kei ( ) , entri ) ; } end }	public replic ani chang object sinc last time object ha primari , ie , object proxi backup , replic br param complet set true , object replic backup set fals , onli object implement replic map entri dirti ( ) return true replic void replic ( object kei , boolean complet ) { ( log . trace enabl ( ) ) log . trace ( replic invok kei : kei ) ; map entri k , v entri = inner map . get ( kei ) ; ( entri = = null ) return ; ( entri . serializ ( ) ) return ; ( entri . primari ( ) entri . get backup node ( ) = null entri . get backup node ( ) . length 0 ) { object valu = entri . get valu ( ) ; check see we need replic thi object dirti ( ) complet boolean repl = complet ( ( valu instanceof replic map entri ) ( ( replic map entri ) valu ) . dirti ( ) ) ; ( repl ) { ( log . trace enabl ( ) ) log . trace ( replic : kei , chang made ) ; return ; } check see messag diffabl boolean diff = ( ( valu instanceof replic map entri ) ( ( replic map entri ) valu ) . diffabl ( ) ) ; map messag msg = null ; ( diff ) { replic map entri rentri = ( replic map entri ) entri . get valu ( ) ; try { rentri . lock ( ) ; construct diff messag msg = new map messag ( map context name , map messag . msg backup , true , ( serializ ) entri . get kei ( ) , null , rentri . get diff ( ) , entri . get primari ( ) , entri . get backup node ( ) ) ; rentri . reset diff ( ) ; } catch ( ioexcept x ) { log . error ( unabl diff object . replic entir object instead . , x ) ; } final { rentri . unlock ( ) ; } } ( msg = = null ) { construct complet msg = new map messag ( map context name , map messag . msg backup , fals , ( serializ ) entri . get kei ( ) , ( serializ ) entri . get valu ( ) , null , entri . get primari ( ) , entri . get backup node ( ) ) ; } try { ( channel = null entri . get backup node ( ) = null entri . get backup node ( ) . length 0 ) { channel . send ( entri . get backup node ( ) , msg , channel send option ) ; } } catch ( channel except x ) { log . error ( unabl replic data . , x ) ; } } end }	overrid public void set owner ( object owner ) { ( owner instanceof cluster manag get manag ( ) = = null ) { cluster manag cm = ( cluster manag ) owner ; thi . set manag ( cm ) ; thi . set valid ( true ) ; thi . set primari session ( fals ) ; thi . access ( ) ; thi . reset delta request ( ) ; thi . end access ( ) ; } }
privat static void init ( ) { int major = 0 ; int minor = 0 ; int patch = 0 ; int apver = 0 ; int rqver = tcn requir major 1000 tcn requir minor 100 tcn requir patch ; int rcver = tcn requir major 1000 tcn requir minor 100 tcn recommend pv ; ( apr initi ) { return ; } apr initi = true ; try { string method name = initi ; class param type = new class 1 ; param type 0 = string . class ; object param valu = new object 1 ; param valu 0 = null ; class clazz = class . name ( org . apach . tomcat . jni . librari ) ; method method = clazz . get method ( method name , param type ) ; method . invok ( null , param valu ) ; major = clazz . get field ( tcn major version ) . get int ( null ) ; minor = clazz . get field ( tcn minor version ) . get int ( null ) ; patch = clazz . get field ( tcn patch version ) . get int ( null ) ; apver = major 1000 minor 100 patch ; } catch ( throwabl t ) { t = except util . unwrap invoc target except ( t ) ; except util . handl throwabl ( t ) ; log . info ( sm . get string ( apr listen . apr init , system . get properti ( java . librari . path ) ) ) ; return ; } ( apver rqver ) { log . error ( sm . get string ( apr listen . tcn invalid , major . minor . patch , tcn requir major . tcn requir minor . tcn requir patch ) ) ; try { termin apr case version below requir . termin apr ( ) ; } catch ( throwabl t ) { t = except util . unwrap invoc target except ( t ) ; except util . handl throwabl ( t ) ; } return ; } ( apver rcver ) { log . info ( sm . get string ( apr listen . tcn version , major . minor . patch , tcn requir major . tcn recommend minor . tcn recommend pv ) ) ; } log . info ( sm . get string ( apr listen . tcn valid , major . minor . patch ) ) ; log apr flag log . info ( sm . get string ( apr listen . flag , boolean . valu ( librari . apr have ipv6 ) , boolean . valu ( librari . apr ha sendfil ) , boolean . valu ( librari . apr ha so acceptfilt ) , boolean . valu ( librari . apr ha random ) ) ) ; apr avail = true ; }
protect initi connect pool call from constructor param properti pool properti properti us initi pool throw sqlexcept initi fail void init ( pool configur properti ) throw sqlexcept { pool properti = properti ; make sure pool properli configur ( properti . get max activ ( ) 1 ) { log . warn ( max activ smaller than 1 , set max activ : pool properti . default max activ ) ; properti . set max activ ( pool properti . default max activ ) ; } ( properti . get max activ ( ) properti . get initi size ( ) ) { log . warn ( initi size larger than max activ , set initi size : properti . get max activ ( ) ) ; properti . set initi size ( properti . get max activ ( ) ) ; } ( properti . get min idl ( ) properti . get max activ ( ) ) { log . warn ( min idl larger than max activ , set min idl : properti . get max activ ( ) ) ; properti . set min idl ( properti . get max activ ( ) ) ; } ( properti . get max idl ( ) properti . get max activ ( ) ) { log . warn ( max idl larger than max activ , set max idl : properti . get max activ ( ) ) ; properti . set max idl ( properti . get max activ ( ) ) ; } ( properti . get max idl ( ) properti . get min idl ( ) ) { log . warn ( max idl smaller than min idl , set max idl : properti . get min idl ( ) ) ; properti . set max idl ( properti . get min idl ( ) ) ; } make space 10 extra case we flow over bit busi = new arrai block queue pool connect ( properti . get max activ ( ) , fals ) ; make space 10 extra case we flow over bit ( properti . fair queue ( ) ) { idl = new fair block queue pool connect ( ) ; idl = new multi lock fair block queue pool connect ( ) ; } els { idl = new arrai block queue pool connect ( properti . get max activ ( ) , properti . fair queue ( ) ) ; } evictor thread suppos run , start now ( properti . pool sweeper enabl ( ) ) { pool cleaner = new pool cleaner ( thi , properti . get time between evict run milli ( ) ) ; pool cleaner . start ( ) ; } creat jmx mbean ( thi . get pool properti ( ) . jmx enabl ( ) ) creat mbean ( ) ; pars creat initi set interceptor . let them know pool ha start . interceptor get ani connect . pool properti . interceptor definit proxi = get pool properti ( ) . get jdbc interceptor arrai ( ) ; ( int i = 0 ; i proxi . length ; i ) { try { ( log . debug enabl ( ) ) { log . debug ( creat interceptor instanc class : proxi i . get interceptor class ( ) ) ; } jdbc interceptor interceptor = proxi i . get interceptor class ( ) . new instanc ( ) ; interceptor . set properti ( proxi i . get properti ( ) ) ; interceptor . pool start ( thi ) ; } catch ( except x ) { log . error ( unabl inform interceptor pool start . , x ) ; ( jmx pool = null ) jmx pool . notifi ( org . apach . tomcat . jdbc . pool . jmx . connect pool . notifi init , get stack trace ( x ) ) ; close ( true ) ; sqlexcept ex = new sqlexcept ( ) ; ex . init caus ( x ) ; throw ex ; } } initi pool initi set member pool connect initi pool = new pool connect pool properti . get initi size ( ) ; try { ( int i = 0 ; i initi pool . length ; i ) { don t wait , should content initi pool i = thi . borrow connect ( 0 , null , null ) ; } } catch ( sqlexcept x ) { ( jmx pool = null ) jmx pool . notifi ( org . apach . tomcat . jdbc . pool . jmx . connect pool . notifi init , get stack trace ( x ) ) ; close ( true ) ; throw x ; } final { return member idl pool ( int i = 0 ; i initi pool . length ; i ) { ( initi pool i = null ) { try { thi . return connect ( initi pool i ) ; } catch ( except x ) { noop } } end } } catch close = fals ; }	{ inherit doc } overrid public void set altern usernam allow ( boolean altern usernam allow ) { noop }	{ inherit doc } overrid public void set data sourc jndi ( string jndi ds ) { noop }	overrid public void set init sql ( string init sql ) { todo auto gener method stub }	overrid public void set initi size ( int initi size ) { todo auto gener method stub }	overrid public void set jdbc interceptor ( string jdbc interceptor ) { todo auto gener method stub }	overrid public void set jmx enabl ( boolean jmx enabl ) { todo auto gener method stub }	overrid public void set log abandon ( boolean log abandon ) { todo auto gener method stub }	overrid public void set max activ ( int max activ ) { todo auto gener method stub }	overrid public void set max idl ( int max idl ) { todo auto gener method stub }	overrid public void set max wait ( int max wait ) { todo auto gener method stub }	overrid public void set min evict idl time milli ( int min evict idl time milli ) { todo auto gener method stub }	overrid public void set min idl ( int min idl ) { todo auto gener method stub }	overrid public void set num test per evict run ( int num test per evict run ) { todo auto gener method stub }	overrid public void set password ( string password ) { todo auto gener method stub }	overrid public void set remov abandon ( boolean remov abandon ) { todo auto gener method stub }	overrid public void set remov abandon timeout ( int remov abandon timeout ) { todo auto gener method stub }	{ inherit doc } overrid public void set suspect timeout ( int second ) { op }	overrid public void set test borrow ( boolean test borrow ) { todo auto gener method stub }	overrid public void set test connect ( boolean test connect ) { todo auto gener method stub }	overrid public void set test return ( boolean test return ) { todo auto gener method stub }	overrid public void set test while idl ( boolean test while idl ) { todo auto gener method stub }	overrid public void set time between evict run milli ( int time between evict run milli ) { todo auto gener method stub }	overrid public void set url ( string url ) { todo auto gener method stub }	overrid public void set us equal ( boolean us equal ) { todo auto gener method stub }	overrid public void set us lock ( boolean us lock ) { todo auto gener method stub }	overrid public void set usernam ( string usernam ) { todo auto gener method stub }	overrid public void set valid interv ( long valid interv ) { todo auto gener method stub }	overrid public void set valid queri ( string valid queri ) { todo auto gener method stub }	{ inherit doc } overrid public void set valid ( valid valid ) { noop }
public static creat new { link express factori } pass provid { link properti } . search order same { link new instanc ( ) } . param properti properti pass new instanc ( mai null ) return new express factori express factori new instanc ( properti properti ) { express factori result = null ; class loader tccl = thread . current thread ( ) . get context class loader ( ) ; string class name = discov class name ( tccl ) ; try { class clazz = null ; ( tccl = = null ) { clazz = class . name ( class name ) ; } els { clazz = tccl . load class ( class name ) ; } constructor constructor = null ; do we need look constructor take properti ( properti = null ) { try { constructor = clazz . get constructor ( properti . class ) ; } catch ( secur except se ) { throw new elexcept ( se ) ; } catch ( method except nsme ) { thi can ignor thi ok thi constructor exist } } ( constructor = = null ) { result = ( express factori ) clazz . new instanc ( ) ; } els { result = ( express factori ) constructor . new instanc ( properti ) ; } } catch ( class found except e ) { throw new elexcept ( unabl find express factori type : class name , e ) ; } catch ( instanti except e ) { throw new elexcept ( unabl creat express factori type : class name , e ) ; } catch ( illeg access except e ) { throw new elexcept ( unabl creat express factori type : class name , e ) ; } catch ( illeg argument except e ) { throw new elexcept ( unabl creat express factori type : class name , e ) ; } catch ( invoc target except e ) { throwabl caus = e . get caus ( ) ; ( caus instanceof thread death ) { throw ( thread death ) caus ; } ( caus instanceof virtual machin error ) { throw ( virtual machin error ) caus ; } throw new elexcept ( unabl creat express factori type : class name , e ) ; } return result ; }

protect static process resourc annot set up resourc . ref jsr 250 , equival resourc ref , messag destin ref , env ref , resourc env ref servic ref element deploy descriptor . void add resourc ( context context , resourc annot ) { ( annot . type ( ) . get canon name ( ) . equal ( java . lang . string ) annot . type ( ) . get canon name ( ) . equal ( java . lang . charact ) annot . type ( ) . get canon name ( ) . equal ( java . lang . integ ) annot . type ( ) . get canon name ( ) . equal ( java . lang . boolean ) annot . type ( ) . get canon name ( ) . equal ( java . lang . doubl ) annot . type ( ) . get canon name ( ) . equal ( java . lang . byte ) annot . type ( ) . get canon name ( ) . equal ( java . lang . short ) annot . type ( ) . get canon name ( ) . equal ( java . lang . long ) annot . type ( ) . get canon name ( ) . equal ( java . lang . float ) ) { env ref element context environ resourc = new context environ ( ) ; resourc . set name ( annot . name ( ) ) ; resourc . set type ( annot . type ( ) . get canon name ( ) ) ; resourc . set descript ( annot . descript ( ) ) ; resourc . set valu ( annot . map name ( ) ) ; context . get name resourc ( ) . add environ ( resourc ) ; } els ( annot . type ( ) . get canon name ( ) . equal ( javax . xml . rpc . servic ) ) { servic ref element context servic servic = new context servic ( ) ; servic . set name ( annot . name ( ) ) ; servic . set wsdlfile ( annot . map name ( ) ) ; servic . set type ( annot . type ( ) . get canon name ( ) ) ; servic . set descript ( annot . descript ( ) ) ; context . get name resourc ( ) . add servic ( servic ) ; } els ( annot . type ( ) . get canon name ( ) . equal ( javax . sql . data sourc ) annot . type ( ) . get canon name ( ) . equal ( javax . jm . connect factori ) annot . type ( ) . get canon name ( ) . equal ( javax . jm . queue connect factori ) annot . type ( ) . get canon name ( ) . equal ( javax . jm . topic connect factori ) annot . type ( ) . get canon name ( ) . equal ( javax . mail . session ) annot . type ( ) . get canon name ( ) . equal ( java . net . url ) annot . type ( ) . get canon name ( ) . equal ( javax . resourc . cci . connect factori ) annot . type ( ) . get canon name ( ) . equal ( org . omg . corba 2 3 . orb ) annot . type ( ) . get canon name ( ) . end ( connect factori ) ) { resourc ref element context resourc resourc = new context resourc ( ) ; resourc . set name ( annot . name ( ) ) ; resourc . set type ( annot . type ( ) . get canon name ( ) ) ; ( annot . authent type ( ) = = resourc . authent type . contain ) { resourc . set auth ( contain ) ; } } }	protect static process annot filter . void load applic filter annot ( context context ) { filter def filter def = context . find filter def ( ) ; ( int i = 0 ; i filter def . length ; i ) { load class annot ( context , ( filter def i ) . get filter class ( ) ) ; } }	protect static process annot listen . void load applic listen annot ( context context ) { string applic listen = context . find applic listen ( ) ; ( int i = 0 ; i applic listen . length ; i ) { load class annot ( context , applic listen i ) ; } }	protect static process annot servlet . void load applic servlet annot ( context context ) { class loader class loader = context . get loader ( ) . get class loader ( ) ; wrapper wrapper = null ; class class class = null ; contain children = context . find children ( ) ; ( int i = 0 ; i children . length ; i ) { ( children i instanceof wrapper ) { wrapper = ( wrapper ) children i ; ( wrapper . get servlet class ( ) = = null ) { continu ; } try { class class = class loader . load class ( wrapper . get servlet class ( ) ) ; } catch ( class found except e ) { we do noth } catch ( class def found error e ) { we do noth } ( class class = = null ) { continu ; } load class annot ( context , wrapper . get servlet class ( ) ) ; process run annot which can onli servlet . ref jsr 250 , equival run element deploy descriptor ( class class . annot present ( run . class ) ) { run annot = class class . get annot ( run . class ) ; wrapper . set run ( annot . valu ( ) ) ; } } } }	protect static process annot context given class name . void load class annot ( context context , string file string ) { class loader class loader = context . get loader ( ) . get class loader ( ) ; class class class = null ; try { class class = class loader . load class ( file string ) ; } catch ( class found except e ) { we do noth } catch ( class def found error e ) { we do noth } ( class class = = null ) { return ; } initi annot ( class class . annot present ( resourc . class ) ) { resourc annot = class class . get annot ( resourc . class ) ; add resourc ( context , annot ) ; } process resourc annot . ref jsr 250 ( class class . annot present ( resourc . class ) ) { resourc annot = class class . get annot ( resourc . class ) ; ( int i = 0 ; annot . valu ( ) = null i annot . valu ( ) . length ; i ) { add resourc ( context , annot . valu ( ) i ) ; } } process declar role annot . ref jsr 250 , equival secur role element deploy descriptor ( class class . annot present ( declar role . class ) ) { declar role annot = class class . get annot ( declar role . class ) ; ( int i = 0 ; annot . valu ( ) = null i annot . valu ( ) . length ; i ) { context . add secur role ( annot . valu ( ) i ) ; } } }
invok pre startup initi . thi us allow connector bind restrict port under unix oper environ . overrid protect void init intern ( ) throw lifecycl except { super . init intern ( ) ; regist global string cach note although cach global , ar multipl server present jvm ( mai happen when embed ) same cach regist under multipl name onam string cach = regist ( new string cach ( ) , type = string cach ) ; regist mbean factori mbean factori factori = new mbean factori ( ) ; factori . set contain ( thi ) ; onam mbean factori = regist ( factori , type = mbean factori ) ; regist name resourc global name resourc . init ( ) ; class loader ( get catalina ( ) = null ) { class loader cl = get catalina ( ) . get parent class loader ( ) ; thi add share ( present ) common class loader while ( cl = class loader . get system class loader ( ) ) { ( cl instanceof urlclass loader ) { url url = ( ( urlclass loader ) cl ) . get url ( ) ; ( url url : url ) { ( url . get protocol ( ) . equal ( file ) ) { try { file f = new file ( url . uri ( ) ) ; ( f . file ( ) f . get name ( ) . end ( . jar ) ) { extens valid . add system resourc ( f ) ; } } catch ( urisyntax except e ) { ignor } catch ( ioexcept e ) { ignor } } } } cl = cl . get parent ( ) ; } } initi our defin servic ( int i = 0 ; i servic . length ; i ) { servic i . init ( ) ; } }
privat thread safe wai retriev connect from pool param wait time wait , overrid max wait from properti , set 1 you wish us max wait , 0 you wish wait time . return pool connect throw sqlexcept pool connect borrow connect ( int wait , string usernam , string password ) throw sqlexcept { ( close ( ) ) { throw new sqlexcept ( connect pool close . ) ; } end get current time stamp long now = system . current time milli ( ) ; see avail immedi pool connect con = idl . poll ( ) ; while ( true ) { ( con = null ) { configur connect return pool connect result = borrow connect ( now , con , usernam , password ) ; null should never return , wa previou impl . ( result = null ) return result ; } new connect ( size . get ( ) get pool properti ( ) . get max activ ( ) ) { atom duplic check ( size . add get ( 1 ) get pool properti ( ) . get max activ ( ) ) { we got here , two thread pass through first size . decrement get ( ) ; } els { creat connect , we re below limit return creat connect ( now , con , usernam , password ) ; } } end calcul wait time thi iter long max wait = wait ; pass wait time 1 , mean we should us pool properti valu ( wait = = 1 ) { max wait = ( get pool properti ( ) . get max wait ( ) = 0 ) long . max valu : get pool properti ( ) . get max wait ( ) ; } long timetowait = math . max ( 0 , max wait ( system . current time milli ( ) now ) ) ; waitcount . increment get ( ) ; try { retriev exist connect con = idl . poll ( timetowait , time unit . millisecond ) ; } catch ( interrupt except ex ) { clear flag , bail out thread . interrupt ( ) ; sqlexcept sx = new sqlexcept ( pool wait interrupt . ) ; sx . init caus ( ex ) ; throw sx ; } final { waitcount . decrement get ( ) ; } ( max wait = = 0 con = = null ) { wait , return we have ( jmx pool = null ) { jmx pool . notifi ( org . apach . tomcat . jdbc . pool . jmx . connect pool . pool empti , pool empti wait . ) ; } throw new pool exhaust except ( thread . current thread ( ) . get name ( ) wait : pool empti . unabl fetch connect , none avail busi . size ( ) us . ) ; } we didn t get connect , let see we time out ( con = = null ) { ( ( system . current time milli ( ) now ) = max wait ) { ( jmx pool = null ) { jmx pool . notifi ( org . apach . tomcat . jdbc . pool . jmx . connect pool . pool empti , pool empti timeout . ) ; } throw new pool exhaust except ( thread . current thread ( ) . get name ( ) timeout : pool empti . unabl fetch connect ( max wait 1000 ) second , none avail size : size . get ( ) ; busi : busi . size ( ) ; idl : idl . size ( ) ; lastwait : timetowait . ) ; } els { timeout , let try again continu ; } } } while }	protect close pool all disconnect all idl connect activ connect close upon { link java . sql . connect close close } method call underli connect instead return pool param forc true even close activ connect void close ( boolean forc ) { ar we alreadi close ( thi . close ) return ; prevent other thread from enter thi . close = true ; stop background thread ( pool cleaner = null ) { pool cleaner . stop run ( ) ; } releas all idl connect block queue pool connect pool = ( idl . size ( ) 0 ) idl : ( forc busi : idl ) ; while ( pool . size ( ) 0 ) { try { retriev next connect pool connect con = pool . poll ( 1000 , time unit . millisecond ) ; close retriev next , avail while ( con = null ) { close connect ( pool = = idl ) releas ( con ) ; els abandon ( con ) ; ( pool . size ( ) 0 ) { con = pool . poll ( 1000 , time unit . millisecond ) ; } els { break ; } } while } catch ( interrupt except ex ) { thread . interrupt ( ) ; } ( pool . size ( ) = = 0 forc pool = busi ) pool = busi ; } ( thi . get pool properti ( ) . jmx enabl ( ) ) thi . jmx pool = null ; pool properti . interceptor definit proxi = get pool properti ( ) . get jdbc interceptor arrai ( ) ; ( int i = 0 ; i proxi . length ; i ) { try { proxi i . get interceptor class ( ) . new instanc ( ) . pool close ( thi ) ; } catch ( except x ) { log . debug ( unabl inform interceptor pool closur . , x ) ; } } }	{ inherit doc } overrid public boolean get log valid error ( ) { return get pool properti ( ) . get log valid error ( ) ; }	{ inherit doc } overrid public boolean get log valid error ( ) { return thi . log valid error ; }	{ inherit doc } overrid public boolean get log valid error ( ) { return get pool properti ( ) . get log valid error ( ) ; }
remov specifi valv from pipelin associ thi contain , found ; otherwis , do noth . valv found remov , valv s code set contain ( null ) code method call implement code contain code . param valv valv remov overrid public void remov valv ( valv valv ) { valv current ; ( first = = valv ) { first = first . get next ( ) ; current = null ; } els { current = first ; } while ( current = null ) { ( current . get next ( ) = = valv ) { current . set next ( valv . get next ( ) ) ; break ; } current = current . get next ( ) ; } ( first = = basic ) first = null ; ( valv instanceof contain ) ( ( contain ) valv ) . set contain ( null ) ; stop thi valv necessari ( get state ( ) . avail ( ) ) { ( valv instanceof lifecycl ) { try { ( ( lifecycl ) valv ) . stop ( ) ; } catch ( lifecycl except e ) { log . error ( standard pipelin . remov valv : stop : , e ) ; } } } try { ( ( lifecycl ) valv ) . destroi ( ) ; } catch ( lifecycl except e ) { log . error ( standard pipelin . remov valv : destroi : , e ) ; } contain . fire contain event ( contain . remov valv event , valv ) ; }

{ inherit doc } overrid public boolean get us dispos connect facad ( ) { return get pool properti ( ) . get us dispos connect facad ( ) ; }	{ inherit doc } overrid public boolean get us dispos connect facad ( ) { return us dispos connect facad ; }	{ inherit doc } overrid public boolean get us dispos connect facad ( ) { return get pool properti ( ) . get us dispos connect facad ( ) ; }	public valid connect . param valid action action us . { link valid borrow } , { link valid idl } , { link valid init } { link valid return } param sql sql us dure valid . { link pool configur set init sql ( string ) } ha been call non null valu action { link valid init } init sql us valid . return true connect wa valid successfulli . return true even valid wa perform , when { link pool configur set valid interv ( long ) } ha been call posit valu . p fals valid fail . caller should close connect fals return sinc session could have been left unknown state dure initi . boolean valid ( int valid action , string sql ) { ( thi . discard ( ) ) { return fals ; } ( do valid ( valid action ) ) { valid requir , init sql prop set return true ; } don t bother valid alreadi have recent enough long now = system . current time milli ( ) ; ( valid action = valid init pool properti . get valid interv ( ) 0 ( now thi . last valid ) pool properti . get valid interv ( ) ) { return true ; } ( pool properti . get valid ( ) = null ) { ( pool properti . get valid ( ) . valid ( connect , valid action ) ) { thi . last valid = now ; return true ; } els { return fals ; } } string queri = sql ; ( valid action = = valid init pool properti . get init sql ( ) = null ) { queri = pool properti . get init sql ( ) ; } ( queri = = null ) { queri = pool properti . get valid queri ( ) ; } statement stmt = null ; try { stmt = connect . creat statement ( ) ; stmt . execut ( queri ) ; stmt . close ( ) ; thi . last valid = now ; return true ; } catch ( except ignor ) { ( log . debug enabl ( ) ) log . debug ( unabl valid object : , ignor ) ; ( stmt = null ) try { stmt . close ( ) ; } catch ( except ignore2 ) { noop } } return fals ; }
privat thread safe wai retriev connect from pool param wait time wait , overrid max wait from properti , set 1 you wish us max wait , 0 you wish wait time . return pool connect throw sqlexcept pool connect borrow connect ( int wait , string usernam , string password ) throw sqlexcept { ( close ( ) ) { throw new sqlexcept ( connect pool close . ) ; } end get current time stamp long now = system . current time milli ( ) ; see avail immedi pool connect con = idl . poll ( ) ; while ( true ) { ( con = null ) { configur connect return pool connect result = borrow connect ( now , con , usernam , password ) ; null should never return , wa previou impl . ( result = null ) return result ; } new connect ( size . get ( ) get pool properti ( ) . get max activ ( ) ) { atom duplic check ( size . add get ( 1 ) get pool properti ( ) . get max activ ( ) ) { we got here , two thread pass through first size . decrement get ( ) ; } els { creat connect , we re below limit return creat connect ( now , con , usernam , password ) ; } } end calcul wait time thi iter long max wait = wait ; pass wait time 1 , mean we should us pool properti valu ( wait = = 1 ) { max wait = ( get pool properti ( ) . get max wait ( ) = 0 ) long . max valu : get pool properti ( ) . get max wait ( ) ; } long timetowait = math . max ( 0 , max wait ( system . current time milli ( ) now ) ) ; waitcount . increment get ( ) ; try { retriev exist connect con = idl . poll ( timetowait , time unit . millisecond ) ; } catch ( interrupt except ex ) { clear flag , bail out thread . interrupt ( ) ; sqlexcept sx = new sqlexcept ( pool wait interrupt . ) ; sx . init caus ( ex ) ; throw sx ; } final { waitcount . decrement get ( ) ; } ( max wait = = 0 con = = null ) { wait , return we have throw new sqlexcept ( thread . current thread ( ) . get name ( ) wait : pool empti . unabl fetch connect , none avail busi . size ( ) us . ) ; } we didn t get connect , let see we time out ( con = = null ) { ( ( system . current time milli ( ) now ) = max wait ) { throw new sqlexcept ( thread . current thread ( ) . get name ( ) timeout : pool empti . unabl fetch connect ( max wait 1000 ) second , none avail size : size . get ( ) ; busi : busi . size ( ) ; idl : idl . size ( ) ; lastwait : timetowait . ) ; } els { timeout , let try again continu ; } } } while }	public static mbean notif info get default notif info ( ) { string type = new string { notifi init , notifi connect , notifi abandon , slow queri notif , fail queri notif , suspect abandon notif } ; string name = notif . class . get name ( ) ; string descript = connect pool error condit wa met . ; mbean notif info info = new mbean notif info ( type , name , descript ) ; return new mbean notif info { info } ; }
overrid protect string report fail queri ( string queri , object arg , string name , long start , throwabl t ) { string sql = super . report fail queri ( queri , arg , name , start , t ) ; ( thi . max queri 0 ) { long now = system . current time milli ( ) ; long delta = now start ; queri stat qs = thi . get queri stat ( sql ) ; qs . failur ( delta , now ) ; } return sql ; }	overrid protect string report slow queri ( string queri , object arg , string name , long start , long delta ) { string sql = super . report slow queri ( queri , arg , name , start , delta ) ; ( thi . max queri 0 ) { queri stat qs = thi . get queri stat ( sql ) ; qs . add ( delta , start ) ; } return sql ; }
public boolean process socket ( nio channel socket , socket statu statu , boolean dispatch ) { try { kei attach attach = ( kei attach ) socket . get attach ( fals ) ; get reset upon next reg attach . set comet notifi ( fals ) ; socket processor sc = processor cach . poll ( ) ; ( sc = = null ) sc = new socket processor ( socket , statu ) ; els sc . reset ( socket , statu ) ; ( dispatch get executor ( ) = null ) get executor ( ) . execut ( sc ) ; els sc . run ( ) ; } catch ( reject execut except rx ) { log . warn ( socket process request wa reject : socket , rx ) ; return fals ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; thi mean we got oom similar creat thread , pool queue ar full log . error ( sm . get string ( endpoint . process . fail ) , t ) ; return fals ; } return true ; }
protect save ani current activ session appropri persist mechan , ani . persist support , thi method return without do anyth . except ioexcept input output error occur void do unload ( ) throw ioexcept { ( log . debug enabl ( ) ) log . debug ( sm . get string ( standard manag . unload . debug ) ) ; ( session . empti ( ) ) { log . debug ( sm . get string ( standard manag . unload . nosess ) ) ; noth do return ; } open output stream specifi pathnam , ani file file = file ( ) ; ( file = = null ) return ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( standard manag . unload , pathnam ) ) ; file output stream fo = null ; object output stream oo = null ; try { fo = new file output stream ( file . get absolut path ( ) ) ; oo = new object output stream ( new buffer output stream ( fo ) ) ; } catch ( ioexcept e ) { log . error ( sm . get string ( standard manag . unload . ioe , e ) , e ) ; ( fo = null ) { try { fo . close ( ) ; } catch ( ioexcept f ) { ignor } } throw e ; } write number activ session , follow detail arrai list standard session list = new arrai list standard session ( ) ; synchron ( session ) { ( log . debug enabl ( ) ) log . debug ( unload session . size ( ) session ) ; try { oo . write object ( new integ ( session . size ( ) ) ) ; iter session element = session . valu ( ) . iter ( ) ; while ( element . ha next ( ) ) { standard session session = ( standard session ) element . next ( ) ; list . add ( session ) ; session . passiv ( ) ; session . write object data ( oo ) ; } } catch ( ioexcept e ) { log . error ( sm . get string ( standard manag . unload . ioe , e ) , e ) ; try { oo . close ( ) ; } catch ( ioexcept f ) { ignor } throw e ; } } flush close output stream try { oo . flush ( ) ; } final { try { oo . close ( ) ; } catch ( ioexcept f ) { ignor } } expir all session we just wrote ( log . debug enabl ( ) ) log . debug ( expir list . size ( ) persist session ) ; iter standard session expir = list . iter ( ) ; while ( expir . ha next ( ) ) { standard session session = expir . next ( ) ; try { session . expir ( fals ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } final { session . recycl ( ) ; } } ( log . debug enabl ( ) ) log . debug ( unload complet ) ; }
privat thread get thread ( ) { get current thread group thread group tg = thread . current thread ( ) . get thread group ( ) ; find root thread group while ( tg . get parent ( ) = null ) { tg = tg . get parent ( ) ; } int thread count guess = tg . activ count ( ) 50 ; thread thread = new thread thread count guess ; int thread count actual = tg . enumer ( thread ) ; make sure we don t miss ani thread while ( thread count actual = = thread count guess ) { thread count guess = 2 ; thread = new thread thread count guess ; note tg . enumer ( thread ) silent ignor ani thread can t fit arrai thread count actual = tg . enumer ( thread ) ; } return thread ; }	privat void check thread local leak ( ) { thread thread = get thread ( ) ; try { make field thread class store thread local access field thread local field = thread . class . get declar field ( thread local ) ; thread local field . set access ( true ) ; field inherit thread local field = thread . class . get declar field ( inherit thread local ) ; inherit thread local field . set access ( true ) ; make underli arrai thread load . thread local map . entri object access class tlm class = class . name ( java . lang . thread local thread local map ) ; field tabl field = tlm class . get declar field ( tabl ) ; tabl field . set access ( true ) ; ( int i = 0 ; i thread . length ; i ) { object thread local map ; ( thread i = null ) { clear first map thread local map = thread local field . get ( thread i ) ; check thread local map leak ( thread local map , tabl field ) ; clear second map thread local map = inherit thread local field . get ( thread i ) ; check thread local map leak ( thread local map , tabl field ) ; } } } catch ( secur except e ) { log . warn ( sm . get string ( webapp class loader . check thread local leak fail , context name ) , e ) ; } catch ( field except e ) { log . warn ( sm . get string ( webapp class loader . check thread local leak fail , context name ) , e ) ; } catch ( class found except e ) { log . warn ( sm . get string ( webapp class loader . check thread local leak fail , context name ) , e ) ; } catch ( illeg argument except e ) { log . warn ( sm . get string ( webapp class loader . check thread local leak fail , context name ) , e ) ; } catch ( illeg access except e ) { log . warn ( sm . get string ( webapp class loader . check thread local leak fail , context name ) , e ) ; } }	privat void clear refer stop timer thread ( thread thread ) { queue . clear ( ) try { field new task mai schedul field = thread . get class ( ) . get declar field ( new task mai schedul ) ; new task mai schedul field . set access ( true ) ; field queue field = thread . get class ( ) . get declar field ( queue ) ; queue field . set access ( true ) ; object queue = queue field . get ( thread ) ; method clear method = queue . get class ( ) . get declar method ( clear ) ; clear method . set access ( true ) ; synchron ( queue ) { new task mai schedul field . set boolean ( thread , fals ) ; clear method . invok ( queue ) ; case queue wa alreadi empti . queue . notifi ( ) ; } log . error ( sm . get string ( webapp class loader . warn timer thread , context name , thread . get name ( ) ) ) ; } catch ( except e ) { so mani thing go wrong abov . . . throwabl t = except util . unwrap invoc target except ( e ) ; except util . handl throwabl ( t ) ; log . warn ( sm . get string ( webapp class loader . stop timer thread fail , thread . get name ( ) , context name ) , t ) ; } }	thread . stop ( ) suppress warn ( deprec ) privat void clear refer thread ( ) { thread thread = get thread ( ) ; iter over set thread ( thread thread : thread ) { ( thread = null ) { class loader ccl = thread . get context class loader ( ) ; ( ccl = = thi ) { don t warn about thi thread ( thread = = thread . current thread ( ) ) { continu ; } jvm control thread thread group tg = thread . get thread group ( ) ; ( tg = null jvm thread group name . contain ( tg . get name ( ) ) ) { http client keep aliv thread ( clear refer http client keep aliv thread thread . get name ( ) . equal ( keep aliv timer ) ) { thread . set context class loader ( parent ) ; log . debug ( sm . get string ( webapp class loader . check thread http client ) ) ; } don t warn about remain jvm control thread continu ; } skip thread have alreadi di ( thread . aliv ( ) ) { continu ; } timer thread can stop safe so treat separ ( thread . get class ( ) . get name ( ) . equal ( java . util . timer thread ) clear refer stop timer thread ) { clear refer stop timer thread ( thread ) ; continu ; } ( request thread ( thread ) ) { log . error ( sm . get string ( webapp class loader . warn request thread , context name , thread . get name ( ) ) ) ; } els { log . error ( sm . get string ( webapp class loader . warn thread , context name , thread . get name ( ) ) ) ; } configur do so ( clear refer stop thread ) { continu ; } shut down executor try { field target field = thread . get class ( ) . get declar field ( target ) ; target field . set access ( true ) ; object target = target field . get ( thread ) ; ( target = null target . get class ( ) . get canon name ( ) . equal ( java . util . concurr . thread pool executor . worker ) ) { field executor field = target . get class ( ) . get declar field ( thi 0 ) ; executor field . set access ( true ) ; object executor = executor field . get ( target ) ; ( executor instanceof thread pool executor ) { ( ( thread pool executor ) executor ) . shutdown now ( ) ; } } } catch ( secur except e ) { log . warn ( sm . get string ( webapp class loader . stop thread fail , thread . get name ( ) , context name ) , e ) ; } catch ( field except e ) { log . warn ( sm . get string ( webapp class loader . stop thread fail , thread . get name ( ) , context name ) , e ) ; } catch ( illeg argument except e ) { log . warn ( sm . get string ( webapp class loader . stop thread fail , thread . get name ( ) , context name ) , e ) ; } catch ( illeg access except e ) { log . warn ( sm . get string ( webapp class loader . stop thread fail , thread . get name ( ) , context name ) , e ) ; } thi method deprec good reason . thi veri riski code onli option thi point . veri good reason app do thi clean up themselv . thread . stop ( ) ; } } } }
public void gener postambl ( ) { servlet writer out = thi . class buffer . get out ( ) ; gener all fragment method : ( int i = 0 ; i fragment . size ( ) ; i ) { fragment fragment = fragment . get ( i ) ; fragment . get gen buffer ( ) . adjust java line ( out . get java line ( ) 1 ) ; out . print multi ln ( fragment . get gen buffer ( ) . string ( ) ) ; } gener postambl : out . printil ( public void invok ( java . io . writer writer ) ) ; out . push indent ( ) ; out . printil ( throw javax . servlet . jsp . jsp except ) ; out . pop indent ( ) ; out . printil ( { ) ; out . push indent ( ) ; out . printil ( javax . servlet . jsp . jsp writer out = null ; ) ; out . printil ( ( writer = null ) { ) ; out . push indent ( ) ; out . printil ( out = thi . jsp context . push bodi ( writer ) ; ) ; out . pop indent ( ) ; out . printil ( } els { ) ; out . push indent ( ) ; out . printil ( out = thi . jsp context . get out ( ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; out . printil ( try { ) ; out . push indent ( ) ; out . printil ( thi . jsp context . get elcontext ( ) . put context ( javax . servlet . jsp . jsp context . class , thi . jsp context ) ; ) ; out . printil ( switch ( thi . discrimin ) { ) ; out . push indent ( ) ; ( int i = 0 ; i fragment . size ( ) ; i ) { out . printil ( case i : ) ; out . push indent ( ) ; out . printil ( invok i ( out ) ; ) ; out . printil ( break ; ) ; out . pop indent ( ) ; } out . pop indent ( ) ; switch out . printil ( } ) ; out . pop indent ( ) ; try out . printil ( } ) ; out . printil ( catch ( java . lang . throwabl e ) { ) ; out . push indent ( ) ; out . printil ( ( e instanceof javax . servlet . jsp . skip page except ) ) ; out . printil ( throw ( javax . servlet . jsp . skip page except ) e ; ) ; out . printil ( throw new javax . servlet . jsp . jsp except ( e ) ; ) ; out . pop indent ( ) ; catch out . printil ( } ) ; out . printil ( final { ) ; out . push indent ( ) ; out . printil ( ( writer = null ) { ) ; out . push indent ( ) ; out . printil ( thi . jsp context . pop bodi ( ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; out . pop indent ( ) ; final out . printil ( } ) ; out . pop indent ( ) ; invok method out . printil ( } ) ; out . pop indent ( ) ; helper class out . printil ( } ) ; out . pop indent ( ) ; }	overrid public void visit ( node . invok action n ) throw jasper except { n . set begin java line ( out . get java line ( ) ) ; copi virtual page scope tag file page scope invok page out . printil ( ( ( org . apach . jasper . runtim . jsp context wrapper ) thi . jsp context ) . sync befor invok ( ) ; ) ; string var reader attr = n . get text attribut ( var reader ) ; string var attr = n . get text attribut ( var ) ; ( var reader attr = null var attr = null ) { out . printil ( jspx sout = new java . io . string writer ( ) ; ) ; } els { out . printil ( jspx sout = null ; ) ; } invok fragment , unless fragment null out . printin ( ( ) ; out . print ( getter method ( n . get text attribut ( fragment ) ) ) ; out . println ( = null ) { ) ; out . push indent ( ) ; out . printin ( getter method ( n . get text attribut ( fragment ) ) ) ; out . println ( . invok ( jspx sout ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; store var reader appropri scope ( var reader attr = null var attr = null ) { string scope name = n . get text attribut ( scope ) ; out . printin ( jspx page context . set attribut ( ) ; ( var reader attr = null ) { out . print ( quot ( var reader attr ) ) ; out . print ( , new java . io . string reader ( jspx sout . string ( ) ) ) ; } els { out . print ( quot ( var attr ) ) ; out . print ( , jspx sout . string ( ) ) ; } ( scope name = null ) { out . print ( , ) ; out . print ( get scope constant ( scope name ) ) ; } out . println ( ) ; ) ; } restor el context out . printil ( jsp context . get elcontext ( ) . put context ( javax . servlet . jsp . jsp context . class , get jsp context ( ) ) ; ) ; n . set end java line ( out . get java line ( ) ) ; }
protect return princip associ given certif . princip get princip ( x509certif usercert ) { return ( get princip ( usercert . get subject dn ( ) . get name ( ) ) ) ; }	overrid protect void init intern ( ) throw lifecycl except { super . init intern ( ) ; we want logger soon possibl ( contain = null ) { thi . contain log = contain . get logger ( ) ; } }	protect string get realm suffix ( ) { return , realm path = get realm path ( ) ; }	public set valid certif chain flag . param valid new valid certif chain flag void set valid ( boolean valid ) { thi . valid = valid ; }
protect valid classnam . per srv . 9 . 7 . 2 , we must restrict load class from j2se ( java . ) most class servlet api ( javax . servlet . ) . should enhanc robust prevent number user error ( where older version servlet . jar would present web inf lib ) . param name class name return true name valid boolean valid ( string name ) { need care order here ( name = = null ) { can t load class without name return fals ; } ( name . start ( java . ) ) { must never load java . class return fals ; } ( name . start ( javax . servlet . jsp . jstl ) ) { ok web app packag jstl return true ; } ( name . start ( javax . servlet . ) ) { web app should never packag ani other servlet jsp class return fals ; } ( name . start ( javax . el ) ) { must never load javax . el . class return fals ; } assum everyth els ok return true ; }	protect check specifi jar file , return code true code doe contain ani trigger class . param jarfil jar file check except ioexcept input output error occur boolean valid jar file ( file jarfil ) throw ioexcept { ( trigger = = null ) return ( true ) ; jar file jar file = new jar file ( jarfil ) ; ( int i = 0 ; i trigger . length ; i ) { class clazz = null ; try { ( parent = null ) { clazz = parent . load class ( trigger i ) ; } els { clazz = class . name ( trigger i ) ; } } catch ( except e ) { clazz = null ; } ( clazz = = null ) continu ; string name = trigger i . replac ( . , ) . class ; ( log . debug enabl ( ) ) log . debug ( check name ) ; jar entri jar entri = jar file . get jar entri ( name ) ; ( jar entri = null ) { log . info ( valid jar file ( jarfil ) jar load . see servlet spec 2 . 3 , section 9 . 7 . 2 . offend class : name ) ; jar file . close ( ) ; return ( fals ) ; } } jar file . close ( ) ; return ( true ) ; }
protect retriev name object . param name name object look up param resolv link true , link resolv return object bound name except name except name except encount object lookup ( name name , boolean resolv link ) throw name except { remov empti part while ( ( name . empti ( ) ) ( name . get ( 0 ) . length ( ) = = 0 ) ) name = name . get suffix ( 1 ) ; ( name . empti ( ) ) { name empti , newli alloc name context return return new name context ( env , thi . name , bind ) ; } name entri entri = bind . get ( name . get ( 0 ) ) ; ( entri = = null ) { throw new name found except ( sm . get string ( name context . name bound , name . get ( 0 ) ) ) ; } ( name . size ( ) 1 ) { number subcontext . ( entri . type = name entri . context ) { throw new name except ( sm . get string ( name context . context expect ) ) ; } return ( ( context ) entri . valu ) . lookup ( name . get suffix ( 1 ) ) ; } els { ( ( resolv link ) ( entri . type = = name entri . link ref ) ) { string link = ( ( link ref ) entri . valu ) . get link name ( ) ; ( link . start ( . ) ) { link rel thi context return lookup ( link . substr ( 1 ) ) ; } els { return ( new initi context ( env ) ) . lookup ( link ) ; } } els ( entri . type = = name entri . refer ) { try { object obj = name manag . get object instanc ( entri . valu , name , thi , env ) ; ( entri . valu instanceof resourc ref ) { boolean singleton = boolean . pars boolean ( ( string ) ( ( resourc ref ) entri . valu ) . get ( singleton ) . get content ( ) ) ; ( singleton ) { entri . type = name entri . entri ; entri . valu = obj ; } } return obj ; } catch ( name except e ) { throw e ; } catch ( except e ) { log . warn ( sm . get string ( name context . fail resolv refer ) , e ) ; throw new name except ( e . get messag ( ) ) ; } } els { return entri . valu ; } } }	protect bind name object . all intermedi context target context ( name all termin atom compon name ) must alreadi exist . param name name bind ; mai empti param obj object bind ; possibl null param rebind true , perform rebind ( ie , overwrit ) except name alreadi bound except name alreadi bound except javax . name . directori . invalid attribut except object did suppli all mandatori attribut except name except name except encount void bind ( name name , object obj , boolean rebind ) throw name except { ( check writabl ( ) ) { return ; } while ( ( name . empti ( ) ) ( name . get ( 0 ) . length ( ) = = 0 ) ) name = name . get suffix ( 1 ) ; ( name . empti ( ) ) throw new name except ( sm . get string ( name context . invalid name ) ) ; name entri entri = bind . get ( name . get ( 0 ) ) ; ( name . size ( ) 1 ) { ( entri = = null ) { throw new name found except ( sm . get string ( name context . name bound , name . get ( 0 ) ) ) ; } ( entri . type = = name entri . context ) { ( rebind ) { ( ( context ) entri . valu ) . rebind ( name . get suffix ( 1 ) , obj ) ; } els { ( ( context ) entri . valu ) . bind ( name . get suffix ( 1 ) , obj ) ; } } els { throw new name except ( sm . get string ( name context . context expect ) ) ; } } els { ( ( rebind ) ( entri = null ) ) { throw new name alreadi bound except ( sm . get string ( name context . alreadi bound , name . get ( 0 ) ) ) ; } els { get type object wrap within new name entri object bind = name manag . get state bind ( obj , name , thi , env ) ; ( bind instanceof context ) { entri = new name entri ( name . get ( 0 ) , bind , name entri . context ) ; } els ( bind instanceof link ref ) { entri = new name entri ( name . get ( 0 ) , bind , name entri . link ref ) ; } els ( bind instanceof refer ) { entri = new name entri ( name . get ( 0 ) , bind , name entri . refer ) ; } els ( bind instanceof referenc ) { bind = ( ( referenc ) bind ) . get refer ( ) ; entri = new name entri ( name . get ( 0 ) , bind , name entri . refer ) ; } els { entri = new name entri ( name . get ( 0 ) , bind , name entri . entri ) ; } bind . put ( name . get ( 0 ) , entri ) ; } } }	destroi name context remov from namespac . ani attribut associ name ar also remov . intermedi context ar destroi . p thi method idempot . succe even termin atom name bound target context , throw name found except ani intermedi context do exist . feder name system , context from name system mai bound name anoth . can subsequ look up perform oper foreign context us composit name . howev , attempt destroi context us thi composit name fail context except , becaus foreign context subcontext context which bound . instead , us unbind ( ) remov bind foreign context . destroi foreign context requir destroi subcontext ( ) perform context from foreign context s nativ name system . param name name context destroi ; mai empti except name found except intermedi context doe exist except context except name bound doe name context , doe name context appropri type overrid public void destroi subcontext ( name name ) throw name except { ( check writabl ( ) ) { return ; } while ( ( name . empti ( ) ) ( name . get ( 0 ) . length ( ) = = 0 ) ) name = name . get suffix ( 1 ) ; ( name . empti ( ) ) throw new name except ( sm . get string ( name context . invalid name ) ) ; name entri entri = bind . get ( name . get ( 0 ) ) ; ( entri = = null ) { throw new name found except ( sm . get string ( name context . name bound , name . get ( 0 ) ) ) ; } ( name . size ( ) 1 ) { ( entri . type = = name entri . context ) { ( ( context ) entri . valu ) . destroi subcontext ( name . get suffix ( 1 ) ) ; } els { throw new name except ( sm . get string ( name context . context expect ) ) ; } } els { ( entri . type = = name entri . context ) { ( ( context ) entri . valu ) . close ( ) ; bind . remov ( name . get ( 0 ) ) ; } els { throw new context except ( sm . get string ( name context . context expect ) ) ; } } }	enumer name bound name context , along object bound them . param name name context list return enumer bind thi context . each element enumer type bind . except name except name except encount overrid public name enumer bind list bind ( string name ) throw name except { return list bind ( new composit name ( name ) ) ; }	unbind name object . remov termin atom name name from target context name all termin atom part name . p thi method idempot . succe even termin atom name bound target context , throw name found except ani intermedi context do exist . param name name bind ; mai empti except name found except intermedi context doe exist except name except name except encount overrid public void unbind ( name name ) throw name except { ( check writabl ( ) ) { return ; } while ( ( name . empti ( ) ) ( name . get ( 0 ) . length ( ) = = 0 ) ) name = name . get suffix ( 1 ) ; ( name . empti ( ) ) throw new name except ( sm . get string ( name context . invalid name ) ) ; name entri entri = bind . get ( name . get ( 0 ) ) ; ( entri = = null ) { throw new name found except ( sm . get string ( name context . name bound , name . get ( 0 ) ) ) ; } ( name . size ( ) 1 ) { ( entri . type = = name entri . context ) { ( ( context ) entri . valu ) . unbind ( name . get suffix ( 1 ) ) ; } els { throw new name except ( sm . get string ( name context . context expect ) ) ; } } els { bind . remov ( name . get ( 0 ) ) ; } }
public execut compil . throw jasper except error occur void execut ( ) throw jasper except { ( log . debug enabl ( ) ) { log . debug ( execut ( ) start page . size ( ) page . ) ; } try { ( uri root = = null ) { ( page . size ( ) = = 0 ) { throw new jasper except ( local . get messag ( jsp . error . jspc . miss target ) ) ; } string first jsp = page . get ( 0 ) ; file first jsp f = new file ( first jsp ) ; ( first jsp f . exist ( ) ) { throw new jasper except ( local . get messag ( jspc . error . file doe exist , first jsp ) ) ; } locat uri root ( first jsp f ) ; } ( uri root = = null ) { throw new jasper except ( local . get messag ( jsp . error . jspc . uriroot ) ) ; } ( context = = null ) { init servlet context ( ) ; } explicit page , we ll process all . jsp webapp ( page . size ( ) = = 0 ) { scan file ( new file ( uri root ) ) ; } file uri root f = new file ( uri root ) ; ( uri root f . exist ( ) uri root f . directori ( ) ) { throw new jasper except ( local . get messag ( jsp . error . jspc . uriroot dir ) ) ; } init web xml ( ) ; iter string iter = page . iter ( ) ; while ( iter . ha next ( ) ) { string nextjsp = iter . next ( ) . string ( ) ; file fjsp = new file ( nextjsp ) ; ( fjsp . absolut ( ) ) { fjsp = new file ( uri root f , nextjsp ) ; } ( fjsp . exist ( ) ) { ( log . warn enabl ( ) ) { log . warn ( local . get messag ( jspc . error . file doe exist , fjsp . string ( ) ) ) ; } continu ; } string s = fjsp . get absolut path ( ) ; ( s . start ( uri root ) ) { nextjsp = s . substr ( uri root . length ( ) ) ; } ( nextjsp . start ( . file . separ char ) ) { nextjsp = nextjsp . substr ( 2 ) ; } process file ( nextjsp ) ; } complet web xml ( ) ; ( add web xml map ) { merg web xml ( ) ; } } catch ( ioexcept ioe ) { throw new jasper except ( ioe ) ; } catch ( jasper except je ) { throwabl root caus = je ; while ( root caus instanceof jasper except ( ( jasper except ) root caus ) . get root caus ( ) = null ) { root caus = ( ( jasper except ) root caus ) . get root caus ( ) ; } ( root caus = je ) { root caus . print stack trace ( ) ; } throw je ; } final { ( loader = null ) { log factori . releas ( loader ) ; } } }
public perform block write us bytebuff data written code selector code paramet null , perform busi write could take up lot cpu cycl . param buf byte buffer buffer contain data , we write long code ( buf . ha remain ( ) = = true ) code param socket socket channel socket write data param write timeout long timeout thi write oper millisecond , 1 mean timeout return int return number byte written throw eofexcept write return 1 throw socket timeout except write time out throw ioexcept io except occur underli socket logic int write ( byte buffer buf , nio channel socket , long write timeout ) throw ioexcept { select kei kei = socket . get iochannel ( ) . kei ( socket . get poller ( ) . get selector ( ) ) ; ( kei = = null ) throw new ioexcept ( kei longer regist ) ; kei refer refer = new kei refer ( ) ; kei attach att = ( kei attach ) kei . attach ( ) ; int written = 0 ; boolean timedout = fals ; assum we can write int keycount = 1 ; start timeout timer long time = system . current time milli ( ) ; try { while ( ( timedout ) buf . ha remain ( ) ) { ( keycount 0 ) { onli write we were regist write write data int cnt = socket . write ( buf ) ; ( cnt = = 1 ) throw new eofexcept ( ) ; written = cnt ; ( cnt 0 ) { reset our timeout timer time = system . current time milli ( ) ; we successfulli wrote , try again without selector continu ; } } try { ( att . get write latch ( ) = = null att . get write latch ( ) . get count ( ) = = 0 ) att . start write latch ( 1 ) ; poller . add ( att , select kei . op write , refer ) ; att . await write latch ( write timeout , time unit . millisecond ) ; } catch ( interrupt except ignor ) { thread . interrupt ( ) ; } ( att . get write latch ( ) = null att . get write latch ( ) . get count ( ) 0 ) { we got interrupt , we haven t receiv notif from poller . keycount = 0 ; } els { latch countdown ha happen keycount = 1 ; att . reset write latch ( ) ; } ( write timeout 0 ( keycount = = 0 ) ) timedout = ( system . current time milli ( ) time ) = write timeout ; } while ( timedout ) throw new socket timeout except ( ) ; } final { poller . remov ( att , select kei . op write ) ; ( timedout refer . kei = null ) { poller . cancel kei ( refer . kei ) ; } refer . kei = null ; } return written ; }
protect open ( necessari ) return databas connect us thi access log valv . except sqlexcept databas error occur void open ( ) throw sqlexcept { do noth databas connect alreadi open ( conn = null ) { return ; } instanti our databas driver necessari ( driver = = null ) { try { class clazz = class . name ( driver name ) ; driver = ( driver ) clazz . new instanc ( ) ; } catch ( throwabl e ) { except util . handl throwabl ( e ) ; throw new sqlexcept ( e . get messag ( ) , e ) ; } } open new connect properti prop = new properti ( ) ; prop . put ( auto reconnect , true ) ; ( connect name = null ) { prop . put ( user , connect name ) ; } ( connect password = null ) { prop . put ( password , connect password ) ; } conn = driver . connect ( connect url , prop ) ; conn . set auto commit ( true ) ; string log pattern = pattern ; ( log pattern . equal ( common ) ) { ps = conn . prepar statement ( insert tabl name ( remot host field , user field , timestamp field , queri field , statu field , byte field ) valu ( , , , , , ) ) ; } els ( log pattern . equal ( combin ) ) { ps = conn . prepar statement ( insert tabl name ( remot host field , user field , timestamp field , queri field , statu field , byte field , virtual host field , method field , refer field , user agent field ) valu ( , , , , , , , , , ) ) ; } }
public boolean authent ( request request , http servlet respons respons ) throw ioexcept { princip princip = request . get user princip ( ) ; ( princip = null ) { probabl from anoth contain ha login config ( contain log . debug enabl ( ) ) contain log . debug ( alreadi authent princip . get name ( ) ) ; ( cach ) { creat new session ( onli necessari ) session session = request . get session intern ( true ) ; save inherit princip ( necessari ) thi session so can remain authent until expir session . set princip ( princip ) ; sso session cooki string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( sso id = null ) { ( contain log . debug enabl ( ) ) contain log . debug ( user authent exist sso ) ; associ session exist sso id necessari associ ( sso id , session ) ; } } user wa alreadi authent , without cooki return true ; } i . e . sc forbidden ( 403 statu ) gener later . ( contain log . debug enabl ( ) ) contain log . debug ( user authent without ani role ) ; return true ; }
static string get class name servic ( class loader tccl ) { input stream = null ; ( tccl = = null ) { = class loader . get system resourc stream ( servic resourc name ) ; } els { = tccl . get resourc stream ( servic resourc name ) ; } ( = null ) { string line = null ; buffer reader br = null ; try { br = new buffer reader ( new input stream reader ( , utf 8 ) ) ; line = br . read line ( ) ; ( line = null line . trim ( ) . length ( ) 0 ) { return line . trim ( ) ; } } catch ( unsupport encod except e ) { should never happen utf 8 doe ignor return null } catch ( ioexcept e ) { throw new elexcept ( fail read servic resourc name , e ) ; } final { try { ( br = null ) { br . close ( ) ; } } catch ( ioexcept ioe ) { ignor } try { . close ( ) ; } catch ( ioexcept ioe ) { ignor } } } return null ; }
protect void gener class ( string smap ) throw file found except , jasper except , except { long t1 = 0 ; ( log . debug enabl ( ) ) { t1 = system . current time milli ( ) ; } final string sourc file = ctxt . get servlet java file name ( ) ; final string output dir = ctxt . get option ( ) . get scratch dir ( ) . get absolut path ( ) ; string packag name = ctxt . get servlet packag name ( ) ; final string target class name = ( ( packag name . length ( ) = 0 ) ( packag name . ) : ) ctxt . get servlet class name ( ) ; final class loader class loader = ctxt . get jsp loader ( ) ; string file name = new string { sourc file } ; string class name = new string { target class name } ; final arrai list javac error detail problem list = new arrai list javac error detail ( ) ; class compil unit implement icompil unit { privat final string class name ; privat final string sourc file ; compil unit ( string sourc file , string class name ) { thi . class name = class name ; thi . sourc file = sourc file ; } overrid public char get file name ( ) { return sourc file . char arrai ( ) ; } overrid public char get content ( ) { char result = null ; file input stream = null ; reader reader = null ; try { = new file input stream ( sourc file ) ; reader = new buffer reader ( new input stream reader ( , ctxt . get option ( ) . get java encod ( ) ) ) ; char char = new char 8192 ; string builder buf = new string builder ( ) ; int count ; while ( ( count = reader . read ( char , 0 , char . length ) ) 0 ) { buf . append ( char , 0 , count ) ; } result = new char buf . length ( ) ; buf . get char ( 0 , result . length , result , 0 ) ; } catch ( ioexcept e ) { log . error ( compil error , e ) ; } final { ( reader = null ) { try { reader . close ( ) ; } catch ( ioexcept ioe ) { ignor } } ( = null ) { try { . close ( ) ; } catch ( ioexcept exc ) { ignor } } } return result ; } overrid public char get main type name ( ) { int dot = class name . last index ( . ) ; ( dot 0 ) { return class name . substr ( dot 1 ) . char arrai ( ) ; } return class name . char arrai ( ) ; } overrid public char get packag name ( ) { string token izer = new string token ( class name , . ) ; char result = new char izer . count token ( ) 1 ; ( int i = 0 ; i result . length ; i ) { string tok = izer . next token ( ) ; result i = tok . char arrai ( ) ; } return result ; } suppress warn ( unus ) } } } }
overrid public void lifecycl event ( lifecycl event event ) { ( lifecycl . befor stop event . equal ( event . get type ( ) ) ) { contain get stop , close all current connect iter request iter = comet request . iter ( ) ; while ( iter . ha next ( ) ) { request request = iter . next ( ) ; remov session track attribut isn t serializ requir . http session session = request . get session ( fals ) ; ( session = null ) { session . remov attribut ( comet request attribut ) ; } close comet connect try { comet event impl comet event = request . get event ( ) ; comet event . set event type ( comet event . event type . end ) ; comet event . set event sub type ( comet event . event sub type . webapp reload ) ; get next ( ) . event ( request , request . get respons ( ) , comet event ) ; comet event . close ( ) ; } catch ( except e ) { contain . get logger ( ) . warn ( sm . get string ( comet connect manag valv . event ) , e ) ; } } comet request . clear ( ) ; } }
protect param cn param war void deploi war ( context name cn , file war ) { check nest meta inf context . xml jar file jar = null ; jar entri entri = null ; input stream istream = null ; buffer output stream ostream = null ; file xml ; ( copi xml ) { xml = new file ( config base ( ) , cn . get base name ( ) . xml ) ; } els { xml = new file ( host . get app base file ( ) , cn . get base name ( ) meta inf context . xml ) ; } boolean xml war = fals ; ( deploi xml xml . exist ( ) ) { try { jar = new jar file ( war ) ; entri = jar . get jar entri ( constant . applic context xml ) ; ( entri = null ) { xml war = true ; } ( ( copi xml unpack war ) xml war ) { istream = jar . get input stream ( entri ) ; ostream = new buffer output stream ( new file output stream ( xml ) , 1024 ) ; byte buffer = new byte 1024 ; while ( true ) { int n = istream . read ( buffer ) ; ( n 0 ) { break ; } ostream . write ( buffer , 0 , n ) ; } ostream . flush ( ) ; ostream . close ( ) ; ostream = null ; istream . close ( ) ; istream = null ; } } catch ( ioexcept e ) { ignor } final { ( ostream = null ) { try { ostream . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } ostream = null ; } ( istream = null ) { try { istream . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } istream = null ; } entri = null ; ( jar = null ) { try { jar . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } jar = null ; } } } deploi applic deploi app = new deploi applic ( cn . get name ( ) ) ; deploi applic thi war file ( log . info enabl ( ) ) log . info ( sm . get string ( host config . deploi war , war . get absolut path ( ) ) ) ; context context = null ; try { ( deploi xml xml . exist ( ) ) { synchron ( digest ) { try { context = ( context ) digest . pars ( xml ) ; } catch ( except e ) { log . error ( sm . get string ( host config . deploi descriptor . error , war . get absolut path ( ) ) ) ; context = new fail context ( ) ; } final { digest . reset ( ) ; } } context . set config file ( xml . uri ( ) . url ( ) ) ; } els ( deploi xml xml war ) { synchron ( digest ) { try { jar = new jar file ( war ) ; entri = jar . get jar entri ( constant . applic context xml ) ; istream = jar . get input stream ( entri ) ; context = ( context ) digest . pars ( istream ) ; } catch ( except e ) { log . error ( sm . get string ( host config . deploi descriptor . error , war . get absolut path ( ) ) ) ; } final { ( context = = null ) { context = new fail context ( ) ; } context . set config file ( new url ( jar : war . uri ( ) . string ( ) constant . applic context xml ) ) ; ( istream = null ) { try { istream . close ( ) ; } catch ( ioexcept e ) { ignor } istream = null ; } entri = null ; ( jar = null ) { try { jar . close ( ) ; } catch ( ioexcept e ) { ignor } jar = null ; } digest . reset ( ) ; } } } els { context = ( context ) class . name ( context class ) . new instanc ( ) ; } popul redeploi resourc war file deploi app . redeploi resourc . put ( war . get absolut path ( ) , long . valu ( war . last modifi ( ) ) ) ; ( deploi xml xml . exist ( ) copi xml ) { deploi app . redeploi resourc . put ( xml . get absolut path ( ) , long . valu ( xml . last modifi ( ) ) ) ; } class clazz = class . name ( host . get config class ( ) ) ; lifecycl listen listen = ( lifecycl listen ) clazz . new instanc ( ) ; context . add lifecycl listen ( listen ) ; context . set name ( cn . get name ( ) ) ; context . set path ( cn . get path ( ) ) ; context . set webapp version ( cn . get version ( ) ) ; context . set doc base ( cn . get base name ( ) . war ) ; host . add child ( context ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( sm . get string ( host config . deploi war . error , war . get absolut path ( ) ) , t ) ; } final { start context ( unpack war context = null context . get doc base ( ) = null ) { file doc base = new file ( host . get app base file ( ) , cn . get base name ( ) ) ; deploi app . redeploi resourc . put ( doc base . get absolut path ( ) , long . valu ( doc base . last modifi ( ) ) ) ; add watch resourc ( deploi app , doc base . get absolut path ( ) , context ) ; ( deploi xml copi xml ( xml war xml . exist ( ) ) ) { deploi app . redeploi resourc . put ( xml . get absolut path ( ) , long . valu ( xml . last modifi ( ) ) ) ; } } els { add watch resourc ( deploi app , null , context ) ; } add global redeploi resourc ( which ar never delet ) end so thei don t interfer delet process add global redeploi resourc ( deploi app ) ; } deploi . put ( cn . get name ( ) , deploi app ) ; }
initi access thi user databas . except except ani except thrown dure open overrid public void open ( ) throw except { synchron ( group ) { synchron ( user ) { eras ani previou group user user . clear ( ) ; group . clear ( ) ; role . clear ( ) ; construct reader xml input file ( exist ) file file = new file ( pathnam ) ; ( file . absolut ( ) ) { file = new file ( system . get properti ( global . catalina base prop ) , pathnam ) ; } ( file . exist ( ) ) { return ; } file input stream fi = new file input stream ( file ) ; construct digest read xml input file digest digest = new digest ( ) ; try { digest . set featur ( http : apach . org xml featur allow java encod , true ) ; } catch ( except e ) { log . warn ( sm . get string ( memori user databas . xml featur encod ) , e ) ; } digest . add factori creat ( tomcat user group , new memori group creation factori ( thi ) , true ) ; digest . add factori creat ( tomcat user role , new memori role creation factori ( thi ) , true ) ; digest . add factori creat ( tomcat user user , new memori user creation factori ( thi ) , true ) ; pars xml input file load thi databas try { digest . pars ( fi ) ; fi . close ( ) ; } catch ( except e ) { try { fi . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } throw e ; } } } }
privat static string get class name base ( string urn ) { string builder base = new string builder ( org . apach . jsp . tag . meta . ) ; ( urn = null ) { base . append ( make java packag ( urn ) ) ; base . append ( . ) ; } return base . string ( ) ; }	public static get fulli qualifi class name tag handler correspond given tag file path . param path tag file path param err error dispatch return fulli qualifi class name tag handler correspond given tag file path string get tag handler class name ( string path , string urn , error dispatch err ) throw jasper except { string class name = null ; int begin = 0 ; int index ; index = path . last index ( . tag ) ; ( index = = 1 ) { err . jsp error ( jsp . error . tagfil . bad suffix , path ) ; } s tempt remov . tag suffix here , we can t . we remov , fulli qualifi class name thi tag could conflict packag name other tag . instanc , tag file web inf tag foo . tag would have fulli qualifi class name org . apach . jsp . tag . web . foo which would conflict packag name tag file web inf tag foo bar . tag index = path . index ( web inf tag ) ; ( index = 1 ) { class name = org . apach . jsp . tag . web . ; begin = index web inf tag . length ( ) ; } els { index = path . index ( meta inf tag ) ; ( index = 1 ) { class name = get class name base ( urn ) ; begin = index meta inf tag . length ( ) ; } els { err . jsp error ( jsp . error . tagfil . illeg path , path ) ; } } class name = make java packag ( path . substr ( begin ) ) ; return class name ; }
public start new server instanc . void load ( ) { long t1 = system . nano time ( ) ; init dir ( ) ; befor digest mai need init name ( ) ; creat execut our digest digest digest = creat start digest ( ) ; input sourc input sourc = null ; input stream input stream = null ; file file = null ; try { file = config file ( ) ; input stream = new file input stream ( file ) ; input sourc = new input sourc ( file : file . get absolut path ( ) ) ; } catch ( except e ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( catalina . config fail , file ) , e ) ; } } ( input stream = = null ) { try { input stream = get class ( ) . get class loader ( ) . get resourc stream ( get config file ( ) ) ; input sourc = new input sourc ( get class ( ) . get class loader ( ) . get resourc ( get config file ( ) ) . string ( ) ) ; } catch ( except e ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( catalina . config fail , get config file ( ) ) , e ) ; } } } altern : don t bother xml , just creat manual . ( input stream = = null ) { try { input stream = get class ( ) . get class loader ( ) . get resourc stream ( server emb . xml ) ; input sourc = new input sourc ( get class ( ) . get class loader ( ) . get resourc ( server emb . xml ) . string ( ) ) ; } catch ( except e ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( catalina . config fail , server emb . xml ) , e ) ; } } } ( input stream = = null input sourc = = null ) { ( file = = null ) { log . warn ( sm . get string ( catalina . config fail , get config file ( ) server emb . xml ) ) ; } els { log . warn ( sm . get string ( catalina . config fail , file . get absolut path ( ) ) ) ; ( file . exist ( ) file . can read ( ) ) { log . warn ( permiss incorrect , read permiss allow file . ) ; } } return ; } try { input sourc . set byte stream ( input stream ) ; digest . push ( thi ) ; digest . pars ( input sourc ) ; input stream . close ( ) ; } catch ( saxpars except spe ) { log . warn ( catalina . start us get config file ( ) : spe . get messag ( ) ) ; return ; } catch ( except e ) { log . warn ( catalina . start us get config file ( ) : , e ) ; return ; } get server ( ) . set catalina ( thi ) ; get server ( ) . set catalina home ( bootstrap . get catalina home file ( ) ) ; get server ( ) . set catalina base ( bootstrap . get catalina base file ( ) ) ; stream redirect init stream ( ) ; start new server try { get server ( ) . init ( ) ; } catch ( lifecycl except e ) { ( boolean . get boolean ( org . apach . catalina . startup . exit init failur ) ) { throw new java . lang . error ( e ) ; } els { log . error ( catalina . start , e ) ; } } long t2 = system . nano time ( ) ; ( log . info enabl ( ) ) { log . info ( initi process ( ( t2 t1 ) 1000000 ) ms ) ; } }	public void stop server ( string argument ) { ( argument = null ) { argument ( argument ) ; } server s = get server ( ) ; ( s = = null ) { creat execut our digest digest digest = creat stop digest ( ) ; digest . set class loader ( thread . current thread ( ) . get context class loader ( ) ) ; file file = config file ( ) ; try { input sourc = new input sourc ( file : file . get absolut path ( ) ) ; file input stream fi = new file input stream ( file ) ; . set byte stream ( fi ) ; digest . push ( thi ) ; digest . pars ( ) ; fi . close ( ) ; } catch ( except e ) { log . error ( catalina . stop : , e ) ; system . exit ( 1 ) ; } } els { server object alreadi present . must run servic try { s . stop ( ) ; } catch ( lifecycl except e ) { log . error ( catalina . stop : , e ) ; } return ; } stop exist server s = get server ( ) ; try { ( s . get port ( ) 0 ) { socket socket = new socket ( s . get address ( ) , s . get port ( ) ) ; output stream stream = socket . get output stream ( ) ; string shutdown = s . get shutdown ( ) ; ( int i = 0 ; i shutdown . length ( ) ; i ) { stream . write ( shutdown . char ( i ) ) ; } stream . flush ( ) ; stream . close ( ) ; socket . close ( ) ; } els { log . error ( sm . get string ( catalina . stop server ) ) ; system . exit ( 1 ) ; } } catch ( ioexcept e ) { log . error ( catalina . stop : , e ) ; system . exit ( 1 ) ; } }


protect void gener class ( string smap ) throw file found except , jasper except , except { long t1 = 0 ; ( log . debug enabl ( ) ) { t1 = system . current time milli ( ) ; } final string sourc file = ctxt . get servlet java file name ( ) ; final string output dir = ctxt . get option ( ) . get scratch dir ( ) . get absolut path ( ) ; string packag name = ctxt . get servlet packag name ( ) ; final string target class name = ( ( packag name . length ( ) = 0 ) ( packag name . ) : ) ctxt . get servlet class name ( ) ; final class loader class loader = ctxt . get jsp loader ( ) ; string file name = new string { sourc file } ; string class name = new string { target class name } ; final arrai list javac error detail problem list = new arrai list javac error detail ( ) ; class compil unit implement icompil unit { string class name ; string sourc file ; compil unit ( string sourc file , string class name ) { thi . class name = class name ; thi . sourc file = sourc file ; } overrid public char get file name ( ) { return sourc file . char arrai ( ) ; } overrid public char get content ( ) { char result = null ; file input stream = null ; reader reader = null ; try { = new file input stream ( sourc file ) ; reader = new buffer reader ( new input stream reader ( , ctxt . get option ( ) . get java encod ( ) ) ) ; char char = new char 8192 ; string builder buf = new string builder ( ) ; int count ; while ( ( count = reader . read ( char , 0 , char . length ) ) 0 ) { buf . append ( char , 0 , count ) ; } result = new char buf . length ( ) ; buf . get char ( 0 , result . length , result , 0 ) ; } catch ( ioexcept e ) { log . error ( compil error , e ) ; } final { ( reader = null ) { try { reader . close ( ) ; } catch ( ioexcept ioe ) { ignor } } ( = null ) { try { . close ( ) ; } catch ( ioexcept exc ) { ignor } } } return result ; } overrid public char get main type name ( ) { int dot = class name . last index ( . ) ; ( dot 0 ) { return class name . substr ( dot 1 ) . char arrai ( ) ; } return class name . char arrai ( ) ; } overrid public char get packag name ( ) { string token izer = new string token ( class name , . ) ; char result = new char izer . count token ( ) 1 ; ( int i = 0 ; i result . length ; i ) { string tok = izer . next token ( ) ; result i = tok . char arrai ( ) ; } return result ; } } final inam environ env = new inam environ ( ) { overrid public name environ answer find type ( char compound type name ) { string result = ; string sep = ; ( int i = 0 ; i compound type name . length ; i ) { result = sep ; result = new string ( compound type name i ) ; sep = . ; } return find type ( result ) ; } overrid public name environ answer find type ( char type name , char packag name ) { string result = ; string sep = ; ( int i = 0 ; i packag name . length ; i ) { result = sep ; result = new string ( packag name i ) ; sep = . ; } result = sep ; result = new string ( type name ) ; return find type ( result ) ; } } } } }
public static string dump bean ( mbean server mbean server , set object name name ) { string builder buf = new string builder ( ) ; iter object name = name . iter ( ) ; while ( . ha next ( ) ) { object name onam = . next ( ) ; buf . append ( name : ) ; buf . append ( onam . string ( ) ) ; buf . append ( crlf ) ; try { mbean info minfo = mbean server . get mbean info ( onam ) ; can t null i think string code = minfo . get class name ( ) ; ( org . apach . common . model . base model mbean . equal ( code ) ) { code = ( string ) mbean server . get attribut ( onam , model type ) ; } buf . append ( model type : ) ; buf . append ( code ) ; buf . append ( crlf ) ; mbean attribut info attr = minfo . get attribut ( ) ; object valu = null ; ( int i = 0 ; i attr . length ; i ) { ( attr i . readabl ( ) ) continu ; string att name = attr i . get name ( ) ; ( model type . equal ( att name ) ) continu ; ( att name . index ( = ) = 0 att name . index ( : ) = 0 att name . index ( ) = 0 ) { continu ; } try { valu = mbean server . get attribut ( onam , att name ) ; } catch ( jmruntim except rme ) { throwabl caus = rme . get caus ( ) ; ( caus instanceof unsupport oper except ) { log . debug ( error get attribut onam att name , rme ) ; } els { log . error ( error get attribut onam att name , rme ) ; } continu ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( error get attribut onam att name , t ) ; continu ; } ( valu = = null ) continu ; string valu string ; try { class c = valu . get class ( ) ; ( c . arrai ( ) ) { int len = arrai . get length ( valu ) ; string builder sb = new string builder ( arrai c . get compon type ( ) . get name ( ) length len ) ; ( len 0 ) { sb . append ( crlf ) ; } ( int j = 0 ; j len ; j ) { sb . append ( t ) ; object item = arrai . get ( valu , j ) ; ( item = = null ) { sb . append ( null valu ) ; } els { try { sb . append ( escap ( item . string ( ) ) ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; sb . append ( non stringabl valu ) ; } } ( j len 1 ) { sb . append ( crlf ) ; } } valu string = sb . string ( ) ; } els { valu string = escap ( valu . string ( ) ) ; } buf . append ( att name ) ; buf . append ( : ) ; buf . append ( valu string ) ; buf . append ( crlf ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } } } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } buf . append ( crlf ) ; } return buf . string ( ) ; }
protect scan web . xml file appli web applic merg them us rule defin spec . global web . xml file , where duplic configur , most specif level win . ie applic s web . xml take preced over host level global web . xml file . void web config ( ) { anyth everyth can overrid global host default . thi implement two part handl web fragment get ad after everyth els so everyth els take prioriti mark servlet overrid so sci configur can replac configur from default set web xml default = new hash set web xml ( ) ; default . add ( get default web xml fragment ( ) ) ; web xml web xml = creat web xml ( ) ; pars context level web . xml input sourc context web xml = get context web xml sourc ( ) ; pars web xml ( context web xml , web xml , fals ) ; ( web xml . get major version ( ) = 3 ) { order import here step 1 . identifi all jar packag applic jar have web fragment . xml pars thi point . map string , web xml fragment = process jar web fragment ( ) ; onli need process fragment annot metadata complet set web xml order fragment = null ; ( web xml . metadata complet ( ) ) { step 2 . order fragment . order fragment = web xml . order web fragment ( web xml , fragment ) ; step 3 . look servlet contain initi implement ( ok ) { process servlet contain initi ( order fragment ) ; } thi add ani match class type initi map ( ok ) { name enumer bind list bind = null ; try { try { list bind = context . get resourc ( ) . list bind ( web inf class ) ; } catch ( name found except ignor ) { safe ignor } while ( list bind = null list bind . ha more element ( ) ) { bind bind = list bind . next element ( ) ; ( bind . get object ( ) instanceof file dir context ) { file web inf class dir = new file ( ( ( file dir context ) bind . get object ( ) ) . get doc base ( ) ) ; process annot file ( web inf class dir , web xml ) ; } } } catch ( name except e ) { log . error ( sm . get string ( context config . webinf class url ) , e ) ; } } thi add ani match class type initi map ( ok ) { process annot ( order fragment ) ; } cach , us , longer requir so clear java class cach . clear ( ) ; file . ( ok ) { ok = web xml . merg ( order fragment ) ; } step 7 . appli global default have merg default befor jsp convers sinc default provid jsp servlet definit . web xml . merg ( default ) ; step 8 . convert explicitli mention jsp servlet ( ok ) { convert jsp ( web xml ) ; } step 9 . appli merg web . xml context ( ok ) { web xml . configur context ( context ) ; step 9a . make merg web . xml avail other compon , specif jasper , save those compon from have re gener . todo us servlet contain initi jasper string merg web xml = web xml . xml ( ) ; context . get servlet context ( ) . set attribut ( org . apach . tomcat . util . scan . constant . merg web xml , merg web xml ) ; ( context . get log effect web xml ( ) ) { log . info ( web . xml : n merg web xml ) ; } } } els { web xml . merg ( default ) ; web xml . configur context ( context ) ; } step 10 . look static resourc packag jar ( ok ) { spec doe defin order . us order jar follow remain jar set web xml resourc jar = new link hash set web xml ( ) ; ( order fragment = null ) { ( web xml fragment : order fragment ) { resourc jar . add ( fragment ) ; } } ( web xml fragment : fragment . valu ( ) ) { ( resourc jar . contain ( fragment ) ) { resourc jar . add ( fragment ) ; } } process resourc jar ( resourc jar ) ; see also standard context . resourc start ( ) web inf class meta inf resourc configur } complet ( web xml . metadata complet ( ) ) { context ( ok ) { ( map . entri servlet contain initi , set class >> entri : initi class map . entri set ( ) ) { ( entri . get valu ( ) . empti ( ) ) { context . add servlet contain initi ( entri . get kei ( ) , null ) ; } els { context . add servlet contain initi ( entri . get kei ( ) , entri . get valu ( ) ) ; } } } } } els { appli unmerg web . xml context web xml . merg ( default ) ; convert jsp ( web xml ) ; web xml . configur context ( context ) ; } }
i couldn t find suppress warn ( uncheck ) public static final enum coerc enum ( final object obj , suppress warn ( rawtyp ) class type ) { ( obj = = null . equal ( obj ) ) { return null ; } ( type . assign from ( obj . get class ( ) ) ) { return ( enum ) obj ; } ( ( obj instanceof string ) ) { throw new elexcept ( messag factori . get ( error . convert , obj , obj . get class ( ) , type ) ) ; } enum result ; try { result = enum . valu ( type , ( string ) obj ) ; } catch ( illeg argument except iae ) { throw new elexcept ( messag factori . get ( error . convert , obj , obj . get class ( ) , type ) ) ; } return result ; }
invok pre startup initi . thi us allow connector bind restrict port under unix oper environ . overrid protect void init intern ( ) throw lifecycl except { super . init intern ( ) ; regist global string cach note although cach global , ar multipl server present jvm ( mai happen when embed ) same cach regist under multipl name onam string cach = regist ( new string cach ( ) , type = string cach ) ; regist mbean factori mbean factori factori = new mbean factori ( ) ; factori . set contain ( thi ) ; onam mbean factori = regist ( factori , type = mbean factori ) ; regist name resourc global name resourc . init ( ) ; initi our defin servic ( int i = 0 ; i servic . length ; i ) { servic i . init ( ) ; } }
send action connector . param action code type action param param action paramet overrid public final void action ( action code action code , object param ) { ( action code = = action code . commit ) { ( respons . commit ( ) ) return ; valid write respons header try { prepar respons ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } try { flush ( fals ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . client flush ) { ( respons . commit ( ) ) { valid write respons header try { prepar respons ( ) ; } catch ( ioexcept e ) { set error flag error = true ; return ; } } try { flush ( true ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . disabl swallow input ) { todo : do swallow request input make sure we ar close connect error = true ; } els ( action code = = action code . close ) { transact client try { finish ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . req ssl attribut ) { ( certif . null ( ) ) { byte chunk cert data = certif . get byte chunk ( ) ; x509certif jsse cert = null ; byte arrai input stream bai = new byte arrai input stream ( cert data . get byte ( ) , cert data . get start ( ) , cert data . get length ( ) ) ; fill element . try { certif factori cf ; ( client cert provid = = null ) { cf = certif factori . get instanc ( x . 509 ) ; } els { cf = certif factori . get instanc ( x . 509 , client cert provid ) ; } while ( bai . avail ( ) 0 ) { x509certif cert = ( x509certif ) cf . gener certif ( bai ) ; ( jsse cert = = null ) { jsse cert = new x509certif 1 ; jsse cert 0 = cert ; } els { x509certif temp = new x509certif jsse cert . length 1 ; system . arraycopi ( jsse cert , 0 , temp , 0 , jsse cert . length ) ; temp jsse cert . length = cert ; jsse cert = temp ; } } } catch ( java . secur . cert . certif except e ) { get log ( ) . error ( sm . get string ( ajpprocessor . cert . fail ) , e ) ; return ; } catch ( provid except e ) { get log ( ) . error ( sm . get string ( ajpprocessor . cert . fail ) , e ) ; return ; } request . set attribut ( sslsupport . certif kei , jsse cert ) ; } } els ( action code = = action code . req host attribut ) { get remot host name us dn resolut ( request . remot host ( ) . null ( ) ) { try { request . remot host ( ) . set string ( inet address . get name ( request . remot addr ( ) . string ( ) ) . get host name ( ) ) ; } catch ( ioexcept iex ) { ignor } } } els ( action code = = action code . req local addr attribut ) { copi from local name now , which should simpli address request . local addr ( ) . set string ( request . local name ( ) . string ( ) ) ; } els ( action code = = action code . req set bodi replai ) { set given byte content byte chunk bc = ( byte chunk ) param ; int length = bc . get length ( ) ; bodi byte . set byte ( bc . get byte ( ) , bc . get start ( ) , length ) ; request . set content length ( length ) ; first = fals ; empti = fals ; replai = true ; } els ( action code = = action code . async start ) { async state machin . async start ( ( async context callback ) param ) ; } els ( action code = = action code . async dispatch ) { async state machin . async dispatch ( ) ; } els ( action code = = action code . async timeout ) { atom boolean result = ( atom boolean ) param ; result . set ( async state machin . async timeout ( ) ) ; } els ( action code = = action code . async run ) { async state machin . async run ( ( runnabl ) param ) ; } els ( action code = = action code . async error ) { async state machin . async error ( ) ; } els ( action code = = action code . async start ) { ( ( atom boolean ) param ) . set ( async state machin . async start ( ) ) ; } els ( action code = = action code . async dispatch ) { ( ( atom boolean ) param ) . set ( async state machin . async dispatch ( ) ) ; } els ( action code = = action code . async async ) { ( ( atom boolean ) param ) . set ( async state machin . async ( ) ) ; } els ( action code = = action code . async timingout ) { ( ( atom boolean ) param ) . set ( async state machin . async time out ( ) ) ; } els ( action code = = action code . upgrad ) { http connect onli . unsupport ajp . noop } els { action intern ( action code , param ) ; } }
public static string dump bean ( mbean server mbean server , set object name name ) { string builder buf = new string builder ( ) ; iter object name = name . iter ( ) ; while ( . ha next ( ) ) { object name onam = . next ( ) ; buf . append ( name : ) ; buf . append ( onam . string ( ) ) ; buf . append ( crlf ) ; try { mbean info minfo = mbean server . get mbean info ( onam ) ; can t null i think string code = minfo . get class name ( ) ; ( org . apach . common . model . base model mbean . equal ( code ) ) { code = ( string ) mbean server . get attribut ( onam , model type ) ; } buf . append ( model type : ) ; buf . append ( code ) ; buf . append ( crlf ) ; mbean attribut info attr = minfo . get attribut ( ) ; object valu = null ; ( int i = 0 ; i attr . length ; i ) { ( attr i . readabl ( ) ) continu ; string att name = attr i . get name ( ) ; ( model type . equal ( att name ) ) continu ; ( att name . index ( = ) = 0 att name . index ( : ) = 0 att name . index ( ) = 0 ) { continu ; } try { valu = mbean server . get attribut ( onam , att name ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( error get attribut onam att name , t ) ; continu ; } ( valu = = null ) continu ; string valu string ; try { class c = valu . get class ( ) ; ( c . arrai ( ) ) { int len = arrai . get length ( valu ) ; string builder sb = new string builder ( arrai c . get compon type ( ) . get name ( ) length len ) ; ( len 0 ) { sb . append ( crlf ) ; } ( int j = 0 ; j len ; j ) { sb . append ( t ) ; object item = arrai . get ( valu , j ) ; ( item = = null ) { sb . append ( null valu ) ; } els { try { sb . append ( escap ( item . string ( ) ) ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; sb . append ( non stringabl valu ) ; } } ( j len 1 ) { sb . append ( crlf ) ; } } valu string = sb . string ( ) ; } els { valu string = escap ( valu . string ( ) ) ; } buf . append ( att name ) ; buf . append ( : ) ; buf . append ( valu string ) ; buf . append ( crlf ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } } } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } buf . append ( crlf ) ; } return buf . string ( ) ; }
privat static find return error page instanc specifi except s class , error page instanc closest superclass which definit . associ error page instanc found , return code null code . param context context which search param except except which find error page error page find error page ( context context , throwabl except ) { ( except = = null ) { return ( null ) ; } class clazz = except . get class ( ) ; string name = clazz . get name ( ) ; while ( object . class . equal ( clazz ) ) { error page error page = context . find error page ( name ) ; ( error page = null ) { return ( error page ) ; } clazz = clazz . get superclass ( ) ; ( clazz = = null ) { break ; } name = clazz . get name ( ) ; } return ( null ) ; }
overrid protect void do get ( http servlet request req , http servlet respons resp ) throw servlet except , ioexcept { resp . set content type ( text plain ) ; resp . set charact encod ( iso 8859 1 ) ; writer w = resp . get writer ( ) ; wrap buffer necessari string us buffer str = req . get paramet ( us buffer ) ; ( us buffer str = null ) { w = new buffer writer ( w ) ; } long start = system . nano time ( ) ; ( int i = 0 ; i write count ; i ) { w . write ( write string ) ; } ( us buffer str = null ) { w . flush ( ) ; } long last run nano = system . nano time ( ) start ; system . out . println ( write length : write string . length ( ) , buffer : ( us buffer str = = null n : y ) , time : last run nano ns ) ; }	public void reset ( ) { writer wa us , mai byte convert ( got enc conv = null ) { conv . recycl ( ) ; } bb . recycl ( ) ; byte written = 0 ; char written = 0 ; got enc = fals ; enc = null ; initi = true ; }	public reset data buffer us writer stream flag ani statu header inform . param reset writer stream flag code true code intern code us writer code , code us output stream code , code charact encod set code flag should also reset except illeg state except respons ha alreadi been commit void reset buffer ( boolean reset writer stream flag ) { ( commit ( ) ) { throw new illeg state except ( sm . get string ( coyot respons . reset buffer . ) ) ; } output buffer . reset ( ) ; ( reset writer stream flag ) { us output stream = fals ; us writer = fals ; charact encod set = fals ; } }	public void test write speed ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; context root = tomcat . add context ( , temp dir ) ; ( int i = 1 ; i = write servlet . expect content length ; i = 10 ) { write servlet servlet = new write servlet ( i ) ; tomcat . add servlet ( root , servlet i , servlet ) ; root . add servlet map ( servlet i , servlet i ) ; } tomcat . start ( ) ; byte chunk bc = new byte chunk ( ) ; ( int i = 1 ; i = write servlet . expect content length ; i = 10 ) { int rc = get url ( http : localhost : get port ( ) servlet i , bc , null , null ) ; assert equal ( http servlet respons . sc ok , rc ) ; assert equal ( write servlet . expect content length , bc . get length ( ) ) ; bc . recycl ( ) ; rc = get url ( http : localhost : get port ( ) servlet i us buffer = y , bc , null , null ) ; assert equal ( http servlet respons . sc ok , rc ) ; assert equal ( write servlet . expect content length , bc . get length ( ) ) ; bc . recycl ( ) ; } }
disallow ani attempt set parent thi contain , sinc engin suppos top contain hierarchi . param contain propos parent contain overrid public void set parent ( contain contain ) { throw new illeg argument except ( sm . get string ( standard engin . parent ) ) ; }
protect class packag web applic , class each super class need check match { link handl type } annot match { link handl type } . param java class void check handl type ( java class java class ) { skip thi we can ( type initi map . size ( ) = = 0 ) { return ; } ( ( java class . get access flag ( ) org . apach . tomcat . util . bcel . constant . acc annot ) 0 ) { skip annot . return ; } choic load class string class name = java class . get class name ( ) ; class clazz = null ; try { clazz = context . get loader ( ) . get class loader ( ) . load class ( class name ) ; } catch ( class def found error e ) { log . debug ( sm . get string ( context config . invalid sci handl type , class name ) , e ) ; return ; } catch ( class found except e ) { log . debug ( sm . get string ( context config . invalid sci handl type , class name ) , e ) ; return ; } catch ( class format error e ) { log . debug ( sm . get string ( context config . invalid sci handl type , class name ) , e ) ; return ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . debug ( sm . get string ( context config . invalid sci handl type , class name ) , t ) ; return ; } ( clazz . annot ( ) ) { skip return ; } boolean match = fals ; ( map . entri class , set servlet contain initi >> entri : type initi map . entri set ( ) ) { ( entri . get kei ( ) . annot ( ) ) { annot entri annot entri = java class . get annot entri ( ) ; ( annot entri annot entri : annot entri ) { ( entri . get kei ( ) . get name ( ) . equal ( get class name ( annot entri . get annot type ( ) ) ) ) { match = true ; break ; } } } els ( entri . get kei ( ) . assign from ( clazz ) ) { match = true ; } ( match ) { ( servlet contain initi sci : entri . get valu ( ) ) { initi class map . get ( sci ) . add ( clazz ) ; } match = fals ; } } }	protect scan jar servlet contain initi implement . implement ad web fragment . xml prioriti order . void process servlet contain initi ( set web xml fragment ) { ( web xml fragment : fragment ) { url url = fragment . get url ( ) ; jar jar = null ; input stream = null ; servlet contain initi sci = null ; try { ( jar . equal ( url . get protocol ( ) ) ) { jar = jar factori . new instanc ( url ) ; = jar . get input stream ( sci locat ) ; } els ( file . equal ( url . get protocol ( ) ) ) { string path = url . get path ( ) ; file file = new file ( path , sci locat ) ; ( file . exist ( ) ) { = new file input stream ( file ) ; } } ( = null ) { sci = get servlet contain initi ( ) ; } } catch ( ioexcept ioe ) { log . error ( sm . get string ( context config . servlet contain initi fail , url , context . get name ( ) ) ) ; ok = fals ; return ; } final { ( = null ) { try { . close ( ) ; } catch ( ioexcept e ) { ignor } } ( jar = null ) { jar . close ( ) ; } } ( sci = = null ) { continu ; } initi class map . put ( sci , new hash set class >> ( ) ) ; handl type ht = sci . get class ( ) . get annot ( handl type . class ) ; ( ht = null ) { class type = ht . valu ( ) ; ( type = null ) { ( class type : type ) { set servlet contain initi sci = type initi map . get ( type ) ; ( sci = = null ) { sci = new hash set servlet contain initi ( ) ; type initi map . put ( type , sci ) ; } sci . add ( sci ) ; } } } } }	protect scan web . xml file appli web applic merg them us rule defin spec . global web . xml file , where duplic configur , most specif level win . ie applic s web . xml take preced over host level global web . xml file . void web config ( ) { anyth everyth can overrid global host default . thi implement two part handl web fragment get ad after everyth els so everyth els take prioriti mark servlet overrid so sci configur can replac configur from default set web xml default = new hash set web xml ( ) ; default . add ( get default web xml fragment ( ) ) ; web xml web xml = creat web xml ( ) ; pars context level web . xml input sourc context web xml = get context web xml sourc ( ) ; pars web xml ( context web xml , web xml , fals ) ; ( web xml . get major version ( ) = 3 ) { order import here step 1 . identifi all jar packag applic jar have web fragment . xml pars thi point . map string , web xml fragment = process jar web fragment ( ) ; onli need process fragment annot metadata complet set web xml order fragment = null ; ( web xml . metadata complet ( ) ) { step 2 . order fragment . order fragment = web xml . order web fragment ( web xml , fragment ) ; step 3 . look servlet contain initi implement ( ok ) { process servlet contain initi ( order fragment ) ; } thi add ani match class type initi map ( ok ) { name enumer bind list bind = null ; try { try { list bind = context . get resourc ( ) . list bind ( web inf class ) ; } catch ( name found except ignor ) { safe ignor } while ( list bind = null list bind . ha more element ( ) ) { bind bind = list bind . next element ( ) ; ( bind . get object ( ) instanceof file dir context ) { file web inf class dir = new file ( ( ( file dir context ) bind . get object ( ) ) . get doc base ( ) ) ; process annot file ( web inf class dir , web xml ) ; } } } catch ( name except e ) { log . error ( sm . get string ( context config . webinf class url ) , e ) ; } } thi add ani match class type initi map ( ok ) { process annot ( order fragment ) ; } file . ( ok ) { ok = web xml . merg ( order fragment ) ; } step 7 . appli global default have merg default befor jsp convers sinc default provid jsp servlet definit . web xml . merg ( default ) ; step 8 . convert explicitli mention jsp servlet ( ok ) { convert jsp ( web xml ) ; } step 9 . appli merg web . xml context ( ok ) { web xml . configur context ( context ) ; step 9a . make merg web . xml avail other compon , specif jasper , save those compon from have re gener . todo us servlet contain initi jasper string merg web xml = web xml . xml ( ) ; context . get servlet context ( ) . set attribut ( org . apach . tomcat . util . scan . constant . merg web xml , merg web xml ) ; ( context . get log effect web xml ( ) ) { log . info ( web . xml : n merg web xml ) ; } } } els { web xml . merg ( default ) ; web xml . configur context ( context ) ; } step 10 . look static resourc packag jar ( ok ) { spec doe defin order . us order jar follow remain jar set web xml resourc jar = new link hash set web xml ( ) ; ( order fragment = null ) { ( web xml fragment : order fragment ) { resourc jar . add ( fragment ) ; } } ( web xml fragment : fragment . valu ( ) ) { ( resourc jar . contain ( fragment ) ) { resourc jar . add ( fragment ) ; } } process resourc jar ( resourc jar ) ; see also standard context . resourc start ( ) web inf class meta inf resourc configur } complet ( web xml . metadata complet ( ) ) { context ( ok ) { ( map . entri servlet contain initi , set class >> entri : initi class map . entri set ( ) ) { ( entri . get valu ( ) . empti ( ) ) { context . add servlet contain initi ( entri . get kei ( ) , null ) ; } els { context . add servlet contain initi ( entri . get kei ( ) , entri . get valu ( ) ) ; } } } } } els { appli unmerg web . xml context web xml . merg ( default ) ; convert jsp ( web xml ) ; web xml . configur context ( context ) ; } }	public return class name . string get class name ( ) { return class name ; }	public long get host time stamp ( ) { return host time stamp ; }	test public void test check handl type ( ) throw except { context config config = new context config ( ) ; need context , loader class loader check handl type standard context context = new standard context ( ) ; context . set loader ( new tester loader ( ) ) ; config . context = context ; add sci ha interest ani type sci sci none = new sci ( ) ; config . initi class map . put ( sci none , new hash set class >> ( ) ) ; add sci interest servlet sci sci servlet = new sci ( ) ; config . initi class map . put ( sci servlet , new hash set class >> ( ) ) ; config . type initi map . put ( servlet . class , new hash set servlet contain initi ( ) ) ; config . type initi map . get ( servlet . class ) . add ( sci servlet ) ; add sci interest object i . e . everyth sci sci object = new sci ( ) ; config . initi class map . put ( sci object , new hash set class >> ( ) ) ; config . type initi map . put ( object . class , new hash set servlet contain initi ( ) ) ; config . type initi map . get ( object . class ) . add ( sci object ) ; scan servlet , filter , servlet , listen web xml ignor = new web xml ( ) ; file file = param class resourc ( org apach catalina startup param servlet ) ; config . process annot file ( file , ignor ) ; file = param class resourc ( org apach catalina startup param filter ) ; config . process annot file ( file , ignor ) ; file = param class resourc ( org apach catalina startup tester servlet ) ; config . process annot file ( file , ignor ) ; file = param class resourc ( org apach catalina startup test listen ) ; config . process annot file ( file , ignor ) ; check right number class were note handl assert equal ( 0 , config . initi class map . get ( sci none ) . size ( ) ) ; assert equal ( 2 , config . initi class map . get ( sci servlet ) . size ( ) ) ; assert equal ( 4 , config . initi class map . get ( sci object ) . size ( ) ) ; }
public recycl output buffer . thi should call when close connect . void recycl ( ) { recycl filter ( int i = 0 ; i = last activ filter ; i ) { activ filter i . recycl ( ) ; } recycl request object respons . recycl ( ) ; po = 0 ; last activ filter = 1 ; commit = fals ; finish = fals ; }
protect thi method write content specifi messag byte buffer output stream , without filter . thi method meant us write respons header . param bc data written void write ( byte chunk bc ) { write byte chunk output buffer int length = bc . get length ( ) ; system . arraycopi ( bc . get byte ( ) , bc . get start ( ) , buf , po , length ) ; po = po length ; }	protect thi method write content specifi char buffer output stream , without filter . thi method meant us write respons header . param cc data written void write ( char chunk cc ) { int start = cc . get start ( ) ; int end = cc . get end ( ) ; char cbuf = cc . get buffer ( ) ; ( int i = start ; i end ; i ) { char c = cbuf i ; stream properli encod output . ( ( ( c = 31 ) ( c = 9 ) ) c = = 127 c 255 ) { c = ; } buf po = ( byte ) c ; } }	protect thi method write content specifi string output stream , without filter . thi method meant us write respons header . param s data written void write ( string s ) { ( s = = null ) return ; from tomcat 3 . 3 http 1 . 0 connector int len = s . length ( ) ; ( int i = 0 ; i len ; i ) { char c = s . char ( i ) ; stream properli encod output . ( ( ( c = 31 ) ( c = 9 ) ) c = = 127 c 255 ) { c = ; } buf po = ( byte ) c ; } }	protect thi method print specifi integ output stream , without filter . thi method meant us write respons header . param i data written void write ( int i ) { write ( string . valu ( i ) ) ; }	public thi method write content specifi byte buffer output stream , without filter . thi method meant us write respons header . param b data written void write ( byte b ) { write byte chunk output buffer system . arraycopi ( b , 0 , buf , po , b . length ) ; po = po b . length ; }
protect scan web . xml file appli web applic merg them us rule defin spec . global web . xml file , where duplic configur , most specif level win . ie applic s web . xml take preced over host level global web . xml file . void web config ( ) { anyth everyth can overrid global host default . thi implement two part handl web fragment get ad after everyth els so everyth els take prioriti mark servlet overrid so sci configur can replac configur from default set web xml default = new hash set web xml ( ) ; default . add ( get default web xml fragment ( ) ) ; web xml web xml = creat web xml ( ) ; pars context level web . xml input sourc context web xml = get context web xml sourc ( ) ; pars web xml ( context web xml , web xml , fals ) ; ( web xml . get major version ( ) = 3 ) { order import here step 1 . identifi all jar packag applic jar have web fragment . xml pars thi point . map string , web xml fragment = process jar web fragment ( ) ; onli need process fragment annot metadata complet set web xml order fragment = null ; ( web xml . metadata complet ( ) ) { step 2 . order fragment . order fragment = web xml . order web fragment ( web xml , fragment ) ; step 3 . look servlet contain initi implement ( ok ) { process servlet contain initi ( order fragment ) ; } thi add ani match class type initi map ( ok ) { try { name enumer bind list bind = context . get resourc ( ) . list bind ( web inf class ) ; while ( list bind . ha more element ( ) ) { bind bind = list bind . next element ( ) ; ( bind . get object ( ) instanceof file dir context ) { file web inf class dir = new file ( ( ( file dir context ) bind . get object ( ) ) . get doc base ( ) ) ; process annot file ( web inf class dir , web xml ) ; } } } catch ( name except e ) { log . error ( sm . get string ( context config . webinf class url ) , e ) ; } } thi add ani match class type initi map ( ok ) { process annot ( order fragment ) ; } file . ( ok ) { ok = web xml . merg ( order fragment ) ; } step 7 . appli global default have merg default befor jsp convers sinc default provid jsp servlet definit . web xml . merg ( default ) ; step 8 . convert explicitli mention jsp servlet ( ok ) { convert jsp ( web xml ) ; } step 9 . appli merg web . xml context ( ok ) { web xml . configur context ( context ) ; step 9a . make merg web . xml avail other compon , specif jasper , save those compon from have re gener . todo us servlet contain initi jasper string merg web xml = web xml . xml ( ) ; context . get servlet context ( ) . set attribut ( org . apach . tomcat . util . scan . constant . merg web xml , merg web xml ) ; ( context . get log effect web xml ( ) ) { log . info ( web . xml : n merg web xml ) ; } } } els { web xml . merg ( default ) ; web xml . configur context ( context ) ; } step 10 . look static resourc packag jar ( ok ) { spec doe defin order . us order jar follow remain jar set web xml resourc jar = new link hash set web xml ( ) ; ( order fragment = null ) { ( web xml fragment : order fragment ) { resourc jar . add ( fragment ) ; } } ( web xml fragment : fragment . valu ( ) ) { ( resourc jar . contain ( fragment ) ) { resourc jar . add ( fragment ) ; } } process resourc jar ( resourc jar ) ; see also standard context . resourc start ( ) web inf class meta inf resourc configur } complet ( web xml . metadata complet ( ) ) { context ( ok ) { ( map . entri servlet contain initi , set class >> entri : initi class map . entri set ( ) ) { ( entri . get valu ( ) . empti ( ) ) { context . add servlet contain initi ( entri . get kei ( ) , null ) ; } els { context . add servlet contain initi ( entri . get kei ( ) , entri . get valu ( ) ) ; } } } } } els { appli unmerg web . xml context web xml . merg ( default ) ; convert jsp ( web xml ) ; web xml . configur context ( context ) ; } }
overrid public void bodi ( string namespac , string name , string text ) throw except { taglib uri rule . set duplic uri ( fals ) ; }
protect charset get digest charset ( ) throw unsupport encod except { ( digest encod = = null ) { return charset . default charset ( ) ; } els { return b2cconvert . get charset ( get digest encod ( ) ) ; } }	protect gener uniqu token . token gener accord follow pattern . nonc token = base64 ( md5 ( client ip : time stamp : privat kei ) ) . param request http servlet request string gener nonc ( request request ) { long current time = system . current time milli ( ) ; string ip time kei = request . get remot addr ( ) : current time : get kei ( ) ; byte buffer ; synchron ( md5helper ) { buffer = md5helper . digest ( ip time kei . get byte ( charset . default charset ( ) ) ) ; } return current time : md5encod . encod ( buffer ) ; }	protect check whether credenti present user match those retriev from directori . param context directori context param info user authent param credenti authent credenti except name except directori server error occur boolean compar credenti ( dir context context , user info , string credenti ) throw name except { ( info = = null credenti = = null ) return ( fals ) ; string password = info . get password ( ) ; ( password = = null ) return ( fals ) ; valid credenti specifi user ( contain log . trace enabl ( ) ) contain log . trace ( valid credenti ) ; boolean valid = fals ; ( ha messag digest ( ) ) { hex encod parent class . ( password . start ( { md5 } ) password . start ( { sha } ) ) { sync sinc super . digest ( ) doe thi same thing synchron ( thi ) { password = password . substr ( 5 ) ; md . reset ( ) ; md . updat ( credenti . get byte ( charset . default charset ( ) ) ) ; string digest password = base64 . encod ( md . digest ( ) ) ; valid = password . equal ( digest password ) ; } } els ( password . start ( { ssha } ) ) { sync sinc super . digest ( ) doe thi same thing synchron ( thi ) { password = password . substr ( 6 ) ; md . reset ( ) ; md . updat ( credenti . get byte ( charset . default charset ( ) ) ) ; decod store password . byte chunk pwbc = new byte chunk ( password . length ( ) ) ; try { pwbc . append ( password . get byte ( charset . default charset ( ) ) , 0 , password . length ( ) ) ; } catch ( ioexcept e ) { should never happen contain log . error ( could append password byte chunk : , e ) ; } char chunk decod = new char chunk ( ) ; base64 . decod ( pwbc , decod ) ; char pwarrai = decod . get buffer ( ) ; split decod password hash salt . final int saltpo = 20 ; byte hash = new byte saltpo ; ( int i = 0 ; i hash . length ; i ) { hash i = ( byte ) pwarrai i ; } byte salt = new byte pwarrai . length saltpo ; ( int i = 0 ; i salt . length ; i ) salt i = ( byte ) pwarrai i saltpo ; md . updat ( salt ) ; byte dp = md . digest ( ) ; valid = arrai . equal ( dp , hash ) ; } end synchron ( thi ) block } els { hex hash should compar case insensit valid = ( digest ( credenti ) . equal ignor case ( password ) ) ; } } els valid = ( digest ( credenti ) . equal ( password ) ) ; return ( valid ) ; }	protect synchron open new log file date specifi code date stamp code . void open ( ) { creat directori necessari file dir = new file ( directori ) ; ( dir . absolut ( ) ) { dir = new file ( system . get properti ( global . catalina base prop ) , directori ) ; } ( dir . mkdir ( ) dir . directori ( ) ) { log . error ( sm . get string ( access log valv . open dir fail , dir ) ) ; } open current log file file pathnam ; rotat need date stamp file name ( rotat ) { pathnam = new file ( dir . get absolut file ( ) , prefix date stamp suffix ) ; } els { pathnam = new file ( dir . get absolut file ( ) , prefix suffix ) ; } file parent = pathnam . get parent file ( ) ; ( parent . mkdir ( ) parent . directori ( ) ) { log . error ( sm . get string ( access log valv . open dir fail , parent ) ) ; } charset charset = null ; ( encod = null ) { try { charset = b2cconvert . get charset ( encod ) ; } catch ( unsupport encod except ex ) { log . error ( sm . get string ( access log valv . unsupport encod , encod ) , ex ) ; } } ( charset = = null ) { charset = charset . default charset ( ) ; } try { writer = new print writer ( new buffer writer ( new output stream writer ( new file output stream ( pathnam , true ) , charset ) , 128000 ) , fals ) ; current log file = pathnam ; } catch ( ioexcept e ) { writer = null ; current log file = null ; log . error ( sm . get string ( access log valv . open fail , pathnam ) , e ) ; } }	protect load entri cach . void cach load ( cach entri entri ) { string name = entri . name ; retriev miss info boolean exist = true ; retriev attribut ( entri . attribut = = null ) { try { attribut attribut = dir context . get attribut ( entri . name ) ; ( ( attribut instanceof resourc attribut ) ) { entri . attribut = new resourc attribut ( attribut ) ; } els { entri . attribut = ( resourc attribut ) attribut ; } } catch ( name except e ) { exist = fals ; } } retriev object ( ( exist ) ( entri . resourc = = null ) ( entri . context = = null ) ) { try { object object = dir context . lookup ( name ) ; ( object instanceof input stream ) { entri . resourc = new resourc ( ( input stream ) object ) ; } els ( object instanceof dir context ) { entri . context = ( dir context ) object ; } els ( object instanceof resourc ) { entri . resourc = ( resourc ) object ; } els { entri . resourc = new resourc ( new byte arrai input stream ( object . string ( ) . get byte ( charset . default charset ( ) ) ) ) ; } } catch ( name except e ) { exist = fals ; } } load object content ( ( exist ) ( entri . resourc = null ) ( entri . resourc . get content ( ) = = null ) ( entri . attribut . get content length ( ) = 0 ) ( entri . attribut . get content length ( ) ( cach object max size 1024 ) ) ) { int length = ( int ) entri . attribut . get content length ( ) ; entri size 1 resourc size kb , cach entri . size = ( entri . attribut . get content length ( ) 1024 ) ; input stream = null ; try { = entri . resourc . stream content ( ) ; int po = 0 ; byte b = new byte length ; while ( po length ) { int n = . read ( b , po , length po ) ; ( n 0 ) break ; po = po n ; } entri . resourc . set content ( b ) ; } catch ( ioexcept e ) { ignor } final { try { ( = null ) . close ( ) ; } catch ( ioexcept e ) { ignor } } } set exist flag entri . exist = exist ; set timestamp entri . timestamp = system . current time milli ( ) cach ttl ; add new entri cach synchron ( cach ) { check cach size , remov element too big ( ( cach . lookup ( name ) = = null ) cach . alloc ( entri . size ) ) { cach . load ( entri ) ; } } }	protect lock method . void do lock ( http servlet request req , http servlet respons resp ) throw servlet except , ioexcept { ( read onli ) { resp . send error ( webdav statu . sc forbidden ) ; return ; } ( lock ( req ) ) { resp . send error ( webdav statu . sc lock ) ; return ; } lock info lock = new lock info ( ) ; pars lock request pars depth header string depth str = req . get header ( depth ) ; ( depth str = = null ) { lock . depth = max depth ; } els { ( depth str . equal ( 0 ) ) { lock . depth = 0 ; } els { lock . depth = max depth ; } } pars timeout header int lock durat = default timeout ; string lock durat str = req . get header ( timeout ) ; ( lock durat str = = null ) { lock durat = default timeout ; } els { int comma po = lock durat str . index ( , ) ; multipl timeout , just us first ( comma po = 1 ) { lock durat str = lock durat str . substr ( 0 , comma po ) ; } ( lock durat str . start ( second ) ) { lock durat = ( new integ ( lock durat str . substr ( 7 ) ) ) . int valu ( ) ; } els { ( lock durat str . equal ignor case ( infin ) ) { lock durat = max timeout ; } els { try { lock durat = ( new integ ( lock durat str ) ) . int valu ( ) ; } catch ( number format except e ) { lock durat = max timeout ; } } } ( lock durat = = 0 ) { lock durat = default timeout ; } ( lock durat max timeout ) { lock durat = max timeout ; } } lock . expir = system . current time milli ( ) ( lock durat 1000 ) ; int lock request type = lock creation ; node lock info node = null ; document builder document builder = get document builder ( ) ; try { document document = document builder . pars ( new input sourc ( req . get input stream ( ) ) ) ; get root element document element root element = document . get document element ( ) ; lock info node = root element ; } catch ( ioexcept e ) { lock request type = lock refresh ; } catch ( saxexcept e ) { lock request type = lock refresh ; } ( lock info node = null ) { read lock inform node list child list = lock info node . get child node ( ) ; string writer str writer = null ; domwrit dom writer = null ; node lock scope node = null ; node lock type node = null ; node lock owner node = null ; ( int i = 0 ; i child list . get length ( ) ; i ) { node current node = child list . item ( i ) ; switch ( current node . get node type ( ) ) { case node . text node : break ; case node . element node : string node name = current node . get node name ( ) ; ( node name . end ( lockscop ) ) { lock scope node = current node ; } ( node name . end ( locktyp ) ) { lock type node = current node ; } ( node name . end ( owner ) ) { lock owner node = current node ; } break ; } } ( lock scope node = null ) { child list = lock scope node . get child node ( ) ; ( int i = 0 ; i child list . get length ( ) ; i ) { node current node = child list . item ( i ) ; switch ( current node . get node type ( ) ) { case node . text node : break ; case node . element node : string temp scope = current node . get node name ( ) ; ( temp scope . index ( : ) = 1 ) { lock . scope = temp scope . substr ( temp scope . index ( : ) 1 ) ; } els { lock . scope = temp scope ; } break ; } } ( lock . scope = = null ) { bad request resp . set statu ( webdav statu . sc bad request ) ; } } els { bad request resp . set statu ( webdav statu . sc bad request ) ; } ( lock type node = null ) { child list = lock type node . get child node ( ) ; ( int i = 0 ; i child list . get length ( ) ; i ) { node current node = child list . item ( i ) ; switch ( current node . get node type ( ) ) { case node . text node : break ; case node . element node : string temp type = current node . get node name ( ) ; ( temp type . index ( : ) = 1 ) { lock . type = temp type . substr ( temp type . index ( : ) 1 ) ; } els { lock . type = temp type ; } break ; } } ( lock . type = = null ) { bad request resp . set statu ( webdav statu . sc bad request ) ; } } els { bad request resp . set statu ( webdav statu . sc bad request ) ; } ( lock owner node = null ) { child list = lock owner node . get child node ( ) ; ( int i = 0 ; i child list . get length ( ) ; i ) { node current node = child list . item ( i ) ; switch ( current node . get node type ( ) ) { case node . text node : lock . owner = current node . get node valu ( ) ; break ; case node . element node : str writer = new string writer ( ) ; dom writer = new domwrit ( str writer , true ) ; dom writer . set qualifi name ( fals ) ; dom writer . print ( current node ) ; lock . owner = str writer . string ( ) ; break ; } } ( lock . owner = = null ) { bad request resp . set statu ( webdav statu . sc bad request ) ; } } els { lock . owner = ; } } string path = get rel path ( req ) ; lock . path = path ; boolean exist = true ; object object = null ; try { object = resourc . lookup ( path ) ; } catch ( name except e ) { exist = fals ; } enumer lock info lock list = null ; ( lock request type = = lock creation ) { gener lock id string lock token str = req . get servlet path ( ) lock . type lock . scope req . get user princip ( ) lock . depth lock . owner lock . token lock . expir system . current time milli ( ) secret ; string lock token = md5encod . encod ( md5helper . digest ( lock token str . get byte ( charset . default charset ( ) ) ) ) ; ( ( exist ) ( object instanceof dir context ) ( lock . depth = = max depth ) ) { lock collect ( all member resourc ) check child resourc thi collect alreadi lock vector string lock path = new vector string ( ) ; lock list = collect lock . element ( ) ; while ( lock list . ha more element ( ) ) { lock info current lock = lock list . next element ( ) ; ( current lock . ha expir ( ) ) { resourc lock . remov ( current lock . path ) ; continu ; } ( ( current lock . path . start ( lock . path ) ) ( ( current lock . exclus ( ) ) ( lock . exclus ( ) ) ) ) { child collect thi collect lock lock path . add element ( current lock . path ) ; } } lock list = resourc lock . element ( ) ; while ( lock list . ha more element ( ) ) { lock info current lock = lock list . next element ( ) ; ( current lock . ha expir ( ) ) { resourc lock . remov ( current lock . path ) ; continu ; } ( ( current lock . path . start ( lock . path ) ) ( ( current lock . exclus ( ) ) ( lock . exclus ( ) ) ) ) { child resourc thi collect lock lock path . add element ( current lock . path ) ; } } ( lock path . empti ( ) ) { child path wa lock we gener multistatu error report enumer string lock path list = lock path . element ( ) ; resp . set statu ( webdav statu . sc conflict ) ; xmlwriter gener xml = new xmlwriter ( ) ; gener xml . write xmlheader ( ) ; gener xml . write element ( d , default namespac , multistatu , xmlwriter . open ) ; while ( lock path list . ha more element ( ) ) { gener xml . write element ( d , respons , xmlwriter . open ) ; gener xml . write element ( d , href , xmlwriter . open ) ; gener xml . write text ( lock path list . next element ( ) ) ; gener xml . write element ( d , href , xmlwriter . close ) ; gener xml . write element ( d , statu , xmlwriter . open ) ; gener xml . write text ( http 1 . 1 webdav statu . sc lock webdav statu . get statu text ( webdav statu . sc lock ) ) ; gener xml . write element ( d , statu , xmlwriter . close ) ; gener xml . write element ( d , respons , xmlwriter . close ) ; } gener xml . write element ( d , multistatu , xmlwriter . close ) ; writer writer = resp . get writer ( ) ; writer . write ( gener xml . string ( ) ) ; writer . close ( ) ; return ; } boolean add lock = true ; check alreadi share lock thi path lock list = collect lock . element ( ) ; while ( lock list . ha more element ( ) ) { lock info current lock = lock list . next element ( ) ; ( current lock . path . equal ( lock . path ) ) { ( current lock . exclus ( ) ) { resp . send error ( webdav statu . sc lock ) ; return ; } els { ( lock . exclus ( ) ) { resp . send error ( webdav statu . sc lock ) ; return ; } } current lock . token . add element ( lock token ) ; lock = current lock ; add lock = fals ; } } ( add lock ) { lock . token . add element ( lock token ) ; collect lock . add element ( lock ) ; } } els { lock singl resourc retriev alreadi exist lock resourc lock info present lock = resourc lock . get ( lock . path ) ; ( present lock = null ) { ( ( present lock . exclus ( ) ) ( lock . exclus ( ) ) ) { either lock exclus , lock can t grant resp . send error ( webdav statu . sc precondit fail ) ; return ; } els { present lock . token . add element ( lock token ) ; lock = present lock ; } } els { lock . token . add element ( lock token ) ; resourc lock . put ( lock . path , lock ) ; check resourc exist thi path exist = true ; try { object = resourc . lookup ( path ) ; } catch ( name except e ) { exist = fals ; } ( exist ) { creat lock null resourc int slash = lock . path . last index ( ) ; string parent path = lock . path . substr ( 0 , slash ) ; vector string lock null = lock null resourc . get ( parent path ) ; ( lock null = = null ) { lock null = new vector string ( ) ; lock null resourc . put ( parent path , lock null ) ; } lock null . add element ( lock . path ) ; } add lock token header rfc 2518 8 . 10 . 1 onli do thi newli creat lock resp . add header ( lock token , opaquelocktoken : lock token ) ; } } } ( lock request type = = lock refresh ) { string header = req . get header ( ) ; ( header = = null ) header = ; check resourc lock lock info renew = resourc lock . get ( path ) ; enumer string token list = null ; ( renew = null ) { least token lock must have been given token list = renew . token . element ( ) ; while ( token list . ha more element ( ) ) { string token = token list . next element ( ) ; ( header . index ( token ) = 1 ) { renew . expir = lock . expir ; lock = renew ; } } } check inherit collect lock enumer lock info collect lock list = collect lock . element ( ) ; while ( collect lock list . ha more element ( ) ) { renew = collect lock list . next element ( ) ; ( path . equal ( renew . path ) ) { token list = renew . token . element ( ) ; while ( token list . ha more element ( ) ) { string token = token list . next element ( ) ; ( header . index ( token ) = 1 ) { renew . expir = lock . expir ; lock = renew ; } } } } } set statu , gener xml respons contain lock inform xmlwriter gener xml = new xmlwriter ( ) ; gener xml . write xmlheader ( ) ; gener xml . write element ( d , default namespac , prop , xmlwriter . open ) ; gener xml . write element ( d , lockdiscoveri , xmlwriter . open ) ; lock . xml ( gener xml ) ; gener xml . write element ( d , lockdiscoveri , xmlwriter . close ) ; gener xml . write element ( d , prop , xmlwriter . close ) ; resp . set statu ( webdav statu . sc ok ) ; resp . set content type ( text xml ; charset = utf 8 ) ; writer writer = resp . get writer ( ) ; writer . write ( gener xml . string ( ) ) ; writer . close ( ) ; }	public retriev name object cach entri , without ani except . param name name object look up return cach entri bound name cach entri lookup cach ( string name ) { cach entri entri = cach lookup ( name ) ; ( entri = = null ) { entri = new cach entri ( ) ; entri . name = name ; try { object object = dir context . lookup ( pars name ( name ) ) ; ( object instanceof input stream ) { entri . resourc = new resourc ( ( input stream ) object ) ; } els ( object instanceof dir context ) { entri . context = ( dir context ) object ; } els ( object instanceof resourc ) { entri . resourc = ( resourc ) object ; } els { entri . resourc = new resourc ( new byte arrai input stream ( object . string ( ) . get byte ( charset . default charset ( ) ) ) ) ; } attribut attribut = dir context . get attribut ( pars name ( name ) ) ; ( ( attribut instanceof resourc attribut ) ) { attribut = new resourc attribut ( attribut ) ; } entri . attribut = ( resourc attribut ) attribut ; } catch ( name except e ) { entri . exist = fals ; } } return entri ; }	retriev name object . param name name object look up return object bound name except name except name except encount overrid public object lookup ( string name ) throw name except { cach entri entri = cach lookup ( name ) ; ( entri = null ) { ( entri . exist ) { throw found except ; } ( entri . resourc = null ) { return entri . resourc ; } els { return entri . context ; } } object object = dir context . lookup ( pars name ( name ) ) ; ( object instanceof input stream ) { return new resourc ( ( input stream ) object ) ; } els ( object instanceof dir context ) { return object ; } els ( object instanceof resourc ) { return object ; } els { return new resourc ( new byte arrai input stream ( object . string ( ) . get byte ( charset . default charset ( ) ) ) ) ; } }	public princip authent ( realm realm ) { second md5 digest us calcul digest : md5 ( method : uri ) string a2 = method : uri ; byte buffer ; synchron ( md5helper ) { buffer = md5helper . digest ( a2 . get byte ( charset . default charset ( ) ) ) ; } string md5a2 = md5encod . encod ( buffer ) ; return realm . authent ( user name , respons , nonc , nc , cnonc , qop , realm name , md5a2 ) ; }	public boolean valid ( request request , string author , login config config ) { valid author credenti format ( author = = null ) { return fals ; } ( author . start ( digest ) ) { return fals ; } author = author . substr ( 7 ) . trim ( ) ; bugzilla 37132 : http : issu . apach . org bugzilla show bug . cgi id = 37132 string token = author . split ( , ( = ( : ) ) ) ; method = request . get method ( ) ; string opaqu = null ; ( int i = 0 ; i token . length ; i ) { string current token = token i ; ( current token . length ( ) = = 0 ) { continu ; } int equal sign = current token . index ( = ) ; ( equal sign 0 ) { return fals ; } string current token name = current token . substr ( 0 , equal sign ) . trim ( ) ; string current token valu = current token . substr ( equal sign 1 ) . trim ( ) ; ( usernam . equal ( current token name ) ) { user name = remov quot ( current token valu ) ; } ( realm . equal ( current token name ) ) { realm name = remov quot ( current token valu , true ) ; } ( nonc . equal ( current token name ) ) { nonc = remov quot ( current token valu ) ; } ( nc . equal ( current token name ) ) { nc = remov quot ( current token valu ) ; } ( cnonc . equal ( current token name ) ) { cnonc = remov quot ( current token valu ) ; } ( qop . equal ( current token name ) ) { qop = remov quot ( current token valu ) ; } ( uri . equal ( current token name ) ) { uri = remov quot ( current token valu ) ; } ( respons . equal ( current token name ) ) { respons = remov quot ( current token valu ) ; } ( opaqu . equal ( current token name ) ) { opaqu = remov quot ( current token valu ) ; } } ( ( user name = = null ) ( realm name = = null ) ( nonc = = null ) ( uri = = null ) ( respons = = null ) ) { return fals ; } valid uri should match request line sent client ( valid uri ) { string uri queri ; string queri = request . get queri string ( ) ; ( queri = = null ) { uri queri = request . get request uri ( ) ; } els { uri queri = request . get request uri ( ) queri ; } ( uri . equal ( uri queri ) ) { return fals ; } } valid realm name string lc realm = config . get realm name ( ) ; ( lc realm = = null ) { lc realm = realm name ; } ( lc realm . equal ( realm name ) ) { return fals ; } valid opaqu string ( thi . opaqu . equal ( opaqu ) ) { return fals ; } valid nonc int i = nonc . index ( : ) ; ( i 0 ( i 1 ) = = nonc . length ( ) ) { return fals ; } long nonc time ; try { nonc time = long . pars long ( nonc . substr ( 0 , i ) ) ; } catch ( number format except nfe ) { return fals ; } string md5client ip time kei = nonc . substr ( i 1 ) ; long current time = system . current time milli ( ) ; ( ( current time nonc time ) nonc valid ) { nonc stale = true ; return fals ; } string server ip time kei = request . get remot addr ( ) : nonc time : kei ; byte buffer = null ; synchron ( md5helper ) { buffer = md5helper . digest ( server ip time kei . get byte ( charset . default charset ( ) ) ) ; } string md5server ip time kei = md5encod . encod ( buffer ) ; ( md5server ip time kei . equal ( md5client ip time kei ) ) { return fals ; } valid qop ( qop = null qop . equal ( qop ) ) { return fals ; } check presenc nc nonc consist presenc qop ( qop = = null ) { ( cnonc = null nc = null ) { return fals ; } } els { ( cnonc = = null nc = = null ) { return fals ; } ( nc . length ( ) = 8 ) { return fals ; } long count ; try { count = long . pars long ( nc , 16 ) ; } catch ( number format except nfe ) { return fals ; } nonc info info ; synchron ( cnonc ) { info = cnonc . get ( cnonc ) ; } ( info = = null ) { info = new nonc info ( ) ; } els { ( count = info . get count ( ) ) { return fals ; } } info . set count ( count ) ; info . set timestamp ( current time ) ; synchron ( cnonc ) { cnonc . put ( cnonc , info ) ; } } return true ; }	public static decod return specifi url encod string . param str url encod string param enc encod us ; null , default encod us . unsupport encod specifi null return param queri thi queri string process except illeg argument except charact follow valid 2 digit hexadecim number string urldecod ( string str , string enc , boolean queri ) { ( str = = null ) return ( null ) ; us specifi encod extract byte out given string so encod lost . encod specifi , let us platform default byte byte = null ; try { ( enc = = null ) { byte = str . get byte ( charset . default charset ( ) ) ; } els { byte = str . get byte ( b2cconvert . get charset ( enc ) ) ; } } catch ( unsupport encod except uee ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( request util . url decod . uee , enc ) , uee ) ; } } return urldecod ( byte , enc , queri ) ; }	public static void instal smap ( string smap ) throw ioexcept { ( smap = = null ) { return ; } ( int i = 0 ; i smap . length ; i = 2 ) { file out servlet = new file ( smap i ) ; sdeinstal . instal ( out servlet , smap i 1 . get byte ( charset . default charset ( ) ) ) ; } }	public execut specifi command , base configur properti . input stream close upon complet thi task , whether wa execut successfulli . param command command execut param istream input stream includ http put , ani param content type content type specifi input , ani param content length content length specifi input , ani except build except error occur void execut ( string command , input stream istream , string content type , int content length ) throw build except { urlconnect conn = null ; input stream reader reader = null ; try { creat connect thi command conn = ( new url ( url command ) ) . open connect ( ) ; http urlconnect hconn = ( http urlconnect ) conn ; set up standard connect characterist hconn . set allow user interact ( fals ) ; hconn . set do input ( true ) ; hconn . set us cach ( fals ) ; ( istream = null ) { hconn . set do output ( true ) ; hconn . set request method ( put ) ; ( content type = null ) { hconn . set request properti ( content type , content type ) ; } ( content length = 0 ) { hconn . set request properti ( content length , content length ) ; hconn . set fix length stream mode ( content length ) ; } } els { hconn . set do output ( fals ) ; hconn . set request method ( get ) ; } hconn . set request properti ( user agent , catalina ant task 1 . 0 ) ; set up author header our credenti string input = usernam : password ; string output = base64 . encod ( input . get byte ( charset . default charset ( ) ) ) ; hconn . set request properti ( author , basic output ) ; establish connect server hconn . connect ( ) ; send request data ( ani ) ( istream = null ) { buffer output stream ostream = new buffer output stream ( hconn . get output stream ( ) , 1024 ) ; byte buffer = new byte 1024 ; while ( true ) { int n = istream . read ( buffer ) ; ( n 0 ) { break ; } ostream . write ( buffer , 0 , n ) ; } ostream . flush ( ) ; ostream . close ( ) ; istream . close ( ) ; } process respons messag reader = new input stream reader ( hconn . get input stream ( ) , charset ) ; string builder buff = new string builder ( ) ; string error = null ; int msg prioriti = project . msg info ; boolean first = true ; while ( true ) { int ch = reader . read ( ) ; ( ch 0 ) { break ; } els ( ( ch = = r ) ( ch = = n ) ) { produc blank line ( buff . length ( ) 0 ) { string line = buff . string ( ) ; buff . set length ( 0 ) ; ( first ) { ( line . start ( ok ) ) { error = line ; msg prioriti = project . msg err ; } first = fals ; } handl output ( line , msg prioriti ) ; } } els { buff . append ( ( char ) ch ) ; } } ( buff . length ( ) 0 ) { handl output ( buff . string ( ) , msg prioriti ) ; } ( error = null fail error ( ) ) { error line log twice throw new build except ( error ) ; } } catch ( except e ) { ( fail error ( ) ) { throw new build except ( e ) ; } els { handl error output ( e . get messag ( ) ) ; } } final { close redirector ( ) ; ( reader = null ) { try { reader . close ( ) ; } catch ( ioexcept ioe ) { ignor } reader = null ; } ( istream = null ) { try { istream . close ( ) ; } catch ( ioexcept ioe ) { ignor } } } }	overrid public void invok ( request request , respons respons ) throw ioexcept , servlet except { mod header convert n so we have rebuild client certif string strcert0 = myget header ( request , ssl client cert ) ; ( strcert0 = null strcert0 . length ( ) 28 ) { string strcert1 = strcert0 . replac ( , n ) ; string strcert2 = strcert1 . substr ( 28 , strcert1 . length ( ) 26 ) ; string strcert3 = begin certif n ; string strcert4 = strcert3 . concat ( strcert2 ) ; string strcert = strcert4 . concat ( n end certif n ) ; byte arrai input stream bai = new byte arrai input stream ( strcert . get byte ( utf 8 ) ) ; byte arrai input stream bai = new byte arrai input stream ( strcert . get byte ( charset . default charset ( ) ) ) ; x509certif jsse cert = null ; string provid name = ( string ) request . get connector ( ) . get properti ( client cert provid ) ; try { certif factori cf ; ( provid name = = null ) { cf = certif factori . get instanc ( x . 509 ) ; } els { cf = certif factori . get instanc ( x . 509 , provid name ) ; } x509certif cert = ( x509certif ) cf . gener certif ( bai ) ; jsse cert = new x509certif 1 ; jsse cert 0 = cert ; } catch ( java . secur . cert . certif except e ) { log . warn ( sm . get string ( ssl valv . cert error , strcert ) , e ) ; } catch ( provid except e ) { log . error ( sm . get string ( ssl valv . invalid provid , provid name ) , e ) ; } request . set attribut ( global . certif attr , jsse cert ) ; } strcert0 = myget header ( request , ssl cipher ) ; ( strcert0 = null ) { request . set attribut ( global . cipher suit attr , strcert0 ) ; } strcert0 = myget header ( request , ssl session id ) ; ( strcert0 = null ) { request . set attribut ( global . ssl session id attr , strcert0 ) ; } strcert0 = myget header ( request , ssl cipher usekeys ) ; ( strcert0 = null ) { request . set attribut ( global . kei size attr , integ . valu ( strcert0 ) ) ; } get next ( ) . invok ( request , respons ) ; }	public do char byte convers . void byte ( ) { ( byte c . null ( ) ) { type = t byte ; return ; } string ( ) ; type = t byte ; byte bb = str valu . get byte ( charset . default charset ( ) ) ; byte c . set byte ( bb , 0 , bb . length ) ; }
privat set appropri context attribut our class path . thi requir onli becaus jasper depend . void set class path ( ) { valid our current state inform ( ( contain instanceof context ) ) return ; servlet context servlet context = ( ( context ) contain ) . get servlet context ( ) ; ( servlet context = = null ) return ; string builder classpath = new string builder ( ) ; assembl class path inform from our class loader chain class loader loader = get class loader ( ) ; int n = 0 ; while ( loader = null ) { ( ( loader instanceof urlclass loader ) ) { string cp = get classpath ( loader ) ; ( cp = = null ) { log . info ( unknown loader loader loader . get class ( ) ) ; } els { ( n 0 ) classpath . append ( file . path separ ) ; classpath . append ( cp ) ; n ; } break ; continu ; } url repositori = ( ( urlclass loader ) loader ) . get url ( ) ; ( int i = 0 ; i repositori . length ; i ) { string repositori = repositori i . string ( ) ; ( repositori . start ( file : ) ) repositori = repositori . substr ( 7 ) ; } } }
public determin type support { link jmxproxi servlet } . param type type check return alwai return code true code boolean support ( string type ) { return true ; }	process get request specifi resourc . param request servlet request we ar process param respons servlet respons we ar creat except ioexcept input output error occur except servlet except servlet specifi error occur overrid public void do get ( http servlet request request , http servlet respons respons ) throw ioexcept , servlet except { respons . set content type ( text plain ) ; print writer writer = respons . get writer ( ) ; ( m bean server = = null ) { writer . println ( error mbean server ) ; return ; } string qry = request . get paramet ( set ) ; ( qry = null ) { string name = request . get paramet ( att ) ; string val = request . get paramet ( val ) ; set attribut ( writer , qry , name , val ) ; return ; } qry = request . get paramet ( get ) ; ( qry = null ) { string name = request . get paramet ( att ) ; get attribut ( writer , qry , name ) ; return ; } qry = request . get paramet ( qry ) ; ( qry = = null ) { qry = : ; } list bean ( writer , qry ) ; }	public void get attribut ( print writer writer , string onam str , string att ) { try { object name onam = new object name ( onam str ) ; object valu = m bean server . get attribut ( onam , att ) ; writer . println ( ok attribut get onam str att = mbean dumper . escap ( valu . string ( ) ) ) ; } catch ( except ex ) { writer . println ( error ex . string ( ) ) ; } }	public void list bean ( print writer writer , string qry ) { set object name name = null ; try { name = m bean server . queri name ( new object name ( qry ) , null ) ; writer . println ( ok number result : name . size ( ) ) ; writer . println ( ) ; } catch ( except e ) { writer . println ( error e . string ( ) ) ; return ; } string dump = mbean dumper . dump bean ( m bean server , name ) ; writer . print ( dump ) ; }	public void set attribut ( print writer writer , string onam str , string att , string val ) { try { object name onam = new object name ( onam str ) ; string type = registri . get type ( onam , att ) ; object valu obj = registri . convert valu ( type , val ) ; m bean server . set attribut ( onam , new attribut ( att , valu obj ) ) ; writer . println ( ok attribut set ) ; } catch ( except ex ) { writer . println ( error ex . string ( ) ) ; } }
privat web xml get default web xml fragment ( ) { host should never null host host = ( host ) context . get parent ( ) ; default web xml cach entri entri = host web xml cach . get ( host ) ; input sourc global web xml = get global web xml sourc ( ) ; input sourc host web xml = get host web xml sourc ( ) ; long global time stamp = 0 ; long host time stamp = 0 ; ( global web xml = null ) { try { file f = new file ( new uri ( global web xml . get system id ( ) ) ) ; global time stamp = f . last modifi ( ) ; } catch ( urisyntax except e ) { global time stamp = 1 ; } } ( host web xml = null ) { try { file f = new file ( new uri ( host web xml . get system id ( ) ) ) ; host time stamp = f . last modifi ( ) ; } catch ( urisyntax except e ) { host time stamp = 1 ; } } ( entri = null entri . get global time stamp ( ) = = global time stamp entri . get host time stamp ( ) = = host time stamp ) { return entri . get web xml ( ) ; } alreadi held host anoth thread synchron ( host . get pipelin ( ) ) { entri = host web xml cach . get ( host ) ; ( entri = null entri . get global time stamp ( ) = = global time stamp entri . get host time stamp ( ) = = host time stamp ) { return entri . get web xml ( ) ; } web xml web xml default fragment = creat web xml ( ) ; web xml default fragment . set overrid ( true ) ; set distribut els everi app prevent from distribut when default fragment merg main web . xml web xml default fragment . set distribut ( true ) ; when merg , default welcom file ar onli us app ha defin ani welcom file . web xml default fragment . set alwai add welcom file ( fals ) ; pars global web . xml present ( global web xml = = null ) { thi unusu enough log log . info ( sm . get string ( context config . default miss ) ) ; } els { pars web xml ( global web xml , web xml default fragment , fals ) ; } pars host level web . xml present addit apart from welcom page web xml default fragment . set replac welcom file ( true ) ; pars web xml ( host web xml , web xml default fragment , fals ) ; don t updat cach error occur ( global time stamp = 1 host time stamp = 1 ) { entri = new default web xml cach entri ( web xml default fragment , global time stamp , host time stamp ) ; host web xml cach . put ( host , entri ) ; } return web xml default fragment ; } }
privat class get type from valu ( object valu ) { ( valu = = null ) { return null ; } class result = new class valu . length ; ( int i = 0 ; i valu . length ; i ) { ( valu i = = null ) { result i = null ; } els { result i = valu i . get class ( ) ; } } return result ; }	sinc el 2 . 2 overrid public boolean paramet provid ( ) { ( thi . children . length 2 thi . jjt get child ( 2 ) instanceof ast method paramet ) { return true ; } return fals ; }	test public void test bug50790b ( ) throw except { valu express ve = factori . creat valu express ( context , { bean . name . contain ( bean aa . name ) } , java . lang . boolean . class ) ; boolean actual = ( boolean ) ve . get valu ( context ) ; assert equal ( boolean . fals , actual ) ; }
public context add webapp ( host host , string url , string name , string path ) { silenc ( host , url ) ; context ctx = new standard context ( ) ; ctx . set name ( name ) ; ctx . set path ( url ) ; ctx . set doc base ( path ) ; ( default realm = = null ) { init simpl auth ( ) ; } ctx . set realm ( default realm ) ; ctx . add lifecycl listen ( new default web xml listen ( ) ) ; context config ctx cfg = new context config ( ) ; ctx . add lifecycl listen ( ctx cfg ) ; prevent from look ( find ll have dup error ) ctx cfg . set default web xml ( default web xml path ( ) ) ; ( host = = null ) { get host ( ) . add child ( ctx ) ; } els { host . add child ( ctx ) ; } return ctx ; }	public access engin , further custom . engin get engin ( ) { ( engin = = null ) { get server ( ) ; engin = new standard engin ( ) ; engin . set name ( tomcat ) ; engin . set default host ( hostnam ) ; servic . set contain ( engin ) ; } return engin ; }	public host get host ( ) { ( host = = null ) { host = new standard host ( ) ; host . set name ( hostnam ) ; get engin ( ) . add child ( host ) ; } return host ; }	public complex configur , thi accessor allow caller thi class obtain simpl realm creat default . return simpl memori realm creat default . realm get default realm ( ) { ( default realm = = null ) { init simpl auth ( ) ; } return default realm ; }	public return pathnam pass { link context config set default web xml ( string ) } when us { link get default web xml listen ( ) } . string default web xml path ( ) { return constant . default web xml ; }
protect valid classnam . per srv . 9 . 7 . 2 , we must restrict load class from j2se ( java . ) most class servlet api ( javax . servlet . ) . should enhanc robust prevent number user error ( where older version servlet . jar would present web inf lib ) . param name class name return true name valid boolean valid ( string name ) { need care order here ( name = = null ) { can t load class without name return fals ; } ( name . start ( java . ) ) { must never load java . class return fals ; } ( name . start ( javax . servlet . jsp . jstl ) ) { ok web app packag jstl return true ; } ( name . start ( javax . servlet . ) ) { web app should never packag ani other servlet jsp class return fals ; } assum everyth els ok return true ; }	overrid public class loader run ( ) { return clazz . get class loader ( ) ; }
overrid public void set imag ( string imag ) { ( valid . identifi ( imag ) ) { throw new elexcept ( messag factori . get ( error . identifi . notjava , imag ) ) ; } thi . imag = imag ; }	public void test get valu refer ( ) { express factori factori = express factori . new instanc ( ) ; elcontext context = new elcontext impl ( ) ; tester bean b bean b = new tester bean b ( ) ; bean b . set name ( tomcat ) ; valu express var = factori . creat valu express ( bean b , tester bean b . class ) ; context . get variabl mapper ( ) . set variabl ( bean b , var ) ; valu express ve = factori . creat valu express ( context , { bean b . name } , string . class ) ; first check basic work string result = ( string ) ve . get valu ( context ) ; assert equal ( tomcat , result ) ; now check valu refer valu refer vr = ve . get valu refer ( context ) ; assert null ( vr ) ; assert equal ( bean b , vr . get base ( ) ) ; assert equal ( name , vr . get properti ( ) ) ; }
protect flush byte char contain buffer . throw ioexcept underli ioexcept occur void do flush ( boolean real flush ) throw ioexcept { ( suspend ) { return ; } try { do flush = true ; ( initi ) { coyot respons . send header ( ) ; initi = fals ; } ( bb . get length ( ) 0 ) { bb . flush buffer ( ) ; } } final { do flush = fals ; } ( real flush ) { coyot respons . action ( action code . client flush , coyot respons ) ; here , notifi servlet ioe ( coyot respons . except present ( ) ) { throw new client abort except ( coyot respons . get error except ( ) ) ; } } }	public void reset ( ) { bb . recycl ( ) ; byte written = 0 ; char written = 0 ; got enc = fals ; enc = null ; initi = true ; }	overrid public void write ( string s ) throw ioexcept { ( suspend ) { return ; } ( s = = null ) { s = null ; } conv . convert ( s ) ; conv . flush buffer ( ) ; }	append string buffer overrid public void write ( string s , int off , int len ) throw ioexcept { ( suspend ) { return ; } char written = len ; ( s = = null ) { s = null ; } conv . convert ( s , off , len ) ; conv . flush buffer ( ) ; }	overrid public void write ( char c , int off , int len ) throw ioexcept { ( suspend ) { return ; } conv . convert ( c , off , len ) ; conv . flush buffer ( ) ; char written = len ; }	char handl method overrid public void write ( int c ) throw ioexcept { ( suspend ) { return ; } conv . convert ( ( char ) c ) ; conv . flush buffer ( ) ; char written ; }
privat void silenc ( string ctx ) { string base = org . apach . catalina . core . contain base . default . ; base = get host ( ) . get name ( ) ; base = . ; base = ctx ; base = ; logger . get logger ( base ) . set level ( level . warn ) ; }	public context add context ( host host , string context path , string context name , string dir ) { silenc ( context path ) ; context ctx = new standard context ( ) ; ctx . set name ( context name ) ; ctx . set path ( context path ) ; ctx . set doc base ( dir ) ; ctx . add lifecycl listen ( new fix context listen ( ) ) ; ( host = = null ) { get host ( ) . add child ( ctx ) ; } els { host . add child ( ctx ) ; } return ctx ; }	public context add webapp ( host host , string url , string name , string path ) { silenc ( url ) ; context ctx = new standard context ( ) ; ctx . set name ( name ) ; ctx . set path ( url ) ; ctx . set doc base ( path ) ; ( default realm = = null ) { init simpl auth ( ) ; } ctx . set realm ( default realm ) ; ctx . add lifecycl listen ( new default web xml listen ( ) ) ; context config ctx cfg = new context config ( ) ; ctx . add lifecycl listen ( ctx cfg ) ; prevent from look ( find ll have dup error ) ctx cfg . set default web xml ( default web xml path ( ) ) ; ( host = = null ) { get host ( ) . add child ( ctx ) ; } els { host . add child ( ctx ) ; } return ctx ; }	public control logger silenc . param silent code true code set log level warn logger log inform tomcat start up . thi prevent usual startup inform log . code fals code set log level default level info . void set silent ( boolean silent ) { ( string s : silenc ) { ( silent ) { logger . get logger ( s ) . set level ( level . warn ) ; } els { logger . get logger ( s ) . set level ( level . info ) ; } } }
protect class packag web applic , class each super class need check match { link handl type } annot match { link handl type } . param java class void check handl type ( java class java class ) { skip thi we can ( type initi map . size ( ) = = 0 ) { return ; } choic load class string class name = java class . get class name ( ) ; class clazz = null ; try { clazz = context . get loader ( ) . get class loader ( ) . load class ( class name ) ; } catch ( class def found error e ) { log . debug ( sm . get string ( context config . invalid sci handl type , class name ) , e ) ; return ; } catch ( class found except e ) { log . warn ( sm . get string ( context config . invalid sci handl type , class name ) , e ) ; return ; } catch ( class format error e ) { log . warn ( sm . get string ( context config . invalid sci handl type , class name ) , e ) ; return ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . warn ( sm . get string ( context config . invalid sci handl type , class name ) , t ) ; return ; } ( clazz . annot ( ) ) { skip return ; } boolean match = fals ; ( map . entri class , set servlet contain initi >> entri : type initi map . entri set ( ) ) { ( entri . get kei ( ) . annot ( ) ) { annot entri annot entri = java class . get annot entri ( ) ; ( annot entri annot entri : annot entri ) { ( entri . get kei ( ) . get name ( ) . equal ( get class name ( annot entri . get annot type ( ) ) ) ) { match = true ; break ; } } } els ( entri . get kei ( ) . assign from ( clazz ) ) { match = true ; } ( match ) { ( servlet contain initi sci : entri . get valu ( ) ) { initi class map . get ( sci ) . add ( clazz ) ; } match = fals ; } } }
protect access log element creat log element ( ) { list access log element list = new arrai list access log element ( ) ; boolean replac = fals ; string builder buf = new string builder ( ) ; ( int i = 0 ; i pattern . length ( ) ; i ) { char ch = pattern . char ( i ) ; ( replac ) { code process { , behavior . . . i do encount close } i ignor { ( { = = ch ) { string builder name = new string builder ( ) ; int j = i 1 ; ( ; j pattern . length ( ) } = pattern . char ( j ) ; j ) { name . append ( pattern . char ( j ) ) ; } ( j 1 pattern . length ( ) ) { 1 wa account } which we increment now j ; list . add ( creat access log element ( name . string ( ) , pattern . char ( j ) ) ) ; i = j ; sinc we walk more than charact } els { d oh end string pretend we never did thi do process old wai list . add ( creat access log element ( ch ) ) ; } } els { list . add ( creat access log element ( ch ) ) ; } replac = fals ; } els ( ch = = ) { replac = true ; list . add ( new string element ( buf . string ( ) ) ) ; buf = new string builder ( ) ; } els { buf . append ( ch ) ; } } ( buf . length ( ) 0 ) { list . add ( new string element ( buf . string ( ) ) ) ; } return list . arrai ( new access log element 0 ) ; }
public boolean authent ( request request , http servlet respons respons , login config config ) throw ioexcept { associ thi request s session sso would allow coordin session invalid , should session webapp user didn t log invalid when anoth session log out string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( sso id = null ) associ ( sso id , get session ( request , true ) ) ; ( contain log . debug enabl ( ) ) { contain log . debug ( user authent requir ) ; } return ( true ) ; }
privat void process paramet ( byte byte , int start , int len , charset charset ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( paramet . byte , new string ( byte , start , len , default charset ) ) ) ; } int decod fail count = 0 ; int po = start ; int end = start len ; while ( po end ) { int name start = po ; int name end = 1 ; int valu start = 1 ; int valu end = 1 ; boolean pars name = true ; boolean decod name = fals ; boolean decod valu = fals ; boolean paramet complet = fals ; do { switch ( byte po ) { case = : ( pars name ) { name finish . valu start from next charact name end = po ; pars name = fals ; valu start = po ; } els { equal charact valu po ; } break ; case : ( pars name ) { name finish . valu . name end = po ; } els { valu finish valu end = po ; } paramet complet = true ; po ; break ; case : case : decod requir ( pars name ) { decod name = true ; } els { decod valu = true ; } po ; break ; default : po ; break ; } } while ( paramet complet po end ) ; ( po = = end ) { ( name end = = 1 ) { name end = po ; } els ( valu start 1 valu end = = 1 ) { valu end = po ; } } ( log . debug enabl ( ) valu start = = 1 ) { log . debug ( sm . get string ( paramet . noequal , integ . valu ( name start ) , integ . valu ( name end ) , new string ( byte , name start , name end name start , default charset ) ) ) ; } ( name end = name start ) { ( log . info enabl ( ) ) { ( valu end = name start log . debug enabl ( ) ) { string extract = new string ( byte , name start , valu end name start , default charset ) ; log . info ( sm . get string ( paramet . invalid chunk , integ . valu ( name start ) , integ . valu ( valu end ) , extract ) ) ; } els { log . info ( sm . get string ( paramet . invalid chunk , integ . valu ( name start ) , integ . valu ( name end ) , null ) ) ; } } pars fail = true ; continu ; invalid chunk s better ignor } tmp name . set byte ( byte , name start , name end name start ) ; tmp valu . set byte ( byte , valu start , valu end valu start ) ; perform onli done debug ( log . debug enabl ( ) ) { try { orig name . append ( byte , name start , name end name start ) ; orig valu . append ( byte , valu start , valu end valu start ) ; } catch ( ioexcept ioe ) { should never happen . . . log . error ( sm . get string ( paramet . copi fail ) , ioe ) ; } } try { string name ; string valu ; ( decod name ) { url decod ( tmp name ) ; } tmp name . set charset ( charset ) ; name = tmp name . string ( ) ; ( decod valu ) { url decod ( tmp valu ) ; } tmp valu . set charset ( charset ) ; valu = tmp valu . string ( ) ; try { add paramet ( name , valu ) ; } catch ( illeg state except ) { hit limit stop process further param doe caus request fail . pars fail = true ; log . warn ( . get messag ( ) ) ; break ; } } catch ( ioexcept e ) { pars fail = true ; decod fail count ; ( decod fail count = = 1 log . debug enabl ( ) ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( paramet . decod fail . debug , orig name . string ( ) , orig valu . string ( ) ) , e ) ; } els ( log . info enabl ( ) ) { log . info ( sm . get string ( paramet . decod fail . info , tmp name . string ( ) , tmp valu . string ( ) ) , e ) ; } } } tmp name . recycl ( ) ; tmp valu . recycl ( ) ; onli recycl copi we us them ( log . debug enabl ( ) ) { orig name . recycl ( ) ; orig valu . recycl ( ) ; } } ( decod fail count 1 log . debug enabl ( ) ) { log . info ( sm . get string ( paramet . multipl decod fail , integ . valu ( decod fail count ) ) ) ; } }


public void set enabl ( boolean enabl ) { enabl = enabl ; ( enabl ) { lock . abort remov ( ) ; last = first = null ; } }
protect void anti lock ( ) { ( ( context instanceof standard context ) ( ( standard context ) context ) . get anti resourc lock ( ) ) { host host = ( host ) context . get parent ( ) ; string doc base = context . get doc base ( ) ; ( doc base = = null ) { return ; } ( origin doc base = = null ) { origin doc base = doc base ; } els { doc base = origin doc base ; } file doc base file = new file ( doc base ) ; ( doc base file . absolut ( ) ) { doc base file = new file ( host . get app base file ( ) , doc base ) ; } string path = context . get path ( ) ; ( path = = null ) { return ; } context name cn = new context name ( path , context . get webapp version ( ) ) ; doc base = cn . get base name ( ) ; file file = null ; ( doc base . lower case ( local . english ) . end ( . war ) ) { todo thi never execut . bug code delet file = new file ( system . get properti ( java . io . tmpdir ) , deploy count doc base . war ) ; } els { file = new file ( system . get properti ( java . io . tmpdir ) , deploy count doc base ) ; } ( log . debug enabl ( ) ) { log . debug ( anti lock context context . get name ( ) set doc base file ) ; } cleanup just case old deploy ly around expand war . delet ( file ) ; ( expand war . copi ( doc base file , file ) ) { context . set doc base ( file . get absolut path ( ) ) ; } } }
public map string , string get taglib ( ) { return taglib ; }
protect get data from channel store byte arrai send cluster throw ioexcept throw java . nio . channel . close channel except void listen ( ) throw except { ( do listen ( ) ) { log . warn ( server socket channel alreadi start ) ; return ; } set listen ( true ) ; ( selector = null datagram channel = null ) { max size datagram packet object reader oread = new object reader ( max udp size ) ; datagram channel . socket ( ) . set send buffer size ( get udp tx buf size ( ) ) ; datagram channel . socket ( ) . set receiv buffer size ( get udp rx buf size ( ) ) ; datagram channel . socket ( ) . set reus address ( get so reus address ( ) ) ; datagram channel . socket ( ) . set so timeout ( get timeout ( ) ) ; datagram channel . socket ( ) . set traffic class ( get so traffic class ( ) ) ; regist channel ( selector , datagram channel , select kei . op read , oread ) ; } while ( do listen ( ) selector = null ) { select set contain kei readi channel try { event ( ) ; socket timeout ( ) ; int n = selector . select ( get selector timeout ( ) ) ; ( n = = 0 ) { noth do continu ; } get iter over set select kei iter select kei = ( selector = null ) selector . select kei ( ) . iter ( ) : null ; look each kei select set while ( = null . ha next ( ) ) { select kei kei = . next ( ) ; new connect come ( kei . accept ( ) ) { server socket channel server = ( server socket channel ) kei . channel ( ) ; socket channel channel = server . accept ( ) ; channel . socket ( ) . set receiv buffer size ( get rx buf size ( ) ) ; channel . socket ( ) . set send buffer size ( get tx buf size ( ) ) ; channel . socket ( ) . set tcp delai ( get tcp delai ( ) ) ; channel . socket ( ) . set keep aliv ( get so keep aliv ( ) ) ; channel . socket ( ) . set oobinlin ( get oo binlin ( ) ) ; channel . socket ( ) . set reus address ( get so reus address ( ) ) ; channel . socket ( ) . set so linger ( get so linger ( ) , get so linger time ( ) ) ; channel . socket ( ) . set traffic class ( get so traffic class ( ) ) ; channel . socket ( ) . set so timeout ( get timeout ( ) ) ; object attach = new object reader ( channel ) ; regist channel ( selector , channel , select kei . op read , attach ) ; } data read thi channel ( kei . readabl ( ) ) { read data from socket ( kei ) ; } els { kei . interest op ( kei . interest op ( ) ( select kei . op write ) ) ; } remov kei from select set , s been handl ( selector = null ) . remov ( ) ; } } catch ( java . nio . channel . close selector except cse ) { ignor normal shutdown stop listen socket } catch ( java . nio . channel . cancel kei except nx ) { log . warn ( replic client disconnect , error when poll kei . ignor client . ) ; } catch ( throwabl t ) { ( t instanceof thread death ) { throw ( thread death ) t ; } ( t instanceof virtual machin error ) { throw ( virtual machin error ) t ; } log . error ( unabl process request nio receiv , t ) ; } } server channel . close ( ) ; ( datagram channel = null ) { try { datagram channel . close ( ) ; } catch ( except iox ) { ( log . debug enabl ( ) ) log . debug ( unabl close datagram channel . , iox ) ; } datagram channel = null ; } close selector ( ) ; }
privat void do test bug51557char ( char s ) { bug51557client client = new bug51557client ( x bug s 51557 , invalid ) ; client . set port ( get port ( ) ) ; client . do request ( ) ; assert true ( client . response200 ( ) ) ; assert equal ( abcd , client . get respons bodi ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; }	privat void do test ( string resourc method , string redirect method , boolean us continu ) throw except { form auth client client = new form auth client ( ) ; first request authent resourc client . set us continu ( us continu ) ; client . do resourc request ( resourc method ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; second request login page client . set us continu ( us continu ) ; client . do login request ( ) ; assert true ( client . response302 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; third request follow redirect client . do resourc request ( redirect method ) ; ( post . equal ( redirect method ) ) { client . set us continu ( us continu ) ; } assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; subsequ request direct resourc ( int i = 0 ; i 5 ; i ) { client . set us continu ( us continu ) ; client . do resourc request ( resourc method ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; } }	privat object name creat object name ( ) throw malform object name except { us same domain connector domain = adapt . get domain ( ) ; ( domain = = null ) { return null ; } string builder name = new string builder ( get domain ( ) ) ; name . append ( : type = protocol handler , port = ) ; name . append ( get port ( ) ) ; inet address address = get address ( ) ; ( address = null ) { name . append ( , address = ) ; name . append ( object name . quot ( address . string ( ) ) ) ; } return new object name ( name . string ( ) ) ; }	test case http : issu . apach . org bugzilla show bug . cgi id = 48692 put request should abl fetch request paramet come from request bodi ( when properli configur us new pars bodi method set ) . test public void test bug48692 ( ) { bug48692client client = new bug48692client ( ) ; client . set port ( get port ( ) ) ; make sure get work properli client . do request ( get , foo = bar , null , null , fals ) ; assert true ( non 200 respons get request , client . response200 ( ) ) ; assert equal ( incorrect respons get request , foo = bar , client . get respons bodi ( ) ) ; client . reset ( ) ; make sure post work properli post separ get post paramet client . do request ( post , foo = bar , applic x www form urlencod , bar = baz , true ) ; assert true ( non 200 respons post request , client . response200 ( ) ) ; assert equal ( incorrect respons post request , bar = baz , foo = bar , client . get respons bodi ( ) ) ; client . reset ( ) ; post overlap get post paramet client . do request ( post , foo = bar bar = foo , applic x www form urlencod , bar = baz foo = baz , true ) ; assert true ( non 200 respons post request , client . response200 ( ) ) ; assert equal ( incorrect respons post request , bar = baz , bar = foo , foo = bar , foo = baz , client . get respons bodi ( ) ) ; client . reset ( ) ; put without post style pars client . do request ( put , foo = bar bar = foo , applic x www form urlencod , bar = baz foo = baz , fals ) ; assert true ( non 200 respons put nopars request , client . response200 ( ) ) ; assert equal ( incorrect respons put request , bar = foo , foo = bar , client . get respons bodi ( ) ) ; client . reset ( ) ; put post style pars client . do request ( put , foo = bar bar = foo , applic x www form urlencod , bar = baz foo = baz , true ) ; assert true ( non 200 respons put request , client . response200 ( ) ) ; assert equal ( incorrect respons put pars request , bar = baz , bar = foo , foo = bar , foo = baz , client . get respons bodi ( ) ) ; client . reset ( ) ; privat except do request ( string method , string queri string , string content type , string request bodi , boolean allow bodi ) { }	protect void servic ( http servlet request req , http servlet respons resp ) throw servlet except , ioexcept { just echo paramet valu back plain text resp . set content type ( text plain ) ; resp . set charact encod ( utf 8 ) ; print writer out = resp . get writer ( ) ; out . println ( part = ( null = = req . get part ( ) null : integ . valu ( req . get part ( ) . size ( ) ) ) ) ; }	protect void do post ( http servlet request req , http servlet respons resp ) throw servlet except , ioexcept { print writer out = resp . get writer ( ) ; resp . set content type ( text plain ) ; resp . set charact encod ( utf 8 ) ; string builder sb = new string builder ( ) ; try { collect part c = req . get part ( ) ; ( c = = null ) { log . debug ( count : 1 ) ; sb . append ( count : 1 n ) ; } els { log . debug ( count : c . size ( ) ) ; sb . append ( count : c . size ( ) n ) ; ( part p : c ) { log . debug ( name : p . get name ( ) , size : p . get size ( ) ) ; sb . append ( name : p . get name ( ) , size : p . get size ( ) n ) ; } } } catch ( illeg state except ex ) { log . debug ( illeg state except dure get part ( ) ) ; sb . append ( illeg state except dure get part ( ) n ) ; resp . set statu ( 500 ) ; } catch ( throwabl ex ) { log . error ( except dure get part ( ) , ex ) ; sb . append ( ex ) ; resp . set statu ( 500 ) ; } out . print ( sb . string ( ) ) ; resp . flush buffer ( ) ; }	protect void do post ( http servlet request req , http servlet respons resp ) throw servlet except , ioexcept { resp . set content type ( text plain ) ; resp . set charact encod ( utf 8 ) ; resp . set statu ( statu ) ; print writer out = resp . get writer ( ) ; out . print ( ok ) ; resp . flush buffer ( ) ; }	public void test equal ( ) throw except { system . set properti ( org . apach . tomcat . util . http . server cooki . allow equal valu , true ) ; test cooki equal client client = new test cooki equal client ( ) ; client . do request ( ) ; }	public void test http sep ( ) throw except { system . set properti ( org . apach . tomcat . util . http . server cooki . allow http separ v0 , true ) ; test cooki http sep client client = new test cooki http sep client ( ) ; client . do request ( ) ; }	public void test equal ( ) throw except { system . set properti ( org . apach . tomcat . util . http . server cooki . allow name onli , true ) ; test cooki name onli client client = new test cooki name onli client ( ) ; client . do request ( ) ; }	public void test equal ( ) throw except { test cooki equal client client = new test cooki equal client ( ) ; client . do request ( ) ; }	privat void do test bug51557char ( char s ) { bug51557client client = new bug51557client ( x bug s 51557 , invalid ) ; client . set port ( get port ( ) ) ; client . do request ( ) ; assert true ( client . response200 ( ) ) ; assert equal ( abcd , client . get respons bodi ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; }	protect string creat object name kei properti ( string type ) { object address obj = get properti ( address ) ; string builder sb = new string builder ( type = ) ; sb . append ( type ) ; sb . append ( , port = ) ; sb . append ( get port ( ) ) ; ( address obj = null ) { string address = address obj . string ( ) ; ( address . length ( ) 0 ) { sb . append ( , address = ) ; sb . append ( object name . quot ( address ) ) ; } } return sb . string ( ) ; }	protect boolean pars bodi method ( string method ) { return pars bodi method set . contain ( method ) ; }	public void test trail header ( ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; tomcat . add servlet ( ctx , servlet , new echo header servlet ( ) ) ; ctx . add servlet map ( , servlet ) ; tomcat . start ( ) ; string request = post echo param . jsp http 1 . 1 simpl http client . crlf host : ani simpl http client . crlf transfer encod : chunk simpl http client . crlf content type : applic x www form urlencod simpl http client . crlf connect : close simpl http client . crlf simpl http client . crlf 3 simpl http client . crlf = 0 simpl http client . crlf 4 simpl http client . crlf b = 1 simpl http client . crlf 0 simpl http client . crlf simpl http client . crlf ; trailer client client = new trailer client ( ) ; client . set port ( get port ( ) ) ; client . set request ( new string { request } ) ; client . connect ( ) ; client . process request ( ) ; assert equal ( null7nul , client . get respons bodi ( ) ) ; }	begin process request via thi connector . except lifecycl except fatal startup error occur overrid protect void start intern ( ) throw lifecycl except { valid set befor start ( get port ( ) 1 ) { throw new lifecycl except ( sm . get string ( coyot connector . invalid port , integ . valu ( get port ( ) ) ) ) ; } set state ( lifecycl state . start ) ; try { protocol handler . start ( ) ; } catch ( except e ) { string err prefix = ; ( thi . servic = null ) { err prefix = servic . get name ( ) : thi . servic . get name ( ) ; ; } throw new lifecycl except ( err prefix sm . get string ( coyot connector . protocol handler start fail ) , e ) ; } mapper listen . start ( ) ; }	protect void valid ( http servlet servlet , integ expect max ag second , int expect respons statu code ) throw except { setup tomcat tomcat = get tomcat instanc ( ) ; context root = tomcat . add context ( , temp dir ) ; filter def filter def = new filter def ( ) ; filter def . add init paramet ( expir default , access plu 1 minut ) ; filter def . add init paramet ( expir type text xml ; charset = utf 8 , access plu 3 minut ) ; filter def . add init paramet ( expir type text xml , access plu 5 minut ) ; filter def . add init paramet ( expir type text , access plu 7 minut ) ; filter def . add init paramet ( expir exclud respons statu code , 304 , 503 ) ; filter def . set filter class ( expir filter . class . get name ( ) ) ; filter def . set filter name ( expir filter . class . get name ( ) ) ; root . add filter def ( filter def ) ; filter map filter map = new filter map ( ) ; filter map . set filter name ( expir filter . class . get name ( ) ) ; filter map . add urlpattern ( ) ; root . add filter map ( filter map ) ; tomcat . add servlet ( root , servlet . get class ( ) . get name ( ) , servlet ) ; root . add servlet map ( test , servlet . get class ( ) . get name ( ) ) ; tomcat . start ( ) ; try { calendar . get instanc ( time zone . get time zone ( gmt ) ) ; long time befor milli = system . current time milli ( ) ; test http urlconnect http urlconnect = ( http urlconnect ) new url ( http : localhost : tomcat . get connector ( ) . get port ( ) test ) . open connect ( ) ; valid assert . assert equal ( expect respons statu code , http urlconnect . get respons code ( ) ) ; string builder msg = new string builder ( ) ; ( entri string , list string >> field : http urlconnect . get header field ( ) . entri set ( ) ) { ( string valu : field . get valu ( ) ) { msg . append ( ( field . get kei ( ) = = null : field . get kei ( ) : ) valu n ) ; } } system . out . println ( msg ) ; integ actual max ag second ; string cach control header = http urlconnect . get header field ( cach control ) ; ( cach control header = = null ) { actual max ag second = null ; } els { actual max ag second = null ; string token cach control token = new string token ( cach control header , , ) ; while ( cach control token . ha more token ( ) actual max ag second = = null ) { string cach direct = cach control token . next token ( ) ; string token cach direct token = new string token ( cach direct , = ) ; ( cach direct token . count token ( ) = = 2 ) { string kei = cach direct token . next token ( ) . trim ( ) ; string valu = cach direct token . next token ( ) . trim ( ) ; ( kei . equal ignor case ( max ag ) ) { actual max ag second = integ . valu ( valu ) ; } } } } ( expect max ag second = = null ) { assert . assert null ( actual max ag second actual max ag second should null , actual max ag second ) ; return ; } assert . assert null ( actual max ag second ) ; suppress warn ( null ) int delta second = math . ab ( actual max ag second . int valu ( ) expect max ag second . int valu ( ) ) ; assert . assert true ( actual max ag second : actual max ag second , expect max ag second : expect max ag second , request time : time befor milli content type http urlconnect . get content type ( ) , delta second 3 ) ; } final { tomcat . stop ( ) ; } }	public test whether abort post correctli handl connect drain . except do abort posttest ( abort postclient client , int statu , boolean swallow ) { client . set port ( get port ( ) ) ; except ex = client . do request ( statu , swallow ) ; ( log . debug enabl ( ) ) { log . debug ( respons line : client . get respons line ( ) ) ; log . debug ( respons header : client . get respons header ( ) ) ; log . debug ( respons bodi : client . get respons bodi ( ) ) ; ( ex = null ) { log . info ( except client : , ex ) ; } } return ex ; }	public except do abort upload test ( abort upload client client , boolean limit , boolean swallow ) { client . set port ( get port ( ) ) ; except ex = client . do request ( limit , swallow ) ; ( log . debug enabl ( ) ) { log . debug ( respons line : client . get respons line ( ) ) ; log . debug ( respons header : client . get respons header ( ) ) ; log . debug ( respons bodi : client . get respons bodi ( ) ) ; ( ex = null ) { log . debug ( except client : , ex ) ; } } return ex ; }	support overrid public boolean get us poll ( ) { return fals ; }	public boolean get sslinsecur renegoti ( ) { return sslinsecur renegoti ; }	public name prefix address port address non null prefix port address null . name appropri quot so can us directli object name . string get name ( ) { string builder name = new string builder ( get name prefix ( ) ) ; name . append ( ) ; ( get address ( ) = null ) { name . append ( get address ( ) ) ; name . append ( ) ; } name . append ( endpoint . get port ( ) ) ; return object name . quot ( name . string ( ) ) ; }	provid us string ( ) implement mai us when log lifecycl error identifi compon . overrid public string string ( ) { worth cach thi right now string builder sb = new string builder ( connector ) ; sb . append ( get protocol ( ) ) ; sb . append ( ) ; sb . append ( get port ( ) ) ; sb . append ( ) ; return sb . string ( ) ; }	public sub class need know port so thei can connect int get port ( ) { return port ; }	public static int get url ( string path , byte chunk out , map string , list string >> re head ) throw ioexcept { out . recycl ( ) ; return tomcat base test . get url ( path , out , re head ) ; }	public void test pipelin ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctxt = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; add protect servlet tomcat . add servlet ( ctxt , tester servlet , new tester servlet ( ) ) ; ctxt . add servlet map ( foo , tester servlet ) ; tomcat . start ( ) ; string request part1 = get foo http 1 . 1 simpl http client . crlf ; string request part2 = host : ani simpl http client . crlf simpl http client . crlf ; final client client = new client ( ) ; client . set port ( get port ( ) ) ; client . set request ( new string { request part1 , request part2 } ) ; client . set request paus ( 1000 ) ; client . set us content length ( true ) ; client . connect ( ) ; runnabl send = new runnabl ( ) { overrid public void run ( ) { try { client . send request ( ) ; client . send request ( ) ; } catch ( interrupt except e ) { throw new runtim except ( e ) ; } catch ( ioexcept e ) { throw new runtim except ( e ) ; } } } ; thread t = new thread ( send ) ; t . start ( ) ; sleep 1500 ms which should mean all request 1 ha been sent half request 2 thread . sleep ( 1500 ) ; now read first respons client . read respons ( true ) ; assert fals ( client . response50x ( ) ) ; assert true ( client . response200 ( ) ) ; assert equal ( ok , client . get respons bodi ( ) ) ; read second respons . need sleep , read block until data process client . read respons ( true ) ; assert fals ( client . response50x ( ) ) ; assert true ( client . response200 ( ) ) ; assert equal ( ok , client . get respons bodi ( ) ) ; }	public void set bind init ( boolean b ) { thi . bind init = b ; }	public void set sslcontext ( sslcontext c ) { ssl context = c ; }	public set port number which we listen request . param port new port number void set port ( int port ) { thi . port = port ; set properti ( port , string . valu ( port ) ) ; }	public void set port ( int port ) { endpoint . set port ( port ) ; }	public void set so timeout ( int timeout ) { set connect timeout ( timeout ) ; }	befor overrid public void set up ( ) throw except { super . set up ( ) ; trigger load catalina . properti catalina properti . get properti ( foo ) ; file app base = new file ( get temporari directori ( ) , webapp ) ; ( app base . exist ( ) app base . mkdir ( ) ) { fail ( unabl creat app base test ) ; } tomcat = new tomcat fast session id ( ) ; string protocol = get protocol ( ) ; connector connector = new connector ( protocol ) ; each test run same port thei mai interfer each other connector . set port ( get next port ( ) ) ; mainli set reduc timeout dure async test connector . set attribut ( connect timeout , 3000 ) ; tomcat . get servic ( ) . add connector ( connector ) ; tomcat . set connector ( connector ) ; add apr lifecycl listen we ar us apr connector ( protocol . contain ( apr ) ) { standard server server = ( standard server ) tomcat . get server ( ) ; apr lifecycl listen listen = new apr lifecycl listen ( ) ; listen . set sslrandom seed ( dev urandom ) ; server . add lifecycl listen ( listen ) ; connector . set attribut ( poller thread count , integ . valu ( 1 ) ) ; } file catalina base = get temporari directori ( ) ; tomcat . set base dir ( catalina base . get absolut path ( ) ) ; tomcat . get host ( ) . set app base ( app base . get absolut path ( ) ) ; access log enabl = boolean . pars boolean ( system . get properti ( tomcat . test . accesslog , fals ) ) ; ( access log enabl ) { access log valv alv = new access log valv ( ) ; alv . set directori ( get build directori ( ) log ) ; alv . set pattern ( h l u t r s b i d ) ; tomcat . get host ( ) . get pipelin ( ) . add valv ( alv ) ; } cannot delet whole temp dir , becaus log ar , delet known subdirectori . add delet tear down ( new file ( catalina base , webapp ) ) ; add delet tear down ( new file ( catalina base , work ) ) ; }	public void test bug37794 ( ) { bug37794client client = new bug37794client ( true ) ; client . set port ( get port ( ) ) ; edg case around zero unlimit client . do request ( 1 , fals ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; unlimit client . do request ( 0 , fals ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; 1 byte too small should fail client . do request ( 1 , fals ) ; assert true ( client . response400 ( ) ) ; client . reset ( ) ; edg case around actual content length client . reset ( ) ; too small should fail client . do request ( 6 , fals ) ; assert true ( client . response400 ( ) ) ; client . reset ( ) ; just enough should pass client . do request ( 7 , fals ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; 1 extra should pass client . do request ( 8 , fals ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; much larger client . reset ( ) ; plenti space should pass client . do request ( 8096 , fals ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; check case insensit client . reset ( ) ; plenti space should pass client . do request ( 8096 , true ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; }	addit test fail request handl when fail request filter defin . test public void test bug37794without filter ( ) { bug37794client client = new bug37794client ( fals ) ; client . set port ( get port ( ) ) ; edg case around actual content length client . reset ( ) ; too small should fail client . do request ( 6 , fals ) ; respons code ok , paramet list empti assert true ( client . response200 ( ) ) ; assert equal ( , client . get respons bodi ( ) ) ; }	public void test bug46243 ( ) throw except { set up contain tomcat tomcat = get tomcat instanc ( ) ; file doc base = new file ( tomcat . get host ( ) . get app base file ( ) , root ) ; ( doc base . mkdir ( ) doc base . directori ( ) ) { fail ( unabl creat doc base ) ; } context root = tomcat . add context ( , root ) ; add test filter fail filter def filter def = new filter def ( ) ; filter def . set filter class ( bug46243filt . class . get name ( ) ) ; filter def . set filter name ( bug46243 ) ; root . add filter def ( filter def ) ; filter map filter map = new filter map ( ) ; filter map . set filter name ( bug46243 ) ; filter map . add urlpattern ( ) ; root . add filter map ( filter map ) ; add test servlet so someth gener respons work ( although shouldn t ) tomcat . add servlet ( root , bug46243 , new hello world servlet ( ) ) ; root . add servlet map ( , bug46243 ) ; tomcat . start ( ) ; configur client bug46243client client = new bug46243client ( ) ; client . set port ( get port ( ) ) ; client . set request ( new string { request } ) ; client . connect ( ) ; client . process request ( ) ; assert true ( client . response404 ( ) ) ; }	test case http : issu . apach . org bugzilla show bug . cgi id = 48692 put request should abl fetch request paramet come from request bodi ( when properli configur us new pars bodi method set ) . test public void test bug48692 ( ) { bug48692client client = new bug48692client ( ) ; client . set port ( get port ( ) ) ; make sure get work properli client . do request ( get , foo = bar , null , null , fals ) ; assert true ( non 200 respons get request , client . response200 ( ) ) ; assert equal ( incorrect respons get request , foo = bar , client . get respons bodi ( ) ) ; client . reset ( ) ; make sure post work properli post separ get post paramet client . do request ( post , foo = bar , applic x www form urlencod , bar = baz , true ) ; assert true ( non 200 respons post request , client . response200 ( ) ) ; assert equal ( incorrect respons post request , bar = baz , foo = bar , client . get respons bodi ( ) ) ; client . reset ( ) ; post overlap get post paramet client . do request ( post , foo = bar bar = foo , applic x www form urlencod , bar = baz foo = baz , true ) ; assert true ( non 200 respons post request , client . response200 ( ) ) ; assert equal ( incorrect respons post request , bar = baz , bar = foo , foo = bar , foo = baz , client . get respons bodi ( ) ) ; client . reset ( ) ; put without post style pars client . do request ( put , foo = bar bar = foo , applic x www form urlencod , bar = baz foo = baz , fals ) ; assert true ( non 200 respons put nopars request , client . response200 ( ) ) ; assert equal ( incorrect respons put request , bar = foo , foo = bar , client . get respons bodi ( ) ) ; client . reset ( ) ; put post style pars client . do request ( put , foo = bar bar = foo , applic x www form urlencod , bar = baz foo = baz , true ) ; assert true ( non 200 respons put request , client . response200 ( ) ) ; assert equal ( incorrect respons put pars request , bar = baz , bar = foo , foo = bar , foo = baz , client . get respons bodi ( ) ) ; client . reset ( ) ; }	public void test bug48839 ( ) { bug48839client client = new bug48839client ( ) ; client . set port ( get port ( ) ) ; client . do request ( ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; }	test case bug 49711 : http servlet request . get part doe work filter . test public void test bug49711 ( ) { bug49711client client = new bug49711client ( ) ; client . set port ( get port ( ) ) ; make sure non multipart work properli client . do request ( regular , fals , fals ) ; assert equal ( incorrect respons get request , part = 0 , client . get respons bodi ( ) ) ; client . reset ( ) ; make sure regular multipart work properli send multipart request client . do request ( multipart , fals , true ) ; assert equal ( regular multipart doesn t work , part = 1 , client . get respons bodi ( ) ) ; client . reset ( ) ; make casual multipart request regular servlet w o config we expect part avail send multipart request client . do request ( regular , fals , true ) ; assert equal ( incorrect respons non configur casual multipart request , multipart request should ignor part = 0 , client . get respons bodi ( ) ) ; client . reset ( ) ; make casual multipart request regular servlet w config we expect server pars part , even though multipart config send multipart request client . do request ( regular , true , true ) ; assert equal ( incorrect respons configur casual multipart request , part = 1 , client . get respons bodi ( ) ) ; client . reset ( ) ; }	test public void test bug51557boundari end ( ) { bug51557client client = new bug51557client ( x bug51557 = , invalid ) ; client . set port ( get port ( ) ) ; client . do request ( ) ; assert true ( client . response200 ( ) ) ; assert equal ( abcd , client . get respons bodi ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; }	test public void test bug51557boundari start ( ) { bug51557client client = new bug51557client ( = x bug51557 , invalid ) ; client . set port ( get port ( ) ) ; client . do request ( ) ; assert true ( client . response200 ( ) ) ; assert equal ( abcd , client . get respons bodi ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; }	test public void test bug51557continu ( ) { bug51557client client = new bug51557client ( x bug = 51557no colon , foo simpl http client . crlf bar ) ; client . set port ( get port ( ) ) ; client . do request ( ) ; assert true ( client . response200 ( ) ) ; assert equal ( abcd , client . get respons bodi ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; }	test public void test bug51557no colon ( ) { bug51557client client = new bug51557client ( x bug51557no colon ) ; client . set port ( get port ( ) ) ; client . do request ( ) ; assert true ( client . response200 ( ) ) ; assert equal ( abcd , client . get respons bodi ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; }	test http : issu . apach . org bugzilla show bug . cgi id = 50413 serv custom error page test public void test custom error page ( ) throw except { file app dir = new file ( get temporari directori ( ) , my app ) ; file web inf = new file ( app dir , web inf ) ; add delet tear down ( app dir ) ; ( web inf . mkdir ( ) web inf . directori ( ) ) { fail ( unabl creat directori web inf ) ; } writer w = new output stream writer ( new file output stream ( new file ( app dir , web inf web . xml ) ) , utf 8 ) ; try { w . write ( xml version = 1 . 0 encod = utf 8 n web app xmln = http : java . sun . com xml ns j2ee xmln : xsi = http : www . w3 . org 2001 xmlschema instanc xsi : schema locat = http : java . sun . com xml ns j2ee http : java . sun . com xml ns j2ee web app 2 4 . xsd version = 2 . 4 n error page n error code 404 error code n locat 404 . html locat n error page n web app n ) ; w . flush ( ) ; } final { w . close ( ) ; } w = new output stream writer ( new file output stream ( new file ( app dir , 404 . html ) ) , iso 8859 1 ) ; try { w . write ( 404 . html ) ; w . flush ( ) ; } final { w . close ( ) ; } tomcat tomcat = get tomcat instanc ( ) ; string context path = my app ; tomcat . add webapp ( null , context path , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; test custom error client client = new test custom error client ( ) ; client . set port ( get port ( ) ) ; client . reset ( ) ; client . set request ( new string { get my app miss http 1 . 0 crlf crlf } ) ; client . connect ( ) ; client . process request ( ) ; assert true ( client . response404 ( ) ) ; assert equal ( 404 . html , client . get respons bodi ( ) ) ; simpl date format format = new simpl date format ( eee , dd mmm yyyi hh : mm : ss zzz , local . us ) ; format . set time zone ( time zone . get time zone ( gmt ) ) ; string tomorrow = format . format ( new date ( system . current time milli ( ) 24 60 60 1000 ) ) ; http : issu . apach . org bugzilla show bug . cgi id = 50413 client . reset ( ) ; client . set request ( new string { get my app miss http 1 . 1 crlf host : localhost crlf connect : close crlf modifi sinc : tomorrow crlf crlf } ) ; client . connect ( ) ; client . process request ( ) ; assert true ( client . response404 ( ) ) ; assert equal ( 404 . html , client . get respons bodi ( ) ) ; http : issu . apach . org bugzilla show bug . cgi id = 50413 c6 client . reset ( ) ; client . set request ( new string { get my app miss http 1 . 1 crlf host : localhost crlf connect : close crlf rang : byte = 0 100 crlf crlf } ) ; client . connect ( ) ; client . process request ( ) ; assert true ( client . response404 ( ) ) ; assert equal ( 404 . html , client . get respons bodi ( ) ) ; }	test what happen custom 404 page configur , file actual miss . test public void test custom error page miss ( ) throw except { file app dir = new file ( get temporari directori ( ) , my app ) ; file web inf = new file ( app dir , web inf ) ; add delet tear down ( app dir ) ; ( web inf . mkdir ( ) web inf . directori ( ) ) { fail ( unabl creat directori web inf ) ; } writer w = new output stream writer ( new file output stream ( new file ( app dir , web inf web . xml ) ) , utf 8 ) ; try { w . write ( xml version = 1 . 0 encod = utf 8 n web app xmln = http : java . sun . com xml ns j2ee xmln : xsi = http : www . w3 . org 2001 xmlschema instanc xsi : schema locat = http : java . sun . com xml ns j2ee http : java . sun . com xml ns j2ee web app 2 4 . xsd version = 2 . 4 n error page n error code 404 error code n locat 404 absent . html locat n error page n web app n ) ; w . flush ( ) ; } final { w . close ( ) ; } tomcat tomcat = get tomcat instanc ( ) ; string context path = my app ; tomcat . add webapp ( null , context path , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; test custom error client client = new test custom error client ( ) ; client . set port ( get port ( ) ) ; client . reset ( ) ; client . set request ( new string { get my app miss http 1 . 0 crlf crlf } ) ; client . connect ( ) ; client . process request ( ) ; assert true ( client . response404 ( ) ) ; }	public void test mbean deregistr ( ) throw except { final mbean server mbean server = registri . get registri ( null , null ) . get mbean server ( ) ; set object name onam = mbean server . queri name ( new object name ( catalina : ) , null ) ; assert equal ( remain : onam , 0 , onam . size ( ) ) ; final tomcat tomcat = get tomcat instanc ( ) ; final file context dir = new file ( get temporari directori ( ) , webapp foo ) ; add delet tear down ( context dir ) ; ( context dir . mkdir ( ) context dir . directori ( ) ) { fail ( fail creat : context dir . string ( ) ) ; } tomcat . add context ( context name , context dir . get absolut path ( ) ) ; tomcat . start ( ) ; verifi ar catalina mbean onam = mbean server . queri name ( new object name ( catalina : ) , null ) ; assert equal ( found : onam , 0 , onam . size ( ) ) ; verifi ar correct tomcat mbean onam = mbean server . queri name ( new object name ( tomcat : ) , null ) ; arrai list string found = new arrai list string ( onam . size ( ) ) ; ( object name : onam ) { found . add ( . string ( ) ) ; } creat list expect mbean name string protocol = get tomcat instanc ( ) . get connector ( ) . get protocol handler class name ( ) ; ( protocol . index ( nio ) 0 ) { protocol = nio ; } els ( protocol . index ( apr ) 0 ) { protocol = apr ; } els { protocol = bio ; } arrai list string expect = new arrai list string ( arrai . list ( basic mbean name ( ) ) ) ; expect . add all ( arrai . list ( host mbean name ( localhost ) ) ) ; expect . add all ( arrai . list ( context mbean name ( localhost , context name ) ) ) ; expect . add all ( arrai . list ( connector mbean name ( integ . string ( get port ( ) ) , protocol ) ) ) ; expect . add all ( arrai . list ( option mbean name ( localhost ) ) ) ; did we find all expect mbean arrai list string miss = new arrai list string ( expect ) ; miss . remov all ( found ) ; assert true ( miss tomcat mbean : miss , miss . empti ( ) ) ; did we find ani unexpect mbean list string addit = found ; addit . remov all ( expect ) ; assert true ( unexpect tomcat mbean : addit , addit . empti ( ) ) ; tomcat . stop ( ) ; should still some tomcat mbean onam = mbean server . queri name ( new object name ( tomcat : ) , null ) ; assert true ( tomcat mbean , onam . size ( ) 0 ) ; add new host standard host host = new standard host ( ) ; host . set name ( otherhost ) ; tomcat . get engin ( ) . add child ( host ) ; final file context dir2 = new file ( get temporari directori ( ) , webapp foo2 ) ; add delet tear down ( context dir2 ) ; ( context dir2 . mkdir ( ) context dir2 . directori ( ) ) { fail ( fail creat : context dir2 . string ( ) ) ; } tomcat . add context ( host , context name 2 , context dir2 . get absolut path ( ) ) ; tomcat . start ( ) ; tomcat . stop ( ) ; tomcat . destroi ( ) ; should catalina mbean tomcat mbean onam = mbean server . queri name ( new object name ( catalina : ) , null ) ; assert equal ( remain : onam , 0 , onam . size ( ) ) ; onam = mbean server . queri name ( new object name ( tomcat : ) , null ) ; assert equal ( remain : onam , 0 , onam . size ( ) ) ; }	test public void test trail header ( ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; tomcat . add servlet ( ctx , servlet , new echo header servlet ( ) ) ; ctx . add servlet map ( , servlet ) ; tomcat . start ( ) ; string request = post echo param . jsp http 1 . 1 simpl http client . crlf host : ani simpl http client . crlf transfer encod : chunk simpl http client . crlf content type : applic x www form urlencod simpl http client . crlf connect : close simpl http client . crlf simpl http client . crlf 3 simpl http client . crlf = 0 simpl http client . crlf 4 simpl http client . crlf b = 1 simpl http client . crlf 0 simpl http client . crlf simpl http client . crlf ; trailer client client = new trailer client ( ) ; client . set port ( get port ( ) ) ; client . set request ( new string { request } ) ; client . connect ( ) ; client . process request ( ) ; assert equal ( null7nul , client . get respons bodi ( ) ) ; }	test public void test pipelin ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctxt = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; add protect servlet tomcat . add servlet ( ctxt , tester servlet , new tester servlet ( ) ) ; ctxt . add servlet map ( foo , tester servlet ) ; tomcat . start ( ) ; string request part1 = get foo http 1 . 1 simpl http client . crlf ; string request part2 = host : ani simpl http client . crlf simpl http client . crlf ; final client client = new client ( ) ; client . set port ( get port ( ) ) ; client . set request ( new string { request part1 , request part2 } ) ; client . set request paus ( 1000 ) ; client . set us content length ( true ) ; client . connect ( ) ; runnabl send = new runnabl ( ) { overrid } }	test public void test start stop bind start ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; connector c = tomcat . get connector ( ) ; c . set properti ( bind init , fals ) ; file app dir = new file ( get build directori ( ) , webapp exampl ) ; tomcat . add webapp ( null , exampl , app dir . get absolut path ( ) ) ; int port = get port ( ) ; tomcat . start ( ) ; tomcat . get connector ( ) . stop ( ) ; except e = null ; server socket s = null ; long pool = 0 ; long nativ socket = 0 ; boolean apr = tomcat . get connector ( ) . get protocol handler class name ( ) . contain ( apr ) ; try { thi should throw except ( apr ) { pool = creat apr pool ( ) ; assert true ( pool = 0 ) ; nativ socket = creat apr socket ( port , pool ) ; assert true ( nativ socket = 0 ) ; } els { s = new server socket ( port ) ; } } catch ( except e1 ) { e = e1 ; } final { try { ( apr ) { destroi apr socket ( nativ socket , pool ) ; } els ( s = null ) { s . close ( ) ; } } catch ( except e2 ) { ignor } } assert null ( e ) ; tomcat . get connector ( ) . start ( ) ; }	public void test stop ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; context root = tomcat . add context ( , temp dir ) ; wrapper w = tomcat . add servlet ( root , tester , new tester servlet ( ) ) ; w . set async support ( true ) ; root . add servlet map ( , tester ) ; connector connector = tomcat . get connector ( ) ; tomcat . start ( ) ; byte chunk bc = new byte chunk ( ) ; int rc = get url ( http : localhost : get port ( ) , bc , null , null ) ; assert equal ( 200 , rc ) ; assert equal ( ok , bc . string ( ) ) ; rc = 1 ; bc . recycl ( ) ; connector . stop ( ) ; try { rc = get url ( http : localhost : get port ( ) , bc , 1000 , null , null ) ; } catch ( socket timeout except ste ) { mai also see thi nio make sure test pass we do rc = 503 ; } assert equal ( 503 , rc ) ; }	public void test trail header ( ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; tomcat . add servlet ( ctx , servlet , new echo header servlet ( ) ) ; ctx . add servlet map ( , servlet ) ; tomcat . start ( ) ; string request = new string { post echo param . jsp http 1 . 1 simpl http client . crlf host : ani simpl http client . crlf transfer encod : chunk simpl http client . crlf content type : applic x www form urlencod simpl http client . crlf connect : close simpl http client . crlf simpl http client . crlf 3 simpl http client . crlf = 0 simpl http client . crlf 4 simpl http client . crlf b = 1 simpl http client . crlf 0 simpl http client . crlf x trailer : test , test simpl http client . crlf simpl http client . crlf } ; trailer client client = new trailer client ( ) ; client . set port ( get port ( ) ) ; client . set request ( request ) ; client . connect ( ) ; client . process request ( ) ; assert equal ( null7test test , client . get respons bodi ( ) ) ; }	test public void test trail header size limit ( ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; tomcat . add servlet ( ctx , servlet , new echo header servlet ( ) ) ; ctx . add servlet map ( , servlet ) ; limit size trail header tomcat . get connector ( ) . set properti ( max trailer size , 10 ) ; tomcat . start ( ) ; string request = new string { post echo param . jsp http 1 . 1 simpl http client . crlf host : ani simpl http client . crlf transfer encod : chunk simpl http client . crlf content type : applic x www form urlencod simpl http client . crlf connect : close simpl http client . crlf simpl http client . crlf 3 simpl http client . crlf = 0 simpl http client . crlf 4 simpl http client . crlf b = 1 simpl http client . crlf 0 simpl http client . crlf x trailer : test simpl http client . crlf simpl http client . crlf } ; trailer client client = new trailer client ( ) ; client . set port ( get port ( ) ) ; client . set request ( request ) ; client . connect ( ) ; client . process request ( ) ; expect fail becaus trailer ar longer than default limit 8kb assert true ( client . response500 ( ) ) ; }	test public void test tebuff ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; us normal tomcat root context file root = new file ( test webapp 3 . 0 ) ; tomcat . add webapp ( , root . get absolut path ( ) ) ; tomcat . start ( ) ; string request = post echo param . jsp http 1 . 1 simpl http client . crlf host : ani simpl http client . crlf transfer encod : buffer simpl http client . crlf content length : 9 simpl http client . crlf content type : applic x www form urlencod simpl http client . crlf simpl http client . crlf test = data ; client client = new client ( ) ; client . set port ( get port ( ) ) ; client . set request ( new string { request } ) ; client . connect ( ) ; client . process request ( ) ; assert true ( client . response501 ( ) ) ; }	test public void test teident ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; us normal tomcat root context file root = new file ( test webapp 3 . 0 ) ; tomcat . add webapp ( , root . get absolut path ( ) ) ; tomcat . start ( ) ; string request = post echo param . jsp http 1 . 1 simpl http client . crlf host : ani simpl http client . crlf transfer encod : ident simpl http client . crlf content length : 9 simpl http client . crlf content type : applic x www form urlencod simpl http client . crlf connect : close simpl http client . crlf simpl http client . crlf test = data ; client client = new client ( ) ; client . set port ( get port ( ) ) ; client . set request ( new string { request } ) ; client . connect ( ) ; client . process request ( ) ; assert true ( client . response200 ( ) ) ; assert true ( client . get respons bodi ( ) . contain ( test data ) ) ; }	test public void test tesav request ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; us normal tomcat root context file root = new file ( test webapp 3 . 0 ) ; tomcat . add webapp ( , root . get absolut path ( ) ) ; tomcat . start ( ) ; string request = post echo param . jsp http 1 . 1 simpl http client . crlf host : ani simpl http client . crlf transfer encod : savedrequest simpl http client . crlf content length : 9 simpl http client . crlf content type : applic x www form urlencod simpl http client . crlf simpl http client . crlf test = data ; client client = new client ( ) ; client . set port ( get port ( ) ) ; client . set request ( new string { request } ) ; client . connect ( ) ; client . process request ( ) ; assert true ( client . response501 ( ) ) ; }	test public void test teunsupport ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; us normal tomcat root context file root = new file ( test webapp 3 . 0 ) ; tomcat . add webapp ( , root . get absolut path ( ) ) ; tomcat . start ( ) ; string request = post echo param . jsp http 1 . 1 simpl http client . crlf host : ani simpl http client . crlf transfer encod : unsupport simpl http client . crlf content length : 9 simpl http client . crlf content type : applic x www form urlencod simpl http client . crlf simpl http client . crlf test = data ; client client = new client ( ) ; client . set port ( get port ( ) ) ; client . set request ( new string { request } ) ; client . connect ( ) ; client . process request ( ) ; assert true ( client . response501 ( ) ) ; }	public void test tevoid ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; us normal tomcat root context file root = new file ( test webapp 3 . 0 ) ; tomcat . add webapp ( , root . get absolut path ( ) ) ; tomcat . start ( ) ; string request = post echo param . jsp http 1 . 1 simpl http client . crlf host : ani simpl http client . crlf transfer encod : void simpl http client . crlf content length : 9 simpl http client . crlf content type : applic x www form urlencod simpl http client . crlf simpl http client . crlf test = data ; client client = new client ( ) ; client . set port ( get port ( ) ) ; client . set request ( new string { request } ) ; client . connect ( ) ; client . process request ( ) ; assert true ( client . response501 ( ) ) ; }	test { link remot ip filter } tomcat standalon server test public void test tomcat server ( ) throw except { mostli default configur : enabl x forward proto map string , string remot ip filter paramet = new hash map string , string ( ) ; remot ip filter paramet . put ( protocol header , x forward proto ) ; setup tomcat tomcat = get tomcat instanc ( ) ; context root = tomcat . add context ( , temp dir ) ; filter def filter def = new filter def ( ) ; filter def . get paramet map ( ) . put all ( remot ip filter paramet ) ; filter def . set filter class ( remot ip filter . class . get name ( ) ) ; filter def . set filter name ( remot ip filter . class . get name ( ) ) ; root . add filter def ( filter def ) ; filter map filter map = new filter map ( ) ; filter map . set filter name ( remot ip filter . class . get name ( ) ) ; filter map . add urlpattern ( ) ; root . add filter map ( filter map ) ; mock http servlet mock servlet = new mock http servlet ( ) ; tomcat . add servlet ( root , mock servlet . get class ( ) . get name ( ) , mock servlet ) ; root . add servlet map ( test , mock servlet . get class ( ) . get name ( ) ) ; get tomcat instanc ( ) . start ( ) ; test http urlconnect http urlconnect = ( http urlconnect ) new url ( http : localhost : tomcat . get connector ( ) . get port ( ) test ) . open connect ( ) ; string expect remot addr = my remot addr ; http urlconnect . add request properti ( x forward , expect remot addr ) ; http urlconnect . add request properti ( x forward proto , http ) ; valid assert . assert equal ( http urlconnect . http ok , http urlconnect . get respons code ( ) ) ; http servlet request request = mock servlet . get request ( ) ; assert . assert null ( request ) ; valid x foward assert . assert equal ( expect remot addr , request . get remot addr ( ) ) ; assert . assert equal ( expect remot addr , request . get remot host ( ) ) ; valid x forward proto assert . assert true ( request . secur ( ) ) ; assert . assert equal ( http , request . get scheme ( ) ) ; assert . assert equal ( 443 , request . get server port ( ) ) ; }
public synchron add alia exist host . param name name host param alia alia add void add host alia ( string name , string alia ) { int po = find ( host , name ) ; ( po 0 ) { just case . . . return ; } host real host = host po ; host new host = new host host . length 1 ; host new host = new host ( ) ; new host . name = alia ; new host . context list = real host . context list ; new host . object = real host ; ( insert map ( host , new host , new host ) ) { host = new host ; } }	public void set up ( ) throw except { mapper = new mapper ( ) ; mapper . add host ( sjbjdvwsbvhrb , new string 0 , blah1 ) ; mapper . add host ( sjbjdvwsbvhr , new string 0 , blah1 ) ; mapper . add host ( wekhfewuifweuibf , new string 0 , blah2 ) ; mapper . add host ( ylwrehirkuewh , new string 0 , blah3 ) ; mapper . add host ( iohgeoihro , new string 0 , blah4 ) ; mapper . add host ( fwehoihoihwfeo , new string 0 , blah5 ) ; mapper . add host ( owefojiwefoi , new string 0 , blah6 ) ; mapper . add host ( iowejoiejfoiew , new string 0 , blah7 ) ; mapper . add host ( iowejoiejfoiew , new string 0 , blah17 ) ; mapper . add host ( ohewoihfewoih , new string 0 , blah8 ) ; mapper . add host ( fewohfoweoih , new string 0 , blah9 ) ; mapper . add host ( ttthtiuhwoih , new string 0 , blah10 ) ; mapper . add host ( lkwefjwojweffewoih , new string 0 , blah11 ) ; mapper . add host ( , new string 0 , blah12 ) ; mapper . add host ( xxxxgqwiwoih , new string 0 , blah13 ) ; mapper . add host ( qwigqwiwoih , new string 0 , blah14 ) ; mapper . set default host name ( ylwrehirkuewh ) ; string welcom = new string 2 ; welcom 0 = boo baba ; welcom 1 = bobou ; mapper . add context version ( iowejoiejfoiew , blah7 , , 0 , context0 , new string 0 , null ) ; mapper . add context version ( iowejoiejfoiew , blah7 , foo , 0 , context1 , new string 0 , null ) ; mapper . add context version ( iowejoiejfoiew , blah7 , foo bar , 0 , context2 , welcom , null ) ; mapper . add context version ( iowejoiejfoiew , blah7 , foo bar bla , 0 , context3 , new string 0 , null ) ; mapper . add wrapper ( iowejoiejfoiew , foo bar , 0 , fo , wrapper0 , fals , fals ) ; mapper . add wrapper ( iowejoiejfoiew , foo bar , 0 , , wrapper1 , fals , fals ) ; mapper . add wrapper ( iowejoiejfoiew , foo bar , 0 , blh , wrapper2 , fals , fals ) ; mapper . add wrapper ( iowejoiejfoiew , foo bar , 0 , . jsp , wrapper3 , fals , fals ) ; mapper . add wrapper ( iowejoiejfoiew , foo bar , 0 , blah bou , wrapper4 , fals , fals ) ; mapper . add wrapper ( iowejoiejfoiew , foo bar , 0 , blah bobou , wrapper5 , fals , fals ) ; mapper . add wrapper ( iowejoiejfoiew , foo bar , 0 , . htm , wrapper6 , fals , fals ) ; mapper . add wrapper ( iowejoiejfoiew , foo bar bla , 0 , bobou , wrapper7 , fals , fals ) ; }	test public void test add host ( ) throw except { check we have right number ( add 16 duplic ) assert equal ( 15 , mapper . host . length ) ; make sure ad duplic doe overwrit assert equal ( blah7 , mapper . host 3 . object ) ; check alphabet order host name string previou ; string current = mapper . host 0 . name ; ( int i = 1 ; i mapper . host . length ; i ) { previou = current ; current = mapper . host i . name ; assert true ( previou . compar ( current ) 0 ) ; } }	test public void test map ( ) throw except { map data map data = new map data ( ) ; messag byte host = messag byte . new instanc ( ) ; host . set string ( iowejoiejfoiew ) ; messag byte uri = messag byte . new instanc ( ) ; uri . set string ( foo bar blah bobou foo ) ; uri . char ( ) ; uri . get char chunk ( ) . set limit ( 1 ) ; mapper . map ( host , uri , null , map data ) ; assert equal ( blah7 , map data . host ) ; assert equal ( context2 , map data . context ) ; assert equal ( wrapper5 , map data . wrapper ) ; assert equal ( foo bar , map data . context path . string ( ) ) ; assert equal ( blah bobou , map data . wrapper path . string ( ) ) ; assert equal ( foo , map data . path info . string ( ) ) ; assert true ( map data . redirect path . null ( ) ) ; map data . recycl ( ) ; uri . recycl ( ) ; uri . set string ( foo bar bla bobou foo ) ; uri . char ( ) ; uri . get char chunk ( ) . set limit ( 1 ) ; mapper . map ( host , uri , null , map data ) ; assert equal ( blah7 , map data . host ) ; assert equal ( context3 , map data . context ) ; assert equal ( wrapper7 , map data . wrapper ) ; assert equal ( foo bar bla , map data . context path . string ( ) ) ; assert equal ( bobou , map data . wrapper path . string ( ) ) ; assert equal ( foo , map data . path info . string ( ) ) ; assert true ( map data . redirect path . null ( ) ) ; }
public return deleg first flag thi class loader . boolean get deleg ( ) { return ( thi . deleg ) ; }
privat static void initi ssl ( ) throw class found except , method except , illeg access except , invoc target except { ( off . equal ignor case ( sslengin ) ) { return ; } ( ssl initi ) { onli onc per vm return ; } ssl initi = true ; string method name = rand set ; class param type = new class 1 ; param type 0 = string . class ; object param valu = new object 1 ; param valu 0 = sslrandom seed ; class clazz = class . name ( org . apach . tomcat . jni . ssl ) ; method method = clazz . get method ( method name , param type ) ; method . invok ( null , param valu ) ; method name = initi ; param valu 0 = . equal ignor case ( sslengin ) null : sslengin ; method = clazz . get method ( method name , param type ) ; method . invok ( null , param valu ) ; ssl avail = true ; }	privat static void termin apr ( ) throw class found except , method except , illeg access except , invoc target except { string method name = termin ; method method = class . name ( org . apach . tomcat . jni . librari ) . get method ( method name , ( class ) null ) ; method . invok ( null , ( object ) null ) ; apr avail = fals ; apr initi = fals ; well we clean pool termin . ssl initi = fals ; well we clean pool termin . ssl avail = fals ; }	primari entri point startup shutdown event . param event event ha occur overrid public void lifecycl event ( lifecycl event event ) { ( lifecycl . befor init event . equal ( event . get type ( ) ) ) { synchron ( lock ) { init ( ) ; ( apr avail ) { try { initi ssl ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . info ( sm . get string ( apr listen . ssl init ) ) ; } } } } els ( lifecycl . after destroi event . equal ( event . get type ( ) ) ) { synchron ( lock ) { ( apr avail ) { return ; } try { termin apr ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . info ( sm . get string ( apr listen . apr destroi ) ) ; } } } }	public void set sslengin ( string sslengin ) { apr lifecycl listen . sslengin = sslengin ; }	public void set sslrandom seed ( string sslrandom seed ) { apr lifecycl listen . sslrandom seed = sslrandom seed ; }
return url resourc map specifi path . path must begin interpret rel current context root . param path path desir resourc except malform urlexcept path given correct form overrid public url get resourc ( string path ) throw malform urlexcept { ( path = = null path . start ( ) get resourc requir slash ) throw new malform urlexcept ( sm . get string ( applic context . request dispatch . iae , path ) ) ; string norm path = request util . normal ( path ) ; ( norm path = = null ) return ( null ) ; dir context resourc = context . get resourc ( ) ; ( resourc = null ) { string full path = context . get path ( ) norm path ; string host name = context . get parent ( ) . get name ( ) ; try { resourc . lookup ( path ) ; return new url ( jndi , , 0 , get jndiuri ( host name , full path ) , new dir context urlstream handler ( resourc ) ) ; } catch ( name except e ) { ignor } catch ( except e ) { unexpect log ( sm . get string ( applic context . lookup . error , path , get context path ( ) ) , e ) ; } } return ( null ) ; }
public creat new standard context . param parent mbean name associ parent compon param path context path thi context param doc base document base directori ( war ) thi context except except mbean cannot creat regist string creat standard context ( string parent , string path , string doc base , boolean xml valid , boolean xml namespac awar , boolean tld valid , boolean tld namespac awar ) throw except { creat new standard context instanc standard context context = new standard context ( ) ; path = get path str ( path ) ; context . set path ( path ) ; context . set doc base ( doc base ) ; context . set xml valid ( xml valid ) ; context . set xml namespac awar ( xml namespac awar ) ; context . set tld valid ( tld valid ) ; context . set tld namespac awar ( tld namespac awar ) ; context config context config = new context config ( ) ; context . add lifecycl listen ( context config ) ; add new instanc parent compon object name pname = new object name ( parent ) ; object name deploy = new object name ( pname . get domain ( ) : type = deploy , host = pname . get kei properti ( host ) ) ; ( mserver . regist ( deploy ) ) { string context name = context . get name ( ) ; mserver . invok ( deploy , add servic , new object { context name } , new string { java . lang . string } ) ; string config path = ( string ) mserver . get attribut ( deploy , config base name ) ; string base name = context . get base name ( ) ; file config file = new file ( new file ( config path ) , base name . xml ) ; context . set config file ( config file . uri ( ) . url ( ) ) ; mserver . invok ( deploy , manag app , new object { context } , new string { org . apach . catalina . context } ) ; mserver . invok ( deploy , remov servic , new object { context name } , new string { java . lang . string } ) ; } els { log . warn ( deploy found pname . get kei properti ( host ) ) ; servic servic = get servic ( pname ) ; engin engin = ( engin ) servic . get contain ( ) ; host host = ( host ) engin . find child ( pname . get kei properti ( host ) ) ; host . add child ( context ) ; } return correspond mbean name return context . get object name ( ) . string ( ) ; }
public static input stream get input stream ( string fname , jar file jar file , jsp compil context ctxt , error dispatch err ) throw jasper except , ioexcept { input stream = null ; ( jar file = null ) { string jar entri name = fname . substr ( 1 , fname . length ( ) ) ; zip entri jar entri = jar file . get entri ( jar entri name ) ; ( jar entri = = null ) { err . jsp error ( jsp . error . file . . found , fname ) ; } = jar file . get input stream ( jar entri ) ; } els { = ctxt . get resourc stream ( fname ) ; } ( = = null ) { err . jsp error ( jsp . error . file . . found , fname ) ; } return ; }	public = = = = = = = = = = = = = = = = = = = = manipul class = = = = = = = = = = = = = = = = = = = = class load ( ) throw jasper except { try { get jsp loader ( ) ; string name = get fqcn ( ) ; servlet class = jsp loader . load class ( name ) ; } catch ( class found except cex ) { throw new jasper except ( local . get messag ( jsp . error . unabl . load ) , cex ) ; } catch ( except ex ) { throw new jasper except ( local . get messag ( jsp . error . unabl . compil ) , ex ) ; } remov = 0 ; return servlet class ; }
privat boolean comet support ( ) { string protocol = get tomcat instanc ( ) . get connector ( ) . get protocol handler class name ( ) ; ( protocol . index ( nio ) = = 1 protocol . index ( apr ) = = 1 ) { return fals ; } els { return true ; } }	event method . return fals indic error , expect overrid public boolean event ( org . apach . coyot . request req , org . apach . coyot . respons re , socket statu statu ) { request request = ( request ) req . get note ( adapt note ) ; respons respons = ( respons ) re . get note ( adapt note ) ; ( request . get wrapper ( ) = = null ) { return fals ; } boolean error = fals ; boolean read = fals ; try { ( statu = = socket statu . open ) { ( respons . close ( ) ) { event ha been close asynchron , so call end instead read cleanup pipelin request . get event ( ) . set event type ( comet event . event type . end ) ; request . get event ( ) . set event sub type ( null ) ; } els { try { fill read buffer servlet layer ( request . read ( ) ) { read = true ; } } catch ( ioexcept e ) { error = true ; } ( read ) { request . get event ( ) . set event type ( comet event . event type . read ) ; request . get event ( ) . set event sub type ( null ) ; } els ( error ) { request . get event ( ) . set event type ( comet event . event type . error ) ; request . get event ( ) . set event sub type ( comet event . event sub type . client disconnect ) ; } els { request . get event ( ) . set event type ( comet event . event type . end ) ; request . get event ( ) . set event sub type ( null ) ; } } } els ( statu = = socket statu . disconnect ) { request . get event ( ) . set event type ( comet event . event type . error ) ; request . get event ( ) . set event sub type ( comet event . event sub type . client disconnect ) ; error = true ; } els ( statu = = socket statu . error ) { request . get event ( ) . set event type ( comet event . event type . error ) ; request . get event ( ) . set event sub type ( comet event . event sub type . ioexcept ) ; error = true ; } els ( statu = = socket statu . stop ) { request . get event ( ) . set event type ( comet event . event type . end ) ; request . get event ( ) . set event sub type ( comet event . event sub type . server shutdown ) ; } els ( statu = = socket statu . timeout ) { ( respons . close ( ) ) { event ha been close asynchron , so call end instead read cleanup pipelin request . get event ( ) . set event type ( comet event . event type . end ) ; request . get event ( ) . set event sub type ( null ) ; } els { request . get event ( ) . set event type ( comet event . event type . error ) ; request . get event ( ) . set event sub type ( comet event . event sub type . timeout ) ; } } req . get request processor ( ) . set worker thread name ( thread . current thread ( ) . get name ( ) ) ; call contain connector . get servic ( ) . get contain ( ) . get pipelin ( ) . get first ( ) . event ( request , respons , request . get event ( ) ) ; ( error respons . close ( ) ( request . get attribut ( request dispatch . error except ) = null ) ) { unexpect except occur while process event , so error should call request . get event ( ) . set event type ( comet event . event type . error ) ; request . get event ( ) . set event sub type ( null ) ; error = true ; connector . get servic ( ) . get contain ( ) . get pipelin ( ) . get first ( ) . event ( request , respons , request . get event ( ) ) ; } ( respons . close ( ) request . comet ( ) ) { ( statu = = socket statu . open request . get event ( ) . get event type ( ) = event type . end ) { comet event . close wa call dure event other than end request . get event ( ) . set event type ( comet event . event type . end ) ; request . get event ( ) . set event sub type ( null ) ; error = true ; connector . get servic ( ) . get contain ( ) . get pipelin ( ) . get first ( ) . event ( request , respons , request . get event ( ) ) ; } re . action ( action code . comet end , null ) ; } els ( error read request . get avail ( ) ) { thi wa read all byte have been read , data wa read from connector , error request . get event ( ) . set event type ( comet event . event type . error ) ; request . get event ( ) . set event sub type ( comet event . event sub type . ioexcept ) ; error = true ; connector . get servic ( ) . get contain ( ) . get pipelin ( ) . get first ( ) . event ( request , respons , request . get event ( ) ) ; } return ( error ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; ( ( t instanceof ioexcept ) ) { log . error ( sm . get string ( coyot adapt . servic ) , t ) ; } error = true ; return fals ; } final { req . get request processor ( ) . set worker thread name ( null ) ; recycl wrapper request respons ( error respons . close ( ) request . comet ( ) ) { request . recycl ( ) ; request . set filter chain ( null ) ; respons . recycl ( ) ; } } }	privat boolean comet support ( ) { string protocol = get tomcat instanc ( ) . get connector ( ) . get protocol handler class name ( ) ; ( protocol . index ( nio ) = = 1 protocol . index ( apr ) = = 1 ) { return fals ; } els { return true ; } }	servic method . overrid public void servic ( org . apach . coyot . request req , org . apach . coyot . respons re ) throw except { request request = ( request ) req . get note ( adapt note ) ; respons respons = ( respons ) re . get note ( adapt note ) ; ( request = = null ) { creat object request = connector . creat request ( ) ; request . set coyot request ( req ) ; respons = connector . creat respons ( ) ; respons . set coyot respons ( re ) ; link object request . set respons ( respons ) ; respons . set request ( request ) ; set note req . set note ( adapt note , request ) ; re . set note ( adapt note , respons ) ; set queri string encod req . get paramet ( ) . set queri string encod ( connector . get uriencod ( ) ) ; } ( connector . get xpower ( ) ) { respons . add header ( x power , power ) ; } boolean comet = fals ; boolean async = fals ; try { pars set catalina configur specif request paramet req . get request processor ( ) . set worker thread name ( thread . current thread ( ) . get name ( ) ) ; boolean post pars success = post pars request ( req , request , re , respons ) ; ( post pars success ) { check valv we support async request . set async support ( connector . get servic ( ) . get contain ( ) . get pipelin ( ) . async support ( ) ) ; call contain connector . get servic ( ) . get contain ( ) . get pipelin ( ) . get first ( ) . invok ( request , respons ) ; ( request . comet ( ) ) { ( respons . close ( ) respons . error ( ) ) { ( request . get avail ( ) ( request . get content length ( ) 0 ( request . paramet pars ( ) ) ) ) { invok read event right awai ar avail byte ( event ( req , re , socket statu . open ) ) { comet = true ; re . action ( action code . comet begin , null ) ; } } els { comet = true ; re . action ( action code . comet begin , null ) ; } } els { clear filter chain , otherwis reset elsewher sinc thi comet request request . set filter chain ( null ) ; } } } async context impl async con impl = ( async context impl ) request . get async context ( ) ; ( async con impl = null ) { async = true ; } els ( comet ) { request . finish request ( ) ; respons . finish respons ( ) ; ( post pars success ) { log onli process wa invok . post pars request ( ) fail , ha alreadi log . ( ( context ) request . get map data ( ) . context ) . log access ( request , respons , system . current time milli ( ) req . get start time ( ) , fals ) ; } req . action ( action code . post request , null ) ; } } catch ( ioexcept e ) { ignor } final { req . get request processor ( ) . set worker thread name ( null ) ; recycl wrapper request respons ( comet async ) { request . recycl ( ) ; respons . recycl ( ) ; } els { clear convert so minimum amount memori us thi processor request . clear encod ( ) ; respons . clear encod ( ) ; } } }	test public void test simpl comet client ( ) throw except { ( comet support ( ) ) { return ; } setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; context root = tomcat . add context ( , temp dir ) ; tomcat . add servlet ( root , comet , new simpl comet servlet ( ) ) ; root . add servlet map ( , comet ) ; tomcat . start ( ) ; creat connect comet servlet final socket socket = socket factori . get default ( ) . creat socket ( localhost , get port ( ) ) ; socket . set so timeout ( 60000 ) ; final output stream os = socket . get output stream ( ) ; string request line = post http : localhost : get port ( ) http 1 . 1 r n ; os . write ( request line . get byte ( ) ) ; os . write ( transfer encod : chunk r n . get byte ( ) ) ; os . write ( r n . get byte ( ) ) ; ping writer thread write thread = new ping writer thread ( 4 , os ) ; write thread . start ( ) ; socket . set so timeout ( 25000 ) ; input stream = socket . get input stream ( ) ; respons reader thread read thread = new respons reader thread ( ) ; read thread . start ( ) ; read thread . join ( ) ; os . close ( ) ; . close ( ) ; valid respons string respons = read thread . get respons ( ) . split ( r n ) ; assert equal ( http 1 . 1 200 ok , respons 0 ) ; assert equal ( server : apach coyot 1 . 1 , respons 1 ) ; assert true ( respons 2 . start ( set cooki : jsessionid = ) ) ; assert equal ( content type : text plain ; charset = iso 8859 1 , respons 3 ) ; assert equal ( transfer encod : chunk , respons 4 ) ; assert true ( respons 5 . start ( date : ) ) ; assert equal ( , respons 6 ) ; assert equal ( 7 , respons 7 ) ; assert equal ( begin , respons 8 ) ; assert equal ( , respons 9 ) ; assert equal ( 17 , respons 10 ) ; assert equal ( client : read : 4 byte , respons 11 ) ; assert equal ( , respons 12 ) ; assert equal ( 17 , respons 13 ) ; assert equal ( client : read : 4 byte , respons 14 ) ; assert equal ( , respons 15 ) ; assert equal ( 17 , respons 16 ) ; assert equal ( client : read : 4 byte , respons 17 ) ; assert equal ( , respons 18 ) ; assert equal ( 17 , respons 19 ) ; assert equal ( client : read : 4 byte , respons 20 ) ; assert equal ( , respons 21 ) ; assert equal ( d , respons 22 ) ; assert equal ( client : end , respons 23 ) ; assert equal ( , respons 24 ) ; assert equal ( 0 , respons 25 ) ; expect 26 line assert equal ( 26 , respons . length ) ; }
convert ( necessari ) return absolut url repres resourc referenc thi possibl rel url . thi url alreadi absolut , return unchang . param locat url ( possibl ) convert return except illeg argument except malform urlexcept thrown when convert rel url absolut protect string absolut ( string locat ) { ( locat = = null ) return ( locat ) ; boolean lead slash = locat . start ( ) ; ( lead slash ha scheme ( locat ) ) { redirect urlcc . recycl ( ) ; string scheme = request . get scheme ( ) ; string name = request . get server name ( ) ; int port = request . get server port ( ) ; try { redirect urlcc . append ( scheme , 0 , scheme . length ( ) ) ; redirect urlcc . append ( : , 0 , 3 ) ; redirect urlcc . append ( name , 0 , name . length ( ) ) ; ( ( scheme . equal ( http ) port = 80 ) ( scheme . equal ( http ) port = 443 ) ) { redirect urlcc . append ( : ) ; string port s = port ; redirect urlcc . append ( port s , 0 , port s . length ( ) ) ; } ( lead slash ) { string rel path = request . get decod request uri ( ) ; int po = rel path . last index ( ) ; rel path = rel path . substr ( 0 , po ) ; string encod uri = null ; final string frel path = rel path ; ( secur util . packag protect enabl ( ) ) { try { encod uri = access control . do privileg ( new privileg except action string ( ) { overrid } } } } } } }
send temporari redirect specifi redirect locat url . param locat locat url redirect except illeg state except thi respons ha alreadi been commit except ioexcept input output error occur overrid public void send redirect ( string locat ) throw ioexcept { ( commit ( ) ) throw new illeg state except ( sm . get string ( coyot respons . send redirect . ) ) ; ignor ani call from includ servlet ( includ ) return ; clear ani data content ha been buffer reset buffer ( true ) ; gener temporari redirect specifi locat try { string absolut = absolut ( locat ) ; set statu ( sc found ) ; set header ( locat , absolut ) ; print writer writer = get writer ( ) ; writer . print ( sm . get string ( coyot respons . send redirect . note , request util . filter ( absolut ) ) ) ; flush buffer ( ) ; } catch ( illeg argument except e ) { set statu ( sc found ) ; } caus respons finish ( from applic perspect ) set suspend ( true ) ; }
overrid protect log get logger ( ) { return log ; }	extract desir request properti , pass ( along comet event filter chain ) protect code process ( ) code method perform actual filter . param event comet event process param chain filter chain thi event except ioexcept input output error occur except servlet except servlet error occur overrid public void do filter event ( comet event event , comet filter chain chain ) throw ioexcept , servlet except { process comet event ( event . get http servlet request ( ) . get remot host ( ) , event , chain ) ; }
protect void servic ( final http servlet request req , final http servlet respons resp ) throw servlet except , ioexcept { ( boolean . true = = req . get attribut ( dispatch ) ) { log . info ( receiv dispatch , complet worker thread . ) ; log . info ( after complet call start : req . async start ( ) ) ; resp . get writer ( ) . write ( async dispatch work : system . current time milli ( ) n ) ; req . get async context ( ) . complet ( ) ; } els { resp . set content type ( text plain ) ; final async context actx = req . start async ( ) ; actx . set timeout ( long . max valu ) ; runnabl run = new runnabl ( ) { overrid } } }
process comet event . main differ here ar us send error ( respons commit ) , avoid creat new filter chain ( which would work pointless ) , few veri minor tweak . param request servlet request process param respons servlet respons creat except ioexcept input output error occur , thrown subsequ invok valv , filter , servlet except servlet except servlet error occur , thrown subsequ invok valv , filter , servlet overrid public void event ( request request , respons respons , comet event event ) throw ioexcept , servlet except { initi local variabl we mai need throwabl throwabl = null ; thi should request attribut . . . long t1 = system . current time milli ( ) ; fixm : add flag count total amount event process request count ; standard wrapper wrapper = ( standard wrapper ) get contain ( ) ; servlet servlet = null ; context context = ( context ) wrapper . get parent ( ) ; check applic mark unavail boolean unavail = context . get avail ( ) wrapper . unavail ( ) ; alloc servlet instanc process thi request try { ( unavail ) { servlet = wrapper . alloc ( ) ; } } catch ( unavail except e ) { respons alreadi commit , so s possibl do anyth } catch ( servlet except e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . alloc except , wrapper . get name ( ) ) , standard wrapper . get root caus ( e ) ) ; throwabl = e ; except ( request , respons , e ) ; } catch ( throwabl e ) { except util . handl throwabl ( e ) ; contain . get logger ( ) . error ( sm . get string ( standard wrapper . alloc except , wrapper . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; servlet = null ; } messag byte request path mb = request . get request path mb ( ) ; request . set attribut ( applic filter factori . dispatch type attr , dispatch type . request ) ; request . set attribut ( applic filter factori . dispatch request path attr , request path mb ) ; get current ( unchang ) filter chain thi request applic filter chain filter chain = ( applic filter chain ) request . get filter chain ( ) ; note : thi also call servlet s event ( ) method try { ( ( servlet = null ) ( filter chain = null ) ) { swallow output need ( context . get swallow output ( ) ) { try { system log handler . start captur ( ) ; filter chain . do filter event ( request . get event ( ) ) ; } final { string log = system log handler . stop captur ( ) ; ( log = null log . length ( ) 0 ) { context . get logger ( ) . info ( log ) ; } } } els { filter chain . do filter event ( request . get event ( ) ) ; } } } catch ( client abort except e ) { throwabl = e ; except ( request , respons , e ) ; } catch ( ioexcept e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . servic except , wrapper . get name ( ) , context . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; } catch ( unavail except e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . servic except , wrapper . get name ( ) , context . get name ( ) ) , e ) ; do save except throwabl , becaus we do want do except ( request , respons , e ) process } catch ( servlet except e ) { throwabl root caus = standard wrapper . get root caus ( e ) ; ( ( root caus instanceof client abort except ) ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . servic except root , wrapper . get name ( ) , context . get name ( ) , e . get messag ( ) ) , root caus ) ; } throwabl = e ; except ( request , respons , e ) ; } catch ( throwabl e ) { except util . handl throwabl ( e ) ; contain . get logger ( ) . error ( sm . get string ( standard wrapper . servic except , wrapper . get name ( ) , context . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; } releas filter chain ( ani ) thi request ( filter chain = null ) { filter chain . reus ( ) ; } dealloc alloc servlet instanc try { ( servlet = null ) { wrapper . dealloc ( servlet ) ; } } catch ( throwabl e ) { except util . handl throwabl ( e ) ; contain . get logger ( ) . error ( sm . get string ( standard wrapper . dealloc except , wrapper . get name ( ) ) , e ) ; ( throwabl = = null ) { throwabl = e ; except ( request , respons , e ) ; } } unload releas thi instanc try { ( ( servlet = null ) ( wrapper . get avail ( ) = = long . max valu ) ) { wrapper . unload ( ) ; } } catch ( throwabl e ) { except util . handl throwabl ( e ) ; contain . get logger ( ) . error ( sm . get string ( standard wrapper . unload except , wrapper . get name ( ) ) , e ) ; ( throwabl = = null ) { throwabl = e ; except ( request , respons , e ) ; } } long t2 = system . current time milli ( ) ; long time = t2 t1 ; process time = time ; ( time max time ) max time = time ; ( time min time ) min time = time ; }
stop endpoint . thi caus all process thread stop . overrid public void stop intern ( ) { releas connect latch ( ) ; ( paus ) { paus ( ) ; } ( run ) { run = fals ; unlock accept ( ) ; ( int i = 0 ; i acceptor . length ; i ) { long s = system . current time milli ( ) 30000 ; while ( acceptor i . aliv ( ) ) { try { acceptor i . interrupt ( ) ; acceptor i . join ( 1000 ) ; } catch ( interrupt except e ) { ignor } ( system . current time milli ( ) = s ) { log . warn ( sm . get string ( endpoint . warn . unlock acceptor fail , acceptor i . get name ( ) ) ) ; hard socket close . ( server sock = 0 ) { socket . shutdown ( server sock , socket . apr shutdown read ) ; server sock = 0 ; } } } } ( int i = 0 ; i poller . length ; i ) { try { poller i . destroi ( ) ; } catch ( except e ) { ignor } } poller = null ; ( int i = 0 ; i comet poller . length ; i ) { try { comet poller i . destroi ( ) ; } catch ( except e ) { ignor } } comet poller = null ; ( us sendfil ) { ( int i = 0 ; i sendfil . length ; i ) { try { sendfil i . destroi ( ) ; } catch ( except e ) { ignor } } sendfil = null ; } } shutdown executor ( ) ; }
protect pars host . void pars host ( messag byte valu mb ) { ( valu mb = = null valu mb . null ( ) ) { http 1 . 0 request . set server port ( request . get local port ( ) ) ; try { request . server name ( ) . duplic ( request . local name ( ) ) ; } catch ( ioexcept e ) { respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } return ; } byte chunk valu bc = valu mb . get byte chunk ( ) ; byte valu b = valu bc . get byte ( ) ; int valu l = valu bc . get length ( ) ; int valu s = valu bc . get start ( ) ; int colon po = 1 ; ( host name c . length valu l ) { host name c = new char valu l ; } boolean ipv6 = ( valu b valu s = = ) ; boolean bracket close = fals ; ( int i = 0 ; i valu l ; i ) { char b = ( char ) valu b i valu s ; host name c i = b ; ( b = = ) { bracket close = true ; } els ( b = = : ) { ( ipv6 bracket close ) { colon po = i ; break ; } } } ( colon po 0 ) { ( request . scheme ( ) . equal ignor case ( http ) ) { 443 default http port request . set server port ( 443 ) ; } els { 80 default htttp port request . set server port ( 80 ) ; } request . server name ( ) . set char ( host name c , 0 , valu l ) ; } els { request . server name ( ) . set char ( host name c , 0 , colon po ) ; int port = 0 ; int mult = 1 ; ( int i = valu l 1 ; i colon po ; i ) { int char valu = hex util . get dec ( valu b i valu s ) ; ( char valu = = 1 ) { invalid charact error = true ; 400 bad request respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; break ; } port = port ( char valu mult ) ; mult = 10 mult ; } request . set server port ( port ) ; } }	protect pars host . void pars host ( messag byte valu mb ) { ( valu mb = = null valu mb . null ( ) ) { http 1 . 0 host header , us port info from endpoint host obtain lazili from socket requir us action code req local name attribut request . set server port ( endpoint . get port ( ) ) ; return ; } byte chunk valu bc = valu mb . get byte chunk ( ) ; byte valu b = valu bc . get byte ( ) ; int valu l = valu bc . get length ( ) ; int valu s = valu bc . get start ( ) ; int colon po = 1 ; ( host name c . length valu l ) { host name c = new char valu l ; } boolean ipv6 = ( valu b valu s = = ) ; boolean bracket close = fals ; ( int i = 0 ; i valu l ; i ) { char b = ( char ) valu b i valu s ; host name c i = b ; ( b = = ) { bracket close = true ; } els ( b = = : ) { ( ipv6 bracket close ) { colon po = i ; break ; } } } ( colon po 0 ) { ( endpoint . sslenabl ( ) ) { 80 default http port request . set server port ( 80 ) ; } els { 443 default http port request . set server port ( 443 ) ; } request . server name ( ) . set char ( host name c , 0 , valu l ) ; } els { request . server name ( ) . set char ( host name c , 0 , colon po ) ; int port = 0 ; int mult = 1 ; ( int i = valu l 1 ; i colon po ; i ) { int char valu = hex util . get dec ( valu b i valu s ) ; ( char valu = = 1 char valu 9 ) { invalid charact error = true ; 400 bad request respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; break ; } port = port ( char valu mult ) ; mult = 10 mult ; } request . set server port ( port ) ; } }	protect after read request header , we have setup request filter . void prepar request ( ) { translat http method code string . byte method code = request header messag . get byte ( ) ; ( method code = constant . sc m jk store ) { string method name = constant . get method code ( method code 1 ) ; request . method ( ) . set string ( method name ) ; } request header messag . get byte ( request . protocol ( ) ) ; request header messag . get byte ( request . request uri ( ) ) ; request header messag . get byte ( request . remot addr ( ) ) ; request header messag . get byte ( request . remot host ( ) ) ; request header messag . get byte ( request . local name ( ) ) ; request . set local port ( request header messag . get int ( ) ) ; boolean ssl = request header messag . get byte ( ) = 0 ; ( ssl ) { request . scheme ( ) . set string ( http ) ; } decod header mime header header = request . get mime header ( ) ; int h count = request header messag . get int ( ) ; ( int i = 0 ; i h count ; i ) { string h name = null ; header name ar encod either integ code start 0x a0 , normal string ( which case first two byte ar length ) . int isc = request header messag . peek int ( ) ; int h id = isc 0x ff ; messag byte v mb = null ; isc = 0x ff00 ; ( 0x a000 = = isc ) { advanc read posit request header messag . get int ( ) ; h name = constant . get header code ( h id 1 ) ; v mb = header . add valu ( h name ) ; } els { reset h id header current read happen 7 8 byte long , code below think s content type header content length header sc req content type = 7 , sc req content length = 8 lead unexpect behaviour . see bug 5861 more inform . h id = 1 ; request header messag . get byte ( tmp mb ) ; byte chunk bc = tmp mb . get byte chunk ( ) ; v mb = header . add valu ( bc . get buffer ( ) , bc . get start ( ) , bc . get length ( ) ) ; } request header messag . get byte ( v mb ) ; ( h id = = constant . sc req content length ( h id = = 1 tmp mb . equal ignor case ( content length ) ) ) { just read content length header , so set long cl = v mb . get long ( ) ; ( cl integ . max valu ) request . set content length ( ( int ) cl ) ; } els ( h id = = constant . sc req content type ( h id = = 1 tmp mb . equal ignor case ( content type ) ) ) { just read content type header , so set byte chunk bchunk = v mb . get byte chunk ( ) ; request . content type ( ) . set byte ( bchunk . get byte ( ) , bchunk . get offset ( ) , bchunk . get length ( ) ) ; } } decod extra attribut boolean secret = fals ; byte attribut code ; while ( ( attribut code = request header messag . get byte ( ) ) = constant . sc ar done ) { switch ( attribut code ) { case constant . sc req attribut : request header messag . get byte ( tmp mb ) ; string n = tmp mb . string ( ) ; request header messag . get byte ( tmp mb ) ; string v = tmp mb . string ( ) ; ajp13 miss forward remot port . allow ajp connector add thi info via privat request attribut . we accept forward data remot port , remov from public list request attribut . ( n . equal ( constant . sc req remot port ) ) { try { request . set remot port ( integ . pars int ( v ) ) ; } catch ( number format except nfe ) { ignor invalid valu } } els { request . set attribut ( n , v ) ; } break ; case constant . sc context : request header messag . get byte ( tmp mb ) ; noth break ; case constant . sc servlet path : request header messag . get byte ( tmp mb ) ; noth break ; case constant . sc remot user : ( tomcat authent ) { ignor server request header messag . get byte ( tmp mb ) ; } els { request header messag . get byte ( request . get remot user ( ) ) ; } break ; case constant . sc auth type : ( tomcat authent ) { ignor server request header messag . get byte ( tmp mb ) ; } els { request header messag . get byte ( request . get auth type ( ) ) ; } break ; case constant . sc queri string : request header messag . get byte ( request . queri string ( ) ) ; break ; case constant . sc jvm rout : request header messag . get byte ( request . instanc id ( ) ) ; break ; case constant . sc ssl cert : request . scheme ( ) . set string ( http ) ; ssl certif extract lazi , move jk coyot handler request header messag . get byte ( certif ) ; break ; case constant . sc ssl cipher : request . scheme ( ) . set string ( http ) ; request header messag . get byte ( tmp mb ) ; request . set attribut ( sslsupport . cipher suit kei , tmp mb . string ( ) ) ; break ; case constant . sc ssl session : request . scheme ( ) . set string ( http ) ; request header messag . get byte ( tmp mb ) ; request . set attribut ( sslsupport . session id kei , tmp mb . string ( ) ) ; break ; case constant . sc ssl kei size : request . set attribut ( sslsupport . kei size kei , integ . valu ( request header messag . get int ( ) ) ) ; break ; case constant . sc store method : request header messag . get byte ( request . method ( ) ) ; break ; case constant . sc secret : request header messag . get byte ( tmp mb ) ; ( requir secret = null ) { secret = true ; ( tmp mb . equal ( requir secret ) ) { respons . set statu ( 403 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } break ; default : ignor unknown attribut backward compat break ; } } check secret wa submit requir ( ( requir secret = null ) secret ) { respons . set statu ( 403 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } check full uri ( includ protocol : host : port ) byte chunk uri bc = request . request uri ( ) . get byte chunk ( ) ; ( uri bc . start ignor case ( http , 0 ) ) { int po = uri bc . index ( : , 0 , 3 , 4 ) ; int uri bcstart = uri bc . get start ( ) ; int slash po = 1 ; ( po = 1 ) { byte uri b = uri bc . get byte ( ) ; slash po = uri bc . index ( , po 3 ) ; ( slash po = = 1 ) { slash po = uri bc . get length ( ) ; set uri request . request uri ( ) . set byte ( uri b , uri bcstart po 1 , 1 ) ; } els { request . request uri ( ) . set byte ( uri b , uri bcstart slash po , uri bc . get length ( ) slash po ) ; } messag byte host mb = header . set valu ( host ) ; host mb . set byte ( uri b , uri bcstart po 3 , slash po po 3 ) ; } } messag byte valu mb = request . get mime header ( ) . get valu ( host ) ; pars host ( valu mb ) ; }	protect after read request header , we have setup request filter . void prepar request ( ) { http11 = true ; http09 = fals ; content delimit = fals ; expect = fals ; prepar request intern ( ) ; ( endpoint . sslenabl ( ) ) { request . scheme ( ) . set string ( http ) ; } messag byte protocol mb = request . protocol ( ) ; ( protocol mb . equal ( constant . http 11 ) ) { http11 = true ; protocol mb . set string ( constant . http 11 ) ; } els ( protocol mb . equal ( constant . http 10 ) ) { http11 = fals ; keep aliv = fals ; protocol mb . set string ( constant . http 10 ) ; } els ( protocol mb . equal ( ) ) { http 0 . 9 http09 = true ; http11 = fals ; keep aliv = fals ; } els { unsupport protocol http11 = fals ; error = true ; send 505 ; unsupport http version ( get log ( ) . debug enabl ( ) ) { get log ( ) . debug ( sm . get string ( http11processor . request . prepar ) unsupport http version protocol mb ) ; } respons . set statu ( 505 ) ; adapt . log ( request , respons , 0 ) ; } messag byte method mb = request . method ( ) ; ( method mb . equal ( constant . get ) ) { method mb . set string ( constant . get ) ; } els ( method mb . equal ( constant . post ) ) { method mb . set string ( constant . post ) ; } mime header header = request . get mime header ( ) ; check connect header messag byte connect valu mb = header . get valu ( connect ) ; ( connect valu mb = null ) { byte chunk connect valu bc = connect valu mb . get byte chunk ( ) ; ( find byte ( connect valu bc , constant . close byte ) = 1 ) { keep aliv = fals ; } els ( find byte ( connect valu bc , constant . keepal byte ) = 1 ) { keep aliv = true ; } } messag byte expect mb = null ; ( http11 ) expect mb = header . get valu ( expect ) ; ( ( expect mb = null ) ( expect mb . index ignor case ( 100 continu , 0 ) = 1 ) ) { get input buffer ( ) . set swallow input ( fals ) ; expect = true ; } check user agent header ( ( restrict user agent = null ) ( ( http11 ) ( keep aliv ) ) ) { messag byte user agent valu mb = header . get valu ( user agent ) ; keep aliv flag accordingli ( user agent valu mb = null ) { string user agent valu = user agent valu mb . string ( ) ; ( restrict user agent = null restrict user agent . matcher ( user agent valu ) . match ( ) ) { http11 = fals ; keep aliv = fals ; } } } check full uri ( includ protocol : host : port ) byte chunk uri bc = request . request uri ( ) . get byte chunk ( ) ; ( uri bc . start ignor case ( http , 0 ) ) { int po = uri bc . index ( : , 0 , 3 , 4 ) ; int uri bcstart = uri bc . get start ( ) ; int slash po = 1 ; ( po = 1 ) { byte uri b = uri bc . get byte ( ) ; slash po = uri bc . index ( , po 3 ) ; ( slash po = = 1 ) { slash po = uri bc . get length ( ) ; set uri request . request uri ( ) . set byte ( uri b , uri bcstart po 1 , 1 ) ; } els { request . request uri ( ) . set byte ( uri b , uri bcstart slash po , uri bc . get length ( ) slash po ) ; } messag byte host mb = header . set valu ( host ) ; host mb . set byte ( uri b , uri bcstart po 3 , slash po po 3 ) ; } } input filter setup input filter input filter = get input buffer ( ) . get filter ( ) ; pars transfer encod header messag byte transfer encod valu mb = null ; ( http11 ) transfer encod valu mb = header . get valu ( transfer encod ) ; ( transfer encod valu mb = null ) { string transfer encod valu = transfer encod valu mb . string ( ) ; pars comma separ list . ident code ar ignor int start po = 0 ; int comma po = transfer encod valu . index ( , ) ; string encod name = null ; while ( comma po = 1 ) { encod name = transfer encod valu . substr ( start po , comma po ) . lower case ( local . english ) . trim ( ) ; ( add input filter ( input filter , encod name ) ) { unsupport transfer encod error = true ; 501 unimpl respons . set statu ( 501 ) ; adapt . log ( request , respons , 0 ) ; } start po = comma po 1 ; comma po = transfer encod valu . index ( , , start po ) ; } encod name = transfer encod valu . substr ( start po ) . lower case ( local . english ) . trim ( ) ; ( add input filter ( input filter , encod name ) ) { unsupport transfer encod error = true ; 501 unimpl ( get log ( ) . debug enabl ( ) ) { get log ( ) . debug ( sm . get string ( http11processor . request . prepar ) unsupport transfer encod encod name ) ; } respons . set statu ( 501 ) ; adapt . log ( request , respons , 0 ) ; } } pars content length header long content length = request . get content length long ( ) ; ( content length = 0 content delimit ) { get input buffer ( ) . add activ filter ( input filter constant . ident filter ) ; content delimit = true ; } messag byte valu mb = header . get valu ( host ) ; check host header ( http11 ( valu mb = = null ) ) { error = true ; 400 bad request ( get log ( ) . debug enabl ( ) ) { get log ( ) . debug ( sm . get string ( http11processor . request . prepar ) host header miss ) ; } respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; } pars host ( valu mb ) ; ( content delimit ) { s content length ( broken http 1 . 0 http 1 . 1 ) , assum client broken didn t send bodi get input buffer ( ) . add activ filter ( input filter constant . void filter ) ; content delimit = true ; } advertis sendfil support through request attribut ( endpoint . get us sendfil ( ) ) { request . set attribut ( org . apach . tomcat . sendfil . support , boolean . true ) ; } advertis comet support through request attribut ( endpoint . get us comet ( ) ) { request . set attribut ( org . apach . tomcat . comet . support , boolean . true ) ; } advertis comet timeout support ( endpoint . get us comet timeout ( ) ) { request . set attribut ( org . apach . tomcat . comet . timeout . support , boolean . true ) ; } }	process pipelin http request us specifi input output stream . throw ioexcept error dure i o oper overrid public socket state process ( socket wrapper long socket ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set up socket thi . socket = socket ; long socket ref = socket . get socket ( ) . long valu ( ) ; socket . setrbb ( socket ref , input buffer ) ; socket . setsbb ( socket ref , output buffer ) ; boolean cping = fals ; error flag error = fals ; boolean kept aliv = fals ; while ( error endpoint . paus ( ) ) { pars request header try { get first messag request ( read messag ( request header messag , true , kept aliv ) ) { method should return true break ; } check messag type , process right awai break regular request process int type = request header messag . get byte ( ) ; ( type = = constant . jk ajp13 cping request ) { ( endpoint . paus ( ) ) { recycl ( true ) ; break ; } cping = true ; ( socket . send ( socket ref , pong messag arrai , 0 , pong messag arrai . length ) 0 ) { error = true ; } continu ; } els ( type = constant . jk ajp13 forward request ) { been swallow finish ( ) . ( log . debug enabl ( ) ) { log . debug ( unexpect messag : type ) ; } error = true ; break ; } kept aliv = true ; request . set start time ( system . current time milli ( ) ) ; } catch ( ioexcept e ) { error = true ; break ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . debug ( sm . get string ( ajpprocessor . header . error ) , t ) ; 400 bad request respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } ( error ) { set up filter , pars some request header rp . set stage ( org . apach . coyot . constant . stage prepar ) ; try { prepar request ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . debug ( sm . get string ( ajpprocessor . request . prepar ) , t ) ; 400 intern server error respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } ( cping endpoint . paus ( ) ) { 503 servic unavail respons . set statu ( 503 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } cping = fals ; process request adapt ( error ) { try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; adapt . servic ( request , respons ) ; } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( sm . get string ( ajpprocessor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } ( async ( ) error ) { break ; } finish respons done yet ( finish ) { try { finish ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; error = true ; } } error , updat statist counter ( error ) { respons . set statu ( 500 ) ; } request . updat counter ( ) ; rp . set stage ( org . apach . coyot . constant . stage keepal ) ; recycl ( fals ) ; } rp . set stage ( org . apach . coyot . constant . stage end ) ; ( error endpoint . paus ( ) ) { ( async ( ) ) { return socket state . long ; } els { return socket state . open ; } } els { return socket state . close ; } }	process pipelin http request us specifi input output stream . throw ioexcept error dure i o oper overrid public socket state process ( socket wrapper nio channel socket ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set up socket thi . socket = socket . get socket ( ) ; long so timeout = endpoint . get so timeout ( ) ; boolean cping = fals ; error flag error = fals ; while ( error endpoint . paus ( ) ) { pars request header try { get first messag request int byte read = read messag ( request header messag , fals ) ; ( byte read = = 0 ) { break ; } set back timeout keep aliv timeout enabl ( keep aliv timeout 0 ) { socket . set timeout ( so timeout ) ; } check messag type , process right awai break regular request process int type = request header messag . get byte ( ) ; ( type = = constant . jk ajp13 cping request ) { ( endpoint . paus ( ) ) { recycl ( true ) ; break ; } cping = true ; try { output ( pong messag arrai , 0 , pong messag arrai . length ) ; } catch ( ioexcept e ) { error = true ; } recycl ( fals ) ; continu ; } els ( type = constant . jk ajp13 forward request ) { been swallow finish ( ) . ( log . debug enabl ( ) ) { log . debug ( unexpect messag : type ) ; } error = true ; recycl ( true ) ; break ; } request . set start time ( system . current time milli ( ) ) ; } catch ( ioexcept e ) { error = true ; break ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . debug ( sm . get string ( ajpprocessor . header . error ) , t ) ; 400 bad request respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } ( error ) { set up filter , pars some request header rp . set stage ( org . apach . coyot . constant . stage prepar ) ; try { prepar request ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . debug ( sm . get string ( ajpprocessor . request . prepar ) , t ) ; 400 intern server error respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } ( cping endpoint . paus ( ) ) { 503 servic unavail respons . set statu ( 503 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } cping = fals ; process request adapt ( error ) { try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; adapt . servic ( request , respons ) ; } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( sm . get string ( ajpprocessor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } ( async ( ) error ) { break ; } finish respons done yet ( finish ) { try { finish ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; error = true ; } } error , updat statist counter ( error ) { respons . set statu ( 500 ) ; } request . updat counter ( ) ; rp . set stage ( org . apach . coyot . constant . stage keepal ) ; set keep aliv timeout enabl ( keep aliv timeout 0 ) { socket . set timeout ( keep aliv timeout ) ; } recycl ( fals ) ; } rp . set stage ( org . apach . coyot . constant . stage end ) ; ( error endpoint . paus ( ) ) { ( async ( ) ) { return socket state . long ; } els { return socket state . open ; } } els { return socket state . close ; } }	process pipelin http request us specifi input output stream . param socket wrapper socket from which http request read http respons written . throw ioexcept error dure i o oper overrid public socket state process ( socket wrapper s socket wrapper ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set up i o set socket wrapper ( socket wrapper ) ; get input buffer ( ) . init ( socket wrapper , endpoint ) ; get output buffer ( ) . init ( socket wrapper , endpoint ) ; flag error = fals ; keep aliv = true ; comet = fals ; open socket = fals ; sendfil progress = fals ; read complet = true ; ( endpoint . get us poll ( ) ) { kept aliv = fals ; } els { kept aliv = socket wrapper . kept aliv ( ) ; } ( disabl keep aliv ( ) ) { socket wrapper . set keep aliv left ( 0 ) ; } while ( error keep aliv comet async ( ) endpoint . paus ( ) ) { pars request header try { set request line read timeout ( ) ; ( get input buffer ( ) . pars request line ( kept aliv ) ) { ( handl incomplet request line read ( ) ) { break ; } } ( endpoint . paus ( ) ) { 503 servic unavail respons . set statu ( 503 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } els { request . set start time ( system . current time milli ( ) ) ; kept aliv = true ; current onli nio ever return fals here ( get input buffer ( ) . pars header ( ) ) { we ve read part request , don t recycl instead associ socket open socket = true ; read complet = fals ; break ; } ( disabl upload timeout ) { set socket timeout ( connect upload timeout ) ; } } } catch ( ioexcept e ) { ( get log ( ) . debug enabl ( ) ) { get log ( ) . debug ( sm . get string ( http11processor . header . pars ) , e ) ; } error = true ; break ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; ( get log ( ) . debug enabl ( ) ) { get log ( ) . debug ( sm . get string ( http11processor . header . pars ) , t ) ; } 400 bad request respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } ( error ) { set up filter , pars some request header rp . set stage ( org . apach . coyot . constant . stage prepar ) ; try { prepar request ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; ( get log ( ) . debug enabl ( ) ) { get log ( ) . debug ( sm . get string ( http11processor . request . prepar ) , t ) ; } 400 intern server error respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } ( max keep aliv request = = 1 ) { keep aliv = fals ; } els ( max keep aliv request 0 socket wrapper . decrement keep aliv ( ) = 0 ) { keep aliv = fals ; } process request adapt ( error ) { try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; adapt . servic ( request , respons ) ; commit , so we can t try set header . ( keep aliv error ) { avoid check twice . error = respons . get error except ( ) = null ( async ( ) statu drop connect ( respons . get statu ( ) ) ) ; } set comet timeout ( socket wrapper ) ; } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; get log ( ) . error ( sm . get string ( http11processor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } finish handl request rp . set stage ( org . apach . coyot . constant . stage endinput ) ; ( async ( ) comet ) { ( error ) { we know we ar close connect , don t drain input . thi wai upload 100gb file doesn t tie up thread servlet ha reject . get input buffer ( ) . set swallow input ( fals ) ; } end request ( ) ; } rp . set stage ( org . apach . coyot . constant . stage endoutput ) ; error , updat statist counter ( error ) { respons . set statu ( 500 ) ; } request . updat counter ( ) ; ( async ( ) comet error ) { get input buffer ( ) . next request ( ) ; get output buffer ( ) . next request ( ) ; } ( disabl upload timeout ) { set socket timeout ( endpoint . get so timeout ( ) ) ; } rp . set stage ( org . apach . coyot . constant . stage keepal ) ; ( break keep aliv loop ( socket wrapper ) ) { break ; } } rp . set stage ( org . apach . coyot . constant . stage end ) ; ( error endpoint . paus ( ) ) { return socket state . close ; } els ( async ( ) comet ) { return socket state . long ; } els { ( sendfil progress ) { return socket state . sendfil ; } els { ( open socket ) { ( read complet ) { return socket state . open ; } els { return socket state . long ; } } els { return socket state . close ; } } } }	process pipelin http request us specifi input output stream . throw ioexcept error dure i o oper overrid public socket state process ( socket wrapper socket socket ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set up socket thi . socket = socket ; input = socket . get socket ( ) . get input stream ( ) ; output = socket . get socket ( ) . get output stream ( ) ; int so timeout = 1 ; ( keep aliv timeout 0 ) { so timeout = socket . get socket ( ) . get so timeout ( ) ; } boolean cping = fals ; error flag error = fals ; while ( error endpoint . paus ( ) ) { pars request header try { set keep aliv timeout enabl ( keep aliv timeout 0 ) { socket . get socket ( ) . set so timeout ( keep aliv timeout ) ; } get first messag request ( read messag ( request header messag ) ) { thi mean connect timeout break ; } set back timeout keep aliv timeout enabl ( keep aliv timeout 0 ) { socket . get socket ( ) . set so timeout ( so timeout ) ; } check messag type , process right awai break regular request process int type = request header messag . get byte ( ) ; ( type = = constant . jk ajp13 cping request ) { ( endpoint . paus ( ) ) { recycl ( true ) ; break ; } cping = true ; try { output . write ( pong messag arrai ) ; } catch ( ioexcept e ) { error = true ; } continu ; } els ( type = constant . jk ajp13 forward request ) { been swallow finish ( ) . ( log . debug enabl ( ) ) { log . debug ( unexpect messag : type ) ; } error = true ; break ; } request . set start time ( system . current time milli ( ) ) ; } catch ( ioexcept e ) { error = true ; break ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . debug ( sm . get string ( ajpprocessor . header . error ) , t ) ; 400 bad request respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } ( error ) { set up filter , pars some request header rp . set stage ( org . apach . coyot . constant . stage prepar ) ; try { prepar request ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . debug ( sm . get string ( ajpprocessor . request . prepar ) , t ) ; 400 intern server error respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } ( cping endpoint . paus ( ) ) { 503 servic unavail respons . set statu ( 503 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } cping = fals ; process request adapt ( error ) { try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; adapt . servic ( request , respons ) ; } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( sm . get string ( ajpprocessor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } ( async ( ) error ) { break ; } finish respons done yet ( finish ) { try { finish ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; error = true ; } } error , updat statist counter ( error ) { respons . set statu ( 500 ) ; } request . updat counter ( ) ; rp . set stage ( org . apach . coyot . constant . stage keepal ) ; recycl ( fals ) ; } rp . set stage ( org . apach . coyot . constant . stage end ) ; ( async ( ) error endpoint . paus ( ) ) { return socket state . long ; } els { input = null ; output = null ; return socket state . close ; } }	public void end request ( ) { finish handl request try { get input buffer ( ) . end request ( ) ; } catch ( ioexcept e ) { error = true ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; get log ( ) . error ( sm . get string ( http11processor . request . finish ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } try { get output buffer ( ) . end request ( ) ; } catch ( ioexcept e ) { error = true ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; get log ( ) . error ( sm . get string ( http11processor . respons . finish ) , t ) ; error = true ; } }	overrid public void log ( org . apach . coyot . request req , org . apach . coyot . respons re , long time ) { request request = ( request ) req . get note ( adapt note ) ; respons respons = ( respons ) re . get note ( adapt note ) ; boolean creat = fals ; ( request = = null ) { creat = true ; creat object request = connector . creat request ( ) ; request . set coyot request ( req ) ; respons = connector . creat respons ( ) ; respons . set coyot respons ( re ) ; link object request . set respons ( respons ) ; respons . set request ( request ) ; set note req . set note ( adapt note , request ) ; re . set note ( adapt note , respons ) ; set queri string encod req . get paramet ( ) . set queri string encod ( connector . get uriencod ( ) ) ; } try { log lowest level avail . log access ( ) automat call parent contain . boolean log = fals ; ( request . map data = null ) { ( request . map data . context = null ) { log = true ; ( ( context ) request . map data . context ) . log access ( request , respons , time , true ) ; } els ( request . map data . host = null ) { log = true ; ( ( host ) request . map data . host ) . log access ( request , respons , time , true ) ; } } ( log ) { connector . get servic ( ) . get contain ( ) . log access ( request , respons , time , true ) ; } } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . warn ( sm . get string ( coyot adapt . accesslog fail ) , t ) ; } ( creat ) { request . recycl ( ) ; respons . recycl ( ) ; } }
public static int post url ( byte bodi , string path , byte chunk out , map string , list string >> req head , map string , list string >> re head ) throw ioexcept { url url = new url ( path ) ; http urlconnect connect = ( http urlconnect ) url . open connect ( ) ; connect . set do output ( true ) ; connect . set read timeout ( 1000000 ) ; ( req head = null ) { ( map . entri string , list string >> entri : req head . entri set ( ) ) { string builder valu list = new string builder ( ) ; ( string valu : entri . get valu ( ) ) { ( valu list . length ( ) 0 ) { valu list . append ( , ) ; } valu list . append ( valu ) ; } connect . set request properti ( entri . get kei ( ) , valu list . string ( ) ) ; } } connect . connect ( ) ; write request bodi output stream os = null ; try { os = connect . get output stream ( ) ; ( bodi = null ) { os . write ( bodi , 0 , bodi . length ) ; } } final { ( os = null ) { try { os . close ( ) ; } catch ( ioexcept ioe ) { ignor } } } int rc = connect . get respons code ( ) ; ( re head = null ) { map string , list string >> head = connect . get header field ( ) ; re head . put all ( head ) ; } ( rc = = http servlet respons . sc ok ) { input stream = connect . get input stream ( ) ; buffer input stream bi = null ; try { bi = new buffer input stream ( ) ; byte buf = new byte 2048 ; int rd = 0 ; while ( ( rd = bi . read ( buf ) ) 0 ) { out . append ( buf , 0 , rd ) ; } } final { ( bi = null ) { try { bi . close ( ) ; } catch ( ioexcept e ) { ignor } } } } return rc ; }	befor public void set up ( ) throw except { need us juli so log messag from test ar visibl system . set properti ( java . util . log . manag , org . apach . juli . class loader log manag ) ; system . set properti ( java . util . log . config . file , new file ( get build directori ( ) , conf log . properti ) . string ( ) ) ; temp dir = new file ( system . get properti ( tomcat . test . temp , output tmp ) ) ; ( temp dir . mkdir ( ) temp dir . directori ( ) ) { fail ( unabl creat temporari directori test ) ; } system . set properti ( catalina . base , temp dir . get absolut path ( ) ) ; trigger load catalina . properti catalina properti . get properti ( foo ) ; file app base = new file ( temp dir , webapp ) ; ( app base . exist ( ) app base . mkdir ( ) ) { fail ( unabl creat app base test ) ; } tomcat = new tomcat ( ) ; string protocol = get protocol ( ) ; connector connector = new connector ( protocol ) ; each test run same port thei mai interfer each other connector . set port ( get next port ( ) ) ; mainli set reduc timeout dure async test connector . set attribut ( connect timeout , 3000 ) ; tomcat . get servic ( ) . add connector ( connector ) ; tomcat . set connector ( connector ) ; add apr lifecycl listen we ar us apr connector ( protocol . contain ( apr ) ) { standard server server = ( standard server ) tomcat . get server ( ) ; apr lifecycl listen listen = new apr lifecycl listen ( ) ; listen . set sslrandom seed ( dev urandom ) ; server . add lifecycl listen ( listen ) ; connector . set attribut ( poller thread count , integ . valu ( 1 ) ) ; } tomcat . set base dir ( temp dir . get absolut path ( ) ) ; tomcat . get host ( ) . set app base ( app base . get absolut path ( ) ) ; access log enabl = boolean . pars boolean ( system . get properti ( tomcat . test . accesslog , fals ) ) ; ( access log enabl ) { access log valv alv = new access log valv ( ) ; alv . set directori ( get build directori ( ) log ) ; alv . set pattern ( h l u t r s b i d ) ; tomcat . get host ( ) . get pipelin ( ) . add valv ( alv ) ; } }
return kei associ given alia . param alia alia name return request kei , null alia can t found overrid public privat kei get privat kei ( string alia ) { return deleg . get privat kei ( alia ) ; }	choos alia authent client side secur socket , given public kei type list certif issuer author recogn peer ( ani ) . param kei type kei algorithm type name ( s ) , order most prefer kei type first param issuer list accept ca issuer subject name , null doe matter which issuer ar us param socket socket us thi connect . thi paramet can null , which case thi method return most gener alia us return alia name desir kei , null ar match overrid public string choos client alia ( string kei type , princip issuer , socket socket ) { return deleg . choos client alia ( kei type , issuer , socket ) ; }
sinc el 2 . 2 overrid public object invok ( elcontext context , object base , object method , class param type , object param ) { ( context = = null ) { throw new null pointer except ( ) ; } ( base = = null method = = null ) { return null ; } express factori factori = express factori . new instanc ( ) ; string method name = ( string ) factori . coerc type ( method , string . class ) ; find match method method match method = null ; class clazz = base . get class ( ) ; ( param type = null ) { try { match method = get method ( clazz , clazz . get method ( method name , param type ) ) ; } catch ( method except e ) { throw new method found except ( e ) ; } } els { int param count = 0 ; ( param = null ) { param count = param . length ; } method method = clazz . get method ( ) ; ( method m : method ) { ( method name . equal ( m . get name ( ) ) m . get paramet type ( ) . length = = param count ) { same number paramet us first match match method = get method ( clazz , m ) ; break ; } ( m . var arg ( ) ) { match method = get method ( clazz , m ) ; } } ( match method = = null ) { throw new method found except ( unabl find method method name param count paramet ) ; } } class paramet type = match method . get paramet type ( ) ; object paramet = null ; ( paramet type . length 0 ) { paramet = new object paramet type . length ; param . length = paramet type . length suppress warn ( null ) int param count = param . length ; ( match method . var arg ( ) ) { int var arg index = paramet type . length 1 ; first arg count 1 paramet ar standard ( int i = 0 ; ( i var arg index 1 ) ; i ) { paramet i = factori . coerc type ( param i , paramet type i ) ; } last paramet varag class var arg class = paramet type var arg index . get compon type ( ) ; ( int i = ( var arg index ) ; i param count ; i ) { object vararg = arrai . new instanc ( paramet type param count , ( param count var arg index ) ) ; arrai . set ( vararg , i , factori . coerc type ( param i , var arg class ) ) ; paramet var arg index = vararg ; } } els { paramet = new object paramet type . length ; ( int i = 0 ; i paramet type . length ; i ) { paramet i = factori . coerc type ( param i , paramet type i ) ; } } } object result = null ; try { result = match method . invok ( base , paramet ) ; } catch ( illeg argument except e ) { throw new elexcept ( e ) ; } catch ( illeg access except e ) { throw new elexcept ( e ) ; } catch ( invoc target except e ) { throw new elexcept ( e . get caus ( ) ) ; } context . set properti resolv ( true ) ; return result ; }
public static string expand ( host host , url war , string pathnam ) throw ioexcept { make sure directori alreadi exist file doc base = new file ( host . get app base file ( ) , pathnam ) ; ( doc base . exist ( ) ) { war file alreadi instal return ( doc base . get absolut path ( ) ) ; } creat new document base directori doc base . mkdir ( ) ; expand war new document base directori string canon doc base prefix = doc base . get canon path ( ) ; ( canon doc base prefix . end ( file . separ ) ) { canon doc base prefix = file . separ ; } jar urlconnect juc = ( jar urlconnect ) war . open connect ( ) ; juc . set us cach ( fals ) ; jar file jar file = null ; input stream input = null ; boolean success = fals ; try { jar file = juc . get jar file ( ) ; enumer jar entri jar entri = jar file . entri ( ) ; while ( jar entri . ha more element ( ) ) { jar entri jar entri = jar entri . next element ( ) ; string name = jar entri . get name ( ) ; file expand file = new file ( doc base , name ) ; ( expand file . get canon path ( ) . start ( canon doc base prefix ) ) { throw except stop deploy throw new illeg argument except ( sm . get string ( expand war . illeg path , war , name , expand file . get canon path ( ) , canon doc base prefix ) ) ; } int last = name . last index ( ) ; ( last = 0 ) { file parent = new file ( doc base , name . substr ( 0 , last ) ) ; ( parent . mkdir ( ) parent . directori ( ) ) { throw new ioexcept ( sm . get string ( expand war . creat fail , parent ) ) ; } } ( name . end ( ) ) { continu ; } input = jar file . get input stream ( jar entri ) ; bugzilla 33636 expand ( input , expand file ) ; long last modifi = jar entri . get time ( ) ; ( ( last modifi = 1 ) ( last modifi = 0 ) ) { expand file . set last modifi ( last modifi ) ; } input . close ( ) ; input = null ; } success = true ; } catch ( ioexcept e ) { throw e ; } final { ( success ) { someth went wrong , delet expand dir keep thing clean delet dir ( doc base ) ; } ( input = null ) { try { input . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } input = null ; } ( jar file = null ) { try { jar file . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } jar file = null ; } } return absolut path our new document base directori return ( doc base . get absolut path ( ) ) ; }
overrid public void lifecycl event ( lifecycl event event ) { initialis class when tomcat start ( lifecycl . befor init event . equal ( event . get type ( ) ) ) { class loader loader = thread . current thread ( ) . get context class loader ( ) ; try { us system classload victim all thi class loader pin we re about do . thread . current thread ( ) . set context class loader ( class loader . get system class loader ( ) ) ; first call thi load all driver current class loader ( driver manag protect ) { driver manag . get driver ( ) ; } issu . ( app context protect ) { imag io . get cach directori ( ) ; } etc . ) thread ( awt thread protect ) { java . awt . toolkit . get default toolkit ( ) ; } sever compon end up call : sun . misc . gc . request latenc ( long ) those librari compon known trigger memori leak due eventu call request latenc ( long ) ar : javax . manag . remot . rmi . rmiconnector server . start ( ) ( gc daemon protect ) { try { class clazz = class . name ( sun . misc . gc ) ; method method = clazz . get declar method ( request latenc , new class { long . class } ) ; method . invok ( null , long . valu ( 3600000 ) ) ; } catch ( class found except e ) { ( system . get properti ( java . vendor ) . start ( sun ) ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } els { log . debug ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } } catch ( secur except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } catch ( method except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } catch ( illeg argument except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } catch ( illeg access except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } catch ( invoc target except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } } call get polici retain static refer context class loader . ( secur polici protect ) { try { polici . get polici ( ) ; class polici class = class . name ( javax . secur . auth . polici ) ; method method = polici class . get method ( get polici ) ; method . invok ( null ) ; } catch ( class found except e ) { ignor . class deprec . } catch ( secur except e ) { ignor . don t need call get polici ( ) success , just need trigger static initi . } catch ( method except e ) { log . warn ( sm . get string ( jre leak listen . auth polici fail ) , e ) ; } catch ( illeg argument except e ) { log . warn ( sm . get string ( jre leak listen . auth polici fail ) , e ) ; } catch ( illeg access except e ) { log . warn ( sm . get string ( jre leak listen . auth polici fail ) , e ) ; } catch ( invoc target except e ) { log . warn ( sm . get string ( jre leak listen . auth polici fail ) , e ) ; } } initi javax . secur . auth . login . configur retain static refer context class loader . ( secur login configur protect ) { try { class . name ( javax . secur . auth . login . configur , true , class loader . get system class loader ( ) ) ; } catch ( class found except e ) { ignor } } creat messag digest dure web applic startup initi java cryptographi architectur . under certain condit thi start token poller thread tccl equal web applic class loader . instead we initi jca right now . ( token poller protect ) { java . secur . secur . get provid ( ) ; } set default url cach polici cach ( url cach protect ) { try { doesn t matter thi jar doesn t exist just long url well form url url = new url ( jar : file : dummi . jar ) ; urlconnect u conn = url . open connect ( ) ; u conn . set default us cach ( fals ) ; } catch ( malform urlexcept e ) { log . error ( sm . get string ( jre leak listen . jar url conn cach fail ) , e ) ; } catch ( ioexcept e ) { log . error ( sm . get string ( jre leak listen . jar url conn cach fail ) , e ) ; } } haven t got root what go thi leak web app first make call below web applic class loader pin memori . ( xml pars protect ) { document builder factori factori = document builder factori . new instanc ( ) ; try { factori . new document builder ( ) ; } catch ( parser configur except e ) { log . error ( sm . get string ( jre leak listen . xml pars fail ) , e ) ; } } ( ldap pool protect ) { try { class . name ( com . sun . jndi . ldap . ldap pool manag ) ; } catch ( class found except e ) { ( system . get properti ( java . vendor ) . start ( sun ) ) { log . error ( sm . get string ( jre leak listen . ldap pool manag fail ) , e ) ; } els { log . debug ( sm . get string ( jre leak listen . ldap pool manag fail ) , e ) ; } } } } final { thread . current thread ( ) . set context class loader ( loader ) ; } } }	public boolean gc daemon protect ( ) { return gc daemon protect ; }
public string get ssl implemen name ( ) { return ssl implemen name ; }	lifecycl method overrid public void init ( ) throw except { ssl implement need place befor end point initi ssl implement = sslimplement . get instanc ( ssl implemen name ) ; super . init ( ) ; }	public void test custom ssl implement ( ) throw except { tester support . configur client ssl ( ) ; tomcat tomcat = get tomcat instanc ( ) ; connector connector = tomcat . get connector ( ) ; ( connector . get protocol handler class name ( ) . contain ( apr ) ) { thi test onli jsse base ssl connector return ; } connector . set properti ( ssl implemen name , org . apach . tomcat . util . net . jsse . tester bug50640ssl impl ) ; connector . set properti ( tester bug50640ssl impl . properti name , tester bug50640ssl impl . properti valu ) ; connector . set properti ( ssl protocol , tl ) ; file keystor file = new file ( test org apach tomcat util net localhost . jk ) ; connector . set attribut ( keystor file , keystor file . get absolut path ( ) ) ; connector . set secur ( true ) ; connector . set properti ( sslenabl , true ) ; file app dir = new file ( get build directori ( ) , webapp exampl ) ; tomcat . add webapp ( null , exampl , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; byte chunk re = get url ( http : localhost : get port ( ) exampl servlet servlet hello world exampl ) ; assert true ( re . string ( ) . index ( h1 hello world h1 ) 0 ) ; }
protect log get log ( ) { return log ; }
protect finish ajp respons . void finish ( ) throw ioexcept { ( respons . commit ( ) ) { valid write respons header try { prepar respons ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } ( finish ) return ; finish = true ; add end messag ( error ) { output ( end close messag arrai , 0 , end close messag arrai . length ) ; } els { output ( end messag arrai , 0 , end messag arrai . length ) ; } }	process pipelin http request us specifi input output stream . throw ioexcept error dure i o oper overrid public socket state process ( socket wrapper long socket ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set up socket thi . socket = socket ; long socket ref = socket . get socket ( ) . long valu ( ) ; socket . setrbb ( socket ref , input buffer ) ; socket . setsbb ( socket ref , output buffer ) ; error flag error = fals ; boolean kept aliv = fals ; while ( error endpoint . paus ( ) ) { pars request header try { get first messag request ( read messag ( request header messag , true , kept aliv ) ) { method should return true break ; } check messag type , process right awai break regular request process int type = request header messag . get byte ( ) ; ( type = = constant . jk ajp13 cping request ) { ( socket . send ( socket ref , pong messag arrai , 0 , pong messag arrai . length ) 0 ) { error = true ; } continu ; } els ( type = constant . jk ajp13 forward request ) { usual servlet didn t read previou request bodi ( log . debug enabl ( ) ) { log . debug ( unexpect messag : type ) ; } continu ; } kept aliv = true ; request . set start time ( system . current time milli ( ) ) ; } catch ( ioexcept e ) { error = true ; break ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . debug ( sm . get string ( ajpprocessor . header . error ) , t ) ; 400 bad request respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } ( error ) { set up filter , pars some request header rp . set stage ( org . apach . coyot . constant . stage prepar ) ; try { prepar request ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . debug ( sm . get string ( ajpprocessor . request . prepar ) , t ) ; 400 intern server error respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } process request adapt ( error ) { try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; adapt . servic ( request , respons ) ; } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( sm . get string ( ajpprocessor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } ( async ( ) error ) { break ; } finish respons done yet ( finish ) { try { finish ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; error = true ; } } error , updat statist counter ( error ) { respons . set statu ( 500 ) ; } request . updat counter ( ) ; rp . set stage ( org . apach . coyot . constant . stage keepal ) ; recycl ( fals ) ; } rp . set stage ( org . apach . coyot . constant . stage end ) ; ( error endpoint . paus ( ) ) { return socket state . close ; } els ( async ( ) ) { return socket state . long ; } els { return socket state . open ; } }	process pipelin http request us specifi input output stream . throw ioexcept error dure i o oper overrid public socket state process ( socket wrapper nio channel socket ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set up socket thi . socket = socket . get socket ( ) ; long so timeout = endpoint . get so timeout ( ) ; error flag error = fals ; while ( error endpoint . paus ( ) ) { pars request header try { get first messag request int byte read = read messag ( request header messag , fals ) ; ( byte read = = 0 ) { break ; } set back timeout keep aliv timeout enabl ( keep aliv timeout 0 ) { socket . set timeout ( so timeout ) ; } check messag type , process right awai break regular request process int type = request header messag . get byte ( ) ; ( type = = constant . jk ajp13 cping request ) { try { output ( pong messag arrai , 0 , pong messag arrai . length ) ; } catch ( ioexcept e ) { error = true ; } recycl ( fals ) ; continu ; } els ( type = constant . jk ajp13 forward request ) { usual servlet didn t read previou request bodi ( log . debug enabl ( ) ) { log . debug ( unexpect messag : type ) ; } recycl ( true ) ; continu ; } request . set start time ( system . current time milli ( ) ) ; } catch ( ioexcept e ) { error = true ; break ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . debug ( sm . get string ( ajpprocessor . header . error ) , t ) ; 400 bad request respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } ( error ) { set up filter , pars some request header rp . set stage ( org . apach . coyot . constant . stage prepar ) ; try { prepar request ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . debug ( sm . get string ( ajpprocessor . request . prepar ) , t ) ; 400 intern server error respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } ( endpoint . paus ( ) ) { 503 servic unavail respons . set statu ( 503 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } process request adapt ( error ) { try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; adapt . servic ( request , respons ) ; } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( sm . get string ( ajpprocessor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } ( async ( ) error ) { break ; } finish respons done yet ( finish ) { try { finish ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; error = true ; } } error , updat statist counter ( error ) { respons . set statu ( 500 ) ; } request . updat counter ( ) ; rp . set stage ( org . apach . coyot . constant . stage keepal ) ; set keep aliv timeout enabl ( keep aliv timeout 0 ) { socket . set timeout ( keep aliv timeout ) ; } recycl ( fals ) ; } rp . set stage ( org . apach . coyot . constant . stage end ) ; ( error endpoint . paus ( ) ) { ( async ( ) ) { return socket state . long ; } els { return socket state . open ; } } els { return socket state . close ; } }	process pipelin http request us specifi input output stream . throw ioexcept error dure i o oper overrid public socket state process ( socket wrapper socket socket ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set up socket thi . socket = socket ; input = socket . get socket ( ) . get input stream ( ) ; output = socket . get socket ( ) . get output stream ( ) ; int so timeout = 1 ; ( keep aliv timeout 0 ) { so timeout = socket . get socket ( ) . get so timeout ( ) ; } error flag error = fals ; while ( error endpoint . paus ( ) ) { pars request header try { set keep aliv timeout enabl ( keep aliv timeout 0 ) { socket . get socket ( ) . set so timeout ( keep aliv timeout ) ; } get first messag request ( read messag ( request header messag ) ) { thi mean connect timeout break ; } set back timeout keep aliv timeout enabl ( keep aliv timeout 0 ) { socket . get socket ( ) . set so timeout ( so timeout ) ; } check messag type , process right awai break regular request process int type = request header messag . get byte ( ) ; ( type = = constant . jk ajp13 cping request ) { try { output . write ( pong messag arrai ) ; } catch ( ioexcept e ) { error = true ; } continu ; } els ( type = constant . jk ajp13 forward request ) { usual servlet didn t read previou request bodi ( log . debug enabl ( ) ) { log . debug ( unexpect messag : type ) ; } continu ; } request . set start time ( system . current time milli ( ) ) ; } catch ( ioexcept e ) { error = true ; break ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . debug ( sm . get string ( ajpprocessor . header . error ) , t ) ; 400 bad request respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } ( error ) { set up filter , pars some request header rp . set stage ( org . apach . coyot . constant . stage prepar ) ; try { prepar request ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . debug ( sm . get string ( ajpprocessor . request . prepar ) , t ) ; 400 intern server error respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } ( endpoint . paus ( ) ) { 503 servic unavail respons . set statu ( 503 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } process request adapt ( error ) { try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; adapt . servic ( request , respons ) ; } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( sm . get string ( ajpprocessor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } ( async ( ) error ) { break ; } finish respons done yet ( finish ) { try { finish ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; error = true ; } } error , updat statist counter ( error ) { respons . set statu ( 500 ) ; } request . updat counter ( ) ; rp . set stage ( org . apach . coyot . constant . stage keepal ) ; recycl ( fals ) ; } rp . set stage ( org . apach . coyot . constant . stage end ) ; ( async ( ) error endpoint . paus ( ) ) { return socket state . long ; } els { input = null ; output = null ; return socket state . close ; } }
authent user make thi request , base specifi login configur . return code true code ani specifi constraint ha been satisfi , code fals code we have creat respons challeng alreadi . param request request we ar process param respons respons we ar creat param config login configur describ how authent should perform except ioexcept input output error occur overrid public boolean authent ( request request , http servlet respons respons , login config config ) throw ioexcept { refer object we need later session session = null ; have we alreadi authent someon princip princip = request . get user princip ( ) ; string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( princip = null ) { ( log . debug enabl ( ) ) log . debug ( alreadi authent princip . get name ( ) ) ; associ session ani exist sso session ( sso id = null ) associ ( sso id , request . get session intern ( true ) ) ; return ( true ) ; } sso session against which we can try reauthent ( sso id = null ) { ( log . debug enabl ( ) ) log . debug ( sso id sso id set ; attempt reauthent ) ; either case we have prompt user logon ( reauthent from sso ( sso id , request ) ) return true ; } have we authent thi user befor have cach disabl ( cach ) { session = request . get session intern ( true ) ; ( log . debug enabl ( ) ) log . debug ( check reauthent session session ) ; string usernam = ( string ) session . get note ( constant . sess usernam note ) ; string password = ( string ) session . get note ( constant . sess password note ) ; ( ( usernam = null ) ( password = null ) ) { ( log . debug enabl ( ) ) log . debug ( reauthent usernam usernam ) ; princip = context . get realm ( ) . authent ( usernam , password ) ; ( princip = null ) { session . set note ( constant . form princip note , princip ) ; ( match request ( request ) ) { regist ( request , respons , princip , constant . form method , usernam , password ) ; return ( true ) ; } } ( log . debug enabl ( ) ) log . debug ( reauthent fail , proce normal ) ; } } authent so , forward origin request instead . ( match request ( request ) ) { session = request . get session intern ( true ) ; ( log . debug enabl ( ) ) log . debug ( restor request from session session . get id intern ( ) ) ; princip = ( princip ) session . get note ( constant . form princip note ) ; regist ( request , respons , princip , constant . form method , ( string ) session . get note ( constant . sess usernam note ) , ( string ) session . get note ( constant . sess password note ) ) ; password session , so remov them ( cach ) { session . remov note ( constant . sess usernam note ) ; session . remov note ( constant . sess password note ) ; } ( restor request ( request , session ) ) { ( log . debug enabl ( ) ) log . debug ( proce restor request ) ; return ( true ) ; } els { ( log . debug enabl ( ) ) log . debug ( restor origin request fail ) ; respons . send error ( http servlet respons . sc bad request ) ; return ( fals ) ; } } acquir refer object we need evalu messag byte uri mb = messag byte . new instanc ( ) ; char chunk uri cc = uri mb . get char chunk ( ) ; uri cc . set limit ( 1 ) ; string context path = request . get context path ( ) ; string request uri = request . get decod request uri ( ) ; thi action request from login page boolean login action = request uri . start ( context path ) request uri . end ( constant . form action ) ; save thi request redirect form login page ( login action ) { session = request . get session intern ( true ) ; ( log . debug enabl ( ) ) log . debug ( save request session session . get id intern ( ) ) ; try { save request ( request , session ) ; } catch ( ioexcept ioe ) { log . debug ( request bodi too big save dure authent ) ; respons . send error ( http servlet respons . sc forbidden , sm . get string ( authent . request bodi too big ) ) ; return ( fals ) ; } forward login page ( request , respons , config ) ; return ( fals ) ; } ye acknowledg request , valid specifi credenti redirect error page thei ar correct request . get respons ( ) . send acknowledg ( ) ; realm realm = context . get realm ( ) ; ( charact encod = null ) { request . set charact encod ( charact encod ) ; } string usernam = request . get paramet ( constant . form usernam ) ; string password = request . get paramet ( constant . form password ) ; ( log . debug enabl ( ) ) log . debug ( authent usernam usernam ) ; princip = realm . authent ( usernam , password ) ; ( princip = = null ) { forward error page ( request , respons , config ) ; return ( fals ) ; } ( log . debug enabl ( ) ) log . debug ( authent usernam wa success ) ; ( session = = null ) session = request . get session intern ( fals ) ; ( session = = null ) { ( contain log . debug enabl ( ) ) contain log . debug ( user took so long log session expir ) ; ( land page = = null ) { respons . send error ( http servlet respons . sc request timeout , sm . get string ( authent . session expir ) ) ; } els { make authent think user origin request land page string uri = request . get context path ( ) land page ; save request save = new save request ( ) ; save . set request uri ( uri ) ; request . get session intern ( true ) . set note ( constant . form request note , save ) ; respons . send redirect ( respons . encod redirect url ( uri ) ) ; } return ( fals ) ; } save authent princip our session session . set note ( constant . form princip note , princip ) ; save usernam password well session . set note ( constant . sess usernam note , usernam ) ; session . set note ( constant . sess password note , password ) ; redirect user origin request uri ( which caus origin request restor ) request uri = save request url ( session ) ; ( log . debug enabl ( ) ) log . debug ( redirect origin request uri ) ; ( request uri = = null ) ( land page = = null ) { respons . send error ( http servlet respons . sc bad request , sm . get string ( authent . formlogin ) ) ; } els { make authent think user origin request land page string uri = request . get context path ( ) land page ; save request save = new save request ( ) ; save . set request uri ( uri ) ; session . set note ( constant . form request note , save ) ; respons . send redirect ( respons . encod redirect url ( uri ) ) ; } els respons . send redirect ( respons . encod redirect url ( request uri ) ) ; return ( fals ) ; }
enforc secur restrict web applic deploy descriptor our associ context . param request request process param respons respons process except ioexcept input output error occur except servlet except thrown process element overrid public void invok ( request request , respons respons ) throw ioexcept , servlet except { ( log . debug enabl ( ) ) log . debug ( secur check request request . get method ( ) request . get request uri ( ) ) ; login config config = thi . context . get login config ( ) ; have we got cach authent princip record ( cach ) { princip princip = request . get user princip ( ) ; ( princip = = null ) { session session = request . get session intern ( fals ) ; ( session = null ) { princip = session . get princip ( ) ; ( princip = null ) { ( log . debug enabl ( ) ) log . debug ( we have cach auth type session . get auth type ( ) princip session . get princip ( ) ) ; request . set auth type ( session . get auth type ( ) ) ; request . set user princip ( princip ) ; } } } } special handl form base login deal case where login form ( therefor j secur check uri which submit ) might outsid secur area string context path = thi . context . get path ( ) ; string request uri = request . get decod request uri ( ) ; ( request uri . start ( context path ) request uri . end ( constant . form action ) ) { ( authent ( request , respons , config ) ) { ( log . debug enabl ( ) ) log . debug ( fail authent ( ) test request uri ) ; return ; } } servlet mai specifi secur constraint through annot . ensur thei have been process befor constraint ar check wrapper wrapper = ( wrapper ) request . get map data ( ) . wrapper ; ( wrapper = null ) { wrapper . servlet secur annot scan ( ) ; } realm realm = thi . context . get realm ( ) ; thi request uri subject secur constraint secur constraint constraint = realm . find secur constraint ( request , thi . context ) ; ( constraint = = null context . get preemptiv authent ( ) ) { ( log . debug enabl ( ) ) log . debug ( subject ani constraint ) ; get next ( ) . invok ( request , respons ) ; return ; } browser cach can provid secur hole ( constraint = null disabl proxi cach request . secur ( ) post . equal ignor case ( request . get method ( ) ) ) { ( secur page pragma ) { note : can caus problem download file ie respons . set header ( pragma , cach ) ; respons . set header ( cach control , cach ) ; } els { respons . set header ( cach control , privat ) ; } respons . set header ( expir , date ) ; } int i ; ( constraint = null ) { enforc ani user data constraint thi secur constraint ( log . debug enabl ( ) ) { log . debug ( call ha user data permiss ( ) ) ; } ( realm . ha user data permiss ( request , respons , constraint ) ) { ( log . debug enabl ( ) ) { log . debug ( fail ha user data permiss ( ) test ) ; } assert : authent alreadi set appropri http statu code , so we do have do anyth special return ; } } sinc authent modifi respons failur , we have check allow from all first . boolean auth requir ; ( constraint = = null ) { auth requir = fals ; } els { auth requir = true ; ( i = 0 ; i constraint . length auth requir ; i ) { ( constraint i . get auth constraint ( ) ) { auth requir = fals ; } els ( constraint i . get all role ( ) ) { string role = constraint i . find auth role ( ) ; ( role = = null role . length = = 0 ) { auth requir = fals ; } } } } ( auth requir context . get preemptiv authent ( ) ) { auth requir = request . get coyot request ( ) . get mime header ( ) . get valu ( author ) = null ; } ( auth requir context . get preemptiv authent ( ) ) { x509certif cert = ( x509certif ) request . get attribut ( global . certif attr ) ; auth requir = cert = null cert . length 0 ; } ( auth requir ) { ( log . debug enabl ( ) ) { log . debug ( call authent ( ) ) ; } ( authent ( request , respons , config ) ) { ( log . debug enabl ( ) ) { log . debug ( fail authent ( ) test ) ; } assert : authent alreadi set appropri http statu code , so we do have do anyth special return ; } } ( constraint = null ) { ( log . debug enabl ( ) ) { log . debug ( call access control ( ) ) ; } ( realm . ha resourc permiss ( request , respons , constraint , thi . context ) ) { ( log . debug enabl ( ) ) { log . debug ( fail access control ( ) test ) ; } assert : access control method ha alreadi set appropri http statu code , so we do have do anyth special return ; } } ani all specifi constraint have been satisfi ( log . debug enabl ( ) ) { log . debug ( successfulli pass all secur constraint ) ; } get next ( ) . invok ( request , respons ) ; }
start thi compon implement requir { link org . apach . catalina . util . lifecycl base start intern ( ) } . start cluster commun channel , thi connect other node cluster , request current session state transfer thi node . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect synchron void start intern ( ) throw lifecycl except { super . start intern ( ) ; try { cluster . regist manag ( thi ) ; catalina cluster catclust = cluster ; lazi replic map map = new lazi replic map ( thi , catclust . get channel ( ) , default repl timeout , get map name ( ) , get class loader ( ) ) ; map . set channel send option ( map send option ) ; thi . session = map ; } catch ( except x ) { log . error ( unabl start backup manag , x ) ; throw new lifecycl except ( fail start backup manag , x ) ; } set state ( lifecycl state . start ) ; }	protect helper method broadcast messag all member channel param msgtype int param rpc boolean throw channel except void broadcast ( int msgtype , boolean rpc ) throw channel except { send out map membership messag , onli wait first repli map messag msg = new map messag ( thi . map context name , msgtype , fals , null , null , null , channel . get local member ( fals ) , null ) ; ( rpc ) { respons resp = rpc channel . send ( channel . get member ( ) , msg , rpc channel . first repli , ( channel send option ) , rpc timeout ) ; ( int i = 0 ; i resp . length ; i ) { map member ad ( resp i . get sourc ( ) ) ; messag receiv ( resp i . get messag ( ) , resp i . get sourc ( ) ) ; } } els { channel . send ( channel . get member ( ) , msg , channel send option ) ; } }	overrid public cluster manag clone from templat ( ) { backup manag result = new backup manag ( ) ; result . m expir session shutdown = m expir session shutdown ; result . name = clone from name ; result . cluster = cluster ; result . notifi listen replic = notifi listen replic ; result . map send option = map send option ; result . max activ session = max activ session ; return result ; }	overrid public string get invalid session ( ) { return new string 0 ; }
privat return file object repres pathnam our session persist directori , ani . directori creat doe alreadi exist . file directori ( ) { ( thi . directori = = null ) { return ( null ) ; } ( thi . directori file = null ) { note : race condit harmless , so do synchron return ( thi . directori file ) ; } file file = new file ( thi . directori ) ; ( file . absolut ( ) ) { contain contain = manag . get contain ( ) ; ( contain instanceof context ) { servlet context servlet context = ( ( context ) contain ) . get servlet context ( ) ; file work = ( file ) servlet context . get attribut ( servlet context . tempdir ) ; file = new file ( work , thi . directori ) ; } els { throw new illeg argument except ( parent contain context ) ; } } ( file . exist ( ) file . directori ( ) ) { file . delet ( ) ; file . mkdir ( ) ; } thi . directori file = file ; return ( file ) ; }	privat void do test timeout ( boolean complet timeout , string dispatch url ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; creat folder trigger redirect file foo = new file ( doc base , async ) ; ( foo . exist ( ) foo . mkdir ( ) ) { fail ( unabl creat async directori doc base ) ; } context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; timeout servlet timeout = new timeout servlet ( complet timeout , dispatch url ) ; wrapper wrapper = tomcat . add servlet ( ctx , time , timeout ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( async , time ) ; ( dispatch url = null ) { non async servlet non async = new non async servlet ( ) ; tomcat . add servlet ( ctx , nonasync , non async ) ; ctx . add servlet map ( dispatch url , nonasync ) ; } ctx . add applic listen ( track request listen . class . get name ( ) ) ; tester access log valv alv = new tester access log valv ( ) ; ctx . get pipelin ( ) . add valv ( alv ) ; tomcat . start ( ) ; byte chunk re = new byte chunk ( ) ; try { get url ( http : localhost : get port ( ) async , re , null ) ; } catch ( ioexcept ioe ) { ignor expect some error condit } string builder expect = new string builder ( request initi ) ; expect . append ( timeout servlet get timeout ) ; ( complet timeout ) { ( dispatch url = = null ) { expect . append ( complet ) ; expect . append ( request destroi ) ; } els { error further output complet sinc complet event would fire dure post process sinc error never happen . } } els { ( dispatch url = = null ) { expect . append ( error ) ; } els { expect . append ( non async servlet get ) ; } expect . append ( complet ) ; expect . append ( request destroi ) ; } assert equal ( expect . string ( ) , re . string ( ) ) ; check access log ( complet timeout dispatch url = null ) { ( access log enabl ( ) ) { valid access log ( alv , 1 , 500 , 0 , timeout servlet . async timeout timeout margin request time ) ; } } els { valid access log ( alv , 1 , 200 , timeout servlet . async timeout , timeout servlet . async timeout timeout margin request time ) ; } }	privat set appropri context attribut our work directori . void post work directori ( ) { acquir ( calcul ) work directori path string work dir = get work dir ( ) ; ( work dir = = null work dir . length ( ) = = 0 ) { retriev our parent ( normal host ) name string host name = null ; string engin name = null ; string host work dir = null ; contain parent host = get parent ( ) ; ( parent host = null ) { host name = parent host . get name ( ) ; ( parent host instanceof standard host ) { host work dir = ( ( standard host ) parent host ) . get work dir ( ) ; } contain parent engin = parent host . get parent ( ) ; ( parent engin = null ) { engin name = parent engin . get name ( ) ; } } ( ( host name = = null ) ( host name . length ( ) 1 ) ) host name = ; ( ( engin name = = null ) ( engin name . length ( ) 1 ) ) engin name = ; string temp = get name ( ) ; ( temp . start ( ) ) temp = temp . substr ( 1 ) ; temp = temp . replac ( , ) ; temp = temp . replac ( , ) ; ( temp . length ( ) 1 ) temp = ; ( host work dir = null ) { work dir = host work dir file . separ temp ; } els { work dir = work file . separ engin name file . separ host name file . separ temp ; } set work dir ( work dir ) ; } creat thi directori necessari file dir = new file ( work dir ) ; ( dir . absolut ( ) ) { file catalina home = engin base ( ) ; string catalina home path = null ; try { catalina home path = catalina home . get canon path ( ) ; dir = new file ( catalina home path , work dir ) ; } catch ( ioexcept e ) { log . warn ( sm . get string ( standard context . work creat except , work dir , catalina home path , get name ( ) ) , e ) ; } } ( dir . exist ( ) dir . mkdir ( ) ) { log . warn ( sm . get string ( standard context . work creat fail , dir , get name ( ) ) ) ; } set appropri servlet context attribut ( context = = null ) { get servlet context ( ) ; } context . set attribut ( servlet context . tempdir , dir ) ; context . set attribut read onli ( servlet context . tempdir ) ; }	privat configur repositori our class loader , base associ context . throw ioexcept void set repositori ( ) throw ioexcept { ( ( contain instanceof context ) ) return ; servlet context servlet context = ( ( context ) contain ) . get servlet context ( ) ; ( servlet context = = null ) return ; loader repositori = new arrai list string ( ) ; load work directori file work dir = ( file ) servlet context . get attribut ( servlet context . tempdir ) ; ( work dir = = null ) { log . info ( work dir servlet context ) ; } ( log . debug enabl ( ) work dir = null ) log . debug ( sm . get string ( webapp loader . deploi , work dir . get absolut path ( ) ) ) ; class loader . set work dir ( work dir ) ; dir context resourc = contain . get resourc ( ) ; set up class repositori ( web inf class ) , exist string class path = web inf class ; dir context class = null ; try { object object = resourc . lookup ( class path ) ; ( object instanceof dir context ) { class = ( dir context ) object ; } } catch ( name except e ) { silent catch : s valid web inf class collect exist } ( class = null ) { file class repositori = null ; string absolut class path = servlet context . get real path ( class path ) ; ( absolut class path = null ) { class repositori = new file ( absolut class path ) ; } els { class repositori = new file ( work dir , class path ) ; ( class repositori . directori ( ) ) { ( class repositori . mkdir ( ) ) throw new ioexcept ( sm . get string ( webapp loader . mkdir failur ) ) ; } ( copi dir ( class , class repositori ) ) { throw new ioexcept ( sm . get string ( webapp loader . copi failur ) ) ; } } ( log . debug enabl ( ) ) log . debug ( sm . get string ( webapp loader . class deploi , class path , class repositori . get absolut path ( ) ) ) ; ad repositori class loader class loader . add repositori ( class path , class repositori ) ; loader repositori . add ( class path ) ; } set up jar repositori ( web inf lib ) , exist string lib path = web inf lib ; class loader . set jar path ( lib path ) ; dir context lib dir = null ; look up directori web inf lib context try { object object = resourc . lookup ( lib path ) ; ( object instanceof dir context ) lib dir = ( dir context ) object ; } catch ( name except e ) { silent catch : s valid web inf lib collect exist } ( lib dir = null ) { boolean copi jar = fals ; string absolut lib path = servlet context . get real path ( lib path ) ; file dest dir = null ; ( absolut lib path = null ) { dest dir = new file ( absolut lib path ) ; } els { copi jar = true ; dest dir = new file ( work dir , lib path ) ; ( dest dir . directori ( ) ) { ( dest dir . mkdir ( ) ) throw new ioexcept ( sm . get string ( webapp loader . mkdir failur ) ) ; } } look up directori web inf lib context name enumer name class pair enumer = null ; try { enumer = lib dir . list ( ) ; } catch ( name except e ) { ioexcept ioe = new ioexcept ( sm . get string ( webapp loader . name failur , lib path ) ) ; ioe . init caus ( e ) ; throw ioe ; } while ( enumer . ha more element ( ) ) { name class pair nc pair = enumer . next element ( ) ; string filenam = lib path nc pair . get name ( ) ; ( filenam . end ( . jar ) ) continu ; copi jar work directori , alwai ( jar file would get lock otherwis , which would make imposs updat remov runtim ) file dest file = new file ( dest dir , nc pair . get name ( ) ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( webapp loader . jar deploi , filenam , dest file . get absolut path ( ) ) ) ; bug 45403 explicitli call lookup ( ) name check resourc readabl . we cannot us resourc return list bind ( ) , becaus list all them , doe perform necessari check each . object obj = null ; try { obj = lib dir . lookup ( nc pair . get name ( ) ) ; } catch ( name except e ) { ioexcept ioe = new ioexcept ( sm . get string ( webapp loader . name failur , filenam ) ) ; ioe . init caus ( e ) ; throw ioe ; } ( ( obj instanceof resourc ) ) continu ; resourc jar resourc = ( resourc ) obj ; ( copi jar ) { ( copi ( jar resourc . stream content ( ) , new file output stream ( dest file ) ) ) { throw new ioexcept ( sm . get string ( webapp loader . copi failur ) ) ; } } try { jar file jar file = new jar file ( dest file ) ; class loader . add jar ( filenam , jar file , dest file ) ; } catch ( except ex ) { catch except empti jar file should ignor continu load other jar file dir } loader repositori . add ( filenam ) ; } } }	protect get config base . file get config base ( string host name ) { file config base = new file ( system . get properti ( global . catalina base prop ) , conf ) ; ( config base . exist ( ) ) { return null ; } ( engin = null ) { config base = new file ( config base , engin . get name ( ) ) ; } ( instal host = null ) { config base = new file ( config base , host name ) ; } ( config base . exist ( ) ) { ( config base . mkdir ( ) ) { return null ; } } return config base ; }	protect find specifi resourc local repositori . return load resourc , null resourc isn t found resourc entri find resourc intern ( string name , string path ) { ( start ) { log . info ( sm . get string ( webapp class loader . stop , name ) ) ; return null ; } ( ( name = = null ) ( path = = null ) ) return null ; resourc entri entri = resourc entri . get ( name ) ; ( entri = null ) return entri ; int content length = 1 ; input stream binari stream = null ; int jar file length = jar file . length ; int repositori length = repositori . length ; int i ; resourc resourc = null ; boolean file need convert = fals ; ( i = 0 ; ( entri = = null ) ( i repositori length ) ; i ) { try { string full path = repositori i path ; object lookup result = resourc . lookup ( full path ) ; ( lookup result instanceof resourc ) { resourc = ( resourc ) lookup result ; } note : get except here mean resourc wa found entri = find resourc intern ( file i , path ) ; resourc attribut attribut = ( resourc attribut ) resourc . get attribut ( full path ) ; content length = ( int ) attribut . get content length ( ) ; entri . last modifi = attribut . get last modifi ( ) ; ( resourc = null ) { try { binari stream = resourc . stream content ( ) ; } catch ( ioexcept e ) { return null ; } ( need convert ) { ( path . end ( . properti ) ) { file need convert = true ; } } note : onli sync constant object need synchron ( all permiss ) { int j ; long result2 = new long last modifi date . length 1 ; ( j = 0 ; j last modifi date . length ; j ) { result2 j = last modifi date j ; } result2 last modifi date . length = entri . last modifi ; last modifi date = result2 ; string result = new string path . length 1 ; ( j = 0 ; j path . length ; j ) { result j = path j ; } result path . length = full path ; path = result ; } } } catch ( name except e ) { ignor } } ( ( entri = = null ) ( found resourc . contain kei ( name ) ) ) return null ; jar entri jar entri = null ; synchron ( jar file ) { try { ( open jar ( ) ) { return null ; } ( i = 0 ; ( entri = = null ) ( i jar file length ) ; i ) { jar entri = jar file i . get jar entri ( path ) ; ( jar entri = null ) { entri = new resourc entri ( ) ; try { entri . code base = get url ( jar real file i , fals ) ; string jar fake url = get uri ( jar real file i ) . string ( ) ; jar fake url = jar : jar fake url path ; entri . sourc = new url ( jar fake url ) ; entri . last modifi = jar real file i . last modifi ( ) ; } catch ( malform urlexcept e ) { return null ; } content length = ( int ) jar entri . get size ( ) ; try { entri . manifest = jar file i . get manifest ( ) ; binari stream = jar file i . get input stream ( jar entri ) ; } catch ( ioexcept e ) { return null ; } extract resourc contain jar workdir ( anti jarlock ( path . end ( . class ) ) ) { byte buf = new byte 1024 ; file resourc file = new file ( loader dir , jar entri . get name ( ) ) ; ( resourc file . exist ( ) ) { enumer jar entri entri = jar file i . entri ( ) ; while ( entri . ha more element ( ) ) { jar entri jar entry2 = entri . next element ( ) ; ( ( jar entry2 . directori ( ) ) ( jar entry2 . get name ( ) . end ( . class ) ) ) { resourc file = new file ( loader dir , jar entry2 . get name ( ) ) ; try { ( resourc file . get canon path ( ) . start ( canon loader dir ) ) { throw new illeg argument except ( sm . get string ( webapp class loader . illeg jar path , jar entry2 . get name ( ) ) ) ; } } catch ( ioexcept ioe ) { throw new illeg argument except ( sm . get string ( webapp class loader . valid error jar path , jar entry2 . get name ( ) ) , ioe ) ; } resourc file . get parent file ( ) . mkdir ( ) ; file output stream os = null ; input stream = null ; try { = jar file i . get input stream ( jar entry2 ) ; os = new file output stream ( resourc file ) ; while ( true ) { int n = . read ( buf ) ; ( n = 0 ) { break ; } os . write ( buf , 0 , n ) ; } resourc file . set last modifi ( jar entry2 . get time ( ) ) ; } catch ( ioexcept e ) { ignor } final { try { ( = null ) { . close ( ) ; } } catch ( ioexcept e ) { ignor } try { ( os = null ) { os . close ( ) ; } } catch ( ioexcept e ) { ignor } } } } } } } } ( entri = = null ) { synchron ( found resourc ) { found resourc . put ( name , name ) ; } return null ; } ( binari stream = null ) { byte binari content = new byte content length ; int po = 0 ; try { while ( true ) { int n = binari stream . read ( binari content , po , binari content . length po ) ; ( n = 0 ) break ; po = n ; } } catch ( ioexcept e ) { log . error ( sm . get string ( webapp class loader . read error , name ) , e ) ; return null ; } ( file need convert ) { workaround certain file platform us ebcdic encod , when thei ar read through file input stream . see commit messag rev . 303915 detail http : svn . apach . org viewvc view = revis revis = 303915 string str = new string ( binari content , 0 , po ) ; try { binari content = str . get byte ( charset utf8 ) ; } catch ( except e ) { return null ; } } entri . binari content = binari content ; associ input stream ha been fulli read ( jar entri = null ) { entri . certif = jar entri . get certif ( ) ; } } } final { ( binari stream = null ) { try { binari stream . close ( ) ; } catch ( ioexcept e ) { ignor } } } } add entri local resourc repositori synchron ( resourc entri ) { ensur all thread which mai race load particular class all end up same resourc entri instanc resourc entri entry2 = resourc entri . get ( name ) ; ( entry2 = = null ) { resourc entri . put ( name , entri ) ; } els { entri = entry2 ; } } return entri ; }	protect boolean make output dir ( ) { synchron ( output dir lock ) { file out dir file = new file ( output dir ) ; return ( out dir file . exist ( ) out dir file . mkdir ( ) ) ; } }	protect synchron open new log file date specifi code date stamp code . void open ( ) { creat directori necessari file dir = new file ( directori ) ; ( dir . absolut ( ) ) dir = new file ( system . get properti ( global . catalina base prop ) , directori ) ; ( dir . exist ( ) ) { ( dir . mkdir ( ) ) { log . error ( sm . get string ( access log valv . open dir fail , dir ) ) ; } } open current log file file pathnam ; rotat need date stamp file name ( rotat ) { pathnam = new file ( dir . get absolut file ( ) , prefix date stamp suffix ) ; } els { pathnam = new file ( dir . get absolut file ( ) , prefix suffix ) ; } file parent = pathnam . get parent file ( ) ; ( parent . exist ( ) ) { ( parent . mkdir ( ) ) { log . error ( sm . get string ( access log valv . open dir fail , parent ) ) ; } } charset charset = null ; ( encod = null ) { try { charset = b2cconvert . get charset ( encod ) ; } catch ( unsupport encod except ex ) { log . error ( sm . get string ( access log valv . unsupport encod , encod ) , ex ) ; } } ( charset = = null ) { charset = charset . default charset ( ) ; } try { writer = new print writer ( new buffer writer ( new output stream writer ( new file output stream ( pathnam , true ) , charset ) , 128000 ) , fals ) ; current log file = pathnam ; } catch ( ioexcept e ) { writer = null ; current log file = null ; log . error ( sm . get string ( access log valv . open fail , pathnam ) , e ) ; } }	protect synchron deploi web applic archiv ( includ current request ) specifi context path . param writer writer render result param cn name applic instal param tag tag associ webapp param request servlet request we ar process void deploi ( print writer writer , context name cn , string tag , boolean updat , http servlet request request , string manag sm client ) { ( debug = 1 ) { log ( deploi : deploi web applic cn ) ; } valid request context path ( valid context name ( cn , writer , sm client ) ) { return ; } string name = cn . get name ( ) ; string base name = cn . get base name ( ) ; string displai path = cn . get displai name ( ) ; check app alreadi exist , undeploi updat context context = ( context ) host . find child ( name ) ; ( updat ) { ( context = null ) { undeploi ( writer , cn , sm client ) ; } context = ( context ) host . find child ( name ) ; } ( context = null ) { writer . println ( sm client . get string ( manag servlet . alreadi context , displai path ) ) ; return ; } calcul base path file deploi path = deploi ; ( tag = null ) { deploi path = new file ( version , tag ) ; ( deploi path . directori ( ) deploi path . mkdir ( ) ) { writer . println ( sm client . get string ( manag servlet . mkdir fail , deploi path ) ) ; return ; } } upload web applic archiv local war file file local war = new file ( deploi path , base name . war ) ; ( debug = 2 ) { log ( upload war file local war ) ; } copi war app base try { ( servic ( name ) ) { add servic ( name ) ; try { upload war upload war ( writer , request , local war , sm client ) ; copi war xml host app base need ( tag = null ) { deploi path = deploi ; file local war copi = new file ( deploi path , base name . war ) ; copi ( local war , local war copi ) ; local war = local war copi ; copi ( local war , new file ( host . get app base file ( ) , base name . war ) ) ; } perform new deploy check ( name ) ; } final { remov servic ( name ) ; } } } catch ( except e ) { log ( manag servlet . check displai path , e ) ; writer . println ( sm client . get string ( manag servlet . except , e . string ( ) ) ) ; return ; } context = ( context ) host . find child ( name ) ; ( context = null context . get configur ( ) ) { writer . println ( sm client . get string ( manag servlet . deploi , displai path ) ) ; } els { someth fail writer . println ( sm client . get string ( manag servlet . deploi fail , displai path ) ) ; } }	protect instal applic specifi path from specifi web applic archiv . param writer writer render result param config url context configur file instal param cn name applic instal param war url web applic archiv instal param updat true overrid ani exist webapp path void deploi ( print writer writer , string config , context name cn , string war , boolean updat , string manag sm client ) { ( config = null config . length ( ) = = 0 ) { config = null ; } ( war = null war . length ( ) = = 0 ) { war = null ; } ( debug = 1 ) { ( config = null config . length ( ) 0 ) { ( war = null ) { log ( instal : instal context configur config from war ) ; } els { log ( instal : instal context configur config ) ; } } els { ( cn = null ) { log ( instal : instal web applic cn from war ) ; } els { log ( instal : instal web applic from war ) ; } } } ( valid context name ( cn , writer , sm client ) ) { return ; } check call abov suppress warn ( null ) string name = cn . get name ( ) ; string base name = cn . get base name ( ) ; string displai path = cn . get displai name ( ) ; check app alreadi exist , undeploi updat context context = ( context ) host . find child ( name ) ; ( updat ) { ( context = null ) { undeploi ( writer , cn , sm client ) ; } context = ( context ) host . find child ( name ) ; } ( context = null ) { writer . println ( sm client . get string ( manag servlet . alreadi context , displai path ) ) ; return ; } ( config = null ( config . start ( file : ) ) ) { config = config . substr ( file : . length ( ) ) ; } ( war = null ( war . start ( file : ) ) ) { war = war . substr ( file : . length ( ) ) ; } try { ( servic ( name ) ) { add servic ( name ) ; try { ( config = null ) { ( config base . directori ( ) config base . mkdir ( ) ) { writer . println ( sm client . get string ( manag servlet . mkdir fail , config base ) ) ; return ; } copi ( new file ( config ) , new file ( config base , base name . xml ) ) ; } ( war = null ) { ( war . end ( . war ) ) { copi ( new file ( war ) , new file ( host . get app base file ( ) , base name . war ) ) ; } els { copi ( new file ( war ) , new file ( host . get app base file ( ) , base name ) ) ; } } perform new deploy check ( name ) ; } final { remov servic ( name ) ; } } context = ( context ) host . find child ( name ) ; ( context = null context . get configur ( ) context . get avail ( ) ) { writer . println ( sm client . get string ( manag servlet . deploi , displai path ) ) ; } els ( context = null context . get avail ( ) ) { writer . println ( sm client . get string ( manag servlet . deploi start , displai path ) ) ; } els { someth fail writer . println ( sm client . get string ( manag servlet . deploi fail , displai path ) ) ; } } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log ( manag servlet . instal displai path , t ) ; writer . println ( sm client . get string ( manag servlet . except , t . string ( ) ) ) ; } }	protect extract request resourc from web app archiv context work directori enabl cgi script execut . void expand cgiscript ( ) { string builder src path = new string builder ( ) ; string builder dest path = new string builder ( ) ; input stream = null ; path depend map ( cgi path prefix = = null ) { src path . append ( path info ) ; = context . get resourc stream ( src path . string ( ) ) ; dest path . append ( tmp dir ) ; dest path . append ( path info ) ; } els { essenti same search algorithm find cgi ( ) src path . append ( cgi path prefix ) ; string token path walker = new string token ( path info , ) ; start first element while ( path walker . ha more element ( ) ( = = null ) ) { src path . append ( ) ; src path . append ( path walker . next element ( ) ) ; = context . get resourc stream ( src path . string ( ) ) ; } dest path . append ( tmp dir ) ; dest path . append ( ) ; dest path . append ( src path ) ; } ( = = null ) { didn t find anyth , give up now ( debug = 2 ) { log ( expand cgiscript : sourc src path found ) ; } return ; } file f = new file ( dest path . string ( ) ) ; ( f . exist ( ) ) { don t need expand alreadi exist return ; } creat directori string dir path = dest path . string ( ) . substr ( 0 , dest path . string ( ) . last index ( ) ) ; file dir = new file ( dir path ) ; ( dir . mkdir ( ) debug = 2 ) { log ( expand cgiscript : fail creat directori dir . get absolut path ( ) ) ; return ; } try { synchron ( expand file lock ) { make sure file doesn t exist ( f . exist ( ) ) { return ; } creat file ( f . creat new file ( ) ) { return ; } file output stream fo = new file output stream ( f ) ; copi data iotool . flow ( , fo ) ; . close ( ) ; fo . close ( ) ; ( debug = 2 ) { log ( expand cgiscript : expand src path dest path ) ; } } } catch ( ioexcept ioe ) { delet case file corrupt ( f . exist ( ) ) { ( f . delet ( ) debug = 2 ) { log ( expand cgiscript : fail delet f . get absolut path ( ) ) ; } } } }	protect void open writer ( ) { creat directori necessari file dir = new file ( directori ) ; ( dir . exist ( ) dir . mkdir ( ) ) { report error ( unabl creat dir , null , error manag . open failur ) ; writer = null ; return ; } open current log file writer lock . write lock ( ) . lock ( ) ; try { file pathnam = new file ( dir . get absolut file ( ) , prefix ( rotat date : ) suffix ) ; file parent = pathnam . get parent file ( ) ; ( parent . exist ( ) ) { ( parent . mkdir ( ) ) { report error ( unabl creat parent , null , error manag . open failur ) ; writer = null ; return ; } } string encod = get encod ( ) ; file output stream fo = new file output stream ( pathnam , true ) ; output stream os = buffer size 0 new buffer output stream ( fo , buffer size ) : fo ; writer = new print writer ( ( encod = null ) new output stream writer ( os , encod ) : new output stream writer ( os ) , fals ) ; writer . write ( get formatt ( ) . get head ( thi ) ) ; } catch ( except e ) { report error ( null , e , error manag . open failur ) ; writer = null ; } final { writer lock . write lock ( ) . unlock ( ) ; } }	public static string expand ( host host , url war , string pathnam ) throw ioexcept { make sure directori alreadi exist file doc base = new file ( host . get app base file ( ) , pathnam ) ; ( doc base . exist ( ) ) { war file alreadi instal return ( doc base . get absolut path ( ) ) ; } creat new document base directori doc base . mkdir ( ) ; expand war new document base directori string canon doc base prefix = doc base . get canon path ( ) ; ( canon doc base prefix . end ( file . separ ) ) { canon doc base prefix = file . separ ; } jar urlconnect juc = ( jar urlconnect ) war . open connect ( ) ; juc . set us cach ( fals ) ; jar file jar file = null ; input stream input = null ; boolean success = fals ; try { jar file = juc . get jar file ( ) ; enumer jar entri jar entri = jar file . entri ( ) ; while ( jar entri . ha more element ( ) ) { jar entri jar entri = jar entri . next element ( ) ; string name = jar entri . get name ( ) ; file expand file = new file ( doc base , name ) ; ( expand file . get canon path ( ) . start ( canon doc base prefix ) ) { throw except stop deploy throw new illeg argument except ( sm . get string ( expand war . illeg path , war , name , expand file . get canon path ( ) , canon doc base prefix ) ) ; } int last = name . last index ( ) ; ( last = 0 ) { file parent = new file ( doc base , name . substr ( 0 , last ) ) ; parent . mkdir ( ) ; } ( name . end ( ) ) { continu ; } input = jar file . get input stream ( jar entri ) ; bugzilla 33636 expand ( input , expand file ) ; long last modifi = jar entri . get time ( ) ; ( ( last modifi = 1 ) ( last modifi = 0 ) ) { expand file . set last modifi ( last modifi ) ; } input . close ( ) ; input = null ; } success = true ; } catch ( ioexcept e ) { throw e ; } final { ( success ) { someth went wrong , delet expand dir keep thing clean delet dir ( doc base ) ; } ( input = null ) { try { input . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } input = null ; } ( jar file = null ) { try { jar file . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } jar file = null ; } } return absolut path our new document base directori return ( doc base . get absolut path ( ) ) ; }	protect synchron add host us specifi paramet . param writer writer render result param name host name param alias comma separ alia list param app base applic base host param manag should manag webapp deploi new host void add ( print writer writer , string name , string alias , string app base , boolean manag , boolean auto deploi , boolean deploi startup , boolean deploi xml , boolean unpack war , string manag sm client ) { ( debug = 1 ) { log ( sm . get string ( host manag servlet . add , name ) ) ; } valid request host name ( ( name = = null ) name . length ( ) = = 0 ) { writer . println ( sm client . get string ( host manag servlet . invalid host name , name ) ) ; return ; } check host alreadi exist ( engin . find child ( name ) = null ) { writer . println ( sm client . get string ( host manag servlet . alreadi host , name ) ) ; return ; } valid creat app base file app base file = null ; file file = null ; ( app base = = null app base . length ( ) = = 0 ) { file = new file ( name ) ; } els { file = new file ( app base ) ; } ( file . absolut ( ) ) file = new file ( system . get properti ( global . catalina base prop ) , file . get path ( ) ) ; try { app base file = file . get canon file ( ) ; } catch ( ioexcept e ) { app base file = file ; } ( app base file . exist ( ) ) { ( app base file . mkdir ( ) ) { writer . println ( sm client . get string ( host manag servlet . app base creat fail , app base file . string ( ) , name ) ) ; return ; } } creat base config file file config base file = get config base ( name ) ; copi manag . xml request ( manag ) { ( config base file = = null ) { writer . println ( sm client . get string ( host manag servlet . config base creat fail , name ) ) ; return ; } input stream = null ; output stream os = null ; try { = get servlet context ( ) . get resourc stream ( manag . xml ) ; os = new file output stream ( new file ( config base file , manag . xml ) ) ; byte buffer = new byte 512 ; int len = buffer . length ; while ( true ) { len = . read ( buffer ) ; ( len = = 1 ) break ; os . write ( buffer , 0 , len ) ; } } catch ( ioexcept e ) { writer . println ( sm client . get string ( host manag servlet . manag xml ) ) ; return ; } final { ( = null ) { try { . close ( ) ; } catch ( ioexcept e ) { ignor } } ( os = null ) { try { os . close ( ) ; } catch ( ioexcept e ) { ignor } } } } standard host host = new standard host ( ) ; host . set app base ( app base ) ; host . set name ( name ) ; host . add lifecycl listen ( new host config ( ) ) ; add host alias ( ( alias = null ) ( . equal ( alias ) ) ) { string token tok = new string token ( alias , , ) ; while ( tok . ha more token ( ) ) { host . add alia ( tok . next token ( ) ) ; } } host . set auto deploi ( auto deploi ) ; host . set deploi startup ( deploi startup ) ; host . set deploi xml ( deploi xml ) ; host . set unpack war ( unpack war ) ; add new host try { engin . add child ( host ) ; } catch ( except e ) { writer . println ( sm client . get string ( host manag servlet . except , e . string ( ) ) ) ; return ; } host = ( standard host ) engin . find child ( name ) ; ( host = null ) { writer . println ( sm client . get string ( host manag servlet . add , name ) ) ; } els { someth fail writer . println ( sm client . get string ( host manag servlet . add fail , name ) ) ; } }	save specifi session thi store . ani previous save inform associ session identifi replac . param session session save except ioexcept input output error occur overrid public void save ( session session ) throw ioexcept { open output stream specifi pathnam , ani file file = file ( session . get id intern ( ) ) ; ( file = = null ) { return ; } ( manag . get contain ( ) . get logger ( ) . debug enabl ( ) ) { manag . get contain ( ) . get logger ( ) . debug ( sm . get string ( get store name ( ) . save , session . get id intern ( ) , file . get absolut path ( ) ) ) ; } file output stream fo = null ; object output stream oo = null ; try { fo = new file output stream ( file . get absolut path ( ) ) ; oo = new object output stream ( new buffer output stream ( fo ) ) ; } catch ( ioexcept e ) { ( fo = null ) { try { fo . close ( ) ; } catch ( ioexcept f ) { ignor } } throw e ; } try { ( ( standard session ) session ) . write object data ( oo ) ; } final { oo . close ( ) ; } }	befor public void set up ( ) throw except { need us juli so log messag from test ar visibl system . set properti ( java . util . log . manag , org . apach . juli . class loader log manag ) ; system . set properti ( java . util . log . config . file , new file ( get build directori ( ) , conf log . properti ) . string ( ) ) ; temp dir = new file ( system . get properti ( tomcat . test . temp , output tmp ) ) ; ( temp dir . exist ( ) temp dir . mkdir ( ) ) { fail ( unabl creat temporari directori test ) ; } system . set properti ( catalina . base , temp dir . get absolut path ( ) ) ; trigger load catalina . properti catalina properti . get properti ( foo ) ; file app base = new file ( temp dir , webapp ) ; ( app base . exist ( ) app base . mkdir ( ) ) { fail ( unabl creat app base test ) ; } tomcat = new tomcat ( ) ; string protocol = get protocol ( ) ; connector connector = new connector ( protocol ) ; each test run same port thei mai interfer each other connector . set port ( get next port ( ) ) ; mainli set reduc timeout dure async test connector . set attribut ( connect timeout , 3000 ) ; tomcat . get servic ( ) . add connector ( connector ) ; tomcat . set connector ( connector ) ; add apr lifecycl listen we ar us apr connector ( protocol . contain ( apr ) ) { standard server server = ( standard server ) tomcat . get server ( ) ; apr lifecycl listen listen = new apr lifecycl listen ( ) ; listen . set sslrandom seed ( dev urandom ) ; server . add lifecycl listen ( listen ) ; connector . set attribut ( poller thread count , integ . valu ( 1 ) ) ; } tomcat . set base dir ( temp dir . get absolut path ( ) ) ; tomcat . get host ( ) . set app base ( app base . get absolut path ( ) ) ; access log enabl = boolean . pars boolean ( system . get properti ( tomcat . test . accesslog , fals ) ) ; ( access log enabl ) { access log valv alv = new access log valv ( ) ; alv . set directori ( get build directori ( ) log ) ; alv . set pattern ( h l u t r s b i d ) ; tomcat . get host ( ) . get pipelin ( ) . add valv ( alv ) ; } }	public process start event thi host . void start ( ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( host config . start ) ) ; try { object name host = host . get object name ( ) ; onam = new object name ( host . get domain ( ) : type = deploy , host = host . get name ( ) ) ; registri . get registri ( null , null ) . regist compon ( thi , onam , thi . get class ( ) . get name ( ) ) ; } catch ( except e ) { log . error ( sm . get string ( host config . jmx . regist , onam ) , e ) ; } ( host . get creat dir ( ) ) { file dir = new file { host . get app base file ( ) , config base ( ) } ; ( int i = 0 ; i dir . length ; i ) { ( ( dir i . directori ( ) ) ( dir i . mkdir ( ) ) ) { log . error ( sm . get string ( host config . creat dir , dir i ) ) ; } } } ( host . get app base file ( ) . directori ( ) ) { log . error ( sm . get string ( host config . app base , host . get name ( ) , host . get app base file ( ) . get path ( ) ) ) ; host . set deploi startup ( fals ) ; host . set auto deploi ( fals ) ; } ( host . get deploi startup ( ) ) deploi app ( ) ; }	public void test bug46243 ( ) throw except { set up contain tomcat tomcat = get tomcat instanc ( ) ; file doc base = new file ( tomcat . get host ( ) . get app base file ( ) , root ) ; ( doc base . exist ( ) doc base . mkdir ( ) ) { fail ( unabl creat doc base ) ; } context root = tomcat . add context ( , root ) ; add test filter fail filter def filter def = new filter def ( ) ; filter def . set filter class ( bug46243filt . class . get name ( ) ) ; filter def . set filter name ( bug46243 ) ; root . add filter def ( filter def ) ; filter map filter map = new filter map ( ) ; filter map . set filter name ( bug46243 ) ; filter map . add urlpattern ( ) ; root . add filter map ( filter map ) ; add test servlet so someth gener respons work ( although shouldn t ) tomcat . add servlet ( root , bug46243 , new hello world servlet ( ) ) ; root . add servlet map ( , bug46243 ) ; tomcat . start ( ) ; configur client bug46243client client = new bug46243client ( ) ; client . set port ( get port ( ) ) ; client . set request ( new string { request } ) ; client . connect ( ) ; client . process request ( ) ; assert true ( client . response404 ( ) ) ; }	test http : issu . apach . org bugzilla show bug . cgi id = 50413 serv custom error page test public void test custom error page ( ) throw except { file app dir = new file ( get temporari directori ( ) , my app ) ; file web inf = new file ( app dir , web inf ) ; ( web inf . mkdir ( ) ) { fail ( unabl creat directori web inf ) ; } writer w = new output stream writer ( new file output stream ( new file ( app dir , web inf web . xml ) ) , utf 8 ) ; try { w . write ( xml version = 1 . 0 encod = utf 8 n web app xmln = http : java . sun . com xml ns j2ee xmln : xsi = http : www . w3 . org 2001 xmlschema instanc xsi : schema locat = http : java . sun . com xml ns j2ee http : java . sun . com xml ns j2ee web app 2 4 . xsd version = 2 . 4 n error page n error code 404 error code n locat 404 . html locat n error page n web app n ) ; w . flush ( ) ; } final { w . close ( ) ; } w = new output stream writer ( new file output stream ( new file ( app dir , 404 . html ) ) , iso 8859 1 ) ; try { w . write ( 404 . html ) ; w . flush ( ) ; } final { w . close ( ) ; } tomcat tomcat = get tomcat instanc ( ) ; string context path = my app ; tomcat . add webapp ( null , context path , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; test custom error client client = new test custom error client ( ) ; client . set port ( get port ( ) ) ; client . reset ( ) ; client . set request ( new string { get my app miss http 1 . 0 crlf crlf } ) ; client . connect ( ) ; client . process request ( ) ; assert true ( client . response404 ( ) ) ; assert equal ( 404 . html , client . get respons bodi ( ) ) ; simpl date format format = new simpl date format ( eee , dd mmm yyyi hh : mm : ss zzz , local . us ) ; format . set time zone ( time zone . get time zone ( gmt ) ) ; string tomorrow = format . format ( new date ( system . current time milli ( ) 24 60 60 1000 ) ) ; http : issu . apach . org bugzilla show bug . cgi id = 50413 client . reset ( ) ; client . set request ( new string { get my app miss http 1 . 1 crlf host : localhost crlf connect : close crlf modifi sinc : tomorrow crlf crlf } ) ; client . connect ( ) ; client . process request ( ) ; assert true ( client . response404 ( ) ) ; assert equal ( 404 . html , client . get respons bodi ( ) ) ; http : issu . apach . org bugzilla show bug . cgi id = 50413 c6 client . reset ( ) ; client . set request ( new string { get my app miss http 1 . 1 crlf host : localhost crlf connect : close crlf rang : byte = 0 100 crlf crlf } ) ; client . connect ( ) ; client . process request ( ) ; assert true ( client . response404 ( ) ) ; assert equal ( 404 . html , client . get respons bodi ( ) ) ; }	test what happen custom 404 page configur , file actual miss . test public void test custom error page miss ( ) throw except { file app dir = new file ( get temporari directori ( ) , my app ) ; file web inf = new file ( app dir , web inf ) ; ( web inf . mkdir ( ) ) { fail ( unabl creat directori web inf ) ; } writer w = new output stream writer ( new file output stream ( new file ( app dir , web inf web . xml ) ) , utf 8 ) ; try { w . write ( xml version = 1 . 0 encod = utf 8 n web app xmln = http : java . sun . com xml ns j2ee xmln : xsi = http : www . w3 . org 2001 xmlschema instanc xsi : schema locat = http : java . sun . com xml ns j2ee http : java . sun . com xml ns j2ee web app 2 4 . xsd version = 2 . 4 n error page n error code 404 error code n locat 404 absent . html locat n error page n web app n ) ; w . flush ( ) ; } final { w . close ( ) ; } tomcat tomcat = get tomcat instanc ( ) ; string context path = my app ; tomcat . add webapp ( null , context path , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; test custom error client client = new test custom error client ( ) ; client . set port ( get port ( ) ) ; client . reset ( ) ; client . set request ( new string { get my app miss http 1 . 0 crlf crlf } ) ; client . connect ( ) ; client . process request ( ) ; assert true ( client . response404 ( ) ) ; }	test public void test path param redirect ( ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; creat folder trigger redirect file foo = new file ( doc base , foo ) ; ( foo . exist ( ) foo . mkdir ( ) ) { fail ( unabl creat foo directori doc base ) ; } context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; tomcat . add servlet ( ctx , servlet , new path param servlet ( ) ) ; ctx . add servlet map ( , servlet ) ; tomcat . start ( ) ; test path ( , none ) ; test path ( ; jsessionid = 1234 , 1234 ) ; test path ( foo ; jsessionid = 1234 , 1234 ) ; test path ( foo ; jsessionid = 1234 ; dummi , 1234 ) ; test path ( foo ; jsessionid = 1234 ; dummi = 5678 , 1234 ) ; test path ( foo ; jsessionid = 1234 ; = 5678 , 1234 ) ; test path ( foo ; jsessionid = 1234 bar , 1234 ) ; }
public static static version { link init webapp default ( string ) } param ctx context set default void init webapp default ( context ctx ) { default servlet wrapper servlet = add servlet ( ctx , default , org . apach . catalina . servlet . default servlet ) ; servlet . set load startup ( 1 ) ; jsp servlet ( class name avoid load all dep ) servlet = add servlet ( ctx , jsp , org . apach . jasper . servlet . jsp servlet ) ; servlet . add init paramet ( fork , fals ) ; servlet . set load startup ( 3 ) ; servlet map ctx . add servlet map ( , default ) ; ctx . add servlet map ( . jsp , jsp ) ; ctx . add servlet map ( . jspx , jsp ) ; session ctx . set manag ( new standard manag ( ) ) ; ctx . set session timeout ( 30 ) ; mime map ( int i = 0 ; i default mime map . length ; ) { ctx . add mime map ( default mime map i , default mime map i ) ; } welcom file ctx . add welcom file ( index . html ) ; ctx . add welcom file ( index . htm ) ; ctx . add welcom file ( index . jsp ) ; }	public void do get ( http servlet request req , http servlet respons re ) throw ioexcept { re . get writer ( ) . write ( hello world ) ; }	test public void test jsp ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; file app dir = new file ( get build directori ( ) , webapp exampl ) ; app dir rel server home tomcat . add webapp ( null , exampl , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; byte chunk re = get url ( http : localhost : get port ( ) exampl jsp jsp2 el basic arithmet . jsp ) ; assert true ( re . string ( ) . index ( td { ( 1 = = 2 ) 3 : 4 } td ) 0 ) ; }

overrid public void lifecycl event ( lifecycl event event ) { initialis class when tomcat start ( lifecycl . befor init event . equal ( event . get type ( ) ) ) { class loader loader = thread . current thread ( ) . get context class loader ( ) ; try { us system classload victim all thi class loader pin we re about do . thread . current thread ( ) . set context class loader ( class loader . get system class loader ( ) ) ; first call thi load all driver current class loader ( driver manag protect ) { driver manag . get driver ( ) ; } issu . ( app context protect ) { imag io . get cach directori ( ) ; } sever compon end up call : sun . misc . gc . request latenc ( long ) those librari compon known trigger memori leak due eventu call request latenc ( long ) ar : javax . manag . remot . rmi . rmiconnector server . start ( ) ( gc daemon protect ) { try { class clazz = class . name ( sun . misc . gc ) ; method method = clazz . get declar method ( request latenc , new class { long . class } ) ; method . invok ( null , long . valu ( 3600000 ) ) ; } catch ( class found except e ) { ( system . get properti ( java . vendor ) . start ( sun ) ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } els { log . debug ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } } catch ( secur except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } catch ( method except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } catch ( illeg argument except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } catch ( illeg access except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } catch ( invoc target except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } } call get polici retain static refer context class loader . ( secur polici protect ) { try { polici . get polici ( ) ; class polici class = class . name ( javax . secur . auth . polici ) ; method method = polici class . get method ( get polici ) ; method . invok ( null ) ; } catch ( class found except e ) { ignor . class deprec . } catch ( secur except e ) { ignor . don t need call get polici ( ) success , just need trigger static initi . } catch ( method except e ) { log . warn ( sm . get string ( jre leak listen . auth polici fail ) , e ) ; } catch ( illeg argument except e ) { log . warn ( sm . get string ( jre leak listen . auth polici fail ) , e ) ; } catch ( illeg access except e ) { log . warn ( sm . get string ( jre leak listen . auth polici fail ) , e ) ; } catch ( invoc target except e ) { log . warn ( sm . get string ( jre leak listen . auth polici fail ) , e ) ; } } initi javax . secur . auth . login . configur retain static refer context class loader . ( secur login configur protect ) { try { class . name ( javax . secur . auth . login . configur , true , class loader . get system class loader ( ) ) ; } catch ( class found except e ) { ignor } } creat messag digest dure web applic startup initi java cryptographi architectur . under certain condit thi start token poller thread tccl equal web applic class loader . instead we initi jca right now . ( token poller protect ) { java . secur . secur . get provid ( ) ; } set default url cach polici cach ( url cach protect ) { try { doesn t matter thi jar doesn t exist just long url well form url url = new url ( jar : file : dummi . jar ) ; urlconnect u conn = url . open connect ( ) ; u conn . set default us cach ( fals ) ; } catch ( malform urlexcept e ) { log . error ( sm . get string ( jre leak listen . jar url conn cach fail ) , e ) ; } catch ( ioexcept e ) { log . error ( sm . get string ( jre leak listen . jar url conn cach fail ) , e ) ; } } haven t got root what go thi leak web app first make call below web applic class loader pin memori . ( xml pars protect ) { document builder factori factori = document builder factori . new instanc ( ) ; try { factori . new document builder ( ) ; } catch ( parser configur except e ) { log . error ( sm . get string ( jre leak listen . xml pars fail ) , e ) ; } } ( ldap pool protect ) { try { class . name ( com . sun . jndi . ldap . ldap pool manag ) ; } catch ( class found except e ) { ( system . get properti ( java . vendor ) . start ( sun ) ) { log . error ( sm . get string ( jre leak listen . ldap pool manag fail ) , e ) ; } els { log . debug ( sm . get string ( jre leak listen . ldap pool manag fail ) , e ) ; } } } } final { thread . current thread ( ) . set context class loader ( loader ) ; } } }	public boolean gc daemon protect ( ) { return gc daemon protect ; }
background thread listen incom tcp ip connect hand them off appropri processor . overrid public void run ( ) { long maintain time = 0 ; loop until we receiv shutdown command while ( run ) { loop endpoint paus while ( paus run ) { try { thread . sleep ( 1000 ) ; } catch ( interrupt except e ) { ignor } } ( run ) { break ; } ( keep aliv count 1 add count 1 ) { synchron ( thi ) { while ( keep aliv count 1 add count 1 run ) { reset maintain time . maintain time = 0 ; try { thi . wait ( ) ; } catch ( interrupt except e ) { ignor } } } } ( run ) { break ; } try { add socket which ar wait poller ( add count 0 ) { synchron ( thi ) { int success count = 0 ; try { ( int i = ( add count 1 ) ; i = 0 ; i ) { int rv = poll . add ( server pollset , add s i , poll . apr pollin ) ; ( rv = = statu . apr success ) { success count ; } els { can t do anyth : close socket right awai ( comet ) { process socket ( add s i , socket statu . error ) ; } els { destroi socket ( add s i ) ; } } } } final { keep aliv count = success count ; add count = 0 ; } } } maintain time = poll time ; pool specifi interv int rv = poll . poll ( server pollset , poll time , desc , true ) ; ( rv 0 ) { keep aliv count = rv ; ( int n = 0 ; n rv ; n ) { check fail socket hand thi socket off worker ( ( ( desc n 2 poll . apr pollhup ) = = poll . apr pollhup ) ( ( desc n 2 poll . apr pollerr ) = = poll . apr pollerr ) ( comet ( process socket ( desc n 2 1 , socket statu . open ) ) ) ( comet ( process socket ( desc n 2 1 ) ) ) ) { close socket clear pool ( comet ) { process socket ( desc n 2 1 , socket statu . disconnect ) ; } els { destroi socket ( desc n 2 1 ) ; } continu ; } } } els ( rv 0 ) { int errn = rv ; ani non timeup interrupt error critic ( ( errn = statu . timeup ) ( errn = statu . eintr ) ) { ( errn statu . apr os start usererr ) { errn = statu . apr os start usererr ; } log . error ( sm . get string ( endpoint . poll . fail , errn , error . strerror ( errn ) ) ) ; handl poll critic failur synchron ( thi ) { destroi ( ) ; init ( ) ; } continu ; } } ( socket properti . get so timeout ( ) 0 maintain time 1000000l run ) { rv = poll . maintain ( server pollset , desc , true ) ; maintain time = 0 ; ( rv 0 ) { keep aliv count = rv ; ( int n = 0 ; n rv ; n ) { close socket clear pool ( comet ) { process socket ( desc n , socket statu . timeout ) ; } els { destroi socket ( desc n ) ; } } } } } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( sm . get string ( endpoint . poll . error ) , t ) ; } } synchron ( thi ) { thi . notifi all ( ) ; } }	overrid protect void long poll ( socket wrapper long socket , http11apr processor processor ) { connect . put ( socket . get socket ( ) , processor ) ; ( processor . async ( ) ) { socket . set async ( true ) ; } els ( processor . comet ) { ( ( apr endpoint ) proto . endpoint ) . get comet poller ( ) . add ( socket . get socket ( ) . long valu ( ) ) ; } }	public void run ( ) { loop until we receiv shutdown command while ( run ) { try { thread . sleep ( 1000 ) ; } catch ( interrupt except e ) { ignor } long now = system . current time milli ( ) ; iter socket wrapper long >> socket = wait request . iter ( ) ; while ( socket . ha next ( ) ) { socket wrapper long socket = socket . next ( ) ; ( socket . async ) { long access = socket . get last access ( ) ; ( socket . get timeout ( ) 0 ( now access ) socket . get timeout ( ) ) { process socket async ( socket , socket statu . timeout ) ; } } } loop endpoint paus while ( paus run ) { try { thread . sleep ( 1000 ) ; } catch ( interrupt except e ) { ignor } } } }	public add specifi socket associ pool poller . socket ad temporari arrai , poll first after maximum amount time equal poll time ( most case , latenc much lower , howev ) . param socket add poller void add ( long socket ) { synchron ( thi ) { most poll time befor poll ( add count = add s . length ) { can t do anyth : close socket right awai ( comet ) { process socket ( socket , socket statu . error ) ; } els { destroi socket ( socket ) ; } return ; } add s add count = socket ; add count ; thi . notifi ( ) ; } }	background thread listen incom tcp ip connect hand them off appropri processor . overrid public void run ( ) { long maintain time = 0 ; loop until we receiv shutdown command while ( run ) { loop endpoint paus while ( paus run ) { try { thread . sleep ( 1000 ) ; } catch ( interrupt except e ) { ignor } } ( run ) { break ; } ( keep aliv count 1 add count 1 ) { synchron ( thi ) { while ( keep aliv count 1 add count 1 run ) { reset maintain time . maintain time = 0 ; try { thi . wait ( ) ; } catch ( interrupt except e ) { ignor } } } } ( run ) { break ; } try { add socket which ar wait poller ( add count 0 ) { synchron ( thi ) { int success count = 0 ; try { ( int i = ( add count 1 ) ; i = 0 ; i ) { int rv = poll . add ( server pollset , add s i , poll . apr pollin ) ; ( rv = = statu . apr success ) { success count ; } els { can t do anyth : close socket right awai ( comet ) { process socket ( add s i , socket statu . error ) ; } els { destroi socket ( add s i ) ; } } } } final { keep aliv count = success count ; add count = 0 ; } } } maintain time = poll time ; pool specifi interv int rv = poll . poll ( server pollset , poll time , desc , true ) ; ( rv 0 ) { keep aliv count = rv ; ( int n = 0 ; n rv ; n ) { check fail socket hand thi socket off worker ( ( ( desc n 2 poll . apr pollhup ) = = poll . apr pollhup ) ( ( desc n 2 poll . apr pollerr ) = = poll . apr pollerr ) ( comet ( process socket ( desc n 2 1 , socket statu . open ) ) ) ( comet ( process socket ( desc n 2 1 ) ) ) ) { close socket clear pool ( comet ) { process socket ( desc n 2 1 , socket statu . disconnect ) ; } els { destroi socket ( desc n 2 1 ) ; } continu ; } } } els ( rv 0 ) { int errn = rv ; ani non timeup interrupt error critic ( ( errn = statu . timeup ) ( errn = statu . eintr ) ) { ( errn statu . apr os start usererr ) { errn = statu . apr os start usererr ; } log . error ( sm . get string ( endpoint . poll . fail , errn , error . strerror ( errn ) ) ) ; handl poll critic failur synchron ( thi ) { destroi ( ) ; init ( ) ; } continu ; } } ( socket properti . get so timeout ( ) 0 maintain time 1000000l run ) { rv = poll . maintain ( server pollset , desc , true ) ; maintain time = 0 ; ( rv 0 ) { keep aliv count = rv ; ( int n = 0 ; n rv ; n ) { close socket clear pool ( comet ) { process socket ( desc n , socket statu . timeout ) ; } els { destroi socket ( desc n ) ; } } } } } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( sm . get string ( endpoint . poll . error ) , t ) ; } } synchron ( thi ) { thi . notifi all ( ) ; } }	expect us handler onc processor longer requir . overrid public void releas ( socket wrapper long socket , ajp apr processor processor , boolean socket close , boolean add poller ) { processor . recycl ( socket close ) ; recycl processor . offer ( processor ) ; ( add poller ) { ( ( apr endpoint ) proto . endpoint ) . get poller ( ) . add ( socket . get socket ( ) . long valu ( ) ) ; } }	expect us handler onc processor longer requir . param socket param processor param socket close us http param add poller overrid public void releas ( socket wrapper long socket , http11apr processor processor , boolean socket close , boolean add poller ) { processor . recycl ( ) ; recycl processor . offer ( processor ) ; ( add poller ) { ( ( apr endpoint ) proto . endpoint ) . get poller ( ) . add ( socket . get socket ( ) . long valu ( ) ) ; } }	protect log get log ( ) { return log ; }
overrid public void log ( org . apach . coyot . request req , org . apach . coyot . respons re , long time ) { request request = ( request ) req . get note ( adapt note ) ; respons respons = ( respons ) re . get note ( adapt note ) ; boolean creat = fals ; ( request = = null ) { creat = true ; creat object request = connector . creat request ( ) ; request . set coyot request ( req ) ; respons = connector . creat respons ( ) ; respons . set coyot respons ( re ) ; link object request . set respons ( respons ) ; respons . set request ( request ) ; set note req . set note ( adapt note , request ) ; re . set note ( adapt note , respons ) ; set queri string encod req . get paramet ( ) . set queri string encod ( connector . get uriencod ( ) ) ; } try { log lowest level avail . log access ( ) automat call parent contain . boolean log = fals ; ( request . map data = null ) { ( request . map data . context = null ) { log = true ; ( ( context ) request . map data . context ) . log access ( request , respons , time , true ) ; } els ( request . map data . host = null ) { log = true ; ( ( context ) request . map data . context ) . log access ( request , respons , time , true ) ; } } ( log ) { connector . get servic ( ) . get contain ( ) . log access ( request , respons , time , true ) ; } } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . warn ( sm . get string ( coyot adapt . accesslog fail ) , t ) ; } ( creat ) { request . recycl ( ) ; respons . recycl ( ) ; } }
public process start event thi host . void start ( ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( host config . start ) ) ; try { object name host = host . get object name ( ) ; onam = new object name ( host . get domain ( ) : type = deploy , host = host . get name ( ) ) ; registri . get registri ( null , null ) . regist compon ( thi , onam , thi . get class ( ) . get name ( ) ) ; } catch ( except e ) { log . error ( sm . get string ( host config . jmx . regist , onam ) , e ) ; } ( host . get creat dir ( ) ) { file dir = new file { app base ( ) , config base ( ) } ; ( int i = 0 ; i dir . length ; i ) { ( ( dir i . directori ( ) ) ( dir i . mkdir ( ) ) ) { log . error ( sm . get string ( host config . creat dir , dir i ) ) ; } } } ( host . get deploi startup ( ) ) deploi app ( ) ; }
public static normal rel uri path mai have rel valu ( . , . . , so ) . strong warn strong thi method us onli normal applic gener path . doe try perform secur check malici input . param path rel path normal param replac back slash should replac string normal ( string path , boolean replac back slash ) { ( path = = null ) return null ; creat place normal path string normal = path ; ( replac back slash normal . index ( ) = 0 ) normal = normal . replac ( , ) ; ( normal . equal ( . ) ) return ; add lead necessari ( normal . start ( ) ) normal = normal ; resolv occurr normal path while ( true ) { int index = normal . index ( ) ; ( index 0 ) break ; normal = normal . substr ( 0 , index ) normal . substr ( index 1 ) ; } resolv occurr . normal path while ( true ) { int index = normal . index ( . ) ; ( index 0 ) break ; normal = normal . substr ( 0 , index ) normal . substr ( index 2 ) ; } resolv occurr . . normal path while ( true ) { int index = normal . index ( . . ) ; ( index 0 ) break ; ( index = = 0 ) try go outsid our context return ( null ) ; int index2 = normal . last index ( , index 1 ) ; normal = normal . substr ( 0 , index2 ) normal . substr ( index 3 ) ; } return normal path we have complet return ( normal ) ; }	public static append request paramet from specifi string specifi map . presum specifi map access from ani other thread , so synchron perform . p strong implement note strong : url decod perform individu pars name valu element , rather than entir queri string ahead time , properli deal case where name valu includ encod = charact would otherwis interpret delimit . param map map accumul result paramet param data input string contain request paramet param encod encod us ; null , default encod us . unsupport encod specifi paramet pars map modifi void pars paramet ( map string , string map , string data , string encod ) { ( ( data = null ) ( data . length ( ) 0 ) ) { us specifi encod extract byte out given string so encod lost . encod specifi , let us platform default byte byte = null ; try { ( encod = = null ) { byte = data . get byte ( charset . default charset ( ) ) ; } els { byte = data . get byte ( b2cconvert . get charset ( encod ) ) ; } pars paramet ( map , byte , encod ) ; } catch ( unsupport encod except uee ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( request util . pars paramet . uee , encod ) , uee ) ; } } } }
privat static javac error detail pars javac messag ( string err msg , string fname , node . node page ) throw ioexcept , jasper except { arrai list javac error detail error = new arrai list javac error detail ( ) ; string builder err msg buf = null ; int line num = 1 ; javac error detail javac error = null ; buffer reader reader = new buffer reader ( new string reader ( err msg ) ) ; pars compil error . each compil error consist file path error line number , follow number line describ error . string line = null ; while ( ( line = reader . read line ( ) ) = null ) { error line number delimit set colon . ignor colon follow drive letter window ( from index = 2 ) . xxx handl deprec warn don t have line info int begin colon = line . index ( : , 2 ) ; int end colon = line . index ( : , begin colon 1 ) ; ( ( begin colon = 0 ) ( end colon = 0 ) ) { ( javac error = null ) { add previou error error vector error . add ( javac error ) ; } string line num str = line . substr ( begin colon 1 , end colon ) ; try { line num = integ . pars int ( line num str ) ; } catch ( number format except e ) { line num = 1 ; } err msg buf = new string builder ( ) ; javac error = creat javac error ( fname , page , err msg buf , line num ) ; } ignor messag preced first error ( err msg buf = null ) { err msg buf . append ( line ) ; err msg buf . append ( n ) ; } } add last error error vector ( javac error = null ) { error . add ( javac error ) ; } reader . close ( ) ; javac error detail err detail = null ; ( error . size ( ) 0 ) { err detail = new javac error detail error . size ( ) ; error . arrai ( err detail ) ; } return err detail ; }	process given javac compil error . param detail arrai javac error detail instanc correspond compil error overrid public void javac error ( javac error detail detail ) throw jasper except { ( detail = = null ) { return ; } object arg = null ; string builder buf = new string builder ( ) ; ( int i = 0 ; i detail . length ; i ) { ( detail i . get jsp begin line number ( ) = 0 ) { arg = new object { integ . valu ( detail i . get jsp begin line number ( ) ) , detail i . get jsp file name ( ) } ; buf . append ( n n ) ; buf . append ( local . get messag ( jsp . error . singl . line . number , arg ) ) ; buf . append ( n ) ; buf . append ( detail i . get error messag ( ) ) ; buf . append ( n ) ; buf . append ( detail i . get jsp extract ( ) ) ; } els { arg = new object { integ . valu ( detail i . get java line number ( ) ) } ; buf . append ( n n ) ; buf . append ( local . get messag ( jsp . error . java . line . number , arg ) ) ; buf . append ( n ) ; buf . append ( detail i . get error messag ( ) ) ; } } buf . append ( n n stacktrac : ) ; throw new jasper except ( local . get messag ( jsp . error . unabl . compil ) : buf ) ; }
public list children thi collect . name given ar rel thi uri s path . full uri children : path name . enumer string list ( ) throw ioexcept { ( connect ) { connect ( ) ; } ( ( resourc = = null ) ( collect = = null ) ) { throw new file found except ( get url ( ) = = null null : get url ( ) . string ( ) ) ; } vector string result = new vector string ( ) ; ( collect = null ) { try { string file = get url ( ) . get file ( ) ; thi form hostnam contextpath file name contextpath empti otherwis thi form hostnam file name strip off hostnam contextpath int start ; ( context instanceof proxi dir context . equal ( ( ( proxi dir context ) context ) . get context path ( ) ) ) { start = file . index ( , 1 ) ; } els start = file . index ( , file . index ( , 1 ) 1 ) ; name enumer name class pair enumer = context . list ( file . substr ( start ) ) ; while ( enumer . ha more element ( ) ) { name class pair ncp = enumer . next element ( ) ; result . add element ( urlencod . encod ( ncp . get name ( ) , utf 8 ) ) ; } } catch ( name except e ) { unexpect except throw new file found except ( get url ( ) = = null null : get url ( ) . string ( ) ) ; } } return result . element ( ) ; }
overrid public void lifecycl event ( lifecycl event event ) { initialis class when tomcat start ( lifecycl . befor init event . equal ( event . get type ( ) ) ) { class loader loader = thread . current thread ( ) . get context class loader ( ) ; try { us system classload victim all thi class loader pin we re about do . thread . current thread ( ) . set context class loader ( class loader . get system class loader ( ) ) ; issu . ( app context protect ) { imag io . get cach directori ( ) ; } sever compon end up call : sun . misc . gc . request latenc ( long ) those librari compon known trigger memori leak due eventu call request latenc ( long ) ar : javax . manag . remot . rmi . rmiconnector server . start ( ) ( gc daemon protect ) { try { class clazz = class . name ( sun . misc . gc ) ; method method = clazz . get declar method ( request latenc , new class { long . class } ) ; method . invok ( null , long . valu ( 3600000 ) ) ; } catch ( class found except e ) { ( system . get properti ( java . vendor ) . start ( sun ) ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } els { log . debug ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } } catch ( secur except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } catch ( method except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } catch ( illeg argument except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } catch ( illeg access except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } catch ( invoc target except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } } call get polici retain static refer context class loader . ( secur polici protect ) { try { polici . get polici ( ) ; class polici class = class . name ( javax . secur . auth . polici ) ; method method = polici class . get method ( get polici ) ; method . invok ( null ) ; } catch ( class found except e ) { ignor . class deprec . } catch ( secur except e ) { ignor . don t need call get polici ( ) success , just need trigger static initi . } catch ( method except e ) { log . warn ( sm . get string ( jre leak listen . auth polici fail ) , e ) ; } catch ( illeg argument except e ) { log . warn ( sm . get string ( jre leak listen . auth polici fail ) , e ) ; } catch ( illeg access except e ) { log . warn ( sm . get string ( jre leak listen . auth polici fail ) , e ) ; } catch ( invoc target except e ) { log . warn ( sm . get string ( jre leak listen . auth polici fail ) , e ) ; } } initi javax . secur . auth . login . configur retain static refer context class loader . ( secur login configur protect ) { try { class . name ( javax . secur . auth . login . configur , true , class loader . get system class loader ( ) ) ; } catch ( class found except e ) { ignor } } creat messag digest dure web applic startup initi java cryptographi architectur . under certain condit thi start token poller thread tccl equal web applic class loader . instead we initi jca right now . ( token poller protect ) { java . secur . secur . get provid ( ) ; } set default url cach polici cach ( url cach protect ) { try { doesn t matter thi jar doesn t exist just long url well form url url = new url ( jar : file : dummi . jar ) ; urlconnect u conn = url . open connect ( ) ; u conn . set default us cach ( fals ) ; } catch ( malform urlexcept e ) { log . error ( sm . get string ( jre leak listen . jar url conn cach fail ) , e ) ; } catch ( ioexcept e ) { log . error ( sm . get string ( jre leak listen . jar url conn cach fail ) , e ) ; } } haven t got root what go thi leak web app first make call below web applic class loader pin memori . ( xml pars protect ) { document builder factori factori = document builder factori . new instanc ( ) ; try { factori . new document builder ( ) ; } catch ( parser configur except e ) { log . error ( sm . get string ( jre leak listen . xml pars fail ) , e ) ; } } ( ldap pool protect ) { try { class . name ( com . sun . jndi . ldap . ldap pool manag ) ; } catch ( class found except e ) { ( system . get properti ( java . vendor ) . start ( sun ) ) { log . error ( sm . get string ( jre leak listen . ldap pool manag fail ) , e ) ; } els { log . debug ( sm . get string ( jre leak listen . ldap pool manag fail ) , e ) ; } } } } final { thread . current thread ( ) . set context class loader ( loader ) ; } } }	public void set ldap pool protect ( boolean ldap pool protect ) { thi . ldap pool protect = ldap pool protect ; }	public boolean ldap pool protect ( ) { return ldap pool protect ; }
expect us poller releas resourc socket close , error etc . overrid public void releas ( socket wrapper nio channel socket ) { http11nio processor processor = connect . remov ( socket ) ; ( processor = null ) { processor . recycl ( ) ; recycl processor . offer ( processor ) ; } }
protect void connect us driver ( ) throw sqlexcept { try { ( driver = = null ) driver = ( java . sql . driver ) class . name ( pool properti . get driver class name ( ) , true , pool connect . class . get class loader ( ) ) . new instanc ( ) ; } catch ( java . lang . except cn ) { ( log . debug enabl ( ) ) { log . debug ( unabl instanti jdbc driver . , cn ) ; } sqlexcept ex = new sqlexcept ( cn . get messag ( ) ) ; ex . init caus ( cn ) ; throw ex ; } string driver url = pool properti . get url ( ) ; string usr = null ; string pwd = null ; ( get attribut ( ) . contain kei ( prop user ) ) { usr = ( string ) get attribut ( ) . get ( prop user ) ; } els { usr = pool properti . get usernam ( ) ; get attribut ( ) . put ( prop user , usr ) ; } ( get attribut ( ) . contain kei ( prop password ) ) { pwd = ( string ) get attribut ( ) . get ( prop password ) ; } els { pwd = pool properti . get password ( ) ; get attribut ( ) . put ( prop password , pwd ) ; } properti properti = pool util . clone ( pool properti . get db properti ( ) ) ; ( usr = null ) properti . set properti ( prop user , usr ) ; ( pwd = null ) properti . set properti ( prop password , pwd ) ; try { connect = connect = driver . connect ( driver url , properti ) ; } catch ( except x ) { ( log . debug enabl ( ) ) { log . debug ( unabl connect databas . , x ) ; } ( parent . jmx pool = null ) { parent . jmx pool . notifi ( org . apach . tomcat . jdbc . pool . jmx . connect pool . notifi connect , connect pool . get stack trace ( x ) ) ; } ( x instanceof sqlexcept ) { throw ( sqlexcept ) x ; } els { sqlexcept ex = new sqlexcept ( x . get messag ( ) ) ; ex . init caus ( x ) ; throw ex ; } } ( connect = = null ) { throw new sqlexcept ( driver : driver return null url : driver url ) ; } }
overrid public final synchron void destroi ( ) throw lifecycl except { ( lifecycl state . destroi . equal ( state ) lifecycl state . destroi . equal ( state ) ) { ( log . debug enabl ( ) ) { except e = new lifecycl except ( ) ; log . debug ( sm . get string ( lifecycl base . alreadi destroi , string ( ) ) , e ) ; } els ( log . info enabl ( ) ) { log . info ( sm . get string ( lifecycl base . alreadi destroi , string ( ) ) ) ; } return ; } ( state . equal ( lifecycl state . stop ) state . equal ( lifecycl state . fail ) state . equal ( lifecycl state . new ) state . equal ( lifecycl state . initi ) ) { invalid transit ( lifecycl . befor destroi event ) ; } set state intern ( lifecycl state . destroi , null , fals ) ; try { destroi intern ( ) ; } catch ( lifecycl except e ) { set state intern ( lifecycl state . fail , null , fals ) ; throw e ; } set state intern ( lifecycl state . destroi , null , fals ) ; }	overrid public final synchron void init ( ) throw lifecycl except { ( state . equal ( lifecycl state . new ) ) { invalid transit ( lifecycl . befor init event ) ; } set state intern ( lifecycl state . initi , null , fals ) ; try { init intern ( ) ; } catch ( lifecycl except e ) { set state intern ( lifecycl state . fail , null , fals ) ; throw e ; } set state intern ( lifecycl state . initi , null , fals ) ; }	{ inherit doc } overrid public final synchron void start ( ) throw lifecycl except { ( lifecycl state . start prep . equal ( state ) lifecycl state . start . equal ( state ) lifecycl state . start . equal ( state ) ) { ( log . debug enabl ( ) ) { except e = new lifecycl except ( ) ; log . debug ( sm . get string ( lifecycl base . alreadi start , string ( ) ) , e ) ; } els ( log . info enabl ( ) ) { log . info ( sm . get string ( lifecycl base . alreadi start , string ( ) ) ) ; } return ; } ( state . equal ( lifecycl state . new ) ) { init ( ) ; } els ( state . equal ( lifecycl state . initi ) state . equal ( lifecycl state . stop ) ) { invalid transit ( lifecycl . befor start event ) ; } set state intern ( lifecycl state . start prep , null , fals ) ; try { start intern ( ) ; } catch ( lifecycl except e ) { set state intern ( lifecycl state . fail , null , fals ) ; throw e ; } ( state . equal ( lifecycl state . fail ) state . equal ( lifecycl state . must stop ) ) { stop ( ) ; } els { do what thei ar suppos . ( state . equal ( lifecycl state . start ) ) { invalid transit ( lifecycl . after start event ) ; } set state intern ( lifecycl state . start , null , fals ) ; } }	{ inherit doc } overrid public final synchron void stop ( ) throw lifecycl except { ( lifecycl state . stop prep . equal ( state ) lifecycl state . stop . equal ( state ) lifecycl state . stop . equal ( state ) ) { ( log . debug enabl ( ) ) { except e = new lifecycl except ( ) ; log . debug ( sm . get string ( lifecycl base . alreadi stop , string ( ) ) , e ) ; } els ( log . info enabl ( ) ) { log . info ( sm . get string ( lifecycl base . alreadi stop , string ( ) ) ) ; } return ; } ( state . equal ( lifecycl state . new ) ) { state = lifecycl state . stop ; return ; } ( state . equal ( lifecycl state . start ) state . equal ( lifecycl state . fail ) state . equal ( lifecycl state . must stop ) ) { invalid transit ( lifecycl . befor stop event ) ; } ( state . equal ( lifecycl state . fail ) ) { don t transit stop prep would briefli mark compon avail do ensur befor stop event fire fire lifecycl event ( befor stop event , null ) ; } els { set state intern ( lifecycl state . stop prep , null , fals ) ; } try { stop intern ( ) ; } catch ( lifecycl except e ) { set state intern ( lifecycl state . fail , null , fals ) ; throw e ; } ( state . equal ( lifecycl state . must destroi ) ) { complet stop process first set state intern ( lifecycl state . stop , null , fals ) ; destroi ( ) ; } els { do what thei ar suppos . ( state . equal ( lifecycl state . stop ) ) { invalid transit ( lifecycl . after stop event ) ; } set state intern ( lifecycl state . stop , null , fals ) ; } }
public call our background reaper thread check session save our store ar subject expir . so expir session remov from store . void process expir ( ) { string kei = null ; ( get state ( ) . avail ( ) ) { return ; } try { kei = kei ( ) ; } catch ( ioexcept e ) { manag . get contain ( ) . get logger ( ) . error ( error get kei , e ) ; return ; } ( manag . get contain ( ) . get logger ( ) . debug enabl ( ) ) { manag . get contain ( ) . get logger ( ) . debug ( get store name ( ) : process expir check number kei . length session ) ; } long time now = system . current time milli ( ) ; ( int i = 0 ; i kei . length ; i ) { try { standard session session = ( standard session ) load ( kei i ) ; ( session = = null ) { continu ; } int time idl = ( int ) ( ( time now session . get thi access time ( ) ) 1000l ) ; ( time idl session . get max inact interv ( ) ) { continu ; } ( manag . get contain ( ) . get logger ( ) . debug enabl ( ) ) { manag . get contain ( ) . get logger ( ) . debug ( get store name ( ) : process expir expir store session kei i ) ; } boolean load = fals ; try { ( manag . find session ( kei i ) = null ) { load = true ; } } catch ( ioexcept ioe ) { ignor session expir } ( load ) { recycl old backup session session . recycl ( ) ; } els { expir swap out session session . expir ( ) ; } remov ( kei i ) ; } catch ( except e ) { manag . get contain ( ) . get logger ( ) . error ( session : kei i ; , e ) ; try { remov ( kei i ) ; } catch ( ioexcept e2 ) { manag . get contain ( ) . get logger ( ) . error ( error remov kei , e2 ) ; } } } }
privat creat access log element implement which need header string access log element creat access log element ( string header , char pattern ) { switch ( pattern ) { case i : return new header element ( header ) ; case c : return new cooki element ( header ) ; case o : return new respons header element ( header ) ; case r : return new request attribut element ( header ) ; case s : return new session attribut element ( header ) ; case t : return new date time element ( header ) ; default : return new string element ( ) ; } }	protect access log element creat log element ( ) { list access log element list = new arrai list access log element ( ) ; boolean replac = fals ; string builder buf = new string builder ( ) ; ( int i = 0 ; i pattern . length ( ) ; i ) { char ch = pattern . char ( i ) ; ( replac ) { code process { , behavior . . . i do encount close } i ignor { ( { = = ch ) { string builder name = new string builder ( ) ; int j = i 1 ; ( ; j pattern . length ( ) } = pattern . char ( j ) ; j ) { name . append ( pattern . char ( j ) ) ; } ( j 1 pattern . length ( ) ) { 1 wa account } which we increment now j ; list . add ( creat access log element ( name . string ( ) , pattern . char ( j ) ) ) ; i = j ; sinc we walk more than charact } els { d oh end string pretend we never did thi do process old wai list . add ( creat access log element ( ch ) ) ; } } els { list . add ( creat access log element ( ch ) ) ; } replac = fals ; } els ( ch = = ) { replac = true ; list . add ( new string element ( buf . string ( ) ) ) ; buf = new string builder ( ) ; } els { buf . append ( ch ) ; } } ( buf . length ( ) 0 ) { list . add ( new string element ( buf . string ( ) ) ) ; } return list . arrai ( new access log element 0 ) ; }
protect class packag web applic , class each super class need check match { link handl type } annot match { link handl type } . param java class void check handl type ( java class java class ) { skip thi we can ( type initi map . size ( ) = = 0 ) return ; choic load class string class name = java class . get class name ( ) ; class clazz = null ; try { clazz = context . get loader ( ) . get class loader ( ) . load class ( class name ) ; } catch ( class def found error e ) { log . debug ( sm . get string ( context config . invalid sci handl type , class name ) , e ) ; return ; } catch ( class found except e ) { log . warn ( sm . get string ( context config . invalid sci handl type , class name ) , e ) ; return ; } catch ( class format error e ) { log . warn ( sm . get string ( context config . invalid sci handl type , class name ) , e ) ; return ; } ( clazz . annot ( ) ) { skip return ; } boolean match = fals ; ( map . entri class , set servlet contain initi >> entri : type initi map . entri set ( ) ) { ( entri . get kei ( ) . annot ( ) ) { annot entri annot entri = java class . get annot entri ( ) ; ( annot entri annot entri : annot entri ) { ( entri . get kei ( ) . get name ( ) . equal ( get class name ( annot entri . get annot type ( ) ) ) ) { match = true ; break ; } } } els ( entri . get kei ( ) . assign from ( clazz ) ) { match = true ; } ( match ) { ( servlet contain initi sci : entri . get valu ( ) ) { initi class map . get ( sci ) . add ( clazz ) ; } match = fals ; } } }
public boolean respons bodi ok ( ) { ( get respons bodi ( ) = = null ) { return fals ; } ( get respons bodi ( ) . contain ( abcd tefgh ) ) { return fals ; } return true ; }	public pars http header . return fals after read blank line ( which indic http header pars done header pars statu pars header ( ) throw ioexcept { check blank line byte chr = 0 ; while ( header pars po = = header pars posit . header start ) { read new byte need ( po = last valid ) { ( fill ( true , fals ) ) { pars header header pars po = header pars posit . header start ; return header pars statu . need more data ; } } chr = buf po ; ( ( chr = = constant . cr ) ( chr = = constant . lf ) ) { ( chr = = constant . lf ) { po ; return header pars statu . done ; } } els { break ; } po ; } ( header pars po = = header pars posit . header start ) { mark current buffer posit header data . start = po ; header pars po = header pars posit . header name ; } while ( header pars po = = header pars posit . header name ) { read new byte need ( po = last valid ) { ( fill ( true , fals ) ) { pars header return header pars statu . need more data ; } } ( buf po = = constant . colon ) { header pars po = header pars posit . header valu ; header data . header valu = header . add valu ( buf , header data . start , po header data . start ) ; } chr = buf po ; ( ( chr = constant . ) ( chr = constant . z ) ) { buf po = ( byte ) ( chr constant . lc offset ) ; } po ; ( header pars po = = header pars posit . header valu ) { mark current buffer posit header data . start = po ; header data . real po = po ; } } read header valu ( which can span over multipl line ) boolean eol = fals ; while ( header pars po = = header pars posit . header valu header pars po = = header pars posit . header multi line ) { ( header pars po = = header pars posit . header valu ) { boolean space = true ; skip space while ( space ) { read new byte need ( po = last valid ) { ( fill ( true , fals ) ) { header valu , should alreadi set return header pars statu . need more data ; } } ( ( buf po = = constant . sp ) ( buf po = = constant . ht ) ) { po ; } els { space = fals ; } } header data . last signific char = header data . real po ; read byte until end line while ( eol ) { read new byte need ( po = last valid ) { ( fill ( true , fals ) ) { header valu return header pars statu . need more data ; } } ( buf po = = constant . cr ) { skip } els ( buf po = = constant . lf ) { eol = true ; } els ( buf po = = constant . sp ) { buf header data . real po = buf po ; header data . real po ; } els { buf header data . real po = buf po ; header data . real po ; header data . last signific char = header data . real po ; } po ; } header data . real po = header data . last signific char ; check first charact new line . charact lw , s multilin header header pars po = header pars posit . header multi line ; } read new byte need ( po = last valid ) { ( fill ( true , fals ) ) { header multi line return header pars statu . need more data ; } } chr = buf po ; ( header pars po = = header pars posit . header multi line ) { ( ( chr = constant . sp ) ( chr = constant . ht ) ) { header pars po = header pars posit . header start ; } els { eol = fals ; copi extra space buffer ( sinc must least space insert between line ) buf header data . real po = chr ; header data . real po ; header pars po = header pars posit . header valu ; } } } set header valu header data . header valu . set byte ( buf , header data . start , header data . real po header data . start ) ; header data . recycl ( ) ; return header pars statu . have more header ; }	header valu cannot null suppress warn ( null ) public boolean pars header ( ) throw ioexcept { check blank line byte chr = 0 ; while ( true ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } chr = buf po ; ( ( chr = = constant . cr ) ( chr = = constant . lf ) ) { ( chr = = constant . lf ) { po ; return fals ; } } els { break ; } po ; } mark current buffer posit int start = po ; read header name header name alwai us ascii boolean colon = fals ; messag byte header valu = null ; while ( colon ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } ( buf po = = constant . colon ) { colon = true ; header valu = header . add valu ( buf , start , po start ) ; } chr = buf po ; ( ( chr = constant . ) ( chr = constant . z ) ) { buf po = ( byte ) ( chr constant . lc offset ) ; } po ; } mark current buffer posit start = po ; int real po = po ; read header valu ( which can span over multipl line ) boolean eol = fals ; boolean valid line = true ; while ( valid line ) { boolean space = true ; skip space while ( space ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } ( ( buf po = = constant . sp ) ( buf po = = constant . ht ) ) { po ; } els { space = fals ; } } int last signific char = real po ; read byte until end line while ( eol ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } ( buf po = = constant . cr ) { skip } els ( buf po = = constant . lf ) { eol = true ; } els ( buf po = = constant . sp ) { buf real po = buf po ; real po ; } els { buf real po = buf po ; real po ; last signific char = real po ; } po ; } real po = last signific char ; read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } chr = buf po ; ( ( chr = constant . sp ) ( chr = constant . ht ) ) { valid line = fals ; } els { eol = fals ; copi extra space buffer ( sinc must least space insert between line ) buf real po = chr ; real po ; } } set header valu header valu . set byte ( buf , start , real po start ) ; return true ; }	header valu cannot null suppress warn ( null ) public boolean pars header ( ) throw ioexcept { check blank line byte chr = 0 ; while ( true ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } chr = buf po ; ( ( chr = = constant . cr ) ( chr = = constant . lf ) ) { ( chr = = constant . lf ) { po ; return fals ; } } els { break ; } po ; } mark current buffer posit int start = po ; read header name header name alwai us ascii boolean colon = fals ; messag byte header valu = null ; while ( colon ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } ( buf po = = constant . colon ) { colon = true ; header valu = header . add valu ( buf , start , po start ) ; } chr = buf po ; ( ( chr = constant . ) ( chr = constant . z ) ) { buf po = ( byte ) ( chr constant . lc offset ) ; } po ; } mark current buffer posit start = po ; int real po = po ; read header valu ( which can span over multipl line ) boolean eol = fals ; boolean valid line = true ; while ( valid line ) { boolean space = true ; skip space while ( space ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } ( ( buf po = = constant . sp ) ( buf po = = constant . ht ) ) { po ; } els { space = fals ; } } int last signific char = real po ; read byte until end line while ( eol ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } ( buf po = = constant . cr ) { skip } els ( buf po = = constant . lf ) { eol = true ; } els ( buf po = = constant . sp ) { buf real po = buf po ; real po ; } els { buf real po = buf po ; real po ; last signific char = real po ; } po ; } real po = last signific char ; read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } chr = buf po ; ( ( chr = constant . sp ) ( chr = constant . ht ) ) { valid line = fals ; } els { eol = fals ; copi extra space buffer ( sinc must least space insert between line ) buf real po = chr ; real po ; } } set header valu header valu . set byte ( buf , start , real po start ) ; return true ; }	read some byte . overrid public int do read ( byte chunk chunk , request req ) throw ioexcept { ( last activ filter = = 1 ) return input stream input buffer . do read ( chunk , req ) ; els return activ filter last activ filter . do read ( chunk , req ) ; }	public set swallow input flag . void set swallow input ( boolean swallow input ) { thi . swallow input = swallow input ; }
protect access log element get xparamet element ( pattern token token ) throw ioexcept { ( token . ha sub token ( ) ) { log . error ( x param wrong format . need x ( . . . ) read doc ) ; return null ; } string token = token . get token ( ) ; ( token . ha paramet ( ) ) { log . error ( x param wrong format . need x ( . . . ) read doc ) ; return null ; } string paramet = token . get paramet ( ) ; ( paramet = = null ) { log . error ( close ) found decod ) ; return null ; } ( . equal ( token ) ) { return new servlet context element ( paramet ) ; } els ( c . equal ( token ) ) { return new cooki element ( paramet ) ; } els ( r . equal ( token ) ) { return new request attribut element ( paramet ) ; } els ( s . equal ( token ) ) { return new session attribut element ( paramet ) ; } els ( h . equal ( token ) ) { return get servlet request element ( paramet ) ; } els ( p . equal ( token ) ) { return new request paramet element ( paramet ) ; } els ( o . equal ( token ) ) { return new respons all header element ( paramet ) ; } log . error ( x param servlet request , couldn t decod valu : token ) ; return null ; }
overrid public final synchron void destroi ( ) throw lifecycl except { ( lifecycl state . destroi . equal ( state ) lifecycl state . destroi . equal ( state ) ) { ( log . debug enabl ( ) ) { except e = new lifecycl except ( ) ; log . debug ( sm . get string ( lifecycl base . alreadi destroi , string ( ) ) , e ) ; } els ( log . info enabl ( ) ) { log . info ( sm . get string ( lifecycl base . alreadi destroi , string ( ) ) ) ; } return ; } ( state . equal ( lifecycl state . stop ) state . equal ( lifecycl state . fail ) state . equal ( lifecycl state . new ) ) { invalid transit ( lifecycl . befor destroi event ) ; } set state intern ( lifecycl state . destroi , null , fals ) ; try { destroi intern ( ) ; } catch ( lifecycl except e ) { set state intern ( lifecycl state . fail , null , fals ) ; throw e ; } set state intern ( lifecycl state . destroi , null , fals ) ; }
overrid public void reset ( ) { ( commit ( ) ) throw new illeg state except ( ) ; respons . reset ( ) ; }	overrid public void reset buffer ( ) { ( commit ( ) ) throw new illeg state except ( ) ; respons . reset buffer ( ) ; }	overrid public void send error ( int sc ) throw ioexcept { ( commit ( ) ) throw new illeg state except ( ) ; respons . set app commit ( true ) ; respons . send error ( sc ) ; }	overrid public void send error ( int sc , string msg ) throw ioexcept { ( commit ( ) ) throw new illeg state except ( ) ; respons . set app commit ( true ) ; respons . send error ( sc , msg ) ; }	overrid public void send redirect ( string locat ) throw ioexcept { ( commit ( ) ) throw new illeg state except ( ) ; respons . set app commit ( true ) ; respons . send redirect ( locat ) ; }	overrid public void set buffer size ( int size ) { ( commit ( ) ) throw new illeg state except ( ) ; respons . set buffer size ( size ) ; }

public determin compil necessari check time stamp jsp page correspond . class . java file . page ha depend , check also extend depend , so . thi method can overridden subclass compil . param check class true , check against . class file , fals , check against . java file . boolean out date ( boolean check class ) { ( jsw = null ( ctxt . get option ( ) . get modif test interv ( ) 0 ) ) { ( jsw . get last modif test ( ) ( ctxt . get option ( ) . get modif test interv ( ) 1000 ) system . current time milli ( ) ) { return fals ; } jsw . set last modif test ( system . current time milli ( ) ) ; } long jsp real last modifi = ctxt . get last modifi ( ctxt . get jsp file ( ) ) ; ( jsp real last modifi . long valu ( ) 0 ) { someth went wrong assum modif return true ; } long target last modifi = 0 ; file target file ; ( check class ) { target file = new file ( ctxt . get class file name ( ) ) ; } els { target file = new file ( ctxt . get servlet java file name ( ) ) ; } ( target file . exist ( ) ) { return true ; } target last modifi = target file . last modifi ( ) ; ( check class jsw = null ) { jsw . set servlet class last modifi time ( target last modifi ) ; } ( target last modifi = jsp real last modifi . long valu ( ) ) { ( log . debug enabl ( ) ) { log . debug ( compil : outdat : target file target last modifi ) ; } return true ; } direct ) have been chang . ( jsw = = null ) { return fals ; } map string , long depend = jsw . get depend ( ) ; ( depend = = null ) { return fals ; } iter entri string , long >> = depend . entri set ( ) . iter ( ) ; while ( . ha next ( ) ) { entri string , long includ = . next ( ) ; try { url includ url = ctxt . get resourc ( includ . get kei ( ) ) ; ( includ url = = null ) { return true ; } urlconnect iuc = includ url . open connect ( ) ; long includ last modifi = 0 ; ( iuc instanceof jar urlconnect ) { includ last modifi = ( ( jar urlconnect ) iuc ) . get jar entri ( ) . get time ( ) ; } els { includ last modifi = iuc . get last modifi ( ) ; } iuc . get input stream ( ) . close ( ) ; ( includ last modifi = includ . get valu ( ) . long valu ( ) ) { return true ; } } catch ( except e ) { ( log . debug enabl ( ) ) log . debug ( problem access resourc . treat outdat . , e ) ; return true ; } } return fals ; }
public boolean contain ( t kei ) { return cach . contain kei ( kei ) ; }	void add ( t kei ) { cach . put ( kei , null ) ; }
p add set rule instanc defin thi rule set specifi code digest code instanc , associ them our namespac uri ( ani ) . thi method should onli call digest instanc . p param digest digest instanc which new rule instanc should ad . overrid public void add rule instanc ( digest digest ) { digest . add rule ( full prefix , new set public id rule ( set public id ) ) ; digest . add rule ( full prefix , new ignor annot rule ( ) ) ; digest . add rule ( full prefix , new version rule ( ) ) ; ( fragment ) { web fragment . xml digest . add call method ( full prefix name , set name , 0 ) ; digest . add rule ( full prefix absolut order , new absolut order rule ( ) ) ; digest . add call method ( full prefix order after name , add after order , 0 ) ; digest . add call method ( full prefix order after other , add after order other ) ; digest . add call method ( full prefix order befor name , add befor order , 0 ) ; digest . add call method ( full prefix order befor other , add befor order other ) ; } els { web . xml digest . add rule ( full prefix order , new rel order rule ( ) ) ; digest . add call method ( full prefix absolut order name , add absolut order , 0 ) ; digest . add call method ( full prefix absolut order name other , add absolut order other ) ; } digest . add call method ( full prefix context param , add context param , 2 ) ; digest . add call param ( full prefix context param param name , 0 ) ; digest . add call param ( full prefix context param param valu , 1 ) ; digest . add call method ( full prefix displai name , set displai name , 0 ) ; digest . add rule ( full prefix distribut , new set distribut rule ( ) ) ; configur name rule ( digest ) ; digest . add object creat ( full prefix error page , org . apach . catalina . deploi . error page ) ; digest . add set next ( full prefix error page , add error page , org . apach . catalina . deploi . error page ) ; digest . add call method ( full prefix error page error code , set error code , 0 ) ; digest . add call method ( full prefix error page except type , set except type , 0 ) ; digest . add call method ( full prefix error page locat , set locat , 0 ) ; digest . add object creat ( full prefix filter , org . apach . catalina . deploi . filter def ) ; digest . add set next ( full prefix filter , add filter , org . apach . catalina . deploi . filter def ) ; digest . add call method ( full prefix filter descript , set descript , 0 ) ; digest . add call method ( full prefix filter displai name , set displai name , 0 ) ; digest . add call method ( full prefix filter filter class , set filter class , 0 ) ; digest . add call method ( full prefix filter filter name , set filter name , 0 ) ; digest . add call method ( full prefix filter icon larg icon , set larg icon , 0 ) ; digest . add call method ( full prefix filter icon small icon , set small icon , 0 ) ; digest . add call method ( full prefix filter async support , set async support , 0 ) ; digest . add call method ( full prefix filter init param , add init paramet , 2 ) ; digest . add call param ( full prefix filter init param param name , 0 ) ; digest . add call param ( full prefix filter init param param valu , 1 ) ; digest . add object creat ( full prefix filter map , org . apach . catalina . deploi . filter map ) ; digest . add set next ( full prefix filter map , add filter map , org . apach . catalina . deploi . filter map ) ; digest . add call method ( full prefix filter map filter name , set filter name , 0 ) ; digest . add call method ( full prefix filter map servlet name , add servlet name , 0 ) ; digest . add call method ( full prefix filter map url pattern , add urlpattern , 0 ) ; digest . add call method ( full prefix filter map dispatch , set dispatch , 0 ) ; digest . add call method ( full prefix listen listen class , add listen , 0 ) ; digest . add rule ( full prefix jsp config , jsp config ) ; digest . add object creat ( full prefix jsp config jsp properti group , org . apach . catalina . deploi . jsp properti group ) ; digest . add set next ( full prefix jsp config jsp properti group , add jsp properti group , org . apach . catalina . deploi . jsp properti group ) ; digest . add call method ( full prefix jsp config jsp properti group defer syntax allow liter , set defer syntax , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group el ignor , set el ignor , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group includ coda , add includ coda , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group includ prelud , add includ prelud , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group xml , set xml , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group page encod , set page encod , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group script invalid , set script invalid , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group trim direct whitespac , set trim whitespac , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group url pattern , set url pattern , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group default content type , set default content type , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group buffer , set buffer , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group error undeclar namespac , set error undeclar namespac , 0 ) ; digest . add rule ( full prefix login config , login config ) ; digest . add object creat ( full prefix login config , org . apach . catalina . deploi . login config ) ; digest . add set next ( full prefix login config , set login config , org . apach . catalina . deploi . login config ) ; digest . add call method ( full prefix login config auth method , set auth method , 0 ) ; digest . add call method ( full prefix login config realm name , set realm name , 0 ) ; digest . add call method ( full prefix login config form login config form error page , set error page , 0 ) ; digest . add call method ( full prefix login config form login config form login page , set login page , 0 ) ; digest . add call method ( full prefix mime map , add mime map , 2 ) ; digest . add call param ( full prefix mime map extens , 0 ) ; digest . add call param ( full prefix mime map mime type , 1 ) ; digest . add object creat ( full prefix secur constraint , org . apach . catalina . deploi . secur constraint ) ; digest . add set next ( full prefix secur constraint , add secur constraint , org . apach . catalina . deploi . secur constraint ) ; digest . add rule ( full prefix secur constraint auth constraint , new set auth constraint rule ( ) ) ; digest . add call method ( full prefix secur constraint auth constraint role name , add auth role , 0 ) ; digest . add call method ( full prefix secur constraint displai name , set displai name , 0 ) ; digest . add call method ( full prefix secur constraint user data constraint transport guarante , set user constraint , 0 ) ; digest . add object creat ( full prefix secur constraint web resourc collect , org . apach . catalina . deploi . secur collect ) ; digest . add set next ( full prefix secur constraint web resourc collect , add collect , org . apach . catalina . deploi . secur collect ) ; digest . add call method ( full prefix secur constraint web resourc collect http method , add method , 0 ) ; digest . add call method ( full prefix secur constraint web resourc collect http method omiss , add omit method , 0 ) ; digest . add call method ( full prefix secur constraint web resourc collect url pattern , add pattern , 0 ) ; digest . add call method ( full prefix secur constraint web resourc collect web resourc name , set name , 0 ) ; digest . add call method ( full prefix secur role role name , add secur role , 0 ) ; digest . add rule ( full prefix servlet , new servlet def creat rule ( ) ) ; digest . add set next ( full prefix servlet , add servlet , org . apach . catalina . deploi . servlet def ) ; digest . add call method ( full prefix servlet init param , add init paramet , 2 ) ; digest . add call param ( full prefix servlet init param param name , 0 ) ; digest . add call param ( full prefix servlet init param param valu , 1 ) ; digest . add call method ( full prefix servlet jsp file , set jsp file , 0 ) ; digest . add call method ( full prefix servlet load startup , set load startup , 0 ) ; digest . add call method ( full prefix servlet run role name , set run , 0 ) ; digest . add call method ( full prefix servlet secur role ref , add secur role ref , 2 ) ; digest . add call param ( full prefix servlet secur role ref role link , 1 ) ; digest . add call param ( full prefix servlet secur role ref role name , 0 ) ; digest . add call method ( full prefix servlet servlet class , set servlet class , 0 ) ; digest . add call method ( full prefix servlet servlet name , set servlet name , 0 ) ; digest . add object creat ( full prefix servlet multipart config , org . apach . catalina . deploi . multipart def ) ; digest . add set next ( full prefix servlet multipart config , set multipart def , org . apach . catalina . deploi . multipart def ) ; digest . add call method ( full prefix servlet multipart config locat , set locat , 0 ) ; digest . add call method ( full prefix servlet multipart config max file size , set max file size , 0 ) ; digest . add call method ( full prefix servlet multipart config max request size , set max request size , 0 ) ; digest . add call method ( full prefix servlet multipart config file size threshold , set file size threshold , 0 ) ; digest . add call method ( full prefix servlet async support , set async support , 0 ) ; digest . add call method ( full prefix servlet enabl , set enabl , 0 ) ; digest . add rule ( full prefix servlet map , new call method multi rule ( add servlet map , 2 , 0 ) ) ; digest . add call param ( full prefix servlet map servlet name , 1 ) ; digest . add rule ( full prefix servlet map url pattern , new call param multi rule ( 0 ) ) ; digest . add rule ( full prefix session config , session config ) ; digest . add object creat ( full prefix session config , org . apach . catalina . deploi . session config ) ; digest . add set next ( full prefix session config , set session config , org . apach . catalina . deploi . session config ) ; digest . add call method ( full prefix session config session timeout , set session timeout , 0 ) ; digest . add call method ( full prefix session config cooki config name , set cooki name , 0 ) ; digest . add call method ( full prefix session config cooki config domain , set cooki domain , 0 ) ; digest . add call method ( full prefix session config cooki config path , set cooki path , 0 ) ; digest . add call method ( full prefix session config cooki config comment , set cooki comment , 0 ) ; digest . add call method ( full prefix session config cooki config http onli , set cooki http onli , 0 ) ; digest . add call method ( full prefix session config cooki config secur , set cooki secur , 0 ) ; digest . add call method ( full prefix session config cooki config max ag , set cooki max ag , 0 ) ; digest . add call method ( full prefix session config track mode , add session track mode , 0 ) ; taglib pre servlet 2 . 4 digest . add rule ( full prefix taglib , new taglib locat rule ( fals ) ) ; digest . add call method ( full prefix taglib , add taglib , 2 ) ; digest . add call param ( full prefix taglib taglib locat , 1 ) ; digest . add call param ( full prefix taglib taglib uri , 0 ) ; taglib servlet 2 . 4 onward digest . add rule ( full prefix jsp config taglib , new taglib locat rule ( true ) ) ; digest . add call method ( full prefix jsp config taglib , add taglib , 2 ) ; digest . add call param ( full prefix jsp config taglib taglib locat , 1 ) ; digest . add call param ( full prefix jsp config taglib taglib uri , 0 ) ; digest . add call method ( full prefix welcom file list welcom file , add welcom file , 0 ) ; digest . add call method ( full prefix local encod map list local encod map , add local encod map , 2 ) ; digest . add call param ( full prefix local encod map list local encod map local , 0 ) ; digest . add call param ( full prefix local encod map list local encod map encod , 1 ) ; }
callback write data from buffer . overrid protect void flush ( boolean explicit ) throw ioexcept { long socket ref = socket . get socket ( ) . long valu ( ) ; ( output buffer . posit ( ) 0 ) { ( socket . sendbb ( socket ref , 0 , output buffer . posit ( ) ) 0 ) { throw new ioexcept ( sm . get string ( ajpprocessor . failedsend ) ) ; } output buffer . clear ( ) ; } send explicit flush messag ( explicit finish ) { ( socket . send ( socket ref , flush messag arrai , 0 , flush messag arrai . length ) 0 ) { throw new ioexcept ( sm . get string ( ajpprocessor . failedflush ) ) ; } } }
begin process request via thi connector . except lifecycl except fatal startup error occur overrid protect void start intern ( ) throw lifecycl except { set state ( lifecycl state . start ) ; try { protocol handler . start ( ) ; } catch ( except e ) { string err prefix = ; ( thi . servic = null ) { err prefix = servic . get name ( ) : thi . servic . get name ( ) ; ; } throw new lifecycl except ( err prefix sm . get string ( coyot connector . protocol handler start fail ) , e ) ; } mapper listen . start ( ) ; }
public static setup ani apr intern data structur . thi must first function call ani apr librari . param librari name name librari load boolean initi ( string librari name ) throw except { ( instanc = = null ) { ( librari name = = null ) instanc = new librari ( ) ; els instanc = new librari ( librari name ) ; tcn major version = version ( 0x01 ) ; tcn minor version = version ( 0x02 ) ; tcn patch version = version ( 0x03 ) ; tcn dev version = version ( 0x04 ) ; apr major version = version ( 0x11 ) ; apr minor version = version ( 0x12 ) ; apr patch version = version ( 0x13 ) ; apr dev version = version ( 0x14 ) ; apr sizeof voidp = size ( 1 ) ; apr path max = size ( 2 ) ; aprmaxhostlen = size ( 3 ) ; apr max iovec size = size ( 4 ) ; apr max sec linger = size ( 5 ) ; apr mmap threshold = size ( 6 ) ; apr mmap limit = size ( 7 ) ; apr have ipv6 = ha ( 0 ) ; apr ha share memori = ha ( 1 ) ; apr ha thread = ha ( 2 ) ; apr ha sendfil = ha ( 3 ) ; apr ha mmap = ha ( 4 ) ; apr ha fork = ha ( 5 ) ; apr ha random = ha ( 6 ) ; apr ha other child = ha ( 7 ) ; apr ha dso = ha ( 8 ) ; apr ha so acceptfilt = ha ( 9 ) ; apr ha unicod fs = ha ( 10 ) ; apr ha proc invok = ha ( 11 ) ; apr ha user = ha ( 12 ) ; apr ha larg file = ha ( 13 ) ; apr ha xthread file = ha ( 14 ) ; apr ha os uuid = ha ( 15 ) ; apr bigendian = ha ( 16 ) ; apr file socket = ha ( 17 ) ; apr charset ebcdic = ha ( 18 ) ; apr tcp nodelai inherit = ha ( 19 ) ; apr o nonblock inherit = ha ( 20 ) ; ( apr major version 1 ) { throw new unsatisfi link error ( unsupport apr version ( apr version string ( ) ) ) ; } ( apr ha thread ) { throw new unsatisfi link error ( miss apr ha thread ) ; } } return initi ( ) ; }	initi endpoint . overrid public void bind ( ) throw except { creat root apr memori pool try { root pool = pool . creat ( 0 ) ; } catch ( unsatisfi link error e ) { throw new except ( sm . get string ( endpoint . init . notavail ) ) ; } creat pool server socket server sock pool = pool . creat ( root pool ) ; creat apr address bound string address str = null ; ( get address ( ) = null ) { address str = get address ( ) . get host address ( ) ; } int famili = socket . apr inet ; ( librari . apr have ipv6 ) { ( address str = = null ) { ( os . bsd os . win32 os . win64 ) famili = socket . apr unspec ; } els ( address str . index ( : ) = 0 ) { famili = socket . apr unspec ; } } long inet address = address . info ( address str , famili , get port ( ) , 0 , root pool ) ; creat apr server socket server sock = socket . creat ( address . get info ( inet address ) . famili , socket . sock stream , socket . apr proto tcp , root pool ) ; ( os . unix ) { socket . opt set ( server sock , socket . apr so reuseaddr , 1 ) ; } deal firewal tend drop inact socket socket . opt set ( server sock , socket . apr so keepal , 1 ) ; bind server socket int ret = socket . bind ( server sock , inet address ) ; ( ret = 0 ) { throw new except ( sm . get string ( endpoint . init . bind , ret , error . strerror ( ret ) ) ) ; } start listen server socket ret = socket . listen ( server sock , get backlog ( ) ) ; ( ret = 0 ) { throw new except ( sm . get string ( endpoint . init . listen , ret , error . strerror ( ret ) ) ) ; } ( os . win32 os . win64 ) { window set reuseaddr flag after bind listen socket . opt set ( server sock , socket . apr so reuseaddr , 1 ) ; } sendfil usag system which don t support caus major problem ( us sendfil librari . apr ha sendfil ) { us sendfil = fals ; } initi thread count default acceptor , poller sendfil ( acceptor thread count = = 0 ) { fixm : doesn t seem work well multipl accept thread acceptor thread count = 1 ; } ( poller thread count = = 0 ) { ( ( os . win32 os . win64 ) ( get max connect ( ) 1024 ) ) { maximum per poller get reason perform 1024 poller thread count = get max connect ( ) 1024 ; adjust poller size so won t reach limit set max connect ( get max connect ( ) ( get max connect ( ) 1024 ) ) ; } els { explicit poller size limit poller thread count = 1 ; } } ( sendfil thread count = = 0 ) { ( ( os . win32 os . win64 ) ( sendfil size 1024 ) ) { maximum per poller get reason perform 1024 sendfil thread count = sendfil size 1024 ; adjust poller size so won t reach limit sendfil size = sendfil size ( sendfil size 1024 ) ; } els { explicit poller size limit fixm : default per cpu sendfil thread count = 1 ; } } other platform thi call noop return apr enotimpl . ( defer accept ) { ( socket . opt set ( server sock , socket . apr tcp defer accept , 1 ) = = statu . apr enotimpl ) { defer accept = fals ; } } initi ssl need ( sslenabl ( ) ) { ( sslcertif file = = null ) { thi requir throw new except ( sm . get string ( endpoint . apr . ssl cert file ) ) ; } ssl protocol int valu = ssl . ssl protocol all ; ( sslv2 . equal ignor case ( sslprotocol ) ) { valu = ssl . ssl protocol sslv2 ; } els ( sslv3 . equal ignor case ( sslprotocol ) ) { valu = ssl . ssl protocol sslv3 ; } els ( tlsv1 . equal ignor case ( sslprotocol ) ) { valu = ssl . ssl protocol tlsv1 ; } els ( sslv2 sslv3 . equal ignor case ( sslprotocol ) ) { valu = ssl . ssl protocol sslv2 ssl . ssl protocol sslv3 ; } els ( all . equal ignor case ( sslprotocol ) sslprotocol = = null sslprotocol . length ( ) = = 0 ) { noop , us default defin abov } els { requir throw new except ( sm . get string ( endpoint . apr . invalid ssl protocol , sslprotocol ) ) ; } creat ssl context ssl context = sslcontext . make ( root pool , valu , ssl . ssl mode server ) ; ( sslinsecur renegoti ) { boolean legaci reneg support = fals ; try { legaci reneg support = ssl . ha op ( ssl . ssl op allow unsaf legaci renegoti ) ; ( legaci reneg support ) sslcontext . set option ( ssl context , ssl . ssl op allow unsaf legaci renegoti ) ; } catch ( unsatisfi link error e ) { ignor } ( legaci reneg support ) { open ssl doe support unsaf legaci renegoti . log . warn ( sm . get string ( endpoint . warn . insecur reneg , ssl . version string ( ) ) ) ; } } list cipher client permit negoti sslcontext . set cipher suit ( ssl context , sslcipher suit ) ; load server kei certif sslcontext . set certif ( ssl context , sslcertif file , sslcertif kei file , sslpassword , ssl . ssl aidx rsa ) ; set certif chain file sslcontext . set certif chain file ( ssl context , sslcertif chain file , fals ) ; support client certif sslcontext . set cacertif ( ssl context , sslcacertif file , sslcacertif path ) ; set revoc sslcontext . set carevoc ( ssl context , sslcarevoc file , sslcarevoc path ) ; client certif verif valu = ssl . ssl cverifi none ; ( option . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi option ; } els ( requir . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi requir ; } els ( option ca . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi option ca ; } sslcontext . set verifi ( ssl context , valu , sslverifi depth ) ; now , sendfil support ssl us sendfil = fals ; } }
protect date format cach initi valu ( ) { return new date format cach ( local cach size , local . get default ( ) , global date cach ) ; }	protect synchron open new log file date specifi code date stamp code . void open ( ) { creat directori necessari file dir = new file ( directori ) ; ( dir . absolut ( ) ) dir = new file ( system . get properti ( global . catalina base prop ) , directori ) ; ( dir . exist ( ) ) { ( dir . mkdir ( ) ) { log . error ( sm . get string ( access log valv . open dir fail , dir ) ) ; } } open current log file try { string pathnam ; rotat need date stamp file name ( rotat ) { pathnam = dir . get absolut path ( ) file . separ prefix date stamp suffix ; } els { pathnam = dir . get absolut path ( ) file . separ prefix suffix ; } writer = new print writer ( new buffer writer ( new file writer ( pathnam , true ) , 128000 ) , fals ) ; current log file = new file ( pathnam ) ; } catch ( ioexcept e ) { writer = null ; current log file = null ; } }	public set local us format timestamp log entri log file name suffix . chang local onli support long access log valv ha log anyth . chang local later can lead inconsist format . param local name local us . void set local ( string local name ) { thi . local name = local name ; local = find local ( local name , local ) ; }
select appropri child wrapper process thi request , base specifi request uri . match wrapper can found , return appropri http error . param request request process param respons respons produc except ioexcept input output error occur except servlet except servlet error occur overrid public final void invok ( request request , respons respons ) throw ioexcept , servlet except { disallow ani direct access resourc under web inf meta inf messag byte request path mb = request . get request path mb ( ) ; ( ( request path mb . start ignor case ( meta inf , 0 ) ) ( request path mb . equal ignor case ( meta inf ) ) ( request path mb . start ignor case ( web inf , 0 ) ) ( request path mb . equal ignor case ( web inf ) ) ) { error ( respons , http servlet respons . sc found ) ; return ; } wait we ar reload boolean reload = fals ; while ( context . get paus ( ) ) { reload = true ; try { thread . sleep ( 1000 ) ; } catch ( interrupt except e ) { ignor } } creat new ( reload context . get loader ( ) = null context . get loader ( ) . get class loader ( ) = null ) { thread . current thread ( ) . set context class loader ( context . get loader ( ) . get class loader ( ) ) ; } select wrapper us thi request wrapper wrapper = request . get wrapper ( ) ; ( wrapper = = null ) { error ( respons , http servlet respons . sc found ) ; return ; } els ( wrapper . unavail ( ) ) { mai result reload , try find new wrapper wrapper = ( wrapper ) contain . find child ( wrapper . get name ( ) ) ; ( wrapper = = null ) { error ( respons , http servlet respons . sc found ) ; return ; } } acknowledg request try { respons . send acknowledg ( ) ; } catch ( ioexcept ioe ) { contain . get logger ( ) . error ( sm . get string ( standard context valv . acknowledg except ) , ioe ) ; request . set attribut ( request dispatch . error except , ioe ) ; error ( respons , http servlet respons . sc intern server error ) ; return ; } don t fire listen dure async process request init listen throw except , request abort boolean async start = request . async ( ) ; ( async start context . fire request init event ( request ) ) { ( request . async support ( ) ) { request . set async support ( wrapper . get pipelin ( ) . async support ( ) ) ; } wrapper . get pipelin ( ) . get first ( ) . invok ( request , respons ) ; place ( ( request . async ( ) ( async start request . get attribut ( request dispatch . error except ) = null ) ) ) { context . fire request destroi event ( request ) ; } } }
public static byte decompress ( byte data ) throw ioexcept { byte arrai input stream bin = new byte arrai input stream ( data ) ; gzipinput stream gin = new gzipinput stream ( bin ) ; byte tmp = new byte default buffer size ; int length = gin . read ( tmp ) ; byte result = new byte length ; system . arraycopi ( tmp , 0 , result , 0 , length ) ; return result ; }
privat final set proper secur properti param properti packag . properti . void set secur properti ( string properti , string packag list ) { ( system . get secur manag ( ) = null ) { string definit = secur . get properti ( properti ) ; ( definit = null definit . length ( ) 0 ) { definit = , ; } secur . set properti ( properti , fatal intern error definit packag list ) ; } }
protect synchron void stop intern ( ) throw lifecycl except { send j2ee . state . stop notif ( thi . get object name ( ) = null ) { notif notif = new notif ( j2ee . state . stop , thi . get object name ( ) , sequenc number . get increment ( ) ) ; broadcast . send notif ( notif ) ; } set state ( lifecycl state . stop ) ; bind thread class loader old ccl = bind thread ( ) ; try { stop our child contain , ani final contain children = find children ( ) ; we do dedic thread memori leak protect , case some webapp code regist some thread local thei forget cleanup todo figur out why dedic thread executor hang randomli unit test us here runnabl lifecycl except stop = new runnabl lifecycl except ( ) { overrid public void run ( ) { class loader old = bind thread ( ) ; try { ( int i = 0 ; i children . length ; i ) { try { children i . stop ( ) ; } catch ( lifecycl except e ) { le = e ; return ; } } stop our filter filter stop ( ) ; stop contain background processor thread thread stop ( ) ; ( manag = null manag instanceof lifecycl ) { try { ( ( lifecycl ) manag ) . stop ( ) ; } catch ( lifecycl except e ) { le = e ; return ; } } stop our applic listen listen stop ( ) ; } final { unbind thread ( old ) ; } } } ; thread t = new thread ( stop ) ; t . set name ( stop children get object name ( ) . string ( ) ) ; t . run ( ) ; try { t . join ( ) ; } catch ( interrupt except e ) { shouldn t happen throw new lifecycl except ( e ) ; } ( stop . get lifecycl except ( ) = null ) { throw stop . get lifecycl except ( ) ; } final our charact set mapper set charset mapper ( null ) ; normal contain shutdown process ( log . debug enabl ( ) ) log . debug ( process standard contain shutdown ) ; after applic ha finish resourc ( name resourc = null ) { name resourc . stop ( ) ; } fire lifecycl event ( lifecycl . configur stop event , null ) ; stop valv our pipelin ( includ basic ) , ani ( pipelin instanceof lifecycl ) { ( ( lifecycl ) pipelin ) . stop ( ) ; } clear all applic origin servlet context attribut ( context = null ) context . clear attribut ( ) ; stop resourc resourc stop ( ) ; ( ( realm = null ) ( realm instanceof lifecycl ) ) { ( ( lifecycl ) realm ) . stop ( ) ; } ( ( cluster = null ) ( cluster instanceof lifecycl ) ) { ( ( lifecycl ) cluster ) . stop ( ) ; } ( ( logger = null ) ( logger instanceof lifecycl ) ) { ( ( lifecycl ) logger ) . stop ( ) ; } ( ( loader = null ) ( loader instanceof lifecycl ) ) { ( ( lifecycl ) loader ) . stop ( ) ; } } final { unbind thread unbind thread ( old ccl ) ; } send j2ee . state . stop notif ( thi . get object name ( ) = null ) { notif notif = new notif ( j2ee . state . stop , thi . get object name ( ) , sequenc number . get increment ( ) ) ; broadcast . send notif ( notif ) ; } reset applic context context = null ; thi object longer visibl us . try { reset context ( ) ; } catch ( except ex ) { log . error ( error reset context thi ex , ex ) ; } reset instanc manag instanc manag = null ; ( log . debug enabl ( ) ) log . debug ( stop complet ) ; }
protect start host specifi name . param writer writer render param name host name void start ( print writer writer , string name , string manag sm client ) { ( debug = 1 ) { log ( sm . get string ( host manag servlet . start , name ) ) ; } valid request host name ( ( name = = null ) name . length ( ) = = 0 ) { writer . println ( sm client . get string ( host manag servlet . invalid host name , name ) ) ; return ; } contain host = engin . find child ( name ) ; check host exist ( host = = null ) { writer . println ( sm client . get string ( host manag servlet . host , name ) ) ; return ; } prevent start our own host ( host = = instal host ) { writer . println ( sm client . get string ( host manag servlet . cannot start own host , name ) ) ; return ; } don t start host alreadi start ( host . get state ( ) . avail ( ) ) { writer . println ( sm client . get string ( host manag servlet . alreadi start , name ) ) ; return ; } start host try { host . start ( ) ; writer . println ( sm client . get string ( host manag servlet . start , name ) ) ; } catch ( except e ) { get servlet context ( ) . log ( sm . get string ( host manag servlet . start fail , name ) , e ) ; writer . println ( sm client . get string ( host manag servlet . start fail , name ) ) ; writer . println ( sm client . get string ( host manag servlet . except , e . string ( ) ) ) ; return ; } }	protect start host specifi name . param writer writer render param name host name void stop ( print writer writer , string name , string manag sm client ) { ( debug = 1 ) { log ( sm . get string ( host manag servlet . stop , name ) ) ; } valid request host name ( ( name = = null ) name . length ( ) = = 0 ) { writer . println ( sm client . get string ( host manag servlet . invalid host name , name ) ) ; return ; } contain host = engin . find child ( name ) ; check host exist ( host = = null ) { writer . println ( sm client . get string ( host manag servlet . host , name ) ) ; return ; } prevent start our own host ( host = = instal host ) { writer . println ( sm client . get string ( host manag servlet . cannot stop own host , name ) ) ; return ; } don t stop host alreadi stop ( host . get state ( ) . avail ( ) ) { writer . println ( sm client . get string ( host manag servlet . alreadi stop , name ) ) ; return ; } stop host try { host . stop ( ) ; writer . println ( sm client . get string ( host manag servlet . stop , name ) ) ; } catch ( except e ) { get servlet context ( ) . log ( sm . get string ( host manag servlet . stop fail , name ) , e ) ; writer . println ( sm client . get string ( host manag servlet . stop fail , name ) ) ; writer . println ( sm client . get string ( host manag servlet . except , e . string ( ) ) ) ; return ; } }
enforc secur restrict web applic deploy descriptor our associ context . param request request process param respons respons process except ioexcept input output error occur except servlet except thrown process element overrid public void invok ( request request , respons respons ) throw ioexcept , servlet except { ( log . debug enabl ( ) ) log . debug ( secur check request request . get method ( ) request . get request uri ( ) ) ; login config config = thi . context . get login config ( ) ; have we got cach authent princip record ( cach ) { princip princip = request . get user princip ( ) ; ( princip = = null ) { session session = request . get session intern ( fals ) ; ( session = null ) { princip = session . get princip ( ) ; ( princip = null ) { ( log . debug enabl ( ) ) log . debug ( we have cach auth type session . get auth type ( ) princip session . get princip ( ) ) ; request . set auth type ( session . get auth type ( ) ) ; request . set user princip ( princip ) ; } } } } special handl form base login deal case where login form ( therefor j secur check uri which submit ) might outsid secur area string context path = thi . context . get path ( ) ; string request uri = request . get decod request uri ( ) ; ( request uri . start ( context path ) request uri . end ( constant . form action ) ) { ( authent ( request , respons , config ) ) { ( log . debug enabl ( ) ) log . debug ( fail authent ( ) test request uri ) ; return ; } } servlet mai specifi secur constraint through annot . ensur thei have been process befor constraint ar check wrapper wrapper = ( wrapper ) request . get map data ( ) . wrapper ; ( wrapper = null ) { wrapper . servlet secur annot scan ( ) ; } realm realm = thi . context . get realm ( ) ; thi request uri subject secur constraint secur constraint constraint = realm . find secur constraint ( request , thi . context ) ; ( constraint = = null context . get preemptiv authent ( ) ) { ( log . debug enabl ( ) ) log . debug ( subject ani constraint ) ; get next ( ) . invok ( request , respons ) ; return ; } browser cach can provid secur hole ( constraint = null disabl proxi cach request . secur ( ) post . equal ignor case ( request . get method ( ) ) ) { ( secur page pragma ) { note : can caus problem download file ie respons . set header ( pragma , cach ) ; respons . set header ( cach control , cach ) ; } els { respons . set header ( cach control , privat ) ; } respons . set header ( expir , date ) ; } int i ; ( constraint = null ) { enforc ani user data constraint thi secur constraint ( log . debug enabl ( ) ) { log . debug ( call ha user data permiss ( ) ) ; } ( realm . ha user data permiss ( request , respons , constraint ) ) { ( log . debug enabl ( ) ) { log . debug ( fail ha user data permiss ( ) test ) ; } assert : authent alreadi set appropri http statu code , so we do have do anyth special return ; } } sinc authent modifi respons failur , we have check allow from all first . boolean auth requir ; ( constraint = = null ) { auth requir = fals ; } els { auth requir = true ; ( i = 0 ; i constraint . length auth requir ; i ) { ( constraint i . get auth constraint ( ) ) { auth requir = fals ; } els ( constraint i . get all role ( ) ) { string role = constraint i . find auth role ( ) ; ( role = = null role . length = = 0 ) { auth requir = fals ; } } } } ( auth requir ) { auth requir = request . get coyot request ( ) . get mime header ( ) . get valu ( author ) = null ; } ( auth requir ) { x509certif cert = ( x509certif ) request . get attribut ( global . certif attr ) ; auth requir = cert = null cert . length 0 ; } ( auth requir ) { ( log . debug enabl ( ) ) { log . debug ( call authent ( ) ) ; } ( authent ( request , respons , config ) ) { ( log . debug enabl ( ) ) { log . debug ( fail authent ( ) test ) ; } assert : authent alreadi set appropri http statu code , so we do have do anyth special return ; } } ( constraint = null ) { ( log . debug enabl ( ) ) { log . debug ( call access control ( ) ) ; } ( realm . ha resourc permiss ( request , respons , constraint , thi . context ) ) { ( log . debug enabl ( ) ) { log . debug ( fail access control ( ) test ) ; } assert : access control method ha alreadi set appropri http statu code , so we do have do anyth special return ; } } ani all specifi constraint have been satisfi ( log . debug enabl ( ) ) { log . debug ( successfulli pass all secur constraint ) ; } get next ( ) . invok ( request , respons ) ; }
privat static final node creat node intern ( string expr ) throw elexcept { ( expr = = null ) { throw new elexcept ( messag factori . get ( error . null ) ) ; } node n = cach . get ( expr ) ; ( n = = null ) { try { n = ( new elpars ( new string reader ( expr ) ) ) . composit express ( ) ; valid composit express int num children = n . jjt get num children ( ) ; ( num children = = 1 ) { n = n . jjt get child ( 0 ) ; } els { class type = null ; node child = null ; ( int i = 0 ; i num children ; i ) { child = n . jjt get child ( i ) ; ( child instanceof ast liter express ) continu ; ( type = = null ) type = child . get class ( ) ; els { ( type . equal ( child . get class ( ) ) ) { throw new elexcept ( messag factori . get ( error . mix , expr ) ) ; } } } } ( n instanceof ast defer express n instanceof ast dynam express ) { n = n . jjt get child ( 0 ) ; } cach . put ( expr , n ) ; } catch ( pars except pe ) { throw new elexcept ( error pars : expr , pe ) ; } } return n ; }
privat report found error specifi resourc . fixm : we should realli us error report set thi web applic , current code run wrapper level rather than context level . param respons respons we ar creat void found ( http servlet respons respons ) { try { respons . send error ( http servlet respons . sc found ) ; } catch ( illeg state except e ) { ignor } catch ( ioexcept e ) { ignor } }	select appropri child wrapper process thi request , base specifi request uri . match wrapper can found , return appropri http error . param request request process param respons respons produc param event except ioexcept input output error occur except servlet except servlet error occur overrid public final void event ( request request , respons respons , comet event event ) throw ioexcept , servlet except { select wrapper us thi request wrapper wrapper = request . get wrapper ( ) ; normal request process fixm : fire request listen could addit core comet api ( context . fire request init event ( request ) ) { wrapper . get pipelin ( ) . get first ( ) . event ( request , respons , event ) ; context . fire request destroi event ( request ) ; } }	select appropri child wrapper process thi request , base specifi request uri . match wrapper can found , return appropri http error . param request request process param respons respons produc except ioexcept input output error occur except servlet except servlet error occur overrid public final void invok ( request request , respons respons ) throw ioexcept , servlet except { disallow ani direct access resourc under web inf meta inf messag byte request path mb = request . get request path mb ( ) ; ( ( request path mb . start ignor case ( meta inf , 0 ) ) ( request path mb . equal ignor case ( meta inf ) ) ( request path mb . start ignor case ( web inf , 0 ) ) ( request path mb . equal ignor case ( web inf ) ) ) { found ( respons ) ; return ; } wait we ar reload boolean reload = fals ; while ( context . get paus ( ) ) { reload = true ; try { thread . sleep ( 1000 ) ; } catch ( interrupt except e ) { ignor } } creat new ( reload context . get loader ( ) = null context . get loader ( ) . get class loader ( ) = null ) { thread . current thread ( ) . set context class loader ( context . get loader ( ) . get class loader ( ) ) ; } select wrapper us thi request wrapper wrapper = request . get wrapper ( ) ; ( wrapper = = null ) { found ( respons ) ; return ; } els ( wrapper . unavail ( ) ) { mai result reload , try find new wrapper wrapper = ( wrapper ) contain . find child ( wrapper . get name ( ) ) ; ( wrapper = = null ) { found ( respons ) ; return ; } } don t fire listen dure async process request init listen throw except , request abort boolean async start = request . async ( ) ; ( async start context . fire request init event ( request ) ) { ( request . async support ( ) ) { request . set async support ( wrapper . get pipelin ( ) . async support ( ) ) ; } wrapper . get pipelin ( ) . get first ( ) . invok ( request , respons ) ; place ( ( request . async ( ) ( async start request . get attribut ( request dispatch . error except ) = null ) ) ) { context . fire request destroi event ( request ) ; } } }	invok servlet we ar manag , respect rule regard servlet lifecycl singl thread model support . param request request process param respons respons produc except ioexcept input output error occur except servlet except servlet error occur overrid public final void invok ( request request , respons respons ) throw ioexcept , servlet except { initi local variabl we mai need boolean unavail = fals ; throwabl throwabl = null ; thi should request attribut . . . long t1 = system . current time milli ( ) ; request count ; standard wrapper wrapper = ( standard wrapper ) get contain ( ) ; servlet servlet = null ; context context = ( context ) wrapper . get parent ( ) ; check applic mark unavail ( context . get avail ( ) ) { respons . send error ( http servlet respons . sc servic unavail , sm . get string ( standard context . unavail ) ) ; unavail = true ; } check servlet mark unavail ( unavail wrapper . unavail ( ) ) { contain . get logger ( ) . info ( sm . get string ( standard wrapper . unavail , wrapper . get name ( ) ) ) ; long avail = wrapper . get avail ( ) ; ( ( avail 0l ) ( avail long . max valu ) ) { respons . set date header ( retri after , avail ) ; respons . send error ( http servlet respons . sc servic unavail , sm . get string ( standard wrapper . unavail , wrapper . get name ( ) ) ) ; } els ( avail = = long . max valu ) { respons . send error ( http servlet respons . sc found , sm . get string ( standard wrapper . found , wrapper . get name ( ) ) ) ; } unavail = true ; } alloc servlet instanc process thi request try { ( unavail ) { servlet = wrapper . alloc ( ) ; } } catch ( unavail except e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . alloc except , wrapper . get name ( ) ) , e ) ; long avail = wrapper . get avail ( ) ; ( ( avail 0l ) ( avail long . max valu ) ) { respons . set date header ( retri after , avail ) ; respons . send error ( http servlet respons . sc servic unavail , sm . get string ( standard wrapper . unavail , wrapper . get name ( ) ) ) ; } els ( avail = = long . max valu ) { respons . send error ( http servlet respons . sc found , sm . get string ( standard wrapper . found , wrapper . get name ( ) ) ) ; } } catch ( servlet except e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . alloc except , wrapper . get name ( ) ) , standard wrapper . get root caus ( e ) ) ; throwabl = e ; except ( request , respons , e ) ; } catch ( throwabl e ) { except util . handl throwabl ( e ) ; contain . get logger ( ) . error ( sm . get string ( standard wrapper . alloc except , wrapper . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; servlet = null ; } identifi request comet relat now servlet ha been alloc boolean comet = fals ; ( servlet instanceof comet processor request . get attribut ( org . apach . tomcat . comet . support ) = = boolean . true ) { comet = true ; request . set comet ( true ) ; } acknowledg request try { respons . send acknowledg ( ) ; } catch ( ioexcept e ) { contain . get logger ( ) . warn ( sm . get string ( standard wrapper . acknowledg except , wrapper . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; } catch ( throwabl e ) { except util . handl throwabl ( e ) ; contain . get logger ( ) . error ( sm . get string ( standard wrapper . acknowledg except , wrapper . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; servlet = null ; } messag byte request path mb = request . get request path mb ( ) ; dispatch type dispatch type = dispatch type . request ; ( request . get dispatch type ( ) = = dispatch type . async ) dispatch type = dispatch type . async ; request . set attribut ( applic filter factori . dispatch type attr , dispatch type ) ; request . set attribut ( applic filter factori . dispatch request path attr , request path mb ) ; creat filter chain thi request applic filter factori factori = applic filter factori . get instanc ( ) ; applic filter chain filter chain = factori . creat filter chain ( request , wrapper , servlet ) ; reset comet flag valu after creat filter chain request . set comet ( fals ) ; note : thi also call servlet s servic ( ) method try { ( ( servlet = null ) ( filter chain = null ) ) { swallow output need ( context . get swallow output ( ) ) { try { system log handler . start captur ( ) ; ( request . async dispatch ( ) ) { todo servlet3 async ( ( async context impl ) request . get async context ( ) ) . do intern dispatch ( ) ; } els ( comet ) { filter chain . do filter event ( request . get event ( ) ) ; request . set comet ( true ) ; } els { filter chain . do filter ( request . get request ( ) , respons . get respons ( ) ) ; } } final { string log = system log handler . stop captur ( ) ; ( log = null log . length ( ) 0 ) { context . get logger ( ) . info ( log ) ; } } } els { ( request . async dispatch ( ) ) { todo servlet3 async ( ( async context impl ) request . get async context ( ) ) . do intern dispatch ( ) ; } els ( comet ) { request . set comet ( true ) ; filter chain . do filter event ( request . get event ( ) ) ; } els { filter chain . do filter ( request . get request ( ) , respons . get respons ( ) ) ; } } } } catch ( client abort except e ) { throwabl = e ; except ( request , respons , e ) ; } catch ( ioexcept e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . servic except , wrapper . get name ( ) , context . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; } catch ( unavail except e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . servic except , wrapper . get name ( ) , context . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; wrapper . unavail ( e ) ; long avail = wrapper . get avail ( ) ; ( ( avail 0l ) ( avail long . max valu ) ) { respons . set date header ( retri after , avail ) ; respons . send error ( http servlet respons . sc servic unavail , sm . get string ( standard wrapper . unavail , wrapper . get name ( ) ) ) ; } els ( avail = = long . max valu ) { respons . send error ( http servlet respons . sc found , sm . get string ( standard wrapper . found , wrapper . get name ( ) ) ) ; } do save except throwabl , becaus we do want do except ( request , respons , e ) process } catch ( servlet except e ) { throwabl root caus = standard wrapper . get root caus ( e ) ; ( ( root caus instanceof client abort except ) ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . servic except root , wrapper . get name ( ) , context . get name ( ) , e . get messag ( ) ) , root caus ) ; } throwabl = e ; except ( request , respons , e ) ; } catch ( throwabl e ) { except util . handl throwabl ( e ) ; contain . get logger ( ) . error ( sm . get string ( standard wrapper . servic except , wrapper . get name ( ) , context . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; } releas filter chain ( ani ) thi request ( filter chain = null ) { ( request . comet ( ) ) { thi comet request , same chain us process all subsequ event . filter chain . reus ( ) ; } els { filter chain . releas ( ) ; } } dealloc alloc servlet instanc try { ( servlet = null ) { wrapper . dealloc ( servlet ) ; } } catch ( throwabl e ) { except util . handl throwabl ( e ) ; contain . get logger ( ) . error ( sm . get string ( standard wrapper . dealloc except , wrapper . get name ( ) ) , e ) ; ( throwabl = = null ) { throwabl = e ; except ( request , respons , e ) ; } } unload releas thi instanc try { ( ( servlet = null ) ( wrapper . get avail ( ) = = long . max valu ) ) { wrapper . unload ( ) ; } } catch ( throwabl e ) { except util . handl throwabl ( e ) ; contain . get logger ( ) . error ( sm . get string ( standard wrapper . unload except , wrapper . get name ( ) ) , e ) ; ( throwabl = = null ) { throwabl = e ; except ( request , respons , e ) ; } } long t2 = system . current time milli ( ) ; long time = t2 t1 ; process time = time ; ( time max time ) max time = time ; ( time min time ) min time = time ; }
privat instanc manag get instanc manag ( ) { ( instanc manag = = null ) { ( context instanceof standard context ) { instanc manag = ( ( standard context ) context ) . get instanc manag ( ) ; } els { instanc manag = new default instanc manag ( null , new hash map string , map string , string >> ( ) , context , get class ( ) . get class loader ( ) ) ; } } return instanc manag ; }	overrid public servlet request get request ( ) { return servlet request ; }	overrid public servlet respons get respons ( ) { return servlet respons ; }	overrid public boolean ha origin request respons ( ) { return ha origin request respons ; }	overrid public long get timeout ( ) { return timeout ; }	overrid public void add listen ( async listen listen ) { async listen wrapper wrapper = new async listen wrapper ( ) ; wrapper . set listen ( listen ) ; listen . add ( wrapper ) ; }	suppress warn ( uncheck ) overrid public t extend async listen t creat listen ( class t clazz ) throw servlet except { t listen = null ; try { listen = ( t ) get instanc manag ( ) . new instanc ( clazz . get name ( ) , clazz . get class loader ( ) ) ; } catch ( instanti except e ) { servlet except se = new servlet except ( e ) ; throw se ; } catch ( illeg access except e ) { servlet except se = new servlet except ( e ) ; throw se ; } catch ( invoc target except e ) { servlet except se = new servlet except ( e ) ; throw se ; } catch ( name except e ) { servlet except se = new servlet except ( e ) ; throw se ; } catch ( class found except e ) { servlet except se = new servlet except ( e ) ; throw se ; } return listen ; }	overrid public void complet ( ) { ( log . debug enabl ( ) ) { log debug ( complet ) ; } request . get coyot request ( ) . action ( action code . commit , null ) ; request . get coyot request ( ) . action ( action code . async complet , null ) ; }	overrid public void dispatch ( ) { http servlet request sr = ( http servlet request ) get request ( ) ; string path = sr . get request uri ( ) ; string cpath = sr . get context path ( ) ; ( cpath . length ( ) 1 ) path = path . substr ( cpath . length ( ) ) ; dispatch ( path ) ; }	overrid public void dispatch ( servlet context context , string path ) { ( log . debug enabl ( ) ) { log debug ( dispatch ) ; } ( request . get attribut ( async request uri ) = = null ) { request . set attribut ( async request uri , request . get request uri ( ) request . get queri string ( ) ) ; request . set attribut ( async context path , request . get context path ( ) ) ; request . set attribut ( async servlet path , request . get servlet path ( ) ) ; request . set attribut ( async queri string , request . get queri string ( ) ) ; } final request dispatch request dispatch = context . get request dispatch ( path ) ; final http servlet request servlet request = ( http servlet request ) get request ( ) ; final http servlet respons servlet respons = ( http servlet respons ) get respons ( ) ; runnabl run = new runnabl ( ) { overrid } }	overrid public void dispatch ( string path ) { dispatch ( request . get servlet context ( ) , path ) ; }	public void recycl ( ) { ( log . debug enabl ( ) ) { log debug ( recycl ) ; } servlet request = null ; servlet respons = null ; ha origin request respons = true ; context = null ; timeout = 1 ; event = null ; }	overrid public void set timeout ( long timeout ) { thi . timeout = timeout ; request . get coyot request ( ) . action ( action code . async settimeout , long . valu ( timeout ) ) ; }	overrid public void start ( final runnabl run ) { ( log . debug enabl ( ) ) { log debug ( start ) ; } runnabl wrapper = new runnabl wrapper ( run , context ) ; thi . request . get coyot request ( ) . action ( action code . async run , wrapper ) ; }
protect session get session name id ( context name cn , string id , string manag sm client ) throw ioexcept { ( ( cn = = null ) ( cn . get path ( ) . start ( ) cn . get path ( ) . equal ( ) ) ) { string path = null ; ( cn = null ) { path = cn . get path ( ) ; } throw new illeg argument except ( sm client . get string ( manag servlet . invalid path , request util . filter ( path ) ) ) ; } context ctxt = ( context ) host . find child ( cn . get name ( ) ) ; ( null = = ctxt ) { throw new illeg argument except ( sm client . get string ( manag servlet . context , request util . filter ( cn . get displai name ( ) ) ) ) ; } session session = ctxt . get manag ( ) . find session ( id ) ; return session ; }	protect list session get session name ( context name cn , string manag sm client ) { ( ( cn = = null ) ( cn . get path ( ) . start ( ) cn . get path ( ) . equal ( ) ) ) { string path = null ; ( cn = null ) { path = cn . get path ( ) ; } throw new illeg argument except ( sm client . get string ( manag servlet . invalid path , request util . filter ( path ) ) ) ; } context ctxt = ( context ) host . find child ( cn . get name ( ) ) ; ( null = = ctxt ) { throw new illeg argument except ( sm client . get string ( manag servlet . context , request util . filter ( cn . get displai name ( ) ) ) ) ; } manag manag = ctxt . get manag ( ) ; list session session = new arrai list session ( ) ; session . add all ( arrai . list ( manag . find session ( ) ) ) ; ( manag instanceof distribut manag show proxi session ) { add dummi proxi session set string session id = ( ( distribut manag ) manag ) . get session id full ( ) ; remov activ ( primari backup ) session id from full list ( session session : session ) { session id . remov ( session . get id ( ) ) ; } left just proxi session add them ( string session id : session id ) { session . add ( new dummi proxi session ( session id ) ) ; } } return session ; }
public context add webapp ( host host , string url , string name , string path ) { silenc ( url ) ; context ctx = new standard context ( ) ; ctx . set name ( name ) ; ctx . set path ( url ) ; ctx . set doc base ( path ) ; ( default realm = = null ) { init simpl auth ( ) ; } ctx . set realm ( default realm ) ; ctx . add lifecycl listen ( new default web xml listen ( ) ) ; context config ctx cfg = new context config ( ) ; ctx . add lifecycl listen ( ctx cfg ) ; prevent from look ( find ll have dup error ) ctx cfg . set default web xml ( org apach catalin startup default xml ) ; ( host = = null ) { get host ( ) . add child ( ctx ) ; } els { host . add child ( ctx ) ; } return ctx ; }
privat configur from code log manag code properti . void configur ( ) { timestamp ts = new timestamp ( system . current time milli ( ) ) ; string ts string = ts . string ( ) . substr ( 0 , 19 ) ; date = ts string . substr ( 0 , 10 ) ; allow class overrid string class name = thi . get class ( ) . get name ( ) ; class loader cl = thread . current thread ( ) . get context class loader ( ) ; retriev configur log file name rotat = boolean . pars boolean ( get properti ( class name . rotat , true ) ) ; ( directori = = null ) directori = get properti ( class name . directori , log ) ; ( prefix = = null ) prefix = get properti ( class name . prefix , juli . ) ; ( suffix = = null ) suffix = get properti ( class name . suffix , . log ) ; string s buffer size = get properti ( class name . buffer size , string . valu ( buffer size ) ) ; try { buffer size = integ . pars int ( s buffer size ) ; } catch ( number format except ignor ) { op } get encod log file string encod = get properti ( class name . encod , null ) ; ( encod = null encod . length ( ) 0 ) { try { set encod ( encod ) ; } catch ( unsupport encod except ex ) { ignor } } get log level handler set level ( level . pars ( get properti ( class name . level , level . all ) ) ) ; get filter configur string filter name = get properti ( class name . filter , null ) ; ( filter name = null ) { try { set filter ( ( filter ) cl . load class ( filter name ) . new instanc ( ) ) ; } catch ( except e ) { ignor } } set formatt string formatt name = get properti ( class name . formatt , null ) ; ( formatt name = null ) { try { set formatt ( ( formatt ) cl . load class ( formatt name ) . new instanc ( ) ) ; } catch ( except e ) { ignor } } els { set formatt ( new simpl formatt ( ) ) ; } set error manag set error manag ( new error manag ( ) ) ; }
p add set rule instanc defin thi rule set specifi code digest code instanc , associ them our namespac uri ( ani ) . thi method should onli call digest instanc . p param digest digest instanc which new rule instanc should ad . overrid public void add rule instanc ( digest digest ) { session config = new set session config ( ) ; jsp config = new set jsp config ( ) ; login config = new set login config ( ) ; digest . add rule ( full prefix , new set public id rule ( set public id ) ) ; digest . add rule ( full prefix , new ignor annot rule ( ) ) ; digest . add rule ( full prefix , new version rule ( ) ) ; ( fragment ) { web fragment . xml digest . add call method ( full prefix name , set name , 0 ) ; digest . add rule ( full prefix absolut order , new absolut order rule ( ) ) ; digest . add call method ( full prefix order after name , add after order , 0 ) ; digest . add call method ( full prefix order after other , add after order other ) ; digest . add call method ( full prefix order befor name , add befor order , 0 ) ; digest . add call method ( full prefix order befor other , add befor order other ) ; } els { web . xml digest . add rule ( full prefix order , new rel order rule ( ) ) ; digest . add call method ( full prefix absolut order name , add absolut order , 0 ) ; digest . add call method ( full prefix absolut order name other , add absolut order other ) ; } digest . add call method ( full prefix context param , add context param , 2 ) ; digest . add call param ( full prefix context param param name , 0 ) ; digest . add call param ( full prefix context param param valu , 1 ) ; digest . add call method ( full prefix displai name , set displai name , 0 ) ; digest . add rule ( full prefix distribut , new set distribut rule ( ) ) ; configur name rule ( digest ) ; digest . add object creat ( full prefix error page , org . apach . catalina . deploi . error page ) ; digest . add set next ( full prefix error page , add error page , org . apach . catalina . deploi . error page ) ; digest . add call method ( full prefix error page error code , set error code , 0 ) ; digest . add call method ( full prefix error page except type , set except type , 0 ) ; digest . add call method ( full prefix error page locat , set locat , 0 ) ; digest . add object creat ( full prefix filter , org . apach . catalina . deploi . filter def ) ; digest . add set next ( full prefix filter , add filter , org . apach . catalina . deploi . filter def ) ; digest . add call method ( full prefix filter descript , set descript , 0 ) ; digest . add call method ( full prefix filter displai name , set displai name , 0 ) ; digest . add call method ( full prefix filter filter class , set filter class , 0 ) ; digest . add call method ( full prefix filter filter name , set filter name , 0 ) ; digest . add call method ( full prefix filter icon larg icon , set larg icon , 0 ) ; digest . add call method ( full prefix filter icon small icon , set small icon , 0 ) ; digest . add call method ( full prefix filter async support , set async support , 0 ) ; digest . add call method ( full prefix filter init param , add init paramet , 2 ) ; digest . add call param ( full prefix filter init param param name , 0 ) ; digest . add call param ( full prefix filter init param param valu , 1 ) ; digest . add object creat ( full prefix filter map , org . apach . catalina . deploi . filter map ) ; digest . add set next ( full prefix filter map , add filter map , org . apach . catalina . deploi . filter map ) ; digest . add call method ( full prefix filter map filter name , set filter name , 0 ) ; digest . add call method ( full prefix filter map servlet name , add servlet name , 0 ) ; digest . add call method ( full prefix filter map url pattern , add urlpattern , 0 ) ; digest . add call method ( full prefix filter map dispatch , set dispatch , 0 ) ; digest . add call method ( full prefix listen listen class , add listen , 0 ) ; digest . add rule ( full prefix jsp config , jsp config ) ; digest . add object creat ( full prefix jsp config jsp properti group , org . apach . catalina . deploi . jsp properti group ) ; digest . add set next ( full prefix jsp config jsp properti group , add jsp properti group , org . apach . catalina . deploi . jsp properti group ) ; digest . add call method ( full prefix jsp config jsp properti group defer syntax allow liter , set defer syntax , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group el ignor , set el ignor , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group includ coda , add includ coda , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group includ prelud , add includ prelud , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group xml , set xml , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group page encod , set page encod , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group script invalid , set script invalid , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group trim direct whitespac , set trim whitespac , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group url pattern , set url pattern , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group default content type , set default content type , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group buffer , set buffer , 0 ) ; digest . add call method ( full prefix jsp config jsp properti group error undeclar namespac , set error undeclar namespac , 0 ) ; digest . add rule ( full prefix login config , login config ) ; digest . add object creat ( full prefix login config , org . apach . catalina . deploi . login config ) ; digest . add set next ( full prefix login config , set login config , org . apach . catalina . deploi . login config ) ; digest . add call method ( full prefix login config auth method , set auth method , 0 ) ; digest . add call method ( full prefix login config realm name , set realm name , 0 ) ; digest . add call method ( full prefix login config form login config form error page , set error page , 0 ) ; digest . add call method ( full prefix login config form login config form login page , set login page , 0 ) ; digest . add call method ( full prefix mime map , add mime map , 2 ) ; digest . add call param ( full prefix mime map extens , 0 ) ; digest . add call param ( full prefix mime map mime type , 1 ) ; digest . add object creat ( full prefix secur constraint , org . apach . catalina . deploi . secur constraint ) ; digest . add set next ( full prefix secur constraint , add secur constraint , org . apach . catalina . deploi . secur constraint ) ; digest . add rule ( full prefix secur constraint auth constraint , new set auth constraint rule ( ) ) ; digest . add call method ( full prefix secur constraint auth constraint role name , add auth role , 0 ) ; digest . add call method ( full prefix secur constraint displai name , set displai name , 0 ) ; digest . add call method ( full prefix secur constraint user data constraint transport guarante , set user constraint , 0 ) ; digest . add object creat ( full prefix secur constraint web resourc collect , org . apach . catalina . deploi . secur collect ) ; digest . add set next ( full prefix secur constraint web resourc collect , add collect , org . apach . catalina . deploi . secur collect ) ; digest . add call method ( full prefix secur constraint web resourc collect http method , add method , 0 ) ; digest . add call method ( full prefix secur constraint web resourc collect http method omiss , add omit method , 0 ) ; digest . add call method ( full prefix secur constraint web resourc collect url pattern , add pattern , 0 ) ; digest . add call method ( full prefix secur constraint web resourc collect web resourc name , set name , 0 ) ; digest . add call method ( full prefix secur role role name , add secur role , 0 ) ; digest . add rule ( full prefix servlet , new servlet def creat rule ( ) ) ; digest . add set next ( full prefix servlet , add servlet , org . apach . catalina . deploi . servlet def ) ; digest . add call method ( full prefix servlet init param , add init paramet , 2 ) ; digest . add call param ( full prefix servlet init param param name , 0 ) ; digest . add call param ( full prefix servlet init param param valu , 1 ) ; digest . add call method ( full prefix servlet jsp file , set jsp file , 0 ) ; digest . add call method ( full prefix servlet load startup , set load startup , 0 ) ; digest . add call method ( full prefix servlet run role name , set run , 0 ) ; digest . add call method ( full prefix servlet secur role ref , add secur role ref , 2 ) ; digest . add call param ( full prefix servlet secur role ref role link , 1 ) ; digest . add call param ( full prefix servlet secur role ref role name , 0 ) ; digest . add call method ( full prefix servlet servlet class , set servlet class , 0 ) ; digest . add call method ( full prefix servlet servlet name , set servlet name , 0 ) ; digest . add object creat ( full prefix servlet multipart config , org . apach . catalina . deploi . multipart def ) ; digest . add set next ( full prefix servlet multipart config , set multipart def , org . apach . catalina . deploi . multipart def ) ; digest . add call method ( full prefix servlet multipart config locat , set locat , 0 ) ; digest . add call method ( full prefix servlet multipart config max file size , set max file size , 0 ) ; digest . add call method ( full prefix servlet multipart config max request size , set max request size , 0 ) ; digest . add call method ( full prefix servlet multipart config file size threshold , set file size threshold , 0 ) ; digest . add call method ( full prefix servlet async support , set async support , 0 ) ; digest . add call method ( full prefix servlet enabl , set enabl , 0 ) ; digest . add rule ( full prefix servlet map , new call method multi rule ( add servlet map , 2 , 0 ) ) ; digest . add call param ( full prefix servlet map servlet name , 1 ) ; digest . add rule ( full prefix servlet map url pattern , new call param multi rule ( 0 ) ) ; digest . add rule ( full prefix session config , session config ) ; digest . add object creat ( full prefix session config , org . apach . catalina . deploi . session config ) ; digest . add set next ( full prefix session config , set session config , org . apach . catalina . deploi . session config ) ; digest . add call method ( full prefix session config session timeout , set session timeout , 0 ) ; digest . add call method ( full prefix session config cooki config name , set cooki name , 0 ) ; digest . add call method ( full prefix session config cooki config domain , set cooki domain , 0 ) ; digest . add call method ( full prefix session config cooki config path , set cooki path , 0 ) ; digest . add call method ( full prefix session config cooki config comment , set cooki comment , 0 ) ; digest . add call method ( full prefix session config cooki config http onli , set cooki http onli , 0 ) ; digest . add call method ( full prefix session config cooki config secur , set cooki secur , 0 ) ; digest . add call method ( full prefix session config cooki config max ag , set cooki max ag , 0 ) ; digest . add call method ( full prefix session config track mode , add session track mode , 0 ) ; taglib pre servlet 2 . 4 digest . add rule ( full prefix taglib , new taglib locat rule ( fals ) ) ; digest . add call method ( full prefix taglib , add taglib , 2 ) ; digest . add call param ( full prefix taglib taglib locat , 1 ) ; digest . add call param ( full prefix taglib taglib uri , 0 ) ; taglib servlet 2 . 4 onward digest . add rule ( full prefix jsp config taglib , new taglib locat rule ( true ) ) ; digest . add call method ( full prefix jsp config taglib , add taglib , 2 ) ; digest . add call param ( full prefix jsp config taglib taglib locat , 1 ) ; digest . add call param ( full prefix jsp config taglib taglib uri , 0 ) ; digest . add call method ( full prefix welcom file list welcom file , add welcom file , 0 ) ; digest . add call method ( full prefix local encod map list local encod map , add local encod map , 2 ) ; digest . add call param ( full prefix local encod map list local encod map local , 0 ) ; digest . add call param ( full prefix local encod map list local encod map encod , 1 ) ; }
privat void convert jsp ( servlet def servlet def , servlet def jsp servlet def ) { servlet def . set servlet class ( org . apach . catalina . core . constant . jsp servlet class ) ; string jsp file = servlet def . get jsp file ( ) ; ( ( jsp file = null ) jsp file . start ( ) ) { ( context . servlet22 ( ) ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( context config . jsp file . warn , jsp file ) ) ; jsp file = jsp file ; } els { throw new illeg argument except ( sm . get string ( context config . jsp file . error , jsp file ) ) ; } } servlet def . get paramet map ( ) . put ( jsp file , jsp file ) ; servlet def . set jsp file ( null ) ; ( map . entri string , string init param : jsp servlet def . get paramet map ( ) . entri set ( ) ) { servlet def . add init paramet ( init param . get kei ( ) , init param . get valu ( ) ) ; } }	privat void convert jsp ( web xml web xml ) { servlet def jsp servlet = web xml . get servlet ( ) . get ( jsp ) ; ( servlet def servlet def : web xml . get servlet ( ) . valu ( ) ) { ( servlet def . get jsp file ( ) = null ) { convert jsp ( servlet def , jsp servlet ) ; } } }	privat void do test overrid default servlet sci ( string servlet name ) throw except { tomcat tomcat = get tomcat instanc ( ) ; file app dir = new file ( test webapp 3 . 0 ) ; standard context ctxt = ( standard context ) tomcat . add context ( null , test , app dir . get absolut path ( ) ) ; ctxt . set default web xml ( new file ( conf web . xml ) . get absolut path ( ) ) ; ctxt . add lifecycl listen ( new context config ( ) ) ; ctxt . add servlet contain initi ( new custom default servlet sci ( servlet name ) , null ) ; tomcat . start ( ) ; byte chunk re = new byte chunk ( ) ; int rc = get url ( http : localhost : get port ( ) test , re , null ) ; check return code assert equal ( http servlet respons . sc ok , rc ) ; check context assert equal ( ok custom default servlet , re . string ( ) ) ; }
privat creat access log element implement which need header string access log element creat access log element ( string header , char pattern ) { switch ( pattern ) { case i : return new header element ( header ) ; case c : return new cooki element ( header ) ; case o : return new respons header element ( header ) ; case r : return new request attribut element ( header ) ; case s : return new session attribut element ( header ) ; default : return new string element ( ) ; } }	protect synchron open new log file date specifi code date stamp code . void open ( ) { creat directori necessari file dir = new file ( directori ) ; ( dir . absolut ( ) ) dir = new file ( system . get properti ( global . catalina base prop ) , directori ) ; ( dir . exist ( ) ) { ( dir . mkdir ( ) ) { log . error ( sm . get string ( access log valv . open dir fail , dir ) ) ; } } open current log file try { string pathnam ; rotat need date stamp file name ( rotat ) { pathnam = dir . get absolut path ( ) file . separ prefix date stamp suffix ; } els { pathnam = dir . get absolut path ( ) file . separ prefix suffix ; } writer = new print writer ( new buffer writer ( new file writer ( pathnam , true ) , 128000 ) , fals ) ; current log file = new file ( pathnam ) ; } catch ( ioexcept e ) { writer = null ; current log file = null ; } }	start thi compon implement requir { link org . apach . catalina . util . lifecycl base start intern ( ) } . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect synchron void start intern ( ) throw lifecycl except { initi date formatt string format = get file date format ( ) ; ( format = = null format . length ( ) = = 0 ) { format = yyyi mm dd ; set file date format ( format ) ; } file date formatt = new simpl date format ( format ) ; file date formatt . set time zone ( timezon ) ; date stamp = file date formatt . format ( current date struct . get ( ) . current date ) ; open ( ) ; set state ( lifecycl state . start ) ; }	protect access log element creat log element ( ) { list access log element list = new arrai list access log element ( ) ; boolean replac = fals ; string builder buf = new string builder ( ) ; ( int i = 0 ; i pattern . length ( ) ; i ) { char ch = pattern . char ( i ) ; ( replac ) { code process { , behavior . . . i do encount close } i ignor { ( { = = ch ) { string builder name = new string builder ( ) ; int j = i 1 ; ( ; j pattern . length ( ) } = pattern . char ( j ) ; j ) { name . append ( pattern . char ( j ) ) ; } ( j 1 pattern . length ( ) ) { 1 wa account } which we increment now j ; list . add ( creat access log element ( name . string ( ) , pattern . char ( j ) ) ) ; i = j ; sinc we walk more than charact } els { d oh end string pretend we never did thi do process old wai list . add ( creat access log element ( ch ) ) ; } } els { list . add ( creat access log element ( ch ) ) ; } replac = fals ; } els ( ch = = ) { replac = true ; list . add ( new string element ( buf . string ( ) ) ) ; buf = new string builder ( ) ; } els { buf . append ( ch ) ; } } ( buf . length ( ) 0 ) { list . add ( new string element ( buf . string ( ) ) ) ; } return list . arrai ( new access log element 0 ) ; }	overrid public void log ( request request , respons respons , long time ) { ( get state ( ) . avail ( ) get enabl ( ) log element = = null condit = null null = request . get request ( ) . get attribut ( condit ) ) { return ; } date date = get date ( ) ; string builder result = new string builder ( 128 ) ; ( int i = 0 ; i log element . length ; i ) { log element i . add element ( result , date , request , respons , time ) ; } log ( result . string ( ) ) ; }
protect class packag web applic , class each super class need check match { link handl type } annot match { link handl type } . param java class void check handl type ( java class java class ) { skip thi we can ( type initi map . size ( ) = = 0 ) return ; choic load class string class name = java class . get class name ( ) ; class clazz = null ; try { clazz = context . get loader ( ) . get class loader ( ) . load class ( class name ) ; } catch ( class def found error e ) { log . debug ( sm . get string ( context config . invalid sci handl type , class name ) , e ) ; return ; } catch ( class found except e ) { log . warn ( sm . get string ( context config . invalid sci handl type , class name ) , e ) ; return ; } catch ( class format error e ) { log . warn ( sm . get string ( context config . invalid sci handl type , class name ) , e ) ; return ; } ( clazz . annot ( ) ) { skip return ; } boolean match = fals ; ( map . entri class , set servlet contain initi >> entri : type initi map . entri set ( ) ) { ( entri . get kei ( ) . annot ( ) ) { annot entri annot entri = java class . get annot entri ( ) ; ( annot entri annot entri : annot entri ) { ( entri . get kei ( ) . get name ( ) . equal ( get class name ( annot entri . get annot type ( ) ) ) ) { match = true ; break ; } } } els ( entri . get kei ( ) . assign from ( clazz ) ) { match = true ; } ( match ) { ( servlet contain initi sci : entri . get valu ( ) ) { initi class map . get ( sci ) . add ( clazz ) ; } } } }	public void test duplic filter map ( ) throw except { web xml webxml = new web xml ( ) ; context config config = new context config ( ) ; file p file = param class resourc ( org apach catalina startup duplic map param filter ) ; assert true ( p file . exist ( ) ) ; try { config . process annot file ( p file , webxml ) ; fail ( ) ; } catch ( illeg argument except ex ) { ignor } filter def filter def = webxml . get filter ( ) . get ( param d ) ; assert null ( filter def ) ; }
public string string ( ) { return left right ; }
protect render html list current activ context our virtual host , memori server statu inform . param request request param respons respons param messag messag displai void list ( http servlet request request , http servlet respons respons , string messag , string manag sm client ) throw ioexcept { ( debug = 1 ) log ( list : list context virtual host host . get name ( ) ) ; print writer writer = respons . get writer ( ) ; html header section writer . print ( constant . html header section ) ; bodi header section object arg = new object 2 ; arg 0 = request . get context path ( ) ; arg 1 = sm client . get string ( html manag servlet . titl ) ; writer . print ( messag format . format ( constant . bodi header section , arg ) ) ; messag section arg = new object 3 ; arg 0 = sm client . get string ( html manag servlet . messag label ) ; ( messag = = null messag . length ( ) = = 0 ) { arg 1 = ok ; } els { arg 1 = request util . filter ( messag ) ; } writer . print ( messag format . format ( constant . messag section , arg ) ) ; manag section arg = new object 9 ; arg 0 = sm client . get string ( html manag servlet . manag ) ; arg 1 = respons . encod url ( request . get context path ( ) html list ) ; arg 2 = sm client . get string ( html manag servlet . list ) ; arg 3 = respons . encod url ( request . get context path ( ) sm client . get string ( html manag servlet . help html manag file ) ) ; arg 4 = sm client . get string ( html manag servlet . help html manag ) ; arg 5 = respons . encod url ( request . get context path ( ) sm client . get string ( html manag servlet . help manag file ) ) ; arg 6 = sm client . get string ( html manag servlet . help manag ) ; arg 7 = respons . encod url ( request . get context path ( ) statu ) ; arg 8 = sm client . get string ( statu servlet . titl ) ; writer . print ( messag format . format ( constant . manag section , arg ) ) ; app header section arg = new object 7 ; arg 0 = sm client . get string ( html manag servlet . app titl ) ; arg 1 = sm client . get string ( html manag servlet . app path ) ; arg 2 = sm client . get string ( html manag servlet . app version ) ; arg 3 = sm client . get string ( html manag servlet . app name ) ; arg 4 = sm client . get string ( html manag servlet . app avail ) ; arg 5 = sm client . get string ( html manag servlet . app session ) ; arg 6 = sm client . get string ( html manag servlet . app task ) ; writer . print ( messag format . format ( app header section , arg ) ) ; app row section creat sort map deploi applic context name . contain children = host . find children ( ) ; string context name = new string children . length ; ( int i = 0 ; i children . length ; i ) context name i = children i . get name ( ) ; arrai . sort ( context name ) ; string app start = sm client . get string ( html manag servlet . app start ) ; string app stop = sm client . get string ( html manag servlet . app stop ) ; string app reload = sm client . get string ( html manag servlet . app reload ) ; string app undeploi = sm client . get string ( html manag servlet . app undeploi ) ; string app expir = sm client . get string ( html manag servlet . app expir ) ; string version = i sm client . get string ( html manag servlet . version ) i ; boolean highlight = true ; boolean deploi = true ; string highlight color = null ; ( string context name : context name ) { context ctxt = ( context ) host . find child ( context name ) ; ( ctxt = null ) { bugzilla 34818 , altern row color highlight = highlight ; ( highlight ) { highlight color = c3f3c3 ; } els { highlight color = ffffff ; } string context path = ctxt . get path ( ) ; string displai path = context path ; ( displai path . equal ( ) ) { displai path = ; } string builder tmp = new string builder ( ) ; tmp . append ( path = ) ; tmp . append ( url encod . encod ( displai path ) ) ; ( ctxt . get webapp version ( ) . length ( ) 0 ) { tmp . append ( version = ) ; tmp . append ( url encod . encod ( ctxt . get webapp version ( ) ) ) ; } string path version = tmp . string ( ) ; try { deploi = deploi ( context name ) ; } catch ( except e ) { assum fals failur safeti deploi = fals ; } arg = new object 7 ; arg 0 = href = url encod . encod ( displai path ) request util . filter ( displai path ) ; ( . equal ( ctxt . get webapp version ( ) ) ) { arg 1 = version ; } els { arg 1 = request util . filter ( ctxt . get webapp version ( ) ) ; } ( ctxt . get displai name ( ) = = null ) { arg 2 = nbsp ; ; } els { arg 2 = request util . filter ( ctxt . get displai name ( ) ) ; } arg 3 = boolean . valu ( ctxt . get avail ( ) ) ; arg 4 = request util . filter ( respons . encod url ( request . get context path ( ) html session path version ) ) ; manag manag = ctxt . get manag ( ) ; ( manag instanceof distribut manag show proxi session ) { arg 5 = integ . valu ( ( ( distribut manag ) manag ) . get activ session full ( ) ) ; } els ( ctxt . get manag ( ) = null ) { arg 5 = integ . valu ( manag . get activ session ( ) ) ; } els { arg 5 = integ . valu ( 0 ) ; } arg 6 = highlight color ; writer . print ( messag format . format ( app row detail section , arg ) ) ; arg = new object 14 ; arg 0 = request util . filter ( respons . encod url ( request . get context path ( ) html start path version ) ) ; arg 1 = app start ; arg 2 = request util . filter ( respons . encod url ( request . get context path ( ) html stop path version ) ) ; arg 3 = app stop ; arg 4 = request util . filter ( respons . encod url ( request . get context path ( ) html reload path version ) ) ; arg 5 = app reload ; arg 6 = request util . filter ( respons . encod url ( request . get context path ( ) html undeploi path version ) ) ; arg 7 = app undeploi ; arg 8 = request util . filter ( respons . encod url ( request . get context path ( ) html expir path version ) ) ; arg 9 = app expir ; arg 10 = sm client . get string ( html manag servlet . expir . explain ) ; ( manag = = null ) { arg 11 = sm client . get string ( html manag servlet . manag ) ; } els { arg 11 = integ . valu ( ctxt . get manag ( ) . get max inact interv ( ) 60 ) ; } arg 12 = sm client . get string ( html manag servlet . expir . unit ) ; arg 13 = highlight color ; ( ctxt . get name ( ) . equal ( thi . context . get name ( ) ) ) { writer . print ( messag format . format ( manag app row button section , arg ) ) ; } els ( ctxt . get avail ( ) deploi ) { writer . print ( messag format . format ( start deploi app row button section , arg ) ) ; } els ( ctxt . get avail ( ) deploi ) { writer . print ( messag format . format ( start nondeploi app row button section , arg ) ) ; } els ( ctxt . get avail ( ) deploi ) { writer . print ( messag format . format ( stop deploi app row button section , arg ) ) ; } els { writer . print ( messag format . format ( stop nondeploi app row button section , arg ) ) ; } } } deploi section arg = new object 7 ; arg 0 = sm client . get string ( html manag servlet . deploi titl ) ; arg 1 = sm client . get string ( html manag servlet . deploi server ) ; arg 2 = respons . encod url ( request . get context path ( ) html deploi ) ; arg 3 = sm client . get string ( html manag servlet . deploi path ) ; arg 4 = sm client . get string ( html manag servlet . deploi config ) ; arg 5 = sm client . get string ( html manag servlet . deploi war ) ; arg 6 = sm client . get string ( html manag servlet . deploi button ) ; writer . print ( messag format . format ( deploi section , arg ) ) ; arg = new object 4 ; arg 0 = sm client . get string ( html manag servlet . deploi upload ) ; arg 1 = respons . encod url ( request . get context path ( ) html upload ) ; arg 2 = sm client . get string ( html manag servlet . deploi upload file ) ; arg 3 = sm client . get string ( html manag servlet . deploi button ) ; writer . print ( messag format . format ( upload section , arg ) ) ; diagnost section arg = new object 5 ; arg 0 = sm client . get string ( html manag servlet . diagnost titl ) ; arg 1 = sm client . get string ( html manag servlet . diagnost leak ) ; arg 2 = respons . encod url ( request . get context path ( ) html findleak ) ; arg 3 = sm client . get string ( html manag servlet . diagnost leak warn ) ; arg 4 = sm client . get string ( html manag servlet . diagnost leak button ) ; writer . print ( messag format . format ( diagnost section , arg ) ) ; server header section arg = new object 7 ; arg 0 = sm client . get string ( html manag servlet . server titl ) ; arg 1 = sm client . get string ( html manag servlet . server version ) ; arg 2 = sm client . get string ( html manag servlet . server jvmversion ) ; arg 3 = sm client . get string ( html manag servlet . server jvmvendor ) ; arg 4 = sm client . get string ( html manag servlet . server osnam ) ; arg 5 = sm client . get string ( html manag servlet . server osvers ) ; arg 6 = sm client . get string ( html manag servlet . server osarch ) ; writer . print ( messag format . format ( constant . server header section , arg ) ) ; server row section arg = new object 6 ; arg 0 = server info . get server info ( ) ; arg 1 = system . get properti ( java . runtim . version ) ; arg 2 = system . get properti ( java . vm . vendor ) ; arg 3 = system . get properti ( os . name ) ; arg 4 = system . get properti ( os . version ) ; arg 5 = system . get properti ( os . arch ) ; writer . print ( messag format . format ( constant . server row section , arg ) ) ; html tail section writer . print ( constant . html tail section ) ; finish up respons writer . flush ( ) ; writer . close ( ) ; }	process get request specifi resourc . param request servlet request we ar process param respons servlet respons we ar creat except ioexcept input output error occur except servlet except servlet specifi error occur overrid public void do get ( http servlet request request , http servlet respons respons ) throw ioexcept , servlet except { mode flag html xml output int mode = 0 ; xml = true , set mode xml ( request . get paramet ( xml ) = null request . get paramet ( xml ) . equal ( true ) ) { mode = 1 ; } statu transform . set content type ( respons , mode ) ; print writer writer = respons . get writer ( ) ; boolean complet statu = fals ; ( ( request . get path info ( ) = null ) ( request . get path info ( ) . equal ( all ) ) ) { complet statu = true ; } us statu transform output statu object arg = new object 1 ; arg 0 = request . get context path ( ) ; statu transform . write header ( writer , arg , mode ) ; bodi header section arg = new object 2 ; arg 0 = request . get context path ( ) ; ( complet statu ) { arg 1 = sm . get string ( statu servlet . complet ) ; } els { arg 1 = sm . get string ( statu servlet . titl ) ; } us statu transform output statu statu transform . write bodi ( writer , arg , mode ) ; manag section arg = new object 9 ; arg 0 = sm . get string ( html manag servlet . manag ) ; arg 1 = respons . encod url ( request . get context path ( ) html list ) ; arg 2 = sm . get string ( html manag servlet . list ) ; arg 3 = respons . encod url ( request . get context path ( ) sm . get string ( html manag servlet . help html manag file ) ) ; arg 4 = sm . get string ( html manag servlet . help html manag ) ; arg 5 = respons . encod url ( request . get context path ( ) sm . get string ( html manag servlet . help manag file ) ) ; arg 6 = sm . get string ( html manag servlet . help manag ) ; ( complet statu ) { arg 7 = respons . encod url ( request . get context path ( ) statu ) ; arg 8 = sm . get string ( statu servlet . titl ) ; } els { arg 7 = respons . encod url ( request . get context path ( ) statu all ) ; arg 8 = sm . get string ( statu servlet . complet ) ; } us statu transform output statu statu transform . write manag ( writer , arg , mode ) ; server header section arg = new object 7 ; arg 0 = sm . get string ( html manag servlet . server titl ) ; arg 1 = sm . get string ( html manag servlet . server version ) ; arg 2 = sm . get string ( html manag servlet . server jvmversion ) ; arg 3 = sm . get string ( html manag servlet . server jvmvendor ) ; arg 4 = sm . get string ( html manag servlet . server osnam ) ; arg 5 = sm . get string ( html manag servlet . server osvers ) ; arg 6 = sm . get string ( html manag servlet . server osarch ) ; us statu transform output statu statu transform . write page head ( writer , arg , mode ) ; server row section arg = new object 6 ; arg 0 = server info . get server info ( ) ; arg 1 = system . get properti ( java . runtim . version ) ; arg 2 = system . get properti ( java . vm . vendor ) ; arg 3 = system . get properti ( os . name ) ; arg 4 = system . get properti ( os . version ) ; arg 5 = system . get properti ( os . arch ) ; us statu transform output statu statu transform . write server info ( writer , arg , mode ) ; try { displai oper system statist us apr avail statu transform . write osstat ( writer , mode ) ; displai virtual machin statist statu transform . write vmstate ( writer , mode ) ; enumer object name enumer = thread pool . element ( ) ; while ( enumer . ha more element ( ) ) { object name object name = enumer . next element ( ) ; string name = object name . get kei properti ( name ) ; us statu transform output statu statu transform . write connector state ( writer , object name , name , m bean server , global request processor , request processor , mode ) ; } ( ( request . get path info ( ) = null ) ( request . get path info ( ) . equal ( all ) ) ) { note : retriev full statu much slower us statu transform output statu statu transform . write detail state ( writer , m bean server , mode ) ; } } catch ( except e ) { throw new servlet except ( e ) ; } us statu transform output statu statu transform . write footer ( writer , mode ) ; }
protect handl receiv new session creat other node ( creat backup primari fals ) param msg param sender void handl session creat ( session messag msg , member sender ) { counter receiv evt session creat ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( delta manag . receiv messag . creat new session , get name ( ) , msg . get session id ( ) ) ) ; delta session session = ( delta session ) creat empti session ( ) ; session . set manag ( thi ) ; session . set valid ( true ) ; session . set primari session ( fals ) ; session . set creation time ( msg . get timestamp ( ) ) ; us contain max inact interv so session expir correctli case primari transfer session . set max inact interv ( get max inact interv ( ) ) ; session . access ( ) ; session . set id ( msg . get session id ( ) , notifi session listen replic ) ; session . reset delta request ( ) ; session . end access ( ) ; }	public void expir ( boolean notifi , boolean notifi cluster ) { ( expir ) return ; string expir id = get id intern ( ) ; ( expir id = null manag = null manag instanceof delta manag ) { delta manag dmanag = ( delta manag ) manag ; catalina cluster cluster = dmanag . get cluster ( ) ; cluster messag msg = dmanag . request complet ( expir id , true ) ; ( msg = null ) { cluster . send ( msg ) ; } } super . expir ( notifi ) ; ( notifi cluster ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( delta session . notifi , ( ( cluster manag ) manag ) . get name ( ) , boolean . valu ( primari session ( ) ) , expir id ) ) ; ( manag instanceof delta manag ) { ( ( delta manag ) manag ) . session expir ( expir id ) ; } } }
protect lock method . void do lock ( http servlet request req , http servlet respons resp ) throw servlet except , ioexcept { ( read onli ) { resp . send error ( webdav statu . sc forbidden ) ; return ; } ( lock ( req ) ) { resp . send error ( webdav statu . sc lock ) ; return ; } lock info lock = new lock info ( ) ; pars lock request pars depth header string depth str = req . get header ( depth ) ; ( depth str = = null ) { lock . depth = max depth ; } els { ( depth str . equal ( 0 ) ) { lock . depth = 0 ; } els { lock . depth = max depth ; } } pars timeout header int lock durat = default timeout ; string lock durat str = req . get header ( timeout ) ; ( lock durat str = = null ) { lock durat = default timeout ; } els { int comma po = lock durat str . index ( , ) ; multipl timeout , just us first ( comma po = 1 ) { lock durat str = lock durat str . substr ( 0 , comma po ) ; } ( lock durat str . start ( second ) ) { lock durat = ( new integ ( lock durat str . substr ( 7 ) ) ) . int valu ( ) ; } els { ( lock durat str . equal ignor case ( infin ) ) { lock durat = max timeout ; } els { try { lock durat = ( new integ ( lock durat str ) ) . int valu ( ) ; } catch ( number format except e ) { lock durat = max timeout ; } } } ( lock durat = = 0 ) { lock durat = default timeout ; } ( lock durat max timeout ) { lock durat = max timeout ; } } lock . expir = system . current time milli ( ) ( lock durat 1000 ) ; int lock request type = lock creation ; node lock info node = null ; document builder document builder = get document builder ( ) ; try { document document = document builder . pars ( new input sourc ( req . get input stream ( ) ) ) ; get root element document element root element = document . get document element ( ) ; lock info node = root element ; } catch ( ioexcept e ) { lock request type = lock refresh ; } catch ( saxexcept e ) { lock request type = lock refresh ; } ( lock info node = null ) { read lock inform node list child list = lock info node . get child node ( ) ; string writer str writer = null ; domwrit dom writer = null ; node lock scope node = null ; node lock type node = null ; node lock owner node = null ; ( int i = 0 ; i child list . get length ( ) ; i ) { node current node = child list . item ( i ) ; switch ( current node . get node type ( ) ) { case node . text node : break ; case node . element node : string node name = current node . get node name ( ) ; ( node name . end ( lockscop ) ) { lock scope node = current node ; } ( node name . end ( locktyp ) ) { lock type node = current node ; } ( node name . end ( owner ) ) { lock owner node = current node ; } break ; } } ( lock scope node = null ) { child list = lock scope node . get child node ( ) ; ( int i = 0 ; i child list . get length ( ) ; i ) { node current node = child list . item ( i ) ; switch ( current node . get node type ( ) ) { case node . text node : break ; case node . element node : string temp scope = current node . get node name ( ) ; ( temp scope . index ( : ) = 1 ) { lock . scope = temp scope . substr ( temp scope . index ( : ) 1 ) ; } els { lock . scope = temp scope ; } break ; } } ( lock . scope = = null ) { bad request resp . set statu ( webdav statu . sc bad request ) ; } } els { bad request resp . set statu ( webdav statu . sc bad request ) ; } ( lock type node = null ) { child list = lock type node . get child node ( ) ; ( int i = 0 ; i child list . get length ( ) ; i ) { node current node = child list . item ( i ) ; switch ( current node . get node type ( ) ) { case node . text node : break ; case node . element node : string temp type = current node . get node name ( ) ; ( temp type . index ( : ) = 1 ) { lock . type = temp type . substr ( temp type . index ( : ) 1 ) ; } els { lock . type = temp type ; } break ; } } ( lock . type = = null ) { bad request resp . set statu ( webdav statu . sc bad request ) ; } } els { bad request resp . set statu ( webdav statu . sc bad request ) ; } ( lock owner node = null ) { child list = lock owner node . get child node ( ) ; ( int i = 0 ; i child list . get length ( ) ; i ) { node current node = child list . item ( i ) ; switch ( current node . get node type ( ) ) { case node . text node : lock . owner = current node . get node valu ( ) ; break ; case node . element node : str writer = new string writer ( ) ; dom writer = new domwrit ( str writer , true ) ; dom writer . set qualifi name ( fals ) ; dom writer . print ( current node ) ; lock . owner = str writer . string ( ) ; break ; } } ( lock . owner = = null ) { bad request resp . set statu ( webdav statu . sc bad request ) ; } } els { lock . owner = ; } } string path = get rel path ( req ) ; lock . path = path ; boolean exist = true ; object object = null ; try { object = resourc . lookup ( path ) ; } catch ( name except e ) { exist = fals ; } enumer lock info lock list = null ; ( lock request type = = lock creation ) { gener lock id string lock token str = req . get servlet path ( ) lock . type lock . scope req . get user princip ( ) lock . depth lock . owner lock . token lock . expir system . current time milli ( ) secret ; string lock token = md5encod . encod ( md5helper . digest ( lock token str . get byte ( ) ) ) ; ( ( exist ) ( object instanceof dir context ) ( lock . depth = = max depth ) ) { lock collect ( all member resourc ) check child resourc thi collect alreadi lock vector string lock path = new vector string ( ) ; lock list = collect lock . element ( ) ; while ( lock list . ha more element ( ) ) { lock info current lock = lock list . next element ( ) ; ( current lock . ha expir ( ) ) { resourc lock . remov ( current lock . path ) ; continu ; } ( ( current lock . path . start ( lock . path ) ) ( ( current lock . exclus ( ) ) ( lock . exclus ( ) ) ) ) { child collect thi collect lock lock path . add element ( current lock . path ) ; } } lock list = resourc lock . element ( ) ; while ( lock list . ha more element ( ) ) { lock info current lock = lock list . next element ( ) ; ( current lock . ha expir ( ) ) { resourc lock . remov ( current lock . path ) ; continu ; } ( ( current lock . path . start ( lock . path ) ) ( ( current lock . exclus ( ) ) ( lock . exclus ( ) ) ) ) { child resourc thi collect lock lock path . add element ( current lock . path ) ; } } ( lock path . empti ( ) ) { child path wa lock we gener multistatu error report enumer string lock path list = lock path . element ( ) ; resp . set statu ( webdav statu . sc conflict ) ; xmlwriter gener xml = new xmlwriter ( ) ; gener xml . write xmlheader ( ) ; gener xml . write element ( d , default namespac , multistatu , xmlwriter . open ) ; while ( lock path list . ha more element ( ) ) { gener xml . write element ( d , respons , xmlwriter . open ) ; gener xml . write element ( d , href , xmlwriter . open ) ; gener xml . write text ( lock path list . next element ( ) ) ; gener xml . write element ( d , href , xmlwriter . close ) ; gener xml . write element ( d , statu , xmlwriter . open ) ; gener xml . write text ( http 1 . 1 webdav statu . sc lock webdav statu . get statu text ( webdav statu . sc lock ) ) ; gener xml . write element ( d , statu , xmlwriter . close ) ; gener xml . write element ( d , respons , xmlwriter . close ) ; } gener xml . write element ( d , multistatu , xmlwriter . close ) ; writer writer = resp . get writer ( ) ; writer . write ( gener xml . string ( ) ) ; writer . close ( ) ; return ; } boolean add lock = true ; check alreadi share lock thi path lock list = collect lock . element ( ) ; while ( lock list . ha more element ( ) ) { lock info current lock = lock list . next element ( ) ; ( current lock . path . equal ( lock . path ) ) { ( current lock . exclus ( ) ) { resp . send error ( webdav statu . sc lock ) ; return ; } els { ( lock . exclus ( ) ) { resp . send error ( webdav statu . sc lock ) ; return ; } } current lock . token . add element ( lock token ) ; lock = current lock ; add lock = fals ; } } ( add lock ) { lock . token . add element ( lock token ) ; collect lock . add element ( lock ) ; } } els { lock singl resourc retriev alreadi exist lock resourc lock info present lock = resourc lock . get ( lock . path ) ; ( present lock = null ) { ( ( present lock . exclus ( ) ) ( lock . exclus ( ) ) ) { either lock exclus , lock can t grant resp . send error ( webdav statu . sc precondit fail ) ; return ; } els { present lock . token . add element ( lock token ) ; lock = present lock ; } } els { lock . token . add element ( lock token ) ; resourc lock . put ( lock . path , lock ) ; check resourc exist thi path exist = true ; try { object = resourc . lookup ( path ) ; } catch ( name except e ) { exist = fals ; } ( exist ) { creat lock null resourc int slash = lock . path . last index ( ) ; string parent path = lock . path . substr ( 0 , slash ) ; vector string lock null = lock null resourc . get ( parent path ) ; ( lock null = = null ) { lock null = new vector string ( ) ; lock null resourc . put ( parent path , lock null ) ; } lock null . add element ( lock . path ) ; } add lock token header rfc 2518 8 . 10 . 1 onli do thi newli creat lock resp . add header ( lock token , opaquelocktoken : lock token ) ; } } } ( lock request type = = lock refresh ) { string header = req . get header ( ) ; ( header = = null ) header = ; check resourc lock lock info renew = resourc lock . get ( path ) ; enumer string token list = null ; least token lock must have been given token list = renew . token . element ( ) ; while ( token list . ha more element ( ) ) { string token = token list . next element ( ) ; ( header . index ( token ) = 1 ) { renew . expir = lock . expir ; lock = renew ; } } check inherit collect lock enumer lock info collect lock list = collect lock . element ( ) ; while ( collect lock list . ha more element ( ) ) { renew = collect lock list . next element ( ) ; ( path . equal ( renew . path ) ) { token list = renew . token . element ( ) ; while ( token list . ha more element ( ) ) { string token = token list . next element ( ) ; ( header . index ( token ) = 1 ) { renew . expir = lock . expir ; lock = renew ; } } } } } set statu , gener xml respons contain lock inform xmlwriter gener xml = new xmlwriter ( ) ; gener xml . write xmlheader ( ) ; gener xml . write element ( d , default namespac , prop , xmlwriter . open ) ; gener xml . write element ( d , lockdiscoveri , xmlwriter . open ) ; lock . xml ( gener xml ) ; gener xml . write element ( d , lockdiscoveri , xmlwriter . close ) ; gener xml . write element ( d , prop , xmlwriter . close ) ; resp . set statu ( webdav statu . sc ok ) ; resp . set content type ( text xml ; charset = utf 8 ) ; writer writer = resp . get writer ( ) ; writer . write ( gener xml . string ( ) ) ; writer . close ( ) ; }
public map specifi login method specifi authent , allow map org apach catalina startup authent . properti overridden . param authent authent handl authent specifi login method param login method login method map specifi authent throw illeg argument except specifi authent doe implement org . apach . catalina . valv interfac void add authent ( authent authent , string login method ) { ( ( authent instanceof valv ) ) { throw new illeg argument except ( sm . get string ( embed . authent instanc valv ) ) ; } ( authent = = null ) { synchron ( thi ) { ( authent = = null ) { authent = new hash map string , authent ( ) ; } } } authent . put ( login method , authent ) ; }
protect scan meta inf lib jar each found add ani meta inf web fragment . xml result map . web fragment . xml file pars befor ad map . everi jar ad code null code us web fragment . xml wa found . ani jar known contain fragment skip . return map jar name process web fragment ( ani ) map string , web xml process jar web fragment ( ) { jar scanner jar scanner = context . get jar scanner ( ) ; fragment jar scanner callback callback = new fragment jar scanner callback ( ) ; jar scanner . scan ( context . get servlet context ( ) , context . get loader ( ) . get class loader ( ) , callback , null ) ; return callback . get fragment ( ) ; }
protect flush byte char contain buffer . throw ioexcept underli ioexcept occur void do flush ( boolean real flush ) throw ioexcept { ( suspend ) return ; do flush = true ; ( initi ) { coyot respons . send header ( ) ; initi = fals ; } ( bb . get length ( ) 0 ) { bb . flush buffer ( ) ; } do flush = fals ; ( real flush ) { coyot respons . action ( action code . client flush , coyot respons ) ; here , notifi servlet ioe ( coyot respons . except present ( ) ) { throw new client abort except ( coyot respons . get error except ( ) ) ; } } }	public recycl output buffer . void recycl ( ) { initi = true ; byte written = 0 ; char written = 0 ; bb . recycl ( ) ; close = fals ; suspend = fals ; ( conv = null ) { conv . recycl ( ) ; } got enc = fals ; enc = null ; }
public string get path ( ) { return ( thi . path ) ; }	execut request oper . except build except error occur overrid public void execut ( ) throw build except { super . execut ( ) ; ( path = = null ) { throw new build except ( must specifi path attribut ) ; } try { execut ( reload path = urlencod . encod ( thi . path , get charset ( ) ) ) ; } catch ( unsupport encod except e ) { throw new build except ( invalid charset attribut : get charset ( ) ) ; } }	execut request oper . except build except error occur overrid public void execut ( ) throw build except { super . execut ( ) ; ( path = = null ) { throw new build except ( must specifi path attribut ) ; } try { execut ( session path = urlencod . encod ( thi . path , get charset ( ) ) ) ; } catch ( unsupport encod except e ) { throw new build except ( invalid charset attribut : get charset ( ) ) ; } }	execut request oper . except build except error occur overrid public void execut ( ) throw build except { super . execut ( ) ; ( path = = null ) { throw new build except ( must specifi path attribut ) ; } try { execut ( start path = urlencod . encod ( thi . path , get charset ( ) ) ) ; } catch ( unsupport encod except e ) { throw new build except ( invalid charset attribut : get charset ( ) ) ; } }	execut request oper . except build except error occur overrid public void execut ( ) throw build except { super . execut ( ) ; ( path = = null ) { throw new build except ( must specifi path attribut ) ; } try { execut ( stop path = urlencod . encod ( thi . path , get charset ( ) ) ) ; } catch ( unsupport encod except e ) { throw new build except ( invalid charset attribut : get charset ( ) ) ; } }	execut request oper . except build except error occur overrid public void execut ( ) throw build except { super . execut ( ) ; ( path = = null ) { throw new build except ( must specifi path attribut ) ; } try { execut ( undeploi path = urlencod . encod ( thi . path , get charset ( ) ) ) ; } catch ( unsupport encod except e ) { throw new build except ( invalid charset attribut : get charset ( ) ) ; } }	public void set path ( string path ) { thi . path = path ; }
privat scan given jar urlconnect tld file locat meta inf ( subdirectori ) , ad implicit map entri taglib map ani tld ha uri element . param jar conn jar urlconnect jar file scan keep sync o . . c . startup . tld config void tld scan jar ( jar urlconnect jar conn ) throw ioexcept { jar urlconnect get jar file ( ) creat temporari copi jar underli resourc file url . can slow so input stream resourc us url resourc url = jar conn . get jar file url ( ) ; string resourc path = resourc url . string ( ) ; non close jar input stream jar input stream = null ; boolean found tld = fals ; try { urlconnect resourc conn = resourc url . open connect ( ) ; resourc conn . set us cach ( fals ) ; jar input stream = new non close jar input stream ( resourc conn . get input stream ( ) ) ; jar entri entri = jar input stream . get next jar entri ( ) ; while ( entri = null ) { string name = entri . get name ( ) ; ( name . start ( meta inf ) name . end ( . tld ) ) { found tld = true ; tld scan stream ( resourc path , name , jar input stream ) ; } entri = jar input stream . get next jar entri ( ) ; } } final { ( jar input stream = null ) { try { jar input stream . realli close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } } } ( found tld ) { log . info ( local . get messag ( jsp . tld cach . tld jar , resourc path ) ) ; } }	privat scan given jar urlconnect tld file locat meta inf ( sub directori ) . param jar conn jar urlconnect jar file scan keep sync o . . j . comil . tld locat cach void tld scan jar ( jar urlconnect jar conn ) { jar urlconnect get jar file ( ) creat temporari copi jar underli resourc file url . can slow so input stream resourc us url resourc url = jar conn . get jar file url ( ) ; non close jar input stream jar input stream = null ; string name = null ; try { urlconnect resourc conn = resourc url . open connect ( ) ; resourc conn . set us cach ( fals ) ; jar input stream = new non close jar input stream ( resourc conn . get input stream ( ) ) ; jar entri entri = jar input stream . get next jar entri ( ) ; while ( entri = null ) { name = entri . get name ( ) ; ( name . start ( meta inf ) name . end ( . tld ) ) { xml error handler handler = tld scan stream ( jar input stream ) ; handler . log find ( log , jar conn . get url ( ) name ) ; } entri = jar input stream . get next jar entri ( ) ; } } catch ( ioexcept ioe ) { log . warn ( sm . get string ( tld config . jar fail , jar conn . get url ( ) name ) , ioe ) ; } final { ( jar input stream = null ) { try { jar input stream . realli close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } } } }	protect void process annot jar ( url url , web xml fragment ) { jar input stream jar input stream = null ; try { urlconnect url conn = url . open connect ( ) ; jar urlconnect jar conn ; ( ( url conn instanceof jar urlconnect ) ) { thi should never happen sm . get string ( context config . jar url , url ) ; return ; } jar conn = ( jar urlconnect ) url conn ; jar conn . set us cach ( fals ) ; url resourc url = jar conn . get jar file url ( ) ; urlconnect resourc conn = resourc url . open connect ( ) ; jar input stream = new jar input stream ( resourc conn . get input stream ( ) ) ; jar entri entri = jar input stream . get next jar entri ( ) ; while ( entri = null ) { string entri name = entri . get name ( ) ; ( entri name . end ( . class ) ) { try { process annot stream ( jar input stream , fragment ) ; } catch ( ioexcept e ) { log . error ( sm . get string ( context config . input stream jar , entri name , url ) , e ) ; } } entri = jar input stream . get next jar entri ( ) ; } } catch ( ioexcept e ) { log . error ( sm . get string ( context config . jar file , url ) , e ) ; } final { ( jar input stream = null ) { try { jar input stream . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } } } }	protect scan jar contain web fragment . xml file us configur thi applic see thei also contain static resourc . static resourc ar found , add them context . resourc ar ad web fragment . xml prioriti order . void process resourc jar ( set web xml fragment ) { ( web xml fragment : fragment ) { url url = fragment . get url ( ) ; jar input stream jar input stream = null ; try { note : ignor file url now sinc onli jar url accept ( jar . equal ( url . get protocol ( ) ) ) { jar urlconnect jar conn = ( jar urlconnect ) url . open connect ( ) ; url resourc url = jar conn . get jar file url ( ) ; urlconnect resourc conn = resourc url . open connect ( ) ; resourc conn . set us cach ( fals ) ; jar input stream = new jar input stream ( resourc conn . get input stream ( ) ) ; jar entri entri = jar input stream . get next jar entri ( ) ; while ( entri = null ) { ( meta inf resourc . equal ( entri . get name ( ) ) ) { break ; } entri = jar input stream . get next jar entri ( ) ; } ( entri = null ) { context . add resourc jar url ( url ) ; } } } catch ( ioexcept ioe ) { log . error ( sm . get string ( context config . resourc jar fail , url , context . get name ( ) ) ) ; } final { ( jar input stream = null ) { try { jar input stream . close ( ) ; } catch ( ioexcept e ) { ignor } } } } }	protect scan jar servlet contain initi implement . implement ad web fragment . xml prioriti order . void process servlet contain initi ( set web xml fragment ) { ( web xml fragment : fragment ) { url url = fragment . get url ( ) ; jar input stream jar input stream = null ; input stream = null ; servlet contain initi sci = null ; try { ( jar . equal ( url . get protocol ( ) ) ) { jar urlconnect jar conn = ( jar urlconnect ) url . open connect ( ) ; url resourc url = jar conn . get jar file url ( ) ; urlconnect resourc conn = resourc url . open connect ( ) ; resourc conn . set us cach ( fals ) ; jar input stream = new jar input stream ( resourc conn . get input stream ( ) ) ; jar entri entri = jar input stream . get next jar entri ( ) ; while ( entri = null ) { ( sci locat . equal ( entri . get name ( ) ) ) { break ; } entri = jar input stream . get next jar entri ( ) ; } ( entri = null ) { = jar input stream ; } } els ( file . equal ( url . get protocol ( ) ) ) { string path = url . get path ( ) ; file file = new file ( path , sci locat ) ; ( file . exist ( ) ) { = new file input stream ( file ) ; } } ( = null ) { sci = get servlet contain initi ( ) ; } } catch ( ioexcept ioe ) { log . error ( sm . get string ( context config . servlet contain initi fail , url , context . get name ( ) ) ) ; ok = fals ; return ; } final { ( = null ) { try { . close ( ) ; } catch ( ioexcept e ) { ignor } } ( jar input stream = null ) { try { jar input stream . close ( ) ; } catch ( ioexcept e ) { ignor } } } ( sci = = null ) { continu ; } initi class map . put ( sci , new hash set class >> ( ) ) ; handl type ht = sci . get class ( ) . get annot ( handl type . class ) ; ( ht = null ) { class type = ht . valu ( ) ; ( type = null ) { ( class type : type ) { set servlet contain initi sci = type initi map . get ( type ) ; ( sci = = null ) { sci = new hash set servlet contain initi ( ) ; type initi map . put ( type , sci ) ; } sci . add ( sci ) ; } } } } }	protect map string , string process annot web init param ( element valu ev ) { map string , string result = new hash map string , string ( ) ; ( ev instanceof arrai element valu ) { element valu arrai valu = ( ( arrai element valu ) ev ) . get element valu arrai ( ) ; ( element valu valu : arrai valu ) { ( valu instanceof annot element valu ) { element valu pair evp = ( ( annot element valu ) valu ) . get annot entri ( ) . get element valu pair ( ) ; string init param name = null ; string init param valu = null ; ( element valu pair evp : evp ) { ( name . equal ( evp . get name string ( ) ) ) { init param name = evp . get valu ( ) . stringifi valu ( ) ; } els ( valu . equal ( evp . get name string ( ) ) ) { init param valu = evp . get valu ( ) . stringifi valu ( ) ; } els { ignor } } result . put ( init param name , init param valu ) ; } } } return result ; }
protect call forward error page param request request we ar process param respons respons we ar popul param config login configur describ how authent should perform throw ioexcept forward error page fail call { link http servlet respons send error ( int , string ) } throw { link ioexcept } void forward error page ( request request , http servlet respons respons , login config config ) throw ioexcept { request dispatch disp = context . get servlet context ( ) . get request dispatch ( config . get error page ( ) ) ; try { ( context . fire request init event ( request ) ) { disp . forward ( request . get request ( ) , respons ) ; context . fire request destroi event ( request ) ; } } catch ( throwabl t ) { except util . handl throwabl ( t ) ; string msg = sm . get string ( form authent . forward error fail ) ; log . warn ( msg , t ) ; request . set attribut ( request dispatch . error except , t ) ; respons . send error ( http servlet respons . sc intern server error , msg ) ; } }	protect call forward login page param request request we ar process param respons respons we ar popul param config login configur describ how authent should perform throw ioexcept forward login page fail call { link http servlet respons send error ( int , string ) } throw { link ioexcept } void forward login page ( request request , http servlet respons respons , login config config ) throw ioexcept { request dispatch disp = context . get servlet context ( ) . get request dispatch ( config . get login page ( ) ) ; try { ( context . fire request init event ( request ) ) { disp . forward ( request . get request ( ) , respons ) ; context . fire request destroi event ( request ) ; } } catch ( throwabl t ) { except util . handl throwabl ( t ) ; string msg = sm . get string ( form authent . forward login fail ) ; log . warn ( msg , t ) ; request . set attribut ( request dispatch . error except , t ) ; respons . send error ( http servlet respons . sc intern server error , msg ) ; } }
protect counter latch initi connect latch ( ) { ( connect counter latch = = null ) { connect counter latch = new counter latch ( 0 , get max connect ( ) ) ; } return connect counter latch ; }	protect long count down connect ( ) { counter latch latch = connect counter latch ; ( latch = null ) { long result = latch . count down ( ) ; ( result 0 ) { get log ( ) . warn ( incorrect connect count , multipl socket . close call same socket . ) ; } return result ; } els return 1 ; }	protect void await connect ( ) throw interrupt except { counter latch latch = connect counter latch ; ( latch = null ) latch . await ( ) ; }	protect void releas connect latch ( ) { counter latch latch = connect counter latch ; ( latch = null ) latch . releas all ( ) ; connect counter latch = null ; }	public int get max connect ( ) { return thi . max connect ; }	public string adjust rel path ( string path , string rel ) { string new path = path ; file f = new file ( new path ) ; ( f . absolut ( ) ) { new path = rel file . separ new path ; f = new file ( new path ) ; } ( f . exist ( ) ) { get log ( ) . warn ( configur file : new path doe exist . ) ; } return new path ; }	protect log get log ( ) { return log ; }	protect log get log ( ) { return log ; }
protect find potenti memori leak caus web applic reload . see manag servlet findleak ( print writer , string manag ) param sm client string manag client s local return messag string string findleak ( string manag sm client ) { string builder msg = new string builder ( ) ; string writer string writer = new string writer ( ) ; print writer print writer = new print writer ( string writer ) ; super . findleak ( print writer , sm client ) ; ( string writer . get buffer ( ) . length ( ) 0 ) { msg . append ( sm client . get string ( html manag servlet . findleak list ) ) ; msg . append ( string writer . string ( ) ) ; } els { msg . append ( sm client . get string ( html manag servlet . findleak none ) ) ; } return msg . string ( ) ; }	protect find potenti memori leak caus web applic reload . void findleak ( print writer writer , string manag sm client ) { ( ( host instanceof standard host ) ) { writer . println ( sm client . get string ( manag servlet . findleak fail ) ) ; return ; } string result = ( ( standard host ) host ) . find reload context memori leak ( ) ; ( string result : result ) { ( . equal ( result ) ) { result = ; } writer . println ( result ) ; } }	process get request specifi resourc . param request servlet request we ar process param respons servlet respons we ar creat except ioexcept input output error occur except servlet except servlet specifi error occur overrid public void do get ( http servlet request request , http servlet respons respons ) throw ioexcept , servlet except { string manag sm client = get string manag ( request ) ; identifi request paramet we need string command = request . get path info ( ) ; ( command = = null ) command = request . get servlet path ( ) ; string config = request . get paramet ( config ) ; string path = request . get paramet ( path ) ; context name cn = null ; ( path = null ) { cn = new context name ( path , request . get paramet ( version ) ) ; } string type = request . get paramet ( type ) ; string war = request . get paramet ( war ) ; string tag = request . get paramet ( tag ) ; boolean updat = fals ; ( ( request . get paramet ( updat ) = null ) ( request . get paramet ( updat ) . equal ( true ) ) ) { updat = true ; } prepar our output writer gener respons messag respons . set content type ( text plain ; charset = constant . charset ) ; print writer writer = respons . get writer ( ) ; process request command ( note deploi list here ) ( command = = null ) { writer . println ( sm client . get string ( manag servlet . command ) ) ; } els ( command . equal ( deploi ) ) { ( war = null config = null ) { deploi ( writer , config , cn , war , updat , sm client ) ; } els { deploi ( writer , cn , tag , sm client ) ; } } els ( command . equal ( list ) ) { list ( writer , sm client ) ; } els ( command . equal ( reload ) ) { reload ( writer , cn , sm client ) ; } els ( command . equal ( resourc ) ) { resourc ( writer , type , sm client ) ; } els ( command . equal ( save ) ) { save ( writer , path , sm client ) ; } els ( command . equal ( serverinfo ) ) { serverinfo ( writer , sm client ) ; } els ( command . equal ( session ) ) { expir session ( writer , cn , request , sm client ) ; } els ( command . equal ( expir ) ) { expir session ( writer , cn , request , sm client ) ; } els ( command . equal ( start ) ) { start ( writer , cn , sm client ) ; } els ( command . equal ( stop ) ) { stop ( writer , cn , sm client ) ; } els ( command . equal ( undeploi ) ) { undeploi ( writer , cn , sm client ) ; } els ( command . equal ( findleak ) ) { findleak ( writer , sm client ) ; } els { writer . println ( sm client . get string ( manag servlet . unknown command , command ) ) ; } finish up respons writer . flush ( ) ; writer . close ( ) ; }	initi thi servlet . overrid public void init ( ) throw servlet except { ensur our contain servlet properti have been set ( ( wrapper = = null ) ( context = = null ) ) throw new unavail except ( sm . get string ( manag servlet . wrapper ) ) ; set our properti from initi paramet string valu = null ; try { valu = get servlet config ( ) . get init paramet ( debug ) ; debug = integ . pars int ( valu ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } acquir global jndi resourc avail server server = ( ( engin ) host . get parent ( ) ) . get servic ( ) . get server ( ) ; ( server = null ) { global = server . get global name context ( ) ; } calcul directori which we deploi applic version = ( file ) get servlet context ( ) . get attribut ( servlet context . tempdir ) ; identifi app base own host thi context ( ani ) string app base = ( ( host ) context . get parent ( ) ) . get app base ( ) ; deploi = new file ( app base ) ; ( deploi . absolut ( ) ) { deploi = new file ( system . get properti ( global . catalina base prop ) , app base ) ; } config base = new file ( system . get properti ( global . catalina base prop ) , conf ) ; contain contain = context ; contain host = null ; contain engin = null ; while ( contain = null ) { ( contain instanceof host ) host = contain ; ( contain instanceof engin ) engin = contain ; contain = contain . get parent ( ) ; } ( engin = null ) { config base = new file ( config base , engin . get name ( ) ) ; } ( host = null ) { config base = new file ( config base , host . get name ( ) ) ; } log debug messag necessari ( debug = 1 ) { log ( init : associ deploy onam ) ; ( global = null ) { log ( init : global resourc ar avail ) ; } } }
enforc secur restrict web applic deploy descriptor our associ context . param request request process param respons respons process except ioexcept input output error occur except servlet except thrown process element overrid public void invok ( request request , respons respons ) throw ioexcept , servlet except { ( log . debug enabl ( ) ) log . debug ( secur check request request . get method ( ) request . get request uri ( ) ) ; login config config = thi . context . get login config ( ) ; have we got cach authent princip record ( cach ) { princip princip = request . get user princip ( ) ; ( princip = = null ) { session session = request . get session intern ( fals ) ; ( session = null ) { princip = session . get princip ( ) ; ( princip = null ) { ( log . debug enabl ( ) ) log . debug ( we have cach auth type session . get auth type ( ) princip session . get princip ( ) ) ; request . set auth type ( session . get auth type ( ) ) ; request . set user princip ( princip ) ; } } } } special handl form base login deal case where login form ( therefor j secur check uri which submit ) might outsid secur area string context path = thi . context . get path ( ) ; string request uri = request . get decod request uri ( ) ; ( request uri . start ( context path ) request uri . end ( constant . form action ) ) { ( authent ( request , respons , config ) ) { ( log . debug enabl ( ) ) log . debug ( fail authent ( ) test request uri ) ; return ; } } servlet mai specifi secur constraint through annot . ensur thei have been process befor constraint ar check wrapper wrapper = ( wrapper ) request . get map data ( ) . wrapper ; ( wrapper = null ) { wrapper . servlet secur annot scan ( ) ; } realm realm = thi . context . get realm ( ) ; thi request uri subject secur constraint secur constraint constraint = realm . find secur constraint ( request , thi . context ) ; ( constraint = = null context . get preemptiv authent ( ) ) { ( log . debug enabl ( ) ) log . debug ( subject ani constraint ) ; get next ( ) . invok ( request , respons ) ; return ; } browser cach can provid secur hole ( constraint = null disabl proxi cach request . secur ( ) post . equal ignor case ( request . get method ( ) ) ) { ( secur page pragma ) { fixm : caus problem download offic doc from ie under ssl mai need newer mozilla client . respons . set header ( pragma , cach ) ; respons . set header ( cach control , cach ) ; } els { respons . set header ( cach control , privat ) ; } respons . set header ( expir , date ) ; } int i ; ( constraint = null ) { enforc ani user data constraint thi secur constraint ( log . debug enabl ( ) ) { log . debug ( call ha user data permiss ( ) ) ; } ( realm . ha user data permiss ( request , respons , constraint ) ) { ( log . debug enabl ( ) ) { log . debug ( fail ha user data permiss ( ) test ) ; } assert : authent alreadi set appropri http statu code , so we do have do anyth special return ; } } sinc authent modifi respons failur , we have check allow from all first . boolean auth requir ; ( constraint = = null ) { auth requir = fals ; } els { auth requir = true ; ( i = 0 ; i constraint . length auth requir ; i ) { ( constraint i . get auth constraint ( ) ) { auth requir = fals ; } els ( constraint i . get all role ( ) ) { string role = constraint i . find auth role ( ) ; ( role = = null role . length = = 0 ) { auth requir = fals ; } } } } ( auth requir ) { auth requir = request . get coyot request ( ) . get mime header ( ) . get valu ( author ) = null ; } ( auth requir ) { x509certif cert = ( x509certif ) request . get attribut ( global . certif attr ) ; auth requir = cert = null cert . length 0 ; } ( auth requir ) { ( log . debug enabl ( ) ) { log . debug ( call authent ( ) ) ; } ( authent ( request , respons , config ) ) { ( log . debug enabl ( ) ) { log . debug ( fail authent ( ) test ) ; } assert : authent alreadi set appropri http statu code , so we do have do anyth special return ; } } ( constraint = null ) { ( log . debug enabl ( ) ) { log . debug ( call access control ( ) ) ; } ( realm . ha resourc permiss ( request , respons , constraint , thi . context ) ) { ( log . debug enabl ( ) ) { log . debug ( fail access control ( ) test ) ; } assert : access control method ha alreadi set appropri http statu code , so we do have do anyth special return ; } } ani all specifi constraint have been satisfi ( log . debug enabl ( ) ) { log . debug ( successfulli pass all secur constraint ) ; } get next ( ) . invok ( request , respons ) ; }
public pool configur get pool properti ( ) { return pool properti ; }
public process start event thi host . void start ( ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( host config . start ) ) ; try { object name host = host . get object name ( ) ; onam = new object name ( host . get domain ( ) : type = deploy , host = host . get name ( ) ) ; registri . get registri ( null , null ) . regist compon ( thi , onam , thi . get class ( ) . get name ( ) ) ; } catch ( except e ) { log . error ( sm . get string ( host config . jmx . regist , onam ) , e ) ; } ( host . get creat dir ( ) ) { file dir = new file { app base ( ) , config base ( ) } ; ( int i = 0 ; i dir . length ; i ) { ( ( dir i . exist ( ) ) ( dir i . mkdir ( ) ) ) { log . error ( sm . get string ( host config . creat dir , dir i ) ) ; } } } ( host . get deploi startup ( ) ) deploi app ( ) ; }
privat gener end part static portion servlet . void gener postambl ( ) { out . pop indent ( ) ; out . printil ( } catch ( java . lang . throwabl t ) { ) ; out . push indent ( ) ; out . printil ( ( ( t instanceof javax . servlet . jsp . skip page except ) ) { ) ; out . push indent ( ) ; out . printil ( out = jspx out ; ) ; out . printil ( ( out = null out . get buffer size ( ) = 0 ) ) ; out . push indent ( ) ; out . printil ( try { out . clear buffer ( ) ; } catch ( java . io . ioexcept e ) { } ) ; out . pop indent ( ) ; out . printil ( ( jspx page context = null ) jspx page context . handl page except ( t ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; out . pop indent ( ) ; out . printil ( } final { ) ; out . push indent ( ) ; out . printil ( jspx factori . releas page context ( jspx page context ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; close servic method out . pop indent ( ) ; out . printil ( } ) ; gener method , helper class , etc . gen common postambl ( ) ; }
protect void servic ( final http servlet request req , final http servlet respons resp ) throw servlet except , ioexcept { ( boolean . true = = req . get attribut ( dispatch ) ) { log . info ( receiv dispatch , complet worker thread . ) ; req . get async context ( ) . complet ( ) ; log . info ( after complet call start : req . async start ( ) ) ; resp . get writer ( ) . write ( async dispatch work : system . current time milli ( ) n ) ; } els { resp . set content type ( text plain ) ; final async context actx = req . start async ( ) ; actx . set timeout ( long . max valu ) ; runnabl run = new runnabl ( ) { overrid } } }
overrid public void set properti ( map string , interceptor properti properti ) { super . set properti ( properti ) ; final string threshold = threshold ; final string maxqueri = max queri ; interceptor properti p1 = properti . get ( threshold ) ; interceptor properti p2 = properti . get ( maxqueri ) ; ( p1 = null ) { set threshold ( long . pars long ( p1 . get valu ( ) ) ) ; } ( p2 = null ) { set max queri ( integ . pars int ( p2 . get valu ( ) ) ) ; } }
public interceptor definit get jdbc interceptor arrai ( ) { ( interceptor = = null ) { ( jdbc interceptor = = null ) { interceptor = new interceptor definit 0 ; } els { string interceptor valu = jdbc interceptor . split ( ; ) ; interceptor definit definit = new interceptor definit interceptor valu . length 1 ; alwai add trap interceptor mix definit 0 = new interceptor definit ( trap except . class ) ; ( int i = 0 ; i interceptor valu . length ; i ) { int prop index = interceptor valu i . index ( ( ) ; int end index = interceptor valu i . index ( ) ) ; ( prop index 0 end index 0 end index = prop index ) { definit i 1 = new interceptor definit ( interceptor valu i . trim ( ) ) ; } els { string name = interceptor valu i . substr ( 0 , prop index ) . trim ( ) ; definit i 1 = new interceptor definit ( name ) ; string prop string = interceptor valu i . substr ( prop index 1 , interceptor valu i . length ( ) 1 ) ; string prop = prop string . split ( , ) ; ( int j = 0 ; j prop . length ; j ) { int pidx = prop j . index ( = ) ; string prop name = prop j . substr ( 0 , pidx ) . trim ( ) ; string prop valu = prop j . substr ( pidx 1 ) . trim ( ) ; definit i . add properti ( new interceptor properti ( prop name , prop valu ) ) ; } } } interceptor = definit ; } } return interceptor ; }
protect compar session get compar ( string sort ) { compar session compar = null ; ( creation time . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session . get creation time ( ) ) ; } } ; } els ( id . equal ignor case ( sort ) ) { compar = new base session compar string ( ) { overrid public compar string get compar object ( session session ) { return session . get id ( ) ; } } ; } els ( last access time . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session . get last access time ( ) ) ; } } ; } els ( max inact interv . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session . get max inact interv ( ) ) ; } } ; } els ( new . equal ignor case ( sort ) ) { compar = new base session compar boolean ( ) { overrid public compar boolean get compar object ( session session ) { return boolean . valu ( session . get session ( ) . new ( ) ) ; } } ; } els ( local . equal ignor case ( sort ) ) { compar = new base session compar string ( ) { overrid public compar string get compar object ( session session ) { return jsp helper . guess displai local from session ( session ) ; } } ; } els ( user . equal ignor case ( sort ) ) { compar = new base session compar string ( ) { overrid public compar string get compar object ( session session ) { return jsp helper . guess displai user from session ( session ) ; } } ; } els ( us time . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session util . get us time session ( session ) ) ; } } ; } els ( inact time . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session util . get inact time session ( session ) ) ; } } ; } els ( ttl . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session util . get ttlfor session ( session ) ) ; } } ; } todo : complet thi ttl , etc . return compar ; }


protect void remov attribut intern ( string name , boolean notifi , boolean add delta request ) { try { lock ( ) ; remov thi attribut from our collect object valu = attribut . get ( name ) ; ( valu = = null ) return ; super . remov attribut intern ( name , notifi ) ; ( add delta request ( delta request = null ) ) delta request . remov attribut ( name ) ; } final { unlock ( ) ; } }	public void set attribut ( string name , object valu , boolean notifi , boolean add delta request ) { name cannot null ( name = = null ) throw new illeg argument except ( sm . get string ( standard session . set attribut . namenul ) ) ; null valu same remov attribut ( ) ( valu = = null ) { remov attribut ( name ) ; return ; } try { lock ( ) ; super . set attribut ( name , valu , notifi ) ; ( add delta request ( delta request = null ) ) delta request . set attribut ( name , valu ) ; } final { unlock ( ) ; } }
public boolean authent ( request request , http servlet respons respons , login config config ) throw ioexcept { have we alreadi authent someon princip princip = request . get user princip ( ) ; string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( princip = null ) { ( log . debug enabl ( ) ) log . debug ( alreadi authent princip . get name ( ) ) ; associ session ani exist sso session ( sso id = null ) associ ( sso id , request . get session intern ( true ) ) ; return true ; } sso session against which we can try reauthent ( sso id = null ) { ( log . debug enabl ( ) ) log . debug ( sso id sso id set ; attempt reauthent ) ; try reauthent us data cach sso . thi fail , either origin sso logon wa digest ssl ( which we can t reauthent ourselv becaus cach usernam password ) , realm deni user s reauthent some reason . either case we have prompt user logon ( reauthent from sso ( sso id , request ) ) return true ; } messag byte author = request . get coyot request ( ) . get mime header ( ) . get valu ( author ) ; ( author = = null ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( authent . auth header ) ) ; } respons . set header ( www authent , negoti ) ; respons . send error ( http servlet respons . sc unauthor ) ; return fals ; } author . byte ( ) ; byte chunk author bc = author . get byte chunk ( ) ; ( author bc . start ignor case ( negoti , 0 ) ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( spnego authent . auth header nego ) ) ; } respons . set header ( www authent , negoti ) ; respons . send error ( http servlet respons . sc unauthor ) ; return fals ; } author bc . set offset ( author bc . get offset ( ) 10 ) ; fixm : add trim author bc . trim ( ) ; byte chunk decod = new byte chunk ( ) ; base64 . decod ( author bc , decod ) ; ( decod . get length ( ) = = 0 ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( spnego authent . auth header token ) ) ; } respons . set header ( www authent , negoti ) ; respons . send error ( http servlet respons . sc unauthor ) ; return fals ; } login context lc = null ; gsscontext gss context = null ; byte out token = null ; try { try { lc = new login context ( login config name ) ; lc . login ( ) ; } catch ( login except e ) { log . error ( sm . get string ( spnego authent . servic login fail ) , e ) ; respons . send error ( http servlet respons . sc intern server error ) ; return fals ; } assum gsscontext stateless todo : confirm thi assumpt gssmanag manag = gssmanag . get instanc ( ) ; gss context = manag . creat context ( manag . creat credenti ( null , gsscredenti . default lifetim , new oid ( 1 . 3 . 6 . 1 . 5 . 5 . 2 ) , gsscredenti . accept onli ) ) ; out token = gss context . accept sec context ( decod . get byte ( ) , decod . get offset ( ) , decod . get length ( ) ) ; ( out token = = null ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( spnego authent . ticket valid fail ) ) ; } start again respons . set header ( www authent , negoti ) ; respons . send error ( http servlet respons . sc unauthor ) ; return fals ; } princip = context . get realm ( ) . authent ( gss context , store deleg credenti ) ; } catch ( gssexcept e ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( spnego authent . ticket valid fail , e ) ) ; } respons . set header ( www authent , negoti ) ; respons . send error ( http servlet respons . sc unauthor ) ; return fals ; } final { ( gss context = null ) { try { gss context . dispos ( ) ; } catch ( gssexcept e ) { ignor } } ( lc = null ) { try { lc . logout ( ) ; } catch ( login except e ) { ignor } } } send respons token success failur respons . set header ( www authent , negoti base64 . encod ( out token ) ) ; ( princip = null ) { regist ( request , respons , princip , constant . spnego method , princip . get name ( ) , null ) ; return true ; } respons . send error ( http servlet respons . sc unauthor ) ; return fals ; }
privat void init ( ) { get all other paramet requir from standard system properti . onli need get paramet affect creation server port . string rmi sslvalu = system . get properti ( com . sun . manag . jmxremot . ssl , true ) ; rmi ssl = boolean . pars boolean ( rmi sslvalu ) ; string protocol valu = system . get properti ( com . sun . manag . jmxremot . ssl . enabl . protocol ) ; ( protocol valu = null ) { protocol = protocol valu . split ( , ) ; } string cipher valu = system . get properti ( com . sun . manag . jmxremot . ssl . enabl . cipher . suit ) ; ( cipher valu = null ) { cipher = cipher valu . split ( , ) ; } string client auth valu = system . get properti ( com . sun . manag . jmxremot . ssl . need . client . auth , true ) ; client auth = boolean . pars boolean ( client auth valu ) ; string authent valu = system . get properti ( com . sun . manag . jmxremot . authent , true ) ; authent = boolean . pars boolean ( authent valu ) ; password file = system . get properti ( com . sun . manag . jmxremot . password . file , jmxremot . password ) ; access file = system . get properti ( com . sun . manag . jmxremot . access . file , jmxremot . access ) ; }	overrid public void lifecycl event ( lifecycl event event ) { when server start , configur jmx rmi ( lifecycl . start event = = event . get type ( ) ) { configur us standard jmx system properti init ( ) ; prevent attack guess rmi object id system . set properti ( java . rmi . server . random id , true ) ; creat environ hash map string , object env = new hash map string , object ( ) ; rmiclient socket factori csf = null ; rmiserv socket factori ssf = null ; configur ssl rmi connect requir ( rmi ssl ) { csf = new ssl rmiclient socket factori ( ) ; ssf = new ssl rmiserv socket factori ( cipher , protocol , client auth ) ; } forc us local port requir ( us local port ) { csf = new rmi client localhost socket factori ( csf ) ; } popul env properti us creat server ( csf = null ) { env . put ( rmiconnector server . rmi client socket factori attribut , csf ) ; } ( ssf = null ) { env . put ( rmiconnector server . rmi server socket factori attribut , ssf ) ; } configur authent ( authent ) { env . put ( jmx . remot . x . password . file , password file ) ; env . put ( jmx . remot . x . access . file , access file ) ; } creat platform server cs platform = creat server ( platform , rmi registri port platform , rmi server port platform , env , manag factori . get platform mbean server ( ) ) ; } els ( lifecycl . stop event = = event . get type ( ) ) { destroi server ( platform , cs platform ) ; } }
privat realloc buffer sinc spec requir unbound . void re alloc buff ( int len ) { ( buffer size len = cb . length ) { buffer size = cb . length ; return ; } ( len cb . length ) { len = cb . length ; } buffer size = cb . length len ; char tmp = new char buffer size ; system . arraycopi ( cb , 0 , tmp , 0 , cb . length ) ; cb = tmp ; tmp = null ; }	clear content buffer . buffer ha been alreadi been flush clear oper shall throw ioexcept signal fact some data ha alreadi been irrevoc written client respons stream . throw ioexcept i o error occur overrid public void clear ( ) throw ioexcept { ( writer = null ) { throw new ioexcept ( ) ; } els { next char = 0 ; ( limit buffer ( cb . length constant . default tag buffer size ) ) { buffer size = constant . default tag buffer size ; cb = new char buffer size ; } } }
public context add context ( host host , string context path , string dir ) { silenc ( context path ) ; context ctx = new standard context ( ) ; ctx . set path ( context path ) ; ctx . set doc base ( dir ) ; ctx . add lifecycl listen ( new fix context listen ( ) ) ; ( host = = null ) { get host ( ) . add child ( ctx ) ; } els { host . add child ( ctx ) ; } return ctx ; }	public context add webapp ( host host , string url , string path ) { silenc ( url ) ; context ctx = new standard context ( ) ; ctx . set path ( url ) ; ctx . set doc base ( path ) ; ( default realm = = null ) { init simpl auth ( ) ; } ctx . set realm ( default realm ) ; ctx . add lifecycl listen ( new default web xml listen ( ) ) ; context config ctx cfg = new context config ( ) ; ctx . add lifecycl listen ( ctx cfg ) ; prevent from look ( find ll have dup error ) ctx cfg . set default web xml ( org apach catalin startup default xml ) ; ( host = = null ) { get host ( ) . add child ( ctx ) ; } els { host . add child ( ctx ) ; } return ctx ; }
protect log get log ( ) { return log ; }
initi endpoint . overrid public void bind ( ) throw except { creat root apr memori pool try { root pool = pool . creat ( 0 ) ; } catch ( unsatisfi link error e ) { throw new except ( sm . get string ( endpoint . init . notavail ) ) ; } creat pool server socket server sock pool = pool . creat ( root pool ) ; creat apr address bound string address str = null ; ( get address ( ) = null ) { address str = get address ( ) . get host address ( ) ; } int famili = socket . apr inet ; ( librari . apr have ipv6 ) { ( address str = = null ) { ( os . bsd os . win32 os . win64 ) famili = socket . apr unspec ; } els ( address str . index ( : ) = 0 ) { famili = socket . apr unspec ; } } long inet address = address . info ( address str , famili , get port ( ) , 0 , root pool ) ; creat apr server socket server sock = socket . creat ( address . get info ( inet address ) . famili , socket . sock stream , socket . apr proto tcp , root pool ) ; ( os . unix ) { socket . opt set ( server sock , socket . apr so reuseaddr , 1 ) ; } deal firewal tend drop inact socket socket . opt set ( server sock , socket . apr so keepal , 1 ) ; bind server socket int ret = socket . bind ( server sock , inet address ) ; ( ret = 0 ) { throw new except ( sm . get string ( endpoint . init . bind , ret , error . strerror ( ret ) ) ) ; } start listen server socket ret = socket . listen ( server sock , get backlog ( ) ) ; ( ret = 0 ) { throw new except ( sm . get string ( endpoint . init . listen , ret , error . strerror ( ret ) ) ) ; } ( os . win32 os . win64 ) { window set reuseaddr flag after bind listen socket . opt set ( server sock , socket . apr so reuseaddr , 1 ) ; } sendfil usag system which don t support caus major problem ( us sendfil librari . apr ha sendfil ) { us sendfil = fals ; } initi thread count default acceptor , poller sendfil ( acceptor thread count = = 0 ) { fixm : doesn t seem work well multipl accept thread acceptor thread count = 1 ; } ( poller thread count = = 0 ) { ( ( os . win32 os . win64 ) ( poller size 1024 ) ) { maximum per poller get reason perform 1024 poller thread count = poller size 1024 ; adjust poller size so won t reach limit poller size = poller size ( poller size 1024 ) ; } els { explicit poller size limit poller thread count = 1 ; } } ( sendfil thread count = = 0 ) { ( ( os . win32 os . win64 ) ( sendfil size 1024 ) ) { maximum per poller get reason perform 1024 sendfil thread count = sendfil size 1024 ; adjust poller size so won t reach limit sendfil size = sendfil size ( sendfil size 1024 ) ; } els { explicit poller size limit fixm : default per cpu sendfil thread count = 1 ; } } other platform thi call noop return apr enotimpl . ( defer accept ) { ( socket . opt set ( server sock , socket . apr tcp defer accept , 1 ) = = statu . apr enotimpl ) { defer accept = fals ; } } initi ssl need ( sslenabl ( ) ) { ( sslcertif file = = null ) { thi requir throw new except ( sm . get string ( endpoint . apr . ssl cert file ) ) ; } ssl protocol int valu = ssl . ssl protocol all ; ( sslv2 . equal ignor case ( sslprotocol ) ) { valu = ssl . ssl protocol sslv2 ; } els ( sslv3 . equal ignor case ( sslprotocol ) ) { valu = ssl . ssl protocol sslv3 ; } els ( tlsv1 . equal ignor case ( sslprotocol ) ) { valu = ssl . ssl protocol tlsv1 ; } els ( sslv2 sslv3 . equal ignor case ( sslprotocol ) ) { valu = ssl . ssl protocol sslv2 ssl . ssl protocol sslv3 ; } creat ssl context ssl context = sslcontext . make ( root pool , valu , ssl . ssl mode server ) ; ( sslinsecur renegoti ) { boolean legaci reneg support = fals ; try { legaci reneg support = ssl . ha op ( ssl . ssl op allow unsaf legaci renegoti ) ; ( legaci reneg support ) sslcontext . set option ( ssl context , ssl . ssl op allow unsaf legaci renegoti ) ; } catch ( unsatisfi link error e ) { ignor } ( legaci reneg support ) { open ssl doe support unsaf legaci renegoti . log . warn ( sm . get string ( endpoint . warn . insecur reneg , ssl . version string ( ) ) ) ; } } list cipher client permit negoti sslcontext . set cipher suit ( ssl context , sslcipher suit ) ; load server kei certif sslcontext . set certif ( ssl context , sslcertif file , sslcertif kei file , sslpassword , ssl . ssl aidx rsa ) ; set certif chain file sslcontext . set certif chain file ( ssl context , sslcertif chain file , fals ) ; support client certif sslcontext . set cacertif ( ssl context , sslcacertif file , sslcacertif path ) ; set revoc sslcontext . set carevoc ( ssl context , sslcarevoc file , sslcarevoc path ) ; client certif verif valu = ssl . ssl cverifi none ; ( option . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi option ; } els ( requir . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi requir ; } els ( option ca . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi option ca ; } sslcontext . set verifi ( ssl context , valu , sslverifi depth ) ; now , sendfil support ssl us sendfil = fals ; } }
protect chang session id send all cluster node param request current request param session id origin session id param new session id new session id node migrat param catalina session current session origin session id void chang session id ( request request , string session id , string new session id , session catalina session ) { fire lifecycl event ( befor session migrat , catalina session ) ; fixm : set id trigger session listen , onli chanc regist manag correct id catalina session . set id ( new session id ) ; set id also trigger reset delta request ( catalina session instanceof delta session ) ( ( delta session ) catalina session ) . reset delta request ( ) ; chang request session id ( request , session id , new session id ) ; now send chang all other clusternod send session idclust backup ( request , session id , new session id ) ; fire lifecycl event ( after session migrat , catalina session ) ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jvm rout . chang session , session id , new session id ) ) ; } }	protect handl receiv chang session id other node param msg param sender throw ioexcept void handl chang session id ( session messag msg , member sender ) throw ioexcept { counter receiv evt chang session id ; delta session session = ( delta session ) find session ( msg . get session id ( ) ) ; ( session = null ) { string new session id = deseri session id ( msg . get session ( ) ) ; session . set primari session ( fals ) ; ( notifi session listen replic ) { session . set id ( new session id ) ; } els { session . set id intern ( new session id ) ; add ( session ) ; } } }	protect handl receiv new session creat other node ( creat backup primari fals ) param msg param sender void handl session creat ( session messag msg , member sender ) { counter receiv evt session creat ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( delta manag . receiv messag . creat new session , get name ( ) , msg . get session id ( ) ) ) ; delta session session = ( delta session ) creat empti session ( ) ; session . set manag ( thi ) ; session . set valid ( true ) ; session . set primari session ( fals ) ; session . set creation time ( msg . get timestamp ( ) ) ; us contain max inact interv so session expir correctli case primari transfer session . set max inact interv ( get max inact interv ( ) ) ; session . access ( ) ; ( notifi session listen replic ) { session . set id ( msg . get session id ( ) ) ; } els { session . set id intern ( msg . get session id ( ) ) ; add ( session ) ; } session . reset delta request ( ) ; session . end access ( ) ; }	chang session id current session new randomli gener session id . param session session chang session id overrid public void chang session id ( session session ) { session . set id ( gener session id ( ) ) ; }	overrid public void set id ( string id ) { thi . session id = id ; }	set session identifi thi session . param id new session identifi overrid public void set id ( string id ) { ( ( thi . id = null ) ( manag = null ) ) manag . remov ( thi ) ; thi . id = id ; ( manag = null ) manag . add ( thi ) ; tell new ( ) ; }	public set session identifi thi session without notifi listen . param id new session identifi void set id intern ( string id ) { thi . id = id ; reset delta request ( ) ; }	set whether thi primari session . param primari session flag valu overrid public void set primari session ( boolean primari session ) { thi . primari session = primari session ; }
privat void do test dispatch ( int iter , boolean us thread ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; dispatch servlet dispatch = new dispatch servlet ( fals , fals ) ; wrapper wrapper = tomcat . add servlet ( ctx , dispatch , dispatch ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( stage1 , dispatch ) ; non async servlet nonasync = new non async servlet ( ) ; wrapper wrapper2 = tomcat . add servlet ( ctx , nonasync , nonasync ) ; wrapper2 . set async support ( true ) ; ctx . add servlet map ( stage2 , nonasync ) ; ctx . add applic listen ( track request listen . class . get name ( ) ) ; tomcat . start ( ) ; string builder url = new string builder ( 48 ) ; url . append ( http : localhost : ) ; url . append ( get port ( ) ) ; url . append ( stage1 iter = ) ; url . append ( iter ) ; ( us thread ) { url . append ( us thread = y ) ; } byte chunk re = get url ( url . string ( ) ) ; string builder expect = new string builder ( request initi ) ; int loop = iter ; while ( loop 0 ) { expect . append ( dispatch servlet get ) ; loop ; } expect . append ( non async servlet get ) ; expect . append ( request destroi ) ; assert equal ( expect . string ( ) , re . string ( ) ) ; }	privat void do test dispatch error ( int iter , boolean us thread , boolean complet error ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; dispatch servlet dispatch = new dispatch servlet ( true , complet error ) ; wrapper wrapper = tomcat . add servlet ( ctx , dispatch , dispatch ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( stage1 , dispatch ) ; error servlet error = new error servlet ( ) ; tomcat . add servlet ( ctx , error , error ) ; ctx . add servlet map ( stage2 , error ) ; ctx . add applic listen ( track request listen . class . get name ( ) ) ; tomcat . start ( ) ; string builder url = new string builder ( 48 ) ; url . append ( http : localhost : ) ; url . append ( get port ( ) ) ; url . append ( stage1 iter = ) ; url . append ( iter ) ; ( us thread ) { url . append ( us thread = y ) ; } byte chunk re = get url ( url . string ( ) ) ; string builder expect = new string builder ( request initi ) ; int loop = iter ; while ( loop 0 ) { expect . append ( dispatch servlet get ) ; ( loop = iter ) { expect . append ( start async ) ; } loop ; } expect . append ( error servlet get error complet request destroi ) ; assert equal ( expect . string ( ) , re . string ( ) ) ; }	privat void do test timeout ( boolean complet timeout , string dispatch url ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; creat folder trigger redirect file foo = new file ( doc base , async ) ; ( foo . exist ( ) foo . mkdir ( ) ) { fail ( unabl creat async directori doc base ) ; } context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; timeout servlet timeout = new timeout servlet ( complet timeout , dispatch url ) ; wrapper wrapper = tomcat . add servlet ( ctx , time , timeout ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( async , time ) ; ( dispatch url = null ) { non async servlet non async = new non async servlet ( ) ; tomcat . add servlet ( ctx , nonasync , non async ) ; ctx . add servlet map ( dispatch url , nonasync ) ; } ctx . add applic listen ( track request listen . class . get name ( ) ) ; tomcat . start ( ) ; byte chunk re = get url ( http : localhost : get port ( ) async ) ; string builder expect = new string builder ( request initi ) ; expect . append ( timeout servlet get timeout ) ; ( complet timeout ) { expect . append ( error ) ; } ( dispatch url = = null ) { expect . append ( complet ) ; } els { expect . append ( non async servlet get ) ; } expect . append ( request destroi ) ; assert equal ( expect . string ( ) , re . string ( ) ) ; }	privat void do test dispatch error ( int iter , boolean us thread , boolean complet error ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; dispatch servlet dispatch = new dispatch servlet ( true , complet error ) ; wrapper wrapper = tomcat . add servlet ( ctx , dispatch , dispatch ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( stage1 , dispatch ) ; error servlet error = new error servlet ( ) ; tomcat . add servlet ( ctx , error , error ) ; ctx . add servlet map ( stage2 , error ) ; ctx . add applic listen ( track request listen . class . get name ( ) ) ; tomcat . start ( ) ; string builder url = new string builder ( 48 ) ; url . append ( http : localhost : ) ; url . append ( get port ( ) ) ; url . append ( stage1 iter = ) ; url . append ( iter ) ; ( us thread ) { url . append ( us thread = y ) ; } byte chunk re = get url ( url . string ( ) ) ; string builder expect = new string builder ( request initi ) ; int loop = iter ; while ( loop 0 ) { expect . append ( dispatch servlet get ) ; ( loop = iter ) { expect . append ( start async ) ; } loop ; } expect . append ( error servlet get error complet request destroi ) ; assert equal ( expect . string ( ) , re . string ( ) ) ; }	overrid protect void do get ( final http servlet request req , final http servlet respons resp ) throw servlet except , ioexcept { result = new string builder ( ) ; result . append ( 1 ) ; result . append ( req . async start ( ) ) ; req . start async ( ) . set timeout ( 10000 ) ; result . append ( 2 ) ; result . append ( req . async start ( ) ) ; req . get async context ( ) . start ( new runnabl ( ) { overrid public void run ( ) { try { result . append ( 3 ) ; result . append ( req . async start ( ) ) ; thread . sleep ( 1000 ) ; result . append ( 4 ) ; result . append ( req . async start ( ) ) ; resp . set content type ( text plain ) ; resp . get writer ( ) . print ( ok ) ; req . get async context ( ) . complet ( ) ; result . append ( 5 ) ; result . append ( req . async start ( ) ) ; done = true ; } catch ( interrupt except e ) { result . append ( e ) ; } catch ( ioexcept e ) { result . append ( e ) ; } } } ) ; pointless method call so somewher put break point when debug req . get method ( ) ; }	overrid public boolean async dispatch ( org . apach . coyot . request req , org . apach . coyot . respons re , socket statu statu ) throw except { request request = ( request ) req . get note ( adapt note ) ; respons respons = ( respons ) re . get note ( adapt note ) ; ( request = = null ) { throw new illeg state except ( dispatch mai onli happen exist request . ) ; } boolean comet = fals ; boolean success = true ; async context impl async con impl = ( async context impl ) request . get async context ( ) ; try { ( request . async ( ) comet ) { error timeout need tell listen request over have test thi first sinc state mai chang while thi method thi onli requir enter thi method thi state context ctxt = ( context ) request . get map data ( ) . context ; ( ctxt = null ) { ctxt . fire request destroi event ( request ) ; } } ( statu = = socket statu . timeout ) { success = true ; ( async con impl . timeout ( ) ) { async con impl . set error state ( null ) ; } } ( request . async dispatch ( ) ) { success = true ; connector . get servic ( ) . get contain ( ) . get pipelin ( ) . get first ( ) . invok ( request , respons ) ; throwabl t = ( throwabl ) request . get attribut ( request dispatch . error except ) ; ( t = null ) { async con impl . set error state ( t ) ; } } ( request . comet ( ) ) { ( respons . close ( ) respons . error ( ) ) { ( request . get avail ( ) ( request . get content length ( ) 0 ( request . paramet pars ( ) ) ) ) { invok read event right awai ar avail byte ( event ( req , re , socket statu . open ) ) { comet = true ; re . action ( action code . comet begin , null ) ; } } els { comet = true ; re . action ( action code . comet begin , null ) ; } } els { clear filter chain , otherwis reset elsewher sinc thi comet request request . set filter chain ( null ) ; } } ( request . async ( ) comet ) { request . finish request ( ) ; respons . finish respons ( ) ; req . action ( action code . post request , null ) ; } } catch ( ioexcept e ) { success = fals ; ignor } catch ( throwabl t ) { except util . handl throwabl ( t ) ; success = fals ; log . error ( sm . get string ( coyot adapt . servic ) , t ) ; } final { req . get request processor ( ) . set worker thread name ( null ) ; recycl wrapper request respons ( success ( comet request . async ( ) ) ) { request . recycl ( ) ; respons . recycl ( ) ; } els { clear convert so minimum amount memori us thi processor request . clear encod ( ) ; respons . clear encod ( ) ; } } return success ; }	public void test bug50753 ( ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; bug50753servlet servlet = new bug50753servlet ( ) ; wrapper wrapper = tomcat . add servlet ( ctx , servlet , servlet ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( , servlet ) ; tomcat . start ( ) ; call servlet onc map string , list string >> header = new link hash map string , list string >> ( ) ; byte chunk bc = new byte chunk ( ) ; int rc = get url ( http : localhost : get port ( ) , bc , header ) ; assert equal ( 200 , rc ) ; assert equal ( ok , bc . string ( ) ) ; list string test header = header . get ( ) ; assert null ( test header ) ; assert equal ( 1 , test header . size ( ) ) ; assert equal ( xyz , test header . get ( 0 ) ) ; }	public void test async start complet ( ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; minimis paus dure test tomcat . get connector ( ) . set attribut ( connect timeout , integ . valu ( 3000 ) ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; async start complet servlet servlet = new async start complet servlet ( ) ; wrapper wrapper = tomcat . add servlet ( ctx , servlet , servlet ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( , servlet ) ; tomcat . start ( ) ; call servlet first time byte chunk bc1 = get url ( http : localhost : get port ( ) echo = run1 ) ; assert equal ( ok run1 , bc1 . string ( ) ) ; call servlet second time request paramet byte chunk bc2 = get url ( http : localhost : get port ( ) echo = run2 ) ; assert equal ( ok run2 , bc2 . string ( ) ) ; }	public void test async start complet ( ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; async start complet servlet servlet = new async start complet servlet ( ) ; wrapper wrapper = tomcat . add servlet ( ctx , servlet , servlet ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( , servlet ) ; tomcat . start ( ) ; call servlet onc byte chunk bc = get url ( http : localhost : get port ( ) ) ; assert equal ( ok , bc . string ( ) ) ; }	public void test bug49528 ( ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; bug49528servlet servlet = new bug49528servlet ( ) ; wrapper wrapper = tomcat . add servlet ( ctx , servlet , servlet ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( , servlet ) ; tomcat . start ( ) ; call servlet onc byte chunk bc = get url ( http : localhost : get port ( ) ) ; assert equal ( ok , bc . string ( ) ) ; give async thread chanc finish ( too long ) int counter = 0 ; while ( servlet . done ( ) counter 10 ) { thread . sleep ( 1000 ) ; counter ; } assert equal ( , servlet . get result ( ) ) ; }	public void test bug49567 ( ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; bug49567servlet servlet = new bug49567servlet ( ) ; wrapper wrapper = tomcat . add servlet ( ctx , servlet , servlet ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( , servlet ) ; tomcat . start ( ) ; call servlet onc byte chunk bc = get url ( http : localhost : get port ( ) ) ; assert equal ( ok , bc . string ( ) ) ; give async thread chanc finish ( too long ) int counter = 0 ; while ( servlet . done ( ) counter 10 ) { thread . sleep ( 1000 ) ; counter ; } assert equal ( , servlet . get result ( ) ) ; }	void test bug50352 ( ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; async start runnabl servlet = new async start runnabl ( ) ; wrapper wrapper = tomcat . add servlet ( ctx , servlet , servlet ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( , servlet ) ; error servlet error = new error servlet ( ) ; tomcat . add servlet ( ctx , error , error ) ; ctx . add servlet map ( stage2 , error ) ; tomcat . start ( ) ; byte chunk re = get url ( http : localhost : get port ( ) ) ; assert equal ( runnabl complet , re . string ( ) ) ; }	public void test bug50753 ( ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; bug50753servlet servlet = new bug50753servlet ( ) ; wrapper wrapper = tomcat . add servlet ( ctx , servlet , servlet ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( , servlet ) ; tomcat . start ( ) ; call servlet onc map string , list string >> header = new link hash map string , list string >> ( ) ; byte chunk bc = new byte chunk ( ) ; int rc = get url ( http : localhost : get port ( ) , bc , header ) ; assert equal ( 200 , rc ) ; assert equal ( ok , bc . string ( ) ) ; list string test header = header . get ( ) ; assert null ( test header ) ; assert equal ( 1 , test header . size ( ) ) ; assert equal ( xyz , test header . get ( 0 ) ) ; }	void test listen ( ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; track servlet track = new track servlet ( ) ; wrapper wrapper = tomcat . add servlet ( ctx , track , track ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( stage1 , track ) ; timeout servlet timeout = new timeout servlet ( true , null ) ; wrapper wrapper2 = tomcat . add servlet ( ctx , timeout , timeout ) ; wrapper2 . set async support ( true ) ; ctx . add servlet map ( stage2 , timeout ) ; tomcat . start ( ) ; string builder url = new string builder ( 48 ) ; url . append ( http : localhost : ) ; url . append ( get port ( ) ) ; url . append ( stage1 ) ; byte chunk re = get url ( url . string ( ) ) ; assert equal ( dispatch servlet get dispatch servlet get start async timeout servlet get start async timeout complet , re . string ( ) ) ; }
privat extract jar name , present , from url string get jar name ( url url ) { string name = null ; string path = url . get path ( ) ; int end = path . index ( constant . jar ext ) ; ( end = 1 ) { int start = path . last index ( , end ) ; name = path . substr ( start 1 , end 4 ) ; } return name ; }	public map string , web xml get fragment ( ) { return fragment ; }
initi endpoint . overrid public void bind ( ) throw except { creat root apr memori pool try { root pool = pool . creat ( 0 ) ; } catch ( unsatisfi link error e ) { throw new except ( sm . get string ( endpoint . init . notavail ) ) ; } creat pool server socket server sock pool = pool . creat ( root pool ) ; creat apr address bound string address str = null ; ( get address ( ) = null ) { address str = get address ( ) . get host address ( ) ; } int famili = socket . apr inet ; ( librari . apr have ipv6 ) { ( address str = = null ) { ( os . bsd os . win32 os . win64 ) famili = socket . apr unspec ; } els ( address str . index ( : ) = 0 ) { famili = socket . apr unspec ; } } long inet address = address . info ( address str , famili , get port ( ) , 0 , root pool ) ; creat apr server socket server sock = socket . creat ( address . get info ( inet address ) . famili , socket . sock stream , socket . apr proto tcp , root pool ) ; ( os . unix ) { socket . opt set ( server sock , socket . apr so reuseaddr , 1 ) ; } deal firewal tend drop inact socket socket . opt set ( server sock , socket . apr so keepal , 1 ) ; bind server socket int ret = socket . bind ( server sock , inet address ) ; ( ret = 0 ) { throw new except ( sm . get string ( endpoint . init . bind , ret , error . strerror ( ret ) ) ) ; } start listen server socket ret = socket . listen ( server sock , get backlog ( ) ) ; ( ret = 0 ) { throw new except ( sm . get string ( endpoint . init . listen , ret , error . strerror ( ret ) ) ) ; } ( os . win32 os . win64 ) { window set reuseaddr flag after bind listen socket . opt set ( server sock , socket . apr so reuseaddr , 1 ) ; } sendfil usag system which don t support caus major problem ( us sendfil librari . apr ha sendfil ) { us sendfil = fals ; } initi thread count default acceptor , poller sendfil ( acceptor thread count = = 0 ) { fixm : doesn t seem work well multipl accept thread acceptor thread count = 1 ; } ( poller thread count = = 0 ) { ( ( os . win32 os . win64 ) ( poller size 1024 ) ) { maximum per poller get reason perform 1024 poller thread count = poller size 1024 ; adjust poller size so won t reach limit poller size = poller size ( poller size 1024 ) ; } els { explicit poller size limit poller thread count = 1 ; } } ( sendfil thread count = = 0 ) { ( ( os . win32 os . win64 ) ( sendfil size 1024 ) ) { maximum per poller get reason perform 1024 sendfil thread count = sendfil size 1024 ; adjust poller size so won t reach limit sendfil size = sendfil size ( sendfil size 1024 ) ; } els { explicit poller size limit fixm : default per cpu sendfil thread count = 1 ; } } other platform thi call noop return apr enotimpl . ( defer accept ) { ( socket . opt set ( server sock , socket . apr tcp defer accept , 1 ) = = statu . apr enotimpl ) { defer accept = fals ; } } initi ssl need ( sslenabl ( ) ) { ssl protocol int valu = ssl . ssl protocol all ; ( sslv2 . equal ignor case ( sslprotocol ) ) { valu = ssl . ssl protocol sslv2 ; } els ( sslv3 . equal ignor case ( sslprotocol ) ) { valu = ssl . ssl protocol sslv3 ; } els ( tlsv1 . equal ignor case ( sslprotocol ) ) { valu = ssl . ssl protocol tlsv1 ; } els ( sslv2 sslv3 . equal ignor case ( sslprotocol ) ) { valu = ssl . ssl protocol sslv2 ssl . ssl protocol sslv3 ; } creat ssl context ssl context = sslcontext . make ( root pool , valu , ssl . ssl mode server ) ; ( sslinsecur renegoti ) { boolean legaci reneg support = fals ; try { legaci reneg support = ssl . ha op ( ssl . ssl op allow unsaf legaci renegoti ) ; ( legaci reneg support ) sslcontext . set option ( ssl context , ssl . ssl op allow unsaf legaci renegoti ) ; } catch ( unsatisfi link error e ) { ignor } ( legaci reneg support ) { open ssl doe support unsaf legaci renegoti . log . warn ( sm . get string ( endpoint . warn . insecur reneg , ssl . version string ( ) ) ) ; } } list cipher client permit negoti sslcontext . set cipher suit ( ssl context , sslcipher suit ) ; load server kei certif sslcontext . set certif ( ssl context , sslcertif file , sslcertif kei file , sslpassword , ssl . ssl aidx rsa ) ; set certif chain file sslcontext . set certif chain file ( ssl context , sslcertif chain file , fals ) ; support client certif sslcontext . set cacertif ( ssl context , sslcacertif file , sslcacertif path ) ; set revoc sslcontext . set carevoc ( ssl context , sslcarevoc file , sslcarevoc path ) ; client certif verif valu = ssl . ssl cverifi none ; ( option . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi option ; } els ( requir . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi requir ; } els ( option ca . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi option ca ; } sslcontext . set verifi ( ssl context , valu , sslverifi depth ) ; now , sendfil support ssl us sendfil = fals ; } }
protect open ( necessari ) return databas connect us thi realm . except sqlexcept databas error occur connect open ( ) throw sqlexcept { do noth databas connect alreadi open ( db connect = null ) return ( db connect ) ; instanti our databas driver necessari ( driver = = null ) { try { class clazz = class . name ( driver name ) ; driver = ( driver ) clazz . new instanc ( ) ; } catch ( throwabl e ) { except util . handl throwabl ( e ) ; throw new sqlexcept ( e . get messag ( ) ) ; } } open new connect properti prop = new properti ( ) ; ( connect name = null ) prop . put ( user , connect name ) ; ( connect password = null ) prop . put ( password , connect password ) ; db connect = driver . connect ( connect url , prop ) ; ( db connect = = null ) { throw new sqlexcept ( sm . get string ( jdbc realm . open . invalidurl , driver name , connect url ) ) ; } db connect . set auto commit ( fals ) ; return ( db connect ) ; }	protect open ( necessari ) return databas connect us thi access log valv . except sqlexcept databas error occur void open ( ) throw sqlexcept { do noth databas connect alreadi open ( conn = null ) return ; instanti our databas driver necessari ( driver = = null ) { try { class clazz = class . name ( driver name ) ; driver = ( driver ) clazz . new instanc ( ) ; } catch ( throwabl e ) { except util . handl throwabl ( e ) ; throw new sqlexcept ( e . get messag ( ) ) ; } } open new connect properti prop = new properti ( ) ; prop . put ( auto reconnect , true ) ; ( connect name = null ) prop . put ( user , connect name ) ; ( connect password = null ) prop . put ( password , connect password ) ; conn = driver . connect ( connect url , prop ) ; conn . set auto commit ( true ) ; string log pattern = pattern ; ( log pattern . equal ( common ) ) { ps = conn . prepar statement ( insert tabl name ( remot host field , user field , timestamp field , queri field , statu field , byte field ) valu ( , , , , , ) ) ; } els ( log pattern . equal ( combin ) ) { ps = conn . prepar statement ( insert tabl name ( remot host field , user field , timestamp field , queri field , statu field , byte field , virtual host field , method field , refer field , user agent field ) valu ( , , , , , , , , , ) ) ; } }	public static pars data from html form client send server us http post method i applic x www form urlencod i mime type . p data sent post method contain kei valu pair . kei can appear more than onc post data differ valu . howev , kei appear onli onc hashtabl , valu arrai string contain multipl valu sent post method . p kei valu hashtabl ar store decod form , so ani charact ar convert space , charact sent hexadecim notat ( like i xx i ) ar convert ascii charact . param len integ specifi length , charact , code servlet input stream code object also pass thi method param code servlet input stream code object contain data sent from client return code hash tabl code object built from pars kei valu pair except illeg argument except data sent post method invalid hashtabl string , string pars post data ( int len , servlet input stream ) { cheap hack return empti hash ( len = 0 ) return new hashtabl string , string ( ) ; ( = = null ) { throw new illeg argument except ( ) ; } make sure we read entir post bodi . byte post byte = new byte len ; try { int offset = 0 ; do { int input len = . read ( post byte , offset , len offset ) ; ( input len = 0 ) { string msg = l string . get string ( err . io . short read ) ; throw new illeg argument except ( msg ) ; } offset = input len ; } while ( ( len offset ) 0 ) ; } catch ( ioexcept e ) { throw new illeg argument except ( e . get messag ( ) ) ; } bodi should alwai treat form data . try { string post bodi = new string ( post byte , 0 , len , 8859 1 ) ; return pars queri string ( post bodi ) ; } catch ( java . io . unsupport encod except e ) { except . otherwis throw someth expect . throw new illeg argument except ( e . get messag ( ) ) ; } }	content accessor . return input stream overrid public input stream stream content ( ) throw ioexcept { try { ( binari content = = null ) { input stream = base . get input stream ( entri ) ; input stream = ; return ; } } catch ( zip except e ) { throw new ioexcept ( e . get messag ( ) ) ; } return super . stream content ( ) ; }	overrid public int read ( final byte b , final int off , final int len ) throw ioexcept { ( secur util . packag protect enabl ( ) ) { try { integ result = access control . do privileg ( new privileg except action integ ( ) { overrid public integ run ( ) throw ioexcept { integ integ = integ . valu ( ib . read ( b , off , len ) ) ; return integ ; } } ) ; return result . int valu ( ) ; } catch ( privileg action except pae ) { except e = pae . get except ( ) ; ( e instanceof ioexcept ) { throw ( ioexcept ) e ; } els { throw new runtim except ( e . get messag ( ) ) ; } } } els { return ib . read ( b , off , len ) ; } }	public void close ( ) throw ioexcept { ( secur util . packag protect enabl ( ) ) { try { access control . do privileg ( new privileg except action void ( ) { overrid public void run ( ) throw ioexcept { ib . close ( ) ; return null ; } } ) ; } catch ( privileg action except pae ) { except e = pae . get except ( ) ; ( e instanceof ioexcept ) { throw ( ioexcept ) e ; } els { throw new runtim except ( e . get messag ( ) ) ; } } } els { ib . close ( ) ; } }	append { link org . w3c . dom . text text } node current node . param ch charact from xml document param start start posit arrai param length number charact read from arrai throw saxexcept dom implement throw except overrid public void charact ( char ch , int start , int length ) throw saxexcept { try { string str = new string ( ch , start , length ) ; ( str . trim ( ) . length ( ) 0 ) { top . append child ( doc . creat text node ( str ) ) ; } } catch ( domexcept e ) { throw new saxexcept ( e . get messag ( ) ) ; } }	check whether control need return digest . param namespac uri namespac uri param local name local name param q name qualifi ( prefix ) name throw saxexcept dom implement throw except overrid public void end element ( string namespac uri , string local name , string q name ) throw saxexcept { try { ( depth = = 0 ) { get digest ( ) . get xmlreader ( ) . set content handler ( old content handler ) ; get digest ( ) . push ( root ) ; get digest ( ) . end element ( namespac uri , local name , q name ) ; } top = top . get parent node ( ) ; depth ; } catch ( domexcept e ) { throw new saxexcept ( e . get messag ( ) ) ; } }	add new { link org . w3c . dom . process instruct process instruct } current node . param target process instruct target param data process instruct data , null none wa suppli throw saxexcept dom implement throw except overrid public void process instruct ( string target , string data ) throw saxexcept { try { top . append child ( doc . creat process instruct ( target , data ) ) ; } catch ( domexcept e ) { throw new saxexcept ( e . get messag ( ) ) ; } }	add new child { link org . w3c . dom . element element } current node . param namespac uri namespac uri param local name local name param q name qualifi ( prefix ) name param att list attribut throw saxexcept dom implement throw except overrid public void start element ( string namespac uri , string local name , string q name , attribut att ) throw saxexcept { try { node previou top = top ; ( ( local name = = null ) ( local name . length ( ) = = 0 ) ) { top = doc . creat element ( q name ) ; } els { top = doc . creat element ns ( namespac uri , local name ) ; } ( int i = 0 ; i att . get length ( ) ; i ) { attr attr = null ; ( ( att . get local name ( i ) = = null ) ( att . get local name ( i ) . length ( ) = = 0 ) ) { attr = doc . creat attribut ( att . get qname ( i ) ) ; attr . set node valu ( att . get valu ( i ) ) ; ( ( element ) top ) . set attribut node ( attr ) ; } els { attr = doc . creat attribut ns ( att . get uri ( i ) , att . get local name ( i ) ) ; attr . set node valu ( att . get valu ( i ) ) ; ( ( element ) top ) . set attribut node ns ( attr ) ; } } previou top . append child ( top ) ; depth ; } catch ( domexcept e ) { throw new saxexcept ( e . get messag ( ) ) ; } }
public process pipelin http request us specifi input output stream . throw ioexcept error dure i o oper socket state process ( nio channel socket ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set up socket thi . socket = socket ; input buffer . set socket ( socket ) ; output buffer . set socket ( socket ) ; input buffer . set selector pool ( endpoint . get selector pool ( ) ) ; output buffer . set selector pool ( endpoint . get selector pool ( ) ) ; error flag error = fals ; keep aliv = true ; comet = fals ; long so timeout = endpoint . get so timeout ( ) ; int keep aliv timeout = endpoint . get keep aliv timeout ( ) ; boolean kept aliv = fals ; boolean open socket = fals ; boolean recycl = true ; final kei attach ka = ( kei attach ) socket . get attach ( fals ) ; while ( error keep aliv comet async ( ) endpoint . paus ( ) ) { alwai default our so timeout ka . set timeout ( so timeout ) ; pars request header try { ( disabl upload timeout kept aliv so timeout 0 ) { socket . get iochannel ( ) . socket ( ) . set so timeout ( ( int ) so timeout ) ; } ( input buffer . pars request line ( kept aliv ) ) { haven t finish read request so keep socket open open socket = true ; check see we have read ani request line yet ( input buffer . get pars request line phase ( ) 2 ) { continu us keep aliv timeout ( keep aliv timeout 0 ) ka . set timeout ( keep aliv timeout ) ; } els { start read request line . need keep processor associ socket recycl = fals ; } break ; } kept aliv = true ; ( input buffer . pars header ( ) ) { we ve read part request , don t recycl instead associ socket open socket = true ; recycl = fals ; break ; } request . set start time ( system . current time milli ( ) ) ; ( disabl upload timeout ) { onli bodi , request header socket . get iochannel ( ) . socket ( ) . set so timeout ( connect upload timeout ) ; } } catch ( ioexcept e ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . header . pars ) , e ) ; } error = true ; break ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . header . pars ) , t ) ; } 400 bad request respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } ( error ) { set up filter , pars some request header rp . set stage ( org . apach . coyot . constant . stage prepar ) ; try { prepar request ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . request . prepar ) , t ) ; } 400 intern server error respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } ( max keep aliv request = = 1 ) keep aliv = fals ; ( max keep aliv request 0 ka . decrement keep aliv ( ) = 0 ) keep aliv = fals ; process request adapt ( error ) { try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; adapt . servic ( request , respons ) ; commit , so we can t try set header . ( keep aliv error ) { avoid check twice . error = respons . get error except ( ) = null statu drop connect ( respons . get statu ( ) ) ; } comet support select kei kei = socket . get iochannel ( ) . kei ( socket . get poller ( ) . get selector ( ) ) ; ( kei = null ) { nio endpoint . kei attach attach = ( nio endpoint . kei attach ) kei . attach ( ) ; ( attach = null ) { attach . set comet ( comet ) ; ( comet ) { integ comettimeout = ( integ ) request . get attribut ( org . apach . tomcat . comet . timeout ) ; ( comettimeout = null ) attach . set timeout ( comettimeout . long valu ( ) ) ; } } } } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( sm . get string ( http11processor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } finish handl request ( comet async ( ) ) { servlet ha reject . ( error ) input buffer . set swallow input ( fals ) ; end request ( ) ; } error , updat statist counter ( error ) { respons . set statu ( 500 ) ; } request . updat counter ( ) ; ( comet async ( ) ) { next request input buffer . next request ( ) ; output buffer . next request ( ) ; } do sendfil need : add socket sendfil end ( sendfil data = null error ) { ka . set sendfil data ( sendfil data ) ; sendfil data . keep aliv = keep aliv ; select kei kei = socket . get iochannel ( ) . kei ( socket . get poller ( ) . get selector ( ) ) ; do first write thi thread , might well open socket = socket . get poller ( ) . process sendfil ( kei , ka , true , true ) ; break ; } rp . set stage ( org . apach . coyot . constant . stage keepal ) ; } while rp . set stage ( org . apach . coyot . constant . stage end ) ; ( error endpoint . paus ( ) ) { recycl ( ) ; return socket state . close ; } els ( comet async ( ) ) { return socket state . long ; } els { ( recycl ) { recycl ( ) ; } return ( open socket ) ( socket state . open ) : socket state . close ; return ( open socket ) ( recycl socket state . open : socket state . long ) : socket state . close ; } }	public process pipelin http request us specifi input output stream . throw ioexcept error dure i o oper socket state process ( socket wrapper long socket ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set remot address remot addr = null ; remot host = null ; local addr = null ; local name = null ; remot port = 1 ; local port = 1 ; set up socket thi . socket = socket ; long socket ref = socket . get socket ( ) . long valu ( ) ; input buffer . set socket ( socket ref ) ; output buffer . set socket ( socket ref ) ; error flag error = fals ; comet = fals ; keep aliv = true ; int keep aliv left = max keep aliv request ; long so timeout = endpoint . get so timeout ( ) ; boolean kept aliv = fals ; boolean open socket = fals ; while ( error keep aliv comet async ( ) endpoint . paus ( ) ) { pars request header try { ( disabl upload timeout kept aliv so timeout 0 ) { socket . timeout set ( socket ref , so timeout 1000 ) ; } ( input buffer . pars request line ( kept aliv ) ) { thi mean data avail right now ( long keepal ) , so processor should recycl method should return true open socket = true ; add socket poller endpoint . get poller ( ) . add ( socket ref ) ; break ; } request . set start time ( system . current time milli ( ) ) ; kept aliv = true ; ( disabl upload timeout ) { socket . timeout set ( socket ref , connect upload timeout 1000 ) ; } input buffer . pars header ( ) ; } catch ( ioexcept e ) { error = true ; break ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . header . pars ) , t ) ; } 400 bad request respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } ( error ) { set up filter , pars some request header rp . set stage ( org . apach . coyot . constant . stage prepar ) ; try { prepar request ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . request . prepar ) , t ) ; } 400 intern server error respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } ( max keep aliv request 0 keep aliv left = = 0 ) keep aliv = fals ; process request adapt ( error ) { try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; adapt . servic ( request , respons ) ; commit , so we can t try set header . ( keep aliv error ) { avoid check twice . error = respons . get error except ( ) = null statu drop connect ( respons . get statu ( ) ) ; } } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( sm . get string ( http11processor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } finish handl request ( comet async ( ) ) { servlet ha reject . ( error ) input buffer . set swallow input ( fals ) ; end request ( ) ; } error , updat statist counter ( error ) { respons . set statu ( 500 ) ; } request . updat counter ( ) ; ( comet async ( ) ) { next request input buffer . next request ( ) ; output buffer . next request ( ) ; } do sendfil need : add socket sendfil end ( sendfil data = null error ) { sendfil data . socket = socket ref ; sendfil data . keep aliv = keep aliv ; ( endpoint . get sendfil ( ) . add ( sendfil data ) ) { open socket = true ; break ; } } rp . set stage ( org . apach . coyot . constant . stage keepal ) ; } rp . set stage ( org . apach . coyot . constant . stage end ) ; ( error endpoint . paus ( ) ) { recycl ( ) ; return socket state . close ; } els ( comet async ( ) ) { return socket state . long ; } els { recycl ( ) ; return ( open socket ) socket state . open : socket state . close ; } }	public process pipelin http request us specifi input output stream . throw ioexcept error dure i o oper socket state process ( socket wrapper socket socket ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set up socket thi . socket = socket ; input = socket . get socket ( ) . get input stream ( ) ; output = socket . get socket ( ) . get output stream ( ) ; int so timeout = 1 ; ( keep aliv timeout 0 ) { so timeout = socket . get socket ( ) . get so timeout ( ) ; } error flag error = fals ; while ( error endpoint . paus ( ) ) { pars request header try { set keep aliv timeout enabl ( keep aliv timeout 0 ) { socket . get socket ( ) . set so timeout ( keep aliv timeout ) ; } get first messag request ( read messag ( request header messag ) ) { thi mean connect timeout rp . set stage ( org . apach . coyot . constant . stage end ) ; break ; } set back timeout keep aliv timeout enabl ( keep aliv timeout 0 ) { socket . get socket ( ) . set so timeout ( so timeout ) ; } check messag type , process right awai break regular request process int type = request header messag . get byte ( ) ; ( type = = constant . jk ajp13 cping request ) { try { output . write ( pong messag arrai ) ; } catch ( ioexcept e ) { error = true ; } continu ; } els ( type = constant . jk ajp13 forward request ) { usual servlet didn t read previou request bodi ( log . debug enabl ( ) ) { log . debug ( unexpect messag : type ) ; } continu ; } request . set start time ( system . current time milli ( ) ) ; } catch ( ioexcept e ) { error = true ; break ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . debug ( sm . get string ( ajpprocessor . header . error ) , t ) ; 400 bad request respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } set up filter , pars some request header rp . set stage ( org . apach . coyot . constant . stage prepar ) ; try { prepar request ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . debug ( sm . get string ( ajpprocessor . request . prepar ) , t ) ; 400 intern server error respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } process request adapt ( error ) { try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; adapt . servic ( request , respons ) ; } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( sm . get string ( ajpprocessor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } ( async ( ) error ) { break ; } finish respons done yet ( finish ) { try { finish ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; error = true ; } } error , updat statist counter ( error ) { respons . set statu ( 500 ) ; } request . updat counter ( ) ; rp . set stage ( org . apach . coyot . constant . stage keepal ) ; recycl ( ) ; } rp . set stage ( org . apach . coyot . constant . stage end ) ; ( async ( ) error endpoint . paus ( ) ) { return socket state . long ; } els { recycl ( ) ; input = null ; output = null ; return socket state . close ; } }	public static int get url ( string path , byte chunk out , map string , list string >> req head , map string , list string >> re head ) throw ioexcept { url url = new url ( path ) ; http urlconnect connect = ( http urlconnect ) url . open connect ( ) ; connect . set read timeout ( 1000000 ) ; ( req head = null ) { ( map . entri string , list string >> entri : req head . entri set ( ) ) { string builder valu list = new string builder ( ) ; ( string valu : entri . get valu ( ) ) { ( valu list . length ( ) 0 ) { valu list . append ( , ) ; } valu list . append ( valu ) ; } connect . set request properti ( entri . get kei ( ) , valu list . string ( ) ) ; } } connect . connect ( ) ; int rc = connect . get respons code ( ) ; ( re head = null ) { map string , list string >> head = connect . get header field ( ) ; re head . put all ( head ) ; } ( rc = = http servlet respons . sc ok ) { input stream = connect . get input stream ( ) ; buffer input stream bi = null ; try { bi = new buffer input stream ( ) ; byte buf = new byte 2048 ; int rd = 0 ; while ( ( rd = bi . read ( buf ) ) 0 ) { out . append ( buf , 0 , rd ) ; } } final { ( bi = null ) { try { bi . close ( ) ; } catch ( ioexcept e ) { ignor } } } } return rc ; }
overrid protect abstract endpoint get endpoint ( ) { return endpoint ; }	protect ajp apr processor creat processor ( ) { ajp apr processor processor = new ajp apr processor ( proto . packet size , ( apr endpoint ) proto . endpoint ) ; processor . set adapt ( proto . adapt ) ; processor . set tomcat authent ( proto . tomcat authent ) ; processor . set requir secret ( proto . requir secret ) ; regist ( processor ) ; return processor ; }	protect ajp processor creat processor ( ) { ajp processor processor = new ajp processor ( proto . packet size , ( jio endpoint ) proto . endpoint ) ; processor . set adapt ( proto . adapt ) ; processor . set tomcat authent ( proto . tomcat authent ) ; processor . set requir secret ( proto . requir secret ) ; processor . set keep aliv timeout ( proto . get keep aliv timeout ( ) ) ; regist ( processor ) ; return processor ; }	protect http11apr processor creat processor ( ) { http11apr processor processor = new http11apr processor ( proto . get max http header size ( ) , ( apr endpoint ) proto . endpoint , proto . get max trailer size ( ) ) ; processor . set adapt ( proto . adapt ) ; processor . set max keep aliv request ( proto . get max keep aliv request ( ) ) ; processor . set connect upload timeout ( proto . get connect upload timeout ( ) ) ; processor . set disabl upload timeout ( proto . get disabl upload timeout ( ) ) ; processor . set compress min size ( proto . get compress min size ( ) ) ; processor . set compress ( proto . get compress ( ) ) ; processor . set compress user agent ( proto . get compress user agent ( ) ) ; processor . set compress mime type ( proto . get compress mime type ( ) ) ; processor . set restrict user agent ( proto . get restrict user agent ( ) ) ; processor . set socket buffer ( proto . get socket buffer ( ) ) ; processor . set max save post size ( proto . get max save post size ( ) ) ; processor . set server ( proto . get server ( ) ) ; regist ( processor ) ; return processor ; }	send action connector . param action code type action param param action paramet overrid public final void action ( action code action code , object param ) { ( action code = = action code . commit ) { ( respons . commit ( ) ) return ; valid write respons header try { prepar respons ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } try { flush ( fals ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . client flush ) { ( respons . commit ( ) ) { valid write respons header try { prepar respons ( ) ; } catch ( ioexcept e ) { set error flag error = true ; return ; } } try { flush ( true ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . disabl swallow input ) { todo : do swallow request input make sure we ar close connect error = true ; } els ( action code = = action code . close ) { transact client try { finish ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . req ssl attribut ) { ( certif . null ( ) ) { byte chunk cert data = certif . get byte chunk ( ) ; x509certif jsse cert = null ; byte arrai input stream bai = new byte arrai input stream ( cert data . get byte ( ) , cert data . get start ( ) , cert data . get length ( ) ) ; fill element . try { certif factori cf = certif factori . get instanc ( x . 509 ) ; while ( bai . avail ( ) 0 ) { x509certif cert = ( x509certif ) cf . gener certif ( bai ) ; ( jsse cert = = null ) { jsse cert = new x509certif 1 ; jsse cert 0 = cert ; } els { x509certif temp = new x509certif jsse cert . length 1 ; system . arraycopi ( jsse cert , 0 , temp , 0 , jsse cert . length ) ; temp jsse cert . length = cert ; jsse cert = temp ; } } } catch ( java . secur . cert . certif except e ) { get log ( ) . error ( sm . get string ( ajpprocessor . cert . fail ) , e ) ; return ; } request . set attribut ( sslsupport . certif kei , jsse cert ) ; } } els ( action code = = action code . req host attribut ) { get remot host name us dn resolut ( request . remot host ( ) . null ( ) ) { try { request . remot host ( ) . set string ( inet address . get name ( request . remot addr ( ) . string ( ) ) . get host name ( ) ) ; } catch ( ioexcept iex ) { ignor } } } els ( action code = = action code . req local addr attribut ) { copi from local name now , which should simpli address request . local addr ( ) . set string ( request . local name ( ) . string ( ) ) ; } els ( action code = = action code . req set bodi replai ) { set given byte content byte chunk bc = ( byte chunk ) param ; int length = bc . get length ( ) ; bodi byte . set byte ( bc . get byte ( ) , bc . get start ( ) , length ) ; request . set content length ( length ) ; first = fals ; empti = fals ; replai = true ; } els ( action code = = action code . async start ) { async state machin . async start ( ( async context callback ) param ) ; } els ( action code = = action code . async dispatch ) { async state machin . async dispatch ( ) ; } els ( action code = = action code . async timeout ) { atom boolean result = ( atom boolean ) param ; result . set ( async state machin . async timeout ( ) ) ; } els ( action code = = action code . async run ) { async state machin . async run ( ( runnabl ) param ) ; } els ( action code = = action code . async error ) { async state machin . async error ( ) ; } els ( action code = = action code . async start ) { ( ( atom boolean ) param ) . set ( async state machin . async start ( ) ) ; } els ( action code = = action code . async dispatch ) { ( ( atom boolean ) param ) . set ( async state machin . async dispatch ( ) ) ; } els ( action code = = action code . async async ) { ( ( atom boolean ) param ) . set ( async state machin . async ( ) ) ; } els ( action code = = action code . async timingout ) { ( ( atom boolean ) param ) . set ( async state machin . async time out ( ) ) ; } els { action intern ( action code , param ) ; } }	send action connector . param action code type action param param action paramet overrid public void action intern ( action code action code , object param ) { long socket ref = socket . get socket ( ) . long valu ( ) ; ( action code = = action code . close ) { close end process current request , stop ani further transact client comet = fals ; try { output buffer . end request ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . req host addr attribut ) { get remot host address ( remot addr = = null ( socket ref = 0 ) ) { try { long sa = address . get ( socket . apr remot , socket ref ) ; remot addr = address . getip ( sa ) ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . remot addr ( ) . set string ( remot addr ) ; } els ( action code = = action code . req local name attribut ) { get local host name ( local name = = null ( socket ref = 0 ) ) { try { long sa = address . get ( socket . apr local , socket ref ) ; local name = address . getnameinfo ( sa , 0 ) ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . local name ( ) . set string ( local name ) ; } els ( action code = = action code . req host attribut ) { get remot host name ( remot host = = null ( socket ref = 0 ) ) { try { long sa = address . get ( socket . apr remot , socket ref ) ; remot host = address . getnameinfo ( sa , 0 ) ; ( remot host = = null ) { remot host = address . getip ( sa ) ; } } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . remot host ( ) . set string ( remot host ) ; } els ( action code = = action code . req local addr attribut ) { get local host address ( local addr = = null ( socket ref = 0 ) ) { try { long sa = address . get ( socket . apr local , socket ref ) ; local addr = address . getip ( sa ) ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . local addr ( ) . set string ( local addr ) ; } els ( action code = = action code . req remoteport attribut ) { get remot port ( remot port = = 1 ( socket ref = 0 ) ) { try { long sa = address . get ( socket . apr remot , socket ref ) ; sockaddr addr = address . get info ( sa ) ; remot port = addr . port ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . set remot port ( remot port ) ; } els ( action code = = action code . req localport attribut ) { get local port ( local port = = 1 ( socket ref = 0 ) ) { try { long sa = address . get ( socket . apr local , socket ref ) ; sockaddr addr = address . get info ( sa ) ; local port = addr . port ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . set local port ( local port ) ; } els ( action code = = action code . req ssl attribut ) { ( ssl ( socket ref = 0 ) ) { try { cipher suit object ssl o = sslsocket . get info s ( socket ref , ssl . ssl info cipher ) ; ( ssl o = null ) { request . set attribut ( sslsupport . cipher suit kei , ssl o ) ; } get client certif certif chain present cert length = = 1 indic error int cert length = sslsocket . get info i ( socket ref , ssl . ssl info client cert chain ) ; byte client cert = sslsocket . get info b ( socket ref , ssl . ssl info client cert ) ; x509certif cert = null ; ( client cert = null cert length 1 ) { cert = new x509certif cert length 1 ; certif factori cf = certif factori . get instanc ( x . 509 ) ; cert 0 = ( x509certif ) cf . gener certif ( new byte arrai input stream ( client cert ) ) ; ( int i = 0 ; i cert length ; i ) { byte data = sslsocket . get info b ( socket ref , ssl . ssl info client cert chain i ) ; cert i 1 = ( x509certif ) cf . gener certif ( new byte arrai input stream ( data ) ) ; } } ( cert = null ) { request . set attribut ( sslsupport . certif kei , cert ) ; } user kei size ssl o = integ . valu ( sslsocket . get info i ( socket ref , ssl . ssl info cipher usekeys ) ) ; request . set attribut ( sslsupport . kei size kei , ssl o ) ; ssl session id ssl o = sslsocket . get info s ( socket ref , ssl . ssl info session id ) ; ( ssl o = null ) { request . set attribut ( sslsupport . session id kei , ssl o ) ; } todo provid hook enabl ssl session invalid . set apr endpoint . session mgr req attr } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . ssl ) , e ) ; } } } els ( action code = = action code . req ssl certif ) { ( ssl ( socket ref = 0 ) ) { consum buffer request bodi , so doe interfer client s handshak messag input filter input filter = input buffer . get filter ( ) ; ( ( buffer input filter ) input filter constant . buffer filter ) . set limit ( max save post size ) ; input buffer . add activ filter ( input filter constant . buffer filter ) ; try { configur connect requir certif sslsocket . set verifi ( socket ref , ssl . ssl cverifi requir , endpoint . get sslverifi depth ( ) ) ; renegoti certif ( sslsocket . renegoti ( socket ref ) = = 0 ) { don t look cert unless we know renegoti work . get client certif certif chain present cert length = = 1 indic error int cert length = sslsocket . get info i ( socket ref , ssl . ssl info client cert chain ) ; byte client cert = sslsocket . get info b ( socket ref , ssl . ssl info client cert ) ; x509certif cert = null ; ( client cert = null cert length 1 ) { cert = new x509certif cert length 1 ; certif factori cf = certif factori . get instanc ( x . 509 ) ; cert 0 = ( x509certif ) cf . gener certif ( new byte arrai input stream ( client cert ) ) ; ( int i = 0 ; i cert length ; i ) { byte data = sslsocket . get info b ( socket ref , ssl . ssl info client cert chain i ) ; cert i 1 = ( x509certif ) cf . gener certif ( new byte arrai input stream ( data ) ) ; } } ( cert = null ) { request . set attribut ( sslsupport . certif kei , cert ) ; } } } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . ssl ) , e ) ; } } } els ( action code = = action code . avail ) { request . set avail ( input buffer . avail ( ) ) ; } els ( action code = = action code . comet begin ) { comet = true ; } els ( action code = = action code . comet end ) { comet = fals ; } els ( action code = = action code . comet close ) { endpoint . process socket async ( thi . socket , socket statu . open ) ; } els ( action code = = action code . comet settimeout ) { op } els ( action code = = action code . async complet ) { ( async state machin . async complet ( ) ) { endpoint . process socket async ( thi . socket , socket statu . open ) ; } } els ( action code = = action code . async settimeout ) { ( param = = null ) return ; long timeout = ( ( long ) param ) . long valu ( ) ; socket . set timeout ( timeout ) ; } els ( action code = = action code . async dispatch ) { ( async state machin . async dispatch ( ) ) { endpoint . process socket async ( thi . socket , socket statu . open ) ; } } }	overrid public void invok ( request request , respons respons ) throw ioexcept , servlet except { mod header convert n so we have rebuild client certif string strcert0 = myget header ( request , ssl client cert ) ; ( strcert0 = null strcert0 . length ( ) 28 ) { string strcert1 = strcert0 . replac ( , n ) ; string strcert2 = strcert1 . substr ( 28 , strcert1 . length ( ) 26 ) ; string strcert3 = begin certif n ; string strcert4 = strcert3 . concat ( strcert2 ) ; string strcert = strcert4 . concat ( n end certif n ) ; byte arrai input stream bai = new byte arrai input stream ( strcert . get byte ( utf 8 ) ) ; byte arrai input stream bai = new byte arrai input stream ( strcert . get byte ( ) ) ; x509certif jsse cert = null ; try { certif factori cf = certif factori . get instanc ( x . 509 ) ; x509certif cert = ( x509certif ) cf . gener certif ( bai ) ; jsse cert = new x509certif 1 ; jsse cert 0 = cert ; } catch ( java . secur . cert . certif except e ) { system . out . println ( sslvalv fail strcert ) ; system . out . println ( sslvalv fail e ) ; } request . set attribut ( global . certif attr , jsse cert ) ; } strcert0 = myget header ( request , ssl cipher ) ; ( strcert0 = null ) { request . set attribut ( global . cipher suit attr , strcert0 ) ; } strcert0 = myget header ( request , ssl session id ) ; ( strcert0 = null ) { request . set attribut ( global . ssl session id attr , strcert0 ) ; } strcert0 = myget header ( request , ssl cipher usekeys ) ; ( strcert0 = null ) { request . set attribut ( global . kei size attr , strcert0 ) ; } get next ( ) . invok ( request , respons ) ; }	properti ar pass through end point overrid public executor get executor ( ) { return endpoint . get executor ( ) ; }	public void set requir secret ( string requir secret ) { thi . requir secret = requir secret ; }
privat convert binari class name canon can us when gener java sourc code . param class name binari class name return canon equival string get canon name ( string class name ) throw jasper except { class clazz ; class loader tccl ; ( constant . secur enabl ) { privileg action class loader pa = new privileg get tccl ( ) ; tccl = access control . do privileg ( pa ) ; } els { tccl = thread . current thread ( ) . get context class loader ( ) ; } try { clazz = class . name ( class name , true , tccl ) ; } catch ( class found except e ) { throw new jasper except ( e ) ; } return clazz . get canon name ( ) ; }
stop thi compon implement requir { link org . apach . catalina . util . lifecycl base stop intern ( ) } . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect synchron void stop intern ( ) throw lifecycl except { send j2ee . state . stop notif ( thi . get object name ( ) = null ) { notif notif = new notif ( j2ee . state . stop , thi . get object name ( ) , sequenc number . get increment ( ) ) ; broadcast . send notif ( notif ) ; } set state ( lifecycl state . stop ) ; current thi effect op need call ensur name resourc follow correct lifecycl ( name resourc = null ) { name resourc . stop ( ) ; } bind thread class loader old ccl = bind thread ( ) ; try { stop our child contain , ani final contain children = find children ( ) ; we do dedic thread memori leak protect , case some webapp code regist some thread local thei forget cleanup dedic thread executor . execut own thread ( new callabl void ( ) { overrid } } }	overrid protect void stop intern ( ) throw lifecycl except { set state ( lifecycl state . stop ) ; fire lifecycl event ( configur stop event , null ) ; }
start associ { link class loader } implement requir { link org . apach . catalina . util . lifecycl base start intern ( ) } . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect void start intern ( ) throw lifecycl except { ( log . debug enabl ( ) ) log . debug ( sm . get string ( webapp loader . start ) ) ; ( contain . get resourc ( ) = = null ) { log . info ( resourc contain ) ; set state ( lifecycl state . start ) ; return ; } regist stream handler factori jndi protocol urlstream handler factori stream handler factori = new dir context urlstream handler factori ( ) ; ( first ) { first = fals ; try { url . set urlstream handler factori ( stream handler factori ) ; } catch ( except e ) { log continu anywai , thi critic log . error ( error regist jndi stream handler , e ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; thi like dual registr log . info ( dual registr jndi stream handler : t . get messag ( ) ) ; } } construct class loader base our current repositori list try { class loader = creat class loader ( ) ; class loader . set resourc ( contain . get resourc ( ) ) ; class loader . set deleg ( thi . deleg ) ; class loader . set search extern first ( search extern first ) ; ( contain instanceof standard context ) { class loader . set anti jarlock ( ( ( standard context ) contain ) . get anti jarlock ( ) ) ; class loader . set clear refer static ( ( ( standard context ) contain ) . get clear refer static ( ) ) ; class loader . set clear refer stop thread ( ( ( standard context ) contain ) . get clear refer stop thread ( ) ) ; class loader . set clear refer stop timer thread ( ( ( standard context ) contain ) . get clear refer stop timer thread ( ) ) ; class loader . set clear refer http client keep aliv thread ( ( ( standard context ) contain ) . get clear refer http client keep aliv thread ( ) ) ; } ( int i = 0 ; i repositori . length ; i ) { class loader . add repositori ( repositori i ) ; } configur our repositori set repositori ( ) ; set class path ( ) ; set permiss ( ) ; ( ( lifecycl ) class loader ) . start ( ) ; bind webapp class loader directori context dir context urlstream handler . bind ( class loader , thi . contain . get resourc ( ) ) ; standard context ctx = ( standard context ) contain ; string context name = ctx . get name ( ) ; ( context name . start ( ) ) { context name = context name ; } object name clonam = new object name ( mbean util . get domain ( ctx ) : type = webapp class loader , context = context name , host = ctx . get parent ( ) . get name ( ) ) ; registri . get registri ( null , null ) . regist compon ( class loader , clonam , null ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( lifecycl except , t ) ; throw new lifecycl except ( start : , t ) ; } set state ( lifecycl state . start ) ; }	creat new urlstream handler instanc specifi protocol . return null protocol code jndi code . param protocol protocol ( must jndi here ) return urlstream handler jndi protocol , null protocol jndi overrid public urlstream handler creat urlstream handler ( string protocol ) { ( protocol . equal ( jndi ) ) { return new dir context urlstream handler ( ) ; } els { return null ; } }
public regist authent princip authent type our request , current session ( ) , our singl sign valv , . set appropri cooki return . param request servlet request we ar process param respons servlet respons we ar gener param princip authent princip regist param auth type authent type regist param usernam usernam us authent ( ani ) param password password us authent ( ani ) void regist ( request request , http servlet respons respons , princip princip , string auth type , string usernam , string password ) { ( log . debug enabl ( ) ) log . debug ( authent princip . get name ( ) type auth type ) ; cach authent inform our request request . set auth type ( auth type ) ; request . set user princip ( princip ) ; session session = request . get session intern ( fals ) ; ( session = null ) { ( chang session id authent ) { manag manag = request . get context ( ) . get manag ( ) ; manag . chang session id ( session ) ; request . chang session id ( session . get id ( ) ) ; } } els ( alwai us session ) { session = request . get session intern ( true ) ; } cach authent inform our session , ani ( cach ) { ( session = null ) { session . set auth type ( auth type ) ; session . set princip ( princip ) ; ( usernam = null ) session . set note ( constant . sess usernam note , usernam ) ; els session . remov note ( constant . sess usernam note ) ; ( password = null ) session . set note ( constant . sess password note , password ) ; els session . remov note ( constant . sess password note ) ; } } construct cooki return client ( sso = = null ) return ; onli creat new sso entri sso did alreadi set note exist entri ( would do subsequ request digest ssl authent context ) string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( sso id = = null ) { construct cooki return client sso id = session id gener . gener session id ( ) ; cooki cooki = new cooki ( constant . singl sign cooki , sso id ) ; cooki . set max ag ( 1 ) ; cooki . set path ( ) ; bugzilla 41217 cooki . set secur ( request . secur ( ) ) ; bugzilla 34724 string sso domain = sso . get cooki domain ( ) ; ( sso domain = null ) { cooki . set domain ( sso domain ) ; } configur http onli sso cooki us same rule session cooki ( request . get servlet context ( ) . get session cooki config ( ) . http onli ( ) request . get context ( ) . get us http onli ( ) ) { cooki . set http onli ( true ) ; } respons . add cooki ( cooki ) ; regist thi princip our sso valv sso . regist ( sso id , princip , auth type , usernam , password ) ; request . set note ( constant . req ssoid note , sso id ) ; } els { ( princip = = null ) { regist programmat logout sso . deregist ( sso id ) ; return ; } els { updat sso session latest authent data sso . updat ( sso id , princip , auth type , usernam , password ) ; } } sso entri never clear we don t associ session ( session = = null ) session = request . get session intern ( true ) ; sso . associ ( sso id , session ) ; }
public retriev connect futur . connect avail , can block us futur . get ( ) until connect ha becom avail . connect retriev , futur must cancel order connect return pool . return futur contain refer connect futur connect throw sqlexcept futur connect get connect async ( ) throw sqlexcept { pool connect pc = thi . borrow connect ( 0 , null , null ) ; ( pc = null ) { return new connect futur ( pc ) ; } we can onli retriev futur underli queue support . ( idl instanceof fair block queue ) { futur pool connect pcf = ( ( fair block queue pool connect ) idl ) . poll async ( ) ; return new connect futur ( pcf ) ; } els ( idl instanceof multi lock fair block queue ) { futur pool connect pcf = ( ( multi lock fair block queue pool connect ) idl ) . poll async ( ) ; return new connect futur ( pcf ) ; } els { throw new sqlexcept ( connect pool misconfigur , doesn t support async retriev . set fair properti true ) ; } }
get input stream . overrid public input stream get input stream ( ) throw ioexcept { ( connect ) connect ( ) ; ( resourc = = null ) { throw new file found except ( ) ; } reopen resourc try { resourc = ( resourc ) context . lookup ( get url ( ) . get file ( ) ) ; } catch ( name except e ) { ignor } return ( resourc . stream content ( ) ) ; }	get object content . overrid public object get content ( ) throw ioexcept { ( connect ) connect ( ) ; ( resourc = null ) return get input stream ( ) ; ( collect = null ) return collect ; ( object = null ) return object ; throw new file found except ( ) ; }	public list children thi collect . name given ar rel thi uri s path . full uri children : path name . enumer string list ( ) throw ioexcept { ( connect ) { connect ( ) ; } ( ( resourc = = null ) ( collect = = null ) ) { throw new file found except ( ) ; } vector string result = new vector string ( ) ; ( collect = null ) { try { string file = get url ( ) . get file ( ) ; thi form hostnam contextpath file name contextpath empti otherwis thi form hostnam file name strip off hostnam contextpath int start ; ( context instanceof proxi dir context . equal ( ( ( proxi dir context ) context ) . get context path ( ) ) ) { start = file . index ( , 1 ) ; } els start = file . index ( , file . index ( , 1 ) 1 ) ; name enumer name class pair enumer = context . list ( file . substr ( start ) ) ; while ( enumer . ha more element ( ) ) { name class pair ncp = enumer . next element ( ) ; result . add element ( ncp . get name ( ) ) ; } } catch ( name except e ) { unexpect except throw new file found except ( ) ; } } return result . element ( ) ; }
execut request oper . except build except error occur overrid public void execut ( ) throw build except { super . execut ( ) ; ( bean = = null attribut = = null ) { throw new build except ( must specifi bean attribut attribut ) ; } log ( get attribut attribut bean bean ) ; execut ( jmxproxi get = bean att = attribut ) ; }	execut request oper . except build except error occur overrid public void execut ( ) throw build except { super . execut ( ) ; string queri string = ( queri = = null ) : ( qry = queri ) ; log ( queri string queri string ) ; execut ( jmxproxi queri string ) ; }	execut request oper . except build except error occur overrid public void execut ( ) throw build except { super . execut ( ) ; ( bean = = null attribut = = null valu = = null ) { throw new build except ( must specifi bean , attribut valu attribut ) ; } log ( set attribut attribut bean bean valu ) ; execut ( jmxproxi set = bean att = attribut val = valu ) ; }	execut request oper . except build except error occur overrid public void execut ( ) throw build except { super . execut ( ) ; ( type = null ) { execut ( resourc type = type ) ; } els { execut ( resourc ) ; } }	execut request oper . except build except error occur overrid public void execut ( ) throw build except { super . execut ( ) ; ( path = = null ) { throw new build except ( must specifi path attribut ) ; } execut ( undeploi path = thi . path ) ; }
privat static load properti . void load properti ( ) { input stream = null ; throwabl error = null ; try { string config url = get config url ( ) ; ( config url = null ) { = ( new url ( config url ) ) . open stream ( ) ; } } catch ( throwabl t ) { handl throwabl ( t ) ; } ( = = null ) { try { file home = new file ( get catalina base ( ) ) ; file conf = new file ( home , conf ) ; file prop file = new file ( conf , catalina . properti ) ; = new file input stream ( prop file ) ; } catch ( throwabl t ) { handl throwabl ( t ) ; } } ( = = null ) { try { = catalina properti . class . get resourc stream ( org apach catalina startup catalina . properti ) ; } catch ( throwabl t ) { handl throwabl ( t ) ; } } ( = null ) { try { properti = new properti ( ) ; properti . load ( ) ; . close ( ) ; } catch ( throwabl t ) { handl throwabl ( t ) ; error = t ; } } ( ( = = null ) ( error = null ) ) { do someth log . warn ( fail load catalina . properti , error ) ; s fine we have reason default . properti = new properti ( ) ; } regist properti system properti enumer enumer = properti . properti name ( ) ; while ( enumer . ha more element ( ) ) { string name = ( string ) enumer . next element ( ) ; string valu = properti . get properti ( name ) ; ( valu = null ) { system . set properti ( name , valu ) ; } } }
privat synchron void set state intern ( lifecycl state state , object data , boolean check ) throw lifecycl except { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( lifecycl base . set state , thi , state ) ) ; } ( check ) { null never valid state ( state = = null ) { invalid transit ( null ) ; possibl npe further down method return ; } stop intern ( ) permit stop prep stop ( ( state = = lifecycl state . fail ( thi . state = = lifecycl state . start prep state = = lifecycl state . start ) ( thi . state = = lifecycl state . stop prep state = = lifecycl state . stop ) ) ) { other transit permit invalid transit ( state . name ( ) ) ; } } thi . state = state ; string lifecycl event = state . get lifecycl event ( ) ; ( lifecycl event = null ) { fire lifecycl event ( lifecycl event , data ) ; } }	{ inherit doc } overrid public final synchron void stop ( ) throw lifecycl except { ( lifecycl state . stop prep . equal ( state ) lifecycl state . stop . equal ( state ) lifecycl state . stop . equal ( state ) ) { ( log . debug enabl ( ) ) { except e = new lifecycl except ( ) ; log . debug ( sm . get string ( lifecycl base . alreadi stop , string ( ) ) , e ) ; } els ( log . info enabl ( ) ) { log . info ( sm . get string ( lifecycl base . alreadi stop , string ( ) ) ) ; } return ; } ( state . equal ( lifecycl state . new ) ) { state = lifecycl state . stop ; return ; } ( state . equal ( lifecycl state . start ) state . equal ( lifecycl state . fail ) state . equal ( lifecycl state . must stop ) ) { invalid transit ( lifecycl . befor stop event ) ; } set state intern ( lifecycl state . stop prep , null , fals ) ; try { stop intern ( ) ; } catch ( lifecycl except e ) { set state intern ( lifecycl state . fail , null , fals ) ; throw e ; } ( state . equal ( lifecycl state . must destroi ) ) { complet stop process first set state intern ( lifecycl state . stop , null , fals ) ; destroi ( ) ; } els { do what thei ar suppos . ( state . equal ( lifecycl state . stop ) ) { invalid transit ( lifecycl . after stop event ) ; } set state intern ( lifecycl state . stop , null , fals ) ; } }
protect perform handshak unwrap param doread boolean return sslengin result throw ioexcept sslengin result handshak unwrap ( boolean doread ) throw ioexcept { ( net buffer . posit ( ) = = net buffer . limit ( ) ) { clear buffer we have empti out data net buffer . clear ( ) ; } ( doread ) { we have data read , read int read = sc . read ( net buffer ) ; ( read = = 1 ) throw new ioexcept ( eof encount dure handshak . ) ; } sslengin result result ; boolean cont = fals ; loop while we can perform pure sslengin data do { prepar buffer incom data net buffer . flip ( ) ; call unwrap result = ssl engin . unwrap ( net buffer , buf handler . get read buffer ( ) ) ; compact buffer , thi option method , wonder what would happen we didn t net buffer . compact ( ) ; read statu init handshak statu = result . get handshak statu ( ) ; ( result . get statu ( ) = = sslengin result . statu . ok result . get handshak statu ( ) = = handshak statu . need task ) { execut task we need init handshak statu = task ( ) ; } perform anoth unwrap cont = result . get statu ( ) = = sslengin result . statu . ok init handshak statu = = handshak statu . need unwrap ; } while ( cont ) ; return result ; }	protect perform wrap function param do write boolean return sslengin result throw ioexcept sslengin result handshak wrap ( boolean do write ) throw ioexcept { thi should never call network buffer contain data so we can clear here . net out buffer . clear ( ) ; perform wrap sslengin result result = ssl engin . wrap ( buf handler . get write buffer ( ) , net out buffer ) ; prepar result written net out buffer . flip ( ) ; set statu init handshak statu = result . get handshak statu ( ) ; optim , we do have writabl channel , write now ( do write ) flush ( net out buffer ) ; return result ; }	overrid public applic buffer handler get buf handler ( ) { return buf handler ; }	public close return boolean todo implement thi org . apach . tomcat . util . net . secur nio channel method boolean close ( ) { return fals ; }	protect execut all task need same thread . return handshak statu sslengin result . handshak statu task ( ) { runnabl r = null ; while ( ( r = ssl engin . get deleg task ( ) ) = null ) { r . run ( ) ; } return ssl engin . get handshak statu ( ) ; }	read sequenc byte from thi channel given buffer . param dst buffer which byte ar transfer return number byte read , possibl zero , tt 1 tt channel ha reach end stream throw ioexcept some other i o error occur throw illeg argument except destin buffer differ than buf handler . get read buffer ( ) todo implement thi java . nio . channel . readabl byte channel method overrid public int read ( byte buffer dst ) throw ioexcept { we want take advantag expand function , make sure we onli us applic buffer handler s buffer ( dst = buf handler . get read buffer ( ) ) throw new illeg argument except ( you can onli read us applic read buffer provid handler . ) ; ar we middl close close ( close close ) return 1 ; did we finish our handshak ( init handshak complet ) throw new illeg state except ( handshak incomplet , you must complet handshak befor read data . ) ; read from network int netread = sc . read ( net buffer ) ; did we reach eof so send eof up layer . ( netread = = 1 ) return 1 ; data read int read = 0 ; ssl engin result sslengin result unwrap ; do { prepar buffer net buffer . flip ( ) ; unwrap data unwrap = ssl engin . unwrap ( net buffer , dst ) ; compact buffer net buffer . compact ( ) ; ( unwrap . get statu ( ) = = statu . ok unwrap . get statu ( ) = = statu . buffer underflow ) { we did receiv some data , add our total read = unwrap . byte produc ( ) ; perform ani task need ( unwrap . get handshak statu ( ) = = handshak statu . need task ) task ( ) ; we need more network data , bail out now . ( unwrap . get statu ( ) = = statu . buffer underflow ) break ; } els ( unwrap . get statu ( ) = = statu . buffer overflow read 0 ) { empti out dst buffer befor we do anoth read break ; } els { constructor throw new ioexcept ( unabl unwrap data , invalid statu : unwrap . get statu ( ) ) ; } } while ( continu unwrap long input buffer ha stuff ( net buffer . posit ( ) = 0 ) ) ; return ( read ) ; }	send action connector . param action code type action param param action paramet overrid public void action intern ( action code action code , object param ) { ( action code = = action code . close ) { close end process current request , stop ani further transact client comet = fals ; comet close = true ; select kei kei = socket . get iochannel ( ) . kei ( socket . get poller ( ) . get selector ( ) ) ; ( kei = null ) { nio endpoint . kei attach attach = ( nio endpoint . kei attach ) kei . attach ( ) ; ( attach = null attach . get comet ( ) ) { thi comet connect execut connect closur next selector loop request . get attribut ( ) . remov ( org . apach . tomcat . comet . timeout ) ; attach . set timeout ( 5000 ) ; forc cleanup 5 second attach . set error ( true ) ; thi ha caus concurr error } } try { output buffer . end request ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . req host addr attribut ) { get remot host address ( ( remot addr = = null ) ( socket = null ) ) { inet address inet addr = socket . get iochannel ( ) . socket ( ) . get inet address ( ) ; ( inet addr = null ) { remot addr = inet addr . get host address ( ) ; } } request . remot addr ( ) . set string ( remot addr ) ; } els ( action code = = action code . req local name attribut ) { get local host name ( ( local name = = null ) ( socket = null ) ) { inet address inet addr = socket . get iochannel ( ) . socket ( ) . get local address ( ) ; ( inet addr = null ) { local name = inet addr . get host name ( ) ; } } request . local name ( ) . set string ( local name ) ; } els ( action code = = action code . req host attribut ) { get remot host name ( ( remot host = = null ) ( socket = null ) ) { inet address inet addr = socket . get iochannel ( ) . socket ( ) . get inet address ( ) ; ( inet addr = null ) { remot host = inet addr . get host name ( ) ; } ( remot host = = null ) { ( remot addr = null ) { remot host = remot addr ; } els { all we can do punt request . remot host ( ) . recycl ( ) ; } } } request . remot host ( ) . set string ( remot host ) ; } els ( action code = = action code . req local addr attribut ) { ( local addr = = null ) local addr = socket . get iochannel ( ) . socket ( ) . get local address ( ) . get host address ( ) ; request . local addr ( ) . set string ( local addr ) ; } els ( action code = = action code . req remoteport attribut ) { ( ( remot port = = 1 ) ( socket = null ) ) { remot port = socket . get iochannel ( ) . socket ( ) . get port ( ) ; } request . set remot port ( remot port ) ; } els ( action code = = action code . req localport attribut ) { ( ( local port = = 1 ) ( socket = null ) ) { local port = socket . get iochannel ( ) . socket ( ) . get local port ( ) ; } request . set local port ( local port ) ; } els ( action code = = action code . req ssl attribut ) { try { ( ssl support = null ) { object ssl o = ssl support . get cipher suit ( ) ; ( ssl o = null ) request . set attribut ( sslsupport . cipher suit kei , ssl o ) ; ssl o = ssl support . get peer certif chain ( fals ) ; ( ssl o = null ) request . set attribut ( sslsupport . certif kei , ssl o ) ; ssl o = ssl support . get kei size ( ) ; ( ssl o = null ) request . set attribut ( sslsupport . kei size kei , ssl o ) ; ssl o = ssl support . get session id ( ) ; ( ssl o = null ) request . set attribut ( sslsupport . session id kei , ssl o ) ; request . set attribut ( sslsupport . session mgr , ssl support ) ; } } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . ssl ) , e ) ; } } els ( action code = = action code . req ssl certif ) { ( ssl support = null ) { consum buffer request bodi , so doe interfer client s handshak messag input filter input filter = input buffer . get filter ( ) ; ( ( buffer input filter ) input filter constant . buffer filter ) . set limit ( max save post size ) ; input buffer . add activ filter ( input filter constant . buffer filter ) ; try { object ssl o = ssl support . get peer certif chain ( true ) ; ( ssl o = null ) { request . set attribut ( sslsupport . certif kei , ssl o ) ; } } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . ssl ) , e ) ; } } } els ( action code = = action code . avail ) { request . set avail ( input buffer . avail ( ) ) ; } els ( action code = = action code . comet begin ) { comet = true ; } els ( action code = = action code . comet end ) { comet = fals ; } els ( action code = = action code . comet close ) { ( socket = = null socket . get attach ( fals ) = = null ) return ; nio endpoint . kei attach attach = ( nio endpoint . kei attach ) socket . get attach ( fals ) ; attach . set comet op ( nio endpoint . op callback ) ; notifi poller tomcat thread request info rp = request . get request processor ( ) ; ( async handl rp . get stage ( ) = org . apach . coyot . constant . stage servic ) socket . get poller ( ) . add ( socket ) ; } els ( action code = = action code . comet settimeout ) { ( param = = null ) return ; ( socket = = null socket . get attach ( fals ) = = null ) return ; nio endpoint . kei attach attach = ( nio endpoint . kei attach ) socket . get attach ( fals ) ; long timeout = ( ( long ) param ) . long valu ( ) ; we ar piggi back worker thread , set timeout request info rp = request . get request processor ( ) ; ( async handl rp . get stage ( ) = org . apach . coyot . constant . stage servic ) attach . set timeout ( timeout ) ; } els ( action code = = action code . async complet ) { ( async state machin . async complet ( ) ) { endpoint . process socket ( thi . socket , socket statu . open , true ) ; } } els ( action code = = action code . async settimeout ) { ( param = = null ) return ; ( socket = = null socket . get attach ( fals ) = = null ) return ; nio endpoint . kei attach attach = ( nio endpoint . kei attach ) socket . get attach ( fals ) ; long timeout = ( ( long ) param ) . long valu ( ) ; we ar piggi back worker thread , set timeout attach . set timeout ( timeout ) ; } els ( action code = = action code . async dispatch ) { ( async state machin . async dispatch ( ) ) { endpoint . process socket ( thi . socket , socket statu . open , true ) ; } } }	overrid public void reset ( ) throw ioexcept { super . reset ( ) ; net out buffer . posit ( 0 ) ; net out buffer . limit ( 0 ) ; net buffer . posit ( 0 ) ; net buffer . limit ( 0 ) ; init handshak complet = fals ; close = fals ; close = fals ; initi handshak ssl engin . begin handshak ( ) ; init handshak statu = ssl engin . get handshak statu ( ) ; }
destroi need clean up context complet . problem undo all config start ( ) restor fresh state imposs . after stop ( ) destroi ( ) init ( ) start ( ) we should have same state fresh start wa done i . e read modifi web . xml , etc . thi can onli done complet remov context object remap new , clean up everyth . xxx should thi done stop ( ) overrid protect void destroi intern ( ) throw lifecycl except { ( ( manag = null ) ( manag instanceof lifecycl ) ) { ( ( lifecycl ) manag ) . destroi ( ) ; } ( ( realm = null ) ( realm instanceof lifecycl ) ) { ( ( lifecycl ) realm ) . destroi ( ) ; } ( ( cluster = null ) ( cluster instanceof lifecycl ) ) { ( ( lifecycl ) cluster ) . destroi ( ) ; } ( ( logger = null ) ( logger instanceof lifecycl ) ) { ( ( lifecycl ) logger ) . destroi ( ) ; } ( ( loader = null ) ( loader instanceof lifecycl ) ) { ( ( lifecycl ) loader ) . destroi ( ) ; } send j2ee . object . delet notif notif notif = new notif ( j2ee . object . delet , thi . get object name ( ) , sequenc number . get increment ( ) ) ; broadcast . send notif ( notif ) ; ( name resourc = null ) { name resourc . destroi ( ) ; } synchron ( instanc listen lock ) { instanc listen = new string 0 ; } super . destroi intern ( ) ; }	public test http : issu . apach . org bugzilla show bug . cgi id = 47866 void test get resourc ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; string context path = exampl ; file app dir = new file ( get build directori ( ) , webapp context path ) ; app dir rel server home org . apach . catalina . context ctx = tomcat . add webapp ( null , exampl , app dir . get absolut path ( ) ) ; tomcat . add servlet ( ctx , test get resourc , new get resourc ( ) ) ; ctx . add servlet map ( test get resourc , test get resourc ) ; tomcat . start ( ) ; byte chunk re = new byte chunk ( ) ; int rc = get url ( http : localhost : get port ( ) context path test get resourc , re , null ) ; assert equal ( http servlet respons . sc ok , rc ) ; assert true ( re . string ( ) . contain ( xml version = 1 . 0 ) ) ; }
protect return list role associ given user . ani role present user s directori entri ar supplement directori search . role ar associ thi user , zero length list return . param context directori context we ar search param user user check except name except directori server error occur list string get role ( dir context context , user user ) throw name except { ( user = = null ) return ( null ) ; string dn = user . get dn ( ) ; string usernam = user . get user name ( ) ; ( dn = = null usernam = = null ) return ( null ) ; ( contain log . trace enabl ( ) ) contain log . trace ( get role ( dn ) ) ; start role retriev from user entri list string list = new arrai list string ( ) ; list string user role = user . get role ( ) ; ( user role = null ) { list . add all ( user role ) ; } ( common role = null ) list . add ( common role ) ; ( contain log . trace enabl ( ) ) { contain log . trace ( found list . size ( ) user intern role ) ; ( int i = 0 ; i list . size ( ) ; i ) contain log . trace ( found user intern role list . get ( i ) ) ; } ar we configur do role search ( ( role format = = null ) ( role name = = null ) ) return ( list ) ; set up paramet appropri search string filter = role format . format ( new string { do rfc2254encod ( dn ) , usernam } ) ; search control control = new search control ( ) ; ( role subtre ) control . set search scope ( search control . subtre scope ) ; els control . set search scope ( search control . onelevel scope ) ; control . set return attribut ( new string { role name } ) ; perform configur search process result name enumer search result result = null ; try { ( role search user ) { user credenti add ( context , dn , user . get password ( ) ) ; } result = context . search ( role base , filter , control ) ; } final { ( role search user ) { user credenti remov ( context ) ; } } ( result = = null ) should never happen , just case . . . return ( list ) ; hash map string , string group map = new hash map string , string ( ) ; try { while ( result . ha more ( ) ) { search result result = result . next ( ) ; attribut attr = result . get attribut ( ) ; ( attr = = null ) continu ; string dname = get distinguish name ( context , role base , result ) ; string name = get attribut valu ( role name , attr ) ; ( name = null dname = null ) { group map . put ( dname , name ) ; } } } catch ( partial result except ex ) { ( ad compat ) throw ex ; } set string kei = group map . kei set ( ) ; ( contain log . trace enabl ( ) ) { contain log . trace ( found kei . size ( ) direct role ) ; ( string kei : kei ) { contain log . trace ( found direct role kei group map . get ( kei ) ) ; } } nest group search enabl , perform search nest group until new group found ( get role nest ( ) ) { follow effici algorithm known member algorithm , describ practic directori group . avoid group slurp handl cyclic group membership well . see http : middlewar . internet2 . edu dir detail map string , string new group = new hash map string , string ( group map ) ; while ( new group . empti ( ) ) { store group we find thi iter map string , string new thi round = new hash map string , string ( ) ; ( entri string , string group : new group . entri set ( ) ) { filter = role format . format ( new string { group . get kei ( ) , group . get valu ( ) } ) ; ( contain log . trace enabl ( ) ) { contain log . trace ( perform nest group search base role base filter filter ) ; } result = context . search ( role base , filter , control ) ; try { while ( result . ha more ( ) ) { search result result = result . next ( ) ; attribut attr = result . get attribut ( ) ; ( attr = = null ) continu ; string dname = get distinguish name ( context , role base , result ) ; string name = get attribut valu ( role name , attr ) ; ( name = null dname = null group map . kei set ( ) . contain ( dname ) ) { group map . put ( dname , name ) ; new thi round . put ( dname , name ) ; ( contain log . trace enabl ( ) ) { contain log . trace ( found nest role dname name ) ; } } } } catch ( partial result except ex ) { ( ad compat ) throw ex ; } } new group = new thi round ; } } list . add all ( group map . valu ( ) ) ; return list ; }	public set base element role search . param role base new base element void set role base ( string role base ) { thi . role base = role base ; }
protect return list role associ given user . ani role present user s directori entri ar supplement directori search . role ar associ thi user , zero length list return . param context directori context we ar search param user user check except name except directori server error occur list string get role ( dir context context , user user ) throw name except { ( user = = null ) return ( null ) ; string dn = user . get dn ( ) ; string usernam = user . get user name ( ) ; ( dn = = null usernam = = null ) return ( null ) ; ( contain log . trace enabl ( ) ) contain log . trace ( get role ( dn ) ) ; start role retriev from user entri list string list = new arrai list string ( ) ; list string user role = user . get role ( ) ; ( user role = null ) { list . add all ( user role ) ; } ( common role = null ) list . add ( common role ) ; ( contain log . trace enabl ( ) ) { contain log . trace ( found list . size ( ) user intern role ) ; ( int i = 0 ; i list . size ( ) ; i ) contain log . trace ( found user intern role list . get ( i ) ) ; } ar we configur do role search ( ( role format = = null ) ( role name = = null ) ) return ( list ) ; set up paramet appropri search string filter = role format . format ( new string { do rfc2254encod ( dn ) , usernam } ) ; search control control = new search control ( ) ; ( role subtre ) control . set search scope ( search control . subtre scope ) ; els control . set search scope ( search control . onelevel scope ) ; control . set return attribut ( new string { role name } ) ; perform configur search process result name enumer search result result = context . search ( role base , filter , control ) ; ( result = = null ) should never happen , just case . . . return ( list ) ; hash map string , string group map = new hash map string , string ( ) ; try { while ( result . ha more ( ) ) { search result result = result . next ( ) ; attribut attr = result . get attribut ( ) ; ( attr = = null ) continu ; string dname = get distinguish name ( context , role base , result ) ; string name = get attribut valu ( role name , attr ) ; ( name = null dname = null ) { group map . put ( dname , name ) ; } } } catch ( partial result except ex ) { ( ad compat ) throw ex ; } set string kei = group map . kei set ( ) ; ( contain log . trace enabl ( ) ) { contain log . trace ( found kei . size ( ) direct role ) ; ( string kei : kei ) { contain log . trace ( found direct role kei group map . get ( kei ) ) ; } } nest group search enabl , perform search nest group until new group found ( get role nest ( ) ) { follow effici algorithm known member algorithm , describ practic directori group . avoid group slurp handl cyclic group membership well . see http : middlewar . internet2 . edu dir detail map string , string new group = new hash map string , string ( group map ) ; while ( new group . empti ( ) ) { store group we find thi iter map string , string new thi round = new hash map string , string ( ) ; ( entri string , string group : new group . entri set ( ) ) { filter = role format . format ( new string { group . get kei ( ) , group . get valu ( ) } ) ; ( contain log . trace enabl ( ) ) { contain log . trace ( perform nest group search base role base filter filter ) ; } result = context . search ( role base , filter , control ) ; try { while ( result . ha more ( ) ) { search result result = result . next ( ) ; attribut attr = result . get attribut ( ) ; ( attr = = null ) continu ; string dname = get distinguish name ( context , role base , result ) ; string name = get attribut valu ( role name , attr ) ; ( name = null dname = null group map . kei set ( ) . contain ( dname ) ) { group map . put ( dname , name ) ; new thi round . put ( dname , name ) ; ( contain log . trace enabl ( ) ) { contain log . trace ( found nest role dname name ) ; } } } } catch ( partial result except ex ) { ( ad compat ) throw ex ; } } new group = new thi round ; } } list . add all ( group map . valu ( ) ) ; return list ; }
close output buffer . thi tri calcul respons size respons ha been commit yet . throw ioexcept underli ioexcept occur overrid public void close ( ) throw ioexcept { ( close ) return ; ( suspend ) return ; ( ( coyot respons . commit ( ) ) ( coyot respons . get content length long ( ) = = 1 ) ) { length can calcul ( coyot respons . commit ( ) ) { coyot respons . set content length ( bb . get length ( ) ) ; } } do flush ( fals ) ; close = true ; coyot respons . finish ( ) ; }
protect list resourc which ar member collect . param file collect return vector contain name entri object arrai list name entri list ( file file ) { arrai list name entri entri = new arrai list name entri ( ) ; ( file . directori ( ) ) return entri ; string name = file . list ( ) ; ( name = = null ) { some io error occur bad file permiss . prevent npe arrai . sort ( name ) log . warn ( sm . get string ( file resourc . list null , file . get absolut path ( ) ) ) ; return entri ; } sort alphabet arrai . sort ( name ) ; name entri entri = null ; ( int i = 0 ; i name . length ; i ) { file current file = new file ( file , name i ) ; object object = null ; ( current file . directori ( ) ) { file dir context temp context = new file dir context ( env ) ; temp context . set doc base ( file . get path ( ) ) ; temp context . set allow link ( get allow link ( ) ) ; object = temp context ; } els { object = new file resourc ( current file ) ; } entri = new name entri ( name i , object , name entri . entri ) ; entri . add ( entri ) ; } return entri ; }	search name context object entri satisfi given search filter . perform search specifi search control . param name name context object search param filter expr filter express us search . express mai contain variabl form { i } where i nonneg integ . mai null . param filter arg arrai argument substitut variabl filter expr . valu filter arg i replac each occurr { i } . null , equival empti arrai . param con search control control search . null , default search control ar us ( equival ( new search control ( ) ) ) . return enumer search result object satisi filter ; never null except arrai index out bound except filter expr contain { i } express where i outsid bound arrai filter arg except javax . name . directori . invalid search control except search control contain invalid set except javax . name . directori . invalid search filter except filter expr filter arg repres invalid search filter except name except name except encount overrid public name enumer search result search ( name name , string filter expr , object filter arg , search control con ) throw name except { return search ( name . string ( ) , filter expr , filter arg , con ) ; }	overrid protect arrai list name entri list ( file file ) { arrai list name entri entri = super . list ( file ) ; add virtual tld web inf list ( web inf . equal ( file . get name ( ) ) ) { entri . add all ( get virtual name entri ( ) ) ; } return entri ; }	enumer name bound name context , along object bound them . param name name context list return enumer bind thi context . each element enumer type bind . except name except name except encount overrid public final name enumer bind list bind ( string name ) throw name except { ( alias . empti ( ) ) { alia result result = find alia ( name ) ; ( result . dir context = null ) { return result . dir context . list bind ( result . alia name ) ; } } next do standard lookup name enumer bind bind = do list bind ( name ) ; ( bind = null ) return bind ; check altern locat ( dir context alt dir context : alt dir context ) { ( alt dir context instanceof base dir context ) bind = ( ( base dir context ) alt dir context ) . do list bind ( meta inf resourc name ) ; els { try { bind = alt dir context . list bind ( name ) ; } catch ( name except ne ) { ignor } } ( bind = null ) return bind ; } realli found throw new name found except ( sm . get string ( resourc . found , name ) ) ; }	enumer name bound name context , along object bound them . content ani subcontext ar includ . p bind ad remov from thi context , effect enumer previous return undefin . param name name context list return enumer bind thi context . each element enumer type bind . except name except name except encount overrid protect name enumer bind do list bind ( string name ) throw name except { file file = file ( name ) ; ( file = = null ) return null ; return new name context bind enumer ( list ( file ) . iter ( ) , thi ) ; }	enumer name bound name context , along object bound them . content ani subcontext ar includ . p bind ad remov from thi context , effect enumer previous return undefin . param str name name context list return enumer bind thi context . each element enumer type bind . except name except name except encount overrid protect name enumer bind do list bind ( string str name ) throw name except { name name = get escap jndi name ( str name ) ; ( name . empti ( ) ) return new name context bind enumer ( list ( entri ) . iter ( ) , thi ) ; entri entri = tree lookup ( name ) ; ( entri = = null ) return null ; return new name context bind enumer ( list ( entri ) . iter ( ) , thi ) ; }
overrid public socket state process ( socket wrapper long socket ) { ajp apr processor processor = recycl processor . poll ( ) ; try { ( processor = = null ) { processor = creat processor ( ) ; } socket state state = processor . process ( socket ) ; ( state = = socket state . long ) { check post process go chang state state = processor . async post process ( ) ; } ( state = = socket state . long state = = socket state . async end ) { need make socket avail next process cycl need poller connect . put ( socket , processor ) ; socket . set async ( true ) ; } els { ( state = = socket state . open ) { connect . put ( socket , processor ) ; } recycl processor . offer ( processor ) ; } return state ; } catch ( java . net . socket except e ) { socket except ar normal log . debug ( sm . get string ( ajpprotocol . proto . socketexcept . debug ) , e ) ; } catch ( java . io . ioexcept e ) { ioexcept ar normal log . debug ( sm . get string ( ajpprotocol . proto . ioexcept . debug ) , e ) ; } abov . catch ( throwabl e ) { except util . handl throwabl ( e ) ; ani other except error odd . here we log error level , so show up even less than verbos log . log . error ( sm . get string ( ajpprotocol . proto . error ) , e ) ; } recycl processor . offer ( processor ) ; return socket state . close ; }
privat prepar request base filter configur . param request servlet request we ar process param respons servlet respons we ar creat param state rd state except ioexcept input output error occur except servlet except servlet error occur void process request ( servlet request request , servlet respons respons , state state ) throw ioexcept , servlet except { dispatch type di int = ( dispatch type ) request . get attribut ( applic filter factori . dispatch type attr ) ; ( di int = null ) { ( di int = dispatch type . error ) { state . outer request . set attribut ( applic filter factori . dispatch request path attr , get combin path ( ) ) ; state . outer request . set attribut ( applic filter factori . dispatch type attr , dispatch type . forward ) ; invok ( state . outer request , respons , state ) ; } els { invok ( state . outer request , respons , state ) ; } } }
overrid public object get valu ( evalu context ctx ) throw elexcept { object base = thi . children 0 . get valu ( ctx ) ; int prop count = thi . jjt get num children ( ) ; int i = 1 ; object suffix = null ; elresolv resolv = ctx . get elresolv ( ) ; while ( base = null i prop count ) { suffix = thi . children i . get valu ( ctx ) ; ( i 1 prop count ( thi . children i 1 instanceof ast method paramet ) ) { ast method paramet mp = ( ast method paramet ) thi . children i 1 ; thi method base = resolv . invok ( ctx , base , suffix , mp . get paramet type ( ctx ) , mp . get paramet ( ctx ) ) ; i = 2 ; } els { thi properti ( suffix = = null ) { return null ; } ctx . set properti resolv ( fals ) ; base = resolv . get valu ( ctx , base , suffix ) ; i ; } } ( ctx . properti resolv ( ) ) { throw new properti found except ( messag factori . get ( error . resolv . unhandl , base , suffix ) ) ; } return base ; }	sinc el 2 . 2 overrid public object invok ( elcontext context , object base , object method , class param type , object param ) { ( context = = null ) { throw new null pointer except ( ) ; } ( base = = null method = = null ) { return null ; } express factori factori = express factori . new instanc ( ) ; string method name = ( string ) factori . coerc type ( method , string . class ) ; find match method method match method = null ; class clazz = base . get class ( ) ; ( param type = null ) { try { match method = clazz . get method ( method name , param type ) ; } catch ( method except e ) { throw new method found except ( e ) ; } } els { int param count = 0 ; ( param = null ) { param count = param . length ; } method method = clazz . get method ( ) ; ( method m : method ) { ( m . get paramet type ( ) . length = = param count ) { same number paramet us first match match method = m ; break ; } ( m . var arg ( ) ) { match method = m ; } } ( match method = = null ) { throw new method found except ( unabl find method method name param count paramet ) ; } } class paramet type = match method . get paramet type ( ) ; object paramet = null ; ( paramet type . length 0 ) { paramet = new object paramet type . length ; param . length = paramet type . length suppress warn ( null ) int param count = param . length ; ( match method . var arg ( ) ) { int var arg index = paramet type . length 1 ; first arg count 1 paramet ar standard ( int i = 0 ; ( i var arg index 1 ) ; i ) { paramet i = factori . coerc type ( param i , paramet type i ) ; } last paramet varag class var arg class = paramet type var arg index . get compon type ( ) ; ( int i = ( var arg index ) ; i param count ; i ) { object vararg = arrai . new instanc ( paramet type param count , ( param count var arg index ) ) ; arrai . set ( vararg , i , factori . coerc type ( param i , var arg class ) ) ; paramet var arg index = vararg ; } } els { paramet = new object paramet type . length ; ( int i = 0 ; i paramet type . length ; i ) { paramet i = factori . coerc type ( param i , paramet type i ) ; } } } object result = null ; try { result = match method . invok ( base , paramet ) ; } catch ( illeg argument except e ) { throw new elexcept ( e ) ; } catch ( illeg access except e ) { throw new elexcept ( e ) ; } catch ( invoc target except e ) { throw new elexcept ( e . get caus ( ) ) ; } context . set properti resolv ( true ) ; return result ; }	public void test bug50449b ( ) throw except { method express me1 = factori . creat method express ( context , { bean b . sai hello ( tomcat ) } , null , null ) ; string actual = ( string ) me1 . invok ( context , null ) ; assert equal ( hello tomcat from b , actual ) ; }
privat void do test dispatch ( int iter , boolean us thread ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; dispatch servlet dispatch = new dispatch servlet ( fals , fals ) ; wrapper wrapper = tomcat . add servlet ( ctx , dispatch , dispatch ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( stage1 , dispatch ) ; non async servlet nonasync = new non async servlet ( ) ; wrapper wrapper2 = tomcat . add servlet ( ctx , nonasync , nonasync ) ; wrapper2 . set async support ( true ) ; ctx . add servlet map ( stage2 , nonasync ) ; tomcat . start ( ) ; string builder url = new string builder ( 48 ) ; url . append ( http : localhost : ) ; url . append ( get port ( ) ) ; url . append ( stage1 iter = ) ; url . append ( iter ) ; ( us thread ) { url . append ( us thread = y ) ; } byte chunk re = get url ( url . string ( ) ) ; string builder expect = new string builder ( ) ; int loop = iter ; while ( loop 0 ) { expect . append ( dispatch servlet get ) ; loop ; } expect . append ( non async servlet get ) ; assert equal ( expect . string ( ) , re . string ( ) ) ; }	privat void do test dispatch error ( int iter , boolean us thread , boolean complet error ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; dispatch servlet dispatch = new dispatch servlet ( true , complet error ) ; wrapper wrapper = tomcat . add servlet ( ctx , dispatch , dispatch ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( stage1 , dispatch ) ; error servlet error = new error servlet ( ) ; tomcat . add servlet ( ctx , error , error ) ; ctx . add servlet map ( stage2 , error ) ; tomcat . start ( ) ; string builder url = new string builder ( 48 ) ; url . append ( http : localhost : ) ; url . append ( get port ( ) ) ; url . append ( stage1 iter = ) ; url . append ( iter ) ; ( us thread ) { url . append ( us thread = y ) ; } byte chunk re = get url ( url . string ( ) ) ; string builder expect = new string builder ( ) ; int loop = iter ; while ( loop 0 ) { expect . append ( dispatch servlet get ) ; ( loop = iter ) { expect . append ( start async ) ; } loop ; } expect . append ( error servlet get error complet ) ; assert equal ( expect . string ( ) , re . string ( ) ) ; }	privat void do test timeout ( boolean complet timeout , string dispatch url ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; creat folder trigger redirect file foo = new file ( doc base , async ) ; ( foo . exist ( ) foo . mkdir ( ) ) { fail ( unabl creat async directori doc base ) ; } context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; timeout servlet timeout = new timeout servlet ( complet timeout , dispatch url ) ; wrapper wrapper = tomcat . add servlet ( ctx , time , timeout ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( async , time ) ; ( dispatch url = null ) { non async servlet non async = new non async servlet ( ) ; tomcat . add servlet ( ctx , nonasync , non async ) ; ctx . add servlet map ( dispatch url , nonasync ) ; } tomcat . start ( ) ; byte chunk re = get url ( http : localhost : get port ( ) async ) ; string builder expect = new string builder ( ) ; expect . append ( timeout servlet get timeout ) ; ( complet timeout ) { expect . append ( error ) ; } ( dispatch url = = null ) { expect . append ( complet ) ; } els { expect . append ( non async servlet get ) ; } assert equal ( expect . string ( ) , re . string ( ) ) ; }	overrid public boolean async dispatch ( org . apach . coyot . request req , org . apach . coyot . respons re , socket statu statu ) throw except { request request = ( request ) req . get note ( adapt note ) ; respons respons = ( respons ) re . get note ( adapt note ) ; ( request = = null ) { throw new illeg state except ( dispatch mai onli happen exist request . ) ; } boolean comet = fals ; boolean success = true ; async context impl async con impl = ( async context impl ) request . get async context ( ) ; try { ( statu = = socket statu . timeout ) { success = true ; ( async con impl . timeout ( ) ) { async con impl . set error state ( null ) ; } } ( request . async dispatch ( ) ) { success = true ; connector . get servic ( ) . get contain ( ) . get pipelin ( ) . get first ( ) . invok ( request , respons ) ; throwabl t = ( throwabl ) request . get attribut ( request dispatch . error except ) ; ( t = null ) { async con impl . set error state ( t ) ; } } ( request . comet ( ) ) { ( respons . close ( ) respons . error ( ) ) { ( request . get avail ( ) ( request . get content length ( ) 0 ( request . paramet pars ( ) ) ) ) { invok read event right awai ar avail byte ( event ( req , re , socket statu . open ) ) { comet = true ; re . action ( action code . comet begin , null ) ; } } els { comet = true ; re . action ( action code . comet begin , null ) ; } } els { clear filter chain , otherwis reset elsewher sinc thi comet request request . set filter chain ( null ) ; } } ( request . async ( ) comet ) { respons . finish respons ( ) ; req . action ( action code . post request , null ) ; } } catch ( ioexcept e ) { success = fals ; ignor } catch ( throwabl t ) { except util . handl throwabl ( t ) ; success = fals ; log . error ( sm . get string ( coyot adapt . servic ) , t ) ; } final { req . get request processor ( ) . set worker thread name ( null ) ; recycl wrapper request respons ( success ( comet request . async ( ) ) ) { request . recycl ( ) ; respons . recycl ( ) ; } els { clear convert so minimum amount memori us thi processor request . clear encod ( ) ; respons . clear encod ( ) ; } } return success ; }	overrid public boolean fire request destroi event ( servlet request request ) { object instanc = get applic event listen ( ) ; ( ( instanc = null ) ( instanc . length 0 ) ) { don t fire listen async request ( dispatch type . async . equal ( request . get dispatch type ( ) ) ) { servlet request event event = new servlet request event ( get servlet context ( ) , request ) ; ( int i = 0 ; i instanc . length ; i ) { int j = ( instanc . length 1 ) i ; ( instanc j = = null ) continu ; ( ( instanc j instanceof servlet request listen ) ) continu ; servlet request listen listen = ( servlet request listen ) instanc j ; try { listen . request destroi ( event ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; get logger ( ) . error ( sm . get string ( standard context . request listen . request init , instanc j . get class ( ) . get name ( ) ) , t ) ; request . set attribut ( request dispatch . error except , t ) ; return fals ; } } } } return true ; }	overrid public boolean fire request init event ( servlet request request ) { object instanc = get applic event listen ( ) ; ( ( instanc = null ) ( instanc . length 0 ) ) { don t fire listen async request ( dispatch type . async . equal ( request . get dispatch type ( ) ) ) { servlet request event event = new servlet request event ( get servlet context ( ) , request ) ; ( int i = 0 ; i instanc . length ; i ) { ( instanc i = = null ) continu ; ( ( instanc i instanceof servlet request listen ) ) continu ; servlet request listen listen = ( servlet request listen ) instanc i ; try { listen . request initi ( event ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; get logger ( ) . error ( sm . get string ( standard context . request listen . request init , instanc i . get class ( ) . get name ( ) ) , t ) ; request . set attribut ( request dispatch . error except , t ) ; return fals ; } } } } return true ; }	select appropri child wrapper process thi request , base specifi request uri . match wrapper can found , return appropri http error . param request request process param respons respons produc except ioexcept input output error occur except servlet except servlet error occur overrid public final void invok ( request request , respons respons ) throw ioexcept , servlet except { disallow ani direct access resourc under web inf meta inf messag byte request path mb = request . get request path mb ( ) ; ( ( request path mb . start ignor case ( meta inf , 0 ) ) ( request path mb . equal ignor case ( meta inf ) ) ( request path mb . start ignor case ( web inf , 0 ) ) ( request path mb . equal ignor case ( web inf ) ) ) { found ( respons ) ; return ; } wait we ar reload boolean reload = fals ; while ( context . get paus ( ) ) { reload = true ; try { thread . sleep ( 1000 ) ; } catch ( interrupt except e ) { ignor } } creat new ( reload context . get loader ( ) = null context . get loader ( ) . get class loader ( ) = null ) { thread . current thread ( ) . set context class loader ( context . get loader ( ) . get class loader ( ) ) ; } select wrapper us thi request wrapper wrapper = request . get wrapper ( ) ; ( wrapper = = null ) { found ( respons ) ; return ; } els ( wrapper . unavail ( ) ) { mai result reload , try find new wrapper wrapper = ( wrapper ) contain . find child ( wrapper . get name ( ) ) ; ( wrapper = = null ) { found ( respons ) ; return ; } } abort ( context . fire request init event ( request ) ) { ( request . async support ( ) ) { request . set async support ( wrapper . get pipelin ( ) . async support ( ) ) ; } wrapper . get pipelin ( ) . get first ( ) . invok ( request , respons ) ; context . fire request destroi event ( request ) ; } }	overrid public void start async ( async event event ) throw ioexcept { servlet respons resp = event . get async context ( ) . get respons ( ) ; resp . get writer ( ) . write ( start async ) ; resp . flush buffer ( ) ; }
protect list resourc given context . void print resourc ( print writer writer , string prefix , javax . name . context name context , string type , class clazz , string manag sm client ) { try { name enumer bind item = name context . list bind ( ) ; while ( item . ha more ( ) ) { bind item = item . next ( ) ; ( item . get object ( ) instanceof javax . name . context ) { print resourc ( writer , prefix item . get name ( ) , ( javax . name . context ) item . get object ( ) , type , clazz , sm client ) ; } els { ( ( clazz = null ) ( ( clazz . instanc ( item . get object ( ) ) ) ) ) { continu ; } writer . print ( prefix item . get name ( ) ) ; writer . print ( : ) ; writer . print ( item . get class name ( ) ) ; do we want descript avail writer . println ( ) ; } } } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log ( manag servlet . resourc type , t ) ; writer . println ( sm client . get string ( manag servlet . except , t . string ( ) ) ) ; } }	process get request specifi resourc . param request servlet request we ar process param respons servlet respons we ar creat except ioexcept input output error occur except servlet except servlet specifi error occur overrid public void do get ( http servlet request request , http servlet respons respons ) throw ioexcept , servlet except { string manag sm client = get string manag ( request ) ; identifi request paramet we need string command = request . get path info ( ) ; ( command = = null ) command = request . get servlet path ( ) ; string config = request . get paramet ( config ) ; string path = request . get paramet ( path ) ; context name cn = null ; ( path = null ) { cn = new context name ( path , request . get paramet ( version ) ) ; } string type = request . get paramet ( type ) ; string war = request . get paramet ( war ) ; string tag = request . get paramet ( tag ) ; boolean updat = fals ; ( ( request . get paramet ( updat ) = null ) ( request . get paramet ( updat ) . equal ( true ) ) ) { updat = true ; } prepar our output writer gener respons messag respons . set content type ( text plain ; charset = constant . charset ) ; print writer writer = respons . get writer ( ) ; process request command ( note deploi list here ) ( command = = null ) { writer . println ( sm client . get string ( manag servlet . command ) ) ; } els ( command . equal ( deploi ) ) { ( war = null config = null ) { deploi ( writer , config , cn , war , updat , sm client ) ; } els { deploi ( writer , cn , tag , sm client ) ; } } els ( command . equal ( list ) ) { list ( writer , sm client ) ; } els ( command . equal ( reload ) ) { reload ( writer , cn , sm client ) ; } els ( command . equal ( resourc ) ) { resourc ( writer , type , sm client ) ; } els ( command . equal ( role ) ) { role ( writer , sm client ) ; } els ( command . equal ( save ) ) { save ( writer , path , sm client ) ; } els ( command . equal ( serverinfo ) ) { serverinfo ( writer , sm client ) ; } els ( command . equal ( session ) ) { expir session ( writer , cn , request , sm client ) ; } els ( command . equal ( expir ) ) { expir session ( writer , cn , request , sm client ) ; } els ( command . equal ( start ) ) { start ( writer , cn , sm client ) ; } els ( command . equal ( stop ) ) { stop ( writer , cn , sm client ) ; } els ( command . equal ( undeploi ) ) { undeploi ( writer , cn , sm client ) ; } els ( command . equal ( findleak ) ) { findleak ( writer , sm client ) ; } els { writer . println ( sm client . get string ( manag servlet . unknown command , command ) ) ; } finish up respons writer . flush ( ) ; writer . close ( ) ; }
privat merg context initi paramet specifi applic deploy descriptor applic paramet describ server configur , respect code overrid code properti applic paramet appropri . void merg paramet ( ) { servlet context sc = get servlet context ( ) ; string name = find paramet ( ) ; ( int i = 0 ; i name . length ; i ) { sc . set init paramet ( name i , find paramet ( name i ) ) ; } applic paramet param = find applic paramet ( ) ; ( int i = 0 ; i param . length ; i ) { ( param i . get overrid ( ) ) { ( sc . get init paramet ( param i . get name ( ) ) = = null ) { sc . set init paramet ( param i . get name ( ) , param i . get valu ( ) ) ; } } els { sc . set init paramet ( param i . get name ( ) , param i . get valu ( ) ) ; } } }
public void execut ( delta session session , boolean notifi listen ) { ( thi . session id . equal ( session . get id ( ) ) ) throw new java . lang . illeg argument except ( session id mismatch , execut delta request ) ; session . access ( ) ; ( int i = 0 ; i action . size ( ) ; i ) { attribut info info = action . get ( i ) ; switch ( info . get type ( ) ) { case type attribut : { ( info . get action ( ) = = action set ) { ( log . trace enabl ( ) ) log . trace ( session . set attribut ( info . get name ( ) , info . get valu ( ) ) ) ; session . set attribut ( info . get name ( ) , info . get valu ( ) , notifi listen , fals ) ; } els { ( log . trace enabl ( ) ) log . trace ( session . remov attribut ( info . get name ( ) ) ) ; session . remov attribut ( info . get name ( ) , notifi listen , fals ) ; } break ; } case case type isnew : { ( log . trace enabl ( ) ) log . trace ( session . set new ( info . get valu ( ) ) ) ; session . set new ( ( ( boolean ) info . get valu ( ) ) . boolean valu ( ) , fals ) ; break ; } case case type maxinterv : { ( log . trace enabl ( ) ) log . trace ( session . set max inact interv ( info . get valu ( ) ) ) ; session . set max inact interv ( ( ( integ ) info . get valu ( ) ) . int valu ( ) , fals ) ; break ; } case case type princip : { princip p = null ; ( info . get action ( ) = = action set ) { serializ princip sp = ( serializ princip ) info . get valu ( ) ; p = sp . get princip ( ) ; } session . set princip ( p , fals ) ; break ; } case default : throw new java . lang . illeg argument except ( invalid attribut info type = info ) ; } switch } session . end access ( ) ; reset ( ) ; }	public void set new ( boolean n ) { int action = action set ; add action ( type isnew , action , name isnew , boolean . valu ( n ) ) ; }	public void set princip ( princip princip , boolean add delta request ) { try { lock ( ) ; super . set princip ( princip ) ; ( add delta request ( delta request = null ) ) delta request . set princip ( princip ) ; } final { unlock ( ) ; } }
overrid public void visit ( node . templat text n ) throw jasper except { string text = n . get text ( ) ; int text size = text . length ( ) ; ( text size = = 0 ) { return ; } ( text size = 3 ) { special case small text string n . set begin java line ( out . get java line ( ) ) ; int line inc = 0 ; ( int i = 0 ; i text size ; i ) { char ch = text . char ( i ) ; out . printil ( out . write ( quot ( ch ) ) ; ) ; ( i 0 ) { n . add smap ( line inc ) ; } ( ch = = n ) { line inc ; } } n . set end java line ( out . get java line ( ) ) ; return ; } ( ctxt . get option ( ) . gen string char arrai ( ) ) { gener string char arrai , perform servlet writer ca out ; ( char arrai buffer = = null ) { char arrai buffer = new gen buffer ( ) ; ca out = char arrai buffer . get out ( ) ; ca out . push indent ( ) ; text map = new hash map string , string ( ) ; } els { ca out = char arrai buffer . get out ( ) ; } string char arrai name = text map . get ( text ) ; ( char arrai name = = null ) { char arrai name = jspx char arrai char arrai count ; text map . put ( text , char arrai name ) ; ca out . printin ( static char ) ; ca out . print ( char arrai name ) ; ca out . print ( = ) ; ca out . print ( quot ( text ) ) ; ca out . println ( . char arrai ( ) ; ) ; } n . set begin java line ( out . get java line ( ) ) ; out . printil ( out . write ( char arrai name ) ; ) ; n . set end java line ( out . get java line ( ) ) ; return ; } n . set begin java line ( out . get java line ( ) ) ; out . printin ( ) ; string builder sb = new string builder ( out . write ( ) ; int init length = sb . length ( ) ; int count = jsp util . chunksiz ; rel start sourc line int src line = 0 ; ( int i = 0 ; i text . length ( ) ; i ) { char ch = text . char ( i ) ; count ; switch ( ch ) { case : sb . append ( ) . append ( ) ; break ; case : sb . append ( ) . append ( ) ; break ; case r : sb . append ( ) . append ( r ) ; break ; case n : sb . append ( ) . append ( n ) ; src line ; ( break lf count 0 ) { gener out . write ( ) when see n templat sb . append ( ) ; ) ; out . println ( sb . string ( ) ) ; ( i text . length ( ) 1 ) { out . printin ( ) ; } sb . set length ( init length ) ; count = jsp util . chunksiz ; } add smap thi line n . add smap ( src line ) ; break ; case sure we need thi t : sb . append ( ) . append ( t ) ; break ; default : sb . append ( ch ) ; } } ( sb . length ( ) init length ) { sb . append ( ) ; ) ; out . println ( sb . string ( ) ) ; } n . set end java line ( out . get java line ( ) ) ; }
public valid connect . param valid action action us . { link valid borrow } , { link valid idl } , { link valid init } { link valid return } param sql sql us dure valid . { link pool configur set init sql ( string ) } ha been call non null valu action { link valid init } init sql us valid . return true connect wa valid successfulli . return true even valid wa perform , when { link pool configur set valid interv ( long ) } ha been call posit valu . p fals valid fail . caller should close connect fals return sinc session could have been left unknown state dure initi . boolean valid ( int valid action , string sql ) { ( thi . discard ( ) ) { return fals ; } ( do valid ( valid action ) ) { valid requir , init sql prop set return true ; } don t bother valid alreadi have recent enough long now = system . current time milli ( ) ; ( valid action = valid init pool properti . get valid interv ( ) 0 ( now thi . last valid ) pool properti . get valid interv ( ) ) { return true ; } ( pool properti . get valid ( ) = null ) { return pool properti . get valid ( ) . valid ( connect , valid action ) ; } string queri = sql ; ( valid action = = valid init pool properti . get init sql ( ) = null ) { queri = pool properti . get init sql ( ) ; } ( queri = = null ) { queri = pool properti . get valid queri ( ) ; } statement stmt = null ; try { stmt = connect . creat statement ( ) ; stmt . execut ( queri ) ; stmt . close ( ) ; thi . last valid = now ; return true ; } catch ( except ignor ) { ( log . debug enabl ( ) ) log . debug ( unabl valid object : , ignor ) ; ( stmt = null ) try { stmt . close ( ) ; } catch ( except ignore2 ) { noop } } return fals ; }
protect us code user pattern code configur attribut locat directori entri user specifi usernam return user object ; otherwis return code null code . param context directori context param usernam usernam param credenti user credenti ( option ) param attr id string contain name attribut param cur user pattern index user pattern format arrai except name except directori server error occur see get user pattern ( dir context , string , string , string ) user get user pattern ( dir context context , string usernam , string credenti , string attr id , int cur user pattern ) throw name except { user user = null ; ( usernam = = null user pattern format arrai cur user pattern = = null ) return ( null ) ; form dn from user pattern string dn = user pattern format arrai cur user pattern . format ( new string { usernam } ) ; try { user = get user pattern ( context , usernam , attr id , dn ) ; } catch ( name found except e ) { return ( null ) ; } catch ( name except e ) { credenti user we re search try { set up secur environ bind user context . add environ ( context . secur princip , dn ) ; context . add environ ( context . secur credenti , credenti ) ; user = get user pattern ( context , usernam , attr id , dn ) ; } final { restor origin secur environ ( connect name = null ) { context . add environ ( context . secur princip , connect name ) ; } els { context . remov from environ ( context . secur princip ) ; } ( connect password = null ) { context . add environ ( context . secur credenti , connect password ) ; } els { context . remov from environ ( context . secur credenti ) ; } } } return user ; }
protect initi name thi should onli enabl java : env root name . tomcat embed applic alreadi defin those shouldn t do . xxx 2 should separ , you mai want enabl java : initi context revers xxx can we guess i . e . lookup java : someth return assum fals xxx we have major problem current set java : url void init name ( ) { set addit variabl ( us name ) { log . info ( catalina name disabl ) ; system . set properti ( catalina . us name , fals ) ; } els { system . set properti ( catalina . us name , true ) ; string valu = org . apach . name ; string old valu = system . get properti ( javax . name . context . url pkg prefix ) ; ( old valu = null ) { valu = valu : old valu ; } system . set properti ( javax . name . context . url pkg prefix , valu ) ; ( log . debug enabl ( ) ) log . debug ( set name prefix = valu ) ; valu = system . get properti ( javax . name . context . initi context factori ) ; ( valu = = null ) { system . set properti ( javax . name . context . initi context factori , org . apach . name . java . java urlcontext factori ) ; } els { log . debug ( initi context factori alread set valu ) ; } } }
public input sourc get input sourc ( ) { return ip ; }	public void close ( ) { ( = null ) { try { . close ( ) ; } catch ( ioexcept e ) { log . error ( local . get messag ( jsp . error . stream . close . fail ) ) ; } } }
public static decod return specifi url encod byte arrai . param byte url encod byte arrai param enc encod us ; null , default encod us . unsupport encod specifi null return param queri thi queri string process except illeg argument except charact follow valid 2 digit hexadecim number string urldecod ( byte byte , string enc , boolean queri ) { ( byte = = null ) return null ; int len = byte . length ; int ix = 0 ; int ox = 0 ; while ( ix len ) { get byte test byte b = byte ix ; ( b = = queri ) { b = ( byte ) ; } els ( b = = ) { ( ix 2 = len ) { throw new illeg argument except ( sm . get string ( request util . url decod . miss digit ) ) ; } b = ( byte ) ( ( convert hex digit ( byte ix ) << 4 ) convert hex digit ( byte ix ) ) ; } byte ox = b ; } ( enc = null ) { try { return new string ( byte , 0 , ox , enc ) ; } catch ( unsupport encod except uee ) { log . debug ( sm . get string ( request util . url decod . uee , enc ) , uee ) ; return null ; } } return new string ( byte , 0 , ox ) ; }	public void test normal string ( ) { assert equal ( someth , request util . normal ( someth ) ) ; assert equal ( some thing , request util . normal ( some thing ) ) ; assert equal ( someth , request util . normal ( someth ) ) ; assert equal ( , request util . normal ( ) ) ; }	public void test urldecod string ( ) { n rather than nn should throw iae accord javadoc except except = null ; try { request util . urldecod ( 5xxxxx ) ; } catch ( except e ) { except = e ; } assert true ( except instanceof illeg argument except ) ; edg case try trigger arrai index out bound except except = null ; try { request util . urldecod ( 5 ) ; } catch ( except e ) { except = e ; } assert true ( except instanceof illeg argument except ) ; }

stop nest compon ( { link servic } s ) implement requir { link org . apach . catalina . util . lifecycl base stop intern ( ) } . except lifecycl except thi compon detect fatal error need report overrid protect void stop intern ( ) throw lifecycl except { set state ( lifecycl state . stop ) ; fire lifecycl event ( configur stop event , null ) ; stop our defin servic ( int i = 0 ; i servic . length ; i ) { servic i . stop ( ) ; } ( port = = 1 ) stop await ( ) ; }	public set global name resourc context . param global name context new global name resourc context void set global name context ( javax . name . context global name context ) { thi . global name context = global name context ; }	wait until proper shutdown command receiv , return . thi keep main thread aliv thread pool listen http connect daemon thread . overrid public void await ( ) { neg valu don t wait port tomcat embed we just don t like port ( port = = 2 ) { undocu yet embed app ar around , aliv . return ; } ( port = = 1 ) { while ( true ) { try { thread . sleep ( 10000 ) ; } catch ( interrupt except ex ) { } ( stop await ) return ; } } set up server socket wait server socket server socket = null ; try { server socket = new server socket ( port , 1 , inet address . get name ( address ) ) ; } catch ( ioexcept e ) { log . error ( standard server . await : creat address : port : , e ) ; system . exit ( 1 ) ; } loop wait connect valid command while ( true ) { wait next connect socket socket = null ; input stream stream = null ; try { socket = server socket . accept ( ) ; ten second socket . set so timeout ( 10 1000 ) ; stream = socket . get input stream ( ) ; } catch ( access control except ac ) { log . warn ( standard server . accept secur except : ac . get messag ( ) , ac ) ; continu ; } catch ( ioexcept e ) { log . error ( standard server . await : accept : , e ) ; system . exit ( 1 ) ; } read set charact from socket string builder command = new string builder ( ) ; cut off avoid do s attack int expect = 1024 ; while ( expect shutdown . length ( ) ) { ( random = = null ) random = new random ( ) ; expect = ( random . next int ( ) 1024 ) ; } while ( expect 0 ) { int ch = 1 ; try { ch = stream . read ( ) ; } catch ( ioexcept e ) { log . warn ( standard server . await : read : , e ) ; ch = 1 ; } ( control charact eof termin loop ch 32 ) break ; command . append ( ( char ) ch ) ; expect ; } close socket now we ar done try { socket . close ( ) ; } catch ( ioexcept e ) { ignor } match against our command string boolean match = command . string ( ) . equal ( shutdown ) ; ( match ) { log . info ( sm . get string ( standard server . shutdown via port ) ) ; break ; } els log . warn ( standard server . await : invalid command command . string ( ) receiv ) ; } close server socket return try { server socket . close ( ) ; } catch ( ioexcept e ) { ignor } }	public stop exist server instanc . void stop ( ) { try { doesn t get invok twice ( us shutdown hook ) { runtim . get runtim ( ) . remov shutdown hook ( shutdown hook ) ; juli us , re enabl juli s shutdown ensur log messag ar lost log manag log manag = log manag . get log manag ( ) ; ( log manag instanceof class loader log manag ) { ( ( class loader log manag ) log manag ) . set us shutdown hook ( true ) ; } } } catch ( throwabl t ) { except util . handl throwabl ( t ) ; thi fail jdk 1 . 2 . ignor , tomcat can run fine without shutdown hook . } shut down server try { get server ( ) . stop ( ) ; } catch ( lifecycl except e ) { log . error ( catalina . stop , e ) ; } }	public void stop await ( ) { stop await = true ; }	public void stop server ( string argument ) { ( argument = null ) { argument ( argument ) ; } ( get server ( ) = = null ) { creat execut our digest digest digest = creat stop digest ( ) ; digest . set class loader ( thread . current thread ( ) . get context class loader ( ) ) ; file file = config file ( ) ; try { input sourc = new input sourc ( file : file . get absolut path ( ) ) ; file input stream fi = new file input stream ( file ) ; . set byte stream ( fi ) ; digest . push ( thi ) ; digest . pars ( ) ; fi . close ( ) ; } catch ( except e ) { log . error ( catalina . stop : , e ) ; system . exit ( 1 ) ; } } els { server object alreadi present . must run servic shutdown hook take care clean up system . exit ( 0 ) ; } stop exist server try { ( get server ( ) . get port ( ) 0 ) { socket socket = new socket ( get server ( ) . get address ( ) , get server ( ) . get port ( ) ) ; output stream stream = socket . get output stream ( ) ; string shutdown = get server ( ) . get shutdown ( ) ; ( int i = 0 ; i shutdown . length ( ) ; i ) stream . write ( shutdown . char ( i ) ) ; stream . flush ( ) ; stream . close ( ) ; socket . close ( ) ; } els { log . error ( sm . get string ( catalina . stop server ) ) ; system . exit ( 1 ) ; } } catch ( ioexcept e ) { log . error ( catalina . stop : , e ) ; system . exit ( 1 ) ; } }
privat void expand ( int newsiz ) { ( newsiz buf . length ) { byte tmp = new byte newsiz ; system . arraycopi ( buf , 0 , tmp , 0 , buf . length ) ; buf = tmp ; } }	protect boolean fill ( boolean timeout , boolean block ) throw ioexcept , eofexcept { boolean read = fals ; ( pars header ) { ( last valid = = buf . length ) { throw new illeg argument except ( sm . get string ( iib . requestheadertoolarg . error ) ) ; } do simpl read short timeout read = read socket ( timeout , block ) 0 ; } els { ( buf . length end 4500 ) { thi case , request header wa realli larg , so we alloc brand new ; old get gced when subsequ request clear all refer buf = new byte buf . length ; end = 0 ; } po = end ; last valid = po ; do simpl read short timeout read = read socket ( timeout , block ) 0 ; } return read ; }	pars http header . overrid public boolean pars header ( ) throw ioexcept { header pars statu statu = header pars statu . have more header ; do { statu = pars header ( ) ; } while ( statu = = header pars statu . have more header ) ; ( statu = = header pars statu . done ) { pars header = fals ; end = po ; return true ; } els { return fals ; } }	read request line . thi function meant us dure http request header pars . do attempt read request bodi us . throw ioexcept except occur dure underli socket read oper , given buffer big enough accommod whole line . return true data properli fed ; fals data avail immedi thread should freed overrid public boolean pars request line ( boolean us avail data onli ) throw ioexcept { check state ( pars request line ) return true ; ( pars request line phase = = 0 ) { byte chr = 0 ; do { read new byte need ( po = last valid ) { ( us avail data onli ) { return fals ; } do simpl read short timeout ( read socket ( true , fals ) = = 0 ) return fals ; } chr = buf po ; } while ( ( chr = = constant . cr ) ( chr = = constant . lf ) ) ; po ; pars request line start = po ; pars request line phase = 1 ; } ( pars request line phase = = 1 ) { mark current buffer posit ( po = last valid ) { ( us avail data onli ) { return fals ; } do simpl read short timeout ( read socket ( true , fals ) = = 0 ) return fals ; } pars request line phase = 2 ; ( log . debug enabl ( ) ) { log . debug ( receiv new string ( buf , po , last valid po , iso 8859 1 ) ) ; } } ( pars request line phase = = 2 ) { read method name method name alwai us ascii boolean space = fals ; while ( space ) { read new byte need ( po = last valid ) { ( request line pars fill ( true , fals ) ) return fals ; } spec sai cr lf method name ( buf po = = constant . cr buf po = = constant . lf ) { throw new illeg argument except ( sm . get string ( iib . invalidmethod ) ) ; } ( buf po = = constant . sp buf po = = constant . ht ) { space = true ; request . method ( ) . set byte ( buf , pars request line start , po pars request line start ) ; } po ; } pars request line phase = 3 ; } ( pars request line phase = = 3 ) { spec sai singl sp also toler multipl ht boolean space = true ; while ( space ) { read new byte need ( po = last valid ) { ( request line pars fill ( true , fals ) ) return fals ; } ( buf po = = constant . sp buf po = = constant . ht ) { po ; } els { space = fals ; } } pars request line start = po ; pars request line phase = 4 ; } ( pars request line phase = = 4 ) { mark current buffer posit int end = 0 ; read uri boolean space = fals ; while ( space ) { read new byte need ( po = last valid ) { ( request line pars fill ( true , fals ) ) return fals ; } ( buf po = = constant . sp buf po = = constant . ht ) { space = true ; end = po ; } els ( ( buf po = = constant . cr ) ( buf po = = constant . lf ) ) { http 0 . 9 style request pars request line eol = true ; space = true ; end = po ; } els ( ( buf po = = constant . question ) ( pars request line qpo = = 1 ) ) { pars request line qpo = po ; } po ; } request . unpars uri ( ) . set byte ( buf , pars request line start , end pars request line start ) ; ( pars request line qpo = 0 ) { request . queri string ( ) . set byte ( buf , pars request line qpo 1 , end pars request line qpo 1 ) ; request . request uri ( ) . set byte ( buf , pars request line start , pars request line qpo pars request line start ) ; } els { request . request uri ( ) . set byte ( buf , pars request line start , end pars request line start ) ; } pars request line phase = 5 ; } ( pars request line phase = = 5 ) { spec sai singl sp also toler multipl ht boolean space = true ; while ( space ) { read new byte need ( po = last valid ) { ( request line pars fill ( true , fals ) ) return fals ; } ( buf po = = constant . sp buf po = = constant . ht ) { po ; } els { space = fals ; } } pars request line start = po ; pars request line phase = 6 ; } ( pars request line phase = = 6 ) { mark current buffer posit end = 0 ; while ( pars request line eol ) { read new byte need ( po = last valid ) { ( request line pars fill ( true , fals ) ) return fals ; } ( buf po = = constant . cr ) { end = po ; } els ( buf po = = constant . lf ) { ( end = = 0 ) end = po ; pars request line eol = true ; } po ; } ( ( end pars request line start ) 0 ) { request . protocol ( ) . set byte ( buf , pars request line start , end pars request line start ) ; } els { request . protocol ( ) . set string ( ) ; } pars request line = fals ; pars request line phase = 0 ; pars request line eol = fals ; pars request line start = 0 ; return true ; } throw new illeg state except ( invalid request line pars phase : pars request line phase ) ; }	public set underli socket . void set socket ( nio channel socket ) { thi . socket = socket ; }
protect string get enabl cipher ( string request cipher , string support cipher ) { string result = null ; ( allow all support cipher . equal ( request cipher ) ) { return support cipher ; } ( request cipher = null ) { vector string vec = null ; string cipher = request cipher ; int index = request cipher . index ( , ) ; ( index = 1 ) { int from index = 0 ; while ( index = 1 ) { cipher = request cipher . substr ( from index , index ) . trim ( ) ; ( cipher . length ( ) 0 ) { check see request cipher among support cipher , i . e . , mai enabl ( int i = 0 ; support cipher = null i support cipher . length ; i ) { ( support cipher i . equal ( cipher ) ) { ( vec = = null ) { vec = new vector string ( ) ; } vec . add element ( cipher ) ; break ; } } } from index = index 1 ; index = request cipher . index ( , , from index ) ; } while cipher = request cipher . substr ( from index ) ; } ( cipher = null ) { cipher = cipher . trim ( ) ; ( cipher . length ( ) 0 ) { check see request cipher among support cipher , i . e . , mai enabl ( int i = 0 ; support cipher = null i support cipher . length ; i ) { ( support cipher i . equal ( cipher ) ) { ( vec = = null ) { vec = new vector string ( ) ; } vec . add element ( cipher ) ; break ; } } } } ( vec = null ) { result = new string vec . size ( ) ; vec . copi ( result ) ; } } els { result = ssl proxi . get default cipher suit ( ) ; } return result ; }
retriev all attribut associ name object . return set attribut associ name . return empti attribut set name ha attribut ; never null . param name name object from which retriev attribut except name except name except encount overrid public attribut get attribut ( name name , string attr id ) throw name except { entri entri = null ; ( name . empti ( ) ) entri = entri ; els entri = tree lookup ( name ) ; ( entri = = null ) return null ; zip entri zip entri = entri . get entri ( ) ; resourc attribut attr = new resourc attribut ( ) ; attr . set creation date ( new date ( zip entri . get time ( ) ) ) ; attr . set name ( entri . get name ( ) ) ; ( zip entri . directori ( ) ) attr . set resourc type ( ) ; attr . set content length ( zip entri . get size ( ) ) ; attr . set last modifi ( zip entri . get time ( ) ) ; return attr ; }
public static object coerc ( string s , class target ) { boolean null empti = ( s = = null s . length ( ) = = 0 ) ; ( target = = boolean . class ) { ( null empti ) { s = fals ; } return boolean . valu ( s ) ; } els ( target = = byte . class ) { ( null empti ) return new byte ( ( byte ) 0 ) ; els return new byte ( s ) ; } els ( target = = charact . class ) { ( null empti ) return new charact ( ( char ) 0 ) ; els return new charact ( s . char ( 0 ) ) ; } els ( target = = doubl . class ) { ( null empti ) return new doubl ( 0 ) ; els return new doubl ( s ) ; } els ( target = = float . class ) { ( null empti ) return new float ( 0 ) ; els return new float ( s ) ; } els ( target = = integ . class ) { ( null empti ) return new integ ( 0 ) ; els return new integ ( s ) ; } els ( target = = short . class ) { ( null empti ) return new short ( ( short ) 0 ) ; els return new short ( s ) ; } els ( target = = long . class ) { ( null empti ) return new long ( 0 ) ; els return new long ( s ) ; } els { return null ; } }	public static begin convert method object convert ( string properti name , string s , class t , class properti editor class ) throw jasper except { try { ( s = = null ) { ( t . equal ( boolean . class ) t . equal ( boolean . type ) ) s = fals ; els return null ; } ( properti editor class = null ) { return get valu from bean info properti editor ( t , properti name , s , properti editor class ) ; } els ( t . equal ( boolean . class ) t . equal ( boolean . type ) ) { ( s . equal ignor case ( ) s . equal ignor case ( true ) ) s = true ; els s = fals ; return boolean . valu ( s ) ; } els ( t . equal ( byte . class ) t . equal ( byte . type ) ) { return new byte ( s ) ; } els ( t . equal ( charact . class ) t . equal ( charact . type ) ) { return s . length ( ) 0 new charact ( s . char ( 0 ) ) : null ; } els ( t . equal ( short . class ) t . equal ( short . type ) ) { return new short ( s ) ; } els ( t . equal ( integ . class ) t . equal ( integ . type ) ) { return new integ ( s ) ; } els ( t . equal ( float . class ) t . equal ( float . type ) ) { return new float ( s ) ; } els ( t . equal ( long . class ) t . equal ( long . type ) ) { return new long ( s ) ; } els ( t . equal ( doubl . class ) t . equal ( doubl . type ) ) { return new doubl ( s ) ; } els ( t . equal ( string . class ) ) { return s ; } els ( t . equal ( java . io . file . class ) ) { return new java . io . file ( s ) ; } els ( t . get name ( ) . equal ( java . lang . object ) ) { return new object { s } ; } els { return get valu from properti editor manag ( t , properti name , s ) ; } } catch ( except ex ) { throw new jasper except ( ex ) ; } }	public static string string ( boolean b ) { return boolean . valu ( b ) . string ( ) ; }	public static string string ( byte b ) { return new byte ( b ) . string ( ) ; }	public static string string ( char c ) { return new charact ( c ) . string ( ) ; }	public static string string ( doubl d ) { return new doubl ( d ) . string ( ) ; }	public static string string ( float f ) { return new float ( f ) . string ( ) ; }	public static string string ( int i ) { return new integ ( i ) . string ( ) ; }	public static string string ( long l ) { return new long ( l ) . string ( ) ; }	public static string string ( short s ) { return new short ( s ) . string ( ) ; }	public static boolean coerc boolean ( string s ) { ( s = = null s . length ( ) = = 0 ) return fals ; els return boolean . valu ( s ) . boolean valu ( ) ; }	public static byte coerc byte ( string s ) { ( s = = null s . length ( ) = = 0 ) return ( byte ) 0 ; els return byte . valu ( s ) . byte valu ( ) ; }	public static doubl coerc doubl ( string s ) { ( s = = null s . length ( ) = = 0 ) return 0 ; els return doubl . valu ( s ) . doubl valu ( ) ; }	public static float coerc float ( string s ) { ( s = = null s . length ( ) = = 0 ) return 0 ; els return float . valu ( s ) . float valu ( ) ; }	public static int coerc int ( string s ) { ( s = = null s . length ( ) = = 0 ) return 0 ; els return integ . valu ( s ) . int valu ( ) ; }	public static long coerc long ( string s ) { ( s = = null s . length ( ) = = 0 ) return 0 ; els return long . valu ( s ) . long valu ( ) ; }	public static short coerc short ( string s ) { ( s = = null s . length ( ) = = 0 ) return ( short ) 0 ; els return short . valu ( s ) . short valu ( ) ; }	public static creat type arrai . thi special case where param ar pass through request properti index . void creat type arrai ( string properti name , object bean , method method , string valu , class t , class properti editor class ) throw jasper except { try { ( properti editor class = null ) { object tmpval = new integ valu . length ; ( int i = 0 ; i valu . length ; i ) { tmpval i = get valu from bean info properti editor ( t , properti name , valu i , properti editor class ) ; } method . invok ( bean , new object { tmpval } ) ; } els ( t . equal ( integ . class ) ) { integ tmpval = new integ valu . length ; ( int i = 0 ; i valu . length ; i ) tmpval i = new integ ( valu i ) ; method . invok ( bean , new object { tmpval } ) ; } els ( t . equal ( byte . class ) ) { byte tmpval = new byte valu . length ; ( int i = 0 ; i valu . length ; i ) tmpval i = new byte ( valu i ) ; method . invok ( bean , new object { tmpval } ) ; } els ( t . equal ( boolean . class ) ) { boolean tmpval = new boolean valu . length ; ( int i = 0 ; i valu . length ; i ) tmpval i = boolean . valu ( valu i ) ; method . invok ( bean , new object { tmpval } ) ; } els ( t . equal ( short . class ) ) { short tmpval = new short valu . length ; ( int i = 0 ; i valu . length ; i ) tmpval i = new short ( valu i ) ; method . invok ( bean , new object { tmpval } ) ; } els ( t . equal ( long . class ) ) { long tmpval = new long valu . length ; ( int i = 0 ; i valu . length ; i ) tmpval i = new long ( valu i ) ; method . invok ( bean , new object { tmpval } ) ; } els ( t . equal ( doubl . class ) ) { doubl tmpval = new doubl valu . length ; ( int i = 0 ; i valu . length ; i ) tmpval i = new doubl ( valu i ) ; method . invok ( bean , new object { tmpval } ) ; } els ( t . equal ( float . class ) ) { float tmpval = new float valu . length ; ( int i = 0 ; i valu . length ; i ) tmpval i = new float ( valu i ) ; method . invok ( bean , new object { tmpval } ) ; } els ( t . equal ( charact . class ) ) { charact tmpval = new charact valu . length ; ( int i = 0 ; i valu . length ; i ) tmpval i = new charact ( valu i . char ( 0 ) ) ; method . invok ( bean , new object { tmpval } ) ; } els ( t . equal ( int . class ) ) { int tmpval = new int valu . length ; ( int i = 0 ; i valu . length ; i ) tmpval i = integ . pars int ( valu i ) ; method . invok ( bean , new object { tmpval } ) ; } els ( t . equal ( byte . class ) ) { byte tmpval = new byte valu . length ; ( int i = 0 ; i valu . length ; i ) tmpval i = byte . pars byte ( valu i ) ; method . invok ( bean , new object { tmpval } ) ; } els ( t . equal ( boolean . class ) ) { boolean tmpval = new boolean valu . length ; ( int i = 0 ; i valu . length ; i ) tmpval i = ( boolean . valu ( valu i ) ) . boolean valu ( ) ; method . invok ( bean , new object { tmpval } ) ; } els ( t . equal ( short . class ) ) { short tmpval = new short valu . length ; ( int i = 0 ; i valu . length ; i ) tmpval i = short . pars short ( valu i ) ; method . invok ( bean , new object { tmpval } ) ; } els ( t . equal ( long . class ) ) { long tmpval = new long valu . length ; ( int i = 0 ; i valu . length ; i ) tmpval i = long . pars long ( valu i ) ; method . invok ( bean , new object { tmpval } ) ; } els ( t . equal ( doubl . class ) ) { doubl tmpval = new doubl valu . length ; ( int i = 0 ; i valu . length ; i ) tmpval i = doubl . valu ( valu i ) . doubl valu ( ) ; method . invok ( bean , new object { tmpval } ) ; } els ( t . equal ( float . class ) ) { float tmpval = new float valu . length ; ( int i = 0 ; i valu . length ; i ) tmpval i = float . valu ( valu i ) . float valu ( ) ; method . invok ( bean , new object { tmpval } ) ; } els ( t . equal ( char . class ) ) { char tmpval = new char valu . length ; ( int i = 0 ; i valu . length ; i ) tmpval i = valu i . char ( 0 ) ; method . invok ( bean , new object { tmpval } ) ; } els { object tmpval = new integ valu . length ; ( int i = 0 ; i valu . length ; i ) { tmpval i = get valu from properti editor manag ( t , properti name , valu i ) ; } method . invok ( bean , new object { tmpval } ) ; } } catch ( except ex ) { throw new jasper except ( error invok method , ex ) ; } }	public static void handl set properti ( object bean , string prop , boolean valu ) throw jasper except { try { method method = get write method ( bean . get class ( ) , prop ) ; method . invok ( bean , new object { boolean . valu ( valu ) } ) ; } catch ( except ex ) { throw new jasper except ( ex ) ; } }
privat compil load tagfil . class load tag file ( compil compil , string tag file path , tag info tag info , page info parent page info ) throw jasper except { jar resourc tag jar resouc = null ; ( tag file path . start ( meta inf ) ) { tag jar resouc = compil . get compil context ( ) . get tld locat ( tag info . get tag librari ( ) . get uri ( ) ) . get jar resourc ( ) ; } string wrapper uri ; ( tag jar resouc = = null ) { wrapper uri = tag file path ; } els { wrapper uri = tag jar resouc . get entri ( tag file path ) . string ( ) ; } jsp compil context ctxt = compil . get compil context ( ) ; jsp runtim context rctxt = ctxt . get runtim context ( ) ; jsp servlet wrapper wrapper = rctxt . get wrapper ( wrapper uri ) ; synchron ( rctxt ) { ( wrapper = = null ) { wrapper = new jsp servlet wrapper ( ctxt . get servlet context ( ) , ctxt . get option ( ) , tag file path , tag info , ctxt . get runtim context ( ) , tag jar resouc ) ; rctxt . add wrapper ( wrapper uri , wrapper ) ; us same classload classpath compil tag file wrapper . get jsp engin context ( ) . set class loader ( ctxt . get class loader ( ) ) ; wrapper . get jsp engin context ( ) . set class path ( ctxt . get class path ( ) ) ; } els { make sure jsp compil context get latest tag info tag file . tag info instanc wa creat last time tag file wa scan direct , tag file mai have been modifi sinc . wrapper . get jsp engin context ( ) . set tag info ( tag info ) ; } class tag clazz ; int trip count = wrapper . inc trip count ( ) ; try { ( trip count 0 ) { when trip count greater than zero , circular depend exist . circularli depend tag file compil prototyp mode , avoid infinit recurs . jsp servlet wrapper temp wrapper = new jsp servlet wrapper ( ctxt . get servlet context ( ) , ctxt . get option ( ) , tag file path , tag info , ctxt . get runtim context ( ) , ctxt . get tag file jar resourc ( tag file path ) ) ; us same classload classpath compil tag file temp wrapper . get jsp engin context ( ) . set class loader ( ctxt . get class loader ( ) ) ; temp wrapper . get jsp engin context ( ) . set class path ( ctxt . get class path ( ) ) ; tag clazz = temp wrapper . load tag file prototyp ( ) ; temp vector . add ( temp wrapper . get jsp engin context ( ) . get compil ( ) ) ; } els { tag clazz = wrapper . load tag file ( ) ; } } final { wrapper . dec trip count ( ) ; } can onli obtain from tag instanc . try { object tag = tag clazz . new instanc ( ) ; ( tag instanceof jsp sourc depend ) { iter string iter = ( ( jsp sourc depend ) tag ) . get depend ( ) . iter ( ) ; while ( iter . ha next ( ) ) { parent page info . add depend ( iter . next ( ) ) ; } } } catch ( except e ) { ignor error } return tag clazz ; } }
protect return file object repres applic root directori our associ host . file get app base ( ) { ( app base = null ) { return app base ; } file file = new file ( host . get app base ( ) ) ; ( file . absolut ( ) ) file = new file ( system . get properti ( global . catalina base prop ) , host . get app base ( ) ) ; try { app base = file . get canon file ( ) ; } catch ( ioexcept e ) { app base = file ; } return ( app base ) ; }	protect invok remov method deploy . void remov ( string path ) throw except { todo handl remov also work dir content stop context first nicer context context = ( context ) host . find child ( path ) ; ( context = null ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( farm war deploy . undeploi local , path ) ) ; context . stop ( ) ; string base name = context . get base name ( ) ; file war = new file ( get app base ( ) , base name . war ) ; file dir = new file ( get app base ( ) , base name ) ; file xml = new file ( config base , base name . xml ) ; ( war . exist ( ) ) { ( war . delet ( ) ) { log . error ( sm . get string ( farm war deploy . delet fail , war ) ) ; } } els ( dir . exist ( ) ) { undeploi dir ( dir ) ; } els { ( xml . delet ( ) ) { log . error ( sm . get string ( farm war deploy . delet fail , xml ) ) ; } } perform new deploy remov intern host config state check ( path ) ; } }	public string get context path ( ) { return context path ; }	befor cluster invok messag receiv cluster ask receiv accept declin messag , futur , when messag get big , accept method onli take messag header param msg cluster messag return boolean return true indic messag receiv should invok . fals return , messag receiv method invok . overrid public boolean accept ( cluster messag msg ) { return ( msg instanceof file messag ) ( msg instanceof undeploi messag ) ; }	public write messag file . ( msg . get messag number ( ) = = msg . get total nr msg ( ) ) output stream close after write . param msg file messag messag contain data written throw illeg argument except factori open read close throw ioexcept file write error occur return return true file complet outputstream close , fals otherwis . boolean write messag ( file messag msg ) throw illeg argument except , ioexcept { ( open write ) throw new illeg argument except ( can t write messag , thi factori read . ) ; ( log . debug enabl ( ) ) log . debug ( messag msg data hex util . hex string ( msg . get data ( ) ) data length msg . get data length ( ) out out ) ; ( msg . get messag number ( ) = last messag process . get ( ) ) { duplic messag alreadi process log . warn ( receiv messag again sender act timeout too short path : msg . get context path ( ) war : msg . get file name ( ) data : hex util . hex string ( msg . get data ( ) ) data length : msg . get data length ( ) ) ; return fals ; } file messag previou = msg buffer . put ( long . valu ( msg . get messag number ( ) ) , msg ) ; ( previou = null ) { duplic messag yet process log . warn ( receiv messag again sender act timeout too short path : msg . get context path ( ) war : msg . get file name ( ) data : hex util . hex string ( msg . get data ( ) ) data length : msg . get data length ( ) ) ; return fals ; } file messag next = null ; synchron ( thi ) { ( write ) { next = msg buffer . get ( long . valu ( last messag process . get ( ) 1 ) ) ; ( next = null ) { write = true ; } els { return fals ; } } els { return fals ; } } while ( next = null ) { out . write ( next . get data ( ) , 0 , next . get data length ( ) ) ; last messag process . increment get ( ) ; out . flush ( ) ; ( next . get messag number ( ) = = next . get total nr msg ( ) ) { out . close ( ) ; cleanup ( ) ; return true ; } synchron ( thi ) { next = msg buffer . get ( long . valu ( last messag process . get ( ) 1 ) ) ; ( next = = null ) { write = fals ; } } } return fals ; }	public synchron creat factori all transport war file param msg return factori all app messag ( war file ) throw java . io . file found except throw java . io . ioexcept file messag factori get factori ( file messag msg ) throw java . io . file found except , java . io . ioexcept { file tmp file = new file ( msg . get file name ( ) ) ; file write file = new file ( get temp dir ( ) , tmp file . get name ( ) ) ; file messag factori factori = file factori . get ( msg . get file name ( ) ) ; ( factori = = null ) { factori = file messag factori . get instanc ( write file , true ) ; file factori . put ( msg . get file name ( ) , factori ) ; } return factori ; }	modif from watch dir war detect see org . apach . catalina . ha . deploi . file chang listen file modifi ( file ) overrid public void file modifi ( file new war ) { try { file deploi war = new file ( get deploi dir ( ) , new war . get name ( ) ) ; copi ( new war , deploi war ) ; string context name = get context name ( deploi war ) ; ( log . info enabl ( ) ) log . info ( sm . get string ( farm war deploy . mod instal , context name , deploi war . get absolut path ( ) ) ) ; try { remov ( context name , fals ) ; } catch ( except x ) { log . error ( sm . get string ( farm war deploy . mod remov fail ) , x ) ; } instal ( context name , deploi war . uri ( ) . url ( ) ) ; } catch ( except x ) { log . error ( sm . get string ( farm war deploy . mod instal fail ) , x ) ; } }	war remov from watch dir see org . apach . catalina . ha . deploi . file chang listen file remov ( file ) overrid public void file remov ( file remov war ) { try { string context name = get context name ( remov war ) ; ( log . info enabl ( ) ) log . info ( sm . get string ( farm war deploy . remov local , context name ) ) ; remov ( context name , true ) ; } catch ( except x ) { log . error ( sm . get string ( farm war deploy . remov local fail ) , x ) ; } }	instal new web applic , whose web applic archiv specifi url , thi contain all other member cluster specifi context path . context path ( empti string ) should us root applic thi contain . otherwis , context path must start slash . p thi applic successfulli instal local , contain event type code instal event code sent all regist listen , newli creat code context code argument . param context path context path which thi applic should instal ( must uniqu ) param war url type jar : point war file , type file : point unpack directori structur contain web applic instal except illeg argument except specifi context path malform ( must start slash ) except illeg state except specifi context path alreadi attach exist web applic except ioexcept input output error wa encount dure instal overrid public void instal ( string context path , url war ) throw ioexcept { member member = get cluster ( ) . get member ( ) ; member local member = get cluster ( ) . get local member ( ) ; file messag factori factori = file messag factori . get instanc ( new file ( war . get file ( ) ) , fals ) ; file messag msg = new file messag ( local member , war . get file ( ) , context path ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( farm war deploy . send start , context path , war ) ) ; msg = factori . read messag ( msg ) ; while ( msg = null ) { ( int i = 0 ; i member . length ; i ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( farm war deploy . send fragment , context path , war , member i ) ) ; get cluster ( ) . send ( msg , member i ) ; } msg = factori . read messag ( msg ) ; } ( log . debug enabl ( ) ) log . debug ( sm . get string ( farm war deploy . send end , context path , war ) ) ; }	callback from cluster , when messag receiv , cluster broadcast invok messag receiv receiv . param msg cluster messag messag receiv from cluster overrid public void messag receiv ( cluster messag msg ) { try { ( msg instanceof file messag ) { file messag fmsg = ( file messag ) msg ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( farm war deploy . msg rx deploi , fmsg . get context path ( ) , fmsg . get file name ( ) ) ) ; file messag factori factori = get factori ( fmsg ) ; todo correct second try after app servic ( factori . write messag ( fmsg ) ) { last messag receiv war file complet string name = factori . get file ( ) . get name ( ) ; ( name . end ( . war ) ) name = name . war ; file deploy = new file ( get deploi dir ( ) , name ) ; try { string path = fmsg . get context path ( ) ; ( servic ( path ) ) { add servic ( path ) ; try { remov ( path ) ; ( factori . get file ( ) . renam ( deploy ) ) { log . error ( sm . get string ( farm war deploy . renam fail , factori . get file ( ) , deploy ) ) ; } check ( path ) ; } final { remov servic ( path ) ; } ( log . debug enabl ( ) ) log . debug ( sm . get string ( farm war deploy . deploi end , path ) ) ; } els log . error ( sm . get string ( farm war deploy . servic deploi , path , name ) ) ; } catch ( except ex ) { log . error ( ex ) ; } final { remov factori ( fmsg ) ; } } } els ( msg instanceof undeploi messag ) { try { undeploi messag umsg = ( undeploi messag ) msg ; string path = umsg . get context path ( ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( farm war deploy . msg rx undeploi , path ) ) ; ( servic ( path ) ) { add servic ( path ) ; try { remov ( path ) ; } final { remov servic ( path ) ; } ( log . debug enabl ( ) ) log . debug ( sm . get string ( farm war deploy . undeploi end , path ) ) ; } els log . error ( sm . get string ( farm war deploy . servic uneploi , path ) ) ; } catch ( except ex ) { log . error ( ex ) ; } } } catch ( java . io . ioexcept x ) { log . error ( sm . get string ( farm war deploy . msg ioe ) , x ) ; } }	remov exist web applic , attach specifi context path . thi applic successfulli remov , contain event type code remov event code sent all regist listen , remov code context code argument . delet web applic war file directori thei exist host s app base . param context path context path applic remov param undeploi boolean flag remov web applic from server except illeg argument except specifi context path malform ( must start slash ) except illeg argument except specifi context path doe identifi current instal web applic except ioexcept input output error occur dure remov overrid public void remov ( string context path , boolean undeploi ) throw ioexcept { ( log . info enabl ( ) ) log . info ( sm . get string ( farm war deploy . remov start , context path ) ) ; member local member = get cluster ( ) . get local member ( ) ; undeploi messag msg = new undeploi messag ( local member , system . current time milli ( ) , undeploi : context path : system . current time milli ( ) , context path , undeploi ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( farm war deploy . remov tx msg , context path ) ) ; cluster . send ( msg ) ; remov local ( undeploi ) { try { ( servic ( context path ) ) { add servic ( context path ) ; try { remov ( context path ) ; } final { remov servic ( context path ) ; } } els log . error ( sm . get string ( farm war deploy . remov fail remot , context path ) ) ; } catch ( except ex ) { log . error ( sm . get string ( farm war deploy . remov fail local , context path ) , ex ) ; } } }	public void set file name ( string file name ) { thi . file name = file name ; }	overrid public void set uniqu id ( string uniqu id ) { thi . uniqu id = uniqu id ; }
thread . stop ( ) suppress warn ( deprec ) privat void clear refer thread ( ) { thread thread = get thread ( ) ; iter over set thread ( thread thread : thread ) { ( thread = null ) { class loader ccl = thread . get context class loader ( ) ; ( ccl = = thi ) { don t warn about thi thread ( thread = = thread . current thread ( ) ) { continu ; } skip thread have alreadi di ( thread . aliv ( ) ) { continu ; } don t warn about jvm control thread thread group tg = thread . get thread group ( ) ; ( tg = null jvm thread group name . contain ( tg . get name ( ) ) ) { continu ; } timer thread can stop safe so treat separ ( thread . get class ( ) . get name ( ) . equal ( java . util . timer thread ) clear refer stop timer thread ) { clear refer stop timer thread ( thread ) ; continu ; } ( request thread ( thread ) ) { log . error ( sm . get string ( webapp class loader . warn request thread , context name , thread . get name ( ) ) ) ; } els { log . error ( sm . get string ( webapp class loader . warn thread , context name , thread . get name ( ) ) ) ; } configur do so ( clear refer stop thread ) { continu ; } shut down executor try { field target field = thread . get class ( ) . get declar field ( target ) ; target field . set access ( true ) ; object target = target field . get ( thread ) ; ( target = null target . get class ( ) . get canon name ( ) . equal ( java . util . concurr . thread pool executor . worker ) ) { field executor field = target . get class ( ) . get declar field ( thi 0 ) ; executor field . set access ( true ) ; object executor = executor field . get ( target ) ; ( executor instanceof thread pool executor ) { ( ( thread pool executor ) executor ) . shutdown now ( ) ; } } } catch ( secur except e ) { log . warn ( sm . get string ( webapp class loader . stop thread fail , thread . get name ( ) , context name ) , e ) ; } catch ( field except e ) { log . warn ( sm . get string ( webapp class loader . stop thread fail , thread . get name ( ) , context name ) , e ) ; } catch ( illeg argument except e ) { log . warn ( sm . get string ( webapp class loader . stop thread fail , thread . get name ( ) , context name ) , e ) ; } catch ( illeg access except e ) { log . warn ( sm . get string ( webapp class loader . stop thread fail , thread . get name ( ) , context name ) , e ) ; } thi method deprec good reason . thi veri riski code onli option thi point . veri good reason app do thi clean up themselv . thread . stop ( ) ; } } } }	start associ { link class loader } implement requir { link org . apach . catalina . util . lifecycl base start intern ( ) } . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect void start intern ( ) throw lifecycl except { ( log . debug enabl ( ) ) log . debug ( sm . get string ( webapp loader . start ) ) ; ( contain . get resourc ( ) = = null ) { log . info ( resourc contain ) ; set state ( lifecycl state . start ) ; return ; } regist stream handler factori jndi protocol urlstream handler factori stream handler factori = new dir context urlstream handler factori ( ) ; ( first ) { first = fals ; try { url . set urlstream handler factori ( stream handler factori ) ; } catch ( except e ) { log continu anywai , thi critic log . error ( error regist jndi stream handler , e ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; thi like dual registr log . info ( dual registr jndi stream handler : t . get messag ( ) ) ; } } construct class loader base our current repositori list try { class loader = creat class loader ( ) ; class loader . set resourc ( contain . get resourc ( ) ) ; class loader . set deleg ( thi . deleg ) ; class loader . set search extern first ( search extern first ) ; ( contain instanceof standard context ) { class loader . set anti jarlock ( ( ( standard context ) contain ) . get anti jarlock ( ) ) ; class loader . set clear refer static ( ( ( standard context ) contain ) . get clear refer static ( ) ) ; class loader . set clear refer stop thread ( ( ( standard context ) contain ) . get clear refer stop thread ( ) ) ; class loader . set clear refer stop timer thread ( ( ( standard context ) contain ) . get clear refer stop timer thread ( ) ) ; } ( int i = 0 ; i repositori . length ; i ) { class loader . add repositori ( repositori i ) ; } configur our repositori set repositori ( ) ; set class path ( ) ; set permiss ( ) ; ( ( lifecycl ) class loader ) . start ( ) ; bind webapp class loader directori context dir context urlstream handler . bind ( class loader , thi . contain . get resourc ( ) ) ; standard context ctx = ( standard context ) contain ; string context name = ctx . get name ( ) ; ( context name . start ( ) ) { context name = context name ; } object name clonam = new object name ( mbean util . get domain ( ctx ) : type = webapp class loader , context = context name , host = ctx . get parent ( ) . get name ( ) ) ; registri . get registri ( null , null ) . regist compon ( class loader , clonam , null ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( lifecycl except , t ) ; throw new lifecycl except ( start : , t ) ; } set state ( lifecycl state . start ) ; }	overrid public void lifecycl event ( lifecycl event event ) { initialis class when tomcat start ( lifecycl . befor init event . equal ( event . get type ( ) ) ) { class loader loader = thread . current thread ( ) . get context class loader ( ) ; try { us system classload victim all thi class loader pin we re about do . thread . current thread ( ) . set context class loader ( class loader . get system class loader ( ) ) ; issu . ( app context protect ) { imag io . get cach directori ( ) ; } sever compon end up call : sun . misc . gc . request latenc ( long ) those librari compon known trigger memori leak due eventu call request latenc ( long ) ar : javax . manag . remot . rmi . rmiconnector server . start ( ) ( gc daemon protect ) { try { class clazz = class . name ( sun . misc . gc ) ; method method = clazz . get declar method ( request latenc , new class { long . class } ) ; method . invok ( null , long . valu ( 3600000 ) ) ; } catch ( class found except e ) { ( system . get properti ( java . vendor ) . start ( sun ) ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } els { log . debug ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } } catch ( secur except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } catch ( method except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } catch ( illeg argument except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } catch ( illeg access except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } catch ( invoc target except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } } when servlet open connect us url us sun . net . www . http . http client which keep static refer keep aliv cach which load us web applic class loader . ( keep aliv protect ) { try { class . name ( sun . net . www . http . http client ) ; } catch ( class found except e ) { ( system . get properti ( java . vendor ) . start ( sun ) ) { log . error ( sm . get string ( jre leak listen . keep aliv fail ) , e ) ; } els { log . debug ( sm . get string ( jre leak listen . keep aliv fail ) , e ) ; } } } call get polici retain static refer context class loader . ( secur polici protect ) { try { polici . get polici ( ) ; class polici class = class . name ( javax . secur . auth . polici ) ; method method = polici class . get method ( get polici ) ; method . invok ( null ) ; } catch ( class found except e ) { ignor . class deprec . } catch ( secur except e ) { ignor . don t need call get polici ( ) success , just need trigger static initi . } catch ( method except e ) { log . warn ( sm . get string ( jre leak listen . auth polici fail ) , e ) ; } catch ( illeg argument except e ) { log . warn ( sm . get string ( jre leak listen . auth polici fail ) , e ) ; } catch ( illeg access except e ) { log . warn ( sm . get string ( jre leak listen . auth polici fail ) , e ) ; } catch ( invoc target except e ) { log . warn ( sm . get string ( jre leak listen . auth polici fail ) , e ) ; } } initi javax . secur . auth . login . configur retain static refer context class loader . ( secur login configur protect ) { try { class . name ( javax . secur . auth . login . configur , true , class loader . get system class loader ( ) ) ; } catch ( class found except e ) { ignor } } creat messag digest dure web applic startup initi java cryptographi architectur . under certain condit thi start token poller thread tccl equal web applic class loader . instead we initi jca right now . ( token poller protect ) { java . secur . secur . get provid ( ) ; } set default url cach polici cach ( url cach protect ) { try { doesn t matter thi jar doesn t exist just long url well form url url = new url ( jar : file : dummi . jar ) ; urlconnect u conn = url . open connect ( ) ; u conn . set default us cach ( fals ) ; } catch ( malform urlexcept e ) { log . error ( sm . get string ( jre leak listen . jar url conn cach fail ) , e ) ; } catch ( ioexcept e ) { log . error ( sm . get string ( jre leak listen . jar url conn cach fail ) , e ) ; } } haven t got root what go thi leak web app first make call below web applic class loader pin memori . ( xml pars protect ) { document builder factori factori = document builder factori . new instanc ( ) ; try { factori . new document builder ( ) ; } catch ( parser configur except e ) { log . error ( sm . get string ( jre leak listen . xml pars fail ) , e ) ; } } ( ldap pool protect ) { try { class . name ( com . sun . jndi . ldap . ldap pool manag ) ; } catch ( class found except e ) { ( system . get properti ( java . vendor ) . start ( sun ) ) { log . error ( sm . get string ( jre leak listen . ldap pool manag fail ) , e ) ; } els { log . debug ( sm . get string ( jre leak listen . ldap pool manag fail ) , e ) ; } } } } final { thread . current thread ( ) . set context class loader ( loader ) ; } } }	public set clear refer log factori releas featur thi context . param clear refer log factori releas new flag valu void set clear refer log factori releas ( boolean clear refer log factori releas ) { thi . clear refer log factori releas = clear refer log factori releas ; }	public set clear refer stop timer thread featur thi context . param clear refer stop timer thread new flag valu void set clear refer stop timer thread ( boolean clear refer stop timer thread ) { boolean old clear refer stop timer thread = thi . clear refer stop timer thread ; thi . clear refer stop timer thread = clear refer stop timer thread ; support . fire properti chang ( clear refer stop timer thread , old clear refer stop timer thread , thi . clear refer stop timer thread ) ; }	public boolean keep aliv protect ( ) { return keep aliv protect ; }
see java . io . externaliz read extern param object input throw ioexcept overrid public void read extern ( object input ) throw ioexcept { int length = . read int ( ) ; messag = new byte length ; . read ( messag , 0 , length ) ; }
privat bind current thread , both cl purpos jndi enc support dure : startup , shutdown reaload context . return previou context class loader class loader bind thread ( ) { class loader old context class loader = thread . current thread ( ) . get context class loader ( ) ; ( get resourc ( ) = = null ) return old context class loader ; ( get loader ( ) . get class loader ( ) = null ) { thread . current thread ( ) . set context class loader ( get loader ( ) . get class loader ( ) ) ; } dir context urlstream handler . bind thread ( get resourc ( ) ) ; ( us name ( ) ) { try { context bind . bind thread ( thi , thi ) ; } catch ( name except e ) { silent catch , thi normal case dure earli startup stage } } return old context class loader ; }	protect return file object repres base directori entir servlet contain ( i . e . engin contain present ) . file engin base ( ) { string base = system . get properti ( global . catalina base prop ) ; ( base = = null ) { standard engin eng = ( standard engin ) thi . get parent ( ) . get parent ( ) ; base = eng . get base dir ( ) ; } return ( new file ( base ) ) ; }
public releas all object refer , initi instanc variabl , prepar reus thi object . void recycl ( ) { context = null ; wrapper = null ; intern dispatch type = null ; request dispatch path = null ; comet = fals ; ( event = null ) { event . clear ( ) ; event = null ; } auth type = null ; input buffer . recycl ( ) ; us input stream = fals ; us reader = fals ; user princip = null ; subject = null ; session pars = fals ; paramet pars = fals ; part = null ; part pars except = null ; cooki pars = fals ; local . clear ( ) ; local pars = fals ; secur = fals ; remot addr = null ; remot host = null ; remot port = 1 ; local port = 1 ; local addr = null ; local name = null ; attribut . clear ( ) ; ssl attribut pars = fals ; note . clear ( ) ; cooki = null ; ( session = null ) { session . end access ( ) ; } session = null ; request session cooki = fals ; request session id = null ; request session url = fals ; ( global . secur enabl connector . recycl facad ) { paramet map = new paramet map string , string ( ) ; } els { paramet map . set lock ( fals ) ; paramet map . clear ( ) ; } map data . recycl ( ) ; ( global . secur enabl connector . recycl facad ) { ( facad = null ) { facad . clear ( ) ; facad = null ; } ( input stream = null ) { input stream . clear ( ) ; input stream = null ; } ( reader = null ) { reader . clear ( ) ; reader = null ; } } async support = null ; ( async context = null ) async context . recycl ( ) ; async context = null ; path paramet . clear ( ) ; }
execut cgi script desir environ , current work directori , input output stream p thi implement follow cgi specif recommed : ul li server should provid code queri code compon script uri command line argument script doe contain ani unencod = charact command line argument can gener unambigu manner . li server should set auth type metavari valu code auth scheme code token code author code wa suppli part request header . see code get cgienviron code method . li where applic , server should set current work directori directori which script locat befor invok . li server implement should defin behavior follow case : ul li u allow charact path info u : thi implement doe allow ascii nul nor ani charact which cannot url encod accord internet standard ; li u allow charact path segment u : thi implement doe allow non termin null segment path ioexcept mai thrown ; li u code . code code . . code path segment u : thi implement doe allow code . code code . . code path , charact result ioexcept thrown ( thi should never happen sinc tomcat normalis request uri befor determin context path , servlet path path info ) ; li u implement limit u : thi implement doe impos ani limit except document abov . thi implement mai limit servlet contain us hous thi implement . particular , all primari cgi variabl valu ar deriv either directli indirectli from contain s implement servlet api method . ul ul p except ioexcept problem dure read write occur see java . lang . runtim exec ( string command , string envp , file dir ) protect void run ( ) throw ioexcept { remind : thi method feel too big ; should re written ( readi ( ) ) { throw new ioexcept ( thi . get class ( ) . get name ( ) : readi run . ) ; } ( debug = 1 ) { log ( run cgi ( envp = env , command = command ) ) ; } ( ( command . index ( file . separ . file . separ ) = 0 ) ( command . index ( file . separ . . ) = 0 ) ( command . index ( . . file . separ ) = 0 ) ) { throw new ioexcept ( thi . get class ( ) . get name ( ) illeg charact cgi command path ( . . . ) detect . run cgi command . ) ; } origin content structur thi section taken from http : bug . sun . com bugdatabas view bug . do bug id = 4216884 major modif martin dengler runtim rt = null ; buffer reader cgi header reader = null ; input stream cgi output = null ; buffer reader command std err = null ; thread err reader thread = null ; buffer output stream command std = null ; process proc = null ; int buf read = 1 ; string cmd arg = new string param . size ( ) 2 ; cmd arg 0 = cgi execut ; cmd arg 1 = command ; creat queri argument ( int i = 0 ; i param . size ( ) ; i ) { cmd arg i 2 = param . get ( i ) ; } try { rt = runtim . get runtim ( ) ; proc = rt . exec ( cmd arg , hash string arrai ( env ) , wd ) ; string s content length = env . get ( content length ) ; ( . equal ( s content length ) ) { command std = new buffer output stream ( proc . get output stream ( ) ) ; iotool . flow ( stdin , command std ) ; command std . flush ( ) ; command std . close ( ) ; } we want wait process exit , process . wait ( ) useless our situat ; see http : bug . sun . com bugdatabas view bug . do bug id = 4223650 boolean run = true ; command std err = new buffer reader ( new input stream reader ( proc . get error stream ( ) ) ) ; final buffer reader std err rdr = command std err ; err reader thread = new thread ( ) { overrid } } }	public void init ( servlet config config ) throw servlet except { super . init ( config ) ; set our properti from initi paramet ( get servlet config ( ) . get init paramet ( debug ) = null ) debug = integ . pars int ( get servlet config ( ) . get init paramet ( debug ) ) ; cgi path prefix = get servlet config ( ) . get init paramet ( cgi path prefix ) ; boolean pass shell environ = boolean . valu ( get servlet config ( ) . get init paramet ( pass shell environ ) ) . boolean valu ( ) ; ( pass shell environ ) { shell env . put all ( system . getenv ( ) ) ; } ( get servlet config ( ) . get init paramet ( execut ) = null ) { cgi execut = get servlet config ( ) . get init paramet ( execut ) ; } ( get servlet config ( ) . get init paramet ( paramet encod ) = null ) { paramet encod = get servlet config ( ) . get init paramet ( paramet encod ) ; } ( get servlet config ( ) . get init paramet ( stderr timeout ) = null ) { stderr timeout = long . pars long ( get servlet config ( ) . get init paramet ( stderr timeout ) ) ; } }
protect creat jdbc connect tri connect databas . param now timestamp when thi wa call param us argument us return pool connect ha been connect throw sqlexcept pool connect creat connect ( long now , pool connect us , string usernam , string password ) throw sqlexcept { connect where avail we ll creat pool connect con = creat ( ) ; ( usernam = null ) con . get attribut ( ) . put ( con . prop user , usernam ) ; ( password = null ) con . get attribut ( ) . put ( con . prop password , password ) ; boolean error = fals ; try { connect valid connect con . lock ( ) ; con . connect ( ) ; ( con . valid ( pool connect . valid init ) ) { need lock new , content con . set timestamp ( now ) ; ( get pool properti ( ) . log abandon ( ) ) { con . set stack trace ( get thread dump ( ) ) ; } ( busi . offer ( con ) ) { log . debug ( connect doesn t fit busi arrai , connect traceabl . ) ; } return con ; } els { valid fail , make sure we disconnect clean up error = true ; } end } catch ( except e ) { error = true ; ( log . debug enabl ( ) ) log . debug ( unabl creat new jdbc connect . , e ) ; ( e instanceof sqlexcept ) { throw ( sqlexcept ) e ; } els { sqlexcept ex = new sqlexcept ( e . get messag ( ) ) ; ex . init caus ( e ) ; throw ex ; } } final { con can never null here ( error ) { releas ( con ) ; } con . unlock ( ) ; } catch return null ; }	protect thread safe wai releas connect param con pool connect void releas ( pool connect con ) { ( con = = null ) return ; try { con . lock ( ) ; ( con . releas ( ) ) { counter onli decrement onc size . add get ( 1 ) ; con . set handler ( null ) ; } } final { con . unlock ( ) ; } notifi ( waitcount . get ( ) 0 ) { idl . offer ( new pool connect ( pool properti , thi ) ) ; } }	public static convert except string param x throwabl return string repres stack trace string get stack trace ( throwabl x ) { ( x = = null ) { return null ; } els { java . io . byte arrai output stream bout = new java . io . byte arrai output stream ( ) ; java . io . print stream writer = new java . io . print stream ( bout ) ; x . print stack trace ( writer ) ; string result = bout . string ( ) ; return ( x . get messag ( ) = null x . get messag ( ) . length ( ) 0 ) x . get messag ( ) ; result : result ; } end }
overrid public collect object valu ( ) { arrai list object valu = new arrai list object ( ) ; iter map . entri , >> i = super . entri set ( ) . iter ( ) ; while ( i . ha next ( ) ) { map . entri , e = i . next ( ) ; map entri entri = ( map entri ) super . get ( e . get kei ( ) ) ; ( entri = null entri . activ ( ) entri . get valu ( ) = null ) valu . add ( entri . get valu ( ) ) ; } return collect . unmodifi collect ( valu ) ; }	overrid public boolean equal ( object obj ) { ( thi = = obj ) { return true ; } ( obj = = null ) { return fals ; } ( ( obj instanceof applic taglib descriptor ) ) { return fals ; } applic taglib descriptor other = ( applic taglib descriptor ) obj ; ( locat = = null ) { ( other . locat = null ) { return fals ; } } els ( locat . equal ( other . locat ) ) { return fals ; } ( uri = = null ) { ( other . uri = null ) { return fals ; } } els ( uri . equal ( other . uri ) ) { return fals ; } return true ; }	( non javadoc ) see java . lang . object equal ( java . lang . object ) overrid public boolean equal ( object obj ) { ( thi = = obj ) return true ; ( obj = = null ) return fals ; ( ( obj instanceof login config ) ) return fals ; login config other = ( login config ) obj ; ( auth method = = null ) { ( other . auth method = null ) return fals ; } els ( auth method . equal ( other . auth method ) ) return fals ; ( error page = = null ) { ( other . error page = null ) return fals ; } els ( error page . equal ( other . error page ) ) return fals ; ( login page = = null ) { ( other . login page = null ) return fals ; } els ( login page . equal ( other . login page ) ) return fals ; ( realm name = = null ) { ( other . realm name = null ) return fals ; } els ( realm name . equal ( other . realm name ) ) return fals ; return true ; }	overrid public boolean equal ( object obj ) { ( thi = = obj ) { return true ; } ( obj = = null ) { return fals ; } ( ( obj instanceof simpl node ) ) { return fals ; } simpl node other = ( simpl node ) obj ; ( arrai . equal ( children , other . children ) ) { return fals ; } ( id = other . id ) { return fals ; } ( imag = = null ) { ( other . imag = null ) { return fals ; } } els ( imag . equal ( other . imag ) ) { return fals ; } return true ; }	object method overrid public boolean equal ( object obj ) { ( ( obj = null ) ( obj instanceof name entri ) ) { return name . equal ( ( ( name entri ) obj ) . name ) ; } els { return fals ; } }	compar two url equal . result code true code onli argument null , code url code object repres same code url code thi object . two code url code ar equal thei have same protocol refer same host , same port number host , same file anchor host . param obj url compar against overrid public boolean equal ( object obj ) { ( obj = = null ) return ( fals ) ; ( ( obj instanceof url ) ) return ( fals ) ; url other = ( url ) obj ; ( same file ( other ) ) return ( fals ) ; return ( compar ( ref , other . get ref ( ) ) ) ; }
public void set password ( string password ) { thi . password = password ; }
set filter definit we ar configur . thi ha side effect instanti instanc correspond filter class . param filter def new filter definit except class cast except specifi class doe implement code javax . servlet . filter code interfac except class found except filter class cannot found except illeg access except filter class cannot publicli instanti except instanti except except occur while instanti filter object except servlet except thrown filter s init ( ) method throw name except throw invoc target except void set filter def ( filter def filter def ) throw class cast except , class found except , illeg access except , instanti except , servlet except , invoc target except , name except { thi . filter def = filter def ; ( filter def = = null ) { releas ani previous alloc filter instanc ( thi . filter = null ) { ( global . secur enabl ) { try { secur util . do privileg ( destroi , filter ) ; } catch ( java . lang . except ex ) { context . get logger ( ) . error ( applic filter config . do privileg , ex ) ; } secur util . remov ( filter ) ; } els { filter . destroi ( ) ; } ( context . get ignor annot ( ) ) { try { ( ( standard context ) context ) . get instanc manag ( ) . destroi instanc ( thi . filter ) ; } catch ( except e ) { context . get logger ( ) . error ( applic filter config . pre destroi , e ) ; } } } thi . filter = null ; } els { alloc new filter instanc get filter ( ) ; } }
public check modif send notif listen void check ( ) { ( log . info enabl ( ) ) log . info ( check cluster war watch dir ) ; file list = watch dir . list file ( new war filter ( ) ) ; ( list = = null ) list = new file 0 ; first make sure all file ar list our current statu ( int i = 0 ; i list . length ; i ) { add war info ( list i ) ; } check all statu code updat farm deploy ( iter map . entri string , war info >> i = current statu . entri set ( ) . iter ( ) ; i . ha next ( ) ; ) { map . entri string , war info entri = i . next ( ) ; war info info = entri . get valu ( ) ; int check = info . check ( ) ; ( check = = 1 ) { listen . file modifi ( info . get war ( ) ) ; } els ( check = = 1 ) { listen . file remov ( info . get war ( ) ) ; need keep memori current statu . remov ( info . get war ( ) . get absolut path ( ) ) ; } } }
protect access log element creat log element ( ) { list access log element list = new arrai list access log element ( ) ; boolean replac = fals ; string builder buf = new string builder ( ) ; ( int i = 0 ; i pattern . length ( ) ; i ) { char ch = pattern . char ( i ) ; ( replac ) { code process { , behavior . . . i do encount close } i ignor { ( { = = ch ) { string builder name = new string builder ( ) ; int j = i 1 ; ( ; j pattern . length ( ) } = pattern . char ( j ) ; j ) { name . append ( pattern . char ( j ) ) ; } ( j 1 pattern . length ( ) ) { 1 wa account } which we increment now j ; list . add ( creat access log element ( name . string ( ) , pattern . char ( j ) ) ) ; i = j ; sinc we walk more than charact } els { d oh end string pretend we never did thi do process old wai list . add ( creat access log element ( ch ) ) ; } } els { list . add ( creat access log element ( ch ) ) ; } replac = fals ; } els ( ch = = ) { replac = true ; list . add ( new string element ( buf . string ( ) ) ) ; buf = new string builder ( ) ; } els { buf . append ( ch ) ; } } ( buf . length ( ) 0 ) { list . add ( new string element ( buf . string ( ) ) ) ; } return list . arrai ( new access log element 0 ) ; }	public end request . throw ioexcept underli i o error occur void end request ( ) throw ioexcept { ( commit ) { send connector request commit . connector should valid header , send them ( us send header ) set filter accordingli . respons . action ( action code . commit , null ) ; } ( finish ) return ; ( last activ filter = 1 ) activ filter last activ filter . end ( ) ; finish = true ; byte count = 0 ; }	log messag summar specifi request respons , accord format specifi code pattern code properti . param request request process param respons respons process except ioexcept input output error ha occur except servlet except servlet error ha occur overrid public void invok ( request request , respons respons ) throw ioexcept , servlet except { ( get state ( ) . avail ( ) get enabl ( ) ) { final string t1name = access log valv . class . get name ( ) . t1 ; pass thi request next valv our pipelin long t1 = system . current time milli ( ) ; boolean asyncdispatch = request . async dispatch ( ) ; ( asyncdispatch ) { request . set attribut ( t1name , long . valu ( t1 ) ) ; } get next ( ) . invok ( request , respons ) ; we re done request ( request . async dispatch ( ) ) { return ; } els ( asyncdispatch request . get attribut ( t1name ) = null ) { t1 = ( ( long ) request . get attribut ( t1name ) ) . long valu ( ) ; } long t2 = system . current time milli ( ) ; long time = t2 t1 ; log ( request , respons , time ) ; } els get next ( ) . invok ( request , respons ) ; }	thi method invok tomcat each queri . param request request object . param respons respons object . except ioexcept should thrown . except servlet except databas sqlexcept wrap servlet except . overrid public void invok ( request request , respons respons ) throw ioexcept , servlet except { get next ( ) . invok ( request , respons ) ; log ( request , respons , 0 ) ; }	overrid public void log ( request request , respons respons , long time ) { ( log element = = null condit = null null = request . get request ( ) . get attribut ( condit ) ) { return ; } date date = get date ( ) ; string builder result = new string builder ( 128 ) ; ( int i = 0 ; i log element . length ; i ) { log element i . add element ( result , date , request , respons , time ) ; } log ( result . string ( ) ) ; }	overrid public void log ( request request , respons respons , long time ) { final string empti = ; string remot host ; ( resolv host ) remot host = request . get remot host ( ) ; els remot host = request . get remot addr ( ) ; string user = request . get remot user ( ) ; string queri = request . get request uri ( ) ; long byte = respons . get byte written ( true ) ; ( byte 0 ) byte = 0 ; int statu = respons . get statu ( ) ; string virtual host = empti ; string method = empti ; string refer = empti ; string user agent = empti ; string log pattern = pattern ; ( log pattern . equal ( combin ) ) { virtual host = request . get server name ( ) ; method = request . get method ( ) ; refer = request . get header ( refer ) ; user agent = request . get header ( user agent ) ; } synchron ( thi ) { int number tri = 2 ; while ( number tri 0 ) { try { open ( ) ; ps . set string ( 1 , remot host ) ; ps . set string ( 2 , user ) ; ps . set timestamp ( 3 , new timestamp ( get current time milli ( ) ) ) ; ps . set string ( 4 , queri ) ; ps . set int ( 5 , statu ) ; ( us long content length ) { ps . set long ( 6 , byte ) ; } els { ( byte integ . max valu ) byte = 1 ; ps . set int ( 6 , ( int ) byte ) ; } ( log pattern . equal ( combin ) ) { ps . set string ( 7 , virtual host ) ; ps . set string ( 8 , method ) ; ps . set string ( 9 , refer ) ; ps . set string ( 10 , user agent ) ; } ps . execut updat ( ) ; return ; } catch ( sqlexcept e ) { log problem poster contain . get logger ( ) . error ( sm . get string ( jdbc access log valv . except ) , e ) ; close connect so get reopen next time ( conn = null ) close ( ) ; } number tri ; } } }	overrid public void log ( org . apach . coyot . request req , org . apach . coyot . respons re , long time ) { request request = ( request ) req . get note ( adapt note ) ; respons respons = ( respons ) re . get note ( adapt note ) ; ( request = = null ) { creat object request = connector . creat request ( ) ; request . set coyot request ( req ) ; respons = connector . creat respons ( ) ; respons . set coyot respons ( re ) ; link object request . set respons ( respons ) ; respons . set request ( request ) ; set note req . set note ( adapt note , request ) ; re . set note ( adapt note , respons ) ; set queri string encod req . get paramet ( ) . set queri string encod ( connector . get uriencod ( ) ) ; } connector . get servic ( ) . get contain ( ) . log access ( request , respons , time , true ) ; request . recycl ( ) ; respons . recycl ( ) ; }	public end process current http request . note : all byte current request should have been alreadi consum . thi method onli reset all pointer so we ar readi pars next http request . void next request ( ) { recycl request object respons . recycl ( ) ; recycl filter ( int i = 0 ; i = last activ filter ; i ) { activ filter i . recycl ( ) ; } reset pointer po = 0 ; last activ filter = 1 ; commit = fals ; finish = fals ; }	servic method . overrid public void servic ( org . apach . coyot . request req , org . apach . coyot . respons re ) throw except { request request = ( request ) req . get note ( adapt note ) ; respons respons = ( respons ) re . get note ( adapt note ) ; ( request = = null ) { creat object request = connector . creat request ( ) ; request . set coyot request ( req ) ; respons = connector . creat respons ( ) ; respons . set coyot respons ( re ) ; link object request . set respons ( respons ) ; respons . set request ( request ) ; set note req . set note ( adapt note , request ) ; re . set note ( adapt note , respons ) ; set queri string encod req . get paramet ( ) . set queri string encod ( connector . get uriencod ( ) ) ; } ( connector . get xpower ( ) ) { respons . add header ( x power , power ) ; } boolean comet = fals ; boolean async = fals ; try { pars set catalina configur specif request paramet req . get request processor ( ) . set worker thread name ( thread . current thread ( ) . get name ( ) ) ; ( post pars request ( req , request , re , respons ) ) { check valv we support async request . set async support ( connector . get servic ( ) . get contain ( ) . get pipelin ( ) . async support ( ) ) ; call contain connector . get servic ( ) . get contain ( ) . get pipelin ( ) . get first ( ) . invok ( request , respons ) ; ( request . comet ( ) ) { ( respons . close ( ) respons . error ( ) ) { ( request . get avail ( ) ( request . get content length ( ) 0 ( request . paramet pars ( ) ) ) ) { invok read event right awai ar avail byte ( event ( req , re , socket statu . open ) ) { comet = true ; re . action ( action code . comet begin , null ) ; } } els { comet = true ; re . action ( action code . comet begin , null ) ; } } els { clear filter chain , otherwis reset elsewher sinc thi comet request request . set filter chain ( null ) ; } } } async context impl async con impl = ( async context impl ) request . get async context ( ) ; ( async con impl = null ) { async = true ; } els ( comet ) { respons . finish respons ( ) ; req . action ( action code . post request , null ) ; } } catch ( ioexcept e ) { ignor } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( sm . get string ( coyot adapt . servic ) , t ) ; } final { req . get request processor ( ) . set worker thread name ( null ) ; recycl wrapper request respons ( comet async ) { request . recycl ( ) ; respons . recycl ( ) ; } els { clear convert so minimum amount memori us thi processor request . clear encod ( ) ; respons . clear encod ( ) ; } } }	public param us long content length us long content length set void set us long content length ( boolean us long content length ) { thi . us long content length = us long content length ; }
protect request without possibl session chang param uri request uri return true session chang boolean request without session chang ( string uri ) { return filter . matcher ( uri ) . match ( ) ; }
public creat return new { link group } defin thi user databas . param groupnam group name new group ( must uniqu ) param descript descript thi group group creat group ( string groupnam , string descript ) { memori group group = new memori group ( thi , groupnam , descript ) ; synchron ( group ) { group . put ( group . get groupnam ( ) , group ) ; } return ( group ) ; }	public creat return new { link role } defin thi user databas . param rolenam role name new group ( must uniqu ) param descript descript thi group role creat role ( string rolenam , string descript ) { memori role role = new memori role ( thi , rolenam , descript ) ; synchron ( role ) { role . put ( role . get rolenam ( ) , role ) ; } return ( role ) ; }	public creat return new { link user } defin thi user databas . param usernam logon usernam new user ( must uniqu ) param password logon password new user param full name full name new user user creat user ( string usernam , string password , string full name ) { memori user user = new memori user ( thi , usernam , password , full name ) ; synchron ( user ) { user . put ( user . get usernam ( ) , user ) ; } return ( user ) ; }	public initi access thi user databas . except except ani except thrown dure open void open ( ) throw except { synchron ( group ) { synchron ( user ) { eras ani previou group user user . clear ( ) ; group . clear ( ) ; role . clear ( ) ; construct reader xml input file ( exist ) file file = new file ( pathnam ) ; ( file . absolut ( ) ) { file = new file ( system . get properti ( global . catalina base prop ) , pathnam ) ; } ( file . exist ( ) ) { return ; } file input stream fi = new file input stream ( file ) ; construct digest read xml input file digest digest = new digest ( ) ; try { digest . set featur ( http : apach . org xml featur allow java encod , true ) ; } catch ( except e ) { log . warn ( sm . get string ( memori user databas . xml featur encod ) , e ) ; } digest . add factori creat ( tomcat user group , new memori group creation factori ( thi ) ) ; digest . add factori creat ( tomcat user role , new memori role creation factori ( thi ) ) ; digest . add factori creat ( tomcat user user , new memori user creation factori ( thi ) ) ; pars xml input file load thi databas try { digest . pars ( fi ) ; fi . close ( ) ; } catch ( except e ) { try { fi . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } throw e ; } } } }
protect void init stream ( ) { replac system . out system . err custom print stream system log handler systemlog = new system log handler ( system . out ) ; system . set out ( systemlog ) ; system . set err ( systemlog ) ; }	protect void init stream ( ) { ( redirect stream ) { replac system . out system . err custom print stream system log handler systemlog = new system log handler ( system . out ) ; system . set out ( systemlog ) ; system . set err ( systemlog ) ; } }
suppress warn ( null ) privat string evalu attribut ( tag handler info handler info , node . jsp attribut attr , node . custom tag n , string tag handler var ) throw jasper except { string attr valu = attr . get valu ( ) ; ( attr valu = = null ) { ( attr . name attribut ( ) ) { ( n . check attribut jsp fragment ( attr . get name ( ) ) ) { xxx need gener temporari variabl here attr valu = gener name attribut jsp fragment ( attr . get name attribut node ( ) , tag handler var ) ; } els { attr valu = gener name attribut valu ( attr . get name attribut node ( ) ) ; } } els { return null ; } } string local name = attr . get local name ( ) ; method m = null ; class c = null ; ( attr . dynam ( ) ) { c = object class ; } els { m = handler info . get setter method ( local name ) ; ( m = = null ) { err . jsp error ( n , jsp . error . unabl . find method , attr . get name ( ) ) ; } c = m . get paramet type ( ) ; xxx assert ( c . length 0 ) } ( attr . express ( ) ) { do noth } els ( attr . name attribut ( ) ) { ( n . check attribut jsp fragment ( attr . get name ( ) ) attr . dynam ( ) ) { attr valu = convert string ( c 0 , attr valu , local name , handler info . get properti editor class ( local name ) , true ) ; } } els ( attr . elinterpret input ( ) ) { result buffer string builder sb = new string builder ( 64 ) ; tag attribut info tai = attr . get tag attribut info ( ) ; gener el context refer sb . append ( get jsp context var ( ) ) ; sb . append ( . get elcontext ( ) ) ; string el context = sb . string ( ) ; ( attr . get el ( ) = null attr . get el ( ) . get map name ( ) = null ) { sb . set length ( 0 ) ; sb . append ( new org . apach . jasper . el . elcontext wrapper ( ) ; sb . append ( el context ) ; sb . append ( , ) ; sb . append ( attr . get el ( ) . get map name ( ) ) ; sb . append ( ) ) ; el context = sb . string ( ) ; } reset buffer sb . set length ( 0 ) ; creat our mark sb . append ( n . get start ( ) . string ( ) ) ; sb . append ( ) ; sb . append ( attr valu ) ; sb . append ( ) ; string mark = sb . string ( ) ; reset buffer sb . set length ( 0 ) ; depend type ( attr . defer input ( ) ( ( tai = null ) valu express . class . get name ( ) . equal ( tai . get type name ( ) ) ) ) { sb . append ( new org . apach . jasper . el . jsp valu express ( ) ; sb . append ( quot ( mark ) ) ; sb . append ( , ) ; sb . append ( get express factori var ( ) ) ; sb . append ( . creat valu express ( ) ; ( attr . get el ( ) = null ) { optim sb . append ( el context ) ; sb . append ( , ) ; } sb . append ( quot ( attr valu ) ) ; sb . append ( , ) ; sb . append ( jsp util . java sourc type from tld ( attr . get expect type name ( ) ) ) ; sb . append ( ) ) ) ; should express evalu befor pass setter boolean evalu = fals ; ( tai = null tai . can request time ( ) ) { jsp . 2 . 3 . 2 evalu = true ; } ( attr . defer input ( ) ) { jsp . 2 . 3 . 3 evalu = fals ; } ( attr . defer input ( ) tai = null tai . can request time ( ) ) { jsp . 2 . 3 . 5 evalu = attr valu . contain ( { ) ; } ( evalu ) { sb . append ( . get valu ( ) ; sb . append ( get jsp context var ( ) ) ; sb . append ( . get elcontext ( ) ) ; sb . append ( ) ) ; } attr valu = sb . string ( ) ; } els ( attr . defer method input ( ) ( ( tai = null ) method express . class . get name ( ) . equal ( tai . get type name ( ) ) ) ) { sb . append ( new org . apach . jasper . el . jsp method express ( ) ; sb . append ( quot ( mark ) ) ; sb . append ( , ) ; sb . append ( get express factori var ( ) ) ; sb . append ( . creat method express ( ) ; sb . append ( el context ) ; sb . append ( , ) ; sb . append ( quot ( attr valu ) ) ; sb . append ( , ) ; sb . append ( jsp util . java sourc type from tld ( attr . get expect type name ( ) ) ) ; sb . append ( , ) ; sb . append ( new class { ) ; string p = attr . get paramet type name ( ) ; ( int i = 0 ; i p . length ; i ) { sb . append ( jsp util . java sourc type from tld ( p i ) ) ; sb . append ( , ) ; } ( p . length 0 ) { sb . set length ( sb . length ( ) 1 ) ; } sb . append ( } ) ) ) ; attr valu = sb . string ( ) ; } els { run attr valu through express interpret string map name = ( attr . get el ( ) = null ) attr . get el ( ) . get map name ( ) : null ; attr valu = jsp util . interpret call ( thi . tag file , attr valu , c 0 , map name , fals ) ; } } els { attr valu = convert string ( c 0 , attr valu , local name , handler info . get properti editor class ( local name ) , fals ) ; } return attr valu ; }	privat convert scope string represent , whose possibl valu ar page , request , session , applic , correspond scope constant . string get scope constant ( string scope ) { default page string scope name = page context . page scope ; ( request . equal ( scope ) ) { scope name = page context . request scope ; } els ( session . equal ( scope ) ) { scope name = page context . session scope ; } els ( applic . equal ( scope ) ) { scope name = page context . applic scope ; } return scope name ; }	static void gener local variabl ( servlet writer out , node n ) throw jasper except { node . child info ci ; ( n instanceof node . custom tag ) { ci = ( ( node . custom tag ) n ) . get child info ( ) ; } els ( n instanceof node . jsp bodi ) { ci = ( ( node . jsp bodi ) n ) . get child info ( ) ; } els ( n instanceof node . name attribut ) { ci = ( ( node . name attribut ) n ) . get child info ( ) ; } els { least flag error . throw new jasper except ( unexpect node type ) ; err . get string ( jsp . error . intern . unexpect node type ) ) ; } ( ci . ha us bean ( ) ) { out . printil ( http session session = jspx page context . get session ( ) ; ) ; out . printil ( servlet context applic = jspx page context . get servlet context ( ) ; ) ; } ( ci . ha us bean ( ) ci . ha includ action ( ) ci . ha set properti ( ) ci . ha param action ( ) ) { out . printil ( http servlet request request = ( http servlet request ) jspx page context . get request ( ) ; ) ; } ( ci . ha includ action ( ) ) { out . printil ( http servlet respons respons = ( http servlet respons ) jspx page context . get respons ( ) ; ) ; } }	privat declar gener purpos method ( share servlet tag handler preambl gener ) void gen preambl method ( ) { method us get compil time file depend out . printil ( public java . util . list string get depend ( ) { ) ; out . push indent ( ) ; out . printil ( return jspx depend ; ) ; out . pop indent ( ) ; out . printil ( } ) ; out . println ( ) ; gener init ( ) ; gener destroi ( ) ; }	privat gener static initi preambl . exampl , depend list , el function map , prefix map . ( share servlet tag handler preambl gener ) void gen preambl static initi ( ) { out . printil ( privat static final jsp factori jspx factori = jsp factori . get default factori ( ) ; ) ; out . println ( ) ; static data get depend ( ) out . printil ( privat static java . util . list string jspx depend ; ) ; out . println ( ) ; list string depend = page info . get depend ( ) ; iter string iter = depend . iter ( ) ; ( depend . empti ( ) ) { out . printil ( static { ) ; out . push indent ( ) ; out . printin ( jspx depend = new java . util . arrai list string ( ) ; out . print ( depend . size ( ) ) ; out . println ( ) ; ) ; while ( iter . ha next ( ) ) { out . printin ( jspx depend . add ( ) ; out . print ( iter . next ( ) ) ; out . println ( ) ; ) ; } out . pop indent ( ) ; out . printil ( } ) ; out . println ( ) ; } }	privat void gener custom end ( node . custom tag n , string tag handler var , string tag eval var , string tag push bodi count var ) { ( n . ha empti bodi ( ) ) { ( n . implement iter tag ( ) ) { out . printin ( int eval do after bodi = ) ; out . print ( tag handler var ) ; out . println ( . do after bodi ( ) ; ) ; synchron begin nest script variabl sync script var ( n , variabl info . begin ) ; sync script var ( n , variabl info . nest ) ; out . printil ( ( eval do after bodi = javax . servlet . jsp . tagext . bodi tag . eval bodi again ) ) ; out . push indent ( ) ; out . printil ( break ; ) ; out . pop indent ( ) ; out . pop indent ( ) ; out . printil ( } while ( true ) ; ) ; } restor script var ( n , variabl info . nest ) ; ( n . implement bodi tag ( ) ) { out . printin ( ( ) ; out . print ( tag eval var ) ; out . println ( = javax . servlet . jsp . tagext . tag . eval bodi includ ) { ) ; out . push indent ( ) ; out . printil ( out = jspx page context . pop bodi ( ) ; ) ; ( n . implement try catch final ( ) ) { out . printin ( tag push bodi count var ) ; out . println ( 0 ; ) ; } els ( push bodi count var = null ) { out . printin ( push bodi count var ) ; out . println ( 0 ; ) ; } out . pop indent ( ) ; out . printil ( } ) ; } eval bodi out . pop indent ( ) ; out . printil ( } ) ; } out . printin ( ( ) ; out . print ( tag handler var ) ; out . println ( . do end tag ( ) = = javax . servlet . jsp . tagext . tag . skip page ) { ) ; out . push indent ( ) ; ( n . implement try catch final ( ) ) { ( pool enabl ( n . implement jsp id consum ( ) ) ) { out . printin ( n . get tag handler pool name ( ) ) ; out . print ( . reus ( ) ; out . print ( tag handler var ) ; out . println ( ) ; ) ; } els { out . printin ( tag handler var ) ; out . println ( . releas ( ) ; ) ; write destroi instanc ( tag handler var ) ; } } ( tag file fragment ) { out . printil ( throw new skip page except ( ) ; ) ; } els { out . printil ( ( method nest 0 ) return true ; : return ; ) ; } out . pop indent ( ) ; out . printil ( } ) ; synchron begin script variabl sync script var ( n , variabl info . begin ) ; try catch final ( n . implement try catch final ( ) ) { try out . pop indent ( ) ; out . printil ( } catch ( throwabl jspx except ) { ) ; out . push indent ( ) ; out . printin ( while ( ) ; out . print ( tag push bodi count var ) ; out . println ( 0 0 ) ) ; out . push indent ( ) ; out . printil ( out = jspx page context . pop bodi ( ) ; ) ; out . pop indent ( ) ; out . printin ( tag handler var ) ; out . println ( . do catch ( jspx except ) ; ) ; out . pop indent ( ) ; out . printil ( } final { ) ; out . push indent ( ) ; out . printin ( tag handler var ) ; out . println ( . do final ( ) ; ) ; } ( pool enabl ( n . implement jsp id consum ( ) ) ) { out . printin ( n . get tag handler pool name ( ) ) ; out . print ( . reus ( ) ; out . print ( tag handler var ) ; out . println ( ) ; ) ; } els { out . printin ( tag handler var ) ; out . println ( . releas ( ) ; ) ; write destroi instanc ( tag handler var ) ; } ( n . implement try catch final ( ) ) { out . pop indent ( ) ; out . printil ( } ) ; } declar synchron end script variabl ( must do thi outsid try catch final block ) declar script var ( n , variabl info . end ) ; sync script var ( n , variabl info . end ) ; restor script var ( n , variabl info . begin ) ; }	gener jsp init ( ) method instanti tag handler pool . tag file , jsp init ha invok manual , servlet config object explicitli pass . jsp 2 . 1 , we also instanti express factori void gener init ( ) { ( ctxt . tag file ( ) ) { out . printil ( privat void jsp init ( servlet config config ) { ) ; } els { out . printil ( public void jsp init ( ) { ) ; } out . push indent ( ) ; ( pool enabl ) { ( int i = 0 ; i tag handler pool name . size ( ) ; i ) { out . printin ( tag handler pool name . element ( i ) ) ; out . print ( = org . apach . jasper . runtim . tag handler pool . get tag handler pool ( ) ; ( ctxt . tag file ( ) ) { out . print ( config ) ; } els { out . print ( get servlet config ( ) ) ; } out . println ( ) ; ) ; } } out . printin ( var expressionfactori ) ; out . print ( = jspx factori . get jsp applic context ( ) ; ( ctxt . tag file ( ) ) { out . print ( config ) ; } els { out . print ( get servlet config ( ) ) ; } out . println ( . get servlet context ( ) ) . get express factori ( ) ; ) ; out . printin ( var instancemanag ) ; out . print ( = org . apach . jasper . runtim . instanc manag factori . get instanc manag ( ) ; ( ctxt . tag file ( ) ) { out . print ( config ) ; } els { out . print ( get servlet config ( ) ) ; } out . println ( ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; out . println ( ) ; }	privat gener end part static portion servlet . void gener postambl ( ) { out . pop indent ( ) ; out . printil ( } catch ( throwabl t ) { ) ; out . push indent ( ) ; out . printil ( ( ( t instanceof skip page except ) ) { ) ; out . push indent ( ) ; out . printil ( out = jspx out ; ) ; out . printil ( ( out = null out . get buffer size ( ) = 0 ) ) ; out . push indent ( ) ; out . printil ( try { out . clear buffer ( ) ; } catch ( java . io . ioexcept e ) { } ) ; out . pop indent ( ) ; out . printil ( ( jspx page context = null ) jspx page context . handl page except ( t ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; out . pop indent ( ) ; out . printil ( } final { ) ; out . push indent ( ) ; out . printil ( jspx factori . releas page context ( jspx page context ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; close servic method out . pop indent ( ) ; out . printil ( } ) ; gener method , helper class , etc . gen common postambl ( ) ; }	privat gener begin static portion servlet . void gener preambl ( node . node page ) throw jasper except { string servlet packag name = ctxt . get servlet packag name ( ) ; string servlet class name = ctxt . get servlet class name ( ) ; string servic method name = constant . servic method name ; first packag name : gen preambl packag ( servlet packag name ) ; gener import gen preambl import ( ) ; gener class declar out . printin ( public final class ) ; out . print ( servlet class name ) ; out . print ( extend ) ; out . println ( page info . get extend ( ) ) ; out . printin ( implement org . apach . jasper . runtim . jsp sourc depend ) ; ( page info . thread safe ( ) ) { out . println ( , ) ; out . printin ( singl thread model ) ; } out . println ( { ) ; out . push indent ( ) ; class bodi begin here gener declar ( page ) ; static initi here gen preambl static initi ( ) ; class variabl declar gen preambl class variabl declar ( ) ; method here gen preambl method ( ) ; now servic method out . printin ( public void ) ; out . print ( servic method name ) ; out . println ( ( final http servlet request request , final http servlet respons respons ) ) ; out . println ( throw java . io . ioexcept , servlet except { ) ; out . push indent ( ) ; out . println ( ) ; local variabl declar out . printil ( final page context page context ; ) ; ( page info . session ( ) ) out . printil ( http session session = null ; ) ; ( page info . error page ( ) ) { out . printil ( throwabl except = org . apach . jasper . runtim . jsp runtim librari . get throwabl ( request ) ; ) ; out . printil ( ( except = null ) { ) ; out . push indent ( ) ; out . printil ( respons . set statu ( http servlet respons . sc intern server error ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; } out . printil ( final servlet context applic ; ) ; out . printil ( final servlet config config ; ) ; out . printil ( jsp writer out = null ; ) ; out . printil ( final object page = thi ; ) ; out . printil ( jsp writer jspx out = null ; ) ; out . printil ( page context jspx page context = null ; ) ; out . println ( ) ; declar temporari script var ( page ) ; out . println ( ) ; out . printil ( try { ) ; out . push indent ( ) ; out . printin ( respons . set content type ( ) ; out . print ( quot ( page info . get content type ( ) ) ) ; out . println ( ) ; ) ; ( ctxt . get option ( ) . xpower ( ) ) { out . printil ( respons . add header ( x power , jsp 2 . 1 ) ; ) ; } out . printil ( page context = jspx factori . get page context ( thi , request , respons , ) ; out . printin ( t t t ) ; out . print ( quot ( page info . get error page ( ) ) ) ; out . print ( , page info . session ( ) ) ; out . print ( , page info . get buffer ( ) ) ; out . print ( , page info . auto flush ( ) ) ; out . println ( ) ; ) ; out . printil ( jspx page context = page context ; ) ; out . printil ( applic = page context . get servlet context ( ) ; ) ; out . printil ( config = page context . get servlet config ( ) ; ) ; ( page info . session ( ) ) out . printil ( session = page context . get session ( ) ; ) ; out . printil ( out = page context . get out ( ) ; ) ; out . printil ( jspx out = out ; ) ; out . println ( ) ; }	privat gener setter jsp context so we can creat wrapper store both origin wrapper . we need wrapper mask page context from tag file simul fresh page context . we need origin do thing like sync begin end script variabl . void gener set jsp context ( tag info tag info ) { boolean nest seen = fals ; boolean begin seen = fals ; boolean end seen = fals ; determin ar ani alias boolean alia seen = fals ; tag variabl info tag var = tag info . get tag variabl info ( ) ; ( int i = 0 ; i tag var . length ; i ) { ( tag var i . get name from attribut ( ) = null tag var i . get name given ( ) = null ) { alia seen = true ; break ; } } ( alia seen ) { out . printil ( public void set jsp context ( jsp context ctx , java . util . map alia map ) { ) ; } els { out . printil ( public void set jsp context ( jsp context ctx ) { ) ; } out . push indent ( ) ; out . printil ( super . set jsp context ( ctx ) ; ) ; out . printil ( java . util . arrai list jspx nest = null ; ) ; out . printil ( java . util . arrai list jspx begin = null ; ) ; out . printil ( java . util . arrai list jspx end = null ; ) ; ( int i = 0 ; i tag var . length ; i ) { switch ( tag var i . get scope ( ) ) { case variabl info . nest : ( nest seen ) { out . printil ( jspx nest = new java . util . arrai list ( ) ; ) ; nest seen = true ; } out . printin ( jspx nest . add ( ) ; break ; case variabl info . begin : ( begin seen ) { out . printil ( jspx begin = new java . util . arrai list ( ) ; ) ; begin seen = true ; } out . printin ( jspx begin . add ( ) ; break ; case variabl info . end : ( end seen ) { out . printil ( jspx end = new java . util . arrai list ( ) ; ) ; end seen = true ; } out . printin ( jspx end . add ( ) ; break ; } switch out . print ( quot ( tag var i . get name given ( ) ) ) ; out . println ( ) ; ) ; } ( alia seen ) { out . printil ( thi . jsp context = new org . apach . jasper . runtim . jsp context wrapper ( ctx , jspx nest , jspx begin , jspx end , alia map ) ; ) ; } els { out . printil ( thi . jsp context = new org . apach . jasper . runtim . jsp context wrapper ( ctx , jspx nest , jspx begin , jspx end , null ) ; ) ; } out . pop indent ( ) ; out . printil ( } ) ; out . println ( ) ; out . printil ( public jsp context get jsp context ( ) { ) ; out . push indent ( ) ; out . printil ( return thi . jsp context ; ) ; out . pop indent ( ) ; out . printil ( } ) ; }	privat void gener tag handler postambl ( tag info tag info ) { out . pop indent ( ) ; have catch throwabl becaus classic tag handler helper method declar throw throwabl . out . printil ( } catch ( throwabl t ) { ) ; out . push indent ( ) ; out . printil ( ( t instanceof skip page except ) ) ; out . printil ( throw ( skip page except ) t ; ) ; out . printil ( ( t instanceof java . io . ioexcept ) ) ; out . printil ( throw ( java . io . ioexcept ) t ; ) ; out . printil ( ( t instanceof illeg state except ) ) ; out . printil ( throw ( illeg state except ) t ; ) ; out . printil ( ( t instanceof jsp except ) ) ; out . printil ( throw ( jsp except ) t ; ) ; out . printil ( throw new jsp except ( t ) ; ) ; out . pop indent ( ) ; out . printil ( } final { ) ; out . push indent ( ) ; handl restor variabl mapper tag attribut info attr info = tag info . get attribut ( ) ; ( int i = 0 ; i attr info . length ; i ) { ( attr info i . defer method ( ) attr info i . defer valu ( ) ) { out . printin ( el variablemapp . set variabl ( ) ; out . print ( quot ( attr info i . get name ( ) ) ) ; out . print ( , el ve ) ; out . print ( i ) ; out . println ( ) ; ) ; } } restor nest jsp context elcontext out . printil ( jsp context . get elcontext ( ) . put context ( jsp context . class , super . get jsp context ( ) ) ; ) ; out . printil ( ( ( org . apach . jasper . runtim . jsp context wrapper ) jsp context ) . sync end tag file ( ) ; ) ; ( pool enabl tag handler pool name . empti ( ) ) { out . printil ( jsp destroi ( ) ; ) ; } out . pop indent ( ) ; out . printil ( } ) ; close do tag method out . pop indent ( ) ; out . printil ( } ) ; gener method , helper class , etc . gen common postambl ( ) ; }	privat gener tag handler preambl . void gener tag handler preambl ( jasper tag info tag info , node . node tag ) throw jasper except { gener packag declar string class name = tag info . get tag class name ( ) ; int last index = class name . last index ( . ) ; ( last index = 1 ) { string pkg name = class name . substr ( 0 , last index ) ; gen preambl packag ( pkg name ) ; class name = class name . substr ( last index 1 ) ; } gener import gen preambl import ( ) ; gener class declar out . printin ( public final class ) ; out . println ( class name ) ; out . printil ( extend javax . servlet . jsp . tagext . simpl tag support ) ; out . printin ( implement org . apach . jasper . runtim . jsp sourc depend ) ; ( tag info . ha dynam attribut ( ) ) { out . println ( , ) ; out . printin ( javax . servlet . jsp . tagext . dynam attribut ) ; } out . println ( { ) ; out . println ( ) ; out . push indent ( ) ; class bodi begin here gener declar ( tag ) ; static initi here gen preambl static initi ( ) ; out . printil ( privat jsp context jsp context ; ) ; declar writer us store result fragment bodi invoc var reader var attribut specifi out . printil ( privat java . io . writer jspx sout ; ) ; class variabl declar gen preambl class variabl declar ( ) ; gener set jsp context ( tag info ) ; tag handler specif declar gener tag handler attribut ( tag info ) ; ( tag info . ha dynam attribut ( ) ) gener set dynam attribut ( ) ; method here gen preambl method ( ) ; now do tag ( ) method out . printil ( public void do tag ( ) throw jsp except , java . io . ioexcept { ) ; ( ctxt . prototyp mode ( ) ) { out . printil ( } ) ; out . pop indent ( ) ; out . printil ( } ) ; return ; } out . push indent ( ) ; accord spec , page context must made avail implicit object tag file . declar jspx page context , so we can share code gener jsp . out . printil ( page context jspx page context = ( page context ) jsp context ; ) ; declar implicit object . out . printil ( http servlet request request = ( http servlet request ) jspx page context . get request ( ) ; ) ; out . printil ( http servlet respons respons = ( http servlet respons ) jspx page context . get respons ( ) ; ) ; out . printil ( http session session = jspx page context . get session ( ) ; ) ; out . printil ( servlet context applic = jspx page context . get servlet context ( ) ; ) ; out . printil ( servlet config config = jspx page context . get servlet config ( ) ; ) ; out . printil ( jsp writer out = jsp context . get out ( ) ; ) ; out . printil ( jsp init ( config ) ; ) ; set current jsp context elcontext out . printil ( jsp context . get elcontext ( ) . put context ( jsp context . class , jsp context ) ; ) ; gener page scope variabl ( tag info ) ; declar temporari script var ( tag ) ; out . println ( ) ; out . printil ( try { ) ; out . push indent ( ) ; }	public fragment open fragment ( node parent , int method nest ) throw jasper except { fragment result = new fragment ( fragment . size ( ) , parent ) ; fragment . add ( result ) ; thi . us = true ; parent . set inner class name ( class name ) ; servlet writer out = result . get gen buffer ( ) . get out ( ) ; out . push indent ( ) ; out . push indent ( ) ; see comment close fragment ( ) ( method nest 0 ) { out . printin ( public boolean invok ) ; } els { out . printin ( public void invok ) ; } out . println ( result . get id ( ) ( jsp writer out ) ) ; out . push indent ( ) ; note : throwabl requir becaus method like jspx meth throw throwabl . out . printil ( throw throwabl ) ; out . pop indent ( ) ; out . printil ( { ) ; out . push indent ( ) ; gener local variabl ( out , parent ) ; return result ; }	public gener code requir obtain runtim valu given name attribut . return name temporari variabl result store . string gener name attribut valu ( node . name attribut n ) throw jasper except { string var name = n . get temporari variabl name ( ) ; onli bodi element thi name attribut node templat text , we need gener extra call push bodi pop bodi . mayb we can further optim here get rid temporari variabl , realiti look like javac doe thi us . node . node bodi = n . get bodi ( ) ; ( bodi = null ) { boolean templat text optim = fals ; ( bodi . size ( ) = = 1 ) { node bodi element = bodi . get node ( 0 ) ; ( bodi element instanceof node . templat text ) { templat text optim = true ; out . printil ( string var name = quot ( ( ( node . templat text ) bodi element ) . get text ( ) ) ; ) ; } } lone el express ( need push bodi here either ) . ( templat text optim ) { out . printil ( out = jspx page context . push bodi ( ) ; ) ; visit bodi ( n ) ; out . printil ( string var name = ( ( javax . servlet . jsp . tagext . bodi content ) out ) . get string ( ) ; ) ; out . printil ( out = jspx page context . pop bodi ( ) ; ) ; } } els { empti bodi must treat out . printil ( string var name = ; ) ; } return var name ; }	public static string coerc boolean ( string s , boolean name attribut ) { ( name attribut ) { return ( boolean ) org . apach . jasper . runtim . jsp runtim librari . coerc ( s , boolean . class ) ; } els { ( s = = null s . length ( ) = = 0 ) { return new boolean ( fals ) ; } els { detect format error translat time return new boolean ( boolean . valu ( s ) . string ( ) ) ; } } }	public static string coerc byte ( string s , boolean name attribut ) { ( name attribut ) { return ( byte ) org . apach . jasper . runtim . jsp runtim librari . coerc ( s , byte . class ) ; } els { ( s = = null s . length ( ) = = 0 ) { return new byte ( ( byte ) 0 ) ; } els { detect format error translat time return new byte ( ( byte ) byte . valu ( s ) . string ( ) ) ; } } }	public static string coerc charact ( string s , boolean name attribut ) { ( name attribut ) { return ( charact ) org . apach . jasper . runtim . jsp runtim librari . coerc ( s , charact . class ) ; } els { ( s = = null s . length ( ) = = 0 ) { return new charact ( ( char ) 0 ) ; } els { char ch = s . char ( 0 ) ; thi trick avoid escap issu return new charact ( ( char ) ( int ) ch ) ; } } }	public static string coerc doubl ( string s , boolean name attribut ) { ( name attribut ) { return ( doubl ) org . apach . jasper . runtim . jsp runtim librari . coerc ( s , doubl . class ) ; } els { ( s = = null s . length ( ) = = 0 ) { return new doubl ( 0 ) ; } els { detect format error translat time return new doubl ( doubl . valu ( s ) . string ( ) ) ; } } }	public static string coerc float ( string s , boolean name attribut ) { ( name attribut ) { return ( float ) org . apach . jasper . runtim . jsp runtim librari . coerc ( s , float . class ) ; } els { ( s = = null s . length ( ) = = 0 ) { return new float ( 0 ) ; } els { detect format error translat time return new float ( float . valu ( s ) . string ( ) f ) ; } } }	public static string coerc integ ( string s , boolean name attribut ) { ( name attribut ) { return ( integ ) org . apach . jasper . runtim . jsp runtim librari . coerc ( s , integ . class ) ; } els { ( s = = null s . length ( ) = = 0 ) { return new integ ( 0 ) ; } els { detect format error translat time return new integ ( integ . valu ( s ) . string ( ) ) ; } } }	public static string coerc long ( string s , boolean name attribut ) { ( name attribut ) { return ( long ) org . apach . jasper . runtim . jsp runtim librari . coerc ( s , long . class ) ; } els { ( s = = null s . length ( ) = = 0 ) { return new long ( 0 ) ; } els { detect format error translat time return new long ( long . valu ( s ) . string ( ) l ) ; } } }	public static string coerc short ( string s , boolean name attribut ) { ( name attribut ) { return ( short ) org . apach . jasper . runtim . jsp runtim librari . coerc ( s , short . class ) ; } els { ( s = = null s . length ( ) = = 0 ) { return new short ( ( short ) 0 ) ; } els { detect format error translat time return new short ( short . valu ( s ) . string ( ) ) ; } } }	static produc string repres call el interpret . param express string contain zero more { } express param expect type expect type interpret result param fnmapvar variabl point function map . param xml escap true result should do xml escap return string repres call el interpret . string interpret call ( boolean tag file , string express , class expect type , string fnmapvar , boolean xml escap ) { determin which context object us . string jsp ctxt = null ; ( tag file ) jsp ctxt = thi . get jsp context ( ) ; els jsp ctxt = jspx page context ; determin whether us expect type s textual name , s primit , name correspond box type . string target type = expect type . get canon name ( ) ; string primit convert method = null ; ( expect type . primit ( ) ) { ( expect type . equal ( boolean . type ) ) { target type = boolean . class . get name ( ) ; primit convert method = boolean valu ; } els ( expect type . equal ( byte . type ) ) { target type = byte . class . get name ( ) ; primit convert method = byte valu ; } els ( expect type . equal ( charact . type ) ) { target type = charact . class . get name ( ) ; primit convert method = char valu ; } els ( expect type . equal ( short . type ) ) { target type = short . class . get name ( ) ; primit convert method = short valu ; } els ( expect type . equal ( integ . type ) ) { target type = integ . class . get name ( ) ; primit convert method = int valu ; } els ( expect type . equal ( long . type ) ) { target type = long . class . get name ( ) ; primit convert method = long valu ; } els ( expect type . equal ( float . type ) ) { target type = float . class . get name ( ) ; primit convert method = float valu ; } els ( expect type . equal ( doubl . type ) ) { target type = doubl . class . get name ( ) ; primit convert method = doubl valu ; } } ( primit convert method = null ) { xml escap = fals ; } build up base call interpret . xxx we us proprietari call interpret now current standard machineri ineffici requir lot wrapper adapt . thi should all clear up onc el interpret move out jstl own project . futur , thi should replac code call express evalu . pars express ( ) cach result express object . interpret call would simpli select pre cach express evalu . note page context impl implement variabl resolv gener servlet simpl tag implement function mapper , so machineri alreadi place ( mroth ) . target type = java sourc type ( target type ) ; string builder call = new string builder ( ( target type ) org . apach . jasper . runtim . page context impl . proprietari evalu ( gener . quot ( express ) , target type . class , ( page context ) jsp ctxt , fnmapvar , xml escap ) ) ; add primit convert method we need . ( primit convert method = null ) { call . insert ( 0 , ( ) ; call . append ( ) . primit convert method ( ) ) ; } return call . string ( ) ; }	public static handl take input from tld java . lang . object java . lang . object . class int int . class void void . type int int . class param type string java sourc type from tld ( string type ) { ( type = = null void . equal ( type ) ) { return void . type ; } return type . class ; }	public void gener postambl ( ) { servlet writer out = thi . class buffer . get out ( ) ; gener all fragment method : ( int i = 0 ; i fragment . size ( ) ; i ) { fragment fragment = fragment . get ( i ) ; fragment . get gen buffer ( ) . adjust java line ( out . get java line ( ) 1 ) ; out . print multi ln ( fragment . get gen buffer ( ) . string ( ) ) ; } gener postambl : out . printil ( public void invok ( java . io . writer writer ) ) ; out . push indent ( ) ; out . printil ( throw jsp except ) ; out . pop indent ( ) ; out . printil ( { ) ; out . push indent ( ) ; out . printil ( jsp writer out = null ; ) ; out . printil ( ( writer = null ) { ) ; out . push indent ( ) ; out . printil ( out = thi . jsp context . push bodi ( writer ) ; ) ; out . pop indent ( ) ; out . printil ( } els { ) ; out . push indent ( ) ; out . printil ( out = thi . jsp context . get out ( ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; out . printil ( try { ) ; out . push indent ( ) ; out . printil ( thi . jsp context . get elcontext ( ) . put context ( jsp context . class , thi . jsp context ) ; ) ; out . printil ( switch ( thi . discrimin ) { ) ; out . push indent ( ) ; ( int i = 0 ; i fragment . size ( ) ; i ) { out . printil ( case i : ) ; out . push indent ( ) ; out . printil ( invok i ( out ) ; ) ; out . printil ( break ; ) ; out . pop indent ( ) ; } out . pop indent ( ) ; switch out . printil ( } ) ; out . pop indent ( ) ; try out . printil ( } ) ; out . printil ( catch ( throwabl e ) { ) ; out . push indent ( ) ; out . printil ( ( e instanceof skip page except ) ) ; out . printil ( throw ( skip page except ) e ; ) ; out . printil ( throw new jsp except ( e ) ; ) ; out . pop indent ( ) ; catch out . printil ( } ) ; out . printil ( final { ) ; out . push indent ( ) ; out . printil ( ( writer = null ) { ) ; out . push indent ( ) ; out . printil ( thi . jsp context . pop bodi ( ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; out . pop indent ( ) ; final out . printil ( } ) ; out . pop indent ( ) ; invok method out . printil ( } ) ; out . pop indent ( ) ; helper class out . printil ( } ) ; out . pop indent ( ) ; }	public void gener preambl ( ) { servlet writer out = thi . class buffer . get out ( ) ; out . println ( ) ; out . push indent ( ) ; note : cannot static , we need refer thing like jspx meth out . printil ( privat class class name ) ; out . printil ( extend org . apach . jasper . runtim . jsp fragment helper ) ; out . printil ( { ) ; out . push indent ( ) ; out . printil ( privat javax . servlet . jsp . tagext . jsp tag jspx parent ; ) ; out . printil ( privat int jspx push bodi count ; ) ; out . println ( ) ; out . printil ( public class name ( int discrimin , jsp context jsp context , javax . servlet . jsp . tagext . jsp tag jspx parent , int jspx push bodi count ) { ) ; out . push indent ( ) ; out . printil ( super ( discrimin , jsp context , jspx parent ) ; ) ; out . printil ( thi . jspx parent = jspx parent ; ) ; out . printil ( thi . jspx push bodi count = jspx push bodi count ; ) ; out . pop indent ( ) ; out . printil ( } ) ; }	public gener implement javax . servlet . jsp . tagext . dynam attribut . set dynam attribut ( ) method , which save each dynam attribut pass so scope variabl can later creat . void gener set dynam attribut ( ) { out . printil ( public void set dynam attribut ( string uri , string local name , object valu ) throw jsp except { ) ; out . push indent ( ) ; accord spec , onli dynam attribut uri ar present map ; all other dynam attribut ar ignor . out . printil ( ( uri = = null ) ) ; out . push indent ( ) ; out . printil ( jspx dynam attr . put ( local name , valu ) ; ) ; out . pop indent ( ) ; out . pop indent ( ) ; out . printil ( } ) ; }	privat gener xml prolog , which includ xml declar xml doctyp declar . void gener xml prolog ( node . node page ) { xml declar gener under follow condit : omit xml declar attribut jsp : output action set fals jsp document without jsp : root string omit xml decl = page info . get omit xml decl ( ) ; ( ( omit xml decl = null jsp util . boolean valu ( omit xml decl ) ) ( omit xml decl = = null page . get root ( ) . xml syntax ( ) page info . ha jsp root ( ) ctxt . tag file ( ) ) ) { string c type = page info . get content type ( ) ; string char set = c type . substr ( c type . index ( charset = ) 8 ) ; out . printil ( out . write ( xml version = 1 . 0 encod = char set n ) ; ) ; } output doctyp declar doctyp root element appear . doctyp public appear : doctyp name public doctyp public doctyp system els doctyp name system doctyp system string doctyp name = page info . get doctyp name ( ) ; ( doctyp name = null ) { string doctyp public = page info . get doctyp public ( ) ; string doctyp system = page info . get doctyp system ( ) ; out . printin ( out . write ( doctyp ) ; out . print ( doctyp name ) ; ( doctyp public = = null ) { out . print ( system ) ; } els { out . print ( public ) ; out . print ( doctyp public ) ; out . print ( ) ; } out . print ( doctyp system ) ; out . println ( n ) ; ) ; } }	overrid public void visit ( node . do bodi action n ) throw jasper except { n . set begin java line ( out . get java line ( ) ) ; copi virtual page scope tag file page scope invok page out . printil ( ( ( org . apach . jasper . runtim . jsp context wrapper ) thi . jsp context ) . sync befor invok ( ) ; ) ; invok bodi string var reader attr = n . get text attribut ( var reader ) ; string var attr = n . get text attribut ( var ) ; ( var reader attr = null var attr = null ) { out . printil ( jspx sout = new java . io . string writer ( ) ; ) ; } els { out . printil ( jspx sout = null ; ) ; } out . printil ( ( get jsp bodi ( ) = null ) ) ; out . push indent ( ) ; out . printil ( get jsp bodi ( ) . invok ( jspx sout ) ; ) ; out . pop indent ( ) ; store var reader appropri scope ( var reader attr = null var attr = null ) { string scope name = n . get text attribut ( scope ) ; out . printin ( jspx page context . set attribut ( ) ; ( var reader attr = null ) { out . print ( quot ( var reader attr ) ) ; out . print ( , new java . io . string reader ( jspx sout . string ( ) ) ) ; } els { out . print ( quot ( var attr ) ) ; out . print ( , jspx sout . string ( ) ) ; } ( scope name = null ) { out . print ( , ) ; out . print ( get scope constant ( scope name ) ) ; } out . println ( ) ; ) ; } restor el context out . printil ( jsp context . get elcontext ( ) . put context ( jsp context . class , get jsp context ( ) ) ; ) ; n . set end java line ( out . get java line ( ) ) ; }	overrid public void visit ( node . forward action n ) throw jasper except { node . jsp attribut page = n . get page ( ) ; n . set begin java line ( out . get java line ( ) ) ; so javac won t complain about out . printil ( ( true ) { ) ; code after return out . push indent ( ) ; string page param ; ( page . name attribut ( ) ) { page jsp : forward wa specifi via jsp : attribut , first gener code evalu bodi . page param = gener name attribut valu ( page . get name attribut node ( ) ) ; } els { page param = attribut valu ( page , fals , string . class ) ; } ani param have valu specifi jsp : attribut , prepar those valu first . node jsp bodi = find jsp bodi ( n ) ; ( jsp bodi = null ) { prepar param ( jsp bodi ) ; } els { prepar param ( n ) ; } out . printin ( jspx page context . forward ( ) ; out . print ( page param ) ; print param ( n , page param , page . liter ( ) ) ; out . println ( ) ; ) ; ( tag file fragment ) { out . printil ( throw new skip page except ( ) ; ) ; } els { out . printil ( ( method nest 0 ) return true ; : return ; ) ; } out . pop indent ( ) ; out . printil ( } ) ; n . set end java line ( out . get java line ( ) ) ; xxx sure we can elimin dead code after thi . }	overrid public void visit ( node . invok action n ) throw jasper except { n . set begin java line ( out . get java line ( ) ) ; copi virtual page scope tag file page scope invok page out . printil ( ( ( org . apach . jasper . runtim . jsp context wrapper ) thi . jsp context ) . sync befor invok ( ) ; ) ; string var reader attr = n . get text attribut ( var reader ) ; string var attr = n . get text attribut ( var ) ; ( var reader attr = null var attr = null ) { out . printil ( jspx sout = new java . io . string writer ( ) ; ) ; } els { out . printil ( jspx sout = null ; ) ; } invok fragment , unless fragment null out . printin ( ( ) ; out . print ( getter method ( n . get text attribut ( fragment ) ) ) ; out . println ( = null ) { ) ; out . push indent ( ) ; out . printin ( getter method ( n . get text attribut ( fragment ) ) ) ; out . println ( . invok ( jspx sout ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; store var reader appropri scope ( var reader attr = null var attr = null ) { string scope name = n . get text attribut ( scope ) ; out . printin ( jspx page context . set attribut ( ) ; ( var reader attr = null ) { out . print ( quot ( var reader attr ) ) ; out . print ( , new java . io . string reader ( jspx sout . string ( ) ) ) ; } els { out . print ( quot ( var attr ) ) ; out . print ( , jspx sout . string ( ) ) ; } ( scope name = null ) { out . print ( , ) ; out . print ( get scope constant ( scope name ) ) ; } out . println ( ) ; ) ; } restor el context out . printil ( jsp context . get elcontext ( ) . put context ( jsp context . class , get jsp context ( ) ) ; ) ; n . set end java line ( out . get java line ( ) ) ; }	overrid public void visit ( node . jsp element n ) throw jasper except { n . set begin java line ( out . get java line ( ) ) ; comput attribut valu string xml style name attribut hashtabl string , string map = new hashtabl string , string ( ) ; node . jsp attribut attr = n . get jsp attribut ( ) ; ( int i = 0 ; attr = null i attr . length ; i ) { string valu = null ; string nvp = null ; ( attr i . name attribut ( ) ) { name attribut attr = attr i . get name attribut node ( ) ; node . jsp attribut omit attr = attr . get omit ( ) ; string omit ; ( omit attr = = null ) { omit = fals ; } els { omit = attribut valu ( omit attr , fals , boolean . class ) ; ( true . equal ( omit ) ) { continu ; } } valu = gener name attribut valu ( attr i . get name attribut node ( ) ) ; ( fals . equal ( omit ) ) { nvp = attr i . get name ( ) = valu ; } els { nvp = ( boolean . valu ( omit ) : attr i . get name ( ) = valu ) ; } } els { valu = attribut valu ( attr i , fals , object . class ) ; nvp = attr i . get name ( ) = valu ; } map . put ( attr i . get name ( ) , nvp ) ; } write begin tag , us xml style name attribut element name string elem name = attribut valu ( n . get name attribut ( ) , fals , string . class ) ; out . printin ( out . write ( ) ; out . print ( elem name ) ; write remain attribut enumer string enumer = map . kei ( ) ; while ( enumer . ha more element ( ) ) { string attr name = enumer . next element ( ) ; out . print ( map . get ( attr name ) ) ; } doe jsp : element have nest tag other than jsp : attribut boolean ha bodi = fals ; node . node subel = n . get bodi ( ) ; ( subel = null ) { ( int i = 0 ; i subel . size ( ) ; i ) { node subelem = subel . get node ( i ) ; ( ( subelem instanceof node . name attribut ) ) { ha bodi = true ; break ; } } } ( ha bodi ) { out . println ( ) ; ) ; smap should includ bodi n . set end java line ( out . get java line ( ) ) ; visit tag bodi visit bodi ( n ) ; write end tag out . printin ( out . write ( ) ; out . print ( elem name ) ; out . println ( ) ; ) ; } els { out . println ( ) ; ) ; n . set end java line ( out . get java line ( ) ) ; } }	privat void gener declar ( node . node page ) throw jasper except { class declar visitor extend node . visitor { privat boolean get servlet info gener = fals ; gener get servlet info ( ) method return valu page direct s info attribut , present . valid ha alreadi ensur translat unit contain more than page direct info attribut , valu match . overrid public void visit ( node . page direct n ) throw jasper except { ( get servlet info gener ) { return ; } string info = n . get attribut valu ( info ) ; ( info = = null ) return ; get servlet info gener = true ; out . printil ( public string get servlet info ( ) { ) ; out . push indent ( ) ; out . printin ( return ) ; out . print ( quot ( info ) ) ; out . println ( ; ) ; out . pop indent ( ) ; out . printil ( } ) ; out . println ( ) ; } overrid } }	overrid public void visit ( node . us bean n ) throw jasper except { string name = n . get text attribut ( id ) ; string scope = n . get text attribut ( scope ) ; string klass = n . get text attribut ( class ) ; string type = n . get text attribut ( type ) ; node . jsp attribut bean name = n . get bean name ( ) ; class specifi , try instanti compil time boolean gener new = fals ; canon name klass string canon name = null ; ( klass = null ) { try { class bean = ctxt . get class loader ( ) . load class ( klass ) ; ( klass . index ( ) = 0 ) { obtain canon type name canon name = bean . get canon name ( ) ; } els { canon name = klass ; } int modifi = bean . get modifi ( ) ; ( modifi . public ( modifi ) modifi . interfac ( modifi ) modifi . abstract ( modifi ) ) { throw new except ( invalid bean class modifi ) ; } check 0 arg constructor bean . get constructor ( new class { } ) ; compil time , we have determin bean class exist , public zero constructor , new ( ) can us bean instanti . gener new = true ; } catch ( except e ) { depend compil flag . ( ctxt . get option ( ) . get error us bean invalid class attribut ( ) ) { err . jsp error ( n , jsp . error . invalid . bean , klass ) ; } ( canon name = = null ) { do our best here get canon name from binari name , should work 99 . 99 time . canon name = klass . replac ( , . ) ; } } ( type = = null ) { type unspecifi , us class type bean type = canon name ; } } jsp . 5 . 1 , semat , para 1 lock requir request page scope default page string scopenam = page context . page scope ; string lock = null ; ( request . equal ( scope ) ) { scopenam = page context . request scope ; } els ( session . equal ( scope ) ) { scopenam = page context . session scope ; lock = session ; } els ( applic . equal ( scope ) ) { scopenam = page context . applic scope ; lock = applic ; } n . set begin java line ( out . get java line ( ) ) ; declar bean out . printin ( type ) ; out . print ( ) ; out . print ( name ) ; out . println ( = null ; ) ; lock ( requir ) while get creat bean ( lock = null ) { out . printin ( synchron ( ) ; out . print ( lock ) ; out . println ( ) { ) ; out . push indent ( ) ; } locat bean from context out . printin ( name ) ; out . print ( = ( ) ; out . print ( type ) ; out . print ( ) jspx page context . get attribut ( ) ; out . print ( quot ( name ) ) ; out . print ( , ) ; out . print ( scopenam ) ; out . println ( ) ; ) ; creat bean check bean alreadi out . printin ( ( ) ; out . print ( name ) ; out . println ( = = null ) { ) ; out . push indent ( ) ; ( klass = = null bean name = = null ) { both class name bean name specifi , bean must found local , otherwis s error out . printin ( throw new java . lang . instanti except ( bean ) ; out . print ( name ) ; out . println ( found within scope ) ; ) ; } els { instanti bean specifi scope . ( gener new ) { string binari name ; ( bean name = null ) { ( bean name . name attribut ( ) ) { valu bean name wa specifi via jsp : attribut , first gener code evalu bodi . binari name = gener name attribut valu ( bean name . get name attribut node ( ) ) ; } els { binari name = attribut valu ( bean name , fals , string . class ) ; } } els { impli klass null binari name = quot ( klass ) ; } out . printil ( try { ) ; out . push indent ( ) ; out . printin ( name ) ; out . print ( = ( ) ; out . print ( type ) ; out . print ( ) java . bean . bean . instanti ( ) ; out . print ( thi . get class ( ) . get class loader ( ) , ) ; out . print ( binari name ) ; out . println ( ) ; ) ; out . pop indent ( ) ; note : bean . instanti throw class found except bean class abstract . out . printil ( } catch ( class found except exc ) { ) ; out . push indent ( ) ; out . printil ( throw new instanti except ( exc . get messag ( ) ) ; ) ; out . pop indent ( ) ; out . printil ( } catch ( except exc ) { ) ; out . push indent ( ) ; out . printin ( throw new servlet except ( ) ; out . print ( cannot creat bean class ) ; out . print ( binari name ) ; out . println ( , exc ) ; ) ; out . pop indent ( ) ; close try out . printil ( } ) ; } els { impli klass null gener code instanti bean class out . printin ( name ) ; out . print ( = new ) ; out . print ( canon name ) ; out . println ( ( ) ; ) ; } set attribut bean specifi scope out . printin ( jspx page context . set attribut ( ) ; out . print ( quot ( name ) ) ; out . print ( , ) ; out . print ( name ) ; out . print ( , ) ; out . print ( scopenam ) ; out . println ( ) ; ) ; onli visit bodi when bean instanti visit bodi ( n ) ; } out . pop indent ( ) ; out . printil ( } ) ; end lock block ( lock = null ) { out . pop indent ( ) ; out . printil ( } ) ; } n . set end java line ( out . get java line ( ) ) ; }
protect initi connect pool call from constructor param properti pool properti properti us initi pool throw sqlexcept initi fail void init ( pool configur properti ) throw sqlexcept { pool properti = properti ; make space 10 extra case we flow over bit busi = new arrai block queue pool connect ( properti . get max activ ( ) , fals ) ; make space 10 extra case we flow over bit ( properti . fair queue ( ) ) { idl = new fair block queue pool connect ( ) ; idl = new multi lock fair block queue pool connect ( ) ; } els { idl = new arrai block queue pool connect ( properti . get max activ ( ) , properti . fair queue ( ) ) ; } evictor thread suppos run , start now ( properti . pool sweeper enabl ( ) ) { pool cleaner = new pool cleaner ( pool cleaner : properti . get name ( ) , thi , properti . get time between evict run milli ( ) ) ; pool cleaner . start ( ) ; } make sure pool properli configur ( properti . get max activ ( ) properti . get initi size ( ) ) { log . warn ( initi size larger than max activ , set initi size : properti . get max activ ( ) ) ; properti . set initi size ( properti . get max activ ( ) ) ; } ( properti . get min idl ( ) properti . get max activ ( ) ) { log . warn ( min idl larger than max activ , set min idl : properti . get max activ ( ) ) ; properti . set min idl ( properti . get max activ ( ) ) ; } ( properti . get max idl ( ) properti . get max activ ( ) ) { log . warn ( max idl larger than max activ , set max idl : properti . get max activ ( ) ) ; properti . set max idl ( properti . get max activ ( ) ) ; } ( properti . get max idl ( ) properti . get min idl ( ) ) { log . warn ( max idl smaller than min idl , set max idl : properti . get min idl ( ) ) ; properti . set max idl ( properti . get min idl ( ) ) ; } creat jmx mbean ( thi . get pool properti ( ) . jmx enabl ( ) ) creat mbean ( ) ; pars creat initi set interceptor . let them know pool ha start . interceptor get ani connect . pool properti . interceptor definit proxi = get pool properti ( ) . get jdbc interceptor arrai ( ) ; ( int i = 0 ; i proxi . length ; i ) { try { ( log . debug enabl ( ) ) { log . debug ( creat interceptor instanc class : proxi i . get interceptor class ( ) ) ; } proxi i . get interceptor class ( ) . new instanc ( ) . pool start ( thi ) ; } catch ( except x ) { log . error ( unabl inform interceptor pool start . , x ) ; ( jmx pool = null ) jmx pool . notifi ( org . apach . tomcat . jdbc . pool . jmx . connect pool . notifi init , get stack trace ( x ) ) ; close ( true ) ; sqlexcept ex = new sqlexcept ( ) ; ex . init caus ( x ) ; throw ex ; } } initi pool initi set member pool connect initi pool = new pool connect pool properti . get initi size ( ) ; try { ( int i = 0 ; i initi pool . length ; i ) { don t wait , should content initi pool i = thi . borrow connect ( 0 , null , null ) ; } } catch ( sqlexcept x ) { ( jmx pool = null ) jmx pool . notifi ( org . apach . tomcat . jdbc . pool . jmx . connect pool . notifi init , get stack trace ( x ) ) ; close ( true ) ; throw x ; } final { return member idl pool ( int i = 0 ; i initi pool . length ; i ) { ( initi pool i = null ) { try { thi . return connect ( initi pool i ) ; } catch ( except x ) { noop } } end } } catch close = fals ; }
overrid protect object creat decor ( object proxi , method method , object arg , object statement , constructor constructor , string sql ) throw instanti except , illeg access except , invoc target except { boolean process = process ( thi . type , method , fals ) ; ( process ) { object result = null ; cach statement statement proxi = new cach statement ( ( statement ) statement , sql ) ; result = constructor . new instanc ( new object { statement proxi } ) ; statement proxi . set actual proxi ( result ) ; statement proxi . set connect ( proxi ) ; statement proxi . set constructor ( constructor ) ; return result ; } els { return super . creat decor ( proxi , method , arg , statement , constructor , sql ) ; } }	public atom integ get cach size ( ) { return cach size ; }	public static mbean notif info get default notif info ( ) { string type = new string { notifi init , notifi connect , notifi abandon , slow queri notif , fail queri notif , suspect abandon notif } ; string name = notif . class . get name ( ) ; string descript = connect pool error condit wa met . ; mbean notif info info = new mbean notif info ( type , name , descript ) ; return new mbean notif info { info } ; }	public void pool start ( connect pool pool ) { cach size map . put absent ( pool , new atom integ ( 0 ) ) ; super . pool start ( pool ) ; }	public void set properti ( map string , interceptor properti properti ) { super . set properti ( properti ) ; interceptor properti p = properti . get ( prepar ) ; ( p = null ) cach prepar = p . get valu boolean ( cach prepar ) ; p = properti . get ( callabl ) ; ( p = null ) cach callabl = p . get valu boolean ( cach callabl ) ; p = properti . get ( max ) ; ( p = null ) max cach size = p . get valu int ( max cach size ) ; ( cach prepar cach callabl ) { thi . type = all type ; } els ( cach prepar ) { thi . type = prepar type ; } els ( cach callabl ) { thi . type = callabl type ; } els { thi . type = type ; } }
public void do get ( http servlet request request , http servlet respons respons ) throw ioexcept , servlet except { respons . set content type ( text html ) ; print writer out = respons . get writer ( ) ; out . println ( html ) ; out . println ( bodi bgcolor = white ) ; out . println ( head ) ; string titl = rb . get string ( cooki . titl ) ; out . println ( titl titl titl ) ; out . println ( head ) ; out . println ( bodi ) ; rel link xxx make absolut till we work out addit path info issu out . println ( href = . . cooki . html ) ; out . println ( img src = . . imag code . gif height = 24 width = 24 align = right border = 0 alt = view code ) ; out . println ( href = . . index . html ) ; out . println ( img src = . . imag return . gif height = 24 width = 24 align = right border = 0 alt = return ) ; out . println ( h3 titl h3 ) ; cooki cooki = request . get cooki ( ) ; ( ( cooki = null ) ( cooki . length 0 ) ) { out . println ( rb . get string ( cooki . cooki ) br ) ; ( int i = 0 ; i cooki . length ; i ) { cooki cooki = cooki i ; out . print ( cooki name : htmlfilter . filter ( cooki . get name ( ) ) br ) ; out . println ( cooki valu : htmlfilter . filter ( cooki . get valu ( ) ) br br ) ; } } els { out . println ( rb . get string ( cooki . cooki ) ) ; } string cooki name = request . get paramet ( cookienam ) ; string cooki valu = request . get paramet ( cookievalu ) ; ( cooki name = null cooki valu = null ) { cooki cooki = new cooki ( cooki name , cooki valu ) ; respons . add cooki ( cooki ) ; out . println ( p ) ; out . println ( rb . get string ( cooki . set ) br ) ; out . print ( rb . get string ( cooki . name ) htmlfilter . filter ( cooki name ) br ) ; out . print ( rb . get string ( cooki . valu ) htmlfilter . filter ( cooki valu ) ) ; } out . println ( p ) ; out . println ( rb . get string ( cooki . make cooki ) br ) ; out . print ( form action = ) ; out . println ( cooki exampl method = post ) ; out . print ( rb . get string ( cooki . name ) ) ; out . println ( input type = text length = 20 name = cookienam br ) ; out . print ( rb . get string ( cooki . valu ) ) ; out . println ( input type = text length = 20 name = cookievalu br ) ; out . println ( input type = submit form ) ; out . println ( bodi ) ; out . println ( html ) ; }
protect ask redirector close all stream . necessari call thi method befor leav task have stream flush content . you ar collect output properti , creat onli thi method call , otherwis you ll find unset . void close redirector ( ) { try { ( redirect output ) { redirector . complet ( ) ; } } catch ( ioexcept ioe ) { log ( error close redirector : ioe . get messag ( ) , project . msg err ) ; } due depend chain , ant could call task more than onc , thi prevent we attempt reus previous close stream . redirect out stream = null ; redirect out print stream = null ; redirect err stream = null ; redirect err print stream = null ; }
public get new ( writabl ) initi context . context get initi context ( hashtabl , environ ) throw name except { ( context bind . thread bound ( ) ( context bind . class loader bound ( ) ) ) { redirect request bound initi context return new selector context ( ( hashtabl string , object ) environ , true ) ; } thread bound , return share writabl context ( initi context = = null ) { synchron ( get class ( ) ) { ( initi context = = null ) { initi context = new name context ( ( hashtabl string , object ) environ , main ) ; } } } return initi context ; }	public object get object instanc ( object obj , name name , context name ctx , hashtabl , environ ) throw name except { ( ( context bind . thread bound ( ) ) ( context bind . class loader bound ( ) ) ) { return new selector context ( ( hashtabl string , object ) environ ) ; } return null ; }
protect creat mbean object can regist . void creat mbean ( ) { try { jmx pool = new org . apach . tomcat . jdbc . pool . jmx . connect pool ( thi ) ; } catch ( except x ) { log . warn ( unabl start jmx integr connect pool . instanc get name ( ) can t monitor . , x ) ; } }	public { inherit doc } connect get ( long timeout , time unit unit ) throw interrupt except , execut except , timeout except { pool connect pc = pc futur . get ( timeout , unit ) ; ( pc = null ) { ( result = null ) return result ; ( configur . compar set ( fals , true ) ) { try { pc = borrow connect ( system . current time milli ( ) , pc , null , null ) ; result = connect pool . thi . setup connect ( pc ) ; } catch ( sqlexcept x ) { caus = x ; } final { latch . count down ( ) ; } } els { we reach here , anoth thread configur actual connect thi shouldn t block long latch . await ( timeout , unit ) ; } ( result = = null ) throw new execut except ( caus ) ; return result ; } els { return null ; } }	protect void creat mbean ( ) { try { jmx pool = new org . apach . tomcat . jdbc . pool . jmx . connect pool ( thi ) ; } catch ( except x ) { log . warn ( unabl start jmx integr connect pool . instanc get name ( ) can t monitor . , x ) ; } }	public retriev connect futur . connect avail , can block us futur . get ( ) until connect ha becom avail . connect retriev , futur must cancel order connect return pool . return futur contain refer connect futur connect throw sqlexcept futur connect get connect async ( ) throw sqlexcept { we can onli retriev futur underli queue support . ( idl instanceof fair block queue ) { futur pool connect pcf = ( ( fair block queue pool connect ) idl ) . poll async ( ) ; return new connect futur ( pcf ) ; } els ( idl instanceof multi lock fair block queue ) { futur pool connect pcf = ( ( multi lock fair block queue pool connect ) idl ) . poll async ( ) ; return new connect futur ( pcf ) ; } els { throw new sqlexcept ( connect pool misconfigur , doesn t support async retriev . set fair properti true ) ; } }	public { inherit doc } boolean cancel ( boolean mai interrupt run ) { ( ( cancel . get ( ) ) cancel . compar set ( fals , true ) ) { cancel retriev connect return pool connect pool . thi . cancel . execut ( thi ) ; } return true ; }	public { inherit doc } boolean cancel ( ) { return pc futur . cancel ( ) cancel . get ( ) ; }	public { inherit doc } boolean done ( ) { return pc futur . done ( ) ; }

protect remov entri from cach . boolean cach unload ( string name ) { ( cach = = null ) return fals ; synchron ( cach ) { return cach . unload ( name ) ; } }
send action connector . param action code type action param param action paramet overrid public void action intern ( action code action code , object param ) { long socket ref = socket . get socket ( ) . long valu ( ) ; ( action code = = action code . close ) { close end process current request , stop ani further transact client comet = fals ; try { output buffer . end request ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . req host addr attribut ) { get remot host address ( remot addr = = null ( socket ref = 0 ) ) { try { long sa = address . get ( socket . apr remot , socket ref ) ; remot addr = address . getip ( sa ) ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . remot addr ( ) . set string ( remot addr ) ; } els ( action code = = action code . req local name attribut ) { get local host name ( local name = = null ( socket ref = 0 ) ) { try { long sa = address . get ( socket . apr local , socket ref ) ; local name = address . getnameinfo ( sa , 0 ) ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . local name ( ) . set string ( local name ) ; } els ( action code = = action code . req host attribut ) { get remot host name ( remot host = = null ( socket ref = 0 ) ) { try { long sa = address . get ( socket . apr remot , socket ref ) ; remot host = address . getnameinfo ( sa , 0 ) ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . remot host ( ) . set string ( remot host ) ; } els ( action code = = action code . req local addr attribut ) { get local host address ( local addr = = null ( socket ref = 0 ) ) { try { long sa = address . get ( socket . apr local , socket ref ) ; local addr = address . getip ( sa ) ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . local addr ( ) . set string ( local addr ) ; } els ( action code = = action code . req remoteport attribut ) { get remot port ( remot port = = 1 ( socket ref = 0 ) ) { try { long sa = address . get ( socket . apr remot , socket ref ) ; sockaddr addr = address . get info ( sa ) ; remot port = addr . port ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . set remot port ( remot port ) ; } els ( action code = = action code . req localport attribut ) { get local port ( local port = = 1 ( socket ref = 0 ) ) { try { long sa = address . get ( socket . apr local , socket ref ) ; sockaddr addr = address . get info ( sa ) ; local port = addr . port ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . set local port ( local port ) ; } els ( action code = = action code . req ssl attribut ) { ( ssl ( socket ref = 0 ) ) { try { cipher suit object ssl o = sslsocket . get info s ( socket ref , ssl . ssl info cipher ) ; ( ssl o = null ) { request . set attribut ( sslsupport . cipher suit kei , ssl o ) ; } get client certif certif chain present cert length = = 1 indic error int cert length = sslsocket . get info i ( socket ref , ssl . ssl info client cert chain ) ; byte client cert = sslsocket . get info b ( socket ref , ssl . ssl info client cert ) ; x509certif cert = null ; ( client cert = null cert length 1 ) { cert = new x509certif cert length 1 ; certif factori cf = certif factori . get instanc ( x . 509 ) ; cert 0 = ( x509certif ) cf . gener certif ( new byte arrai input stream ( client cert ) ) ; ( int i = 0 ; i cert length ; i ) { byte data = sslsocket . get info b ( socket ref , ssl . ssl info client cert chain i ) ; cert i 1 = ( x509certif ) cf . gener certif ( new byte arrai input stream ( data ) ) ; } } ( cert = null ) { request . set attribut ( sslsupport . certif kei , cert ) ; } user kei size ssl o = integ . valu ( sslsocket . get info i ( socket ref , ssl . ssl info cipher usekeys ) ) ; request . set attribut ( sslsupport . kei size kei , ssl o ) ; ssl session id ssl o = sslsocket . get info s ( socket ref , ssl . ssl info session id ) ; ( ssl o = null ) { request . set attribut ( sslsupport . session id kei , ssl o ) ; } todo provid hook enabl ssl session invalid . set apr endpoint . session mgr req attr } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . ssl ) , e ) ; } } } els ( action code = = action code . req ssl certif ) { ( ssl ( socket ref = 0 ) ) { consum buffer request bodi , so doe interfer client s handshak messag input filter input filter = input buffer . get filter ( ) ; ( ( buffer input filter ) input filter constant . buffer filter ) . set limit ( max save post size ) ; input buffer . add activ filter ( input filter constant . buffer filter ) ; try { configur connect requir certif sslsocket . set verifi ( socket ref , ssl . ssl cverifi requir , endpoint . get sslverifi depth ( ) ) ; renegoti certif ( sslsocket . renegoti ( socket ref ) = = 0 ) { don t look cert unless we know renegoti work . get client certif certif chain present cert length = = 1 indic error int cert length = sslsocket . get info i ( socket ref , ssl . ssl info client cert chain ) ; byte client cert = sslsocket . get info b ( socket ref , ssl . ssl info client cert ) ; x509certif cert = null ; ( client cert = null cert length 1 ) { cert = new x509certif cert length 1 ; certif factori cf = certif factori . get instanc ( x . 509 ) ; cert 0 = ( x509certif ) cf . gener certif ( new byte arrai input stream ( client cert ) ) ; ( int i = 0 ; i cert length ; i ) { byte data = sslsocket . get info b ( socket ref , ssl . ssl info client cert chain i ) ; cert i 1 = ( x509certif ) cf . gener certif ( new byte arrai input stream ( data ) ) ; } } ( cert = null ) { request . set attribut ( sslsupport . certif kei , cert ) ; } } } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . ssl ) , e ) ; } } } els ( action code = = action code . avail ) { request . set avail ( input buffer . avail ( ) ) ; } els ( action code = = action code . comet begin ) { comet = true ; } els ( action code = = action code . comet end ) { comet = fals ; } els ( action code = = action code . comet close ) { endpoint . process socket async ( thi . socket , socket statu . open ) ; } els ( action code = = action code . comet settimeout ) { op } els ( action code = = action code . async complet ) { ( async state machin . async complet ( ) ) { endpoint . process socket async ( thi . socket , socket statu . open ) ; } } els ( action code = = action code . async settimeout ) { ( param = = null ) return ; long timeout = ( ( long ) param ) . long valu ( ) ; socket . set timeout ( timeout ) ; } els ( action code = = action code . async dispatch ) { ( async state machin . async dispatch ( ) ) { endpoint . process socket async ( thi . socket , socket statu . open ) ; } } }
protect send session expir other cluster node param id session id void session expir ( string id ) { counter send evt session expir ; session messag msg = new session messag impl ( get name ( ) , session messag . evt session expir , null , id , id expir msg ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( delta manag . creat messag . expir , get name ( ) , id ) ) ; send ( msg ) ; }	protect byte serial session id ( string session id ) throw ioexcept { byte arrai output stream bo = new byte arrai output stream ( ) ; object output stream oo = new object output stream ( bo ) ; oo . write utf ( session id ) ; oo . flush ( ) ; oo . close ( ) ; return bo . byte arrai ( ) ; }
public void do filter ( http servlet request request , http servlet respons respons , filter chain chain ) throw ioexcept , servlet except { ( match ( request . get remot addr ( ) , intern proxi ) ) { string remot ip = null ; java 6 , proxi header valu should declar java . util . dequ link list string proxi header valu = new link list string ( ) ; string remot ip header valu = comma delimit list string arrai ( request . get header ( remot ip header ) ) ; int idx ; loop remot ip header valu find first trust remot ip build proxi chain ( idx = remot ip header valu . length 1 ; idx = 0 ; idx ) { string current remot ip = remot ip header valu idx ; remot ip = current remot ip ; ( match ( current remot ip , intern proxi ) ) { do noth , intern proxi ip ar append } els ( match ( current remot ip , trust proxi ) ) { proxi header valu . add first ( current remot ip ) ; } els { decrement idx becaus break statement doesn t do idx ; break ; } } continu loop remot ip header valu build new valu remot ip header link list string new remot ip header valu = new link list string ( ) ; ( ; idx = 0 ; idx ) { string current remot ip = remot ip header valu idx ; new remot ip header valu . add first ( current remot ip ) ; } xforward request x request = new xforward request ( request ) ; ( remot ip = null ) { x request . set remot addr ( remot ip ) ; x request . set remot host ( remot ip ) ; ( proxi header valu . size ( ) = = 0 ) { x request . remov header ( proxi header ) ; } els { string comma delimit list proxi = list comma delimit string ( proxi header valu ) ; x request . set header ( proxi header , comma delimit list proxi ) ; } ( new remot ip header valu . size ( ) = = 0 ) { x request . remov header ( remot ip header ) ; } els { string comma delimit remot ip header valu = list comma delimit string ( new remot ip header valu ) ; x request . set header ( remot ip header , comma delimit remot ip header valu ) ; } } ( protocol header = null ) { string protocol header valu = request . get header ( protocol header ) ; ( protocol header valu = = null ) { don t modifi secur , scheme server port attribut request } els ( protocol header http valu . equal ignor case ( protocol header valu ) ) { x request . set secur ( true ) ; x request . set scheme ( http ) ; x request . set server port ( http server port ) ; } els { x request . set secur ( fals ) ; x request . set scheme ( http ) ; x request . set server port ( http server port ) ; } } ( log . debug enabl ( ) ) { log . debug ( incom request request . get request uri ( ) origin remot addr request . get remot addr ( ) , origin remot host = request . get remot host ( ) , origin secur = request . secur ( ) , origin scheme = request . get scheme ( ) , origin remot ip header = request . get header ( remot ip header ) , origin protocol header = ( protocol header = = null null : request . get header ( protocol header ) ) seen new remot addr = x request . get remot addr ( ) , new remot host = x request . get remot host ( ) , new scheme = x request . get scheme ( ) , new secur = x request . secur ( ) , new remot ip header = x request . get header ( remot ip header ) , new proxi header = x request . get header ( proxi header ) ) ; } chain . do filter ( x request , respons ) ; } els { ( log . debug enabl ( ) ) { log . debug ( skip remot ip filter request request . get request uri ( ) origin remot addr request . get remot addr ( ) ) ; } chain . do filter ( request , respons ) ; } }	{ inherit doc } overrid public void invok ( request request , respons respons ) throw ioexcept , servlet except { final string origin remot addr = request . get remot addr ( ) ; final string origin remot host = request . get remot host ( ) ; final string origin scheme = request . get scheme ( ) ; final boolean origin secur = request . secur ( ) ; final int origin server port = request . get server port ( ) ; ( match ( origin remot addr , intern proxi ) ) { string remot ip = null ; java 6 , proxi header valu should declar java . util . dequ link list string proxi header valu = new link list string ( ) ; string remot ip header valu = comma delimit list string arrai ( request . get header ( remot ip header ) ) ; int idx ; loop remot ip header valu find first trust remot ip build proxi chain ( idx = remot ip header valu . length 1 ; idx = 0 ; idx ) { string current remot ip = remot ip header valu idx ; remot ip = current remot ip ; ( match ( current remot ip , intern proxi ) ) { do noth , intern proxi ip ar append } els ( match ( current remot ip , trust proxi ) ) { proxi header valu . add first ( current remot ip ) ; } els { decrement idx becaus break statement doesn t do idx ; break ; } } continu loop remot ip header valu build new valu remot ip header link list string new remot ip header valu = new link list string ( ) ; ( ; idx = 0 ; idx ) { string current remot ip = remot ip header valu idx ; new remot ip header valu . add first ( current remot ip ) ; } ( remot ip = null ) { request . set remot addr ( remot ip ) ; request . set remot host ( remot ip ) ; 6 . 0 ( proxi header valu . size ( ) = = 0 ) { request . get coyot request ( ) . get mime header ( ) . remov header ( proxi header ) ; } els { string comma delimit list proxi = list comma delimit string ( proxi header valu ) ; request . get coyot request ( ) . get mime header ( ) . set valu ( proxi header ) . set string ( comma delimit list proxi ) ; } ( new remot ip header valu . size ( ) = = 0 ) { request . get coyot request ( ) . get mime header ( ) . remov header ( remot ip header ) ; } els { string comma delimit remot ip header valu = list comma delimit string ( new remot ip header valu ) ; request . get coyot request ( ) . get mime header ( ) . set valu ( remot ip header ) . set string ( comma delimit remot ip header valu ) ; } } ( protocol header = null ) { string protocol header valu = request . get header ( protocol header ) ; ( protocol header valu = = null ) { don t modifi secur , scheme server port attribut request } els ( protocol header http valu . equal ignor case ( protocol header valu ) ) { request . set secur ( true ) ; us request . coyot request . scheme instead request . set scheme ( ) becaus request . set scheme ( ) op tomcat 6 . 0 request . get coyot request ( ) . scheme ( ) . set string ( http ) ; request . set server port ( http server port ) ; } els { request . set secur ( fals ) ; us request . coyot request . scheme instead request . set scheme ( ) becaus request . set scheme ( ) op tomcat 6 . 0 request . get coyot request ( ) . scheme ( ) . set string ( http ) ; request . set server port ( http server port ) ; } } ( log . debug enabl ( ) ) { log . debug ( incom request request . get request uri ( ) origin remot addr origin remot addr , origin remot host = origin remot host , origin secur = origin secur , origin scheme = origin scheme seen new remot addr = request . get remot addr ( ) , new remot host = request . get remot host ( ) , new scheme = request . get scheme ( ) , new secur = request . secur ( ) ) ; } } els { ( log . debug enabl ( ) ) { log . debug ( skip remot ip valv request request . get request uri ( ) origin remot addr request . get remot addr ( ) ) ; } } try { get next ( ) . invok ( request , respons ) ; } final { request . set remot addr ( origin remot addr ) ; request . set remot host ( origin remot host ) ; request . set secur ( origin secur ) ; us request . coyot request . scheme instead request . set scheme ( ) becaus request . set scheme ( ) op tomcat 6 . 0 request . get coyot request ( ) . scheme ( ) . set string ( origin scheme ) ; request . set server port ( origin server port ) ; } }	public void set header ( string name , string valu ) { get coyot request ( ) . get mime header ( ) . set valu ( name ) . set string ( valu ) ; }	public void test invok all proxi ar intern ( ) throw except { prepar filter def filter def = new filter def ( ) ; filter def . add init paramet ( intern proxi , 192 . 168 . 0 . 10 , 192 . 168 . 0 . 11 ) ; filter def . add init paramet ( trust proxi , proxy1 , proxy2 , proxy3 ) ; filter def . add init paramet ( remot ip header , x forward ) ; filter def . add init paramet ( proxi header , x forward ) ; mock http servlet request request = new mock http servlet request ( ) ; request . set remot addr ( 192 . 168 . 0 . 10 ) ; request . set remot host ( remot host origin valu ) ; request . set header ( x forward , 140 . 211 . 11 . 130 , 192 . 168 . 0 . 10 , 192 . 168 . 0 . 11 ) ; test http servlet request actual request = test remot ip filter ( filter def , request ) ; verifi string actual xforward = actual request . get header ( x forward ) ; assert null ( all proxi ar intern , x forward must null , actual xforward ) ; string actual xforward = actual request . get header ( x forward ) ; assert null ( all proxi ar intern , x forward must null , actual xforward ) ; string actual remot addr = actual request . get remot addr ( ) ; assert equal ( remot addr , 140 . 211 . 11 . 130 , actual remot addr ) ; string actual remot host = actual request . get remot host ( ) ; assert equal ( remot host , 140 . 211 . 11 . 130 , actual remot host ) ; }	public void test invok all proxi ar trust remot addr match regexp ( ) throw except { prepar filter def filter def = new filter def ( ) ; filter def . add init paramet ( intern proxi , 127 . 0 . 0 . 1 , 192 . 168 . . , anoth intern proxi ) ; filter def . add init paramet ( trust proxi , proxy1 , proxy2 , proxy3 ) ; filter def . add init paramet ( remot ip header , x forward ) ; filter def . add init paramet ( proxi header , x forward ) ; mock http servlet request request = new mock http servlet request ( ) ; request . set remot addr ( 192 . 168 . 0 . 10 ) ; request . set remot host ( remot host origin valu ) ; request . set header ( x forward , 140 . 211 . 11 . 130 , proxy1 , proxy2 ) ; test http servlet request actual request = test remot ip filter ( filter def , request ) ; verifi string actual xforward = actual request . get header ( x forward ) ; assert null ( all proxi ar trust , x forward must null , actual xforward ) ; string actual xforward = actual request . get header ( x forward ) ; assert equal ( all proxi ar trust , thei must appear x forward , proxy1 , proxy2 , actual xforward ) ; string actual remot addr = actual request . get remot addr ( ) ; assert equal ( remot addr , 140 . 211 . 11 . 130 , actual remot addr ) ; string actual remot host = actual request . get remot host ( ) ; assert equal ( remot host , 140 . 211 . 11 . 130 , actual remot host ) ; }	public void test invok all proxi ar trust remot addr match regexp ( ) throw except { prepar remot ip valv remot ip valv = new remot ip valv ( ) ; remot ip valv . set intern proxi ( 127 . 0 . 0 . 1 , 192 . 168 . . , anoth intern proxi ) ; remot ip valv . set trust proxi ( proxy1 , proxy2 , proxy3 ) ; remot ip valv . set remot ip header ( x forward ) ; remot ip valv . set proxi header ( x forward ) ; remot addr host tracker valv remot addr host tracker valv = new remot addr host tracker valv ( ) ; remot ip valv . set next ( remot addr host tracker valv ) ; request request = new request ( ) ; request . set coyot request ( new org . apach . coyot . request ( ) ) ; request . set remot addr ( 192 . 168 . 0 . 10 ) ; request . set remot host ( remot host origin valu ) ; request . get coyot request ( ) . get mime header ( ) . add valu ( x forward ) . set string ( 140 . 211 . 11 . 130 , proxy1 , proxy2 ) ; test remot ip valv . invok ( request , null ) ; verifi string actual xforward = request . get header ( x forward ) ; assert null ( all proxi ar trust , x forward must null , actual xforward ) ; string actual xforward = request . get header ( x forward ) ; assert equal ( all proxi ar trust , thei must appear x forward , proxy1 , proxy2 , actual xforward ) ; string actual remot addr = remot addr host tracker valv . get remot addr ( ) ; assert equal ( remot addr , 140 . 211 . 11 . 130 , actual remot addr ) ; string actual remot host = remot addr host tracker valv . get remot host ( ) ; assert equal ( remot host , 140 . 211 . 11 . 130 , actual remot host ) ; string actual post invok remot addr = request . get remot addr ( ) ; assert equal ( post invok remot addr , 192 . 168 . 0 . 10 , actual post invok remot addr ) ; string actual post invok remot host = request . get remot host ( ) ; assert equal ( post invok remot addr , remot host origin valu , actual post invok remot host ) ; }
protect log get log ( ) { return log ; }
protect search directori return user object contain inform about user specifi usernam , found directori ; otherwis return code null code . param context directori context param usernam usernam param attr id string contain name attribut retriev . except name except directori server error occur user get user search ( dir context context , string usernam , string attr id ) throw name except { ( usernam = = null user search format = = null ) return ( null ) ; form search filter string filter = user search format . format ( new string { usernam } ) ; set up search control search control constraint = new search control ( ) ; ( user subtre ) { constraint . set search scope ( search control . subtre scope ) ; } els { constraint . set search scope ( search control . onelevel scope ) ; } specifi attribut retriev ( attr id = = null ) attr id = new string 0 ; constraint . set return attribut ( attr id ) ; name enumer search result result = context . search ( user base , filter , constraint ) ; fail entri found try { ( result = = null result . ha more ( ) ) { return ( null ) ; } } catch ( partial result except ex ) { ( ad compat ) throw ex ; els return ( null ) ; } get result first entri found search result result = result . next ( ) ; check further entri were found try { ( result . ha more ( ) ) { ( contain log . info enabl ( ) ) contain log . info ( usernam usernam ha multipl entri ) ; return ( null ) ; } } catch ( partial result except ex ) { ( ad compat ) throw ex ; } string dn = get distinguish name ( context , user base , result ) ; ( contain log . trace enabl ( ) ) contain log . trace ( entri found usernam dn dn ) ; get entri s attribut attribut attr = result . get attribut ( ) ; ( attr = = null ) return null ; retriev valu user password string password = null ; ( user password = null ) password = get attribut valu ( user password , attr ) ; retriev valu user role name attribut arrai list string role = null ; ( user role name = null ) role = add attribut valu ( user role name , attr , role ) ; return new user ( usernam , dn , password , role ) ; }	public set connect timeout . param timeout new connect timeout void set connect timeout ( string timeout ) { thi . connect timeout = timeout ; }
public static final number add ( final object obj0 , final object obj1 ) { ( obj0 = = null obj1 = = null ) { return long . valu ( 0 ) ; } final elarithmet deleg ; ( bigdecim . match ( obj0 , obj1 ) ) deleg = bigdecim ; }	static final number mod ( final object obj0 , final object obj1 ) { ( obj0 = = null obj1 = = null ) { return long . valu ( 0 ) ; } final elarithmet deleg ; ( bigdecim . match ( obj0 , obj1 ) ) deleg = bigdecim ; }	static final number multipli ( final object obj0 , final object obj1 ) { ( obj0 = = null obj1 = = null ) { return long . valu ( 0 ) ; } final elarithmet deleg ; ( bigdecim . match ( obj0 , obj1 ) ) deleg = bigdecim ; }	static final number subtract ( final object obj0 , final object obj1 ) { ( obj0 = = null obj1 = = null ) { return long . valu ( 0 ) ; } final elarithmet deleg ; ( bigdecim . match ( obj0 , obj1 ) ) deleg = bigdecim ; }
privat thread safe wai retriev connect from pool param wait time wait , overrid max wait from properti , set 1 you wish us max wait , 0 you wish wait time . return pool connect throw sqlexcept pool connect borrow connect ( int wait ) throw sqlexcept { ( close ( ) ) { throw new sqlexcept ( connect pool close . ) ; } end get current time stamp long now = system . current time milli ( ) ; see avail immedi pool connect con = idl . poll ( ) ; while ( true ) { ( con = null ) { configur connect return pool connect result = borrow connect ( now , con ) ; null should never return , wa previou impl . ( result = null ) return result ; } new connect ( size . get ( ) get pool properti ( ) . get max activ ( ) ) { atom duplic check ( size . add get ( 1 ) get pool properti ( ) . get max activ ( ) ) { we got here , two thread pass through first size . decrement get ( ) ; } els { creat connect , we re below limit return creat connect ( now , con ) ; } } end calcul wait time thi iter long max wait = wait ; pass wait time 1 , mean we should us pool properti valu ( wait = = 1 ) { max wait = ( get pool properti ( ) . get max wait ( ) = 0 ) long . max valu : get pool properti ( ) . get max wait ( ) ; } long timetowait = math . max ( 0 , max wait ( system . current time milli ( ) now ) ) ; waitcount . increment get ( ) ; try { retriev exist connect con = idl . poll ( timetowait , time unit . millisecond ) ; } catch ( interrupt except ex ) { clear flag , bail out thread . interrupt ( ) ; sqlexcept sx = new sqlexcept ( pool wait interrupt . ) ; sx . init caus ( ex ) ; throw sx ; } final { waitcount . decrement get ( ) ; } ( max wait = = 0 con = = null ) { wait , return we have throw new sqlexcept ( thread . current thread ( ) . get name ( ) wait : pool empti . unabl fetch connect , none avail busi . size ( ) us . ) ; } we didn t get connect , let see we time out ( con = = null ) { ( ( system . current time milli ( ) now ) = max wait ) { throw new sqlexcept ( thread . current thread ( ) . get name ( ) timeout : pool empti . unabl fetch connect ( max wait 1000 ) second , none avail busi . size ( ) us . ) ; } els { timeout , let try again continu ; } } } while }	protect valid configur previous idl connect param now timestamp param con connect valid configur return con throw sqlexcept valid error happen pool connect borrow connect ( long now , pool connect con ) throw sqlexcept { we have connect , let set up flag see we need nullifi boolean set null = fals ; try { con . lock ( ) ; ( con . releas ( ) ) { return null ; } ( con . discard ( ) con . initi ( ) ) { attempt connect con . connect ( ) ; } ( ( con . discard ( ) ) con . valid ( pool connect . valid borrow ) ) { set timestamp con . set timestamp ( now ) ; ( get pool properti ( ) . log abandon ( ) ) { set stack trace thi pool con . set stack trace ( get thread dump ( ) ) ; } ( busi . offer ( con ) ) { log . debug ( connect doesn t fit busi arrai , connect traceabl . ) ; } return con ; } connect shouldn t have poll again . try { con . reconnect ( ) ; ( con . valid ( pool connect . valid init ) ) { set timestamp con . set timestamp ( now ) ; ( get pool properti ( ) . log abandon ( ) ) { set stack trace thi pool con . set stack trace ( get thread dump ( ) ) ; } ( busi . offer ( con ) ) { log . debug ( connect doesn t fit busi arrai , connect traceabl . ) ; } return con ; } els { valid fail . releas ( con ) ; set null = true ; throw new sqlexcept ( fail valid newli establish connect . ) ; } } catch ( except x ) { releas ( con ) ; set null = true ; ( x instanceof sqlexcept ) { throw ( sqlexcept ) x ; } els { sqlexcept ex = new sqlexcept ( x . get messag ( ) ) ; ex . init caus ( x ) ; throw ex ; } } } final { con . unlock ( ) ; ( set null ) { con = null ; } } }	protect creat jdbc connect tri connect databas . param now timestamp when thi wa call param us argument us return pool connect ha been connect throw sqlexcept pool connect creat connect ( long now , pool connect us ) throw sqlexcept { connect where avail we ll creat pool connect con = creat ( ) ; boolean error = fals ; try { connect valid connect con . lock ( ) ; con . connect ( ) ; ( con . valid ( pool connect . valid init ) ) { need lock new , content con . set timestamp ( now ) ; ( get pool properti ( ) . log abandon ( ) ) { con . set stack trace ( get thread dump ( ) ) ; } ( busi . offer ( con ) ) { log . debug ( connect doesn t fit busi arrai , connect traceabl . ) ; } return con ; } els { valid fail , make sure we disconnect clean up error = true ; } end } catch ( except e ) { error = true ; ( log . debug enabl ( ) ) log . debug ( unabl creat new jdbc connect . , e ) ; ( e instanceof sqlexcept ) { throw ( sqlexcept ) e ; } els { sqlexcept ex = new sqlexcept ( e . get messag ( ) ) ; ex . init caus ( e ) ; throw ex ; } } final { con can never null here ( error ) { releas ( con ) ; } con . unlock ( ) ; } catch return null ; }	protect void connect us data sourc ( ) throw sqlexcept { ( pool properti . get data sourc ( ) instanceof javax . sql . xadata sourc ) { javax . sql . xadata sourc xd = ( javax . sql . xadata sourc ) pool properti . get data sourc ( ) ; ( pool properti . get usernam ( ) = null pool properti . get password ( ) = null ) { xa connect = xd . get xaconnect ( pool properti . get usernam ( ) , pool properti . get password ( ) ) ; connect = xa connect . get connect ( ) ; } els { xa connect = xd . get xaconnect ( ) ; connect = xa connect . get connect ( ) ; } } els ( pool properti . get data sourc ( ) instanceof javax . sql . data sourc ) { javax . sql . data sourc ds = ( javax . sql . data sourc ) pool properti . get data sourc ( ) ; ( pool properti . get usernam ( ) = null pool properti . get password ( ) = null ) { connect = ds . get connect ( pool properti . get usernam ( ) , pool properti . get password ( ) ) ; } els { connect = ds . get connect ( ) ; } } els ( pool properti . get data sourc ( ) instanceof javax . sql . connect pool data sourc ) { javax . sql . connect pool data sourc ds = ( javax . sql . connect pool data sourc ) pool properti . get data sourc ( ) ; ( pool properti . get usernam ( ) = null pool properti . get password ( ) = null ) { connect = ds . get pool connect ( pool properti . get usernam ( ) , pool properti . get password ( ) ) . get connect ( ) ; } els { connect = ds . get pool connect ( ) . get connect ( ) ; } } els { throw new sqlexcept ( data sourc unknown class : ( pool properti . get data sourc ( ) = null pool properti . get data sourc ( ) . get class ( ) : null ) ) ; } }	protect void connect us driver ( ) throw sqlexcept { java . sql . driver driver = null ; try { driver = ( java . sql . driver ) class . name ( pool properti . get driver class name ( ) , true , pool connect . class . get class loader ( ) ) . new instanc ( ) ; } catch ( java . lang . except cn ) { ( log . debug enabl ( ) ) { log . debug ( unabl instanti jdbc driver . , cn ) ; } sqlexcept ex = new sqlexcept ( cn . get messag ( ) ) ; ex . init caus ( cn ) ; throw ex ; } string driver url = pool properti . get url ( ) ; string usr = pool properti . get usernam ( ) ; string pwd = pool properti . get password ( ) ; ( usr = null ) { pool properti . get db properti ( ) . set properti ( user , usr ) ; } ( pwd = null ) { pool properti . get db properti ( ) . set properti ( password , pwd ) ; } try { connect = driver . connect ( driver url , pool properti . get db properti ( ) ) ; } catch ( except x ) { ( log . debug enabl ( ) ) { log . debug ( unabl connect databas . , x ) ; } ( parent . jmx pool = null ) { parent . jmx pool . notifi ( org . apach . tomcat . jdbc . pool . jmx . connect pool . notifi connect , connect pool . get stack trace ( x ) ) ; } ( x instanceof sqlexcept ) { throw ( sqlexcept ) x ; } els { sqlexcept ex = new sqlexcept ( x . get messag ( ) ) ; ex . init caus ( x ) ; throw ex ; } } ( connect = = null ) { throw new sqlexcept ( driver : driver return null url : driver url ) ; } }	protect initi connect pool call from constructor param properti pool properti properti us initi pool throw sqlexcept initi fail void init ( pool configur properti ) throw sqlexcept { pool properti = properti ; make space 10 extra case we flow over bit busi = new arrai block queue pool connect ( properti . get max activ ( ) , fals ) ; make space 10 extra case we flow over bit ( properti . fair queue ( ) ) { idl = new fair block queue pool connect ( ) ; idl = new multi lock fair block queue pool connect ( ) ; } els { idl = new arrai block queue pool connect ( properti . get max activ ( ) , properti . fair queue ( ) ) ; } evictor thread suppos run , start now ( properti . pool sweeper enabl ( ) ) { pool cleaner = new pool cleaner ( pool cleaner : properti . get name ( ) , thi , properti . get time between evict run milli ( ) ) ; pool cleaner . start ( ) ; } make sure pool properli configur ( properti . get max activ ( ) properti . get initi size ( ) ) { log . warn ( initi size larger than max activ , set initi size : properti . get max activ ( ) ) ; properti . set initi size ( properti . get max activ ( ) ) ; } ( properti . get min idl ( ) properti . get max activ ( ) ) { log . warn ( min idl larger than max activ , set min idl : properti . get max activ ( ) ) ; properti . set min idl ( properti . get max activ ( ) ) ; } ( properti . get max idl ( ) properti . get max activ ( ) ) { log . warn ( max idl larger than max activ , set max idl : properti . get max activ ( ) ) ; properti . set max idl ( properti . get max activ ( ) ) ; } ( properti . get max idl ( ) properti . get min idl ( ) ) { log . warn ( max idl smaller than min idl , set max idl : properti . get min idl ( ) ) ; properti . set max idl ( properti . get min idl ( ) ) ; } creat jmx mbean ( thi . get pool properti ( ) . jmx enabl ( ) ) creat mbean ( ) ; pars creat initi set interceptor . let them know pool ha start . interceptor get ani connect . pool properti . interceptor definit proxi = get pool properti ( ) . get jdbc interceptor arrai ( ) ; ( int i = 0 ; i proxi . length ; i ) { try { ( log . debug enabl ( ) ) { log . debug ( creat interceptor instanc class : proxi i . get interceptor class ( ) ) ; } proxi i . get interceptor class ( ) . new instanc ( ) . pool start ( thi ) ; } catch ( except x ) { log . error ( unabl inform interceptor pool start . , x ) ; ( jmx pool = null ) jmx pool . notifi ( org . apach . tomcat . jdbc . pool . jmx . connect pool . notifi init , get stack trace ( x ) ) ; close ( true ) ; sqlexcept ex = new sqlexcept ( ) ; ex . init caus ( x ) ; throw ex ; } } initi pool initi set member pool connect initi pool = new pool connect pool properti . get initi size ( ) ; try { ( int i = 0 ; i initi pool . length ; i ) { don t wait , should content initi pool i = thi . borrow connect ( 0 ) ; } } catch ( sqlexcept x ) { ( jmx pool = null ) jmx pool . notifi ( org . apach . tomcat . jdbc . pool . jmx . connect pool . notifi init , get stack trace ( x ) ) ; close ( true ) ; throw x ; } final { return member idl pool ( int i = 0 ; i initi pool . length ; i ) { ( initi pool i = null ) { try { thi . return connect ( initi pool i ) ; } catch ( except x ) { noop } } end } } catch close = fals ; }	protect thread safe wai releas connect param con pool connect void releas ( pool connect con ) { ( con = = null ) return ; try { con . lock ( ) ; ( con . releas ( ) ) { counter onli decrement onc size . add get ( 1 ) ; con . set handler ( null ) ; } } final { con . unlock ( ) ; } notifi ( waitcount . get ( ) 0 ) { idl . offer ( new pool connect ( pool properti , thi ) ) ; } }	public connect connect ( string url , properti info ) throw sqlexcept { connect count . add get ( 1 ) ; return new org . apach . tomcat . jdbc . test . driver . connect ( ) ; }	public { inherit doc } connect get ( long timeout , time unit unit ) throw interrupt except , execut except , timeout except { pool connect pc = pc futur . get ( timeout , unit ) ; ( pc = null ) { ( result = null ) return result ; ( configur . compar set ( fals , true ) ) { try { pc = borrow connect ( system . current time milli ( ) , pc ) ; result = connect pool . thi . setup connect ( pc ) ; } catch ( sqlexcept x ) { caus = x ; } final { latch . count down ( ) ; } } els { we reach here , anoth thread configur actual connect thi shouldn t block long latch . await ( timeout , unit ) ; } ( result = = null ) throw new execut except ( caus ) ; return result ; } els { return null ; } }	public borrow connect from pool . connect avail ( idl queue ) pool ha reach { link pool properti max activ max activ } connect connect return immedi . connect avail , pool attempt fetch connect { link pool properti max wait max wait } millisecond . return connect java . sql . connect javax . sql . pool connect reflect proxi , wrap underli object . throw sqlexcept wait time out failur occur creat connect connect get connect ( ) throw sqlexcept { check out connect pool connect con = borrow connect ( 1 ) ; return setup connect ( con ) ; }	public { link javax . sql . data sourc get connect ( ) } connect get connect ( string usernam , string password ) throw sqlexcept { return get connect ( ) ; }	public { inherit doc } string get data sourc jndi ( ) { return get pool properti ( ) . get data sourc jndi ( ) ; }	public { inherit doc } string get data sourc jndi ( ) { return get pool properti ( ) . get data sourc jndi ( ) ; }	public static pool configur pars pool properti ( properti properti ) throw ioexcept { pool configur pool properti = new pool properti ( ) ; string valu = null ; valu = properti . get properti ( prop defaultautocommit ) ; ( valu = null ) { pool properti . set default auto commit ( boolean . valu ( valu ) ) ; } valu = properti . get properti ( prop defaultreadonli ) ; ( valu = null ) { pool properti . set default read onli ( boolean . valu ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { int level = unknown transactionisol ; ( none . equal ignor case ( valu ) ) { level = connect . transact none ; } els ( read commit . equal ignor case ( valu ) ) { level = connect . transact read commit ; } els ( read uncommit . equal ignor case ( valu ) ) { level = connect . transact read uncommit ; } els ( repeat read . equal ignor case ( valu ) ) { level = connect . transact repeat read ; } els ( serializ . equal ignor case ( valu ) ) { level = connect . transact serializ ; } els { try { level = integ . pars int ( valu ) ; } catch ( number format except e ) { system . err . println ( could pars default transact isol : valu ) ; system . err . println ( warn : default transact isol set ) ; system . err . println ( us default valu databas driver ) ; level = unknown transactionisol ; } } pool properti . set default transact isol ( level ) ; } valu = properti . get properti ( prop defaultcatalog ) ; ( valu = null ) { pool properti . set default catalog ( valu ) ; } valu = properti . get properti ( prop driverclassnam ) ; ( valu = null ) { pool properti . set driver class name ( valu ) ; } valu = properti . get properti ( prop maxact ) ; ( valu = null ) { pool properti . set max activ ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop maxidl ) ; ( valu = null ) { pool properti . set max idl ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop minidl ) ; ( valu = null ) { pool properti . set min idl ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop initials ) ; ( valu = null ) { pool properti . set initi size ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop maxwait ) ; ( valu = null ) { pool properti . set max wait ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop testonborrow ) ; ( valu = null ) { pool properti . set test borrow ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop testonreturn ) ; ( valu = null ) { pool properti . set test return ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop testonconnect ) ; ( valu = null ) { pool properti . set test connect ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set time between evict run milli ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set num test per evict run ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set min evict idl time milli ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop testwhileidl ) ; ( valu = null ) { pool properti . set test while idl ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop password ) ; ( valu = null ) { pool properti . set password ( valu ) ; } valu = properti . get properti ( prop url ) ; ( valu = null ) { pool properti . set url ( valu ) ; } valu = properti . get properti ( prop usernam ) ; ( valu = null ) { pool properti . set usernam ( valu ) ; } valu = properti . get properti ( prop validationqueri ) ; ( valu = null ) { pool properti . set valid queri ( valu ) ; } valu = properti . get properti ( prop valid class name ) ; ( valu = null ) { pool properti . set valid class name ( valu ) ; } valu = properti . get properti ( prop validationinterv ) ; ( valu = null ) { pool properti . set valid interv ( long . pars long ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set access underli connect allow ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop removeabandon ) ; ( valu = null ) { pool properti . set remov abandon ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set remov abandon timeout ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop logabandon ) ; ( valu = null ) { pool properti . set log abandon ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop poolpreparedstat ) ; ( valu = null ) { log . warn ( prop poolpreparedstat valid set , have effect . ) ; } valu = properti . get properti ( prop maxopenpreparedstat ) ; ( valu = null ) { log . warn ( prop maxopenpreparedstat valid set , have effect . ) ; } valu = properti . get properti ( prop connectionproperti ) ; ( valu = null ) { properti p = get properti ( valu ) ; pool properti . set db properti ( p ) ; } els { pool properti . set db properti ( new properti ( ) ) ; } ( pool properti . get usernam ( ) = null ) { pool properti . get db properti ( ) . set properti ( user , pool properti . get usernam ( ) ) ; } ( pool properti . get password ( ) = null ) { pool properti . get db properti ( ) . set properti ( password , pool properti . get password ( ) ) ; } valu = properti . get properti ( prop initsql ) ; ( valu = null ) { pool properti . set init sql ( valu ) ; } valu = properti . get properti ( prop interceptor ) ; ( valu = null ) { pool properti . set jdbc interceptor ( valu ) ; } valu = properti . get properti ( prop jmx enabl ) ; ( valu = null ) { pool properti . set jmx enabl ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop fair queue ) ; ( valu = null ) { pool properti . set fair queue ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop us equal ) ; ( valu = null ) { pool properti . set us equal ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( object name ) ; ( valu = null ) { pool properti . set name ( object name . quot ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set abandon when percentag full ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop maxag ) ; ( valu = null ) { pool properti . set max ag ( long . pars long ( valu ) ) ; } valu = properti . get properti ( prop us con lock ) ; ( valu = null ) { pool properti . set us lock ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop datasourc ) ; ( valu = null ) { thi should never happen throw new illeg argument except ( can t set data sourc properti string , thi must javax . sql . data sourc object . ) ; } valu = properti . get properti ( prop datasourc jndi ) ; ( valu = null ) { pool properti . set data sourc jndi ( valu ) ; } valu = properti . get properti ( prop suspect timeout ) ; ( valu = null ) { pool properti . set suspect timeout ( integ . pars int ( valu ) ) ; } return pool properti ; }	public static properti get properti ( string prop text , properti prop ) { ( prop = = null ) prop = new properti ( ) ; ( prop text = null ) { try { prop . load ( new byte arrai input stream ( prop text . replac ( ; , n ) . get byte ( ) ) ) ; } catch ( ioexcept x ) { throw new runtim except ( x ) ; } } return prop ; }
param name param manag return todo overrid public string get manag name ( string name , manag manag ) { string cluster name = name ; ( cluster name = = null ) cluster name = manag . get contain ( ) . get name ( ) ; ( get contain ( ) instanceof engin ) { contain context = manag . get contain ( ) ; ( context = null context instanceof context ) { contain host = ( ( context ) context ) . get parent ( ) ; ( host = null host instanceof host cluster name = null ( cluster name . index ( ) = 0 ) ) cluster name = host . get name ( ) cluster name ; } } return cluster name ; }
privat gener begin static portion servlet . void gener preambl ( node . node page ) throw jasper except { string servlet packag name = ctxt . get servlet packag name ( ) ; string servlet class name = ctxt . get servlet class name ( ) ; string servic method name = constant . servic method name ; first packag name : gen preambl packag ( servlet packag name ) ; gener import gen preambl import ( ) ; gener class declar out . printin ( public final class ) ; out . print ( servlet class name ) ; out . print ( extend ) ; out . println ( page info . get extend ( ) ) ; out . printin ( implement org . apach . jasper . runtim . jsp sourc depend ) ; ( page info . thread safe ( ) ) { out . println ( , ) ; out . printin ( singl thread model ) ; } out . println ( { ) ; out . push indent ( ) ; class bodi begin here gener declar ( page ) ; static initi here gen preambl static initi ( ) ; class variabl declar gen preambl class variabl declar ( ) ; constructor gener constructor ( class name ) ; method here gen preambl method ( ) ; now servic method out . printin ( public void ) ; out . print ( servic method name ) ; out . println ( ( http servlet request request , http servlet respons respons ) ) ; out . println ( throw java . io . ioexcept , servlet except { ) ; out . push indent ( ) ; out . println ( ) ; local variabl declar out . printil ( page context page context = null ; ) ; ( page info . session ( ) ) out . printil ( http session session = null ; ) ; ( page info . error page ( ) ) { out . printil ( throwabl except = org . apach . jasper . runtim . jsp runtim librari . get throwabl ( request ) ; ) ; out . printil ( ( except = null ) { ) ; out . push indent ( ) ; out . printil ( respons . set statu ( http servlet respons . sc intern server error ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; } out . printil ( servlet context applic = null ; ) ; out . printil ( servlet config config = null ; ) ; out . printil ( jsp writer out = null ; ) ; out . printil ( object page = thi ; ) ; out . printil ( jsp writer jspx out = null ; ) ; out . printil ( page context jspx page context = null ; ) ; out . println ( ) ; declar temporari script var ( page ) ; out . println ( ) ; out . printil ( try { ) ; out . push indent ( ) ; out . printin ( respons . set content type ( ) ; out . print ( quot ( page info . get content type ( ) ) ) ; out . println ( ) ; ) ; ( ctxt . get option ( ) . xpower ( ) ) { out . printil ( respons . add header ( x power , jsp 2 . 1 ) ; ) ; } out . printil ( page context = jspx factori . get page context ( thi , request , respons , ) ; out . printin ( t t t ) ; out . print ( quot ( page info . get error page ( ) ) ) ; out . print ( , page info . session ( ) ) ; out . print ( , page info . get buffer ( ) ) ; out . print ( , page info . auto flush ( ) ) ; out . println ( ) ; ) ; out . printil ( jspx page context = page context ; ) ; out . printil ( applic = page context . get servlet context ( ) ; ) ; out . printil ( config = page context . get servlet config ( ) ; ) ; ( page info . session ( ) ) out . printil ( session = page context . get session ( ) ; ) ; out . printil ( out = page context . get out ( ) ; ) ; out . printil ( jspx out = out ; ) ; out . println ( ) ; }
public creat sax except which also understand about locat digest file where except occur return new except saxexcept creat saxexcept ( string messag , except e ) { ( ( e = null ) ( e instanceof invoc target except ) ) { throwabl t = ( ( invoc target except ) e ) . get target except ( ) ; ( ( t = null ) ( t instanceof except ) ) { e = ( except ) t ; } } ( locat = null ) { string error = error ( locat . get line number ( ) , locat . get column number ( ) : messag ; ( e = null ) { return new saxpars except ( error , locat , e ) ; } els { return new saxpars except ( error , locat ) ; } } log . error ( locat ) ; ( e = null ) { return new saxexcept ( messag , e ) ; } els { return new saxexcept ( messag ) ; } }	process begin thi element . param namespac namespac uri match element , empti string parser namespac awar element ha namespac param name local name parser namespac awar , just element name otherwis param attribut attribut list thi element overrid public void begin ( string namespac , string name , attribut attribut ) throw except { identifi name class instanti string real class name = class name ; ( attribut name = null ) { string valu = attribut . get valu ( attribut name ) ; ( valu = null ) { real class name = valu ; } } ( digest . log . debug enabl ( ) ) { digest . log . debug ( object creat rule { digest . match } new real class name ) ; } instanti new object push context stack class clazz = digest . get class loader ( ) . load class ( real class name ) ; object instanc = clazz . new instanc ( ) ; digest . push ( instanc ) ; }	public start new server instanc . void load ( ) { long t1 = system . nano time ( ) ; init dir ( ) ; befor digest mai need init name ( ) ; creat execut our digest digest digest = creat start digest ( ) ; input sourc input sourc = null ; input stream input stream = null ; file file = null ; try { file = config file ( ) ; input stream = new file input stream ( file ) ; input sourc = new input sourc ( file : file . get absolut path ( ) ) ; } catch ( except e ) { ignor } ( input stream = = null ) { try { input stream = get class ( ) . get class loader ( ) . get resourc stream ( get config file ( ) ) ; input sourc = new input sourc ( get class ( ) . get class loader ( ) . get resourc ( get config file ( ) ) . string ( ) ) ; } catch ( except e ) { ignor } } altern : don t bother xml , just creat manual . ( input stream = = null ) { try { input stream = get class ( ) . get class loader ( ) . get resourc stream ( server emb . xml ) ; input sourc = new input sourc ( get class ( ) . get class loader ( ) . get resourc ( server emb . xml ) . string ( ) ) ; } catch ( except e ) { ignor } } ( ( input stream = = null ) ( file = null ) ) { log . warn ( can t load server . xml from file . get absolut path ( ) ) ; ( file . exist ( ) file . can read ( ) ) { log . warn ( permiss incorrect , read permiss allow file . ) ; } return ; } try { input sourc . set byte stream ( input stream ) ; digest . push ( thi ) ; digest . pars ( input sourc ) ; input stream . close ( ) ; } catch ( except e ) { log . warn ( catalina . start us get config file ( ) : , e ) ; return ; } get server ( ) . set catalina ( thi ) ; stream redirect init stream ( ) ; start new server try { get server ( ) . init ( ) ; } catch ( lifecycl except e ) { ( boolean . get boolean ( org . apach . catalina . startup . exit init failur ) ) throw new java . lang . error ( e ) ; els log . error ( catalina . start , e ) ; } long t2 = system . nano time ( ) ; ( log . info enabl ( ) ) log . info ( initi process ( ( t2 t1 ) 1000000 ) ms ) ; }
public regist authent princip authent type our request , current session ( ) , our singl sign valv , . set appropri cooki return . param request servlet request we ar process param respons servlet respons we ar gener param princip authent princip regist param auth type authent type regist param usernam usernam us authent ( ani ) param password password us authent ( ani ) void regist ( request request , http servlet respons respons , princip princip , string auth type , string usernam , string password ) { ( log . debug enabl ( ) ) log . debug ( authent princip . get name ( ) type auth type ) ; cach authent inform our request request . set auth type ( auth type ) ; request . set user princip ( princip ) ; session session = request . get session intern ( fals ) ; ( session = null chang session id authent ) { manag manag = request . get context ( ) . get manag ( ) ; manag . chang session id ( session ) ; request . chang session id ( session . get id ( ) ) ; } cach authent inform our session , ani ( cach ) { ( session = null ) { session . set auth type ( auth type ) ; session . set princip ( princip ) ; ( usernam = null ) session . set note ( constant . sess usernam note , usernam ) ; els session . remov note ( constant . sess usernam note ) ; ( password = null ) session . set note ( constant . sess password note , password ) ; els session . remov note ( constant . sess password note ) ; } } construct cooki return client ( sso = = null ) return ; onli creat new sso entri sso did alreadi set note exist entri ( would do subsequ request digest ssl authent context ) string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( sso id = = null ) { construct cooki return client sso id = session id gener . gener session id ( ) ; cooki cooki = new cooki ( constant . singl sign cooki , sso id ) ; cooki . set max ag ( 1 ) ; cooki . set path ( ) ; bugzilla 41217 cooki . set secur ( request . secur ( ) ) ; bugzilla 34724 string sso domain = sso . get cooki domain ( ) ; ( sso domain = null ) { cooki . set domain ( sso domain ) ; } configur http onli sso cooki us same rule session cooki ( request . get servlet context ( ) . get session cooki config ( ) . http onli ( ) request . get context ( ) . get us http onli ( ) ) { cooki . set http onli ( true ) ; } respons . add cooki ( cooki ) ; regist thi princip our sso valv sso . regist ( sso id , princip , auth type , usernam , password ) ; request . set note ( constant . req ssoid note , sso id ) ; } els { ( princip = = null ) { regist programmat logout sso . deregist ( sso id ) ; return ; } els { updat sso session latest authent data sso . updat ( sso id , princip , auth type , usernam , password ) ; } } sso entri never clear we don t associ session ( session = = null ) session = request . get session intern ( true ) ; sso . associ ( sso id , session ) ; }
public write messag file . ( msg . get messag number ( ) = = msg . get total nr msg ( ) ) output stream close after write . param msg file messag messag contain data written throw illeg argument except factori open read close throw ioexcept file write error occur return return true file complet outputstream close , fals otherwis . boolean write messag ( file messag msg ) throw illeg argument except , ioexcept { ( open write ) throw new illeg argument except ( can t write messag , thi factori read . ) ; ( log . debug enabl ( ) ) log . debug ( messag msg data msg . get data ( ) data length msg . get data length ( ) out out ) ; ( msg . get messag number ( ) = last messag process . get ( ) ) { duplic messag alreadi process log . warn ( receiv messag again sender act timeout too short path : msg . get context path ( ) war : msg . get file name ( ) data : msg . get data ( ) data length : msg . get data length ( ) ) ; return fals ; } file messag previou = msg buffer . put ( long . valu ( msg . get messag number ( ) ) , msg ) ; ( previou = null ) { duplic messag yet process log . warn ( receiv messag again sender act timeout too short path : msg . get context path ( ) war : msg . get file name ( ) data : msg . get data ( ) data length : msg . get data length ( ) ) ; return fals ; } file messag next = null ; synchron ( thi ) { ( write ) { next = msg buffer . get ( long . valu ( last messag process . get ( ) 1 ) ) ; ( next = null ) { write = true ; } els { return fals ; } } els { return fals ; } } while ( next = null ) { out . write ( next . get data ( ) , 0 , next . get data length ( ) ) ; last messag process . increment get ( ) ; out . flush ( ) ; ( next . get messag number ( ) = = next . get total nr msg ( ) ) { out . close ( ) ; cleanup ( ) ; return true ; } synchron ( thi ) { next = msg buffer . get ( long . valu ( last messag process . get ( ) 1 ) ) ; ( next = = null ) { write = fals ; } } } return fals ; }	public static byte get hex ( int index ) { return hex index ; }	public dump content messag , prefix given string . void dump ( string msg ) { ( log . debug enabl ( ) ) { log . debug ( msg : buf po ( len 4 ) ) ; } int max = po ; ( len 4 po ) max = len 4 ; ( max 1000 ) max = 1000 ; ( log . debug enabl ( ) ) { ( int j = 0 ; j max ; j = 16 ) { log . debug ( hex line ( buf , j , len ) ) ; } } }
privat static get saxpars . param valid indic whether request saxpars should valid param jsp doc parser jsp document parser return saxpars saxpars get saxpars ( boolean valid , jsp document parser jsp doc parser ) throw except { saxpars factori factori = saxpars factori . new instanc ( ) ; factori . set namespac awar ( true ) ; preserv xmln attribut factori . set featur ( http : xml . org sax featur namespac prefix , true ) ; factori . set valid ( valid ) ; factori . set featur ( http : xml . org sax featur valid , valid ) ; configur parser saxpars sax parser = factori . new saxpars ( ) ; xmlreader xml reader = sax parser . get xmlreader ( ) ; xml reader . set properti ( lexic handler properti , jsp doc parser ) ; xml reader . set error handler ( jsp doc parser ) ; return sax parser ; }	overrid public void set root caus ( throwabl e ) { noop }	see org . xml . sax . ext . lexic handler . overrid public void start dtd ( string name , string public id , string system id ) throw saxexcept { ( valid ) { fatal error ( enabl dtd valid except ) ; } dtd = true ; }
overrid public long get creation time ( ) { return 0 ; }	return time when thi session wa creat , millisecond sinc midnight , januari 1 , 1970 gmt . except illeg state except thi method call invalid session overrid public long get creation time ( ) { ( valid intern ( ) ) throw new illeg state except ( sm . get string ( standard session . get creation time . ) ) ; return ( thi . creation time ) ; }	remov thi session from activ session thi manag . param session session remov param updat should expir statist updat overrid public void remov ( session session , boolean updat ) { manag becaus persist updat expir stat ( updat ) { long time now = system . current time milli ( ) ; int time aliv = ( int ) ( ( time now session . get creation time ( ) ) 1000 ) ; updat session max aliv time ( time aliv ) ; expir session . increment get ( ) ; session time time = new session time ( time now , time aliv ) ; synchron ( session expir time ) { session expir time . add ( time ) ; session expir time . poll ( ) ; } } ( session . get id intern ( ) = null ) { session . remov ( session . get id intern ( ) ) ; } }
overrid public class get type ( elcontext context , object base , object properti ) throw null pointer except , properti found except , elexcept { context . set properti resolv ( fals ) ; int sz = thi . size ; class type ; ( int i = 0 ; i sz ; i ) { type = thi . resolv i . get type ( context , base , properti ) ; ( context . properti resolv ( ) ) { return type ; } } return null ; }
overrid protect void init intern ( ) throw lifecycl except { super . init intern ( ) ; initi adapt adapt = new coyot adapt ( thi ) ; protocol handler . set adapt ( adapt ) ; protocol handler . set domain ( get domain ( ) ) ; try { protocol handler . init ( ) ; } catch ( except e ) { throw new lifecycl except ( sm . get string ( coyot connector . protocol handler initi fail , e ) ) ; } onam protocol handler = regist ( protocol handler , creat object name kei properti ( protocol handler ) ) ; initi mapper listen mapper listen . init ( ) ; }	protect pars request paramet . void pars paramet ( ) { paramet pars = true ; paramet paramet = coyot request . get paramet ( ) ; get charact encod ( ) mai have been overridden search hidden form field contain request encod string enc = get charact encod ( ) ; boolean us bodi encod uri = connector . get us bodi encod uri ( ) ; ( enc = null ) { paramet . set encod ( enc ) ; ( us bodi encod uri ) { paramet . set queri string encod ( enc ) ; } } els { paramet . set encod ( org . apach . coyot . constant . default charact encod ) ; ( us bodi encod uri ) { paramet . set queri string encod ( org . apach . coyot . constant . default charact encod ) ; } } paramet . handl queri paramet ( ) ; ( us input stream us reader ) return ; ( get method ( ) . equal ignor case ( post ) ) return ; string content type = get content type ( ) ; ( content type = = null ) content type = ; int semicolon = content type . index ( ; ) ; ( semicolon = 0 ) { content type = content type . substr ( 0 , semicolon ) . trim ( ) ; } els { content type = content type . trim ( ) ; } ( multipart form data . equal ( content type ) ) { pars part ( ) ; return ; } ( ( applic x www form urlencod . equal ( content type ) ) ) return ; int len = get content length ( ) ; ( len 0 ) { int max post size = connector . get max post size ( ) ; ( ( max post size 0 ) ( len max post size ) ) { ( context . get logger ( ) . debug enabl ( ) ) { context . get logger ( ) . debug ( sm . get string ( coyot request . post too larg ) ) ; } return ; } byte form data = null ; ( len cach post len ) { ( post data = = null ) post data = new byte cach post len ; form data = post data ; } els { form data = new byte len ; } try { ( read post bodi ( form data , len ) = len ) { return ; } } catch ( ioexcept e ) { client disconnect ( context . get logger ( ) . debug enabl ( ) ) { context . get logger ( ) . debug ( sm . get string ( coyot request . pars paramet ) , e ) ; } return ; } paramet . process paramet ( form data , 0 , len ) ; } els ( chunk . equal ignor case ( coyot request . get header ( transfer encod ) ) ) { byte form data = null ; try { form data = read chunk post bodi ( ) ; } catch ( ioexcept e ) { client disconnect ( context . get logger ( ) . debug enabl ( ) ) { context . get logger ( ) . debug ( sm . get string ( coyot request . pars paramet ) , e ) ; } return ; } ( form data = null ) { paramet . process paramet ( form data , 0 , form data . length ) ; } } }	public set maximum size post which save contain dure authent . param max save post size new maximum size byte post which save contain dure authent . void set max save post size ( int max save post size ) { thi . max save post size = max save post size ; set properti ( max save post size , string . valu ( max save post size ) ) ; }	public void test bug49424with chunk ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; context root = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; tomcat . add servlet ( root , bug37794 , new bug37794servlet ( ) ) ; root . add servlet map ( , bug37794 ) ; tomcat . start ( ) ; http urlconnect conn = get connect ( ) ; conn . set chunk stream mode ( 8 1024 ) ; input stream = conn . get input stream ( ) ; assert null ( ) ; }
stop nest compon ( { link connector } s { link engin } s ) implement requir { link org . apach . catalina . util . lifecycl base stop intern ( ) } . except lifecycl except thi compon detect fatal error need report overrid protect void stop intern ( ) throw lifecycl except { ( log . debug enabl ( ) ) log . debug ( stop embed server ) ; fire lifecycl event ( stop event , null ) ; set state ( lifecycl state . start ) ; stop our defin connector first ( int i = 0 ; i connector . length ; i ) { ( ( lifecycl ) connector i ) . stop ( ) ; } stop our defin engin second ( int i = 0 ; i engin . length ; i ) { engin i . stop ( ) ; } }
privat static get saxpars . param valid indic whether request saxpars should valid param jsp doc parser jsp document parser return saxpars saxpars get saxpars ( boolean valid , jsp document parser jsp doc parser ) throw except { saxpars factori factori = saxpars factori . new instanc ( ) ; factori . set namespac awar ( true ) ; preserv xmln attribut factori . set featur ( http : xml . org sax featur namespac prefix , true ) ; factori . set valid ( valid ) ; factori . set featur ( http : xml . org sax featur valid , valid ) ; configur parser saxpars sax parser = factori . new saxpars ( ) ; xmlreader xml reader = sax parser . get xmlreader ( ) ; xml reader . set properti ( lexic handler properti , jsp doc parser ) ; xml reader . set error handler ( jsp doc parser ) ; return sax parser ; }	overrid public string string ( ) { string builder buf = new string builder ( map entri kei : ) ; buf . append ( get kei ( ) ) . append ( ; ) ; buf . append ( valu : ) . append ( get valu ( ) ) . append ( ; ) ; buf . append ( primari : ) . append ( primari ( ) ) . append ( ; ) ; buf . append ( backup : ) . append ( backup ( ) ) . append ( ; ) ; buf . append ( proxi : ) . append ( proxi ( ) ) . append ( ; ) ; return buf . string ( ) ; }	public static executor servic new thread pool ( int min thread , int max thread , long max idl time , time unit unit , thread factori thread factori ) { task queue taskqueu = new task queue ( ) ; thread pool executor servic = new thread pool executor ( min thread , max thread , max idl time , unit , taskqueu , thread factori ) ; taskqueu . set parent ( servic ) ; return servic ; }	public static creat gui show . thread safeti , thi method should invok from event dispatch thread . simpl tabl demo creat show gui ( lazi replic map map , string titl ) { make sure we have nice window decor . jframe . set default look feel decor ( true ) ; creat set up window . jframe frame = new jframe ( simpl tabl demo titl ) ; frame . set default close oper ( jframe . exit close ) ; creat set up content pane . simpl tabl demo new content pane = new simpl tabl demo ( map ) ; content pane must opaqu new content pane . set opaqu ( true ) ; frame . set content pane ( new content pane ) ; displai window . frame . set size ( 450 , 250 ) ; new content pane . set size ( 450 , 300 ) ; frame . pack ( ) ; frame . set visibl ( true ) ; return new content pane ; }	overrid public void run ( ) { system . out . println ( shut down . . . ) ; creat exit thread forc shutdown jvm wont exit cleanli system exit exit = new system exit ( 5000 ) ; exit . set daemon ( true ) ; exit . start ( ) ; try { stop channel channel . stop ( channel . default ) ; } catch ( except x ) { x . print stack trace ( ) ; } system . out . println ( channel stop . ) ; }
thread . stop ( ) suppress warn ( deprec ) privat void clear refer thread ( ) { thread thread = get thread ( ) ; iter over set thread ( thread thread : thread ) { ( thread = null ) { class loader ccl = thread . get context class loader ( ) ; ( ccl = null ccl = = thi ) { don t warn about thi thread ( thread = = thread . current thread ( ) ) { continu ; } skip thread have alreadi di ( thread . aliv ( ) ) { continu ; } don t warn about jvm control thread thread group tg = thread . get thread group ( ) ; ( tg = null jvm thread group name . contain ( tg . get name ( ) ) ) { continu ; } timer thread can stop safe so treat separ ( thread . get class ( ) . get name ( ) . equal ( java . util . timer thread ) clear refer stop timer thread ) { clear refer stop timer thread ( thread ) ; continu ; } ( request thread ( thread ) ) { log . error ( sm . get string ( webapp class loader . warn request thread , context name , thread . get name ( ) ) ) ; } els { log . error ( sm . get string ( webapp class loader . warn thread , context name , thread . get name ( ) ) ) ; } configur do so ( clear refer stop thread ) { continu ; } shut down executor try { field target field = thread . get class ( ) . get declar field ( target ) ; target field . set access ( true ) ; object target = target field . get ( thread ) ; ( target = null target . get class ( ) . get canon name ( ) . equal ( java . util . concurr . thread pool executor . worker ) ) { field executor field = target . get class ( ) . get declar field ( thi 0 ) ; executor field . set access ( true ) ; object executor = executor field . get ( target ) ; ( executor instanceof thread pool executor ) { ( ( thread pool executor ) executor ) . shutdown now ( ) ; } } } catch ( secur except e ) { log . warn ( sm . get string ( webapp class loader . stop thread fail , thread . get name ( ) , context name ) , e ) ; } catch ( field except e ) { log . warn ( sm . get string ( webapp class loader . stop thread fail , thread . get name ( ) , context name ) , e ) ; } catch ( illeg argument except e ) { log . warn ( sm . get string ( webapp class loader . stop thread fail , thread . get name ( ) , context name ) , e ) ; } catch ( illeg access except e ) { log . warn ( sm . get string ( webapp class loader . stop thread fail , thread . get name ( ) , context name ) , e ) ; } thi method deprec good reason . thi veri riski code onli option thi point . veri good reason app do thi clean up themselv . thread . stop ( ) ; } } } }	privat thread get thread ( ) { get current thread group thread group tg = thread . current thread ( ) . get thread group ( ) ; find root thread group while ( tg . get parent ( ) = null ) { tg = tg . get parent ( ) ; } int thread count guess = tg . activ count ( ) 50 ; thread thread = new thread thread count guess ; int thread count actual = tg . enumer ( thread ) ; make sure we don t miss ani thread while ( thread count actual = = thread count guess ) { thread count guess = 2 ; thread = new thread thread count guess ; note tg . enumer ( thread ) silent ignor ani thread can t fit arrai thread count actual = tg . enumer ( thread ) ; } return thread ; }
public int get packet size ( ) { return packet size ; }	public void set so linger ( int so linger ) { endpoint . set so linger ( so linger ) ; }
protect void timeout ( int kei count , boolean ha event ) { long now = system . current time milli ( ) ; we can check timeout avoid gap ( ( ( kei count 0 ha event ) ( now next expir ) ) ( close ) ) { return ; } log purpos onli long prev exp = next expir ; next expir = now socket properti . get timeout interv ( ) ; timeout set select kei kei = selector . kei ( ) ; int keycount = 0 ; ( iter select kei iter = kei . iter ( ) ; iter . ha next ( ) ; ) { select kei kei = iter . next ( ) ; keycount ; try { kei attach ka = ( kei attach ) kei . attach ( ) ; ( ka = = null ) { we don t support ani kei without attach cancel kei ( kei , socket statu . error , fals ) ; } els ( ka . get error ( ) ) { todo thi yet us cancel kei ( kei , socket statu . error , true ) ; } els ( ka . get comet ( ) ka . get comet notifi ( ) ) { ka . set comet notifi ( fals ) ; avoid multipl call , thi get reregist after invoc reg ( kei , ka , 0 ) ; ( process socket ( ka . get channel ( ) , socket statu . open callback ) ) process socket ( ka . get channel ( ) , socket statu . disconnect ) ; ( process socket ( ka . get channel ( ) , socket statu . open , true ) ) process socket ( ka . get channel ( ) , socket statu . disconnect , true ) ; } els ( ( ka . interest op ( ) select kei . op read ) = = select kei . op read ( ka . interest op ( ) select kei . op write ) = = select kei . op write ) { onli timeout socket we ar wait read from long delta = now ka . get last access ( ) ; long timeout = ( ka . get timeout ( ) = = 1 ) ( ( long ) socket properti . get so timeout ( ) ) : ( ka . get timeout ( ) ) ; boolean timedout = delta timeout ; ( close ) { kei . interest op ( 0 ) ; avoid duplic stop call ka . interest op ( 0 ) ; process kei ( kei , ka ) ; } els ( timedout ) { kei . interest op ( 0 ) ; avoid duplic timeout call ka . interest op ( 0 ) ; cancel kei ( kei , socket statu . timeout , true ) ; } els { long next time = now ( timeout delta ) ; next expir = ( next time next expir ) next time : next expir ; } } els ( ka . async ( ) ) { long delta = now ka . get last access ( ) ; long timeout = ( ka . get timeout ( ) = = 1 ) ( ( long ) socket properti . get so timeout ( ) ) : ( ka . get timeout ( ) ) ; boolean timedout = delta timeout ; ( timedout ) { process socket ( ka . get channel ( ) , socket statu . timeout , true ) ; } } end } catch ( cancel kei except ckx ) { cancel kei ( kei , socket statu . error , fals ) ; } } ( log . trace enabl ( ) ) log . trace ( timeout complet : kei process = keycount ; now = now ; next expir = prev exp ; kei count = kei count ; ha event = ha event ; eval = ( ( now prev exp ) ( kei count 0 ha event ) ( close ) ) ) ; }	overrid public socket state event ( nio channel socket , socket statu statu ) { http11nio processor processor = connect . get ( socket ) ; nio endpoint . kei attach att = ( nio endpoint . kei attach ) socket . get attach ( fals ) ; longer check timeout att . set async ( fals ) ; socket state state = socket state . close ; ( processor = null ) { ( log . debug enabl ( ) ) log . debug ( http11nio processor . error = processor . error ) ; call appropri event try { ( processor . comet ) { state = processor . event ( statu ) ; } els { state = processor . async dispatch ( statu ) ; } } catch ( java . net . socket except e ) { socket except ar normal http11nio protocol . log . debug ( sm . get string ( http11protocol . proto . socketexcept . debug ) , e ) ; } catch ( java . io . ioexcept e ) { ioexcept ar normal http11nio protocol . log . debug ( sm . get string ( http11protocol . proto . ioexcept . debug ) , e ) ; } abov . catch ( throwabl e ) { except util . handl throwabl ( e ) ; ani other except error odd . here we log error level , so show up even less than verbos log . http11nio protocol . log . error ( sm . get string ( http11protocol . proto . error ) , e ) ; } final { ( processor . async ( ) ) { state = processor . async post process ( ) ; } ( state = socket state . long state = socket state . async end ) { releas ( socket ) ; ( state = = socket state . open ) { socket . get poller ( ) . add ( socket ) ; } } els ( state = = socket state . async end ) { further work requir } els ( state = = socket state . long ) { re enabl timeout att . set async ( true ) ; } els { ( log . debug enabl ( ) ) log . debug ( keep processor processor ) ; add correct poller event here base comet stuff socket . get poller ( ) . add ( socket , att . get comet op ( ) ) ; } } } return state ; }
public static displai given size byte , either kb mb . param mb true displai megabyt , fals kilobyt string format size ( object obj , boolean mb ) { long byte = 1l ; ( obj instanceof long ) { byte = ( ( long ) obj ) . long valu ( ) ; } els ( obj instanceof integ ) { byte = ( ( integ ) obj ) . int valu ( ) ; } ( mb ) { long mbyte = byte ( 1024 1024 ) ; long rest = ( ( byte ( mbyte ( 1024 1024 ) ) ) 100 ) ( 1024 1024 ) ; return ( mbyte . ( ( rest 10 ) 0 : ) rest mb ) ; } els { return ( ( byte 1024 ) kb ) ; } }	public static string second time string ( long second ) { string builder buff = new string builder ( 9 ) ; long rest = second ; long hour = rest 3600 ; rest = rest 3600 ; long minut = rest 60 ; rest = rest 60 ; long second = rest ; ( hour 10 ) { buff . append ( 0 ) ; } buff . append ( hour ) ; buff . append ( : ) ; ( minut 10 ) { buff . append ( 0 ) ; } buff . append ( minut ) ; buff . append ( : ) ; ( second 10 ) { buff . append ( 0 ) ; } buff . append ( second ) ; return buff . string ( ) ; }
privat void do test timeout ( boolean complet timeout ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; creat folder trigger redirect file foo = new file ( doc base , async ) ; ( foo . exist ( ) foo . mkdir ( ) ) { fail ( unabl creat async directori doc base ) ; } context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; timeout servlet timeout = new timeout servlet ( complet timeout ) ; wrapper wrapper = tomcat . add servlet ( ctx , time , timeout ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( async , time ) ; tomcat . start ( ) ; byte chunk re = get url ( http : localhost : get port ( ) async ) ; string builder expect = new string builder ( ) ; expect . append ( timeout servlet get timeout ) ; ( complet timeout ) { expect . append ( error ) ; } expect . append ( complet ) ; assert equal ( expect . string ( ) , re . string ( ) ) ; }	privat void do test dispatch error ( int iter , boolean us thread , boolean complet error ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; dispatch servlet dispatch = new dispatch servlet ( true , complet error ) ; wrapper wrapper = tomcat . add servlet ( ctx , dispatch , dispatch ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( stage1 , dispatch ) ; error servlet error = new error servlet ( ) ; tomcat . add servlet ( ctx , error , error ) ; ctx . add servlet map ( stage2 , error ) ; tomcat . start ( ) ; string builder url = new string builder ( 48 ) ; url . append ( http : localhost : ) ; url . append ( get port ( ) ) ; url . append ( stage1 iter = ) ; url . append ( iter ) ; ( us thread ) { url . append ( us thread = y ) ; } byte chunk re = get url ( url . string ( ) ) ; string builder expect = new string builder ( ) ; int loop = iter ; while ( loop 0 ) { expect . append ( dispatch servlet get ) ; ( loop = iter ) { expect . append ( start async ) ; } loop ; } expect . append ( error servlet get error complet ) ; assert equal ( expect . string ( ) , re . string ( ) ) ; }	privat void do test timeout ( boolean complet timeout ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; creat folder trigger redirect file foo = new file ( doc base , async ) ; ( foo . exist ( ) foo . mkdir ( ) ) { fail ( unabl creat async directori doc base ) ; } context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; timeout servlet timeout = new timeout servlet ( complet timeout ) ; wrapper wrapper = tomcat . add servlet ( ctx , time , timeout ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( async , time ) ; tomcat . start ( ) ; byte chunk re = get url ( http : localhost : get port ( ) async ) ; string builder expect = new string builder ( ) ; expect . append ( timeout servlet get timeout ) ; ( complet timeout ) { expect . append ( error ) ; } expect . append ( complet ) ; assert equal ( expect . string ( ) , re . string ( ) ) ; }	public void run ( ) { ( first ) { ctxt . dispatch ( stage1 ) ; } els { ctxt . dispatch ( stage2 ) ; } }	public synchron boolean async dispatch ( ) { boolean do dispatch = fals ; ( state = = async state . start ) { state = async state . must dispatch ; } els ( state = = async state . start ) { state = async state . dispatch ; do dispatch = true ; } els { throw new illeg state except ( sm . get string ( async state machin . invalid async state , dispatch async ( ) , state ) ) ; } return do dispatch ; }	overrid public void timeout ( async event event ) throw ioexcept { servlet respons resp = event . get async context ( ) . get respons ( ) ; resp . get writer ( ) . write ( timeout ) ; resp . flush buffer ( ) ; ( complet timeout ) { event . get async context ( ) . complet ( ) ; } }	public void test listen ( ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; track servlet track = new track servlet ( ) ; wrapper wrapper = tomcat . add servlet ( ctx , track , track ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( stage1 , track ) ; timeout servlet timeout = new timeout servlet ( true ) ; wrapper wrapper2 = tomcat . add servlet ( ctx , timeout , timeout ) ; wrapper2 . set async support ( true ) ; ctx . add servlet map ( stage2 , timeout ) ; tomcat . start ( ) ; string builder url = new string builder ( 48 ) ; url . append ( http : localhost : ) ; url . append ( get port ( ) ) ; url . append ( stage1 ) ; byte chunk re = get url ( url . string ( ) ) ; assert equal ( dispatch servlet get dispatch servlet get start async timeout servlet get start async timeout complet , re . string ( ) ) ; }	void test listen ( ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp file doc base = new file ( system . get properti ( java . io . tmpdir ) ) ; context ctx = tomcat . add context ( , doc base . get absolut path ( ) ) ; track servlet track = new track servlet ( ) ; wrapper wrapper = tomcat . add servlet ( ctx , track , track ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( stage1 , track ) ; timeout servlet timeout = new timeout servlet ( true ) ; wrapper wrapper2 = tomcat . add servlet ( ctx , timeout , timeout ) ; wrapper2 . set async support ( true ) ; ctx . add servlet map ( stage2 , timeout ) ; tomcat . start ( ) ; string builder url = new string builder ( 48 ) ; url . append ( http : localhost : ) ; url . append ( get port ( ) ) ; url . append ( stage1 ) ; byte chunk re = get url ( url . string ( ) ) ; assert equal ( dispatch servlet get dispatch servlet get start async timeout servlet get start async timeout complet , re . string ( ) ) ; }	void test timeout listen complet ( ) throw except { do test timeout ( true ) ; }	public void test timeout listen complet ( ) throw except { do test timeout ( fals ) ; }
privat string get web modul kei properti ( ) { string builder kei properti = new string builder ( , web modul = ) ; string host name = get parent ( ) . get parent ( ) . get name ( ) ; ( host name = = null ) { kei properti . append ( default ) ; } els { kei properti . append ( host name ) ; } string context name = ( ( context ) get parent ( ) ) . get name ( ) ; ( context name . start ( ) ) { kei properti . append ( ) ; } kei properti . append ( context name ) ; standard context ctx = null ; ( parent instanceof standard context ) { ctx = ( standard context ) get parent ( ) ; } kei properti . append ( , j2eeapplic = ) ; ( ctx = = null ) { kei properti . append ( none ) ; } els { kei properti . append ( ctx . get j2eeapplic ( ) ) ; } kei properti . append ( , j2eeserv = ) ; ( ctx = = null ) { kei properti . append ( none ) ; } els { kei properti . append ( ctx . get j2eeserv ( ) ) ; } return kei properti . string ( ) ; }

public valu express set variabl ( string variabl , valu express express ) { ( var = = null ) var = new hash map string , valu express ( ) ; return var . put ( variabl , express ) ; }	overrid public class get type ( elcontext context , object base , object properti ) throw null pointer except , properti found except , elexcept { ( context = = null ) { throw new null pointer except ( ) ; } ( base = = null ) { context . set properti resolv ( true ) ; ( properti = null ) { try { object obj = thi . variabl resolv . resolv variabl ( properti . string ( ) ) ; return ( obj = null ) obj . get class ( ) : null ; } catch ( javax . servlet . jsp . el . elexcept e ) { throw new elexcept ( e . get messag ( ) , e . get caus ( ) ) ; } } } ( context . properti resolv ( ) ) { return get default resolv ( ) . get type ( context , base , properti ) ; } return null ; }	overrid public valu express set variabl ( string variabl , valu express express ) { ( var = = null ) var = new hash map string , valu express ( ) ; return var . put ( variabl , express ) ; }	overrid public class get common properti type ( elcontext context , object base ) { ( base = = null ) { return string . class ; } return get default resolv ( ) . get common properti type ( context , base ) ; }	overrid public void set valu ( elcontext context , object base , object properti , object valu ) throw null pointer except , properti found except , properti writabl except , elexcept { ( context = = null ) { throw new null pointer except ( ) ; } ( base = = null ) { context . set properti resolv ( true ) ; throw new properti writabl except ( legaci variabl resolv wrap , writabl ) ; } ( context . properti resolv ( ) ) { get default resolv ( ) . set valu ( context , base , properti , valu ) ; } }
protect list session get session path ( string path , string manag sm client ) { ( ( path = = null ) ( path . start ( ) path . equal ( ) ) ) { throw new illeg argument except ( sm client . get string ( manag servlet . invalid path , request util . filter ( path ) ) ) ; } string search path = path ; ( path . equal ( ) ) search path = ; context ctxt = ( context ) host . find child ( search path ) ; ( null = = ctxt ) { throw new illeg argument except ( sm client . get string ( manag servlet . context , request util . filter ( path ) ) ) ; } manag manag = ctxt . get manag ( ) ; list session session = new arrai list session ( ) ; session . add all ( arrai . list ( manag . find session ( ) ) ) ; ( manag instanceof backup manag show proxi session ) { add dummi proxi session set string session id = ( ( backup manag ) manag ) . get session id full ( ) ; remov activ ( primari backup ) session id from full list ( session session : session ) { session id . remov ( session . get id ( ) ) ; } left just proxi session add them ( string session id : session id ) { session . add ( new dummi proxi session ( session id ) ) ; } } return session ; }	overrid public cluster manag clone from templat ( ) { backup manag result = new backup manag ( ) ; result . m expir session shutdown = m expir session shutdown ; result . name = clone from name ; result . cluster = cluster ; result . notifi listen replic = notifi listen replic ; result . map send option = map send option ; result . max activ session = max activ session ; return result ; }	public int get activ session full ( ) { lazi replic map map = ( lazi replic map ) session ; return map . size full ( ) ; }	public render html list current activ context our virtual host , memori server statu inform . param request request param respons respons param messag messag displai void list ( http servlet request request , http servlet respons respons , string messag , string manag sm client ) throw ioexcept { ( debug = 1 ) log ( list : list context virtual host host . get name ( ) ) ; print writer writer = respons . get writer ( ) ; html header section writer . print ( constant . html header section ) ; bodi header section object arg = new object 2 ; arg 0 = request . get context path ( ) ; arg 1 = sm client . get string ( html manag servlet . titl ) ; writer . print ( messag format . format ( constant . bodi header section , arg ) ) ; messag section arg = new object 3 ; arg 0 = sm client . get string ( html manag servlet . messag label ) ; ( messag = = null messag . length ( ) = = 0 ) { arg 1 = ok ; } els { arg 1 = request util . filter ( messag ) ; } writer . print ( messag format . format ( constant . messag section , arg ) ) ; manag section arg = new object 9 ; arg 0 = sm client . get string ( html manag servlet . manag ) ; arg 1 = respons . encod url ( request . get context path ( ) html list ) ; arg 2 = sm client . get string ( html manag servlet . list ) ; arg 3 = respons . encod url ( request . get context path ( ) sm client . get string ( html manag servlet . help html manag file ) ) ; arg 4 = sm client . get string ( html manag servlet . help html manag ) ; arg 5 = respons . encod url ( request . get context path ( ) sm client . get string ( html manag servlet . help manag file ) ) ; arg 6 = sm client . get string ( html manag servlet . help manag ) ; arg 7 = respons . encod url ( request . get context path ( ) statu ) ; arg 8 = sm client . get string ( statu servlet . titl ) ; writer . print ( messag format . format ( constant . manag section , arg ) ) ; app header section arg = new object 6 ; arg 0 = sm client . get string ( html manag servlet . app titl ) ; arg 1 = sm client . get string ( html manag servlet . app path ) ; arg 2 = sm client . get string ( html manag servlet . app name ) ; arg 3 = sm client . get string ( html manag servlet . app avail ) ; arg 4 = sm client . get string ( html manag servlet . app session ) ; arg 5 = sm client . get string ( html manag servlet . app task ) ; writer . print ( messag format . format ( app header section , arg ) ) ; app row section creat sort map deploi applic context path . contain children = host . find children ( ) ; string context path = new string children . length ; ( int i = 0 ; i children . length ; i ) context path i = children i . get name ( ) ; tree map string , string sort context path map = new tree map string , string ( ) ; ( int i = 0 ; i context path . length ; i ) { string displai path = context path i ; sort context path map . put ( displai path , context path i ) ; } string app start = sm client . get string ( html manag servlet . app start ) ; string app stop = sm client . get string ( html manag servlet . app stop ) ; string app reload = sm client . get string ( html manag servlet . app reload ) ; string app undeploi = sm client . get string ( html manag servlet . app undeploi ) ; string app expir = sm client . get string ( html manag servlet . app expir ) ; iter map . entri string , string >> iter = sort context path map . entri set ( ) . iter ( ) ; boolean highlight = true ; boolean deploi = true ; string highlight color = null ; while ( iter . ha next ( ) ) { bugzilla 34818 , altern row color highlight = highlight ; ( highlight ) { highlight color = c3f3c3 ; } els { highlight color = ffffff ; } map . entri string , string entri = iter . next ( ) ; string displai path = entri . get kei ( ) ; string context path = entri . get valu ( ) ; context ctxt = ( context ) host . find child ( context path ) ; ( displai path . equal ( ) ) { displai path = ; } ( ctxt = null ) { try { deploi = deploi ( context path ) ; } catch ( except e ) { assum fals failur safeti deploi = fals ; } arg = new object 7 ; arg 0 = url encod . encod ( displai path ) ; arg 1 = displai path ; arg 2 = ctxt . get displai name ( ) ; ( arg 2 = = null ) { arg 2 = nbsp ; ; } arg 3 = new boolean ( ctxt . get avail ( ) ) ; arg 4 = respons . encod url ( request . get context path ( ) html session path = url encod . encod ( displai path ) ) ; manag manag = ctxt . get manag ( ) ; ( manag instanceof backup manag show proxi session ) { arg 5 = new integ ( ( ( backup manag ) manag ) . get activ session full ( ) ) ; } els ( ctxt . get manag ( ) = null ) { arg 5 = new integ ( manag . get activ session ( ) ) ; } els { arg 5 = new integ ( 0 ) ; } arg 6 = highlight color ; writer . print ( messag format . format ( app row detail section , arg ) ) ; arg = new object 14 ; arg 0 = respons . encod url ( request . get context path ( ) html start path = url encod . encod ( displai path ) ) ; arg 1 = app start ; arg 2 = respons . encod url ( request . get context path ( ) html stop path = url encod . encod ( displai path ) ) ; arg 3 = app stop ; arg 4 = respons . encod url ( request . get context path ( ) html reload path = url encod . encod ( displai path ) ) ; arg 5 = app reload ; arg 6 = respons . encod url ( request . get context path ( ) html undeploi path = url encod . encod ( displai path ) ) ; arg 7 = app undeploi ; arg 8 = respons . encod url ( request . get context path ( ) html expir path = url encod . encod ( displai path ) ) ; arg 9 = app expir ; arg 10 = sm client . get string ( html manag servlet . expir . explain ) ; ( manag = = null ) { arg 11 = sm client . get string ( html manag servlet . manag ) ; } els { arg 11 = new integ ( ctxt . get manag ( ) . get max inact interv ( ) 60 ) ; } arg 12 = sm client . get string ( html manag servlet . expir . unit ) ; arg 13 = highlight color ; ( ctxt . get name ( ) . equal ( thi . context . get name ( ) ) ) { writer . print ( messag format . format ( manag app row button section , arg ) ) ; } els ( ctxt . get avail ( ) deploi ) { writer . print ( messag format . format ( start deploi app row button section , arg ) ) ; } els ( ctxt . get avail ( ) deploi ) { writer . print ( messag format . format ( start nondeploi app row button section , arg ) ) ; } els ( ctxt . get avail ( ) deploi ) { writer . print ( messag format . format ( stop deploi app row button section , arg ) ) ; } els { writer . print ( messag format . format ( stop nondeploi app row button section , arg ) ) ; } } } deploi section arg = new object 7 ; arg 0 = sm client . get string ( html manag servlet . deploi titl ) ; arg 1 = sm client . get string ( html manag servlet . deploi server ) ; arg 2 = respons . encod url ( request . get context path ( ) html deploi ) ; arg 3 = sm client . get string ( html manag servlet . deploi path ) ; arg 4 = sm client . get string ( html manag servlet . deploi config ) ; arg 5 = sm client . get string ( html manag servlet . deploi war ) ; arg 6 = sm client . get string ( html manag servlet . deploi button ) ; writer . print ( messag format . format ( deploi section , arg ) ) ; arg = new object 4 ; arg 0 = sm client . get string ( html manag servlet . deploi upload ) ; arg 1 = respons . encod url ( request . get context path ( ) html upload ) ; arg 2 = sm client . get string ( html manag servlet . deploi upload file ) ; arg 3 = sm client . get string ( html manag servlet . deploi button ) ; writer . print ( messag format . format ( upload section , arg ) ) ; diagnost section arg = new object 5 ; arg 0 = sm client . get string ( html manag servlet . diagnost titl ) ; arg 1 = sm client . get string ( html manag servlet . diagnost leak ) ; arg 2 = respons . encod url ( request . get context path ( ) html findleak ) ; arg 3 = sm client . get string ( html manag servlet . diagnost leak warn ) ; arg 4 = sm client . get string ( html manag servlet . diagnost leak button ) ; writer . print ( messag format . format ( diagnost section , arg ) ) ; server header section arg = new object 7 ; arg 0 = sm client . get string ( html manag servlet . server titl ) ; arg 1 = sm client . get string ( html manag servlet . server version ) ; arg 2 = sm client . get string ( html manag servlet . server jvmversion ) ; arg 3 = sm client . get string ( html manag servlet . server jvmvendor ) ; arg 4 = sm client . get string ( html manag servlet . server osnam ) ; arg 5 = sm client . get string ( html manag servlet . server osvers ) ; arg 6 = sm client . get string ( html manag servlet . server osarch ) ; writer . print ( messag format . format ( constant . server header section , arg ) ) ; server row section arg = new object 6 ; arg 0 = server info . get server info ( ) ; arg 1 = system . get properti ( java . runtim . version ) ; arg 2 = system . get properti ( java . vm . vendor ) ; arg 3 = system . get properti ( os . name ) ; arg 4 = system . get properti ( os . version ) ; arg 5 = system . get properti ( os . arch ) ; writer . print ( messag format . format ( constant . server row section , arg ) ) ; html tail section writer . print ( constant . html tail section ) ; finish up respons writer . flush ( ) ; writer . close ( ) ; }
protect retriev name object . param name name object look up param resolv link true , link resolv return object bound name except name except name except encount object lookup ( name name , boolean resolv link ) throw name except { remov empti part while ( ( name . empti ( ) ) ( name . get ( 0 ) . length ( ) = = 0 ) ) name = name . get suffix ( 1 ) ; ( name . empti ( ) ) { name empti , newli alloc name context return return new name context ( env , thi . name , bind ) ; } name entri entri = bind . get ( name . get ( 0 ) ) ; ( entri = = null ) { throw new name found except ( sm . get string ( name context . name bound , name . get ( 0 ) ) ) ; } ( name . size ( ) 1 ) { number subcontext . ( entri . type = name entri . context ) { throw new name except ( sm . get string ( name context . context expect ) ) ; } return ( ( context ) entri . valu ) . lookup ( name . get suffix ( 1 ) ) ; } els { ( ( resolv link ) ( entri . type = = name entri . link ref ) ) { string link = ( ( link ref ) entri . valu ) . get link name ( ) ; ( link . start ( . ) ) { link rel thi context return lookup ( link . substr ( 1 ) ) ; } els { return ( new initi context ( env ) ) . lookup ( link ) ; } } els ( entri . type = = name entri . refer ) { try { object obj = name manag . get object instanc ( entri . valu , name , thi , env ) ; boolean singleton = boolean . pars boolean ( ( string ) ( ( resourc ref ) entri . valu ) . get ( singleton ) . get content ( ) ) ; ( singleton ) { entri . type = name entri . entri ; entri . valu = obj ; } return obj ; } catch ( name except e ) { throw e ; } catch ( except e ) { log . warn ( sm . get string ( name context . fail resolv refer ) , e ) ; throw new name except ( e . get messag ( ) ) ; } } els { return entri . valu ; } } }
loop forev wait work do overrid public synchron void run ( ) { ( socket = = null ) return ; try { drain socket ( ) ; } catch ( except x ) { log . error ( unabl servic bio socket ) ; } final { try { socket . close ( ) ; } catch ( except e ) { ignor } try { reader . close ( ) ; } catch ( except e ) { ignor } reader = null ; socket = null ; } done , readi more , return pool ( get task pool ( ) = null ) get task pool ( ) . return worker ( thi ) ; }	public synchron void servic socket ( socket socket , object reader reader ) { thi . socket = socket ; thi . reader = reader ; awaken thread thi . notifi ( ) ; }	public void listen ( ) throw except { ( do listen ( ) ) { log . warn ( server socket alreadi start ) ; return ; } set listen ( true ) ; while ( do listen ( ) ) { socket socket = null ; ( get task pool ( ) . avail ( ) 1 ) { ( log . warn enabl ( ) ) log . warn ( all bio server replic thread ar busi , unabl handl more request until thread freed up . ) ; } bio replic task task = ( bio replic task ) get task pool ( ) . get rx task ( ) ; should never happen ( task = = null ) continu ; try { socket = server socket . accept ( ) ; } catch ( except x ) { ( do listen ( ) ) throw x ; } ( do listen ( ) ) { task . set do run ( fals ) ; task . servic socket ( null , null ) ; get executor ( ) . execut ( task ) ; regular shutdown break ; } ( socket = = null ) continu ; socket . set receiv buffer size ( get rx buf size ( ) ) ; socket . set send buffer size ( get tx buf size ( ) ) ; socket . set tcp delai ( get tcp delai ( ) ) ; socket . set keep aliv ( get so keep aliv ( ) ) ; socket . set oobinlin ( get oo binlin ( ) ) ; socket . set reus address ( get so reus address ( ) ) ; socket . set so linger ( get so linger ( ) , get so linger time ( ) ) ; socket . set traffic class ( get so traffic class ( ) ) ; socket . set so timeout ( get timeout ( ) ) ; object reader reader = new object reader ( socket ) ; task . servic socket ( socket , reader ) ; } while }
add map associ wrapper . param map new wrapper map overrid public void add map ( string map ) { synchron ( map ) { map . add ( map ) ; } fire contain event ( add map event , map ) ; }	add new welcom file set recogn thi context . param name new welcom file name overrid public void add welcom file ( string name ) { synchron ( welcom file lock ) { complet replac those from default conf web . xml file ( replac welcom file ) { fire contain event ( clear welcom file event , null ) ; welcom file = new string 0 ; set replac welcom file ( fals ) ; } string result = new string welcom file . length 1 ; ( int i = 0 ; i welcom file . length ; i ) result i = welcom file i ; result welcom file . length = name ; welcom file = result ; } post welcom file ( ) ; fire contain event ( add welcom file event , name ) ; }	remov map associ wrapper . param map pattern remov overrid public void remov map ( string map ) { synchron ( map ) { map . remov ( map ) ; } fire contain event ( remov map event , map ) ; }	remov specifi welcom file name from list recogn thi context . param name name welcom file remov overrid public void remov welcom file ( string name ) { synchron ( welcom file lock ) { make sure thi welcom file current present int n = 1 ; ( int i = 0 ; i welcom file . length ; i ) { ( welcom file i . equal ( name ) ) { n = i ; break ; } } ( n 0 ) return ; remov specifi constraint int j = 0 ; string result = new string welcom file . length 1 ; ( int i = 0 ; i welcom file . length ; i ) { ( i = n ) result j = welcom file i ; } welcom file = result ; } inform interest listen post welcom file ( ) ; fire contain event ( remov welcom file event , name ) ; }
overrid public void lifecycl event ( lifecycl event event ) { initialis class when tomcat start ( lifecycl . befor init event . equal ( event . get type ( ) ) ) { issu . ( app context protect ) { imag io . get cach directori ( ) ; } sever compon end up call : sun . misc . gc . request latenc ( long ) those librari compon known trigger memori leak due eventu call request latenc ( long ) ar : javax . manag . remot . rmi . rmiconnector server . start ( ) ( gc daemon protect ) { try { class clazz = class . name ( sun . misc . gc ) ; method method = clazz . get declar method ( request latenc , new class { long . class } ) ; method . invok ( null , long . valu ( 3600000 ) ) ; } catch ( class found except e ) { ( system . get properti ( java . vendor ) . start ( sun ) ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } els { log . debug ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } } catch ( secur except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } catch ( method except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } catch ( illeg argument except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } catch ( illeg access except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } catch ( invoc target except e ) { log . error ( sm . get string ( jre leak listen . gc daemon fail ) , e ) ; } } when servlet open connect us url us sun . net . www . http . http client which keep static refer keep aliv cach which load us web applic class loader . ( keep aliv protect ) { try { class . name ( sun . net . www . http . http client ) ; } catch ( class found except e ) { ( system . get properti ( java . vendor ) . start ( sun ) ) { log . error ( sm . get string ( jre leak listen . keep aliv fail ) , e ) ; } els { log . debug ( sm . get string ( jre leak listen . keep aliv fail ) , e ) ; } } } call get polici retain static refer context class loader . ( secur polici protect ) { try { polici . get polici ( ) ; class polici class = class . name ( javax . secur . auth . polici ) ; method method = polici class . get method ( get polici ) ; method . invok ( null ) ; } catch ( class found except e ) { ignor . class deprec . } catch ( secur except e ) { ignor . don t need call get polici ( ) success , just need trigger static initi . } catch ( method except e ) { log . warn ( sm . get string ( jre leak listen . auth polici fail ) , e ) ; } catch ( illeg argument except e ) { log . warn ( sm . get string ( jre leak listen . auth polici fail ) , e ) ; } catch ( illeg access except e ) { log . warn ( sm . get string ( jre leak listen . auth polici fail ) , e ) ; } catch ( invoc target except e ) { log . warn ( sm . get string ( jre leak listen . auth polici fail ) , e ) ; } } creat messag digest dure web applic startup initi java cryptographi architectur . under certain condit thi start token poller thread tccl equal web applic class loader . instead we initi jca right now . ( token poller protect ) { java . secur . secur . get provid ( ) ; } set default url cach polici cach ( url cach protect ) { try { doesn t matter thi jar doesn t exist just long url well form url url = new url ( jar : file : dummi . jar ) ; urlconnect u conn = url . open connect ( ) ; u conn . set default us cach ( fals ) ; } catch ( malform urlexcept e ) { log . error ( sm . get string ( jre leak listen . jar url conn cach fail ) , e ) ; } catch ( ioexcept e ) { log . error ( sm . get string ( jre leak listen . jar url conn cach fail ) , e ) ; } } haven t got root what go thi leak web app first make call below web applic class loader pin memori . ( xml pars protect ) { document builder factori factori = document builder factori . new instanc ( ) ; try { factori . new document builder ( ) ; } catch ( parser configur except e ) { log . error ( sm . get string ( jre leak listen . xml pars fail ) , e ) ; } } } }
overrid public void messag receiv ( serializ msg , member sender ) { rpc messag rmsg = ( rpc messag ) msg ; rpc collector kei kei = new rpc collector kei ( rmsg . uuid ) ; ( rmsg . repli ) { rpc collector collector = respons map . get ( kei ) ; ( collector = = null ) { callback . left over ( rmsg . messag , sender ) ; } els { synchron ( collector ) { make sure hasn t been remov ( respons map . contain kei ( kei ) ) { ( ( rmsg instanceof rpc messag . rpc channel repli ) ) collector . destcnt ; els collector . add respons ( rmsg . messag , sender ) ; ( collector . complet ( ) ) collector . notifi all ( ) ; } els { ( ( rmsg instanceof rpc messag . rpc channel repli ) ) callback . left over ( rmsg . messag , sender ) ; } } synchron } end } els { serializ repli = callback . repli request ( rmsg . messag , sender ) ; rmsg . repli = true ; rmsg . messag = repli ; try { channel . send ( new member { sender } , rmsg , 0 ) ; } catch ( except x ) { log . error ( unabl send back repli rpc channel . , x ) ; } } end }	public void set rpc id ( byte rpc id ) { thi . rpc id = rpc id ; }
public call our background reaper thread check session save our store ar subject expir . so expir session remov from store . void process expir ( ) { string kei = null ; ( get state ( ) . avail ( ) ) { return ; } try { kei = kei ( ) ; } catch ( ioexcept e ) { manag . get contain ( ) . get logger ( ) . error ( error get kei , e ) ; return ; } ( manag . get contain ( ) . get logger ( ) . debug enabl ( ) ) { manag . get contain ( ) . get logger ( ) . debug ( get store name ( ) : process expir check number kei . length session ) ; } long time now = system . current time milli ( ) ; ( int i = 0 ; i kei . length ; i ) { try { standard session session = ( standard session ) load ( kei i ) ; ( session = = null ) { continu ; } int time idl = ( int ) ( ( time now session . get thi access time ( ) ) 1000l ) ; ( time idl session . get max inact interv ( ) ) { continu ; } ( manag . get contain ( ) . get logger ( ) . debug enabl ( ) ) { manag . get contain ( ) . get logger ( ) . debug ( get store name ( ) : process expir expir store session kei i ) ; } ( ( ( persist manag base ) manag ) . load ( kei i ) ) { recycl old backup session session . recycl ( ) ; } els { expir swap out session session . expir ( ) ; } remov ( kei i ) ; } catch ( except e ) { manag . get contain ( ) . get logger ( ) . error ( session : kei i ; , e ) ; try { remov ( kei i ) ; } catch ( ioexcept e2 ) { manag . get contain ( ) . get logger ( ) . error ( error remov kei , e2 ) ; } } } }
overrid public final synchron void destroi ( ) throw lifecycl except { ( lifecycl state . destroi . equal ( state ) ) { ( log . debug enabl ( ) ) { except e = new lifecycl except ( ) ; log . debug ( sm . get string ( lifecycl base . alreadi destroi , string ( ) ) , e ) ; } els ( log . info enabl ( ) ) { log . info ( sm . get string ( lifecycl base . alreadi destroi , string ( ) ) ) ; } return ; } ( state . equal ( lifecycl state . stop ) state . equal ( lifecycl state . fail ) state . equal ( lifecycl state . new ) ) { invalid transit ( lifecycl . destroi event ) ; } destroi intern ( ) ; set state ( lifecycl state . destroi ) ; }	primari entri point startup shutdown event . param event event ha occur overrid public void lifecycl event ( lifecycl event event ) { ( lifecycl . befor init event . equal ( event . get type ( ) ) ) { synchron ( lock ) { init ( ) ; ( apr avail ) { try { initi ssl ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . info ( sm . get string ( apr listen . ssl init ) ) ; } } } } els ( lifecycl . destroi event . equal ( event . get type ( ) ) ) { synchron ( lock ) { ( apr avail ) { return ; } try { termin apr ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . info ( sm . get string ( apr listen . apr destroi ) ) ; } } } }	process event associ context . param event lifecycl event ha occur overrid public void lifecycl event ( lifecycl event event ) { identifi context we ar associ try { context = ( context ) event . get lifecycl ( ) ; } catch ( class cast except e ) { log . error ( sm . get string ( context config . cce , event . get lifecycl ( ) ) , e ) ; return ; } process event ha occur ( event . get type ( ) . equal ( lifecycl . configur start event ) ) { configur start ( ) ; } els ( event . get type ( ) . equal ( lifecycl . befor start event ) ) { befor start ( ) ; } els ( event . get type ( ) . equal ( lifecycl . after start event ) ) { restor doc base manag tool ( origin doc base = null ) { string doc base = context . get doc base ( ) ; context . set doc base ( origin doc base ) ; origin doc base = doc base ; } } els ( event . get type ( ) . equal ( lifecycl . configur stop event ) ) { ( origin doc base = null ) { string doc base = context . get doc base ( ) ; context . set doc base ( origin doc base ) ; origin doc base = doc base ; } configur stop ( ) ; } els ( event . get type ( ) . equal ( lifecycl . after init event ) ) { init ( ) ; } els ( event . get type ( ) . equal ( lifecycl . destroi event ) ) { destroi ( ) ; } }	remov exist child contain from associ thi parent contain . param child exist child contain remov overrid public void remov child ( contain child ) { ( child = = null ) { return ; } synchron ( children ) { ( children . get ( child . get name ( ) ) = = null ) return ; children . remov ( child . get name ( ) ) ; } try { ( child . get state ( ) . avail ( ) ) { child . stop ( ) ; } } catch ( lifecycl except e ) { log . error ( contain base . remov child : stop : , e ) ; } fire contain event ( remov child event , child ) ; set child s parent null prevent loop child . set parent ( null ) ; try { child . destroi ( ) ; } catch ( lifecycl except e ) { log . error ( contain base . remov child : destroi : , e ) ; } }
protect regist all cluster valv host engin throw except throw class found except void regist cluster valv ( ) throw except { ( contain = null ) { ( iter valv iter = valv . iter ( ) ; iter . ha next ( ) ; ) { cluster valv valv = ( cluster valv ) iter . next ( ) ; ( log . debug enabl ( ) ) log . debug ( invok add valv get contain ( ) class = valv . get class ( ) . get name ( ) ) ; ( valv = null ) { introspect util . call method n ( get contain ( ) , add valv , new object { valv } , new class { org . apach . catalina . valv . class } ) ; } valv . set cluster ( thi ) ; } } }	public return return manag . map string , cluster manag get manag ( ) { return manag ; }	protect unregist all cluster valv host engin throw except throw class found except void unregist cluster valv ( ) throw except { ( iter valv iter = valv . iter ( ) ; iter . ha next ( ) ; ) { cluster valv valv = ( cluster valv ) iter . next ( ) ; ( log . debug enabl ( ) ) log . debug ( invok remov valv get contain ( ) class = valv . get class ( ) . get name ( ) ) ; ( valv = null ) { introspect util . call method n ( get contain ( ) , remov valv , new object { valv } , new class { org . apach . catalina . valv . class } ) ; } valv . set cluster ( thi ) ; } }	public logger log get logger ( ) { return log ; }	public get manag see org . apach . catalina . ha . catalina cluster get manag ( java . lang . string ) manag get manag ( string name ) { return manag . get ( name ) ; }	public get all properti kei return iter over properti name . iter string get properti name ( ) { return properti . kei set ( ) . iter ( ) ; }	public return name cluster thi server current configur oper within . return name cluster associ thi server string get cluster name ( ) { ( cluster name = = null contain = null ) return contain . get name ( ) ; return cluster name ; }	deprec us get manag templat ( ) . get class ( ) . get name ( ) instead . return string deprec public string get manag class name ( ) { return manag templat . get class ( ) . get name ( ) ; }	public param name param manag return todo string get manag name ( string name , manag manag ) { string cluster name = name ; ( cluster name = = null ) cluster name = manag . get contain ( ) . get name ( ) ; ( get contain ( ) instanceof engin ) { contain context = manag . get contain ( ) ; ( context = null context instanceof context ) { contain host = ( ( context ) context ) . get parent ( ) ; ( host = null host instanceof host cluster name = null ( cluster name . index ( ) = 0 ) ) cluster name = host . get name ( ) cluster name ; } } return cluster name ; }	return string render thi object . overrid public string string ( ) { string builder sb = new string builder ( thi . get class ( ) . get name ( ) ) ; sb . append ( ) ; ( contain = = null ) { sb . append ( contain null ) ; } els { sb . append ( contain . get name ( ) ) ; } sb . append ( ) ; return sb . string ( ) ; }	public notifi all listen from receiv new messag cluster messag emit failur event lifecylc listen param msg receiv messag boolean accept ( serializ msg , member sender ) { return ( msg instanceof cluster messag ) ; }	public member get member ( ) { return channel . get member ( ) ; }	public set config attribut reflect propag all manag param name param valu boolean set properti ( string name , object valu ) { ( log . trace enabl ( ) ) log . trace ( sm . get string ( simpl tcp cluster . set properti , name , valu , properti . get ( name ) ) ) ; properti . put ( name , valu ) ; us dynam wai set properti nice , secur risk expos through jmx . thi wai you can sit try guess properti name , we onli allow explicit properti name log . warn ( dynam set properti ( name , valu ) ha been disabl , pleas us explicit properti element you ar try identifi ) ; return fals ; }	public jmx hack direct us jconsol param name param valu boolean set properti ( string name , string valu ) { return set properti ( name , ( object ) valu ) ; }	public int get channel send option ( ) { return channel send option ; }	public synchron creat new manag without add cluster ( come start manag ) param name context name thi manag see org . apach . catalina . cluster creat manag ( java . lang . string ) see delta manag start ( ) manag creat manag ( string name ) { ( log . debug enabl ( ) ) log . debug ( creat cluster manag context name us class get manag class name ( ) ) ; manag manag = null ; try { manag = manag templat . clone from templat ( ) ; ( ( cluster manag ) manag ) . set name ( name ) ; } catch ( except x ) { log . error ( unabl clone cluster manag , default org . apach . catalina . ha . session . delta manag , x ) ; manag = new org . apach . catalina . ha . session . delta manag ( ) ; } final { ( manag = null ( manag instanceof cluster manag ) ) ( ( cluster manag ) manag ) . set cluster ( thi ) ; } return manag ; }	public add cluster messag listen regist cluster thi listen . see org . apach . catalina . ha . catalina cluster add cluster listen ( org . apach . catalina . ha . cluster listen ) void add cluster listen ( cluster listen listen ) { ( listen = null cluster listen . contain ( listen ) ) { cluster listen . add ( listen ) ; listen . set cluster ( thi ) ; } }	public cluster listen find cluster listen ( ) { ( cluster listen . size ( ) 0 ) { cluster listen listen = new cluster listen cluster listen . size ( ) ; cluster listen . arrai ( listen ) ; return listen ; } els return new cluster listen 0 ; }	public execut period task , reload , etc . thi method invok insid classload context thi contain . unexpect throwabl caught log . see org . apach . catalina . ha . deploi . farm war deploy background process ( ) see org . apach . catalina . tribe . group . group channel heartbeat ( ) see org . apach . catalina . tribe . group . group channel . heartbeat thread run ( ) void background process ( ) { ( cluster deploy = null ) cluster deploy . background process ( ) ; send heartbeat through channel ( heartbeat background enabl ( ) channel = null ) channel . heartbeat ( ) ; }	new cluster member regist see org . apach . catalina . tribe . membership listen member ad ( org . apach . catalina . tribe . member ) void member ad ( member member ) { try { ha member = channel . ha member ( ) ; ( log . info enabl ( ) ) log . info ( replic member ad : member ) ; notifi our interest lifecycl listen fire lifecycl event ( befor memberregist event , member ) ; notifi our interest lifecycl listen fire lifecycl event ( after memberregist event , member ) ; } catch ( except x ) { log . error ( unabl connect replic system . , x ) ; } }	public cluster member gone see org . apach . catalina . tribe . membership listen member disappear ( org . apach . catalina . tribe . member ) void member disappear ( member member ) { try { ha member = channel . ha member ( ) ; ( log . info enabl ( ) ) log . info ( receiv member disappear : member ) ; notifi our interest lifecycl listen fire lifecycl event ( befor memberunregist event , member ) ; notifi our interest lifecycl listen fire lifecycl event ( after memberunregist event , member ) ; } catch ( except x ) { log . error ( unabl remov cluster node from replic system . , x ) ; } }	public void messag receiv ( cluster messag messag ) { ( log . debug enabl ( ) messag = null ) log . debug ( assum clock ar synch : replic messag . get uniqu id ( ) took = ( system . current time milli ( ) ( messag ) . get timestamp ( ) ) ms . ) ; invok all listen boolean accept = fals ; ( messag = null ) { ( iter cluster listen iter = cluster listen . iter ( ) ; iter . ha next ( ) ; ) { cluster listen listen = iter . next ( ) ; ( listen . accept ( messag ) ) { accept = true ; listen . messag receiv ( messag ) ; } } } ( accept log . debug enabl ( ) ) { ( notifi lifecycl listen failur ) { member dest = messag . get address ( ) ; notifi our interest lifecycl listen fire lifecycl event ( receiv messag failur event , new send messag data ( messag , dest , null ) ) ; } log . debug ( messag messag . string ( ) from type messag . get class ( ) . get name ( ) transfer listen regist ) ; } return ; }	public get current deploy org . apach . catalina . ha . cluster deploy get cluster deploy ( ) { return cluster deploy ; }	remov applic from cluster replic bu . see org . apach . catalina . cluster remov manag ( manag ) overrid public void remov manag ( manag manag ) { ( manag = null manag instanceof cluster manag ) { cluster manag cmgr = ( cluster manag ) manag ; notifi our interest lifecycl listen fire lifecycl event ( befor managerunregist event , manag ) ; manag . remov ( get manag name ( cmgr . get name ( ) , manag ) ) ; cmgr . set cluster ( null ) ; notifi our interest lifecycl listen fire lifecycl event ( after managerunregist event , manag ) ; } }	public send messag all cluster member param msg messag transfer see org . apach . catalina . ha . catalina cluster send ( org . apach . catalina . ha . cluster messag ) void send ( cluster messag msg ) { send ( msg , null ) ; }	public void set channel send option ( int channel send option ) { thi . channel send option = channel send option ; }	public set new deploy , must set befor cluster start void set cluster deploy ( org . apach . catalina . ha . cluster deploy cluster deploy ) { thi . cluster deploy = cluster deploy ; }	public set name cluster join , cluster thi name present creat . param cluster name clusternam join void set cluster name ( string cluster name ) { thi . cluster name = cluster name ; }	public set contain associ our cluster param contain contain us void set contain ( contain contain ) { contain old contain = thi . contain ; thi . contain = contain ; support . fire properti chang ( contain , old contain , thi . contain ) ; }	public enabl contain background thread call heartbeat channel param heartbeat background enabl heartbeat background enabl set void set heartbeat background enabl ( boolean heartbeat background enabl ) { thi . heartbeat background enabl = heartbeat background enabl ; }	deprec us nest lt ; manag gt ; element insid cluster config instead . param manag class name string deprec public void set manag class name ( string manag class name ) { log . warn ( set manag class name deprec , us nest manag element insid cluster element instead , thi request ignor . ) ; }	public see org . apach . catalina . cluster set protocol ( java . lang . string ) void set protocol ( string protocol ) { }
privat configur from code log manag code properti . void configur ( ) { timestamp ts = new timestamp ( system . current time milli ( ) ) ; string ts string = ts . string ( ) . substr ( 0 , 19 ) ; date = ts string . substr ( 0 , 10 ) ; allow class overrid string class name = thi . get class ( ) . get name ( ) ; class loader cl = thread . current thread ( ) . get context class loader ( ) ; retriev configur log file name ( directori = = null ) directori = get properti ( class name . directori , log ) ; ( prefix = = null ) prefix = get properti ( class name . prefix , juli . ) ; ( suffix = = null ) suffix = get properti ( class name . suffix , . log ) ; string s buffer size = get properti ( class name . buffer size , string . valu ( buffer size ) ) ; try { buffer size = integ . pars int ( s buffer size ) ; } catch ( number format except ignor ) { op } get encod log file string encod = get properti ( class name . encod , null ) ; ( encod = null encod . length ( ) 0 ) { try { set encod ( encod ) ; } catch ( unsupport encod except ex ) { ignor } } get log level handler set level ( level . pars ( get properti ( class name . level , level . all ) ) ) ; get filter configur string filter name = get properti ( class name . filter , null ) ; ( filter name = null ) { try { set filter ( ( filter ) cl . load class ( filter name ) . new instanc ( ) ) ; } catch ( except e ) { ignor } } set formatt string formatt name = get properti ( class name . formatt , null ) ; ( formatt name = null ) { try { set formatt ( ( formatt ) cl . load class ( formatt name ) . new instanc ( ) ) ; } catch ( except e ) { ignor } } els { set formatt ( new simpl formatt ( ) ) ; } set error manag set error manag ( new error manag ( ) ) ; }	protect void open writer ( ) { creat directori necessari file dir = new file ( directori ) ; dir . mkdir ( ) ; open current log file writer lock . write lock ( ) . lock ( ) ; try { string pathnam = dir . get absolut path ( ) file . separ prefix date suffix ; string encod = get encod ( ) ; file output stream fo = new file output stream ( pathnam , true ) ; output stream os = buffer size 0 new buffer output stream ( fo , buffer size ) : fo ; writer = new print writer ( ( encod = null ) new output stream writer ( os , encod ) : new output stream writer ( os ) , fals ) ; writer . write ( get formatt ( ) . get head ( thi ) ) ; } catch ( except e ) { report error ( null , e , error manag . open failur ) ; writer = null ; } final { writer lock . write lock ( ) . unlock ( ) ; } }	format publish tt log record tt . param record descript log event overrid public void publish ( log record record ) { ( loggabl ( record ) ) { return ; } construct timestamp we us , request timestamp ts = new timestamp ( system . current time milli ( ) ) ; string ts string = ts . string ( ) . substr ( 0 , 19 ) ; string ts date = ts string . substr ( 0 , 10 ) ; writer lock . read lock ( ) . lock ( ) ; date ha chang , switch log file ( date . equal ( ts date ) ) { updat write lock befor we switch writer lock . read lock ( ) . unlock ( ) ; writer lock . write lock ( ) . lock ( ) ; try { make sure anoth thread hasn t alreadi done thi ( date . equal ( ts date ) ) { close writer ( ) ; date = ts date ; open writer ( ) ; } down grade read lock . thi ensur writer remain valid until log messag written writer lock . read lock ( ) . lock ( ) ; } final { writer lock . write lock ( ) . unlock ( ) ; } } try { string result = null ; try { result = get formatt ( ) . format ( record ) ; } catch ( except e ) { report error ( null , e , error manag . format failur ) ; return ; } try { ( writer = null ) { writer . write ( result ) ; ( buffer size 0 ) { writer . flush ( ) ; } } els { report error ( file handler close yet initi , unabl log result , null , error manag . write failur ) ; } } catch ( except e ) { report error ( null , e , error manag . write failur ) ; return ; } } final { writer lock . read lock ( ) . unlock ( ) ; } }
privat protect method void find default host ( ) { engin engin = ( engin ) connector . get servic ( ) . get contain ( ) ; string default host = engin . get default host ( ) ; boolean found = fals ; ( default host = null default host . length ( ) 0 ) { contain contain = engin . find children ( ) ; ( contain contain : contain ) { host host = ( host ) contain ; ( default host . equal ignor case ( host . get name ( ) ) ) { found = true ; break ; } string alias = host . find alias ( ) ; ( string alia : alias ) { ( default host . equal ignor case ( alia ) ) { found = true ; break ; } } } } ( found ) { mapper . set default host name ( default host ) ; } els { log . warn ( sm . get string ( mapper listen . unknown default host , default host ) ) ; } }	privat regist context . void regist context ( context context ) { string context name = context . get name ( ) ; ( . equal ( context name ) ) { context name = ; } contain host = context . get parent ( ) ; javax . name . context resourc = context . get resourc ( ) ; string welcom file = context . find welcom file ( ) ; mapper . add context ( host . get name ( ) , host , context name , context , welcom file , resourc ) ; context . add contain listen ( thi ) ; ( contain contain : context . find children ( ) ) { regist wrapper ( ( wrapper ) contain ) ; } ( log . debug enabl ( ) ) { log . debug ( sm . get string ( mapper listen . regist context , context name ) ) ; } }	privat regist host . void regist host ( host host ) { string alias = host . find alias ( ) ; mapper . add host ( host . get name ( ) , alias , host ) ; host . add contain listen ( thi ) ; ( contain contain : host . find children ( ) ) { regist context ( ( context ) contain ) ; } ( log . debug enabl ( ) ) { log . debug ( sm . get string ( mapper listen . regist host , host . get name ( ) , domain ) ) ; } }	privat regist wrapper . void regist wrapper ( wrapper wrapper ) { string wrapper name = wrapper . get name ( ) ; string context name = wrapper . get parent ( ) . get name ( ) ; ( . equal ( context name ) ) { context name = ; } string host name = wrapper . get parent ( ) . get parent ( ) . get name ( ) ; string map = wrapper . find map ( ) ; ( string map : map ) { boolean jsp wild card = ( wrapper name . equal ( jsp ) map . end ( ) ) ; mapper . add wrapper ( host name , context name , map , wrapper , jsp wild card ) ; } wrapper . add contain listen ( thi ) ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( mapper listen . regist wrapper , wrapper name , context name ) ) ; } }	privat unregist context . void unregist context ( context context ) { don t un map context paus ( context . get paus ( ) ) { return ; } string context name = context . get name ( ) ; ( . equal ( context name ) ) { context name = ; } string host name = context . get parent ( ) . get name ( ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( mapper listen . unregist context , context name ) ) ; mapper . remov context ( host name , context name ) ; }	privat unregist host . void unregist host ( host host ) { string hostnam = host . get name ( ) ; mapper . remov host ( hostnam ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( mapper listen . unregist host , hostnam , domain ) ) ; }	privat unregist wrapper . void unregist wrapper ( wrapper wrapper ) { string context name = wrapper . get parent ( ) . get name ( ) ; ( . equal ( context name ) ) { context name = ; } string host name = wrapper . get parent ( ) . get parent ( ) . get name ( ) ; string map = wrapper . find map ( ) ; ( string map : map ) { mapper . remov wrapper ( host name , context name , map ) ; } }	public contain listen method void contain event ( contain event event ) { ( event . get type ( ) = = contain . add child event ) { contain child = ( contain ) event . get data ( ) ; child . add lifecycl listen ( thi ) ; child . add contain listen ( thi ) ; ( child instanceof host ) { regist host ( ( host ) child ) ; } els ( child instanceof context ) { regist context ( ( context ) child ) ; } els ( child instanceof wrapper ) { regist wrapper ( ( wrapper ) child ) ; } } els ( event . get type ( ) = = contain . remov child event ) { contain child = ( contain ) event . get data ( ) ; remov listen ( child ) ; ( child instanceof host ) { unregist host ( ( host ) child ) ; } els ( child instanceof context ) { unregist context ( ( context ) child ) ; } els ( child instanceof wrapper ) { unregist wrapper ( ( wrapper ) child ) ; } } els ( event . get type ( ) = = host . add alia event ) { handl dynam ad host alias mapper . add host alia ( ( ( host ) event . get sourc ( ) ) . get name ( ) , event . get data ( ) . string ( ) ) ; } els ( event . get type ( ) = = host . remov alia event ) { handl dynam remov host alias mapper . remov host alia ( event . get data ( ) . string ( ) ) ; } els ( event . get type ( ) = = wrapper . add map event ) { handl dynam ad wrapper wrapper wrapper = ( wrapper ) event . get sourc ( ) ; string context name = wrapper . get parent ( ) . get name ( ) ; ( . equal ( context name ) ) { context name = ; } string host name = wrapper . get parent ( ) . get parent ( ) . get name ( ) ; string map = ( string ) event . get data ( ) ; boolean jsp wild card = ( jsp . equal ( wrapper . get name ( ) ) map . end ( ) ) ; mapper . add wrapper ( host name , context name , map , wrapper , jsp wild card ) ; } els ( event . get type ( ) = = wrapper . remov map event ) { handl dynam remov wrapper wrapper wrapper = ( wrapper ) event . get sourc ( ) ; string context name = wrapper . get parent ( ) . get name ( ) ; ( . equal ( context name ) ) { context name = ; } string host name = wrapper . get parent ( ) . get parent ( ) . get name ( ) ; string map = ( string ) event . get data ( ) ; mapper . remov wrapper ( host name , context name , map ) ; } els ( event . get type ( ) = = context . add welcom file event ) { handl dynam ad welcom file context context = ( context ) event . get sourc ( ) ; string host name = context . get parent ( ) . get name ( ) ; string context name = context . get name ( ) ; ( . equal ( context name ) ) { context name = ; } string welcom file = ( string ) event . get data ( ) ; mapper . add welcom file ( host name , context name , welcom file ) ; } els ( event . get type ( ) = = context . remov welcom file event ) { handl dynam remov welcom file context context = ( context ) event . get sourc ( ) ; string host name = context . get parent ( ) . get name ( ) ; string context name = context . get name ( ) ; ( . equal ( context name ) ) { context name = ; } string welcom file = ( string ) event . get data ( ) ; mapper . remov welcom file ( host name , context name , welcom file ) ; } els ( event . get type ( ) = = context . clear welcom file event ) { handl dynam clear welcom file context context = ( context ) event . get sourc ( ) ; string host name = context . get parent ( ) . get name ( ) ; string context name = context . get name ( ) ; ( . equal ( context name ) ) { context name = ; } mapper . clear welcom file ( host name , context name ) ; } }	public clean up . void destroi ( ) { op }	public initi associ mapper . void init ( ) { find ani compon have alreadi been initi sinc mbean listen won t notifi those compon have alreadi regist mbean find default host ( ) ; engin engin = ( engin ) connector . get servic ( ) . get contain ( ) ; engin . add contain listen ( thi ) ; contain con host = engin . find children ( ) ; ( contain con host : con host ) { host host = ( host ) con host ; ( lifecycl state . new . equal ( host . get state ( ) ) ) { host . add lifecycl listen ( thi ) ; regist host regist context wrapper regist host ( host ) ; } } }	overrid public void lifecycl event ( lifecycl event event ) { ( event . get type ( ) = = lifecycl . after start event ) { object obj = event . get sourc ( ) ; ( obj instanceof wrapper ) { regist wrapper ( ( wrapper ) obj ) ; } els ( obj instanceof context ) { regist context ( ( context ) obj ) ; } els ( obj instanceof host ) { regist host ( ( host ) obj ) ; } } els ( event . get type ( ) = = lifecycl . befor stop event ) { object obj = event . get sourc ( ) ; ( obj instanceof wrapper ) { unregist wrapper ( ( wrapper ) obj ) ; } els ( obj instanceof context ) { unregist context ( ( context ) obj ) ; } els ( obj instanceof host ) { unregist host ( ( host ) obj ) ; } } }	public remov lifecycl event listen from thi compon . param type class name listen remov . note all listen have given class name remov . void remov life cycl listen ( string type ) throw mbean except { contain base contain = null ; try { contain = ( contain base ) get manag resourc ( ) ; } catch ( instanc found except e ) { throw new mbean except ( e ) ; } catch ( runtim oper except e ) { throw new mbean except ( e ) ; } catch ( invalid target object type except e ) { throw new mbean except ( e ) ; } lifecycl listen listen = contain . find lifecycl listen ( ) ; ( lifecycl listen listen : listen ) { ( listen . get class ( ) . equal ( type ) ) { contain . remov lifecycl listen ( listen ) ; } } }
protect map string , string process annot web init param ( element valu ev ) { map string , string result = new hash map string , string ( ) ; ( ev instanceof arrai element valu ) { element valu arrai valu = ( ( arrai element valu ) ev ) . get element valu arrai ( ) ; ( element valu valu : arrai valu ) { ( valu instanceof annot element valu ) { element valu pair evp = ( ( annot element valu ) valu ) . get annot entri ( ) . get element valu pair ( ) ; string init param name = null ; string init param valu = null ; ( element valu pair evp : evp ) { ( name . equal ( evp . get name string ( ) ) ) { init param name = evp . get valu ( ) . stringifi valu ( ) ; } els ( valu . equal ( evp . get name string ( ) ) ) { init param valu = evp . get valu ( ) . stringifi valu ( ) ; } els { ignor } } result . put ( init param name , init param valu ) ; } } } return result ; }	protect void process annot web servlet ( string class name , annot entri ae , web xml fragment ) { string servlet name = null ; must search name s . spec servlet api 3 . 0 8 . 2 . 3 . 3 . n . ii page 81 element valu pair evp = ae . get element valu pair ( ) ; ( element valu pair evp : evp ) { string name = evp . get name string ( ) ; ( name . equal ( name ) ) { servlet name = evp . get valu ( ) . stringifi valu ( ) ; break ; } } ( servlet name = = null ) { classnam default servlet name annot ha name servlet name = class name ; } servlet def servlet def = fragment . get servlet ( ) . get ( servlet name ) ; boolean web xmlservlet def = servlet def = null ; ( web xmlservlet def ) { servlet def = new servlet def ( ) ; servlet def . set servlet name ( servlet name ) ; servlet def . set servlet class ( class name ) ; } boolean url pattern set = fals ; string url pattern = null ; element valu pair evp = ae . get element valu pair ( ) ; ( element valu pair evp : evp ) { string name = evp . get name string ( ) ; ( valu . equal ( name ) url pattern . equal ( name ) ) { ( url pattern set ) { throw new illeg argument except ( sm . get string ( context config . url pattern valu , class name ) ) ; } url pattern set = true ; url pattern = process annot string arrai ( evp . get valu ( ) ) ; } els ( descript . equal ( name ) ) { ( servlet def . get descript ( ) = = null ) { servlet def . set descript ( evp . get valu ( ) . stringifi valu ( ) ) ; } } els ( displai name . equal ( name ) ) { ( servlet def . get displai name ( ) = = null ) { servlet def . set displai name ( evp . get valu ( ) . stringifi valu ( ) ) ; } } els ( larg icon . equal ( name ) ) { ( servlet def . get larg icon ( ) = = null ) { servlet def . set larg icon ( evp . get valu ( ) . stringifi valu ( ) ) ; } } els ( small icon . equal ( name ) ) { ( servlet def . get small icon ( ) = = null ) { servlet def . set small icon ( evp . get valu ( ) . stringifi valu ( ) ) ; } } els ( async support . equal ( name ) ) { ( servlet def . get async support ( ) = = null ) { servlet def . set async support ( evp . get valu ( ) . stringifi valu ( ) ) ; } } els ( load startup . equal ( name ) ) { ( servlet def . get load startup ( ) = = null ) { servlet def . set load startup ( evp . get valu ( ) . stringifi valu ( ) ) ; } } els ( init param . equal ( name ) ) { map string , string init param = process annot web init param ( evp . get valu ( ) ) ; ( web xmlservlet def ) { map string , string web xmlinit param = servlet def . get paramet map ( ) ; ( map . entri string , string entri : init param . entri set ( ) ) { ( web xmlinit param . get ( entri . get kei ( ) ) = = null ) { servlet def . add init paramet ( entri . get kei ( ) , entri . get valu ( ) ) ; } } } els { ( map . entri string , string entri : init param . entri set ( ) ) { servlet def . add init paramet ( entri . get kei ( ) , entri . get valu ( ) ) ; } } } } ( web xmlservlet def url pattern = null ) { fragment . add servlet ( servlet def ) ; } ( url pattern set ) { ( fragment . get servlet map ( ) . contain valu ( servlet name ) ) { ( string url pattern : url pattern ) { fragment . add servlet map ( url pattern , servlet name ) ; } } } }
perform work particular code subject code . here work grant code null code subject . param method name method appli secur restrict param target object code servlet code which method call . param target argument code object code arrai contain runtim paramet instanc . param princip code princip code which secur privileg appli privat static void execut ( final method method , final object target object , final object target argument , princip princip ) throw java . lang . except { try { subject subject = null ; privileg except action void pea = new privileg except action void ( ) { } } }	public static perform work particular code subject code . here work grant code null code subject . param method name method appli secur restrict param target object code filter code which method call . param target type code class code arrai us instanti code method code object . param target argument code object code arrai contain runtim paramet instanc . param princip code princip code which secur privileg appli void do privileg ( final string method name , final filter target object , final class target type , final object target argument , princip princip ) throw java . lang . except { method method = null ; method method cach = null ; ( object cach . contain kei ( target object ) ) { method cach = object cach . get ( target object ) ; method = find method ( method cach , method name ) ; ( method = = null ) { method = creat method cach ( method cach , method name , target object , target type ) ; } } els { method = creat method cach ( method cach , method name , target object , target type ) ; } execut ( method , target object , target argument , princip ) ; }
public remov exist host . param name mbean name compon remov except except compon cannot remov void remov host ( string name ) throw except { acquir refer compon remov object name onam = new object name ( name ) ; string host name = onam . get kei properti ( host ) ; servic servic = get servic ( onam ) ; engin engin = ( engin ) servic . get contain ( ) ; host host = ( host ) engin . find child ( host name ) ; remov thi compon from parent compon ( host = null ) { ( host instanceof standard host ) ( ( standard host ) host ) . destroi ( ) ; els engin . remov child ( host ) ; } }
overrid public object get valu ( evalu context ctx ) throw elexcept { string builder sb = new string builder ( 16 ) ; object obj = null ; ( thi . children = null ) { ( int i = 0 ; i thi . children . length ; i ) { obj = thi . children i . get valu ( ctx ) ; ( obj = null ) { sb . append ( obj ) ; } } } return sb . string ( ) ; }	public void test bug49345 ( ) { express factori factori = express factori . new instanc ( ) ; elcontext context = new elcontext impl ( ) ; tester bean bean = new tester bean ( ) ; tester bean b bean b = new tester bean b ( ) ; bean b . set name ( tomcat ) ; bean . set bean ( bean b ) ; valu express var = factori . creat valu express ( bean , tester bean . class ) ; context . get variabl mapper ( ) . set variabl ( bean , var ) ; valu express ve = factori . creat valu express ( context , { bean . bean . name } , string . class ) ; first check basic work string result = ( string ) ve . get valu ( context ) ; assert equal ( tomcat , result ) ; now check valu refer valu refer vr = ve . get valu refer ( context ) ; assert null ( vr ) ; assert equal ( bean b , vr . get base ( ) ) ; assert equal ( name , vr . get properti ( ) ) ; }
privat adapt from file upload base . get file name ( ) string extract filenam ( string cd ) { string file name = null ; ( cd = null ) { string cdl = cd . lower case ( local . english ) ; ( cdl . start ( form data ) cdl . start ( attach ) ) { paramet parser parser = new paramet parser ( ) ; parser . set lower case name ( true ) ; paramet parser can handl null input map string , string param = parser . pars ( cd , ; ) ; ( param . contain kei ( filenam ) ) { file name = param . get ( filenam ) ; ( file name = null ) { file name = file name . trim ( ) ; } els { even valu , paramet present , so we return empti file name rather than file name . file name = ; } } } } return file name ; }	protect session get session path id ( string path , string id ) throw ioexcept { ( ( path = = null ) ( path . start ( ) path . equal ( ) ) ) { throw new illeg argument except ( sm . get string ( manag servlet . invalid path , request util . filter ( path ) ) ) ; } string search path = path ; ( path . equal ( ) ) search path = ; context ctxt = ( context ) host . find child ( search path ) ; ( null = = ctxt ) { throw new illeg argument except ( sm . get string ( manag servlet . context , request util . filter ( path ) ) ) ; } session session = ctxt . get manag ( ) . find session ( id ) ; return session ; }	protect deploi applic specifi path from specifi web applic archiv . param config url context configur file deploi param path context path applic deploi param war url web applic archiv deploi return messag string string deploi intern ( string config , string path , string war ) { string writer string writer = new string writer ( ) ; print writer print writer = new print writer ( string writer ) ; super . deploi ( print writer , config , path , war , fals ) ; return string writer . string ( ) ; }	protect extract expir request paramet param path param req string expir session ( string path , http servlet request req ) { int idl = 1 ; string idl param = req . get paramet ( idl ) ; ( idl param = null ) { try { idl = integ . pars int ( idl param ) ; } catch ( number format except e ) { log ( could pars idl paramet int : idl param ) ; } } return session ( path , idl ) ; }	protect find potenti memori leak caus web applic reload . see manag servlet findleak ( print writer ) return messag string string findleak ( ) { string builder msg = new string builder ( ) ; string writer string writer = new string writer ( ) ; print writer print writer = new print writer ( string writer ) ; super . findleak ( print writer ) ; ( string writer . get buffer ( ) . length ( ) 0 ) { msg . append ( sm . get string ( html manag servlet . findleak list ) ) ; msg . append ( string writer . string ( ) ) ; } els { msg . append ( sm . get string ( html manag servlet . findleak none ) ) ; } return msg . string ( ) ; }	protect gener onc time token ( nonc ) authent subsequ request . thi also add token session . nonc gener simplifi version manag base . gener session id ( ) . string gener nonc ( ) { byte random = new byte 16 ; render result string hexadecim digit string builder buffer = new string builder ( ) ; random sourc . next byte ( random ) ; ( int j = 0 ; j random . length ; j ) { byte b1 = ( byte ) ( ( random j 0xf0 ) >> 4 ) ; byte b2 = ( byte ) ( random j 0x0f ) ; ( b1 10 ) buffer . append ( ( char ) ( 0 b1 ) ) ; els buffer . append ( ( char ) ( ( b1 10 ) ) ) ; ( b2 10 ) buffer . append ( ( char ) ( 0 b2 ) ) ; els buffer . append ( ( char ) ( ( b2 10 ) ) ) ; } return buffer . string ( ) ; }	protect reload web applic specifi context path . see manag servlet reload ( print writer , string ) param path context path applic restart return messag string string reload ( string path ) { string writer string writer = new string writer ( ) ; print writer print writer = new print writer ( string writer ) ; super . reload ( print writer , path ) ; return string writer . string ( ) ; }	protect stop web applic specifi context path . see manag servlet stop ( print writer , string ) param path context path applic stop return messag string string stop ( string path ) { string writer string writer = new string writer ( ) ; print writer print writer = new print writer ( string writer ) ; super . stop ( print writer , path ) ; return string writer . string ( ) ; }	protect undeploi web applic specifi context path . see manag servlet undeploi ( print writer , string ) param path context path applic undeploi return messag string string undeploi ( string path ) { string writer string writer = new string writer ( ) ; print writer print writer = new print writer ( string writer ) ; super . undeploi ( print writer , path ) ; return string writer . string ( ) ; }	protect string upload ( http servlet request request ) throw ioexcept , servlet except { string messag = ; part war part = null ; string filenam = null ; string basenam = null ; collect part part = request . get part ( ) ; iter part iter = part . iter ( ) ; try { while ( iter . ha next ( ) ) { part part = iter . next ( ) ; ( part . get name ( ) . equal ( deploi war ) war part = = null ) { war part = part ; } els { part . delet ( ) ; } } while ( true ) { ( war part = = null ) { messag = sm . get string ( html manag servlet . deploi upload file ) ; break ; } filenam = extract filenam ( war part . get header ( content disposit ) ) ; ( filenam . lower case ( local . english ) . end ( . war ) ) { messag = sm . get string ( html manag servlet . deploi upload war , filenam ) ; break ; } get filenam upload name includ path ( filenam . last index ( ) = 0 ) { filenam = filenam . substr ( filenam . last index ( ) 1 ) ; } ( filenam . last index ( ) = 0 ) { filenam = filenam . substr ( filenam . last index ( ) 1 ) ; } identifi app base own host thi context ( ani ) basenam = filenam . substr ( 0 , filenam . lower case ( local . english ) . index ( . war ) ) ; file file = new file ( get app base ( ) , filenam ) ; ( file . exist ( ) ) { messag = sm . get string ( html manag servlet . deploi upload war exist , filenam ) ; break ; } string path = null ; ( basenam . equal ( root ) ) { path = ; } els { path = basenam . replac ( , ) ; } ( ( host . find child ( path ) = null ) deploi ( path ) ) { messag = sm . get string ( html manag servlet . deploi upload server xml , filenam ) ; break ; } ( servic ( path ) ) { add servic ( path ) ; try { war part . write ( file . get absolut path ( ) ) ; perform new deploy check ( path ) ; } final { remov servic ( path ) ; } } break ; } } catch ( except e ) { messag = sm . get string ( html manag servlet . deploi upload fail , e . get messag ( ) ) ; log ( messag , e ) ; } final { ( war part = null ) { war part . delet ( ) ; } war part = null ; } return messag ; }	protect synchron deploi web applic archiv ( includ current request ) specifi context path . param writer writer render result param path context path applic instal param tag tag associ webapp param request servlet request we ar process void deploi ( print writer writer , string path , string tag , boolean updat , http servlet request request ) { ( debug = 1 ) { log ( deploi : deploi web applic path ) ; } valid request context path ( ( path = = null ) path . length ( ) = = 0 path . start ( ) ) { writer . println ( sm . get string ( manag servlet . invalid path , path ) ) ; return ; } string displai path = path ; ( path . equal ( ) ) path = ; string basenam = get doc base ( path ) ; check app alreadi exist , undeploi updat context context = ( context ) host . find child ( path ) ; ( updat ) { ( context = null ) { undeploi ( writer , displai path ) ; } context = ( context ) host . find child ( path ) ; } ( context = null ) { writer . println ( sm . get string ( manag servlet . alreadi context , displai path ) ) ; return ; } calcul base path file deploi path = deploi ; ( tag = null ) { deploi path = new file ( version , tag ) ; deploi path . mkdir ( ) ; } upload web applic archiv local war file file local war = new file ( deploi path , basenam . war ) ; ( debug = 2 ) { log ( upload war file local war ) ; } copi war app base try { ( servic ( path ) ) { add servic ( path ) ; try { upload war upload war ( request , local war ) ; copi war xml host app base need ( tag = null ) { deploi path = deploi ; file local war copi = new file ( deploi path , basenam . war ) ; copi ( local war , local war copi ) ; local war = local war copi ; copi ( local war , new file ( get app base ( ) , basenam . war ) ) ; } perform new deploy check ( path ) ; } final { remov servic ( path ) ; } } } catch ( except e ) { log ( manag servlet . check displai path , e ) ; writer . println ( sm . get string ( manag servlet . except , e . string ( ) ) ) ; return ; } context = ( context ) host . find child ( path ) ; ( context = null context . get configur ( ) ) { writer . println ( sm . get string ( manag servlet . deploi , displai path ) ) ; } els { someth fail writer . println ( sm . get string ( manag servlet . deploi fail , displai path ) ) ; } }	protect instal applic specifi path from specifi web applic archiv . param writer writer render result param config url context configur file instal param path context path applic instal param war url web applic archiv instal param updat true overrid ani exist webapp path void deploi ( print writer writer , string config , string path , string war , boolean updat ) { ( config = null config . length ( ) = = 0 ) { config = null ; } ( war = null war . length ( ) = = 0 ) { war = null ; } ( debug = 1 ) { ( config = null config . length ( ) 0 ) { ( war = null ) { log ( instal : instal context configur config from war ) ; } els { log ( instal : instal context configur config ) ; } } els { ( path = null path . length ( ) 0 ) { log ( instal : instal web applic path from war ) ; } els { log ( instal : instal web applic from war ) ; } } } ( path = = null path . length ( ) = = 0 path . start ( ) ) { writer . println ( sm . get string ( manag servlet . invalid path , request util . filter ( path ) ) ) ; return ; } string displai path = path ; ( . equal ( path ) ) { path = ; } check app alreadi exist , undeploi updat context context = ( context ) host . find child ( path ) ; ( updat ) { ( context = null ) { undeploi ( writer , displai path ) ; } context = ( context ) host . find child ( path ) ; } ( context = null ) { writer . println ( sm . get string ( manag servlet . alreadi context , displai path ) ) ; return ; } ( config = null ( config . start ( file : ) ) ) { config = config . substr ( file : . length ( ) ) ; } ( war = null ( war . start ( file : ) ) ) { war = war . substr ( file : . length ( ) ) ; } try { ( servic ( path ) ) { add servic ( path ) ; try { ( config = null ) { config base . mkdir ( ) ; copi ( new file ( config ) , new file ( config base , get config file ( path ) . xml ) ) ; } ( war = null ) { ( war . end ( . war ) ) { copi ( new file ( war ) , new file ( get app base ( ) , get doc base ( path ) . war ) ) ; } els { copi ( new file ( war ) , new file ( get app base ( ) , get doc base ( path ) ) ) ; } } perform new deploy check ( path ) ; } final { remov servic ( path ) ; } } context = ( context ) host . find child ( path ) ; ( context = null context . get configur ( ) context . get avail ( ) ) { writer . println ( sm . get string ( manag servlet . deploi , displai path ) ) ; } els ( context = null context . get avail ( ) ) { writer . println ( sm . get string ( manag servlet . deploi start , displai path ) ) ; } els { someth fail writer . println ( sm . get string ( manag servlet . deploi fail , displai path ) ) ; } } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log ( manag servlet . instal displai path , t ) ; writer . println ( sm . get string ( manag servlet . except , t . string ( ) ) ) ; } }	protect instal applic specifi path from specifi web applic archiv . param writer writer render result param tag revis tag deploi from param path context path applic instal void deploi ( print writer writer , string path , string tag ) { valid request context path ( ( path = = null ) path . length ( ) = = 0 path . start ( ) ) { writer . println ( sm . get string ( manag servlet . invalid path , path ) ) ; return ; } string displai path = path ; ( path . equal ( ) ) path = ; calcul base path file deploi path = version ; ( tag = null ) { deploi path = new file ( deploi path , tag ) ; } find local war file file local war = new file ( deploi path , get doc base ( path ) . war ) ; check app alreadi exist , undeploi updat context context = ( context ) host . find child ( path ) ; ( context = null ) { undeploi ( writer , displai path ) ; } copi war app base try { ( servic ( path ) ) { add servic ( path ) ; try { copi ( local war , new file ( get app base ( ) , get doc base ( path ) . war ) ) ; perform new deploy check ( path ) ; } final { remov servic ( path ) ; } } } catch ( except e ) { log ( manag servlet . check displai path , e ) ; writer . println ( sm . get string ( manag servlet . except , e . string ( ) ) ) ; return ; } context = ( context ) host . find child ( path ) ; ( context = null context . get configur ( ) ) { writer . println ( sm . get string ( manag servlet . deploi , displai path ) ) ; } els { someth fail writer . println ( sm . get string ( manag servlet . deploi fail , displai path ) ) ; } }	protect param req param resp throw servlet except throw ioexcept void displai session detail page ( http servlet request req , http servlet respons resp , string path , string session id ) throw servlet except , ioexcept { session session = get session path id ( path , session id ) ; strong note strong thi header overridden automat code request dispatch . forward ( ) code call ultim invok . http 1 . 0 resp . set header ( pragma , cach ) ; http 1 . 1 resp . set header ( cach control , cach , store , max ag = 0 ) ; 0 mean now resp . set date header ( expir , 0 ) ; req . set attribut ( current session , session ) ; get servlet context ( ) . get request dispatch ( resp . encod url ( session detail jsp path ) ) . includ ( req , resp ) ; }	protect param req param resp throw servlet except throw ioexcept void displai session list page ( string path , http servlet request req , http servlet respons resp ) throw servlet except , ioexcept { list session session = get session path ( path ) ; string sort = req . get paramet ( sort ) ; string order = null ; ( null = sort . equal ( sort . trim ( ) ) ) { compar session compar = get compar ( sort ) ; ( compar = null ) { order = req . get paramet ( order ) ; ( desc . equal ignor case ( order ) ) { compar = new revers compar ( compar ) ; order = asc ; } els { order = desc ; } try { collect . sort ( session , compar ) ; } catch ( illeg state except ) { least 1 session invalid req . set attribut ( applic error , can t sort session list : session invalid ) ; } } els { log ( warn : unknown sort order : sort ) ; } } keep sort order req . set attribut ( sort , sort ) ; req . set attribut ( order , order ) ; req . set attribut ( activ session , session ) ; strong note strong thi header overridden automat code request dispatch . forward ( ) code call ultim invok . http 1 . 0 resp . set header ( pragma , cach ) ; http 1 . 1 resp . set header ( cach control , cach , store , max ag = 0 ) ; 0 mean now resp . set date header ( expir , 0 ) ; get servlet context ( ) . get request dispatch ( session list jsp path ) . includ ( req , resp ) ; }	protect list session get session path ( string path ) { ( ( path = = null ) ( path . start ( ) path . equal ( ) ) ) { throw new illeg argument except ( sm . get string ( manag servlet . invalid path , request util . filter ( path ) ) ) ; } string search path = path ; ( path . equal ( ) ) search path = ; context ctxt = ( context ) host . find child ( search path ) ; ( null = = ctxt ) { throw new illeg argument except ( sm . get string ( manag servlet . context , request util . filter ( path ) ) ) ; } manag manag = ctxt . get manag ( ) ; list session session = new arrai list session ( ) ; session . add all ( arrai . list ( manag . find session ( ) ) ) ; ( manag instanceof backup manag show proxi session ) { add dummi proxi session set string session id = ( ( backup manag ) manag ) . get session id full ( ) ; remov activ ( primari backup ) session id from full list ( session session : session ) { session id . remov ( session . get id ( ) ) ; } left just proxi session add them ( string session id : session id ) { session . add ( new dummi proxi session ( session id ) ) ; } } return session ; }	protect extract expir request paramet param path param req void expir session ( print writer writer , string path , http servlet request req ) { int idl = 1 ; string idl param = req . get paramet ( idl ) ; ( idl param = null ) { try { idl = integ . pars int ( idl param ) ; } catch ( number format except e ) { log ( could pars idl paramet int : idl param ) ; } } session ( writer , path , idl ) ; }	protect find potenti memori leak caus web applic reload . void findleak ( print writer writer ) { ( ( host instanceof standard host ) ) { writer . println ( sm . get string ( manag servlet . findleak fail ) ) ; return ; } string result = ( ( standard host ) host ) . find reload context memori leak ( ) ; ( string result : result ) { ( . equal ( result ) ) { result = ; } writer . println ( result ) ; } }	protect render list current activ context our virtual host . param writer writer render void list ( print writer writer ) { ( debug = 1 ) log ( list : list context virtual host host . get name ( ) ) ; writer . println ( sm . get string ( manag servlet . list , host . get name ( ) ) ) ; contain context = host . find children ( ) ; ( int i = 0 ; i context . length ; i ) { context context = ( context ) context i ; ( context = null ) { string displai path = context . get path ( ) ; ( displai path . equal ( ) ) displai path = ; ( context . get avail ( ) ) { writer . println ( sm . get string ( manag servlet . listitem , displai path , run , context . get manag ( ) . find session ( ) . length , context . get doc base ( ) ) ) ; } els { writer . println ( sm . get string ( manag servlet . listitem , displai path , stop , 0 , context . get doc base ( ) ) ) ; } } } }	protect list resourc given context . void print resourc ( print writer writer , string prefix , javax . name . context name context , string type , class clazz ) { try { name enumer bind item = name context . list bind ( ) ; while ( item . ha more ( ) ) { bind item = item . next ( ) ; ( item . get object ( ) instanceof javax . name . context ) { print resourc ( writer , prefix item . get name ( ) , ( javax . name . context ) item . get object ( ) , type , clazz ) ; } els { ( ( clazz = null ) ( ( clazz . instanc ( item . get object ( ) ) ) ) ) { continu ; } writer . print ( prefix item . get name ( ) ) ; writer . print ( : ) ; writer . print ( item . get class name ( ) ) ; do we want descript avail writer . println ( ) ; } } } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log ( manag servlet . resourc type , t ) ; writer . println ( sm . get string ( manag servlet . except , t . string ( ) ) ) ; } }	protect reload web applic specifi context path . param writer writer render param path context path applic restart void reload ( print writer writer , string path ) { ( debug = 1 ) log ( restart : reload web applic path ) ; ( ( path = = null ) ( path . start ( ) path . equal ( ) ) ) { writer . println ( sm . get string ( manag servlet . invalid path , request util . filter ( path ) ) ) ; return ; } string displai path = path ; ( path . equal ( ) ) path = ; try { context context = ( context ) host . find child ( path ) ; ( context = = null ) { writer . println ( sm . get string ( manag servlet . context , request util . filter ( displai path ) ) ) ; return ; } isn t possibl manag reload itself ( context . get path ( ) . equal ( thi . context . get path ( ) ) ) { writer . println ( sm . get string ( manag servlet . self ) ) ; return ; } context . reload ( ) ; writer . println ( sm . get string ( manag servlet . reload , displai path ) ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log ( manag servlet . reload displai path , t ) ; writer . println ( sm . get string ( manag servlet . except , t . string ( ) ) ) ; } }	protect render list avail global jndi resourc . param type fulli qualifi class name resourc type interest , code null code list resourc all type void resourc ( print writer writer , string type ) { ( debug = 1 ) { ( type = null ) { log ( resourc : list resourc type type ) ; } els { log ( resourc : list resourc all type ) ; } } global jndi resourc context avail ( global = = null ) { writer . println ( sm . get string ( manag servlet . global ) ) ; return ; } enumer global jndi resourc request type ( type = null ) { writer . println ( sm . get string ( manag servlet . resourc type , type ) ) ; } els { writer . println ( sm . get string ( manag servlet . resourc all ) ) ; } class clazz = null ; try { ( type = null ) { clazz = class . name ( type ) ; } } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log ( manag servlet . resourc type , t ) ; writer . println ( sm . get string ( manag servlet . except , t . string ( ) ) ) ; return ; } print resourc ( writer , , global , type , clazz ) ; }	protect render list secur role name ( correspond descript ) from code org . apach . catalina . user databas code resourc connect code user code resourc refer . typic , thi global user databas , can adjust you have differ user databas differ virtual host . param writer writer render void role ( print writer writer ) { ( debug = 1 ) { log ( role : list secur role from user databas ) ; } look up user databas instanc we should us user databas databas = null ; try { initi context ic = new initi context ( ) ; databas = ( user databas ) ic . lookup ( java : comp env user ) ; } catch ( name except e ) { writer . println ( sm . get string ( manag servlet . user databas error ) ) ; log ( java : comp env user , e ) ; return ; } ( databas = = null ) { writer . println ( sm . get string ( manag servlet . user databas miss ) ) ; return ; } enumer avail role writer . println ( sm . get string ( manag servlet . role list ) ) ; iter role role = databas . get role ( ) ; ( role = null ) { while ( role . ha next ( ) ) { role role = role . next ( ) ; writer . print ( role . get rolenam ( ) ) ; writer . print ( : ) ; ( role . get descript ( ) = null ) { writer . print ( role . get descript ( ) ) ; } writer . println ( ) ; } } }	protect write system os jvm properti . param writer writer render void serverinfo ( print writer writer ) { ( debug = 1 ) log ( serverinfo ) ; try { string builder prop = new string builder ( ) ; prop . append ( ok server info ) ; prop . append ( n tomcat version : ) ; prop . append ( server info . get server info ( ) ) ; prop . append ( n os name : ) ; prop . append ( system . get properti ( os . name ) ) ; prop . append ( n os version : ) ; prop . append ( system . get properti ( os . version ) ) ; prop . append ( n os architectur : ) ; prop . append ( system . get properti ( os . arch ) ) ; prop . append ( n jvm version : ) ; prop . append ( system . get properti ( java . runtim . version ) ) ; prop . append ( n jvm vendor : ) ; prop . append ( system . get properti ( java . vm . vendor ) ) ; writer . println ( prop . string ( ) ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; get servlet context ( ) . log ( manag servlet . serverinfo , t ) ; writer . println ( sm . get string ( manag servlet . except , t . string ( ) ) ) ; } }	session inform web applic specifi context path . displai profil session thi access time list number session each 10 minut interv up 10 hour . param writer writer render param path context path applic list session inform void session ( print writer writer , string path ) { session ( writer , path , 1 ) ; }	session inform web applic specifi context path . displai profil session thi access time list number session each 10 minut interv up 10 hour . param writer writer render param path context path applic list session inform param idl expir all session idl time gt ; idl thi context protect void session ( print writer writer , string path , int idl ) { ( debug = 1 ) { log ( session : session inform web applic path ) ; ( idl = 0 ) log ( session : session expir idl minut path ) ; } ( ( path = = null ) ( path . start ( ) path . equal ( ) ) ) { writer . println ( sm . get string ( manag servlet . invalid path , request util . filter ( path ) ) ) ; return ; } string displai path = path ; ( path . equal ( ) ) path = ; try { context context = ( context ) host . find child ( path ) ; ( context = = null ) { writer . println ( sm . get string ( manag servlet . context , request util . filter ( displai path ) ) ) ; return ; } manag manag = context . get manag ( ) ; ( manag = = null ) { writer . println ( sm . get string ( manag servlet . manag , request util . filter ( displai path ) ) ) ; return ; } int max count = 60 ; int max inact interv = manag . get max inact interv ( ) 60 ; int histo interv = max inact interv max count ; ( histo interv max count max inact interv ) histo interv ; ( 0 = = histo interv ) histo interv = 1 ; max count = max inact interv histo interv ; ( histo interv max count max inact interv ) max count ; writer . println ( sm . get string ( manag servlet . session , displai path ) ) ; writer . println ( sm . get string ( manag servlet . sessiondefaultmax , max inact interv ) ) ; session session = manag . find session ( ) ; int timeout = new int max count ; int notimeout = 0 ; int expir = 0 ; long now = system . current time milli ( ) ; ( int i = 0 ; i session . length ; i ) { int time = ( int ) ( ( now session i . get thi access time intern ( ) ) 1000 ) ; ( idl = 0 time = idl 60 ) { session i . expir ( ) ; expir ; } time = time 60 histo interv ; ( time 0 ) notimeout ; } } }	protect start web applic specifi context path . param writer writer render param path context path applic start void start ( print writer writer , string path ) { ( debug = 1 ) log ( start : start web applic path ) ; ( ( path = = null ) ( path . start ( ) path . equal ( ) ) ) { writer . println ( sm . get string ( manag servlet . invalid path , request util . filter ( path ) ) ) ; return ; } string displai path = path ; ( path . equal ( ) ) path = ; try { context context = ( context ) host . find child ( path ) ; ( context = = null ) { writer . println ( sm . get string ( manag servlet . context , request util . filter ( displai path ) ) ) ; return ; } context . start ( ) ; ( context . get avail ( ) ) writer . println ( sm . get string ( manag servlet . start , displai path ) ) ; els writer . println ( sm . get string ( manag servlet . start fail , displai path ) ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; get servlet context ( ) . log ( sm . get string ( manag servlet . start fail , displai path ) , t ) ; writer . println ( sm . get string ( manag servlet . start fail , displai path ) ) ; writer . println ( sm . get string ( manag servlet . except , t . string ( ) ) ) ; } }	protect stop web applic specifi context path . param writer writer render param path context path applic stop void stop ( print writer writer , string path ) { ( debug = 1 ) log ( stop : stop web applic path ) ; ( ( path = = null ) ( path . start ( ) path . equal ( ) ) ) { writer . println ( sm . get string ( manag servlet . invalid path , request util . filter ( path ) ) ) ; return ; } string displai path = path ; ( path . equal ( ) ) path = ; try { context context = ( context ) host . find child ( path ) ; ( context = = null ) { writer . println ( sm . get string ( manag servlet . context , request util . filter ( displai path ) ) ) ; return ; } isn t possibl manag stop itself ( context . get path ( ) . equal ( thi . context . get path ( ) ) ) { writer . println ( sm . get string ( manag servlet . self ) ) ; return ; } context . stop ( ) ; writer . println ( sm . get string ( manag servlet . stop , displai path ) ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log ( manag servlet . stop displai path , t ) ; writer . println ( sm . get string ( manag servlet . except , t . string ( ) ) ) ; } }	protect undeploi web applic specifi context path . param writer writer render param path context path applic remov void undeploi ( print writer writer , string path ) { ( debug = 1 ) log ( undeploi : undeploi web applic path ) ; ( ( path = = null ) ( path . start ( ) path . equal ( ) ) ) { writer . println ( sm . get string ( manag servlet . invalid path , request util . filter ( path ) ) ) ; return ; } string displai path = path ; ( path . equal ( ) ) path = ; try { valid context specifi applic context context = ( context ) host . find child ( path ) ; ( context = = null ) { writer . println ( sm . get string ( manag servlet . context , request util . filter ( displai path ) ) ) ; return ; } ( deploi ( path ) ) { writer . println ( sm . get string ( manag servlet . deploi , request util . filter ( displai path ) ) ) ; return ; } ( servic ( path ) ) { add servic ( path ) ; try { try stop context first nicer context . stop ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } try { ( path . last index ( ) 0 ) { path = path . substr ( 1 ) . replac ( , ) ; } file war = new file ( get app base ( ) , get doc base ( path ) . war ) ; file dir = new file ( get app base ( ) , get doc base ( path ) ) ; file xml = new file ( config base , get config file ( path ) . xml ) ; ( war . exist ( ) ) { war . delet ( ) ; } els ( dir . exist ( ) ) { undeploi dir ( dir ) ; } els { xml . delet ( ) ; } perform new deploy check ( path . replac ( , ) ) ; } final { remov servic ( path . replac ( , ) ) ; } } writer . println ( sm . get string ( manag servlet . undeploi , displai path ) ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log ( manag servlet . undeploi displai path , t ) ; writer . println ( sm . get string ( manag servlet . except , t . string ( ) ) ) ; } }	protect upload war file includ thi request , store specifi file locat . param request servlet request we ar process param war file which we should store upload war except ioexcept i o error occur dure process void upload war ( http servlet request request , file war ) throw ioexcept { war . delet ( ) ; servlet input stream istream = null ; buffer output stream ostream = null ; try { istream = request . get input stream ( ) ; ostream = new buffer output stream ( new file output stream ( war ) , 1024 ) ; byte buffer = new byte 1024 ; while ( true ) { int n = istream . read ( buffer ) ; ( n 0 ) { break ; } ostream . write ( buffer , 0 , n ) ; } ostream . flush ( ) ; ostream . close ( ) ; ostream = null ; istream . close ( ) ; istream = null ; } catch ( ioexcept e ) { war . delet ( ) ; throw e ; } final { ( ostream = null ) { try { ostream . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } ostream = null ; } ( istream = null ) { try { istream . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } istream = null ; } } }	public get string from underli resourc bundl return null string found . param kei desir resourc string return resourc string match i kei i from underli bundl null found . throw illeg argument except i kei i null . string get string ( string kei ) { ( kei = = null ) { string msg = kei mai have null valu ; throw new illeg argument except ( msg ) ; } string str = null ; try { avoid npe bundl null treat like mre ( bundl = null ) { str = bundl . get string ( kei ) ; } } catch ( miss resourc except mre ) { bad : shouldn t mask except follow wai : str = cannot find messag associ kei kei due mre ; becaus hide fact string wa miss from call code . good : could just throw except ( wrap anoth ) would probabl caus much havoc exist code . better : consist contain pattern simpli return null . call code can do null check . str = null ; } return str ; }	public get string from underli resourc bundl format given set argument . param kei param arg string get string ( final string kei , final object . . . arg ) { string valu = get string ( kei ) ; ( valu = = null ) { valu = kei ; } messag format mf = new messag format ( valu ) ; mf . set local ( local ) ; return mf . format ( arg , new string buffer ( ) , null ) . string ( ) ; }	public displai session inform invok list . see manag servlet session ( print writer , string ) param path context path applic list session inform return messag string string session ( string path ) { return session ( path , 1 ) ; }	public displai session inform invok list . see manag servlet session ( print writer , string , int ) param path context path applic list session inform param idl expir all session idl time ge ; idl thi context return messag string string session ( string path , int idl ) { string writer string writer = new string writer ( ) ; print writer print writer = new print writer ( string writer ) ; super . session ( print writer , path , idl ) ; return string writer . string ( ) ; }	public start web applic specifi context path . see manag servlet start ( print writer , string ) param path context path applic start return messag string string start ( string path ) { string writer string writer = new string writer ( ) ; print writer print writer = new print writer ( string writer ) ; super . start ( print writer , path ) ; return string writer . string ( ) ; }	public remov attribut from http session param session id param attribut name return true wa attribut remov , fals otherwis throw ioexcept boolean remov session attribut ( string path , string session id , string attribut name ) throw ioexcept { http session session = get session path id ( path , session id ) . get session ( ) ; ( null = = session ) { shouldn t happen , let s plai nice . . . ( debug = 1 ) { log ( warn : can t remov attribut attribut name null session session id ) ; } return fals ; } boolean wa present = ( null = session . get attribut ( attribut name ) ) ; try { session . remov attribut ( attribut name ) ; } catch ( illeg state except ) { ( debug = 1 ) { log ( can t remot attribut attribut name invalid session id session id ) ; } } return wa present ; }	public invalid http session param session id return number invalid session throw ioexcept int invalid session ( string path , string session id ) throw ioexcept { ( null = = session id ) { return 0 ; } int nb affect session = 0 ; ( int i = 0 ; i session id . length ; i ) { string session id = session id i ; http session session = get session path id ( path , session id ) . get session ( ) ; ( null = = session ) { shouldn t happen , let s plai nice . . . ( debug = 1 ) { log ( warn : can t invalid null session session id ) ; } continu ; } try { session . invalid ( ) ; nb affect session ; ( debug = 1 ) { log ( invalid session id session id ) ; } } catch ( illeg state except ) { ( debug = 1 ) { log ( can t invalid alreadi invalid session id session id ) ; } } } return nb affect session ; }	public static final synchron get string manag particular packag . manag packag alreadi exist , reus , els new string manag creat return . param packag name packag name string manag get manag ( string packag name ) { string manag mgr = manag . get ( packag name ) ; ( mgr = = null ) { mgr = new string manag ( packag name ) ; manag . put ( packag name , mgr ) ; } return mgr ; }	public void do get ( http servlet request request , http servlet respons respons ) throw ioexcept , servlet except { identifi request paramet we need obtain command from path info , per command secur can configur web . xml string command = request . get path info ( ) ; string path = request . get paramet ( path ) ; prepar our output writer gener respons messag respons . set content type ( text html ; charset = constant . charset ) ; string messag = ; process request command ( command = = null command . equal ( ) ) { command = = list } els ( command . equal ( list ) ) { list alwai displai noth do here } els ( command . equal ( session ) ) { try { do session ( path , request , respons ) ; return ; } catch ( except e ) { log ( htmlmanag servlet . session path , e ) ; messag = sm . get string ( manag servlet . except , e . string ( ) ) ; } } els ( command . equal ( upload ) command . equal ( deploi ) command . equal ( reload ) command . equal ( undeploi ) command . equal ( expir ) command . equal ( start ) command . equal ( stop ) ) { messag = sm . get string ( manag servlet . post command , command ) ; } els { messag = sm . get string ( manag servlet . unknown command , command ) ; } list ( request , respons , messag ) ; }	process get request specifi resourc . param request servlet request we ar process param respons servlet respons we ar creat except ioexcept input output error occur except servlet except servlet specifi error occur overrid public void do get ( http servlet request request , http servlet respons respons ) throw ioexcept , servlet except { identifi request paramet we need string command = request . get path info ( ) ; ( command = = null ) command = request . get servlet path ( ) ; string config = request . get paramet ( config ) ; string path = request . get paramet ( path ) ; string type = request . get paramet ( type ) ; string war = request . get paramet ( war ) ; string tag = request . get paramet ( tag ) ; boolean updat = fals ; ( ( request . get paramet ( updat ) = null ) ( request . get paramet ( updat ) . equal ( true ) ) ) { updat = true ; } prepar our output writer gener respons messag respons . set content type ( text plain ; charset = constant . charset ) ; print writer writer = respons . get writer ( ) ; process request command ( note deploi list here ) ( command = = null ) { writer . println ( sm . get string ( manag servlet . command ) ) ; } els ( command . equal ( deploi ) ) { ( war = null config = null ) { deploi ( writer , config , path , war , updat ) ; } els { deploi ( writer , path , tag ) ; } } els ( command . equal ( list ) ) { list ( writer ) ; } els ( command . equal ( reload ) ) { reload ( writer , path ) ; } els ( command . equal ( resourc ) ) { resourc ( writer , type ) ; } els ( command . equal ( role ) ) { role ( writer ) ; } els ( command . equal ( save ) ) { save ( writer , path ) ; } els ( command . equal ( serverinfo ) ) { serverinfo ( writer ) ; } els ( command . equal ( session ) ) { expir session ( writer , path , request ) ; } els ( command . equal ( expir ) ) { expir session ( writer , path , request ) ; } els ( command . equal ( start ) ) { start ( writer , path ) ; } els ( command . equal ( stop ) ) { stop ( writer , path ) ; } els ( command . equal ( undeploi ) ) { undeploi ( writer , path ) ; } els ( command . equal ( findleak ) ) { findleak ( writer ) ; } els { writer . println ( sm . get string ( manag servlet . unknown command , command ) ) ; } finish up respons writer . flush ( ) ; writer . close ( ) ; }	process post request specifi resourc . param request servlet request we ar process param respons servlet respons we ar creat except ioexcept input output error occur except servlet except servlet specifi error occur overrid public void do post ( http servlet request request , http servlet respons respons ) throw ioexcept , servlet except { identifi request paramet we need obtain command from path info , per command secur can configur web . xml string command = request . get path info ( ) ; string path = request . get paramet ( path ) ; string deploi path = request . get paramet ( deploi path ) ; string deploi config = request . get paramet ( deploi config ) ; string deploi war = request . get paramet ( deploi war ) ; prepar our output writer gener respons messag respons . set content type ( text html ; charset = constant . charset ) ; string messag = ; ( command = = null command . length ( ) = = 0 ) { command = = list list alwai displai do noth } els ( command . equal ( upload ) ) { messag = upload ( request ) ; } els ( command . equal ( deploi ) ) { messag = deploi intern ( deploi config , deploi path , deploi war ) ; } els ( command . equal ( reload ) ) { messag = reload ( path ) ; } els ( command . equal ( undeploi ) ) { messag = undeploi ( path ) ; } els ( command . equal ( expir ) ) { messag = expir session ( path , request ) ; } els ( command . equal ( start ) ) { messag = start ( path ) ; } els ( command . equal ( stop ) ) { messag = stop ( path ) ; } els ( command . equal ( findleak ) ) { messag = findleak ( ) ; } els { try get do get ( request , respons ) ; return ; } list ( request , respons , messag ) ; }	process put request specifi resourc . param request servlet request we ar process param respons servlet respons we ar creat except ioexcept input output error occur except servlet except servlet specifi error occur overrid public void do put ( http servlet request request , http servlet respons respons ) throw ioexcept , servlet except { identifi request paramet we need string command = request . get path info ( ) ; ( command = = null ) command = request . get servlet path ( ) ; string path = request . get paramet ( path ) ; string tag = request . get paramet ( tag ) ; boolean updat = fals ; ( ( request . get paramet ( updat ) = null ) ( request . get paramet ( updat ) . equal ( true ) ) ) { updat = true ; } prepar our output writer gener respons messag respons . set content type ( text plain ; charset = constant . charset ) ; print writer writer = respons . get writer ( ) ; process request command ( command = = null ) { writer . println ( sm . get string ( manag servlet . command ) ) ; } els ( command . equal ( deploi ) ) { deploi ( writer , path , tag , updat , request ) ; } els { writer . println ( sm . get string ( manag servlet . unknown command , command ) ) ; } finish up respons writer . flush ( ) ; writer . close ( ) ; }	see javax . servlet . gener servlet init ( ) overrid public void init ( ) throw servlet except { super . init ( ) ; set our properti from initi paramet string valu = null ; valu = get servlet config ( ) . get init paramet ( show proxi session ) ; show proxi session = boolean . pars boolean ( valu ) ; }	initi thi servlet . overrid public void init ( ) throw servlet except { ensur our contain servlet properti have been set ( ( wrapper = = null ) ( context = = null ) ) throw new unavail except ( sm . get string ( manag servlet . wrapper ) ) ; set our properti from initi paramet string valu = null ; try { valu = get servlet config ( ) . get init paramet ( debug ) ; debug = integ . pars int ( valu ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } acquir global jndi resourc avail server server = ( ( engin ) host . get parent ( ) ) . get servic ( ) . get server ( ) ; ( ( server = null ) ( server instanceof standard server ) ) { global = ( ( standard server ) server ) . get global name context ( ) ; } calcul directori which we deploi applic version = ( file ) get servlet context ( ) . get attribut ( servlet context . tempdir ) ; identifi app base own host thi context ( ani ) string app base = ( ( host ) context . get parent ( ) ) . get app base ( ) ; deploi = new file ( app base ) ; ( deploi . absolut ( ) ) { deploi = new file ( system . get properti ( global . catalina base prop ) , app base ) ; } config base = new file ( system . get properti ( global . catalina base prop ) , conf ) ; contain contain = context ; contain host = null ; contain engin = null ; while ( contain = null ) { ( contain instanceof host ) host = contain ; ( contain instanceof engin ) engin = contain ; contain = contain . get parent ( ) ; } ( engin = null ) { config base = new file ( config base , engin . get name ( ) ) ; } ( host = null ) { config base = new file ( config base , host . get name ( ) ) ; } log debug messag necessari ( debug = 1 ) { log ( init : associ deploy onam ) ; ( global = null ) { log ( init : global resourc ar avail ) ; } } }	public render html list current activ context our virtual host , memori server statu inform . param request request param respons respons param messag messag displai void list ( http servlet request request , http servlet respons respons , string messag ) throw ioexcept { ( debug = 1 ) log ( list : list context virtual host host . get name ( ) ) ; print writer writer = respons . get writer ( ) ; html header section writer . print ( constant . html header section ) ; bodi header section object arg = new object 2 ; arg 0 = request . get context path ( ) ; arg 1 = sm . get string ( html manag servlet . titl ) ; writer . print ( messag format . format ( constant . bodi header section , arg ) ) ; messag section arg = new object 3 ; arg 0 = sm . get string ( html manag servlet . messag label ) ; ( messag = = null messag . length ( ) = = 0 ) { arg 1 = ok ; } els { arg 1 = request util . filter ( messag ) ; } writer . print ( messag format . format ( constant . messag section , arg ) ) ; manag section arg = new object 9 ; arg 0 = sm . get string ( html manag servlet . manag ) ; arg 1 = respons . encod url ( request . get context path ( ) html list ) ; arg 2 = sm . get string ( html manag servlet . list ) ; arg 3 = respons . encod url ( request . get context path ( ) sm . get string ( html manag servlet . help html manag file ) ) ; arg 4 = sm . get string ( html manag servlet . help html manag ) ; arg 5 = respons . encod url ( request . get context path ( ) sm . get string ( html manag servlet . help manag file ) ) ; arg 6 = sm . get string ( html manag servlet . help manag ) ; arg 7 = respons . encod url ( request . get context path ( ) statu ) ; arg 8 = sm . get string ( statu servlet . titl ) ; writer . print ( messag format . format ( constant . manag section , arg ) ) ; app header section arg = new object 6 ; arg 0 = sm . get string ( html manag servlet . app titl ) ; arg 1 = sm . get string ( html manag servlet . app path ) ; arg 2 = sm . get string ( html manag servlet . app name ) ; arg 3 = sm . get string ( html manag servlet . app avail ) ; arg 4 = sm . get string ( html manag servlet . app session ) ; arg 5 = sm . get string ( html manag servlet . app task ) ; writer . print ( messag format . format ( app header section , arg ) ) ; app row section creat sort map deploi applic context path . contain children = host . find children ( ) ; string context path = new string children . length ; ( int i = 0 ; i children . length ; i ) context path i = children i . get name ( ) ; tree map string , string sort context path map = new tree map string , string ( ) ; ( int i = 0 ; i context path . length ; i ) { string displai path = context path i ; sort context path map . put ( displai path , context path i ) ; } string app start = sm . get string ( html manag servlet . app start ) ; string app stop = sm . get string ( html manag servlet . app stop ) ; string app reload = sm . get string ( html manag servlet . app reload ) ; string app undeploi = sm . get string ( html manag servlet . app undeploi ) ; string app expir = sm . get string ( html manag servlet . app expir ) ; iter map . entri string , string >> iter = sort context path map . entri set ( ) . iter ( ) ; boolean highlight = true ; boolean deploi = true ; string highlight color = null ; while ( iter . ha next ( ) ) { bugzilla 34818 , altern row color highlight = highlight ; ( highlight ) { highlight color = c3f3c3 ; } els { highlight color = ffffff ; } map . entri string , string entri = iter . next ( ) ; string displai path = entri . get kei ( ) ; string context path = entri . get valu ( ) ; context ctxt = ( context ) host . find child ( context path ) ; ( displai path . equal ( ) ) { displai path = ; } ( ctxt = null ) { try { deploi = deploi ( context path ) ; } catch ( except e ) { assum fals failur safeti deploi = fals ; } arg = new object 7 ; arg 0 = url encod . encod ( displai path ) ; arg 1 = displai path ; arg 2 = ctxt . get displai name ( ) ; ( arg 2 = = null ) { arg 2 = nbsp ; ; } arg 3 = new boolean ( ctxt . get avail ( ) ) ; arg 4 = respons . encod url ( request . get context path ( ) html session path = url encod . encod ( displai path ) ) ; manag manag = ctxt . get manag ( ) ; ( manag instanceof backup manag show proxi session ) { arg 5 = new integ ( ( ( backup manag ) manag ) . get activ session full ( ) ) ; } els ( ctxt . get manag ( ) = null ) { arg 5 = new integ ( manag . get activ session ( ) ) ; } els { arg 5 = new integ ( 0 ) ; } arg 6 = highlight color ; writer . print ( messag format . format ( app row detail section , arg ) ) ; arg = new object 14 ; arg 0 = respons . encod url ( request . get context path ( ) html start path = url encod . encod ( displai path ) ) ; arg 1 = app start ; arg 2 = respons . encod url ( request . get context path ( ) html stop path = url encod . encod ( displai path ) ) ; arg 3 = app stop ; arg 4 = respons . encod url ( request . get context path ( ) html reload path = url encod . encod ( displai path ) ) ; arg 5 = app reload ; arg 6 = respons . encod url ( request . get context path ( ) html undeploi path = url encod . encod ( displai path ) ) ; arg 7 = app undeploi ; arg 8 = respons . encod url ( request . get context path ( ) html expir path = url encod . encod ( displai path ) ) ; arg 9 = app expir ; arg 10 = sm . get string ( html manag servlet . expir . explain ) ; ( manag = = null ) { arg 11 = sm . get string ( html manag servlet . manag ) ; } els { arg 11 = new integ ( ctxt . get manag ( ) . get max inact interv ( ) 60 ) ; } arg 12 = sm . get string ( html manag servlet . expir . unit ) ; arg 13 = highlight color ; ( ctxt . get path ( ) . equal ( thi . context . get path ( ) ) ) { writer . print ( messag format . format ( manag app row button section , arg ) ) ; } els ( ctxt . get avail ( ) deploi ) { writer . print ( messag format . format ( start deploi app row button section , arg ) ) ; } els ( ctxt . get avail ( ) deploi ) { writer . print ( messag format . format ( start nondeploi app row button section , arg ) ) ; } els ( ctxt . get avail ( ) deploi ) { writer . print ( messag format . format ( stop deploi app row button section , arg ) ) ; } els { writer . print ( messag format . format ( stop nondeploi app row button section , arg ) ) ; } } } deploi section arg = new object 7 ; arg 0 = sm . get string ( html manag servlet . deploi titl ) ; arg 1 = sm . get string ( html manag servlet . deploi server ) ; arg 2 = respons . encod url ( request . get context path ( ) html deploi ) ; arg 3 = sm . get string ( html manag servlet . deploi path ) ; arg 4 = sm . get string ( html manag servlet . deploi config ) ; arg 5 = sm . get string ( html manag servlet . deploi war ) ; arg 6 = sm . get string ( html manag servlet . deploi button ) ; writer . print ( messag format . format ( deploi section , arg ) ) ; arg = new object 4 ; arg 0 = sm . get string ( html manag servlet . deploi upload ) ; arg 1 = respons . encod url ( request . get context path ( ) html upload ) ; arg 2 = sm . get string ( html manag servlet . deploi upload file ) ; arg 3 = sm . get string ( html manag servlet . deploi button ) ; writer . print ( messag format . format ( upload section , arg ) ) ; diagnost section arg = new object 5 ; arg 0 = sm . get string ( html manag servlet . diagnost titl ) ; arg 1 = sm . get string ( html manag servlet . diagnost leak ) ; arg 2 = respons . encod url ( request . get context path ( ) html findleak ) ; arg 3 = sm . get string ( html manag servlet . diagnost leak warn ) ; arg 4 = sm . get string ( html manag servlet . diagnost leak button ) ; writer . print ( messag format . format ( diagnost section , arg ) ) ; server header section arg = new object 7 ; arg 0 = sm . get string ( html manag servlet . server titl ) ; arg 1 = sm . get string ( html manag servlet . server version ) ; arg 2 = sm . get string ( html manag servlet . server jvmversion ) ; arg 3 = sm . get string ( html manag servlet . server jvmvendor ) ; arg 4 = sm . get string ( html manag servlet . server osnam ) ; arg 5 = sm . get string ( html manag servlet . server osvers ) ; arg 6 = sm . get string ( html manag servlet . server osarch ) ; writer . print ( messag format . format ( constant . server header section , arg ) ) ; server row section arg = new object 6 ; arg 0 = server info . get server info ( ) ; arg 1 = system . get properti ( java . runtim . version ) ; arg 2 = system . get properti ( java . vm . vendor ) ; arg 3 = system . get properti ( os . name ) ; arg 4 = system . get properti ( os . version ) ; arg 5 = system . get properti ( os . arch ) ; writer . print ( messag format . format ( constant . server row section , arg ) ) ; html tail section writer . print ( constant . html tail section ) ; finish up respons writer . flush ( ) ; writer . close ( ) ; }
protect class packag web applic , class each super class need check match { link handl type } annot match { link handl type } . param java class void check handl type ( java class java class ) { skip thi we can ( type initi map . size ( ) = = 0 ) return ; choic load class string class name = java class . get class name ( ) ; class clazz = null ; try { clazz = context . get loader ( ) . get class loader ( ) . load class ( class name ) ; } catch ( class def found error e ) { log . debug ( sm . get string ( context config . invalid sci handl type , class name ) , e ) ; return ; } catch ( class found except e ) { log . warn ( sm . get string ( context config . invalid sci handl type , class name ) , e ) ; return ; } ( clazz . annot ( ) ) { skip return ; } boolean match = fals ; ( map . entri class , set servlet contain initi >> entri : type initi map . entri set ( ) ) { ( entri . get kei ( ) . annot ( ) ) { annot entri annot entri = java class . get annot entri ( ) ; ( annot entri annot entri : annot entri ) { ( entri . get kei ( ) . get name ( ) . equal ( get class name ( annot entri . get annot type ( ) ) ) ) { match = true ; break ; } } } els ( entri . get kei ( ) . assign from ( clazz ) ) { match = true ; } ( match ) { ( servlet contain initi sci : entri . get valu ( ) ) { initi class map . get ( sci ) . add ( clazz ) ; } } } }
privat compil load tagfil . class load tag file ( compil compil , string tag file path , tag info tag info , page info parent page info ) throw jasper except { jar resourc tag jar resouc = null ; ( tag file path . start ( meta inf ) ) { tag jar resouc = compil . get compil context ( ) . get tld locat ( tag info . get tag librari ( ) . get uri ( ) ) . get jar resourc ( ) ; } string wrapper uri ; ( tag jar resouc = = null ) { wrapper uri = tag file path ; } els { wrapper uri = tag jar resouc . get entri ( tag file path ) . string ( ) ; } jsp compil context ctxt = compil . get compil context ( ) ; jsp runtim context rctxt = ctxt . get runtim context ( ) ; jsp servlet wrapper wrapper = rctxt . get wrapper ( wrapper uri ) ; synchron ( rctxt ) { ( wrapper = = null ) { wrapper = new jsp servlet wrapper ( ctxt . get servlet context ( ) , ctxt . get option ( ) , tag file path , tag info , ctxt . get runtim context ( ) , tag jar resouc ) ; rctxt . add wrapper ( wrapper uri , wrapper ) ; us same classload classpath compil tag file wrapper . get jsp engin context ( ) . set class loader ( ctxt . get class loader ( ) ) ; wrapper . get jsp engin context ( ) . set class path ( ctxt . get class path ( ) ) ; } els { make sure jsp compil context get latest tag info tag file . tag info instanc wa creat last time tag file wa scan direct , tag file mai have been modifi sinc . wrapper . get jsp engin context ( ) . set tag info ( tag info ) ; } class tag clazz ; int trip count = wrapper . inc trip count ( ) ; try { ( trip count 0 ) { when trip count greater than zero , circular depend exist . circularli depend tag file compil prototyp mode , avoid infinit recurs . jsp servlet wrapper temp wrapper = new jsp servlet wrapper ( ctxt . get servlet context ( ) , ctxt . get option ( ) , tag file path , tag info , ctxt . get runtim context ( ) , ctxt . get tag file jar resourc ( tag file path ) ) ; tag clazz = temp wrapper . load tag file prototyp ( ) ; temp vector . add ( temp wrapper . get jsp engin context ( ) . get compil ( ) ) ; } els { tag clazz = wrapper . load tag file ( ) ; } } final { wrapper . dec trip count ( ) ; } can onli obtain from tag instanc . try { object tag = tag clazz . new instanc ( ) ; ( tag instanceof jsp sourc depend ) { iter string iter = ( ( jsp sourc depend ) tag ) . get depend ( ) . iter ( ) ; while ( iter . ha next ( ) ) { parent page info . add depend ( iter . next ( ) ) ; } } } catch ( except e ) { ignor error } return tag clazz ; } }
protect scan web . xml file appli web applic merg them us rule defin spec . global web . xml file , where duplic configur , most specif level win . ie applic s web . xml take preced over host level global web . xml file . void web config ( ) { web xml web xml = creat web xml ( ) ; pars global web . xml present input sourc global web xml = get global web xml sourc ( ) ; ( global web xml = = null ) { thi unusu enough log log . info ( sm . get string ( context config . default miss ) ) ; } els { pars web xml ( global web xml , web xml , fals ) ; } pars host level web . xml present addit apart from welcom page web xml . set replac welcom file ( true ) ; input sourc host web xml = get host web xml sourc ( ) ; pars web xml ( host web xml , web xml , fals ) ; pars context level web . xml web xml . set replac welcom file ( true ) ; input sourc context web xml = get context web xml sourc ( ) ; pars web xml ( context web xml , web xml , fals ) ; assum 0 safe what requir thi case doubl web xml version = 0 ; ( web xml . get version ( ) = null ) { web xml version = doubl . pars doubl ( web xml . get version ( ) ) ; } ( web xml version = 3 ) { order import here step 1 . identifi all jar packag applic jar have web fragment . xml pars thi point . map string , web xml fragment = process jar web fragment ( ) ; onli need process fragment annot metadata complet set web xml order fragment = null ; ( web xml . metadata complet ( ) ) { step 2 . order fragment . order fragment = web xml . order web fragment ( web xml , fragment ) ; step 3 . look servlet contain initi implement ok = process servlet contain initi ( order fragment ) ; thi add ani match class type initi map ( ok ) { url webinf class ; try { webinf class = context . get servlet context ( ) . get resourc ( web inf class ) ; process annot url ( webinf class , web xml ) ; } catch ( malform urlexcept e ) { log . error ( sm . get string ( context config . webinf class url ) , e ) ; } } thi add ani match class type initi map ( ok ) { process annot ( order fragment ) ; } file . ( ok ) { ok = web xml . merg ( order fragment ) ; } step 6 . 5 convert explicitli mention jsp servlet ( fals ) { convert jsp ( web xml ) ; } step 7 . appli merg web . xml context ( ok ) { web xml . configur context ( context ) ; step 7a . make merg web . xml avail other compon , specif jasper , save those compon from have re gener . todo us servlet contain initi jasper string merg web xml = web xml . xml ( ) ; context . get servlet context ( ) . set attribut ( org . apach . tomcat . util . scan . constant . merg web xml , merg web xml ) ; ( context . get log effect web xml ( ) ) { log . info ( web . xml : n merg web xml ) ; } } } els { ok = true ; } step 8 . look static resourc packag jar ( ok ) { spec doe defin order . us order jar follow remain jar set web xml resourc jar = new link hash set web xml ( ) ; ( order fragment = null ) { ( web xml fragment : order fragment ) { resourc jar . add ( fragment ) ; } } ( web xml fragment : fragment . valu ( ) ) { ( resourc jar . contain ( fragment ) ) { resourc jar . add ( fragment ) ; } } process resourc jar ( resourc jar ) ; } complet ( web xml . metadata complet ( ) ) { context ( ok ) { ( map . entri servlet contain initi , set class >> entri : initi class map . entri set ( ) ) { ( entri . get valu ( ) . empti ( ) ) { context . add servlet contain initi ( entri . get kei ( ) , null ) ; } els { context . add servlet contain initi ( entri . get kei ( ) , entri . get valu ( ) ) ; } } } } } els { appli unmerg web . xml context convert jsp ( web xml ) ; web xml . configur context ( context ) ; } }
public set name resourc thi web applic . param name resourc new name resourc void set name resourc ( name resourc name resourc ) { process properti set chang name resourc old name resourc = thi . name resourc ; thi . name resourc = name resourc ; name resourc . set contain ( thi ) ; support . fire properti chang ( name resourc , old name resourc , thi . name resourc ) ; unregist ( onam name resourc ) ; onam name resourc = regist ( name resourc , type = name resourc , get object kei properti name onli ( ) ) ; }
protect scan web . xml file appli web applic merg them us rule defin spec . global web . xml file , where duplic configur , most specif level win . ie applic s web . xml take preced over host level global web . xml file . void web config ( ) { web xml web xml = creat web xml ( ) ; pars global web . xml present input sourc global web xml = get global web xml sourc ( ) ; ( global web xml = = null ) { thi unusu enough log log . info ( sm . get string ( context config . default miss ) ) ; } els { pars web xml ( global web xml , web xml , fals ) ; } pars host level web . xml present addit apart from welcom page web xml . set replac welcom file ( true ) ; input sourc host web xml = get host web xml sourc ( ) ; pars web xml ( host web xml , web xml , fals ) ; pars context level web . xml web xml . set replac welcom file ( true ) ; input sourc context web xml = get context web xml sourc ( ) ; pars web xml ( context web xml , web xml , fals ) ; assum 0 safe what requir thi case doubl web xml version = 0 ; ( web xml . get version ( ) = null ) { web xml version = doubl . pars doubl ( web xml . get version ( ) ) ; } ( web xml version = 3 web xml . metadata complet ( ) ) { order import here step 1 . identifi all jar packag applic jar have web fragment . xml pars thi point . map string , web xml fragment = process jar web fragment ( ) ; step 2 . order fragment . set web xml order fragment = web xml . order web fragment ( web xml , fragment ) ; step 3 . look servlet contain initi implement ok = process servlet contain initi ( order fragment ) ; thi add ani match class type initi map ( ok ) { url webinf class ; try { webinf class = context . get servlet context ( ) . get resourc ( web inf class ) ; process annot url ( webinf class , web xml ) ; } catch ( malform urlexcept e ) { log . error ( sm . get string ( context config . webinf class url ) , e ) ; } } thi add ani match class type initi map ( ok ) { process annot ( order fragment ) ; } step 6 . merg web fragment . xml file main web . xml file . ( ok ) { ok = web xml . merg ( order fragment ) ; } step 6 . 5 convert explicitli mention jsp servlet ( fals ) { convert jsp ( web xml ) ; } step 7 . appli merg web . xml context ( ok ) { web xml . configur context ( context ) ; step 7a . make merg web . xml avail other compon , specif jasper , save those compon from have re gener . todo us servlet contain initi jasper string merg web xml = web xml . xml ( ) ; context . get servlet context ( ) . set attribut ( org . apach . tomcat . util . scan . constant . merg web xml , merg web xml ) ; ( context . get log effect web xml ( ) ) { log . info ( web . xml : n merg web xml ) ; } } step 8 . look static resourc packag jar ( ok ) { spec doe defin order . us order jar follow remain jar set web xml resourc jar = new link hash set web xml ( ) ; ( web xml fragment : order fragment ) { resourc jar . add ( fragment ) ; } ( web xml fragment : fragment . valu ( ) ) { ( resourc jar . contain ( fragment ) ) { resourc jar . add ( fragment ) ; } } process resourc jar ( resourc jar ) ; } context ( ok ) { ( map . entri servlet contain initi , set class >> entri : initi class map . entri set ( ) ) { ( entri . get valu ( ) . empti ( ) ) { context . add servlet contain initi ( entri . get kei ( ) , null ) ; } els { context . add servlet contain initi ( entri . get kei ( ) , entri . get valu ( ) ) ; } } } } els { appli unmerg web . xml context convert jsp ( web xml ) ; web xml . configur context ( context ) ; } }
public get enclos jsp writer . return enclos jsp writer pass construct time jsp writer get enclos writer ( ) { return enclos writer ; }	public enumer attribut . return enumer attribut tag data java . util . enumer string get attribut ( ) { return attribut . kei ( ) ; }	public signatur function . return signatur function string get function signatur ( ) { return function signatur ; }	public get local valid messag . return valid messag string get messag ( ) { return messag ; }	return string represent thi tag attribut info , suitabl debug purpos . return string represent thi tag attribut info overrid public string string ( ) { string builder b = new string builder ( 64 ) ; b . append ( name = name ) ; b . append ( type = type ) ; b . append ( req time = req time ) ; b . append ( requir = requir ) ; b . append ( fragment = fragment ) ; b . append ( defer valu = defer valu ) ; b . append ( expect type name = expect type name ) ; b . append ( defer method = defer method ) ; b . append ( method signatur = method signatur ) ; return b . string ( ) ; }	public return inform about thi tag , pars from direct tag file . return tag info object contain inform about thi tag tag info get tag info ( ) { return tag info ; }	public final get tag info thi class . return taginfo instanc thi instanc extend tag info get tag info ( ) { return tag info ; }	public bodi lt ; scope gt ; element . return scope give variabl . nest scope return defin tld . int get scope ( ) { return scope ; }	public return lexic scope variabl . return lexic scope variabl , either begin , end , nest . see begin see end see nest int get scope ( ) { return scope ; }
public boolean authent ( request request , http servlet respons respons , login config config ) throw ioexcept { have we alreadi authent someon princip princip = request . get user princip ( ) ; string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( princip = null ) { ( log . debug enabl ( ) ) log . debug ( alreadi authent princip . get name ( ) ) ; associ session ani exist sso session ( sso id = null ) associ ( sso id , request . get session intern ( true ) ) ; return ( true ) ; } sso session against which we can try reauthent ( sso id = null ) { ( log . debug enabl ( ) ) log . debug ( sso id sso id set ; attempt reauthent ) ; try reauthent us data cach sso . thi fail , either origin sso logon wa digest ssl ( which we can t reauthent ourselv becaus cach usernam password ) , realm deni user s reauthent some reason . either case we have prompt user logon ( reauthent from sso ( sso id , request ) ) return true ; } valid ani credenti alreadi includ thi request string usernam = null ; string password = null ; messag byte author = request . get coyot request ( ) . get mime header ( ) . get valu ( author ) ; ( author = null ) { author . byte ( ) ; byte chunk author bc = author . get byte chunk ( ) ; ( author bc . start ignor case ( basic , 0 ) ) { author bc . set offset ( author bc . get offset ( ) 6 ) ; fixm : add trim author bc . trim ( ) ; char chunk author cc = author . get char chunk ( ) ; base64 . decod ( author bc , author cc ) ; get usernam password int colon = author cc . index ( : ) ; ( colon 0 ) { usernam = author cc . string ( ) ; } els { char buf = author cc . get buffer ( ) ; usernam = new string ( buf , 0 , colon ) ; password = new string ( buf , colon 1 , author cc . get end ( ) colon 1 ) ; } author bc . set offset ( author bc . get offset ( ) 6 ) ; } princip = context . get realm ( ) . authent ( usernam , password ) ; ( princip = null ) { regist ( request , respons , princip , constant . basic method , usernam , password ) ; return ( true ) ; } } string builder valu = new string builder ( 16 ) ; valu . append ( basic realm = ) ; ( config . get realm name ( ) = = null ) { valu . append ( realm name ) ; } els { valu . append ( config . get realm name ( ) ) ; } valu . append ( ) ; respons . set header ( auth header name , valu . string ( ) ) ; respons . send error ( http servlet respons . sc unauthor ) ; return ( fals ) ; }	authent user make thi request , base specifi login configur . return code true code ani specifi constraint ha been satisfi , code fals code we have creat respons challeng alreadi . param request request we ar process param respons respons we ar creat param config login configur describ how authent should perform except ioexcept input output error occur overrid public boolean authent ( request request , http servlet respons respons , login config config ) throw ioexcept { have we alreadi authent someon princip princip = request . get user princip ( ) ; string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( princip = null ) { ( log . debug enabl ( ) ) log . debug ( alreadi authent princip . get name ( ) ) ; associ session ani exist sso session order get coordin session invalid logout string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( sso id = null ) associ ( sso id , request . get session intern ( true ) ) ; return ( true ) ; } note : we don t try reauthent us ani exist sso session , becaus onli work origin authent wa basic form , which ar less secur than digest auth type specifi thi webapp uncom below allow previou form basic authent authent user thi webapp todo make thi configur attribut ( singl sign ) sso session against which we can try reauthent ( sso id = null ) { ( log . debug enabl ( ) ) log . debug ( sso id sso id set ; attempt reauthent ) ; try reauthent us data cach sso . thi fail , either origin sso logon wa digest ssl ( which we can t reauthent ourselv becaus cach usernam password ) , realm deni user s reauthent some reason . either case we have prompt user logon ( reauthent from sso ( sso id , request ) ) return true ; } valid ani credenti alreadi includ thi request string author = request . get header ( author ) ; ( author = null ) { princip = find princip ( request , author , context . get realm ( ) ) ; ( princip = null ) { string usernam = pars usernam ( author ) ; regist ( request , respons , princip , constant . digest method , usernam , null ) ; return ( true ) ; } } send unauthor respons appropri challeng next , gener n onc token ( token which suppos uniqu ) . string n onc = gener nonc ( request ) ; set authent header ( request , respons , config , n onc ) ; respons . send error ( http servlet respons . sc unauthor ) ; hre . flush buffer ( ) ; return ( fals ) ; }	authent user make thi request , base specifi login configur . return code true code ani specifi constraint ha been satisfi , code fals code we have creat respons challeng alreadi . param request request we ar process param respons respons we ar creat param config login configur describ how authent should perform except ioexcept input output error occur overrid public boolean authent ( request request , http servlet respons respons , login config config ) throw ioexcept { refer object we need later session session = null ; have we alreadi authent someon princip princip = request . get user princip ( ) ; string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( princip = null ) { ( log . debug enabl ( ) ) log . debug ( alreadi authent princip . get name ( ) ) ; associ session ani exist sso session ( sso id = null ) associ ( sso id , request . get session intern ( true ) ) ; return ( true ) ; } sso session against which we can try reauthent ( sso id = null ) { ( log . debug enabl ( ) ) log . debug ( sso id sso id set ; attempt reauthent ) ; either case we have prompt user logon ( reauthent from sso ( sso id , request ) ) return true ; } have we authent thi user befor have cach disabl ( cach ) { session = request . get session intern ( true ) ; ( log . debug enabl ( ) ) log . debug ( check reauthent session session ) ; string usernam = ( string ) session . get note ( constant . sess usernam note ) ; string password = ( string ) session . get note ( constant . sess password note ) ; ( ( usernam = null ) ( password = null ) ) { ( log . debug enabl ( ) ) log . debug ( reauthent usernam usernam ) ; princip = context . get realm ( ) . authent ( usernam , password ) ; ( princip = null ) { session . set note ( constant . form princip note , princip ) ; ( match request ( request ) ) { regist ( request , respons , princip , constant . form method , usernam , password ) ; return ( true ) ; } } ( log . debug enabl ( ) ) log . debug ( reauthent fail , proce normal ) ; } } authent so , forward origin request instead . ( match request ( request ) ) { session = request . get session intern ( true ) ; ( log . debug enabl ( ) ) log . debug ( restor request from session session . get id intern ( ) ) ; princip = ( princip ) session . get note ( constant . form princip note ) ; regist ( request , respons , princip , constant . form method , ( string ) session . get note ( constant . sess usernam note ) , ( string ) session . get note ( constant . sess password note ) ) ; password session , so remov them ( cach ) { session . remov note ( constant . sess usernam note ) ; session . remov note ( constant . sess password note ) ; } ( restor request ( request , session ) ) { ( log . debug enabl ( ) ) log . debug ( proce restor request ) ; return ( true ) ; } els { ( log . debug enabl ( ) ) log . debug ( restor origin request fail ) ; respons . send error ( http servlet respons . sc bad request ) ; return ( fals ) ; } } acquir refer object we need evalu messag byte uri mb = messag byte . new instanc ( ) ; char chunk uri cc = uri mb . get char chunk ( ) ; uri cc . set limit ( 1 ) ; string context path = request . get context path ( ) ; string request uri = request . get decod request uri ( ) ; thi action request from login page boolean login action = request uri . start ( context path ) request uri . end ( constant . form action ) ; save thi request redirect form login page ( login action ) { session = request . get session intern ( true ) ; ( log . debug enabl ( ) ) log . debug ( save request session session . get id intern ( ) ) ; try { save request ( request , session ) ; } catch ( ioexcept ioe ) { log . debug ( request bodi too big save dure authent ) ; respons . send error ( http servlet respons . sc forbidden , sm . get string ( authent . request bodi too big ) ) ; return ( fals ) ; } forward login page ( request , respons , config ) ; return ( fals ) ; } ye acknowledg request , valid specifi credenti redirect error page thei ar correct request . get respons ( ) . send acknowledg ( ) ; realm realm = context . get realm ( ) ; ( charact encod = null ) { request . set charact encod ( charact encod ) ; } string usernam = request . get paramet ( constant . form usernam ) ; string password = request . get paramet ( constant . form password ) ; ( log . debug enabl ( ) ) log . debug ( authent usernam usernam ) ; princip = realm . authent ( usernam , password ) ; ( princip = = null ) { forward error page ( request , respons , config ) ; return ( fals ) ; } ( log . debug enabl ( ) ) log . debug ( authent usernam wa success ) ; ( session = = null ) session = request . get session intern ( fals ) ; ( session = = null ) { ( contain log . debug enabl ( ) ) contain log . debug ( user took so long log session expir ) ; respons . send error ( http servlet respons . sc request timeout , sm . get string ( authent . session expir ) ) ; return ( fals ) ; } save authent princip our session session . set note ( constant . form princip note , princip ) ; save usernam password well session . set note ( constant . sess usernam note , usernam ) ; session . set note ( constant . sess password note , password ) ; redirect user origin request uri ( which caus origin request restor ) request uri = save request url ( session ) ; ( log . debug enabl ( ) ) log . debug ( redirect origin request uri ) ; ( request uri = = null ) respons . send error ( http servlet respons . sc bad request , sm . get string ( authent . formlogin ) ) ; els respons . send redirect ( respons . encod redirect url ( request uri ) ) ; return ( fals ) ; }	authent user make thi request , base specifi login configur . return code true code ani specifi constraint ha been satisfi , code fals code we have creat respons challeng alreadi . param request request we ar process param respons respons we ar popul param config login configur describ how authent should perform except ioexcept input output error occur overrid public boolean authent ( request request , http servlet respons respons , login config config ) throw ioexcept { associ thi request s session sso would allow coordin session invalid , should session webapp user didn t log invalid when anoth session log out string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( sso id = null ) associ ( sso id , get session ( request , true ) ) ; ( contain log . debug enabl ( ) ) contain log . debug ( user authent requir ) ; return ( true ) ; }	authent user check exist certif chain , option ask trust manag valid we trust thi user . param request request we ar process param respons respons we ar creat param config login configur describ how authent should perform except ioexcept input output error occur overrid public boolean authent ( request request , http servlet respons respons , login config config ) throw ioexcept { have we alreadi authent someon princip princip = request . get user princip ( ) ; string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( princip = null ) { ( contain log . debug enabl ( ) ) contain log . debug ( alreadi authent princip . get name ( ) ) ; associ session ani exist sso session order get coordin session invalid logout string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( sso id = null ) associ ( sso id , request . get session intern ( true ) ) ; return ( true ) ; } retriev certif chain thi client ( contain log . debug enabl ( ) ) contain log . debug ( look up certif ) ; x509certif cert = ( x509certif ) request . get attribut ( global . certif attr ) ; ( ( cert = = null ) ( cert . length 1 ) ) { request . get coyot request ( ) . action ( action code . req ssl certif , null ) ; cert = ( x509certif ) request . get attribut ( global . certif attr ) ; } ( ( cert = = null ) ( cert . length 1 ) ) { ( contain log . debug enabl ( ) ) contain log . debug ( certif includ thi request ) ; respons . send error ( http servlet respons . sc unauthor , sm . get string ( authent . certif ) ) ; return ( fals ) ; } authent specifi certif chain princip = context . get realm ( ) . authent ( cert ) ; ( princip = = null ) { ( contain log . debug enabl ( ) ) contain log . debug ( realm . authent ( ) return fals ) ; respons . send error ( http servlet respons . sc unauthor , sm . get string ( authent . unauthor ) ) ; return ( fals ) ; } cach princip ( request ) record thi authent regist ( request , respons , princip , constant . cert method , null , null ) ; return ( true ) ; }	public perform access control base specifi author constraint . return code true code thi constraint satisfi process should continu , code fals code otherwis . param request request we ar process param respons respons we ar creat param constraint secur constraint we ar enforc param context context which client thi class attach . except ioexcept input output error occur boolean ha resourc permiss ( request request , respons respons , secur constraint constraint , context context ) throw ioexcept { ( constraint = = null constraint . length = = 0 ) return ( true ) ; specif allow access form login form error page j secur check action login config config = context . get login config ( ) ; ( ( config = null ) ( constant . form method . equal ( config . get auth method ( ) ) ) ) { string request uri = request . get request path mb ( ) . string ( ) ; string login page = config . get login page ( ) ; ( login page . equal ( request uri ) ) { ( log . debug enabl ( ) ) log . debug ( allow access login page login page ) ; return ( true ) ; } string error page = config . get error page ( ) ; ( error page . equal ( request uri ) ) { ( log . debug enabl ( ) ) log . debug ( allow access error page error page ) ; return ( true ) ; } ( request uri . end ( constant . form action ) ) { ( log . debug enabl ( ) ) log . debug ( allow access usernam password submiss ) ; return ( true ) ; } } which user princip have we alreadi authent princip princip = request . get princip ( ) ; boolean statu = fals ; boolean denyfromal = fals ; ( int i = 0 ; i constraint . length ; i ) { secur constraint constraint = constraint i ; string role ; ( constraint . get all role ( ) ) { mean all role defin web . xml role = request . get context ( ) . find secur role ( ) ; } els { role = constraint . find auth role ( ) ; } ( role = = null ) role = new string 0 ; ( log . debug enabl ( ) ) log . debug ( check role princip ) ; ( role . length = = 0 constraint . get all role ( ) ) { ( constraint . get auth constraint ( ) ) { ( log . debug enabl ( ) ) log . debug ( role ) ; list role mean access all statu = fals ; denyfromal = true ; break ; } ( log . debug enabl ( ) ) log . debug ( pass all access ) ; statu = true ; } els ( princip = = null ) { ( log . debug enabl ( ) ) log . debug ( user authent , cannot grant access ) ; } els { ( int j = 0 ; j role . length ; j ) { ( ha role ( princip , role j ) ) { statu = true ; ( log . debug enabl ( ) ) log . debug ( role found : role j ) ; } } } } }	return code true code specifi princip ha specifi secur role , within context thi realm ; otherwis return code fals code . thi implement return code true code code user code ha role , ani code group code code user code member ha role . param princip princip whom role check param role secur role check overrid public boolean ha role ( princip princip , string role ) { ( princip instanceof gener princip ) { gener princip gp = ( gener princip ) princip ; ( gp . get user princip ( ) instanceof user ) { princip = gp . get user princip ( ) ; } } ( ( princip instanceof user ) ) { plai nice sso mix realm return super . ha role ( princip , role ) ; } ( . equal ( role ) ) { return true ; } els ( role = = null ) { return fals ; } user user = ( user ) princip ; role dbrole = databas . find role ( role ) ; ( dbrole = = null ) { return fals ; } ( user . role ( dbrole ) ) { return true ; } iter group group = user . get group ( ) ; while ( group . ha next ( ) ) { group group = group . next ( ) ; ( group . role ( dbrole ) ) { return true ; } } return fals ; }	return code true code authent user princip possess specifi role name . param role role name valid overrid public boolean user role ( string role ) { have we got authent princip all ( user princip = = null ) return fals ; identifi realm we us check role assign ( context = = null ) return fals ; realm realm = context . get realm ( ) ; ( realm = = null ) return fals ; check role alia defin secur role ref element ( wrapper = null ) { string real role = wrapper . find secur refer ( role ) ; ( ( real role = null ) realm . ha role ( user princip , real role ) ) return true ; } check role defin directli secur role return ( realm . ha role ( user princip , role ) ) ; }	{ inherit doc } overrid public void login ( string usernam , string password ) throw servlet except { ( get auth type ( ) = null get remot user ( ) = null get user princip ( ) = null ) { throw new servlet except ( sm . get string ( coyot request . alreadi authent ) ) ; } login config config = context . get login config ( ) ; ( config = = null ) { throw new servlet except ( sm . get string ( coyot request . login config ) ) ; } string auth method = config . get auth method ( ) ; ( basic auth . equal ( auth method ) form auth . equal ( auth method ) digest auth . equal ( auth method ) ) { method support user name password authent realm realm = context . get realm ( ) ; princip princip = realm . authent ( usernam , password ) ; ( princip = = null ) { throw new servlet except ( sm . get string ( coyot request . auth fail , usernam ) ) ; } assum we have non null login config we must have authent context . get authent ( ) . regist ( thi , get respons ( ) , princip , auth method , usernam , password ) ; } els { throw new servlet except ( coyot request . password login ) ; } }	{ inherit doc } overrid public collect part get part ( ) throw ioexcept , illeg state except , servlet except { pars part ( ) ; ( part pars except = null ) { ( part pars except instanceof ioexcept ) { throw ( ioexcept ) part pars except ; } els ( part pars except instanceof illeg state except ) { throw ( illeg state except ) part pars except ; } els ( part pars except instanceof servlet except ) { throw ( servlet except ) part pars except ; } } return part ; }	public regist authent princip authent type our request , current session ( ) , our singl sign valv , . set appropri cooki return . param request servlet request we ar process param respons servlet respons we ar gener param princip authent princip regist param auth type authent type regist param usernam usernam us authent ( ani ) param password password us authent ( ani ) void regist ( request request , http servlet respons respons , princip princip , string auth type , string usernam , string password ) { ( log . debug enabl ( ) ) log . debug ( authent princip . get name ( ) type auth type ) ; cach authent inform our request request . set auth type ( auth type ) ; request . set user princip ( princip ) ; session session = request . get session intern ( fals ) ; ( session = null chang session id authent ) { manag manag = request . get context ( ) . get manag ( ) ; manag . chang session id ( session ) ; request . chang session id ( session . get id ( ) ) ; } cach authent inform our session , ani ( cach ) { ( session = null ) { session . set auth type ( auth type ) ; session . set princip ( princip ) ; ( usernam = null ) session . set note ( constant . sess usernam note , usernam ) ; els session . remov note ( constant . sess usernam note ) ; ( password = null ) session . set note ( constant . sess password note , password ) ; els session . remov note ( constant . sess password note ) ; } } construct cooki return client ( sso = = null ) return ; onli creat new sso entri sso did alreadi set note exist entri ( would do subsequ request digest ssl authent context ) string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( sso id = = null ) { construct cooki return client sso id = gener session id ( ) ; cooki cooki = new cooki ( constant . singl sign cooki , sso id ) ; cooki . set max ag ( 1 ) ; cooki . set path ( ) ; bugzilla 41217 cooki . set secur ( request . secur ( ) ) ; bugzilla 34724 string sso domain = sso . get cooki domain ( ) ; ( sso domain = null ) { cooki . set domain ( sso domain ) ; } configur http onli sso cooki us same rule session cooki ( request . get servlet context ( ) . get session cooki config ( ) . http onli ( ) request . get context ( ) . get us http onli ( ) ) { cooki . set http onli ( true ) ; } respons . add cooki ( cooki ) ; regist thi princip our sso valv sso . regist ( sso id , princip , auth type , usernam , password ) ; request . set note ( constant . req ssoid note , sso id ) ; } els { ( princip = = null ) { regist programmat logout sso . deregist ( sso id ) ; return ; } els { updat sso session latest authent data sso . updat ( sso id , princip , auth type , usernam , password ) ; } } sso entri never clear we don t associ session ( session = = null ) session = request . get session intern ( true ) ; sso . associ ( sso id , session ) ; }	public set global jndi name code user databas code resourc we us . param resourc name new global jndi name void set resourc name ( string resourc name ) { thi . resourc name = resourc name ; }
privat void add inject target ( inject resourc , map string , map string , string >> inject map ) { list inject target inject target = resourc . get inject target ( ) ; ( inject target = null inject target . size ( ) 0 ) { string jndi name = resourc . get name ( ) ; ( inject target inject target : inject target ) { string clazz = inject target . get target class ( ) ; map string , string inject = inject map . get ( clazz ) ; ( inject = = null ) { inject = new hash map string , string ( ) ; inject map . put ( clazz , inject ) ; } inject . put ( inject target . get target name ( ) , jndi name ) ; } } }	privat map string , map string , string >> build inject map ( name resourc name resourc ) { map string , map string , string >> inject map = new hash map string , map string , string >> ( ) ; ( inject resourc : name resourc . find local ejb ( ) ) { add inject target ( resourc , inject map ) ; } ( inject resourc : name resourc . find ejb ( ) ) { add inject target ( resourc , inject map ) ; } ( inject resourc : name resourc . find environ ( ) ) { add inject target ( resourc , inject map ) ; } ( inject resourc : name resourc . find messag destin ref ( ) ) { add inject target ( resourc , inject map ) ; } ( inject resourc : name resourc . find resourc env ref ( ) ) { add inject target ( resourc , inject map ) ; } ( inject resourc : name resourc . find resourc ( ) ) { add inject target ( resourc , inject map ) ; } ( inject resourc : name resourc . find servic ( ) ) { add inject target ( resourc , inject map ) ; } return inject map ; }	protect void set new servlet context listen allow ( boolean allow ) { thi . new servlet context listen allow = allow ; }	public return name context s initi paramet , empti enumer context ha initi paramet . enumer string get init paramet name ( ) { merg paramet ( ) ; return ( new enumer string ( paramet . kei set ( ) ) ) ; }	overrid public boolean set init paramet ( string name , string valu ) { merg paramet ( ) ; ( paramet . contain kei ( name ) ) { return fals ; } paramet . put ( name , valu ) ; return true ; }
public servlet get servlet ( ) throw servlet except { ( reload ) { synchron ( thi ) { differ page , same page . ( reload ) { thi maintain origin protocol . destroi ( ) ; servlet servlet = null ; try { instanc manag instanc manag = instanc manag factori . get instanc manag ( config ) ; servlet = ( servlet ) instanc manag . new instanc ( ctxt . get fqcn ( ) , ctxt . get jsp loader ( ) ) ; } catch ( illeg access except e ) { throw new jasper except ( e ) ; } catch ( instanti except e ) { throw new jasper except ( e ) ; } catch ( except e ) { throw new jasper except ( e ) ; } servlet . init ( config ) ; ( first time ) { ctxt . get runtim context ( ) . increment jsp reload count ( ) ; } servlet = servlet ; reload = fals ; } } } return servlet ; }	public get list file current page ha sourc depend . java . util . list string get depend ( ) { try { object target ; ( tag file ) { ( reload ) { tag handler class = ctxt . load ( ) ; reload = fals ; } target = tag handler class . new instanc ( ) ; } els { target = get servlet ( ) ; } ( target = null target instanceof jsp sourc depend ) { return ( ( jsp sourc depend ) target ) . get depend ( ) ; } } catch ( throwabl ex ) { except util . handl throwabl ( ex ) ; } return null ; }
public static final get http format specifi date . string format date ( long valu , date format thread localformat ) { long long valu = new long ( valu ) ; string cach date = format cach . get ( long valu ) ; ( cach date = null ) return cach date ; string new date = null ; date date valu = new date ( valu ) ; ( thread localformat = null ) { new date = thread localformat . format ( date valu ) ; updat format cach ( long valu , new date ) ; } els { synchron ( format cach ) { synchron ( format ) { new date = format . format ( date valu ) ; } updat format cach ( long valu , new date ) ; } } return new date ; }
protect ajp apr processor creat processor ( ) { ajp apr processor processor = new ajp apr processor ( proto . packet size , proto . endpoint ) ; processor . set adapt ( proto . adapt ) ; processor . set tomcat authent ( proto . tomcat authent ) ; processor . set requir secret ( proto . requir secret ) ; regist ( processor ) ; return processor ; }	protect ajp processor creat processor ( ) { ajp processor processor = new ajp processor ( proto . packet size , proto . endpoint ) ; processor . set adapt ( proto . adapt ) ; processor . set tomcat authent ( proto . tomcat authent ) ; processor . set requir secret ( proto . requir secret ) ; processor . set keep aliv timeout ( proto . keep aliv timeout ) ; regist ( processor ) ; return processor ; }	protect void unregist ( ajp apr processor processor ) { ( proto . get domain ( ) = null ) { synchron ( thi ) { try { request info rp = processor . get request ( ) . get request processor ( ) ; rp . set global processor ( null ) ; object name rp name = rp . get rp name ( ) ; ( log . debug enabl ( ) ) { log . debug ( unregist rp name ) ; } registri . get registri ( null , null ) . unregist compon ( rp name ) ; rp . set rp name ( null ) ; } catch ( except e ) { log . warn ( error unregist request , e ) ; } } } }	protect void unregist ( ajp processor processor ) { ( proto . get domain ( ) = null ) { synchron ( thi ) { try { request info rp = processor . get request ( ) . get request processor ( ) ; rp . set global processor ( null ) ; object name rp name = rp . get rp name ( ) ; ( log . debug enabl ( ) ) { log . debug ( unregist rp name ) ; } registri . get registri ( null , null ) . unregist compon ( rp name ) ; rp . set rp name ( null ) ; } catch ( except e ) { log . warn ( error unregist request , e ) ; } } } }	overrid public socket state async dispatch ( socket wrapper long socket , socket statu statu ) { ajp apr processor result = connect . get ( socket ) ; socket state state = socket state . close ; ( result = null ) { call appropri event try { state = result . async dispatch ( socket , statu ) ; } debug . catch ( throwabl e ) { except util . handl throwabl ( e ) ; ani other except error odd . here we log error level , so show up even less than verbos log . ajp apr protocol . log . error ( sm . get string ( ajpprotocol . proto . error ) , e ) ; } final { ( state = = socket state . long result . async ( ) ) { state = result . async post process ( ) ; } ( state = socket state . long state = socket state . async end ) { connect . remov ( socket ) ; recycl processor . offer ( result ) ; ( state = = socket state . open ) { proto . endpoint . get poller ( ) . add ( socket . get socket ( ) . long valu ( ) ) ; } } } } return state ; }	start protocol overrid public void init ( ) throw except { endpoint . set name ( get name ( ) ) ; endpoint . set handler ( c handler ) ; endpoint . set us sendfil ( fals ) ; try { endpoint . init ( ) ; } catch ( except ex ) { log . error ( sm . get string ( ajpprotocol . endpoint . initerror ) , ex ) ; throw ex ; } ( log . info enabl ( ) ) { log . info ( sm . get string ( ajpprotocol . init , get name ( ) ) ) ; } }	start protocol overrid public void init ( ) throw except { endpoint . set name ( get name ( ) ) ; endpoint . set handler ( c handler ) ; try { endpoint . init ( ) ; } catch ( except ex ) { log . error ( sm . get string ( ajpprotocol . endpoint . initerror ) , ex ) ; throw ex ; } ( log . info enabl ( ) ) { log . info ( sm . get string ( ajpprotocol . init , get name ( ) ) ) ; } }	overrid public void start ( ) throw except { ( thi . domain = null ) { try { tp onam = new object name ( domain : type = thread pool , name = get name ( ) ) ; registri . get registri ( null , null ) . regist compon ( endpoint , tp onam , null ) ; } catch ( except e ) { log . error ( can t regist threadpool ) ; } rg onam = new object name ( domain : type = global request processor , name = get name ( ) ) ; registri . get registri ( null , null ) . regist compon ( c handler . global , rg onam , null ) ; } try { endpoint . start ( ) ; } catch ( except ex ) { log . error ( sm . get string ( ajpprotocol . endpoint . starterror ) , ex ) ; throw ex ; } ( log . info enabl ( ) ) log . info ( sm . get string ( ajpprotocol . start , get name ( ) ) ) ; }	overrid public void start ( ) throw except { ( thi . domain = null ) { try { tp onam = new object name ( domain : type = thread pool , name = get name ( ) ) ; registri . get registri ( null , null ) . regist compon ( endpoint , tp onam , null ) ; } catch ( except e ) { log . error ( can t regist threadpool ) ; } rg onam = new object name ( domain : type = global request processor , name = get name ( ) ) ; registri . get registri ( null , null ) . regist compon ( c handler . global , rg onam , null ) ; } try { endpoint . start ( ) ; } catch ( except ex ) { log . error ( sm . get string ( ajpprotocol . endpoint . starterror ) , ex ) ; throw ex ; } ( log . info enabl ( ) ) log . info ( sm . get string ( ajpprotocol . start , get name ( ) ) ) ; }
protect static inject resourc specifi field . param context jndi context extract valu from param instanc object inject param field field target inject param name jndi name valu bound under param clazz class annot defin throw illeg access except field inaccess throw javax . name . name except valu access name context void lookup field resourc ( context context , object instanc , field field , string name , class clazz ) throw name except , illeg access except { object lookedup resourc ; boolean access ; ( ( name = null ) ( name . length ( ) 0 ) ) { lookedup resourc = context . lookup ( name ) ; } els { lookedup resourc = context . lookup ( clazz . get name ( ) field . get name ( ) ) ; } access = field . access ( ) ; field . set access ( true ) ; field . set ( instanc , lookedup resourc ) ; field . set access ( access ) ; }	protect static inject resourc specifi method . param context jndi context extract valu from param instanc object inject param method field target inject param name jndi name valu bound under param clazz class annot defin throw illeg access except method inaccess throw javax . name . name except valu access name context throw java . lang . reflect . invoc target except setter call fail void lookup method resourc ( context context , object instanc , method method , string name , class clazz ) throw name except , illeg access except , invoc target except { ( method . get name ( ) . start ( set ) method . get name ( ) . length ( ) 4 method . get paramet type ( ) . length = 1 method . get return type ( ) . get name ( ) . equal ( void ) ) { throw new illeg argument except ( invalid method resourc inject annot ) ; } object lookedup resourc ; boolean access ; ( ( name = null ) ( name . length ( ) 0 ) ) { lookedup resourc = context . lookup ( name ) ; } els { lookedup resourc = context . lookup ( clazz . get name ( ) get name ( method ) ) ; } access = method . access ( ) ; method . set access ( true ) ; method . invok ( instanc , lookedup resourc ) ; method . set access ( access ) ; }	public static string get name ( method setter ) { string builder name = new string builder ( setter . get name ( ) ) ; remov set name . delet ( 0 , 3 ) ; lowercas first char name . set char ( 0 , charact . lower case ( name . char ( 0 ) ) ) ; return name . string ( ) ; }
public configur set instanti applic event listen thi context . return code true code all listen wre initi successfulli , code fals code otherwis . boolean listen start ( ) { ( log . debug enabl ( ) ) log . debug ( configur applic event listen ) ; instanti requir listen string listen = find applic listen ( ) ; object result = new object listen . length ; boolean ok = true ; ( int i = 0 ; i result . length ; i ) { ( get logger ( ) . debug enabl ( ) ) get logger ( ) . debug ( configur event listen class listen i ) ; try { result i = instanc manag . new instanc ( listen i ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; get logger ( ) . error ( sm . get string ( standard context . applic listen , listen i ) , t ) ; ok = fals ; } } ( ok ) { get logger ( ) . error ( sm . get string ( standard context . applic skip ) ) ; return ( fals ) ; } sort listen two arrai arrai list object event listen = new arrai list object ( ) ; arrai list object lifecycl listen = new arrai list object ( ) ; ( int i = 0 ; i result . length ; i ) { ( ( result i instanceof servlet context attribut listen ) ( result i instanceof servlet request attribut listen ) ( result i instanceof servlet request listen ) ( result i instanceof http session attribut listen ) ) { event listen . add ( result i ) ; } ( ( result i instanceof servlet context listen ) ( result i instanceof http session listen ) ) { lifecycl listen . add ( result i ) ; } } set applic event listen ( event listen . arrai ( ) ) ; set applic lifecycl listen ( lifecycl listen . arrai ( ) ) ; send applic start event ( get logger ( ) . debug enabl ( ) ) get logger ( ) . debug ( send applic start event ) ; ensur context null get servlet context ( ) ; context . set new servlet context listen allow ( fals ) ; object instanc = get applic lifecycl listen ( ) ; ( instanc = = null ) return ( ok ) ; servlet context event event = new servlet context event ( get servlet context ( ) ) ; ( int i = 0 ; i instanc . length ; i ) { ( instanc i = = null ) continu ; ( ( instanc i instanceof servlet context listen ) ) continu ; servlet context listen listen = ( servlet context listen ) instanc i ; try { fire contain event ( befor context initi , listen ) ; listen . context initi ( event ) ; fire contain event ( after context initi , listen ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; fire contain event ( after context initi , listen ) ; get logger ( ) . error ( sm . get string ( standard context . listen start , instanc i . get class ( ) . get name ( ) ) , t ) ; ok = fals ; } } return ( ok ) ; }
privat void log debug ( string method ) { string r hash code ; string cr hash code ; string rp hash code ; string stage ; string builder uri = new string builder ( ) ; ( request = = null ) { r hash code = null ; cr hash code = null ; rp hash code = null ; stage = ; uri . append ( n ) ; } els { r hash code = integ . hex string ( request . hash code ( ) ) ; org . apach . coyot . request coyot request = request . get coyot request ( ) ; ( coyot request = = null ) { cr hash code = null ; rp hash code = null ; stage = ; } els { cr hash code = integ . hex string ( coyot request . hash code ( ) ) ; request info rp = coyot request . get request processor ( ) ; ( rp = = null ) { rp hash code = null ; stage = ; } els { rp hash code = integ . hex string ( rp . hash code ( ) ) ; stage = integ . string ( rp . get stage ( ) ) ; } } uri . append ( request . get request uri ( ) ) ; ( request . get queri string ( ) = null ) { uri . append ( ) ; uri . append ( request . get queri string ( ) ) ; } } string thread name = thread . current thread ( ) . get name ( ) ; int len = thread name . length ( ) ; ( len 20 ) { thread name = thread name . substr ( len 20 , len ) ; } string msg = string . format ( req : 1 8s creq : 2 8s rp : 3 8s stage : 4 s thread : 5 20 state : 6 20 method : 7 11 uri : 8 s , r hash code , cr hash code , rp hash code , stage , thread . current thread ( ) . get name ( ) , n , method , uri ) ; ( log . trace enabl ( ) ) { log . trace ( msg , new debug except ( ) ) ; } els { log . debug ( msg ) ; } }	overrid public t extend async listen t creat listen ( class t clazz ) throw servlet except { t listen = null ; try { listen = clazz . new instanc ( ) ; } catch ( instanti except e ) { servlet except se = new servlet except ( e ) ; throw se ; } catch ( illeg access except e ) { servlet except se = new servlet except ( e ) ; throw se ; } return listen ; }

return string represent thi compon . overrid public string string ( ) { string builder sb = new string builder ( standard server ) ; sb . append ( get port ( ) ) ; sb . append ( ) ; return ( sb . string ( ) ) ; }	public synchron write configur inform thi entir code server code out server . xml configur file . except javax . manag . instanc found except manag resourc object cannot found except javax . manag . mbean except initi object throw except , persist support except javax . manag . runtim oper except except report persist mechan void store config ( ) throw except { object name sname = null ; try { sname = new object name ( catalina : type = store config ) ; ( mserver . regist ( sname ) ) { mserver . invok ( sname , store config , null , null ) ; } els log . error ( store config mbean regist sname ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( t ) ; } }
overrid public void start queue ( ) { ( run ) return ; executor = new thread pool executor ( max spare thread , max thread , keep aliv time , time unit . millisecond , runnablequeu ) ; run = true ; }
run overrid public string string ( ) { return super . string ( ) int op = thi . interest op ; }	protect log get log ( ) { return log ; }
privat jmxconnector server creat server ( string server name , int rmi registri port , int rmi server port , hash map string , object env , mbean server mbean server ) { creat rmi registri try { locat registri . creat registri ( rmi registri port ) ; } catch ( remot except e ) { log . error ( sm . get string ( jmx remot lifecycl listen . creat registri fail , server name , integ . string ( rmi registri port ) ) , e ) ; return null ; } build connect string fix port string builder url = new string builder ( ) ; url . append ( servic : jmx : rmi : localhost : ) ; url . append ( rmi server port ) ; url . append ( jndi rmi : localhost : ) ; url . append ( rmi registri port ) ; url . append ( jmxrmi ) ; jmxservic url servic url ; try { servic url = new jmxservic url ( url . string ( ) ) ; } catch ( malform urlexcept e ) { log . error ( sm . get string ( jmx remot lifecycl listen . invalid url , server name , url . string ( ) ) , e ) ; return null ; } start jmx server connect string jmxconnector server cs = null ; try { cs = jmxconnector server factori . new jmxconnector server ( servic url , env , mbean server ) ; cs . start ( ) ; log . info ( sm . get string ( jmx remot lifecycl listen . start , integ . valu ( rmi registri port ) , integ . valu ( rmi server port ) , server name ) ) ; } catch ( ioexcept e ) { log . error ( sm . get string ( jmx remot lifecycl listen . creat server fail , server name ) , e ) ; } return cs ; }

public test ip base virtual host enabl . boolean get us ipvhost ( ) { return us ipvhost ; }
overrid protect void after execut ( runnabl r , throwabl t ) { activ count . decrement get ( ) ; }	overrid protect void befor execut ( thread t , runnabl r ) { activ count . increment get ( ) ; }	overrid public boolean offer ( runnabl o ) { we can t do ani check ( parent = = null ) return super . offer ( o ) ; we ar max out thread , simpli queue object ( parent . get pool size ( ) = = parent . get maximum pool size ( ) ) return super . offer ( o ) ; we have idl thread , just add queue ( parent . get activ count ( ) ( parent . get pool size ( ) ) ) return super . offer ( o ) ; we have less thread than maximum forc creation new thread ( parent . get pool size ( ) parent . get maximum pool size ( ) ) return fals ; we reach here , we need add queue return super . offer ( o ) ; }	public execut given command some time futur . command mai execut new thread , pool thread , call thread , discret tt executor tt implement . thread ar avail , ad work queue . work queue full , system wait specifi time throw reject execut except queue still full after . param command runnabl task throw reject execut except thi task cannot accept execut queue full throw null pointer except command unit null void execut ( runnabl command , long timeout , time unit unit ) { try { super . execut ( command ) ; } catch ( reject execut except rx ) { ( super . get queue ( ) instanceof task queue ) { final task queue queue = ( task queue ) super . get queue ( ) ; try { ( queue . forc ( command , timeout , unit ) ) { throw new reject execut except ( queue capac full . ) ; } } catch ( interrupt except x ) { thread . interrupt ( ) ; throw new reject execut except ( x ) ; } } els { throw rx ; } } }
privat void init class loader ( ) { try { common loader = creat class loader ( common , null ) ; ( common loader = = null ) { config file , default thi loader we might singl env . common loader = thi . get class ( ) . get class loader ( ) ; } catalina loader = creat class loader ( server , common loader ) ; share loader = creat class loader ( share , common loader ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; log . error ( class loader creation threw except , t ) ; system . exit ( 1 ) ; } }	public static get valu catalina . base environ variabl . string get catalina base ( ) { return system . get properti ( global . catalina base prop , get catalina home ( ) ) ; }	public static main method , us test onli . param arg command line argument process void main ( string arg ) { ( daemon = = null ) { don t set daemon until init ( ) ha complet bootstrap bootstrap = new bootstrap ( ) ; try { bootstrap . init ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; t . print stack trace ( ) ; return ; } daemon = bootstrap ; } try { string command = start ; ( arg . length 0 ) { command = arg arg . length 1 ; } ( command . equal ( startd ) ) { arg arg . length 1 = start ; daemon . load ( arg ) ; daemon . start ( ) ; } els ( command . equal ( stopd ) ) { arg arg . length 1 = stop ; daemon . stop ( ) ; } els ( command . equal ( start ) ) { daemon . set await ( true ) ; daemon . load ( arg ) ; daemon . start ( ) ; } els ( command . equal ( stop ) ) { daemon . stop server ( arg ) ; } els { log . warn ( bootstrap : command command doe exist . ) ; } } catch ( throwabl t ) { except util . handl throwabl ( t ) ; t . print stack trace ( ) ; } }
privat pars jsp page tag file given path name . param file name name jsp page tag file pars . param parent parent node ( non null when process includ direct ) param tag file true file pars tag file , fals regular jsp page param direct onli true file pars tag file we ar onli interest direct need construct tag file info . param jar file jar file from which read jsp page tag file , null jsp page tag file read from filesystem node . node do pars ( string file name , node parent , jar resourc jar resourc ) throw file found except , jasper except , ioexcept { node . node pars page = null ; encod specifi prolog = fals ; bom present = fals ; default page encod = fals ; jar file jar file = ( jar resourc = = null ) null : jar resourc . get jar file ( ) ; string ab file name = resolv file name ( file name ) ; string jsp config page enc = get jsp config page encod ( ab file name ) ; figur out what type jsp document encod type we ar deal determin syntax encod ( ab file name , jar file , jsp config page enc ) ; ( parent = null ) { includ resourc , add depend list ( jar file = = null ) { compil . get page info ( ) . add depend ( ab file name ) ; } els { compil . get page info ( ) . add depend ( jar resourc . get entri ( ab file name . substr ( 1 ) ) . string ( ) ) ; } } ( ( xml encod specifi prolog ) bom present ) { make sure encod explicitli specifi xml prolog ( ani ) match jsp config element ( ani ) , treat utf 16 , utf 16be , utf 16le ident . ( jsp config page enc = null jsp config page enc . equal ( sourc enc ) ( jsp config page enc . start ( utf 16 ) sourc enc . start ( utf 16 ) ) ) { err . jsp error ( jsp . error . prolog config encod mismatch , sourc enc , jsp config page enc ) ; } } dispatch appropri parser ( xml ) { jsp document ( xml syntax ) input stream jspx page creat properli close jsp document parser . pars page = jsp document parser . pars ( thi , ab file name , jar file , parent , tag file , direct onli , sourc enc , jsp config page enc , encod specifi prolog , bom present ) ; } els { standard syntax input stream reader stream reader = null ; try { stream reader = jsp util . get reader ( ab file name , sourc enc , jar file , ctxt , err , skip ) ; jsp reader jsp reader = new jsp reader ( ctxt , ab file name , sourc enc , stream reader , err ) ; pars page = parser . pars ( thi , jsp reader , parent , tag file , direct onli , jar resourc , sourc enc , jsp config page enc , default page encod , bom present ) ; } final { ( stream reader = null ) { try { stream reader . close ( ) ; } catch ( except ani ) { } } } } ( jar file = null ) { try { jar file . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } } base dir stack . pop ( ) ; return pars page ; }	perform miscellan check after node ar visit . void post check ( ) throw jasper except { check var . name from attribut ha valid valu . iter string iter = name from tabl . kei set ( ) . iter ( ) ; while ( iter . ha next ( ) ) { string name from = iter . next ( ) ; name entri name entri = name tabl . get ( name from ) ; name entri name from entri = name from tabl . get ( name from ) ; node name from node = name from entri . get node ( ) ; ( name entri = = null ) { err . jsp error ( name from node , jsp . error . tagfil . name from . attribut , name from ) ; } els { node node = name entri . get node ( ) ; tag attribut info tag attr = name entri . get tag attribut info ( ) ; ( java . lang . string . equal ( tag attr . get type name ( ) ) tag attr . requir ( ) tag attr . can request time ( ) ) { err . jsp error ( name from node , jsp . error . tagfil . name from . bad attribut , name from , integ . string ( node . get start ( ) . get line number ( ) ) ) ; } } } }
public void stop server ( string argument ) { ( argument = null ) { argument ( argument ) ; } ( get server ( ) = = null ) { creat execut our digest digest digest = creat stop digest ( ) ; digest . set class loader ( thread . current thread ( ) . get context class loader ( ) ) ; file file = config file ( ) ; try { input sourc = new input sourc ( file : file . get absolut path ( ) ) ; file input stream fi = new file input stream ( file ) ; . set byte stream ( fi ) ; digest . push ( thi ) ; digest . pars ( ) ; fi . close ( ) ; } catch ( except e ) { log . error ( catalina . stop : , e ) ; system . exit ( 1 ) ; } } stop exist server try { ( get server ( ) . get port ( ) 0 ) { socket socket = new socket ( get server ( ) . get address ( ) , get server ( ) . get port ( ) ) ; output stream stream = socket . get output stream ( ) ; string shutdown = get server ( ) . get shutdown ( ) ; ( int i = 0 ; i shutdown . length ( ) ; i ) stream . write ( shutdown . char ( i ) ) ; stream . flush ( ) ; stream . close ( ) ; socket . close ( ) ; } els { log . error ( sm . get string ( catalina . stop server ) ) ; system . exit ( 1 ) ; } } catch ( ioexcept e ) { log . error ( catalina . stop : , e ) ; system . exit ( 1 ) ; } }
privat follow workaround until problem ar resolv . input stream get resourc stream ( string uri ) throw file found except { uri absolut ( uri . start ( file : ) ) { return new file input stream ( new file ( uri . substr ( 5 ) ) ) ; } els { try { see file exist filesystem string real = ctxt . get real path ( uri ) ; ( real = = null ) { return ctxt . get resourc stream ( uri ) ; } els { return new file input stream ( real ) ; } } catch ( file found except ex ) { context return ctxt . get resourc stream ( uri ) ; } } }	privat creat tag librari associ given uri namespac , return . param prefix prefix xmln attribut param uri uri namespac ( valu xmln attribut ) return tag librari associ given uri namespac tag librari info get taglib info ( string prefix , string uri ) throw jasper except { tag librari info result = null ; ( uri . start ( urn jsptagdir ) ) { uri ( form urn : jsptagdir : path ) refer tag file dir string tagdir = uri . substr ( urn jsptagdir . length ( ) ) ; result = new implicit tag librari info ( ctxt , parser control , page info , prefix , tagdir , err ) ; } els { uri refer tld file boolean plain uri = fals ; ( uri . start ( urn jsptld ) ) { uri form urn : jsptld : path uri = uri . substr ( urn jsptld . length ( ) ) ; } els { plain uri = true ; } tld locat locat = ctxt . get tld locat ( uri ) ; ( locat = null plain uri ) { ( ctxt . get option ( ) . cach ( ) ) { result = ctxt . get option ( ) . get cach ( ) . get ( uri ) ; } ( result = = null ) { uri valu plain uri , translat error must gener uri found taglib map . instead , ani action namespac defin uri valu must treat uninterpret . result = new tag librari info impl ( ctxt , parser control , page info , prefix , uri , locat , err ) ; ( ctxt . get option ( ) . cach ( ) ) { ctxt . get option ( ) . get cach ( ) . put ( uri , result ) ; } } } } return result ; }	privat pars taglib direct follow syntax : direct : : = ( s attribut ) void pars taglib direct ( node parent ) throw jasper except { attribut attr = pars attribut ( ) ; string uri = attr . get valu ( uri ) ; string prefix = attr . get valu ( prefix ) ; ( prefix = null ) { mark prev mark = page info . get non custom tag prefix ( prefix ) ; ( prev mark = null ) { err . jsp error ( reader . mark ( ) , jsp . error . prefix . us befor dcl , prefix , prev mark . get file ( ) , prev mark . get line number ( ) ) ; } ( uri = null ) { string uri prev = page info . get uri ( prefix ) ; ( uri prev = null uri prev . equal ( uri ) ) { err . jsp error ( reader . mark ( ) , jsp . error . prefix . refin , prefix , uri , uri prev ) ; } ( page info . get taglib ( uri ) = = null ) { tag librari info impl impl = null ; ( ctxt . get option ( ) . cach ( ) ) { impl = ( tag librari info impl ) ctxt . get option ( ) . get cach ( ) . get ( uri ) ; } ( impl = = null ) { tld locat locat = ctxt . get tld locat ( uri ) ; impl = new tag librari info impl ( ctxt , parser control , page info , prefix , uri , locat , err ) ; ( ctxt . get option ( ) . cach ( ) ) { ctxt . get option ( ) . get cach ( ) . put ( uri , impl ) ; } } els { tag file ( tag file info info : impl . get tag file ( ) ) { ctxt . set tag file jar resourc ( info . get path ( ) , ctxt . get tag file jar resourc ( ) ) ; } } page info . add taglib ( uri , impl ) ; } page info . add prefix map ( prefix , uri ) ; } els { string tagdir = attr . get valu ( tagdir ) ; ( tagdir = null ) { string urn tagdir = urn jsptagdir tagdir ; ( page info . get taglib ( urn tagdir ) = = null ) { page info . add taglib ( urn tagdir , new implicit tag librari info ( ctxt , parser control , page info , prefix , tagdir , err ) ) ; } page info . add prefix map ( prefix , urn tagdir ) ; } } } new node . taglib direct ( attr , start , parent ) ; }	overrid public tag librari info get tag librari info ( ) { collect tag librari info coll = pi . get taglib ( ) ; return coll . arrai ( new tag librari info 0 ) ; }	overrid public void visit ( node . get properti n ) throw jasper except { string name = n . get text attribut ( name ) ; string properti = n . get text attribut ( properti ) ; n . set begin java line ( out . get java line ( ) ) ; ( bean info . check variabl ( name ) ) { bean defin us us bean , introspect compil time class bean = bean info . get bean type ( name ) ; string bean name = bean . get canon name ( ) ; java . lang . reflect . method meth = jsp runtim librari . get read method ( bean , properti ) ; string method name = meth . get name ( ) ; out . printil ( out . write ( org . apach . jasper . runtim . jsp runtim librari . string ( ( ( ( bean name ) jspx page context . find attribut ( name ) ) . method name ( ) ) ) ) ; ) ; } els ( strict get properti var info name . contain ( name ) ) { object custom action associ variabl info entri thi name . get class name introspect runtim . out . printil ( out . write ( org . apach . jasper . runtim . jsp runtim librari . string ( org . apach . jasper . runtim . jsp runtim librari . handl get properti ( jspx page context . find attribut ( name ) , properti ) ) ) ; ) ; } els { string builder msg = new string builder ( jsp : get properti bean name ) ; msg . append ( name ) ; msg . append ( . name wa previous introduc per jsp . 5 . 3 ) ; throw new jasper except ( msg . string ( ) ) ; } n . set end java line ( out . get java line ( ) ) ; }
privat when commit respons , we have valid set header , well setup respons filter . void prepar respons ( ) { boolean entiti bodi = true ; content delimit = fals ; output filter output filter = get output buffer ( ) . get filter ( ) ; ( http09 = = true ) { http 0 . 9 get output buffer ( ) . add activ filter ( output filter constant . ident filter ) ; return ; } int statu code = respons . get statu ( ) ; ( ( statu code = = 204 ) ( statu code = = 205 ) ( statu code = = 304 ) ) { entiti bodi get output buffer ( ) . add activ filter ( output filter constant . void filter ) ; entiti bodi = fals ; content delimit = true ; } messag byte method mb = request . method ( ) ; ( method mb . equal ( head ) ) { entiti bodi get output buffer ( ) . add activ filter ( output filter constant . void filter ) ; content delimit = true ; } sendfil support boolean send sendfil = fals ; ( get endpoint ( ) . get us sendfil ( ) ) { send sendfil = prepar sendfil ( output filter ) ; } check compress boolean us compress = fals ; ( entiti bodi ( compress level 0 ) send sendfil ) { us compress = compress ( ) ; chang content length 1 forc chunk ( us compress ) { respons . set content length ( 1 ) ; } } mime header header = respons . get mime header ( ) ; ( entiti bodi ) { respons . set content length ( 1 ) ; } els { string content type = respons . get content type ( ) ; ( content type = null ) { header . set valu ( content type ) . set string ( content type ) ; } string content languag = respons . get content languag ( ) ; ( content languag = null ) { header . set valu ( content languag ) . set string ( content languag ) ; } } long content length = respons . get content length long ( ) ; ( content length = 1 ) { header . set valu ( content length ) . set long ( content length ) ; get output buffer ( ) . add activ filter ( output filter constant . ident filter ) ; content delimit = true ; } els { ( entiti bodi http11 ) { get output buffer ( ) . add activ filter ( output filter constant . chunk filter ) ; content delimit = true ; header . add valu ( constant . transferencod ) . set string ( constant . chunk ) ; } els { get output buffer ( ) . add activ filter ( output filter constant . ident filter ) ; } } ( us compress ) { get output buffer ( ) . add activ filter ( output filter constant . gzip filter ) ; header . set valu ( content encod ) . set string ( gzip ) ; make proxi happi via vari ( from mod deflat ) messag byte vari = header . get valu ( vari ) ; ( vari = = null ) { add new vari header header . set valu ( vari ) . set string ( accept encod ) ; } els ( vari . equal ( ) ) { action requir } els { merg current header header . set valu ( vari ) . set string ( vari . get string ( ) , accept encod ) ; } } add date header header . set valu ( date ) . set string ( fast http date format . get current date ( ) ) ; fixm : add transfer encod header ( ( entiti bodi ) ( content delimit ) ) { mark close connect after request , add connect : close header keep aliv = fals ; } we know request bad thi earli , add connect : close header . keep aliv = keep aliv statu drop connect ( statu code ) ; ( keep aliv ) { header . add valu ( constant . connect ) . set string ( constant . close ) ; } els ( http11 error ) { header . add valu ( constant . connect ) . set string ( constant . keepal ) ; } build respons header get output buffer ( ) . send statu ( ) ; add server header ( server = null ) { alwai overrid anyth app might set header . set valu ( server ) . set string ( server ) ; } els ( header . get valu ( server ) = = null ) { app didn t set header , us default get output buffer ( ) . write ( constant . server byte ) ; } int size = header . size ( ) ; ( int i = 0 ; i size ; i ) { get output buffer ( ) . send header ( header . get name ( i ) , header . get valu ( i ) ) ; } get output buffer ( ) . end header ( ) ; }	protect check compress boolean compress ( ) { nope compress could work http 1 . 0 also cf : mod deflat compress onli sinc http 1 . 1 ( http11 ) return fals ; check browser support gzip encod messag byte accept encod mb = request . get mime header ( ) . get valu ( accept encod ) ; ( ( accept encod mb = = null ) ( accept encod mb . index ( gzip ) = = 1 ) ) return fals ; check content alreadi gzip messag byte content encod mb = respons . get mime header ( ) . get valu ( content encod ) ; ( ( content encod mb = null ) ( content encod mb . index ( gzip ) = 1 ) ) return fals ; forc mode , alwai compress ( test purpos onli ) ( compress level = = 2 ) return true ; check incompat browser ( compress user agent = null ) { messag byte user agent valu mb = request . get mime header ( ) . get valu ( user agent ) ; ( user agent valu mb = null ) { string user agent valu = user agent valu mb . string ( ) ; regexp rule match , disabl compress ( int i = 0 ; i compress user agent . length ; i ) ( compress user agent i . matcher ( user agent valu ) . match ( ) ) return fals ; } } check suffici length trigger compress long content length = respons . get content length long ( ) ; ( ( content length = = 1 ) ( content length compress min size ) ) { check compat mime type ( compress mime type = null ) { return ( start string arrai ( compress mime type , respons . get content type ( ) ) ) ; } } return fals ; }	public get associ adapt . return associ adapt adapt get adapt ( ) { return adapt ; }
privat final deregist ani jdbc driver regist webapp webapp forgot . thi made unnecessari complex becaus ) driver manag check class loader call class ( would much easier check context class loader ) b ) us reflect would creat depend driver manag implement which can , ha , chang . we can t just creat instanc jdbc leak prevent load common class loader ( sinc s . class file catalina home lib directori ) . thi would fail driver manag s check class loader call class . so , we load byte via our parent class loader defin class thi class loader so jdbc leak prevent look like webapp class driver manag . onli app clean up after themselv . . . void clear refer jdbc ( ) { input stream = get resourc stream ( org apach catalina loader jdbc leak prevent . class ) ; we know roughli how big class ( 1k ) so allow 2k start point byte class byte = new byte 2048 ; int offset = 0 ; try { int read = . read ( class byte , offset , class byte . length offset ) ; while ( read 1 ) { offset = read ; ( offset = = class byte . length ) { buffer full doubl size byte tmp = new byte class byte . length 2 ; system . arraycopi ( class byte , 0 , tmp , 0 , class byte . length ) ; class byte = tmp ; } read = . read ( class byte , offset , class byte . length offset ) ; } class lp class = defin class ( org . apach . catalina . loader . jdbc leak prevent , class byte , 0 , offset ) ; object obj = lp class . new instanc ( ) ; clear jdbc driver registr ( ) return list string suppress warn ( uncheck ) list string driver name = ( list string ) obj . get class ( ) . get method ( clear jdbc driver registr ) . invok ( obj ) ; ( string name : driver name ) { log . error ( sm . get string ( webapp class loader . clear jbdc , context name , name ) ) ; } } catch ( except e ) { so mani thing go wrong abov . . . log . warn ( sm . get string ( webapp class loader . jdbc remov fail , context name ) , e ) ; } final { ( = null ) { try { . close ( ) ; } catch ( ioexcept ioe ) { log . warn ( sm . get string ( webapp class loader . jdbc remov stream error , context name ) , ioe ) ; } } } }
protect after read request header , we have setup request filter . void prepar request ( ) { translat http method code string . byte method code = request header messag . get byte ( ) ; ( method code = constant . sc m jk store ) { string method name = constant . method tran arrai method code 1 ; request . method ( ) . set string ( method name ) ; } request header messag . get byte ( request . protocol ( ) ) ; request header messag . get byte ( request . request uri ( ) ) ; request header messag . get byte ( request . remot addr ( ) ) ; request header messag . get byte ( request . remot host ( ) ) ; request header messag . get byte ( request . local name ( ) ) ; request . set local port ( request header messag . get int ( ) ) ; boolean ssl = request header messag . get byte ( ) = 0 ; ( ssl ) { request . scheme ( ) . set string ( http ) ; } decod header mime header header = request . get mime header ( ) ; int h count = request header messag . get int ( ) ; ( int i = 0 ; i h count ; i ) { string h name = null ; header name ar encod either integ code start 0x a0 , normal string ( which case first two byte ar length ) . int isc = request header messag . peek int ( ) ; int h id = isc 0x ff ; messag byte v mb = null ; isc = 0x ff00 ; ( 0x a000 = = isc ) { advanc read posit request header messag . get int ( ) ; h name = constant . header tran arrai h id 1 ; v mb = header . add valu ( h name ) ; } els { reset h id header current read happen 7 8 byte long , code below think s content type header content length header sc req content type = 7 , sc req content length = 8 lead unexpect behaviour . see bug 5861 more inform . h id = 1 ; request header messag . get byte ( tmp mb ) ; byte chunk bc = tmp mb . get byte chunk ( ) ; v mb = header . add valu ( bc . get buffer ( ) , bc . get start ( ) , bc . get length ( ) ) ; } request header messag . get byte ( v mb ) ; ( h id = = constant . sc req content length ( h id = = 1 tmp mb . equal ignor case ( content length ) ) ) { just read content length header , so set long cl = v mb . get long ( ) ; ( cl integ . max valu ) request . set content length ( ( int ) cl ) ; } els ( h id = = constant . sc req content type ( h id = = 1 tmp mb . equal ignor case ( content type ) ) ) { just read content type header , so set byte chunk bchunk = v mb . get byte chunk ( ) ; request . content type ( ) . set byte ( bchunk . get byte ( ) , bchunk . get offset ( ) , bchunk . get length ( ) ) ; } } decod extra attribut boolean secret = fals ; byte attribut code ; while ( ( attribut code = request header messag . get byte ( ) ) = constant . sc ar done ) { switch ( attribut code ) { case constant . sc req attribut : request header messag . get byte ( tmp mb ) ; string n = tmp mb . string ( ) ; request header messag . get byte ( tmp mb ) ; string v = tmp mb . string ( ) ; ajp13 miss forward remot port . allow ajp connector add thi info via privat request attribut . we accept forward data remot port , remov from public list request attribut . ( n . equal ( constant . sc req remot port ) ) { try { request . set remot port ( integ . pars int ( v ) ) ; } catch ( number format except nfe ) { } } els { request . set attribut ( n , v ) ; } break ; case constant . sc context : request header messag . get byte ( tmp mb ) ; noth break ; case constant . sc servlet path : request header messag . get byte ( tmp mb ) ; noth break ; case constant . sc remot user : ( tomcat authent ) { ignor server request header messag . get byte ( tmp mb ) ; } els { request header messag . get byte ( request . get remot user ( ) ) ; } break ; case constant . sc auth type : ( tomcat authent ) { ignor server request header messag . get byte ( tmp mb ) ; } els { request header messag . get byte ( request . get auth type ( ) ) ; } break ; case constant . sc queri string : request header messag . get byte ( request . queri string ( ) ) ; break ; case constant . sc jvm rout : request header messag . get byte ( request . instanc id ( ) ) ; break ; case constant . sc ssl cert : request . scheme ( ) . set string ( http ) ; ssl certif extract lazi , move jk coyot handler request header messag . get byte ( certif ) ; break ; case constant . sc ssl cipher : request . scheme ( ) . set string ( http ) ; request header messag . get byte ( tmp mb ) ; request . set attribut ( abstract endpoint . cipher suit kei , tmp mb . string ( ) ) ; break ; case constant . sc ssl session : request . scheme ( ) . set string ( http ) ; request header messag . get byte ( tmp mb ) ; request . set attribut ( abstract endpoint . session id kei , tmp mb . string ( ) ) ; break ; case constant . sc ssl kei size : request . set attribut ( abstract endpoint . kei size kei , new integ ( request header messag . get int ( ) ) ) ; break ; case constant . sc store method : request header messag . get byte ( request . method ( ) ) ; break ; case constant . sc secret : request header messag . get byte ( tmp mb ) ; ( requir secret = null ) { secret = true ; ( tmp mb . equal ( requir secret ) ) { respons . set statu ( 403 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } break ; default : ignor unknown attribut backward compat break ; } } check secret wa submit requir ( ( requir secret = null ) secret ) { respons . set statu ( 403 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } check full uri ( includ protocol : host : port ) byte chunk uri bc = request . request uri ( ) . get byte chunk ( ) ; ( uri bc . start ignor case ( http , 0 ) ) { int po = uri bc . index ( : , 0 , 3 , 4 ) ; int uri bcstart = uri bc . get start ( ) ; int slash po = 1 ; ( po = 1 ) { byte uri b = uri bc . get byte ( ) ; slash po = uri bc . index ( , po 3 ) ; ( slash po = = 1 ) { slash po = uri bc . get length ( ) ; set uri request . request uri ( ) . set byte ( uri b , uri bcstart po 1 , 1 ) ; } els { request . request uri ( ) . set byte ( uri b , uri bcstart slash po , uri bc . get length ( ) slash po ) ; } messag byte host mb = header . set valu ( host ) ; host mb . set byte ( uri b , uri bcstart po 3 , slash po po 3 ) ; } } messag byte valu mb = request . get mime header ( ) . get valu ( host ) ; pars host ( valu mb ) ; }	protect after read request header , we have setup request filter . void prepar request ( ) { translat http method code string . byte method code = request header messag . get byte ( ) ; ( method code = constant . sc m jk store ) { string method name = constant . method tran arrai method code 1 ; request . method ( ) . set string ( method name ) ; } request header messag . get byte ( request . protocol ( ) ) ; request header messag . get byte ( request . request uri ( ) ) ; request header messag . get byte ( request . remot addr ( ) ) ; request header messag . get byte ( request . remot host ( ) ) ; request header messag . get byte ( request . local name ( ) ) ; request . set local port ( request header messag . get int ( ) ) ; boolean ssl = request header messag . get byte ( ) = 0 ; ( ssl ) { request . scheme ( ) . set string ( http ) ; } decod header mime header header = request . get mime header ( ) ; int h count = request header messag . get int ( ) ; ( int i = 0 ; i h count ; i ) { string h name = null ; header name ar encod either integ code start 0x a0 , normal string ( which case first two byte ar length ) . int isc = request header messag . peek int ( ) ; int h id = isc 0x ff ; messag byte v mb = null ; isc = 0x ff00 ; ( 0x a000 = = isc ) { advanc read posit request header messag . get int ( ) ; h name = constant . header tran arrai h id 1 ; v mb = header . add valu ( h name ) ; } els { reset h id header current read happen 7 8 byte long , code below think s content type header content length header sc req content type = 7 , sc req content length = 8 lead unexpect behaviour . see bug 5861 more inform . h id = 1 ; request header messag . get byte ( tmp mb ) ; byte chunk bc = tmp mb . get byte chunk ( ) ; v mb = header . add valu ( bc . get buffer ( ) , bc . get start ( ) , bc . get length ( ) ) ; } request header messag . get byte ( v mb ) ; ( h id = = constant . sc req content length ( h id = = 1 tmp mb . equal ignor case ( content length ) ) ) { just read content length header , so set long cl = v mb . get long ( ) ; ( cl integ . max valu ) request . set content length ( ( int ) cl ) ; } els ( h id = = constant . sc req content type ( h id = = 1 tmp mb . equal ignor case ( content type ) ) ) { just read content type header , so set byte chunk bchunk = v mb . get byte chunk ( ) ; request . content type ( ) . set byte ( bchunk . get byte ( ) , bchunk . get offset ( ) , bchunk . get length ( ) ) ; } } decod extra attribut boolean secret = fals ; byte attribut code ; while ( ( attribut code = request header messag . get byte ( ) ) = constant . sc ar done ) { switch ( attribut code ) { case constant . sc req attribut : request header messag . get byte ( tmp mb ) ; string n = tmp mb . string ( ) ; request header messag . get byte ( tmp mb ) ; string v = tmp mb . string ( ) ; ajp13 miss forward remot port . allow ajp connector add thi info via privat request attribut . we accept forward data remot port , remov from public list request attribut . ( n . equal ( constant . sc req remot port ) ) { try { request . set remot port ( integ . pars int ( v ) ) ; } catch ( number format except nfe ) { } } els { request . set attribut ( n , v ) ; } break ; case constant . sc context : request header messag . get byte ( tmp mb ) ; noth break ; case constant . sc servlet path : request header messag . get byte ( tmp mb ) ; noth break ; case constant . sc remot user : ( tomcat authent ) { ignor server request header messag . get byte ( tmp mb ) ; } els { request header messag . get byte ( request . get remot user ( ) ) ; } break ; case constant . sc auth type : ( tomcat authent ) { ignor server request header messag . get byte ( tmp mb ) ; } els { request header messag . get byte ( request . get auth type ( ) ) ; } break ; case constant . sc queri string : request header messag . get byte ( request . queri string ( ) ) ; break ; case constant . sc jvm rout : request header messag . get byte ( request . instanc id ( ) ) ; break ; case constant . sc ssl cert : request . scheme ( ) . set string ( http ) ; ssl certif extract lazi , move jk coyot handler request header messag . get byte ( certif ) ; break ; case constant . sc ssl cipher : request . scheme ( ) . set string ( http ) ; request header messag . get byte ( tmp mb ) ; request . set attribut ( abstract endpoint . cipher suit kei , tmp mb . string ( ) ) ; break ; case constant . sc ssl session : request . scheme ( ) . set string ( http ) ; request header messag . get byte ( tmp mb ) ; request . set attribut ( abstract endpoint . session id kei , tmp mb . string ( ) ) ; break ; case constant . sc ssl kei size : request . set attribut ( abstract endpoint . kei size kei , new integ ( request header messag . get int ( ) ) ) ; break ; case constant . sc store method : request header messag . get byte ( request . method ( ) ) ; break ; case constant . sc secret : request header messag . get byte ( tmp mb ) ; ( requir secret = null ) { secret = true ; ( tmp mb . equal ( requir secret ) ) { respons . set statu ( 403 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } break ; default : ignor unknown attribut backward compat break ; } } check secret wa submit requir ( ( requir secret = null ) secret ) { respons . set statu ( 403 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } check full uri ( includ protocol : host : port ) byte chunk uri bc = request . request uri ( ) . get byte chunk ( ) ; ( uri bc . start ignor case ( http , 0 ) ) { int po = uri bc . index ( : , 0 , 3 , 4 ) ; int uri bcstart = uri bc . get start ( ) ; int slash po = 1 ; ( po = 1 ) { byte uri b = uri bc . get byte ( ) ; slash po = uri bc . index ( , po 3 ) ; ( slash po = = 1 ) { slash po = uri bc . get length ( ) ; set uri request . request uri ( ) . set byte ( uri b , uri bcstart po 1 , 1 ) ; } els { request . request uri ( ) . set byte ( uri b , uri bcstart slash po , uri bc . get length ( ) slash po ) ; } messag byte host mb = header . set valu ( host ) ; host mb . set byte ( uri b , uri bcstart po 3 , slash po po 3 ) ; } } messag byte valu mb = request . get mime header ( ) . get valu ( host ) ; pars host ( valu mb ) ; }
protect filter class . param name class name return true class should filter boolean filter ( string name ) { ( name = = null ) return fals ; look up packag string packag name = null ; int po = name . last index ( . ) ; ( po = 1 ) packag name = name . substr ( 0 , po ) ; els return fals ; ( int i = 0 ; i packag trigger . length ; i ) { ( packag name . start ( packag trigger i ) ) return true ; } return fals ; }	protect valid classnam . per srv . 9 . 7 . 2 , we must restrict load class from j2se ( java . ) class servlet api ( javax . servlet . ) . should enhanc robust prevent number user error ( where older version servlet . jar would present web inf lib ) . param name class name return true name valid boolean valid ( string name ) { ( name = = null ) return fals ; ( name . start ( java . ) ) return fals ; ( name . start ( javax . servlet . ) ) return fals ; return true ; }
overrid public object get ( object kei ) { map entri entri = ( map entri ) super . get ( kei ) ; ( log . trace enabl ( ) ) log . trace ( request id : kei entri : entri ) ; ( entri = = null ) return null ; ( entri . primari ( ) ) { messag primari , we need retriev latest valu try { member backup = null ; map messag msg = null ; ( entri . backup ( ) ) { make sure we don t retriev from ourselv msg = new map messag ( get map context name ( ) , map messag . msg retriev backup , fals , ( serializ ) kei , null , null , null , null ) ; respons resp = get rpc channel ( ) . send ( entri . get backup node ( ) , msg , rpc channel . first repli , channel . send option default , get rpc timeout ( ) ) ; ( resp = = null resp . length = = 0 ) { respons log . warn ( unabl retriev remot object kei : kei ) ; return null ; } msg = ( map messag ) resp 0 . get messag ( ) ; msg . deseri ( get extern loader ( ) ) ; backup = entri . get backup node ( ) ; ( entri . get valu ( ) instanceof replic map entri ) { replic map entri val = ( replic map entri ) entri . get valu ( ) ; val . set owner ( get map owner ( ) ) ; } ( msg . get valu ( ) = null ) entri . set valu ( msg . get valu ( ) ) ; } ( entri . backup ( ) ) { select new backup node backup = publish entri info ( kei , entri . get valu ( ) ) ; } els ( entri . proxi ( ) ) { invalid previou primari msg = new map messag ( get map context name ( ) , map messag . msg proxi , fals , ( serializ ) kei , null , null , channel . get local member ( fals ) , backup ) ; member dest = get map member excl ( backup ) ; ( dest = null dest . length 0 ) { get channel ( ) . send ( dest , msg , get channel send option ( ) ) ; } } entri . set primari ( channel . get local member ( fals ) ) ; entri . set backup node ( backup ) ; entri . set backup ( fals ) ; entri . set proxi ( fals ) ; } catch ( except x ) { log . error ( unabl replic out data lazi replic map . get oper , x ) ; return null ; } } ( log . trace enabl ( ) ) log . trace ( request id : kei result : entri . get valu ( ) ) ; ( entri . get valu ( ) = null entri . get valu ( ) instanceof replic map entri ) { replic map entri val = ( replic map entri ) entri . get valu ( ) ; hack , somehow thi set abov val . set owner ( get map owner ( ) ) ; } return entri . get valu ( ) ; }	public = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = = void object made primai ( object kei , object valu ) { ( valu = null valu instanceof delta session ) { delta session session = ( delta session ) valu ; synchron ( session ) { session . access ( ) ; session . end access ( ) ; } } }
overrid protect void destroi intern ( ) throw lifecycl except { destroi our defin servic ( int i = 0 ; i servic . length ; i ) { servic i . destroi ( ) ; } unregist ( onam mbean factori ) ; unregist ( onam string cach ) ; unregist ( onam name resoucr ) ; super . destroi intern ( ) ; }	overrid protect void destroi intern ( ) throw lifecycl except { destroi our defin connector synchron ( connector ) { ( connector connector : connector ) { try { connector . destroi ( ) ; } catch ( except e ) { log . error ( sm . get string ( standard servic . connector . destroyfail , connector ) , e ) ; } } } destroi ani executor ( executor executor : find executor ( ) ) { executor . destroi ( ) ; } ( contain = null ) { contain . destroi ( ) ; } super . destroi intern ( ) ; }	public set global name resourc context . param global name context new global name resourc context void set global name context ( javax . name . context global name context ) { thi . global name context = global name context ; }	public start new server instanc . void load ( ) { long t1 = system . nano time ( ) ; init dir ( ) ; befor digest mai need init name ( ) ; creat execut our digest digest digest = creat start digest ( ) ; input sourc input sourc = null ; input stream input stream = null ; file file = null ; try { file = config file ( ) ; input stream = new file input stream ( file ) ; input sourc = new input sourc ( file : file . get absolut path ( ) ) ; } catch ( except e ) { ignor } ( input stream = = null ) { try { input stream = get class ( ) . get class loader ( ) . get resourc stream ( get config file ( ) ) ; input sourc = new input sourc ( get class ( ) . get class loader ( ) . get resourc ( get config file ( ) ) . string ( ) ) ; } catch ( except e ) { ignor } } altern : don t bother xml , just creat manual . ( input stream = = null ) { try { input stream = get class ( ) . get class loader ( ) . get resourc stream ( server emb . xml ) ; input sourc = new input sourc ( get class ( ) . get class loader ( ) . get resourc ( server emb . xml ) . string ( ) ) ; } catch ( except e ) { ignor } } ( ( input stream = = null ) ( file = null ) ) { log . warn ( can t load server . xml from file . get absolut path ( ) ) ; ( file . exist ( ) file . can read ( ) ) { log . warn ( permiss incorrect , read permiss allow file . ) ; } return ; } try { input sourc . set byte stream ( input stream ) ; digest . push ( thi ) ; digest . pars ( input sourc ) ; input stream . close ( ) ; } catch ( except e ) { log . warn ( catalina . start us get config file ( ) : , e ) ; return ; } stream redirect init stream ( ) ; start new server try { get server ( ) . init ( ) ; } catch ( lifecycl except e ) { ( boolean . get boolean ( org . apach . catalina . startup . exit init failur ) ) throw new java . lang . error ( e ) ; els log . error ( catalina . start , e ) ; } long t2 = system . nano time ( ) ; ( log . info enabl ( ) ) log . info ( initi process ( ( t2 t1 ) 1000000 ) ms ) ; }	overrid default implement . access log defin engin , look engin s default host default host s root context . still none found , return default op access log . overrid public void log access ( request request , respons respons , long time , boolean us default ) { boolean log = fals ; ( access log = null ) { access log . log ( request , respons , time ) ; log = true ; } ( log us default ) { host host = null ; ( default access log = = null ) { we reach thi point , thi engin can t have access log look default host host = ( host ) find child ( get default host ( ) ) ; default access log = host . get access log ( ) ; ( default access log = = null ) { try root context default host context context = ( context ) host . find child ( ) ; ( context = null ) { default access log = context . get access log ( ) ; } ( default access log = = null ) { default access log = new noop access log ( ) ; } } } default access log . log ( request , respons , time ) ; } }	public set share extens class loader . param parent class loader share extens class loader . void set parent class loader ( class loader parent class loader ) { thi . parent class loader = parent class loader ; }	public set shutdown command we ar wait . param shutdown new shutdown command void set shutdown ( string shutdown ) { thi . shutdown = shutdown ; }
protect static inject resourc specifi method . param context jndi context extract valu from param instanc object inject param method field target inject param name jndi name valu bound under param clazz class annot defin throw illeg access except method inaccess throw javax . name . name except valu access name context throw java . lang . reflect . invoc target except setter call fail void lookup method resourc ( context context , object instanc , method method , string name , class clazz ) throw name except , illeg access except , invoc target except { ( method . get name ( ) . start ( set ) method . get paramet type ( ) . length = 1 method . get return type ( ) . get name ( ) . equal ( void ) ) { throw new illeg argument except ( invalid method resourc inject annot ) ; } object lookedup resourc ; boolean access ; ( ( name = null ) ( name . length ( ) 0 ) ) { lookedup resourc = context . lookup ( name ) ; } els { lookedup resourc = context . lookup ( clazz . get name ( ) method . get name ( ) . substr ( 3 ) ) ; } access = method . access ( ) ; method . set access ( true ) ; method . invok ( instanc , lookedup resourc ) ; method . set access ( access ) ; }
privat disconnect connect . all except ar log us debug level . param final set true , call { link connect pool final ( pool connect ) } call . void disconnect ( boolean final ) { ( discard ( ) ) { return ; } set discard ( true ) ; ( connect = null ) { try { parent . disconnect event ( thi , final ) ; connect . close ( ) ; } catch ( except ignor ) { ( log . debug enabl ( ) ) { log . debug ( unabl close underli sql connect , ignor ) ; } } } connect = null ; xa connect = null ; last connect = 1 ; ( final ) parent . final ( thi ) ; }
overrid protect string get name ( ) { thi method should never call stack trace show where thi wa call from unsupport oper except uoe = new unsupport oper except ( sm . get string ( combin realm . get name ) ) ; log . error ( sm . get string ( combin realm . unexpect method ) , uoe ) ; throw uoe ; }
protect process given socket . boolean process socket ( socket socket ) { try { socket wrapper socket wrapper = new socket wrapper socket ( socket ) ; wrapper . set keep aliv left ( get max keep aliv request ( ) ) ; get executor ( ) . execut ( new socket processor ( wrapper ) ) ; } catch ( reject execut except x ) { log . warn ( socket process request wa reject : socket , x ) ; return fals ; } catch ( throwabl t ) { thi mean we got oom similar creat thread , pool queue ar full log . error ( sm . get string ( endpoint . process . fail ) , t ) ; return fals ; } return true ; }	protect process given socket . boolean process socket option ( long socket ) { try { get executor ( ) . execut ( new socket option processor ( socket ) ) ; } catch ( reject execut except x ) { log . warn ( socket process request wa reject : socket , x ) ; return fals ; } catch ( throwabl t ) { thi mean we got oom similar creat thread , pool queue ar full log . error ( sm . get string ( endpoint . process . fail ) , t ) ; return fals ; } return true ; }	termin process request via thi connector . except lifecycl except fatal shutdown error occur overrid protect void stop intern ( ) throw lifecycl except { set state ( lifecycl state . stop ) ; mapper listen doesn t follow lifecycl convent mapper listen . destroi ( ) ; }	stop nest compon ( { link executor } s , { link connector } s { link contain } s ) implement requir { link lifecycl base stop intern ( ) } . except lifecycl except thi compon detect fatal error need report overrid protect void stop intern ( ) throw lifecycl except { stop our defin connector first synchron ( connector ) { ( connector connector : connector ) { try { connector . paus ( ) ; } catch ( except e ) { log . error ( sm . get string ( standard servic . connector . paus fail , connector ) , e ) ; } } } heurist : sleep while ensur paus connector try { thread . sleep ( 1000 ) ; } catch ( interrupt except e ) { ignor } ( log . info enabl ( ) ) log . info ( sm . get string ( standard servic . stop . name , thi . name ) ) ; set state ( lifecycl state . stop ) ; stop our defin contain second ( contain = null ) { synchron ( contain ) { contain . stop ( ) ; } } stop our defin connector first synchron ( connector ) { ( connector connector : connector ) { ( lifecycl state . initi . equal ( connector . get state ( ) ) ) { start continu ; } try { connector . stop ( ) ; } catch ( except e ) { log . error ( sm . get string ( standard servic . connector . stop fail , connector ) , e ) ; } } } synchron ( executor ) { ( executor executor : executor ) { executor . stop ( ) ; } } }	protect unlock server socket accept us bogu connect . void unlock accept ( ) { java . net . socket s = null ; inet socket address saddr = null ; try { need creat connect unlock accept ( ) ; ( address = = null ) { saddr = new inet socket address ( localhost , get port ( ) ) ; } els { saddr = new inet socket address ( address , get port ( ) ) ; } s = new java . net . socket ( ) ; s . set so timeout ( get socket properti ( ) . get so timeout ( ) ) ; todo consid hard code s . set so linger ( true , 0 ) s . set so linger ( get socket properti ( ) . get so linger ( ) , get socket properti ( ) . get so linger time ( ) ) ; ( log . debug enabl ( ) ) { log . debug ( about unlock socket : saddr ) ; } s . connect ( saddr , get socket properti ( ) . get unlock timeout ( ) ) ; ( log . debug enabl ( ) ) { log . debug ( socket unlock complet : saddr ) ; } } catch ( except e ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( endpoint . debug . unlock , get port ( ) ) , e ) ; } } final { ( s = null ) { try { s . close ( ) ; } catch ( except e ) { ignor } } } }	unlock server socket accept us bogu connect . overrid protect void unlock accept ( ) { java . net . socket s = null ; inet socket address saddr = null ; try { need creat connect unlock accept ( ) ; ( get address ( ) = = null ) { saddr = new inet socket address ( localhost , get port ( ) ) ; } els { saddr = new inet socket address ( get address ( ) , get port ( ) ) ; } s = new java . net . socket ( ) ; s . set so timeout ( get socket properti ( ) . get so timeout ( ) ) ; todo consid hard code s . set so linger ( true , 0 ) s . set so linger ( get socket properti ( ) . get so linger ( ) , get socket properti ( ) . get so linger time ( ) ) ; ( log . debug enabl ( ) ) { log . debug ( about unlock socket : saddr ) ; } s . connect ( saddr , get socket properti ( ) . get unlock timeout ( ) ) ; case defer accept accept filter we need send data wake up accept . send option bypass even bsd accept filter . acceptor discard . ( defer accept ) { output stream writer sw ; sw = new output stream writer ( s . get output stream ( ) , iso 8859 1 ) ; sw . write ( option http 1 . 0 r n user agent : tomcat wakeup connect r n r n ) ; sw . flush ( ) ; } ( log . debug enabl ( ) ) { log . debug ( socket unlock complet : saddr ) ; } } catch ( except e ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( endpoint . debug . unlock , get port ( ) ) , e ) ; } } final { ( s = null ) { try { s . close ( ) ; } catch ( except e ) { ignor } } } }	public retriev executor name , null found param name string return executor executor get executor ( string name ) { synchron ( executor ) { ( executor executor : executor ) { ( name . equal ( executor . get name ( ) ) ) return executor ; } } return null ; }	public process pipelin http request us specifi input output stream . throw ioexcept error dure i o oper socket state process ( nio channel socket ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set up socket thi . socket = socket ; input buffer . set socket ( socket ) ; output buffer . set socket ( socket ) ; input buffer . set selector pool ( endpoint . get selector pool ( ) ) ; output buffer . set selector pool ( endpoint . get selector pool ( ) ) ; error flag error = fals ; keep aliv = true ; comet = fals ; async = fals ; long so timeout = endpoint . get so timeout ( ) ; int keep aliv timeout = endpoint . get keep aliv timeout ( ) ; boolean kept aliv = fals ; boolean open socket = fals ; boolean recycl = true ; final kei attach ka = ( kei attach ) socket . get attach ( fals ) ; while ( error keep aliv comet async ) { alwai default our so timeout ka . set timeout ( so timeout ) ; pars request header try { ( disabl upload timeout kept aliv so timeout 0 ) { socket . get iochannel ( ) . socket ( ) . set so timeout ( ( int ) so timeout ) ; } ( input buffer . pars request line ( kept aliv ) ) { haven t finish read request so keep socket open open socket = true ; check see we have read ani request line yet ( input buffer . get pars request line phase ( ) 2 ) { continu us keep aliv timeout ( keep aliv timeout 0 ) ka . set timeout ( keep aliv timeout ) ; } els { start read request line . need keep processor associ socket recycl = fals ; } break ; } kept aliv = true ; ( input buffer . pars header ( ) ) { we ve read part request , don t recycl instead associ socket open socket = true ; recycl = fals ; break ; } request . set start time ( system . current time milli ( ) ) ; ( disabl upload timeout ) { onli bodi , request header socket . get iochannel ( ) . socket ( ) . set so timeout ( timeout ) ; } } catch ( ioexcept e ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . header . pars ) , e ) ; } error = true ; break ; } catch ( throwabl t ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . header . pars ) , t ) ; } 400 bad request respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } ( error ) { set up filter , pars some request header rp . set stage ( org . apach . coyot . constant . stage prepar ) ; try { prepar request ( ) ; } catch ( throwabl t ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . request . prepar ) , t ) ; } 400 intern server error respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } ( max keep aliv request = = 1 ) keep aliv = fals ; ( max keep aliv request 0 ka . decrement keep aliv ( ) = 0 ) keep aliv = fals ; process request adapt ( error ) { try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; adapt . servic ( request , respons ) ; commit , so we can t try set header . ( keep aliv error ) { avoid check twice . error = respons . get error except ( ) = null statu drop connect ( respons . get statu ( ) ) ; } comet support select kei kei = socket . get iochannel ( ) . kei ( socket . get poller ( ) . get selector ( ) ) ; ( kei = null ) { nio endpoint . kei attach attach = ( nio endpoint . kei attach ) kei . attach ( ) ; ( attach = null ) { attach . set comet ( comet ) ; ( comet ) { integ comettimeout = ( integ ) request . get attribut ( org . apach . tomcat . comet . timeout ) ; ( comettimeout = null ) attach . set timeout ( comettimeout . long valu ( ) ) ; } } } } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { log . error ( sm . get string ( http11processor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } finish handl request ( comet async ) { servlet ha reject . ( error ) input buffer . set swallow input ( fals ) ; end request ( ) ; } error , updat statist counter ( error ) { respons . set statu ( 500 ) ; } request . updat counter ( ) ; ( comet async ) { next request input buffer . next request ( ) ; output buffer . next request ( ) ; } do sendfil need : add socket sendfil end ( sendfil data = null error ) { ka . set sendfil data ( sendfil data ) ; sendfil data . keep aliv = keep aliv ; select kei kei = socket . get iochannel ( ) . kei ( socket . get poller ( ) . get selector ( ) ) ; do first write thi thread , might well open socket = socket . get poller ( ) . process sendfil ( kei , ka , true , true ) ; break ; } rp . set stage ( org . apach . coyot . constant . stage keepal ) ; } while rp . set stage ( org . apach . coyot . constant . stage end ) ; ( comet async ) { ( error ) { recycl ( ) ; return socket state . close ; } els { return socket state . long ; } } els { ( recycl ) { recycl ( ) ; } return ( open socket ) ( socket state . open ) : socket state . close ; return ( open socket ) ( recycl socket state . open : socket state . long ) : socket state . close ; } }	public process pipelin http request us specifi input output stream . throw ioexcept error dure i o oper socket state process ( socket wrapper socket socket ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set up socket thi . socket = socket ; input = socket . get socket ( ) . get input stream ( ) ; output = socket . get socket ( ) . get output stream ( ) ; int so timeout = 1 ; ( keep aliv timeout 0 ) { so timeout = socket . get socket ( ) . get so timeout ( ) ; } error flag error = fals ; while ( start error ) { pars request header try { set keep aliv timeout enabl ( keep aliv timeout 0 ) { socket . get socket ( ) . set so timeout ( keep aliv timeout ) ; } get first messag request ( read messag ( request header messag ) ) { thi mean connect timeout rp . set stage ( org . apach . coyot . constant . stage end ) ; break ; } set back timeout keep aliv timeout enabl ( keep aliv timeout 0 ) { socket . get socket ( ) . set so timeout ( so timeout ) ; } check messag type , process right awai break regular request process int type = request header messag . get byte ( ) ; ( type = = constant . jk ajp13 cping request ) { try { output . write ( pong messag arrai ) ; } catch ( ioexcept e ) { error = true ; } continu ; } els ( type = constant . jk ajp13 forward request ) { usual servlet didn t read previou request bodi ( log . debug enabl ( ) ) { log . debug ( unexpect messag : type ) ; } continu ; } request . set start time ( system . current time milli ( ) ) ; } catch ( ioexcept e ) { error = true ; break ; } catch ( throwabl t ) { log . debug ( sm . get string ( ajpprocessor . header . error ) , t ) ; 400 bad request respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } set up filter , pars some request header rp . set stage ( org . apach . coyot . constant . stage prepar ) ; try { prepar request ( ) ; } catch ( throwabl t ) { log . debug ( sm . get string ( ajpprocessor . request . prepar ) , t ) ; 400 intern server error respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } process request adapt ( error ) { try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; adapt . servic ( request , respons ) ; } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { log . error ( sm . get string ( ajpprocessor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } ( async error ) { break ; } finish respons done yet ( finish ) { try { finish ( ) ; } catch ( throwabl t ) { error = true ; } } error , updat statist counter ( error ) { respons . set statu ( 500 ) ; } request . updat counter ( ) ; rp . set stage ( org . apach . coyot . constant . stage keepal ) ; recycl ( ) ; } ( async error ) { rp . set stage ( org . apach . coyot . constant . stage end ) ; return socket state . long ; } els { rp . set stage ( org . apach . coyot . constant . stage end ) ; recycl ( ) ; input = null ; output = null ; return socket state . close ; } }	process pipelin http request specifi socket . param socket wrapper socket from which http request read http respons written . throw ioexcept error dure i o oper public socket state process ( socket wrapper socket socket wrapper ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set remot address remot addr = null ; remot host = null ; local addr = null ; local name = null ; remot port = 1 ; local port = 1 ; set up i o thi . socket = socket wrapper ; input buffer . set input stream ( socket . get socket ( ) . get input stream ( ) ) ; output buffer . set output stream ( socket . get socket ( ) . get output stream ( ) ) ; error flag error = fals ; keep aliv = true ; int keep aliv left = max keep aliv request 0 socket wrapper . decrement keep aliv ( ) : 1 ; int so timeout = endpoint . get so timeout ( ) ; try { socket . get socket ( ) . set so timeout ( so timeout ) ; } catch ( throwabl t ) { log . debug ( sm . get string ( http11processor . socket . timeout ) , t ) ; error = true ; } boolean kept aliv = socket wrapper . kept aliv ( ) ; while ( start error keep aliv ) { pars request header try { todo calcul timeout base length queue ( system . current time mill ( ) wrapper . get last access ( ) time queue ) ( kept aliv ) { ( keep aliv timeout 0 ) { socket . get socket ( ) . set so timeout ( keep aliv timeout ) ; } } } } }	public process pipelin http request us specifi input output stream . throw ioexcept error dure i o oper socket state process ( long socket ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set remot address remot addr = null ; remot host = null ; local addr = null ; local name = null ; remot port = 1 ; local port = 1 ; set up socket thi . socket = socket ; input buffer . set socket ( socket ) ; output buffer . set socket ( socket ) ; error flag error = fals ; comet = fals ; async = fals ; keep aliv = true ; int keep aliv left = max keep aliv request ; long so timeout = endpoint . get so timeout ( ) ; boolean kept aliv = fals ; boolean open socket = fals ; while ( error keep aliv comet async ) { pars request header try { ( disabl upload timeout kept aliv so timeout 0 ) { socket . timeout set ( socket , so timeout 1000 ) ; } ( input buffer . pars request line ( kept aliv ) ) { thi mean data avail right now ( long keepal ) , so processor should recycl method should return true open socket = true ; add socket poller endpoint . get poller ( ) . add ( socket ) ; break ; } request . set start time ( system . current time milli ( ) ) ; kept aliv = true ; ( disabl upload timeout ) { socket . timeout set ( socket , timeout 1000 ) ; } input buffer . pars header ( ) ; } catch ( ioexcept e ) { error = true ; break ; } catch ( throwabl t ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . header . pars ) , t ) ; } 400 bad request respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } ( error ) { set up filter , pars some request header rp . set stage ( org . apach . coyot . constant . stage prepar ) ; try { prepar request ( ) ; } catch ( throwabl t ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . request . prepar ) , t ) ; } 400 intern server error respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } ( max keep aliv request 0 keep aliv left = = 0 ) keep aliv = fals ; process request adapt ( error ) { try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; adapt . servic ( request , respons ) ; commit , so we can t try set header . ( keep aliv error ) { avoid check twice . error = respons . get error except ( ) = null statu drop connect ( respons . get statu ( ) ) ; } } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { log . error ( sm . get string ( http11processor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } finish handl request ( comet async ) { servlet ha reject . ( error ) input buffer . set swallow input ( fals ) ; end request ( ) ; } error , updat statist counter ( error ) { respons . set statu ( 500 ) ; } request . updat counter ( ) ; ( comet async ) { next request input buffer . next request ( ) ; output buffer . next request ( ) ; } do sendfil need : add socket sendfil end ( sendfil data = null error ) { sendfil data . socket = socket ; sendfil data . keep aliv = keep aliv ; ( endpoint . get sendfil ( ) . add ( sendfil data ) ) { open socket = true ; break ; } } rp . set stage ( org . apach . coyot . constant . stage keepal ) ; } rp . set stage ( org . apach . coyot . constant . stage end ) ; ( comet async ) { ( error ) { input buffer . next request ( ) ; output buffer . next request ( ) ; recycl ( ) ; return socket state . close ; } els { return socket state . long ; } } els { recycl ( ) ; return ( open socket ) socket state . open : socket state . close ; } }	public process pipelin http request us specifi input output stream . throw ioexcept error dure i o oper boolean process ( long socket ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set up socket thi . socket = socket ; socket . setrbb ( thi . socket , input buffer ) ; socket . setsbb ( thi . socket , output buffer ) ; error flag error = fals ; async = fals ; boolean open socket = true ; boolean kept aliv = fals ; while ( start error ) { pars request header try { get first messag request ( read messag ( request header messag , true , kept aliv ) ) { thi mean data avail right now ( long keepal ) , so processor should recycl method should return true rp . set stage ( org . apach . coyot . constant . stage end ) ; break ; } check messag type , process right awai break regular request process int type = request header messag . get byte ( ) ; ( type = = constant . jk ajp13 cping request ) { ( socket . sendb ( socket , pong messag buffer , 0 , pong messag buffer . posit ( ) ) 0 ) { error = true ; } continu ; } els ( type = constant . jk ajp13 forward request ) { usual servlet didn t read previou request bodi ( log . debug enabl ( ) ) { log . debug ( unexpect messag : type ) ; } continu ; } kept aliv = true ; request . set start time ( system . current time milli ( ) ) ; } catch ( ioexcept e ) { error = true ; break ; } catch ( throwabl t ) { log . debug ( sm . get string ( ajpprocessor . header . error ) , t ) ; 400 bad request respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } set up filter , pars some request header rp . set stage ( org . apach . coyot . constant . stage prepar ) ; try { prepar request ( ) ; } catch ( throwabl t ) { log . debug ( sm . get string ( ajpprocessor . request . prepar ) , t ) ; 400 intern server error respons . set statu ( 400 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } process request adapt ( error ) { try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; adapt . servic ( request , respons ) ; } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { log . error ( sm . get string ( ajpprocessor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } } ( async error ) { break ; } finish respons done yet ( finish ) { try { finish ( ) ; } catch ( throwabl t ) { error = true ; } } error , updat statist counter ( error ) { respons . set statu ( 500 ) ; } request . updat counter ( ) ; rp . set stage ( org . apach . coyot . constant . stage keepal ) ; recycl ( ) ; } add socket poller ( error ) { endpoint . get poller ( ) . add ( socket ) ; } els { open socket = fals ; } rp . set stage ( org . apach . coyot . constant . stage end ) ; ( async error ) recycl ( ) ; return open socket ; }	public number keepal socket . int get keep aliv count ( ) { ( poller = = null ) { return 0 ; } els { int sum = 0 ; ( int i = 0 ; i poller . length ; i ) { sum = poller i . get kei count ( ) ; } return sum ; } }	public executor find executor ( ) { synchron ( executor ) { executor arr = new executor executor . size ( ) ; executor . arrai ( arr ) ; return arr ; } }	public void destroi ( ) throw except { ( log . info enabl ( ) ) log . info ( sm . get string ( ajpprotocol . stop , get name ( ) ) ) ; endpoint . destroi ( ) ; ( tp onam = null ) registri . get registri ( null , null ) . unregist compon ( tp onam ) ; ( rg onam = null ) registri . get registri ( null , null ) . unregist compon ( rg onam ) ; }	public void destroi ( ) throw except { ( log . info enabl ( ) ) log . info ( sm . get string ( ajpprotocol . stop , get name ( ) ) ) ; endpoint . destroi ( ) ; ( tp onam = null ) registri . get registri ( null , null ) . unregist compon ( tp onam ) ; ( rg onam = null ) registri . get registri ( null , null ) . unregist compon ( rg onam ) ; }	public boolean get secur ( ) { return secur ; }	public void resum ( ) throw except { try { endpoint . resum ( ) ; } catch ( except ex ) { log . error ( sm . get string ( ajpprotocol . endpoint . resumeerror ) , ex ) ; throw ex ; } ( log . info enabl ( ) ) log . info ( sm . get string ( ajpprotocol . resum , get name ( ) ) ) ; }	public void resum ( ) throw except { try { endpoint . resum ( ) ; } catch ( except ex ) { log . error ( sm . get string ( ajpprotocol . endpoint . resumeerror ) , ex ) ; throw ex ; } ( log . info enabl ( ) ) log . info ( sm . get string ( ajpprotocol . resum , get name ( ) ) ) ; }	overrid public void resum ( ) throw except { try { endpoint . resum ( ) ; } catch ( except ex ) { get log ( ) . error ( sm . get string ( http11protocol . endpoint . resumeerror ) , ex ) ; throw ex ; } ( get log ( ) . info enabl ( ) ) get log ( ) . info ( sm . get string ( http11protocol . resum , get name ( ) ) ) ; }	overrid public void start ( ) throw except { initi socket done befor ( initi ) { init ( ) ; } ( run ) { run = true ; paus = fals ; creat worker collect ( get executor ( ) = = null ) { creat executor ( ) ; } start acceptor thread ( int i = 0 ; i acceptor thread count ; i ) { thread acceptor thread = new thread ( new acceptor ( ) , get name ( ) acceptor i ) ; acceptor thread . set prioriti ( thread prioriti ) ; acceptor thread . set daemon ( get daemon ( ) ) ; acceptor thread . start ( ) ; } start async timeout thread thread timeout thread = new thread ( new async timeout ( ) , get name ( ) async timeout ) ; timeout thread . set prioriti ( thread prioriti ) ; timeout thread . set daemon ( true ) ; timeout thread . start ( ) ; } }	start nio endpoint , creat acceptor , poller thread . overrid public void start ( ) throw except { initi socket done befor ( initi ) { init ( ) ; } ( run ) { run = true ; paus = fals ; creat worker collect ( get executor ( ) = = null ) { creat executor ( ) ; } start poller thread poller = new poller get poller thread count ( ) ; ( int i = 0 ; i poller . length ; i ) { poller i = new poller ( ) ; thread poller thread = new thread ( poller i , get name ( ) client poller i ) ; poller thread . set prioriti ( thread prioriti ) ; poller thread . set daemon ( true ) ; poller thread . start ( ) ; } start acceptor thread ( int i = 0 ; i acceptor thread count ; i ) { thread acceptor thread = new thread ( new acceptor ( ) , get name ( ) acceptor i ) ; acceptor thread . set prioriti ( thread prioriti ) ; acceptor thread . set daemon ( get daemon ( ) ) ; acceptor thread . start ( ) ; } } }	public stop endpoint . thi caus all process thread stop . void stop ( ) { ( run ) { run = fals ; unlock accept ( ) ; ( int i = 0 ; i acceptor . length ; i ) { int c = 0 ; while ( acceptor i . aliv ( ) ) { try { acceptor i . interrupt ( ) ; acceptor i . join ( 1000 ) ; } catch ( interrupt except e ) { ignor } ( c 60 ) { hard socket close . ( server sock = 0 ) { socket . shutdown ( server sock , socket . apr shutdown read ) ; server sock = 0 ; } } } } ( int i = 0 ; i poller . length ; i ) { try { poller i . destroi ( ) ; } catch ( except e ) { ignor } } poller = null ; ( int i = 0 ; i comet poller . length ; i ) { try { comet poller i . destroi ( ) ; } catch ( except e ) { ignor } } comet poller = null ; ( us sendfil ) { ( int i = 0 ; i sendfil . length ; i ) { try { sendfil i . destroi ( ) ; } catch ( except e ) { ignor } } sendfil = null ; } } shutdown executor ( ) ; }	public void stop ( ) { ( run ) { run = fals ; unlock accept ( ) ; } shutdown executor ( ) ; }	public stop endpoint . thi caus all process thread stop . void stop ( ) { ( run ) { run = fals ; unlock accept ( ) ; ( int i = 0 ; poller = null i poller . length ; i ) { ( poller i = = null ) continu ; poller i . destroi ( ) ; poller i = null ; } try { stop latch . await ( selector timeout 100 , time unit . millisecond ) ; } catch ( interrupt except ignor ) { } } event cach . clear ( ) ; kei cach . clear ( ) ; nio channel . clear ( ) ; processor cach . clear ( ) ; shutdown executor ( ) ; }
privat static int unwrap ( thread local tl ) { return ( ( integ ) tl . get ( ) ) . int valu ( ) ; }	privat static void wrap ( thread local tl , int valu ) { tl . set ( new integ ( valu ) ) ; }	public annot entri get annot entri ( ) { ( annot out date ) { find attribut contain annot data attribut attr = get attribut ( ) ; list accumul annot = new arrai list ( ) ; ( int i = 0 ; i attr . length ; i ) { attribut attribut = attr i ; ( attribut instanceof annot ) { annot runtim annot = ( annot ) attribut ; ( int j = 0 ; j runtim annot . get annot entri ( ) . length ; j ) accumul annot . add ( runtim annot . get annot entri ( ) j ) ; } } annot = ( annot entri ) accumul annot . arrai ( new annot entri accumul annot . size ( ) ) ; annot out date = fals ; } return annot ; }	public element valu pair get element valu pair ( ) { tofo return list return ( element valu pair ) element valu pair . arrai ( new element valu pair element valu pair . size ( ) ) ; }	return valu defin given bcelcompar strategi . default two java class object ar said equal when class name ar equal . see java . lang . object equal ( java . lang . object ) overrid public boolean equal ( object obj ) { return cmp . equal ( thi , obj ) ; }	public static annot entri read ( data input stream file , constant pool constant pool ) throw ioexcept { final annot entri annot entri = new annot entri ( file . read unsign short ( ) , constant pool ) ; final int num element valu pair = ( file . read unsign short ( ) ) ; annot entri . element valu pair = new arrai list ( ) ; ( int i = 0 ; i num element valu pair ; i ) { annot entri . element valu pair . add ( new element valu pair ( file . read unsign short ( ) , element valu . read element valu ( file , constant pool ) , constant pool ) ) ; } return annot entri ; }	public static final class method read attribut from input data stream . thi method must access from outsid . call field method constructor method . see field see method param file input stream param constant pool arrai constant return attribut throw ioexcept throw class format except attribut read attribut ( data input stream file , constant pool constant pool ) throw ioexcept , class format except { constant utf8 c ; string name ; int name index ; int length ; unknown attribut byte tag = constant . attr unknown ; get class name from constant pool via name index indirect name index = file . read unsign short ( ) ; c = ( constant utf8 ) constant pool . get constant ( name index , constant . constant utf8 ) ; name = c . get byte ( ) ; length data byte length = file . read int ( ) ; system . out . println ( name ) ; ( byte i = 0 ; i constant . known attribut ; i ) { ( name . equal ( constant . attribut name i ) ) { found tag = i ; break ; } } call proper constructor , depend tag switch ( tag ) { case constant . attr unknown : attribut reader r = ( attribut reader ) reader . get ( name ) ; ( r = null ) { return r . creat attribut ( name index , length , file , constant pool ) ; } return new unknown ( name index , length , file , constant pool ) ; case constant . attr constant valu : return new constant valu ( name index , length , file , constant pool ) ; case constant . attr sourc file : return new sourc file ( name index , length , file , constant pool ) ; case constant . attr code : return new code ( name index , length , file , constant pool ) ; case constant . attr except : return new except tabl ( name index , length , file , constant pool ) ; case constant . attr line number tabl : return new line number tabl ( name index , length , file , constant pool ) ; case constant . attr local variabl tabl : return new local variabl tabl ( name index , length , file , constant pool ) ; case constant . attr inner class : return new inner class ( name index , length , file , constant pool ) ; case constant . attr synthet : return new synthet ( name index , length , file , constant pool ) ; case constant . attr deprec : return new deprec ( name index , length , file , constant pool ) ; case constant . attr pmg : return new pmgclass ( name index , length , file , constant pool ) ; case constant . attr signatur : return new signatur ( name index , length , file , constant pool ) ; case constant . attr stack map : return new stack map ( name index , length , file , constant pool ) ; case constant . attr runtim visibl annot : return new runtim visibl annot ( name index , length , file , constant pool ) ; case constant . attr runtimein visibl annot : return new runtim invis annot ( name index , length , file , constant pool ) ; case constant . attr runtim visibl paramet annot : return new runtim visibl paramet annot ( name index , length , file , constant pool ) ; case constant . attr runtimein visibl paramet annot : return new runtim invis paramet annot ( name index , length , file , constant pool ) ; case constant . attr annot default : return new annot default ( name index , length , file , constant pool ) ; case constant . attr local variabl type tabl : return new local variabl type tabl ( name index , length , file , constant pool ) ; case constant . attr enclos method : return new enclos method ( name index , length , file , constant pool ) ; case constant . attr stack map tabl : return new stack map tabl ( name index , length , file , constant pool ) ; default : never reach throw new illeg state except ( unrecogn attribut type tag pars : tag ) ; } }	public void dump ( data output stream do ) throw ioexcept { u2 index type name cpool do . write short ( type index ) ; u2 element valu pair count do . write short ( element valu pair . size ( ) ) ; ( int i = 0 ; i element valu pair . size ( ) ; i ) { element valu pair envp = ( element valu pair ) element valu pair . get ( i ) ; envp . dump ( do ) ; } }	public dump attribut file stream binari format . param file output file stream throw ioexcept void dump ( data output stream file ) throw ioexcept { file . write short ( name index ) ; file . write int ( length ) ; }
public class loader run ( ) { return clazz . get class loader ( ) ; }
privat get kei truststor specifi type , path , password . kei store get store ( string type , string provid , string path , string pass ) throw ioexcept { kei store ks = null ; input stream istream = null ; try { ( provid = = null ) { ks = kei store . get instanc ( type ) ; } els { ks = kei store . get instanc ( type , provid ) ; } ( ( pkcs11 . equal ignor case ( type ) . equal ignor case ( path ) ) ) { file kei store file = new file ( path ) ; ( kei store file . absolut ( ) ) { kei store file = new file ( system . get properti ( catalina . base ) , path ) ; } istream = new file input stream ( kei store file ) ; } char store pass = null ; ( pass = null . equal ( pass ) ) { store pass = pass . char arrai ( ) ; } ks . load ( istream , store pass ) ; } catch ( file found except fnfe ) { log . error ( sm . get string ( jsse . keystor load fail , type , path , fnfe . get messag ( ) ) , fnfe ) ; throw fnfe ; } catch ( ioexcept ioe ) { re throw . caller catch log requir throw ioe ; } catch ( except ex ) { string msg = sm . get string ( jsse . keystor load fail , type , path , ex . get messag ( ) ) ; log . error ( msg , ex ) ; throw new ioexcept ( msg ) ; } final { ( istream = null ) { try { istream . close ( ) ; } catch ( ioexcept ioe ) { do noth } } } return ks ; }	privat static get valu catalina . base environ variabl . string get catalina base ( ) { return system . get properti ( catalina . base , get catalina home ( ) ) ; }	privat static get valu catalina . home environ variabl . string get catalina home ( ) { return system . get properti ( catalina . home , system . get properti ( user . dir ) ) ; }	privat static load properti . void load properti ( ) { input stream = null ; throwabl error = null ; try { string config url = get config url ( ) ; ( config url = null ) { = ( new url ( config url ) ) . open stream ( ) ; } } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } ( = = null ) { try { file home = new file ( get catalina base ( ) ) ; file conf = new file ( home , conf ) ; file properti = new file ( conf , catalina . properti ) ; = new file input stream ( properti ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } } ( = = null ) { try { = catalina properti . class . get resourc stream ( org apach catalina startup catalina . properti ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } } ( = null ) { try { properti = new properti ( ) ; properti . load ( ) ; . close ( ) ; } catch ( throwabl t ) { error = t ; } } ( ( = = null ) ( error = null ) ) { do someth log . warn ( fail load catalina . properti , error ) ; s fine we have reason default . properti = new properti ( ) ; } regist properti system properti enumer enumer = properti . properti name ( ) ; while ( enumer . ha more element ( ) ) { string name = ( string ) enumer . next element ( ) ; string valu = properti . get properti ( name ) ; ( valu = null ) { system . set properti ( name , valu ) ; } } }	privat set code catalina . base code system properti current work directori ha been set . void set catalina base ( ) { ( system . get properti ( catalina . base ) = null ) return ; ( system . get properti ( catalina . home ) = null ) system . set properti ( catalina . base , system . get properti ( catalina . home ) ) ; els system . set properti ( catalina . base , system . get properti ( user . dir ) ) ; }	privat set code catalina . home code system properti current work directori ha been set . void set catalina home ( ) { ( system . get properti ( catalina . home ) = null ) return ; file bootstrap jar = new file ( system . get properti ( user . dir ) , bootstrap . jar ) ; ( bootstrap jar . exist ( ) ) { try { system . set properti ( catalina . home , ( new file ( system . get properti ( user . dir ) , . . ) ) . get canon path ( ) ) ; } catch ( except e ) { ignor system . set properti ( catalina . home , system . get properti ( user . dir ) ) ; } } els { system . set properti ( catalina . home , system . get properti ( user . dir ) ) ; } }	protect load collect crl . collect extend crl get crl ( string crlf ) throw ioexcept , crlexcept , certif except { file crl file = new file ( crlf ) ; ( crl file . absolut ( ) ) { crl file = new file ( system . get properti ( catalina . base ) , crlf ) ; } collect extend crl crl = null ; input stream = null ; try { certif factori cf = certif factori . get instanc ( x . 509 ) ; = new file input stream ( crl file ) ; crl = cf . gener crl ( ) ; } catch ( ioexcept iex ) { throw iex ; } catch ( crlexcept crle ) { throw crle ; } catch ( certif except ce ) { throw ce ; } final { ( = null ) { try { . close ( ) ; } catch ( except ex ) { ignor } } } return crl ; }	protect return file object repres our configur file . file config file ( ) { file file = new file ( config file ) ; ( file . absolut ( ) ) file = new file ( system . get properti ( catalina . base ) , config file ) ; return ( file ) ; }	protect return file object repres base directori entir servlet contain ( i . e . engin contain present ) . file engin base ( ) { string base = system . get properti ( catalina . base ) ; ( base = = null ) { standard engin eng = ( standard engin ) thi . get parent ( ) . get parent ( ) ; base = eng . get base dir ( ) ; } return ( new file ( base ) ) ; }	protect return file object repres applic root directori our associ host . file get app base ( ) { ( app base = null ) { return app base ; } file file = new file ( host . get app base ( ) ) ; ( file . absolut ( ) ) file = new file ( system . get properti ( catalina . base ) , host . get app base ( ) ) ; try { app base = file . get canon file ( ) ; } catch ( ioexcept e ) { app base = file ; } return ( app base ) ; }	protect return file object repres applic root directori our associ host . file get app base ( ) { ( app base = null ) { return app base ; } file file = new file ( host . get app base ( ) ) ; ( file . absolut ( ) ) file = new file ( system . get properti ( catalina . base ) , host . get app base ( ) ) ; try { app base = file . get canon file ( ) ; } catch ( ioexcept e ) { app base = file ; } return ( app base ) ; }	protect get config base . file get config base ( string host name ) { file config base = new file ( system . get properti ( catalina . base ) , conf ) ; ( config base . exist ( ) ) { return null ; } ( engin = null ) { config base = new file ( config base , engin . get name ( ) ) ; } ( instal host = null ) { config base = new file ( config base , host name ) ; } ( config base . exist ( ) ) { ( config base . mkdir ( ) ) { return null ; } } return config base ; }	protect file return canon path ( string path ) { file file = new file ( path ) ; file base = new file ( system . get properti ( catalina . base ) ) ; ( file . absolut ( ) ) file = new file ( base , path ) ; try { return file . get canon file ( ) ; } catch ( ioexcept e ) { return file ; } }	protect project get project ( ) { ( project = null ) return project ; initi project project = new project ( ) ; logger = new jasper ant logger ( ) ; logger . set output print stream ( system . out ) ; logger . set error print stream ( system . err ) ; logger . set messag output level ( project . msg info ) ; project . add build listen ( logger ) ; ( system . get properti ( catalina . home ) = null ) { project . set basedir ( system . get properti ( catalina . home ) ) ; } ( option . get compil ( ) = null ) { ( log . debug enabl ( ) ) log . debug ( compil option . get compil ( ) ) ; project . set properti ( build . compil , option . get compil ( ) ) ; } project . init ( ) ; return project ; }	protect synchron open new log file date specifi code date stamp code . void open ( ) { creat directori necessari file dir = new file ( directori ) ; ( dir . absolut ( ) ) dir = new file ( system . get properti ( catalina . base ) , directori ) ; dir . mkdir ( ) ; open current log file try { string pathnam ; rotat need date stamp file name ( rotat ) { pathnam = dir . get absolut path ( ) file . separ prefix date stamp suffix ; } els { pathnam = dir . get absolut path ( ) file . separ prefix suffix ; } writer = new print writer ( new buffer writer ( new file writer ( pathnam , true ) , 128000 ) , fals ) ; current log file = new file ( pathnam ) ; } catch ( ioexcept e ) { writer = null ; current log file = null ; } }	void init base dir ( ) { ( basedir = = null ) { basedir = system . get properti ( catalina . base ) ; } ( basedir = = null ) { basedir = system . get properti ( catalina . home ) ; } ( basedir = = null ) { creat temp dir . basedir = system . get properti ( user . dir ) tomcat . port ; file home = new file ( basedir ) ; home . mkdir ( ) ; ( home . absolut ( ) ) { try { basedir = home . get canon path ( ) ; } catch ( ioexcept e ) { basedir = home . get absolut path ( ) ; } } } system . set properti ( catalina . home , basedir ) ; system . set properti ( catalina . base , basedir ) ; }	protect void init dir ( ) { string catalina home = system . get properti ( catalina . home ) ; ( catalina home = = null ) { backward compat patch j2ee ri 1 . 3 string j2ee home = system . get properti ( com . sun . enterpris . home ) ; ( j2ee home = null ) { catalina home = system . get properti ( com . sun . enterpris . home ) ; } els ( system . get properti ( catalina . base ) = null ) { catalina home = system . get properti ( catalina . base ) ; } els { us introspect util guess dir catalina home = introspect util . guess instal ( catalina . home , catalina . base , catalina . jar ) ; ( catalina home = = null ) { catalina home = introspect util . guess instal ( tomcat . instal , catalina . home , tomcat . jar ) ; } } } last resort minim embed case . ( catalina home = = null ) { catalina home = system . get properti ( user . dir ) ; } ( catalina home = null ) { file home = new file ( catalina home ) ; ( home . absolut ( ) ) { try { catalina home = home . get canon path ( ) ; } catch ( ioexcept e ) { catalina home = home . get absolut path ( ) ; } } system . set properti ( catalina . home , catalina home ) ; } ( system . get properti ( catalina . base ) = = null ) { system . set properti ( catalina . base , catalina home ) ; } els { string catalina base = system . get properti ( catalina . base ) ; file base = new file ( catalina base ) ; ( base . absolut ( ) ) { try { catalina base = base . get canon path ( ) ; } catch ( ioexcept e ) { catalina base = base . get absolut path ( ) ; } } system . set properti ( catalina . base , catalina base ) ; } string temp = system . get properti ( java . io . tmpdir ) ; ( temp = = null ( ( new file ( temp ) ) . exist ( ) ) ( ( new file ( temp ) ) . directori ( ) ) ) { log . error ( sm . get string ( embed . notmp , temp ) ) ; } }	protect void init dir ( ) { string catalina home = system . get properti ( catalina . home ) ; ( catalina home = = null ) { backward compat patch j2ee ri 1 . 3 string j2ee home = system . get properti ( com . sun . enterpris . home ) ; ( j2ee home = null ) { catalina home = system . get properti ( com . sun . enterpris . home ) ; } els ( system . get properti ( catalina . base ) = null ) { catalina home = system . get properti ( catalina . base ) ; } els { us introspect util guess dir catalina home = introspect util . guess instal ( catalina . home , catalina . base , catalina . jar ) ; ( catalina home = = null ) { catalina home = introspect util . guess instal ( tomcat . instal , catalina . home , tomcat . jar ) ; } } } last resort minim embed case . ( catalina home = = null ) { catalina home = system . get properti ( user . dir ) ; } ( catalina home = null ) { file home = new file ( catalina home ) ; ( home . absolut ( ) ) { try { catalina home = home . get canon path ( ) ; } catch ( ioexcept e ) { catalina home = home . get absolut path ( ) ; } } system . set properti ( catalina . home , catalina home ) ; } ( system . get properti ( catalina . base ) = = null ) { system . set properti ( catalina . base , catalina home ) ; } els { string catalina base = system . get properti ( catalina . base ) ; file base = new file ( catalina base ) ; ( base . absolut ( ) ) { try { catalina base = base . get canon path ( ) ; } catch ( ioexcept e ) { catalina base = base . get absolut path ( ) ; } } system . set properti ( catalina . base , catalina base ) ; } string temp = system . get properti ( java . io . tmpdir ) ; ( temp = = null ( ( new file ( temp ) ) . exist ( ) ) ( ( new file ( temp ) ) . directori ( ) ) ) { log . error ( sm . get string ( embed . notmp , temp ) ) ; } }	overrid protect void init intern ( ) throw lifecycl except { super . init intern ( ) ; initi adapt adapt = new coyot adapt ( thi ) ; protocol handler . set adapt ( adapt ) ; introspect util . set properti ( protocol handler , jk home , system . get properti ( catalina . base ) ) ; try { protocol handler . init ( ) ; } catch ( except e ) { throw new lifecycl except ( sm . get string ( coyot connector . protocol handler initi fail , e ) ) ; } onam protocol handler = regist ( protocol handler , creat object name kei properti ( protocol handler ) ) ; mapper listen . set domain ( get domain ( ) ) ; onam mapper = regist ( mapper listen , creat object name kei properti ( mapper ) ) ; }	protect load content our configur file . void load ( ) { valid exist our configur file file file = new file ( pathnam ) ; ( file . absolut ( ) ) file = new file ( system . get properti ( catalina . base ) , pathnam ) ; ( file . exist ( ) file . can read ( ) ) { log . warn ( cannot load configur file file . get absolut path ( ) ) ; return ; } load content our configur file digest digest = new digest ( ) ; digest . set valid ( fals ) ; digest . add rule set ( new memori rule set ( ) ) ; try { digest . push ( thi ) ; digest . pars ( file ) ; } catch ( except e ) { log . warn ( error process configur file file . get absolut path ( ) , e ) ; return ; } final { digest . reset ( ) ; } }	prepar begin activ us public method thi compon implement requir { link lifecycl base start intern ( ) } . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect void start intern ( ) throw lifecycl except { valid exist our databas file file file = new file ( pathnam ) ; ( file . absolut ( ) ) file = new file ( system . get properti ( catalina . base ) , pathnam ) ; ( file . exist ( ) file . can read ( ) ) throw new lifecycl except ( sm . get string ( memori realm . load exist , file . get absolut path ( ) ) ) ; load content databas file ( log . debug enabl ( ) ) log . debug ( sm . get string ( memori realm . load path , file . get absolut path ( ) ) ) ; digest digest = get digest ( ) ; try { synchron ( digest ) { digest . push ( thi ) ; digest . pars ( file ) ; } } catch ( except e ) { throw new lifecycl except ( sm . get string ( memori realm . read xml ) , e ) ; } final { digest . reset ( ) ; } super . start intern ( ) ; }	public get config base . file get config base ( ) { file config base = new file ( system . get properti ( catalina . base ) , conf ) ; ( config base . exist ( ) ) { return null ; } contain contain = thi ; contain host = null ; contain engin = null ; while ( contain = null ) { ( contain instanceof host ) host = contain ; ( contain instanceof engin ) engin = contain ; contain = contain . get parent ( ) ; } ( engin = null ) { config base = new file ( config base , engin . get name ( ) ) ; } ( host = null ) { config base = new file ( config base , host . get name ( ) ) ; } ( save config ) { config base . mkdir ( ) ; } return config base ; }	public string get catalina base ( ) { return system . get properti ( catalina . base ) ; }	public string get catalina home ( ) { return system . get properti ( catalina . home ) ; }	public boolean await ( ) { return await ; }	public check permiss save thi user databas persist storag locat boolean writeabl ( ) { file file = new file ( pathnam ) ; ( file . absolut ( ) ) { file = new file ( system . get properti ( catalina . base ) , pathnam ) ; } file dir = file . get parent file ( ) ; return dir . exist ( ) dir . directori ( ) dir . can write ( ) ; }	public static string expand ( host host , url war , string pathnam ) throw ioexcept { make sure directori alreadi exist file app base = new file ( host . get app base ( ) ) ; ( app base . absolut ( ) ) { app base = new file ( system . get properti ( catalina . base ) , host . get app base ( ) ) ; } ( app base . exist ( ) app base . directori ( ) ) { throw new ioexcept ( sm . get string ( host config . app base , app base . get absolut path ( ) ) ) ; } file doc base = new file ( app base , pathnam ) ; ( doc base . exist ( ) ) { war file alreadi instal return ( doc base . get absolut path ( ) ) ; } creat new document base directori doc base . mkdir ( ) ; expand war new document base directori string canon doc base prefix = doc base . get canon path ( ) ; ( canon doc base prefix . end ( file . separ ) ) { canon doc base prefix = file . separ ; } jar urlconnect juc = ( jar urlconnect ) war . open connect ( ) ; juc . set us cach ( fals ) ; jar file jar file = null ; input stream input = null ; boolean success = fals ; try { jar file = juc . get jar file ( ) ; enumer jar entri jar entri = jar file . entri ( ) ; while ( jar entri . ha more element ( ) ) { jar entri jar entri = jar entri . next element ( ) ; string name = jar entri . get name ( ) ; file expand file = new file ( doc base , name ) ; ( expand file . get canon path ( ) . start ( canon doc base prefix ) ) { throw except stop deploy throw new illeg argument except ( sm . get string ( expand war . illeg path , war , name ) ) ; } int last = name . last index ( ) ; ( last = 0 ) { file parent = new file ( doc base , name . substr ( 0 , last ) ) ; parent . mkdir ( ) ; } ( name . end ( ) ) { continu ; } input = jar file . get input stream ( jar entri ) ; bugzilla 33636 expand ( input , expand file ) ; long last modifi = jar entri . get time ( ) ; ( ( last modifi = 1 ) ( last modifi = 0 ) ) { expand file . set last modifi ( last modifi ) ; } input . close ( ) ; input = null ; } success = true ; } catch ( ioexcept e ) { throw e ; } final { ( success ) { someth went wrong , delet expand dir keep thing clean delet dir ( doc base ) ; } ( input = null ) { try { input . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } input = null ; } ( jar file = null ) { try { jar file . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } jar file = null ; } } return absolut path our new document base directori return ( doc base . get absolut path ( ) ) ; }	public static get valu catalina . base environ variabl . string get catalina base ( ) { return system . get properti ( catalina . base , get catalina home ( ) ) ; }	public static get valu catalina . home environ variabl . string get catalina home ( ) { return system . get properti ( catalina . home , system . get properti ( user . dir ) ) ; }	public static void main ( string arg ) { verifi catalina . home wa pass . ( catalina home = = null ) { log . error ( must set catalina . home system properti ) ; system . exit ( 1 ) ; } process command line option int index = 0 ; while ( true ) { ( index = = arg . length ) { usag ( ) ; system . exit ( 1 ) ; } ( ant . equal ( arg index ) ) ant = true ; } }	public static valid war file found specifi url . param host host war instal param war url web applic archiv valid ( must start jar : ) param pathnam context path name web applic except illeg argument except thi jar : url war file invalid except ioexcept input output error wa encount dure valid void valid ( host host , url war , string pathnam ) throw ioexcept { make app base absolut file app base = new file ( host . get app base ( ) ) ; ( app base . absolut ( ) ) { app base = new file ( system . get properti ( catalina . base ) , host . get app base ( ) ) ; } file doc base = new file ( app base , pathnam ) ; calcul document base directori string canon doc base prefix = doc base . get canon path ( ) ; ( canon doc base prefix . end ( file . separ ) ) { canon doc base prefix = file . separ ; } jar urlconnect juc = ( jar urlconnect ) war . open connect ( ) ; juc . set us cach ( fals ) ; jar file jar file = null ; try { jar file = juc . get jar file ( ) ; enumer jar entri jar entri = jar file . entri ( ) ; while ( jar entri . ha more element ( ) ) { jar entri jar entri = jar entri . next element ( ) ; string name = jar entri . get name ( ) ; file expand file = new file ( doc base , name ) ; ( expand file . get canon path ( ) . start ( canon doc base prefix ) ) { throw except stop deploy throw new illeg argument except ( sm . get string ( expand war . illeg path , war , name ) ) ; } } } catch ( ioexcept e ) { throw e ; } final { ( jar file = null ) { try { jar file . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } jar file = null ; } } }	initi thi servlet . overrid public void init ( ) throw servlet except { ensur our contain servlet properti have been set ( ( wrapper = = null ) ( context = = null ) ) throw new unavail except ( sm . get string ( manag servlet . wrapper ) ) ; set our properti from initi paramet string valu = null ; try { valu = get servlet config ( ) . get init paramet ( debug ) ; debug = integ . pars int ( valu ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } acquir global jndi resourc avail server server = ( ( engin ) host . get parent ( ) ) . get servic ( ) . get server ( ) ; ( ( server = null ) ( server instanceof standard server ) ) { global = ( ( standard server ) server ) . get global name context ( ) ; } calcul directori which we deploi applic version = ( file ) get servlet context ( ) . get attribut ( servlet context . tempdir ) ; identifi app base own host thi context ( ani ) string app base = ( ( host ) context . get parent ( ) ) . get app base ( ) ; deploi = new file ( app base ) ; ( deploi . absolut ( ) ) { deploi = new file ( system . get properti ( catalina . base ) , app base ) ; } config base = new file ( system . get properti ( catalina . base ) , conf ) ; contain contain = context ; contain host = null ; contain engin = null ; while ( contain = null ) { ( contain instanceof host ) host = contain ; ( contain instanceof engin ) engin = contain ; contain = contain . get parent ( ) ; } ( engin = null ) { config base = new file ( config base , engin . get name ( ) ) ; } ( host = null ) { config base = new file ( config base , host . get name ( ) ) ; } log debug messag necessari ( debug = 1 ) { log ( init : associ deploy onam ) ; ( global = null ) { log ( init : global resourc ar avail ) ; } } }	protect synchron add host us specifi paramet . param writer writer render result param name host name param alias comma separ alia list param app base applic base host param manag should manag webapp deploi new host void add ( print writer writer , string name , string alias , string app base , boolean manag , boolean auto deploi , boolean deploi startup , boolean deploi xml , boolean unpack war ) { ( debug = 1 ) { log ( sm . get string ( host manag servlet . add , name ) ) ; } valid request host name ( ( name = = null ) name . length ( ) = = 0 ) { writer . println ( sm . get string ( host manag servlet . invalid host name , name ) ) ; return ; } check host alreadi exist ( engin . find child ( name ) = null ) { writer . println ( sm . get string ( host manag servlet . alreadi host , name ) ) ; return ; } valid creat app base file app base file = null ; file file = null ; ( app base = = null app base . length ( ) = = 0 ) { file = new file ( name ) ; } els { file = new file ( app base ) ; } ( file . absolut ( ) ) file = new file ( system . get properti ( catalina . base ) , file . get path ( ) ) ; try { app base file = file . get canon file ( ) ; } catch ( ioexcept e ) { app base file = file ; } ( app base file . exist ( ) ) { ( app base file . mkdir ( ) ) { writer . println ( sm . get string ( host manag servlet . app base creat fail , app base file . string ( ) , name ) ) ; return ; } } creat base config file file config base file = get config base ( name ) ; copi manag . xml request ( manag ) { ( config base file = = null ) { writer . println ( sm . get string ( host manag servlet . config base creat fail , name ) ) ; return ; } input stream = null ; output stream os = null ; try { = get servlet context ( ) . get resourc stream ( manag . xml ) ; os = new file output stream ( new file ( config base file , manag . xml ) ) ; byte buffer = new byte 512 ; int len = buffer . length ; while ( true ) { len = . read ( buffer ) ; ( len = = 1 ) break ; os . write ( buffer , 0 , len ) ; } } catch ( ioexcept e ) { writer . println ( sm . get string ( host manag servlet . manag xml ) ) ; return ; } final { ( = null ) { try { . close ( ) ; } catch ( ioexcept e ) { ignor } } ( os = null ) { try { os . close ( ) ; } catch ( ioexcept e ) { ignor } } } } standard host host = new standard host ( ) ; host . set app base ( app base ) ; host . set name ( name ) ; host . add lifecycl listen ( new host config ( ) ) ; add host alias ( ( alias = null ) ( . equal ( alias ) ) ) { string token tok = new string token ( alias , , ) ; while ( tok . ha more token ( ) ) { host . add alia ( tok . next token ( ) ) ; } } host . set auto deploi ( auto deploi ) ; host . set deploi startup ( deploi startup ) ; host . set deploi xml ( deploi xml ) ; host . set unpack war ( unpack war ) ; add new host try { engin . add child ( host ) ; } catch ( except e ) { writer . println ( sm . get string ( host manag servlet . except , e . string ( ) ) ) ; return ; } host = ( standard host ) engin . find child ( name ) ; ( host = null ) { writer . println ( sm . get string ( host manag servlet . add , name ) ) ; } els { someth fail writer . println ( sm . get string ( host manag servlet . add fail , name ) ) ; } }	public initi access thi user databas . except except ani except thrown dure open void open ( ) throw except { synchron ( group ) { synchron ( user ) { eras ani previou group user user . clear ( ) ; group . clear ( ) ; role . clear ( ) ; construct reader xml input file ( exist ) file file = new file ( pathnam ) ; ( file . absolut ( ) ) { file = new file ( system . get properti ( catalina . base ) , pathnam ) ; } ( file . exist ( ) ) { return ; } file input stream fi = new file input stream ( file ) ; construct digest read xml input file digest digest = new digest ( ) ; try { digest . set featur ( http : apach . org xml featur allow java encod , true ) ; } catch ( except e ) { log . warn ( sm . get string ( memori user databas . xml featur encod ) , e ) ; } digest . add factori creat ( tomcat user group , new memori group creation factori ( thi ) ) ; digest . add factori creat ( tomcat user role , new memori role creation factori ( thi ) ) ; digest . add factori creat ( tomcat user user , new memori user creation factori ( thi ) ) ; pars xml input file load thi databas try { digest . pars ( fi ) ; fi . close ( ) ; } catch ( except e ) { try { fi . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } throw e ; } } } }	public save ani updat inform persist storag locat thi user databas . except except ani except thrown dure save void save ( ) throw except { ( get readonli ( ) ) { log . error ( sm . get string ( memori user databas . read onli ) ) ; return ; } ( writeabl ( ) ) { log . warn ( sm . get string ( memori user databas . persist ) ) ; return ; } write out content temporari file file file new = new file ( pathnam new ) ; ( file new . absolut ( ) ) { file new = new file ( system . get properti ( catalina . base ) , pathnam new ) ; } print writer writer = null ; try { configur our print writer file output stream fo = new file output stream ( file new ) ; output stream writer osw = new output stream writer ( fo , utf8 ) ; writer = new print writer ( osw ) ; print file prolog writer . println ( xml version = 1 . 0 encod = utf 8 ) ; writer . println ( tomcat user ) ; print entri each defin role , group , user iter valu = null ; valu = get role ( ) ; while ( valu . ha next ( ) ) { writer . print ( ) ; writer . println ( valu . next ( ) ) ; } valu = get group ( ) ; while ( valu . ha next ( ) ) { writer . print ( ) ; writer . println ( valu . next ( ) ) ; } valu = get user ( ) ; while ( valu . ha next ( ) ) { writer . print ( ) ; writer . println ( valu . next ( ) ) ; } print file epilog writer . println ( tomcat user ) ; check error occur while print ( writer . check error ( ) ) { writer . close ( ) ; file new . delet ( ) ; throw new ioexcept ( sm . get string ( memori user databas . write except , file new . get absolut path ( ) ) ) ; } writer . close ( ) ; } catch ( ioexcept e ) { ( writer = null ) { writer . close ( ) ; } file new . delet ( ) ; throw e ; } perform requir renam perman save thi file file file old = new file ( pathnam old ) ; ( file old . absolut ( ) ) { file old = new file ( system . get properti ( catalina . base ) , pathnam old ) ; } file old . delet ( ) ; file file orig = new file ( pathnam ) ; ( file orig . absolut ( ) ) { file orig = new file ( system . get properti ( catalina . base ) , pathnam ) ; } ( file orig . exist ( ) ) { file old . delet ( ) ; ( file orig . renam ( file old ) ) { throw new ioexcept ( sm . get string ( memori user databas . renam old , file old . get absolut path ( ) ) ) ; } } ( file new . renam ( file orig ) ) { ( file old . exist ( ) ) { file old . renam ( file orig ) ; } throw new ioexcept ( sm . get string ( memori user databas . renam new , file orig . get absolut path ( ) ) ) ; } file old . delet ( ) ; }	public void set catalina base ( string s ) { system . set properti ( catalina . base , s ) ; }	public void set catalina home ( string s ) { system . set properti ( catalina . home , s ) ; }	public void set catalina home ( string s ) { system . set properti ( catalina . home , s ) ; }	public string get cipher ( ) { return cipher ; }	public string get truststor pass ( ) { return truststor pass ; }	public logic void start ( ) throw except { ( start ) return ; contain hcontain = get cluster ( ) . get contain ( ) ; ( ( hcontain instanceof host ) ) { log . error ( farm war deploy can onli work host cluster subel ) ; return ; } host = ( host ) hcontain ; check correct engin host setup contain econtain = host . get parent ( ) ; ( ( econtain instanceof engin ) ) { log . error ( farm war deploy can onli work parent host . get name ( ) engin ) ; return ; } engin engin = ( engin ) econtain ; string hostnam = null ; hostnam = host . get name ( ) ; try { onam = new object name ( engin . get name ( ) : type = deploy , host = hostnam ) ; } catch ( except e ) { log . error ( can t construct mbean object name e ) ; return ; } ( watch enabl ) { watcher = new war watcher ( thi , new file ( get watch dir ( ) ) ) ; ( log . info enabl ( ) ) { log . info ( cluster deploy watch get watch dir ( ) chang . ) ; } } config base = new file ( system . get properti ( catalina . base ) , conf ) ; ( engin = null ) { config base = new file ( config base , engin . get name ( ) ) ; } ( host = null ) { config base = new file ( config base , hostnam ) ; } retriev mbean server m bean server = registri . get registri ( null , null ) . get mbean server ( ) ; start = true ; count = 0 ; get cluster ( ) . add cluster listen ( thi ) ; ( log . info enabl ( ) ) log . info ( cluster farm war deploy start . ) ; }
public regist authent princip authent type our request , current session ( ) , our singl sign valv , . set appropri cooki return . param request servlet request we ar process param respons servlet respons we ar gener param princip authent princip regist param auth type authent type regist param usernam usernam us authent ( ani ) param password password us authent ( ani ) void regist ( request request , http servlet respons respons , princip princip , string auth type , string usernam , string password ) { ( log . debug enabl ( ) ) log . debug ( authent princip . get name ( ) type auth type ) ; cach authent inform our request request . set auth type ( auth type ) ; request . set user princip ( princip ) ; session session = request . get session intern ( fals ) ; ( session = null chang session id authent ) { manag manag = request . get context ( ) . get manag ( ) ; manag . chang session id ( session ) ; request . chang session id ( session . get id ( ) ) ; } cach authent inform our session , ani ( cach ) { ( session = null ) { session . set auth type ( auth type ) ; session . set princip ( princip ) ; ( usernam = null ) session . set note ( constant . sess usernam note , usernam ) ; els session . remov note ( constant . sess usernam note ) ; ( password = null ) session . set note ( constant . sess password note , password ) ; els session . remov note ( constant . sess password note ) ; } } construct cooki return client ( sso = = null ) return ; onli creat new sso entri sso did alreadi set note exist entri ( would do subsequ request digest ssl authent context ) string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( sso id = = null ) { construct cooki return client sso id = gener session id ( ) ; cooki cooki = new cooki ( constant . singl sign cooki , sso id ) ; cooki . set max ag ( 1 ) ; cooki . set path ( ) ; bugzilla 41217 cooki . set secur ( request . secur ( ) ) ; bugzilla 34724 string sso domain = sso . get cooki domain ( ) ; ( sso domain = null ) { cooki . set domain ( sso domain ) ; } respons . add cooki ( cooki ) ; regist thi princip our sso valv sso . regist ( sso id , princip , auth type , usernam , password ) ; request . set note ( constant . req ssoid note , sso id ) ; } els { ( princip = = null ) { regist programmat logout sso . deregist ( sso id ) ; return ; } els { updat sso session latest authent data sso . updat ( sso id , princip , auth type , usernam , password ) ; } } sso entri never clear we don t associ session ( session = = null ) session = request . get session intern ( true ) ; sso . associ ( sso id , session ) ; }
public int do write ( byte chunk chunk , respons re ) throw ioexcept { ( compress stream = = null ) { compress stream = new gzipoutput stream ( fake output stream ) ; } compress stream . write ( chunk . get byte ( ) , chunk . get start ( ) , chunk . get length ( ) ) ; return chunk . get length ( ) ; }	public end current request . accept write extra byte us buffer . do write dure execut thi method . long end ( ) throw ioexcept { ( compress stream = = null ) { compress stream = new gzipoutput stream ( fake output stream ) ; } compress stream . finish ( ) ; compress stream . close ( ) ; return ( ( output filter ) buffer ) . end ( ) ; }	public flush respons . throw ioexcept underli i o error occur void flush ( ) throw ioexcept { ( commit ) { send connector request commit . connector should valid header , send them ( us send header ) set filter accordingli . respons . action ( action code . action commit , null ) ; } }
start thi compon implement requir { link lifecycl base start intern ( ) } . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect synchron void start intern ( ) throw lifecycl except { look up singl sign implement our request process path , contain parent = context . get parent ( ) ; while ( ( sso = = null ) ( parent = null ) ) { ( ( parent instanceof pipelin ) ) { parent = parent . get parent ( ) ; continu ; } valv valv = ( ( pipelin ) parent ) . get valv ( ) ; ( int i = 0 ; i valv . length ; i ) { ( valv i instanceof singl sign ) { sso = ( singl sign ) valv i ; break ; } } ( sso = = null ) parent = parent . get parent ( ) ; } ( log . debug enabl ( ) ) { ( sso = null ) log . debug ( found singl sign valv sso ) ; els log . debug ( singl sign valv present ) ; } super . start intern ( ) ; }
protect scan web . xml file appli web applic merg them us rule defin spec . global web . xml file , where duplic configur , most specif level win . ie applic s web . xml take preced over host level global web . xml file . void web config ( ) { web xml web xml = creat web xml ( ) ; pars global web . xml present input sourc global web xml = get global web xml sourc ( ) ; ( global web xml = = null ) { thi unusu enough log log . info ( sm . get string ( context config . default miss ) ) ; } els { pars web xml ( global web xml , web xml , fals ) ; } pars host level web . xml present addit apart from welcom page web xml . set replac welcom file ( true ) ; input sourc host web xml = get host web xml sourc ( ) ; pars web xml ( host web xml , web xml , fals ) ; pars context level web . xml web xml . set replac welcom file ( true ) ; input sourc context web xml = get context web xml sourc ( ) ; pars web xml ( context web xml , web xml , fals ) ; assum 0 safe what requir thi case doubl web xml version = 0 ; ( web xml . get version ( ) = null ) { web xml version = doubl . pars doubl ( web xml . get version ( ) ) ; } ( web xml version = 3 web xml . metadata complet ( ) ) { order import here step 1 . identifi all jar packag applic jar have web fragment . xml pars thi point . map string , web xml fragment = process jar web fragment ( ) ; step 2 . order fragment . set web xml order fragment = web xml . order web fragment ( web xml , fragment ) ; step 3 . look servlet contain initi implement ok = process servlet contain initi ( order fragment ) ; thi add ani match class type initi map ( ok ) { url webinf class ; try { webinf class = context . get servlet context ( ) . get resourc ( web inf class ) ; process annot url ( webinf class , web xml ) ; } catch ( malform urlexcept e ) { log . error ( sm . get string ( context config . webinf class url ) , e ) ; } } thi add ani match class type initi map ( ok ) { process annot ( order fragment ) ; } step 6 . merg web fragment . xml file main web . xml file . ( ok ) { ok = web xml . merg ( order fragment ) ; } step 7 . appli merg web . xml context ( ok ) { web xml . configur context ( context ) ; step 7a . make merg web . xml avail other compon , specif jasper , save those compon from have re gener . todo us servlet contain initi jasper string merg web xml = web xml . xml ( ) ; context . get servlet context ( ) . set attribut ( org . apach . tomcat . util . scan . constant . merg web xml , merg web xml ) ; ( context . get log effect web xml ( ) ) { log . info ( web . xml : n merg web xml ) ; } } step 8 . look static resourc packag jar ( ok ) { process resourc jar ( order fragment ) ; } context ( ok ) { ( map . entri servlet contain initi , set class >> entri : initi class map . entri set ( ) ) { ( entri . get valu ( ) . empti ( ) ) { context . add servlet contain initi ( entri . get kei ( ) , null ) ; } els { context . add servlet contain initi ( entri . get kei ( ) , entri . get valu ( ) ) ; } } } } els { appli unmerg web . xml context web xml . configur context ( context ) ; } }
protect string gener java ( ) throw except { string smap str = null ; long t1 , t2 , t3 , t4 ; t1 = t2 = t3 = t4 = 0 ; ( log . debug enabl ( ) ) { t1 = system . current time milli ( ) ; } setup page info area page info = new page info ( new bean repositori ( ctxt . get class loader ( ) , err dispatch ) , ctxt . get jsp file ( ) ) ; jsp config jsp config = option . get jsp config ( ) ; jsp config . jsp properti jsp properti = jsp config . find jsp properti ( ctxt . get jsp file ( ) ) ; current uri match pattern specifi jsp properti group web . xml , initi page info those properti . ( jsp properti . elignor ( ) = null ) { page info . set elignor ( jsp util . boolean valu ( jsp properti . elignor ( ) ) ) ; } ( jsp properti . script invalid ( ) = null ) { page info . set script invalid ( jsp util . boolean valu ( jsp properti . script invalid ( ) ) ) ; } ( jsp properti . get includ prelud ( ) = null ) { page info . set includ prelud ( jsp properti . get includ prelud ( ) ) ; } ( jsp properti . get includ coda ( ) = null ) { page info . set includ coda ( jsp properti . get includ coda ( ) ) ; } ( jsp properti . defer syntax allow liter ( ) = null ) { page info . set defer syntax allow liter ( jsp util . boolean valu ( jsp properti . defer syntax allow liter ( ) ) ) ; } ( jsp properti . trim direct whitespac ( ) = null ) { page info . set trim direct whitespac ( jsp util . boolean valu ( jsp properti . trim direct whitespac ( ) ) ) ; } ( jsp properti . get default content type ( ) = null ) { page info . set content type ( jsp properti . get default content type ( ) ) ; } ( jsp properti . get buffer ( ) = null ) { page info . set buffer valu ( jsp properti . get buffer ( ) , null , err dispatch ) ; } ( jsp properti . error undeclar namespac ( ) = null ) { page info . set error undeclar namespac ( jsp util . boolean valu ( jsp properti . error undeclar namespac ( ) ) ) ; } ( ctxt . tag file ( ) ) { try { doubl librari version = doubl . pars doubl ( ctxt . get tag info ( ) . get tag librari ( ) . get requir version ( ) ) ; ( librari version 2 . 0 ) { page info . set elignor ( true , null , err dispatch , true ) ; } ( librari version 2 . 1 ) { page info . set defer syntax allow liter ( true , null , err dispatch , true ) ; } } catch ( number format except ex ) { err dispatch . jsp error ( ex ) ; } } ctxt . check output dir ( ) ; string java file name = ctxt . get servlet java file name ( ) ; servlet writer writer = null ; try { set elignor chang behaviour parser subtl wai . add fun , elignor can set ani file form part translat unit so set file includ toward end translat unit can chang how parser should have behav when pars content up point where elignor wa set . arghh previou attempt hack around thi have onli provid partial solut . we now us two pass pars translat unit . first just pars direct second pars whole translat unit onc we know how elignor ha been set . todo ar some possibl optimis thi process . pars file parser control parser ctl = new parser control ( ctxt , thi ) ; pass 1 direct node . node direct = parser ctl . pars direct ( ctxt . get jsp file ( ) ) ; valid . valid direct ( thi , direct ) ; pass 2 whole translat unit page node = parser ctl . pars ( ctxt . get jsp file ( ) ) ; ( ctxt . prototyp mode ( ) ) { gener prototyp . java file tag file writer = setup context writer ( java file name ) ; gener . gener ( writer , thi , page node ) ; writer . close ( ) ; writer = null ; return null ; } valid process attribut don t re valid direct we valid pass 1 valid . valid ex direct ( thi , page node ) ; ( log . debug enabl ( ) ) { t2 = system . current time milli ( ) ; } collect page info collector . collect ( thi , page node ) ; compil ( necessari ) load tag file referenc thi compil unit . tfp = new tag file processor ( ) ; tfp . load tag file ( thi , page node ) ; ( log . debug enabl ( ) ) { t3 = system . current time milli ( ) ; } determin which custom tag need declar which script var script variabl . set ( page node , err dispatch ) ; optim tag plugin tag plugin manag tag plugin manag = option . get tag plugin manag ( ) ; tag plugin manag . appli ( page node , err dispatch , page info ) ; optim : concaten contigu templat text . text optim . concaten ( thi , page node ) ; gener static function mapper code . elfunct mapper . map ( page node ) ; gener servlet . java file writer = setup context writer ( java file name ) ; gener . gener ( writer , thi , page node ) ; writer . close ( ) ; writer = null ; writer onli us dure compil , derefer jsp compil context when done allow gc d save memori . ctxt . set writer ( null ) ; ( log . debug enabl ( ) ) { t4 = system . current time milli ( ) ; log . debug ( gener java file name total = ( t4 t1 ) gener = ( t4 t3 ) valid = ( t2 t1 ) ) ; } } catch ( except e ) { ( writer = null ) { try { writer . close ( ) ; writer = null ; } catch ( except e1 ) { do noth } } remov gener . java file new file ( java file name ) . delet ( ) ; throw e ; } final { ( writer = null ) { try { writer . close ( ) ; } catch ( except e2 ) { do noth } } } jsr45 support ( option . smap suppress ( ) ) { smap str = smap util . gener smap ( ctxt , page node ) ; } ani proto type . java . class file wa gener , prototyp . java mai have been replac current compil ( tag file self referenc ) , . class file need remov , make sure javac would gener . class again from new . java file just gener . tfp . remov proto type file ( ctxt . get class file name ( ) ) ; return smap str ; }
protect valid classnam . per srv . 9 . 7 . 2 , we must restrict load class from j2se ( java . ) class servlet api ( javax . servlet . ) . should enhanc robust prevent number user error ( where older version servlet . jar would present web inf lib ) . param name class name return true name valid boolean valid ( string name ) { ( name = = null ) return fals ; ( name . start ( java . ) ) return fals ; return true ; }
privat class get type ( ) { return type ; }	overrid public express pars express ( string express , api doe us gener suppress warn ( uncheck ) class expect type , function mapper f mapper ) throw elexcept { try { elcontext impl ctx = new elcontext impl ( elresolv impl . get default resolv ( ) ) ; ( f mapper = null ) { ctx . set function mapper ( new function mapper impl ( f mapper ) ) ; } valu express ve = thi . factori . creat valu express ( ctx , express , expect type ) ; return new express impl ( ve ) ; } catch ( javax . el . elexcept e ) { throw new elpars except ( e . get messag ( ) ) ; } }	overrid public interfac el . parser . node us raw type ( auto gener ) method info get method info ( evalu context ctx , suppress warn ( uncheck ) class param type ) throw elexcept { target t = get target ( ctx ) ; method m = reflect util . get method ( t . base , t . properti , param type ) ; return new method info ( m . get name ( ) , m . get return type ( ) , m . get paramet type ( ) ) ; }	overrid public object evalu ( string express , api doe us gener suppress warn ( uncheck ) class expect type , variabl resolv v resolv , function mapper f mapper ) throw elexcept { return thi . pars express ( express , expect type , f mapper ) . evalu ( v resolv ) ; }	get object content . overrid public object get content ( ) throw ioexcept { ( connect ) connect ( ) ; ( resourc = null ) return get input stream ( ) ; ( collect = null ) return collect ; ( object = null ) return object ; throw new file found except ( ) ; }	overrid public object get valu ( elcontext context , object base , object properti ) throw null pointer except , properti found except , elexcept { ( context = = null ) { throw new null pointer except ( ) ; } ( base = = null properti = null ) { int idx = arrai . binari search ( scope name , properti . string ( ) ) ; ( idx = 0 ) { page context page = ( page context ) context . get context ( jsp context . class ) ; context . set properti resolv ( true ) ; switch ( idx ) { case applicationscop : return scope manag . get ( page ) . get applic scope ( ) ; case cooki : return scope manag . get ( page ) . get cooki ( ) ; case header : return scope manag . get ( page ) . get header ( ) ; case headervalu : return scope manag . get ( page ) . get header valu ( ) ; case initparam : return scope manag . get ( page ) . get init param ( ) ; case pagecontext : return scope manag . get ( page ) . get page context ( ) ; case pagescop : return scope manag . get ( page ) . get page scope ( ) ; case param : return scope manag . get ( page ) . get param ( ) ; case param valu : return scope manag . get ( page ) . get param valu ( ) ; case request scope : return scope manag . get ( page ) . get request scope ( ) ; case session scope : return scope manag . get ( page ) . get session scope ( ) ; } } } return null ; }	privat class get type from valu ( object valu ) { ( valu = = null ) { return null ; } class result = new class valu . length ; ( int i = 0 ; i valu . length ; i ) { ( valu i = = null ) { result i = null ; } els { result i = valu i . get class ( ) ; } } return result ; }	overrid public variabl mapper get variabl mapper ( ) { return thi . var mapper ; }	overrid public variabl mapper get variabl mapper ( ) { return thi . target . get variabl mapper ( ) ; }	overrid public boolean properti resolv ( ) { return thi . el context . properti resolv ( ) ; }	overrid public boolean properti resolv ( ) { return thi . target . properti resolv ( ) ; }	overrid public class get common properti type ( elcontext context , object base ) { ( base instanceof resourc bundl ) { return string . class ; } return null ; }	public param wrap sinc servlet 3 . 0 todo servlet3 add comment boolean wrapper ( servlet request wrap ) { ( request = = wrap ) { return true ; } ( request instanceof servlet request wrapper ) { return ( ( servlet request wrapper ) request ) . wrapper ( wrap ) ; } return fals ; }	public param wrap sinc servlet 3 . 0 todo servlet3 add comment boolean wrapper ( servlet respons wrap ) { ( respons = = wrap ) { return true ; } ( respons instanceof servlet respons wrapper ) { return ( ( servlet respons wrapper ) respons ) . wrapper ( wrap ) ; } return fals ; }	public static final tag find ancestor class ( tag from , tck signatur test fail gener suppress warn ( uncheck ) class klass ) { boolean interfac = fals ; ( from = = null klass = = null ( tag . class . assign from ( klass ) ( interfac = klass . interfac ( ) ) ) ) { return null ; } ( ; ; ) { tag tag = from . get parent ( ) ; ( tag = = null ) { return null ; } ( ( interfac klass . instanc ( tag ) ) ( ( class ) klass ) . assign from ( tag . get class ( ) ) ) { return tag ; } from = tag ; } }
public member get next backup node ( ) { member member = get map member ( ) ; int node = get next backup index ( ) ; ( member . length = = 0 node = = 1 ) return null ; ( node = member . length ) node = 0 ; return member node ; }	overrid public string string ( ) { string builder buf = new string builder ( map entri kei : ) ; buf . append ( get kei ( ) ) . append ( ; ) ; buf . append ( valu : ) . append ( get valu ( ) ) . append ( ; ) ; buf . append ( primari : ) . append ( primari ( ) ) . append ( ; ) ; buf . append ( backup : ) . append ( backup ( ) ) . append ( ; ) ; buf . append ( proxi : ) . append ( proxi ( ) ) . append ( ; ) ; return buf . string ( ) ; }	public object get valu ( ) { return valu ; }	public object set valu ( object valu ) { object old = thi . valu ; thi . valu = valu ; return old ; }	public todo implement state transfer param msg serializ return serializ null repli should sent serializ repli request ( serializ msg , final member sender ) { ( ( msg instanceof map messag ) ) return null ; map messag mapmsg = ( map messag ) msg ; map init request ( mapmsg . get msg type ( ) = = map messag . msg init ) { mapmsg . set primari ( channel . get local member ( fals ) ) ; return mapmsg ; } map start request ( mapmsg . get msg type ( ) = = map messag . msg start ) { mapmsg . set primari ( channel . get local member ( fals ) ) ; map member ad ( sender ) ; return mapmsg ; } backup request ( mapmsg . get msg type ( ) = = map messag . msg retriev backup ) { map entri entri = ( map entri ) super . get ( mapmsg . get kei ( ) ) ; ( entri = = null ( entri . serializ ( ) ) ) return null ; mapmsg . set valu ( ( serializ ) entri . get valu ( ) ) ; return mapmsg ; } state transfer request ( mapmsg . get msg type ( ) = = map messag . msg state mapmsg . get msg type ( ) = = map messag . msg state copi ) { synchron ( state mutex ) { make sure we dont do two thing same time arrai list map messag list = new arrai list map messag ( ) ; iter map . entri , >> i = super . entri set ( ) . iter ( ) ; while ( i . ha next ( ) ) { map . entri , e = i . next ( ) ; map entri entri = ( map entri ) super . get ( e . get kei ( ) ) ; ( entri = null entri . serializ ( ) ) { boolean copi = ( mapmsg . get msg type ( ) = = map messag . msg state copi ) ; map messag me = new map messag ( map context name , copi map messag . msg copi : map messag . msg proxi , fals , ( serializ ) entri . get kei ( ) , copi ( serializ ) entri . get valu ( ) : null , null , entri . get primari ( ) , entri . get backup node ( ) ) ; list . add ( me ) ; } } mapmsg . set valu ( list ) ; return mapmsg ; } synchron } return null ; }	public member exclud from set ( member mbr , member set ) { arrai list member result = new arrai list member ( ) ; ( int i = 0 ; i set . length ; i ) { boolean includ = true ; ( int j = 0 ; j mbr . length ; j ) ( mbr j . equal ( set i ) ) includ = fals ; ( includ ) result . add ( set i ) ; } return result . arrai ( new member result . size ( ) ) ; }	overrid public collect object valu ( ) { arrai list object valu = new arrai list object ( ) ; iter map . entri , >> i = super . entri set ( ) . iter ( ) ; while ( i . ha next ( ) ) { map . entri , e = i . next ( ) ; map entri entri = ( map entri ) super . get ( e . get kei ( ) ) ; ( entri = null entri . activ ( ) entri . get valu ( ) = null ) valu . add ( entri . get valu ( ) ) ; } return collect . unmodifi collect ( valu ) ; }	public repli ha alreadi been sent request thread , rpc callback can handl ani data come after fact . param msg serializ param sender member void left over ( serializ msg , member sender ) { left over membership messag ( ( msg instanceof map messag ) ) return ; map messag mapmsg = ( map messag ) msg ; try { mapmsg . deseri ( get extern loader ( ) ) ; ( mapmsg . get msg type ( ) = = map messag . msg start ) { map member ad ( mapmsg . get primari ( ) ) ; } els ( mapmsg . get msg type ( ) = = map messag . msg init ) { member aliv ( mapmsg . get primari ( ) ) ; } } catch ( ioexcept x ) { log . error ( unabl deseri map messag . , x ) ; } catch ( class found except x ) { log . error ( unabl deseri map messag . , x ) ; } }	public void list bean ( print writer writer , string qry ) { set object name name = null ; try { name = m bean server . queri name ( new object name ( qry ) , null ) ; writer . println ( ok number result : name . size ( ) ) ; writer . println ( ) ; } catch ( except e ) { writer . println ( error e . string ( ) ) ; return ; } iter object name = name . iter ( ) ; while ( . ha next ( ) ) { object name onam = . next ( ) ; writer . println ( name : onam . string ( ) ) ; try { mbean info minfo = m bean server . get mbean info ( onam ) ; can t null i think string code = minfo . get class name ( ) ; ( org . apach . common . model . base model mbean . equal ( code ) ) { code = ( string ) m bean server . get attribut ( onam , model type ) ; } writer . println ( model type : code ) ; mbean attribut info attr = minfo . get attribut ( ) ; object valu = null ; ( int i = 0 ; i attr . length ; i ) { ( attr i . readabl ( ) ) continu ; ( support ( attr i . get type ( ) ) ) continu ; string att name = attr i . get name ( ) ; ( model type . equal ( att name ) ) continu ; ( att name . index ( = ) = 0 att name . index ( : ) = 0 att name . index ( ) = 0 ) { continu ; } try { valu = m bean server . get attribut ( onam , att name ) ; } catch ( throwabl t ) { log ( error get attribut onam att name t . string ( ) ) ; continu ; } ( valu = = null ) continu ; string valu string ; try { class c = valu . get class ( ) ; ( c . arrai ( ) ) { int len = arrai . get length ( valu ) ; string builder sb = new string builder ( arrai c . get compon type ( ) . get name ( ) length len ) ; ( len 0 ) { sb . append ( r n ) ; } ( int j = 0 ; j len ; j ) { sb . append ( t ) ; object item = arrai . get ( valu , j ) ; ( item = = null ) { sb . append ( null valu ) ; } els { try { sb . append ( escap ( item . string ( ) ) ) ; } catch ( throwabl t ) { sb . append ( non stringabl valu ) ; } } ( j len 1 ) { sb . append ( r n ) ; } } valu string = sb . string ( ) ; } els { valu string = escap ( valu . string ( ) ) ; } writer . println ( att name : valu string ) ; } catch ( throwabl t ) { ignor } } } catch ( except e ) { ignor } writer . println ( ) ; } }	public void member ad ( member member ) { do noth }	public void messag receiv ( serializ msg , member sender ) { ( ( msg instanceof map messag ) ) return ; map messag mapmsg = ( map messag ) msg ; ( log . trace enabl ( ) ) { log . trace ( map mapnam receiv messag : mapmsg ) ; } try { mapmsg . deseri ( get extern loader ( ) ) ; } catch ( ioexcept x ) { log . error ( unabl deseri map messag . , x ) ; return ; } catch ( class found except x ) { log . error ( unabl deseri map messag . , x ) ; return ; } ( log . trace enabl ( ) ) log . trace ( map messag receiv from : sender . get name ( ) msg : mapmsg ) ; ( mapmsg . get msg type ( ) = = map messag . msg start ) { map member ad ( mapmsg . get primari ( ) ) ; } ( mapmsg . get msg type ( ) = = map messag . msg stop ) { member disappear ( mapmsg . get primari ( ) ) ; } ( mapmsg . get msg type ( ) = = map messag . msg proxi ) { map entri entri = ( map entri ) super . get ( mapmsg . get kei ( ) ) ; ( entri = = null ) { entri = new map entri ( mapmsg . get kei ( ) , mapmsg . get valu ( ) ) ; entri . set backup ( fals ) ; entri . set proxi ( true ) ; entri . set backup node ( mapmsg . get backup node ( ) ) ; entri . set primari ( mapmsg . get primari ( ) ) ; super . put ( entri . get kei ( ) , entri ) ; } els { entri . set proxi ( true ) ; entri . set backup ( fals ) ; entri . set backup node ( mapmsg . get backup node ( ) ) ; entri . set primari ( mapmsg . get primari ( ) ) ; } } ( mapmsg . get msg type ( ) = = map messag . msg remov ) { super . remov ( mapmsg . get kei ( ) ) ; } ( mapmsg . get msg type ( ) = = map messag . msg backup mapmsg . get msg type ( ) = = map messag . msg copi ) { map entri entri = ( map entri ) super . get ( mapmsg . get kei ( ) ) ; ( entri = = null ) { entri = new map entri ( mapmsg . get kei ( ) , mapmsg . get valu ( ) ) ; entri . set backup ( mapmsg . get msg type ( ) = = map messag . msg backup ) ; entri . set proxi ( fals ) ; entri . set backup node ( mapmsg . get backup node ( ) ) ; entri . set primari ( mapmsg . get primari ( ) ) ; ( mapmsg . get valu ( ) = null mapmsg . get valu ( ) instanceof replic map entri ) { ( ( replic map entri ) mapmsg . get valu ( ) ) . set owner ( get map owner ( ) ) ; } } els { entri . set backup ( mapmsg . get msg type ( ) = = map messag . msg backup ) ; entri . set proxi ( fals ) ; entri . set backup node ( mapmsg . get backup node ( ) ) ; entri . set primari ( mapmsg . get primari ( ) ) ; ( entri . get valu ( ) instanceof replic map entri ) { replic map entri diff = ( replic map entri ) entri . get valu ( ) ; ( mapmsg . diff ( ) ) { try { diff . lock ( ) ; diff . appli diff ( mapmsg . get diff valu ( ) , 0 , mapmsg . get diff valu ( ) . length ) ; } catch ( except x ) { log . error ( unabl appli diff kei : entri . get kei ( ) , x ) ; } final { diff . unlock ( ) ; } } els { ( mapmsg . get valu ( ) = null ) entri . set valu ( mapmsg . get valu ( ) ) ; ( ( replic map entri ) entri . get valu ( ) ) . set owner ( get map owner ( ) ) ; } end } els ( mapmsg . get valu ( ) instanceof replic map entri ) { replic map entri re = ( replic map entri ) mapmsg . get valu ( ) ; re . set owner ( get map owner ( ) ) ; entri . set valu ( re ) ; } els { ( mapmsg . get valu ( ) = null ) entri . set valu ( mapmsg . get valu ( ) ) ; } end } end super . put ( entri . get kei ( ) , entri ) ; } end }	public void transfer state ( ) { try { member member = get map member ( ) ; member backup = member . length 0 ( member ) member 0 : null ; ( backup = null ) { map messag msg = new map messag ( map context name , get state messag type ( ) , fals , null , null , null , null , null ) ; respons resp = rpc channel . send ( new member { backup } , msg , rpc channel . first repli , channel send option , rpc timeout ) ; ( resp . length 0 ) { synchron ( state mutex ) { msg = ( map messag ) resp 0 . get messag ( ) ; msg . deseri ( get extern loader ( ) ) ; arrai list list = ( arrai list ) msg . get valu ( ) ; ( int i = 0 ; i list . size ( ) ; i ) { messag receiv ( ( serializ ) list . get ( i ) , resp 0 . get sourc ( ) ) ; } } } els { log . warn ( transfer state , 0 repli , probabl timeout . ) ; } } } catch ( channel except x ) { log . error ( unabl transfer lazi replic map state . , x ) ; } catch ( ioexcept x ) { log . error ( unabl transfer lazi replic map state . , x ) ; } catch ( class found except x ) { log . error ( unabl transfer lazi replic map state . , x ) ; } state transfer = true ; }
protect void process annot ( set web xml fragment ) { ( web xml fragment : fragment ) { ( fragment . metadata complet ( ) ) { web xml annot = new web xml ( ) ; url url = fragment . get url ( ) ; process annot url ( url , annot ) ; set web xml set = new hash set web xml ( ) ; set . add ( annot ) ; merg annot fragment fragment take prioriti fragment . merg ( set ) ; } } }
public void test invok var arg aaabbb ( ) throw except { method express me9 = factori . creat method express ( context , { bean c . sai hello ( bean aaa , bean bbb , bean bbb ) } , null , null ) ; object r9 = me9 . invok ( context , null ) ; assert equal ( abb : hello aaa from bbb , bbb , r9 . string ( ) ) ; }
public construct return new session object , base default set specifi thi manag s properti . session id specifi us session id . new session cannot creat ani reason , return code null code . param session id session id which should us creat new session ; code null code , new session id gener except illeg state except new session cannot instanti ani reason session creat session ( string session id ) { ( ( max activ session = 0 ) ( session . size ( ) = max activ session ) ) { reject session ; throw new illeg state except ( sm . get string ( manag base . creat session . ) ) ; } recycl creat session instanc session session = creat empti session ( ) ; initi properti new session return session . set new ( true ) ; session . set valid ( true ) ; session . set creation time ( system . current time milli ( ) ) ; session . set max inact interv ( thi . max inact interv ) ; string id = session id ; ( id = = null ) { id = gener session id ( ) ; } session . set id ( id ) ; session counter ; return ( session ) ; }	overrid public boolean contain valu ( object valu ) { ( valu = = null ) { return super . contain valu ( valu ) ; } els { iter map . entri , >> i = super . entri set ( ) . iter ( ) ; while ( i . ha next ( ) ) { map . entri , e = i . next ( ) ; map entri entri = ( map entri ) super . get ( e . get kei ( ) ) ; ( entri = null entri . primari ( ) valu . equal ( entri . get valu ( ) ) ) return true ; } while return fals ; } end }	overrid public collect object valu ( ) { arrai list object valu = new arrai list object ( ) ; iter map . entri , >> i = super . entri set ( ) . iter ( ) ; while ( i . ha next ( ) ) { map . entri , e = i . next ( ) ; map entri entri = ( map entri ) super . get ( e . get kei ( ) ) ; ( entri = null entri . primari ( ) entri . get valu ( ) = null ) valu . add ( entri . get valu ( ) ) ; } return collect . unmodifi collect ( valu ) ; }	public boolean primari ( ) { return ( ( proxi ) ( backup ) ) ; }	overrid public int size ( ) { todo , implement counter variabl instead onli count activ member thi node int counter = 0 ; iter map . entri , >> = super . entri set ( ) . iter ( ) ; while ( = null . ha next ( ) ) { map . entri , e = . next ( ) ; ( e = null ) { map entri entri = ( map entri ) super . get ( e . get kei ( ) ) ; ( entri = null entri . primari ( ) entri . get valu ( ) = null ) counter ; } } return counter ; }	overrid public set object kei set ( ) { todo implement should onli return kei where thi activ . link hash set object set = new link hash set object ( super . size ( ) ) ; iter map . entri , >> i = super . entri set ( ) . iter ( ) ; while ( i . ha next ( ) ) { map . entri , e = i . next ( ) ; object kei = e . get kei ( ) ; map entri entri = ( map entri ) super . get ( kei ) ; ( entri = null entri . primari ( ) ) set . add ( kei ) ; } return collect . unmodifi set ( set ) ; }	public add thi session set activ session thi manag . param session session ad void add ( session session ) { session . put ( session . get id intern ( ) , session ) ; int size = session . size ( ) ; ( size max activ ) { synchron ( max activ updat lock ) { ( size max activ ) { max activ = size ; } } } }
public return specifi request attribut exist ; otherwis , return code null code . param name name request attribut return object get attribut ( string name ) { ( name . equal ( global . dispatch type attr ) ) { return ( intern dispatch type = = null ) dispatch type . request : intern dispatch type ; } els ( name . equal ( global . dispatch request path attr ) ) { return ( request dispatch path = = null ) get request path mb ( ) . string ( ) : request dispatch path . string ( ) ; } ( name . equal ( global . async support attr ) ) { return async support ; } object attr = attribut . get ( name ) ; ( attr = null ) return ( attr ) ; attr = coyot request . get attribut ( name ) ; ( attr = null ) return attr ; ( sslattribut ( name ) ) { coyot request . action ( action code . action req ssl attribut , coyot request ) ; attr = coyot request . get attribut ( global . certif attr ) ; ( attr = null ) { attribut . put ( global . certif attr , attr ) ; } attr = coyot request . get attribut ( global . cipher suit attr ) ; ( attr = null ) { attribut . put ( global . cipher suit attr , attr ) ; } attr = coyot request . get attribut ( global . kei size attr ) ; ( attr = null ) { attribut . put ( global . kei size attr , attr ) ; } attr = coyot request . get attribut ( global . ssl session id attr ) ; ( attr = null ) { attribut . put ( global . ssl session id attr , attr ) ; } attr = coyot request . get attribut ( global . ssl session mgr attr ) ; ( attr = null ) { attribut . put ( global . ssl session mgr attr , attr ) ; } attr = attribut . get ( name ) ; } return attr ; }	public releas all object refer , initi instanc variabl , prepar reus thi object . void recycl ( ) { context = null ; wrapper = null ; intern dispatch type = null ; request dispatch path = null ; comet = fals ; ( event = null ) { event . clear ( ) ; event = null ; } auth type = null ; input buffer . recycl ( ) ; us input stream = fals ; us reader = fals ; user princip = null ; subject = null ; session pars = fals ; paramet pars = fals ; part = null ; part pars except = null ; cooki pars = fals ; local . clear ( ) ; local pars = fals ; secur = fals ; remot addr = null ; remot host = null ; remot port = 1 ; local port = 1 ; local addr = null ; local name = null ; attribut . clear ( ) ; note . clear ( ) ; cooki = null ; ( session = null ) { session . end access ( ) ; } session = null ; request session cooki = fals ; request session id = null ; request session url = fals ; ( global . secur enabl connector . recycl facad ) { paramet map = new paramet map string , string ( ) ; } els { paramet map . set lock ( fals ) ; paramet map . clear ( ) ; } map data . recycl ( ) ; ( global . secur enabl connector . recycl facad ) { ( facad = null ) { facad . clear ( ) ; facad = null ; } ( input stream = null ) { input stream . clear ( ) ; input stream = null ; } ( reader = null ) { reader . clear ( ) ; reader = null ; } } async support = null ; ( async context = null ) async context . recycl ( ) ; async context = null ; path paramet . clear ( ) ; }	public get coyot request . org . apach . coyot . request get coyot request ( ) { return ( thi . coyot request ) ; }	public return name all request attribut thi request , empti code enumer code ar none . note attribut name return onli those attribut set via { link set attribut ( string , object ) } . tomcat intern attribut includ although thei ar access via { link get attribut ( string ) } . tomcat intern attribut includ : ul li { link global dispatch type attr } li li { link global dispatch request path attr } li li { link global async support attr } li li { link global certif attr } ( ssl connect onli ) li li { link global cipher suit attr } ( ssl connect onli ) li li { link global kei size attr } ( ssl connect onli ) li li { link global ssl session id attr } ( ssl connect onli ) li li { link global ssl session mgr attr } ( ssl connect onli ) li ul underli connector mai also expos request attribut . all have name start org . apach . tomcat includ : ul li org . apach . tomcat . sendfil . support li li org . apach . tomcat . comet . support li li org . apach . tomcat . comet . timeout . support li ul connector implement mai return some , all none attribut mai also support addit attribut . enumer string get attribut name ( ) { ( secur ( ) ) { get attribut ( global . certif attr ) ; } return new enumer string ( attribut . kei set ( ) , true ) ; }
socket state async dispatch ( socket statu statu ) throw ioexcept { request info rp = request . get request processor ( ) ; try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; error = adapt . async dispatch ( request , respons , statu ) ; } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { log . error ( sm . get string ( http11processor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; adapt . log ( request , respons , 0 ) ; error = true ; } rp . set stage ( org . apach . coyot . constant . stage end ) ; ( error ) { recycl ( ) ; return socket state . close ; } els ( async ) { return socket state . long ; } els { ( keep aliv ) { recycl ( ) ; return socket state . close ; } els { return socket state . open ; } } }	public boolean async dispatch ( org . apach . coyot . request req , org . apach . coyot . respons re , socket statu statu ) throw except { request request = ( request ) req . get note ( adapt note ) ; respons respons = ( respons ) re . get note ( adapt note ) ; ( request = = null ) { throw new illeg state except ( dispatch mai onli happen exist request . ) ; } boolean comet = fals ; boolean async = fals ; boolean success = true ; try { ( statu = = socket statu . timeout ) { async context impl async con impl = ( async context impl ) request . get async context ( ) ; todo servlet3 async configur set time out async con impl . set timeout state ( ) ; } ( statu = = socket statu . error statu = = socket statu . stop statu = = socket statu . disconnect ) { async context impl async con impl = ( async context impl ) request . get async context ( ) ; todo servlet3 async configur set time out async con impl . set error state ( new ioexcept ( socket error . ) ) ; } while ( success ) { async context impl impl = ( async context impl ) request . get async context ( ) ; call contain ( impl . get state ( ) = = async context impl . async state . dispatch ) { call contain try { impl . complet ( ) ; connector . get servic ( ) . get contain ( ) . get pipelin ( ) . get first ( ) . invok ( request , respons ) ; } final { success = fals ; } } els ( impl . get state ( ) = = async context impl . async state . start ) { todo servlet3 async re . action ( action code . action async start , request . get async context ( ) ) ; async = true ; break ; } els ( impl . get state ( ) = = async context impl . async state . start ) { todo servlet3 async async = fals ; break ; } els ( impl . get state ( ) = = async context impl . async state . error dispatch ) { async = fals ; success = fals ; connector . get servic ( ) . get contain ( ) . get pipelin ( ) . get first ( ) . invok ( request , respons ) ; } els { try { connector . get servic ( ) . get contain ( ) . get pipelin ( ) . get first ( ) . invok ( request , respons ) ; } catch ( runtim except x ) { impl . set error state ( x ) ; } } } ( request . comet ( ) ) { ( respons . close ( ) respons . error ( ) ) { ( request . get avail ( ) ( request . get content length ( ) 0 ( request . paramet pars ( ) ) ) ) { invok read event right awai ar avail byte ( event ( req , re , socket statu . open ) ) { comet = true ; re . action ( action code . action comet begin , null ) ; } } els { comet = true ; re . action ( action code . action comet begin , null ) ; } } els { clear filter chain , otherwis reset elsewher sinc thi comet request request . set filter chain ( null ) ; } } ( async comet ) { respons . finish respons ( ) ; req . action ( action code . action post request , null ) ; } } catch ( ioexcept e ) { success = fals ; ignor } catch ( throwabl t ) { success = fals ; log . error ( sm . get string ( coyot adapt . servic ) , t ) ; } final { req . get request processor ( ) . set worker thread name ( null ) ; recycl wrapper request respons ( success ( comet async ) ) { request . recycl ( ) ; respons . recycl ( ) ; } els { clear convert so minimum amount memori us thi processor request . clear encod ( ) ; respons . clear encod ( ) ; } } return success ; }	public boolean async dispatch ( ) { ( async context = = null ) { return fals ; } return ( async context . get state ( ) = = async context impl . async state . dispatch async context . get state ( ) = = async context impl . async state . dispatch runnabl async context . get state ( ) = = async context impl . async state . time out async context . get state ( ) = = async context impl . async state . start async context . get state ( ) = = async context impl . async state . error dispatch async context . get state ( ) = = async context impl . async state . complet ) ; }	public boolean start ( ) { return ( state . get ( ) = = async state . start state . get ( ) = = async state . dispatch state . get ( ) = = async state . dispatch runnabl ) ; }	overrid public void complet ( ) { ( log . debug enabl ( ) ) { log . debug ( async context complet call state . get ( ) ; request . get request uri ( ) request . get queri string ( ) , new debug except ( ) ) ; } ( state . get ( ) = = async state . complet ) { do noth } els ( state . compar set ( async state . dispatch , async state . complet ) state . compar set ( async state . start , async state . complet ) ) { todo servlet3 async atom boolean dispatch = new atom boolean ( fals ) ; request . get coyot request ( ) . action ( action code . action async complet , dispatch ) ; ( dispatch . get ( ) ) do intern complet ( fals ) ; } els ( state . compar set ( async state . dispatch runnabl , async state . complet runnabl ) ) { do noth } els { throw new illeg state except ( complet allow . invalid state : state . get ( ) ) ; } }	public void do intern dispatch ( ) throw servlet except , ioexcept { ( thi . state . compar set ( async state . time out , async state . complet ) ) { log . debug ( time out ) ; boolean listen invok = fals ; ( async listen wrapper listen : listen ) { listen . fire timeout ( event ) ; listen invok = true ; } ( listen invok ) { ( ( http servlet respons ) servlet respons ) . set statu ( 500 ) ; } do intern complet ( true ) ; } els ( thi . state . compar set ( async state . error dispatch , async state . complet ) ) { log . debug ( error ) ; boolean listen invok = fals ; ( async listen wrapper listen : listen ) { try { listen . fire error ( event ) ; } catch ( illeg state except x ) { log . debug ( listen invok invalid state . , x ) ; } catch ( except x ) { log . debug ( except dure error . , x ) ; } listen invok = true ; } ( listen invok ) { ( ( http servlet respons ) servlet respons ) . set statu ( 500 ) ; } do intern complet ( true ) ; } els ( thi . state . compar set ( async state . dispatch , async state . dispatch ) ) { ( thi . dispatch = null ) { try { dispatch . run ( ) ; } catch ( runtim except x ) { do intern complet ( true ) ; ( x . get caus ( ) instanceof servlet except ) throw ( servlet except ) x . get caus ( ) ; ( x . get caus ( ) instanceof ioexcept ) throw ( ioexcept ) x . get caus ( ) ; els throw new servlet except ( x ) ; } final { dispatch = null ; } } } els ( thi . state . get ( ) = = async state . dispatch runnabl ) { ( thi . dispatch = null ) { try { dispatch . run ( ) ; } catch ( runtim except x ) { do intern complet ( true ) ; ( x . get caus ( ) instanceof servlet except ) throw ( servlet except ) x . get caus ( ) ; ( x . get caus ( ) instanceof ioexcept ) throw ( ioexcept ) x . get caus ( ) ; els throw new servlet except ( x ) ; } final { dispatch = null ; } ( thi . state . compar set ( async state . complet runnabl , async state . complet ) ) { do intern complet ( fals ) ; } els ( thi . state . get ( ) = = async state . dispatch runnabl ) { do intern complet ( true ) ; throw new illeg state except ( fail call dispatch ( ) complet ( ) after start ( ) ) ; } } } els ( thi . state . get ( ) = = async state . complet ) { do intern complet ( fals ) ; } els { throw new illeg state except ( dispatch illeg . invalid state : state . get ( ) ) ; } }	protect void do get ( final http servlet request req , final http servlet respons resp ) throw servlet except , ioexcept { result . append ( 1 ) ; result . append ( req . async start ( ) ) ; req . start async ( ) ; result . append ( 2 ) ; result . append ( req . async start ( ) ) ; req . get async context ( ) . start ( new runnabl ( ) { overrid public void run ( ) { try { result . append ( 3 ) ; result . append ( req . async start ( ) ) ; thread . sleep ( 1000 ) ; result . append ( 4 ) ; result . append ( req . async start ( ) ) ; req . get async context ( ) . complet ( ) ; result . append ( 5 ) ; result . append ( req . async start ( ) ) ; } catch ( interrupt except e ) { todo auto gener catch block e . print stack trace ( ) ; } } } ) ; pointless method call so somewher put break point when debug req . get method ( ) ; }	overrid public void start ( final runnabl run ) { ( log . debug enabl ( ) ) { log . debug ( async context start call state . get ( ) ; request . get request uri ( ) request . get queri string ( ) , new debug except ( ) ) ; } ( state . compar set ( async state . start , async state . dispatch runnabl ) state . compar set ( async state . dispatch , async state . dispatch runnabl ) ) { todo servlet3 async final servlet context sctx = get servlet request ( ) . get servlet context ( ) ; runnabl r = new runnabl ( ) { } } }	public void test bug49528 ( ) throw except { setup tomcat instanc tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; bug49528servlet servlet = new bug49528servlet ( ) ; wrapper wrapper = tomcat . add servlet ( ctx , servlet , servlet ) ; wrapper . set async support ( true ) ; ctx . add servlet map ( , servlet ) ; tomcat . start ( ) ; call servlet onc get url ( http : localhost : get port ( ) ) ; assert equal ( , servlet . get result ( ) ) ; }
public void test configur ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; context root = tomcat . add context ( , temp dir ) ; filter def filter def = new filter def ( ) ; filter def . add init paramet ( expir default , access plu 1 month ) ; filter def . add init paramet ( expir type text html , access plu 1 month 15 dai 2 hour ) ; filter def . add init paramet ( expir type imag gif , modif plu 5 hour 3 minut ) ; filter def . add init paramet ( expir type imag jpg , a10000 ) ; filter def . add init paramet ( expir type video mpeg , m20000 ) ; filter def . add init paramet ( expir activ , off ) ; filter def . add init paramet ( expir exclud respons statu code , 304 , 503 ) ; expir filter expir filter = new expir filter ( ) ; filter def . set filter ( expir filter ) ; filter def . set filter class ( expir filter . class . get name ( ) ) ; filter def . set filter name ( expir filter . class . get name ( ) ) ; root . add filter def ( filter def ) ; filter map filter map = new filter map ( ) ; filter map . set filter name ( expir filter . class . get name ( ) ) ; filter map . add urlpattern ( ) ; tomcat . start ( ) ; try { verifi exclud respons statu code { int exclud respons statu code = expir filter . get exclud respons statu code int ( ) ; assert . assert equal ( 2 , exclud respons statu code . length ) ; assert . assert equal ( 304 , exclud respons statu code 0 ) ; assert . assert equal ( 503 , exclud respons statu code 1 ) ; } verifi default configur { expir configur expir configur = expir filter . get default expir configur ( ) ; assert . assert equal ( start point . access time , expir configur . get start point ( ) ) ; assert . assert equal ( 1 , expir configur . get durat ( ) . size ( ) ) ; assert . assert equal ( durat unit . month , expir configur . get durat ( ) . get ( 0 ) . get unit ( ) ) ; assert . assert equal ( 1 , expir configur . get durat ( ) . get ( 0 ) . get amount ( ) ) ; } verifi text html { expir configur expir configur = expir filter . get expir configur content type ( ) . get ( text html ) ; assert . assert equal ( start point . access time , expir configur . get start point ( ) ) ; assert . assert equal ( 3 , expir configur . get durat ( ) . size ( ) ) ; durat month = expir configur . get durat ( ) . get ( 0 ) ; assert . assert equal ( durat unit . month , month . get unit ( ) ) ; assert . assert equal ( 1 , month . get amount ( ) ) ; durat fifteen dai = expir configur . get durat ( ) . get ( 1 ) ; assert . assert equal ( durat unit . dai , fifteen dai . get unit ( ) ) ; assert . assert equal ( 15 , fifteen dai . get amount ( ) ) ; durat two hour = expir configur . get durat ( ) . get ( 2 ) ; assert . assert equal ( durat unit . hour , two hour . get unit ( ) ) ; assert . assert equal ( 2 , two hour . get amount ( ) ) ; } verifi imag gif { expir configur expir configur = expir filter . get expir configur content type ( ) . get ( imag gif ) ; assert . assert equal ( start point . last modif time , expir configur . get start point ( ) ) ; assert . assert equal ( 2 , expir configur . get durat ( ) . size ( ) ) ; durat five hour = expir configur . get durat ( ) . get ( 0 ) ; assert . assert equal ( durat unit . hour , five hour . get unit ( ) ) ; assert . assert equal ( 5 , five hour . get amount ( ) ) ; durat three minut = expir configur . get durat ( ) . get ( 1 ) ; assert . assert equal ( durat unit . minut , three minut . get unit ( ) ) ; assert . assert equal ( 3 , three minut . get amount ( ) ) ; } verifi imag jpg { expir configur expir configur = expir filter . get expir configur content type ( ) . get ( imag jpg ) ; assert . assert equal ( start point . access time , expir configur . get start point ( ) ) ; assert . assert equal ( 1 , expir configur . get durat ( ) . size ( ) ) ; durat ten thousand second = expir configur . get durat ( ) . get ( 0 ) ; assert . assert equal ( durat unit . second , ten thousand second . get unit ( ) ) ; assert . assert equal ( 10000 , ten thousand second . get amount ( ) ) ; } verifi video mpeg { expir configur expir configur = expir filter . get expir configur content type ( ) . get ( video mpeg ) ; assert . assert equal ( start point . last modif time , expir configur . get start point ( ) ) ; assert . assert equal ( 1 , expir configur . get durat ( ) . size ( ) ) ; durat twenti thousand second = expir configur . get durat ( ) . get ( 0 ) ; assert . assert equal ( durat unit . second , twenti thousand second . get unit ( ) ) ; assert . assert equal ( 20000 , twenti thousand second . get amount ( ) ) ; } } final { tomcat . stop ( ) ; } }

start thi compon implement requir { link lifecycl base start intern ( ) } . start cluster commun channel , thi connect other node cluster , request current session state transfer thi node . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect synchron void start intern ( ) throw lifecycl except { try { ( log . info enabl ( ) ) log . info ( start cluster manag . . . : get name ( ) ) ; ( cluster = = null ) { log . error ( start . . . cluster associ thi context : get name ( ) ) ; set state ( lifecycl state . fail ) ; return ; } cluster . regist manag ( thi ) ; ( cluster . get member ( ) . length 0 ) { member mbr = cluster . get member ( ) 0 ; session messag msg = new session messag impl ( thi . get name ( ) , session messag . evt get all session , null , get all , get all thi . get name ( ) ) ; cluster . send ( msg , mbr ) ; ( log . warn enabl ( ) ) log . warn ( manag get name ( ) , request session state from mbr . thi oper timeout session state ha been receiv within 60 second ) ; long req start = system . current time milli ( ) ; long req now = 0 ; boolean timeout = fals ; do { try { thread . sleep ( 100 ) ; } catch ( except sleep ) { } req now = system . current time milli ( ) ; timeout = ( ( req now req start ) ( 1000 60 ) ) ; } while ( ( state transfer ( ) ) ( timeout ) ) ; ( timeout ( state transfer ( ) ) ) { log . error ( manag get name ( ) , session state receiv , time out . ) ; } els { ( log . info enabl ( ) ) log . info ( manag get name ( ) , session state receiv ( req now req start ) ms . ) ; } } els { ( log . info enabl ( ) ) log . info ( manag get name ( ) , skip state transfer . member activ cluster group . ) ; } end super . start intern ( ) ; } catch ( except x ) { log . error ( unabl start simpl tcp replic manag , x ) ; set state ( lifecycl state . fail ) ; } }
public start class loader . except lifecycl except lifecycl error occur void start ( ) throw lifecycl except { start = true ; string encod = null ; try { encod = system . get properti ( file . encod ) ; } catch ( except e ) { return ; } ( encod . index ( ebcdic ) = 1 ) { need convert = true ; } }
protect void add builtin command ( ) { add command ( config , new ssiconfig ( ) ) ; add command ( echo , new ssiecho ( ) ) ; add command ( exec , new ssiexec ( ) ) ; add command ( includ , new ssiinclud ( ) ) ; add command ( flastmod , new ssiflastmod ( ) ) ; add command ( fsize , new ssifsiz ( ) ) ; add command ( printenv , new ssiprintenv ( ) ) ; add command ( set , new ssiset ( ) ) ; ssicondit ssi condit = new ssicondit ( ) ; add command ( , ssi condit ) ; add command ( elif , ssi condit ) ; add command ( endif , ssi condit ) ; add command ( els , ssi condit ) ; }	protect void process ssi ( http servlet request req , http servlet respons re , url resourc ) throw ioexcept { ssiextern resolv ssi extern resolv = new ssiservlet extern resolv ( get servlet context ( ) , req , re , virtual webapp rel , debug , input encod ) ; ssiprocessor ssi processor = new ssiprocessor ( ssi extern resolv , debug ) ; print writer print writer = null ; string writer string writer = null ; ( buffer ) { string writer = new string writer ( ) ; print writer = new print writer ( string writer ) ; } els { print writer = re . get writer ( ) ; } urlconnect resourc info = resourc . open connect ( ) ; input stream resourc input stream = resourc info . get input stream ( ) ; string encod = resourc info . get content encod ( ) ; ( encod = = null ) { encod = input encod ; } input stream reader isr ; ( encod = = null ) { isr = new input stream reader ( resourc input stream ) ; } els { isr = new input stream reader ( resourc input stream , encod ) ; } buffer reader buffer reader = new buffer reader ( isr ) ; long last modifi = ssi processor . process ( buffer reader , resourc info . get last modifi ( ) , print writer ) ; ( last modifi 0 ) { re . set date header ( last modifi , last modifi ) ; } ( buffer ) { print writer . flush ( ) ; string text = string writer . string ( ) ; re . get writer ( ) . write ( text ) ; } buffer reader . close ( ) ; }	public void do filter ( servlet request request , servlet respons respons , filter chain chain ) throw ioexcept , servlet except { cast onc http servlet request req = ( http servlet request ) request ; http servlet respons re = ( http servlet respons ) respons ; indic we re ssi process req . set attribut ( global . ssi flag attr , true ) ; setup captur output byte arrai servlet output stream baso = new byte arrai servlet output stream ( ) ; respons includ wrapper respons includ wrapper = new respons includ wrapper ( config . get servlet context ( ) , req , re , baso ) ; process remaind filter chain chain . do filter ( req , respons includ wrapper ) ; we can t assum chain flush output respons includ wrapper . flush output stream writer ( ) ; byte byte = baso . byte arrai ( ) ; get content type string content type = respons includ wrapper . get content type ( ) ; thi allow type ssi process ( content type reg ex . matcher ( content type ) . match ( ) ) { string encod = re . get charact encod ( ) ; set up ssi process ssiextern resolv ssi extern resolv = new ssiservlet extern resolv ( config . get servlet context ( ) , req , re , virtual webapp rel , debug , encod ) ; ssiprocessor ssi processor = new ssiprocessor ( ssi extern resolv , debug ) ; prepar reader writer reader reader = new input stream reader ( new byte arrai input stream ( byte ) , encod ) ; byte arrai output stream ssiout = new byte arrai output stream ( ) ; print writer writer = new print writer ( new output stream writer ( ssiout , encod ) ) ; do ssi process long last modifi = ssi processor . process ( reader , respons includ wrapper . get last modifi ( ) , writer ) ; set output byte writer . flush ( ) ; byte = ssiout . byte arrai ( ) ; overrid header ( expir = null ) { re . set date header ( expir , ( new java . util . date ( ) ) . get time ( ) expir . long valu ( ) 1000 ) ; } ( last modifi 0 ) { re . set date header ( last modifi , last modifi ) ; } re . set content length ( byte . length ) ; matcher shtml matcher = shtml reg ex . matcher ( respons includ wrapper . get content type ( ) ) ; ( shtml matcher . match ( ) ) { convert shtml mime type ordinari html mime type preserv encod , ani . string enc = shtml matcher . group ( 1 ) ; re . set content type ( text html ( ( enc = null ) enc : ) ) ; } } write output output stream out = null ; try { out = re . get output stream ( ) ; } catch ( illeg state except e ) { ignor , try us writer } ( out = = null ) { re . get writer ( ) . write ( new string ( byte ) ) ; } els { out . write ( byte ) ; } }	public void init ( ) throw servlet except { ( get servlet config ( ) . get init paramet ( debug ) = null ) debug = integ . pars int ( get servlet config ( ) . get init paramet ( debug ) ) ; virtual webapp rel = boolean . pars boolean ( get servlet config ( ) . get init paramet ( virtual webapp rel ) ) ; ( get servlet config ( ) . get init paramet ( expir ) = null ) expir = long . valu ( get servlet config ( ) . get init paramet ( expir ) ) ; buffer = boolean . pars boolean ( get servlet config ( ) . get init paramet ( buffer ) ) ; input encod = get servlet config ( ) . get init paramet ( input encod ) ; ( get servlet config ( ) . get init paramet ( output encod ) = null ) output encod = get servlet config ( ) . get init paramet ( output encod ) ; ( debug 0 ) log ( ssiservlet . init ( ) ssi invok start debug = debug ) ; }	public void init ( filter config config ) throw servlet except { thi . config = config ; ( config . get init paramet ( debug ) = null ) { debug = integ . pars int ( config . get init paramet ( debug ) ) ; } ( config . get init paramet ( content type ) = null ) { content type reg ex = pattern . compil ( config . get init paramet ( content type ) ) ; } els { content type reg ex = shtml reg ex ; } virtual webapp rel = boolean . pars boolean ( config . get init paramet ( virtual webapp rel ) ) ; ( config . get init paramet ( expir ) = null ) expir = long . valu ( config . get init paramet ( expir ) ) ; ( debug 0 ) config . get servlet context ( ) . log ( ssifilt . init ( ) ssi invok start debug = debug ) ; }
public get string from underli resourc bundl format given set argument . param kei param arg string get string ( final string kei , final object . . . arg ) { string valu = get string ( kei ) ; ( valu = = null ) { valu = kei ; } messag format mf = new messag format ( valu ) ; mf . set local ( local ) ; return mf . format ( arg , new string buffer ( ) , null ) . string ( ) ; }
public void set content type ( string ct ) { ( ct = null ct . start ( text ) ct . index ( charset = ) 0 ) { us get charact encod ( ) case charset ha alreadi been set separ call . super . set content type ( ct ; charset = get charact encod ( ) ) ; } els { super . set content type ( ct ) ; } }	public void do filter ( servlet request request , servlet respons respons , filter chain chain ) throw ioexcept , servlet except { wrap respons ( respons instanceof http servlet respons ) { respons wrapper wrap = new respons wrapper ( ( http servlet respons ) respons ) ; chain . do filter ( request , wrap ) ; } els { chain . do filter ( request , respons ) ; } }	public void init ( filter config filter config ) throw servlet except { noop }	public void init ( filter config filter config ) throw servlet except { noop }
public void write gzip ( byte b , int off , int len ) throw ioexcept { ( debug 1 ) { system . out . println ( write gzip , len = len ) ; } ( debug 2 ) { system . out . print ( write gzip ( ) ; system . out . write ( b , off , len ) ; system . out . println ( ) ) ; } ( gzipstream = = null ) { ( debug 1 ) { system . out . println ( new gzipoutput stream ) ; } ( respons . commit ( ) ) { ( debug 1 ) system . out . print ( respons alreadi commit . us origin output stream ) ; gzipstream = output ; } els { respons . add header ( content encod , gzip ) ; gzipstream = new gzipoutput stream ( output ) ; } } gzipstream . write ( b , off , len ) ; }
overrid protect void destroi intern ( ) throw lifecycl except { unregist ( onam mapper ) ; unregist ( onam protocol handler ) ; ( get servic ( ) = null ) { get servic ( ) . remov connector ( thi ) ; } super . destroi intern ( ) ; }	overrid protect void init intern ( ) throw lifecycl except { super . init intern ( ) ; initi adapt adapt = new coyot adapt ( thi ) ; protocol handler . set adapt ( adapt ) ; introspect util . set properti ( protocol handler , jk home , system . get properti ( catalina . base ) ) ; onam protocol handler = regist ( protocol handler , creat object name kei properti ( protocol handler ) ) ; mapper listen . set domain ( get domain ( ) ) ; onam mapper = regist ( mapper listen , creat object name kei properti ( mapper ) ) ; }	begin process request via thi connector . except lifecycl except fatal startup error occur overrid protect void start intern ( ) throw lifecycl except { set state ( lifecycl state . start ) ; protocol handler . init ( ) need wait until connector . start ( ) try { protocol handler . init ( ) ; } catch ( except e ) { throw new lifecycl except ( sm . get string ( coyot connector . protocol handler initi fail , e ) ) ; } try { protocol handler . start ( ) ; } catch ( except e ) { string err prefix = ; ( thi . servic = null ) { err prefix = servic . get name ( ) : thi . servic . get name ( ) ; ; } throw new lifecycl except ( err prefix sm . get string ( coyot connector . protocol handler start fail , e ) ) ; } mapper listen doesn t follow lifecycl convent either mapper listen . init ( ) ; }	termin process request via thi connector . except lifecycl except fatal shutdown error occur overrid protect void stop intern ( ) throw lifecycl except { set state ( lifecycl state . stop ) ; protocol handler . destroi ( ) need call connector . stop ( ) try { protocol handler . destroi ( ) ; } catch ( except e ) { throw new lifecycl except ( sm . get string ( coyot connector . protocol handler destroi fail , e ) ) ; } mapper listen doesn t follow lifecycl convent either mapper listen . destroi ( ) ; }
protect process default configur file , exist . void context config ( ) { open default web . xml file , exist ( default context xml = = null context instanceof standard context ) { default context xml = ( ( standard context ) context ) . get default context xml ( ) ; } set default we don t have ani overrid ( default context xml = = null ) get default context xml ( ) ; ( context . get overrid ( ) ) { file default context file = new file ( get base dir ( ) , default context xml ) ; ( default context file . exist ( ) ) { try { url default context url = default context file . uri ( ) . url ( ) ; process context config ( default context url ) ; } catch ( malform urlexcept e ) { log . error ( sm . get string ( context config . bad url , default context file ) , e ) ; } } file host context file = new file ( get config base ( ) , get host config path ( constant . host context xml ) ) ; ( host context file . exist ( ) ) { try { url host context url = host context file . uri ( ) . url ( ) ; process context config ( host context url ) ; } catch ( malform urlexcept e ) { log . error ( sm . get string ( context config . bad url , host context file ) , e ) ; } } } ( context . get config file ( ) = null ) process context config ( context . get config file ( ) ) ; }
public set content length ( byte ) thi respons . param length new content length void set content length ( int length ) { ( commit ( ) ) return ; ignor ani call from includ servlet ( includ ) return ; ( us writer ) return ; coyot respons . set content length ( length ) ; }	public set content type thi respons . param type new content type void set content type ( string type ) { ( commit ( ) ) return ; ignor ani call from includ servlet ( includ ) return ; ignor charset get writer ( ) ha alreadi been call ( us writer ) { ( type = null ) { int index = type . index ( ; ) ; ( index = 1 ) { type = type . substr ( 0 , index ) ; } } } coyot respons . set content type ( type ) ; check see content type contain charset ( type = null ) { int index = type . index ( ; ) ; ( index = 1 ) { int len = type . length ( ) ; index ; while ( index len charact . space ( type . char ( index ) ) ) { index ; } ( index 7 len type . char ( index ) = = c type . char ( index 1 ) = = h type . char ( index 2 ) = = type . char ( index 3 ) = = r type . char ( index 4 ) = = s type . char ( index 5 ) = = e type . char ( index 6 ) = = t type . char ( index 7 ) = = = ) { charact encod set = true ; } } } }
public remov exist child contain from associ thi parent contain . param child exist child contain remov void remov child ( contain child ) { ( child = = null ) { return ; } synchron ( children ) { ( children . get ( child . get name ( ) ) = = null ) return ; children . remov ( child . get name ( ) ) ; } ( get state ( ) . avail ( ) ) { try { ( child . get state ( ) . avail ( ) ) { child . stop ( ) ; } } catch ( lifecycl except e ) { log . error ( contain base . remov child : stop : , e ) ; } } fire contain event ( remov child event , child ) ; child . set parent ( null ) ; }
privat regist context . void regist context ( context context ) { string context name = context . get name ( ) ; ( . equal ( context name ) ) { context name = ; } string host name = context . get parent ( ) . get name ( ) ; javax . name . context resourc = context . get resourc ( ) ; string welcom file = context . find welcom file ( ) ; mapper . add context ( host name , context name , context , welcom file , resourc ) ; context . add contain listen ( thi ) ; ( contain contain : context . find children ( ) ) { regist wrapper ( ( wrapper ) contain ) ; } ( log . debug enabl ( ) ) { log . debug ( sm . get string ( mapper listen . regist context , context name ) ) ; } }	privat regist host . void regist host ( host host ) { string alias = host . find alias ( ) ; mapper . add host ( host . get name ( ) , alias , host . get object name ( ) ) ; host . add contain listen ( thi ) ; ( contain contain : host . find children ( ) ) { regist context ( ( context ) contain ) ; } ( log . debug enabl ( ) ) { log . debug ( sm . get string ( mapper listen . regist host , host . get name ( ) , domain ) ) ; } }	protect pars addit request paramet . boolean post pars request ( org . apach . coyot . request req , request request , org . apach . coyot . respons re , respons respons ) throw except { otherwis , us connector configur ( req . scheme ( ) . null ( ) ) { us processor specifi scheme determin secur state request . set secur ( req . scheme ( ) . equal ( http ) ) ; } els { us connector scheme secur configur , ( default http fals respect ) req . scheme ( ) . set string ( connector . get scheme ( ) ) ; request . set secur ( connector . get secur ( ) ) ; } fixm : code below doesnt belong here , thi onli have sens http11 , ajp13 . . thi point host header ha been process . overrid proxi port proxi host ar set string proxi name = connector . get proxi name ( ) ; int proxi port = connector . get proxi port ( ) ; ( proxi port = 0 ) { req . set server port ( proxi port ) ; } ( proxi name = null ) { req . server name ( ) . set string ( proxi name ) ; } copi raw uri decod uri messag byte decod uri = req . decod uri ( ) ; decod uri . duplic ( req . request uri ( ) ) ; pars path paramet . thi : strip out path paramet convert decod uri byte pars path paramet ( req , request ) ; xx decod url try { req . get urldecod ( ) . convert ( decod uri , fals ) ; } catch ( ioexcept ioe ) { re . set statu ( 400 ) ; re . set messag ( invalid uri : ioe . get messag ( ) ) ; connector . get servic ( ) . get contain ( ) . log access ( request , respons , 0 , true ) ; return fals ; } normal ( normal ( req . decod uri ( ) ) ) { re . set statu ( 400 ) ; re . set messag ( invalid uri ) ; connector . get servic ( ) . get contain ( ) . log access ( request , respons , 0 , true ) ; return fals ; } charact decod convert uri ( decod uri , request ) ; check uri still normal ( check normal ( req . decod uri ( ) ) ) { re . set statu ( 400 ) ; re . set messag ( invalid uri charact encod ) ; connector . get servic ( ) . get contain ( ) . log access ( request , respons , 0 , true ) ; return fals ; } set remot princip string princip = req . get remot user ( ) . string ( ) ; ( princip = null ) { request . set user princip ( new coyot princip ( princip ) ) ; } set author type string authtyp = req . get auth type ( ) . string ( ) ; ( authtyp = null ) { request . set auth type ( authtyp ) ; } request map . messag byte server name ; ( connector . get us ipvhost ( ) ) { server name = req . local name ( ) ; ( server name . null ( ) ) { well , thei did ask re . action ( action code . action req local name attribut , null ) ; } } els { server name = req . server name ( ) ; } ( request . async start ( ) ) { todo servlet3 async reset map data , should prolli done elsewher request . get map data ( ) . recycl ( ) ; } connector . get mapper ( ) . map ( server name , decod uri , request . get map data ( ) ) ; request . set context ( ( context ) request . get map data ( ) . context ) ; request . set wrapper ( ( wrapper ) request . get map data ( ) . wrapper ) ; filter trace method ( connector . get allow trace ( ) req . method ( ) . equal ignor case ( trace ) ) { wrapper wrapper = request . get wrapper ( ) ; string header = null ; ( wrapper = null ) { string method = wrapper . get servlet method ( ) ; ( method = null ) { ( int i = 0 ; i method . length ; i ) { ( trace . equal ( method i ) ) { continu ; } ( header = = null ) { header = method i ; } els { header = , method i ; } } } } re . set statu ( 405 ) ; re . add header ( allow , header ) ; re . set messag ( trace method allow ) ; request . get context ( ) . log access ( request , respons , 0 , true ) ; return fals ; } includ session id redirect ( request . get servlet context ( ) . get effect session track mode ( ) . contain ( session track mode . url ) ) { get session id wa string session id = request . get path paramet ( applic session cooki config . get session uri param name ( request . get context ( ) ) ) ; ( session id = null ) { request . set request session id ( session id ) ; request . set request session url ( true ) ; } } possibl redirect messag byte redirect path mb = request . get map data ( ) . redirect path ; ( redirect path mb . null ( ) ) { string redirect path = url encod . encod ( redirect path mb . string ( ) ) ; string queri = request . get queri string ( ) ; ( request . request session id from url ( ) ) { thi optim , thi veri common , shouldn t matter redirect path = redirect path ; applic session cooki config . get session uri param name ( request . get context ( ) ) = request . get request session id ( ) ; } ( queri = null ) { thi optim , thi veri common , shouldn t matter redirect path = redirect path queri ; } respons . send redirect ( redirect path ) ; request . get context ( ) . log access ( request , respons , 0 , true ) ; return fals ; } final look session id cooki ssl session pars session cooki id ( req , request ) ; pars session ssl id ( request ) ; return true ; }	public return host within which thi request process . host get host ( ) { ( get context ( ) = = null ) return null ; return ( host ) get context ( ) . get parent ( ) ; return ( ( host ) map data . host ) ; }	public add new context exist host . param host name virtual host name thi context belong param path context path param context context object param welcom resourc welcom file defin thi context param resourc static resourc context void add context ( string host name , string path , object context , string welcom resourc , javax . name . context resourc ) { host host = thi . host ; int po = find ( host , host name ) ; ( po 0 ) { add host ( host name , new string 0 , ) ; host = thi . host ; po = find ( host , host name ) ; } ( po 0 ) { log . error ( host found : host name ) ; } host host = host po ; ( host . name . equal ( host name ) ) { int slash count = slash count ( path ) ; synchron ( host ) { context context = host . context list . context ; updat nest ( slash count host . context list . nest ) { host . context list . nest = slash count ; } context new context = new context context . length 1 ; context new context = new context ( ) ; new context . name = path ; new context . object = context ; new context . welcom resourc = welcom resourc ; new context . resourc = resourc ; ( insert map ( context , new context , new context ) ) { host . context list . context = new context ; } } } }
public static creat new session cooki given session id param context context web applic param session id id session which cooki creat param secur should session cooki configur secur cooki creat session cooki ( context context , string session id , boolean secur ) { session cooki config scc = context . get servlet context ( ) . get session cooki config ( ) ; note : prioriti order session cooki configur : 1 . context level configur 2 . valu from session cooki config 3 . default cooki cooki = new cooki ( get session cooki name ( context ) , session id ) ; just appli default . cooki . set max ag ( scc . get max ag ( ) ) ; cooki . set comment ( scc . get comment ( ) ) ; ( context . get session cooki domain ( ) = = null ) { avoid possibl npe ( scc . get domain ( ) = null ) { cooki . set domain ( scc . get domain ( ) ) ; } } els { cooki . set domain ( context . get session cooki domain ( ) ) ; } alwai set secur request secur ( scc . secur ( ) secur ) { cooki . set secur ( true ) ; } alwai set http onli context configur ( scc . http onli ( ) context . get us http onli ( ) ) { cooki . set http onli ( true ) ; } string context path = context . get session cooki path ( ) ; ( context path = = null context path . length ( ) = = 0 ) { context path = scc . get path ( ) ; } ( context path = = null context path . length ( ) = = 0 ) { context path = context . get encod path ( ) ; } cooki . set path ( context path ) ; return cooki ; }
overrid protect string get object name kei properti ( ) { string builder kei properti = new string builder ( j2ee type = web modul , name = ) ; string host name = get parent ( ) . get name ( ) ; ( host name = = null ) { kei properti . append ( default ) ; } els { kei properti . append ( host name ) ; } string path name = get name ( ) ; ( . equal ( path name ) ) { kei properti . append ( ) ; } els { kei properti . append ( path name ) ; } kei properti . append ( , j2eeapplic = ) ; kei properti . append ( get j2eeapplic ( ) ) ; kei properti . append ( , j2eeserv = ) ; kei properti . append ( get j2eeserv ( ) ) ; return kei properti . string ( ) ; }	public set name resourc thi web applic . param name resourc new name resourc void set name resourc ( name resourc name resourc ) { process properti set chang name resourc old name resourc = thi . name resourc ; thi . name resourc = name resourc ; name resourc . set contain ( thi ) ; support . fire properti chang ( name resourc , old name resourc , thi . name resourc ) ; unregist ( onam name resoucr ) ; onam name resoucr = regist ( name resourc , type = name resourc , get object name kei properti ( ) ) ; }
privat return specifi url nonc ad queri string param url url modifi param nonc nonc add string add nonc ( string url ) { ( ( url = = null ) ( nonc = = null ) ) return ( url ) ; string path = url ; string queri = ; string anchor = ; int question = url . index ( ) ; ( question = 0 ) { path = url . substr ( 0 , question ) ; queri = url . substr ( question ) ; } int pound = path . index ( ) ; ( pound = 0 ) { anchor = path . substr ( pound ) ; path = path . substr ( 0 , pound ) ; } string builder sb = new string builder ( path ) ; sb . append ( anchor ) ; ( queri . length ( ) 0 ) { sb . append ( queri ) ; sb . append ( ) ; } els { sb . append ( ) ; } sb . append ( constant . csrf nonc request param ) ; sb . append ( = ) ; sb . append ( nonc ) ; return ( sb . string ( ) ) ; }	protect session get session path id ( string path , string id ) throw ioexcept { ( ( path = = null ) ( path . start ( ) path . equal ( ) ) ) { throw new illeg argument except ( sm . get string ( manag servlet . invalid path , request util . filter ( path ) ) ) ; } string search path = path ; ( path . equal ( ) ) search path = ; context context = ( context ) host . find child ( search path ) ; ( null = = context ) { throw new illeg argument except ( sm . get string ( manag servlet . context , request util . filter ( path ) ) ) ; } session session = context . get manag ( ) . find session ( id ) ; return session ; }	protect param req param resp throw servlet except throw ioexcept void displai session detail page ( http servlet request req , http servlet respons resp , string path , string session id ) throw servlet except , ioexcept { session session = get session path id ( path , session id ) ; strong note strong thi header overridden automat code request dispatch . forward ( ) code call ultim invok . http 1 . 0 resp . set header ( pragma , cach ) ; http 1 . 1 resp . set header ( cach control , cach , store , max ag = 0 ) ; 0 mean now resp . set date header ( expir , 0 ) ; req . set attribut ( current session , session ) ; get servlet context ( ) . get request dispatch ( session detail jsp path ) . includ ( req , resp ) ; }	protect session get session path ( string path ) { ( ( path = = null ) ( path . start ( ) path . equal ( ) ) ) { throw new illeg argument except ( sm . get string ( manag servlet . invalid path , request util . filter ( path ) ) ) ; } string search path = path ; ( path . equal ( ) ) search path = ; context context = ( context ) host . find child ( search path ) ; ( null = = context ) { throw new illeg argument except ( sm . get string ( manag servlet . context , request util . filter ( path ) ) ) ; } session session = context . get manag ( ) . find session ( ) ; return session ; }	protect compar session get compar ( string sort ) { compar session compar = null ; ( creation time . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session . get creation time ( ) ) ; } } ; } els ( id . equal ignor case ( sort ) ) { compar = new base session compar string ( ) { overrid public compar string get compar object ( session session ) { return session . get id ( ) ; } } ; } els ( last access time . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session . get last access time ( ) ) ; } } ; } els ( max inact interv . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session . get max inact interv ( ) ) ; } } ; } els ( new . equal ignor case ( sort ) ) { compar = new base session compar boolean ( ) { overrid public compar boolean get compar object ( session session ) { return boolean . valu ( session . get session ( ) . new ( ) ) ; } } ; } els ( local . equal ignor case ( sort ) ) { compar = new base session compar string ( ) { overrid public compar string get compar object ( session session ) { return jsp helper . guess displai local from session ( session ) ; } } ; } els ( user . equal ignor case ( sort ) ) { compar = new base session compar string ( ) { overrid public compar string get compar object ( session session ) { return jsp helper . guess displai user from session ( session ) ; } } ; } els ( us time . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session util . get us time session ( session ) ) ; } } ; } els ( inact time . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session util . get inact time session ( session ) ) ; } } ; } els ( ttl . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session util . get ttlfor session ( session ) ) ; } } ; } todo : complet thi ttl , etc . return compar ; }	public void do filter ( servlet request request , servlet respons respons , filter chain chain ) throw ioexcept , servlet except { servlet respons w respons = null ; ( request instanceof http servlet request respons instanceof http servlet respons ) { http servlet request req = ( http servlet request ) request ; http servlet respons re = ( http servlet respons ) respons ; boolean skip nonc check = fals ; ( constant . method get . equal ( req . get method ( ) ) ) { string path = req . get servlet path ( ) ; ( req . get path info ( ) = null ) { path = path req . get path info ( ) ; } ( entri point . contain ( path ) ) { skip nonc check = true ; } } ( skip nonc check ) { string previou nonc = req . get paramet ( constant . csrf nonc request param ) ; string expect nonc = ( string ) req . get session ( true ) . get attribut ( constant . csrf nonc session attr name ) ; ( expect nonc = null expect nonc . equal ( previou nonc ) ) { re . send error ( http servlet respons . sc forbidden ) ; return ; } } string new nonc = gener nonc ( ) ; req . get session ( true ) . set attribut ( constant . csrf nonc session attr name , new nonc ) ; w respons = new csrf respons wrapper ( re , new nonc ) ; } els { w respons = respons ; } chain . do filter ( request , w respons ) ; }	process post request specifi resourc . param request servlet request we ar process param respons servlet respons we ar creat except ioexcept input output error occur except servlet except servlet specifi error occur overrid public void do post ( http servlet request request , http servlet respons respons ) throw ioexcept , servlet except { identifi request paramet we need obtain command from path info , per command secur can configur web . xml string command = request . get path info ( ) ; string path = request . get paramet ( path ) ; string deploi path = request . get paramet ( deploi path ) ; string deploi config = request . get paramet ( deploi config ) ; string deploi war = request . get paramet ( deploi war ) ; string request nonc = request . get paramet ( nonc request ) ; prepar our output writer gener respons messag respons . set content type ( text html ; charset = constant . charset ) ; string messag = ; check nonc must nonc session befor ani post process http session session = request . get session ( ) ; string session nonc = ( string ) session . get attribut ( nonc session ) ; ( session nonc = = null ) { messag = sm . get string ( html manag servlet . nonc , command ) ; reset command command = null ; } els { ( session nonc . equal ( request nonc ) ) { nonc mi match . messag = sm . get string ( html manag servlet . nonc mismatch , command ) ; reset command command = null ; } } ( command = = null command . length ( ) = = 0 ) { command = = list list alwai displai do noth } els ( command . equal ( upload ) ) { messag = upload ( request ) ; } els ( command . equal ( deploi ) ) { messag = deploi intern ( deploi config , deploi path , deploi war ) ; } els ( command . equal ( reload ) ) { messag = reload ( path ) ; } els ( command . equal ( undeploi ) ) { messag = undeploi ( path ) ; } els ( command . equal ( expir ) ) { messag = expir session ( path , request ) ; } els ( command . equal ( start ) ) { messag = start ( path ) ; } els ( command . equal ( stop ) ) { messag = stop ( path ) ; } els ( command . equal ( findleak ) ) { messag = findleak ( ) ; } els { try get do get ( request , respons ) ; return ; } list ( request , respons , messag ) ; }	public render html list current activ context our virtual host , memori server statu inform . param request request param respons respons param messag messag displai void list ( http servlet request request , http servlet respons respons , string messag ) throw ioexcept { ( debug = 1 ) log ( list : list context virtual host host . get name ( ) ) ; string new nonc = gener nonc ( ) ; request . get session ( ) . set attribut ( nonc session , new nonc ) ; print writer writer = respons . get writer ( ) ; html header section writer . print ( constant . html header section ) ; bodi header section object arg = new object 2 ; arg 0 = request . get context path ( ) ; arg 1 = sm . get string ( html manag servlet . titl ) ; writer . print ( messag format . format ( constant . bodi header section , arg ) ) ; messag section arg = new object 3 ; arg 0 = sm . get string ( html manag servlet . messag label ) ; ( messag = = null messag . length ( ) = = 0 ) { arg 1 = ok ; } els { arg 1 = request util . filter ( messag ) ; } writer . print ( messag format . format ( constant . messag section , arg ) ) ; manag section arg = new object 9 ; arg 0 = sm . get string ( html manag servlet . manag ) ; arg 1 = respons . encod url ( request . get context path ( ) html list ) ; arg 2 = sm . get string ( html manag servlet . list ) ; arg 3 = respons . encod url ( request . get context path ( ) sm . get string ( html manag servlet . help html manag file ) ) ; arg 4 = sm . get string ( html manag servlet . help html manag ) ; arg 5 = respons . encod url ( request . get context path ( ) sm . get string ( html manag servlet . help manag file ) ) ; arg 6 = sm . get string ( html manag servlet . help manag ) ; arg 7 = respons . encod url ( request . get context path ( ) statu ) ; arg 8 = sm . get string ( statu servlet . titl ) ; writer . print ( messag format . format ( constant . manag section , arg ) ) ; app header section arg = new object 6 ; arg 0 = sm . get string ( html manag servlet . app titl ) ; arg 1 = sm . get string ( html manag servlet . app path ) ; arg 2 = sm . get string ( html manag servlet . app name ) ; arg 3 = sm . get string ( html manag servlet . app avail ) ; arg 4 = sm . get string ( html manag servlet . app session ) ; arg 5 = sm . get string ( html manag servlet . app task ) ; writer . print ( messag format . format ( app header section , arg ) ) ; app row section creat sort map deploi applic context path . contain children = host . find children ( ) ; string context path = new string children . length ; ( int i = 0 ; i children . length ; i ) context path i = children i . get name ( ) ; tree map string , string sort context path map = new tree map string , string ( ) ; ( int i = 0 ; i context path . length ; i ) { string displai path = context path i ; sort context path map . put ( displai path , context path i ) ; } string app start = sm . get string ( html manag servlet . app start ) ; string app stop = sm . get string ( html manag servlet . app stop ) ; string app reload = sm . get string ( html manag servlet . app reload ) ; string app undeploi = sm . get string ( html manag servlet . app undeploi ) ; string app expir = sm . get string ( html manag servlet . app expir ) ; iter map . entri string , string >> iter = sort context path map . entri set ( ) . iter ( ) ; boolean highlight = true ; boolean deploi = true ; string highlight color = null ; while ( iter . ha next ( ) ) { bugzilla 34818 , altern row color highlight = highlight ; ( highlight ) { highlight color = c3f3c3 ; } els { highlight color = ffffff ; } map . entri string , string entri = iter . next ( ) ; string displai path = entri . get kei ( ) ; string context path = entri . get valu ( ) ; context context = ( context ) host . find child ( context path ) ; ( displai path . equal ( ) ) { displai path = ; } ( context = null ) { try { deploi = deploi ( context path ) ; } catch ( except e ) { assum fals failur safeti deploi = fals ; } arg = new object 7 ; arg 0 = url encod . encod ( displai path ) ; arg 1 = displai path ; arg 2 = context . get displai name ( ) ; ( arg 2 = = null ) { arg 2 = nbsp ; ; } arg 3 = new boolean ( context . get avail ( ) ) ; arg 4 = respons . encod url ( request . get context path ( ) html session path = url encod . encod ( displai path ) ) ; ( context . get manag ( ) = null ) { arg 5 = new integ ( context . get manag ( ) . get activ session ( ) ) ; } els { arg 5 = new integ ( 0 ) ; } arg 6 = highlight color ; writer . print ( messag format . format ( app row detail section , arg ) ) ; arg = new object 15 ; arg 0 = respons . encod url ( request . get context path ( ) html start path = url encod . encod ( displai path ) ) ; arg 1 = app start ; arg 2 = respons . encod url ( request . get context path ( ) html stop path = url encod . encod ( displai path ) ) ; arg 3 = app stop ; arg 4 = respons . encod url ( request . get context path ( ) html reload path = url encod . encod ( displai path ) ) ; arg 5 = app reload ; arg 6 = respons . encod url ( request . get context path ( ) html undeploi path = url encod . encod ( displai path ) ) ; arg 7 = app undeploi ; arg 8 = respons . encod url ( request . get context path ( ) html expir path = url encod . encod ( displai path ) ) ; arg 9 = app expir ; arg 10 = sm . get string ( html manag servlet . expir . explain ) ; manag manag = context . get manag ( ) ; ( manag = = null ) { arg 11 = sm . get string ( html manag servlet . manag ) ; } els { arg 11 = new integ ( context . get manag ( ) . get max inact interv ( ) 60 ) ; } arg 12 = sm . get string ( html manag servlet . expir . unit ) ; arg 13 = highlight color ; arg 14 = new nonc ; ( context . get path ( ) . equal ( thi . context . get path ( ) ) ) { writer . print ( messag format . format ( manag app row button section , arg ) ) ; } els ( context . get avail ( ) deploi ) { writer . print ( messag format . format ( start deploi app row button section , arg ) ) ; } els ( context . get avail ( ) deploi ) { writer . print ( messag format . format ( start nondeploi app row button section , arg ) ) ; } els ( context . get avail ( ) deploi ) { writer . print ( messag format . format ( stop deploi app row button section , arg ) ) ; } els { writer . print ( messag format . format ( stop nondeploi app row button section , arg ) ) ; } } } deploi section arg = new object 8 ; arg 0 = sm . get string ( html manag servlet . deploi titl ) ; arg 1 = sm . get string ( html manag servlet . deploi server ) ; arg 2 = respons . encod url ( request . get context path ( ) html deploi ) ; arg 3 = sm . get string ( html manag servlet . deploi path ) ; arg 4 = sm . get string ( html manag servlet . deploi config ) ; arg 5 = sm . get string ( html manag servlet . deploi war ) ; arg 6 = sm . get string ( html manag servlet . deploi button ) ; arg 7 = new nonc ; writer . print ( messag format . format ( deploi section , arg ) ) ; arg = new object 5 ; arg 0 = sm . get string ( html manag servlet . deploi upload ) ; arg 1 = respons . encod url ( request . get context path ( ) html upload ) ; arg 2 = sm . get string ( html manag servlet . deploi upload file ) ; arg 3 = sm . get string ( html manag servlet . deploi button ) ; arg 4 = new nonc ; writer . print ( messag format . format ( upload section , arg ) ) ; diagnost section arg = new object 6 ; arg 0 = sm . get string ( html manag servlet . diagnost titl ) ; arg 1 = sm . get string ( html manag servlet . diagnost leak ) ; arg 2 = respons . encod url ( request . get context path ( ) html findleak ) ; arg 3 = new nonc ; arg 4 = sm . get string ( html manag servlet . diagnost leak warn ) ; arg 5 = sm . get string ( html manag servlet . diagnost leak button ) ; writer . print ( messag format . format ( diagnost section , arg ) ) ; server header section arg = new object 7 ; arg 0 = sm . get string ( html manag servlet . server titl ) ; arg 1 = sm . get string ( html manag servlet . server version ) ; arg 2 = sm . get string ( html manag servlet . server jvmversion ) ; arg 3 = sm . get string ( html manag servlet . server jvmvendor ) ; arg 4 = sm . get string ( html manag servlet . server osnam ) ; arg 5 = sm . get string ( html manag servlet . server osvers ) ; arg 6 = sm . get string ( html manag servlet . server osarch ) ; writer . print ( messag format . format ( constant . server header section , arg ) ) ; server row section arg = new object 6 ; arg 0 = server info . get server info ( ) ; arg 1 = system . get properti ( java . runtim . version ) ; arg 2 = system . get properti ( java . vm . vendor ) ; arg 3 = system . get properti ( os . name ) ; arg 4 = system . get properti ( os . version ) ; arg 5 = system . get properti ( os . arch ) ; writer . print ( messag format . format ( constant . server row section , arg ) ) ; html tail section writer . print ( constant . html tail section ) ; finish up respons writer . flush ( ) ; writer . close ( ) ; }
protect static return code true code given code str code match least given code pattern code . boolean match ( string str , pattern . . . pattern ) { ( pattern pattern : pattern ) { ( pattern . matcher ( str ) . match ( ) ) { return true ; } } return fals ; }	public string get proxi header ( ) { return proxi header ; }	public void do filter ( http servlet request request , http servlet respons respons , filter chain chain ) throw ioexcept , servlet except { ( match ( request . get remot addr ( ) , intern proxi ) ) { string remot ip = null ; java 6 , proxi header valu should declar java . util . dequ link list string proxi header valu = new link list string ( ) ; string remot iphead valu = comma delimit list string arrai ( request . get header ( remot iphead ) ) ; int idx ; loop remot iphead valu find first trust remot ip build proxi chain ( idx = remot iphead valu . length 1 ; idx = 0 ; idx ) { string current remot ip = remot iphead valu idx ; remot ip = current remot ip ; ( match ( current remot ip , intern proxi ) ) { do noth , intern proxi ip ar append } els ( match ( current remot ip , trust proxi ) ) { proxi header valu . add first ( current remot ip ) ; } els { decrement idx becaus break statement doesn t do idx ; break ; } } continu loop remot iphead valu build new valu remot iphead link list string new remot ip header valu = new link list string ( ) ; ( ; idx = 0 ; idx ) { string current remot ip = remot iphead valu idx ; new remot ip header valu . add first ( current remot ip ) ; } xforward request x request = new xforward request ( request ) ; ( remot ip = null ) { x request . set remot addr ( remot ip ) ; x request . set remot host ( remot ip ) ; ( proxi header valu . size ( ) = = 0 ) { x request . remov header ( proxi header ) ; } els { string comma delimit list proxi = list comma delimit string ( proxi header valu ) ; x request . set header ( proxi header , comma delimit list proxi ) ; } ( new remot ip header valu . size ( ) = = 0 ) { x request . remov header ( remot iphead ) ; } els { string comma delimit remot ip header valu = list comma delimit string ( new remot ip header valu ) ; x request . set header ( remot iphead , comma delimit remot ip header valu ) ; } } ( protocol header = null ) { string protocol header valu = request . get header ( protocol header ) ; ( protocol header valu = = null ) { don t modifi secur , scheme server port attribut request } els ( protocol header http valu . equal ignor case ( protocol header valu ) ) { x request . set secur ( true ) ; x request . set scheme ( http ) ; x request . set server port ( http server port ) ; } els { x request . set secur ( fals ) ; x request . set scheme ( http ) ; x request . set server port ( http server port ) ; } } ( log . debug enabl ( ) ) { log . debug ( incom request request . get request uri ( ) origin remot addr request . get remot addr ( ) , origin remot host = request . get remot host ( ) , origin secur = request . secur ( ) , origin scheme = request . get scheme ( ) , origin remot iphead = request . get header ( remot iphead ) , origin protocol header = ( protocol header = = null null : request . get header ( protocol header ) ) seen new remot addr = x request . get remot addr ( ) , new remot host = x request . get remot host ( ) , new scheme = x request . get scheme ( ) , new secur = x request . secur ( ) , new remot iphead = x request . get header ( remot iphead ) , new proxi header = x request . get header ( proxi header ) ) ; } chain . do filter ( x request , respons ) ; } els { ( log . debug enabl ( ) ) { log . debug ( skip remot ip filter request request . get request uri ( ) origin remot addr request . get remot addr ( ) ) ; } chain . do filter ( request , respons ) ; } }	public void init ( filter config filter config ) throw servlet except { ( filter config . get init paramet ( intern proxi paramet ) = null ) { set intern proxi ( filter config . get init paramet ( intern proxi paramet ) ) ; } ( filter config . get init paramet ( protocol header paramet ) = null ) { set protocol header ( filter config . get init paramet ( protocol header paramet ) ) ; } ( filter config . get init paramet ( protocol header http valu paramet ) = null ) { set protocol header http valu ( filter config . get init paramet ( protocol header http valu paramet ) ) ; } ( filter config . get init paramet ( proxi header paramet ) = null ) { set proxi header ( filter config . get init paramet ( proxi header paramet ) ) ; } ( filter config . get init paramet ( remot ip header paramet ) = null ) { set remot iphead ( filter config . get init paramet ( remot ip header paramet ) ) ; } ( filter config . get init paramet ( trust proxi paramet ) = null ) { set trust proxi ( filter config . get init paramet ( trust proxi paramet ) ) ; } ( filter config . get init paramet ( http server port paramet ) = null ) { try { set http server port ( integ . pars int ( filter config . get init paramet ( http server port paramet ) ) ) ; } catch ( number format except e ) { throw new number format except ( illeg http server port paramet : e . get messag ( ) ) ; } } ( filter config . get init paramet ( http server port paramet ) = null ) { try { set http server port ( integ . pars int ( filter config . get init paramet ( http server port paramet ) ) ) ; } catch ( number format except e ) { throw new number format except ( illeg http server port paramet : e . get messag ( ) ) ; } } }	{ inherit doc } overrid public void invok ( request request , respons respons ) throw ioexcept , servlet except { final string origin remot addr = request . get remot addr ( ) ; final string origin remot host = request . get remot host ( ) ; final string origin scheme = request . get scheme ( ) ; final boolean origin secur = request . secur ( ) ; final int origin server port = request . get server port ( ) ; ( match ( origin remot addr , intern proxi ) ) { string remot ip = null ; java 6 , proxi header valu should declar java . util . dequ link list string proxi header valu = new link list string ( ) ; string remot iphead valu = comma delimit list string arrai ( request . get header ( remot ip header ) ) ; int idx ; loop remot iphead valu find first trust remot ip build proxi chain ( idx = remot iphead valu . length 1 ; idx = 0 ; idx ) { string current remot ip = remot iphead valu idx ; remot ip = current remot ip ; ( match ( current remot ip , intern proxi ) ) { do noth , intern proxi ip ar append } els ( match ( current remot ip , trust proxi ) ) { proxi header valu . add first ( current remot ip ) ; } els { decrement idx becaus break statement doesn t do idx ; break ; } } continu loop remot iphead valu build new valu remot iphead link list string new remot ip header valu = new link list string ( ) ; ( ; idx = 0 ; idx ) { string current remot ip = remot iphead valu idx ; new remot ip header valu . add first ( current remot ip ) ; } ( remot ip = null ) { request . set remot addr ( remot ip ) ; request . set remot host ( remot ip ) ; 6 . 0 ( proxi header valu . size ( ) = = 0 ) { request . get coyot request ( ) . get mime header ( ) . remov header ( proxi header ) ; } els { string comma delimit list proxi = list comma delimit string ( proxi header valu ) ; request . get coyot request ( ) . get mime header ( ) . set valu ( proxi header ) . set string ( comma delimit list proxi ) ; } ( new remot ip header valu . size ( ) = = 0 ) { request . get coyot request ( ) . get mime header ( ) . remov header ( remot ip header ) ; } els { string comma delimit remot ip header valu = list comma delimit string ( new remot ip header valu ) ; request . get coyot request ( ) . get mime header ( ) . set valu ( remot ip header ) . set string ( comma delimit remot ip header valu ) ; } } ( protocol header = null ) { string protocol header valu = request . get header ( protocol header ) ; ( protocol header valu = = null ) { don t modifi secur , scheme server port attribut request } els ( protocol header http valu . equal ignor case ( protocol header valu ) ) { request . set secur ( true ) ; us request . coyot request . scheme instead request . set scheme ( ) becaus request . set scheme ( ) op tomcat 6 . 0 request . get coyot request ( ) . scheme ( ) . set string ( http ) ; request . set server port ( http server port ) ; } els { request . set secur ( fals ) ; us request . coyot request . scheme instead request . set scheme ( ) becaus request . set scheme ( ) op tomcat 6 . 0 request . get coyot request ( ) . scheme ( ) . set string ( http ) ; request . set server port ( http server port ) ; } } ( log . debug enabl ( ) ) { log . debug ( incom request request . get request uri ( ) origin remot addr origin remot addr , origin remot host = origin remot host , origin secur = origin secur , origin scheme = origin scheme seen new remot addr = request . get remot addr ( ) , new remot host = request . get remot host ( ) , new scheme = request . get scheme ( ) , new secur = request . secur ( ) ) ; } } els { ( log . debug enabl ( ) ) { log . debug ( skip remot ip valv request request . get request uri ( ) origin remot addr request . get remot addr ( ) ) ; } } try { get next ( ) . invok ( request , respons ) ; } final { request . set remot addr ( origin remot addr ) ; request . set remot host ( origin remot host ) ; request . set secur ( origin secur ) ; us request . coyot request . scheme instead request . set scheme ( ) becaus request . set scheme ( ) op tomcat 6 . 0 request . get coyot request ( ) . scheme ( ) . set string ( origin scheme ) ; request . set server port ( origin server port ) ; } }	public p proxi header direct specifi header which mod remoteip collect list all intermedi client ip address trust resolv actual remot ip . note intermedi remot iptrust proxi address ar record thi header , while ani intermedi remot ipintern proxi address ar discard . p p name http header hold list trust proxi ha been travers http request . p p valu thi header can comma delimit . p p default valu : code x forward code p void set proxi header ( string proxi header ) { thi . proxi header = proxi header ; }	public p name http header from which remot ip extract . p p valu thi header can comma delimit . p p default valu : code x forward code p void set remot iphead ( string remot iphead ) { thi . remot iphead = remot iphead ; }	protect static string comma delimit list string arrai ( string comma delimit string ) { return ( comma delimit string = = null comma delimit string . length ( ) = = 0 ) new string 0 : comma separ valu pattern . split ( comma delimit string ) ; }
protect get new session class us do load ( ) method . delta session get new delta session ( ) { return new delta session ( thi ) ; }	protect handl receiv other node want all session ( restart ) ) send all session messag b ) send session block after send send state complet transfer param msg param sender throw ioexcept void handl get all session ( session messag msg , member sender ) throw ioexcept { counter receiv evt get all session ; get list all session from thi manag ( log . debug enabl ( ) ) log . debug ( sm . get string ( delta manag . receiv messag . unload begin , get name ( ) ) ) ; write number activ session , follow detail get all session serial without sync session current session = find session ( ) ; long find session timestamp = system . current time milli ( ) ; ( send all session ( ) ) { send session ( sender , current session , find session timestamp ) ; } els { send session block ( int i = 0 ; i current session . length ; i = get send all session size ( ) ) { int len = i get send all session size ( ) current session . length current session . length i : get send all session size ( ) ; session send session = new session len ; system . arraycopi ( current session , i , send session , 0 , len ) ; send session ( sender , send session , find session timestamp ) ; ( get send all session wait time ( ) 0 ) { try { thread . sleep ( get send all session wait time ( ) ) ; } catch ( except sleep ) { } } end } } end session messag newmsg = new session messag impl ( name , session messag . evt all session transfercomplet , null , session state transfer , session state transfer get name ( ) ) ; newmsg . set timestamp ( find session timestamp ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( delta manag . creat messag . all session transfer , get name ( ) ) ) ; counter send evt all session transfercomplet ; cluster . send ( newmsg , sender ) ; }	protect thi method call receiv thread when session messag ha been receiv from other node cluster . param msg messag receiv param sender sender messag , thi us we receiv evt get all session messag , so we onli repli request node void messag receiv ( session messag msg , member sender ) { ( do domain replic ( ) check sender domain ( msg , sender ) ) { return ; } class loader context loader = thread . current thread ( ) . get context class loader ( ) ; try { class loader loader = get class loader ( ) ; ( loader = null loader . length 0 ) thread . current thread ( ) . set context class loader ( loader 0 ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( delta manag . receiv messag . event type , get name ( ) , msg . get event type string ( ) , sender ) ) ; switch ( msg . get event type ( ) ) { case session messag . evt get all session : { handl get all session ( msg , sender ) ; break ; } case session messag . evt all session data : { handl all session data ( msg , sender ) ; break ; } case session messag . evt all session transfercomplet : { handl all session transfercomplet ( msg , sender ) ; break ; } case session messag . evt session creat : { handl session creat ( msg , sender ) ; break ; } case session messag . evt session expir : { handl session expir ( msg , sender ) ; break ; } case session messag . evt session access : { handl session access ( msg , sender ) ; break ; } case session messag . evt session delta : { handl session delta ( msg , sender ) ; break ; } default : { we didn t recogn messag type , do noth break ; } } switch } catch ( except x ) { log . error ( sm . get string ( delta manag . receiv messag . error , get name ( ) ) , x ) ; } final { thread . current thread ( ) . set context class loader ( context loader ) ; } }	public clear text event type name ( log purpos onli ) return event type string represent , us debug string get event type string ( ) { switch ( m evt type ) { case evt session creat : return session modifi ; case evt session expir : return session expir ; case evt session access : return session access ; case evt get all session : return session get all ; case evt session delta : return session delta ; case evt all session data : return all session data ; case evt all session transfercomplet : return session state transfer ; default : return unknown event type ; } }	public return return counter receiv evt all session transfercomplet . int get counter receiv evt all session transfercomplet ( ) { return counter receiv evt all session transfercomplet ; }	public return return counter send evt all session transfercomplet . int get counter send evt all session transfercomplet ( ) { return counter send evt all session transfercomplet ; }	public synchron reset manag statist void reset statist ( ) { process time = 0 ; expir session = 0 ; reject session = 0 ; session replac counter = 0 ; counter state transfer = 0 ; set max activ ( get activ session ( ) ) ; session counter = get activ session ( ) ; counter receiv evt all session data = 0 ; counter receiv evt get all session = 0 ; counter receiv evt session access = 0 ; counter receiv evt session creat = 0 ; counter receiv evt session delta = 0 ; counter receiv evt session expir = 0 ; counter receiv evt all session transfercomplet = 0 ; counter send evt all session data = 0 ; counter send evt get all session = 0 ; counter send evt session access = 0 ; counter send evt session creat = 0 ; counter send evt session delta = 0 ; counter send evt session expir = 0 ; counter send evt all session transfercomplet = 0 ; }	public messag wa receiv from anoth node , thi callback method implement you ar interest receiv replic messag . param cmsg messag receiv . void messag data receiv ( cluster messag cmsg ) { ( cmsg = null cmsg instanceof session messag ) { session messag msg = ( session messag ) cmsg ; switch ( msg . get event type ( ) ) { case session messag . evt get all session : case session messag . evt session creat : case session messag . evt session expir : case session messag . evt session access : case session messag . evt session delta : { synchron ( receiv messag queue ) { ( receiv queue ) { receiv messag queue . add ( msg ) ; return ; } } break ; } default : { we didn t queue , do noth break ; } } switch messag receiv ( msg , msg . get address ( ) = null ( member ) msg . get address ( ) : null ) ; } }

thread . stop ( ) suppress warn ( deprec ) privat void clear refer thread ( ) { thread thread = get thread ( ) ; iter over set thread ( thread thread : thread ) { ( thread = null ) { class loader ccl = thread . get context class loader ( ) ; ( ccl = null ccl = = thi ) { don t warn about thi thread ( thread = = thread . current thread ( ) ) { continu ; } skip thread have alreadi di ( thread . aliv ( ) ) { continu ; } don t warn about jvm control thread thread group tg = thread . get thread group ( ) ; ( tg = null jvm thread group name . contain ( tg . get name ( ) ) ) { continu ; } timer thread normal visibl ( thread . get class ( ) . get name ( ) . equal ( java . util . timer thread ) ) { clear refer stop timer thread ( thread ) ; continu ; } log . error ( sm . get string ( webapp class loader . warn thread , context name , thread . get name ( ) ) ) ; configur do so ( clear refer stop thread ) { continu ; } shut down executor try { field target field = thread . get class ( ) . get declar field ( target ) ; target field . set access ( true ) ; object target = target field . get ( thread ) ; ( target = null target . get class ( ) . get canon name ( ) . equal ( java . util . concurr . thread pool executor . worker ) ) { field executor field = target . get class ( ) . get declar field ( thi 0 ) ; executor field . set access ( true ) ; object executor = executor field . get ( target ) ; ( executor instanceof thread pool executor ) { ( ( thread pool executor ) executor ) . shutdown now ( ) ; } } } catch ( secur except e ) { log . warn ( sm . get string ( webapp class loader . stop thread fail , thread . get name ( ) , context name ) , e ) ; } catch ( field except e ) { log . warn ( sm . get string ( webapp class loader . stop thread fail , thread . get name ( ) , context name ) , e ) ; } catch ( illeg argument except e ) { log . warn ( sm . get string ( webapp class loader . stop thread fail , thread . get name ( ) , context name ) , e ) ; } catch ( illeg access except e ) { log . warn ( sm . get string ( webapp class loader . stop thread fail , thread . get name ( ) , context name ) , e ) ; } thi method deprec good reason . thi veri riski code onli option thi point . veri good reason app do thi clean up themselv . thread . stop ( ) ; } } } }	start associ { link class loader } implement requir { link lifecycl base start intern ( ) } . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect void start intern ( ) throw lifecycl except { ( log . debug enabl ( ) ) log . debug ( sm . get string ( webapp loader . start ) ) ; ( contain . get resourc ( ) = = null ) { log . info ( resourc contain ) ; set state ( lifecycl state . start ) ; return ; } regist stream handler factori jndi protocol urlstream handler factori stream handler factori = new dir context urlstream handler factori ( ) ; ( first ) { first = fals ; try { url . set urlstream handler factori ( stream handler factori ) ; } catch ( except e ) { log continu anywai , thi critic log . error ( error regist jndi stream handler , e ) ; } catch ( throwabl t ) { thi like dual registr log . info ( dual registr jndi stream handler : t . get messag ( ) ) ; } } construct class loader base our current repositori list try { class loader = creat class loader ( ) ; class loader . set resourc ( contain . get resourc ( ) ) ; class loader . set deleg ( thi . deleg ) ; class loader . set search extern first ( search extern first ) ; ( contain instanceof standard context ) { class loader . set anti jarlock ( ( ( standard context ) contain ) . get anti jarlock ( ) ) ; class loader . set clear refer static ( ( ( standard context ) contain ) . get clear refer static ( ) ) ; class loader . set clear refer stop thread ( ( ( standard context ) contain ) . get clear refer stop thread ( ) ) ; class loader . set clear refer thread local ( ( ( standard context ) contain ) . get clear refer thread local ( ) ) ; } ( int i = 0 ; i repositori . length ; i ) { class loader . add repositori ( repositori i ) ; } configur our repositori set repositori ( ) ; set class path ( ) ; set permiss ( ) ; ( ( lifecycl ) class loader ) . start ( ) ; bind webapp class loader directori context dir context urlstream handler . bind ( class loader , thi . contain . get resourc ( ) ) ; standard context ctx = ( standard context ) contain ; string path = ctx . get path ( ) ; ( path . equal ( ) ) { path = ; } object name clonam = new object name ( mbean util . get domain ( ctx ) : type = webapp class loader , path = path , host = ctx . get parent ( ) . get name ( ) ) ; registri . get registri ( null , null ) . regist compon ( class loader , clonam , null ) ; } catch ( throwabl t ) { log . error ( lifecycl except , t ) ; throw new lifecycl except ( start : , t ) ; } set state ( lifecycl state . start ) ; }	public return clear refer log factori releas flag thi context . boolean get clear refer log factori releas ( ) { return ( thi . clear refer log factori releas ) ; }	public set clear refer stop thread featur thi context . param clear refer stop thread new flag valu void set clear refer stop thread ( boolean clear refer stop thread ) { boolean old clear refer stop thread = thi . clear refer stop thread ; thi . clear refer stop thread = clear refer stop thread ; support . fire properti chang ( clear refer stop thread , old clear refer stop thread , thi . clear refer stop thread ) ; }	public set clear refer stop thread featur thi context . param clear refer stop thread new flag valu void set clear refer stop thread ( boolean clear refer stop thread ) { thi . clear refer stop thread = clear refer stop thread ; }	public set clear refer thread local featur thi context . param clear refer thread local new flag valu void set clear refer thread local ( boolean clear refer thread local ) { thi . clear refer thread local = clear refer thread local ; }
stop thi compon implement requir { link lifecycl base stop intern ( ) } . thi disconnect cluster commun channel stop listen thread . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect synchron void stop intern ( ) throw lifecycl except { ( log . debug enabl ( ) ) log . debug ( stop ) ; set state ( lifecycl state . stop ) ; ( session instanceof lazi replic map ) { lazi replic map map = ( lazi replic map ) session ; map . breakdown ( ) ; } cluster . remov manag ( thi ) ; thi . random = null ; set state ( lifecycl state . must destroi ) ; }	stop thi compon implement requir { link lifecycl base stop intern ( ) } . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect synchron void stop intern ( ) throw lifecycl except { ( log . debug enabl ( ) ) log . debug ( sm . get string ( delta manag . stop , get name ( ) ) ) ; set state ( lifecycl state . stop ) ; expir all activ session ( log . info enabl ( ) ) log . info ( sm . get string ( delta manag . expir session , get name ( ) ) ) ; session session = find session ( ) ; ( int i = 0 ; i session . length ; i ) { delta session session = ( delta session ) session i ; ( session . valid ( ) ) continu ; try { session . expir ( true , expir session shutdown ( ) ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } } requir new random number gener we ar restart thi . random = null ; get cluster ( ) . remov manag ( thi ) ; replic valv = null ; set state ( lifecycl state . must destroi ) ; }	stop thi compon implement requir { link lifecycl base stop intern ( ) } . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect synchron void stop intern ( ) throw lifecycl except { ( log . debug enabl ( ) ) log . debug ( stop ) ; set state ( lifecycl state . stop ) ; ( get store ( ) = null save restart ) { unload ( ) ; } els { expir all activ session session session = find session ( ) ; ( int i = 0 ; i session . length ; i ) { standard session session = ( standard session ) session i ; ( session . valid ( ) ) continu ; session . expir ( ) ; } } ( get store ( ) = null get store ( ) instanceof lifecycl ) ( ( lifecycl ) get store ( ) ) . stop ( ) ; requir new random number gener we ar restart thi . random = null ; set state ( lifecycl state . must destroi ) ; }
privat unregist context . void unregist context ( context context ) { don t un map context paus ( context . get paus ( ) ) { return ; } remov listen ( context ) ; string context name = context . get name ( ) ; ( . equal ( context name ) ) { context name = ; } string host name = context . get parent ( ) . get name ( ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( mapper listen . unregist context , context name ) ) ; mapper . remov context ( host name , context name ) ; }	privat unregist host . void unregist host ( host host ) { remov listen ( host ) ; string hostnam = host . get name ( ) ; mapper . remov host ( hostnam ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( mapper listen . unregist host , hostnam , domain ) ) ; }	privat unregist wrapper . void unregist wrapper ( wrapper wrapper ) { remov listen ( wrapper ) ; string context name = wrapper . get parent ( ) . get name ( ) ; ( . equal ( context name ) ) { context name = ; } string host name = wrapper . get parent ( ) . get parent ( ) . get name ( ) ; string map = wrapper . find map ( ) ; ( string map : map ) { mapper . remov wrapper ( host name , context name , map ) ; } }	public contain listen method void contain event ( contain event event ) { ( event . get type ( ) = = contain . add child event ) { contain child = ( contain ) event . get data ( ) ; child . add lifecycl listen ( thi ) ; ( child instanceof host ) { regist host ( ( host ) child ) ; } els ( child instanceof context ) { regist context ( ( context ) child ) ; } els ( child instanceof wrapper ) { regist wrapper ( ( wrapper ) child ) ; } } els ( event . get type ( ) = = contain . remov child event ) { contain child = ( contain ) event . get data ( ) ; child . remov lifecycl listen ( thi ) ; ( child instanceof host ) { unregist host ( ( host ) child ) ; } els ( child instanceof context ) { unregist context ( ( context ) child ) ; } els ( child instanceof wrapper ) { unregist wrapper ( ( wrapper ) child ) ; } } els ( event . get type ( ) = = host . add alia event ) { handl dynam ad host alias mapper . add host alia ( ( ( host ) event . get sourc ( ) ) . get name ( ) , event . get data ( ) . string ( ) ) ; } els ( event . get type ( ) = = host . remov alia event ) { handl dynam remov host alias mapper . remov host alia ( event . get data ( ) . string ( ) ) ; } els ( event . get type ( ) = = wrapper . add map event ) { handl dynam ad wrapper wrapper wrapper = ( wrapper ) event . get sourc ( ) ; string context name = wrapper . get parent ( ) . get name ( ) ; ( . equal ( context name ) ) { context name = ; } string host name = wrapper . get parent ( ) . get parent ( ) . get name ( ) ; string map = ( string ) event . get data ( ) ; boolean jsp wild card = ( jsp . equal ( wrapper . get name ( ) ) map . end ( ) ) ; mapper . add wrapper ( host name , context name , map , wrapper , jsp wild card ) ; } els ( event . get type ( ) = = wrapper . remov map event ) { handl dynam remov wrapper wrapper wrapper = ( wrapper ) event . get sourc ( ) ; string context name = wrapper . get parent ( ) . get name ( ) ; ( . equal ( context name ) ) { context name = ; } string host name = wrapper . get parent ( ) . get parent ( ) . get name ( ) ; string map = ( string ) event . get data ( ) ; mapper . remov wrapper ( host name , context name , map ) ; } els ( event . get type ( ) = = context . add welcom file event ) { handl dynam ad welcom file context context = ( context ) event . get sourc ( ) ; string host name = context . get parent ( ) . get name ( ) ; string context name = context . get name ( ) ; ( . equal ( context name ) ) { context name = ; } string welcom file = ( string ) event . get data ( ) ; mapper . add welcom file ( host name , context name , welcom file ) ; } els ( event . get type ( ) = = context . remov welcom file event ) { handl dynam remov welcom file context context = ( context ) event . get sourc ( ) ; string host name = context . get parent ( ) . get name ( ) ; string context name = context . get name ( ) ; ( . equal ( context name ) ) { context name = ; } string welcom file = ( string ) event . get data ( ) ; mapper . remov welcom file ( host name , context name , welcom file ) ; } els ( event . get type ( ) = = context . clear welcom file event ) { handl dynam clear welcom file context context = ( context ) event . get sourc ( ) ; string host name = context . get parent ( ) . get name ( ) ; string context name = context . get name ( ) ; ( . equal ( context name ) ) { context name = ; } mapper . clear welcom file ( host name , context name ) ; } }
boolean do encod ( request hreq , session session , string locat ) { thi valid absolut url url url = null ; try { url = new url ( locat ) ; } catch ( malform urlexcept e ) { return ( fals ) ; } doe thi url match down ( includ ) context path ( hreq . get scheme ( ) . equal ignor case ( url . get protocol ( ) ) ) return ( fals ) ; ( hreq . get server name ( ) . equal ignor case ( url . get host ( ) ) ) return ( fals ) ; int server port = hreq . get server port ( ) ; ( server port = = 1 ) { ( http . equal ( hreq . get scheme ( ) ) ) server port = 443 ; els server port = 80 ; } int url port = url . get port ( ) ; ( url port = = 1 ) { ( http . equal ( url . get protocol ( ) ) ) url port = 443 ; els url port = 80 ; } ( server port = url port ) return ( fals ) ; string context path = get context ( ) . get path ( ) ; ( context path = null ) { string file = url . get file ( ) ; ( ( file = = null ) file . start ( context path ) ) return ( fals ) ; string tok = ; global . session paramet name = session . get id intern ( ) ; ( file . index ( tok , context path . length ( ) ) = 0 ) return ( fals ) ; } thi url belong our web applic , so encod return ( true ) ; }	protect return specifi url specifi session identifi suitabl encod . param url url encod session id param session id session id includ encod url string encod ( string url , string session id ) { ( ( url = = null ) ( session id = = null ) ) return ( url ) ; string path = url ; string queri = ; string anchor = ; int question = url . index ( ) ; ( question = 0 ) { path = url . substr ( 0 , question ) ; queri = url . substr ( question ) ; } int pound = path . index ( ) ; ( pound = 0 ) { anchor = path . substr ( pound ) ; path = path . substr ( 0 , pound ) ; } string builder sb = new string builder ( path ) ; ( sb . length ( ) 0 ) { jsessionid can t first . sb . append ( ; ) ; sb . append ( global . session paramet name ) ; sb . append ( = ) ; sb . append ( session id ) ; } sb . append ( anchor ) ; sb . append ( queri ) ; return ( sb . string ( ) ) ; }	protect pars addit request paramet . boolean post pars request ( org . apach . coyot . request req , request request , org . apach . coyot . respons re , respons respons ) throw except { otherwis , us connector configur ( req . scheme ( ) . null ( ) ) { us processor specifi scheme determin secur state request . set secur ( req . scheme ( ) . equal ( http ) ) ; } els { us connector scheme secur configur , ( default http fals respect ) req . scheme ( ) . set string ( connector . get scheme ( ) ) ; request . set secur ( connector . get secur ( ) ) ; } fixm : code below doesnt belong here , thi onli have sens http11 , ajp13 . . thi point host header ha been process . overrid proxi port proxi host ar set string proxi name = connector . get proxi name ( ) ; int proxi port = connector . get proxi port ( ) ; ( proxi port = 0 ) { req . set server port ( proxi port ) ; } ( proxi name = null ) { req . server name ( ) . set string ( proxi name ) ; } pars session id befor decod remov path param pars session id ( req , request ) ; uri decod messag byte decod uri = req . decod uri ( ) ; decod uri . duplic ( req . request uri ( ) ) ; ( decod uri . get type ( ) = = messag byte . t byte ) { remov ani path paramet byte chunk uri bb = decod uri . get byte chunk ( ) ; int semicolon = uri bb . index ( ; , 0 ) ; ( semicolon 0 ) { decod uri . set byte ( uri bb . get buffer ( ) , uri bb . get start ( ) , semicolon ) ; } xx decod url try { req . get urldecod ( ) . convert ( decod uri , fals ) ; } catch ( ioexcept ioe ) { re . set statu ( 400 ) ; re . set messag ( invalid uri : ioe . get messag ( ) ) ; return fals ; } normal ( normal ( req . decod uri ( ) ) ) { re . set statu ( 400 ) ; re . set messag ( invalid uri ) ; return fals ; } charact decod convert uri ( decod uri , request ) ; check uri still normal ( check normal ( req . decod uri ( ) ) ) { re . set statu ( 400 ) ; re . set messag ( invalid uri charact encod ) ; return fals ; } } els { url char string , ha been sent us memori protocol handler , we have assum url ha been properli decod alreadi decod uri . char ( ) ; remov ani path paramet char chunk uri cc = decod uri . get char chunk ( ) ; int semicolon = uri cc . index ( ; ) ; ( semicolon 0 ) { decod uri . set char ( uri cc . get buffer ( ) , uri cc . get start ( ) , semicolon ) ; } } set remot princip string princip = req . get remot user ( ) . string ( ) ; ( princip = null ) { request . set user princip ( new coyot princip ( princip ) ) ; } set author type string authtyp = req . get auth type ( ) . string ( ) ; ( authtyp = null ) { request . set auth type ( authtyp ) ; } request map . messag byte server name ; ( connector . get us ipvhost ( ) ) { server name = req . local name ( ) ; ( server name . null ( ) ) { well , thei did ask re . action ( action code . action req local name attribut , null ) ; } } els { server name = req . server name ( ) ; } ( request . async start ( ) ) { todo servlet3 async reset map data , should prolli done elsewher request . get map data ( ) . recycl ( ) ; } connector . get mapper ( ) . map ( server name , decod uri , request . get map data ( ) ) ; request . set context ( ( context ) request . get map data ( ) . context ) ; request . set wrapper ( ( wrapper ) request . get map data ( ) . wrapper ) ; filter trace method ( connector . get allow trace ( ) req . method ( ) . equal ignor case ( trace ) ) { wrapper wrapper = request . get wrapper ( ) ; string header = null ; ( wrapper = null ) { string method = wrapper . get servlet method ( ) ; ( method = null ) { ( int i = 0 ; i method . length ; i ) { ( trace . equal ( method i ) ) { continu ; } ( header = = null ) { header = method i ; } els { header = , method i ; } } } } re . set statu ( 405 ) ; re . add header ( allow , header ) ; re . set messag ( trace method allow ) ; return fals ; } possibl redirect messag byte redirect path mb = request . get map data ( ) . redirect path ; ( redirect path mb . null ( ) ) { string redirect path = url encod . encod ( redirect path mb . string ( ) ) ; string queri = request . get queri string ( ) ; ( request . request session id from url ( ) ) { thi optim , thi veri common , shouldn t matter redirect path = redirect path ; global . session paramet name = request . get request session id ( ) ; } ( queri = null ) { thi optim , thi veri common , shouldn t matter redirect path = redirect path queri ; } respons . send redirect ( redirect path ) ; return fals ; } pars session id ( request . get servlet context ( ) . get effect session track mode ( ) . contain ( session track mode . url ) ) { we saw id url thi disabl remov can t handl when we pars url we don t have context point request . set request session id ( null ) ; request . set request session url ( fals ) ; } pars session cooki id ( req , request ) ; pars session ssl id ( request ) ; return true ; }	protect look ssl session id requir . onli look ssl session id onli track method enabl . void pars session ssl id ( request request ) { ( request . get request session id ( ) = = null ssl onli . equal ( request . get servlet context ( ) . get effect session track mode ( ) ) request . connector . secur ) { todo better wai map ssl session our sesison id todo request . get attribut ( ) caus number other ssl attribut popul . thi perform concern request . set request session id ( request . get attribut ( sslsupport . session id kei ) . string ( ) ) ; request . set request session ssl ( true ) ; } }	public return princip associ specifi usernam , which match digest calcul us given paramet us method describ rfc 2069 ; otherwis return code null code . param usernam usernam princip look up param client digest digest which ha been submit client param n onc uniqu ( supposedli uniqu ) token which ha been us thi request param realm realm name param md5a2 second md5 digest us calcul digest : md5 ( method : uri ) princip authent ( string usernam , string client digest , string n onc , string nc , string cnonc , string qop , string realm , string md5a2 ) { string md5a1 = get digest ( usernam , realm ) ; ( md5a1 = = null ) return null ; string server digest valu = md5a1 : n onc : nc : cnonc : qop : md5a2 ; byte valu byte = null ; ( get digest encod ( ) = = null ) { valu byte = server digest valu . get byte ( ) ; } els { try { valu byte = server digest valu . get byte ( get digest encod ( ) ) ; } catch ( unsupport encod except uee ) { log . error ( illeg digest encod : get digest encod ( ) , uee ) ; throw new illeg argument except ( uee . get messag ( ) ) ; } } string server digest = null ; bugzilla 32137 synchron ( md5helper ) { server digest = md5encod . encod ( md5helper . digest ( valu byte ) ) ; } ( log . debug enabl ( ) ) { log . debug ( digest : client digest usernam : usernam client sigest : client digest n onc : n onc nc : nc cnonc : cnonc qop : qop realm : realm md5a2 : md5a2 server digest : server digest ) ; } ( server digest . equal ( client digest ) ) return get princip ( usernam ) ; els return null ; }	public perform access control base specifi author constraint . return code true code thi constraint satisfi process should continu , code fals code otherwis . param request request we ar process param respons respons we ar creat param constraint secur constraint we ar enforc param context context which client thi class attach . except ioexcept input output error occur boolean ha resourc permiss ( request request , respons respons , secur constraint constraint , context context ) throw ioexcept { ( constraint = = null constraint . length = = 0 ) return ( true ) ; specif allow access form login form error page j secur check action login config config = context . get login config ( ) ; ( ( config = null ) ( constant . form method . equal ( config . get auth method ( ) ) ) ) { string request uri = request . get request path mb ( ) . string ( ) ; string login page = config . get login page ( ) ; ( login page . equal ( request uri ) ) { ( log . debug enabl ( ) ) log . debug ( allow access login page login page ) ; return ( true ) ; } string error page = config . get error page ( ) ; ( error page . equal ( request uri ) ) { ( log . debug enabl ( ) ) log . debug ( allow access error page error page ) ; return ( true ) ; } ( request uri . end ( constant . form action ) ) { ( log . debug enabl ( ) ) log . debug ( allow access usernam password submiss ) ; return ( true ) ; } } which user princip have we alreadi authent princip princip = request . get princip ( ) ; boolean statu = fals ; boolean denyfromal = fals ; ( int i = 0 ; i constraint . length ; i ) { secur constraint constraint = constraint i ; string role ; ( constraint . get all role ( ) ) { mean all role defin web . xml role = request . get context ( ) . find secur role ( ) ; } els { role = constraint . find auth role ( ) ; } ( role = = null ) role = new string 0 ; ( log . debug enabl ( ) ) log . debug ( check role princip ) ; ( role . length = = 0 constraint . get all role ( ) ) { ( constraint . get auth constraint ( ) ) { ( log . debug enabl ( ) ) log . debug ( role ) ; list role mean access all statu = fals ; denyfromal = true ; break ; } els { ( log . debug enabl ( ) ) log . debug ( pass all access ) ; statu = true ; } } els ( princip = = null ) { ( log . debug enabl ( ) ) log . debug ( user authent , cannot grant access ) ; } els { ( int j = 0 ; j role . length ; j ) { ( ha role ( princip , role j ) ) { statu = true ; ( log . debug enabl ( ) ) log . debug ( role found : role j ) ; } } } } }	public enforc ani user data constraint requir secur constraint guard thi request uri . return code true code thi constraint wa violat process should continu , code fals code we have creat respons alreadi . param request request we ar process param respons respons we ar creat param constraint secur constraint check except ioexcept input output error occur boolean ha user data permiss ( request request , respons respons , secur constraint constraint ) throw ioexcept { relev user data constraint ( constraint = = null constraint . length = = 0 ) { ( log . debug enabl ( ) ) log . debug ( applic secur constraint defin ) ; return ( true ) ; } ( int i = 0 ; i constraint . length ; i ) { secur constraint constraint = constraint i ; string user constraint = constraint . get user constraint ( ) ; ( user constraint = = null ) { ( log . debug enabl ( ) ) log . debug ( applic user data constraint defin ) ; return ( true ) ; } ( user constraint . equal ( constant . none transport ) ) { ( log . debug enabl ( ) ) log . debug ( user data constraint ha restrict ) ; return ( true ) ; } } valid request against user data constraint ( request . get request ( ) . secur ( ) ) { ( log . debug enabl ( ) ) log . debug ( user data constraint alreadi satisfi ) ; return ( true ) ; } initi variabl we need determin appropri action int redirect port = request . get connector ( ) . get redirect port ( ) ; redirect disabl ( redirect port = 0 ) { ( log . debug enabl ( ) ) log . debug ( ssl redirect disabl ) ; respons . send error ( http servlet respons . sc forbidden , request . get request uri ( ) ) ; return ( fals ) ; } redirect correspond ssl port string builder file = new string builder ( ) ; string protocol = http ; string host = request . get server name ( ) ; protocol file . append ( protocol ) . append ( : ) . append ( host ) ; host port ( redirect port = 443 ) { file . append ( : ) . append ( redirect port ) ; } uri file . append ( request . get request uri ( ) ) ; string request session id = request . get request session id ( ) ; ( ( request session id = null ) request . request session id from url ( ) ) { file . append ( ; ) ; file . append ( global . session paramet name ) ; file . append ( = ) ; file . append ( request session id ) ; } string queri string = request . get queri string ( ) ; ( queri string = null ) { file . append ( ) ; file . append ( queri string ) ; } ( log . debug enabl ( ) ) log . debug ( redirect file . string ( ) ) ; respons . send redirect ( file . string ( ) ) ; return ( fals ) ; }	public static creat new session cooki given session id param context context web applic param session id id session which cooki creat param secur should session cooki configur secur cooki creat session cooki ( context context , string session id , boolean secur ) { session cooki config scc = context . get servlet context ( ) . get session cooki config ( ) ; note : prioriti order session cooki configur : 1 . context level configur 2 . valu from session cooki config 3 . default cooki cooki = new cooki ( get session cooki name ( context ) , session id ) ; just appli default . cooki . set max ag ( scc . get max ag ( ) ) ; cooki . set comment ( scc . get comment ( ) ) ; ( context . get session cooki domain ( ) = = null ) { avoid possibl npe ( scc . get domain ( ) = null ) { cooki . set domain ( scc . get domain ( ) ) ; } } els { cooki . set domain ( context . get session cooki domain ( ) ) ; } alwai set secur request secur ( scc . secur ( ) secur ) { cooki . set secur ( true ) ; } alwai set http onli context configur ( scc . http onli ( ) context . get us http onli ( ) ) { cooki . set http onli ( true ) ; } string context path = context . get session cooki path ( ) ; ( context path = = null context path . length ( ) = = 0 ) { context path = scc . get path ( ) ; } ( context path = = null context path . length ( ) = = 0 ) { context path = context . get encod path ( ) ; } cooki . set path ( context path ) ; return cooki ; }	public static determin name us session cooki provid context . param context string get session cooki name ( context context ) { 3 . default defin spec ( context = null ) { string cooki name = context . get session cooki name ( ) ; ( cooki name = null cooki name . length ( ) 0 ) { return cooki name ; } session cooki config scc = context . get servlet context ( ) . get session cooki config ( ) ; cooki name = scc . get name ( ) ; ( cooki name = null cooki name . length ( ) 0 ) { return cooki name ; } } return global . session cooki name ; }	public releas all object refer , initi instanc variabl , prepar reus thi object . void recycl ( ) { context = null ; wrapper = null ; intern dispatch type = null ; request dispatch path = null ; comet = fals ; ( event = null ) { event . clear ( ) ; event = null ; } auth type = null ; input buffer . recycl ( ) ; us input stream = fals ; us reader = fals ; user princip = null ; subject = null ; session pars = fals ; paramet pars = fals ; part = null ; part pars except = null ; cooki pars = fals ; local . clear ( ) ; local pars = fals ; secur = fals ; remot addr = null ; remot host = null ; remot port = 1 ; local port = 1 ; local addr = null ; local name = null ; attribut . clear ( ) ; note . clear ( ) ; cooki = null ; ( session = null ) { session . end access ( ) ; } session = null ; request session cooki = fals ; request session id = null ; request session url = fals ; ( global . secur enabl connector . recycl facad ) { paramet map = new paramet map string , string ( ) ; } els { paramet map . set lock ( fals ) ; paramet map . clear ( ) ; } map data . recycl ( ) ; ( global . secur enabl connector . recycl facad ) { ( facad = null ) { facad . clear ( ) ; facad = null ; } ( input stream = null ) { input stream . clear ( ) ; input stream = null ; } ( reader = null ) { reader . clear ( ) ; reader = null ; } } async support = null ; ( async context = null ) async context . recycl ( ) ; async context = null ; }	public get coyot request . org . apach . coyot . request get coyot request ( ) { return ( thi . coyot request ) ; }
protect scan jar servlet contain initi implement . implement ad web fragment . xml prioriti order . boolean process servlet contain initi ( set web xml fragment ) { ( web xml fragment : fragment ) { url jar url = fragment . get url ( ) ; jar file jar file = null ; input stream = null ; servlet contain initi sci = null ; try { jar urlconnect conn = ( jar urlconnect ) jar url . open connect ( ) ; jar file = conn . get jar file ( ) ; zip entri entri = jar file . get entri ( meta inf servic javax . servlet . servlet contain initi ) ; ( entri = null ) { = jar file . get input stream ( entri ) ; sci = get servlet contain initi ( ) ; } } catch ( ioexcept ioe ) { log . error ( sm . get string ( context config . servlet contain initi fail , jar url , context . get path ( ) ) ) ; return fals ; } final { ( = null ) { try { . close ( ) ; } catch ( ioexcept e ) { ignor } } ( jar file = null ) { try { jar file . close ( ) ; } catch ( ioexcept e ) { ignor } } } ( sci = = null ) { continu ; } initi class map . put ( sci , new hash set class >> ( ) ) ; handl type ht = sci . get class ( ) . get annot ( handl type . class ) ; ( ht = null ) { class type = ht . valu ( ) ; ( type = null ) { ( class type : type ) { set servlet contain initi sci = type initi map . get ( type ) ; ( sci = = null ) { sci = new hash set servlet contain initi ( ) ; type initi map . put ( type , sci ) ; } sci . add ( sci ) ; } } } } return true ; }	protect scan jar contain web fragment . xml file us configur thi applic see thei also contain static resourc . static resourc ar found , add them context . resourc ar ad web fragment . xml prioriti order . void process resourc jar ( set web xml fragment ) { ( web xml fragment : fragment ) { url jar url = fragment . get url ( ) ; jar file jar file = null ; try { jar urlconnect conn = ( jar urlconnect ) jar url . open connect ( ) ; jar file = conn . get jar file ( ) ; zip entri entri = jar file . get entri ( meta inf resourc ) ; ( entri = null ) { context . add resourc jar url ( jar url ) ; } } catch ( ioexcept ioe ) { log . error ( sm . get string ( context config . resourc jar fail , jar url , context . get path ( ) ) ) ; } final { ( jar file = null ) { try { jar file . close ( ) ; } catch ( ioexcept e ) { ignor } } } } }
public specifi domain within which thi cooki should present . p form domain name specifi rfc 2109 . domain name begin dot ( code . foo . com code ) mean cooki visibl server specifi domain name system ( dn ) zone ( exampl , code www . foo . com code , code . b . foo . com code ) . default , cooki ar onli return server sent them . param pattern code string code contain domain name within which thi cooki visibl ; form accord rfc 2109 see get domain void set domain ( string pattern ) { ie allegedli need thi domain = pattern . lower case ( ) ; }
protect void connect us driver ( ) throw sqlexcept { java . sql . driver driver = null ; try { driver = ( java . sql . driver ) class . name ( pool properti . get driver class name ( ) , true , pool connect . class . get class loader ( ) ) . new instanc ( ) ; } catch ( java . lang . except cn ) { ( log . debug enabl ( ) ) { log . debug ( unabl instanti jdbc driver . , cn ) ; } sqlexcept ex = new sqlexcept ( cn . get messag ( ) ) ; ex . init caus ( cn ) ; throw ex ; } string driver url = pool properti . get url ( ) ; string usr = pool properti . get usernam ( ) ; string pwd = pool properti . get password ( ) ; pool properti . get db properti ( ) . set properti ( user , usr ) ; pool properti . get db properti ( ) . set properti ( password , pwd ) ; try { connect = driver . connect ( driver url , pool properti . get db properti ( ) ) ; } catch ( except x ) { ( log . debug enabl ( ) ) { log . debug ( unabl connect databas . , x ) ; } ( parent . jmx pool = null ) { parent . jmx pool . notifi ( org . apach . tomcat . jdbc . pool . jmx . connect pool . notifi connect , connect pool . get stack trace ( x ) ) ; } ( x instanceof sqlexcept ) { throw ( sqlexcept ) x ; } els { sqlexcept ex = new sqlexcept ( x . get messag ( ) ) ; ex . init caus ( x ) ; throw ex ; } } ( connect = = null ) { throw new sqlexcept ( driver : driver return null url : driver url ) ; } }
privat adapt from file upload base . get file name ( ) string extract filenam ( string cd ) { string file name = null ; ( cd = null ) { string cdl = cd . lower case ( ) ; ( cdl . start ( form data ) cdl . start ( attach ) ) { paramet parser parser = new paramet parser ( ) ; parser . set lower case name ( true ) ; paramet parser can handl null input map string , string param = parser . pars ( cd , ; ) ; ( param . contain kei ( filenam ) ) { file name = param . get ( filenam ) ; ( file name = null ) { file name = file name . trim ( ) ; } els { even valu , paramet present , so we return empti file name rather than file name . file name = ; } } } } return file name ; }	privat return field name , which given content disposit header . param p content disposit content disposit header valu . return field jake string get field name ( string p content disposit ) { string field name = null ; ( p content disposit = null p content disposit . lower case ( ) . start ( form data ) ) { paramet parser parser = new paramet parser ( ) ; parser . set lower case name ( true ) ; paramet parser can handl null input map string , string param = parser . pars ( p content disposit , ; ) ; field name = param . get ( name ) ; ( field name = null ) { field name = field name . trim ( ) ; } } return field name ; }	privat return given content disposit header file name . param p content disposit content disposit header valu . return file name string get file name ( string p content disposit ) { string file name = null ; ( p content disposit = null ) { string cdl = p content disposit . lower case ( ) ; ( cdl . start ( form data ) cdl . start ( attach ) ) { paramet parser parser = new paramet parser ( ) ; parser . set lower case name ( true ) ; paramet parser can handl null input map string , string param = parser . pars ( p content disposit , ; ) ; ( param . contain kei ( filenam ) ) { file name = param . get ( filenam ) ; ( file name = null ) { file name = file name . trim ( ) ; } els { even valu , paramet present , so we return empti file name rather than file name . file name = ; } } } } return file name ; }	privat copi resourc . param req servlet request param resp servlet respons return boolean true copi success boolean copi resourc ( http servlet request req , http servlet respons resp ) throw ioexcept { pars destin header string destin path = req . get header ( destin ) ; ( destin path = = null ) { resp . send error ( webdav statu . sc bad request ) ; return fals ; } remov url encod from destin destin path = request util . urldecod ( destin path , utf8 ) ; int protocol index = destin path . index ( : ) ; ( protocol index = 0 ) { destin url contain protocol , we can safe trim everyth upto first charact after : int first separ = destin path . index ( , protocol index 4 ) ; ( first separ 0 ) { destin path = ; } els { destin path = destin path . substr ( first separ ) ; } } els { string host name = req . get server name ( ) ; ( ( host name = null ) ( destin path . start ( host name ) ) ) { destin path = destin path . substr ( host name . length ( ) ) ; } int port index = destin path . index ( : ) ; ( port index = 0 ) { destin path = destin path . substr ( port index ) ; } ( destin path . start ( : ) ) { int first separ = destin path . index ( ) ; ( first separ 0 ) { destin path = ; } els { destin path = destin path . substr ( first separ ) ; } } } normalis destin path ( remov . . . ) destin path = request util . normal ( destin path ) ; string context path = req . get context path ( ) ; ( ( context path = null ) ( destin path . start ( context path ) ) ) { destin path = destin path . substr ( context path . length ( ) ) ; } string path info = req . get path info ( ) ; ( path info = null ) { string servlet path = req . get servlet path ( ) ; ( ( servlet path = null ) ( destin path . start ( servlet path ) ) ) { destin path = destin path . substr ( servlet path . length ( ) ) ; } } ( debug 0 ) log ( dest path : destin path ) ; ( ( destin path . upper case ( ) . start ( web inf ) ) ( destin path . upper case ( ) . start ( meta inf ) ) ) { resp . send error ( webdav statu . sc forbidden ) ; return fals ; } string path = get rel path ( req ) ; ( ( path . upper case ( ) . start ( web inf ) ) ( path . upper case ( ) . start ( meta inf ) ) ) { resp . send error ( webdav statu . sc forbidden ) ; return fals ; } ( destin path . equal ( path ) ) { resp . send error ( webdav statu . sc forbidden ) ; return fals ; } pars overwrit header boolean overwrit = true ; string overwrit header = req . get header ( overwrit ) ; ( overwrit header = null ) { ( overwrit header . equal ignor case ( t ) ) { overwrit = true ; } els { overwrit = fals ; } } overwrit destin boolean exist = true ; try { resourc . lookup ( destin path ) ; } catch ( name except e ) { exist = fals ; } ( overwrit ) { delet destin resourc , exist ( exist ) { ( delet resourc ( destin path , req , resp , true ) ) { return fals ; } } els { resp . set statu ( webdav statu . sc creat ) ; } } els { destin exist , s conflict ( exist ) { resp . send error ( webdav statu . sc precondit fail ) ; return fals ; } } copi sourc destin hashtabl string , integ error list = new hashtabl string , integ ( ) ; boolean result = copi resourc ( resourc , error list , path , destin path ) ; ( ( result ) ( error list . empti ( ) ) ) { ( error list . size ( ) = = 1 ) { resp . send error ( error list . element ( ) . next element ( ) . int valu ( ) ) ; } els { send report ( req , resp , error list ) ; } return fals ; } copi wa success ( exist ) { resp . set statu ( webdav statu . sc content ) ; } els { resp . set statu ( webdav statu . sc creat ) ; } remov ani lock null resourc which would present destin path lock null resourc . remov ( destin path ) ; return true ; }	privat delet resourc . param path path resourc which delet param req servlet request param resp servlet respons param set statu should respons statu set success complet boolean delet resourc ( string path , http servlet request req , http servlet respons resp , boolean set statu ) throw ioexcept { ( ( path . upper case ( ) . start ( web inf ) ) ( path . upper case ( ) . start ( meta inf ) ) ) { resp . send error ( webdav statu . sc forbidden ) ; return fals ; } string header = req . get header ( ) ; ( header = = null ) header = ; string lock token header = req . get header ( lock token ) ; ( lock token header = = null ) lock token header = ; ( lock ( path , header lock token header ) ) { resp . send error ( webdav statu . sc lock ) ; return fals ; } boolean exist = true ; object object = null ; try { object = resourc . lookup ( path ) ; } catch ( name except e ) { exist = fals ; } ( exist ) { resp . send error ( webdav statu . sc found ) ; return fals ; } boolean collect = ( object instanceof dir context ) ; ( collect ) { try { resourc . unbind ( path ) ; } catch ( name except e ) { resp . send error ( webdav statu . sc intern server error ) ; return fals ; } } els { hashtabl string , integ error list = new hashtabl string , integ ( ) ; delet collect ( req , resourc , path , error list ) ; try { resourc . unbind ( path ) ; } catch ( name except e ) { error list . put ( path , new integ ( webdav statu . sc intern server error ) ) ; } ( error list . empti ( ) ) { send report ( req , resp , error list ) ; return fals ; } } ( set statu ) { resp . set statu ( webdav statu . sc content ) ; } return true ; }	call find nex item , ani . return true , next item wa found , otherwis fals . throw ioexcept i o error occur . boolean find next item ( ) throw ioexcept { ( eof ) { return fals ; } ( current item = null ) { current item . close ( ) ; current item = null ; } ( ; ; ) { boolean next part ; ( skip preambl ) { next part = multi . skip preambl ( ) ; } els { next part = multi . read boundari ( ) ; } ( next part ) { ( current field name = = null ) { outer multipart termin more data eof = true ; return fals ; } inner multipart termin return pars outer multi . set boundari ( boundari ) ; current field name = null ; continu ; } file item header header = get pars header ( multi . read header ( ) ) ; ( current field name = = null ) { we re pars outer multipart string field name = get field name ( header ) ; ( field name = null ) { string sub content type = header . get header ( content type ) ; ( sub content type = null sub content type . lower case ( ) . start ( multipart mix ) ) { current field name = field name ; multipl file associ thi field name byte sub boundari = get boundari ( sub content type ) ; multi . set boundari ( sub boundari ) ; skip preambl = true ; continu ; } string file name = get file name ( header ) ; current item = new file item stream impl ( file name , field name , header . get header ( content type ) , file name = = null , get content length ( header ) ) ; current item . set header ( header ) ; notifi . note item ( ) ; item valid = true ; return true ; } } els { string file name = get file name ( header ) ; ( file name = null ) { current item = new file item stream impl ( file name , current field name , header . get header ( content type ) , fals , get content length ( header ) ) ; current item . set header ( header ) ; notifi . note item ( ) ; item valid = true ; return true ; } } multi . discard bodi data ( ) ; } }	privat static add jar specifi extens list . void add folder list ( string properti ) { get file extens directori string extens dir = system . get properti ( properti ) ; ( extens dir = null ) { string token extens tok = new string token ( extens dir , file . path separ ) ; while ( extens tok . ha more token ( ) ) { file target dir = new file ( extens tok . next token ( ) ) ; ( target dir . directori ( ) ) { continu ; } file file = target dir . list file ( ) ; ( int i = 0 ; i file . length ; i ) { ( file i . get name ( ) . lower case ( ) . end ( . jar ) file i . file ( ) ) { try { add system resourc ( file i ) ; } catch ( ioexcept e ) { log . error ( sm . get string ( extens valid . failload , file i ) , e ) ; } } } } } }	privat static void process accept languag ( string accept languag , hashtabl string , vector string >> languag , vector doubl q ) { string token languag token = new string token ( accept languag , , ) ; while ( languag token . ha more token ( ) ) { string languag = languag token . next token ( ) . trim ( ) ; int q valu index = languag . index ( ; ) ; int q index = languag . index ( q ) ; int equal index = languag . index ( = ) ; doubl q valu = new doubl ( 1 ) ; ( q valu index 1 q valu index q index q index equal index ) { string q valu str = languag . substr ( q valu index 1 ) ; languag = languag . substr ( 0 , q valu index ) ; q valu str = q valu str . trim ( ) . lower case ( ) ; q valu index = q valu str . index ( = ) ; q valu = new doubl ( 0 ) ; ( q valu str . start ( q ) q valu index 1 ) { q valu str = q valu str . substr ( q valu index 1 ) ; try { q valu = new doubl ( q valu str . trim ( ) ) ; } catch ( number format except nfe ) { } } } mai need handl some point time ( languag . equal ( ) ) { string kei = q valu . string ( ) ; vector string v ; ( languag . contain kei ( kei ) ) { v = languag . get ( kei ) ; } els { v = new vector string ( ) ; q . add element ( q valu ) ; } v . add element ( languag ) ; languag . put ( kei , v ) ; } } }	privat delet collect . param dir context resourc implement associ context param path path collect delet param error list contain list error which occur void delet collect ( http servlet request req , dir context dir context , string path , hashtabl string , integ error list ) { ( debug 1 ) log ( delet : path ) ; ( ( path . upper case ( ) . start ( web inf ) ) ( path . upper case ( ) . start ( meta inf ) ) ) { error list . put ( path , new integ ( webdav statu . sc forbidden ) ) ; return ; } string header = req . get header ( ) ; ( header = = null ) header = ; string lock token header = req . get header ( lock token ) ; ( lock token header = = null ) lock token header = ; enumer name class pair enumer = null ; try { enumer = dir context . list ( path ) ; } catch ( name except e ) { error list . put ( path , new integ ( webdav statu . sc intern server error ) ) ; return ; } while ( enumer . ha more element ( ) ) { name class pair nc pair = enumer . next element ( ) ; string child name = path ; ( child name . equal ( ) ) child name = ; child name = nc pair . get name ( ) ; ( lock ( child name , header lock token header ) ) { error list . put ( child name , new integ ( webdav statu . sc lock ) ) ; } els { try { object object = dir context . lookup ( child name ) ; ( object instanceof dir context ) { delet collect ( req , dir context , child name , error list ) ; } try { dir context . unbind ( child name ) ; } catch ( name except e ) { ( ( object instanceof dir context ) ) { s collect , s unknown error error list . put ( child name , new integ ( webdav statu . sc intern server error ) ) ; } } } catch ( name except e ) { error list . put ( child name , new integ ( webdav statu . sc intern server error ) ) ; } } } }	privat print lock discoveri inform associ path . param path path param gener xml xml data which lock info append return true least lock wa displai boolean gener lock discoveri ( string path , xmlwriter gener xml ) { lock info resourc lock = resourc lock . get ( path ) ; enumer lock info collect lock list = collect lock . element ( ) ; boolean wrote start = fals ; ( resourc lock = null ) { wrote start = true ; gener xml . write element ( null , lockdiscoveri , xmlwriter . open ) ; resourc lock . xml ( gener xml ) ; } while ( collect lock list . ha more element ( ) ) { lock info current lock = collect lock list . next element ( ) ; ( path . start ( current lock . path ) ) { ( wrote start ) { wrote start = true ; gener xml . write element ( null , lockdiscoveri , xmlwriter . open ) ; } current lock . xml ( gener xml ) ; } } ( wrote start ) { gener xml . write element ( null , lockdiscoveri , xmlwriter . close ) ; } els { return fals ; } return true ; }	privat propfind helper method . param req servlet request param resourc resourc object associ thi context param gener xml xml respons propfind request param path path current resourc param type propfind type param properti vector propfind type find properti name , thi vector contain those properti void pars properti ( http servlet request req , xmlwriter gener xml , string path , int type , vector string properti vector ) { ( upper case ( ) avoid problem window system ) ( path . upper case ( ) . start ( web inf ) path . upper case ( ) . start ( meta inf ) ) return ; cach entri cach entri = resourc . lookup cach ( path ) ; ( cach entri . exist ) { broken symlink odd permiss set return ; } gener xml . write element ( null , respons , xmlwriter . open ) ; string statu = new string ( http 1 . 1 webdav statu . sc ok webdav statu . get statu text ( webdav statu . sc ok ) ) ; gener href element gener xml . write element ( null , href , xmlwriter . open ) ; string href = req . get context path ( ) req . get servlet path ( ) ; ( ( href . end ( ) ) ( path . start ( ) ) ) href = path . substr ( 1 ) ; els href = path ; ( ( cach entri . context = null ) ( href . end ( ) ) ) href = ; gener xml . write text ( rewrit url ( href ) ) ; gener xml . write element ( null , href , xmlwriter . close ) ; string resourc name = path ; int last slash = path . last index ( ) ; ( last slash = 1 ) resourc name = resourc name . substr ( last slash 1 ) ; switch ( type ) { case find all prop : gener xml . write element ( null , propstat , xmlwriter . open ) ; gener xml . write element ( null , prop , xmlwriter . open ) ; gener xml . write properti ( null , creationd , get isocr date ( cach entri . attribut . get creation ( ) ) ) ; gener xml . write element ( null , displaynam , xmlwriter . open ) ; gener xml . write data ( resourc name ) ; gener xml . write element ( null , displaynam , xmlwriter . close ) ; ( cach entri . resourc = null ) { gener xml . write properti ( null , getlastmodifi , fast http date format . format date ( cach entri . attribut . get last modifi ( ) , null ) ) ; gener xml . write properti ( null , getcontentlength , string . valu ( cach entri . attribut . get content length ( ) ) ) ; string content type = get servlet context ( ) . get mime type ( cach entri . name ) ; ( content type = null ) { gener xml . write properti ( null , getcontenttyp , content type ) ; } gener xml . write properti ( null , getetag , cach entri . attribut . get etag ( ) ) ; gener xml . write element ( null , resourcetyp , xmlwriter . content ) ; } els { gener xml . write element ( null , resourcetyp , xmlwriter . open ) ; gener xml . write element ( null , collect , xmlwriter . content ) ; gener xml . write element ( null , resourcetyp , xmlwriter . close ) ; } gener xml . write properti ( null , sourc , ) ; string support lock = lockentri lockscop exclus lockscop locktyp write locktyp lockentri lockentri lockscop share lockscop locktyp write locktyp lockentri ; gener xml . write element ( null , supportedlock , xmlwriter . open ) ; gener xml . write text ( support lock ) ; gener xml . write element ( null , supportedlock , xmlwriter . close ) ; gener lock discoveri ( path , gener xml ) ; gener xml . write element ( null , prop , xmlwriter . close ) ; gener xml . write element ( null , statu , xmlwriter . open ) ; gener xml . write text ( statu ) ; gener xml . write element ( null , statu , xmlwriter . close ) ; gener xml . write element ( null , propstat , xmlwriter . close ) ; break ; case find properti name : gener xml . write element ( null , propstat , xmlwriter . open ) ; gener xml . write element ( null , prop , xmlwriter . open ) ; gener xml . write element ( null , creationd , xmlwriter . content ) ; gener xml . write element ( null , displaynam , xmlwriter . content ) ; ( cach entri . resourc = null ) { gener xml . write element ( null , getcontentlanguag , xmlwriter . content ) ; gener xml . write element ( null , getcontentlength , xmlwriter . content ) ; gener xml . write element ( null , getcontenttyp , xmlwriter . content ) ; gener xml . write element ( null , getetag , xmlwriter . content ) ; gener xml . write element ( null , getlastmodifi , xmlwriter . content ) ; } gener xml . write element ( null , resourcetyp , xmlwriter . content ) ; gener xml . write element ( null , sourc , xmlwriter . content ) ; gener xml . write element ( null , lockdiscoveri , xmlwriter . content ) ; gener xml . write element ( null , prop , xmlwriter . close ) ; gener xml . write element ( null , statu , xmlwriter . open ) ; gener xml . write text ( statu ) ; gener xml . write element ( null , statu , xmlwriter . close ) ; gener xml . write element ( null , propstat , xmlwriter . close ) ; break ; case find properti : vector string properti found = new vector string ( ) ; pars list properti gener xml . write element ( null , propstat , xmlwriter . open ) ; gener xml . write element ( null , prop , xmlwriter . open ) ; enumer string properti = properti vector . element ( ) ; while ( properti . ha more element ( ) ) { string properti = properti . next element ( ) ; ( properti . equal ( creationd ) ) { gener xml . write properti ( null , creationd , get isocr date ( cach entri . attribut . get creation ( ) ) ) ; } els ( properti . equal ( displaynam ) ) { gener xml . write element ( null , displaynam , xmlwriter . open ) ; gener xml . write data ( resourc name ) ; gener xml . write element ( null , displaynam , xmlwriter . close ) ; } els ( properti . equal ( getcontentlanguag ) ) { ( cach entri . context = null ) { properti found . add element ( properti ) ; } els { gener xml . write element ( null , getcontentlanguag , xmlwriter . content ) ; } } els ( properti . equal ( getcontentlength ) ) { ( cach entri . context = null ) { properti found . add element ( properti ) ; } els { gener xml . write properti ( null , getcontentlength , ( string . valu ( cach entri . attribut . get content length ( ) ) ) ) ; } } els ( properti . equal ( getcontenttyp ) ) { ( cach entri . context = null ) { properti found . add element ( properti ) ; } els { gener xml . write properti ( null , getcontenttyp , get servlet context ( ) . get mime type ( cach entri . name ) ) ; } } els ( properti . equal ( getetag ) ) { ( cach entri . context = null ) { properti found . add element ( properti ) ; } els { gener xml . write properti ( null , getetag , cach entri . attribut . get etag ( ) ) ; } } els ( properti . equal ( getlastmodifi ) ) { ( cach entri . context = null ) { properti found . add element ( properti ) ; } els { gener xml . write properti ( null , getlastmodifi , fast http date format . format date ( cach entri . attribut . get last modifi ( ) , null ) ) ; } } els ( properti . equal ( resourcetyp ) ) { ( cach entri . context = null ) { gener xml . write element ( null , resourcetyp , xmlwriter . open ) ; gener xml . write element ( null , collect , xmlwriter . content ) ; gener xml . write element ( null , resourcetyp , xmlwriter . close ) ; } els { gener xml . write element ( null , resourcetyp , xmlwriter . content ) ; } } els ( properti . equal ( sourc ) ) { gener xml . write properti ( null , sourc , ) ; } els ( properti . equal ( supportedlock ) ) { support lock = lockentri lockscop exclus lockscop locktyp write locktyp lockentri lockentri lockscop share lockscop locktyp write locktyp lockentri ; gener xml . write element ( null , supportedlock , xmlwriter . open ) ; gener xml . write text ( support lock ) ; gener xml . write element ( null , supportedlock , xmlwriter . close ) ; } els ( properti . equal ( lockdiscoveri ) ) { ( gener lock discoveri ( path , gener xml ) ) properti found . add element ( properti ) ; } els { properti found . add element ( properti ) ; } } gener xml . write element ( null , prop , xmlwriter . close ) ; gener xml . write element ( null , statu , xmlwriter . open ) ; gener xml . write text ( statu ) ; gener xml . write element ( null , statu , xmlwriter . close ) ; gener xml . write element ( null , propstat , xmlwriter . close ) ; enumer string properti found list = properti found . element ( ) ; ( properti found list . ha more element ( ) ) { statu = new string ( http 1 . 1 webdav statu . sc found webdav statu . get statu text ( webdav statu . sc found ) ) ; gener xml . write element ( null , propstat , xmlwriter . open ) ; gener xml . write element ( null , prop , xmlwriter . open ) ; while ( properti found list . ha more element ( ) ) { gener xml . write element ( null , properti found list . next element ( ) , xmlwriter . content ) ; } gener xml . write element ( null , prop , xmlwriter . close ) ; gener xml . write element ( null , statu , xmlwriter . open ) ; gener xml . write text ( statu ) ; gener xml . write element ( null , statu , xmlwriter . close ) ; gener xml . write element ( null , propstat , xmlwriter . close ) ; } break ; } gener xml . write element ( null , respons , xmlwriter . close ) ; }	protect string get cgivari ( string name ) { string ret val = null ; string name part = name . upper case ( ) . split ( ) ; int requir part = 2 ; ( name part . length = = 1 ) { ( name part 0 . equal ( path ) ) { requir part = 1 ; } } }	protect string upload ( http servlet request request ) throw ioexcept , servlet except { string messag = ; part war part = null ; string filenam = null ; string basenam = null ; collect part part = request . get part ( ) ; iter part iter = part . iter ( ) ; try { while ( iter . ha next ( ) ) { part part = iter . next ( ) ; ( part . get name ( ) . equal ( deploi war ) war part = = null ) { war part = part ; } els { part . delet ( ) ; } } while ( true ) { ( war part = = null ) { messag = sm . get string ( html manag servlet . deploi upload file ) ; break ; } filenam = extract filenam ( war part . get header ( content disposit ) ) ; ( filenam . lower case ( ) . end ( . war ) ) { messag = sm . get string ( html manag servlet . deploi upload war , filenam ) ; break ; } get filenam upload name includ path ( filenam . last index ( ) = 0 ) { filenam = filenam . substr ( filenam . last index ( ) 1 ) ; } ( filenam . last index ( ) = 0 ) { filenam = filenam . substr ( filenam . last index ( ) 1 ) ; } identifi app base own host thi context ( ani ) basenam = filenam . substr ( 0 , filenam . lower case ( ) . index ( . war ) ) ; file file = new file ( get app base ( ) , filenam ) ; ( file . exist ( ) ) { messag = sm . get string ( html manag servlet . deploi upload war exist , filenam ) ; break ; } string path = null ; ( basenam . equal ( root ) ) { path = ; } els { path = basenam . replac ( , ) ; } ( ( host . find child ( path ) = null ) deploi ( path ) ) { messag = sm . get string ( html manag servlet . deploi upload server xml , filenam ) ; break ; } ( servic ( path ) ) { add servic ( path ) ; try { war part . write ( file . get absolut path ( ) ) ; perform new deploy check ( path ) ; } final { remov servic ( path ) ; } } break ; } } catch ( except e ) { messag = sm . get string ( html manag servlet . deploi upload fail , e . get messag ( ) ) ; log ( messag , e ) ; } final { ( war part = null ) { war part . delet ( ) ; } war part = null ; } return messag ; }	protect construct cgi environ suppli invok cgi script ; reli heavili servlet api method find cgi param req request associ cgi invoc return true environ wa set ok , fals wa problem environ wa set boolean set cgienviron ( http servlet request req ) throw ioexcept { thi method slightli ugli ; c est la vie . you cannot stop ugli , you can onli hope contain ( apolog marv albert regard mj ) hashtabl string , string envp = new hashtabl string , string ( ) ; add shell environ variabl ( ani ) envp . put all ( shell env ) ; add cgi environ variabl string s path info orig = null ; string s path info cgi = null ; string s path translat cgi = null ; string s cgiful path = null ; string s cgiscript name = null ; string s cgiful name = null ; string s cginam = null ; string s cginam ; s path info orig = thi . path info ; s path info orig = s path info orig = = null : s path info orig ; ( web app root dir = = null ) { app ha been deploi explod form web app root dir = tmp dir . string ( ) ; expand cgiscript ( ) ; } s cginam = find cgi ( s path info orig , web app root dir , context path , servlet path , cgi path prefix ) ; s cgiful path = s cginam 0 ; s cgiscript name = s cginam 1 ; s cgiful name = s cginam 2 ; s cginam = s cginam 3 ; ( s cgiful path = = null s cgiscript name = = null s cgiful name = = null s cginam = = null ) { return fals ; } envp . put ( server softwar , tomcat ) ; envp . put ( server name , null blank ( req . get server name ( ) ) ) ; envp . put ( gatewai interfac , cgi 1 . 1 ) ; envp . put ( server protocol , null blank ( req . get protocol ( ) ) ) ; int port = req . get server port ( ) ; integ i port = ( port = = 0 integ . valu ( 1 ) : integ . valu ( port ) ) ; envp . put ( server port , i port . string ( ) ) ; envp . put ( request method , null blank ( req . get method ( ) ) ) ; envp . put ( request uri , null blank ( req . get request uri ( ) ) ) ; path info should determin us s cgiful name : 1 ) let s cgiful name end ( see method find cgi ) 2 ) let s cgiful name equal path info fragment which correspond actual cgi script . 3 ) thu , path info = request . get path info ( ) . substr ( s cgiful name . length ( ) ) ( see method find cgi , where real work done ) ( path info = = null ( path info . substr ( s cgiful name . length ( ) ) . length ( ) = 0 ) ) { s path info cgi = ; } els { s path info cgi = path info . substr ( s cgiful name . length ( ) ) ; } envp . put ( path info , s path info cgi ) ; path translat must determin after path info ( impli real cgi script ) ha been taken account . follow exampl demonstr : servlet info = servlet cgigw dir1 dir2 cgi1 trans1 trans2 cgifullpath = servlet cgigw dir1 dir2 cgi1 path info = trans1 trans2 web app root dir = servlet context . get real path ( ) path translat = servlet context . get real path ( trans1 trans2 ) , path translat = web app root dir s path info cgi ( unless s path info cgi null blank , cgi specif dictat path translat metavari should defin . ( s path info cgi = null ( . equal ( s path info cgi ) ) ) { s path translat cgi = context . get real path ( s path info cgi ) ; } ( s path translat cgi = = null . equal ( s path translat cgi ) ) { noop } els { envp . put ( path translat , null blank ( s path translat cgi ) ) ; } envp . put ( script name , null blank ( s cgiscript name ) ) ; envp . put ( queri string , null blank ( req . get queri string ( ) ) ) ; envp . put ( remot host , null blank ( req . get remot host ( ) ) ) ; envp . put ( remot addr , null blank ( req . get remot addr ( ) ) ) ; envp . put ( auth type , null blank ( req . get auth type ( ) ) ) ; envp . put ( remot user , null blank ( req . get remot user ( ) ) ) ; necessari full complianc envp . put ( remot ident , ) ; envp . put ( content type , null blank ( req . get content type ( ) ) ) ; note cgi spec sai content length must null ( ) undefin content , so we cannot put 0 1 per servlet api spec . int content length = req . get content length ( ) ; string s content length = ( content length = 0 : ( integ . valu ( content length ) ) . string ( ) ) ; envp . put ( content length , s content length ) ; enumer string header = req . get header name ( ) ; string header = null ; while ( header . ha more element ( ) ) { header = null ; header = header . next element ( ) . upper case ( ) ; remind : i forgot what previou remind mean ( author . equal ignor case ( header ) proxi author . equal ignor case ( header ) ) { noop per cgi specif section 11 . 2 } els { envp . put ( http header . replac ( , ) , req . get header ( header ) ) ; } } file f cgiful path = new file ( s cgiful path ) ; command = f cgiful path . get canon path ( ) ; kick envp . put ( x tomcat script path , command ) ; php envp . put ( script filenam , command ) ; thi . env = envp ; return true ; }	protect void anti lock ( ) { ( ( context instanceof standard context ) ( ( standard context ) context ) . get anti resourc lock ( ) ) { host host = ( host ) context . get parent ( ) ; string app base = host . get app base ( ) ; string doc base = context . get doc base ( ) ; ( doc base = = null ) return ; ( origin doc base = = null ) { origin doc base = doc base ; } els { doc base = origin doc base ; } file doc base file = new file ( doc base ) ; ( doc base file . absolut ( ) ) { file file = new file ( app base ) ; ( file . absolut ( ) ) { file = new file ( system . get properti ( catalina . base ) , app base ) ; } doc base file = new file ( file , doc base ) ; } string path = context . get path ( ) ; ( path = = null ) { return ; } ( path . equal ( ) ) { doc base = root ; } els { ( path . start ( ) ) { doc base = path . substr ( 1 ) ; } els { doc base = path ; } } file file = null ; ( doc base . lower case ( ) . end ( . war ) ) { file = new file ( system . get properti ( java . io . tmpdir ) , deploy count doc base . war ) ; } els { file = new file ( system . get properti ( java . io . tmpdir ) , deploy count doc base ) ; } ( log . debug enabl ( ) ) log . debug ( anti lock context context . get path ( ) set doc base file ) ; cleanup just case old deploy ly around expand war . delet ( file ) ; ( expand war . copi ( doc base file , file ) ) { context . set doc base ( file . get absolut path ( ) ) ; } } }	protect param context path param context xml param file void deploi descriptor ( string context path , file context xml , string file ) { ( deploy exist ( context path ) ) { return ; } deploi applic deploi app = new deploi applic ( context path ) ; assum thi configur descriptor deploi ( log . info enabl ( ) ) { log . info ( sm . get string ( host config . deploi descriptor , file , config base . get path ( ) ) ) ; } context context = null ; try { synchron ( digest ) { try { context = ( context ) digest . pars ( context xml ) ; ( context = = null ) { log . error ( sm . get string ( host config . deploi descriptor . error , file ) ) ; return ; } } final { digest . reset ( ) ; } } class clazz = class . name ( host . get config class ( ) ) ; lifecycl listen listen = ( lifecycl listen ) clazz . new instanc ( ) ; context . add lifecycl listen ( listen ) ; context . set config file ( context xml . uri ( ) . url ( ) ) ; context . set path ( context path ) ; add associ doc base redeploi list s war boolean extern war = fals ; boolean extern = fals ; ( context . get doc base ( ) = null ) { file doc base = new file ( context . get doc base ( ) ) ; ( doc base . absolut ( ) ) { doc base = new file ( app base ( ) , context . get doc base ( ) ) ; } extern doc base , regist . xml redeploi first ( doc base . get canon path ( ) . start ( app base ( ) . get absolut path ( ) file . separ ) ) { extern = true ; deploi app . redeploi resourc . put ( context xml . get absolut path ( ) , new long ( context xml . last modifi ( ) ) ) ; deploi app . redeploi resourc . put ( doc base . get absolut path ( ) , new long ( doc base . last modifi ( ) ) ) ; ( doc base . get absolut path ( ) . lower case ( ) . end ( . war ) ) { extern war = true ; } } els { log . warn ( sm . get string ( host config . deploi descriptor . local doc base specifi , doc base ) ) ; ignor specifi doc base context . set doc base ( null ) ; } } host . add child ( context ) ; get path war expand war app base string name = null ; string path = context . get path ( ) ; ( path . equal ( ) ) { name = root ; } els { ( path . start ( ) ) { name = path . substr ( 1 ) ; } els { name = path ; } } default app base dir name file expand doc base = new file ( app base ( ) , name ) ; ( context . get doc base ( ) = null ) { first assum doc base absolut expand doc base = new file ( context . get doc base ( ) ) ; ( expand doc base . absolut ( ) ) { doc base specifi rel , must rel app base expand doc base = new file ( app base ( ) , context . get doc base ( ) ) ; } } watch insid ( extern war unpack war ) { deploi app . redeploi resourc . put ( expand doc base . get absolut path ( ) , new long ( expand doc base . last modifi ( ) ) ) ; deploi app . redeploi resourc . put ( context xml . get absolut path ( ) , new long ( context xml . last modifi ( ) ) ) ; add watch resourc ( deploi app , expand doc base . get absolut path ( ) , context ) ; } els { find exist match war expand folder ( extern ) { file war doc base = new file ( expand doc base . get absolut path ( ) . war ) ; ( war doc base . exist ( ) ) { deploi app . redeploi resourc . put ( war doc base . get absolut path ( ) , new long ( war doc base . last modifi ( ) ) ) ; } } ( expand doc base . exist ( ) ) { deploi app . redeploi resourc . put ( expand doc base . get absolut path ( ) , new long ( expand doc base . last modifi ( ) ) ) ; add watch resourc ( deploi app , expand doc base . get absolut path ( ) , context ) ; } els { add watch resourc ( deploi app , null , context ) ; } add context xml list file which should trigger redeploy ( extern ) { deploi app . redeploi resourc . put ( context xml . get absolut path ( ) , new long ( context xml . last modifi ( ) ) ) ; } } } catch ( throwabl t ) { log . error ( sm . get string ( host config . deploi descriptor . error , file ) , t ) ; } ( context = null host . find child ( context . get name ( ) ) = null ) { deploi . put ( context path , deploi app ) ; } }	protect deploi xml context descriptor . void deploi descriptor ( file config base , string file ) { ( file = = null ) return ; ( int i = 0 ; i file . length ; i ) { file context xml = new file ( config base , file i ) ; ( file i . lower case ( ) . end ( . xml ) ) { calcul context path make sure uniqu string name tmp = file i . substr ( 0 , file i . length ( ) 4 ) ; string context path = name tmp . replac ( , ) ; ( name tmp . equal ( root ) ) { context path = ; } ( servic ( context path ) ) continu ; string file = file i ; deploi descriptor ( context path , context xml , file ) ; } } }	protect deploi war file . void deploi war ( file app base , string file ) { ( file = = null ) return ; ( int i = 0 ; i file . length ; i ) { ( file i . equal ignor case ( meta inf ) ) continu ; ( file i . equal ignor case ( web inf ) ) continu ; file dir = new file ( app base , file i ) ; ( file i . lower case ( ) . end ( . war ) dir . file ( ) invalid war . contain ( file i ) ) { calcul context path make sure uniqu string context path = file i . replac ( , ) ; int period = context path . last index ( . ) ; context path = context path . substr ( 0 , period ) ; check war . . . similar sequenc name ( valid context path ( app base , context path ) ) { log . error ( sm . get string ( host config . illeg war name , file i ) ) ; invalid war . add ( file i ) ; continu ; } ( context path . equal ( root ) ) context path = ; ( servic ( context path ) ) continu ; string file = file i ; deploi war ( context path , dir , file ) ; } } }	protect mkcol method . void do mkcol ( http servlet request req , http servlet respons resp ) throw servlet except , ioexcept { ( read onli ) { resp . send error ( webdav statu . sc forbidden ) ; return ; } ( lock ( req ) ) { resp . send error ( webdav statu . sc lock ) ; return ; } string path = get rel path ( req ) ; ( ( path . upper case ( ) . start ( web inf ) ) ( path . upper case ( ) . start ( meta inf ) ) ) { resp . send error ( webdav statu . sc forbidden ) ; return ; } boolean exist = true ; try { resourc . lookup ( path ) ; } catch ( name except e ) { exist = fals ; } path ( exist ) { get allow method string builder method allow = determin method allow ( resourc , req ) ; resp . add header ( allow , method allow . string ( ) ) ; resp . send error ( webdav statu . sc method allow ) ; return ; } ( req . get content length ( ) 0 ) { document builder document builder = get document builder ( ) ; try { document document = document builder . pars ( new input sourc ( req . get input stream ( ) ) ) ; todo : process thi request bodi resp . send error ( webdav statu . sc implement ) ; return ; } catch ( saxexcept sax ) { pars error assum invalid content resp . send error ( webdav statu . sc unsupport media type ) ; return ; } } boolean result = true ; try { resourc . creat subcontext ( path ) ; } catch ( name except e ) { result = fals ; } ( result ) { resp . send error ( webdav statu . sc conflict , webdav statu . get statu text ( webdav statu . sc conflict ) ) ; } els { resp . set statu ( webdav statu . sc creat ) ; remov ani lock null resourc which would present lock null resourc . remov ( path ) ; } }	protect propfind method . void do propfind ( http servlet request req , http servlet respons resp ) throw servlet except , ioexcept { ( list ) { get allow method string builder method allow = determin method allow ( resourc , req ) ; resp . add header ( allow , method allow . string ( ) ) ; resp . send error ( webdav statu . sc method allow ) ; return ; } string path = get rel path ( req ) ; ( path . end ( ) ) path = path . substr ( 0 , path . length ( ) 1 ) ; ( ( path . upper case ( ) . start ( web inf ) ) ( path . upper case ( ) . start ( meta inf ) ) ) { resp . send error ( webdav statu . sc forbidden ) ; return ; } properti which ar displai . vector string properti = null ; propfind depth int depth = max depth ; propfind type int type = find all prop ; string depth str = req . get header ( depth ) ; ( depth str = = null ) { depth = max depth ; } els { ( depth str . equal ( 0 ) ) { depth = 0 ; } els ( depth str . equal ( 1 ) ) { depth = 1 ; } els ( depth str . equal ( infin ) ) { depth = max depth ; } } node prop node = null ; ( req . get content length ( ) 0 ) { document builder document builder = get document builder ( ) ; try { document document = document builder . pars ( new input sourc ( req . get input stream ( ) ) ) ; get root element document element root element = document . get document element ( ) ; node list child list = root element . get child node ( ) ; ( int i = 0 ; i child list . get length ( ) ; i ) { node current node = child list . item ( i ) ; switch ( current node . get node type ( ) ) { case node . text node : break ; case node . element node : ( current node . get node name ( ) . end ( prop ) ) { type = find properti ; prop node = current node ; } ( current node . get node name ( ) . end ( propnam ) ) { type = find properti name ; } ( current node . get node name ( ) . end ( allprop ) ) { type = find all prop ; } break ; } } } catch ( saxexcept e ) { someth went wrong bad request resp . send error ( webdav statu . sc bad request ) ; } catch ( ioexcept e ) { someth went wrong bad request resp . send error ( webdav statu . sc bad request ) ; } } ( type = = find properti ) { properti = new vector string ( ) ; prop node must non null type = = find properti suppress warn ( null ) node list child list = prop node . get child node ( ) ; ( int i = 0 ; i child list . get length ( ) ; i ) { node current node = child list . item ( i ) ; switch ( current node . get node type ( ) ) { case node . text node : break ; case node . element node : string node name = current node . get node name ( ) ; string properti name = null ; ( node name . index ( : ) = 1 ) { properti name = node name . substr ( node name . index ( : ) 1 ) ; } els { properti name = node name ; } href live properti which handl differ properti . add element ( properti name ) ; break ; } } } boolean exist = true ; object object = null ; try { object = resourc . lookup ( path ) ; } catch ( name except e ) { exist = fals ; int slash = path . last index ( ) ; ( slash = 1 ) { string parent path = path . substr ( 0 , slash ) ; vector string current lock null resourc = lock null resourc . get ( parent path ) ; ( current lock null resourc = null ) { enumer string lock null resourc list = current lock null resourc . element ( ) ; while ( lock null resourc list . ha more element ( ) ) { string lock null path = lock null resourc list . next element ( ) ; ( lock null path . equal ( path ) ) { resp . set statu ( webdav statu . sc multi statu ) ; resp . set content type ( text xml ; charset = utf 8 ) ; creat multistatu object xmlwriter gener xml = new xmlwriter ( resp . get writer ( ) ) ; gener xml . write xmlheader ( ) ; gener xml . write element ( null , multistatu gener namespac declar ( ) , xmlwriter . open ) ; pars lock null properti ( req , gener xml , lock null path , type , properti ) ; gener xml . write element ( null , multistatu , xmlwriter . close ) ; gener xml . send data ( ) ; return ; } } } } } ( exist ) { resp . send error ( http servlet respons . sc found , path ) ; return ; } resp . set statu ( webdav statu . sc multi statu ) ; resp . set content type ( text xml ; charset = utf 8 ) ; creat multistatu object xmlwriter gener xml = new xmlwriter ( resp . get writer ( ) ) ; gener xml . write xmlheader ( ) ; gener xml . write element ( null , multistatu gener namespac declar ( ) , xmlwriter . open ) ; ( depth = = 0 ) { pars properti ( req , gener xml , path , type , properti ) ; } els { stack alwai contain object current level stack string stack = new stack string ( ) ; stack . push ( path ) ; stack object level below stack string stack below = new stack string ( ) ; while ( ( stack . empti ( ) ) ( depth = 0 ) ) { string current path = stack . pop ( ) ; pars properti ( req , gener xml , current path , type , properti ) ; try { object = resourc . lookup ( current path ) ; } catch ( name except e ) { continu ; } ( ( object instanceof dir context ) ( depth 0 ) ) { try { name enumer name class pair enumer = resourc . list ( current path ) ; while ( enumer . ha more element ( ) ) { name class pair nc pair = enumer . next element ( ) ; string new path = current path ; ( ( new path . end ( ) ) ) new path = ; new path = nc pair . get name ( ) ; stack below . push ( new path ) ; } } catch ( name except e ) { resp . send error ( http servlet respons . sc intern server error , path ) ; return ; } displai lock null resourc present collect string lock path = current path ; ( lock path . end ( ) ) lock path = lock path . substr ( 0 , lock path . length ( ) 1 ) ; vector string current lock null resourc = lock null resourc . get ( lock path ) ; ( current lock null resourc = null ) { enumer string lock null resourc list = current lock null resourc . element ( ) ; while ( lock null resourc list . ha more element ( ) ) { string lock null path = lock null resourc list . next element ( ) ; pars lock null properti ( req , gener xml , lock null path , type , properti ) ; } } } ( stack . empti ( ) ) { depth ; stack = stack below ; stack below = new stack string ( ) ; } gener xml . send data ( ) ; } } gener xml . write element ( null , multistatu , xmlwriter . close ) ; gener xml . send data ( ) ; }	protect adjust doc base . void fix doc base ( ) throw ioexcept { host host = ( host ) context . get parent ( ) ; string app base = host . get app base ( ) ; boolean unpack war = true ; ( host instanceof standard host ) { unpack war = ( ( standard host ) host ) . unpack war ( ) ( ( standard context ) context ) . get unpack war ( ) ; } file canon app base = new file ( app base ) ; ( canon app base . absolut ( ) ) { canon app base = canon app base . get canon file ( ) ; } els { canon app base = new file ( system . get properti ( catalina . base ) , app base ) . get canon file ( ) ; } string doc base = context . get doc base ( ) ; ( doc base = = null ) { try guess doc base accord path string path = context . get path ( ) ; ( path = = null ) { return ; } ( path . equal ( ) ) { doc base = root ; } els { ( path . start ( ) ) { doc base = path . substr ( 1 ) . replac ( , ) ; } els { doc base = path . replac ( , ) ; } } } file file = new file ( doc base ) ; ( file . absolut ( ) ) { doc base = ( new file ( canon app base , doc base ) ) . get path ( ) ; } els { doc base = file . get canon path ( ) ; } file = new file ( doc base ) ; string orig doc base = doc base ; string path name = context . get path ( ) ; ( path name . equal ( ) ) { path name = root ; } els { context path must start path name = path name . substr ( 1 ) . replac ( , ) ; } ( doc base . lower case ( ) . end ( . war ) file . directori ( ) unpack war ) { url war = new url ( jar : ( new file ( doc base ) ) . uri ( ) . url ( ) ) ; doc base = expand war . expand ( host , war , path name ) ; file = new file ( doc base ) ; doc base = file . get canon path ( ) ; ( context instanceof standard context ) { ( ( standard context ) context ) . set origin doc base ( orig doc base ) ; } } els ( doc base . lower case ( ) . end ( . war ) file . directori ( ) unpack war ) { url war = new url ( jar : ( new file ( doc base ) ) . uri ( ) . url ( ) ) ; expand war . valid ( host , war , path name ) ; } els { file doc dir = new file ( doc base ) ; ( doc dir . exist ( ) ) { file war file = new file ( doc base . war ) ; ( war file . exist ( ) ) { url war = new url ( jar : war file . uri ( ) . url ( ) ) ; ( unpack war ) { doc base = expand war . expand ( host , war , path name ) ; file = new file ( doc base ) ; doc base = file . get canon path ( ) ; } els { doc base = war file . get canon path ( ) ; expand war . valid ( host , war , path name ) ; } } ( context instanceof standard context ) { ( ( standard context ) context ) . set origin doc base ( orig doc base ) ; } } } ( doc base . start ( canon app base . get path ( ) file . separ char ) ) { doc base = doc base . substr ( canon app base . get path ( ) . length ( ) ) ; doc base = doc base . replac ( file . separ char , ) ; ( doc base . start ( ) ) { doc base = doc base . substr ( 1 ) ; } } els { doc base = doc base . replac ( file . separ char , ) ; } context . set doc base ( doc base ) ; }	protect process our request locat right ssi command . param req valu type http servlet request param re valu type http servlet respons void request handler ( http servlet request req , http servlet respons re ) throw ioexcept { servlet context servlet context = get servlet context ( ) ; string path = ssiservlet request util . get rel path ( req ) ; ( debug 0 ) log ( ssiservlet . request handler ( ) n serv ( buffer buffer : unbuff ) resourc path ) ; ( upper case ( ) avoid problem window system ) ( path = = null path . upper case ( ) . start ( web inf ) path . upper case ( ) . start ( meta inf ) ) { re . send error ( http servlet respons . sc found , path ) ; log ( can t serv file : path ) ; return ; } url resourc = servlet context . get resourc ( path ) ; ( resourc = = null ) { re . send error ( http servlet respons . sc found , path ) ; log ( can t find file : path ) ; return ; } string resourc mime type = servlet context . get mime type ( path ) ; ( resourc mime type = = null ) { resourc mime type = text html ; } re . set content type ( resourc mime type ; charset = output encod ) ; ( expir = null ) { re . set date header ( expir , ( new java . util . date ( ) ) . get time ( ) expir . long valu ( ) 1000 ) ; } req . set attribut ( global . ssi flag attr , true ) ; process ssi ( req , re , resourc ) ; }	public adapt from file upload base . get file name ( ) string get filenam ( ) { string file name = null ; string cd = get header ( content disposit ) ; ( cd = null ) { string cdl = cd . lower case ( ) ; ( cdl . start ( form data ) cdl . start ( attach ) ) { paramet parser param parser = new paramet parser ( ) ; param parser . set lower case name ( true ) ; paramet parser can handl null input map string , string param = param parser . pars ( cd , ; ) ; ( param . contain kei ( filenam ) ) { file name = param . get ( filenam ) ; ( file name = null ) { file name = file name . trim ( ) ; } els { even valu , paramet present , so we return empti file name rather than file name . file name = ; } } } } return file name ; }	public iter string get header ( string name ) { string name lower = name . lower case ( ) ; list string header valu list = header name valu list map . get ( name lower ) ; ( null = = header valu list ) { return collect . string empti list ( ) . iter ( ) ; } return header valu list . iter ( ) ; }	public string get variabl valu ( string variabl name , string encod ) { string lower case variabl name = variabl name . lower case ( ) ; string variabl valu = null ; ( name reserv ( lower case variabl name ) ) { try get extern first , fail , try get built valu variabl valu = ssi extern resolv . get variabl valu ( variabl name ) ; ( variabl valu = = null ) { variabl name = variabl name . upper case ( ) ; variabl valu = ssi extern resolv . get variabl valu ( class name . variabl name ) ; } ( variabl valu = null ) { variabl valu = encod ( variabl valu , encod ) ; } } return variabl valu ; }	overrid public int do end tag ( ) throw jsp except { ( ( jsp file . index ( . . ) = 0 ) ( jsp file . upper case ( ) . index ( web inf ) = 0 ) ( jsp file . upper case ( ) . index ( meta inf ) = 0 ) ) throw new jsp tag except ( invalid jsp file jsp file ) ; input stream = page context . get servlet context ( ) . get resourc stream ( jsp file ) ; ( = = null ) throw new jsp tag except ( unabl find jsp file : jsp file ) ; jsp writer out = page context . get out ( ) ; try { out . println ( bodi ) ; out . println ( pre ) ; ( int ch = . read ( ) ; ch = 1 ; ch = . read ( ) ) ( ch = = ) out . print ( lt ; ) ; els out . print ( ( char ) ch ) ; out . println ( pre ) ; out . println ( bodi ) ; } catch ( ioexcept ex ) { throw new jsp tag except ( ioexcept : ex . string ( ) ) ; } return super . do end tag ( ) ; }	public int index ignor case ( string s , int start ) { string ( ) ; string upper = str valu . upper case ( ) ; string s u = s . upper case ( ) ; return upper . index ( s u , start ) ; }	protect string pars param valu ( string builder cmd , int start , int count ) { int val index = 0 ; boolean insid = fals ; string val = new string count ; string builder sb = new string builder ( ) ; char end quot = 0 ; ( int b idx = start ; b idx cmd . length ( ) ; b idx ) { ( insid ) { while ( b idx cmd . length ( ) quot ( cmd . char ( b idx ) ) ) b idx ; ( b idx = cmd . length ( ) ) break ; insid = insid ; end quot = cmd . char ( b idx ) ; } els { boolean escap = fals ; ( ; b idx cmd . length ( ) ; b idx ) { char c = cmd . char ( b idx ) ; check escap ( c = = escap ) { escap = true ; continu ; } we reach other stop ( c = = end quot escap ) break ; we need leav escap string ( c = = escap ) sb . append ( ) ; escap = fals ; sb . append ( c ) ; } signal error ( b idx = = cmd . length ( ) ) return null ; val val index = sb . string ( ) ; clear buffer sb . delet ( 0 , sb . length ( ) ) ; insid = insid ; } } return val ; }	public static class loader creat class loader ( file unpack , file pack , class loader parent ) throw except { ( log . debug enabl ( ) ) log . debug ( creat new class loader ) ; construct class path thi class loader set url set = new link hash set url ( ) ; add unpack directori ( unpack = null ) { ( int i = 0 ; i unpack . length ; i ) { file file = unpack i ; ( file . exist ( ) file . can read ( ) ) continu ; file = new file ( file . get canon path ( ) file . separ ) ; url url = file . uri ( ) . url ( ) ; ( log . debug enabl ( ) ) log . debug ( includ directori url ) ; set . add ( url ) ; } } add pack directori jar file ( pack = null ) { ( int i = 0 ; i pack . length ; i ) { file directori = pack i ; ( directori . directori ( ) directori . exist ( ) directori . can read ( ) ) continu ; string filenam = directori . list ( ) ; ( int j = 0 ; j filenam . length ; j ) { string filenam = filenam j . lower case ( ) ; ( filenam . end ( . jar ) ) continu ; file file = new file ( directori , filenam j ) ; ( log . debug enabl ( ) ) log . debug ( includ jar file file . get absolut path ( ) ) ; url url = file . uri ( ) . url ( ) ; set . add ( url ) ; } } } construct class loader itself url arrai = set . arrai ( new url set . size ( ) ) ; standard class loader class loader = null ; ( parent = = null ) class loader = new standard class loader ( arrai ) ; els class loader = new standard class loader ( arrai , parent ) ; return ( class loader ) ; }	public static creat return new class loader , base configur default specifi directori path : param locat arrai string contain class directori , jar file , jar directori url should ad repositori class loader . type given member param type . param type arrai type member param locat . possibl valu ar dir ( class directori ) , jar ( singl jar file ) , glob ( directori jar file ) url ( url ) . param parent parent class loader new class loader , code null code system class loader . except except error occur construct class loader class loader creat class loader ( string locat , integ type , class loader parent ) throw except { ( log . debug enabl ( ) ) log . debug ( creat new class loader ) ; construct class path thi class loader set url set = new link hash set url ( ) ; ( locat = null type = null locat . length = = type . length ) { ( int i = 0 ; i locat . length ; i ) { string locat = locat i ; ( type i = = url ) { url url = new url ( locat ) ; ( log . debug enabl ( ) ) log . debug ( includ url url ) ; set . add ( url ) ; } els ( type i = = dir ) { file directori = new file ( locat ) ; directori = new file ( directori . get canon path ( ) ) ; ( directori . exist ( ) directori . directori ( ) directori . can read ( ) ) continu ; url url = directori . uri ( ) . url ( ) ; ( log . debug enabl ( ) ) log . debug ( includ directori url ) ; set . add ( url ) ; } els ( type i = = jar ) { file file = new file ( locat ) ; file = new file ( file . get canon path ( ) ) ; ( file . exist ( ) file . can read ( ) ) continu ; url url = file . uri ( ) . url ( ) ; ( log . debug enabl ( ) ) log . debug ( includ jar file url ) ; set . add ( url ) ; } els ( type i = = glob ) { file directori = new file ( locat ) ; ( directori . exist ( ) directori . directori ( ) directori . can read ( ) ) continu ; ( log . debug enabl ( ) ) log . debug ( includ directori glob directori . get absolut path ( ) ) ; string filenam = directori . list ( ) ; ( int j = 0 ; j filenam . length ; j ) { string filenam = filenam j . lower case ( ) ; ( filenam . end ( . jar ) ) continu ; file file = new file ( directori , filenam j ) ; file = new file ( file . get canon path ( ) ) ; ( file . exist ( ) file . can read ( ) ) continu ; ( log . debug enabl ( ) ) log . debug ( includ glob jar file file . get absolut path ( ) ) ; url url = file . uri ( ) . url ( ) ; set . add ( url ) ; } } } } construct class loader itself url arrai = set . arrai ( new url set . size ( ) ) ; ( log . debug enabl ( ) ) ( int i = 0 ; i arrai . length ; i ) { log . debug ( locat i arrai i ) ; } standard class loader class loader = null ; ( parent = = null ) class loader = new standard class loader ( arrai ) ; els class loader = new standard class loader ( arrai , parent ) ; return ( class loader ) ; }	public static local guess local from session ( final http session session ) { ( null = = session ) { return null ; } try { local local = null ; first search known locat ( int i = 0 ; i local test attribut . length ; i ) { object obj = session . get attribut ( local test attribut i ) ; ( null = obj obj instanceof local ) { local = ( local ) obj ; break ; } obj = session . get attribut ( local test attribut i . lower case ( ) ) ; ( null = obj obj instanceof local ) { local = ( local ) obj ; break ; } obj = session . get attribut ( local test attribut i . upper case ( ) ) ; ( null = obj obj instanceof local ) { local = ( local ) obj ; break ; } } ( null = local ) { return local ; } tapestri 3 . 0 : engin store session under org . apach . tapestri . engin : config . get servlet name ( ) todo : tapestri 4 { final list object tapestri arrai = new arrai list object ( ) ; ( enumer string enumer = session . get attribut name ( ) ; enumer . ha more element ( ) ; ) { string name = enumer . next element ( ) ; ( name . index ( tapestri ) 1 name . index ( engin ) 1 null = session . get attribut ( name ) ) { non nl 1 non nl 2 tapestri arrai . add ( session . get attribut ( name ) ) ; } } ( tapestri arrai . size ( ) = = 1 ) { found potenti engin let s call get local ( ) . object probabl engin = tapestri arrai . get ( 0 ) ; ( null = probabl engin ) { try { non nl 1 method read method = probabl engin . get class ( ) . get method ( get local , ( class ) null ) ; ( null = read method ) { call properti getter return valu object possibl local = read method . invok ( probabl engin , ( object ) null ) ; ( null = possibl local possibl local instanceof local ) { local = ( local ) possibl local ; } } } catch ( except e ) { stai silent } } } } ( null = local ) { return local ; } last guess : iter over all attribut , find local onli , consid local { final list object local arrai = new arrai list object ( ) ; ( enumer string enumer = session . get attribut name ( ) ; enumer . ha more element ( ) ; ) { string name = enumer . next element ( ) ; object obj = session . get attribut ( name ) ; ( null = obj obj instanceof local ) { local arrai . add ( obj ) ; } } ( local arrai . size ( ) = = 1 ) { local = ( local ) local arrai . get ( 0 ) ; } } return local ; } catch ( illeg state except ) { ignor : invalid session return null ; } }	public static try get user from session , possibl . param session return object object guess user from session ( final session session ) { ( null = = session ) { return null ; } ( session . get princip ( ) = null ) { return session . get princip ( ) . get name ( ) ; } http session http session = session . get session ( ) ; try { object user = null ; first search known locat ( int i = 0 ; i user test attribut . length ; i ) { object obj = http session . get attribut ( user test attribut i ) ; ( null = obj ) { user = obj ; break ; } obj = http session . get attribut ( user test attribut i . lower case ( ) ) ; ( null = obj ) { user = obj ; break ; } obj = http session . get attribut ( user test attribut i . upper case ( ) ) ; ( null = obj ) { user = obj ; break ; } } ( null = user ) { return user ; } last guess : iter over all attribut , find java . secur . princip javax . secur . auth . subject onli , consid user { final list object princip arrai = new arrai list object ( ) ; ( enumer string enumer = http session . get attribut name ( ) ; enumer . ha more element ( ) ; ) { string name = enumer . next element ( ) ; object obj = http session . get attribut ( name ) ; ( null = obj ( obj instanceof princip obj instanceof subject ) ) { princip arrai . add ( obj ) ; } } ( princip arrai . size ( ) = = 1 ) { user = princip arrai . get ( 0 ) ; } } ( null = user ) { return user ; } return user ; } catch ( illeg state except ) { ignor : invalid session return null ; } }	public static string cap ( string text ) { return text . upper case ( ) ; }	public static convert mime charset name , also known xml encod name , java encod name . param mime charset name case insensit mime charset name : code utf 8 , us ascii , iso 8859 1 , iso 8859 2 , iso 8859 3 , iso 8859 4 , iso 8859 5 , iso 8859 6 , iso 8859 7 , iso 8859 8 , iso 8859 9 , iso 2022 jp , shift ji , euc jp , gb2312 , big5 , euc kr , iso 2022 kr , koi8 r , ebcdic cp us , ebcdic cp ca , ebcdic cp nl , ebcdic cp dk , ebcdic cp , ebcdic cp fi , ebcdic cp se , ebcdic cp , ebcdic cp es , ebcdic cp gb , ebcdic cp fr , ebcdic cp ar1 , ebcdic cp he , ebcdic cp ch , ebcdic cp roec , ebcdic cp yu , ebcdic cp ebcdic cp ar2 code . return java encod name , var null var var mime charset name var unknown . see revers string convert ( string mime charset name ) { return s enchash . get ( mime charset name . upper case ( ) ) ; }	public static convert java encod name mime charset name . avail valu i encod i ar utf8 , 8859 1 , 8859 2 , 8859 3 , 8859 4 , 8859 5 , 8859 6 , 8859 7 , 8859 8 , 8859 9 , ji , sji , eucji , gb2312 , big5 , ksc5601 , iso2022kr , koi8 r , cp037 , cp277 , cp278 , cp280 , cp284 , cp285 , cp297 , cp420 , cp424 , cp500 , cp870 , cp871 cp918 . param encod case insensit java encod name : code utf8 , 8859 1 , 8859 2 , 8859 3 , 8859 4 , 8859 5 , 8859 6 , 8859 7 , 8859 8 , 8859 9 , ji , sji , eucji , gb2312 , big5 , ksc5601 , iso2022kr , koi8 r , cp037 , cp277 , cp278 , cp280 , cp284 , cp285 , cp297 , cp420 , cp424 , cp500 , cp870 , cp871 cp918 code . return mime charset name , var null var var encod var unknown . see convert string revers ( string encod ) { return s revhash . get ( encod . upper case ( ) ) ; }	public static final boolean multipart content ( request context ctx ) { string content type = ctx . get content type ( ) ; ( content type = = null ) { return fals ; } ( content type . lower case ( ) . start ( multipart ) ) { return true ; } return fals ; }	public static final boolean multipart content ( http servlet request request ) { ( post . equal ( request . get method ( ) . lower case ( ) ) ) { return fals ; } string content type = request . get content type ( ) ; ( content type = = null ) { return fals ; } ( content type . lower case ( ) . start ( multipart ) ) { return true ; } return fals ; }	public static synchron boolean valid applic ( dir context dir context , context context ) throw ioexcept { string app name = context . get path ( ) ; arrai list manifest resourc app manifest resourc = new arrai list manifest resourc ( ) ; therefor valid ( dir context = = null ) return fals ; find manifest web applic input stream input stream = null ; try { name enumer bind wne = dir context . list bind ( meta inf ) ; bind bind = wne . next element ( ) ; ( bind . get name ( ) . upper case ( ) . equal ( manifest . mf ) ) { resourc resourc = ( resourc ) dir context . lookup ( meta inf bind . get name ( ) ) ; input stream = resourc . stream content ( ) ; manifest manifest = new manifest ( input stream ) ; input stream . close ( ) ; input stream = null ; manifest resourc mre = new manifest resourc ( sm . get string ( extens valid . web applic manifest ) , manifest , manifest resourc . war ) ; app manifest resourc . add ( mre ) ; } } catch ( name except nex ) { applic doe contain manifest . mf file } catch ( element except nse ) { applic doe contain manifest . mf file } final { ( input stream = null ) { try { input stream . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } } } locat manifest all bundl jar name enumer bind ne = null ; try { ne = dir context . list bind ( web inf lib ) ; while ( ( ne = null ) ne . ha more element ( ) ) { bind bind = ne . next element ( ) ; ( bind . get name ( ) . lower case ( ) . end ( . jar ) ) { continu ; } object obj = dir context . lookup ( web inf lib bind . get name ( ) ) ; ( ( obj instanceof resourc ) ) { probabl directori name xxx . jar ignor continu ; } resourc resourc = ( resourc ) obj ; input stream = resourc . stream content ( ) ; manifest jmanifest = get manifest ( input stream ) ; ( jmanifest = null ) { manifest resourc mre = new manifest resourc ( bind . get name ( ) , jmanifest , manifest resourc . applic ) ; app manifest resourc . add ( mre ) ; } } } catch ( name except nex ) { jump out check thi applic becaus ha resourc } final { ( input stream = null ) { try { input stream . close ( ) ; } catch ( throwabl t ) { except util . handl throwabl ( t ) ; } } } return valid manifest resourc ( app name , app manifest resourc ) ; }	public add alia name should map thi same host . param alia alia ad void add alia ( string alia ) { alia = alia . lower case ( ) ; synchron ( alias lock ) { skip duplic alias ( int i = 0 ; i alias . length ; i ) { ( alias i . equal ( alia ) ) return ; } add thi alia list string new alias = new string alias . length 1 ; ( int i = 0 ; i alias . length ; i ) new alias i = alias i ; new alias alias . length = alia ; alias = new alias ; } inform interest listen fire contain event ( add alia event , alia ) ; }	overrid public void add date header ( string name , long valu ) { super . add date header ( name , valu ) ; string lname = name . lower case ( ) ; ( lname . equal ( last modifi ) ) { last modifi = valu ; } }	overrid public void add header ( string name , string valu ) { super . add header ( name , valu ) ; string lname = name . lower case ( ) ; ( lname . equal ( last modifi ) ) { try { synchron ( rfc1123 format ) { last modifi = rfc1123 format . pars ( valu ) . get time ( ) ; } } catch ( throwabl ignor ) { except util . handl throwabl ( ignor ) ; } } els ( lname . equal ( content type ) ) { content type = valu ; } }	public remov specifi alia name from alias thi host . param alia alia name remov void remov alia ( string alia ) { alia = alia . lower case ( ) ; synchron ( alias lock ) { make sure thi alia current present int n = 1 ; ( int i = 0 ; i alias . length ; i ) { ( alias i . equal ( alia ) ) { n = i ; break ; } } ( n 0 ) return ; remov specifi alia int j = 0 ; string result = new string alias . length 1 ; ( int i = 0 ; i alias . length ; i ) { ( i = n ) result j = alias i ; } alias = result ; } inform interest listen fire contain event ( remov alia event , alia ) ; }	overrid public void set date header ( string name , long valu ) { super . set date header ( name , valu ) ; string lname = name . lower case ( ) ; ( lname . equal ( last modifi ) ) { last modifi = valu ; } }	public set default host . param host new default host void set default host ( string host ) { string old default host = thi . default host ; ( host = = null ) { thi . default host = null ; } els { thi . default host = host . lower case ( ) ; } support . fire properti chang ( default host , old default host , thi . default host ) ; }	public thi method us set current state filter map repres state when filter should appli . void set dispatch ( string dispatch string ) { string dispatch = dispatch string . upper case ( ) ; ( dispatch . equal ( dispatch type . forward . name ( ) ) ) { appli forward global dispatch map . dispatch map = forward ; } els ( dispatch . equal ( dispatch type . includ . name ( ) ) ) { appli includ global dispatch map . dispatch map = includ ; } els ( dispatch . equal ( dispatch type . request . name ( ) ) ) { appli request global dispatch map . dispatch map = request ; } els ( dispatch . equal ( dispatch type . error . name ( ) ) ) { appli error global dispatch map . dispatch map = error ; } els ( dispatch . equal ( dispatch type . async . name ( ) ) ) { appli error global dispatch map . dispatch map = async ; } }	overrid public void set header ( string name , string valu ) { super . set header ( name , valu ) ; string lname = name . lower case ( ) ; ( lname . equal ( last modifi ) ) { try { synchron ( rfc1123 format ) { last modifi = rfc1123 format . pars ( valu ) . get time ( ) ; } } catch ( throwabl ignor ) { except util . handl throwabl ( ignor ) ; } } }	public set file item header . param p header item header object void set header ( file item header p header ) { header = p header ; }	public void set impact ( string impact ) { ( impact = = null ) thi . impact = null ; els thi . impact = impact . upper case ( ) ; }	public extract map name valu pair from given arrai charact . name ar expect uniqu . param char arrai charact contain sequenc name valu pair param offset initi offset . param length length . param separ name valu pair separ return map name valu pair map string , string pars ( final char input char , int offset , int length , char separ ) { ( input char = = null ) { return new hash map string , string ( ) ; } hash map string , string param = new hash map string , string ( ) ; thi . char = input char ; thi . po = offset ; thi . len = length ; string param name = null ; string param valu = null ; while ( ha char ( ) ) { param name = pars token ( new char { = , separ } ) ; param valu = null ; ( ha char ( ) ( char po = = = ) ) { skip = po ; param valu = pars quot token ( new char { separ } ) ; } ( ha char ( ) ( char po = = separ ) ) { skip separ po ; } ( ( param name = null ) ( param name . length ( ) 0 ) ) { ( thi . lower case name ) { param name = param name . lower case ( ) ; } param . put ( param name , param valu ) ; } } return param ; }	set canon , fulli qualifi , name virtual host thi contain repres . param name virtual host name except illeg argument except name null overrid public void set name ( string name ) { ( name = = null ) throw new illeg argument except ( sm . get string ( standard host . null name ) ) ; intern all name ar lower case name = name . lower case ( ) ; string old name = thi . name ; thi . name = name ; support . fire properti chang ( name , old name , thi . name ) ; }	protect trust manag get trust manag ( string keystor type , string keystor provid , string algorithm ) throw except { string crlf = ( string ) attribut . get ( abstract endpoint . ssl attr crl file ) ; trust manag tm = null ; kei store trust store = get trust store ( keystor type , keystor provid ) ; ( trust store = null ) { ( crlf = = null ) { trust manag factori tmf = trust manag factori . get instanc ( algorithm ) ; tmf . init ( trust store ) ; tm = tmf . get trust manag ( ) ; } els { trust manag factori tmf = trust manag factori . get instanc ( algorithm ) ; cert path paramet param = get paramet ( algorithm , crlf , trust store ) ; manag factori paramet mfp = new cert path trust manag paramet ( param ) ; tmf . init ( mfp ) ; tm = tmf . get trust manag ( ) ; } } return tm ; }
protect after read request header , we have setup request filter . void prepar request ( ) { http11 = true ; http09 = fals ; content delimit = fals ; expect = fals ; sendfil data = null ; ( ssl ) { request . scheme ( ) . set string ( http ) ; } messag byte protocol mb = request . protocol ( ) ; ( protocol mb . equal ( constant . http 11 ) ) { http11 = true ; protocol mb . set string ( constant . http 11 ) ; } els ( protocol mb . equal ( constant . http 10 ) ) { http11 = fals ; keep aliv = fals ; protocol mb . set string ( constant . http 10 ) ; } els ( protocol mb . equal ( ) ) { http 0 . 9 http09 = true ; http11 = fals ; keep aliv = fals ; } els { unsupport protocol http11 = fals ; error = true ; send 505 ; unsupport http version respons . set statu ( 505 ) ; } messag byte method mb = request . method ( ) ; ( method mb . equal ( constant . get ) ) { method mb . set string ( constant . get ) ; } els ( method mb . equal ( constant . post ) ) { method mb . set string ( constant . post ) ; } mime header header = request . get mime header ( ) ; check connect header messag byte connect valu mb = header . get valu ( connect ) ; ( connect valu mb = null ) { byte chunk connect valu bc = connect valu mb . get byte chunk ( ) ; ( find byte ( connect valu bc , constant . close byte ) = 1 ) { keep aliv = fals ; } els ( find byte ( connect valu bc , constant . keepal byte ) = 1 ) { keep aliv = true ; } } messag byte expect mb = null ; ( http11 ) expect mb = header . get valu ( expect ) ; ( ( expect mb = null ) ( expect mb . index ignor case ( 100 continu , 0 ) = 1 ) ) { input buffer . set swallow input ( fals ) ; expect = true ; } check user agent header ( ( restrict user agent = null ) ( ( http11 ) ( keep aliv ) ) ) { messag byte user agent valu mb = header . get valu ( user agent ) ; keep aliv flag accordingli ( user agent valu mb = null ) { string user agent valu = user agent valu mb . string ( ) ; ( int i = 0 ; i restrict user agent . length ; i ) { ( restrict user agent i . matcher ( user agent valu ) . match ( ) ) { http11 = fals ; keep aliv = fals ; break ; } } } } check full uri ( includ protocol : host : port ) byte chunk uri bc = request . request uri ( ) . get byte chunk ( ) ; ( uri bc . start ignor case ( http , 0 ) ) { int po = uri bc . index ( : , 0 , 3 , 4 ) ; int uri bcstart = uri bc . get start ( ) ; int slash po = 1 ; ( po = 1 ) { byte uri b = uri bc . get byte ( ) ; slash po = uri bc . index ( , po 3 ) ; ( slash po = = 1 ) { slash po = uri bc . get length ( ) ; set uri request . request uri ( ) . set byte ( uri b , uri bcstart po 1 , 1 ) ; } els { request . request uri ( ) . set byte ( uri b , uri bcstart slash po , uri bc . get length ( ) slash po ) ; } messag byte host mb = header . set valu ( host ) ; host mb . set byte ( uri b , uri bcstart po 3 , slash po po 3 ) ; } } input filter setup input filter input filter = input buffer . get filter ( ) ; pars transfer encod header messag byte transfer encod valu mb = null ; ( http11 ) transfer encod valu mb = header . get valu ( transfer encod ) ; ( transfer encod valu mb = null ) { string transfer encod valu = transfer encod valu mb . string ( ) ; pars comma separ list . ident code ar ignor int start po = 0 ; int comma po = transfer encod valu . index ( , ) ; string encod name = null ; while ( comma po = 1 ) { encod name = transfer encod valu . substr ( start po , comma po ) . lower case ( ) . trim ( ) ; ( add input filter ( input filter , encod name ) ) { unsupport transfer encod error = true ; 501 unimpl respons . set statu ( 501 ) ; } start po = comma po 1 ; comma po = transfer encod valu . index ( , , start po ) ; } encod name = transfer encod valu . substr ( start po ) . lower case ( ) . trim ( ) ; ( add input filter ( input filter , encod name ) ) { unsupport transfer encod error = true ; 501 unimpl respons . set statu ( 501 ) ; } } pars content length header long content length = request . get content length long ( ) ; ( content length = 0 content delimit ) { input buffer . add activ filter ( input filter constant . ident filter ) ; content delimit = true ; } messag byte valu mb = header . get valu ( host ) ; check host header ( http11 ( valu mb = = null ) ) { error = true ; 400 bad request respons . set statu ( 400 ) ; } pars host ( valu mb ) ; ( content delimit ) { s content length ( broken http 1 . 0 http 1 . 1 ) , assum client broken didn t send bodi input buffer . add activ filter ( input filter constant . void filter ) ; content delimit = true ; } advertis sendfil support through request attribut ( endpoint . get us sendfil ( ) ) { request . set attribut ( org . apach . tomcat . sendfil . support , boolean . true ) ; } advertis comet support through request attribut request . set attribut ( org . apach . tomcat . comet . support , boolean . true ) ; }	protect after read request header , we have setup request filter . void prepar request ( ) { http11 = true ; http09 = fals ; content delimit = fals ; expect = fals ; sendfil data = null ; ( ssl ) { request . scheme ( ) . set string ( http ) ; } messag byte protocol mb = request . protocol ( ) ; ( protocol mb . equal ( constant . http 11 ) ) { http11 = true ; protocol mb . set string ( constant . http 11 ) ; } els ( protocol mb . equal ( constant . http 10 ) ) { http11 = fals ; keep aliv = fals ; protocol mb . set string ( constant . http 10 ) ; } els ( protocol mb . equal ( ) ) { http 0 . 9 http09 = true ; http11 = fals ; keep aliv = fals ; } els { unsupport protocol http11 = fals ; error = true ; send 505 ; unsupport http version respons . set statu ( 505 ) ; } messag byte method mb = request . method ( ) ; ( method mb . equal ( constant . get ) ) { method mb . set string ( constant . get ) ; } els ( method mb . equal ( constant . post ) ) { method mb . set string ( constant . post ) ; } mime header header = request . get mime header ( ) ; check connect header messag byte connect valu mb = header . get valu ( connect ) ; ( connect valu mb = null ) { byte chunk connect valu bc = connect valu mb . get byte chunk ( ) ; ( find byte ( connect valu bc , constant . close byte ) = 1 ) { keep aliv = fals ; } els ( find byte ( connect valu bc , constant . keepal byte ) = 1 ) { keep aliv = true ; } } messag byte expect mb = null ; ( http11 ) expect mb = header . get valu ( expect ) ; ( ( expect mb = null ) ( expect mb . index ignor case ( 100 continu , 0 ) = 1 ) ) { input buffer . set swallow input ( fals ) ; expect = true ; } check user agent header ( ( restrict user agent = null ) ( ( http11 ) ( keep aliv ) ) ) { messag byte user agent valu mb = header . get valu ( user agent ) ; keep aliv flag accordingli ( user agent valu mb = null ) { string user agent valu = user agent valu mb . string ( ) ; ( int i = 0 ; i restrict user agent . length ; i ) { ( restrict user agent i . matcher ( user agent valu ) . match ( ) ) { http11 = fals ; keep aliv = fals ; break ; } } } } check full uri ( includ protocol : host : port ) byte chunk uri bc = request . request uri ( ) . get byte chunk ( ) ; ( uri bc . start ignor case ( http , 0 ) ) { int po = uri bc . index ( : , 0 , 3 , 4 ) ; int uri bcstart = uri bc . get start ( ) ; int slash po = 1 ; ( po = 1 ) { byte uri b = uri bc . get byte ( ) ; slash po = uri bc . index ( , po 3 ) ; ( slash po = = 1 ) { slash po = uri bc . get length ( ) ; set uri request . request uri ( ) . set byte ( uri b , uri bcstart po 1 , 1 ) ; } els { request . request uri ( ) . set byte ( uri b , uri bcstart slash po , uri bc . get length ( ) slash po ) ; } messag byte host mb = header . set valu ( host ) ; host mb . set byte ( uri b , uri bcstart po 3 , slash po po 3 ) ; } } input filter setup input filter input filter = input buffer . get filter ( ) ; pars transfer encod header messag byte transfer encod valu mb = null ; ( http11 ) transfer encod valu mb = header . get valu ( transfer encod ) ; ( transfer encod valu mb = null ) { string transfer encod valu = transfer encod valu mb . string ( ) ; pars comma separ list . ident code ar ignor int start po = 0 ; int comma po = transfer encod valu . index ( , ) ; string encod name = null ; while ( comma po = 1 ) { encod name = transfer encod valu . substr ( start po , comma po ) . lower case ( ) . trim ( ) ; ( add input filter ( input filter , encod name ) ) { unsupport transfer encod error = true ; 501 unimpl respons . set statu ( 501 ) ; } start po = comma po 1 ; comma po = transfer encod valu . index ( , , start po ) ; } encod name = transfer encod valu . substr ( start po ) . lower case ( ) . trim ( ) ; ( add input filter ( input filter , encod name ) ) { unsupport transfer encod error = true ; 501 unimpl respons . set statu ( 501 ) ; } } pars content length header long content length = request . get content length long ( ) ; ( content length = 0 content delimit ) { input buffer . add activ filter ( input filter constant . ident filter ) ; content delimit = true ; } messag byte valu mb = header . get valu ( host ) ; check host header ( http11 ( valu mb = = null ) ) { error = true ; 400 bad request respons . set statu ( 400 ) ; } pars host ( valu mb ) ; ( content delimit ) { s content length ( broken http 1 . 0 http 1 . 1 ) , assum client broken didn t send bodi input buffer . add activ filter ( input filter constant . void filter ) ; content delimit = true ; } advertis sendfil support through request attribut ( endpoint . get us sendfil ( ) ) request . set attribut ( org . apach . tomcat . sendfil . support , boolean . true ) ; advertis comet support through request attribut request . set attribut ( org . apach . tomcat . comet . support , boolean . true ) ; advertis comet timeout support request . set attribut ( org . apach . tomcat . comet . timeout . support , boolean . true ) ; }	protect after read request header , we have setup request filter . void prepar request ( ) { http11 = true ; http09 = fals ; content delimit = fals ; expect = fals ; ( ssl support = null ) { request . scheme ( ) . set string ( http ) ; } messag byte protocol mb = request . protocol ( ) ; ( protocol mb . equal ( constant . http 11 ) ) { http11 = true ; protocol mb . set string ( constant . http 11 ) ; } els ( protocol mb . equal ( constant . http 10 ) ) { http11 = fals ; keep aliv = fals ; protocol mb . set string ( constant . http 10 ) ; } els ( protocol mb . equal ( ) ) { http 0 . 9 http09 = true ; http11 = fals ; keep aliv = fals ; } els { unsupport protocol http11 = fals ; error = true ; send 505 ; unsupport http version ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . request . prepar ) unsupport http version protocol mb ) ; } respons . set statu ( 505 ) ; } messag byte method mb = request . method ( ) ; ( method mb . equal ( constant . get ) ) { method mb . set string ( constant . get ) ; } els ( method mb . equal ( constant . post ) ) { method mb . set string ( constant . post ) ; } mime header header = request . get mime header ( ) ; check connect header messag byte connect valu mb = header . get valu ( connect ) ; ( connect valu mb = null ) { byte chunk connect valu bc = connect valu mb . get byte chunk ( ) ; ( find byte ( connect valu bc , constant . close byte ) = 1 ) { keep aliv = fals ; } els ( find byte ( connect valu bc , constant . keepal byte ) = 1 ) { keep aliv = true ; } } messag byte expect mb = null ; ( http11 ) expect mb = header . get valu ( expect ) ; ( ( expect mb = null ) ( expect mb . index ignor case ( 100 continu , 0 ) = 1 ) ) { input buffer . set swallow input ( fals ) ; expect = true ; } check user agent header ( ( restrict user agent = null ) ( ( http11 ) ( keep aliv ) ) ) { messag byte user agent valu mb = header . get valu ( user agent ) ; keep aliv flag accordingli ( user agent valu mb = null ) { string user agent valu = user agent valu mb . string ( ) ; ( int i = 0 ; i restrict user agent . length ; i ) { ( restrict user agent i . matcher ( user agent valu ) . match ( ) ) { http11 = fals ; keep aliv = fals ; break ; } } } } check full uri ( includ protocol : host : port ) byte chunk uri bc = request . request uri ( ) . get byte chunk ( ) ; ( uri bc . start ignor case ( http , 0 ) ) { int po = uri bc . index ( : , 0 , 3 , 4 ) ; int uri bcstart = uri bc . get start ( ) ; int slash po = 1 ; ( po = 1 ) { byte uri b = uri bc . get byte ( ) ; slash po = uri bc . index ( , po 3 ) ; ( slash po = = 1 ) { slash po = uri bc . get length ( ) ; set uri request . request uri ( ) . set byte ( uri b , uri bcstart po 1 , 1 ) ; } els { request . request uri ( ) . set byte ( uri b , uri bcstart slash po , uri bc . get length ( ) slash po ) ; } messag byte host mb = header . set valu ( host ) ; host mb . set byte ( uri b , uri bcstart po 3 , slash po po 3 ) ; } } input filter setup input filter input filter = input buffer . get filter ( ) ; pars transfer encod header messag byte transfer encod valu mb = null ; ( http11 ) transfer encod valu mb = header . get valu ( transfer encod ) ; ( transfer encod valu mb = null ) { string transfer encod valu = transfer encod valu mb . string ( ) ; pars comma separ list . ident code ar ignor int start po = 0 ; int comma po = transfer encod valu . index ( , ) ; string encod name = null ; while ( comma po = 1 ) { encod name = transfer encod valu . substr ( start po , comma po ) . lower case ( ) . trim ( ) ; ( add input filter ( input filter , encod name ) ) { unsupport transfer encod error = true ; 501 unimpl respons . set statu ( 501 ) ; } start po = comma po 1 ; comma po = transfer encod valu . index ( , , start po ) ; } encod name = transfer encod valu . substr ( start po ) . lower case ( ) . trim ( ) ; ( add input filter ( input filter , encod name ) ) { unsupport transfer encod error = true ; 501 unimpl ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . request . prepar ) unsupport transfer encod encod name ) ; } respons . set statu ( 501 ) ; } } pars content length header long content length = request . get content length long ( ) ; ( content length = 0 content delimit ) { input buffer . add activ filter ( input filter constant . ident filter ) ; content delimit = true ; } messag byte valu mb = header . get valu ( host ) ; check host header ( http11 ( valu mb = = null ) ) { error = true ; 400 bad request ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . request . prepar ) host header miss ) ; } respons . set statu ( 400 ) ; } pars host ( valu mb ) ; ( content delimit ) { s content length ( broken http 1 . 0 http 1 . 1 ) , assum client broken didn t send bodi input buffer . add activ filter ( input filter constant . void filter ) ; content delimit = true ; } }
privat compar page encod specifi variou place , throw except case page encod mismatch . param page dir enc valu page encod attribut page direct param page dir page direct node throw jasper except case page encod mismatch string compar page encod ( string page dir enc , node . page direct page dir ) throw jasper except { node . root root = page dir . get root ( ) ; string config enc = root . get jsp config page encod ( ) ; string page dir enc = page dir enc . upper case ( ) ; compar page encod attribut page direct encod specifi jsp config element whose url pattern match thi page . treat utf 16 , utf 16be , utf 16le ident . ( config enc = null ) { config enc = config enc . upper case ( ) ; ( page dir enc . equal ( config enc ) ( page dir enc . start ( utf 16 ) config enc . start ( utf 16 ) ) ) { err . jsp error ( page dir , jsp . error . config pagedir encod mismatch , config enc , page dir enc ) ; } els { return config enc ; } } compar page encod attribut page direct encod specifi xml prolog ( onli xml syntax , onli jsp document contain xml prolog encod declar ) . treat utf 16 , utf 16be , utf 16le ident . ( ( root . xml syntax ( ) root . encod specifi prolog ( ) ) root . bom present ( ) ) { string page enc = root . get page encod ( ) . upper case ( ) ; ( page dir enc . equal ( page enc ) ( page dir enc . start ( utf 16 ) page enc . start ( utf 16 ) ) ) { err . jsp error ( page dir , jsp . error . prolog pagedir encod mismatch , page enc , page dir enc ) ; } els { return page enc ; } } return page dir enc ; }	privat compar page encod specifi variou place , throw except case page encod mismatch . param page dir enc valu page encod attribut page direct param page dir page direct node throw jasper except case page encod mismatch void compar tag encod ( string page dir enc , node . tag direct page dir ) throw jasper except { node . root root = page dir . get root ( ) ; string page dir enc = page dir enc . upper case ( ) ; compar page encod attribut page direct encod specifi xml prolog ( onli xml syntax , onli jsp document contain xml prolog encod declar ) . treat utf 16 , utf 16be , utf 16le ident . ( ( root . xml syntax ( ) root . encod specifi prolog ( ) ) root . bom present ( ) ) { string page enc = root . get page encod ( ) . upper case ( ) ; ( page dir enc . equal ( page enc ) ( page dir enc . start ( utf 16 ) page enc . start ( utf 16 ) ) ) { err . jsp error ( page dir , jsp . error . prolog pagedir encod mismatch , page enc , page dir enc ) ; } } }	public static get valu associ content type attribut . syntax defin rfc 2045 , section 5 . 1 . taken from org . apach . taglib . standard . tag . common . core . util string get content type attribut ( string input , string name ) { int begin ; int end ; int index = input . upper case ( ) . index ( name . upper case ( ) ) ; ( index = = 1 ) return null ; posit after attribut name index = index name . length ( ) ; posit = index = input . index ( = , index ) ; ( index = = 1 ) return null ; posit after = index = 1 ; input = input . substr ( index ) . trim ( ) ; ( input . char ( 0 ) = = ) { attribut valu quot string begin = 1 ; end = input . index ( , begin ) ; ( end = = 1 ) return null ; } els { begin = 0 ; end = input . index ( ; ) ; ( end = = 1 ) end = input . index ( ) ; ( end = = 1 ) end = input . length ( ) ; } return input . substr ( begin , end ) . trim ( ) ; }
protect class packag web applic , class each super class need check match { link handl type } . param java class void check handl type ( java class java class ) { skip thi we can ( type initi map . size ( ) = = 0 ) return ; choic load class string class name = java class . get class name ( ) ; class clazz = null ; try { clazz = context . get loader ( ) . get class loader ( ) . load class ( class name ) ; } catch ( class def found error e ) { log . debug ( sm . get string ( context config . invalid sci handl type , class name ) , e ) ; return ; } catch ( class found except e ) { log . warn ( sm . get string ( context config . invalid sci handl type , class name ) , e ) ; return ; } ( map . entri class , set servlet contain initi >> entri : type initi map . entri set ( ) ) { ( entri . get kei ( ) . assign from ( clazz ) ) { ( servlet contain initi sci : entri . get valu ( ) ) { initi class map . get ( sci ) . add ( clazz ) ; } } } }	protect void process annot stream ( input stream , web xml fragment ) throw class format except , ioexcept { class parser parser = new class parser ( , null ) ; java class clazz = parser . pars ( ) ; check handl type ( clazz ) ; string class name = clazz . get class name ( ) ; annot entri annot entri = clazz . get annot entri ( ) ; ( annot entri ae : annot entri ) { string type = ae . get annot type ( ) ; ( ljavax servlet annot web servlet ; . equal ( type ) ) { process annot web servlet ( class name , ae , fragment ) ; } els ( ljavax servlet annot web filter ; . equal ( type ) ) { process annot web filter ( class name , ae , fragment ) ; } els ( ljavax servlet annot web listen ; . equal ( type ) ) { fragment . add listen ( class name ) ; } els { unknown annot ignor } } }
protect class packag web applic , class each super class need check match { link handl type } . param java class void check handl type ( java class java class ) { skip thi we can ( type initi map . size ( ) = = 0 ) return ; choic load class string class name = java class . get class name ( ) ; class clazz = null ; try { clazz = class . name ( class name , true , context . get loader ( ) . get class loader ( ) ) ; } catch ( class found except e ) { log . warn ( sm . get string ( context config . invalid sci handl type , class name ) , e ) ; } ( map . entri class , set servlet contain initi >> entri : type initi map . entri set ( ) ) { ( entri . get kei ( ) . assign from ( clazz ) ) { ( servlet contain initi sci : entri . get valu ( ) ) { initi class map . get ( sci ) . add ( clazz ) ; } } } }

public static pool configur pars pool properti ( properti properti ) throw ioexcept { pool configur pool properti = new pool properti ( ) ; string valu = null ; valu = properti . get properti ( prop defaultautocommit ) ; ( valu = null ) { pool properti . set default auto commit ( boolean . valu ( valu ) ) ; } valu = properti . get properti ( prop defaultreadonli ) ; ( valu = null ) { pool properti . set default read onli ( boolean . valu ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { int level = unknown transactionisol ; ( none . equal ignor case ( valu ) ) { level = connect . transact none ; } els ( read commit . equal ignor case ( valu ) ) { level = connect . transact read commit ; } els ( read uncommit . equal ignor case ( valu ) ) { level = connect . transact read uncommit ; } els ( repeat read . equal ignor case ( valu ) ) { level = connect . transact repeat read ; } els ( serializ . equal ignor case ( valu ) ) { level = connect . transact serializ ; } els { try { level = integ . pars int ( valu ) ; } catch ( number format except e ) { system . err . println ( could pars default transact isol : valu ) ; system . err . println ( warn : default transact isol set ) ; system . err . println ( us default valu databas driver ) ; level = unknown transactionisol ; } } pool properti . set default transact isol ( level ) ; } valu = properti . get properti ( prop defaultcatalog ) ; ( valu = null ) { pool properti . set default catalog ( valu ) ; } valu = properti . get properti ( prop driverclassnam ) ; ( valu = null ) { pool properti . set driver class name ( valu ) ; } valu = properti . get properti ( prop maxact ) ; ( valu = null ) { pool properti . set max activ ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop maxidl ) ; ( valu = null ) { pool properti . set max idl ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop minidl ) ; ( valu = null ) { pool properti . set min idl ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop initials ) ; ( valu = null ) { pool properti . set initi size ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop maxwait ) ; ( valu = null ) { pool properti . set max wait ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop testonborrow ) ; ( valu = null ) { pool properti . set test borrow ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop testonreturn ) ; ( valu = null ) { pool properti . set test return ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop testonconnect ) ; ( valu = null ) { pool properti . set test connect ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set time between evict run milli ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set num test per evict run ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set min evict idl time milli ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop testwhileidl ) ; ( valu = null ) { pool properti . set test while idl ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop password ) ; ( valu = null ) { pool properti . set password ( valu ) ; } valu = properti . get properti ( prop url ) ; ( valu = null ) { pool properti . set url ( valu ) ; } valu = properti . get properti ( prop usernam ) ; ( valu = null ) { pool properti . set usernam ( valu ) ; } valu = properti . get properti ( prop validationqueri ) ; ( valu = null ) { pool properti . set valid queri ( valu ) ; } valu = properti . get properti ( prop validationinterv ) ; ( valu = null ) { pool properti . set valid interv ( long . pars long ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set access underli connect allow ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop removeabandon ) ; ( valu = null ) { pool properti . set remov abandon ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set remov abandon timeout ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop logabandon ) ; ( valu = null ) { pool properti . set log abandon ( boolean . valu ( valu ) . boolean valu ( ) ) ; } valu = properti . get properti ( prop poolpreparedstat ) ; ( valu = null ) { log . warn ( prop poolpreparedstat valid set , have effect . ) ; } valu = properti . get properti ( prop maxopenpreparedstat ) ; ( valu = null ) { log . warn ( prop maxopenpreparedstat valid set , have effect . ) ; } valu = properti . get properti ( prop connectionproperti ) ; ( valu = null ) { properti p = get properti ( valu ) ; pool properti . set db properti ( p ) ; } els { pool properti . set db properti ( new properti ( ) ) ; } ( pool properti . get usernam ( ) = null ) { pool properti . get db properti ( ) . set properti ( user , pool properti . get usernam ( ) ) ; } ( pool properti . get password ( ) = null ) { pool properti . get db properti ( ) . set properti ( password , pool properti . get password ( ) ) ; } valu = properti . get properti ( prop initsql ) ; ( valu = null ) { pool properti . set init sql ( valu ) ; } valu = properti . get properti ( prop interceptor ) ; ( valu = null ) { pool properti . set jdbc interceptor ( valu ) ; } valu = properti . get properti ( prop jmx enabl ) ; ( valu = null ) { pool properti . set jmx enabl ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop fair queue ) ; ( valu = null ) { pool properti . set fair queue ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop us equal ) ; ( valu = null ) { pool properti . set us equal ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( object name ) ; ( valu = null ) { pool properti . set name ( object name . quot ( valu ) ) ; } valu = properti . get properti ( prop ) ; ( valu = null ) { pool properti . set abandon when percentag full ( integ . pars int ( valu ) ) ; } valu = properti . get properti ( prop maxag ) ; ( valu = null ) { pool properti . set max ag ( long . pars long ( valu ) ) ; } valu = properti . get properti ( prop us con lock ) ; ( valu = null ) { pool properti . set us lock ( boolean . pars boolean ( valu ) ) ; } valu = properti . get properti ( prop datasourc ) ; ( valu = null ) { thi should never happen throw new illeg argument except ( can t set data sourc properti string , thi must javax . sql . data sourc object . ) ; } valu = properti . get properti ( prop datasourc jndi ) ; ( valu = null ) { pool properti . set data sourc jndi ( valu ) ; } return pool properti ; }
public static debug method , displai classpath void displai class path ( string msg , url cp ) { ( log . debug enabl ( ) ) { log . debug ( msg ) ; ( int i = 0 ; i cp . length ; i ) { log . debug ( cp i . get file ( ) ) ; } } }
overrid public collect string get url pattern map ( ) { collect string result = new hash set string ( ) ; filter map filter map = context . find filter map ( ) ; ( filter map filter map : filter map ) { ( filter map . get filter name ( ) . equal ( filter def . get filter name ( ) ) ) { ( string url pattern : filter map . get urlpattern ( ) ) { result . add ( url pattern ) ; } } } return result ; }
public add filter map thi context befor map defin deploy descriptor after ani other map ad via thi method . param filter map filter map ad except illeg argument except specifi filter name doe match exist filter definit , filter map malform void add filter map befor ( filter map filter map ) { valid filter map ( filter map ) ; add thi filter map our regist set synchron ( filter map lock ) { filter map result = new filter map filter map . length 1 ; system . arraycopi ( filter map , 0 , result , 0 , filter map insert point ) ; result filter map insert point = filter map ; system . arraycopi ( filter map , filter map insert point , result , filter map . length filter map insert point 1 , filter map . length filter map insert point ) ; filter map insert point ; filter map = result ; } fire contain event ( add filter map , filter map ) ; }
public static main entri parser param pc pars control , us get other object compil pars includ page param reader read page param parent parent node thi page , null top level page return list node repres pars page node . node pars ( parser control pc , jsp reader reader , node parent , boolean tag file , boolean direct onli , url jar file url , string page enc , string jsp config page enc , boolean default page encod , boolean bom present ) throw jasper except { parser parser = new parser ( pc , reader , tag file , direct onli , jar file url ) ; node . root root = new node . root ( reader . mark ( ) , parent , fals ) ; root . set page encod ( page enc ) ; root . set jsp config page encod ( jsp config page enc ) ; root . set default page encod ( default page encod ) ; root . set bom present ( bom present ) ; top level page , add includ prelud includ coda page info page info = pc . get compil ( ) . get page info ( ) ; ( parent = = null tag file ) { parser . add includ ( root , page info . get includ prelud ( ) ) ; } ( direct onli ) { parser . pars file direct ( root ) ; } els { while ( reader . ha more input ( ) ) { parser . pars element ( root ) ; } } ( parent = = null tag file ) { parser . add includ ( root , page info . get includ coda ( ) ) ; } node . node page = new node . node ( root ) ; return page ; }	privat pars tag file direct given tag file turn them tag info . param elem tag file element tld param uri locat tld , case tag file specifi rel param jar file jar file , case tag file packag jar return tag info correspond tag file direct tag file info creat tag file info ( tree node elem , url jar file url ) throw jasper except { string name = null ; string path = null ; iter tree node list = elem . find children ( ) ; while ( list . ha next ( ) ) { tree node child = list . next ( ) ; string tname = child . get name ( ) ; ( name . equal ( tname ) ) { name = child . get bodi ( ) ; } els ( path . equal ( tname ) ) { path = child . get bodi ( ) ; } els ( exampl . equal ( tname ) ) { ignor exampl element : bugzilla 33538 } els ( tag extens . equal ( tname ) ) { ignor tag extens element : bugzilla 33538 } els ( icon . equal ( tname ) displai name . equal ( tname ) descript . equal ( tname ) ) { ignor element : bugzilla 38015 } els { ( log . warn enabl ( ) ) { log . warn ( local . get messag ( jsp . warn . unknown . element . . tagfil , tname ) ) ; } } } ( path . start ( meta inf tag ) ) { tag file packag jar see http : issu . apach . org bugzilla show bug . cgi id = 46471 thi need remov onc all broken code depend ha been remov ctxt . set tag file jar url ( path , jar file url ) ; } els ( path . start ( web inf tag ) ) { err . jsp error ( jsp . error . tagfil . illeg path , path ) ; } tag info tag info = tag file processor . pars tag file direct ( parser control , name , path , jar file url , thi ) ; return new tag file info ( name , path , tag info ) ; }	privat tag info creat tag info ( tree node elem , string jsp version ) throw jasper except { string tag name = null ; string tag class name = null ; string tei class name = null ; default bodi content jsp 1 . 2 tag handler ( bodi content ha becom mandatori jsp 2 . 0 , becaus default would invalid simpl tag handler ) string bodycont = jsp ; string info = null ; string displai name = null ; string small icon = null ; string larg icon = null ; boolean dynam attribut = fals ; vector tag attribut info attribut vector = new vector tag attribut info ( ) ; vector tag variabl info variabl vector = new vector tag variabl info ( ) ; iter tree node list = elem . find children ( ) ; while ( list . ha next ( ) ) { tree node element = list . next ( ) ; string tname = element . get name ( ) ; ( name . equal ( tname ) ) { tag name = element . get bodi ( ) ; } els ( tagclass . equal ( tname ) tag class . equal ( tname ) ) { tag class name = element . get bodi ( ) ; } els ( teiclass . equal ( tname ) tei class . equal ( tname ) ) { tei class name = element . get bodi ( ) ; } els ( bodycont . equal ( tname ) bodi content . equal ( tname ) ) { bodycont = element . get bodi ( ) ; } els ( displai name . equal ( tname ) ) { displai name = element . get bodi ( ) ; } els ( small icon . equal ( tname ) ) { small icon = element . get bodi ( ) ; } els ( larg icon . equal ( tname ) ) { larg icon = element . get bodi ( ) ; } els ( icon . equal ( tname ) ) { tree node icon = element . find child ( small icon ) ; ( icon = null ) { small icon = icon . get bodi ( ) ; } icon = element . find child ( larg icon ) ; ( icon = null ) { larg icon = icon . get bodi ( ) ; } } els ( info . equal ( tname ) descript . equal ( tname ) ) { info = element . get bodi ( ) ; } els ( variabl . equal ( tname ) ) { variabl vector . add element ( creat variabl ( element ) ) ; } els ( attribut . equal ( tname ) ) { attribut vector . add element ( creat attribut ( element , jsp version ) ) ; } els ( dynam attribut . equal ( tname ) ) { dynam attribut = jsp util . boolean valu ( element . get bodi ( ) ) ; } els ( exampl . equal ( tname ) ) { ignor element } els ( tag extens . equal ( tname ) ) { ignor } els { ( log . warn enabl ( ) ) { log . warn ( local . get messag ( jsp . warn . unknown . element . . tag , tname ) ) ; } } } tag extra info tei = null ; ( tei class name = null tei class name . equal ( ) ) { try { class tei class = ctxt . get class loader ( ) . load class ( tei class name ) ; tei = ( tag extra info ) tei class . new instanc ( ) ; } catch ( except e ) { err . jsp error ( jsp . error . teiclass . instanti , tei class name , e ) ; } } tag attribut info tag attribut info = new tag attribut info attribut vector . size ( ) ; attribut vector . copi ( tag attribut info ) ; tag variabl info tag variabl info = new tag variabl info variabl vector . size ( ) ; variabl vector . copi ( tag variabl info ) ; tag info taginfo = new tag info ( tag name , tag class name , bodycont , info , thi , tei , tag attribut info , displai name , small icon , larg icon , tag variabl info , dynam attribut ) ; return taginfo ; }	privat creat tag librari associ given uri namespac , return . param prefix prefix xmln attribut param uri uri namespac ( valu xmln attribut ) return tag librari associ given uri namespac tag librari info get taglib info ( string prefix , string uri ) throw jasper except { tag librari info result = null ; ( uri . start ( urn jsptagdir ) ) { uri ( form urn : jsptagdir : path ) refer tag file dir string tagdir = uri . substr ( urn jsptagdir . length ( ) ) ; result = new implicit tag librari info ( ctxt , parser control , page info , prefix , tagdir , err ) ; } els { uri refer tld file boolean plain uri = fals ; ( uri . start ( urn jsptld ) ) { uri form urn : jsptld : path uri = uri . substr ( urn jsptld . length ( ) ) ; } els { plain uri = true ; } string locat = ctxt . get tld locat ( uri ) ; ( locat = null plain uri ) { ( ctxt . get option ( ) . cach ( ) ) { result = ctxt . get option ( ) . get cach ( ) . get ( uri ) ; } ( result = = null ) { uri valu plain uri , translat error must gener uri found taglib map . instead , ani action namespac defin uri valu must treat uninterpret . result = new tag librari info impl ( ctxt , parser control , page info , prefix , uri , locat , err ) ; ( ctxt . get option ( ) . cach ( ) ) { ctxt . get option ( ) . get cach ( ) . put ( uri , result ) ; } } } } return result ; }	privat pars taglib direct follow syntax : direct : : = ( s attribut ) void pars taglib direct ( node parent ) throw jasper except { attribut attr = pars attribut ( ) ; string uri = attr . get valu ( uri ) ; string prefix = attr . get valu ( prefix ) ; ( prefix = null ) { mark prev mark = page info . get non custom tag prefix ( prefix ) ; ( prev mark = null ) { err . jsp error ( reader . mark ( ) , jsp . error . prefix . us befor dcl , prefix , prev mark . get file ( ) , prev mark . get line number ( ) ) ; } ( uri = null ) { string uri prev = page info . get uri ( prefix ) ; ( uri prev = null uri prev . equal ( uri ) ) { err . jsp error ( reader . mark ( ) , jsp . error . prefix . refin , prefix , uri , uri prev ) ; } ( page info . get taglib ( uri ) = = null ) { tag librari info impl impl = null ; ( ctxt . get option ( ) . cach ( ) ) { impl = ( tag librari info impl ) ctxt . get option ( ) . get cach ( ) . get ( uri ) ; } ( impl = = null ) { string locat = ctxt . get tld locat ( uri ) ; impl = new tag librari info impl ( ctxt , parser control , page info , prefix , uri , locat , err ) ; ( ctxt . get option ( ) . cach ( ) ) { ctxt . get option ( ) . get cach ( ) . put ( uri , impl ) ; } } els { tag file ( tag file info info : impl . get tag file ( ) ) { ctxt . set tag file jar url ( info . get path ( ) , ctxt . get tag file jar url ( ) ) ; } } page info . add taglib ( uri , impl ) ; } page info . add prefix map ( prefix , uri ) ; } els { string tagdir = attr . get valu ( tagdir ) ; ( tagdir = null ) { string urn tagdir = urn jsptagdir tagdir ; ( page info . get taglib ( urn tagdir ) = = null ) { page info . add taglib ( urn tagdir , new implicit tag librari info ( ctxt , parser control , page info , prefix , tagdir , err ) ) ; } page info . add prefix map ( prefix , urn tagdir ) ; } } } new node . taglib direct ( attr , start , parent ) ; }	privat invok parser control pars includ page void process includ direct ( string file , node parent ) throw jasper except { ( file = = null ) { return ; } try { parser control . pars ( file , parent , jar file url ) ; } catch ( file found except ex ) { err . jsp error ( start , jsp . error . file . . found , file ) ; } catch ( except ex ) { err . jsp error ( start , ex . get messag ( ) ) ; } }	privat scan tld content specifi input stream add ani new uri map . param resourc path path resourc param entri name resourc jar file , name entri jar file param stream input stream resourc throw ioexcept void tld scan stream ( string resourc path , string entri name , input stream stream ) throw ioexcept { try { pars tag librari descriptor specifi resourc path string uri = null ; tree node tld = new parser util ( ) . pars xmldocument ( resourc path , stream ) ; tree node uri node = tld . find child ( uri ) ; ( uri node = null ) { string bodi = uri node . get bodi ( ) ; ( bodi = null ) uri = bodi ; } present map ( uri = null map . get ( uri ) = = null ) { map . put ( uri , new string { resourc path , entri name } ) ; } } catch ( jasper except e ) { hack make except handl simpler throw new ioexcept ( e ) ; } final { ( stream = null ) { try { stream . close ( ) ; } catch ( throwabl t ) { do noth } } } }	popul taglib map describ web . xml . thi kept sync o . . c . startup . tld config jasper onli need uri tld map from scan web . xml wherea tld config need scan actual tld file . void tld scan web xml ( ) throw except { web xml web xml = null ; try { web xml = new web xml ( ctxt ) ; pars web applic deploy descriptor tree node webtld = null ; webtld = new parser util ( ) . pars xmldocument ( web xml . get system id ( ) , web xml . get input sourc ( ) ) ; allow taglib element root jsp config ( jsp2 . 0 ) tree node jsp config = webtld . find child ( jsp config ) ; ( jsp config = null ) { webtld = jsp config ; } iter tree node taglib = webtld . find children ( taglib ) ; while ( taglib . ha next ( ) ) { pars next taglib element tree node taglib = taglib . next ( ) ; string tag uri = null ; string tag loc = null ; tree node child = taglib . find child ( taglib uri ) ; ( child = null ) tag uri = child . get bodi ( ) ; child = taglib . find child ( taglib locat ) ; ( child = null ) tag loc = child . get bodi ( ) ; save thi locat appropri ( tag loc = = null ) continu ; ( uri type ( tag loc ) = = noroot rel uri ) tag loc = web inf tag loc ; string tag loc2 = null ; ( tag loc . end ( jar ext ) ) { tag loc = ctxt . get resourc ( tag loc ) . string ( ) ; tag loc2 = meta inf taglib . tld ; } map . put ( tag uri , new string { tag loc , tag loc2 } ) ; } } final { ( web xml = null ) { web xml . close ( ) ; } } }	privat pars jsp page tag file given path name . param file name name jsp page tag file pars . param parent parent node ( non null when process includ direct ) param tag file true file pars tag file , fals regular jsp page param direct onli true file pars tag file we ar onli interest direct need construct tag file info . param jar file jar file from which read jsp page tag file , null jsp page tag file read from filesystem node . node do pars ( string file name , node parent , url jar file url ) throw file found except , jasper except , ioexcept { node . node pars page = null ; encod specifi prolog = fals ; bom present = fals ; default page encod = fals ; jar file jar file = get jar file ( jar file url ) ; string ab file name = resolv file name ( file name ) ; string jsp config page enc = get jsp config page encod ( ab file name ) ; figur out what type jsp document encod type we ar deal determin syntax encod ( ab file name , jar file , jsp config page enc ) ; ( parent = null ) { includ resourc , add depend list ( jar file = = null ) { compil . get page info ( ) . add depend ( ab file name ) ; } els { compil . get page info ( ) . add depend ( jar file url . extern form ( ) ab file name . substr ( 1 ) ) ; } } ( ( xml encod specifi prolog ) bom present ) { make sure encod explicitli specifi xml prolog ( ani ) match jsp config element ( ani ) , treat utf 16 , utf 16be , utf 16le ident . ( jsp config page enc = null jsp config page enc . equal ( sourc enc ) ( jsp config page enc . start ( utf 16 ) sourc enc . start ( utf 16 ) ) ) { err . jsp error ( jsp . error . prolog config encod mismatch , sourc enc , jsp config page enc ) ; } } dispatch appropri parser ( xml ) { jsp document ( xml syntax ) input stream jspx page creat properli close jsp document parser . pars page = jsp document parser . pars ( thi , ab file name , jar file , parent , tag file , direct onli , sourc enc , jsp config page enc , encod specifi prolog , bom present ) ; } els { standard syntax input stream reader stream reader = null ; try { stream reader = jsp util . get reader ( ab file name , sourc enc , jar file , ctxt , err , skip ) ; jsp reader jsp reader = new jsp reader ( ctxt , ab file name , sourc enc , stream reader , err ) ; pars page = parser . pars ( thi , jsp reader , parent , tag file , direct onli , jar file url , sourc enc , jsp config page enc , default page encod , bom present ) ; } final { ( stream reader = null ) { try { stream reader . close ( ) ; } catch ( except ani ) { } } } } ( jar file = null ) { try { jar file . close ( ) ; } catch ( throwabl t ) { } } base dir stack . pop ( ) ; return pars page ; }	public get actual path uri rel context compil . string get real path ( string path ) { ( context = null ) { return context . get real path ( path ) ; } return path ; }	overrid public tag librari info get tag librari info ( ) { collect tag librari info coll = pi . get taglib ( ) ; return coll . arrai ( new tag librari info 0 ) ; }	overrid public tag librari info get tag librari info ( ) { collect tag librari info coll = pi . get taglib ( ) ; return coll . arrai ( new tag librari info 0 ) ; }	public set string get resourc path ( string path ) { return context . get resourc path ( canon uri ( path ) ) ; }	public return tag file name jar file map thi compil unit , which map tag file name jar file which tag file ar packag . map popul when pars tag file element tld ani import taglib . url get tag file jar url ( string tag file ) { return thi . tag file jar url . get ( tag file ) ; }	privat compil load tagfil . class load tag file ( compil compil , string tag file path , tag info tag info , page info parent page info ) throw jasper except { url tag file jar url = null ; ( tag file path . start ( meta inf ) ) { try { tag file jar url = new url ( jar : compil . get compil context ( ) . get tld locat ( tag info . get tag librari ( ) . get uri ( ) ) 0 ) ; } catch ( malform urlexcept e ) { ignor tag file jar url null } } string tag file jar path ; ( tag file jar url = = null ) { tag file jar path = ; } els { tag file jar path = tag file jar url . string ( ) ; } jsp compil context ctxt = compil . get compil context ( ) ; jsp runtim context rctxt = ctxt . get runtim context ( ) ; string wrapper uri = tag file jar path tag file path ; jsp servlet wrapper wrapper = rctxt . get wrapper ( wrapper uri ) ; synchron ( rctxt ) { ( wrapper = = null ) { wrapper = new jsp servlet wrapper ( ctxt . get servlet context ( ) , ctxt . get option ( ) , tag file path , tag info , ctxt . get runtim context ( ) , tag file jar url ) ; rctxt . add wrapper ( wrapper uri , wrapper ) ; us same classload classpath compil tag file wrapper . get jsp engin context ( ) . set class loader ( ctxt . get class loader ( ) ) ; wrapper . get jsp engin context ( ) . set class path ( ctxt . get class path ( ) ) ; } els { make sure jsp compil context get latest tag info tag file . tag info instanc wa creat last time tag file wa scan direct , tag file mai have been modifi sinc . wrapper . get jsp engin context ( ) . set tag info ( tag info ) ; } class tag clazz ; int trip count = wrapper . inc trip count ( ) ; try { ( trip count 0 ) { when trip count greater than zero , circular depend exist . circularli depend tag file compil prototyp mode , avoid infinit recurs . jsp servlet wrapper temp wrapper = new jsp servlet wrapper ( ctxt . get servlet context ( ) , ctxt . get option ( ) , tag file path , tag info , ctxt . get runtim context ( ) , ctxt . get tag file jar url ( tag file path ) ) ; tag clazz = temp wrapper . load tag file prototyp ( ) ; temp vector . add ( temp wrapper . get jsp engin context ( ) . get compil ( ) ) ; } els { tag clazz = wrapper . load tag file ( ) ; } } final { wrapper . dec trip count ( ) ; } can onli obtain from tag instanc . try { object tag = tag clazz . new instanc ( ) ; ( tag instanceof jsp sourc depend ) { iter string iter = ( ( jsp sourc depend ) tag ) . get depend ( ) . iter ( ) ; while ( iter . ha next ( ) ) { parent page info . add depend ( iter . next ( ) ) ; } } } catch ( except e ) { ignor error } return tag clazz ; } }	public string get locat ( string uri ) throw jasper except { ( initi ) { init ( ) ; } return map . get ( uri ) ; }	public void set tag file jar url ( string tag file , url tag file url ) { thi . tag file jar url . put ( tag file , tag file url ) ; }	public string get tld locat ( string uri ) throw jasper except { string locat = get option ( ) . get tld locat cach ( ) . get locat ( uri ) ; return locat ; }	privat compil load tagfil . class load tag file ( compil compil , string tag file path , tag info tag info , page info parent page info ) throw jasper except { url tag file jar url = null ; ( tag file path . start ( meta inf ) ) { try { tag file jar url = new url ( jar : compil . get compil context ( ) . get tld locat ( tag info . get tag librari ( ) . get uri ( ) ) 0 ) ; } catch ( malform urlexcept e ) { ignor tag file jar url null } } string tag file jar path ; ( tag file jar url = = null ) { tag file jar path = ; } els { tag file jar path = tag file jar url . string ( ) ; } jsp compil context ctxt = compil . get compil context ( ) ; jsp runtim context rctxt = ctxt . get runtim context ( ) ; string wrapper uri = tag file jar path tag file path ; jsp servlet wrapper wrapper = rctxt . get wrapper ( wrapper uri ) ; synchron ( rctxt ) { ( wrapper = = null ) { wrapper = new jsp servlet wrapper ( ctxt . get servlet context ( ) , ctxt . get option ( ) , tag file path , tag info , ctxt . get runtim context ( ) , tag file jar url ) ; rctxt . add wrapper ( wrapper uri , wrapper ) ; us same classload classpath compil tag file wrapper . get jsp engin context ( ) . set class loader ( ctxt . get class loader ( ) ) ; wrapper . get jsp engin context ( ) . set class path ( ctxt . get class path ( ) ) ; } els { make sure jsp compil context get latest tag info tag file . tag info instanc wa creat last time tag file wa scan direct , tag file mai have been modifi sinc . wrapper . get jsp engin context ( ) . set tag info ( tag info ) ; } class tag clazz ; int trip count = wrapper . inc trip count ( ) ; try { ( trip count 0 ) { when trip count greater than zero , circular depend exist . circularli depend tag file compil prototyp mode , avoid infinit recurs . jsp servlet wrapper temp wrapper = new jsp servlet wrapper ( ctxt . get servlet context ( ) , ctxt . get option ( ) , tag file path , tag info , ctxt . get runtim context ( ) , ctxt . get tag file jar url ( tag file path ) ) ; tag clazz = temp wrapper . load tag file prototyp ( ) ; temp vector . add ( temp wrapper . get jsp engin context ( ) . get compil ( ) ) ; } els { tag clazz = wrapper . load tag file ( ) ; } } final { wrapper . dec trip count ( ) ; } can onli obtain from tag instanc . try { object tag = tag clazz . new instanc ( ) ; ( tag instanceof jsp sourc depend ) { iter string iter = ( ( jsp sourc depend ) tag ) . get depend ( ) . iter ( ) ; while ( iter . ha next ( ) ) { parent page info . add depend ( iter . next ( ) ) ; } } } catch ( except e ) { ignor error } return tag clazz ; } }
privat session get session ( string session id , string ctxname ) { map string , cluster manag manag = cluster sso . get cluster ( ) . get manag ( ) ; session session = null ; ( ctxname = = null ) { java . util . iter string i = manag . kei set ( ) . iter ( ) ; while ( i . ha next ( ) ) { string kei = i . next ( ) ; cluster manag mgr = manag . get ( kei ) ; ( mgr = null ) { try { session = mgr . find session ( session id ) ; } catch ( ioexcept io ) { log . error ( session doesn t exist : io ) ; } return session ; } els { up ( log . debug enabl ( ) ) log . debug ( context manag doesn t exist : kei ) ; } } } els { cluster manag mgr = manag . get ( ctxname ) ; ( mgr = null ) { try { session = mgr . find session ( session id ) ; } catch ( ioexcept io ) { log . error ( session doesn t exist : io ) ; } return session ; } els ( log . error enabl ( ) ) log . error ( context manag doesn t exist : ctxname ) ; } return null ; }	protect pars accept languag header valu . void pars local header ( string valu ) { store accumul languag have been request local collect , sort qualiti valu ( so we can add local descend order ) . valu arrai list contain correspond local ad tree map doubl , arrai list local >> local = new tree map doubl , arrai list local >> ( ) ; preprocess valu remov all whitespac int white = valu . index ( ) ; ( white 0 ) white = valu . index ( t ) ; ( white = 0 ) { string builder sb = new string builder ( ) ; int len = valu . length ( ) ; ( int i = 0 ; i len ; i ) { char ch = valu . char ( i ) ; ( ( ch = ) ( ch = t ) ) sb . append ( ch ) ; } valu = sb . string ( ) ; } process each comma delimit languag specif assert : parser avail us parser . set string ( valu ) ; int length = parser . get length ( ) ; while ( true ) { extract next comma delimit entri int start = parser . get index ( ) ; ( start = length ) break ; int end = parser . find char ( , ) ; string entri = parser . extract ( start , end ) . trim ( ) ; follow entri parser . advanc ( ) ; extract qualiti factor thi entri doubl qualiti = 1 . 0 ; int semi = entri . index ( ; q = ) ; ( semi = 0 ) { try { qualiti = doubl . pars doubl ( entri . substr ( semi 3 ) ) ; } catch ( number format except e ) { qualiti = 0 . 0 ; } entri = entri . substr ( 0 , semi ) ; } skip entri we ar go keep track ( qualiti 0 . 00005 ) zero ( effect zero ) qualiti factor continu ; ( . equal ( entri ) ) fixm entri ar handl continu ; extract languag countri thi entri string languag = null ; string countri = null ; string variant = null ; int dash = entri . index ( ) ; ( dash 0 ) { languag = entri ; countri = ; variant = ; } els { languag = entri . substr ( 0 , dash ) ; countri = entri . substr ( dash 1 ) ; int v dash = countri . index ( ) ; ( v dash 0 ) { string c temp = countri . substr ( 0 , v dash ) ; variant = countri . substr ( v dash 1 ) ; countri = c temp ; } els { variant = ; } } ( alpha ( languag ) alpha ( countri ) alpha ( variant ) ) { continu ; } add new local list local thi qualiti level local local = new local ( languag , countri , variant ) ; revers order doubl kei = new doubl ( qualiti ) ; arrai list local valu = local . get ( kei ) ; ( valu = = null ) { valu = new arrai list local ( ) ; local . put ( kei , valu ) ; } valu . add ( local ) ; } process qualiti valu highest lowest order ( due negat doubl valu when creat kei ) iter doubl kei = local . kei set ( ) . iter ( ) ; while ( kei . ha next ( ) ) { doubl kei = kei . next ( ) ; arrai list local list = local . get ( kei ) ; iter local valu = list . iter ( ) ; while ( valu . ha next ( ) ) { local local = valu . next ( ) ; add local ( local ) ; } } }	protect map string , string process annot web init param ( element valu ev ) { map string , string result = new hash map string , string ( ) ; ( ev instanceof arrai element valu ) { element valu arrai valu = ( ( arrai element valu ) ev ) . get element valu arrai ( ) ; ( element valu valu : arrai valu ) { ( valu instanceof annot element valu ) { element valu pair evp = ( ( annot element valu ) valu ) . get annot entri ( ) . get element valu pair ( ) ; string init param name = null ; string init param valu = null ; ( element valu pair evp : evp ) { ( name . equal ( evp . get name string ( ) ) ) { init param name = evp . get valu ( ) . stringifi valu ( ) ; } els ( valu . equal ( evp . get name string ( ) ) ) { init param valu = evp . get valu ( ) . stringifi valu ( ) ; } els { ignor } } result . put ( init param name , init param valu ) ; } } } return result ; }	protect void process annot web servlet ( string class name , annot entri ae , web xml fragment ) { ( fragment . get servlet ( ) . contain kei ( class name ) ) { skip thi annot . entri web . xml take prioriti return ; } boolean url pattern set = fals ; servlet def servlet def = new servlet def ( ) ; servlet def . set servlet name ( class name ) ; servlet def . set servlet class ( class name ) ; string url pattern = null ; element valu pair evp = ae . get element valu pair ( ) ; ( element valu pair evp : evp ) { string name = evp . get name string ( ) ; ( valu . equal ( name ) url pattern . equal ( name ) ) { ( url pattern set ) { throw new illeg argument except ( sm . get string ( context config . url pattern valu , class name ) ) ; } url pattern set = true ; url pattern = process annot string arrai ( evp . get valu ( ) ) ; } els ( name . equal ( name ) ) { servlet def . set servlet name ( evp . get valu ( ) . stringifi valu ( ) ) ; } els ( descript . equal ( name ) ) { servlet def . set descript ( evp . get valu ( ) . stringifi valu ( ) ) ; } els ( displai name . equal ( name ) ) { servlet def . set displai name ( evp . get valu ( ) . stringifi valu ( ) ) ; } els ( larg icon . equal ( name ) ) { servlet def . set larg icon ( evp . get valu ( ) . stringifi valu ( ) ) ; } els ( small icon . equal ( name ) ) { servlet def . set small icon ( evp . get valu ( ) . stringifi valu ( ) ) ; } els ( async support . equal ( name ) ) { servlet def . set async support ( evp . get valu ( ) . stringifi valu ( ) ) ; } els ( load startup . equal ( name ) ) { servlet def . set load startup ( evp . get valu ( ) . stringifi valu ( ) ) ; } els ( init param . equal ( name ) ) { map string , string init param = process annot web init param ( evp . get valu ( ) ) ; ( string param name : init param . kei set ( ) ) { servlet def . add init paramet ( param name , init param . get ( param name ) ) ; } } els { ignor } } ( url pattern = null ) { fragment . add servlet ( servlet def ) ; ( string url pattern : url pattern ) { fragment . add servlet map ( url pattern , servlet def . get servlet name ( ) ) ; } } }	perform shallow copi specifi map , return result . param orig origin map copi map string , string copi map ( map string , string orig ) { ( orig = = null ) return ( new hash map string , string ( ) ) ; hash map string , string dest = new hash map string , string ( ) ; iter string kei = orig . kei set ( ) . iter ( ) ; while ( kei . ha next ( ) ) { string kei = kei . next ( ) ; dest . put ( kei , orig . get ( kei ) ) ; } return ( dest ) ; }	public load initi all servlet mark load startup web applic deploy descriptor . param children arrai wrapper all current defin servlet ( includ those declar load startup ) void load startup ( contain children ) { collect load startup servlet need initi tree map integ , arrai list wrapper >> map = new tree map integ , arrai list wrapper >> ( ) ; ( int i = 0 ; i children . length ; i ) { wrapper wrapper = ( wrapper ) children i ; int load startup = wrapper . get load startup ( ) ; ( load startup 0 ) continu ; integ kei = integ . valu ( load startup ) ; arrai list wrapper list = map . get ( kei ) ; ( list = = null ) { list = new arrai list wrapper ( ) ; map . put ( kei , list ) ; } list . add ( wrapper ) ; } load collect load startup servlet iter integ kei = map . kei set ( ) . iter ( ) ; while ( kei . ha next ( ) ) { integ kei = kei . next ( ) ; arrai list wrapper list = map . get ( kei ) ; iter wrapper wrapper = list . iter ( ) ; while ( wrapper . ha next ( ) ) { wrapper wrapper = wrapper . next ( ) ; try { wrapper . load ( ) ; } catch ( servlet except e ) { get logger ( ) . error ( sm . get string ( standard wrapper . load except , get name ( ) ) , standard wrapper . get root caus ( e ) ) ; note : load error ( includ servlet throw unavail except from tht init ( ) method ) ar fatal applic startup } } } }	callback from cluster , when messag receiv , cluster broadcast invok messag receiv receiv . param myobj cluster messag messag receiv from cluster overrid public void messag receiv ( cluster messag myobj ) { ( myobj = null myobj instanceof session messag ) { session messag msg = ( session messag ) myobj ; string ctxname = msg . get context name ( ) ; check messag evt get all session , so , wait until we ar fulli start up map string , cluster manag manag = cluster . get manag ( ) ; ( ctxname = = null ) { iter string i = manag . kei set ( ) . iter ( ) ; while ( i . ha next ( ) ) { string kei = i . next ( ) ; cluster manag mgr = manag . get ( kei ) ; ( mgr = null ) mgr . messag data receiv ( msg ) ; els { up ( log . debug enabl ( ) ) log . debug ( context manag doesn t exist : kei ) ; } } } els { cluster manag mgr = manag . get ( ctxname ) ; ( mgr = null ) mgr . messag data receiv ( msg ) ; } } }
protect write serial version thi session object specifi object output stream . p b implement note b : own manag store serial represent thi session . after call code read object ( ) code , you must set associ manag explicitli . p b implement note b : ani attribut serializ unbound from session , appropri action implement http session bind listen . you do want ani attribut , sure code distribut code properti associ manag set code true code . param stream output stream write except ioexcept input output error occur void write object ( object output stream stream ) throw ioexcept { write scalar instanc variabl ( except manag ) stream . write object ( new long ( creation time ) ) ; stream . write object ( new long ( last access time ) ) ; stream . write object ( new integ ( max inact interv ) ) ; stream . write object ( new boolean ( new ) ) ; stream . write object ( new boolean ( valid ) ) ; stream . write object ( new long ( thi access time ) ) ; stream . write object ( id ) ; ( manag . get contain ( ) . get logger ( ) . debug enabl ( ) ) manag . get contain ( ) . get logger ( ) . debug ( write object ( ) store session id ) ; accumul name serializ non serializ attribut string kei = kei ( ) ; arrai list string save name = new arrai list string ( ) ; arrai list object save valu = new arrai list object ( ) ; ( int i = 0 ; i kei . length ; i ) { object valu = attribut . get ( kei i ) ; ( valu = = null ) continu ; } }
public static main method , us test onli . param arg command line argument process void main ( string arg ) { ( daemon = = null ) { daemon = new bootstrap ( ) ; try { daemon . init ( ) ; } catch ( throwabl t ) { t . print stack trace ( ) ; return ; } } try { string command = start ; ( arg . length 0 ) { command = arg arg . length 1 ; } ( command . equal ( startd ) ) { arg arg . length 1 = start ; daemon . load ( arg ) ; daemon . start ( ) ; } els ( command . equal ( stopd ) ) { arg arg . length 1 = stop ; daemon . stop ( ) ; } els ( command . equal ( start ) ) { daemon . set await ( true ) ; daemon . load ( arg ) ; daemon . start ( ) ; } els ( command . equal ( stop ) ) { daemon . stop server ( arg ) ; } els { log . warn ( bootstrap : command command doe exist . ) ; } } catch ( throwabl t ) { t . print stack trace ( ) ; } }	public set flag . void set await ( boolean await ) throw except { class param type = new class 1 ; param type 0 = boolean . type ; object param valu = new object 1 ; param valu 0 = new boolean ( await ) ; method method = catalina daemon . get class ( ) . get method ( set await , param type ) ; method . invok ( catalina daemon , param valu ) ; }
public void test order2 ( ) throw except { final member dest = channel 0 . get member ( ) ; final atom integ valu = new atom integ ( 0 ) ; runnabl run = new runnabl ( ) { public void run ( ) { ( int i = 0 ; i 100 ; i ) { try { synchron ( channel 0 ) { channel 0 . send ( dest , new integ ( valu . get add ( 1 ) ) , 0 ) ; } } catch ( except x ) { x . print stack trace ( ) ; assert equal ( true , fals ) ; } } } } ; thread thread = new thread 5 ; ( int i = 0 ; i thread . length ; i ) { thread i = new thread ( run ) ; } ( int i = 0 ; i thread . length ; i ) { thread i . start ( ) ; } ( int i = 0 ; i thread . length ; i ) { thread i . join ( ) ; } thread . sleep ( 5000 ) ; ( int i = 0 ; i test . length ; i ) { assert equal ( fals , test i . fail ) ; } }	public void test order2 ( ) throw except { final member dest = channel 0 . get member ( ) ; final atom integ valu = new atom integ ( 0 ) ; runnabl run = new runnabl ( ) { } }
public static final tag find ancestor class ( tag from , tck signatur test fail gener suppress warn ( uncheck ) class klass ) { boolean interfac = fals ; ( from = = null klass = = null ( tag . class . assign from ( klass ) ( interfac = klass . interfac ( ) ) ) ) { return null ; } ( ; ; ) { tag tag = from . get parent ( ) ; ( tag = = null ) { return null ; } ( ( interfac klass . instanc ( tag ) ) klass . assign from ( tag . get class ( ) ) ) { return tag ; } from = tag ; } }
protect handl receiv other node want all session ( restart ) ) send all session messag b ) send session block after send send state complet transfer param msg param sender throw ioexcept void handl get all session ( session messag msg , member sender ) throw ioexcept { counter receiv evt get all session ; get list all session from thi manag ( log . debug enabl ( ) ) log . debug ( sm . get string ( delta manag . receiv messag . unload begin , get name ( ) ) ) ; write number activ session , follow detail get all session serial without sync session current session = find session ( ) ; long find session timestamp = system . current time milli ( ) ; ( send all session ( ) ) { send session ( sender , current session , find session timestamp ) ; } els { send session block int len = current session . length get send all session size ( ) current session . length : get send all session size ( ) ; session send session = new session len ; ( int i = 0 ; i current session . length ; i = get send all session size ( ) ) { len = i get send all session size ( ) current session . length current session . length i : get send all session size ( ) ; system . arraycopi ( current session , i , send session , 0 , len ) ; send session ( sender , send session , find session timestamp ) ; ( get send all session wait time ( ) 0 ) { try { thread . sleep ( get send all session wait time ( ) ) ; } catch ( except sleep ) { } } end } } end session messag newmsg = new session messag impl ( name , session messag . evt all session transfercomplet , null , session state transfer , session state transfer get name ( ) ) ; newmsg . set timestamp ( find session timestamp ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( delta manag . creat messag . all session transfer , get name ( ) ) ) ; counter send evt all session transfercomplet ; cluster . send ( newmsg , sender ) ; }
start compon implement requir { link lifecycl base start intern ( ) } . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect void start intern ( ) throw lifecycl except { taskqueu = new task queue ( max queue size ) ; task thread factori tf = new task thread factori ( name prefix , daemon , get thread prioriti ( ) ) ; executor = new thread pool executor ( get min spare thread ( ) , get max thread ( ) , max idl time , time unit . millisecond , taskqueu , tf ) ; taskqueu . set parent ( executor ) ; set state ( lifecycl state . start ) ; }	public string get name ( ) { return name ; }	public void set min spare thread ( int min spare thread ) { thi . min spare thread = min spare thread ; ( executor = null ) { executor . set core pool size ( min spare thread ) ; } }

stop thi compon implement requir { link lifecycl base stop intern ( ) } . thi disconnect cluster commun channel stop listen thread . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect synchron void stop intern ( ) throw lifecycl except { ( log . debug enabl ( ) ) log . debug ( stop ) ; set state ( lifecycl state . stop ) ; lazi replic map map = ( lazi replic map ) session ; ( map = null ) { map . breakdown ( ) ; } cluster . remov manag ( thi ) ; thi . random = null ; ( initi ) { destroi ( ) ; } }
start thi compon implement requir { link lifecycl base start intern ( ) } . start cluster commun channel , thi connect other node cluster , request current session state transfer thi node . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect synchron void start intern ( ) throw lifecycl except { try { cluster . regist manag ( thi ) ; catalina cluster catclust = cluster ; lazi replic map map = new lazi replic map ( thi , catclust . get channel ( ) , default repl timeout , get map name ( ) , get class loader ( ) ) ; map . set channel send option ( map send option ) ; thi . session = map ; } catch ( except x ) { log . error ( unabl start backup manag , x ) ; throw new lifecycl except ( fail start backup manag , x ) ; } super . start intern ( ) ; }	stop thi compon implement requir { link lifecycl base stop intern ( ) } . thi disconnect cluster commun channel stop listen thread . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect synchron void stop intern ( ) throw lifecycl except { super . stop intern ( ) ; lazi replic map map = ( lazi replic map ) session ; ( map = null ) { map . breakdown ( ) ; } cluster . remov manag ( thi ) ; }

protect call server ( via code servic code method ) allow servlet handl trace request . trace return header sent trace request client , so thei can us debug . s need overrid thi method . param req { link http servlet request } object contain request client made servlet param resp { link http servlet respons } object contain respons servlet return client except ioexcept input output error occur while servlet handl trace request except servlet except request trace cannot handl void do trace ( http servlet request req , http servlet respons resp ) throw servlet except , ioexcept { int respons length ; string crlf = r n ; string respons string = trace req . get request uri ( ) req . get protocol ( ) ; enumer string req header enum = req . get header name ( ) ; while ( req header enum . ha more element ( ) ) { string header name = req header enum . next element ( ) ; respons string = crlf header name : req . get header ( header name ) ; } respons string = crlf ; respons length = respons string . length ( ) ; resp . set content type ( messag http ) ; resp . set content length ( respons length ) ; servlet output stream out = resp . get output stream ( ) ; out . print ( respons string ) ; out . close ( ) ; return ; }
public page context run ( ) { return factori . intern get page context ( servlet , request , respons , error page url , need session , buffer size , autoflush ) ; }
protect void start intern ( ) throw lifecycl except { configur list fail user delet oldest entri onc exce specifi size fail user = new link hash map string , lock record ( cach size , 0 . 75f , true ) { privat static final long serial version uid = 1l ; overrid protect boolean remov eldest entri ( map . entri string , lock record eldest ) { ( size ( ) cach size ) { check see thi element ha been remov too quickli long time cach = ( system . current time milli ( ) eldest . get valu ( ) . get last failur time ( ) ) 1000 ; ( time cach cach remov warn time ) { log . warn ( sm . get string ( lock out realm . remov warn , eldest . get kei ( ) , long . valu ( time cach ) ) ) ; } return true ; } return fals ; } } ; super . start intern ( ) ; }	public return princip associ specifi usernam credenti , ; otherwis return code null code . param usernam usernam princip look up param credenti password other credenti us authent thi usernam princip authent ( string usernam , string credenti ) { string server credenti = get password ( usernam ) ; boolean valid ; ( server credenti = = null ) { valid = fals ; } els ( ha messag digest ( ) ) { valid = server credenti . equal ignor case ( digest ( credenti ) ) ; } els { valid = server credenti . equal ( credenti ) ; } ( valid ) { ( contain log . trace enabl ( ) ) { contain log . trace ( sm . get string ( realm base . authent failur , usernam ) ) ; } return null ; } ( contain log . trace enabl ( ) ) { contain log . trace ( sm . get string ( realm base . authent success , usernam ) ) ; } return get princip ( usernam ) ; }	public object name get realm ( ) { object name result = new object name realm . size ( ) ; ( realm realm : realm ) { ( realm instanceof realm base ) { result realm . index ( realm ) = ( ( realm base ) realm ) . get object name ( ) ; } } return result ; }

protect call forward login page param request request we ar process param respons respons we ar popul param config login configur describ how authent should perform throw ioexcept forward login page fail call { link http servlet respons send error ( int , string ) throw { link ioexcept } void forward login page ( request request , http servlet respons respons , login config config ) throw ioexcept { request dispatch disp = context . get servlet context ( ) . get request dispatch ( config . get login page ( ) ) ; try { disp . forward ( request . get request ( ) , respons ) ; } catch ( throwabl t ) { string msg = sm . get string ( form authent . forward login fail ) ; log . warn ( msg , t ) ; request . set attribut ( global . except attr , t ) ; respons . send error ( http servlet respons . sc intern server error , msg ) ; } }	public respons send ( member destin , serializ messag , int rpc option , int channel option , long timeout ) throw channel except { ( destin = = null destin . length = = 0 ) return new respons 0 ; avoid dead lock channel option = channel option channel . send option synchron ack ; rpc collector kei kei = new rpc collector kei ( uuidgener . random uuid ( fals ) ) ; rpc collector collector = new rpc collector ( kei , rpc option , destin . length , timeout ) ; try { synchron ( collector ) { ( rpc option = repli ) respons map . put ( kei , collector ) ; rpc messag rmsg = new rpc messag ( rpc id , kei . id , messag ) ; channel . send ( destin , rmsg , channel option ) ; ( rpc option = repli ) collector . wait ( timeout ) ; } } catch ( interrupt except ix ) { thread . interrupt ( ) ; throw new channel except ( ix ) ; } final { respons map . remov ( kei ) ; } return collector . get respons ( ) ; }	public return session associ thi request , creat necessari . session get session intern ( ) { return do get session ( true ) ; }	sinc el 2 . 2 overrid public valu refer get valu refer ( evalu context ctx ) { check thi refer base properti ( thi . children . length 2 thi . jjt get child ( 2 ) instanceof ast method paramet ) { thi method call return null ; } target t = get target ( ctx ) ; return new valu refer ( t . base , thi . jjt get child ( 1 ) . get valu ( ctx ) ) ; }	authent user make thi request , base specifi login configur . return code true code ani specifi constraint ha been satisfi , code fals code we have creat respons challeng alreadi . param request request we ar process param respons respons we ar creat param config login configur describ how authent should perform except ioexcept input output error occur overrid public boolean authent ( request request , http servlet respons respons , login config config ) throw ioexcept { refer object we need later session session = null ; have we alreadi authent someon princip princip = request . get user princip ( ) ; string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( princip = null ) { ( log . debug enabl ( ) ) log . debug ( alreadi authent princip . get name ( ) ) ; associ session ani exist sso session ( sso id = null ) associ ( sso id , request . get session intern ( true ) ) ; return ( true ) ; } sso session against which we can try reauthent ( sso id = null ) { ( log . debug enabl ( ) ) log . debug ( sso id sso id set ; attempt reauthent ) ; either case we have prompt user logon ( reauthent from sso ( sso id , request ) ) return true ; } have we authent thi user befor have cach disabl ( cach ) { session = request . get session intern ( true ) ; ( log . debug enabl ( ) ) log . debug ( check reauthent session session ) ; string usernam = ( string ) session . get note ( constant . sess usernam note ) ; string password = ( string ) session . get note ( constant . sess password note ) ; ( ( usernam = null ) ( password = null ) ) { ( log . debug enabl ( ) ) log . debug ( reauthent usernam usernam ) ; princip = context . get realm ( ) . authent ( usernam , password ) ; ( princip = null ) { session . set note ( constant . form princip note , princip ) ; ( match request ( request ) ) { regist ( request , respons , princip , constant . form method , usernam , password ) ; return ( true ) ; } } ( log . debug enabl ( ) ) log . debug ( reauthent fail , proce normal ) ; } } authent so , forward origin request instead . ( match request ( request ) ) { session = request . get session intern ( true ) ; ( log . debug enabl ( ) ) log . debug ( restor request from session session . get id intern ( ) ) ; princip = ( princip ) session . get note ( constant . form princip note ) ; regist ( request , respons , princip , constant . form method , ( string ) session . get note ( constant . sess usernam note ) , ( string ) session . get note ( constant . sess password note ) ) ; password session , so remov them ( cach ) { session . remov note ( constant . sess usernam note ) ; session . remov note ( constant . sess password note ) ; } ( restor request ( request , session ) ) { ( log . debug enabl ( ) ) log . debug ( proce restor request ) ; return ( true ) ; } els { ( log . debug enabl ( ) ) log . debug ( restor origin request fail ) ; respons . send error ( http servlet respons . sc bad request ) ; return ( fals ) ; } } acquir refer object we need evalu messag byte uri mb = messag byte . new instanc ( ) ; char chunk uri cc = uri mb . get char chunk ( ) ; uri cc . set limit ( 1 ) ; string context path = request . get context path ( ) ; string request uri = request . get decod request uri ( ) ; thi action request from login page boolean login action = request uri . start ( context path ) request uri . end ( constant . form action ) ; save thi request redirect form login page ( login action ) { session = request . get session intern ( true ) ; ( log . debug enabl ( ) ) log . debug ( save request session session . get id intern ( ) ) ; try { save request ( request , session ) ; } catch ( ioexcept ioe ) { log . debug ( request bodi too big save dure authent ) ; respons . send error ( http servlet respons . sc forbidden , sm . get string ( authent . request bodi too big ) ) ; return ( fals ) ; } forward login page ( request , respons , config ) ; return ( fals ) ; } ye valid specifi credenti redirect error page thei ar correct realm realm = context . get realm ( ) ; ( charact encod = null ) { request . set charact encod ( charact encod ) ; } string usernam = request . get paramet ( constant . form usernam ) ; string password = request . get paramet ( constant . form password ) ; ( log . debug enabl ( ) ) log . debug ( authent usernam usernam ) ; princip = realm . authent ( usernam , password ) ; ( princip = = null ) { forward error page ( request , respons , config ) ; return ( fals ) ; } ( log . debug enabl ( ) ) log . debug ( authent usernam wa success ) ; ( session = = null ) session = request . get session intern ( fals ) ; ( session = = null ) { ( contain log . debug enabl ( ) ) contain log . debug ( user took so long log session expir ) ; respons . send error ( http servlet respons . sc request timeout , sm . get string ( authent . session expir ) ) ; return ( fals ) ; } save authent princip our session session . set note ( constant . form princip note , princip ) ; save usernam password well session . set note ( constant . sess usernam note , usernam ) ; session . set note ( constant . sess password note , password ) ; redirect user origin request uri ( which caus origin request restor ) request uri = save request url ( session ) ; ( log . debug enabl ( ) ) log . debug ( redirect origin request uri ) ; ( request uri = = null ) respons . send error ( http servlet respons . sc bad request , sm . get string ( authent . formlogin ) ) ; els respons . send redirect ( respons . encod redirect url ( request uri ) ) ; return ( fals ) ; }	public return clear refer thread local flag thi context . boolean get clear refer thread local ( ) { return ( thi . clear refer thread local ) ; }	public return true valu repres name attribut valu . boolean name attribut ( ) { return name attribut ; }	public return last time client sent request associ thi session , number millisecond sinc midnight , januari 1 , 1970 gmt . action your applic take , get set valu associ session , do affect access time . thi get updat whenev request finish . long get last access time ( ) { ( valid intern ( ) ) { throw new illeg state except ( sm . get string ( standard session . get last access time . ) ) ; } return ( thi . last access time ) ; }	public return last time client sent request associ thi session , number millisecond sinc midnight , januari 1 , 1970 gmt . action your applic take , get set valu associ session , do affect access time . thi get updat whenev request start . long get thi access time ( ) { ( valid intern ( ) ) { throw new illeg state except ( sm . get string ( standard session . get thi access time . ) ) ; } return ( thi . thi access time ) ; }	public static creat new { link express factori } . class us determin follow search order : ol li servic api ( meta inf servic javax . el . express factori ) li li jre home lib el . properti kei javax . el . express factori li li javax . el . express factori li li platform default implement org . apach . el . express factori impl li ol return express factori new instanc ( ) { return new instanc ( null ) ; }	public void destroi ( ) throw except { ( get state ( ) . avail ( ) ) { stop ( ) ; } initi = fals ; unregist thi compon ( onam = null ) { try { ( control = = onam ) { registri . get registri ( null , null ) . unregist compon ( onam ) ; ( log . debug enabl ( ) ) log . debug ( unregist onam ) ; } } catch ( throwabl t ) { log . error ( error unregist , t ) ; } } ( parent = null ) { parent . remov child ( thi ) ; } stop our child contain , ani contain children = find children ( ) ; ( int i = 0 ; i children . length ; i ) { remov child ( children i ) ; } }	public void destroi ( ) { thi . attribut = null ; thi . filter config = null ; }	public void destroi ( ) { thi . encod = null ; thi . filter config = null ; }	overrid public void set secur ( boolean secur ) { thi . secur = secur ; }	public void stop ( ) { run = fals ; }
public boolean process socket ( socket wrapper socket socket , socket statu statu ) { try { ( statu = = socket statu . open statu = = socket statu . stop statu = = socket statu . timeout ) { ( wait request . remov ( socket ) ) { socket processor proc = new socket processor ( socket , statu ) ; class loader loader = thread . current thread ( ) . get context class loader ( ) ; try { thread should creat webapp classload ( global . secur enabl ) { privileg action void pa = new privileg set tccl ( get class ( ) . get class loader ( ) ) ; access control . do privileg ( pa ) ; } els { thread . current thread ( ) . set context class loader ( get class ( ) . get class loader ( ) ) ; } get executor ( ) . execut ( proc ) ; } final { ( global . secur enabl ) { privileg action void pa = new privileg set tccl ( loader ) ; access control . do privileg ( pa ) ; } els { thread . current thread ( ) . set context class loader ( loader ) ; } } } } } catch ( throwabl t ) { thi mean we got oom similar creat thread , pool queue ar full log . error ( sm . get string ( endpoint . process . fail ) , t ) ; return fals ; } return true ; }	public server socket factori get server socket factori ( ) { return server socket factori ; }	public void set keep aliv timeout ( int timeout ) { keep aliv timeout = timeout ; }	public void set sslimplement ( string valu s ) { ssl implement name = valu s ; set secur ( true ) ; }
overrid public sslsupport get sslsupport ( socket s ) { sslsupport ssl = factori . get sslsupport ( s ) ; return ssl ; }	return state endpoint . return true endpoint paus , fals otherwis overrid public boolean paus ( ) { return paus ; }	protect process given socket event . boolean process socket ( long socket , socket statu statu ) { try { get executor ( ) . execut ( new socket event processor ( socket , statu ) ) ; } catch ( reject execut except x ) { log . warn ( socket process request wa reject : socket , x ) ; return fals ; } catch ( throwabl t ) { thi mean we got oom similar creat thread , pool queue ar full log . error ( sm . get string ( endpoint . process . fail ) , t ) ; return fals ; } return true ; }	public initi endpoint . void init ( ) throw except { ( initi ) return ; creat root apr memori pool root pool = pool . creat ( 0 ) ; creat pool server socket server sock pool = pool . creat ( root pool ) ; creat apr address bound string address str = null ; ( get address ( ) = null ) { address str = get address ( ) . get host address ( ) ; } int famili = socket . apr inet ; ( librari . apr have ipv6 ) { ( address str = = null ) { ( os . bsd os . win32 os . win64 ) famili = socket . apr unspec ; } els ( address str . index ( : ) = 0 ) { famili = socket . apr unspec ; } } long inet address = address . info ( address str , famili , get port ( ) , 0 , root pool ) ; creat apr server socket server sock = socket . creat ( address . get info ( inet address ) . famili , socket . sock stream , socket . apr proto tcp , root pool ) ; ( os . unix ) { socket . opt set ( server sock , socket . apr so reuseaddr , 1 ) ; } deal firewal tend drop inact socket socket . opt set ( server sock , socket . apr so keepal , 1 ) ; bind server socket int ret = socket . bind ( server sock , inet address ) ; ( ret = 0 ) { throw new except ( sm . get string ( endpoint . init . bind , ret , error . strerror ( ret ) ) ) ; } start listen server socket ret = socket . listen ( server sock , get backlog ( ) ) ; ( ret = 0 ) { throw new except ( sm . get string ( endpoint . init . listen , ret , error . strerror ( ret ) ) ) ; } ( os . win32 os . win64 ) { window set reuseaddr flag after bind listen socket . opt set ( server sock , socket . apr so reuseaddr , 1 ) ; } sendfil usag system which don t support caus major problem ( us sendfil librari . apr ha sendfil ) { us sendfil = fals ; } initi thread count default acceptor , poller sendfil ( acceptor thread count = = 0 ) { fixm : doesn t seem work well multipl accept thread acceptor thread count = 1 ; } ( poller thread count = = 0 ) { ( ( os . win32 os . win64 ) ( poller size 1024 ) ) { maximum per poller get reason perform 1024 poller thread count = poller size 1024 ; adjust poller size so won t reach limit poller size = poller size ( poller size 1024 ) ; } els { explicit poller size limit poller thread count = 1 ; } } ( sendfil thread count = = 0 ) { ( ( os . win32 os . win64 ) ( sendfil size 1024 ) ) { maximum per poller get reason perform 1024 sendfil thread count = sendfil size 1024 ; adjust poller size so won t reach limit sendfil size = sendfil size ( sendfil size 1024 ) ; } els { explicit poller size limit fixm : default per cpu sendfil thread count = 1 ; } } other platform thi call noop return apr enotimpl . ( defer accept ) { ( socket . opt set ( server sock , socket . apr tcp defer accept , 1 ) = = statu . apr enotimpl ) { defer accept = fals ; } } initi ssl need ( sslenabl ( ) ) { ssl protocol int valu = ssl . ssl protocol all ; ( sslv2 . equal ignor case ( sslprotocol ) ) { valu = ssl . ssl protocol sslv2 ; } els ( sslv3 . equal ignor case ( sslprotocol ) ) { valu = ssl . ssl protocol sslv3 ; } els ( tlsv1 . equal ignor case ( sslprotocol ) ) { valu = ssl . ssl protocol tlsv1 ; } els ( sslv2 sslv3 . equal ignor case ( sslprotocol ) ) { valu = ssl . ssl protocol sslv2 ssl . ssl protocol sslv3 ; } creat ssl context ssl context = sslcontext . make ( root pool , valu , ssl . ssl mode server ) ; ( sslinsecur renegoti ) { boolean legaci reneg support = fals ; try { legaci reneg support = ssl . ha op ( ssl . ssl op allow unsaf legaci renegoti ) ; ( legaci reneg support ) sslcontext . set option ( ssl context , ssl . ssl op allow unsaf legaci renegoti ) ; } catch ( unsatisfi link error e ) { ignor } ( legaci reneg support ) { open ssl doe support unsaf legaci renegoti . log . warn ( sm . get string ( endpoint . warn . insecur reneg , ssl . version string ( ) ) ) ; } } list cipher client permit negoti sslcontext . set cipher suit ( ssl context , sslcipher suit ) ; load server kei certif sslcontext . set certif ( ssl context , sslcertif file , sslcertif kei file , sslpassword , ssl . ssl aidx rsa ) ; set certif chain file sslcontext . set certif chain file ( ssl context , sslcertif chain file , fals ) ; support client certif sslcontext . set cacertif ( ssl context , sslcacertif file , sslcacertif path ) ; set revoc sslcontext . set carevoc ( ssl context , sslcarevoc file , sslcarevoc path ) ; client certif verif valu = ssl . ssl cverifi none ; ( option . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi option ; } els ( requir . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi requir ; } els ( option ca . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi option ca ; } sslcontext . set verifi ( ssl context , valu , sslverifi depth ) ; now , sendfil support ssl us sendfil = fals ; } initi = true ; }	public kei manag wrap ( kei manag manag ) { ( manag = = null ) return null ; kei manag result = new kei manag manag . length ; ( int i = 0 ; i result . length ; i ) { ( manag i instanceof x509kei manag get kei alia ( ) = null ) { result i = new nio x509kei manag ( ( x509kei manag ) manag i , get kei alia ( ) ) ; } els { result i = manag i ; } } return result ; }	public paus endpoint , which make stop accept new socket . void paus ( ) { ( run paus ) { paus = true ; unlock accept ( ) ; } }	public paus endpoint , which make stop accept new socket . void paus ( ) { ( run paus ) { paus = true ; unlock accept ( ) ; } }	public start apr endpoint , creat acceptor , poller sendfil thread . void start ( ) throw except { initi socket done befor ( initi ) { init ( ) ; } ( run ) { run = true ; paus = fals ; creat worker collect ( get executor ( ) = = null ) { creat executor ( ) ; } start poller thread poller = new poller poller thread count ; ( int i = 0 ; i poller thread count ; i ) { poller i = new poller ( fals ) ; poller i . init ( ) ; thread poller thread = new thread ( poller i , get name ( ) poller i ) ; poller thread . set prioriti ( thread prioriti ) ; poller thread . set daemon ( true ) ; poller thread . start ( ) ; } start comet poller thread comet poller = new poller poller thread count ; ( int i = 0 ; i poller thread count ; i ) { comet poller i = new poller ( true ) ; comet poller i . init ( ) ; thread poller thread = new thread ( comet poller i , get name ( ) comet poller i ) ; poller thread . set prioriti ( thread prioriti ) ; poller thread . set daemon ( true ) ; poller thread . start ( ) ; } start sendfil thread ( us sendfil ) { sendfil = new sendfil sendfil thread count ; ( int i = 0 ; i sendfil thread count ; i ) { sendfil i = new sendfil ( ) ; sendfil i . init ( ) ; thread sendfil thread = new thread ( sendfil i , get name ( ) sendfil i ) ; sendfil thread . set prioriti ( thread prioriti ) ; sendfil thread . set daemon ( true ) ; sendfil thread . start ( ) ; } } start acceptor thread ( int i = 0 ; i acceptor thread count ; i ) { thread acceptor thread = new thread ( new acceptor ( ) , get name ( ) acceptor i ) ; acceptor thread . set prioriti ( thread prioriti ) ; acceptor thread . set daemon ( get daemon ( ) ) ; acceptor thread . start ( ) ; } } }	public start nio endpoint , creat acceptor , poller thread . void start ( ) throw except { initi socket done befor ( initi ) { init ( ) ; } ( run ) { run = true ; paus = fals ; creat worker collect ( get executor ( ) = = null ) { creat executor ( ) ; } start poller thread poller = new poller get poller thread count ( ) ; ( int i = 0 ; i poller . length ; i ) { poller i = new poller ( ) ; thread poller thread = new thread ( poller i , get name ( ) client poller i ) ; poller thread . set prioriti ( thread prioriti ) ; poller thread . set daemon ( true ) ; poller thread . start ( ) ; } start acceptor thread ( int i = 0 ; i acceptor thread count ; i ) { thread acceptor thread = new thread ( new acceptor ( ) , get name ( ) acceptor i ) ; acceptor thread . set prioriti ( thread prioriti ) ; acceptor thread . set daemon ( get daemon ( ) ) ; acceptor thread . start ( ) ; } } }	public stop endpoint . thi caus all process thread stop . void stop ( ) { ( run ) { run = fals ; unlock accept ( ) ; ( int i = 0 ; i poller . length ; i ) { poller i . destroi ( ) ; } poller = null ; ( int i = 0 ; i comet poller . length ; i ) { comet poller i . destroi ( ) ; } comet poller = null ; ( us sendfil ) { ( int i = 0 ; i sendfil . length ; i ) { sendfil i . destroi ( ) ; } sendfil = null ; } } shutdown executor ( ) ; }	public stop endpoint . thi caus all process thread stop . void stop ( ) { ( run ) { run = fals ; unlock accept ( ) ; ( int i = 0 ; poller = null i poller . length ; i ) { ( poller i = = null ) continu ; poller i . destroi ( ) ; poller i = null ; } try { stop latch . await ( selector timeout 100 , time unit . millisecond ) ; } catch ( interrupt except ignor ) { } } event cach . clear ( ) ; kei cach . clear ( ) ; nio channel . clear ( ) ; processor cach . clear ( ) ; shutdown executor ( ) ; }
public creat new standard context . param parent mbean name associ parent compon param path context path thi context param doc base document base directori ( war ) thi context except except mbean cannot creat regist string creat standard context ( string parent , string path , string doc base , boolean xml valid , boolean xml namespac awar , boolean tld valid , boolean tld namespac awar ) throw except { creat new standard context instanc standard context context = new standard context ( ) ; path = get path str ( path ) ; context . set path ( path ) ; context . set doc base ( doc base ) ; context . set xml valid ( xml valid ) ; context . set xml namespac awar ( xml namespac awar ) ; context . set tld valid ( tld valid ) ; context . set tld namespac awar ( tld namespac awar ) ; context config context config = new context config ( ) ; context . add lifecycl listen ( context config ) ; add new instanc parent compon object name pname = new object name ( parent ) ; object name deploy = new object name ( pname . get domain ( ) : type = deploy , host = pname . get kei properti ( host ) ) ; ( mserver . regist ( deploy ) ) { string context path = context . get path ( ) ; mserver . invok ( deploy , add servic , new object { context path } , new string { java . lang . string } ) ; string config path = ( string ) mserver . get attribut ( deploy , config base name ) ; string base name = get config file ( context path ) ; file config file = new file ( new file ( config path ) , base name . xml ) ; context . set config file ( config file . uri ( ) . url ( ) ) ; mserver . invok ( deploy , manag app , new object { context } , new string { org . apach . catalina . context } ) ; mserver . invok ( deploy , remov servic , new object { context path } , new string { java . lang . string } ) ; } els { log . warn ( deploy found pname . get kei properti ( host ) ) ; servic servic = get servic ( pname ) ; engin engin = ( engin ) servic . get contain ( ) ; host host = ( host ) engin . find child ( pname . get kei properti ( host ) ) ; host . add child ( context ) ; } return correspond mbean name object name onam = context . get jmx name ( ) ; return ( onam . string ( ) ) ; }	public creat new standard host . param parent mbean name associ parent compon param name uniqu name thi host param app base applic base directori name param auto deploi should we auto deploi param deploi startup deploi server startup param deploi xml should we deploi context xml config file properti param unpack war should we unpack war when auto deploi param xml namespac awar should we turn off xml namespac awar param xml valid should we turn off xml valid except except mbean cannot creat regist string creat standard host ( string parent , string name , string app base , boolean auto deploi , boolean deploi startup , boolean deploi xml , boolean unpack war , boolean xml namespac awar , boolean xml valid ) throw except { creat new standard host instanc standard host host = new standard host ( ) ; host . set name ( name ) ; host . set app base ( app base ) ; host . set auto deploi ( auto deploi ) ; host . set deploi startup ( deploi startup ) ; host . set deploi xml ( deploi xml ) ; host . set unpack war ( unpack war ) ; host . set xml namespac awar ( xml namespac awar ) ; host . set xml valid ( xml valid ) ; add host config activ reload host config host config = new host config ( ) ; host . add lifecycl listen ( host config ) ; add new instanc parent compon object name pname = new object name ( parent ) ; servic servic = get servic ( pname ) ; engin engin = ( engin ) servic . get contain ( ) ; engin . add child ( host ) ; return correspond mbean name return ( host . get object name ( ) . string ( ) ) ; }	public remov exist realm . param name mbean name compon remov except except compon cannot remov void remov realm ( string name ) throw except { object name onam = new object name ( name ) ; acquir refer compon remov contain base contain = get parent contain from child ( onam ) ; contain . set realm ( null ) ; }

protect load ani current activ session were previous unload appropri persist mechan , ani . persist support , thi method return without do anyth . except class found except serial class cannot found dure reload except ioexcept input output error occur void do load ( ) throw class found except , ioexcept { ( log . debug enabl ( ) ) log . debug ( start : load persist session ) ; initi our intern data structur session . clear ( ) ; open input stream specifi pathnam , ani file file = file ( ) ; ( file = = null ) return ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( standard manag . load , pathnam ) ) ; file input stream fi = null ; buffer input stream bi = null ; object input stream oi = null ; loader loader = null ; class loader class loader = null ; try { fi = new file input stream ( file . get absolut path ( ) ) ; bi = new buffer input stream ( fi ) ; ( contain = null ) loader = contain . get loader ( ) ; ( loader = null ) class loader = loader . get class loader ( ) ; ( class loader = null ) { ( log . debug enabl ( ) ) log . debug ( creat custom object input stream class loader ) ; oi = new custom object input stream ( bi , class loader ) ; } els { ( log . debug enabl ( ) ) log . debug ( creat standard object input stream ) ; oi = new object input stream ( bi ) ; } } catch ( file found except e ) { ( log . debug enabl ( ) ) log . debug ( persist data file found ) ; return ; } catch ( ioexcept e ) { log . error ( sm . get string ( standard manag . load . ioe , e ) , e ) ; ( fi = null ) { try { fi . close ( ) ; } catch ( ioexcept f ) { ignor } } ( bi = null ) { try { bi . close ( ) ; } catch ( ioexcept f ) { ignor } } throw e ; } load previous unload activ session synchron ( session ) { try { integ count = ( integ ) oi . read object ( ) ; int n = count . int valu ( ) ; ( log . debug enabl ( ) ) log . debug ( load n persist session ) ; ( int i = 0 ; i n ; i ) { standard session session = get new session ( ) ; session . read object data ( oi ) ; session . set manag ( thi ) ; session . put ( session . get id intern ( ) , session ) ; session . activ ( ) ; session counter ; } } catch ( class found except e ) { log . error ( sm . get string ( standard manag . load . cnfe , e ) , e ) ; try { oi . close ( ) ; } catch ( ioexcept f ) { ignor } throw e ; } catch ( ioexcept e ) { log . error ( sm . get string ( standard manag . load . ioe , e ) , e ) ; try { oi . close ( ) ; } catch ( ioexcept f ) { ignor } throw e ; } final { close input stream try { oi . close ( ) ; } catch ( ioexcept f ) { ignor } delet persist storag file ( file . exist ( ) ) file . delet ( ) ; } } ( log . debug enabl ( ) ) log . debug ( finish : load persist session ) ; }


protect return distinguish name search result . param context our dir context param base base dn param result search result return string contain distinguish name string get distinguish name ( dir context context , string base , search result result ) throw name except { result name . non rel name , us return name . ( result . rel ( ) ) { ( contain log . trace enabl ( ) ) { contain log . trace ( search return rel name : result . get name ( ) ) ; } name parser parser = context . get name parser ( ) ; name context name = parser . pars ( context . get name namespac ( ) ) ; name base name = parser . pars ( base ) ; bugzilla 32269 name entri name = parser . pars ( new composit name ( result . get name ( ) ) . get ( 0 ) ) ; name name = context name . add all ( base name ) ; name = name . add all ( entri name ) ; return name . string ( ) ; } els { string absolut name = result . get name ( ) ; ( contain log . trace enabl ( ) ) contain log . trace ( search return absolut name : result . get name ( ) ) ; try { normal name run through name parser . name parser parser = context . get name parser ( ) ; uri user name uri = new uri ( absolut name ) ; string path compon = user name uri . get path ( ) ; should ever have empti path compon , sinc { dn } ( path compon . length ( ) 1 ) { throw new invalid name except ( search return unpars absolut name : absolut name ) ; } name name = parser . pars ( path compon . substr ( 1 ) ) ; return name . string ( ) ; } catch ( urisyntax except e ) { throw new invalid name except ( search return unpars absolut name : absolut name ) ; } } }	protect string get distinguish name ( dir context context , string base , search result result ) throw name except { result name . non rel name , us return name . ( result . rel ( ) ) { ( contain log . trace enabl ( ) ) { contain log . trace ( search return rel name : result . get name ( ) ) ; } name parser parser = context . get name parser ( ) ; name context name = parser . pars ( context . get name namespac ( ) ) ; name base name = parser . pars ( base ) ; bugzilla 32269 name entri name = parser . pars ( new composit name ( result . get name ( ) ) . get ( 0 ) ) ; name name = context name . add all ( base name ) ; name = name . add all ( entri name ) ; return name . string ( ) ; } els { string absolut name = result . get name ( ) ; ( contain log . trace enabl ( ) ) contain log . trace ( search return absolut name : result . get name ( ) ) ; try { normal name run through name parser . name parser parser = context . get name parser ( ) ; uri user name uri = new uri ( absolut name ) ; string path compon = user name uri . get path ( ) ; should ever have empti path compon , sinc { dn } ( path compon . length ( ) 1 ) { throw new invalid name except ( search return unpars absolut name : absolut name ) ; } name name = parser . pars ( path compon . substr ( 1 ) ) ; return name . string ( ) ; } catch ( urisyntax except e ) { throw new invalid name except ( search return unpars absolut name : absolut name ) ; } } }
session inform web applic specifi context path . displai profil session thi access time list number session each 10 minut interv up 10 hour . param writer writer render param path context path applic list session inform param idl expir all session idl time gt ; idl thi context protect void session ( print writer writer , string path , int idl ) { ( debug = 1 ) { log ( session : session inform web applic path ) ; ( idl = 0 ) log ( session : session expir idl minut path ) ; } ( ( path = = null ) ( path . start ( ) path . equal ( ) ) ) { writer . println ( sm . get string ( manag servlet . invalid path , request util . filter ( path ) ) ) ; return ; } string displai path = path ; ( path . equal ( ) ) path = ; try { context context = ( context ) host . find child ( path ) ; ( context = = null ) { writer . println ( sm . get string ( manag servlet . context , request util . filter ( displai path ) ) ) ; return ; } manag manag = context . get manag ( ) ; ( manag = = null ) { writer . println ( sm . get string ( manag servlet . manag , request util . filter ( displai path ) ) ) ; return ; } int max count = 60 ; int max inact interv = manag . get max inact interv ( ) 60 ; int histo interv = max inact interv max count ; ( histo interv max count max inact interv ) histo interv ; ( 0 = = histo interv ) histo interv = 1 ; max count = max inact interv histo interv ; ( histo interv max count max inact interv ) max count ; writer . println ( sm . get string ( manag servlet . session , displai path ) ) ; writer . println ( sm . get string ( manag servlet . sessiondefaultmax , max inact interv ) ) ; session session = manag . find session ( ) ; int timeout = new int max count ; int notimeout = 0 ; int expir = 0 ; long now = system . current time milli ( ) ; ( int i = 0 ; i session . length ; i ) { int time = ( int ) ( ( now session i . get thi access time intern ( ) ) 1000 ) ; ( idl = 0 time = idl 60 ) { session i . expir ( ) ; idl ; } time = time 60 histo interv ; ( time 0 ) notimeout ; } } }
public background thread listen incom tcp ip connect hand them off appropri processor . void run ( ) { long maintain time = 0 ; loop until we receiv shutdown command while ( run ) { loop endpoint paus while ( paus ) { try { thread . sleep ( 1000 ) ; } catch ( interrupt except e ) { ignor } } while ( keep aliv count 1 add count 1 ) { reset maintain time . maintain time = 0 ; try { synchron ( thi ) { thi . wait ( ) ; } } catch ( interrupt except e ) { ignor } } try { add socket which ar wait poller ( add count 0 ) { synchron ( thi ) { ( int i = ( add count 1 ) ; i = 0 ; i ) { int rv = poll . add ( server pollset , add s i , poll . apr pollin ) ; ( rv = = statu . apr success ) { keep aliv count ; } els { can t do anyth : close socket right awai ( comet ) { process socket ( add s i , socket statu . error ) ; } els { socket . destroi ( add s i ) ; } } } add count = 0 ; } } maintain time = poll time ; pool specifi interv int rv = poll . poll ( server pollset , poll time , desc , true ) ; ( rv 0 ) { keep aliv count = rv ; ( int n = 0 ; n rv ; n ) { check fail socket hand thi socket off worker ( ( ( desc n 2 poll . apr pollhup ) = = poll . apr pollhup ) ( ( desc n 2 poll . apr pollerr ) = = poll . apr pollerr ) ( comet ( process socket ( desc n 2 1 , socket statu . open ) ) ) ( comet ( process socket ( desc n 2 1 ) ) ) ) { close socket clear pool ( comet ) { process socket ( desc n 2 1 , socket statu . disconnect ) ; } els { socket . destroi ( desc n 2 1 ) ; } continu ; } } } els ( rv 0 ) { int errn = rv ; ani non timeup interrupt error critic ( ( errn = statu . timeup ) ( errn = statu . eintr ) ) { ( errn statu . apr os start usererr ) { errn = statu . apr os start usererr ; } log . error ( sm . get string ( endpoint . poll . fail , errn , error . strerror ( errn ) ) ) ; handl poll critic failur synchron ( thi ) { destroi ( ) ; init ( ) ; } continu ; } } ( socket properti . get so timeout ( ) 0 maintain time 1000000l run ) { rv = poll . maintain ( server pollset , desc , true ) ; maintain time = 0 ; ( rv 0 ) { keep aliv count = rv ; ( int n = 0 ; n rv ; n ) { close socket clear pool ( comet ) { process socket ( desc n , socket statu . timeout ) ; } els { socket . destroi ( desc n ) ; } } } } } catch ( throwabl t ) { log . error ( sm . get string ( endpoint . poll . error ) , t ) ; } } synchron ( thi ) { thi . notifi all ( ) ; } }

public void do filter ( http servlet request request , http servlet respons respons , filter chain chain ) throw ioexcept , servlet except { ( match ( request . get remot addr ( ) , intern proxi ) ) { string remot ip = null ; java 6 , proxi header valu should declar java . util . dequ link list string proxi header valu = new link list string ( ) ; string remot iphead valu = comma delimit list string arrai ( request . get header ( remot iphead ) ) ; int idx ; loop remot iphead valu find first trust remot ip build proxi chain ( idx = remot iphead valu . length 1 ; idx = 0 ; idx ) { string current remot ip = remot iphead valu idx ; remot ip = current remot ip ; ( match ( current remot ip , intern proxi ) ) { do noth , intern proxi ip ar append } els ( match ( current remot ip , trust proxi ) ) { proxi header valu . add first ( current remot ip ) ; } els { decrement idx becaus break statement doesn t do idx ; break ; } } continu loop remot iphead valu build new valu remot iphead link list string new remot ip header valu = new link list string ( ) ; ( ; idx = 0 ; idx ) { string current remot ip = remot iphead valu idx ; new remot ip header valu . add first ( current remot ip ) ; } xforward request x request = new xforward request ( request ) ; ( remot ip = null ) { x request . set remot addr ( remot ip ) ; x request . set remot host ( remot ip ) ; ( proxi header valu . size ( ) = = 0 ) { x request . remov header ( proxi header ) ; } els { string comma delimit list proxi = list comma delimit string ( proxi header valu ) ; x request . set header ( proxi header , comma delimit list proxi ) ; } ( new remot ip header valu . size ( ) = = 0 ) { x request . remov header ( remot iphead ) ; } els { string comma delimit remot ip header valu = list comma delimit string ( new remot ip header valu ) ; x request . set header ( remot iphead , comma delimit remot ip header valu ) ; } } ( protocol header = null ) { string protocol header valu = request . get header ( protocol header ) ; ( protocol header valu = = null ) { don t modifi secur , scheme server port attribut request } els ( protocol header http valu . equal ignor case ( protocol header valu ) ) { x request . set secur ( true ) ; x request . set scheme ( http ) ; x request . set server port ( http server port ) ; } els { x request . set secur ( fals ) ; x request . set scheme ( http ) ; x request . set server port ( http server port ) ; } } ( log . debug enabl ( ) ) { log . debug ( incom request request . get request uri ( ) origin remot addr request . get remot addr ( ) , origin remot host = request . get remot host ( ) , origin secur = request . secur ( ) , origin scheme = request . get scheme ( ) , origin remot iphead = request . get header ( remot iphead ) , origin protocol header = ( protocol header = = null null : request . get header ( protocol header ) ) seen new remot addr = x request . get remot addr ( ) , new remot host = x request . get remot host ( ) , new scheme = x request . get scheme ( ) , new secur = x request . secur ( ) , new remot iphead = x request . get header ( remot iphead ) , new proxi header = x request . get header ( proxi header ) ) ; } chain . do filter ( x request , respons ) ; } els { chain . do filter ( request , respons ) ; } }	{ inherit doc } overrid public void invok ( request request , respons respons ) throw ioexcept , servlet except { final string origin remot addr = request . get remot addr ( ) ; final string origin remot host = request . get remot host ( ) ; final string origin scheme = request . get scheme ( ) ; final boolean origin secur = request . secur ( ) ; final int origin server port = request . get server port ( ) ; ( match ( origin remot addr , intern proxi ) ) { string remot ip = null ; java 6 , proxi header valu should declar java . util . dequ link list string proxi header valu = new link list string ( ) ; string remot iphead valu = comma delimit list string arrai ( request . get header ( remot ip header ) ) ; int idx ; loop remot iphead valu find first trust remot ip build proxi chain ( idx = remot iphead valu . length 1 ; idx = 0 ; idx ) { string current remot ip = remot iphead valu idx ; remot ip = current remot ip ; ( match ( current remot ip , intern proxi ) ) { do noth , intern proxi ip ar append } els ( match ( current remot ip , trust proxi ) ) { proxi header valu . add first ( current remot ip ) ; } els { decrement idx becaus break statement doesn t do idx ; break ; } } continu loop remot iphead valu build new valu remot iphead link list string new remot ip header valu = new link list string ( ) ; ( ; idx = 0 ; idx ) { string current remot ip = remot iphead valu idx ; new remot ip header valu . add first ( current remot ip ) ; } ( remot ip = null ) { request . set remot addr ( remot ip ) ; request . set remot host ( remot ip ) ; 6 . 0 ( proxi header valu . size ( ) = = 0 ) { request . get coyot request ( ) . get mime header ( ) . remov header ( proxi header ) ; } els { string comma delimit list proxi = list comma delimit string ( proxi header valu ) ; request . get coyot request ( ) . get mime header ( ) . set valu ( proxi header ) . set string ( comma delimit list proxi ) ; } ( new remot ip header valu . size ( ) = = 0 ) { request . get coyot request ( ) . get mime header ( ) . remov header ( remot ip header ) ; } els { string comma delimit remot ip header valu = list comma delimit string ( new remot ip header valu ) ; request . get coyot request ( ) . get mime header ( ) . set valu ( remot ip header ) . set string ( comma delimit remot ip header valu ) ; } } ( protocol header = null ) { string protocol header valu = request . get header ( protocol header ) ; ( protocol header valu = = null ) { don t modifi secur , scheme server port attribut request } els ( protocol header http valu . equal ignor case ( protocol header valu ) ) { request . set secur ( true ) ; us request . coyot request . scheme instead request . set scheme ( ) becaus request . set scheme ( ) op tomcat 6 . 0 request . get coyot request ( ) . scheme ( ) . set string ( http ) ; request . set server port ( http server port ) ; } els { request . set secur ( fals ) ; us request . coyot request . scheme instead request . set scheme ( ) becaus request . set scheme ( ) op tomcat 6 . 0 request . get coyot request ( ) . scheme ( ) . set string ( http ) ; request . set server port ( http server port ) ; } } ( log . debug enabl ( ) ) { log . debug ( incom request request . get request uri ( ) origin remot addr origin remot addr , origin remot host = origin remot host , origin secur = origin secur , origin scheme = origin scheme seen new remot addr = request . get remot addr ( ) , new remot host = request . get remot host ( ) , new scheme = request . get scheme ( ) , new secur = request . secur ( ) ) ; } } try { get next ( ) . invok ( request , respons ) ; } final { request . set remot addr ( origin remot addr ) ; request . set remot host ( origin remot host ) ; request . set secur ( origin secur ) ; us request . coyot request . scheme instead request . set scheme ( ) becaus request . set scheme ( ) op tomcat 6 . 0 request . get coyot request ( ) . scheme ( ) . set string ( origin scheme ) ; request . set server port ( origin server port ) ; } }
privat thread get thread ( ) { get current thread group thread group tg = thread . current thread ( ) . get thread group ( ) ; find root thread group while ( tg . get parent ( ) = null ) { tg = tg . get parent ( ) ; } int thread count guess = tg . activ count ( ) 50 ; thread thread = new thread thread count guess ; int thread count actual = tg . enumer ( thread ) ; make sure we don t miss ani thread while ( thread count actual = = thread count guess ) { thread count guess = 2 ; thread = new thread thread count guess ; note tg . enumer ( thread ) silent ignor ani thread can t fit arrai thread count actual = tg . enumer ( thread ) ; } return thread ; }	start associ { link class loader } implement requir { link lifecycl base start intern ( ) } . except lifecycl except thi compon detect fatal error prevent thi compon from us overrid protect void start intern ( ) throw lifecycl except { ( initi ) init ( ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( webapp loader . start ) ) ; ( contain . get resourc ( ) = = null ) { log . info ( resourc contain ) ; set state ( lifecycl state . start ) ; return ; } regist stream handler factori jndi protocol urlstream handler factori stream handler factori = new dir context urlstream handler factori ( ) ; ( first ) { first = fals ; try { url . set urlstream handler factori ( stream handler factori ) ; } catch ( except e ) { log continu anywai , thi critic log . error ( error regist jndi stream handler , e ) ; } catch ( throwabl t ) { thi like dual registr log . info ( dual registr jndi stream handler : t . get messag ( ) ) ; } } construct class loader base our current repositori list try { class loader = creat class loader ( ) ; class loader . set resourc ( contain . get resourc ( ) ) ; class loader . set deleg ( thi . deleg ) ; ( contain instanceof standard context ) { class loader . set anti jarlock ( ( ( standard context ) contain ) . get anti jarlock ( ) ) ; class loader . set clear refer static ( ( ( standard context ) contain ) . get clear refer static ( ) ) ; class loader . set clear refer stop thread ( ( ( standard context ) contain ) . get clear refer stop thread ( ) ) ; } ( int i = 0 ; i repositori . length ; i ) { class loader . add repositori ( repositori i ) ; } configur our repositori set repositori ( ) ; set class path ( ) ; set permiss ( ) ; ( ( lifecycl ) class loader ) . start ( ) ; bind webapp class loader directori context dir context urlstream handler . bind ( class loader , thi . contain . get resourc ( ) ) ; standard context ctx = ( standard context ) contain ; string path = ctx . get path ( ) ; ( path . equal ( ) ) { path = ; } object name clonam = new object name ( ctx . get engin name ( ) : type = webapp class loader , path = path , host = ctx . get parent ( ) . get name ( ) ) ; registri . get registri ( null , null ) . regist compon ( class loader , clonam , null ) ; } catch ( throwabl t ) { log . error ( lifecycl except , t ) ; throw new lifecycl except ( start : , t ) ; } set state ( lifecycl state . start ) ; }	public return clear refer log factori releas flag thi context . boolean get clear refer log factori releas ( ) { return ( thi . clear refer log factori releas ) ; }	public set clear refer stop thread featur thi context . param clear refer stop thread new flag valu void set clear refer stop thread ( boolean clear refer stop thread ) { boolean old clear refer stop thread = thi . clear refer stop thread ; thi . clear refer stop thread = clear refer stop thread ; support . fire properti chang ( clear refer stop thread , old clear refer stop thread , thi . clear refer stop thread ) ; }
protect byte serial session ( session current session ) throw ioexcept { open output stream specifi pathnam , ani byte arrai output stream fo = null ; object output stream oo = null ; try { fo = new byte arrai output stream ( ) ; oo = new object output stream ( new buffer output stream ( fo ) ) ; oo . write object ( new integ ( current session . length ) ) ; ( int i = 0 ; i current session . length ; i ) { ( ( delta session ) current session i ) . write object data ( oo ) ; } flush close output stream oo . flush ( ) ; } catch ( ioexcept e ) { log . error ( sm . get string ( delta manag . unload . ioe , e ) , e ) ; throw e ; } final { ( oo = null ) { try { oo . close ( ) ; } catch ( ioexcept f ) { ignor } oo = null ; } } send object data byte return fo . byte arrai ( ) ; }
protect process default configur file , exist . void context config ( ) { open default web . xml file , exist ( default context xml = = null context instanceof standard context ) { default context xml = ( ( standard context ) context ) . get default context xml ( ) ; } set default we don t have ani overrid ( default context xml = = null ) get default context xml ( ) ; ( context . get overrid ( ) ) { process context config ( new file ( get base dir ( ) ) , default context xml ) ; process context config ( get config base ( ) , get host config path ( constant . host context xml ) ) ; } ( context . get config file ( ) = null ) process context config ( new file ( context . get config file ( ) ) , null ) ; }	protect param context path param context xml param file void deploi descriptor ( string context path , file context xml , string file ) { ( deploy exist ( context path ) ) { return ; } deploi applic deploi app = new deploi applic ( context path ) ; assum thi configur descriptor deploi ( log . info enabl ( ) ) { log . info ( sm . get string ( host config . deploi descriptor , file , config base . get path ( ) ) ) ; } context context = null ; try { synchron ( digest ) { try { context = ( context ) digest . pars ( context xml ) ; ( context = = null ) { log . error ( sm . get string ( host config . deploi descriptor . error , file ) ) ; return ; } } final { digest . reset ( ) ; } } class clazz = class . name ( host . get config class ( ) ) ; lifecycl listen listen = ( lifecycl listen ) clazz . new instanc ( ) ; context . add lifecycl listen ( listen ) ; context . set config file ( context xml . get absolut path ( ) ) ; context . set path ( context path ) ; add associ doc base redeploi list s war boolean extern war = fals ; boolean extern = fals ; ( context . get doc base ( ) = null ) { file doc base = new file ( context . get doc base ( ) ) ; ( doc base . absolut ( ) ) { doc base = new file ( app base ( ) , context . get doc base ( ) ) ; } extern doc base , regist . xml redeploi first ( doc base . get canon path ( ) . start ( app base ( ) . get absolut path ( ) file . separ ) ) { extern = true ; deploi app . redeploi resourc . put ( context xml . get absolut path ( ) , new long ( context xml . last modifi ( ) ) ) ; deploi app . redeploi resourc . put ( doc base . get absolut path ( ) , new long ( doc base . last modifi ( ) ) ) ; ( doc base . get absolut path ( ) . lower case ( ) . end ( . war ) ) { extern war = true ; } } els { log . warn ( sm . get string ( host config . deploi descriptor . local doc base specifi , doc base ) ) ; ignor specifi doc base context . set doc base ( null ) ; } } host . add child ( context ) ; get path war expand war app base string name = null ; string path = context . get path ( ) ; ( path . equal ( ) ) { name = root ; } els { ( path . start ( ) ) { name = path . substr ( 1 ) ; } els { name = path ; } } default app base dir name file expand doc base = new file ( app base ( ) , name ) ; ( context . get doc base ( ) = null ) { first assum doc base absolut expand doc base = new file ( context . get doc base ( ) ) ; ( expand doc base . absolut ( ) ) { doc base specifi rel , must rel app base expand doc base = new file ( app base ( ) , context . get doc base ( ) ) ; } } watch insid ( extern war unpack war ) { deploi app . redeploi resourc . put ( expand doc base . get absolut path ( ) , new long ( expand doc base . last modifi ( ) ) ) ; deploi app . redeploi resourc . put ( context xml . get absolut path ( ) , new long ( context xml . last modifi ( ) ) ) ; add watch resourc ( deploi app , expand doc base . get absolut path ( ) , context ) ; } els { find exist match war expand folder ( extern ) { file war doc base = new file ( expand doc base . get absolut path ( ) . war ) ; ( war doc base . exist ( ) ) { deploi app . redeploi resourc . put ( war doc base . get absolut path ( ) , new long ( war doc base . last modifi ( ) ) ) ; } } ( expand doc base . exist ( ) ) { deploi app . redeploi resourc . put ( expand doc base . get absolut path ( ) , new long ( expand doc base . last modifi ( ) ) ) ; add watch resourc ( deploi app , expand doc base . get absolut path ( ) , context ) ; } els { add watch resourc ( deploi app , null , context ) ; } add context xml list file which should trigger redeploy ( extern ) { deploi app . redeploi resourc . put ( context xml . get absolut path ( ) , new long ( context xml . last modifi ( ) ) ) ; } } } catch ( throwabl t ) { log . error ( sm . get string ( host config . deploi descriptor . error , file ) , t ) ; } ( context = null host . find child ( context . get name ( ) ) = null ) { deploi . put ( context path , deploi app ) ; } }	protect param context path param dir param file void deploi directori ( string context path , file dir , string file ) { deploi applic deploi app = new deploi applic ( context path ) ; ( deploy exist ( context path ) ) return ; deploi applic thi directori ( log . info enabl ( ) ) log . info ( sm . get string ( host config . deploi dir , file ) ) ; try { context context = null ; file xml = new file ( dir , constant . applic context xml ) ; file xml copi = null ; ( deploi xml xml . exist ( ) ) { deploi descriptor ( ) instead synchron ( digest ) { try { context = ( context ) digest . pars ( xml ) ; ( context = = null ) { log . error ( sm . get string ( host config . deploi descriptor . error , xml ) ) ; return ; } } final { digest . reset ( ) ; } } xml copi = new file ( config base ( ) , file . xml ) ; input stream = null ; output stream os = null ; try { = new file input stream ( xml ) ; os = new file output stream ( xml copi ) ; iotool . flow ( , os ) ; don t catch ioe let outer try catch handl } final { try { ( = null ) . close ( ) ; } catch ( ioexcept e ) { ignor } try { ( os = null ) os . close ( ) ; } catch ( ioexcept e ) { ignor } } context . set config file ( xml copi . get absolut path ( ) ) ; } els { context = ( context ) class . name ( context class ) . new instanc ( ) ; } class clazz = class . name ( host . get config class ( ) ) ; lifecycl listen listen = ( lifecycl listen ) clazz . new instanc ( ) ; context . add lifecycl listen ( listen ) ; context . set path ( context path ) ; context . set doc base ( file ) ; host . add child ( context ) ; deploi app . redeploi resourc . put ( dir . get absolut path ( ) , new long ( dir . last modifi ( ) ) ) ; ( xml copi = null ) { deploi app . redeploi resourc . put ( xml copi . get absolut path ( ) , new long ( xml copi . last modifi ( ) ) ) ; } add watch resourc ( deploi app , dir . get absolut path ( ) , context ) ; } catch ( throwabl t ) { log . error ( sm . get string ( host config . deploi dir . error , file ) , t ) ; } deploi . put ( context path , deploi app ) ; }	protect param context path param war param file void deploi war ( string context path , file war , string file ) { ( deploy exist ( context path ) ) return ; check nest meta inf context . xml jar file jar = null ; jar entri entri = null ; input stream istream = null ; buffer output stream ostream = null ; file xml = new file ( config base ( ) , file . substr ( 0 , file . last index ( . ) ) . xml ) ; ( deploi xml xml . exist ( ) ) { try { jar = new jar file ( war ) ; entri = jar . get jar entri ( constant . applic context xml ) ; ( entri = null ) { istream = jar . get input stream ( entri ) ; ostream = new buffer output stream ( new file output stream ( xml ) , 1024 ) ; byte buffer = new byte 1024 ; while ( true ) { int n = istream . read ( buffer ) ; ( n 0 ) { break ; } ostream . write ( buffer , 0 , n ) ; } ostream . flush ( ) ; ostream . close ( ) ; ostream = null ; istream . close ( ) ; istream = null ; } } catch ( except e ) { ignor continu ( ostream = null ) { try { ostream . close ( ) ; } catch ( throwabl t ) { ignor } ostream = null ; } ( istream = null ) { try { istream . close ( ) ; } catch ( throwabl t ) { ignor } istream = null ; } } final { entri = null ; ( jar = null ) { try { jar . close ( ) ; } catch ( throwabl t ) { ignor } jar = null ; } } } deploi applic deploi app = new deploi applic ( context path ) ; deploi applic thi war file ( log . info enabl ( ) ) log . info ( sm . get string ( host config . deploi war , file ) ) ; try { context context = null ; ( deploi xml xml . exist ( ) ) { synchron ( digest ) { try { context = ( context ) digest . pars ( xml ) ; ( context = = null ) { log . error ( sm . get string ( host config . deploi descriptor . error , file ) ) ; return ; } } final { digest . reset ( ) ; } } context . set config file ( xml . get absolut path ( ) ) ; } els { context = ( context ) class . name ( context class ) . new instanc ( ) ; } popul redeploi resourc war file deploi app . redeploi resourc . put ( war . get absolut path ( ) , new long ( war . last modifi ( ) ) ) ; ( deploi xml xml . exist ( ) ) { deploi app . redeploi resourc . put ( xml . get absolut path ( ) , new long ( xml . last modifi ( ) ) ) ; } class clazz = class . name ( host . get config class ( ) ) ; lifecycl listen listen = ( lifecycl listen ) clazz . new instanc ( ) ; context . add lifecycl listen ( listen ) ; context . set path ( context path ) ; context . set doc base ( file ) ; host . add child ( context ) ; start context ( unpack war ( context . get doc base ( ) = null ) ) { string name = null ; string path = context . get path ( ) ; ( path . equal ( ) ) { name = root ; } els { ( path . start ( ) ) { name = path . substr ( 1 ) ; } els { name = path ; } } name = name . replac ( , ) ; file doc base = new file ( name ) ; ( doc base . absolut ( ) ) { doc base = new file ( app base ( ) , name ) ; } deploi app . redeploi resourc . put ( doc base . get absolut path ( ) , new long ( doc base . last modifi ( ) ) ) ; add watch resourc ( deploi app , doc base . get absolut path ( ) , context ) ; } els { add watch resourc ( deploi app , null , context ) ; } } catch ( throwabl t ) { log . error ( sm . get string ( host config . deploi war . error , file ) , t ) ; } deploi . put ( context path , deploi app ) ; }	protect process context . xml . void process context config ( file base dir , string resourc name ) { ( log . debug enabl ( ) ) log . debug ( process context context . get name ( ) configur file base dir resourc name ) ; input sourc sourc = null ; input stream stream = null ; file file = base dir ; ( resourc name = null ) { file = new file ( base dir , resourc name ) ; } try { ( file . exist ( ) ) { ( resourc name = null ) { us get resourc get resourc stream stream = get class ( ) . get class loader ( ) . get resourc stream ( resourc name ) ; ( stream = null ) { sourc = new input sourc ( get class ( ) . get class loader ( ) . get resourc ( resourc name ) . string ( ) ) ; } } } els { sourc = new input sourc ( file : file . get absolut path ( ) ) ; stream = new file input stream ( file ) ; add watch resourc so cascad reload occur default config file modifi ad remov context . add watch resourc ( file . get absolut path ( ) ) ; } } catch ( except e ) { log . error ( sm . get string ( context config . context miss , resourc name file ) , e ) ; } ( sourc = = null ) return ; synchron ( context digest ) { try { sourc . set byte stream ( stream ) ; context digest . set class loader ( thi . get class ( ) . get class loader ( ) ) ; context digest . set us context class loader ( fals ) ; context digest . push ( context . get parent ( ) ) ; context digest . push ( context ) ; context error handler error handler = new context error handler ( ) ; context digest . set error handler ( error handler ) ; context digest . pars ( sourc ) ; ( error handler . pars except = null ) { ok = fals ; } ( log . debug enabl ( ) ) log . debug ( successfulli process context context . get name ( ) configur file base dir resourc name ) ; } catch ( saxpars except e ) { log . error ( sm . get string ( context config . context pars , context . get name ( ) ) , e ) ; log . error ( sm . get string ( context config . default posit , e . get line number ( ) , e . get column number ( ) ) ) ; ok = fals ; } catch ( except e ) { log . error ( sm . get string ( context config . context pars , context . get name ( ) ) , e ) ; ok = fals ; } final { context digest . reset ( ) ; try { ( stream = null ) { stream . close ( ) ; } } catch ( ioexcept e ) { log . error ( sm . get string ( context config . context close ) , e ) ; } } } }	public creat new standard context . param parent mbean name associ parent compon param path context path thi context param doc base document base directori ( war ) thi context except except mbean cannot creat regist string creat standard context ( string parent , string path , string doc base , boolean xml valid , boolean xml namespac awar , boolean tld valid , boolean tld namespac awar ) throw except { creat new standard context instanc standard context context = new standard context ( ) ; path = get path str ( path ) ; context . set path ( path ) ; context . set doc base ( doc base ) ; context . set xml valid ( xml valid ) ; context . set xml namespac awar ( xml namespac awar ) ; context . set tld valid ( tld valid ) ; context . set tld namespac awar ( tld namespac awar ) ; context config context config = new context config ( ) ; context . add lifecycl listen ( context config ) ; add new instanc parent compon object name pname = new object name ( parent ) ; object name deploy = new object name ( pname . get domain ( ) : type = deploy , host = pname . get kei properti ( host ) ) ; ( mserver . regist ( deploy ) ) { string context path = context . get path ( ) ; mserver . invok ( deploy , add servic , new object { context path } , new string { java . lang . string } ) ; string config path = ( string ) mserver . get attribut ( deploy , config base name ) ; string base name = get config file ( context path ) ; file config file = new file ( new file ( config path ) , base name . xml ) ; context . set config file ( config file . get absolut path ( ) ) ; mserver . invok ( deploy , manag app , new object { context } , new string { org . apach . catalina . context } ) ; mserver . invok ( deploy , remov servic , new object { context path } , new string { java . lang . string } ) ; } els { log . warn ( deploy found pname . get kei properti ( host ) ) ; servic servic = get servic ( pname ) ; engin engin = ( engin ) servic . get contain ( ) ; host host = ( host ) engin . find child ( pname . get kei properti ( host ) ) ; host . add child ( context ) ; } return correspond mbean name object name onam = context . get jmx name ( ) ; return ( onam . string ( ) ) ; }	public return path file save thi context inform . string get config file ( ) { return ( thi . config file ) ; }	public process start event associ host . param event lifecycl event ha occur void lifecycl event ( lifecycl event event ) { ( event . get type ( ) . equal ( lifecycl . period event ) ) check ( ) ; identifi host we ar associ try { host = ( host ) event . get lifecycl ( ) ; ( host instanceof standard host ) { set deploi xml ( ( ( standard host ) host ) . deploi xml ( ) ) ; set unpack war ( ( ( standard host ) host ) . unpack war ( ) ) ; set xml namespac awar ( ( ( standard host ) host ) . get xml namespac awar ( ) ) ; set xml valid ( ( ( standard host ) host ) . get xml valid ( ) ) ; } } catch ( class cast except e ) { log . error ( sm . get string ( host config . cce , event . get lifecycl ( ) ) , e ) ; return ; } process event ha occur ( event . get type ( ) . equal ( lifecycl . start event ) ) start ( ) ; }	public set local charact set mapper thi context . param mapper new mapper void set charset mapper ( charset mapper mapper ) { charset mapper old charset mapper = thi . charset mapper ; thi . charset mapper = mapper ; ( mapper = null ) thi . charset mapper class = mapper . get class ( ) . get name ( ) ; support . fire properti chang ( charset mapper , old charset mapper , thi . charset mapper ) ; }	public deploi xml context config file flag mutat . void set deploi xml ( boolean deploi xml ) { thi . deploi xml = deploi xml ; }	public set deploi xml config file flag thi compon . param deploi xml new deploi xml flag void set deploi xml ( boolean deploi xml ) { thi . deploi xml = deploi xml ; }
public send data member see org . apach . catalina . tribe . cluster sender send messag ( org . apach . catalina . tribe . cluster messag , org . apach . catalina . tribe . member ) void send messag ( channel messag messag , member destin ) throw channel except { multi point sender sender = get transport ( ) ; try { sender . send messag ( destin , messag ) ; } catch ( channel except x ) { sender . disconnect ( ) ; throw x ; } }	public void send messag ( member destin , channel messag messag ) throw channel except { ( connect ) throw new channel except ( sender connect . ) ; parallel nio sender sender = ( parallel nio sender ) get sender ( ) ; ( sender = = null ) { channel except cx = new channel except ( unabl retriev data sender , time out error . ) ; ( int i = 0 ; i destin . length ; i ) cx . add faulti member ( destin i , new null pointer except ( unabl retriev sender from sender pool ) ) ; throw cx ; } els { try { sender . send messag ( destin , messag ) ; sender . keepal ( ) ; } final { ( connect ) disconnect ( ) ; return sender ( sender ) ; } } }
write singl charact . overrid public void write ( int c ) throw ioexcept { ensur open ( ) ; ( buffer size = = 0 ) { init out ( ) ; out . write ( c ) ; } els { ( next char = buffer size ) ( auto flush ) flush buffer ( ) ; els buffer overflow ( ) ; cb next char = ( char ) c ; } }
protect list resourc which ar member collect . param file collect return vector contain name entri object arrai list name entri list ( file file ) { arrai list name entri entri = new arrai list name entri ( ) ; ( file . directori ( ) ) return entri ; string name = file . list ( ) ; ( name = = null ) { some io error occur bad file permiss . prevent npe arrai . sort ( name ) log . warn ( sm . get string ( file resourc . list null , file . get absolut path ( ) ) ) ; return entri ; } sort alphabet arrai . sort ( name ) ; name entri entri = null ; ( int i = 0 ; i name . length ; i ) { file current file = new file ( file , name i ) ; object object = null ; ( current file . directori ( ) ) { file dir context temp context = new file dir context ( env ) ; temp context . set doc base ( file . get path ( ) ) ; temp context . set allow link ( get allow link ( ) ) ; object = temp context ; } els { object = new file resourc ( current file ) ; } entri = new name entri ( name i , object , name entri . entri ) ; entri . add ( entri ) ; } return entri ; }	content accessor . return input stream overrid public input stream stream content ( ) throw ioexcept { ( binari content = = null ) { input stream = new file input stream ( file ) ; } return super . stream content ( ) ; }	content accessor . return input stream overrid public input stream stream content ( ) throw ioexcept { try { ( binari content = = null ) { input stream = base . get input stream ( entri ) ; } } catch ( zip except e ) { throw new ioexcept ( e . get messag ( ) ) ; } return super . stream content ( ) ; }
public set string get resourc path ( string path ) { return context . get resourc path ( canon uri ( path ) ) ; }
protect return list role associ given user . ani role present user s directori entri ar supplement directori search . role ar associ thi user , zero length list return . param context directori context we ar search param user user check except name except directori server error occur list string get role ( dir context context , user user ) throw name except { ( user = = null ) return ( null ) ; string dn = user . dn ; string usernam = user . usernam ; ( dn = = null usernam = = null ) return ( null ) ; ( contain log . trace enabl ( ) ) contain log . trace ( get role ( dn ) ) ; start role retriev from user entri list string list = user . role ; ( list = = null ) { list = new arrai list string ( ) ; } ( common role = null ) list . add ( common role ) ; ( contain log . trace enabl ( ) ) { contain log . trace ( found list . size ( ) user intern role ) ; ( int i = 0 ; i list . size ( ) ; i ) contain log . trace ( found user intern role list . get ( i ) ) ; } ar we configur do role search ( ( role format = = null ) ( role name = = null ) ) return ( list ) ; set up paramet appropri search string filter = role format . format ( new string { do rfc2254encod ( dn ) , usernam } ) ; search control control = new search control ( ) ; ( role subtre ) control . set search scope ( search control . subtre scope ) ; els control . set search scope ( search control . onelevel scope ) ; control . set return attribut ( new string { role name } ) ; perform configur search process result name enumer search result result = context . search ( role base , filter , control ) ; ( result = = null ) should never happen , just case . . . return ( list ) ; hash map string , string group map = new hash map string , string ( ) ; try { while ( result . ha more ( ) ) { search result result = result . next ( ) ; attribut attr = result . get attribut ( ) ; ( attr = = null ) continu ; string dname = get distinguish name ( context , role base , result ) ; string name = get attribut valu ( role name , attr ) ; ( name = null dname = null ) { group map . put ( dname , name ) ; } } } catch ( partial result except ex ) { ( ad compat ) throw ex ; } set string kei = group map . kei set ( ) ; ( contain log . trace enabl ( ) ) { contain log . trace ( found kei . size ( ) direct role ) ; ( string kei : kei ) { contain log . trace ( found direct role kei group map . get ( kei ) ) ; } } nest group search enabl , perform search nest group until new group found ( get role nest ( ) ) { follow effici algorithm known member algorithm , describ practic directori group . avoid group slurp handl cyclic group membership well . see http : middlewar . internet2 . edu dir detail map string , string new group = new hash map string , string ( group map ) ; while ( new group . empti ( ) ) { store group we find thi iter map string , string new thi round = new hash map string , string ( ) ; ( entri string , string group : new group . entri set ( ) ) { filter = role format . format ( new string { group . get kei ( ) , group . get valu ( ) } ) ; ( contain log . trace enabl ( ) ) { contain log . trace ( perform nest group search base role base filter filter ) ; } result = context . search ( role base , filter , control ) ; try { while ( result . ha more ( ) ) { search result result = result . next ( ) ; attribut attr = result . get attribut ( ) ; ( attr = = null ) continu ; string dname = get distinguish name ( context , role base , result ) ; string name = get attribut valu ( role name , attr ) ; ( name = null dname = null group map . kei set ( ) . contain ( dname ) ) { group map . put ( dname , name ) ; new thi round . put ( dname , name ) ; ( contain log . trace enabl ( ) ) { contain log . trace ( found nest role dname name ) ; } } } } catch ( partial result except ex ) { ( ad compat ) throw ex ; } } new group = new thi round ; } } return new arrai list string ( group map . valu ( ) ) ; }
protect handl http statu code java except forward control locat includ specifi error page object . assum caller ha alreadi record ani request attribut ar forward thi page . return code true code we successfulli util specifi error page locat , code fals code default error report should render . param request request process param respons respons gener param error page error page direct we ar obei boolean custom ( request request , respons respons , error page error page ) { ( contain . get logger ( ) . debug enabl ( ) ) contain . get logger ( ) . debug ( process error page ) ; request . set path info ( error page . get locat ( ) ) ; try { reset respons ( keep real error code messag ) respons . reset buffer ( true ) ; forward control specifi locat servlet context servlet context = request . get context ( ) . get servlet context ( ) ; request dispatch rd = servlet context . get request dispatch ( error page . get locat ( ) ) ; rd . forward ( request . get request ( ) , respons . get respons ( ) ) ; we forward , respons suspend again respons . set suspend ( fals ) ; indic we have successfulli process thi custom page return ( true ) ; } catch ( throwabl t ) { report our failur process thi custom page contain . get logger ( ) . error ( except process error page , t ) ; return ( fals ) ; } }
public servlet context get servlet context ( ) { return config . get servlet context ( ) ; }
public static void secur class load ( class loader loader ) { ( system . get secur manag ( ) = = null ) { return ; } string base packag = org . apach . jasper . ; try { loader . load class ( base packag runtim . jsp factori impl privileg get page context ) ; loader . load class ( base packag runtim . jsp factori impl privileg releas page context ) ; loader . load class ( base packag runtim . jsp runtim librari ) ; loader . load class ( base packag runtim . jsp runtim librari privileg introspect helper ) ; loader . load class ( base packag runtim . servlet respons wrapper includ ) ; loader . load class ( base packag runtim . tag handler pool ) ; loader . load class ( base packag runtim . jsp fragment helper ) ; loader . load class ( base packag runtim . protect function mapper ) ; loader . load class ( base packag runtim . protect function mapper 1 ) ; loader . load class ( base packag runtim . protect function mapper 2 ) ; loader . load class ( base packag runtim . protect function mapper 3 ) ; loader . load class ( base packag runtim . protect function mapper 4 ) ; loader . load class ( base packag runtim . page context impl ) ; loader . load class ( base packag runtim . page context impl 1 ) ; loader . load class ( base packag runtim . page context impl 2 ) ; loader . load class ( base packag runtim . page context impl 3 ) ; loader . load class ( base packag runtim . page context impl 4 ) ; loader . load class ( base packag runtim . page context impl 5 ) ; loader . load class ( base packag runtim . page context impl 6 ) ; loader . load class ( base packag runtim . page context impl 7 ) ; loader . load class ( base packag runtim . page context impl 8 ) ; loader . load class ( base packag runtim . page context impl 9 ) ; loader . load class ( base packag runtim . page context impl 10 ) ; loader . load class ( base packag runtim . page context impl 11 ) ; loader . load class ( base packag runtim . page context impl 12 ) ; loader . load class ( base packag runtim . page context impl 13 ) ; loader . load class ( base packag runtim . jsp context wrapper ) ; loader . load class ( base packag servlet . jsp servlet wrapper ) ; loader . load class ( base packag runtim . jsp writer impl 1 ) ; } catch ( class found except ex ) { log . error ( secur class load , ex ) ; } }

protect return xsl templat inputstream ( possibl ) input stream find xslt input stream ( dir context directori ) throw ioexcept { ( local xslt file = null ) { try { object obj = directori . lookup ( local xslt file ) ; ( ( obj = null ) ( obj instanceof resourc ) ) { input stream = ( ( resourc ) obj ) . stream content ( ) ; ( = null ) return ; } } catch ( name except e ) { ( debug 10 ) log ( local xslt file local xslt file found , e ) ; return null ; } } open read file fell swoop reduc chanc chanc leav handl open . ( global xslt file = null ) { file input stream fi = null ; try { file f = new file ( global xslt file ) ; ( f . exist ( ) ) { fi = new file input stream ( f ) ; byte b = new byte ( int ) f . length ( ) ; danger fi . read ( b ) ; return new byte arrai input stream ( b ) ; } } final { ( fi = null ) fi . close ( ) ; } } return null ; }	protect return input stream html represent content thi directori . param context path context path which our intern path ar rel input stream render xml ( string context path , cach entri cach entri , input stream xslt input stream ) throw ioexcept , servlet except { string builder sb = new string builder ( ) ; sb . append ( xml version = 1 . 0 ) ; sb . append ( list ) ; sb . append ( context path = ) ; sb . append ( context path ) ; sb . append ( ) ; sb . append ( directori = ) ; sb . append ( cach entri . name ) ; sb . append ( ) ; sb . append ( ha parent = ) . append ( cach entri . name . equal ( ) ) ; sb . append ( ) ; sb . append ( entri ) ; try { render directori entri within thi directori name enumer name class pair enumer = resourc . list ( cach entri . name ) ; rewrit url ( context path ) expens . cach result later reus string rewritten context path = rewrit url ( context path ) ; while ( enumer . ha more element ( ) ) { name class pair nc pair = enumer . next element ( ) ; string resourc name = nc pair . get name ( ) ; string trim = resourc name ; ( trim . equal ignor case ( web inf ) trim . equal ignor case ( meta inf ) trim . equal ignor case ( local xslt file ) ) continu ; cach entri child cach entri = resourc . lookup cach ( cach entri . name resourc name ) ; ( child cach entri . exist ) { continu ; } sb . append ( entri ) ; sb . append ( type = ) . append ( ( child cach entri . context = null ) dir : file ) . append ( ) ; sb . append ( url path = ) . append ( rewritten context path ) . append ( rewrit url ( cach entri . name resourc name ) ) . append ( ( child cach entri . context = null ) : ) . append ( ) ; ( child cach entri . resourc = null ) { sb . append ( size = ) . append ( render size ( child cach entri . attribut . get content length ( ) ) ) . append ( ) ; } sb . append ( date = ) . append ( child cach entri . attribut . get last modifi http ( ) ) . append ( ) ; sb . append ( ) ; sb . append ( request util . filter ( trim ) ) ; ( child cach entri . context = null ) sb . append ( ) ; sb . append ( entri ) ; } } catch ( name except e ) { someth went wrong throw new servlet except ( error access resourc , e ) ; } sb . append ( entri ) ; string readm = get readm ( cach entri . context ) ; ( readm = null ) { sb . append ( readm cdata ) ; sb . append ( readm ) ; sb . append ( readm ) ; } sb . append ( list ) ; try { transform factori t factori = transform factori . new instanc ( ) ; sourc xml sourc = new stream sourc ( new string reader ( sb . string ( ) ) ) ; sourc xsl sourc = new stream sourc ( xslt input stream ) ; transform transform = t factori . new transform ( xsl sourc ) ; byte arrai output stream stream = new byte arrai output stream ( ) ; output stream writer os writer = new output stream writer ( stream , utf8 ) ; stream result out = new stream result ( os writer ) ; transform . transform ( xml sourc , out ) ; os writer . flush ( ) ; return ( new byte arrai input stream ( stream . byte arrai ( ) ) ) ; } catch ( transform except e ) { throw new servlet except ( xsl transform error , e ) ; } }	initi thi servlet . overrid public void init ( ) throw servlet except { ( get servlet config ( ) . get init paramet ( debug ) = null ) debug = integ . pars int ( get servlet config ( ) . get init paramet ( debug ) ) ; ( get servlet config ( ) . get init paramet ( input ) = null ) input = integ . pars int ( get servlet config ( ) . get init paramet ( input ) ) ; ( get servlet config ( ) . get init paramet ( output ) = null ) output = integ . pars int ( get servlet config ( ) . get init paramet ( output ) ) ; list = boolean . pars boolean ( get servlet config ( ) . get init paramet ( list ) ) ; ( get servlet config ( ) . get init paramet ( readonli ) = null ) read onli = boolean . pars boolean ( get servlet config ( ) . get init paramet ( readonli ) ) ; ( get servlet config ( ) . get init paramet ( sendfil size ) = null ) sendfil size = integ . pars int ( get servlet config ( ) . get init paramet ( sendfil size ) ) 1024 ; file encod = get servlet config ( ) . get init paramet ( file encod ) ; global xslt file = get servlet config ( ) . get init paramet ( global xslt file ) ; local xslt file = get servlet config ( ) . get init paramet ( local xslt file ) ; readm file = get servlet config ( ) . get init paramet ( readm file ) ; ( get servlet config ( ) . get init paramet ( us accept rang ) = null ) us accept rang = boolean . pars boolean ( get servlet config ( ) . get init paramet ( us accept rang ) ) ; saniti check specifi buffer size ( input 256 ) input = 256 ; ( output 256 ) output = 256 ; ( debug 0 ) { log ( default servlet . init : input buffer size = input , output buffer size = output ) ; } load proxi dir context . resourc = ( proxi dir context ) get servlet context ( ) . get attribut ( global . resourc attr ) ; ( resourc = = null ) { try { resourc = ( proxi dir context ) new initi context ( ) . lookup ( resourc jndi name ) ; } catch ( name except e ) { fail throw new servlet except ( resourc , e ) ; } } ( resourc = = null ) { throw new unavail except ( resourc ) ; } }
protect includ gener web . xml insid webapp s web . xml . void merg web xml ( ) throw ioexcept { file webapp base = new file ( uri root ) ; file web xml = new file ( webapp base , web inf web . xml ) ; file web xml2 = new file ( webapp base , web inf web2 . xml ) ; string insert start marker = local . get messag ( jspc . webinc . insert start ) ; string insert end marker = local . get messag ( jspc . webinc . insert end ) ; buffer reader reader = new buffer reader ( new file reader ( web xml ) ) ; buffer reader fragment reader = new buffer reader ( new file reader ( webxml file ) ) ; print writer writer = new print writer ( new file writer ( web xml2 ) ) ; insert servlet servlet map declar int po = 1 ; string line = null ; while ( true ) { line = reader . read line ( ) ; ( line = = null ) { break ; } skip anyth previous gener jspc ( line . index ( insert start marker ) = 0 ) { while ( true ) { line = reader . read line ( ) ; ( line = = null ) { return ; } ( line . index ( insert end marker ) = 0 ) { line = reader . read line ( ) ; line = reader . read line ( ) ; ( line = = null ) { return ; } break ; } } } ( int i = 0 ; i insert befor . length ; i ) { po = line . index ( insert befor i ) ; ( po = 0 ) break ; } ( po = 0 ) { writer . print ( line . substr ( 0 , po ) ) ; break ; } els { writer . println ( line ) ; } } writer . println ( insert start marker ) ; while ( true ) { string line2 = fragment reader . read line ( ) ; ( line2 = = null ) { writer . println ( ) ; break ; } writer . println ( line2 ) ; } writer . println ( insert end marker ) ; writer . println ( ) ; ( int i = 0 ; i po ; i ) { writer . print ( ) ; } writer . println ( line . substr ( po ) ) ; while ( true ) { line = reader . read line ( ) ; ( line = = null ) { break ; } writer . println ( line ) ; } writer . close ( ) ; reader . close ( ) ; fragment reader . close ( ) ; file input stream fi = new file input stream ( web xml2 ) ; file output stream fo = new file output stream ( web xml ) ; byte buf = new byte 512 ; while ( true ) { int n = fi . read ( buf ) ; ( n 0 ) { break ; } fo . write ( buf , 0 , n ) ; } fi . close ( ) ; fo . close ( ) ; web xml2 . delet ( ) ; ( new file ( webxml file ) ) . delet ( ) ; }
privat propfind helper method . param req servlet request param resourc resourc object associ thi context param gener xml xml respons propfind request param path path current resourc param type propfind type param properti vector propfind type find properti name , thi vector contain those properti void pars properti ( http servlet request req , xmlwriter gener xml , string path , int type , vector string properti vector ) { ( upper case ( ) avoid problem window system ) ( path . upper case ( ) . start ( web inf ) path . upper case ( ) . start ( meta inf ) ) return ; cach entri cach entri = resourc . lookup cach ( path ) ; gener xml . write element ( null , respons , xmlwriter . open ) ; string statu = new string ( http 1 . 1 webdav statu . sc ok webdav statu . get statu text ( webdav statu . sc ok ) ) ; gener href element gener xml . write element ( null , href , xmlwriter . open ) ; string href = req . get context path ( ) req . get servlet path ( ) ; ( ( href . end ( ) ) ( path . start ( ) ) ) href = path . substr ( 1 ) ; els href = path ; ( ( cach entri . context = null ) ( href . end ( ) ) ) href = ; gener xml . write text ( rewrit url ( href ) ) ; gener xml . write element ( null , href , xmlwriter . close ) ; string resourc name = path ; int last slash = path . last index ( ) ; ( last slash = 1 ) resourc name = resourc name . substr ( last slash 1 ) ; switch ( type ) { case find all prop : gener xml . write element ( null , propstat , xmlwriter . open ) ; gener xml . write element ( null , prop , xmlwriter . open ) ; gener xml . write properti ( null , creationd , get isocr date ( cach entri . attribut . get creation ( ) ) ) ; gener xml . write element ( null , displaynam , xmlwriter . open ) ; gener xml . write data ( resourc name ) ; gener xml . write element ( null , displaynam , xmlwriter . close ) ; ( cach entri . resourc = null ) { gener xml . write properti ( null , getlastmodifi , fast http date format . format date ( cach entri . attribut . get last modifi ( ) , null ) ) ; gener xml . write properti ( null , getcontentlength , string . valu ( cach entri . attribut . get content length ( ) ) ) ; string content type = get servlet context ( ) . get mime type ( cach entri . name ) ; ( content type = null ) { gener xml . write properti ( null , getcontenttyp , content type ) ; } gener xml . write properti ( null , getetag , cach entri . attribut . get etag ( ) ) ; gener xml . write element ( null , resourcetyp , xmlwriter . content ) ; } els { gener xml . write element ( null , resourcetyp , xmlwriter . open ) ; gener xml . write element ( null , collect , xmlwriter . content ) ; gener xml . write element ( null , resourcetyp , xmlwriter . close ) ; } gener xml . write properti ( null , sourc , ) ; string support lock = lockentri lockscop exclus lockscop locktyp write locktyp lockentri lockentri lockscop share lockscop locktyp write locktyp lockentri ; gener xml . write element ( null , supportedlock , xmlwriter . open ) ; gener xml . write text ( support lock ) ; gener xml . write element ( null , supportedlock , xmlwriter . close ) ; gener lock discoveri ( path , gener xml ) ; gener xml . write element ( null , prop , xmlwriter . close ) ; gener xml . write element ( null , statu , xmlwriter . open ) ; gener xml . write text ( statu ) ; gener xml . write element ( null , statu , xmlwriter . close ) ; gener xml . write element ( null , propstat , xmlwriter . close ) ; break ; case find properti name : gener xml . write element ( null , propstat , xmlwriter . open ) ; gener xml . write element ( null , prop , xmlwriter . open ) ; gener xml . write element ( null , creationd , xmlwriter . content ) ; gener xml . write element ( null , displaynam , xmlwriter . content ) ; ( cach entri . resourc = null ) { gener xml . write element ( null , getcontentlanguag , xmlwriter . content ) ; gener xml . write element ( null , getcontentlength , xmlwriter . content ) ; gener xml . write element ( null , getcontenttyp , xmlwriter . content ) ; gener xml . write element ( null , getetag , xmlwriter . content ) ; gener xml . write element ( null , getlastmodifi , xmlwriter . content ) ; } gener xml . write element ( null , resourcetyp , xmlwriter . content ) ; gener xml . write element ( null , sourc , xmlwriter . content ) ; gener xml . write element ( null , lockdiscoveri , xmlwriter . content ) ; gener xml . write element ( null , prop , xmlwriter . close ) ; gener xml . write element ( null , statu , xmlwriter . open ) ; gener xml . write text ( statu ) ; gener xml . write element ( null , statu , xmlwriter . close ) ; gener xml . write element ( null , propstat , xmlwriter . close ) ; break ; case find properti : vector string properti found = new vector string ( ) ; pars list properti gener xml . write element ( null , propstat , xmlwriter . open ) ; gener xml . write element ( null , prop , xmlwriter . open ) ; enumer string properti = properti vector . element ( ) ; while ( properti . ha more element ( ) ) { string properti = properti . next element ( ) ; ( properti . equal ( creationd ) ) { gener xml . write properti ( null , creationd , get isocr date ( cach entri . attribut . get creation ( ) ) ) ; } els ( properti . equal ( displaynam ) ) { gener xml . write element ( null , displaynam , xmlwriter . open ) ; gener xml . write data ( resourc name ) ; gener xml . write element ( null , displaynam , xmlwriter . close ) ; } els ( properti . equal ( getcontentlanguag ) ) { ( cach entri . context = null ) { properti found . add element ( properti ) ; } els { gener xml . write element ( null , getcontentlanguag , xmlwriter . content ) ; } } els ( properti . equal ( getcontentlength ) ) { ( cach entri . context = null ) { properti found . add element ( properti ) ; } els { gener xml . write properti ( null , getcontentlength , ( string . valu ( cach entri . attribut . get content length ( ) ) ) ) ; } } els ( properti . equal ( getcontenttyp ) ) { ( cach entri . context = null ) { properti found . add element ( properti ) ; } els { gener xml . write properti ( null , getcontenttyp , get servlet context ( ) . get mime type ( cach entri . name ) ) ; } } els ( properti . equal ( getetag ) ) { ( cach entri . context = null ) { properti found . add element ( properti ) ; } els { gener xml . write properti ( null , getetag , cach entri . attribut . get etag ( ) ) ; } } els ( properti . equal ( getlastmodifi ) ) { ( cach entri . context = null ) { properti found . add element ( properti ) ; } els { gener xml . write properti ( null , getlastmodifi , fast http date format . format date ( cach entri . attribut . get last modifi ( ) , null ) ) ; } } els ( properti . equal ( resourcetyp ) ) { ( cach entri . context = null ) { gener xml . write element ( null , resourcetyp , xmlwriter . open ) ; gener xml . write element ( null , collect , xmlwriter . content ) ; gener xml . write element ( null , resourcetyp , xmlwriter . close ) ; } els { gener xml . write element ( null , resourcetyp , xmlwriter . content ) ; } } els ( properti . equal ( sourc ) ) { gener xml . write properti ( null , sourc , ) ; } els ( properti . equal ( supportedlock ) ) { support lock = lockentri lockscop exclus lockscop locktyp write locktyp lockentri lockentri lockscop share lockscop locktyp write locktyp lockentri ; gener xml . write element ( null , supportedlock , xmlwriter . open ) ; gener xml . write text ( support lock ) ; gener xml . write element ( null , supportedlock , xmlwriter . close ) ; } els ( properti . equal ( lockdiscoveri ) ) { ( gener lock discoveri ( path , gener xml ) ) properti found . add element ( properti ) ; } els { properti found . add element ( properti ) ; } } gener xml . write element ( null , prop , xmlwriter . close ) ; gener xml . write element ( null , statu , xmlwriter . open ) ; gener xml . write text ( statu ) ; gener xml . write element ( null , statu , xmlwriter . close ) ; gener xml . write element ( null , propstat , xmlwriter . close ) ; enumer string properti found list = properti found . element ( ) ; ( properti found list . ha more element ( ) ) { statu = new string ( http 1 . 1 webdav statu . sc found webdav statu . get statu text ( webdav statu . sc found ) ) ; gener xml . write element ( null , propstat , xmlwriter . open ) ; gener xml . write element ( null , prop , xmlwriter . open ) ; while ( properti found list . ha more element ( ) ) { gener xml . write element ( null , properti found list . next element ( ) , xmlwriter . content ) ; } gener xml . write element ( null , prop , xmlwriter . close ) ; gener xml . write element ( null , statu , xmlwriter . open ) ; gener xml . write text ( statu ) ; gener xml . write element ( null , statu , xmlwriter . close ) ; gener xml . write element ( null , propstat , xmlwriter . close ) ; } break ; } gener xml . write element ( null , respons , xmlwriter . close ) ; }
execut request oper . except build except error occur overrid public void execut ( ) throw build except { super . execut ( ) ; ( path = = null ) { throw new build except ( must specifi path attribut ) ; } ( ( war = = null ) ( local war = = null ) ( config = = null ) ( tag = = null ) ) { throw new build except ( must specifi either war , local war , config , tag attribut ) ; } build input stream war upload , ani buffer input stream stream = null ; string content type = null ; int content length = 1 ; ( war = null ) { ( war . start ( file : ) ) { try { url url = new url ( war ) ; urlconnect conn = url . open connect ( ) ; content length = conn . get content length ( ) ; stream = new buffer input stream ( conn . get input stream ( ) , 1024 ) ; } catch ( ioexcept e ) { throw new build except ( e ) ; } } els { try { stream = new buffer input stream ( new file input stream ( war ) , 1024 ) ; } catch ( ioexcept e ) { throw new build except ( e ) ; } } content type = applic octet stream ; } build url string builder sb = new string builder ( deploi path = ) ; try { sb . append ( urlencod . encod ( thi . path , get charset ( ) ) ) ; ( ( war = = null ) ( config = null ) ) { sb . append ( config = ) ; sb . append ( urlencod . encod ( config , get charset ( ) ) ) ; } ( ( war = = null ) ( local war = null ) ) { sb . append ( war = ) ; sb . append ( urlencod . encod ( local war , get charset ( ) ) ) ; } ( updat ) { sb . append ( updat = true ) ; } ( tag = null ) { sb . append ( tag = ) ; sb . append ( urlencod . encod ( tag , get charset ( ) ) ) ; } } catch ( unsupport encod except e ) { throw new build except ( invalid charset attribut : get charset ( ) ) ; } execut ( sb . string ( ) , stream , content type , content length ) ; }	public execut specifi command , base configur properti . input stream close upon complet thi task , whether wa execut successfulli . param command command execut param istream input stream includ http put , ani param content type content type specifi input , ani param content length content length specifi input , ani except build except error occur void execut ( string command , input stream istream , string content type , int content length ) throw build except { urlconnect conn = null ; input stream reader reader = null ; try { creat connect thi command conn = ( new url ( url command ) ) . open connect ( ) ; http urlconnect hconn = ( http urlconnect ) conn ; set up standard connect characterist hconn . set allow user interact ( fals ) ; hconn . set do input ( true ) ; hconn . set us cach ( fals ) ; ( istream = null ) { hconn . set do output ( true ) ; hconn . set request method ( put ) ; ( content type = null ) { hconn . set request properti ( content type , content type ) ; } ( content length = 0 ) { hconn . set request properti ( content length , content length ) ; } } els { hconn . set do output ( fals ) ; hconn . set request method ( get ) ; } hconn . set request properti ( user agent , catalina ant task 1 . 0 ) ; set up author header our credenti string input = usernam : password ; string output = new string ( base64 . encod ( input . get byte ( ) ) ) ; hconn . set request properti ( author , basic output ) ; establish connect server hconn . connect ( ) ; send request data ( ani ) ( istream = null ) { buffer output stream ostream = new buffer output stream ( hconn . get output stream ( ) , 1024 ) ; byte buffer = new byte 1024 ; while ( true ) { int n = istream . read ( buffer ) ; ( n 0 ) { break ; } ostream . write ( buffer , 0 , n ) ; } ostream . flush ( ) ; ostream . close ( ) ; istream . close ( ) ; } process respons messag reader = new input stream reader ( hconn . get input stream ( ) , charset ) ; string builder buff = new string builder ( ) ; string error = null ; int msg prioriti = project . msg info ; boolean first = true ; while ( true ) { int ch = reader . read ( ) ; ( ch 0 ) { break ; } els ( ( ch = = r ) ( ch = = n ) ) { produc blank line ( buff . length ( ) 0 ) { string line = buff . string ( ) ; buff . set length ( 0 ) ; ( first ) { ( line . start ( ok ) ) { error = line ; msg prioriti = project . msg err ; } first = fals ; } handl output ( line , msg prioriti ) ; } } els { buff . append ( ( char ) ch ) ; } } ( buff . length ( ) 0 ) { handl output ( buff . string ( ) , msg prioriti ) ; } ( error = null fail error ( ) ) { error line log twice throw new build except ( error ) ; } } catch ( throwabl t ) { ( fail error ( ) ) { throw new build except ( t ) ; } els { handl error output ( t . get messag ( ) ) ; } } final { close redirector ( ) ; ( reader = null ) { try { reader . close ( ) ; } catch ( throwabl u ) { ignor } reader = null ; } ( istream = null ) { try { istream . close ( ) ; } catch ( throwabl u ) { ignor } istream = null ; } } }
public static synchron p set default factori thi implement . illeg ani princip other than jsp engin runtim call thi method . p param deflt default factori implement void set default factori ( jsp factori deflt ) { jsp factori . deflt = deflt ; }
protect find specifi resourc local repositori . return load resourc , null resourc isn t found resourc entri find resourc intern ( string name , string path ) { ( start ) { log . info ( sm . get string ( webapp class loader . stop , name ) ) ; return null ; } ( ( name = = null ) ( path = = null ) ) return null ; resourc entri entri = resourc entri . get ( name ) ; ( entri = null ) return entri ; int content length = 1 ; input stream binari stream = null ; int jar file length = jar file . length ; int repositori length = repositori . length ; int i ; resourc resourc = null ; boolean file need convert = fals ; ( i = 0 ; ( entri = = null ) ( i repositori length ) ; i ) { try { string full path = repositori i path ; object lookup result = resourc . lookup ( full path ) ; ( lookup result instanceof resourc ) { resourc = ( resourc ) lookup result ; } note : get except here mean resourc wa found entri = find resourc intern ( file i , path ) ; resourc attribut attribut = ( resourc attribut ) resourc . get attribut ( full path ) ; content length = ( int ) attribut . get content length ( ) ; entri . last modifi = attribut . get last modifi ( ) ; ( resourc = null ) { try { binari stream = resourc . stream content ( ) ; } catch ( ioexcept e ) { return null ; } ( need convert ) { ( path . end ( . properti ) ) { file need convert = true ; } } note : onli sync constant object need synchron ( all permiss ) { int j ; long result2 = new long last modifi date . length 1 ; ( j = 0 ; j last modifi date . length ; j ) { result2 j = last modifi date j ; } result2 last modifi date . length = entri . last modifi ; last modifi date = result2 ; string result = new string path . length 1 ; ( j = 0 ; j path . length ; j ) { result j = path j ; } result path . length = full path ; path = result ; } } } catch ( name except e ) { } } ( ( entri = = null ) ( found resourc . contain kei ( name ) ) ) return null ; jar entri jar entri = null ; synchron ( jar file ) { ( open jar ( ) ) { return null ; } ( i = 0 ; ( entri = = null ) ( i jar file length ) ; i ) { jar entri = jar file i . get jar entri ( path ) ; ( jar entri = null ) { entri = new resourc entri ( ) ; try { entri . code base = get url ( jar real file i , fals ) ; string jar fake url = get uri ( jar real file i ) . string ( ) ; jar fake url = jar : jar fake url path ; entri . sourc = new url ( jar fake url ) ; entri . last modifi = jar real file i . last modifi ( ) ; } catch ( malform urlexcept e ) { return null ; } content length = ( int ) jar entri . get size ( ) ; try { entri . manifest = jar file i . get manifest ( ) ; binari stream = jar file i . get input stream ( jar entri ) ; } catch ( ioexcept e ) { return null ; } extract resourc contain jar workdir ( anti jarlock ( path . end ( . class ) ) ) { byte buf = new byte 1024 ; file resourc file = new file ( loader dir , jar entri . get name ( ) ) ; ( resourc file . exist ( ) ) { enumer jar entri entri = jar file i . entri ( ) ; while ( entri . ha more element ( ) ) { jar entri jar entry2 = entri . next element ( ) ; ( ( jar entry2 . directori ( ) ) ( jar entry2 . get name ( ) . end ( . class ) ) ) { resourc file = new file ( loader dir , jar entry2 . get name ( ) ) ; try { ( resourc file . get canon path ( ) . start ( canon loader dir ) ) { throw new illeg argument except ( sm . get string ( webapp class loader . illeg jar path , jar entry2 . get name ( ) ) ) ; } } catch ( ioexcept ioe ) { throw new illeg argument except ( sm . get string ( webapp class loader . valid error jar path , jar entry2 . get name ( ) ) , ioe ) ; } resourc file . get parent file ( ) . mkdir ( ) ; file output stream os = null ; input stream = null ; try { = jar file i . get input stream ( jar entry2 ) ; os = new file output stream ( resourc file ) ; while ( true ) { int n = . read ( buf ) ; ( n = 0 ) { break ; } os . write ( buf , 0 , n ) ; } } catch ( ioexcept e ) { ignor } final { try { ( = null ) { . close ( ) ; } } catch ( ioexcept e ) { } try { ( os = null ) { os . close ( ) ; } } catch ( ioexcept e ) { } } } } } } } } ( entri = = null ) { synchron ( found resourc ) { found resourc . put ( name , name ) ; } return null ; } ( binari stream = null ) { byte binari content = new byte content length ; int po = 0 ; try { while ( true ) { int n = binari stream . read ( binari content , po , binari content . length po ) ; ( n = 0 ) break ; po = n ; } } catch ( ioexcept e ) { log . error ( sm . get string ( webapp class loader . read error , name ) , e ) ; return null ; } final { try { binari stream . close ( ) ; } catch ( ioexcept e ) { } } ( file need convert ) { workaround certain file platform us ebcdic encod , when thei ar read through file input stream . see commit messag rev . 303915 detail http : svn . apach . org viewvc view = revis revis = 303915 string str = new string ( binari content , 0 , po ) ; try { binari content = str . get byte ( utf 8 ) ; } catch ( except e ) { return null ; } } entri . binari content = binari content ; associ input stream ha been fulli read ( jar entri = null ) { entri . certif = jar entri . get certif ( ) ; } } } add entri local resourc repositori synchron ( resourc entri ) { ensur all thread which mai race load particular class all end up same resourc entri instanc resourc entri entry2 = resourc entri . get ( name ) ; ( entry2 = = null ) { resourc entri . put ( name , entri ) ; } els { entri = entry2 ; } } return entri ; }

protect load ani current activ session were previous unload appropri persist mechan , ani . persist support , thi method return without do anyth . except class found except serial class cannot found dure reload except ioexcept input output error occur void do load ( ) throw class found except , ioexcept { ( log . debug enabl ( ) ) log . debug ( start : load persist session ) ; initi our intern data structur session . clear ( ) ; open input stream specifi pathnam , ani file file = file ( ) ; ( file = = null ) return ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( standard manag . load , pathnam ) ) ; file input stream fi = null ; object input stream oi = null ; loader loader = null ; class loader class loader = null ; try { fi = new file input stream ( file . get absolut path ( ) ) ; buffer input stream bi = new buffer input stream ( fi ) ; ( contain = null ) loader = contain . get loader ( ) ; ( loader = null ) class loader = loader . get class loader ( ) ; ( class loader = null ) { ( log . debug enabl ( ) ) log . debug ( creat custom object input stream class loader ) ; oi = new custom object input stream ( bi , class loader ) ; } els { ( log . debug enabl ( ) ) log . debug ( creat standard object input stream ) ; oi = new object input stream ( bi ) ; } } catch ( file found except e ) { ( log . debug enabl ( ) ) log . debug ( persist data file found ) ; return ; } catch ( ioexcept e ) { log . error ( sm . get string ( standard manag . load . ioe , e ) , e ) ; ( oi = null ) { try { oi . close ( ) ; } catch ( ioexcept f ) { ignor } oi = null ; } throw e ; } load previous unload activ session synchron ( session ) { try { integ count = ( integ ) oi . read object ( ) ; int n = count . int valu ( ) ; ( log . debug enabl ( ) ) log . debug ( load n persist session ) ; ( int i = 0 ; i n ; i ) { standard session session = get new session ( ) ; session . read object data ( oi ) ; session . set manag ( thi ) ; session . put ( session . get id intern ( ) , session ) ; session . activ ( ) ; session counter ; } } catch ( class found except e ) { log . error ( sm . get string ( standard manag . load . cnfe , e ) , e ) ; ( oi = null ) { try { oi . close ( ) ; } catch ( ioexcept f ) { ignor } oi = null ; } throw e ; } catch ( ioexcept e ) { log . error ( sm . get string ( standard manag . load . ioe , e ) , e ) ; ( oi = null ) { try { oi . close ( ) ; } catch ( ioexcept f ) { ignor } oi = null ; } throw e ; } final { close input stream try { ( oi = null ) oi . close ( ) ; } catch ( ioexcept f ) { ignor } delet persist storag file ( file . exist ( ) ) file . delet ( ) ; } } ( log . debug enabl ( ) ) log . debug ( finish : load persist session ) ; }	protect save ani current activ session appropri persist mechan , ani . persist support , thi method return without do anyth . except ioexcept input output error occur void do unload ( ) throw ioexcept { ( log . debug enabl ( ) ) log . debug ( unload persist session ) ; open output stream specifi pathnam , ani file file = file ( ) ; ( file = = null ) return ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( standard manag . unload , pathnam ) ) ; file output stream fo = null ; object output stream oo = null ; try { fo = new file output stream ( file . get absolut path ( ) ) ; oo = new object output stream ( new buffer output stream ( fo ) ) ; } catch ( ioexcept e ) { log . error ( sm . get string ( standard manag . unload . ioe , e ) , e ) ; ( oo = null ) { try { oo . close ( ) ; } catch ( ioexcept f ) { ignor } oo = null ; } throw e ; } write number activ session , follow detail arrai list standard session list = new arrai list standard session ( ) ; synchron ( session ) { ( log . debug enabl ( ) ) log . debug ( unload session . size ( ) session ) ; try { oo . write object ( new integ ( session . size ( ) ) ) ; iter session element = session . valu ( ) . iter ( ) ; while ( element . ha next ( ) ) { standard session session = ( standard session ) element . next ( ) ; list . add ( session ) ; session . passiv ( ) ; session . write object data ( oo ) ; } } catch ( ioexcept e ) { log . error ( sm . get string ( standard manag . unload . ioe , e ) , e ) ; ( oo = null ) { try { oo . close ( ) ; } catch ( ioexcept f ) { ignor } oo = null ; } throw e ; } } flush close output stream try { oo . flush ( ) ; oo . close ( ) ; oo = null ; } catch ( ioexcept e ) { ( oo = null ) { try { oo . close ( ) ; } catch ( ioexcept f ) { ignor } oo = null ; } throw e ; } expir all session we just wrote ( log . debug enabl ( ) ) log . debug ( expir list . size ( ) persist session ) ; iter standard session expir = list . iter ( ) ; while ( expir . ha next ( ) ) { standard session session = expir . next ( ) ; try { session . expir ( fals ) ; } catch ( throwabl t ) { ignor } final { session . recycl ( ) ; } } ( log . debug enabl ( ) ) log . debug ( unload complet ) ; }	public load return session associ specifi session identifi from thi store , without remov . store session , return code null code . param id session identifi session load except class found except deseri error occur except ioexcept input output error occur session load ( string id ) throw class found except , ioexcept { open input stream specifi pathnam , ani file file = file ( id ) ; ( file = = null ) { return ( null ) ; } ( file . exist ( ) ) { return ( null ) ; } ( manag . get contain ( ) . get logger ( ) . debug enabl ( ) ) { manag . get contain ( ) . get logger ( ) . debug ( sm . get string ( get store name ( ) . load , id , file . get absolut path ( ) ) ) ; } file input stream fi = null ; object input stream oi = null ; loader loader = null ; class loader class loader = null ; try { fi = new file input stream ( file . get absolut path ( ) ) ; buffer input stream bi = new buffer input stream ( fi ) ; contain contain = manag . get contain ( ) ; ( contain = null ) loader = contain . get loader ( ) ; ( loader = null ) class loader = loader . get class loader ( ) ; ( class loader = null ) oi = new custom object input stream ( bi , class loader ) ; els oi = new object input stream ( bi ) ; } catch ( file found except e ) { ( manag . get contain ( ) . get logger ( ) . debug enabl ( ) ) manag . get contain ( ) . get logger ( ) . debug ( persist data file found ) ; return ( null ) ; } catch ( ioexcept e ) { ( oi = null ) { try { oi . close ( ) ; } catch ( ioexcept f ) { ignor } oi = null ; } throw e ; } try { standard session session = ( standard session ) manag . creat empti session ( ) ; session . read object data ( oi ) ; session . set manag ( manag ) ; return ( session ) ; } final { close input stream ( oi = null ) { try { oi . close ( ) ; } catch ( ioexcept f ) { ignor } } } }	public save specifi session thi store . ani previous save inform associ session identifi replac . param session session save except ioexcept input output error occur void save ( session session ) throw ioexcept { open output stream specifi pathnam , ani file file = file ( session . get id intern ( ) ) ; ( file = = null ) { return ; } ( manag . get contain ( ) . get logger ( ) . debug enabl ( ) ) { manag . get contain ( ) . get logger ( ) . debug ( sm . get string ( get store name ( ) . save , session . get id intern ( ) , file . get absolut path ( ) ) ) ; } file output stream fo = null ; object output stream oo = null ; try { fo = new file output stream ( file . get absolut path ( ) ) ; oo = new object output stream ( new buffer output stream ( fo ) ) ; } catch ( ioexcept e ) { ( oo = null ) { try { oo . close ( ) ; } catch ( ioexcept f ) { ignor } } throw e ; } try { ( ( standard session ) session ) . write object data ( oo ) ; } final { oo . close ( ) ; } }
public await shutdown . void await ( ) { server . await ( ) ; }	public start new server instanc . void load ( ) { long t1 = system . nano time ( ) ; init dir ( ) ; befor digest mai need init name ( ) ; creat execut our digest digest digest = creat start digest ( ) ; input sourc input sourc = null ; input stream input stream = null ; file file = null ; try { file = config file ( ) ; input stream = new file input stream ( file ) ; input sourc = new input sourc ( file : file . get absolut path ( ) ) ; } catch ( except e ) { ignor } ( input stream = = null ) { try { input stream = get class ( ) . get class loader ( ) . get resourc stream ( get config file ( ) ) ; input sourc = new input sourc ( get class ( ) . get class loader ( ) . get resourc ( get config file ( ) ) . string ( ) ) ; } catch ( except e ) { ignor } } altern : don t bother xml , just creat manual . ( input stream = = null ) { try { input stream = get class ( ) . get class loader ( ) . get resourc stream ( server emb . xml ) ; input sourc = new input sourc ( get class ( ) . get class loader ( ) . get resourc ( server emb . xml ) . string ( ) ) ; } catch ( except e ) { ignor } } ( ( input stream = = null ) ( file = null ) ) { log . warn ( can t load server . xml from file . get absolut path ( ) ) ; ( file . exist ( ) file . can read ( ) ) { log . warn ( permiss incorrect , read permiss allow file . ) ; } return ; } try { input sourc . set byte stream ( input stream ) ; digest . push ( thi ) ; digest . pars ( input sourc ) ; input stream . close ( ) ; } catch ( except e ) { log . warn ( catalina . start us get config file ( ) : , e ) ; return ; } stream redirect init stream ( ) ; start new server ( server instanceof lifecycl ) { try { server . initi ( ) ; } catch ( lifecycl except e ) { ( boolean . get boolean ( org . apach . catalina . startup . exit init failur ) ) throw new java . lang . error ( e ) ; els log . error ( catalina . start , e ) ; } } long t2 = system . nano time ( ) ; ( log . info enabl ( ) ) log . info ( initi process ( ( t2 t1 ) 1000000 ) ms ) ; }	protect void usag ( ) { system . out . println ( usag : java org . apach . catalina . startup . catalina config { pathnam } nonam { help start stop } ) ; }	public set share extens class loader . param parent class loader share extens class loader . void set parent class loader ( class loader parent class loader ) { thi . parent class loader = parent class loader ; }	start new server instanc . overrid public void start ( ) { ( server = = null ) { load ( ) ; } ( server = = null ) { log . fatal ( cannot start server . server instanc configur . ) ; return ; } long t1 = system . nano time ( ) ; start new server ( server instanceof lifecycl ) { try { ( ( lifecycl ) server ) . start ( ) ; } catch ( lifecycl except e ) { log . error ( catalina . start : , e ) ; } } long t2 = system . nano time ( ) ; ( log . info enabl ( ) ) log . info ( server startup ( ( t2 t1 ) 1000000 ) ms ) ; try { regist shutdown hook ( us shutdown hook ) { ( shutdown hook = = null ) { shutdown hook = new catalina shutdown hook ( ) ; } runtim . get runtim ( ) . add shutdown hook ( shutdown hook ) ; } } catch ( throwabl t ) { thi fail jdk 1 . 2 . ignor , tomcat can run fine without shutdown hook . } ( await ) { await ( ) ; stop ( ) ; } }	stop exist server instanc . overrid public void stop ( ) { try { doesn t get invok twice ( us shutdown hook ) { runtim . get runtim ( ) . remov shutdown hook ( shutdown hook ) ; } } catch ( throwabl t ) { thi fail jdk 1 . 2 . ignor , tomcat can run fine without shutdown hook . } shut down server ( server instanceof lifecycl ) { try { ( ( lifecycl ) server ) . stop ( ) ; } catch ( lifecycl except e ) { log . error ( catalina . stop , e ) ; } } }	public void stop server ( string argument ) { ( argument = null ) { argument ( argument ) ; } ( server = = null ) { creat execut our digest digest digest = creat stop digest ( ) ; digest . set class loader ( thread . current thread ( ) . get context class loader ( ) ) ; file file = config file ( ) ; try { input sourc = new input sourc ( file : file . get absolut path ( ) ) ; file input stream fi = new file input stream ( file ) ; . set byte stream ( fi ) ; digest . push ( thi ) ; digest . pars ( ) ; fi . close ( ) ; } catch ( except e ) { log . error ( catalina . stop : , e ) ; system . exit ( 1 ) ; } } stop exist server try { ( server . get port ( ) 0 ) { socket socket = new socket ( server . get address ( ) , server . get port ( ) ) ; output stream stream = socket . get output stream ( ) ; string shutdown = server . get shutdown ( ) ; ( int i = 0 ; i shutdown . length ( ) ; i ) stream . write ( shutdown . char ( i ) ) ; stream . flush ( ) ; stream . close ( ) ; socket . close ( ) ; } els { log . error ( sm . get string ( catalina . stop server ) ) ; system . exit ( 1 ) ; } } catch ( ioexcept e ) { log . error ( catalina . stop : , e ) ; system . exit ( 1 ) ; } }
public static gener sub set web fragment . xml file process order fragment must process per rule servlet spec . param applic applic web . xml file param fragment map fragment name web fragment return order list web fragment . xml file process set web xml order web fragment ( web xml applic , map string , web xml fragment ) { set web xml order fragment = new link hash set web xml ( ) ; boolean absolut order = ( applic . get absolut order ( ) = null ) ; ( absolut order ) { onli those fragment list should process set string request order = applic . get absolut order ( ) ; ( string request name : request order ) { ( web xml . order other . equal ( request name ) ) { add all fragment name explicitli thi point ( string name : fragment . kei set ( ) ) { ( request order . contain ( name ) ) { web xml fragment = fragment . get ( name ) ; ( fragment = null ) { order fragment . add ( fragment ) ; } } } } els { web xml fragment = fragment . get ( request name ) ; ( fragment = null ) { order fragment . add ( fragment ) ; } } } } els { list string order = new link list string ( ) ; start ad all fragment order doesn t matter order . add all ( fragment . kei set ( ) ) ; thei specifi other ( web xml fragment : fragment . valu ( ) ) { string name = fragment . get name ( ) ; ( fragment . get befor order ( ) . contain ( web xml . order other ) ) { move begin order . remov ( name ) ; order . add ( 0 , name ) ; } els ( fragment . get after order ( ) . contain ( web xml . order other ) ) { move end order . remov ( name ) ; order . add ( name ) ; } } now appli remain order ( web xml fragment : fragment . valu ( ) ) { string name = fragment . get name ( ) ; ( string befor : fragment . get befor order ( ) ) { ( befor . equal ( web xml . order other ) order . contain ( befor ) order . index ( befor ) order . index ( name ) ) { order . remov ( name ) ; order . add ( order . index ( befor ) , name ) ; } } ( string after : fragment . get after order ( ) ) { ( after . equal ( web xml . order other ) order . contain ( after ) order . index ( after ) order . index ( name ) ) { order . remov ( name ) ; order . add ( order . index ( after ) 1 , name ) ; } } } error indic circular refer ( web xml fragment : fragment . valu ( ) ) { string name = fragment . get name ( ) ; ( string befor : fragment . get befor order ( ) ) { ( befor . equal ( web xml . order other ) order . contain ( befor ) order . index ( befor ) order . index ( name ) ) { throw new illeg argument except ( sm . get string ( ) ) ; } } ( string after : fragment . get after order ( ) ) { ( after . equal ( web xml . order other ) order . contain ( after ) order . index ( after ) order . index ( name ) ) { throw new illeg argument except ( ) ; } } } build order list ( string name : order ) { order fragment . add ( fragment . get ( name ) ) ; } } return order fragment ; }	privat static t boolean merg map ( map string , t fragment map , map string , t main map , map string , t temp map , web xml fragment , string map name ) { ( string kei : fragment map . kei set ( ) ) { ( main map . contain kei ( kei ) ) { defin main web . xml t valu = fragment map . get ( kei ) ; ( temp map . contain kei ( kei ) ) { ( valu = null valu . equal ( temp map . get ( kei ) ) ) { log . error ( sm . get string ( web xml . merg conflict string , map name , kei , fragment . get name ( ) , fragment . get url ( ) ) ) ; return fals ; } } els { temp map . put ( kei , valu ) ; } } } return true ; }	public static string string ( byte chunk bc ) { still train ( bc cach = = null ) { string valu = bc . string intern ( ) ; ( byte enabl ( valu . length ( ) max string size ) ) { train , everyth sync synchron ( bc stat ) { we just calcul ( bc cach = null ) { return valu ; } string ( bc count train threshold ) { long t1 = system . current time milli ( ) ; sort entri accord occurr tree map integ , arrai list byte entri >> temp map = new tree map integ , arrai list byte entri >> ( ) ; iter byte entri entri = bc stat . kei set ( ) . iter ( ) ; while ( entri . ha next ( ) ) { byte entri entri = entri . next ( ) ; int count = bc stat . get ( entri ) ; integ count = new integ ( count 0 ) ; add list count arrai list byte entri list = temp map . get ( count ) ; ( list = = null ) { creat list list = new arrai list byte entri ( ) ; temp map . put ( count , list ) ; } list . add ( entri ) ; } alloc arrai right size int size = bc stat . size ( ) ; ( size cach size ) { size = cach size ; } byte entri tempbc cach = new byte entri size ; fill up us alphabet order dumb insert sort byte chunk temp chunk = new byte chunk ( ) ; int n = 0 ; while ( n size ) { object kei = temp map . last kei ( ) ; arrai list byte entri list = temp map . get ( kei ) ; ( int i = 0 ; i list . size ( ) n size ; i ) { byte entri entri = list . get ( i ) ; temp chunk . set byte ( entri . name , 0 , entri . name . length ) ; int insert po = find closest ( temp chunk , tempbc cach , n ) ; ( insert po = = n ) { tempbc cach n 1 = entri ; } els { system . arraycopi ( tempbc cach , insert po 1 , tempbc cach , insert po 2 , n insert po 1 ) ; tempbc cach insert po 1 = entri ; } n ; } temp map . remov ( kei ) ; } bc count = 0 ; bc stat . clear ( ) ; bc cach = tempbc cach ; ( log . debug enabl ( ) ) { long t2 = system . current time milli ( ) ; log . debug ( byte cach gener time : ( t2 t1 ) ms ) ; } } els { bc count ; alloc new byte entri lookup byte entri entri = new byte entri ( ) ; entri . valu = valu ; int count = bc stat . get ( entri ) ; ( count = = null ) { int end = bc . get end ( ) ; int start = bc . get start ( ) ; creat byte arrai copi byte entri . name = new byte bc . get length ( ) ; system . arraycopi ( bc . get buffer ( ) , start , entri . name , 0 , end start ) ; set encod entri . enc = bc . get encod ( ) ; initi occurr count count = new int 1 ; count 0 = 1 ; set stat hash map bc stat . put ( entri , count ) ; } els { count 0 = count 0 1 ; } } } } return valu ; } els { access count ; find correspond string string result = find ( bc ) ; ( result = = null ) { return bc . string intern ( ) ; } note : we don t care about safeti stat hit count ; return result ; } }	public static string string ( char chunk cc ) { still train ( cc cach = = null ) { string valu = cc . string intern ( ) ; ( char enabl ( valu . length ( ) max string size ) ) { train , everyth sync synchron ( cc stat ) { we just calcul ( cc cach = null ) { return valu ; } string ( cc count train threshold ) { long t1 = system . current time milli ( ) ; sort entri accord occurr tree map integ , arrai list char entri >> temp map = new tree map integ , arrai list char entri >> ( ) ; iter char entri entri = cc stat . kei set ( ) . iter ( ) ; while ( entri . ha next ( ) ) { char entri entri = entri . next ( ) ; int count = cc stat . get ( entri ) ; integ count = new integ ( count 0 ) ; add list count arrai list char entri list = temp map . get ( count ) ; ( list = = null ) { creat list list = new arrai list char entri ( ) ; temp map . put ( count , list ) ; } list . add ( entri ) ; } alloc arrai right size int size = cc stat . size ( ) ; ( size cach size ) { size = cach size ; } char entri tempcc cach = new char entri size ; fill up us alphabet order dumb insert sort char chunk temp chunk = new char chunk ( ) ; int n = 0 ; while ( n size ) { object kei = temp map . last kei ( ) ; arrai list char entri list = temp map . get ( kei ) ; ( int i = 0 ; i list . size ( ) n size ; i ) { char entri entri = list . get ( i ) ; temp chunk . set char ( entri . name , 0 , entri . name . length ) ; int insert po = find closest ( temp chunk , tempcc cach , n ) ; ( insert po = = n ) { tempcc cach n 1 = entri ; } els { system . arraycopi ( tempcc cach , insert po 1 , tempcc cach , insert po 2 , n insert po 1 ) ; tempcc cach insert po 1 = entri ; } n ; } temp map . remov ( kei ) ; } cc count = 0 ; cc stat . clear ( ) ; cc cach = tempcc cach ; ( log . debug enabl ( ) ) { long t2 = system . current time milli ( ) ; log . debug ( char cach gener time : ( t2 t1 ) ms ) ; } } els { cc count ; alloc new char entri lookup char entri entri = new char entri ( ) ; entri . valu = valu ; int count = cc stat . get ( entri ) ; ( count = = null ) { int end = cc . get end ( ) ; int start = cc . get start ( ) ; creat char arrai copi char entri . name = new char cc . get length ( ) ; system . arraycopi ( cc . get buffer ( ) , start , entri . name , 0 , end start ) ; initi occurr count count = new int 1 ; count 0 = 1 ; set stat hash map cc stat . put ( entri , count ) ; } els { count 0 = count 0 1 ; } } } } return valu ; } els { access count ; find correspond string string result = find ( cc ) ; ( result = = null ) { return cc . string intern ( ) ; } note : we don t care about safeti stat hit count ; return result ; } }	public configur { link context } us store web . xml represent . param context context configur void configur context ( context context ) { far possibl , process alphabet order so easi check everyth present some valid depend correct public id context . set public id ( public id ) ; everyth els order ( string context param : context param . kei set ( ) ) { context . add paramet ( context param , context param . get ( context param ) ) ; } context . set displai name ( displai name ) ; context . set distribut ( distribut ) ; ( context local ejb ejb local ref : ejb local ref . valu ( ) ) { context . get name resourc ( ) . add local ejb ( ejb local ref ) ; } ( context ejb ejb ref : ejb ref . valu ( ) ) { context . get name resourc ( ) . add ejb ( ejb ref ) ; } ( context environ environ : env entri . valu ( ) ) { context . get name resourc ( ) . add environ ( environ ) ; } ( error page error page : error page . valu ( ) ) { context . add error page ( error page ) ; } ( filter def filter : filter . valu ( ) ) { context . add filter def ( filter ) ; } ( filter map filter map : filter map ) { context . add filter map ( filter map ) ; } jsp properti group need after servlet configur ( string listen : listen ) { context . add applic listen ( listen ) ; } ( string local : local encod map . kei set ( ) ) { context . add local encod map paramet ( local , local encod map . get ( local ) ) ; } prevent iae ( login config = null ) { context . set login config ( login config ) ; } ( messag destin ref mdr : messag destin ref . valu ( ) ) { context . get name resourc ( ) . add messag destin ref ( mdr ) ; } messag destin were ignor tomcat 6 , so ignor here context . set ignor annot ( metadata complet ) ; ( string extens : mime map . kei set ( ) ) { context . add mime map ( extens , mime map . get ( extens ) ) ; } name just us order ( context resourc env ref resourc : resourc env ref . valu ( ) ) { context . get name resourc ( ) . add resourc env ref ( resourc ) ; } ( context resourc resourc : resourc ref . valu ( ) ) { context . get name resourc ( ) . add resourc ( resourc ) ; } ( secur constraint constraint : secur constraint ) { context . add constraint ( constraint ) ; } ( string role : secur role ) { context . add secur role ( role ) ; } ( context servic servic : servic ref . valu ( ) ) { context . get name resourc ( ) . add servic ( servic ) ; } ( servlet def servlet : servlet . valu ( ) ) { wrapper wrapper = context . creat wrapper ( ) ; descript ignor displai name ignor icon ar ignor onli set thi non null els everi servlet get mark jsp servlet string jsp file = servlet . get jsp file ( ) ; ( jsp file = null ) { wrapper . set jsp file ( jsp file ) ; } ( servlet . get load startup ( ) = null ) { wrapper . set load startup ( servlet . get load startup ( ) . int valu ( ) ) ; } ( servlet . get enabl ( ) = null ) { wrapper . set enabl ( servlet . get enabl ( ) . boolean valu ( ) ) ; } wrapper . set name ( servlet . get servlet name ( ) ) ; map string , string param = servlet . get paramet map ( ) ; ( string param : param . kei set ( ) ) { wrapper . add init paramet ( param , param . get ( param ) ) ; } wrapper . set run ( servlet . get run ( ) ) ; set secur role ref role ref = servlet . get secur role ref ( ) ; ( secur role ref role ref : role ref ) { wrapper . add secur refer ( role ref . get name ( ) , role ref . get link ( ) ) ; } wrapper . set servlet class ( servlet . get servlet class ( ) ) ; multipart def multipartdef = servlet . get multipart def ( ) ; ( multipartdef = null ) { ( multipartdef . get max file size ( ) = null multipartdef . get max request size ( ) = null multipartdef . get file size threshold ( ) = null ) { wrapper . set multipart config element ( new multipart config element ( multipartdef . get locat ( ) , long . pars long ( multipartdef . get max file size ( ) ) , long . pars long ( multipartdef . get max request size ( ) ) , integ . pars int ( multipartdef . get file size threshold ( ) ) ) ) ; } els { wrapper . set multipart config element ( new multipart config element ( multipartdef . get locat ( ) ) ) ; } } ( servlet . get async support ( ) = null ) { wrapper . set async support ( servlet . get async support ( ) . boolean valu ( ) ) ; } context . add child ( wrapper ) ; } ( string pattern : servlet map . kei set ( ) ) { context . add servlet map ( pattern , servlet map . get ( pattern ) ) ; } ( session config = null ) { ( session config . get session timeout ( ) = null ) { context . set session timeout ( session config . get session timeout ( ) . int valu ( ) ) ; } session cooki config scc = context . get servlet context ( ) . get session cooki config ( ) ; scc . set name ( session config . get cooki name ( ) ) ; scc . set domain ( session config . get cooki domain ( ) ) ; scc . set path ( session config . get cooki path ( ) ) ; scc . set comment ( session config . get cooki comment ( ) ) ; ( session config . get cooki http onli ( ) = null ) { scc . set http onli ( session config . get cooki http onli ( ) . boolean valu ( ) ) ; } ( session config . get cooki secur ( ) = null ) { scc . set secur ( session config . get cooki secur ( ) . boolean valu ( ) ) ; } ( session config . get cooki max ag ( ) = null ) { scc . set max ag ( session config . get cooki max ag ( ) . int valu ( ) ) ; } ( session config . get session track mode ( ) . size ( ) 0 ) { context . get servlet context ( ) . set session track mode ( session config . get session track mode ( ) ) ; } } ( string uri : taglib . kei set ( ) ) { context . add taglib ( uri , taglib . get ( uri ) ) ; } context doesn t us version directli ( string welcom file : welcom file ) { context . add welcom file ( welcom file ) ; } do thi last depend servlet ( jsp properti group jsp properti group : jsp properti group ) { context . add jsp map ( jsp properti group . get url pattern ( ) ) ; } }
protect static return code true code given code str code match least given code pattern code . boolean match ( string str , pattern . . . pattern ) { ( pattern pattern : pattern ) { ( pattern . matcher ( str ) . match ( ) ) { return true ; } } return fals ; }	public string get remot host ( ) { return remot host ; }	public see set remot ip header ( string ) return remot ip header name ( e . g . x forward ) string get remot ip header ( ) { return remot ip header ; }	public int get http server port ( ) { return http server port ; }	{ inherit doc } overrid public void invok ( request request , respons respons ) throw ioexcept , servlet except { final string origin remot addr = request . get remot addr ( ) ; final string origin remot host = request . get remot host ( ) ; final string origin scheme = request . get scheme ( ) ; final boolean origin secur = request . secur ( ) ; final int origin server port = request . get server port ( ) ; ( match ( origin remot addr , intern proxi ) ) { string remot ip = null ; java 6 , proxi header valu should declar java . util . dequ link list string proxi header valu = new link list string ( ) ; string remot iphead valu = comma delimit list string arrai ( request . get header ( remot ip header ) ) ; int idx ; loop remot iphead valu find first trust remot ip build proxi chain ( idx = remot iphead valu . length 1 ; idx = 0 ; idx ) { string current remot ip = remot iphead valu idx ; remot ip = current remot ip ; ( match ( current remot ip , intern proxi ) ) { do noth , intern proxi ip ar append } els ( match ( current remot ip , trust proxi ) ) { proxi header valu . add first ( current remot ip ) ; } els { decrement idx becaus break statement doesn t do idx ; break ; } } continu loop remot iphead valu build new valu remot iphead link list string new remot ip header valu = new link list string ( ) ; ( ; idx = 0 ; idx ) { string current remot ip = remot iphead valu idx ; new remot ip header valu . add first ( current remot ip ) ; } ( remot ip = null ) { request . set remot addr ( remot ip ) ; request . set remot host ( remot ip ) ; 6 . 0 ( proxi header valu . size ( ) = = 0 ) { request . get coyot request ( ) . get mime header ( ) . remov header ( proxi header ) ; } els { string comma delimit list proxi = list comma delimit string ( proxi header valu ) ; request . get coyot request ( ) . get mime header ( ) . set valu ( proxi header ) . set string ( comma delimit list proxi ) ; } ( new remot ip header valu . size ( ) = = 0 ) { request . get coyot request ( ) . get mime header ( ) . remov header ( remot ip header ) ; } els { string comma delimit remot ip header valu = list comma delimit string ( new remot ip header valu ) ; request . get coyot request ( ) . get mime header ( ) . set valu ( remot ip header ) . set string ( comma delimit remot ip header valu ) ; } } ( protocol header = null ) { string protocol header valu = request . get header ( protocol header ) ; ( protocol header valu = null protocol header http valu . equal ignor case ( protocol header valu ) ) { request . set secur ( true ) ; us request . coyot request . scheme instead request . set scheme ( ) becaus request . set scheme ( ) op tomcat 6 . 0 request . get coyot request ( ) . scheme ( ) . set string ( http ) ; request . set server port ( http server port ) ; } } ( log . debug enabl ( ) ) { log . debug ( incom request request . get request uri ( ) origin remot addr origin remot addr , origin remot host = origin remot host , origin secur = origin secur , origin scheme = origin scheme seen new remot addr = request . get remot addr ( ) , new remot host = request . get remot host ( ) , new scheme = request . get scheme ( ) , new secur = request . secur ( ) ) ; } } try { get next ( ) . invok ( request , respons ) ; } final { request . set remot addr ( origin remot addr ) ; request . set remot host ( origin remot host ) ; request . set secur ( origin secur ) ; us request . coyot request . scheme instead request . set scheme ( ) becaus request . set scheme ( ) op tomcat 6 . 0 request . get coyot request ( ) . scheme ( ) . set string ( origin scheme ) ; request . set server port ( origin server port ) ; } }	overrid public void invok ( request request , respons respons ) throw ioexcept , servlet except { thi . remot host = request . get remot host ( ) ; thi . remot addr = request . get remot addr ( ) ; }	public void test invok all proxi ar trust remot addr match regexp ( ) throw except { prepar remot ip valv remot ip valv = new remot ip valv ( ) ; remot ip valv . set intern proxi ( 127 . 0 . 0 . 1 , 192 . 168 . . , anoth intern proxi ) ; remot ip valv . set trust proxi ( proxy1 , proxy2 , proxy3 ) ; remot ip valv . set remot ip header ( x forward ) ; remot ip valv . set proxi header ( x forward ) ; remot addr host tracker valv remot addr host tracker valv = new remot addr host tracker valv ( ) ; remot ip valv . set next ( remot addr host tracker valv ) ; request request = new request ( ) ; request . set coyot request ( new org . apach . coyot . request ( ) ) ; request . set remot addr ( 192 . 168 . 0 . 10 ) ; request . set remot host ( remot host origin valu ) ; request . get coyot request ( ) . get mime header ( ) . add valu ( x forward ) . set string ( 140 . 211 . 11 . 130 , proxy1 , proxy2 ) ; test remot ip valv . invok ( request , null ) ; verifi string actual xforward = request . get header ( x forward ) ; assert null ( all proxi ar trust , x forward must null , actual xforward ) ; string actual xforward = request . get header ( x forward ) ; assert equal ( all proxi ar trust , thei must appear x forward , proxy1 , proxy2 , actual xforward ) ; string actual remot addr = remot addr host tracker valv . get remot addr ( ) ; assert equal ( remot addr , 140 . 211 . 11 . 130 , actual remot addr ) ; string actual remot host = remot addr host tracker valv . get remot host ( ) ; assert equal ( remot host , 140 . 211 . 11 . 130 , actual remot host ) ; string actual post invok remot addr = request . get remot addr ( ) ; assert equal ( post invok remot addr , 192 . 168 . 0 . 10 , actual post invok remot addr ) ; string actual post invok remot host = request . get remot host ( ) ; assert equal ( post invok remot addr , remot host origin valu , actual post invok remot host ) ; }
protect static return code true code given code str code match least given code pattern code . boolean match ( string str , pattern . . . pattern ) { ( pattern pattern : pattern ) { ( pattern . matcher ( str ) . match ( ) ) { return true ; } } return fals ; }	public void do filter ( http servlet request request , http servlet respons respons , filter chain chain ) throw ioexcept , servlet except { ( match ( request . get remot addr ( ) , intern proxi ) ) { string remot ip = null ; java 6 , proxi header valu should declar java . util . dequ link list string proxi header valu = new link list string ( ) ; string remot iphead valu = comma delimit list string arrai ( request . get header ( remot iphead ) ) ; int idx ; loop remot iphead valu find first trust remot ip build proxi chain ( idx = remot iphead valu . length 1 ; idx = 0 ; idx ) { string current remot ip = remot iphead valu idx ; remot ip = current remot ip ; ( match ( current remot ip , intern proxi ) ) { do noth , intern proxi ip ar append } els ( match ( current remot ip , trust proxi ) ) { proxi header valu . add first ( current remot ip ) ; } els { decrement idx becaus break statement doesn t do idx ; break ; } } continu loop remot iphead valu build new valu remot iphead link list string new remot ip header valu = new link list string ( ) ; ( ; idx = 0 ; idx ) { string current remot ip = remot iphead valu idx ; new remot ip header valu . add first ( current remot ip ) ; } xforward request x request = new xforward request ( request ) ; ( remot ip = null ) { x request . set remot addr ( remot ip ) ; x request . set remot host ( remot ip ) ; ( proxi header valu . size ( ) = = 0 ) { x request . remov header ( proxi header ) ; } els { string comma delimit list proxi = list comma delimit string ( proxi header valu ) ; x request . set header ( proxi header , comma delimit list proxi ) ; } ( new remot ip header valu . size ( ) = = 0 ) { x request . remov header ( remot iphead ) ; } els { string comma delimit remot ip header valu = list comma delimit string ( new remot ip header valu ) ; x request . set header ( remot iphead , comma delimit remot ip header valu ) ; } } ( protocol header = null ) { string protocol header valu = request . get header ( protocol header ) ; ( protocol header valu = null protocol header http valu . equal ignor case ( protocol header valu ) ) { x request . set secur ( true ) ; x request . set scheme ( http ) ; x request . set server port ( http server port ) ; } } ( log . debug enabl ( ) ) { log . debug ( incom request request . get request uri ( ) origin remot addr request . get remot addr ( ) , origin remot host = request . get remot host ( ) , origin secur = request . secur ( ) , origin scheme = request . get scheme ( ) , origin remot iphead = request . get header ( remot iphead ) , origin protocol header = ( protocol header = = null null : request . get header ( protocol header ) ) seen new remot addr = x request . get remot addr ( ) , new remot host = x request . get remot host ( ) , new scheme = x request . get scheme ( ) , new secur = x request . secur ( ) , new remot iphead = x request . get header ( remot iphead ) , new proxi header = x request . get header ( proxi header ) ) ; } chain . do filter ( x request , respons ) ; } els { chain . do filter ( request , respons ) ; } }	public void init ( filter config filter config ) throw servlet except { ( filter config . get init paramet ( intern proxi paramet ) = null ) { set intern proxi ( filter config . get init paramet ( intern proxi paramet ) ) ; } ( filter config . get init paramet ( protocol header paramet ) = null ) { set protocol header ( filter config . get init paramet ( protocol header paramet ) ) ; } ( filter config . get init paramet ( protocol header http valu paramet ) = null ) { set protocol header http valu ( filter config . get init paramet ( protocol header http valu paramet ) ) ; } ( filter config . get init paramet ( proxi header paramet ) = null ) { set proxi header ( filter config . get init paramet ( proxi header paramet ) ) ; } ( filter config . get init paramet ( remot ip header paramet ) = null ) { set remot iphead ( filter config . get init paramet ( remot ip header paramet ) ) ; } ( filter config . get init paramet ( trust proxi paramet ) = null ) { set trust proxi ( filter config . get init paramet ( trust proxi paramet ) ) ; } ( filter config . get init paramet ( http server port paramet ) = null ) { try { set http server port ( integ . pars int ( filter config . get init paramet ( http server port paramet ) ) ) ; } catch ( number format except e ) { throw new number format except ( illeg server port : e . get messag ( ) ) ; } } }	protect static string comma delimit list string arrai ( string comma delimit string ) { return ( comma delimit string = = null comma delimit string . length ( ) = = 0 ) new string 0 : comma separ valu pattern . split ( comma delimit string ) ; }
public static decod return specifi url encod byte arrai . assum string queri string . param byte url encod byte arrai param enc encod us ; null , default encod us except illeg argument except charact follow valid 2 digit hexadecim number string urldecod ( byte byte , string enc ) { return urldecod ( byte , null , fals ) ; }
protect synchron return princip associ given user name . princip get princip ( dir context context , string usernam ) throw name except { user user = get user ( context , usernam ) ; return new gener princip ( user . usernam , user . password , get role ( context , user ) ) ; }
protect when commit respons , we have valid set header , well setup respons filter . void prepar respons ( ) throw ioexcept { boolean entiti bodi = true ; content delimit = fals ; output filter output filter = output buffer . get filter ( ) ; ( http09 = = true ) { http 0 . 9 output buffer . add activ filter ( output filter constant . ident filter ) ; return ; } int statu code = respons . get statu ( ) ; ( ( statu code = = 204 ) ( statu code = = 205 ) ( statu code = = 304 ) ) { entiti bodi output buffer . add activ filter ( output filter constant . void filter ) ; entiti bodi = fals ; content delimit = true ; } messag byte method mb = request . method ( ) ; ( method mb . equal ( head ) ) { entiti bodi output buffer . add activ filter ( output filter constant . void filter ) ; content delimit = true ; } sendfil support ( thi . endpoint . get us sendfil ( ) ) { string file name = ( string ) request . get attribut ( org . apach . tomcat . sendfil . filenam ) ; ( file name = null ) { entiti bodi sent here output buffer . add activ filter ( output filter constant . void filter ) ; content delimit = true ; sendfil data = new nio endpoint . sendfil data ( ) ; sendfil data . file name = file name ; sendfil data . po = ( ( long ) request . get attribut ( org . apach . tomcat . sendfil . start ) ) . long valu ( ) ; sendfil data . length = ( ( long ) request . get attribut ( org . apach . tomcat . sendfil . end ) ) . long valu ( ) sendfil data . po ; } } check compress boolean us compress = fals ; ( entiti bodi ( compress level 0 ) ( sendfil data = = null ) ) { us compress = compress ( ) ; chang content length 1 forc chunk ( us compress ) { respons . set content length ( 1 ) ; } } mime header header = respons . get mime header ( ) ; ( entiti bodi ) { respons . set content length ( 1 ) ; } els { string content type = respons . get content type ( ) ; ( content type = null ) { header . set valu ( content type ) . set string ( content type ) ; } string content languag = respons . get content languag ( ) ; ( content languag = null ) { header . set valu ( content languag ) . set string ( content languag ) ; } } long content length = respons . get content length long ( ) ; ( content length = 1 ) { header . set valu ( content length ) . set long ( content length ) ; output buffer . add activ filter ( output filter constant . ident filter ) ; content delimit = true ; } els { ( entiti bodi http11 keep aliv ) { output buffer . add activ filter ( output filter constant . chunk filter ) ; content delimit = true ; header . add valu ( constant . transferencod ) . set string ( constant . chunk ) ; } els { output buffer . add activ filter ( output filter constant . ident filter ) ; } } ( us compress ) { output buffer . add activ filter ( output filter constant . gzip filter ) ; header . set valu ( content encod ) . set string ( gzip ) ; make proxi happi via vari ( from mod deflat ) header . set valu ( vari ) . set string ( accept encod ) ; } add date header header . set valu ( date ) . set string ( fast http date format . get current date ( ) ) ; fixm : add transfer encod header ( ( entiti bodi ) ( content delimit ) ) { mark close connect after request , add connect : close header keep aliv = fals ; } we know request bad thi earli , add connect : close header . keep aliv = keep aliv statu drop connect ( statu code ) ; ( keep aliv ) { header . add valu ( constant . connect ) . set string ( constant . close ) ; } els ( http11 error ) { header . add valu ( constant . connect ) . set string ( constant . keepal ) ; } build respons header output buffer . send statu ( ) ; add server header ( server = null ) { header . set valu ( server ) . set string ( server ) ; } els { output buffer . write ( constant . server byte ) ; } int size = header . size ( ) ; ( int i = 0 ; i size ; i ) { output buffer . send header ( header . get name ( i ) , header . get valu ( i ) ) ; } output buffer . end header ( ) ; }	protect when commit respons , we have valid set header , well setup respons filter . void prepar respons ( ) { boolean entiti bodi = true ; content delimit = fals ; output filter output filter = output buffer . get filter ( ) ; ( http09 = = true ) { http 0 . 9 output buffer . add activ filter ( output filter constant . ident filter ) ; return ; } int statu code = respons . get statu ( ) ; ( ( statu code = = 204 ) ( statu code = = 205 ) ( statu code = = 304 ) ) { entiti bodi output buffer . add activ filter ( output filter constant . void filter ) ; entiti bodi = fals ; content delimit = true ; } messag byte method mb = request . method ( ) ; ( method mb . equal ( head ) ) { entiti bodi output buffer . add activ filter ( output filter constant . void filter ) ; content delimit = true ; } sendfil support ( endpoint . get us sendfil ( ) ) { string file name = ( string ) request . get attribut ( org . apach . tomcat . sendfil . filenam ) ; ( file name = null ) { entiti bodi sent here output buffer . add activ filter ( output filter constant . void filter ) ; content delimit = true ; sendfil data = new apr endpoint . sendfil data ( ) ; sendfil data . file name = file name ; sendfil data . start = ( ( long ) request . get attribut ( org . apach . tomcat . sendfil . start ) ) . long valu ( ) ; sendfil data . end = ( ( long ) request . get attribut ( org . apach . tomcat . sendfil . end ) ) . long valu ( ) ; } } check compress boolean us compress = fals ; ( entiti bodi ( compress level 0 ) ( sendfil data = = null ) ) { us compress = compress ( ) ; chang content length 1 forc chunk ( us compress ) { respons . set content length ( 1 ) ; } } mime header header = respons . get mime header ( ) ; ( entiti bodi ) { respons . set content length ( 1 ) ; } els { string content type = respons . get content type ( ) ; ( content type = null ) { header . set valu ( content type ) . set string ( content type ) ; } string content languag = respons . get content languag ( ) ; ( content languag = null ) { header . set valu ( content languag ) . set string ( content languag ) ; } } long content length = respons . get content length long ( ) ; ( content length = 1 ) { header . set valu ( content length ) . set long ( content length ) ; output buffer . add activ filter ( output filter constant . ident filter ) ; content delimit = true ; } els { ( entiti bodi http11 keep aliv ) { output buffer . add activ filter ( output filter constant . chunk filter ) ; content delimit = true ; header . add valu ( constant . transferencod ) . set string ( constant . chunk ) ; } els { output buffer . add activ filter ( output filter constant . ident filter ) ; } } ( us compress ) { output buffer . add activ filter ( output filter constant . gzip filter ) ; header . set valu ( content encod ) . set string ( gzip ) ; make proxi happi via vari ( from mod deflat ) header . set valu ( vari ) . set string ( accept encod ) ; } add date header header . set valu ( date ) . set string ( fast http date format . get current date ( ) ) ; fixm : add transfer encod header ( ( entiti bodi ) ( content delimit ) ) { mark close connect after request , add connect : close header keep aliv = fals ; } we know request bad thi earli , add connect : close header . keep aliv = keep aliv statu drop connect ( statu code ) ; ( keep aliv ) { header . add valu ( constant . connect ) . set string ( constant . close ) ; } els ( http11 error ) { header . add valu ( constant . connect ) . set string ( constant . keepal ) ; } build respons header output buffer . send statu ( ) ; add server header ( server = null ) { header . set valu ( server ) . set string ( server ) ; } els { output buffer . write ( constant . server byte ) ; } int size = header . size ( ) ; ( int i = 0 ; i size ; i ) { output buffer . send header ( header . get name ( i ) , header . get valu ( i ) ) ; } output buffer . end header ( ) ; }	protect void prepar respons ( ) { boolean entiti bodi = true ; content delimit = fals ; output filter output filter = output buffer . get filter ( ) ; ( http09 = = true ) { http 0 . 9 output buffer . add activ filter ( output filter constant . ident filter ) ; return ; } int statu code = respons . get statu ( ) ; ( ( statu code = = 204 ) ( statu code = = 205 ) ( statu code = = 304 ) ) { entiti bodi output buffer . add activ filter ( output filter constant . void filter ) ; entiti bodi = fals ; content delimit = true ; } messag byte method mb = request . method ( ) ; ( method mb . equal ( head ) ) { entiti bodi output buffer . add activ filter ( output filter constant . void filter ) ; content delimit = true ; } check compress boolean us compress = fals ; ( entiti bodi ( compress level 0 ) ) { us compress = compress ( ) ; chang content length 1 forc chunk ( us compress ) { respons . set content length ( 1 ) ; } } mime header header = respons . get mime header ( ) ; ( entiti bodi ) { respons . set content length ( 1 ) ; } els { string content type = respons . get content type ( ) ; ( content type = null ) { header . set valu ( content type ) . set string ( content type ) ; } string content languag = respons . get content languag ( ) ; ( content languag = null ) { header . set valu ( content languag ) . set string ( content languag ) ; } } long content length = respons . get content length long ( ) ; ( content length = 1 ) { header . set valu ( content length ) . set long ( content length ) ; output buffer . add activ filter ( output filter constant . ident filter ) ; content delimit = true ; } els { ( entiti bodi http11 keep aliv ) { output buffer . add activ filter ( output filter constant . chunk filter ) ; content delimit = true ; header . add valu ( constant . transferencod ) . set string ( constant . chunk ) ; } els { output buffer . add activ filter ( output filter constant . ident filter ) ; } } ( us compress ) { output buffer . add activ filter ( output filter constant . gzip filter ) ; header . set valu ( content encod ) . set string ( gzip ) ; make proxi happi via vari ( from mod deflat ) header . set valu ( vari ) . set string ( accept encod ) ; } add date header string date = null ; ( secur enabl ) { date = access control . do privileg ( new privileg action string ( ) { public string run ( ) { return fast http date format . get current date ( ) ; } } ) ; } els { date = fast http date format . get current date ( ) ; } header . set valu ( date ) . set string ( date ) ; fixm : add transfer encod header ( ( entiti bodi ) ( content delimit ) ) { mark close connect after request , add connect : close header keep aliv = fals ; } we know request bad thi earli , add connect : close header . keep aliv = keep aliv statu drop connect ( statu code ) ; ( keep aliv ) { header . add valu ( constant . connect ) . set string ( constant . close ) ; } els ( http11 error ) { header . add valu ( constant . connect ) . set string ( constant . keepal ) ; } build respons header output buffer . send statu ( ) ; add server header ( server = null ) { header . set valu ( server ) . set string ( server ) ; } els { output buffer . write ( constant . server byte ) ; } int size = header . size ( ) ; ( int i = 0 ; i size ; i ) { output buffer . send header ( header . get name ( i ) , header . get valu ( i ) ) ; } output buffer . end header ( ) ; }
system properti replac given string . param str origin string return modifi string string replac ( string str ) { string result = str ; int po start = result . index ( { ) ; ( po start = 1 ) { int po end = result . index ( } ) ; ( po end = 1 ) { string prop name = result . substr ( po start 2 , po end ) ; string replac = system . get properti ( prop name ) ; ( replac = null ) { ( po start 0 ) { result = result . substr ( 0 , po start ) replac replac ( result . substr ( po end 1 ) ) ; } els { result = replac replac ( result . substr ( po end 1 ) ) ; } } } } return result ; }	public static conveni method return name logger , without applic have care about factori . param name logic name code log code instanc return ( mean thi name onli known underli log implement wrap ) except log configur except suitabl code log code instanc cannot return log get log ( string name ) throw log configur except { return ( get factori ( ) . get instanc ( name ) ) ; }
protect void process annot jndi ( url url , web xml fragment ) { try { urlconnect url conn = url . open connect ( ) ; dir context urlconnect dc url conn ; ( ( url conn instanceof dir context urlconnect ) ) { thi should never happen sm . get string ( context config . jndi url , url ) ; return ; } dc url conn = ( dir context urlconnect ) url conn ; dc url conn . set us cach ( fals ) ; string type = dc url conn . get header field ( resourc attribut . type ) ; ( resourc attribut . collect type . equal ( type ) ) { collect enumer string dir = dc url conn . list ( ) ; while ( dir . ha more element ( ) ) { string dir = dir . next element ( ) ; url dir url = new url ( url . string ( ) dir ) ; process annot jndi ( dir url , fragment ) ; } } els { singl file ( url . get path ( ) . end ( . class ) ) { input stream = null ; try { = dc url conn . get input stream ( ) ; process annot stream ( , fragment ) ; } catch ( ioexcept e ) { log . error ( sm . get string ( context config . input stream jndi , url ) , e ) ; } final { ( = null ) { try { . close ( ) ; } catch ( throwabl t ) { ignor } } } } } } catch ( ioexcept e ) { log . error ( sm . get string ( context config . jndi url , url ) , e ) ; } }
privat boolean assign ( object valu , class target class ) { ( target class = = null ) { return fals ; } els ( valu = null target class . primit ( ) ) { return fals ; } els ( valu = null target class . instanc ( valu ) ) { return fals ; } return true ; }	privat final deregist ani jdbc driver regist webapp webapp forgot . thi made unnecessari complex becaus ) driver manag check class loader call class ( would much easier check context class loader ) b ) us reflect would creat depend driver manag implement which can , ha , chang . we can t just creat instanc jdbc leak prevent load common class loader ( sinc s . class file catalina home lib directori ) . thi would fail driver manag s check class loader call class . so , we load byte via our parent class loader defin class thi class loader so jdbc leak prevent look like webapp class driver manag . onli app clean up after themselv . . . void clear refer jdbc ( ) { input stream = get resourc stream ( org apach catalina loader jdbc leak prevent . class ) ; we know roughli how big class ( 1k ) so allow 2k start point byte class byte = new byte 2048 ; int offset = 0 ; try { int read = . read ( class byte , offset , class byte . length offset ) ; while ( read 1 ) { offset = read ; ( offset = = class byte . length ) { buffer full doubl size byte tmp = new byte class byte . length 2 ; system . arraycopi ( class byte , 0 , tmp , 0 , class byte . length ) ; class byte = tmp ; } read = . read ( class byte , offset , class byte . length offset ) ; } class lp class = defin class ( org . apach . catalina . loader . jdbc leak prevent , class byte , 0 , offset ) ; object obj = lp class . new instanc ( ) ; suppress warn ( uncheck ) list string driver name = ( list string ) obj . get class ( ) . get method ( clear jdbc driver registr ) . invok ( obj ) ; ( string name : driver name ) { log . error ( sm . get string ( webapp class loader . clear jbdc , name ) ) ; } } catch ( except e ) { so mani thing go wrong abov . . . log . warn ( sm . get string ( webapp class loader . jdbc remov fail ) , e ) ; } final { ( = null ) { try { . close ( ) ; } catch ( ioexcept ioe ) { log . warn ( sm . get string ( webapp class loader . jdbc remov stream error ) , ioe ) ; } } } }	privat final void clear refer static final ( ) { suppress warn ( uncheck ) collect resourc entri valu = ( ( hash map string , resourc entri ) resourc entri . clone ( ) ) . valu ( ) ; iter resourc entri load class = valu . iter ( ) ; class mai call previous clear class . while ( load class . ha next ( ) ) { resourc entri entri = load class . next ( ) ; ( entri . load class = null ) { class clazz = entri . load class ; try { field field = clazz . get declar field ( ) ; ( int i = 0 ; i field . length ; i ) { ( modifi . static ( field i . get modifi ( ) ) ) { field i . get ( null ) ; break ; } } } catch ( throwabl t ) { ignor } } } load class = valu . iter ( ) ; while ( load class . ha next ( ) ) { resourc entri entri = load class . next ( ) ; ( entri . load class = null ) { class clazz = entri . load class ; try { field field = clazz . get declar field ( ) ; ( int i = 0 ; i field . length ; i ) { field field = field i ; int mod = field . get modifi ( ) ; ( field . get type ( ) . primit ( ) ( field . get name ( ) . index ( ) = 1 ) ) { continu ; } ( modifi . static ( mod ) ) { try { field . set access ( true ) ; ( modifi . final ( mod ) ) { ( ( ( field . get type ( ) . get name ( ) . start ( java . ) ) ( field . get type ( ) . get name ( ) . start ( javax . ) ) ) ) { null instanc ( field . get ( null ) ) ; } } els { field . set ( null , null ) ; ( log . debug enabl ( ) ) { log . debug ( set field field . get name ( ) null class clazz . get name ( ) ) ; } } } catch ( throwabl t ) { ( log . debug enabl ( ) ) { log . debug ( could set field field . get name ( ) null class clazz . get name ( ) , t ) ; } } } } } catch ( throwabl t ) { ( log . debug enabl ( ) ) { log . debug ( could clean field class clazz . get name ( ) , t ) ; } } } } }	privat void null instanc ( object instanc ) { ( instanc = = null ) { return ; } field field = instanc . get class ( ) . get declar field ( ) ; ( int i = 0 ; i field . length ; i ) { field field = field i ; int mod = field . get modifi ( ) ; ( field . get type ( ) . primit ( ) ( field . get name ( ) . index ( ) = 1 ) ) { continu ; } try { field . set access ( true ) ; ( modifi . static ( mod ) modifi . final ( mod ) ) { do someth recurs too riski continu ; } object valu = field . get ( instanc ) ; ( null = valu ) { class extend object valu class = valu . get class ( ) ; ( load thi child ( valu class ) ) { ( log . debug enabl ( ) ) { log . debug ( set field field . get name ( ) null object class instanc . get class ( ) . get name ( ) becaus referenc object wa type valu class . get name ( ) which wa load thi webapp class loader . ) ; } } els { field . set ( instanc , null ) ; ( log . debug enabl ( ) ) { log . debug ( set field field . get name ( ) null class instanc . get class ( ) . get name ( ) ) ; } } } } catch ( throwabl t ) { ( log . debug enabl ( ) ) { log . debug ( could set field field . get name ( ) null object instanc class instanc . get class ( ) . get name ( ) , t ) ; } } } }	overrid public attribut get attribut ( string name ) throw name except { handl virtual tld ( name . start ( web inf ) name . end ( . tld ) ) { string tld name = name . substr ( name . last index ( ) 1 ) ; ( virtual map . contain kei ( tld name ) ) { return new file resourc attribut ( virtual map . get ( tld name ) ) ; } } els ( name . start ( meta inf tag ) name . end ( . tag ) name . end ( . tagx ) ) { alreadi load tag file ( tagfil map . contain kei ( name ) ) { return new file resourc attribut ( tagfil map . get ( name ) ) ; } unknown tagfil , search virtual classpath string token tkn = new string token ( virtual classpath , ; ) ; while ( tkn . ha more token ( ) ) { file file = new file ( tkn . next token ( ) , name ) ; ( file . exist ( ) ) { tagfil map . put ( name , file ) ; return new file resourc attribut ( file ) ; } } } return super . get attribut ( name ) ; }	privat class get type ( ) { return type ; }	suppress warn ( uncheck ) overrid public method info get method info ( evalu context ctx , class param type ) throw elexcept { target t = get target ( ctx ) ; method m = reflect util . get method ( t . base , t . properti , param type ) ; return new method info ( m . get name ( ) , m . get return type ( ) , m . get paramet type ( ) ) ; }	suppress warn ( uncheck ) public method info get method info ( evalu context ctx , class param type ) throw elexcept { throw new unsupport oper except ( ) ; }	can t us class becaus api need match specif suppress warn ( uncheck ) public object get context ( class kei ) { ( thi . map = = null ) { return null ; } return thi . map . get ( kei ) ; }	suppress warn ( uncheck ) overrid public object invok ( evalu context ctx , class param type , object param valu ) throw elexcept { return thi . get method express ( ctx ) . invok ( ctx . get elcontext ( ) , param valu ) ; }	suppress warn ( uncheck ) public object invok ( evalu context ctx , class param type , object param valu ) throw elexcept { throw new unsupport oper except ( ) ; }	overrid public variabl mapper get variabl mapper ( ) { return thi . var mapper ; }	overrid public boolean properti resolv ( ) { return thi . el context . properti resolv ( ) ; }	overrid public boolean read onli ( elcontext context , object base , object properti ) throw null pointer except , properti found except , elexcept { ( context = = null ) { throw new null pointer except ( ) ; } ( base instanceof resourc bundl ) { context . set properti resolv ( true ) ; } return true ; }	public static final compar two object , after coerc same type appropri . object ar ident , thei ar equal accord { link equal ( object , object ) } return 0 . either object big decim , coerc both big decim first . similarli doubl ( float ) , big integ , long ( integ , char , short , byte ) . otherwis , check first object instanc compar , compar against second object . null , return 1 , otherwis return result compar against second object . similarli , second object compar , first null , return 1 , els return result compar against first object . null object consid : ul li zero when compar number li li empti string string compar li li otherwis null consid lower than anyth els . li ul param obj0 first object param obj1 second object return 1 , 0 , 1 thi object less than , equal , greater than val . throw elexcept neither object compar throw class cast except object ar mutual compar int compar ( final object obj0 , final object obj1 ) throw elexcept { ( obj0 = = obj1 equal ( obj0 , obj1 ) ) { return 0 ; } ( big decim op ( obj0 , obj1 ) ) { big decim bd0 = ( big decim ) coerc number ( obj0 , big decim . class ) ; big decim bd1 = ( big decim ) coerc number ( obj1 , big decim . class ) ; return bd0 . compar ( bd1 ) ; } ( doubl op ( obj0 , obj1 ) ) { doubl d0 = ( doubl ) coerc number ( obj0 , doubl . class ) ; doubl d1 = ( doubl ) coerc number ( obj1 , doubl . class ) ; return d0 . compar ( d1 ) ; } ( big integ op ( obj0 , obj1 ) ) { big integ bi0 = ( big integ ) coerc number ( obj0 , big integ . class ) ; big integ bi1 = ( big integ ) coerc number ( obj1 , big integ . class ) ; return bi0 . compar ( bi1 ) ; } ( long op ( obj0 , obj1 ) ) { long l0 = ( long ) coerc number ( obj0 , long . class ) ; long l1 = ( long ) coerc number ( obj1 , long . class ) ; return l0 . compar ( l1 ) ; } ( obj0 instanceof string obj1 instanceof string ) { return coerc string ( obj0 ) . compar ( coerc string ( obj1 ) ) ; } ( obj0 instanceof compar ) { suppress warn ( uncheck ) final compar object compar = ( compar object ) obj0 ; return ( obj1 = null ) compar . compar ( obj1 ) : 1 ; } ( obj1 instanceof compar ) { suppress warn ( uncheck ) final compar object compar = ( compar object ) obj1 ; return ( obj0 = null ) compar . compar ( obj0 ) : 1 ; } throw new elexcept ( messag factori . get ( error . compar , obj0 , obj1 ) ) ; }	public void accept ( node visitor visitor ) throw except { visitor . visit ( thi ) ; ( thi . children = null thi . children . length 0 ) { ( int i = 0 ; i thi . children . length ; i ) { thi . children i . accept ( visitor ) ; } } }	overrid public void set valu ( evalu context ctx , object valu ) throw elexcept { variabl mapper var mapper = ctx . get variabl mapper ( ) ; ( var mapper = null ) { valu express expr = var mapper . resolv variabl ( thi . imag ) ; ( expr = null ) { expr . set valu ( ctx . get elcontext ( ) , valu ) ; return ; } } ctx . set properti resolv ( fals ) ; ctx . get elresolv ( ) . set valu ( ctx , null , thi . imag , valu ) ; }
privat string evalu express ( string express ) { elcontext impl ctx = new elcontext impl ( ) ; express factori impl expr factori = new express factori impl ( ) ; valu express ve = expr factori . creat valu express ( ctx , express , string . class ) ; return ( string ) ve . get valu ( ctx ) ; }	public void test parser string liter ( ) { inspir work bug 45451 , comment from kkolinko dev list look spec find some edg case onli escap charact insid string liter assert equal ( , evalu express ( { } ) ) ; assert equal ( , evalu express ( { } ) ) ; can us insid when quot vice versa without escap assert equal ( , evalu express ( { } ) ) ; assert equal ( , evalu express ( { } ) ) ; assert equal ( , evalu express ( { } ) ) ; assert equal ( , evalu express ( { } ) ) ; assert equal ( , evalu express ( { } ) ) ; assert equal ( , evalu express ( { } ) ) ; assert equal ( , evalu express ( { } ) ) ; assert equal ( , evalu express ( { } ) ) ; }
protect object name creat object name ( string domain , string type ) throw malform object name except { string encod addr = null ; ( get properti ( address ) = null ) { encod addr = urlencod . encod ( get properti ( address ) . string ( ) ) ; } string add suffix = ( get properti ( address ) = = null ) : , address = encod addr ; object name onam = new object name ( domain : type = type , port = get port ( ) add suffix ) ; return onam ; }	static creat code object name code thi code valv code object . param domain domain which thi name creat param valv valv name except malform object name except name cannot creat object name creat object name ( string domain , valv valv ) throw malform object name except { ( valv instanceof valv base ) { object name name = ( ( valv base ) valv ) . get object name ( ) ; ( name = null ) return name ; } object name name = null ; contain contain = null ; string class name = valv . get class ( ) . get name ( ) ; int period = class name . last index ( . ) ; ( period = 0 ) class name = class name . substr ( period 1 ) ; ( valv instanceof contain ) { contain = ( ( contain ) valv ) . get contain ( ) ; } ( contain = = null ) { throw new malform object name except ( cannot creat mbean non contain valv valv ) ; } ( contain instanceof engin ) { string local = ; int seq = get seq ( local ) ; string ext = ; ( seq 0 ) { ext = , seq = seq ; } name = new object name ( domain : type = valv , name = class name ext local ) ; } els ( contain instanceof host ) { string local = , host = contain . get name ( ) ; int seq = get seq ( local ) ; string ext = ; ( seq 0 ) { ext = , seq = seq ; } name = new object name ( domain : type = valv , name = class name ext local ) ; } els ( contain instanceof context ) { string path = ( ( context ) contain ) . get path ( ) ; ( path . length ( ) 1 ) { path = ; } host host = ( host ) contain . get parent ( ) ; string local = , path = path , host = host . get name ( ) ; int seq = get seq ( local ) ; string ext = ; ( seq 0 ) { ext = , seq = seq ; } name = new object name ( domain : type = valv , name = class name ext local ) ; } return ( name ) ; }
public servic method . void servic ( org . apach . coyot . request req , org . apach . coyot . respons re ) throw except { request request = ( request ) req . get note ( adapt note ) ; respons respons = ( respons ) re . get note ( adapt note ) ; ( request = = null ) { creat object request = connector . creat request ( ) ; request . set coyot request ( req ) ; respons = connector . creat respons ( ) ; respons . set coyot respons ( re ) ; link object request . set respons ( respons ) ; respons . set request ( request ) ; set note req . set note ( adapt note , request ) ; re . set note ( adapt note , respons ) ; set queri string encod req . get paramet ( ) . set queri string encod ( connector . get uriencod ( ) ) ; } ( connector . get xpower ( ) ) { respons . add header ( x power , servlet 2 . 5 ) ; } boolean comet = fals ; boolean async = request . async start ( ) ; try { pars set catalina configur specif request paramet req . get request processor ( ) . set worker thread name ( thread . current thread ( ) . get name ( ) ) ; ( post pars request ( req , request , re , respons ) ) { check valv we support async request . set async support ( connector . get contain ( ) . get pipelin ( ) . async support ( ) ) ; call contain connector . get contain ( ) . get pipelin ( ) . get first ( ) . invok ( request , respons ) ; ( request . comet ( ) ) { ( respons . close ( ) respons . error ( ) ) { ( request . get avail ( ) ( request . get content length ( ) 0 ( request . paramet pars ( ) ) ) ) { invok read event right awai ar avail byte ( event ( req , re , socket statu . open ) ) { comet = true ; re . action ( action code . action comet begin , null ) ; } } els { comet = true ; re . action ( action code . action comet begin , null ) ; } } els { clear filter chain , otherwis reset elsewher sinc thi comet request request . set filter chain ( null ) ; } } } ( request . async start ( ) ) { todo servlet3 async re . action ( action code . action async start , request . get async context ( ) ) ; async = true ; } els ( comet ) { respons . finish respons ( ) ; req . action ( action code . action post request , null ) ; } } catch ( ioexcept e ) { ignor } catch ( throwabl t ) { log . error ( sm . get string ( coyot adapt . servic ) , t ) ; } final { req . get request processor ( ) . set worker thread name ( null ) ; recycl wrapper request respons ( comet async ) { request . recycl ( ) ; respons . recycl ( ) ; } els { clear convert so minimum amount memori us thi processor request . clear encod ( ) ; respons . clear encod ( ) ; } } }
privat make sure given custom action doe have ani invalid attribut . custom action declar attribut alwai belong same namespac , which identifi prefix name custom tag invoc . exampl , thi invoc : my : test = 1 b = 2 c = 3 , action test attribut , b , c all belong namespac identifi prefix my . abov invoc would equival : my : test my : = 1 my : b = 2 my : c = 3 action attribut mai have prefix differ from action invoc onli underli tag handler support dynam attribut , which case attribut differ prefix consid dynam attribut . void check xml attribut ( node . custom tag n , node . jsp attribut jsp attr , hashtabl string , object tag data attr ) throw jasper except { tag info tag info = n . get tag info ( ) ; ( tag info = = null ) { err . jsp error ( n , jsp . error . miss . tag info , n . get qname ( ) ) ; } tag attribut info tld attr = tag info . get attribut ( ) ; attribut attr = n . get attribut ( ) ; boolean check defer = page info . defer syntax allow liter ( ) ( tag info . get tag librari ( ) . get requir version ( ) . equal ( 2 . 0 ) tag info . get tag librari ( ) . get requir version ( ) . equal ( 1 . 2 ) ) ; ( int i = 0 ; attr = null i attr . get length ( ) ; i ) { boolean found = fals ; boolean runtim express = ( ( n . get root ( ) . xml syntax ( ) attr . get valu ( i ) . start ( = ) ) ( n . get root ( ) . xml syntax ( ) attr . get valu ( i ) . start ( = ) ) ) ; boolean el express = fals ; boolean defer = fals ; boolean defer valu liter = fals ; elnod . node el = null ; ( runtim express ) { el = elpars . pars ( attr . get valu ( i ) ) ; iter elnod node = el . iter ( ) ; while ( node . ha next ( ) ) { elnod node = node . next ( ) ; ( node instanceof elnod . root ) { ( ( ( elnod . root ) node ) . get type ( ) = = ) { el express = true ; } els ( check defer ( ( elnod . root ) node ) . get type ( ) = = ) { el express = true ; defer = true ; ( page info . elignor ( ) ) { defer valu liter = true ; } } } } } boolean express = runtim express ( el express ( page info . elignor ( ) ( true . equal ignor case ( page info . get elignor ( ) ) check defer defer ) ) ) ; ( int j = 0 ; tld attr = null j tld attr . length ; j ) { ( attr . get local name ( i ) . equal ( tld attr j . get name ( ) ) ( attr . get uri ( i ) = = null attr . get uri ( i ) . length ( ) = = 0 attr . get uri ( i ) . equal ( n . get uri ( ) ) ) ) { ( tld attr j . can request time ( ) tld attr j . defer method ( ) tld attr j . defer valu ( ) ) { jsp 2 . 1 ( express ) { ( defer valu liter page info . defer syntax allow liter ( ) ) { err . jsp error ( n , jsp . error . attribut . custom . non rt expr , tld attr j . get name ( ) ) ; } string expect type = null ; ( tld attr j . defer method ( ) ) { string liter must castabl what declar type attribut string m = tld attr j . get method signatur ( ) ; ( m = null ) { int rti = m . trim ( ) . index ( ) ; ( rti 0 ) { expect type = m . substr ( 0 , rti ) . trim ( ) ; } } els { expect type = java . lang . object ; } ( void . equal ( expect type ) ) { can t specifi liter defer method expect type void jsp . 2 . 3 . 4 err . jsp error ( n , jsp . error . liter void , tld attr j . get name ( ) ) ; } } ( tld attr j . defer valu ( ) ) { string liter must castabl what declar type attribut expect type = tld attr j . get expect type name ( ) ; } ( expect type = null ) { class expect class = string . class ; try { expect class = jsp util . class ( expect type , loader ) ; } catch ( class found except e ) { err . jsp error ( n , jsp . error . unknown attribut type , tld attr j . get name ( ) , expect type ) ; } check cast try { elsupport . check type ( attr . get valu ( i ) , expect class ) ; } catch ( except e ) { err . jsp error ( n , jsp . error . coerc type , tld attr j . get name ( ) , expect type , attr . get valu ( i ) ) ; } } jsp attr i = new node . jsp attribut ( tld attr j , attr . get qname ( i ) , attr . get uri ( i ) , attr . get local name ( i ) , attr . get valu ( i ) , fals , null , fals ) ; } els { ( defer tld attr j . defer method ( ) tld attr j . defer valu ( ) ) { defer express allow thi attribut err . jsp error ( n , jsp . error . attribut . custom . non rt expr , tld attr j . get name ( ) ) ; } ( defer tld attr j . can request time ( ) ) { onli defer express ar allow thi attribut err . jsp error ( n , jsp . error . attribut . custom . non rt expr , tld attr j . get name ( ) ) ; } ( el express ) { el express valid function ( el , n ) ; jsp attr i = new node . jsp attribut ( tld attr j , attr . get qname ( i ) , attr . get uri ( i ) , attr . get local name ( i ) , attr . get valu ( i ) , fals , el , fals ) ; elcontext impl ctx = new elcontext impl ( ) ; ctx . set function mapper ( get function mapper ( el ) ) ; try { jsp attr i . valid el ( thi . page info . get express factori ( ) , ctx ) ; } catch ( elexcept e ) { thi . err . jsp error ( n . get start ( ) , jsp . error . invalid . express , attr . get valu ( i ) , e . string ( ) ) ; } } els { runtim express jsp attr i = get jsp attribut ( tld attr j , attr . get qname ( i ) , attr . get uri ( i ) , attr . get local name ( i ) , attr . get valu ( i ) , n , fals ) ; } } } els { make sure valu doe contain ani . ( express ) { err . jsp error ( n , jsp . error . attribut . custom . non rt expr , tld attr j . get name ( ) ) ; } jsp attr i = new node . jsp attribut ( tld attr j , attr . get qname ( i ) , attr . get uri ( i ) , attr . get local name ( i ) , attr . get valu ( i ) , fals , null , fals ) ; } ( express ) { tag data attr . put ( attr . get qname ( i ) , tag data . request time valu ) ; } els { tag data attr . put ( attr . get qname ( i ) , attr . get valu ( i ) ) ; } found = true ; break ; } } ( found ) { ( tag info . ha dynam attribut ( ) ) { jsp attr i = get jsp attribut ( null , attr . get qname ( i ) , attr . get uri ( i ) , attr . get local name ( i ) , attr . get valu ( i ) , n , true ) ; } els { err . jsp error ( n , jsp . error . bad attribut , attr . get qname ( i ) , n . get local name ( ) ) ; } } } }	privat compar page encod specifi variou place , throw except case page encod mismatch . param page dir enc valu page encod attribut page direct param page dir page direct node throw jasper except case page encod mismatch void compar tag encod ( string page dir enc , node . tag direct page dir ) throw jasper except { node . root root = page dir . get root ( ) ; string page dir enc = page dir enc . upper case ( ) ; compar page encod attribut page direct encod specifi xml prolog ( onli xml syntax , onli jsp document contain xml prolog encod declar ) . treat utf 16 , utf 16be , utf 16le ident . ( ( root . xml syntax ( ) root . encod specifi prolog ( ) ) root . bom present ( ) ) { string page enc = root . get page encod ( ) . upper case ( ) ; ( page dir enc . equal ( page enc ) ( page dir enc . start ( utf 16 ) page enc . start ( utf 16 ) ) ) { err . jsp error ( page dir , jsp . error . prolog pagedir encod mismatch , page enc , page dir enc ) ; } } }	public static express factori new instanc ( ) { return new instanc ( null ) ; }	public static express factori new instanc ( properti properti ) { todo return null ; }
public call our background reaper thread check session save our store ar subject expir . so expir session remov from store . void process expir ( ) { string kei = null ; ( start ) { return ; } try { kei = kei ( ) ; } catch ( ioexcept e ) { manag . get contain ( ) . get logger ( ) . error ( error get kei , e ) ; return ; } ( manag . get contain ( ) . get logger ( ) . debug enabl ( ) ) { manag . get contain ( ) . get logger ( ) . debug ( get store name ( ) : process expir check number kei . length session ) ; } ( int i = 0 ; i kei . length ; i ) { try { standard session session = ( standard session ) load ( kei i ) ; ( session = = null ) { continu ; } ( session . valid ( ) ) { continu ; } ( manag . get contain ( ) . get logger ( ) . debug enabl ( ) ) { manag . get contain ( ) . get logger ( ) . debug ( get store name ( ) : process expir expir store session kei i ) ; } ( ( ( persist manag base ) manag ) . load ( kei i ) ) { recycl old backup session session . recycl ( ) ; } els { expir swap out session session . expir ( ) ; } remov ( session . get id intern ( ) ) ; } catch ( except e ) { manag . get contain ( ) . get logger ( ) . error ( session : kei i ; , e ) ; try { remov ( kei i ) ; } catch ( ioexcept e2 ) { manag . get contain ( ) . get logger ( ) . error ( error remov kei , e2 ) ; } } } }
execut cgi script desir environ , current work directori , input output stream p thi implement follow cgi specif recommed : ul li server should provid code queri code compon script uri command line argument script doe contain ani unencod = charact command line argument can gener unambigu manner . li server should set auth type metavari valu code auth scheme code token code author code wa suppli part request header . see code get cgienviron code method . li where applic , server should set current work directori directori which script locat befor invok . li server implement should defin behavior follow case : ul li u allow charact path info u : thi implement doe allow ascii nul nor ani charact which cannot url encod accord internet standard ; li u allow charact path segment u : thi implement doe allow non termin null segment path ioexcept mai thrown ; li u code . code code . . code path segment u : thi implement doe allow code . code code . . code path , charact result ioexcept thrown ; li u implement limit u : thi implement doe impos ani limit except document abov . thi implement mai limit servlet contain us hous thi implement . particular , all primari cgi variabl valu ar deriv either directli indirectli from contain s implement servlet api method . ul ul p except ioexcept problem dure read write occur see java . lang . runtim exec ( string command , string envp , file dir ) protect void run ( ) throw ioexcept { remind : thi method feel too big ; should re written ( readi ( ) ) { throw new ioexcept ( thi . get class ( ) . get name ( ) : readi run . ) ; } ( debug = 1 ) { log ( run cgi ( envp = env , command = command ) ) ; } ( ( command . index ( file . separ . file . separ ) = 0 ) ( command . index ( file . separ . . ) = 0 ) ( command . index ( . . file . separ ) = 0 ) ) { throw new ioexcept ( thi . get class ( ) . get name ( ) illeg charact cgi command path ( . . . ) detect . run cgi command . ) ; } origin content structur thi section taken from http : develop . java . sun . com develop bug parad bug 4216884 . html major modif martin dengler runtim rt = null ; buffer reader cgi header reader = null ; input stream cgi output = null ; buffer reader command std err = null ; buffer output stream command std = null ; process proc = null ; int buf read = 1 ; creat queri argument string builder cmd arg = new string builder ( ) ; ( command . index ( ) 0 ) { cmd arg . append ( command ) ; } els { space us delimit , so need us quot cmd arg . append ( ) ; cmd arg . append ( command ) ; cmd arg . append ( ) ; } ( int i = 0 ; i param . size ( ) ; i ) { cmd arg . append ( ) ; string param = param . get ( i ) ; ( param . index ( ) 0 ) { cmd arg . append ( param ) ; } els { space us delimit , so need us quot cmd arg . append ( ) ; cmd arg . append ( param ) ; cmd arg . append ( ) ; } } string builder command = new string builder ( cgi execut ) ; command . append ( ) ; command . append ( cmd arg . string ( ) ) ; cmd arg = command ; try { rt = runtim . get runtim ( ) ; proc = rt . exec ( cmd arg . string ( ) , hash string arrai ( env ) , wd ) ; string s content length = env . get ( content length ) ; ( . equal ( s content length ) ) { command std = new buffer output stream ( proc . get output stream ( ) ) ; iotool . flow ( stdin , command std ) ; command std . flush ( ) ; command std . close ( ) ; } we want wait process exit , process . wait ( ) useless our situat ; see http : develop . java . sun . com develop bug parad bug 4223650 . html boolean run = true ; command std err = new buffer reader ( new input stream reader ( proc . get error stream ( ) ) ) ; final buffer reader std err rdr = command std err ; new thread ( ) { overrid } } }	public void init ( servlet config config ) throw servlet except { super . init ( config ) ; set our properti from initi paramet ( get servlet config ( ) . get init paramet ( debug ) = null ) debug = integ . pars int ( get servlet config ( ) . get init paramet ( debug ) ) ; cgi path prefix = get servlet config ( ) . get init paramet ( cgi path prefix ) ; boolean pass shell environ = boolean . valu ( get servlet config ( ) . get init paramet ( pass shell environ ) ) . boolean valu ( ) ; ( pass shell environ ) { shell env . put all ( system . getenv ( ) ) ; } ( get servlet config ( ) . get init paramet ( execut ) = null ) { cgi execut = get servlet config ( ) . get init paramet ( execut ) ; } ( get servlet config ( ) . get init paramet ( paramet encod ) = null ) { paramet encod = get servlet config ( ) . get init paramet ( paramet encod ) ; } }	protect void run ( ) throw ioexcept { remind : thi method feel too big ; should re written ( readi ( ) ) { throw new ioexcept ( thi . get class ( ) . get name ( ) : readi run . ) ; } ( debug = 1 ) { log ( run cgi ( envp = env , command = command ) ) ; } ( ( command . index ( file . separ . file . separ ) = 0 ) ( command . index ( file . separ . . ) = 0 ) ( command . index ( . . file . separ ) = 0 ) ) { throw new ioexcept ( thi . get class ( ) . get name ( ) illeg charact cgi command path ( . . . ) detect . run cgi command . ) ; } origin content structur thi section taken from http : develop . java . sun . com develop bug parad bug 4216884 . html major modif martin dengler runtim rt = null ; buffer reader cgi header reader = null ; input stream cgi output = null ; buffer reader command std err = null ; buffer output stream command std = null ; process proc = null ; int buf read = 1 ; creat queri argument string builder cmd arg = new string builder ( ) ; ( command . index ( ) 0 ) { cmd arg . append ( command ) ; } els { space us delimit , so need us quot cmd arg . append ( ) ; cmd arg . append ( command ) ; cmd arg . append ( ) ; } ( int i = 0 ; i param . size ( ) ; i ) { cmd arg . append ( ) ; string param = param . get ( i ) ; ( param . index ( ) 0 ) { cmd arg . append ( param ) ; } els { space us delimit , so need us quot cmd arg . append ( ) ; cmd arg . append ( param ) ; cmd arg . append ( ) ; } } string builder command = new string builder ( cgi execut ) ; command . append ( ) ; command . append ( cmd arg . string ( ) ) ; cmd arg = command ; try { rt = runtim . get runtim ( ) ; proc = rt . exec ( cmd arg . string ( ) , hash string arrai ( env ) , wd ) ; string s content length = env . get ( content length ) ; ( . equal ( s content length ) ) { command std = new buffer output stream ( proc . get output stream ( ) ) ; iotool . flow ( stdin , command std ) ; command std . flush ( ) ; command std . close ( ) ; } we want wait process exit , process . wait ( ) useless our situat ; see http : develop . java . sun . com develop bug parad bug 4223650 . html boolean run = true ; command std err = new buffer reader ( new input stream reader ( proc . get error stream ( ) ) ) ; final buffer reader std err rdr = command std err ; new thread ( ) { overrid public void run ( ) { send log ( std err rdr ) ; } } . start ( ) ; input stream cgi header stream = new httpheader input stream ( proc . get input stream ( ) ) ; cgi header reader = new buffer reader ( new input stream reader ( cgi header stream ) ) ; while ( run ) { try { set header string line = null ; while ( ( ( line = cgi header reader . read line ( ) ) = null ) ( . equal ( line ) ) ) { ( debug = 2 ) { log ( run cgi : add header ( line ) ) ; } ( line . start ( http ) ) { respons . set statu ( get scfrom http statu line ( line ) ) ; } els ( line . index ( : ) = 0 ) { string header = line . substr ( 0 , line . index ( : ) ) . trim ( ) ; string valu = line . substr ( line . index ( : ) 1 ) . trim ( ) ; ( header . equal ignor case ( statu ) ) { respons . set statu ( get scfrom cgistatu header ( valu ) ) ; } els { respons . add header ( header , valu ) ; } } els { log ( run cgi : bad header line line ) ; } } write output byte b buf = new byte 2048 ; output stream out = respons . get output stream ( ) ; cgi output = proc . get input stream ( ) ; try { while ( ( buf read = cgi output . read ( b buf ) ) = 1 ) { ( debug = 4 ) { log ( run cgi : output buf read byte data ) ; } out . write ( b buf , 0 , buf read ) ; } } final { extern process could hang ( buf read = 1 ) { while ( ( buf read = cgi output . read ( b buf ) ) = 1 ) { noop just read data } } } throw except aliv proc . exit valu ( ) ; run = fals ; } catch ( illeg thread state except e ) { try { thread . sleep ( 500 ) ; } catch ( interrupt except ignor ) { ignor } } } replac process . wait ( ) } catch ( ioexcept e ) { log ( caught except e ) ; throw e ; } final { close header reader ( cgi header reader = null ) { try { cgi header reader . close ( ) ; } catch ( ioexcept ioe ) { log ( except close header reader ioe ) ; } } close output stream us ( cgi output = null ) { try { cgi output . close ( ) ; } catch ( ioexcept ioe ) { log ( except close output stream ioe ) ; } } ( debug 4 ) { log ( run final block ) ; } ( proc = null ) { proc . destroi ( ) ; proc = null ; } } }
public list children thi collect . name given ar rel thi uri s path . full uri children : path name . enumer string list ( ) throw ioexcept { ( connect ) { connect ( ) ; } ( ( resourc = = null ) ( collect = = null ) ) { throw new file found except ( ) ; } vector string result = new vector string ( ) ; ( collect = null ) { try { string file = get url ( ) . get file ( ) ; thi form hostnam contextpath file name strip off hostnam contextpath int start = file . index ( , file . index ( , 1 ) 1 ) ; name enumer name class pair enumer = context . list ( file . substr ( start ) ) ; while ( enumer . ha more element ( ) ) { name class pair ncp = enumer . next element ( ) ; result . add element ( ncp . get name ( ) ) ; } } catch ( name except e ) { unexpect except throw new file found except ( ) ; } } return result . element ( ) ; }
public int get next poll ( ) { int idx = math . ab ( poll queue . increment get ( ) ) lock count ; return idx ; }
protect look session store , found , restor manag s list activ session appropri . session remov from store after swap , ad activ session list invalid past expir . session swap ( string id ) throw ioexcept { ( store = = null ) return null ; session session = null ; try { ( secur util . packag protect enabl ( ) ) { try { session = access control . do privileg ( new privileg store load ( id ) ) ; } catch ( privileg action except ex ) { except except = ex . get except ( ) ; log . error ( except store dure swap : except ) ; ( except instanceof ioexcept ) { throw ( ioexcept ) except ; } els ( except instanceof class found except ) { throw ( class found except ) except ; } } } els { session = store . load ( id ) ; } } catch ( class found except e ) { log . error ( sm . get string ( persist manag . deseri error , id , e ) ) ; throw new illeg state except ( sm . get string ( persist manag . deseri error , id , e ) ) ; } ( session = = null ) return ( null ) ; ( session . valid ( ) ) { log . error ( session swap invalid expir ) ; session . expir ( ) ; remov session ( id ) ; return ( null ) ; } ( log . debug enabl ( ) ) log . debug ( sm . get string ( persist manag . swap , id ) ) ; session . set manag ( thi ) ; make sure listen know about . ( ( standard session ) session ) . tell new ( ) ; add ( session ) ; ( ( standard session ) session ) . activ ( ) ; end access ( ) ensur timeout happen correctli . access ( ) keep access count correct end up neg session . access ( ) ; session . end access ( ) ; return ( session ) ; }	public void run ( ) throw except { store . clear ( ) ; return null ; }
protect static return code true code given code str code match least given code pattern code . boolean match ( string str , pattern . . . pattern ) { ( pattern pattern : pattern ) { ( pattern . matcher ( str ) . match ( ) ) { return true ; } } return fals ; }	public string get protocol header ( ) { return protocol header ; }	public void do filter ( http servlet request request , http servlet respons respons , filter chain chain ) throw ioexcept , servlet except { ( match ( request . get remot addr ( ) , intern proxi ) ) { string remot ip = null ; java 6 , proxi header valu should declar java . util . dequ link list string proxi header valu = new link list string ( ) ; string remot iphead valu = comma delimit list string arrai ( request . get header ( remot iphead ) ) ; int idx ; loop remot iphead valu find first trust remot ip build proxi chain ( idx = remot iphead valu . length 1 ; idx = 0 ; idx ) { string current remot ip = remot iphead valu idx ; remot ip = current remot ip ; ( match ( current remot ip , intern proxi ) ) { do noth , intern proxi ip ar append } els ( match ( current remot ip , trust proxi ) ) { proxi header valu . add first ( current remot ip ) ; } els { decrement idx becaus break statement doesn t do idx ; break ; } } continu loop remot iphead valu build new valu remot iphead link list string new remot ip header valu = new link list string ( ) ; ( ; idx = 0 ; idx ) { string current remot ip = remot iphead valu idx ; new remot ip header valu . add first ( current remot ip ) ; } xforward request x request = new xforward request ( request ) ; ( remot ip = null ) { x request . set remot addr ( remot ip ) ; x request . set remot host ( remot ip ) ; ( proxi header valu . size ( ) = = 0 ) { x request . remov header ( proxi header ) ; } els { string comma delimit list proxi = list comma delimit string ( proxi header valu ) ; x request . set header ( proxi header , comma delimit list proxi ) ; } ( new remot ip header valu . size ( ) = = 0 ) { x request . remov header ( remot iphead ) ; } els { string comma delimit remot ip header valu = list comma delimit string ( new remot ip header valu ) ; x request . set header ( remot iphead , comma delimit remot ip header valu ) ; } } ( protocol header = null ) { string protocol header valu = request . get header ( protocol header ) ; ( protocol header valu = null protocol header ssl valu . equal ignor case ( protocol header valu ) ) { x request . set secur ( true ) ; x request . set scheme ( http ) ; x request . set server port ( http server port ) ; } } ( log . debug enabl ( ) ) { log . debug ( incom request request . get request uri ( ) origin remot addr request . get remot addr ( ) , origin remot host = request . get remot host ( ) , origin secur = request . secur ( ) , origin scheme = request . get scheme ( ) , origin remot iphead = request . get header ( remot iphead ) , origin protocol header = ( protocol header = = null null : request . get header ( protocol header ) ) seen new remot addr = x request . get remot addr ( ) , new remot host = x request . get remot host ( ) , new scheme = x request . get scheme ( ) , new secur = x request . secur ( ) , new remot iphead = x request . get header ( remot iphead ) , new proxi header = x request . get header ( proxi header ) ) ; } chain . do filter ( x request , respons ) ; } els { chain . do filter ( request , respons ) ; } }	public void init ( filter config filter config ) throw servlet except { ( filter config . get init paramet ( intern proxi paramet ) = null ) { set intern proxi ( filter config . get init paramet ( intern proxi paramet ) ) ; } ( filter config . get init paramet ( protocol header paramet ) = null ) { set protocol header ( filter config . get init paramet ( protocol header paramet ) ) ; } ( filter config . get init paramet ( protocol header ssl valu paramet ) = null ) { set protocol header ssl valu ( filter config . get init paramet ( protocol header ssl valu paramet ) ) ; } ( filter config . get init paramet ( proxi header paramet ) = null ) { set proxi header ( filter config . get init paramet ( proxi header paramet ) ) ; } ( filter config . get init paramet ( remot ip header paramet ) = null ) { set remot iphead ( filter config . get init paramet ( remot ip header paramet ) ) ; } ( filter config . get init paramet ( trust proxi paramet ) = null ) { set trust proxi ( filter config . get init paramet ( trust proxi paramet ) ) ; } ( filter config . get init paramet ( http server port paramet ) = null ) { try { set http server port ( integ . pars int ( filter config . get init paramet ( http server port paramet ) ) ) ; } catch ( number format except e ) { throw new number format except ( illeg server port : e . get messag ( ) ) ; } } }	public p header hold incom protocol , usal name code x forward proto code . code null code , request . scheme request . secur modifi . p p default valu : code null code p void set protocol header ( string protocol header ) { thi . protocol header = protocol header ; }	protect static string comma delimit list string arrai ( string comma delimit string ) { return ( comma delimit string = = null comma delimit string . length ( ) = = 0 ) new string 0 : comma separ valu pattern . split ( comma delimit string ) ; }
public copi from code org . apach . catalina . valv . certif valv code integ get kei size ( ) throw ioexcept { look up current sslsession sslsupport . cipher data c aux = cipher ; ( session = = null ) return null ; integ kei size = ( integ ) session . get valu ( kei size kei ) ; ( kei size = = null ) { int size = 0 ; string cipher suit = session . get cipher suit ( ) ; ( int i = 0 ; i c aux . length ; i ) { ( cipher suit . index ( c aux i . phrase ) = 0 ) { size = c aux i . kei size ; break ; } } kei size = new integ ( size ) ; session . put valu ( kei size kei , kei size ) ; } return kei size ; }
protect call forward error page param request request we ar process param respons respons we ar popul param config login configur describ how authent should perform void forward error page ( request request , http servlet respons respons , login config config ) { request dispatch disp = context . get servlet context ( ) . get request dispatch ( config . get error page ( ) ) ; try { disp . forward ( request . get request ( ) , respons ) ; } catch ( throwabl t ) { log . warn ( unexpect error forward error page , t ) ; } }	protect call forward login page param request request we ar process param respons respons we ar popul param config login configur describ how authent should perform void forward login page ( request request , http servlet respons respons , login config config ) { request dispatch disp = context . get servlet context ( ) . get request dispatch ( config . get login page ( ) ) ; try { disp . forward ( request . get request ( ) , respons ) ; } catch ( throwabl t ) { log . warn ( unexpect error forward login page , t ) ; } }	authent user make thi request , base specifi login configur . return code true code ani specifi constraint ha been satisfi , code fals code we have creat respons challeng alreadi . param request request we ar process param respons respons we ar creat param config login configur describ how authent should perform except ioexcept input output error occur overrid public boolean authent ( request request , http servlet respons respons , login config config ) throw ioexcept { refer object we need later session session = null ; have we alreadi authent someon princip princip = request . get user princip ( ) ; string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( princip = null ) { ( log . debug enabl ( ) ) log . debug ( alreadi authent princip . get name ( ) ) ; associ session ani exist sso session ( sso id = null ) associ ( sso id , request . get session intern ( true ) ) ; return ( true ) ; } sso session against which we can try reauthent ( sso id = null ) { ( log . debug enabl ( ) ) log . debug ( sso id sso id set ; attempt reauthent ) ; either case we have prompt user logon ( reauthent from sso ( sso id , request ) ) return true ; } have we authent thi user befor have cach disabl ( cach ) { session = request . get session intern ( true ) ; ( log . debug enabl ( ) ) log . debug ( check reauthent session session ) ; string usernam = ( string ) session . get note ( constant . sess usernam note ) ; string password = ( string ) session . get note ( constant . sess password note ) ; ( ( usernam = null ) ( password = null ) ) { ( log . debug enabl ( ) ) log . debug ( reauthent usernam usernam ) ; princip = context . get realm ( ) . authent ( usernam , password ) ; ( princip = null ) { session . set note ( constant . form princip note , princip ) ; ( match request ( request ) ) { regist ( request , respons , princip , constant . form method , usernam , password ) ; return ( true ) ; } } ( log . debug enabl ( ) ) log . debug ( reauthent fail , proce normal ) ; } } authent so , forward origin request instead . ( match request ( request ) ) { session = request . get session intern ( true ) ; ( log . debug enabl ( ) ) log . debug ( restor request from session session . get id intern ( ) ) ; princip = ( princip ) session . get note ( constant . form princip note ) ; regist ( request , respons , princip , constant . form method , ( string ) session . get note ( constant . sess usernam note ) , ( string ) session . get note ( constant . sess password note ) ) ; password session , so remov them ( cach ) { session . remov note ( constant . sess usernam note ) ; session . remov note ( constant . sess password note ) ; } ( restor request ( request , session ) ) { ( log . debug enabl ( ) ) log . debug ( proce restor request ) ; return ( true ) ; } els { ( log . debug enabl ( ) ) log . debug ( restor origin request fail ) ; respons . send error ( http servlet respons . sc bad request ) ; return ( fals ) ; } } acquir refer object we need evalu messag byte uri mb = messag byte . new instanc ( ) ; char chunk uri cc = uri mb . get char chunk ( ) ; uri cc . set limit ( 1 ) ; string context path = request . get context path ( ) ; string request uri = request . get decod request uri ( ) ; thi action request from login page boolean login action = request uri . start ( context path ) request uri . end ( constant . form action ) ; save thi request redirect form login page ( login action ) { session = request . get session intern ( true ) ; ( log . debug enabl ( ) ) log . debug ( save request session session . get id intern ( ) ) ; try { save request ( request , session ) ; } catch ( ioexcept ioe ) { log . debug ( request bodi too big save dure authent ) ; respons . send error ( http servlet respons . sc forbidden , sm . get string ( authent . request bodi too big ) ) ; return ( fals ) ; } forward login page ( request , respons , config ) ; return ( fals ) ; } ye valid specifi credenti redirect error page thei ar correct realm realm = context . get realm ( ) ; ( charact encod = null ) { request . set charact encod ( charact encod ) ; } string usernam = request . get paramet ( constant . form usernam ) ; string password = request . get paramet ( constant . form password ) ; ( log . debug enabl ( ) ) log . debug ( authent usernam usernam ) ; princip = realm . authent ( usernam , password ) ; ( princip = = null ) { forward error page ( request , respons , config ) ; return ( fals ) ; } ( log . debug enabl ( ) ) log . debug ( authent usernam wa success ) ; ( session = = null ) session = request . get session intern ( fals ) ; ( session = = null ) { ( contain log . debug enabl ( ) ) contain log . debug ( user took so long log session expir ) ; respons . send error ( http servlet respons . sc request timeout , sm . get string ( authent . session expir ) ) ; return ( fals ) ; } save authent princip our session session . set note ( constant . form princip note , princip ) ; save usernam password well session . set note ( constant . sess usernam note , usernam ) ; session . set note ( constant . sess password note , password ) ; redirect user origin request uri ( which caus origin request restor ) request uri = save request url ( session ) ; ( log . debug enabl ( ) ) log . debug ( redirect origin request uri ) ; ( request uri = = null ) respons . send error ( http servlet respons . sc bad request , sm . get string ( authent . formlogin ) ) ; els respons . send redirect ( respons . encod redirect url ( request uri ) ) ; return ( fals ) ; }
public list client get client ( ) { return java . util . arrai . list ( client . entri set ( ) . arrai ( new client 0 ) ) ; }
public check client request valid . per section 5 . 1 . 1 bayuex spec connect request must contain : 1 ) channel identifi channel public . 2 ) data send . return http error thi method return null error were found http error valid ( ) { ( channel = = null ( thi . get tomcat bayeux ( ) . ha channel ( channel ) ) ) return new http error ( 400 , channel id valid . , null ) ; ( data = = null data . length ( ) = = 0 ) return new http error ( 400 , messag data miss . , null ) ; try { thi . msg data = new jsonobject ( data ) ; } catch ( jsonexcept x ) { return new http error ( 400 , invalid json object data attribut . , x ) ; } ( client id = = null ( thi . get tomcat bayeux ( ) . ha client ( client id ) ) ) return new http error ( 400 , client id valid . , null ) ; error return null ; }
public return session associ thi request , creat necessari request . param creat creat new session doe exist session get session intern ( boolean creat ) { return do get session ( creat ) ; }	public void set comet timeout ( long timeout ) { coyot request . action ( action code . action comet settimeout , new long ( timeout ) ) ; }	public return name all request attribut thi request , empti code enumer code ar none . note attribut name return onli those attribut set via { link set attribut ( string , object ) } . tomcat intern attribut includ although thei ar access via { link get attribut ( string ) } . tomcat intern attribut includ : ul li { link global . dispatch type attr } li li { link global . dispatch request path attr } li li { link global . async support attr } li li { link global . certif attr } ( ssl connect onli ) li li { link global . cipher suit attr } ( ssl connect onli ) li li { link global . kei size attr } ( ssl connect onli ) li li { link global . ssl session id attr } ( ssl connect onli ) li li { link global . ssl session mgr attr } ( ssl connect onli ) li ul underli connector mai also expos request attribut . all have name start org . apach . tomcat includ : ul li org . apach . tomcat . sendfil . support li li org . apach . tomcat . comet . support li li org . apach . tomcat . comet . timeout . support li ul connector implement mai return some , all none attribut mai also support addit attribut . enumer string get attribut name ( ) { ( secur ( ) ) { get attribut ( global . certif attr ) ; } return new enumer string ( attribut . kei set ( ) , true ) ; }
privat void write object ( object output stream ) throw ioexcept { write scalar instanc variabl ( except manag ) stream . write object ( new long ( creation time ) ) ; stream . write object ( new long ( last access time ) ) ; stream . write object ( new integ ( max inact interv ) ) ; stream . write object ( new boolean ( new ) ) ; stream . write object ( new boolean ( valid ) ) ; stream . write object ( new long ( thi access time ) ) ; stream . write object ( new long ( version ) ) ; stream . write boolean ( get princip ( ) = null ) ; ( get princip ( ) = null ) { serializ princip . write princip ( ( gener princip ) princip , stream ) ; } stream . write object ( id ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( delta session . write session , id ) ) ; accumul name serializ non serializ attribut string kei = kei ( ) ; arrai list string save name = new arrai list string ( ) ; arrai list object save valu = new arrai list object ( ) ; ( int i = 0 ; i kei . length ; i ) { object valu = null ; valu = attribut . get ( kei i ) ; ( valu = = null ) continu ; } }
return unmodifi map header field . overrid public map string , list string >> get header field ( ) { ( connect ) { try connect ( silent ) try { connect ( ) ; } catch ( ioexcept e ) { } } ( attribut = = null ) return ( collect . empti map ) ; hash map string , list string >> header field = new hash map string , list string >> ( attribut . size ( ) ) ; name enumer string attribut enum = attribut . get id ( ) ; try { while ( attribut enum . ha more ( ) ) { string attribut id = attribut enum . next ( ) ; attribut attribut = attribut . get ( attribut id ) ; ( attribut = = null ) continu ; arrai list string attribut valu list = new arrai list string ( attribut . size ( ) ) ; name enumer attribut valu = attribut . get all ( ) ; while ( attribut valu . ha more ( ) ) { object attr valu = attribut valu . next ( ) ; attribut valu list . add ( get header valu string ( attr valu ) ) ; } should op attribut . size ( ) didn t lie attribut valu list . trim size ( ) ; header field . put ( attribut id , collect . unmodifi list ( attribut valu list ) ) ; } } catch ( name except ne ) { shouldn t happen } return collect . unmodifi map ( header field ) ; }	protect creat result properti name from properti prefix when result arrai separ arrai result true , resultproperti us prefix ( code resultproperti . 0 arrai . length code store result arrai length code resultproperti . length code . other option you delimit your result delimit ( java . util . string token us ) . param properti prefix param result void creat properti ( string properti prefix , object result ) { ( properti prefix = = null ) properti prefix = ; ( result instanceof composit data support ) { composit data support data = ( composit data support ) result ; composit type composit type = data . get composit type ( ) ; set string kei = composit type . kei set ( ) ; ( iter string iter = kei . iter ( ) ; iter . ha next ( ) ; ) { string kei = iter . next ( ) ; object valu = data . get ( kei ) ; open type type = composit type . get type ( kei ) ; ( type instanceof simpl type ) { set properti ( properti prefix . kei , valu ) ; } els { creat properti ( properti prefix . kei , valu ) ; } } } els ( result instanceof tabular data support ) { tabular data support data = ( tabular data support ) result ; ( iter object iter = data . kei set ( ) . iter ( ) ; iter . ha next ( ) ; ) { object kei = iter . next ( ) ; ( iter object iter1 = ( ( list object ) kei ) . iter ( ) ; iter1 . ha next ( ) ; ) { object key1 = iter1 . next ( ) ; composit data valuedata = data . get ( new object { key1 } ) ; object valu = valuedata . get ( valu ) ; open type type = valuedata . get composit type ( ) . get type ( valu ) ; ( type instanceof simpl type ) { set properti ( properti prefix . key1 , valu ) ; } els { creat properti ( properti prefix . key1 , valu ) ; } } } } els ( result . get class ( ) . arrai ( ) ) { ( separatearrayresult ( ) ) { int size = 0 ; ( int i = 0 ; i arrai . get length ( result ) ; i ) { ( set properti ( properti prefix . size , arrai . get ( result , i ) ) ) { size ; } } ( size 0 ) { set properti ( properti prefix . length , integ . string ( size ) ) ; } } } els { string delim = get delimit ( ) ; ( delim = null ) { string token token = new string token ( result . string ( ) , delim ) ; int size = 0 ; ( ; token . ha more token ( ) ; ) { string token = token . next token ( ) ; ( set properti ( properti prefix . size , token ) ) { size ; } } ( size 0 ) set properti ( properti prefix . length , integ . string ( size ) ) ; } els { set properti ( properti prefix , result . string ( ) ) ; } } }	public object clone ( ) { synchron ( member lock ) { membership clone = new membership ( local , member compar ) ; clone . map = ( hash map member impl , mbr entri ) map . clone ( ) ; clone . member = new member impl member . length ; system . arraycopi ( member , 0 , clone . member , 0 , member . length ) ; return clone ; } }	get object content . overrid public object get content ( ) throw ioexcept { ( connect ) connect ( ) ; ( resourc = null ) return get input stream ( ) ; ( collect = null ) return collect ; ( object = null ) return object ; throw new file found except ( ) ; }	public synchron reset membership start over fresh . ie , delet all member wait them ping again join thi membership void reset ( ) { map . clear ( ) ; member = empti member ; }
overrid public synchron void start ( ) throw lifecycl except { ( thi . start ) return ; super . add lifecycl listen ( thi ) ; try { catalina cluster catclust = ( catalina cluster ) thi . get cluster ( ) ; ( thi . context = = null ) thi . context = new repl appl context ( thi ) ; ( catclust = null ) { replic map map = new replic map ( thi , catclust . get channel ( ) , default repl timeout , get name ( ) , get class loader ( ) ) ; map . set channel send option ( map send option ) ; ( ( repl appl context ) thi . context ) . set attribut map ( map ) ; ( get alt ddname ( ) = null ) context . set attribut ( global . alt dd attr , get alt ddname ( ) ) ; } super . start ( ) ; } catch ( except x ) { log . error ( unabl start replic context , x ) ; throw new lifecycl except ( fail start replic context , x ) ; } }
protect static final number coerc number ( final string val , final class type ) throw illeg argument except { ( long . type = = type long . class . equal ( type ) ) { return long . valu ( val ) ; } ( integ . type = = type integ . class . equal ( type ) ) { return integ . valu ( val ) ; } ( doubl . type = = type doubl . class . equal ( type ) ) { return doubl . valu ( val ) ; } ( big integ . class . equal ( type ) ) { return new big integ ( val ) ; } ( big decim . class . equal ( type ) ) { return new big decim ( val ) ; } ( byte . type = = type byte . class . equal ( type ) ) { return byte . valu ( val ) ; } ( short . type = = type short . class . equal ( type ) ) { return short . valu ( val ) ; } ( float . type = = type float . class . equal ( type ) ) { return float . valu ( val ) ; } throw new illeg argument except ( messag factori . get ( error . convert , val , string . class , type ) ) ; }	public static final param obj param type return enum coerc enum ( final object obj , class type ) { ( obj = = null . equal ( obj ) ) { return null ; } ( obj . get class ( ) . enum ( ) ) { return ( enum ) obj ; } return enum . valu ( type , obj . string ( ) ) ; }	public static final object coerc type ( final object obj , final class type ) throw illeg argument except { ( type = = null object . class . equal ( type ) ( obj = null type . assign from ( obj . get class ( ) ) ) ) { return obj ; } ( string . class . equal ( type ) ) { return coerc string ( obj ) ; } ( elarithmet . number type ( type ) ) { return coerc number ( obj , type ) ; } ( charact . class . equal ( type ) charact . type = = type ) { return coerc charact ( obj ) ; } ( boolean . class . equal ( type ) boolean . type = = type ) { return coerc boolean ( obj ) ; } ( type . enum ( ) ) { return coerc enum ( obj , type ) ; } new spec ( obj = = null ) return null ; ( obj instanceof string ) { ( . equal ( obj ) ) return null ; properti editor editor = properti editor manag . find editor ( type ) ; ( editor = null ) { editor . set text ( ( string ) obj ) ; return editor . get valu ( ) ; } } throw new illeg argument except ( messag factori . get ( error . convert , obj , obj . get class ( ) , type ) ) ; }	public static final param obj return string coerc string ( final object obj ) { ( obj = = null ) { return ; } els ( obj instanceof string ) { return ( string ) obj ; } els ( obj instanceof enum ) { return ( ( enum ) obj ) . name ( ) ; } els { return obj . string ( ) ; } }	public static final param obj0 param obj1 return throw evalu except int compar ( final object obj0 , final object obj1 ) throw elexcept { ( obj0 = = obj1 equal ( obj0 , obj1 ) ) { return 0 ; } ( big decim op ( obj0 , obj1 ) ) { big decim bd0 = ( big decim ) coerc number ( obj0 , big decim . class ) ; big decim bd1 = ( big decim ) coerc number ( obj1 , big decim . class ) ; return bd0 . compar ( bd1 ) ; } ( doubl op ( obj0 , obj1 ) ) { doubl d0 = ( doubl ) coerc number ( obj0 , doubl . class ) ; doubl d1 = ( doubl ) coerc number ( obj1 , doubl . class ) ; return d0 . compar ( d1 ) ; } ( big integ op ( obj0 , obj1 ) ) { big integ bi0 = ( big integ ) coerc number ( obj0 , big integ . class ) ; big integ bi1 = ( big integ ) coerc number ( obj1 , big integ . class ) ; return bi0 . compar ( bi1 ) ; } ( long op ( obj0 , obj1 ) ) { long l0 = ( long ) coerc number ( obj0 , long . class ) ; long l1 = ( long ) coerc number ( obj1 , long . class ) ; return l0 . compar ( l1 ) ; } ( obj0 instanceof string obj1 instanceof string ) { return coerc string ( obj0 ) . compar ( coerc string ( obj1 ) ) ; } ( obj0 instanceof compar ) { return ( obj1 = null ) ( ( compar ) obj0 ) . compar ( obj1 ) : 1 ; } ( obj1 instanceof compar ) { return ( obj0 = null ) ( ( compar ) obj1 ) . compar ( obj0 ) : 1 ; } throw new elexcept ( messag factori . get ( error . compar , obj0 , obj1 ) ) ; }	public static final void throw unhandl ( object base , object properti ) throw elexcept { ( base = = null ) { throw new properti found except ( messag factori . get ( error . resolv . unhandl . null , properti ) ) ; } els { throw new properti found except ( messag factori . get ( error . resolv . unhandl , base . get class ( ) , properti ) ) ; } }	public void test misc ( ) { from bug 45451 parser bug assert equal ( , evalu express ( ) ) ; }
overrid public variabl mapper get variabl mapper ( ) { return thi . var mapper ; }	overrid public variabl mapper get variabl mapper ( ) { return thi . target . get variabl mapper ( ) ; }	overrid public boolean properti resolv ( ) { return thi . el context . properti resolv ( ) ; }	overrid public boolean properti resolv ( ) { return thi . target . properti resolv ( ) ; }
public t extend servlet t creat servlet ( class t c ) throw servlet except { ( secur util . packag protect enabl ( ) ) { return ( t ) do privileg ( creat servlet , new object { c } ) ; } els { return context . creat servlet ( c ) ; } }	overrid public map string , extend servlet registr get servlet registr ( ) { ( secur util . packag protect enabl ( ) ) { return ( map string , extend servlet registr ) do privileg ( get servlet registr , null ) ; } els { return context . get servlet registr ( ) ; } }	public enumer string get attribut name ( ) { ( secur util . packag protect enabl ( ) ) { return ( enumer string ) do privileg ( get attribut name , null ) ; } els { return context . get attribut name ( ) ; } }	deprec deprec public enumer string get servlet name ( ) { ( secur util . packag protect enabl ( ) ) { return ( enumer string ) do privileg ( get servlet name , null ) ; } els { return context . get servlet name ( ) ; } }	public enum set session track mode get effect session track mode ( ) { ( secur util . packag protect enabl ( ) ) { return ( enum set session track mode ) do privileg ( get effect session track mode , null ) ; } els { return context . get effect session track mode ( ) ; } }	public t extend filter t creat filter ( class t c ) throw servlet except { ( secur util . packag protect enabl ( ) ) { return ( t ) do privileg ( creat filter , new object { c } ) ; } els { return context . creat filter ( c ) ; } }	public enumer string get init paramet name ( ) { ( secur util . packag protect enabl ( ) ) { return ( enumer string ) do privileg ( get init paramet name , null ) ; } els { return context . get init paramet name ( ) ; } }	public set string get resourc path ( string path ) { ( secur util . packag protect enabl ( ) ) { return ( set string ) do privileg ( get resourc path , new object { path } ) ; } els { return context . get resourc path ( path ) ; } }	overrid public map string , extend filter registr get filter registr ( ) { ( secur util . packag protect enabl ( ) ) { return ( map string , extend filter registr ) do privileg ( get filter registr , null ) ; } els { return context . get filter registr ( ) ; } }	overrid public t extend event listen t creat listen ( class t c ) throw servlet except { ( secur util . packag protect enabl ( ) ) { return ( t ) do privileg ( creat listen , new object { c } ) ; } els { return context . creat listen ( c ) ; } }
conveni method which return true dispatch type match dispatch type specifi filter map boolean match dispatch ( filter map filter map , dispatch type type ) { switch ( type ) { case forward : { ( ( filter map . get dispatch map ( ) filter map . forward ) 0 ) { return true ; } break ; } case includ : { ( ( filter map . get dispatch map ( ) filter map . includ ) 0 ) { return true ; } break ; } case request : { ( ( filter map . get dispatch map ( ) filter map . request ) 0 ) { return true ; } break ; } case error : { ( ( filter map . get dispatch map ( ) filter map . error ) 0 ) { return true ; } break ; } } return fals ; }	public void add urlpattern ( string url pattern ) { ( . equal ( url pattern ) ) { thi . match all url pattern = true ; } els { string result = new string url pattern . length 1 ; system . arraycopi ( url pattern , 0 , result , 0 , url pattern . length ) ; result url pattern . length = request util . urldecod ( url pattern ) ; url pattern = result ; } }	public thi method us set current state filter map repres state when filter should appli : error forward forward error includ includ error includ error forward request request error request error includ request error forward includ request includ request forward , request forward includ void set dispatch ( string dispatch string ) { string dispatch = dispatch string . upper case ( ) ; ( dispatch . equal ( dispatch type . forward . name ( ) ) ) { appli forward global dispatch map . dispatch map = forward ; } els ( dispatch . equal ( dispatch type . includ . name ( ) ) ) { appli includ global dispatch map . dispatch map = includ ; } els ( dispatch . equal ( dispatch type . request . name ( ) ) ) { appli request global dispatch map . dispatch map = request ; } els ( dispatch . equal ( dispatch type . error . name ( ) ) ) { appli error global dispatch map . dispatch map = error ; } }
public string find manag bean ( string group ) { arrai list string result = new arrai list string ( ) ; iter manag bean item = descriptor . valu ( ) . iter ( ) ; while ( item . ha next ( ) ) { manag bean item = item . next ( ) ; ( ( group = = null ) ( item . get group ( ) = = null ) ) { result . add ( item . get name ( ) ) ; } els ( group . equal ( item . get group ( ) ) ) { result . add ( item . get name ( ) ) ; } } string valu = new string result . size ( ) ; return result . arrai ( valu ) ; }	public experiment . param sourc type param sourc param param return list descriptor throw except list object name load ( string sourc type , object sourc , string param ) throw except { ( log . trace enabl ( ) ) { log . trace ( load sourc ) ; } string locat = null ; string type = null ; object inputsourc = null ; ( sourc instanceof dynam mbean ) { sourc type = mbean descriptor dynam mbean sourc ; inputsourc = sourc ; } els ( sourc instanceof url ) { url url = ( url ) sourc ; locat = url . string ( ) ; type = param ; inputsourc = url . open stream ( ) ; ( sourc type = = null ) { sourc type = sourc type from ext ( locat ) ; } } els ( sourc instanceof file ) { locat = ( ( file ) sourc ) . get absolut path ( ) ; inputsourc = new file input stream ( ( file ) sourc ) ; type = param ; ( sourc type = = null ) { sourc type = sourc type from ext ( locat ) ; } } els ( sourc instanceof input stream ) { type = param ; inputsourc = sourc ; } els ( sourc instanceof class ) { locat = ( ( class ) sourc ) . get name ( ) ; type = param ; inputsourc = sourc ; ( sourc type = = null ) { sourc type = mbean descriptor introspect sourc ; } } ( sourc type = = null ) { sourc type = mbean descriptor digest sourc ; } model sourc ds = get model sourc ( sourc type ) ; list object name mbean = ds . load descriptor ( thi , locat , type , inputsourc ) ; return mbean ; }
final bean properti properti ( elcontext ctx , object base , object properti ) { class type = base . get class ( ) ; string prop = properti . string ( ) ; bean properti prop = thi . cach . get ( type . get name ( ) ) ; ( prop = = null type = prop . get type ( ) ) { prop = new bean properti ( type ) ; thi . cach . put ( type . get name ( ) , prop ) ; } return prop . get ( ctx , prop ) ; }	privat class get type ( ) { return type ; }	overrid public class get common properti type ( elcontext context , object base ) { ( base instanceof resourc bundl ) { return string . class ; } return null ; }	public object get context ( class kei ) { ( thi . map = = null ) { return null ; } return thi . map . get ( kei ) ; }	overrid public class get type ( elcontext context , object base , object properti ) throw null pointer except , properti found except , elexcept { ( context = = null ) { throw new null pointer except ( ) ; } ( base instanceof list ) { context . set properti resolv ( true ) ; list object list = ( list object ) base ; int idx = coerc ( properti ) ; ( idx 0 idx = list . size ( ) ) { return null ; } object obj = list . get ( idx ) ; return ( obj = null ) obj . get class ( ) : null ; } return null ; }	overrid public class get type ( elcontext context , object base , object properti ) throw null pointer except , properti found except , elexcept { ( context = = null ) { throw new null pointer except ( ) ; } ( base instanceof map ) { context . set properti resolv ( true ) ; object obj = ( ( map ) base ) . get ( properti ) ; return ( obj = null ) obj . get class ( ) : null ; } return null ; }	overrid public class get common properti type ( elcontext context , object base ) { ( base = null base instanceof list ) { return integ . class ; } return null ; }	overrid public class get common properti type ( elcontext context , object base ) { ( base instanceof map ) { return object . class ; } return null ; }	overrid public boolean read onli ( elcontext context , object base , object properti ) throw null pointer except , properti found except , elexcept { ( context = = null ) { throw new null pointer except ( ) ; } ( base instanceof resourc bundl ) { context . set properti resolv ( true ) ; } return true ; }	overrid public void set valu ( elcontext context , object base , object properti , object valu ) throw null pointer except , properti found except , properti writabl except , elexcept { ( context = = null ) { throw new null pointer except ( ) ; } ( base instanceof list ) { context . set properti resolv ( true ) ; list object list = ( list object ) base ; ( thi . read onli ) { throw new properti writabl except ( messag ( context , resolv writeabl , new object { base . get class ( ) . get name ( ) } ) ) ; } int idx = coerc ( properti ) ; try { list . set ( idx , valu ) ; } catch ( unsupport oper except e ) { throw new properti writabl except ( e ) ; } catch ( index out bound except e ) { throw new properti found except ( e ) ; } } }	overrid public void set valu ( elcontext context , object base , object properti , object valu ) throw null pointer except , properti found except , properti writabl except , elexcept { ( context = = null ) { throw new null pointer except ( ) ; } ( base instanceof map ) { context . set properti resolv ( true ) ; ( thi . read onli ) { throw new properti writabl except ( messag ( context , resolv writeabl , new object { base . get class ( ) . get name ( ) } ) ) ; } try { ( ( map ) base ) . put ( properti , valu ) ; } catch ( unsupport oper except e ) { throw new properti writabl except ( e ) ; } } }
protect creat result properti name from properti prefix when result arrai separ arrai result true , resultproperti us prefix ( code resultproperti . 0 arrai . length code store result arrai length code resultproperti . length code . other option you delimit your result delimit ( java . util . string token us ) . param properti prefix param result void creat properti ( string properti prefix , object result ) { ( properti prefix = = null ) properti prefix = ; ( result instanceof composit data support ) { composit data support data = ( composit data support ) result ; composit type composit type = data . get composit type ( ) ; set string kei = composit type . kei set ( ) ; ( iter string iter = kei . iter ( ) ; iter . ha next ( ) ; ) { string kei = iter . next ( ) ; object valu = data . get ( kei ) ; open type type = composit type . get type ( kei ) ; ( type instanceof simpl type ) { set properti ( properti prefix . kei , valu ) ; } els { creat properti ( properti prefix . kei , valu ) ; } } } els ( result instanceof tabular data support ) { tabular data support data = ( tabular data support ) result ; ( iter object iter = data . kei set ( ) . iter ( ) ; iter . ha next ( ) ; ) { object kei = iter . next ( ) ; ( iter object iter1 = ( ( list object ) kei ) . iter ( ) ; iter1 . ha next ( ) ; ) { object key1 = iter1 . next ( ) ; composit data valuedata = data . get ( new object { key1 } ) ; object valu = valuedata . get ( valu ) ; open type type = valuedata . get composit type ( ) . get type ( valu ) ; ( type instanceof simpl type ) { set properti ( properti prefix . key1 , valu ) ; } els { creat properti ( properti prefix . key1 , valu ) ; } } } } els ( result . get class ( ) . arrai ( ) ) { ( separatearrayresult ( ) ) { int size = 0 ; ( int i = 0 ; i arrai . get length ( result ) ; i ) { ( set properti ( properti prefix . size , arrai . get ( result , i ) ) ) { size ; } } ( size 0 ) { set properti ( properti prefix . length , integ . string ( size ) ) ; } } } els { string delim = get delimit ( ) ; ( delim = null ) { string token token = new string token ( result . string ( ) , delim ) ; int size = 0 ; ( ; token . ha more token ( ) ; ) { string token = token . next token ( ) ; ( set properti ( properti prefix . size , token ) ) { size ; } } ( size 0 ) set properti ( properti prefix . length , integ . string ( size ) ) ; } els { set properti ( properti prefix , result . string ( ) ) ; } } }	protect void print map ( string header ) { try { system . out . println ( n debug map : header ) ; system . out . println ( map new string ( map context name , chset ) , map size : super . size ( ) ) ; member mbr = get map member ( ) ; ( int i = 0 ; i mbr . length ; i ) { system . out . println ( mbr ( i 1 ) = mbr i . get name ( ) ) ; } iter i = super . entri set ( ) . iter ( ) ; int cnt = 0 ; while ( i . ha next ( ) ) { map . entri e = ( map . entri ) i . next ( ) ; system . out . println ( ( cnt ) . super . get ( e . get kei ( ) ) ) ; } system . out . println ( end map n n ) ; } catch ( except ignor ) { ignor . print stack trace ( ) ; } }	protect fix memori leak long session mani chang , when backup member exist param request current request after respons gener param cross context check crosscontext threadloc void reset replic request ( request request , boolean cross context ) { session context session = request . get session intern ( fals ) ; ( context session instanceof delta session ) { reset delta request ( context session ) ; ( ( delta session ) context session ) . set primari session ( true ) ; } ( cross context ) { object session = cross context session . get ( ) ; ( session = null session instanceof list ( ( list session ) session ) . size ( ) 0 ) { iter session iter = ( ( list session ) session ) . iter ( ) ; ( ; iter . ha next ( ) ; ) { session session = iter . next ( ) ; reset delta request ( session ) ; ( session instanceof delta session ) ( ( delta session ) context session ) . set primari session ( true ) ; } } } }	protect send all chang cross context session backup param contain cluster void send cross context session ( catalina cluster contain cluster ) { object session = cross context session . get ( ) ; ( session = null session instanceof list ( ( list session ) session ) . size ( ) 0 ) { ( iter session iter = ( ( list session ) session ) . iter ( ) ; iter . ha next ( ) ; ) { session session = iter . next ( ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( replic valv . cross context . send delta , session . get manag ( ) . get contain ( ) . get name ( ) ) ) ; send messag ( session , ( cluster manag ) session . get manag ( ) , contain cluster ) ; ( do statist ( ) ) { nr cross context send request ; } } } }	public todo implement state transfer param msg serializ return serializ null repli should sent serializ repli request ( serializ msg , final member sender ) { ( ( msg instanceof map messag ) ) return null ; map messag mapmsg = ( map messag ) msg ; map init request ( mapmsg . get msg type ( ) = = map messag . msg init ) { mapmsg . set primari ( channel . get local member ( fals ) ) ; return mapmsg ; } map start request ( mapmsg . get msg type ( ) = = map messag . msg start ) { mapmsg . set primari ( channel . get local member ( fals ) ) ; map member ad ( sender ) ; return mapmsg ; } backup request ( mapmsg . get msg type ( ) = = map messag . msg retriev backup ) { map entri entri = ( map entri ) super . get ( mapmsg . get kei ( ) ) ; ( entri = = null ( entri . serializ ( ) ) ) return null ; mapmsg . set valu ( ( serializ ) entri . get valu ( ) ) ; return mapmsg ; } state transfer request ( mapmsg . get msg type ( ) = = map messag . msg state mapmsg . get msg type ( ) = = map messag . msg state copi ) { synchron ( state mutex ) { make sure we dont do two thing same time arrai list map messag list = new arrai list map messag ( ) ; iter i = super . entri set ( ) . iter ( ) ; while ( i . ha next ( ) ) { map . entri e = ( map . entri ) i . next ( ) ; map entri entri = ( map entri ) super . get ( e . get kei ( ) ) ; ( entri = null entri . serializ ( ) ) { boolean copi = ( mapmsg . get msg type ( ) = = map messag . msg state copi ) ; map messag me = new map messag ( map context name , copi map messag . msg copi : map messag . msg proxi , fals , ( serializ ) entri . get kei ( ) , copi ( serializ ) entri . get valu ( ) : null , null , entri . get primari ( ) , entri . get backup node ( ) ) ; list . add ( me ) ; } } mapmsg . set valu ( list ) ; return mapmsg ; } synchron } return null ; }	public string list session id full ( ) { string builder sb = new string builder ( ) ; lazi replic map map = ( lazi replic map ) session ; iter string kei = map . kei set full ( ) . iter ( ) ; while ( kei . ha next ( ) ) { sb . append ( kei . next ( ) ) . append ( ) ; } return sb . string ( ) ; }	overrid public boolean contain valu ( object valu ) { ( valu = = null ) { return super . contain valu ( valu ) ; } els { iter i = super . entri set ( ) . iter ( ) ; while ( i . ha next ( ) ) { map . entri e = ( map . entri ) i . next ( ) ; map entri entri = ( map entri ) super . get ( e . get kei ( ) ) ; ( entri = null entri . primari ( ) valu . equal ( entri . get valu ( ) ) ) return true ; } while return fals ; } end }	overrid public collect object valu ( ) { arrai list object valu = new arrai list object ( ) ; iter i = super . entri set ( ) . iter ( ) ; while ( i . ha next ( ) ) { map . entri e = ( map . entri ) i . next ( ) ; map entri entri = ( map entri ) super . get ( e . get kei ( ) ) ; ( entri = null entri . primari ( ) entri . get valu ( ) = null ) valu . add ( entri . get valu ( ) ) ; } return collect . unmodifi collect ( valu ) ; }	overrid public collect object valu ( ) { arrai list object valu = new arrai list object ( ) ; iter i = super . entri set ( ) . iter ( ) ; while ( i . ha next ( ) ) { map . entri e = ( map . entri ) i . next ( ) ; map entri entri = ( map entri ) super . get ( e . get kei ( ) ) ; ( entri = null entri . primari ( ) entri . get valu ( ) = null ) valu . add ( entri . get valu ( ) ) ; } return collect . unmodifi collect ( valu ) ; }	overrid public boolean keepal ( ) { throw new unsupport oper except ( method parallel bio sender . check keep aliv ( ) implement ) ; boolean result = fals ; map . entri member , bio sender entri = bio sender . entri set ( ) . arrai ( new map . entri bio sender . size ( ) ) ; ( int i = 0 ; i entri . length ; i ) { bio sender sender = entri i . get valu ( ) ; ( sender . keepal ( ) ) { bio sender . remov ( entri i . get kei ( ) ) ; } } return result ; }	overrid public int size ( ) { todo , implement counter variabl instead onli count activ member thi node int counter = 0 ; iter = super . entri set ( ) . iter ( ) ; while ( = null . ha next ( ) ) { map . entri e = ( map . entri ) . next ( ) ; ( e = null ) { map entri entri = ( map entri ) super . get ( e . get kei ( ) ) ; ( entri = null entri . primari ( ) entri . get valu ( ) = null ) counter ; } } return counter ; }	overrid public set object kei set ( ) { todo implement should onli return kei where thi activ . link hash set object set = new link hash set object ( super . size ( ) ) ; iter i = super . entri set ( ) . iter ( ) ; while ( i . ha next ( ) ) { map . entri e = ( map . entri ) i . next ( ) ; object kei = e . get kei ( ) ; map entri entri = ( map entri ) super . get ( kei ) ; ( entri = null entri . primari ( ) ) set . add ( kei ) ; } return collect . unmodifi set ( set ) ; }	public void init ( string host , int port ) throw except { int iport = 0 ; string shost = null ; m bean server = registri . get registri ( null , null ) . get mbean server ( ) ; string str = : type = thread pool , ; object name object name = new object name ( str ) ; set set = m bean server . queri mbean ( object name , null ) ; iter object instanc iter = set . iter ( ) ; while ( iter . ha next ( ) ) { object instanc oi = iter . next ( ) ; obj name = oi . get object name ( ) ; string name = obj name . get kei properti ( name ) ; name ar : http 8080 jk 10 . 33 . 144 . 3 8009 jk jfcpc 2f10 . 33 . 144 . 3 8009 string elenam = name . split ( ) ; string sport = elenam elenam . length 1 ; iport = integ . pars int ( sport ) ; string shost = elenam 1 . split ( 2f ) ; shost = shost 0 ; ( port = = 0 host = = null ) break ; take first ( host = = null iport = = port ) break ; onli port done ( shost . compar ( host ) = = 0 ) break ; done port host ar expect } ( obj name = = null ) throw ( new except ( can t find connector host : port ) ) ; thi . port = iport ; thi . host = shost ; }	public void map member ad ( member member ) { ( member . equal ( get channel ( ) . get local member ( fals ) ) ) return ; boolean member ad = fals ; select backup node we don t have synchron ( map member ) { ( map member . contain kei ( member ) ) { map member . put ( member , new long ( system . current time milli ( ) ) ) ; member ad = true ; } } ( member ad ) { synchron ( state mutex ) { iter i = super . entri set ( ) . iter ( ) ; while ( i . ha next ( ) ) { map . entri e = ( map . entri ) i . next ( ) ; map entri entri = ( map entri ) super . get ( e . get kei ( ) ) ; ( entri = = null ) continu ; ( entri . primari ( ) ( entri . get backup node ( ) = = null entri . get backup node ( ) . length = = 0 ) ) { try { member backup = publish entri info ( entri . get kei ( ) , entri . get valu ( ) ) ; entri . set backup node ( backup ) ; entri . set primari ( channel . get local member ( fals ) ) ; } catch ( channel except x ) { log . error ( unabl select backup node . , x ) ; } catch } end } while } synchron } end }	public void member disappear ( member member ) { boolean remov = fals ; synchron ( map member ) { remov = ( map member . remov ( member ) = null ) ; ( remov ) { ( log . debug enabl ( ) ) log . debug ( member member disappear , wa present map . ) ; member wa part our map . return ; } } iter i = super . entri set ( ) . iter ( ) ; while ( i . ha next ( ) ) { map . entri e = ( map . entri ) i . next ( ) ; map entri entri = ( map entri ) super . get ( e . get kei ( ) ) ; ( entri = = null ) continu ; ( entri . primari ( ) set ( member , entri . get backup node ( ) ) ) { ( log . debug enabl ( ) ) log . debug ( 1 primari choos new backup ) ; try { member backup = publish entri info ( entri . get kei ( ) , entri . get valu ( ) ) ; entri . set backup node ( backup ) ; entri . set primari ( channel . get local member ( fals ) ) ; } catch ( channel except x ) { log . error ( unabl reloc entri . get kei ( ) new backup node , x ) ; } } els ( member . equal ( entri . get primari ( ) ) ) { ( log . debug enabl ( ) ) log . debug ( 2 primari disappear ) ; entri . set primari ( null ) ; } end ( entri . proxi ( ) entri . get primari ( ) = = null entri . get backup node ( ) = null entri . get backup node ( ) . length = = 1 entri . get backup node ( ) 0 . equal ( member ) ) { remov proxi have backup nor primari ( log . debug enabl ( ) ) log . debug ( 3 remov orphan proxi ) ; i . remov ( ) ; } els ( entri . get primari ( ) = = null entri . backup ( ) entri . get backup node ( ) = null entri . get backup node ( ) . length = = 1 entri . get backup node ( ) 0 . equal ( channel . get local member ( fals ) ) ) { try { ( log . debug enabl ( ) ) log . debug ( 4 backup becom primari ) ; entri . set primari ( channel . get local member ( fals ) ) ; entri . set backup ( fals ) ; entri . set proxi ( fals ) ; member backup = publish entri info ( entri . get kei ( ) , entri . get valu ( ) ) ; entri . set backup node ( backup ) ; ( map owner = null ) map owner . object made primai ( entri . get kei ( ) , entri . get valu ( ) ) ; } catch ( channel except x ) { log . error ( unabl reloc entri . get kei ( ) new backup node , x ) ; } } } while }	copi all valu from map thi instanc param m map overrid public void put all ( map m ) { iter i = m . entri set ( ) . iter ( ) ; while ( i . ha next ( ) ) { map . entri entri = ( map . entri ) i . next ( ) ; put ( entri . get kei ( ) , entri . get valu ( ) ) ; } }	public thi can invok period thread replic out ani chang . map don t store object implement replic map entri , thi method should us infrequ avoid larg amount data transfer param complet boolean void replic ( boolean complet ) { iter i = super . entri set ( ) . iter ( ) ; while ( i . ha next ( ) ) { map . entri e = ( map . entri ) i . next ( ) ; replic ( e . get kei ( ) , complet ) ; } while }	public void transfer state ( ) { try { member member = get map member ( ) ; member backup = member . length 0 ( member ) member 0 : null ; ( backup = null ) { map messag msg = new map messag ( map context name , get state messag type ( ) , fals , null , null , null , null , null ) ; respons resp = rpc channel . send ( new member { backup } , msg , rpc channel . first repli , channel send option , rpc timeout ) ; ( resp . length 0 ) { synchron ( state mutex ) { msg = ( map messag ) resp 0 . get messag ( ) ; msg . deseri ( get extern loader ( ) ) ; arrai list list = ( arrai list ) msg . get valu ( ) ; ( int i = 0 ; i list . size ( ) ; i ) { messag receiv ( ( serializ ) list . get ( i ) , resp 0 . get sourc ( ) ) ; } } } els { log . warn ( transfer state , 0 repli , probabl timeout . ) ; } } } catch ( channel except x ) { log . error ( unabl transfer lazi replic map state . , x ) ; } catch ( ioexcept x ) { log . error ( unabl transfer lazi replic map state . , x ) ; } catch ( class found except x ) { log . error ( unabl transfer lazi replic map state . , x ) ; } state transfer = true ; }
privat void reset context ( ) throw except , mbean registr except { restor origin state ( pre read web . xml start ) you extend thi overrid thi method make sure clean up children = new hash map string , contain ( ) ; startup time = 0 ; start time = 0 ; tld scan time = 0 ; bugzilla 32867 distribut = fals ; applic listen = new string 0 ; applic event listen object = new object 0 ; applic lifecycl listen object = new object 0 ; ( log . debug enabl ( ) ) log . debug ( reset context onam ) ; }	public void lifecycl event ( lifecycl event event ) { identifi context we ar associ try { context = ( context ) event . get lifecycl ( ) ; } catch ( class cast except e ) { log . error ( sm . get string ( tld config . cce , event . get lifecycl ( ) ) , e ) ; return ; } ( event . get type ( ) . equal ( lifecycl . init event ) ) { init ( ) ; } els ( event . get type ( ) . equal ( lifecycl . start event ) ) { try { execut ( ) ; } catch ( except e ) { log . error ( sm . get string ( tld config . execut , context . get path ( ) ) , e ) ; } } ignor other event type noth do }
protect pars header chunk . chunk header can look like a10crlf f23 ; chunk extens ignor crlf letter befor crlf after trailer mark , must valid hex digit , we should pars valid header accord spec boolean pars chunk header ( ) throw ioexcept { int result = 0 ; boolean eol = fals ; boolean read digit = fals ; boolean trailer = fals ; while ( eol ) { ( po = last valid ) { ( read byte ( ) = 0 ) return fals ; } ( buf po = = constant . cr ) { } els ( buf po = = constant . lf ) { eol = true ; } els ( buf po = = constant . semi colon ) { trailer = true ; } els ( trailer ) { don t read data after trailer ( hex util . dec buf po = 1 ) { read digit = true ; result = 16 ; result = hex util . dec buf po ; } els { chunk header return fals ; } } po ; } ( read digit ) return fals ; ( result = = 0 ) end chunk = true ; remain = result ; ( remain 0 ) return fals ; return true ; }	protect pars host . void pars host ( messag byte valu mb ) { ( valu mb = = null valu mb . null ( ) ) { http 1 . 0 default what socket tell us . overridden host found pars request . set server port ( socket . get local port ( ) ) ; inet address local address = socket . get local address ( ) ; set socket relat field . adapt doesn t know about socket . request . server name ( ) . set string ( local address . get host name ( ) ) ; return ; } byte chunk valu bc = valu mb . get byte chunk ( ) ; byte valu b = valu bc . get byte ( ) ; int valu l = valu bc . get length ( ) ; int valu s = valu bc . get start ( ) ; int colon po = 1 ; ( host name c . length valu l ) { host name c = new char valu l ; } boolean ipv6 = ( valu b valu s = = ) ; boolean bracket close = fals ; ( int i = 0 ; i valu l ; i ) { char b = ( char ) valu b i valu s ; host name c i = b ; ( b = = ) { bracket close = true ; } els ( b = = : ) { ( ipv6 bracket close ) { colon po = i ; break ; } } } ( colon po 0 ) { ( ssl support = = null ) { 80 default http port request . set server port ( 80 ) ; } els { 443 default http port request . set server port ( 443 ) ; } request . server name ( ) . set char ( host name c , 0 , valu l ) ; } els { request . server name ( ) . set char ( host name c , 0 , colon po ) ; int port = 0 ; int mult = 1 ; ( int i = valu l 1 ; i colon po ; i ) { int char valu = hex util . dec valu b i valu s ; ( char valu = = 1 ) { invalid charact error = true ; 400 bad request respons . set statu ( 400 ) ; break ; } port = port ( char valu mult ) ; mult = 10 mult ; } request . set server port ( port ) ; } }	public write some byte . return number byte written filter int do write ( byte chunk chunk , respons re ) throw ioexcept { int result = chunk . get length ( ) ; ( result = 0 ) { return 0 ; } calcul chunk header int po = 7 ; int current = result ; while ( current 0 ) { int digit = current 16 ; current = current 16 ; chunk length po = hex util . hex digit ; } chunk header . set byte ( chunk length , po 1 , 9 po ) ; buffer . do write ( chunk header , re ) ; buffer . do write ( chunk , re ) ; chunk header . set byte ( chunk length , 8 , 2 ) ; buffer . do write ( chunk header , re ) ; return result ; }	public static void load ( ) { noth do }	public pars host . void pars host ( messag byte valu mb ) { ( valu mb = = null ( valu mb = null valu mb . null ( ) ) ) { http 1 . 0 request . set server port ( request . get local port ( ) ) ; try { request . server name ( ) . duplic ( request . local name ( ) ) ; } catch ( ioexcept e ) { respons . set statu ( 400 ) ; error = true ; } return ; } byte chunk valu bc = valu mb . get byte chunk ( ) ; byte valu b = valu bc . get byte ( ) ; int valu l = valu bc . get length ( ) ; int valu s = valu bc . get start ( ) ; int colon po = 1 ; ( host name c . length valu l ) { host name c = new char valu l ; } boolean ipv6 = ( valu b valu s = = ) ; boolean bracket close = fals ; ( int i = 0 ; i valu l ; i ) { char b = ( char ) valu b i valu s ; host name c i = b ; ( b = = ) { bracket close = true ; } els ( b = = : ) { ( ipv6 bracket close ) { colon po = i ; break ; } } } ( colon po 0 ) { ( request . scheme ( ) . equal ignor case ( http ) ) { 443 default http port request . set server port ( 443 ) ; } els { 80 default htttp port request . set server port ( 80 ) ; } request . server name ( ) . set char ( host name c , 0 , valu l ) ; } els { request . server name ( ) . set char ( host name c , 0 , colon po ) ; int port = 0 ; int mult = 1 ; ( int i = valu l 1 ; i colon po ; i ) { int char valu = hex util . dec valu b i valu s ; ( char valu = = 1 ) { invalid charact error = true ; 400 bad request respons . set statu ( 400 ) ; break ; } port = port ( char valu mult ) ; mult = 10 mult ; } request . set server port ( port ) ; } }	public pars host . void pars host ( messag byte valu mb ) { ( valu mb = = null ( valu mb = null valu mb . null ( ) ) ) { http 1 . 0 request . set server port ( request . get local port ( ) ) ; try { request . server name ( ) . duplic ( request . local name ( ) ) ; } catch ( ioexcept e ) { respons . set statu ( 400 ) ; error = true ; } return ; } byte chunk valu bc = valu mb . get byte chunk ( ) ; byte valu b = valu bc . get byte ( ) ; int valu l = valu bc . get length ( ) ; int valu s = valu bc . get start ( ) ; int colon po = 1 ; ( host name c . length valu l ) { host name c = new char valu l ; } boolean ipv6 = ( valu b valu s = = ) ; boolean bracket close = fals ; ( int i = 0 ; i valu l ; i ) { char b = ( char ) valu b i valu s ; host name c i = b ; ( b = = ) { bracket close = true ; } els ( b = = : ) { ( ipv6 bracket close ) { colon po = i ; break ; } } } ( colon po 0 ) { ( request . scheme ( ) . equal ignor case ( http ) ) { 443 default http port request . set server port ( 443 ) ; } els { 80 default htttp port request . set server port ( 80 ) ; } request . server name ( ) . set char ( host name c , 0 , valu l ) ; } els { request . server name ( ) . set char ( host name c , 0 , colon po ) ; int port = 0 ; int mult = 1 ; ( int i = valu l 1 ; i colon po ; i ) { int char valu = hex util . dec valu b i valu s ; ( char valu = = 1 ) { invalid charact error = true ; 400 bad request respons . set statu ( 400 ) ; break ; } port = port ( char valu mult ) ; mult = 10 mult ; } request . set server port ( port ) ; } }	public pars host . void pars host ( messag byte valu mb ) { ( valu mb = = null valu mb . null ( ) ) { http 1 . 0 default what socket tell us . overridden host found pars request . set server port ( endpoint . get port ( ) ) ; return ; } byte chunk valu bc = valu mb . get byte chunk ( ) ; byte valu b = valu bc . get byte ( ) ; int valu l = valu bc . get length ( ) ; int valu s = valu bc . get start ( ) ; int colon po = 1 ; ( host name c . length valu l ) { host name c = new char valu l ; } boolean ipv6 = ( valu b valu s = = ) ; boolean bracket close = fals ; ( int i = 0 ; i valu l ; i ) { char b = ( char ) valu b i valu s ; host name c i = b ; ( b = = ) { bracket close = true ; } els ( b = = : ) { ( ipv6 bracket close ) { colon po = i ; break ; } } } ( colon po 0 ) { ( ssl ) { 80 default http port request . set server port ( 80 ) ; } els { 443 default http port request . set server port ( 443 ) ; } request . server name ( ) . set char ( host name c , 0 , valu l ) ; } els { request . server name ( ) . set char ( host name c , 0 , colon po ) ; int port = 0 ; int mult = 1 ; ( int i = valu l 1 ; i colon po ; i ) { int char valu = hex util . dec valu b i valu s ; ( char valu = = 1 ) { invalid charact error = true ; 400 bad request respons . set statu ( 400 ) ; break ; } port = port ( char valu mult ) ; mult = 10 mult ; } request . set server port ( port ) ; } }	public pars host . void pars host ( messag byte valu mb ) { ( valu mb = = null valu mb . null ( ) ) { http 1 . 0 default what socket tell us . overridden host found pars request . set server port ( endpoint . get port ( ) ) ; return ; } byte chunk valu bc = valu mb . get byte chunk ( ) ; byte valu b = valu bc . get byte ( ) ; int valu l = valu bc . get length ( ) ; int valu s = valu bc . get start ( ) ; int colon po = 1 ; ( host name c . length valu l ) { host name c = new char valu l ; } boolean ipv6 = ( valu b valu s = = ) ; boolean bracket close = fals ; ( int i = 0 ; i valu l ; i ) { char b = ( char ) valu b i valu s ; host name c i = b ; ( b = = ) { bracket close = true ; } els ( b = = : ) { ( ipv6 bracket close ) { colon po = i ; break ; } } } ( colon po 0 ) { ( ssl ) { 80 default http port request . set server port ( 80 ) ; } els { 443 default http port request . set server port ( 443 ) ; } request . server name ( ) . set char ( host name c , 0 , valu l ) ; } els { request . server name ( ) . set char ( host name c , 0 , colon po ) ; int port = 0 ; int mult = 1 ; ( int i = valu l 1 ; i colon po ; i ) { int char valu = hex util . dec valu b i valu s ; ( char valu = = 1 ) { invalid charact error = true ; 400 bad request respons . set statu ( 400 ) ; break ; } port = port ( char valu mult ) ; mult = 10 mult ; } request . set server port ( port ) ; } }	public set buffer represent int void set int ( int i ) { byte c . alloc ( 16 , 32 ) ; int current = i ; byte buf = byte c . get buffer ( ) ; int start = 0 ; int end = 0 ; ( i = = 0 ) { buf end = ( byte ) 0 ; } ( i 0 ) { current = i ; buf end = ( byte ) ; } while ( current 0 ) { int digit = current 10 ; current = current 10 ; buf end = hex util . hex digit ; } byte c . set offset ( 0 ) ; byte c . set end ( end ) ; invert buffer end ; ( i 0 ) { start ; } while ( end start ) { byte temp = buf start ; buf start = buf end ; buf end = temp ; start ; end ; } int valu = i ; ha str valu = fals ; ha hash code = fals ; ha int valu = true ; ha long valu = fals ; type = t byte ; }	public set buffer represent long void set long ( long l ) { byte c . alloc ( 32 , 64 ) ; long current = l ; byte buf = byte c . get buffer ( ) ; int start = 0 ; int end = 0 ; ( l = = 0 ) { buf end = ( byte ) 0 ; } ( l 0 ) { current = l ; buf end = ( byte ) ; } while ( current 0 ) { int digit = ( int ) ( current 10 ) ; current = current 10 ; buf end = hex util . hex digit ; } byte c . set offset ( 0 ) ; byte c . set end ( end ) ; invert buffer end ; ( l 0 ) { start ; } while ( end start ) { byte temp = buf start ; buf start = buf end ; buf end = temp ; start ; end ; } long valu = l ; ha str valu = fals ; ha hash code = fals ; ha int valu = fals ; ha long valu = true ; type = t byte ; }
public void remov ( ) { empti oper }	public long get recoveri sleep time ( ) { return recoveri sleep time ; }
public perform block read us bytebuff data read code selector code paramet null , perform busi read could take up lot cpu cycl . param buf byte buffer buffer contain data , we read until we have read least byte we time out param socket socket channel socket write data param read timeout long timeout thi read oper millisecond , 1 mean timeout return int return number byte read throw eofexcept read return 1 throw socket timeout except read time out throw ioexcept io except occur underli socket logic int read ( byte buffer buf , nio channel socket , long read timeout ) throw ioexcept { select kei kei = socket . get iochannel ( ) . kei ( socket . get poller ( ) . get selector ( ) ) ; ( kei = = null ) throw new ioexcept ( kei longer regist ) ; kei refer refer = new kei refer ( ) ; kei attach att = ( kei attach ) kei . attach ( ) ; int read = 0 ; boolean timedout = fals ; assum we can write int keycount = 1 ; start timeout timer long time = system . current time milli ( ) ; try { while ( ( timedout ) read = = 0 ) { ( keycount 0 ) { onli read we were regist read int cnt = socket . read ( buf ) ; ( cnt = = 1 ) throw new eofexcept ( ) ; read = cnt ; ( cnt 0 ) break ; } try { ( att . get read latch ( ) = = null att . get read latch ( ) . get count ( ) = = 0 ) att . start read latch ( 1 ) ; poller . add ( att , select kei . op read , refer ) ; att . await read latch ( read timeout , time unit . millisecond ) ; } catch ( interrupt except ignor ) { thread . interrupt ( ) ; } ( att . get read latch ( ) = null att . get read latch ( ) . get count ( ) 0 ) { we got interrupt , we haven t receiv notif from poller . keycount = 0 ; } els { latch countdown ha happen keycount = 1 ; att . reset read latch ( ) ; } ( read timeout 0 ( keycount = = 0 ) ) timedout = ( system . current time milli ( ) time ) = read timeout ; } while ( timedout ) throw new socket timeout except ( ) ; } final { poller . remov ( att , select kei . op read ) ; ( timedout refer . kei = null ) { poller . cancel kei ( refer . kei ) ; } refer . kei = null ; } return read ; }
public destroi name context remov from namespac . ani attribut associ name ar also remov . intermedi context ar destroi . p thi method idempot . succe even termin atom name bound target context , throw name found except ani intermedi context do exist . feder name system , context from name system mai bound name anoth . can subsequ look up perform oper foreign context us composit name . howev , attempt destroi context us thi composit name fail context except , becaus foreign context subcontext context which bound . instead , us unbind ( ) remov bind foreign context . destroi foreign context requir destroi subcontext ( ) perform context from foreign context s nativ name system . param name name context destroi ; mai empti except name found except intermedi context doe exist except context except name bound doe name context , doe name context appropri type void destroi subcontext ( name name ) throw name except { check writabl ( ) ; while ( ( name . empti ( ) ) ( name . get ( 0 ) . length ( ) = = 0 ) ) name = name . get suffix ( 1 ) ; ( name . empti ( ) ) throw new name except ( sm . get string ( name context . invalid name ) ) ; name entri entri = bind . get ( name . get ( 0 ) ) ; ( entri = = null ) { throw new name found except ( sm . get string ( name context . name bound , name . get ( 0 ) ) ) ; } ( name . size ( ) 1 ) { ( entri . type = = name entri . context ) { ( ( context ) entri . valu ) . unbind ( name . get suffix ( 1 ) ) ; } els { throw new name except ( sm . get string ( name context . context expect ) ) ; } } els { ( entri . type = = name entri . context ) { ( ( context ) entri . valu ) . close ( ) ; bind . remov ( name . get ( 0 ) ) ; } els { throw new context except ( sm . get string ( name context . context expect ) ) ; } } }
public void set domain ( byte domain ) { thi . domain = domain ; }	public void set domain ( byte domain ) { thi . domain = domain ; ( local member = null ) { local member . set domain ( domain ) ; local member . get data ( true , true ) ; try { ( impl = null ) impl . send ( fals ) ; } catch ( except x ) { log . error ( unabl send domain updat . , x ) ; } } }
overrid public void begin ( string namespac , string name , attribut attribut ) throw except { ( login config set ) { throw new illeg argument except ( login config element limit 1 occurr ) ; } login config set = true ; }
privat process properti chang global name resourc , make correspond addit remov associ jndi context . param name properti name chang process param old valu old valu ( code null code ad ) param new valu new valu ( code null code remov ) void process global resourc chang ( string name , object old valu , object new valu ) { left read write mode , so we do have chang here ( name . equal ( ejb ) ) { ( old valu = null ) { context ejb ejb = ( context ejb ) old valu ; ( ejb . get name ( ) = null ) { remov ejb ( ejb . get name ( ) ) ; } } ( new valu = null ) { context ejb ejb = ( context ejb ) new valu ; ( ejb . get name ( ) = null ) { add ejb ( ejb ) ; } } } els ( name . equal ( environ ) ) { ( old valu = null ) { context environ env = ( context environ ) old valu ; ( env . get name ( ) = null ) { remov environ ( env . get name ( ) ) ; } } ( new valu = null ) { context environ env = ( context environ ) new valu ; ( env . get name ( ) = null ) { add environ ( env ) ; } } } els ( name . equal ( local ejb ) ) { ( old valu = null ) { context local ejb ejb = ( context local ejb ) old valu ; ( ejb . get name ( ) = null ) { remov local ejb ( ejb . get name ( ) ) ; } } ( new valu = null ) { context local ejb ejb = ( context local ejb ) new valu ; ( ejb . get name ( ) = null ) { add local ejb ( ejb ) ; } } } els ( name . equal ( resourc ) ) { ( old valu = null ) { context resourc resourc = ( context resourc ) old valu ; ( resourc . get name ( ) = null ) { remov resourc ( resourc . get name ( ) ) ; } } ( new valu = null ) { context resourc resourc = ( context resourc ) new valu ; ( resourc . get name ( ) = null ) { add resourc ( resourc ) ; } } } els ( name . equal ( resourc env ref ) ) { ( old valu = null ) { context resourc env ref resourc env ref = ( context resourc env ref ) old valu ; ( resourc env ref . get name ( ) = null ) { remov resourc env ref ( resourc env ref . get name ( ) ) ; } } ( new valu = null ) { context resourc env ref resourc env ref = ( context resourc env ref ) new valu ; ( resourc env ref . get name ( ) = null ) { add resourc env ref ( resourc env ref ) ; } } } els ( name . equal ( resourc link ) ) { ( old valu = null ) { context resourc link rl = ( context resourc link ) old valu ; ( rl . get name ( ) = null ) { remov resourc link ( rl . get name ( ) ) ; } } ( new valu = null ) { context resourc link rl = ( context resourc link ) new valu ; ( rl . get name ( ) = null ) { add resourc link ( rl ) ; } } } els ( name . equal ( servic ) ) { ( old valu = null ) { context servic servic = ( context servic ) old valu ; ( servic . get name ( ) = null ) { remov servic ( servic . get name ( ) ) ; } } ( new valu = null ) { context servic servic = ( context servic ) new valu ; ( servic . get name ( ) = null ) { add servic ( servic ) ; } } } }	public acknowledg occurr specifi event . note : never call when listen associ server , sinc contain . param event contain event ha occur void contain event ( contain event event ) { ( initi ) return ; set context read write mode context access control . set writabl ( get name ( ) , contain ) ; string type = event . get type ( ) ; ( type . equal ( add ejb ) ) { string ejb name = ( string ) event . get data ( ) ; ( ejb name = null ) { context ejb ejb = name resourc . find ejb ( ejb name ) ; add ejb ( ejb ) ; } } els ( type . equal ( add environ ) ) { string environ name = ( string ) event . get data ( ) ; ( environ name = null ) { context environ env = name resourc . find environ ( environ name ) ; add environ ( env ) ; } } els ( type . equal ( add local ejb ) ) { string local ejb name = ( string ) event . get data ( ) ; ( local ejb name = null ) { context local ejb local ejb = name resourc . find local ejb ( local ejb name ) ; add local ejb ( local ejb ) ; } } els ( type . equal ( add resourc ) ) { string resourc name = ( string ) event . get data ( ) ; ( resourc name = null ) { context resourc resourc = name resourc . find resourc ( resourc name ) ; add resourc ( resourc ) ; } } els ( type . equal ( add resourc link ) ) { string resourc link name = ( string ) event . get data ( ) ; ( resourc link name = null ) { context resourc link resourc link = name resourc . find resourc link ( resourc link name ) ; add resourc link ( resourc link ) ; } } els ( type . equal ( add resourc env ref ) ) { string resourc env ref name = ( string ) event . get data ( ) ; ( resourc env ref name = null ) { context resourc env ref resourc env ref = name resourc . find resourc env ref ( resourc env ref name ) ; add resourc env ref ( resourc env ref ) ; } } els ( type . equal ( add servic ) ) { string servic name = ( string ) event . get data ( ) ; ( servic name = null ) { context servic servic = name resourc . find servic ( servic name ) ; add servic ( servic ) ; } } els ( type . equal ( remov ejb ) ) { string ejb name = ( string ) event . get data ( ) ; ( ejb name = null ) { remov ejb ( ejb name ) ; } } els ( type . equal ( remov environ ) ) { string environ name = ( string ) event . get data ( ) ; ( environ name = null ) { remov environ ( environ name ) ; } } els ( type . equal ( remov local ejb ) ) { string local ejb name = ( string ) event . get data ( ) ; ( local ejb name = null ) { remov local ejb ( local ejb name ) ; } } els ( type . equal ( remov resourc ) ) { string resourc name = ( string ) event . get data ( ) ; ( resourc name = null ) { remov resourc ( resourc name ) ; } } els ( type . equal ( remov resourc link ) ) { string resourc link name = ( string ) event . get data ( ) ; ( resourc link name = null ) { remov resourc link ( resourc link name ) ; } } els ( type . equal ( remov resourc env ref ) ) { string resourc env ref name = ( string ) event . get data ( ) ; ( resourc env ref name = null ) { remov resourc env ref ( resourc env ref name ) ; } } els ( type . equal ( remov servic ) ) { string servic name = ( string ) event . get data ( ) ; ( servic name = null ) { remov servic ( servic name ) ; } } set context read onli mode context access control . set read onli ( get name ( ) ) ; }	public acknowledg occurr specifi event . param event lifecycl event ha occur void lifecycl event ( lifecycl event event ) { contain = event . get lifecycl ( ) ; ( contain instanceof context ) { name resourc = ( ( context ) contain ) . get name resourc ( ) ; logger = log ; } els ( contain instanceof server ) { name resourc = ( ( server ) contain ) . get global name resourc ( ) ; } els { return ; } ( lifecycl . start event . equal ( event . get type ( ) ) ) { ( initi ) return ; hashtabl string , object context env = new hashtabl string , object ( ) ; try { name context = new name context ( context env , get name ( ) ) ; } catch ( name except e ) { never happen } context access control . set secur token ( get name ( ) , contain ) ; context bind . bind context ( contain , name context , contain ) ; ( log . debug enabl ( ) ) { log . debug ( bound contain ) ; } set context read write mode context access control . set writabl ( get name ( ) , contain ) ; try { creat name context ( ) ; } catch ( name except e ) { logger . error ( sm . get string ( name . name context creation fail , e ) ) ; } bind name context class loader ( contain instanceof context ) { set context read onli mode context access control . set read onli ( get name ( ) ) ; try { context bind . bind class loader ( contain , contain , ( ( contain ) contain ) . get loader ( ) . get class loader ( ) ) ; } catch ( name except e ) { logger . error ( sm . get string ( name . bind fail , e ) ) ; } } ( contain instanceof server ) { name resourc . add properti chang listen ( thi ) ; org . apach . name . factori . resourc link factori . set global context ( name context ) ; try { context bind . bind class loader ( contain , contain , thi . get class ( ) . get class loader ( ) ) ; } catch ( name except e ) { logger . error ( sm . get string ( name . bind fail , e ) ) ; } ( contain instanceof standard server ) { ( ( standard server ) contain ) . set global name context ( name context ) ; } } initi = true ; } els ( lifecycl . stop event . equal ( event . get type ( ) ) ) { ( initi ) return ; set context read write mode context access control . set writabl ( get name ( ) , contain ) ; context bind . unbind context ( contain , contain ) ; ( contain instanceof context ) { context bind . unbind class loader ( contain , contain , ( ( contain ) contain ) . get loader ( ) . get class loader ( ) ) ; } ( contain instanceof server ) { name resourc . remov properti chang listen ( thi ) ; context bind . unbind class loader ( contain , contain , thi . get class ( ) . get class loader ( ) ) ; } context access control . unset secur token ( get name ( ) , contain ) ; name context = null ; env ctx = null ; comp ctx = null ; initi = fals ; } }	public process properti chang event . current , onli listen event code name resourc code instanc global name resourc . param event properti chang event ha occur void properti chang ( properti chang event event ) { ( initi ) return ; object sourc = event . get sourc ( ) ; ( sourc = = name resourc ) { set context read write mode context access control . set writabl ( get name ( ) , contain ) ; process global resourc chang ( event . get properti name ( ) , event . get old valu ( ) , event . get new valu ( ) ) ; set context read onli mode context access control . set read onli ( get name ( ) ) ; } }
public void destroi ( ) { ( onam = null ) registri . get registri ( null , null ) . unregist compon ( onam ) ; initi = fals ; onam = null ; }
public gener properti , introspect boolean set properti ( string name , string valu ) { final string socket name = socket . ; try { ( name . start ( socket name ) ) { return introspect util . set properti ( socket properti , name . substr ( socket name . length ( ) ) , valu ) ; } els { return introspect util . set properti ( thi , name , valu ) ; } } catch ( except x ) { log . error ( unabl set attribut name valu , x ) ; return fals ; } }	public static find method right name found , call method ( param int boolean we ll convert valu right type befor ) mean you can have set debug ( 1 ) . boolean set properti ( object o , string name , string valu ) { ( log . debug enabl ( ) ) log . debug ( introspect util : set properti ( o . get class ( ) name = valu ) ) ; string setter = set capit ( name ) ; try { method method = find method ( o . get class ( ) ) ; method set properti method void = null ; method set properti method bool = null ; first , ideal case set foo ( string ) method ( int i = 0 ; i method . length ; i ) { class param t = method i . get paramet type ( ) ; ( setter . equal ( method i . get name ( ) ) param t . length = = 1 java . lang . string . equal ( param t 0 . get name ( ) ) ) { method i . invok ( o , new object { valu } ) ; return true ; } } try set foo ( int ) ( boolean ) ( int i = 0 ; i method . length ; i ) { boolean ok = true ; ( setter . equal ( method i . get name ( ) ) method i . get paramet type ( ) . length = = 1 ) { match find type invok class param type = method i . get paramet type ( ) 0 ; object param = new object 1 ; try set foo ( int ) ( java . lang . integ . equal ( param type . get name ( ) ) int . equal ( param type . get name ( ) ) ) { try { param 0 = new integ ( valu ) ; } catch ( number format except ex ) { ok = fals ; } try set foo ( long ) } els ( java . lang . long . equal ( param type . get name ( ) ) long . equal ( param type . get name ( ) ) ) { try { param 0 = new long ( valu ) ; } catch ( number format except ex ) { ok = fals ; } try set foo ( boolean ) } els ( java . lang . boolean . equal ( param type . get name ( ) ) boolean . equal ( param type . get name ( ) ) ) { param 0 = new boolean ( valu ) ; try set foo ( inet address ) } els ( java . net . inet address . equal ( param type . get name ( ) ) ) { try { param 0 = inet address . get name ( valu ) ; } catch ( unknown host except exc ) { ( log . debug enabl ( ) ) log . debug ( introspect util : unabl resolv host name : valu ) ; ok = fals ; } unknown type } els { ( log . debug enabl ( ) ) log . debug ( introspect util : unknown type param type . get name ( ) ) ; } ( ok ) { method i . invok ( o , param ) ; return true ; } } save set properti later ( set properti . equal ( method i . get name ( ) ) ) { ( method i . get return type ( ) = = boolean . type ) { set properti method bool = method i ; } els { set properti method void = method i ; } } } ok , set xxx found , try set properti ( name , valu ) ( set properti method bool = null set properti method void = null ) { object param = new object 2 ; param 0 = name ; param 1 = valu ; ( set properti method bool = null ) { try { return ( boolean ) set properti method bool . invok ( o , param ) ; } catch ( illeg argument except biae ) { paramet type . let try other ( set properti method void = null ) { set properti method void . invok ( o , param ) ; return true ; } els { throw biae ; } } } els { set properti method void . invok ( o , param ) ; return true ; } } } catch ( illeg argument except ex2 ) { log . warn ( iae o name valu , ex2 ) ; } catch ( secur except ex1 ) { ( log . debug enabl ( ) ) log . debug ( introspect util : secur except o . get class ( ) name = valu ) , ex1 ) ; } catch ( illeg access except iae ) { ( log . debug enabl ( ) ) log . debug ( introspect util : illeg access except o . get class ( ) name = valu ) , iae ) ; } catch ( invoc target except ie ) { ( log . debug enabl ( ) ) log . debug ( introspect util : invoc target except o . get class ( ) name = valu ) , ie ) ; } return fals ; }
public synchron set loader which thi contain associ . param loader newli associ loader void set loader ( loader loader ) { chang compon necessari loader old loader = thi . loader ; ( old loader = = loader ) return ; thi . loader = loader ; stop old compon necessari ( start ( old loader = null ) ( old loader instanceof lifecycl ) ) { try { ( ( lifecycl ) old loader ) . stop ( ) ; } catch ( lifecycl except e ) { log . error ( contain base . set loader : stop : , e ) ; } } start new compon necessari ( loader = null ) loader . set contain ( thi ) ; ( start ( loader = null ) ( loader instanceof lifecycl ) ) { try { ( ( lifecycl ) loader ) . start ( ) ; } catch ( lifecycl except e ) { log . error ( contain base . set loader : start : , e ) ; } } report thi properti chang interest listen support . fire properti chang ( loader , old loader , thi . loader ) ; }
privat method us initi classpath compil . void init class path ( ) { string builder cpath = new string builder ( ) ; string sep = system . get properti ( path . separ ) ; ( parent class loader instanceof urlclass loader ) { url url = ( ( urlclass loader ) parent class loader ) . get url ( ) ; ( int i = 0 ; i url . length ; i ) { protocol url s classpath . ( url i . get protocol ( ) . equal ( file ) ) { cpath . append ( url i . get file ( ) sep ) ; } } } cpath . append ( option . get scratch dir ( ) sep ) ; string cp = ( string ) context . get attribut ( constant . servlet classpath ) ; ( cp = = null cp . equal ( ) ) { cp = option . get class path ( ) ; } classpath = cpath . string ( ) cp ; ( log . debug enabl ( ) ) { log . debug ( compil classpath initi : get class path ( ) ) ; } }	privat method us initi secur manag data . void init secur ( ) { setup permiss collect thi web app context base permiss configur root web app context directori , add file read permiss directori . polici polici = polici . get polici ( ) ; ( polici = null ) { try { get permiss web app context string doc base = context . get real path ( ) ; ( doc base = = null ) { doc base = option . get scratch dir ( ) . string ( ) ; } string code base = doc base ; ( code base . end ( file . separ ) ) { code base = code base file . separ ; } file context dir = new file ( code base ) ; url url = context dir . get canon file ( ) . uri ( ) . url ( ) ; code sourc = new code sourc ( url , ( certif ) null ) ; permiss collect = polici . get permiss ( code sourc ) ; creat file read permiss web app context directori ( doc base . end ( file . separ ) ) { permiss collect . add ( new file permiss ( doc base , read ) ) ; doc base = doc base file . separ ; } els { permiss collect . add ( new file permiss ( doc base . substr ( 0 , doc base . length ( ) 1 ) , read ) ) ; } doc base = doc base ; permiss collect . add ( new file permiss ( doc base , read ) ) ; spec sai app should have read write temp directori . thi fine , secur sensit file , least ani app doesn t have full control anywai , written here . string work dir = option . get scratch dir ( ) . string ( ) ; ( work dir . end ( file . separ ) ) { permiss collect . add ( new file permiss ( work dir , read , write ) ) ; work dir = work dir file . separ ; } work dir = work dir ; permiss collect . add ( new file permiss ( work dir , read , write , delet ) ) ; allow jsp access org . apach . jasper . runtim . http jsp base permiss collect . add ( new runtim permiss ( access class packag . org . apach . jasper . runtim ) ) ; ( parent class loader instanceof urlclass loader ) { url url = ( ( urlclass loader ) parent class loader ) . get url ( ) ; string jar url = null ; string jndi url = null ; ( int i = 0 ; i url . length ; i ) { ( jndi url = = null url i . string ( ) . start ( jndi : ) ) { jndi url = url i . string ( ) ; } ( jar url = = null url i . string ( ) . start ( jar : jndi : ) ) { jar url = url i . string ( ) ; jar url = jar url . substr ( 0 , jar url . length ( ) 2 ) ; jar url = jar url . substr ( 0 , jar url . last index ( ) ) ; } } ( jar url = null ) { permiss collect . add ( new file permiss ( jar url , read ) ) ; permiss collect . add ( new file permiss ( jar url . substr ( 4 ) , read ) ) ; } ( jndi url = null ) permiss collect . add ( new file permiss ( jndi url , read ) ) ; } } catch ( except e ) { context . log ( secur init context fail , e ) ; } } }	public classpath pass off java compil . string get class path ( ) { return classpath ; }	public get current valu jsp reload counter . return current valu jsp reload counter int get jsp reload count ( ) { return jsp reload count ; }	public synchron increment jsp reload counter . void increment jsp reload count ( ) { jsp reload count ; }	public process destroi event thi web applic context . void destroi ( ) { iter jsp servlet wrapper servlet = jsp . valu ( ) . iter ( ) ; while ( servlet . ha next ( ) ) { servlet . next ( ) . destroi ( ) ; } }
public static byte creat data packag ( byte data , int doff , int dlength , byte buffer , int bufoff ) { ( ( buffer . length bufoff ) get data packag length ( dlength ) ) { throw new arrai index out bound except ( unabl creat data packag , buffer too small . ) ; } system . arraycopi ( start data , 0 , buffer , bufoff , start data . length ) ; byte ( data . length , buffer , bufoff start data . length ) ; system . arraycopi ( data , doff , buffer , bufoff start data . length 4 , dlength ) ; system . arraycopi ( end data , 0 , buffer , bufoff start data . length 4 data . length , end data . length ) ; return buffer ; }	public static serializ deseri ( byte data , int offset , int length ) throw ioexcept , class found except , class cast except { return deseri ( data , offset , length , null ) ; }	public static byte byte ( boolean bool , byte data , int offset ) { data offset = ( byte ) ( bool 1 : 0 ) ; return data ; }

public nio endpoint get endpoint ( ) { return ( ( nio endpoint ) endpoint ) ; }	public void deregist ( http11nio processor processor ) { ( proto . get domain ( ) = null ) { synchron ( thi ) { try { regist count . add get ( 1 ) ; ( log . debug enabl ( ) ) log . debug ( deregist processor count = regist count . get ( ) ) ; request info rp = processor . get request ( ) . get request processor ( ) ; rp . set global processor ( null ) ; object name rp name = rp . get rp name ( ) ; registri . get registri ( null , null ) . unregist compon ( rp name ) ; rp . set rp name ( null ) ; } catch ( except e ) { log . warn ( error unregist request , e ) ; } } } }	public start protocol void init ( ) throw except { endpoint . set name ( get name ( ) ) ; ( ( nio endpoint ) endpoint ) . set handler ( c handler ) ; try { endpoint . init ( ) ; ssl implement = new jsseimplement ( ) ; } catch ( except ex ) { log . error ( sm . get string ( http11protocol . endpoint . initerror ) , ex ) ; throw ex ; } ( log . info enabl ( ) ) log . info ( sm . get string ( http11protocol . init , get name ( ) ) ) ; }	public void init ( ) throw except { ( ( jio endpoint ) endpoint ) . set name ( get name ( ) ) ; ( ( jio endpoint ) endpoint ) . set handler ( c handler ) ; verifi valid configur socket factori try { ( sslenabl ( ) ) { ssl implement = sslimplement . get instanc ( ssl implement name ) ; socket factori = ssl implement . get server socket factori ( ) ; ( ( jio endpoint ) endpoint ) . set server socket factori ( socket factori ) ; } els ( socket factori name = null ) { socket factori = ( server socket factori ) class . name ( socket factori name ) . new instanc ( ) ; ( ( jio endpoint ) endpoint ) . set server socket factori ( socket factori ) ; } } catch ( except ex ) { log . error ( sm . get string ( http11protocol . socketfactori . initerror ) , ex ) ; throw ex ; } ( socket factori = null ) { iter string att e = attribut . kei set ( ) . iter ( ) ; while ( att e . ha next ( ) ) { string kei = att e . next ( ) ; object v = attribut . get ( kei ) ; socket factori . set attribut ( kei , v ) ; } } try { endpoint . init ( ) ; } catch ( except ex ) { log . error ( sm . get string ( http11protocol . endpoint . initerror ) , ex ) ; throw ex ; } ( log . info enabl ( ) ) log . info ( sm . get string ( http11protocol . init , get name ( ) ) ) ; }
overrid public boolean unavail ( ) { return fals ; }

privat copi file specifi temp directori . thi requir onli becaus jasper depend . boolean copi ( input stream , output stream os ) { try { byte buf = new byte 4096 ; while ( true ) { int len = . read ( buf ) ; ( len 0 ) break ; os . write ( buf , 0 , len ) ; } . close ( ) ; os . close ( ) ; } catch ( ioexcept e ) { return fals ; } return true ; }	privat static return unqualifi version given file path . string unqualifi ( string path ) { path = path . replac ( , ) ; return path . substr ( path . last index ( ) 1 ) ; }	public void deregist ( http11nio processor processor ) { ( proto . get domain ( ) = null ) { synchron ( thi ) { try { regist count . add get ( 1 ) ; ( log . debug enabl ( ) ) log . debug ( deregist processor count = regist count . get ( ) ) ; request info rp = processor . get request ( ) . get request processor ( ) ; rp . set global processor ( null ) ; object name rp name = rp . get rp name ( ) ; registri . get registri ( null , null ) . unregist compon ( rp name ) ; rp . set rp name ( null ) ; } catch ( except e ) { log . warn ( error unregist request , e ) ; } } } }	public void remov ( ) { empti oper }	protect void usag ( ) { system . out . println ( usag : java org . apach . catalina . startup . catalina config { pathnam } nonam { help start stop } ) ; }



protect return bodi pass contain via set jsp bodi . return fragment encapsul bodi thi tag , null action element empti page . jsp fragment get jsp bodi ( ) { return thi . jsp bodi ; }	public thi method indic whether jsp writer auto flush . return thi jsp writer auto flush throw ioexcept buffer overflow condit boolean auto flush ( ) { return auto flush ; }	protect return time code http servlet request code object wa last modifi , millisecond sinc midnight januari 1 , 1970 gmt . time unknown , thi method return neg number ( default ) . p servlet support http get request can quickli determin last modif time should overrid thi method . thi make browser proxi cach work more effect , reduc load server network resourc . param req code http servlet request code object sent servlet return code long code integ specifi time code http servlet request code object wa last modifi , millisecond sinc midnight , januari 1 , 1970 gmt , 1 time known long get last modifi ( suppress warn ( unus ) http servlet request req ) { return 1 ; }	public get function info given function name , look through all function thi tag librari . param name name ( prefix ) function return function info function given name , null function exist sinc 2 . 0 function info get function ( string name ) { ( function = = null function . length = = 0 ) { system . err . println ( function ) ; return null ; } ( int i = 0 ; i function . length ; i ) { ( function i . get name ( ) . equal ( name ) ) { return function i ; } } return null ; }	public return inform about servlet , author , version , copyright . default , thi method return empti string . overrid thi method have return meaning valu . see { link servlet get servlet info } . return string inform about thi servlet , default empti string string get servlet info ( ) { return ; }
privat check compress boolean compress ( ) { nope compress could work http 1 . 0 also cf : mod deflat compress onli sinc http 1 . 1 ( http11 ) return fals ; check browser support gzip encod messag byte accept encod mb = request . get mime header ( ) . get valu ( accept encod ) ; ( ( accept encod mb = = null ) ( accept encod mb . index ( gzip ) = = 1 ) ) return fals ; check content allreadi gzip messag byte content encod mb = respons . get mime header ( ) . get valu ( content encod ) ; ( ( content encod mb = null ) ( content encod mb . index ( gzip ) = 1 ) ) return fals ; forc mode , allwai compress ( test purpos onli ) ( compress level = = 2 ) return true ; check incompat browser ( compress user agent = null ) { messag byte user agent valu mb = request . get mime header ( ) . get valu ( user agent ) ; ( user agent valu mb = null ) { string user agent valu = user agent valu mb . string ( ) ; regexp rule match , disabl compress ( int i = 0 ; i compress user agent . length ; i ) ( compress user agent i . matcher ( user agent valu ) . match ( ) ) return fals ; } } check suffis len trig compress long content length = respons . get content length long ( ) ; ( ( content length = = 1 ) ( content length compress min size ) ) { check compat mime type ( compress mime type = null ) { return ( start string arrai ( compress mime type , respons . get content type ( ) ) ) ; } } return fals ; }	privat final target get target ( evalu context ctx ) throw elexcept { evalu expr valu object base = thi . children 0 . get valu ( ctx ) ; our base null ( we know ar more properit evalu ) ( base = = null ) { throw new properti found except ( messag factori . get ( error . unreach . base , thi . children 0 . get imag ( ) ) ) ; } set up our start end object properti = null ; int prop count = thi . jjt get num children ( ) 1 ; int i = 1 ; evalu ani properti befor our target elresolv resolv = ctx . get elresolv ( ) ; ( prop count 1 ) { while ( base = null i prop count ) { properti = thi . children i . get valu ( ctx ) ; ctx . set properti resolv ( fals ) ; base = resolv . get valu ( ctx , base , properti ) ; i ; } our base wa null ( base = = null properti = = null ) { throw new properti found except ( messag factori . get ( error . unreach . properti , properti ) ) ; } } properti = thi . children i . get valu ( ctx ) ; ( properti = = null ) { throw new properti found except ( messag factori . get ( error . unreach . properti , thi . children i ) ) ; } target t = new target ( ) ; t . base = base ; t . properti = properti ; return t ; }	privat synchron param bytebuff byte buffer param flip boolean return int throw ioexcept todo fix non block write properli int write socket ( byte buffer bytebuff , boolean block , boolean flip ) throw ioexcept { ( flip ) bytebuff . flip ( ) ; int written = 0 ; nio endpoint . kei attach att = ( nio endpoint . kei attach ) socket . get attach ( fals ) ; ( att = = null ) throw new ioexcept ( kei must cancel ) ; long write timeout = att . get timeout ( ) ; selector selector = null ; try { selector = get selector pool ( ) . get ( ) ; } catch ( ioexcept x ) { ignor } try { written = get selector pool ( ) . write ( bytebuff , socket , selector , write timeout , block , last write ) ; make sure we ar flush do { ( socket . flush ( true , selector , write timeout , last write ) ) break ; } while ( true ) ; } final { ( selector = null ) get selector pool ( ) . put ( selector ) ; } onli clear ( block ) bytebuff . clear ( ) ; thi . total = 0 ; return written ; }	protect check compress boolean compress ( ) { nope compress could work http 1 . 0 also cf : mod deflat compress onli sinc http 1 . 1 ( http11 ) return fals ; check browser support gzip encod messag byte accept encod mb = request . get mime header ( ) . get valu ( accept encod ) ; ( ( accept encod mb = = null ) ( accept encod mb . index ( gzip ) = = 1 ) ) return fals ; check content allreadi gzip messag byte content encod mb = respons . get mime header ( ) . get valu ( content encod ) ; ( ( content encod mb = null ) ( content encod mb . index ( gzip ) = 1 ) ) return fals ; forc mode , allwai compress ( test purpos onli ) ( compress level = = 2 ) return true ; check incompat browser ( compress user agent = null ) { messag byte user agent valu mb = request . get mime header ( ) . get valu ( user agent ) ; ( user agent valu mb = null ) { string user agent valu = user agent valu mb . string ( ) ; regexp rule match , disabl compress ( int i = 0 ; i compress user agent . length ; i ) ( compress user agent i . matcher ( user agent valu ) . match ( ) ) return fals ; } } check suffis len trig compress long content length = respons . get content length long ( ) ; ( ( content length = = 1 ) ( content length compress min size ) ) { check compat mime type ( compress mime type = null ) { return ( start string arrai ( compress mime type , respons . get content type ( ) ) ) ; } } return fals ; }	protect commit respons . throw ioexcept und i o error occur void commit ( ) throw ioexcept { respons now commit commit = true ; respons . set commit ( true ) ; ( po 0 ) { send respons header buffer bbuf . put ( buf , 0 , po ) ; } }	protect pars host . void pars host ( messag byte valu mb ) { ( valu mb = = null valu mb . null ( ) ) { http 1 . 0 default what socket tell us . overriden host found pars request . set server port ( socket . get local port ( ) ) ; inet address local address = socket . get local address ( ) ; set socket relat field . adapt doesn t know about socket . request . server name ( ) . set string ( local address . get host name ( ) ) ; return ; } byte chunk valu bc = valu mb . get byte chunk ( ) ; byte valu b = valu bc . get byte ( ) ; int valu l = valu bc . get length ( ) ; int valu s = valu bc . get start ( ) ; int colon po = 1 ; ( host name c . length valu l ) { host name c = new char valu l ; } boolean ipv6 = ( valu b valu s = = ) ; boolean bracket close = fals ; ( int i = 0 ; i valu l ; i ) { char b = ( char ) valu b i valu s ; host name c i = b ; ( b = = ) { bracket close = true ; } els ( b = = : ) { ( ipv6 bracket close ) { colon po = i ; break ; } } } ( colon po 0 ) { ( ssl support = = null ) { 80 default http port request . set server port ( 80 ) ; } els { 443 default http port request . set server port ( 443 ) ; } request . server name ( ) . set char ( host name c , 0 , valu l ) ; } els { request . server name ( ) . set char ( host name c , 0 , colon po ) ; int port = 0 ; int mult = 1 ; ( int i = valu l 1 ; i colon po ; i ) { int char valu = hex util . dec valu b i valu s ; ( char valu = = 1 ) { invalid charact error = true ; 400 bad request respons . set statu ( 400 ) ; break ; } port = port ( char valu mult ) ; mult = 10 mult ; } request . set server port ( port ) ; } }	protect thi method write content specyfi messag byte buffer output stream , without filter . thi method meant us write respons header . param bc data written void write ( byte chunk bc ) { write byte chunk output buffer int length = bc . get length ( ) ; system . arraycopi ( bc . get byte ( ) , bc . get start ( ) , buf , po , length ) ; po = po length ; }	protect thi method write content specyfi messag byte buffer output stream , without filter . thi method meant us write respons header . param bc data written void write ( byte chunk bc ) { write byte chunk output buffer int length = bc . get length ( ) ; system . arraycopi ( bc . get byte ( ) , bc . get start ( ) , buf , po , length ) ; po = po length ; }	protect thi method write content specyfi char buffer output stream , without filter . thi method meant us write respons header . param cc data written void write ( char chunk cc ) { int start = cc . get start ( ) ; int end = cc . get end ( ) ; char cbuf = cc . get buffer ( ) ; ( int i = start ; i end ; i ) { char c = cbuf i ; stream properli encod output . ( ( c = 31 ) ( c = 9 ) ) { c = ; } els ( c = = 127 ) { c = ; } buf po = ( byte ) c ; } }	protect thi method write content specyfi char buffer output stream , without filter . thi method meant us write respons header . param cc data written void write ( char chunk cc ) { int start = cc . get start ( ) ; int end = cc . get end ( ) ; char cbuf = cc . get buffer ( ) ; ( int i = start ; i end ; i ) { char c = cbuf i ; stream properli encod output . ( ( c = 31 ) ( c = 9 ) ) { c = ; } els ( c = = 127 ) { c = ; } buf po = ( byte ) c ; } }	protect thi method write content specyfi messag byte buffer output stream , without filter . thi method meant us write respons header . param mb data written void write ( messag byte mb ) { ( mb . get type ( ) = = messag byte . t byte ) { byte chunk bc = mb . get byte chunk ( ) ; write ( bc ) ; } els ( mb . get type ( ) = = messag byte . t char ) { char chunk cc = mb . get char chunk ( ) ; write ( cc ) ; } els { write ( mb . string ( ) ) ; } }	protect thi method write content specyfi messag byte buffer output stream , without filter . thi method meant us write respons header . param mb data written void write ( messag byte mb ) { ( mb . get type ( ) = = messag byte . t byte ) { byte chunk bc = mb . get byte chunk ( ) ; write ( bc ) ; } els ( mb . get type ( ) = = messag byte . t char ) { char chunk cc = mb . get char chunk ( ) ; write ( cc ) ; } els { write ( mb . string ( ) ) ; } }	public i18n local get local ( ) { return local ; }	public nio selector pool get selector pool ( ) { return pool ; }	public return content languag . string get content languag ( ) { return content languag ; }	public boolean writabl ( ) { return last write . get ( ) 0 ; }	read request line . thi function meant us dure http request header pars . do attempt read request bodi us . throw ioexcept except occur dure underli socket read oper , given buffer big enough accomod whole line . return true data properli fed ; fals data avail immedi thread should freed overrid public boolean pars request line ( boolean us avail data onli ) throw ioexcept { check state ( pars request line ) return true ; ( pars request line phase = = 0 ) { byte chr = 0 ; do { read new byte need ( po = last valid ) { ( us avail data onli ) { return fals ; } do simpl read short timeout ( read socket ( true , fals ) = = 0 ) return fals ; } chr = buf po ; } while ( ( chr = = constant . cr ) ( chr = = constant . lf ) ) ; po ; pars request line start = po ; pars request line phase = 1 ; } ( pars request line phase = = 1 ) { mark current buffer posit ( po = last valid ) { ( us avail data onli ) { return fals ; } do simpl read short timeout ( read socket ( true , fals ) = = 0 ) return fals ; } pars request line phase = 2 ; } ( pars request line phase = = 2 ) { read method name method name alwai us ascii boolean space = fals ; while ( space ) { read new byte need ( po = last valid ) { ( request line pars fill ( true , fals ) ) return fals ; } spec sai cr lf method name ( buf po = = constant . cr buf po = = constant . lf ) { throw new illeg argument except ( sm . get string ( iib . invalidmethod ) ) ; } ( buf po = = constant . sp buf po = = constant . ht ) { space = true ; request . method ( ) . set byte ( buf , pars request line start , po pars request line start ) ; } po ; } pars request line start = po ; pars request line phase = 3 ; } ( pars request line phase = = 3 ) { spec sai singl sp also toler multipl ht boolean space = true ; while ( space ) { read new byte need ( po = last valid ) { ( request line pars fill ( true , fals ) ) return fals ; } ( buf po = = constant . sp buf po = = constant . ht ) { po ; } els { space = fals ; } } mark current buffer posit int end = 0 ; while ( space ) { read new byte need ( po = last valid ) { ( request line pars fill ( true , fals ) ) return fals ; } ( buf po = = constant . sp buf po = = constant . ht ) { space = true ; end = po ; } els ( ( buf po = = constant . cr ) ( buf po = = constant . lf ) ) { http 0 . 9 style request pars request line eol = true ; space = true ; end = po ; } els ( ( buf po = = constant . question ) ( pars request line qpo = = 1 ) ) { pars request line qpo = po ; } po ; } request . unpars uri ( ) . set byte ( buf , pars request line start , end pars request line start ) ; ( pars request line qpo = 0 ) { request . queri string ( ) . set byte ( buf , pars request line qpo 1 , end pars request line qpo 1 ) ; request . request uri ( ) . set byte ( buf , pars request line start , pars request line qpo pars request line start ) ; } els { request . request uri ( ) . set byte ( buf , pars request line start , end pars request line start ) ; } pars request line start = po ; pars request line phase = 4 ; } ( pars request line phase = = 4 ) { spec sai singl sp also toler multipl ht boolean space = true ; while ( space ) { read new byte need ( po = last valid ) { ( request line pars fill ( true , fals ) ) return fals ; } ( buf po = = constant . sp buf po = = constant . ht ) { po ; } els { space = fals ; } } mark current buffer posit end = 0 ; while ( pars request line eol ) { read new byte need ( po = last valid ) { ( requ line pars fill ( true , fals ) ) return fals ; } ( buf po = = constant . cr ) { end = po ; } els ( buf po = = constant . lf ) { ( end = = 0 ) end = po ; pars request line eol = true ; } po ; } ( ( end pars request line start ) 0 ) { request . protocol ( ) . set byte ( buf , pars request line start , end pars request line start ) ; } els { request . protocol ( ) . set string ( ) ; } pars request line = fals ; pars request line phase = 0 ; pars request line eol = fals ; pars request line start = 0 ; return true ; } throw new illeg state except ( invalid request line pars phase : pars request line phase ) ; }	public read some byte . int do read ( byte chunk chunk , request req ) throw ioexcept { ( last activ filter = = 1 ) return input stream input buffer . do read ( chunk , req ) ; els return activ filter last activ filter . do read ( chunk , req ) ; }	public int do read ( byte chunk chunk , request req ) throw ioexcept { return 1 ; }	public int do read ( byte chunk chunk , request req ) throw ioexcept { ( end stream ) { return 1 ; } ( first req . get content length long ( ) 0 ) { handl special first bodi chunk ( receiv ( ) ) { return 0 ; } } els ( empti ) { ( refil read buffer ( ) ) { return 1 ; } } byte chunk bc = bodi byte . get byte chunk ( ) ; chunk . set byte ( bc . get buffer ( ) , bc . get start ( ) , bc . get length ( ) ) ; empti = true ; return chunk . get length ( ) ; }	public int do read ( byte chunk chunk , request req ) throw ioexcept { ( end stream ) { return 1 ; } ( first req . get content length long ( ) 0 ) { handl special first bodi chunk ( receiv ( ) ) { return 0 ; } } els ( empti ) { ( refil read buffer ( ) ) { return 1 ; } } byte chunk bc = bodi byte . get byte chunk ( ) ; chunk . set byte ( bc . get buffer ( ) , bc . get start ( ) , bc . get length ( ) ) ; empti = true ; return chunk . get length ( ) ; }	public write content byte chunk . param chunk byte chunk return number byte written throw ioexcept und i o error occur int do write ( byte chunk chunk , respons re ) throw ioexcept { ( commit ) { send connector request commit . connector should valid header , send them ( us send header ) set filter accordingli . respons . action ( action code . action commit , null ) ; } ( last activ filter = = 1 ) return output stream output buffer . do write ( chunk , re ) ; els return activ filter last activ filter . do write ( chunk , re ) ; }	protect callback write data from buffer . void flush buffer ( ) throw ioexcept { ( bbuf . posit ( ) 0 ) { ( socket . sendbb ( socket , 0 , bbuf . posit ( ) ) 0 ) { throw new ioexcept ( ) ; } bbuf . clear ( ) ; } }	public send action connector . param action code type action param param action paramet void action ( action code action code , object param ) { ( action code = = action code . action commit ) { commit current respons ( respons . commit ( ) ) return ; valid write respons header prepar respons ( ) ; try { output buffer . commit ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . action ack ) { yet , client specifi expect 100 continu ) ( ( respons . commit ( ) ) expect ) return ; input buffer . set swallow input ( true ) ; try { output buffer . send ack ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . action client flush ) { try { output buffer . flush ( ) ; } catch ( ioexcept e ) { set error flag error = true ; respons . set error except ( e ) ; } } els ( action code = = action code . action close ) { close end process current request , stop ani further transact client comet = fals ; try { output buffer . end request ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . action reset ) { reset respons note : thi must call befor respons commit output buffer . reset ( ) ; } els ( action code = = action code . action custom ) { do noth } els ( action code = = action code . action req host addr attribut ) { get remot host address ( remot addr = = null ( socket = 0 ) ) { try { long sa = address . get ( socket . apr remot , socket ) ; remot addr = address . getip ( sa ) ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . remot addr ( ) . set string ( remot addr ) ; } els ( action code = = action code . action req local name attribut ) { get local host name ( local name = = null ( socket = 0 ) ) { try { long sa = address . get ( socket . apr local , socket ) ; local name = address . getnameinfo ( sa , 0 ) ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . local name ( ) . set string ( local name ) ; } els ( action code = = action code . action req host attribut ) { get remot host name ( remot host = = null ( socket = 0 ) ) { try { long sa = address . get ( socket . apr remot , socket ) ; remot host = address . getnameinfo ( sa , 0 ) ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . remot host ( ) . set string ( remot host ) ; } els ( action code = = action code . action req local addr attribut ) { get local host address ( local addr = = null ( socket = 0 ) ) { try { long sa = address . get ( socket . apr local , socket ) ; local addr = address . getip ( sa ) ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . local addr ( ) . set string ( local addr ) ; } els ( action code = = action code . action req remoteport attribut ) { get remot port ( remot port = = 1 ( socket = 0 ) ) { try { long sa = address . get ( socket . apr remot , socket ) ; sockaddr addr = address . get info ( sa ) ; remot port = addr . port ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . set remot port ( remot port ) ; } els ( action code = = action code . action req localport attribut ) { get local port ( local port = = 1 ( socket = 0 ) ) { try { long sa = address . get ( socket . apr local , socket ) ; sockaddr addr = address . get info ( sa ) ; local port = addr . port ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . set local port ( local port ) ; } els ( action code = = action code . action req ssl attribut ) { ( ssl ( socket = 0 ) ) { try { cipher suit object ssl o = sslsocket . get info s ( socket , ssl . ssl info cipher ) ; ( ssl o = null ) { request . set attribut ( apr endpoint . cipher suit kei , ssl o ) ; } get client certif certif chain present cert length = = 1 indic error int cert length = sslsocket . get info i ( socket , ssl . ssl info client cert chain ) ; byte client cert = sslsocket . get info b ( socket , ssl . ssl info client cert ) ; x509certif cert = null ; ( client cert = null cert length 1 ) { cert = new x509certif cert length 1 ; certif factori cf = certif factori . get instanc ( x . 509 ) ; cert 0 = ( x509certif ) cf . gener certif ( new byte arrai input stream ( client cert ) ) ; ( int i = 0 ; i cert length ; i ) { byte data = sslsocket . get info b ( socket , ssl . ssl info client cert chain i ) ; cert i 1 = ( x509certif ) cf . gener certif ( new byte arrai input stream ( data ) ) ; } } ( cert = null ) { request . set attribut ( apr endpoint . certif kei , cert ) ; } user kei size ssl o = new integ ( sslsocket . get info i ( socket , ssl . ssl info cipher usekeys ) ) ; request . set attribut ( apr endpoint . kei size kei , ssl o ) ; ssl session id ssl o = sslsocket . get info s ( socket , ssl . ssl info session id ) ; ( ssl o = null ) { request . set attribut ( apr endpoint . session id kei , ssl o ) ; } todo provid hook enabl ssl session invalid . set apr endpoint . session mgr req attr } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . ssl ) , e ) ; } } } els ( action code = = action code . action req ssl certif ) { ( ssl ( socket = 0 ) ) { consum buffer request bodi , so doe interfer client s handshak messag input filter input filter = input buffer . get filter ( ) ; ( ( buffer input filter ) input filter constant . buffer filter ) . set limit ( max save post size ) ; input buffer . add activ filter ( input filter constant . buffer filter ) ; try { configur connect requir certif sslsocket . set verifi ( socket , ssl . ssl cverifi requir , endpoint . get sslverifi depth ( ) ) ; renegoti certif ( sslsocket . renegoti ( socket ) = = 0 ) { don t look cert unless we know renegoti work . get client certif certif chain present cert length = = 1 indic error int cert length = sslsocket . get info i ( socket , ssl . ssl info client cert chain ) ; byte client cert = sslsocket . get info b ( socket , ssl . ssl info client cert ) ; x509certif cert = null ; ( client cert = null cert length 1 ) { cert = new x509certif cert length 1 ; certif factori cf = certif factori . get instanc ( x . 509 ) ; cert 0 = ( x509certif ) cf . gener certif ( new byte arrai input stream ( client cert ) ) ; ( int i = 0 ; i cert length ; i ) { byte data = sslsocket . get info b ( socket , ssl . ssl info client cert chain i ) ; cert i 1 = ( x509certif ) cf . gener certif ( new byte arrai input stream ( data ) ) ; } } ( cert = null ) { request . set attribut ( apr endpoint . certif kei , cert ) ; } } } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . ssl ) , e ) ; } } } els ( action code = = action code . action req set bodi replai ) { byte chunk bodi = ( byte chunk ) param ; input filter save bodi = new save request input filter ( bodi ) ; save bodi . set request ( request ) ; intern apr input buffer intern buffer = ( intern apr input buffer ) request . get input buffer ( ) ; intern buffer . add activ filter ( save bodi ) ; } els ( action code = = action code . action avail ) { request . set avail ( input buffer . avail ( ) ) ; } els ( action code = = action code . action comet begin ) { comet = true ; } els ( action code = = action code . action comet end ) { comet = fals ; } els ( action code = = action code . action comet close ) { op } els ( action code = = action code . action comet settimeout ) { op } els ( action code = = action code . action async start ) { todo servlet3 async } els ( action code = = action code . action async complet ) { todo servlet3 async } els ( action code = = action code . action async settimeout ) { todo servlet3 async } }	public send action connector . param action code type action param param action paramet void action ( action code action code , object param ) { ( action code = = action code . action commit ) { commit current respons ( respons . commit ( ) ) return ; valid write respons header try { prepar respons ( ) ; output buffer . commit ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . action ack ) { yet , client specifi expect 100 continu ) ( ( respons . commit ( ) ) expect ) return ; input buffer . set swallow input ( true ) ; try { output buffer . send ack ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . action client flush ) { try { output buffer . flush ( ) ; } catch ( ioexcept e ) { set error flag error = true ; respons . set error except ( e ) ; } } els ( action code = = action code . action close ) { close end process current request , stop ani further transact client comet = fals ; comet close = true ; async = fals ; select kei kei = socket . get iochannel ( ) . kei ( socket . get poller ( ) . get selector ( ) ) ; ( kei = null ) { nio endpoint . kei attach attach = ( nio endpoint . kei attach ) kei . attach ( ) ; ( attach = null attach . get comet ( ) ) { thi comet connect execut connect closur next selector loop request . get attribut ( ) . remov ( org . apach . tomcat . comet . timeout ) ; attach . set timeout ( 5000 ) ; forc cleanup 5 second attach . set error ( true ) ; thi ha caus concurr error } } try { output buffer . end request ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . action reset ) { reset respons note : thi must call befor respons commit output buffer . reset ( ) ; } els ( action code = = action code . action custom ) { do noth } els ( action code = = action code . action req host addr attribut ) { get remot host address ( ( remot addr = = null ) ( socket = null ) ) { inet address inet addr = socket . get iochannel ( ) . socket ( ) . get inet address ( ) ; ( inet addr = null ) { remot addr = inet addr . get host address ( ) ; } } request . remot addr ( ) . set string ( remot addr ) ; } els ( action code = = action code . action req local name attribut ) { get local host name ( ( local name = = null ) ( socket = null ) ) { inet address inet addr = socket . get iochannel ( ) . socket ( ) . get local address ( ) ; ( inet addr = null ) { local name = inet addr . get host name ( ) ; } } request . local name ( ) . set string ( local name ) ; } els ( action code = = action code . action req host attribut ) { get remot host name ( ( remot host = = null ) ( socket = null ) ) { inet address inet addr = socket . get iochannel ( ) . socket ( ) . get inet address ( ) ; ( inet addr = null ) { remot host = inet addr . get host name ( ) ; } ( remot host = = null ) { ( remot addr = null ) { remot host = remot addr ; } els { all we can do punt request . remot host ( ) . recycl ( ) ; } } } request . remot host ( ) . set string ( remot host ) ; } els ( action code = = action code . action req local addr attribut ) { ( local addr = = null ) local addr = socket . get iochannel ( ) . socket ( ) . get local address ( ) . get host address ( ) ; request . local addr ( ) . set string ( local addr ) ; } els ( action code = = action code . action req remoteport attribut ) { ( ( remot port = = 1 ) ( socket = null ) ) { remot port = socket . get iochannel ( ) . socket ( ) . get port ( ) ; } request . set remot port ( remot port ) ; } els ( action code = = action code . action req localport attribut ) { ( ( local port = = 1 ) ( socket = null ) ) { local port = socket . get iochannel ( ) . socket ( ) . get local port ( ) ; } request . set local port ( local port ) ; } els ( action code = = action code . action req ssl attribut ) { try { ( ssl support = null ) { object ssl o = ssl support . get cipher suit ( ) ; ( ssl o = null ) request . set attribut ( sslsupport . cipher suit kei , ssl o ) ; ssl o = ssl support . get peer certif chain ( fals ) ; ( ssl o = null ) request . set attribut ( sslsupport . certif kei , ssl o ) ; ssl o = ssl support . get kei size ( ) ; ( ssl o = null ) request . set attribut ( sslsupport . kei size kei , ssl o ) ; ssl o = ssl support . get session id ( ) ; ( ssl o = null ) request . set attribut ( sslsupport . session id kei , ssl o ) ; request . set attribut ( sslsupport . session mgr , ssl support ) ; } } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . ssl ) , e ) ; } } els ( action code = = action code . action req ssl certif ) { ( ssl support = null ) { consum buffer request bodi , so doe interfer client s handshak messag input filter input filter = input buffer . get filter ( ) ; ( ( buffer input filter ) input filter constant . buffer filter ) . set limit ( max save post size ) ; input buffer . add activ filter ( input filter constant . buffer filter ) ; try { object ssl o = ssl support . get peer certif chain ( true ) ; ( ssl o = null ) { request . set attribut ( sslsupport . certif kei , ssl o ) ; } } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . ssl ) , e ) ; } } } els ( action code = = action code . action req set bodi replai ) { byte chunk bodi = ( byte chunk ) param ; input filter save bodi = new save request input filter ( bodi ) ; save bodi . set request ( request ) ; intern nio input buffer intern buffer = ( intern nio input buffer ) request . get input buffer ( ) ; intern buffer . add activ filter ( save bodi ) ; } els ( action code = = action code . action avail ) { request . set avail ( input buffer . avail ( ) ) ; } els ( action code = = action code . action comet begin ) { comet = true ; } els ( action code = = action code . action comet end ) { comet = fals ; } els ( action code = = action code . action comet close ) { ( socket = = null socket . get attach ( fals ) = = null ) return ; nio endpoint . kei attach attach = ( nio endpoint . kei attach ) socket . get attach ( fals ) ; attach . set comet op ( nio endpoint . op callback ) ; notifi poller tomcat thread request info rp = request . get request processor ( ) ; ( async handl rp . get stage ( ) = org . apach . coyot . constant . stage servic ) socket . get poller ( ) . comet interest ( socket ) ; } els ( action code = = action code . action comet settimeout ) { ( param = = null ) return ; ( socket = = null socket . get attach ( fals ) = = null ) return ; nio endpoint . kei attach attach = ( nio endpoint . kei attach ) socket . get attach ( fals ) ; long timeout = ( ( long ) param ) . long valu ( ) ; we ar piggi back worker thread , set timeout request info rp = request . get request processor ( ) ; ( async handl rp . get stage ( ) = org . apach . coyot . constant . stage servic ) attach . set timeout ( timeout ) ; } els ( action code = = action code . action async start ) { todo servlet3 async async = true ; } els ( action code = = action code . action async complet ) { todo servlet3 async atom boolean dispatch = ( atom boolean ) param ; request info rp = request . get request processor ( ) ; ( rp . get stage ( ) = org . apach . coyot . constant . stage servic ) { async handl dispatch . set ( true ) ; endpoint . process socket ( thi . socket , socket statu . stop , true ) ; } } els ( action code = = action code . action async settimeout ) { todo servlet3 async ( param = = null ) return ; ( socket = = null socket . get attach ( fals ) = = null ) return ; nio endpoint . kei attach attach = ( nio endpoint . kei attach ) socket . get attach ( fals ) ; long timeout = ( ( long ) param ) . long valu ( ) ; we ar piggi back worker thread , set timeout attach . set timeout ( timeout ) ; } els ( action code = = action code . action async dispatch ) { request info rp = request . get request processor ( ) ; atom boolean dispatch = ( atom boolean ) param ; ( rp . get stage ( ) = org . apach . coyot . constant . stage servic ) { async handl endpoint . process socket ( thi . socket , socket statu . open , true ) ; dispatch . set ( true ) ; } els { } } }	send action connector . param action code type action param param action paramet void action ( action code action code , object param ) { ( action code = = action code . action commit ) { commit current respons ( respons . commit ( ) ) return ; valid write respons header prepar respons ( ) ; try { output buffer . commit ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . action ack ) { yet , client specifi expect 100 continu ) ( ( respons . commit ( ) ) expect ) return ; input buffer . set swallow input ( true ) ; try { output buffer . send ack ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . action client flush ) { try { output buffer . flush ( ) ; } catch ( ioexcept e ) { set error flag error = true ; respons . set error except ( e ) ; } } els ( action code = = action code . action close ) { transact client try { output buffer . end request ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . action reset ) { reset respons note : thi must call befor respons commit output buffer . reset ( ) ; } els ( action code = = action code . action custom ) { do noth } els ( action code = = action code . action start ) { start = true ; } els ( action code = = action code . action stop ) { start = fals ; } els ( action code = = action code . action req ssl attribut ) { try { ( ssl support = null ) { object ssl o = ssl support . get cipher suit ( ) ; ( ssl o = null ) request . set attribut ( sslsupport . cipher suit kei , ssl o ) ; ssl o = ssl support . get peer certif chain ( fals ) ; ( ssl o = null ) request . set attribut ( sslsupport . certif kei , ssl o ) ; ssl o = ssl support . get kei size ( ) ; ( ssl o = null ) request . set attribut ( sslsupport . kei size kei , ssl o ) ; ssl o = ssl support . get session id ( ) ; ( ssl o = null ) request . set attribut ( sslsupport . session id kei , ssl o ) ; request . set attribut ( sslsupport . session mgr , ssl support ) ; } } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . ssl ) , e ) ; } } els ( action code = = action code . action req host addr attribut ) { ( ( remot addr = = null ) ( socket = null ) ) { inet address inet addr = socket . get inet address ( ) ; ( inet addr = null ) { remot addr = inet addr . get host address ( ) ; } } request . remot addr ( ) . set string ( remot addr ) ; } els ( action code = = action code . action req local name attribut ) { ( ( local name = = null ) ( socket = null ) ) { inet address inet addr = socket . get local address ( ) ; ( inet addr = null ) { local name = inet addr . get host name ( ) ; } } request . local name ( ) . set string ( local name ) ; } els ( action code = = action code . action req host attribut ) { ( ( remot host = = null ) ( socket = null ) ) { inet address inet addr = socket . get inet address ( ) ; ( inet addr = null ) { remot host = inet addr . get host name ( ) ; } ( remot host = = null ) { ( remot addr = null ) { remot host = remot addr ; } els { all we can do punt request . remot host ( ) . recycl ( ) ; } } } request . remot host ( ) . set string ( remot host ) ; } els ( action code = = action code . action req local addr attribut ) { ( local addr = = null ) local addr = socket . get local address ( ) . get host address ( ) ; request . local addr ( ) . set string ( local addr ) ; } els ( action code = = action code . action req remoteport attribut ) { ( ( remot port = = 1 ) ( socket = null ) ) { remot port = socket . get port ( ) ; } request . set remot port ( remot port ) ; } els ( action code = = action code . action req localport attribut ) { ( ( local port = = 1 ) ( socket = null ) ) { local port = socket . get local port ( ) ; } request . set local port ( local port ) ; } els ( action code = = action code . action req ssl certif ) { ( ssl support = null ) { consum buffer request bodi , so doe interfer client s handshak messag input filter input filter = input buffer . get filter ( ) ; ( ( buffer input filter ) input filter constant . buffer filter ) . set limit ( max save post size ) ; input buffer . add activ filter ( input filter constant . buffer filter ) ; try { object ssl o = ssl support . get peer certif chain ( true ) ; ( ssl o = null ) { request . set attribut ( sslsupport . certif kei , ssl o ) ; } } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . ssl ) , e ) ; } } } els ( action code = = action code . action req set bodi replai ) { byte chunk bodi = ( byte chunk ) param ; input filter save bodi = new save request input filter ( bodi ) ; save bodi . set request ( request ) ; intern input buffer intern buffer = ( intern input buffer ) request . get input buffer ( ) ; intern buffer . add activ filter ( save bodi ) ; } els ( action code = = action code . action async start ) { todo servlet3 async } els ( action code = = action code . action async complet ) { todo servlet3 async } els ( action code = = action code . action async settimeout ) { todo servlet3 async } }	public add output filter filter librari . void add activ filter ( output filter filter ) { ( last activ filter = = 1 ) { filter . set buffer ( output stream output buffer ) ; } els { ( int i = 0 ; i = last activ filter ; i ) { ( activ filter i = = filter ) return ; } filter . set buffer ( activ filter last activ filter ) ; } activ filter last activ filter = filter ; filter . set respons ( respons ) ; }	public add output filter filter librari . void add activ filter ( output filter filter ) { ( last activ filter = = 1 ) { filter . set buffer ( output stream output buffer ) ; } els { ( int i = 0 ; i = last activ filter ; i ) { ( activ filter i = = filter ) return ; } filter . set buffer ( activ filter last activ filter ) ; } activ filter last activ filter = filter ; filter . set respons ( respons ) ; }	public add mime type which compress mime type string exactli match respons mime type header . param mime type mime type string void add compress mime type ( string mime type ) { compress mime type = add string arrai ( compress mime type , mime type ) ; }	public add mime type which compress mime type string exactli match respons mime type header . param mime type mime type string void add compress mime type ( string mime type ) { compress mime type = add string arrai ( compress mime type , mime type ) ; }	public end header block . void end header ( ) { buf po = constant . cr ; buf po = constant . lf ; }	public end header block . void end header ( ) { buf po = constant . cr ; buf po = constant . lf ; }	public end request ( consum leftov byte ) . throw ioexcept und i o error occur void end request ( ) throw ioexcept { ( swallow input ( last activ filter = 1 ) ) { int extra byte = ( int ) activ filter last activ filter . end ( ) ; po = po extra byte ; } }	public end request . throw ioexcept und i o error occur void end request ( ) throw ioexcept { ( commit ) { send connector request commit . connector should valid header , send them ( us send header ) set filter accordingli . respons . action ( action code . action commit , null ) ; } ( finish ) return ; ( last activ filter = 1 ) activ filter last activ filter . end ( ) ; flush buffer ( ) ; finish = true ; }	end request . throw ioexcept underli i o error occur overrid public void end request ( ) throw ioexcept { super . end request ( ) ; ( us socket buffer ) { socket buffer . flush buffer ( ) ; } }	public end process current http request . note : all byte current request should have been alreadi consum . thi method onli reset all pointer so we ar readi pars next http request . void next request ( ) { recycl request object request . recycl ( ) ; copi leftov byte begin buffer ( last valid po 0 ) { int npo = 0 ; int opo = po ; while ( last valid opo opo npo ) { system . arraycopi ( buf , opo , buf , npo , opo npo ) ; npo = po ; opo = po ; } system . arraycopi ( buf , opo , buf , npo , last valid opo ) ; } recycl filter ( int i = 0 ; i = last activ filter ; i ) { activ filter i . recycl ( ) ; } reset pointer last valid = last valid po ; po = 0 ; last activ filter = 1 ; pars header = true ; swallow input = true ; }	public end process current http request . note : all byte current request should have been alreadi consum . thi method onli reset all pointer so we ar readi pars next http request . void next request ( ) { recycl request object respons . recycl ( ) ; recycl filter ( int i = 0 ; i = last activ filter ; i ) { activ filter i . recycl ( ) ; } reset pointer po = 0 ; last activ filter = 1 ; commit = fals ; finish = fals ; }	public end process current http request . note : all byte current request should have been alreadi consum . thi method onli reset all pointer so we ar readi pars next http request . void next request ( ) { recycl request object request . recycl ( ) ; copi leftov byte begin buffer ( last valid po 0 ) { int npo = 0 ; int opo = po ; while ( last valid opo opo npo ) { system . arraycopi ( buf , opo , buf , npo , opo npo ) ; npo = po ; opo = po ; } system . arraycopi ( buf , opo , buf , npo , last valid opo ) ; } recycl filter ( int i = 0 ; i = last activ filter ; i ) { activ filter i . recycl ( ) ; } reset pointer last valid = last valid po ; po = 0 ; last activ filter = 1 ; pars header = true ; swallow input = true ; }	public end process current http request . note : all byte current request should have been alreadi consum . thi method onli reset all pointer so we ar readi pars next http request . void next request ( ) { recycl request object respons . recycl ( ) ; recycl filter ( int i = 0 ; i = last activ filter ; i ) { activ filter i . recycl ( ) ; } reset pointer po = 0 ; last activ filter = 1 ; commit = fals ; finish = fals ; }	end process current http request . note : all byte current request should have been alreadi consum . thi method onli reset all pointer so we ar readi pars next http request . overrid public void next request ( ) { super . next request ( ) ; pars header = true ; header pars po = header pars posit . header start ; pars request line = true ; pars request line phase = 0 ; pars request line eol = fals ; pars request line start = 0 ; pars request line qpo = 1 ; header data . recycl ( ) ; }	public pars host . void pars host ( messag byte valu mb ) { ( valu mb = = null valu mb . null ( ) ) { http 1 . 0 default what socket tell us . overriden host found pars request . set server port ( endpoint . get port ( ) ) ; return ; } byte chunk valu bc = valu mb . get byte chunk ( ) ; byte valu b = valu bc . get byte ( ) ; int valu l = valu bc . get length ( ) ; int valu s = valu bc . get start ( ) ; int colon po = 1 ; ( host name c . length valu l ) { host name c = new char valu l ; } boolean ipv6 = ( valu b valu s = = ) ; boolean bracket close = fals ; ( int i = 0 ; i valu l ; i ) { char b = ( char ) valu b i valu s ; host name c i = b ; ( b = = ) { bracket close = true ; } els ( b = = : ) { ( ipv6 bracket close ) { colon po = i ; break ; } } } ( colon po 0 ) { ( ssl ) { 80 default http port request . set server port ( 80 ) ; } els { 443 default http port request . set server port ( 443 ) ; } request . server name ( ) . set char ( host name c , 0 , valu l ) ; } els { request . server name ( ) . set char ( host name c , 0 , colon po ) ; int port = 0 ; int mult = 1 ; ( int i = valu l 1 ; i colon po ; i ) { int char valu = hex util . dec valu b i valu s ; ( char valu = = 1 ) { invalid charact error = true ; 400 bad request respons . set statu ( 400 ) ; break ; } port = port ( char valu mult ) ; mult = 10 mult ; } request . set server port ( port ) ; } }	public pars host . void pars host ( messag byte valu mb ) { ( valu mb = = null valu mb . null ( ) ) { http 1 . 0 default what socket tell us . overriden host found pars request . set server port ( endpoint . get port ( ) ) ; return ; } byte chunk valu bc = valu mb . get byte chunk ( ) ; byte valu b = valu bc . get byte ( ) ; int valu l = valu bc . get length ( ) ; int valu s = valu bc . get start ( ) ; int colon po = 1 ; ( host name c . length valu l ) { host name c = new char valu l ; } boolean ipv6 = ( valu b valu s = = ) ; boolean bracket close = fals ; ( int i = 0 ; i valu l ; i ) { char b = ( char ) valu b i valu s ; host name c i = b ; ( b = = ) { bracket close = true ; } els ( b = = : ) { ( ipv6 bracket close ) { colon po = i ; break ; } } } ( colon po 0 ) { ( ssl ) { 80 default http port request . set server port ( 80 ) ; } els { 443 default http port request . set server port ( 443 ) ; } request . server name ( ) . set char ( host name c , 0 , valu l ) ; } els { request . server name ( ) . set char ( host name c , 0 , colon po ) ; int port = 0 ; int mult = 1 ; ( int i = valu l 1 ; i colon po ; i ) { int char valu = hex util . dec valu b i valu s ; ( char valu = = 1 ) { invalid charact error = true ; 400 bad request respons . set statu ( 400 ) ; break ; } port = port ( char valu mult ) ; mult = 10 mult ; } request . set server port ( port ) ; } }	recycl output buffer . thi should call when close connect . overrid public void recycl ( ) { super . recycl ( ) ; socket . get buf handler ( ) . get write buffer ( ) . clear ( ) ; socket = null ; last write . set ( 1 ) ; }	send acknoledg . overrid public void send ack ( ) throw ioexcept { ( commit ) output stream . write ( constant . ack byte ) ; }	public set compress mime type list ( thi method best when us larg number connector , where would better have all them referenc singl arrai ) . void set compress mime type ( string compress mime type ) { thi . compress mime type = compress mime type ; }	public void set global processor ( request group info global ) { ( global = null ) { thi . global = global ; global . add request processor ( thi ) ; } els { ( thi . global = null ) { thi . global . remov request processor ( thi ) ; thi . global = null ; } } }	public set compress user agent list . list contain user agent separ , : ie : gorilla , desesplor , tigru void set compress user agent ( string compress user agent ) { ( compress user agent = null ) { string token st = new string token ( compress user agent , , ) ; while ( st . ha more token ( ) ) { add compress user agent ( st . next token ( ) . trim ( ) ) ; } } }	public set compress user agent list . list contain user agent separ , : ie : gorilla , desesplor , tigru void set compress user agent ( string compress user agent ) { ( compress user agent = null ) { string token st = new string token ( compress user agent , , ) ; while ( st . ha more token ( ) ) { add compress user agent ( st . next token ( ) . trim ( ) ) ; } } }	public thi method write content specyfi byte buffer output stream , without filter . thi method meant us write respons header . param b data written void write ( byte b ) { write byte chunk output buffer system . arraycopi ( b , 0 , buf , po , b . length ) ; po = po b . length ; }	public thi method write content specyfi byte buffer output stream , without filter . thi method meant us write respons header . param b data written void write ( byte b ) { write byte chunk output buffer system . arraycopi ( b , 0 , buf , po , b . length ) ; po = po b . length ; }
final load chunk text . param offset offset charact buffer read next batch charact . param chang entiti true load should chang entiti end entiti , otherwis leav current entiti place entiti boundari signal return valu . return return true entiti chang result thi load oper . boolean load ( int offset , boolean chang entiti ) throw ioexcept { read charact int length = f current entiti . mai read chunk ( f current entiti . ch . length offset ) : ( default xmldecl buffer size ) ; int count = f current entiti . reader . read ( f current entiti . ch , offset , length ) ; reset count posit boolean entiti chang = fals ; ( count = 1 ) { ( count = 0 ) { f current entiti . count = count offset ; f current entiti . posit = offset ; } } els end thi entiti { f current entiti . count = offset ; f current entiti . posit = offset ; entiti chang = true ; ( chang entiti ) { end entiti ( ) ; ( f current entiti = = null ) { throw new eofexcept ( ) ; } handl trail edg ( f current entiti . posit = = f current entiti . count ) { load ( 0 , fals ) ; } } } return entiti chang ; }	privat string get express factori var ( ) { return var expressionfactori ; }	privat tag info creat tag info ( tree node elem , string jsp version ) throw jasper except { string tag name = null ; string tag class name = null ; string tei class name = null ; default bodi content jsp 1 . 2 tag handler ( bodi content ha becom mandatori jsp 2 . 0 , becaus default would invalid simpl tag handler ) string bodycont = jsp ; string info = null ; string displai name = null ; string small icon = null ; string larg icon = null ; boolean dynam attribut = fals ; vector tag attribut info attribut vector = new vector tag attribut info ( ) ; vector tag variabl info variabl vector = new vector tag variabl info ( ) ; iter tree node list = elem . find children ( ) ; while ( list . ha next ( ) ) { tree node element = list . next ( ) ; string tname = element . get name ( ) ; ( name . equal ( tname ) ) { tag name = element . get bodi ( ) ; } els ( tagclass . equal ( tname ) tag class . equal ( tname ) ) { tag class name = element . get bodi ( ) ; } els ( teiclass . equal ( tname ) tei class . equal ( tname ) ) { tei class name = element . get bodi ( ) ; } els ( bodycont . equal ( tname ) bodi content . equal ( tname ) ) { bodycont = element . get bodi ( ) ; } els ( displai name . equal ( tname ) ) { displai name = element . get bodi ( ) ; } els ( small icon . equal ( tname ) ) { small icon = element . get bodi ( ) ; } els ( larg icon . equal ( tname ) ) { larg icon = element . get bodi ( ) ; } els ( icon . equal ( tname ) ) { tree node icon = element . find child ( small icon ) ; ( icon = null ) { small icon = icon . get bodi ( ) ; } icon = element . find child ( larg icon ) ; ( icon = null ) { larg icon = icon . get bodi ( ) ; } } els ( info . equal ( tname ) descript . equal ( tname ) ) { info = element . get bodi ( ) ; } els ( variabl . equal ( tname ) ) { variabl vector . add element ( creat variabl ( element ) ) ; } els ( attribut . equal ( tname ) ) { attribut vector . add element ( creat attribut ( element , jsp version ) ) ; } els ( dynam attribut . equal ( tname ) ) { dynam attribut = jsp util . boolean valu ( element . get bodi ( ) ) ; } els ( exampl . equal ( tname ) ) { ignor element } els ( tag extens . equal ( tname ) ) { ignor } els { ( log . warn enabl ( ) ) { log . warn ( local . get messag ( jsp . warn . unknown . element . . tag , tname ) ) ; } } } tag extra info tei = null ; ( tei class name = null tei class name . equal ( ) ) { try { class tei class = ctxt . get class loader ( ) . load class ( tei class name ) ; tei = ( tag extra info ) tei class . new instanc ( ) ; } catch ( except e ) { err . jsp error ( jsp . error . teiclass . instanti , tei class name , e ) ; } } tag attribut info tag attribut info = new tag attribut info attribut vector . size ( ) ; attribut vector . copi ( tag attribut info ) ; tag variabl info tag variabl info = new tag variabl info variabl vector . size ( ) ; variabl vector . copi ( tag variabl info ) ; tag info taginfo = new tag info ( tag name , tag class name , bodycont , info , thi , tei , tag attribut info , displai name , small icon , larg icon , tag variabl info , dynam attribut ) ; return taginfo ; }	privat pop file from file stack . field current retor valu point previou file , ani , set null otherwis . return true previou file stack . fals otherwis . boolean pop file ( ) throw jasper except { miss . ( current = = null curr file id 0 ) { return fals ; } restor parser state : string f name = get file ( curr file id ) ; curr file id = unregist sourc file ( f name ) ; ( curr file id 1 ) { err . jsp error ( jsp . error . file . . regist , f name ) ; } mark previou = current . pop stream ( ) ; ( previou = null ) { master = current . base dir ; current = previou ; return true ; } set current ( undefin ) posit . return fals ; }	privat regist new sourc file . thi method us implement file inclus . each includ file get uniqu identifi ( which index arrai sourc file ) . return index now regist file . int regist sourc file ( final string file ) { ( sourc file . contain ( file ) ) { return 1 ; } sourc file . add ( file ) ; thi . size ; return sourc file . size ( ) 1 ; }	privat add thi node bodi given parent . void add parent ( node parent ) { ( parent = null ) { thi . parent = parent ; node parent bodi = parent . get bodi ( ) ; ( parent bodi = = null ) { parent bodi = new node ( ) ; parent . set bodi ( parent bodi ) ; } parent bodi . add ( thi ) ; } }	privat void check uniqu name ( string name , string type , node n , tag attribut info attr ) throw jasper except { hash map string , name entri tabl = ( type = = var name from ) name from tabl : name tabl ; name entri name entri = tabl . get ( name ) ; ( name entri = null ) { ( type = tag dynam name entri . get type ( ) = tag dynam ) { int line = name entri . get node ( ) . get start ( ) . get line number ( ) ; err . jsp error ( n , jsp . error . tagfil . name uniqu , type , name entri . get type ( ) , integ . string ( line ) ) ; } } els { tabl . put ( name , new name entri ( type , n , attr ) ) ; } }	privat make sure given custom action doe have ani invalid attribut . custom action declar attribut alwai belong same namespac , which identifi prefix name custom tag invoc . exampl , thi invoc : my : test = 1 b = 2 c = 3 , action test attribut , b , c all belong namespac identifi prefix my . abov invoc would equival : my : test my : = 1 my : b = 2 my : c = 3 action attribut mai have prefix differ from action invoc onli underli tag handler support dynam attribut , which case attribut differ prefix consid dynam attribut . void check xml attribut ( node . custom tag n , node . jsp attribut jsp attr , hashtabl string , object tag data attr ) throw jasper except { tag info tag info = n . get tag info ( ) ; ( tag info = = null ) { err . jsp error ( n , jsp . error . miss . tag info , n . get qname ( ) ) ; } tag attribut info tld attr = tag info . get attribut ( ) ; attribut attr = n . get attribut ( ) ; boolean check defer = page info . defer syntax allow liter ( ) ( tag info . get tag librari ( ) . get requir version ( ) . equal ( 2 . 0 ) tag info . get tag librari ( ) . get requir version ( ) . equal ( 1 . 2 ) ) ; ( int i = 0 ; attr = null i attr . get length ( ) ; i ) { boolean found = fals ; boolean runtim express = ( ( n . get root ( ) . xml syntax ( ) attr . get valu ( i ) . start ( = ) ) ( n . get root ( ) . xml syntax ( ) attr . get valu ( i ) . start ( = ) ) ) ; boolean el express = fals ; boolean defer = fals ; boolean defer valu liter = fals ; elnod . node el = null ; ( runtim express ) { el = elpars . pars ( attr . get valu ( i ) ) ; iter elnod node = el . iter ( ) ; while ( node . ha next ( ) ) { elnod node = node . next ( ) ; ( node instanceof elnod . root ) { ( ( ( elnod . root ) node ) . get type ( ) = = ) { el express = true ; } els ( check defer ( ( elnod . root ) node ) . get type ( ) = = ) { el express = true ; defer = true ; ( page info . elignor ( ) ) { defer valu liter = true ; } } } } } boolean express = runtim express ( el express ( page info . elignor ( ) ( true . equal ignor case ( page info . get elignor ( ) ) check defer defer ) ) ) ; ( int j = 0 ; tld attr = null j tld attr . length ; j ) { ( attr . get local name ( i ) . equal ( tld attr j . get name ( ) ) ( attr . get uri ( i ) = = null attr . get uri ( i ) . length ( ) = = 0 attr . get uri ( i ) . equal ( n . get uri ( ) ) ) ) { ( tld attr j . can request time ( ) tld attr j . defer method ( ) tld attr j . defer valu ( ) ) { jsp 2 . 1 ( express ) { ( defer valu liter page info . defer syntax allow liter ( ) ) { err . jsp error ( n , jsp . error . attribut . custom . non rt expr , tld attr j . get name ( ) ) ; } string expect type = null ; ( tld attr j . defer method ( ) ) { string liter must castabl what declar type attribut string m = tld attr j . get method signatur ( ) ; ( m = null ) { int rti = m . trim ( ) . index ( ) ; ( rti 0 ) { expect type = m . substr ( 0 , rti ) . trim ( ) ; } } els { expect type = java . lang . object ; } } ( tld attr j . defer valu ( ) ) { string litter must castabl what declar type attribut expect type = tld attr j . get expect type name ( ) ; } ( expect type = null ) { class expect class = string . class ; try { expect class = jsp util . class ( expect type , loader ) ; } catch ( class found except e ) { err . jsp error ( n , jsp . error . unknown attribut type , tld attr j . get name ( ) , expect type ) ; } check cast try { elsupport . check type ( attr . get valu ( i ) , expect class ) ; } catch ( except e ) { err . jsp error ( n , jsp . error . coerc type , tld attr j . get name ( ) , expect type , attr . get valu ( i ) ) ; } } jsp attr i = new node . jsp attribut ( tld attr j , attr . get qname ( i ) , attr . get uri ( i ) , attr . get local name ( i ) , attr . get valu ( i ) , fals , null , fals ) ; } els { ( defer tld attr j . defer method ( ) tld attr j . defer valu ( ) ) { defer express allow thi attribut err . jsp error ( n , jsp . error . attribut . custom . non rt expr , tld attr j . get name ( ) ) ; } ( defer tld attr j . can request time ( ) ) { onli defer express ar allow thi attribut err . jsp error ( n , jsp . error . attribut . custom . non rt expr , tld attr j . get name ( ) ) ; } ( el express ) { el express valid function ( el , n ) ; jsp attr i = new node . jsp attribut ( tld attr j , attr . get qname ( i ) , attr . get uri ( i ) , attr . get local name ( i ) , attr . get valu ( i ) , fals , el , fals ) ; elcontext impl ctx = new elcontext impl ( ) ; ctx . set function mapper ( get function mapper ( el ) ) ; try { jsp attr i . valid el ( thi . page info . get express factori ( ) , ctx ) ; } catch ( elexcept e ) { thi . err . jsp error ( n . get start ( ) , jsp . error . invalid . express , attr . get valu ( i ) , e . string ( ) ) ; } } els { runtim express jsp attr i = get jsp attribut ( tld attr j , attr . get qname ( i ) , attr . get uri ( i ) , attr . get local name ( i ) , attr . get valu ( i ) , n , fals ) ; } } } els { make sure valu doe contain ani . ( express ) { err . jsp error ( n , jsp . error . attribut . custom . non rt expr , tld attr j . get name ( ) ) ; } jsp attr i = new node . jsp attribut ( tld attr j , attr . get qname ( i ) , attr . get uri ( i ) , attr . get local name ( i ) , attr . get valu ( i ) , fals , null , fals ) ; } ( express ) { tag data attr . put ( attr . get qname ( i ) , tag data . request time valu ) ; } els { tag data attr . put ( attr . get qname ( i ) , attr . get valu ( i ) ) ; } found = true ; break ; } } ( found ) { ( tag info . ha dynam attribut ( ) ) { jsp attr i = get jsp attribut ( null , attr . get qname ( i ) , attr . get uri ( i ) , attr . get local name ( i ) , attr . get valu ( i ) , n , true ) ; } els { err . jsp error ( n , jsp . error . bad attribut , attr . get qname ( i ) , n . get local name ( ) ) ; } } } }	privat gener preambl import ( share servlet tag handler preambl gener ) void gen preambl import ( ) { iter string iter = page info . get import ( ) . iter ( ) ; while ( iter . ha next ( ) ) { out . printin ( import ) ; out . print ( iter . next ( ) ) ; out . println ( ; ) ; } out . println ( ) ; }	protect find web inf dir look up directori tree . thi us explicit docbas set , onli file . xxx mayb we should requir docbas . void locat uri root ( file f ) { string t uri base = uri base ; ( t uri base = = null ) { t uri base = ; } try { ( f . exist ( ) ) { f = new file ( f . get absolut path ( ) ) ; while ( f = null ) { file g = new file ( f , web inf ) ; ( g . exist ( ) g . directori ( ) ) { uri root = f . get canon path ( ) ; uri base = t uri base ; ( log . info enabl ( ) ) { log . info ( local . get messag ( jspc . implicit . uri root , uri root ) ) ; } break ; } ( f . exist ( ) f . directori ( ) ) { t uri base = f . get name ( ) t uri base ; } string f parent = f . get parent ( ) ; ( f parent = = null ) { break ; } els { f = new file ( f parent ) ; } accept candid , uri root remain null indic compil context us current work user dir . } ( uri root = null ) { file froot = new file ( uri root ) ; uri root = froot . get canon path ( ) ; } } } catch ( ioexcept ioe ) { sinc thi option default null valu uri root ha non error mean , we can just pass straight through } }	protect static set parent child relationship between two specifi logger . param logger param parent void do set parent logger ( final logger logger , final logger parent ) { access control . do privileg ( new privileg action object ( ) { public object run ( ) { logger . set parent ( parent ) ; return null ; } } ) ; }	public get secur manag permiss collect thi web applic context . return permiss collect permiss permiss collect get permiss collect ( ) { return permiss collect ; }	public get resourc stream , rel mean thi context s implement . return null resourc cannot found repres input stream . java . io . input stream get resourc stream ( string re ) { return context . get resourc stream ( canon uri ( re ) ) ; }	public should class file compil debug inform boolean get class debug info ( ) { return class debug info ; }	public jasper us develop mode boolean get develop ( ) { return develop ; }	public jasper us develop mode boolean get develop ( ) { return fals ; }	public boolean get fail error ( ) { return fail error ; }	public return true thi templat text contain whitespac onli . boolean all space ( ) { boolean all space = true ; ( int i = 0 ; i text . length ( ) ; i ) { ( charact . whitespac ( text . char ( i ) ) ) { all space = fals ; break ; } } return all space ; }	public thi protect method intend overridden subclass compil . thi us compil method do all compil . boolean out date ( ) { return out date ( true ) ; }	public final void fatal ( object messag , throwabl t ) { log ( level . sever , string . valu ( messag ) , t ) ; }	public return number jsp which jsp servlet wrapper exist , i . e . , number jsp have been load webapp . return number jsp have been load webapp int get jsp count ( ) { return jsp . size ( ) ; }	public get number jsp have been reload . p thi info mai us monitor purpos . return number jsp ( webapp which thi jsp servlet associ ) have been reload int get jsp reload count ( ) { return thi . rctxt . get jsp reload count ( ) ; }	read charact portion arrai . thi method block until some input avail , i o error occur , end stream reach . param ch destin buffer param offset offset which start store charact param length maximum number charact read return number charact read , 1 end stream ha been reach except ioexcept i o error occur overrid public int read ( char ch , int offset , int length ) throw ioexcept { handl surrog int out = offset ; ( f surrog = 1 ) { ch offset 1 = ( char ) f surrog ; f surrog = 1 ; length ; out ; } read byte int count = 0 ; ( f offset = = 0 ) { adjust length read ( length f buffer . length ) { length = f buffer . length ; } perform read oper count = f input stream . read ( f buffer , 0 , length ) ; ( count = = 1 ) { return 1 ; } count = out offset ; } els skip read ; last charact wa error note : have offset valu other than zero mean wa error last charact read . thi case , we have skip read so we don t consum ani byte past error . signal error next block read we allow method return most valid charact can previou block read . ac { count = f offset ; f offset = 0 ; } convert byte charact final int total = count ; ( int = 0 ; total ; ) { int b0 = f buffer 0x00ff ; unicod : 0000 0000 0xxx xxxx ( b0 0x80 ) { ch out = ( char ) b0 ; continu ; } unicod : 0000 0yyi yyxx xxxx ( ( b0 0x e0 ) = = 0x c0 ) { int b1 = 1 ; ( total ) { b1 = f buffer 0x00ff ; } els { b1 = f input stream . read ( ) ; ( b1 = = 1 ) { ( out offset ) { f buffer 0 = ( byte ) b0 ; f offset = 1 ; return out offset ; } expect byte ( 2 , 2 ) ; } count ; } ( ( b1 0x c0 ) = 0x80 ) { ( out offset ) { f buffer 0 = ( byte ) b0 ; f buffer 1 = ( byte ) b1 ; f offset = 2 ; return out offset ; } invalid byte ( 2 , 2 ) ; } int c = ( ( b0 << 6 ) 0x07c0 ) ( b1 0x003f ) ; ch out = ( char ) c ; count = 1 ; continu ; } unicod : zzzz yyyi yyxx xxxx ( ( b0 0x f0 ) = = 0x e0 ) { int b1 = 1 ; ( total ) { b1 = f buffer 0x00ff ; } els { b1 = f input stream . read ( ) ; ( b1 = = 1 ) { ( out offset ) { f buffer 0 = ( byte ) b0 ; f offset = 1 ; return out offset ; } expect byte ( 2 , 3 ) ; } count ; } ( ( b1 0x c0 ) = 0x80 ) { ( out offset ) { f buffer 0 = ( byte ) b0 ; f buffer 1 = ( byte ) b1 ; f offset = 2 ; return out offset ; } invalid byte ( 2 , 3 ) ; } int b2 = 1 ; ( total ) { b2 = f buffer 0x00ff ; } els { b2 = f input stream . read ( ) ; ( b2 = = 1 ) { ( out offset ) { f buffer 0 = ( byte ) b0 ; f buffer 1 = ( byte ) b1 ; f offset = 2 ; return out offset ; } expect byte ( 3 , 3 ) ; } count ; } ( ( b2 0x c0 ) = 0x80 ) { ( out offset ) { f buffer 0 = ( byte ) b0 ; f buffer 1 = ( byte ) b1 ; f buffer 2 = ( byte ) b2 ; f offset = 3 ; return out offset ; } invalid byte ( 3 , 3 ) ; } int c = ( ( b0 << 12 ) 0x f000 ) ( ( b1 << 6 ) 0x0fc0 ) ( b2 0x003f ) ; ch out = ( char ) c ; count = 2 ; continu ; } uuuuu = wwww 1 ( ( b0 0x f8 ) = = 0x f0 ) { int b1 = 1 ; ( total ) { b1 = f buffer 0x00ff ; } els { b1 = f input stream . read ( ) ; ( b1 = = 1 ) { ( out offset ) { f buffer 0 = ( byte ) b0 ; f offset = 1 ; return out offset ; } expect byte ( 2 , 4 ) ; } count ; } ( ( b1 0x c0 ) = 0x80 ) { ( out offset ) { f buffer 0 = ( byte ) b0 ; f buffer 1 = ( byte ) b1 ; f offset = 2 ; return out offset ; } invalid byte ( 2 , 4 ) ; } int b2 = 1 ; ( total ) { b2 = f buffer 0x00ff ; } els { b2 = f input stream . read ( ) ; ( b2 = = 1 ) { ( out offset ) { f buffer 0 = ( byte ) b0 ; f buffer 1 = ( byte ) b1 ; f offset = 2 ; return out offset ; } expect byte ( 3 , 4 ) ; } count ; } ( ( b2 0x c0 ) = 0x80 ) { ( out offset ) { f buffer 0 = ( byte ) b0 ; f buffer 1 = ( byte ) b1 ; f buffer 2 = ( byte ) b2 ; f offset = 3 ; return out offset ; } invalid byte ( 3 , 4 ) ; } int b3 = 1 ; ( total ) { b3 = f buffer 0x00ff ; } els { b3 = f input stream . read ( ) ; ( b3 = = 1 ) { ( out offset ) { f buffer 0 = ( byte ) b0 ; f buffer 1 = ( byte ) b1 ; f buffer 2 = ( byte ) b2 ; f offset = 3 ; return out offset ; } expect byte ( 4 , 4 ) ; } count ; } ( ( b3 0x c0 ) = 0x80 ) { ( out offset ) { f buffer 0 = ( byte ) b0 ; f buffer 1 = ( byte ) b1 ; f buffer 2 = ( byte ) b2 ; f buffer 3 = ( byte ) b3 ; f offset = 4 ; return out offset ; } invalid byte ( 4 , 4 ) ; } decod byte surrog charact int uuuuu = ( ( b0 << 2 ) 0x001c ) ( ( b1 >> 4 ) 0x0003 ) ; ( uuuuu 0x10 ) { invalid surrog ( uuuuu ) ; } int wwww = uuuuu 1 ; int zzzz = b1 0x000f ; int yyyyyi = b2 0x003f ; int xxxxxx = b3 0x003f ; int hs = 0x d800 ( ( wwww << 6 ) 0x03c0 ) ( zzzz << 2 ) ( yyyyyi >> 4 ) ; int ls = 0x dc00 ( ( yyyyyi << 6 ) 0x03c0 ) xxxxxx ; set charact ch out = ( char ) hs ; ch out = ( char ) ls ; count = 2 ; continu ; } error ( out offset ) { f buffer 0 = ( byte ) b0 ; f offset = 1 ; return out offset ; } invalid byte ( 1 , 1 ) ; } return number charact convert ( debug read ) { ( log . debug enabl ( ) ) log . debug ( read ( char , offset , length ) : count = count ) ; } return count ; }	public static class . get name ( ) return arrai form et , where et , element type can zbcdfij l classnam ; convert form can understood javac . string java sourc type ( string type ) { ( type . char ( 0 ) = ) { return type ; } int dim = 1 ; string t = null ; ( int i = 1 ; i type . length ( ) ; i ) { ( type . char ( i ) = = ) { dim ; } els { switch ( type . char ( i ) ) { case z : t = boolean ; break ; case b : t = byte ; break ; case c : t = char ; break ; case d : t = doubl ; break ; case f : t = float ; break ; case i : t = int ; break ; case j : t = long ; break ; case s : t = short ; break ; case l : t = type . substr ( i 1 , type . index ( ; ) ) ; break ; } break ; } } string builder result type = new string builder ( t ) ; ( ; dim 0 ; dim ) { result type . append ( ) ; } return result type . string ( ) ; }	privat compil load tagfil . class load tag file ( compil compil , string tag file path , tag info tag info , page info parent page info ) throw jasper except { url tag file jar url = null ; ( tag file path . start ( meta inf ) ) { try { tag file jar url = new url ( jar : compil . get compil context ( ) . get tld locat ( tag info . get tag librari ( ) . get uri ( ) ) 0 ) ; } catch ( malform urlexcept e ) { ignor tag file jar url null } } string tag file jar path ; ( tag file jar url = = null ) { tag file jar path = ; } els { tag file jar path = tag file jar url . string ( ) ; } jsp compil context ctxt = compil . get compil context ( ) ; jsp runtim context rctxt = ctxt . get runtim context ( ) ; string wrapper uri = tag file jar path tag file path ; jsp servlet wrapper wrapper = rctxt . get wrapper ( wrapper uri ) ; synchron ( rctxt ) { ( wrapper = = null ) { wrapper = new jsp servlet wrapper ( ctxt . get servlet context ( ) , ctxt . get option ( ) , tag file path , tag info , ctxt . get runtim context ( ) , tag file jar url ) ; rctxt . add wrapper ( wrapper uri , wrapper ) ; us same classload classpath compil tag file wrapper . get jsp engin context ( ) . set class loader ( ctxt . get class loader ( ) ) ; wrapper . get jsp engin context ( ) . set class path ( ctxt . get class path ( ) ) ; } els { make sure jsp compil context get latest tag info tag file . tag info instanc wa creat last time tag file wa scan direct , tag file mai have been modifi sinc . wrapper . get jsp engin context ( ) . set tag info ( tag info ) ; } class tag clazz ; int trip count = wrapper . inc trip count ( ) ; try { ( trip count 0 ) { when trip count greater than zero , circular depend exist . circularili depend tag file compil prototyp mode , avoid infinit recurs . jsp servlet wrapper temp wrapper = new jsp servlet wrapper ( ctxt . get servlet context ( ) , ctxt . get option ( ) , tag file path , tag info , ctxt . get runtim context ( ) , ctxt . get tag file jar url ( tag file path ) ) ; tag clazz = temp wrapper . load tag file prototyp ( ) ; temp vector . add ( temp wrapper . get jsp engin context ( ) . get compil ( ) ) ; } els { tag clazz = wrapper . load tag file ( ) ; } } final { wrapper . dec trip count ( ) ; } can onli obtain from tag instanc . try { object tag = tag clazz . new instanc ( ) ; ( tag instanceof jsp sourc depend ) { iter string iter = ( ( jsp sourc depend ) tag ) . get depend ( ) . iter ( ) ; while ( iter . ha next ( ) ) { parent page info . add depend ( iter . next ( ) ) ; } } } catch ( except e ) { ignor error } return tag clazz ; } }	public static releas ani intern refer previous creat { link log factori } instanc , after call instanc method code releas ( ) code each them . thi us environ like servlet contain , which implement applic reload throw awai class loader . dangl refer object class loader would prevent garbag collect . void releas all ( ) { singleton . releas ( ) ; }	public arrai list integ get extra smap ( ) { return extra smap ; }	clear content buffer . buffer ha been alreadi been flush clear oper shall throw ioexcept signal fact some data ha alreadi been irrevoc written client respons stream . throw ioexcept i o error occur overrid public void clear ( ) throw ioexcept { ( writer = null ) { throw new ioexcept ( ) ; } els { next char = 0 ; ( limit buffer ( cb . length constant . default tag buffer size ) ) { buffer size = constant . default tag buffer size ; cb = new char buffer size ; } } }	public void do tag ( tag plugin context ctxt ) { boolean ha context , ha var , ha scope , ha var reader , ha char encod ; flag ha context = ctxt . attribut specifi ( context ) ; ha var = ctxt . attribut specifi ( var ) ; ha scope = ctxt . attribut specifi ( scope ) ; ha var reader = ctxt . attribut specifi ( var reader ) ; ha char encod = ctxt . attribut specifi ( char encod ) ; variabl name string url name = ctxt . get temporari variabl name ( ) ; string context name = ctxt . get temporari variabl name ( ) ; absolut url string iau name = ctxt . get temporari variabl name ( ) ; url object string url obj name = ctxt . get temporari variabl name ( ) ; urlconnect string uc name = ctxt . get temporari variabl name ( ) ; string input stream name = ctxt . get temporari variabl name ( ) ; string temp reader name = ctxt . get temporari variabl name ( ) ; string temp reader name2 = ctxt . get temporari variabl name ( ) ; string char set name = ctxt . get temporari variabl name ( ) ; string char encod name = ctxt . get temporari variabl name ( ) ; string content type name = ctxt . get temporari variabl name ( ) ; string var reader name = ctxt . get temporari variabl name ( ) ; string servlet context name = ctxt . get temporari variabl name ( ) ; string servlet path name = ctxt . get temporari variabl name ( ) ; string request dispatch name = ctxt . get temporari variabl name ( ) ; import respons wrapper name string irw name = ctxt . get temporari variabl name ( ) ; buffer reader name string br name = ctxt . get temporari variabl name ( ) ; string builder name string sb name = ctxt . get temporari variabl name ( ) ; string temp string name = ctxt . get temporari variabl name ( ) ; absolut url ctxt . gener java sourc ( boolean iau name ; ) ; get url valu ctxt . gener java sourc ( string url name = ) ; ctxt . gener attribut ( url ) ; ctxt . gener java sourc ( ; ) ; valid url ctxt . gener java sourc ( ( url name = = null url name . equal ( ) ) { ) ; ctxt . gener java sourc ( throw new jsp tag except ( url attribut illeg evalu null lt ; import gt ; ) ; ) ; ctxt . gener java sourc ( } ) ; initi absolut url ctxt . gener java sourc ( iau name = org . apach . jasper . tagplugin . jstl . util . absolut url ( url name ) ; ) ; valid context ( ha context ) { ctxt . gener java sourc ( string context name = ) ; ctxt . gener attribut ( context ) ; ctxt . gener java sourc ( ; ) ; ctxt . gener java sourc ( ( ( context name . start ( ) ) ( url name . start ( ) ) ) { ) ; ctxt . gener java sourc ( throw new jsp tag except ( url tag , when context attribut specifi , valu both context url must start . ) ; ) ; ctxt . gener java sourc ( } ) ; } defin charset ctxt . gener java sourc ( string char set name = null ; ) ; char encod attribut specifi ( ha char encod ) { initi char encod ctxt . gener java sourc ( string char encod name = ) ; ctxt . gener attribut ( char encod ) ; ctxt . gener java sourc ( ; ) ; assign appropri valu tp charset ctxt . gener java sourc ( ( null = char encod name char encod name . equal ( ) ) { ) ; ctxt . gener java sourc ( char set name = char encod name ; ) ; ctxt . gener java sourc ( } ) ; } reshap url string ctxt . gener java sourc ( ( iau name ) { ) ; ctxt . gener java sourc ( ( url name . start ( ) ) { ) ; ctxt . gener java sourc ( string servlet path name = ( ( http servlet request ) page context . get request ( ) ) . get servlet path ( ) ; ) ; ctxt . gener java sourc ( url name = servlet path name . substr ( 0 , servlet path name . last index ( ) ) url name ; ) ; ctxt . gener java sourc ( } ) ; ctxt . gener java sourc ( } ) ; var reader attribut specifi ( ha var reader ) { get string valu var reader ctxt . gener java sourc ( string var reader name = ) ; ctxt . gener attribut ( var reader ) ; ctxt . gener java sourc ( ; ) ; url absolut url ctxt . gener java sourc ( ( iau name ) { ) ; get content target ctxt . gener java sourc ( java . net . url url obj name = new java . net . url ( url name ) ; ) ; ctxt . gener java sourc ( java . net . urlconnect uc name = url obj name . open connect ( ) ; ) ; ctxt . gener java sourc ( java . io . input stream input stream name = uc name . get input stream ( ) ; ) ; ctxt . gener java sourc ( ( char set name = = null ) { ) ; ctxt . gener java sourc ( string content type name = uc name . get content type ( ) ; ) ; ctxt . gener java sourc ( ( null = content type name ) { ) ; ctxt . gener java sourc ( char set name = org . apach . jasper . tagplugin . jstl . util . get content type attribut ( content type name , charset ) ; ) ; ctxt . gener java sourc ( ( char set name = = null ) char set name = org . apach . jasper . tagplugin . jstl . util . default encod ; ) ; ctxt . gener java sourc ( } els { ) ; ctxt . gener java sourc ( char set name = org . apach . jasper . tagplugin . jstl . util . default encod ; ) ; ctxt . gener java sourc ( } ) ; ctxt . gener java sourc ( } ) ; ( ha char encod ) { ctxt . gener java sourc ( string content type name = uc name . get content type ( ) ; ) ; } defin reader ctxt . gener java sourc ( java . io . reader temp reader name = null ; ) ; initi reader object ctxt . gener java sourc ( try { ) ; ctxt . gener java sourc ( temp reader name = new java . io . input stream reader ( input stream name , char set name ) ; ) ; ctxt . gener java sourc ( } catch ( except ex ) { ) ; ctxt . gener java sourc ( temp reader name = new java . io . input stream reader ( input stream name , org . apach . jasper . tagplugin . jstl . util . default encod ) ; ) ; ctxt . gener java sourc ( } ) ; valid respons ctxt . gener java sourc ( ( uc name instanceof java . net . http urlconnect ) { ) ; ctxt . gener java sourc ( int statu = ( ( java . net . http urlconnect ) uc name ) . get respons code ( ) ; ) ; ctxt . gener java sourc ( ( statu 200 statu 299 ) { ) ; ctxt . gener java sourc ( throw new jsp tag except ( statu url name ) ; ) ; ctxt . gener java sourc ( } ) ; ctxt . gener java sourc ( } ) ; set attribut page context scope ctxt . gener java sourc ( page context . set attribut ( var reader name , temp reader name ) ; ) ; url rel ctxt . gener java sourc ( } els { ) ; url rel , http request need ctxt . gener java sourc ( ( ( page context . get request ( ) instanceof http servlet request page context . get respons ( ) instanceof http servlet respons ) ) { ) ; ctxt . gener java sourc ( throw new jsp tag except ( rel lt ; import gt ; from non http request allow ) ; ) ; ctxt . gener java sourc ( } ) ; get servlet context context defin context attribut ctxt . gener java sourc ( servlet context servlet context name = null ; ) ; ( ha context ) { ctxt . gener java sourc ( ( null = context name ) { ) ; ctxt . gener java sourc ( servlet context name = page context . get servlet context ( ) . get context ( context name ) ; ) ; ctxt . gener java sourc ( } els { ) ; ctxt . gener java sourc ( servlet context name = page context . get servlet context ( ) ; ) ; ctxt . gener java sourc ( } ) ; } els { ctxt . gener java sourc ( servlet context name = page context . get servlet context ( ) ; ) ; } ctxt . gener java sourc ( ( servlet context name = = null ) { ) ; ( ha context ) { ctxt . gener java sourc ( throw new jsp tag except ( unabl get request dispatch context : context name url : url name . verifi valu enabl cross context access . ) ; ) ; } els { ctxt . gener java sourc ( throw new jsp tag except ( unabl get request dispatch url : url name . verifi valu enabl cross context access . ) ; ) ; } ctxt . gener java sourc ( } ) ; get request dispatch ctxt . gener java sourc ( request dispatch request dispatch name = servlet context name . get request dispatch ( org . apach . jasper . tagplugin . jstl . util . strip session ( url name ) ) ; ) ; ctxt . gener java sourc ( ( request dispatch name = = null ) throw new jsp tag except ( org . apach . jasper . tagplugin . jstl . util . strip session ( url name ) ) ; ) ; initi import respons wrapper includ resourc ctxt . gener java sourc ( org . apach . jasper . tagplugin . jstl . util . import respons wrapper irw name = new org . apach . jasper . tagplugin . jstl . util . import respons wrapper ( ( http servlet respons ) page context . get respons ( ) ) ; ) ; ctxt . gener java sourc ( ( char set name = = null ) { ) ; ctxt . gener java sourc ( char set name = org . apach . jasper . tagplugin . jstl . util . default encod ; ) ; ctxt . gener java sourc ( } ) ; ctxt . gener java sourc ( irw name . set char encod ( char set name ) ; ) ; ctxt . gener java sourc ( try { ) ; ctxt . gener java sourc ( request dispatch name . includ ( page context . get request ( ) , irw name ) ; ) ; ctxt . gener java sourc ( } catch ( java . io . ioexcept ex ) { ) ; ctxt . gener java sourc ( throw new jsp except ( ex ) ; ) ; ctxt . gener java sourc ( } catch ( runtim except ex ) { ) ; ctxt . gener java sourc ( throw new jsp except ( ex ) ; ) ; ctxt . gener java sourc ( } catch ( servlet except ex ) { ) ; ctxt . gener java sourc ( throwabl rc = ex . get root caus ( ) ; ) ; ctxt . gener java sourc ( ( rc = = null ) ) ; ctxt . gener java sourc ( throw new jsp except ( ex ) ; ) ; ctxt . gener java sourc ( els ) ; ctxt . gener java sourc ( throw new jsp except ( rc ) ; ) ; ctxt . gener java sourc ( } ) ; valid respons statu ctxt . gener java sourc ( ( irw name . get statu ( ) 200 irw name . get statu ( ) 299 ) { ) ; ctxt . gener java sourc ( throw new jsp tag except ( irw name . get statu ( ) org . apach . jasper . tagplugin . jstl . util . strip session ( url name ) ) ; ) ; ctxt . gener java sourc ( } ) ; push page context ctxt . gener java sourc ( java . io . reader temp reader name = new java . io . string reader ( irw name . get string ( ) ) ; ) ; ctxt . gener java sourc ( page context . set attribut ( var reader name , temp reader name ) ; ) ; ctxt . gener java sourc ( } ) ; execut bodi action ctxt . gener bodi ( ) ; close reader ctxt . gener java sourc ( java . io . reader temp reader name2 = ( java . io . reader ) page context . get attribut ( var reader name ) ; ) ; ctxt . gener java sourc ( ( temp reader name2 = null ) temp reader name2 . close ( ) ; ) ; ctxt . gener java sourc ( page context . remov attribut ( var reader name , 1 ) ; ) ; } els var reader specifi { ctxt . gener java sourc ( page context . set attribut ( url without param , url name ) ; ) ; ctxt . gener bodi ( ) ; ctxt . gener java sourc ( url name = ( string ) page context . get attribut ( url without param ) ; ) ; ctxt . gener java sourc ( page context . remov attribut ( url without param ) ; ) ; string str scope = page ; ( ha scope ) { str scope = ctxt . get constant attribut ( scope ) ; } int i scope = util . get scope ( str scope ) ; ctxt . gener java sourc ( string temp string name = null ; ) ; ctxt . gener java sourc ( ( iau name ) { ) ; get content target ctxt . gener java sourc ( java . net . url url obj name = new java . net . url ( url name ) ; ) ; ctxt . gener java sourc ( java . net . urlconnect uc name = url obj name . open connect ( ) ; ) ; ctxt . gener java sourc ( java . io . input stream input stream name = uc name . get input stream ( ) ; ) ; ctxt . gener java sourc ( java . io . reader temp reader name = null ; ) ; ctxt . gener java sourc ( ( char set name = = null ) { ) ; ctxt . gener java sourc ( string content type name = uc name . get content type ( ) ; ) ; ctxt . gener java sourc ( ( null = content type name ) { ) ; ctxt . gener java sourc ( char set name = org . apach . jasper . tagplugin . jstl . util . get content type attribut ( content type name , charset ) ; ) ; ctxt . gener java sourc ( ( char set name = = null ) char set name = org . apach . jasper . tagplugin . jstl . util . default encod ; ) ; ctxt . gener java sourc ( } els { ) ; ctxt . gener java sourc ( char set name = org . apach . jasper . tagplugin . jstl . util . default encod ; ) ; ctxt . gener java sourc ( } ) ; ctxt . gener java sourc ( } ) ; ctxt . gener java sourc ( try { ) ; ctxt . gener java sourc ( temp reader name = new java . io . input stream reader ( input stream name , char set name ) ; ) ; ctxt . gener java sourc ( } catch ( except ex ) { ) ; ctxt . gener java sourc ( throw new jsp tag except ( ex . string ( ) ) ; ) ; ctxt . gener java sourc ( temp reader name = new java . io . input stream reader ( input stream name , org . apach . jasper . tagplugin . jstl . util . default encod ) ; ) ; ctxt . gener java sourc ( } ) ; valid respons ctxt . gener java sourc ( ( uc name instanceof java . net . http urlconnect ) { ) ; ctxt . gener java sourc ( int statu = ( ( java . net . http urlconnect ) uc name ) . get respons code ( ) ; ) ; ctxt . gener java sourc ( ( statu 200 statu 299 ) { ) ; ctxt . gener java sourc ( throw new jsp tag except ( statu url name ) ; ) ; ctxt . gener java sourc ( } ) ; ctxt . gener java sourc ( } ) ; ctxt . gener java sourc ( java . io . buffer reader br name = new java . io . buffer reader ( temp reader name ) ; ) ; ctxt . gener java sourc ( string builder sb name = new string builder ( ) ; ) ; string index = ctxt . get temporari variabl name ( ) ; ctxt . gener java sourc ( int index ; ) ; ctxt . gener java sourc ( while ( ( index = br name . read ( ) ) = 1 ) sb name . append ( ( char ) index ) ; ) ; ctxt . gener java sourc ( temp string name = sb name . string ( ) ; ) ; ctxt . gener java sourc ( } els { ) ; url rel , http request need . ctxt . gener java sourc ( ( ( page context . get request ( ) instanceof http servlet request page context . get respons ( ) instanceof http servlet respons ) ) { ) ; ctxt . gener java sourc ( throw new jsp tag except ( rel lt ; import gt ; from non http request allow ) ; ) ; ctxt . gener java sourc ( } ) ; get servlet context context defin context attribut ctxt . gener java sourc ( servlet context servlet context name = null ; ) ; ( ha context ) { ctxt . gener java sourc ( ( null = context name ) { ) ; ctxt . gener java sourc ( servlet context name = page context . get servlet context ( ) . get context ( context name ) ; ) ; ctxt . gener java sourc ( } els { ) ; ctxt . gener java sourc ( servlet context name = page context . get servlet context ( ) ; ) ; ctxt . gener java sourc ( } ) ; } els { ctxt . gener java sourc ( servlet context name = page context . get servlet context ( ) ; ) ; } ctxt . gener java sourc ( ( servlet context name = = null ) { ) ; ( ha context ) { ctxt . gener java sourc ( throw new jsp tag except ( unabl get request dispatch context : context name url : url name . verifi valu enabl cross context access . ) ; ) ; } els { ctxt . gener java sourc ( throw new jsp tag except ( unabl get request dispatch url : url name . verifi valu enabl cross context access . ) ; ) ; } ctxt . gener java sourc ( } ) ; get request dispatch ctxt . gener java sourc ( request dispatch request dispatch name = servlet context name . get request dispatch ( org . apach . jasper . tagplugin . jstl . util . strip session ( url name ) ) ; ) ; ctxt . gener java sourc ( ( request dispatch name = = null ) throw new jsp tag except ( org . apach . jasper . tagplugin . jstl . util . strip session ( url name ) ) ; ) ; initi import respons wrapper includ resourc ctxt . gener java sourc ( org . apach . jasper . tagplugin . jstl . util . import respons wrapper irw name = new org . apach . jasper . tagplugin . jstl . util . import respons wrapper ( ( http servlet respons ) page context . get respons ( ) ) ; ) ; ctxt . gener java sourc ( ( char set name = = null ) { ) ; ctxt . gener java sourc ( char set name = org . apach . jasper . tagplugin . jstl . util . default encod ; ) ; ctxt . gener java sourc ( } ) ; ctxt . gener java sourc ( irw name . set char encod ( char set name ) ; ) ; ctxt . gener java sourc ( try { ) ; ctxt . gener java sourc ( request dispatch name . includ ( page context . get request ( ) , irw name ) ; ) ; ctxt . gener java sourc ( } catch ( java . io . ioexcept ex ) { ) ; ctxt . gener java sourc ( throw new jsp except ( ex ) ; ) ; ctxt . gener java sourc ( } catch ( runtim except ex ) { ) ; ctxt . gener java sourc ( throw new jsp except ( ex ) ; ) ; ctxt . gener java sourc ( } catch ( servlet except ex ) { ) ; ctxt . gener java sourc ( throwabl rc = ex . get root caus ( ) ; ) ; ctxt . gener java sourc ( ( rc = = null ) ) ; ctxt . gener java sourc ( throw new jsp except ( ex ) ; ) ; ctxt . gener java sourc ( els ) ; ctxt . gener java sourc ( throw new jsp except ( rc ) ; ) ; ctxt . gener java sourc ( } ) ; valid respons statu ctxt . gener java sourc ( ( irw name . get statu ( ) 200 irw name . get statu ( ) 299 ) { ) ; ctxt . gener java sourc ( throw new jsp tag except ( irw name . get statu ( ) org . apach . jasper . tagplugin . jstl . util . strip session ( url name ) ) ; ) ; ctxt . gener java sourc ( } ) ; ctxt . gener java sourc ( temp string name = irw name . get string ( ) ; ) ; ctxt . gener java sourc ( } ) ; ( ha var ) { string str var = ctxt . get constant attribut ( var ) ; ctxt . gener java sourc ( page context . set attribut ( str var , temp string name , i scope ) ; ) ; } els { ctxt . gener java sourc ( page context . get out ( ) . print ( temp string name ) ; ) ; } } }	overrid public void do visit ( node n ) throw jasper except { collect text ( ) ; }	public void set prototyp mode ( boolean pm ) { proto type mode = pm ; }	public get list file current page ha sourc depend . java . util . list string get depend ( ) { try { object target ; ( tag file ) { ( reload ) { tag handler class = ctxt . load ( ) ; reload = fals ; } target = tag handler class . new instanc ( ) ; } els { target = get servlet ( ) ; } ( target = null target instanceof jsp sourc depend ) { return ( ( jsp sourc depend ) target ) . get depend ( ) ; } } catch ( throwabl ex ) { } return null ; }	public synchron variabl begin tag file void sync begin tag file ( ) { save nest variabl ( ) ; }	privat gener xml prolog , which includ xml declar xml doctyp declar . void gener xml prolog ( node . node page ) { xml declar gener under follow condit : omit xml declar attribut jsp : output action set fals jsp document without jsp : root string omit xml decl = page info . get omit xml decl ( ) ; ( ( omit xml decl = null jsp util . boolean valu ( omit xml decl ) ) ( omit xml decl = = null page . get root ( ) . xml syntax ( ) page info . ha jsp root ( ) ctxt . tag file ( ) ) ) { string c type = page info . get content type ( ) ; string char set = c type . substr ( c type . index ( charset = ) 8 ) ; out . printil ( out . write ( xml version = 1 . 0 encod = char set n ) ; ) ; } output doctyp declar doctyp root element appear . doctyp public appear : doctyp name public doctyp public doctyp system els doctyp name system doctyp system string doctyp name = page info . get doctyp name ( ) ; ( doctyp name = null ) { string doctyp public = page info . get doctyp public ( ) ; string doctyp system = page info . get doctyp system ( ) ; out . printin ( out . write ( doctyp ) ; out . print ( doctyp name ) ; ( doctyp public = = null ) { out . print ( system ) ; } els { out . print ( public ) ; out . print ( doctyp public ) ; out . print ( ) ; } out . print ( doctyp system ) ; out . println ( n ) ; ) ; } }	privat compil load tagfil . class load tag file ( compil compil , string tag file path , tag info tag info , page info parent page info ) throw jasper except { url tag file jar url = null ; ( tag file path . start ( meta inf ) ) { try { tag file jar url = new url ( jar : compil . get compil context ( ) . get tld locat ( tag info . get tag librari ( ) . get uri ( ) ) 0 ) ; } catch ( malform urlexcept e ) { ignor tag file jar url null } } string tag file jar path ; ( tag file jar url = = null ) { tag file jar path = ; } els { tag file jar path = tag file jar url . string ( ) ; } jsp compil context ctxt = compil . get compil context ( ) ; jsp runtim context rctxt = ctxt . get runtim context ( ) ; string wrapper uri = tag file jar path tag file path ; jsp servlet wrapper wrapper = rctxt . get wrapper ( wrapper uri ) ; synchron ( rctxt ) { ( wrapper = = null ) { wrapper = new jsp servlet wrapper ( ctxt . get servlet context ( ) , ctxt . get option ( ) , tag file path , tag info , ctxt . get runtim context ( ) , tag file jar url ) ; rctxt . add wrapper ( wrapper uri , wrapper ) ; us same classload classpath compil tag file wrapper . get jsp engin context ( ) . set class loader ( ctxt . get class loader ( ) ) ; wrapper . get jsp engin context ( ) . set class path ( ctxt . get class path ( ) ) ; } els { make sure jsp compil context get latest tag info tag file . tag info instanc wa creat last time tag file wa scan direct , tag file mai have been modifi sinc . wrapper . get jsp engin context ( ) . set tag info ( tag info ) ; } class tag clazz ; int trip count = wrapper . inc trip count ( ) ; try { ( trip count 0 ) { when trip count greater than zero , circular depend exist . circularili depend tag file compil prototyp mode , avoid infinit recurs . jsp servlet wrapper temp wrapper = new jsp servlet wrapper ( ctxt . get servlet context ( ) , ctxt . get option ( ) , tag file path , tag info , ctxt . get runtim context ( ) , ctxt . get tag file jar url ( tag file path ) ) ; tag clazz = temp wrapper . load tag file prototyp ( ) ; temp vector . add ( temp wrapper . get jsp engin context ( ) . get compil ( ) ) ; } els { tag clazz = wrapper . load tag file ( ) ; } } final { wrapper . dec trip count ( ) ; } can onli obtain from tag instanc . try { object tag = tag clazz . new instanc ( ) ; ( tag instanceof jsp sourc depend ) { iter string iter = ( ( jsp sourc depend ) tag ) . get depend ( ) . iter ( ) ; while ( iter . ha next ( ) ) { parent page info . add depend ( iter . next ( ) ) ; } } } catch ( except e ) { ignor error } return tag clazz ; } }	privat function mapper get function mapper ( elnod . node el ) throw jasper except { class valid function mapper extend function mapper { privat hash map string , method fnmap = new hash map string , method ( ) ; public void map function ( string fn qname , method method ) { fnmap . put ( fn qname , method ) ; } overrid public method resolv function ( string prefix , string local name ) { return thi . fnmap . get ( prefix : local name ) ; } } class mapper elvisitor extend elnod . visitor { valid function mapper fmapper ; mapper elvisitor ( valid function mapper fmapper ) { thi . fmapper = fmapper ; } overrid public void visit ( elnod . function n ) throw jasper except { class c = null ; method method = null ; try { c = loader . load class ( n . get function info ( ) . get function class ( ) ) ; } catch ( class found except e ) { err . jsp error ( jsp . error . function . classnotfound , n . get function info ( ) . get function class ( ) , n . get prefix ( ) : n . get name ( ) , e . get messag ( ) ) ; } string param type = n . get paramet ( ) ; int size = param type . length ; class param = new class size ; int i = 0 ; try { ( i = 0 ; i size ; i ) { param i = jsp util . class ( param type i , loader ) ; } method = c . get declar method ( n . get method name ( ) , param ) ; } catch ( class found except e ) { err . jsp error ( jsp . error . signatur . classnotfound , param type i , n . get prefix ( ) : n . get name ( ) , e . get messag ( ) ) ; } catch ( method except e ) { err . jsp error ( jsp . error . function method , n . get method name ( ) , n . get name ( ) , c . get name ( ) ) ; } fmapper . map function ( n . get prefix ( ) : n . get name ( ) , method ) ; } } valid function mapper fmapper = new valid function mapper ( ) ; el . visit ( new mapper elvisitor ( fmapper ) ) ; return fmapper ; }	overrid public void visit ( node . templat text n ) throw jasper except { string text = n . get text ( ) ; int text size = text . length ( ) ; ( text size = = 0 ) { return ; } ( text size = 3 ) { special case small text string n . set begin java line ( out . get java line ( ) ) ; int line inc = 0 ; ( int i = 0 ; i text size ; i ) { char ch = text . char ( i ) ; out . printil ( out . write ( quot ( ch ) ) ; ) ; ( i 0 ) { n . add smap ( line inc ) ; } ( ch = = n ) { line inc ; } } n . set end java line ( out . get java line ( ) ) ; return ; } ( ctxt . get option ( ) . gen string char arrai ( ) ) { gener string char arrai , perform servlet writer ca out ; ( char arrai buffer = = null ) { char arrai buffer = new gen buffer ( ) ; ca out = char arrai buffer . get out ( ) ; ca out . push indent ( ) ; text map = new hash map string , string ( ) ; } els { ca out = char arrai buffer . get out ( ) ; } string char arrai name = text map . get ( text ) ; ( char arrai name = = null ) { char arrai name = jspx char arrai char arrai count ; text map . put ( text , char arrai name ) ; ca out . printin ( static char ) ; ca out . print ( char arrai name ) ; ca out . print ( = ) ; ca out . print ( quot ( text ) ) ; ca out . println ( . char arrai ( ) ; ) ; } n . set begin java line ( out . get java line ( ) ) ; out . printil ( out . write ( char arrai name ) ; ) ; n . set end java line ( out . get java line ( ) ) ; return ; } n . set begin java line ( out . get java line ( ) ) ; out . printin ( ) ; string builder sb = new string builder ( out . write ( ) ; int init length = sb . length ( ) ; int count = jsp util . chunksiz ; rel start srouc line int src line = 0 ; ( int i = 0 ; i text . length ( ) ; i ) { char ch = text . char ( i ) ; count ; switch ( ch ) { case : sb . append ( ) . append ( ) ; break ; case : sb . append ( ) . append ( ) ; break ; case r : sb . append ( ) . append ( r ) ; break ; case n : sb . append ( ) . append ( n ) ; src line ; ( break lf count 0 ) { gener out . write ( ) when see n templat sb . append ( ) ; ) ; out . println ( sb . string ( ) ) ; ( i text . length ( ) 1 ) { out . printin ( ) ; } sb . set length ( init length ) ; count = jsp util . chunksiz ; } add smap thi line n . add smap ( src line ) ; break ; case sure we need thi t : sb . append ( ) . append ( t ) ; break ; default : sb . append ( ch ) ; } } ( sb . length ( ) init length ) { sb . append ( ) ; ) ; out . println ( sb . string ( ) ) ; } n . set end java line ( out . get java line ( ) ) ; }	overrid public void visit ( node . us bean n ) throw jasper except { string name = n . get text attribut ( id ) ; string scope = n . get text attribut ( scope ) ; string klass = n . get text attribut ( class ) ; string type = n . get text attribut ( type ) ; node . jsp attribut bean name = n . get bean name ( ) ; class specifi , try instanti compil time boolean gener new = fals ; canon name klass string canon name = null ; ( klass = null ) { try { class bean = ctxt . get class loader ( ) . load class ( klass ) ; ( klass . index ( ) = 0 ) { obtain canon type name canon name = jsp util . get canon name ( bean ) ; } els { canon name = klass ; } int modifi = bean . get modifi ( ) ; ( modifi . public ( modifi ) modifi . interfac ( modifi ) modifi . abstract ( modifi ) ) { throw new except ( invalid bean class modifi ) ; } check 0 arg constructor bean . get constructor ( new class { } ) ; compil time , we have determin bean class exist , public zero constructor , new ( ) can us bean instanti . gener new = true ; } catch ( except e ) { depend compil flag . ( ctxt . get option ( ) . get error us bean invalid class attribut ( ) ) { err . jsp error ( n , jsp . error . invalid . bean , klass ) ; } ( canon name = = null ) { do our best here get canon name from binari name , should work 99 . 99 time . canon name = klass . replac ( , . ) ; } } ( type = = null ) { type unspecifi , us class type bean type = canon name ; } } default page string scopenam = page context . page scope ; string lock = jspx page context ; ( request . equal ( scope ) ) { scopenam = page context . request scope ; lock = request ; } els ( session . equal ( scope ) ) { scopenam = page context . session scope ; lock = session ; } els ( applic . equal ( scope ) ) { scopenam = page context . applic scope ; lock = applic ; } n . set begin java line ( out . get java line ( ) ) ; declar bean out . printin ( type ) ; out . print ( ) ; out . print ( name ) ; out . println ( = null ; ) ; lock while get creat bean out . printin ( synchron ( ) ; out . print ( lock ) ; out . println ( ) { ) ; out . push indent ( ) ; locat bean from context out . printin ( name ) ; out . print ( = ( ) ; out . print ( type ) ; out . print ( ) jspx page context . get attribut ( ) ; out . print ( quot ( name ) ) ; out . print ( , ) ; out . print ( scopenam ) ; out . println ( ) ; ) ; creat bean check bean alredi out . printin ( ( ) ; out . print ( name ) ; out . println ( = = null ) { ) ; out . push indent ( ) ; ( klass = = null bean name = = null ) { both class name bean name specifi , bean must found local , otherwis s error out . printin ( throw new java . lang . instanti except ( bean ) ; out . print ( name ) ; out . println ( found within scope ) ; ) ; } els { instanti bean specifi scope . ( gener new ) { string binari name ; ( bean name = null ) { ( bean name . name attribut ( ) ) { valu bean name wa specifi via jsp : attribut , first gener code evalu bodi . binari name = gener name attribut valu ( bean name . get name attribut node ( ) ) ; } els { binari name = attribut valu ( bean name , fals , string . class ) ; } } els { impli klass null binari name = quot ( klass ) ; } out . printil ( try { ) ; out . push indent ( ) ; out . printin ( name ) ; out . print ( = ( ) ; out . print ( type ) ; out . print ( ) java . bean . bean . instanti ( ) ; out . print ( thi . get class ( ) . get class loader ( ) , ) ; out . print ( binari name ) ; out . println ( ) ; ) ; out . pop indent ( ) ; note : bean . instanti throw class found except bean class abstract . out . printil ( } catch ( class found except exc ) { ) ; out . push indent ( ) ; out . printil ( throw new instanti except ( exc . get messag ( ) ) ; ) ; out . pop indent ( ) ; out . printil ( } catch ( except exc ) { ) ; out . push indent ( ) ; out . printin ( throw new servlet except ( ) ; out . print ( cannot creat bean class ) ; out . print ( binari name ) ; out . println ( , exc ) ; ) ; out . pop indent ( ) ; close try out . printil ( } ) ; } els { impli klass null gener code instanti bean class out . printin ( name ) ; out . print ( = new ) ; out . print ( canon name ) ; out . println ( ( ) ; ) ; } set attribut bean specifi scope out . printin ( jspx page context . set attribut ( ) ; out . print ( quot ( name ) ) ; out . print ( , ) ; out . print ( name ) ; out . print ( , ) ; out . print ( scopenam ) ; out . println ( ) ; ) ; onli visit bodi when bean instanti visit bodi ( n ) ; } out . pop indent ( ) ; out . printil ( } ) ; end lock block out . pop indent ( ) ; out . printil ( } ) ; n . set end java line ( out . get java line ( ) ) ; }	perform miscellean check after node ar visit . void post check ( ) throw jasper except { check var . name from attribut ha valid valu . iter string iter = name from tabl . kei set ( ) . iter ( ) ; while ( iter . ha next ( ) ) { string name from = iter . next ( ) ; name entri name entri = name tabl . get ( name from ) ; name entri name from entri = name from tabl . get ( name from ) ; node name from node = name from entri . get node ( ) ; ( name entri = = null ) { err . jsp error ( name from node , jsp . error . tagfil . name from . attribut , name from ) ; } els { node node = name entri . get node ( ) ; tag attribut info tag attr = name entri . get tag attribut info ( ) ; ( java . lang . string . equal ( tag attr . get type name ( ) ) tag attr . requir ( ) tag attr . can request time ( ) ) { err . jsp error ( name from node , jsp . error . tagfil . name from . bad attribut , name from , integ . string ( node . get start ( ) . get line number ( ) ) ) ; } } } }
protect list resourc which ar member collect . param file collect return vector conta name entri object arrai list name entri list ( file file ) { arrai list name entri entri = new arrai list name entri ( ) ; ( file . directori ( ) ) return entri ; string name = file . list ( ) ; ( name = = null ) { some io error occur bad file permiss . prevent npe arrai . sort ( name ) log . warn ( sm . get string ( file resourc . list null , file . get absolut path ( ) ) ) ; return entri ; } sort alphabet arrai . sort ( name ) ; name entri entri = null ; ( int i = 0 ; i name . length ; i ) { file current file = new file ( file , name i ) ; object object = null ; ( current file . directori ( ) ) { file dir context temp context = new file dir context ( env ) ; temp context . set doc base ( file . get path ( ) ) ; temp context . set allow link ( get allow link ( ) ) ; object = temp context ; } els { object = new file resourc ( current file ) ; } entri = new name entri ( name i , object , name entri . entri ) ; entri . add ( entri ) ; } return entri ; }	protect load entri cach . void cach load ( cach entri entri ) { string name = entri . name ; retriev miss info boolean exist = true ; retriev attribut ( entri . attribut = = null ) { try { attribut attribut = dir context . get attribut ( entri . name ) ; ( ( attribut instanceof resourc attribut ) ) { entri . attribut = new resourc attribut ( attribut ) ; } els { entri . attribut = ( resourc attribut ) attribut ; } } catch ( name except e ) { exist = fals ; } } retriv object ( ( exist ) ( entri . resourc = = null ) ( entri . context = = null ) ) { try { object object = dir context . lookup ( name ) ; ( object instanceof input stream ) { entri . resourc = new resourc ( ( input stream ) object ) ; } els ( object instanceof dir context ) { entri . context = ( dir context ) object ; } els ( object instanceof resourc ) { entri . resourc = ( resourc ) object ; } els { entri . resourc = new resourc ( new byte arrai input stream ( object . string ( ) . get byte ( ) ) ) ; } } catch ( name except e ) { exist = fals ; } } load object content ( ( exist ) ( entri . resourc = null ) ( entri . resourc . get content ( ) = = null ) ( entri . attribut . get content length ( ) = 0 ) ( entri . attribut . get content length ( ) ( cach object max size 1024 ) ) ) { int length = ( int ) entri . attribut . get content length ( ) ; entri size 1 resourc size kb , cach entri . size = ( entri . attribut . get content length ( ) 1024 ) ; input stream = null ; try { = entri . resourc . stream content ( ) ; int po = 0 ; byte b = new byte length ; while ( po length ) { int n = . read ( b , po , length po ) ; ( n 0 ) break ; po = po n ; } entri . resourc . set content ( b ) ; } catch ( ioexcept e ) { ignor } final { try { ( = null ) . close ( ) ; } catch ( ioexcept e ) { ignor } } } set exist flag entri . exist = exist ; set timestamp entri . timestamp = system . current time milli ( ) cach ttl ; add new entri cach synchron ( cach ) { check cach size , remov element too big ( ( cach . lookup ( name ) = = null ) cach . alloc ( entri . size ) ) { cach . load ( entri ) ; } } }	search name context object entri satisfi given search filter . perform search specifi search control . param name name context object search param filter expr filter express us search . express mai contain variabl form { i } where i nonneg integ . mai null . param filter arg arrai argument substitut variabl filter expr . valu filter arg i replac each occurr { i } . null , equival empti arrai . param con search control control search . null , default search control ar us ( equival ( new search control ( ) ) ) . return enumer search result object satisi filter ; never null except arrai index out bound except filter expr contain { i } express where i outsid bound arrai filter arg except invalid search control except con contain invalid set except invalid search filter except filter expr filter arg repres invalid search filter except name except name except encount overrid public name enumer search result search ( string name , string filter expr , object filter arg , search control con ) throw name except { return null ; }	search name context object entri satisfi given search filter . perform search specifi search control . param name name context object search param filter expr filter express us search . express mai contain variabl form { i } where i nonneg integ . mai null . param filter arg arrai argument substitut variabl filter expr . valu filter arg i replac each occurr { i } . null , equival empti arrai . param con search control control search . null , default search control ar us ( equival ( new search control ( ) ) ) . return enumer search result object satisi filter ; never null except arrai index out bound except filter expr contain { i } express where i outsid bound arrai filter arg except invalid search control except con contain invalid set except invalid search filter except filter expr filter arg repres invalid search filter except name except name except encount overrid public name enumer search result search ( string name , string filter expr , object filter arg , search control con ) throw name except { throw new oper support except ( ) ; }	public search name context object entri satisfi given search filter . perform search specifi search control . param name name context object search param filter expr filter express us search . express mai contain variabl form { i } where i nonneg integ . mai null . param filter arg arrai argument substitut variabl filter expr . valu filter arg i replac each occurr { i } . null , equival empti arrai . param con search control control search . null , default search control ar us ( equival ( new search control ( ) ) ) . return enumer search result object satisi filter ; never null except arrai index out bound except filter expr contain { i } express where i outsid bound arrai filter arg except invalid search control except con contain invalid set except invalid search filter except filter expr filter arg repres invalid search filter except name except name except encount name enumer search result search ( name name , string filter expr , object filter arg , search control con ) throw name except { return search ( name . string ( ) , filter expr , filter arg , con ) ; }	public boolean unload ( string name ) { cach entri remov entri = remov cach ( name ) ; ( remov entri = null ) { cach size = remov entri . size ; return true ; } els ( found cach . remov ( name ) = null ) { cach size ; return true ; } return fals ; }	public void post deregist ( ) { destroi ( ) ; }
privat void remov header ( int idx ) { mime header field mh = header idx ; mh . recycl ( ) ; header idx = header count 1 ; header count 1 = mh ; count ; }	privat final extens map . void intern map extens wrapper ( wrapper wrapper , char chunk path , map data map data ) { char buf = path . get buffer ( ) ; int path end = path . get end ( ) ; int servlet path = path . get offset ( ) ; int slash = 1 ; ( int i = path end 1 ; i = servlet path ; i ) { ( buf i = = ) { slash = i ; break ; } } ( slash = 0 ) { int period = 1 ; ( int i = path end 1 ; i slash ; i ) { ( buf i = = . ) { period = i ; break ; } } ( period = 0 ) { path . set offset ( period 1 ) ; path . set end ( path end ) ; int po = find ( wrapper , path ) ; ( ( po = 1 ) ( path . equal ( wrapper po . name ) ) ) { map data . wrapper path . set char ( buf , servlet path , path end servlet path ) ; map data . request path . set char ( buf , servlet path , path end servlet path ) ; map data . wrapper = wrapper po . object ; } path . set offset ( servlet path ) ; path . set end ( path end ) ; } } }	privat static final find map elemnt given name sort arrai map element . thi return index closest inferior equal item given arrai . int find ( map element map , char chunk name ) { return find ( map , name , name . get start ( ) , name . get end ( ) ) ; }	privat static final find map elemnt given name sort arrai map element . thi return index closest inferior equal item given arrai . int find ( map element map , char chunk name , int start , int end ) { int = 0 ; int b = map . length 1 ; special case : 1 0 ( b = = 1 ) { return 1 ; } ( compar ( name , start , end , map 0 . name ) 0 ) { return 1 ; } ( b = = 0 ) { return 0 ; } int i = 0 ; while ( true ) { i = ( b ) 2 ; int result = compar ( name , start , end , map i . name ) ; ( result = = 1 ) { = i ; } els ( result = = 0 ) { return i ; } els { b = i ; } ( ( b ) = = 1 ) { int result2 = compar ( name , start , end , map b . name ) ; ( result2 0 ) { return ; } els { return b ; } } } }	privat static final find map elemnt given name sort arrai map element . thi return index closest inferior equal item given arrai . int find ignor case ( map element map , char chunk name ) { return find ignor case ( map , name , name . get start ( ) , name . get end ( ) ) ; }	privat static final given start posit token , thi get end token , separ charact between . jvk int get token end posit ( byte byte , int off , int end , int version , boolean name ) { int po = off ; while ( po end ( cooki support . http separ ( ( char ) byte po ) version = = 0 cooki support . allow http separ v0 byte po = = cooki support . v0separ ( ( char ) byte po ) name byte po = = = cooki support . allow equal valu ) ) { po ; } ( po end ) return end ; return po ; }	privat call notifi listen . void notifi listen ( ) { ( listen = null ) { listen . updat ( byte read , content length , item ) ; } }	privat reset swap last header param idx index header remov . void remov header ( int idx ) { mime header field mh = header idx ; mh . recycl ( ) ; header idx = header count 1 ; header count 1 = mh ; count ; }	protect check thi class conform java bean specif . class conform , return true . param java type class check return boolean true class compat . boolean bean compat ( class java type ) { must non primit non arrai ( java type . arrai ( ) java type . primit ( ) ) { return fals ; } doe have defin map exclud . ( java type . get name ( ) . start ( java . ) java type . get name ( ) . start ( javax . ) ) { return fals ; } try { java type . get constructor ( new class { } ) ; } catch ( java . lang . method except e ) { return fals ; } make sure superclass compat class super class = java type . get superclass ( ) ; ( super class = null super class = java . lang . object . class super class = java . lang . except . class super class = java . lang . throwabl . class ) { ( bean compat ( super class ) ) { return fals ; } } return true ; }	protect boolean process kei ( select kei sk , kei attach attach ) { boolean result = true ; try { ( close ) { cancel kei ( sk , socket statu . stop , fals ) ; } els ( sk . valid ( ) attach = null ) { make sure we don t time out valid socket attach . access ( ) ; cant rememb why thi here sk . attach ( attach ) ; nio channel channel = attach . get channel ( ) ; ( sk . readabl ( ) sk . writabl ( ) ) { ( attach . get sendfil data ( ) = null ) { process sendfil ( sk , attach , true , fals ) ; } els ( attach . get comet ( ) ) { check thread avail ( worker avail ( ) ) { set interest op 0 so we don t get multipl invok both read write separ thread reg ( sk , attach , 0 ) ; read goe befor write ( sk . readabl ( ) ) { read notif ( process socket ( channel , socket statu . open , true ) ) process socket ( channel , socket statu . disconnect , true ) ; } els { futur placement write notif ( process socket ( channel , socket statu . open , true ) ) process socket ( channel , socket statu . disconnect , true ) ; } } els { result = fals ; } } els { later , improv latch behavior ( worker avail ( ) ) { unreg ( sk , attach , sk . readi op ( ) ) ; boolean close = ( process socket ( channel , null , true ) ) ; ( close ) { cancel kei ( sk , socket statu . disconnect , fals ) ; } } els { result = fals ; } } } } els { invalid kei cancel kei ( sk , socket statu . error , fals ) ; } } catch ( cancel kei except ckx ) { cancel kei ( sk , socket statu . error , fals ) ; } catch ( throwabl t ) { log . error ( , t ) ; } return result ; }	protect final pars cooki header after initi cooki : ws token ws = ws ( token qv ) ; , rfc 2965 jvk void process cooki header ( byte byte , int off , int len ) { ( len = 0 byte = = null ) return ; int end = off len ; int po = off ; int name start = 0 ; int name end = 0 ; int valu start = 0 ; int valu end = 0 ; int version = 0 ; server cooki sc = null ; boolean special ; boolean quot ; while ( po end ) { special = fals ; quot = fals ; skip whitespac non token charact ( separ ) while ( po end ( cooki support . http separ ( ( char ) byte po ) cooki support . allow http separ v0 cooki support . v0separ ( ( char ) byte po ) white space ( byte po ) ) ) { po ; } ( po = end ) return ; detect special cooki ( byte po = = ) { special = true ; po ; } get cooki attribut name . thi must token valu end = valu start = name start = po ; po = name end = get token end posit ( byte , po , end , version , true ) ; skip whitespac while ( po end white space ( byte po ) ) { po ; } skip name onli part . ( po end byte po = = = ) { skip whitespac do { po ; } while ( po end white space ( byte po ) ) ; ( po = end ) return ; token , name onli = , other ( bad ) switch ( byte po ) { case quot valu : quot = true ; strip valu start = po 1 ; get quot valu return posit befor last qout . thi must dealt when byte ar copi cooki valu end = get quot valu end posit ( byte , valu start , end ) ; we need po advanc po = valu end ; e . g . mynam = valu ( po = end ) return ; break ; case ; : case , : name onli cooki = after name token thi mai rfc compliant valu start = valu end = 1 ; posit ok ( delimit ) break ; default : ( version = = 0 cooki support . v0separ ( ( char ) byte po ) cooki support . allow http separ v0 cooki support . http separ ( ( char ) byte po ) byte po = = = cooki support . allow equal valu ) { token valu start = po ; get token return posit delimet other non token charact valu end = get token end posit ( byte , valu start , end , version , fals ) ; we need po advanc po = valu end ; } els { invalid cooki , advanc next delimit start charact cooki valu wa valid . log . info ( cooki : invalid cooki . valu token quot valu ) ; while ( po end byte po = ; byte po = , ) { po ; } po ; make sure special avpair can attribut previou cooki set current cooki null sc = null ; continu ; } } } els { name onli cooki valu start = valu end = 1 ; po = name end ; } skip whitespac while ( po end white space ( byte po ) ) { po ; } onli import thi last cooki pair while ( po end byte po = ; byte po = , ) { po ; } po ; special avpair first ( special ) { special = fals ; ( sc must null ) ( equal ( version , byte , name start , name end ) sc = = null ) { set version ( byte valu start = = 1 valu end = = ( valu start 1 ) ) { version = 1 ; } els { unknown version ( version veri strict ) } continu ; } we need activ cooki path port etc . ( sc = = null ) { continu ; } domain more common , so goe first ( equal ( domain , byte , name start , name end ) ) { sc . get domain ( ) . set byte ( byte , valu start , valu end valu start ) ; continu ; } ( equal ( path , byte , name start , name end ) ) { sc . get path ( ) . set byte ( byte , valu start , valu end valu start ) ; continu ; } v2 cooki attribut skip them ( equal ( port , byte , name start , name end ) ) { continu ; } ( equal ( comment url , byte , name start , name end ) ) { continu ; } unknown cooki , complain log . info ( cooki : unknown special cooki ) ; } els { normal cooki sc = add cooki ( ) ; sc . set version ( version ) ; sc . get name ( ) . set byte ( byte , name start , name end name start ) ; ( valu start = 1 ) { normal avpair sc . get valu ( ) . set byte ( byte , valu start , valu end valu start ) ; ( quot ) { we know thi byte valu so thi safe unescap doubl quot ( sc . get valu ( ) . get byte chunk ( ) ) ; } } els { name onli sc . get valu ( ) . set string ( ) ; } continu ; } } }	public background thread listen incom tcp ip connect hand them off appropri processor . void run ( ) { long maintain time = 0 ; loop until we receiv shutdown command while ( run ) { loop endpoint paus while ( paus ) { try { thread . sleep ( 1000 ) ; } catch ( interrupt except e ) { ignor } } while ( keep aliv count 1 add count 1 ) { reset maintain time . maintain time = 0 ; try { synchron ( thi ) { thi . wait ( ) ; } } catch ( interrupt except e ) { ignor } } try { add socket which ar wait poller ( add count 0 ) { synchron ( thi ) { ( int i = ( add count 1 ) ; i = 0 ; i ) { int rv = poll . add ( server pollset , add s i , poll . apr pollin ) ; ( rv = = statu . apr success ) { keep aliv count ; } els { can t do anyth : close socket right awai ( comet ) { process socket ( add s i , socket statu . error ) ; } els { socket . destroi ( add s i ) ; } } } add count = 0 ; } } maintain time = poll time ; pool specifi interv int rv = poll . poll ( server pollset , poll time , desc , true ) ; ( rv 0 ) { keep aliv count = rv ; ( int n = 0 ; n rv ; n ) { check fail socket hand thi socket off worker ( ( ( desc n 2 poll . apr pollhup ) = = poll . apr pollhup ) ( ( desc n 2 poll . apr pollerr ) = = poll . apr pollerr ) ( comet ( process socket ( desc n 2 1 , socket statu . open ) ) ) ( comet ( process socket ( desc n 2 1 ) ) ) ) { close socket clear pool ( comet ) { process socket ( desc n 2 1 , socket statu . disconnect ) ; } els { socket . destroi ( desc n 2 1 ) ; } continu ; } } } els ( rv 0 ) { int errn = rv ; ani non timeup interrupt error critic ( ( errn = statu . timeup ) ( errn = statu . eintr ) ) { ( errn statu . apr os start usererr ) { errn = statu . apr os start usererr ; } log . error ( sm . get string ( endpoint . poll . fail , errn , error . strerror ( errn ) ) ) ; handl poll critic failur synchron ( thi ) { destroi ( ) ; init ( ) ; } continu ; } } ( socket properti . get so timeout ( ) 0 maintain time 1000000l run ) { rv = poll . maintain ( server pollset , desc , true ) ; maintain time = 0 ; ( rv 0 ) { keep aliv count = rv ; ( int n = 0 ; n rv ; n ) { close socket clear pool ( comet ) { process socket ( desc n , socket statu . timeout ) ; } els { socket . destroi ( desc n ) ; } } } } } catch ( throwabl t ) { log . error ( sm . get string ( endpoint . poll . error ) , t ) ; } } synchron ( thi ) { thi . notifi all ( ) ; } }	protect void timeout ( int kei count , boolean ha event ) { long now = system . current time milli ( ) ; we can check timeout avoid gap ( ( ( kei count 0 ha event ) ( now next expir ) ) ( close ) ) { return ; } log purpos onli long prev exp = next expir ; next expir = now socket properti . get timeout interv ( ) ; timeout set select kei kei = selector . kei ( ) ; int keycount = 0 ; ( iter select kei iter = kei . iter ( ) ; iter . ha next ( ) ; ) { select kei kei = iter . next ( ) ; keycount ; try { kei attach ka = ( kei attach ) kei . attach ( ) ; ( ka = = null ) { we don t support ani kei without attach cancel kei ( kei , socket statu . error , fals ) ; } els ( ka . get error ( ) ) { todo thi yet us cancel kei ( kei , socket statu . error , true ) ; } els ( ka . get comet ( ) ka . get comet notifi ( ) ) { ka . set comet notifi ( fals ) ; avoid multipl call , thi get reregist after invok reg ( kei , ka , 0 ) ; ( process socket ( ka . get channel ( ) , socket statu . open callback ) ) process socket ( ka . get channel ( ) , socket statu . disconnect ) ; ( process socket ( ka . get channel ( ) , socket statu . open , true ) ) process socket ( ka . get channel ( ) , socket statu . disconnect , true ) ; } els ( ( ka . interest op ( ) select kei . op read ) = = select kei . op read ( ka . interest op ( ) select kei . op write ) = = select kei . op write ) { onli timeout socket we ar wait read from long delta = now ka . get last access ( ) ; long timeout = ( ka . get timeout ( ) = = 1 ) ( ( long ) socket properti . get so timeout ( ) ) : ( ka . get timeout ( ) ) ; boolean timedout = delta timeout ; ( close ) { kei . interest op ( 0 ) ; avoid duplic stop call ka . interest op ( 0 ) ; process kei ( kei , ka ) ; } els ( timedout ) { kei . interest op ( 0 ) ; avoid duplic timeout call ka . interest op ( 0 ) ; cancel kei ( kei , socket statu . timeout , true ) ; } els { long next time = now ( timeout delta ) ; next expir = ( next time next expir ) next time : next expir ; } } els ( ka . async ( ) ) { long delta = now ka . get last access ( ) ; long timeout = ( ka . get timeout ( ) = = 1 ) ( ( long ) socket properti . get so timeout ( ) ) : ( ka . get timeout ( ) ) ; boolean timedout = delta timeout ; ( timedout ) { process socket ( ka . get channel ( ) , socket statu . timeout , true ) ; } } end } catch ( cancel kei except ckx ) { cancel kei ( kei , socket statu . error , fals ) ; } } ( log . trace enabl ( ) ) log . trace ( timeout complet : kei process = keycount ; now = now ; next expir = prev exp ; kei count = kei count ; ha event = ha event ; eval = ( ( now prev exp ) ( kei count 0 ha event ) ( close ) ) ) ; }	public get digest us rule digest get digest ( ) { return wrap rule . get digest ( ) ; }	public void reset ( ) throw ioexcept { destroi reader ii ii = new intermedi input stream ( ) ; conv = new read convertor ( ii , encod ) ; }	public string string intern ( ) { string str valu = null ; try { ( enc = = null ) enc = default charact encod ; str valu = new string ( buff , start , end start , enc ) ; } }	public final void flush buffer ( ) throw ioexcept { conv . flush ( ) ; }	public boolean equal ( messag byte mb ) { switch ( type ) { case t str : return mb . equal ( str valu ) ; } ( mb . type = t char mb . type = t byte ) { s string int date string valu return equal ( mb . string ( ) ) ; } deal 4 case ( fact 3 , simetr ) ( mb . type = = t char type = = t char ) { return char c . equal ( mb . char c ) ; } ( mb . type = = t byte type = = t byte ) { return byte c . equal ( mb . byte c ) ; } ( mb . type = = t char type = = t byte ) { return byte c . equal ( mb . char c ) ; } ( mb . type = = t byte type = = t char ) { return mb . byte c . equal ( char c ) ; } can t happen return true ; }	public find begin first code encapsul code . return code true code code encapsul code wa found stream . throw ioexcept i o error occur . boolean skip preambl ( ) throw ioexcept { first delimit mai preceed crlf . system . arraycopi ( boundari , 2 , boundari , 0 , boundari . length 2 ) ; boundari length = boundari . length 2 ; try { discard all data up delimit . discard bodi data ( ) ; encapsul . return read boundari ( ) ; } catch ( malform stream except e ) { return fals ; } final { restor delimit . system . arraycopi ( boundari , 0 , boundari , 2 , boundari . length 2 ) ; boundari length = boundari . length ; boundari 0 = cr ; boundari 1 = lf ; } }	public int get cooki count ( ) { ( unprocess ) { unprocess = fals ; process cooki ( header ) ; } return cooki count ; }	public return length byte . xxx need clean thi up int get length ( ) { return end start ; }	public int substract ( byte src , int off , int len ) throw ioexcept { ( ( end start ) = = 0 ) { ( = = null ) return 1 ; int n = . real read byte ( buff , 0 , buff . length ) ; ( n 0 ) return 1 ; } int n = len ; ( len get length ( ) ) { n = get length ( ) ; } system . arraycopi ( buff , start , src , off , n ) ; start = n ; return n ; }	public static string get content ( node n ) { ( n = = null ) return null ; node n1 = dom util . get child ( n , node . text node ) ; ( n1 = = null ) return null ; string s1 = n1 . get node valu ( ) ; return s1 . trim ( ) ; }	public static string string ( byte chunk bc ) { still train ( bc cach = = null ) { string valu = bc . string intern ( ) ; ( byte enabl ( valu . length ( ) max string size ) ) { train , everyth sync synchron ( bc stat ) { we just calcul ( bc cach = null ) { return valu ; } string ( bc count train threshold ) { long t1 = system . current time milli ( ) ; sort entri accord occurr tree map integ , arrai list byte entri >> temp map = new tree map integ , arrai list byte entri >> ( ) ; iter byte entri entri = bc stat . kei set ( ) . iter ( ) ; while ( entri . ha next ( ) ) { byte entri entri = entri . next ( ) ; int count = bc stat . get ( entri ) ; integ count = new integ ( count 0 ) ; add list count arrai list byte entri list = temp map . get ( count ) ; ( list = = null ) { creat list list = new arrai list byte entri ( ) ; temp map . put ( count , list ) ; } list . add ( entri ) ; } alloc arrai right size int size = bc stat . size ( ) ; ( size cach size ) { size = cach size ; } byte entri tempbc cach = new byte entri size ; fill up us alphabet order dumb insert sort byte chunk temp chunk = new byte chunk ( ) ; int n = 0 ; while ( n size ) { object kei = temp map . last kei ( ) ; arrai list byte entri list = temp map . get ( kei ) ; ( int i = 0 ; i list . size ( ) n size ; i ) { byte entri entri = list . get ( i ) ; temp chunk . set byte ( entri . name , 0 , entri . name . length ) ; int insert po = find closest ( temp chunk , tempbc cach , n ) ; ( insert po = = n ) { tempbc cach n 1 = entri ; } els { system . arraycopi ( tempbc cach , insert po 1 , tempbc cach , insert po 2 , n insert po 1 ) ; tempbc cach insert po 1 = entri ; } n ; } temp map . remov ( kei ) ; } bc count = 0 ; bc stat . clear ( ) ; bc cach = tempbc cach ; ( log . debug enabl ( ) ) { long t2 = system . current time milli ( ) ; log . debug ( byte cach gener time : ( t2 t1 ) ms ) ; } } els { bc count ; alloc new byte entri lookup byte entri entri = new byte entri ( ) ; entri . valu = valu ; int count = bc stat . get ( entri ) ; ( count = = null ) { int end = bc . get end ( ) ; int start = bc . get start ( ) ; creat byte arrai copi byte entri . name = new byte bc . get length ( ) ; system . arraycopi ( bc . get buffer ( ) , start , entri . name , 0 , end start ) ; set encod entri . enc = bc . get encod ( ) ; initi occurr count count = new int 1 ; count 0 = 1 ; set stat hash map bc stat . put ( entri , count ) ; } els { count 0 = count 0 1 ; } } } } return valu ; } els { access count ; find correspond string string result = find ( bc ) ; ( result = = null ) { return bc . string intern ( ) ; } note : we don t care about safeti stat hit count ; return result ; } }	public static test object implement particular method boolean ha hook ( object obj , string method n ) { try { method my method = find method ( obj . get class ( ) ) ; ( int i = 0 ; i my method . length ; i ) { ( method n . equal ( my method i . get name ( ) ) ) { check s overriden class declar = my method i . get declar class ( ) ; class parent declar = declar . get superclass ( ) ; parent base interceptor intermedi class ( java . lang . object . equal ( parent declar . get name ( ) ) ) { return true ; } } } } catch ( except ex ) { ex . print stack trace ( ) ; } return fals ; }	public static return apr time t msec long msec ( long t ) { return t apr msec per usec ; }	public add call method rule specifi paramet . code param count code set zero rule us bodi match element singl argument method , unless code param type code null empti , thi case rule call specifi method argument . param pattern element match pattern param method name method name call param param count number expect paramet ( zero singl paramet from bodi thi element ) param param type java class name argument ( you wish us primit type , specifi corresond java wrapper class instead , code java . lang . boolean code code boolean code paramet ) see call method rule void add call method ( string pattern , string method name , int param count , class param type ) { add rule ( pattern , new call method rule ( method name , param count , param type ) ) ; }	public add set next rule specifi paramet . param pattern element match pattern param method name method name call parent element see set next rule void add set next ( string pattern , string method name ) { add rule ( pattern , new set next rule ( method name ) ) ; }	public add set top rule specifi paramet . param pattern element match pattern param method name method name call parent element see set top rule void add set top ( string pattern , string method name ) { add rule ( pattern , new set top rule ( method name ) ) ; }	public urldecod , modifi sourc . void convert ( byte chunk mb , boolean queri ) throw ioexcept { int start = mb . get offset ( ) ; byte buff = mb . get byte ( ) ; int end = mb . get end ( ) ; int idx = byte chunk . index ( buff , start , end , ) ; int idx2 = 1 ; ( queri ) idx2 = byte chunk . index ( buff , start , end , ) ; ( idx 0 idx2 0 ) { return ; } idx smallest posit inx ( first ) ( idx2 = 0 idx2 idx ) idx = idx2 ; ( idx 0 ) idx = idx2 ; boolean slash = ( allow encod slash queri ) ; ( int j = idx ; j end ; j , idx ) { ( buff j = = queri ) { buff idx = ( byte ) ; } els ( buff j = ) { buff idx = buff j ; } els { read next 2 digit ( j 2 = end ) { throw new char convers except ( eof ) ; } byte b1 = buff j 1 ; byte b2 = buff j 2 ; ( hex digit ( b1 ) hex digit ( b2 ) ) throw new char convers except ( hex digit ) ; j = 2 ; int re = x2c ( b1 , b2 ) ; ( slash ( re = = ) ) { throw new char convers except ( slash ) ; } buff idx = ( byte ) re ; } } mb . set end ( idx ) ; return ; }	public remov field specifi posit . multi map preserv order field add unless remov ( ) call . thi thread safe , invalid all iter . thi frequent oper header paramet ar better wai ( like ad valid field ) void remov ( int i ) { reset swap last header field mh = field i ; reset field mh . recycl ( ) ; field i = field count 1 ; field count 1 = mh ; count ; }	public remov cach string valu . us after convers byte after encod chang xxx thi need void reset string valu ( ) { ( type = t str ) { thi wa cread byte char , we remov old string valu ha str valu = fals ; str valu = null ; } }	protect boolean process socket ( long socket , socket statu statu ) { try { get executor ( ) . execut ( new socket event processor ( socket , statu ) ) ; } catch ( reject execut except x ) { log . warn ( socket process request wa reject : socket , x ) ; return fals ; } catch ( throwabl t ) { thi mean we got oom similar creat thread , pool queue ar full log . error ( sm . get string ( endpoint . process . fail ) , t ) ; return fals ; } return true ; }	public void set char ( char c , int off , int len ) { buff = c ; start = off ; end = start len ; set = true ; }	public set encod . object wa construct from byte . ani previou convers reset . encod set , we ll us 8859 1 . void set encod ( string enc ) { ( byte c . null ( ) ) { encod chang we need reset converion result char c . recycl ( ) ; ha str valu = fals ; } byte c . set encod ( enc ) ; }	public set namespac awar flag parser we creat . param namespac awar new namespac awar flag void set namespac awar ( boolean namespac awar ) { thi . namespac awar = namespac awar ; }	public void set set method ( string set method ) { thi . set method = set method ; }	public load extend mlet file . sourc can url , file input stream . all mbean instanti , regist attribut set . result list object name . param sourc input stream url file param cl class loader us load mbean , null us default jmx mechan ( i . e . all regist loader ) return list object name load mbean throw except sinc 1 . 1 list object name load mbean ( object sourc , class loader cl ) throw except { return load ( mbean sourc , sourc , null ) ; }	public void url encod ( writer buf , byte byte , int off , int len ) throw ioexcept { ( int j = off ; j len ; j ) { buf . write ( ) ; char ch = charact . digit ( ( byte j >> 4 ) 0x f , 16 ) ; ( log . debug enabl ( ) ) log . debug ( encod : encod : ch ) ; buf . write ( ch ) ; ch = charact . digit ( byte j 0x f , 16 ) ; ( log . debug enabl ( ) ) log . debug ( encod : encod : ch ) ; buf . write ( ch ) ; } }	protect trust manag get trust manag ( string keystor type , string keystor provid , string algorithm ) throw except { string crlf = ( string ) attribut . get ( crl file ) ; trust manag tm = null ; kei store trust store = get trust store ( keystor type , keystor provid ) ; ( trust store = null ) { ( crlf = = null ) { trust manag factori tmf = trust manag factori . get instanc ( algorithm ) ; tmf . init ( trust store ) ; tm = tmf . get trust manag ( ) ; } els { trust manag factori tmf = trust manag factori . get instanc ( algorithm ) ; cert path paramet param = get paramet ( algorithm , crlf , trust store ) ; manag factori paramet mfp = new cert path trust manag paramet ( param ) ; tmf . init ( mfp ) ; tm = tmf . get trust manag ( ) ; } } return tm ; }
void intern do filter ( servlet request request , servlet respons respons ) throw ioexcept , servlet except { call next filter ( po n ) { applic filter config filter config = filter po ; filter filter = null ; try { filter = filter config . get filter ( ) ; support . fire instanc event ( instanc event . befor filter event , filter , request , respons ) ; ( global . secur enabl ) { final servlet request req = request ; final servlet respons re = respons ; princip princip = ( ( http servlet request ) req ) . get user princip ( ) ; object arg = new object { req , re , thi } ; secur util . do privileg ( do filter , filter , class type , arg , princip ) ; arg = null ; } els { filter . do filter ( request , respons , thi ) ; } support . fire instanc event ( instanc event . after filter event , filter , request , respons ) ; } catch ( ioexcept e ) { ( filter = null ) support . fire instanc event ( instanc event . after filter event , filter , request , respons , e ) ; throw e ; } catch ( servlet except e ) { ( filter = null ) support . fire instanc event ( instanc event . after filter event , filter , request , respons , e ) ; throw e ; } catch ( runtim except e ) { ( filter = null ) support . fire instanc event ( instanc event . after filter event , filter , request , respons , e ) ; throw e ; } catch ( throwabl e ) { ( filter = null ) support . fire instanc event ( instanc event . after filter event , filter , request , respons , e ) ; throw new servlet except ( sm . get string ( filter chain . filter ) , e ) ; } return ; } we fell off end chain call servlet instanc try { ( global . strict servlet complianc ) { last servic request . set ( request ) ; last servic respons . set ( respons ) ; } support . fire instanc event ( instanc event . befor servic event , servlet , request , respons ) ; ( ( request instanceof http servlet request ) ( respons instanceof http servlet respons ) ) { ( global . secur enabl ) { final servlet request req = request ; final servlet respons re = respons ; princip princip = ( ( http servlet request ) req ) . get user princip ( ) ; object arg = new object { req , re } ; secur util . do privileg ( servic , servlet , class type us servic , arg , princip ) ; arg = null ; } els { servlet . servic ( request , respons ) ; } } els { servlet . servic ( request , respons ) ; } support . fire instanc event ( instanc event . after servic event , servlet , request , respons ) ; } catch ( ioexcept e ) { support . fire instanc event ( instanc event . after servic event , servlet , request , respons , e ) ; throw e ; } catch ( servlet except e ) { support . fire instanc event ( instanc event . after servic event , servlet , request , respons , e ) ; throw e ; } catch ( runtim except e ) { support . fire instanc event ( instanc event . after servic event , servlet , request , respons , e ) ; throw e ; } catch ( throwabl e ) { support . fire instanc event ( instanc event . after servic event , servlet , request , respons , e ) ; throw new servlet except ( sm . get string ( filter chain . servlet ) , e ) ; } final { ( global . strict servlet complianc ) { last servic request . set ( null ) ; last servic respons . set ( null ) ; } } }	public byte get data ( boolean getal ) { return get data ( getal , fals ) ; }	public static byte creat data packag ( byte data , int doff , int dlength , byte buffer , int bufoff ) { ( ( buffer . length bufoff ) get data packag length ( dlength ) ) { throw new arrai index out bound except ( unabl creat data packag , buffer too small . ) ; } system . arraycopi ( start data , 0 , buffer , bufoff , start data . length ) ; byte ( data . length , buffer , bufoff start data . length ) ; system . arraycopi ( data , doff , buffer , bufoff start data . length 4 , dlength ) ; system . arraycopi ( end data , 0 , buffer , bufoff start data . length 4 data . length , end data . length ) ; return buffer ; }	privat pars jsp page tag file given path name . param file name name jsp page tag file pars . param parent parent node ( non null when process includ direct ) param tag file true file pars tag file , fals regular jsp page param direct onli true file pars tag file we ar onli interest direct need construct tag file info . param jar file jar file from which read jsp page tag file , null jsp page tag file read from filesystem node . node do pars ( string file name , node parent , url jar file url ) throw file found except , jasper except , ioexcept { node . node pars page = null ; encod specifi prolog = fals ; bom present = fals ; default page encod = fals ; jar file jar file = get jar file ( jar file url ) ; string ab file name = resolv file name ( file name ) ; string jsp config page enc = get jsp config page encod ( ab file name ) ; figur out what type jsp document encod type we ar deal determin syntax encod ( ab file name , jar file , jsp config page enc ) ; ( parent = null ) { includ resourc , add depend list ( jar file = = null ) { compil . get page info ( ) . add depend ( ab file name ) ; } els { compil . get page info ( ) . add depend ( jar file url . extern form ( ) ab file name . substr ( 1 ) ) ; } } ( ( xml encod specifi prolog ) bom present ) { make sure encod explicitli specifi xml prolog ( ani ) match jsp config element ( ani ) , treat utf 16 , utf 16be , utf 16le ident . ( jsp config page enc = null jsp config page enc . equal ( sourc enc ) ( jsp config page enc . start ( utf 16 ) sourc enc . start ( utf 16 ) ) ) { err . jsp error ( jsp . error . prolog config encod mismatch , sourc enc , jsp config page enc ) ; } } dispatch appropri parser ( xml ) { jsp document ( xml syntax ) input stream jspx page creat properli close jsp document parser . pars page = jsp document parser . pars ( thi , ab file name , jar file , parent , tag file , direct onli , sourc enc , jsp config page enc , encod specifi prolog , bom present ) ; } els { standard syntax input stream reader stream reader = null ; try { stream reader = jsp util . get reader ( ab file name , sourc enc , jar file , ctxt , err , skip ) ; jsp reader jsp reader = new jsp reader ( ctxt , ab file name , sourc enc , stream reader , err ) ; pars page = parser . pars ( thi , jsp reader , parent , tag file , direct onli , jar file url , sourc enc , jsp config page enc , default page encod , bom present ) ; } final { ( stream reader = null ) { try { stream reader . close ( ) ; } catch ( except ani ) { } } } } ( jar file = null ) { try { jar file . close ( ) ; } catch ( throwabl t ) { } } base dir stack . pop ( ) ; return pars page ; }	public object clone ( ) { synchron ( member lock ) { membership clone = new membership ( local , member compar ) ; clone . map = ( hash map member impl , mbr entri ) map . clone ( ) ; clone . member = new member impl member . length ; system . arraycopi ( member , 0 , clone . member , 0 , member . length ) ; return clone ; } }	return princip associ specifi usernam , which match digest calcul us given paramet us method describ rfc 2069 ; otherwis return code null code . param usernam usernam princip look up param client digest digest which ha been submit client param n onc uniqu ( supposedli uniqu ) token which ha been us thi request param realm realm name param md5a2 second md5 digest us calcul digest : md5 ( method : uri ) overrid public princip authent ( string usernam , string client digest , string onc , string nc , string cnonc , string qop , string realm name , string md5a2 ) { princip authent user = null ; ( realm realm : realm ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( combin realm . auth start , usernam , realm . get info ( ) ) ) ; } authent user = realm . authent ( usernam , client digest , onc , nc , cnonc , qop , realm name , md5a2 ) ; ( authent user = = null ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( combin realm . auth fail , usernam , realm . get info ( ) ) ) ; } } els { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( combin realm . auth sucess , usernam , realm . get info ( ) ) ) ; } break ; } } return authent user ; }	return princip associ specifi usernam , which match digest calcul us given paramet us method describ rfc 2069 ; otherwis return code null code . param usernam usernam princip look up param client digest digest which ha been submit client param n onc uniqu ( supposedli uniqu ) token which ha been us thi request param realm realm name param md5a2 second md5 digest us calcul digest : md5 ( method : uri ) overrid public princip authent ( string usernam , string client digest , string onc , string nc , string cnonc , string qop , string realm name , string md5a2 ) { ( lock ( usernam ) ) { try authent lock user automat failur regist auth failur ( usernam ) ; log . warn ( sm . get string ( lock out realm . auth lock user , usernam ) ) ; return null ; } princip authent user = super . authent ( usernam , client digest , onc , nc , cnonc , qop , realm name , md5a2 ) ; ( authent user = = null ) { regist auth failur ( usernam ) ; } els { regist auth success ( usernam ) ; } return authent user ; }	return princip associ specifi usernam credenti , ; otherwis return code null code . param usernam usernam princip look up param credenti password other credenti us authent thi usernam overrid public princip authent ( string usernam , byte credenti ) { princip authent user = null ; ( realm realm : realm ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( combin realm . auth start , usernam , realm . get info ( ) ) ) ; } authent user = realm . authent ( usernam , credenti ) ; ( authent user = = null ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( combin realm . auth fail , usernam , realm . get info ( ) ) ) ; } } els { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( combin realm . auth sucess , usernam , realm . get info ( ) ) ) ; } break ; } } return authent user ; }	return princip associ specifi usernam credenti , ; otherwis return code null code . param usernam usernam princip look up param credenti password other credenti us authent thi usernam overrid public princip authent ( string usernam , byte credenti ) { ( lock ( usernam ) ) { try authent lock user automat failur regist auth failur ( usernam ) ; log . warn ( sm . get string ( lock out realm . auth lock user , usernam ) ) ; return null ; } princip authent user = super . authent ( usernam , credenti ) ; ( authent user = = null ) { regist auth failur ( usernam ) ; } els { regist auth success ( usernam ) ; } return authent user ; }	public void bodi ( string namespac , string name , string text ) throw except { string namespaceuri = null ; string localpart = text ; int colon = text . index ( : ) ; ( colon = 0 ) { string prefix = text . substr ( 0 , colon ) ; namespaceuri = digest . find namespac uri ( prefix ) ; localpart = text . substr ( colon 1 ) ; } context handler context handler = ( context handler ) digest . peek ( ) ; context handler . add soap header ( localpart , namespaceuri ) ; }	public void begin ( string namespac , string name , attribut attribut ) throw except { digest . get logger ( ) . warn ( web rule set . sm . get string ( web rule set . rel order ) ) ; }	public return return class loader . string get class loader ( ) { return class loader ; }	return descript inform about thi valv implement . overrid public string get info ( ) { return ( info ) ; }	return descript inform about thi valv implement . overrid public string get info ( ) { return ( info ) ; }	public string get object name ( ) { ( onam = null ) { return onam . string ( ) ; } els { return null ; } }	public return readonli statu user databas boolean get readonli ( ) { return ( thi . readonli ) ; }	public boolean access ( ) { return thi . access ; }	public return true redirect standard stream enabl . boolean redirect stream ( ) { return ( thi . redirect stream ) ; }	select appropri child wrapper process thi request , base specifi request uri . match wrapper can found , return appropri http error . param request request process param respons respons produc param valv context valv context us forward next valv except ioexcept input output error occur except servlet except servlet error occur overrid public final void invok ( request request , respons respons ) throw ioexcept , servlet except { disallow ani direct access resourc under web inf meta inf messag byte request path mb = request . get request path mb ( ) ; ( ( request path mb . start ignor case ( meta inf , 0 ) ) ( request path mb . equal ignor case ( meta inf ) ) ( request path mb . start ignor case ( web inf , 0 ) ) ( request path mb . equal ignor case ( web inf ) ) ) { found ( respons ) ; return ; } wait we ar reload boolean reload = fals ; while ( context . get paus ( ) ) { reload = true ; try { thread . sleep ( 1000 ) ; } catch ( interrupt except e ) { ignor } } creat new ( reload context . get loader ( ) = null context . get loader ( ) . get class loader ( ) = null ) { thread . current thread ( ) . set context class loader ( context . get loader ( ) . get class loader ( ) ) ; } select wrapper us thi request wrapper wrapper = request . get wrapper ( ) ; ( wrapper = = null ) { found ( respons ) ; return ; } els ( wrapper . unavail ( ) ) { mai result reload , try find new wrapper wrapper = ( wrapper ) contain . find child ( wrapper . get name ( ) ) ; ( wrapper = = null ) { found ( respons ) ; return ; } } normal request process object instanc = context . get applic event listen ( ) ; servlet request event event = null ; ( ( instanc = null ) ( instanc . length 0 ) ) { event = new servlet request event ( ( ( standard context ) contain ) . get servlet context ( ) , request . get request ( ) ) ; creat pre servic event ( int i = 0 ; i instanc . length ; i ) { ( instanc i = = null ) continu ; ( ( instanc i instanceof servlet request listen ) ) continu ; servlet request listen listen = ( servlet request listen ) instanc i ; try { listen . request initi ( event ) ; } catch ( throwabl t ) { contain . get logger ( ) . error ( sm . get string ( standard context . request listen . request init , instanc i . get class ( ) . get name ( ) ) , t ) ; servlet request sreq = request . get request ( ) ; sreq . set attribut ( global . except attr , t ) ; return ; } } } ( request . async support ( ) ) { request . set async support ( wrapper . get pipelin ( ) . async support ( ) ) ; } wrapper . get pipelin ( ) . get first ( ) . invok ( request , respons ) ; ( ( instanc = null ) ( instanc . length 0 ) ) { creat post servic event ( int i = 0 ; i instanc . length ; i ) { ( instanc i = = null ) continu ; ( ( instanc i instanceof servlet request listen ) ) continu ; servlet request listen listen = ( servlet request listen ) instanc i ; try { listen . request destroi ( event ) ; } catch ( throwabl t ) { contain . get logger ( ) . error ( sm . get string ( standard context . request listen . request destroi , instanc i . get class ( ) . get name ( ) ) , t ) ; servlet request sreq = request . get request ( ) ; sreq . set attribut ( global . except attr , t ) ; } } } }	select appropri child host process thi request , base request server name . match host can found , return appropri http error . param request request process param respons respons produc param valv context valv context us forward next valv except ioexcept input output error occur except servlet except servlet error occur overrid public final void invok ( request request , respons respons ) throw ioexcept , servlet except { select host us thi request host host = request . get host ( ) ; ( host = = null ) { respons . send error ( http servlet respons . sc bad request , sm . get string ( standard engin . host , request . get server name ( ) ) ) ; return ; } ( request . async support ( ) ) { request . set async support ( host . get pipelin ( ) . async support ( ) ) ; } ask thi host process thi request host . get pipelin ( ) . get first ( ) . invok ( request , respons ) ; }	select appropri child context process thi request , base specifi request uri . match context can found , return appropri http error . param request request process param respons respons produc param valv context valv context us forward next valv except ioexcept input output error occur except servlet except servlet error occur overrid public final void invok ( request request , respons respons ) throw ioexcept , servlet except { select context us thi request context context = request . get context ( ) ; ( context = = null ) { respons . send error ( http servlet respons . sc intern server error , sm . get string ( standard host . context ) ) ; return ; } bind context cl current thread ( context . get loader ( ) = null ) { start should check avail first thi should eventu move engin , s gener . thread . current thread ( ) . set context class loader ( context . get loader ( ) . get class loader ( ) ) ; } ( request . async support ( ) ) { request . set async support ( context . get pipelin ( ) . async support ( ) ) ; } ask thi context process thi request context . get pipelin ( ) . get first ( ) . invok ( request , respons ) ; strict interpret specif ( global . strict servlet complianc ) { request . get session ( fals ) ; } error page process respons . set suspend ( fals ) ; throwabl t = ( throwabl ) request . get attribut ( global . except attr ) ; ( t = null ) { throwabl ( request , respons , t ) ; } els { statu ( request , respons ) ; } restor context classload thread . current thread ( ) . set context class loader ( standard host valv . class . get class loader ( ) ) ; }	public byte get data packag ( byte data , int offset ) { byte addr = ( ( member impl ) address ) . get data ( fals ) ; xbyte buffer . byte ( option , data , offset ) ; option offset = 4 ; xbyte buffer . byte ( timestamp , data , offset ) ; timestamp offset = 8 ; xbyte buffer . byte ( uniqu id . length , data , offset ) ; uniqu id . length offset = 4 ; system . arraycopi ( uniqu id , 0 , data , offset , uniqu id . length ) ; uniqu id data offset = uniqu id . length ; xbyte buffer . byte ( addr . length , data , offset ) ; addr . length offset = 4 ; system . arraycopi ( addr , 0 , data , offset , addr . length ) ; addr data offset = addr . length ; xbyte buffer . byte ( messag . get length ( ) , data , offset ) ; messag . length offset = 4 ; system . arraycopi ( messag . get byte direct ( ) , 0 , data , offset , messag . get length ( ) ) ; messag data offset = messag . get length ( ) ; return data ; }	public return return messag option see org . apach . catalina . tribe . channel send messag ( org . apach . catalina . tribe . member , java . io . serializ , int ) int get option ( ) { return option ; }	public perform block write us bytebuff data written code selector code paramet null , perform busi write could take up lot cpu cycl . param buf byte buffer buffer contain data , we write long code ( buf . ha remain ( ) = = true ) code param socket socket channel socket write data param write timeout long timeout thi write oper millisecond , 1 mean timeout return int return number byte written throw eofexcept write return 1 throw socket timeout except write time out throw ioexcept io except occur underli socket logic int write ( byte buffer buf , nio channel socket , long write timeout , mutabl integ last write ) throw ioexcept { select kei kei = socket . get iochannel ( ) . kei ( socket . get poller ( ) . get selector ( ) ) ; ( kei = = null ) throw new ioexcept ( kei longer regist ) ; kei refer refer = new kei refer ( ) ; kei attach att = ( kei attach ) kei . attach ( ) ; int written = 0 ; boolean timedout = fals ; assum we can write int keycount = 1 ; start timeout timer long time = system . current time milli ( ) ; try { while ( ( timedout ) buf . ha remain ( ) ) { ( keycount 0 ) { onli write we were regist write write data int cnt = socket . write ( buf ) ; last write . set ( cnt ) ; ( cnt = = 1 ) throw new eofexcept ( ) ; written = cnt ; ( cnt 0 ) { reset our timeout timer time = system . current time milli ( ) ; we successfulli wrote , try again without selector continu ; } } try { ( att . get write latch ( ) = = null att . get write latch ( ) . get count ( ) = = 0 ) att . start write latch ( 1 ) ; poller . add ( att , select kei . op write , refer ) ; att . await write latch ( write timeout , time unit . millisecond ) ; } catch ( interrupt except ignor ) { thread . interrupt ( ) ; } ( att . get write latch ( ) = null att . get write latch ( ) . get count ( ) 0 ) { we got interrupt , we haven t receiv notif from poller . keycount = 0 ; } els { latch countdown ha happen keycount = 1 ; att . reset write latch ( ) ; } ( write timeout 0 ( keycount = = 0 ) ) timedout = ( system . current time milli ( ) time ) = write timeout ; } while ( timedout ) throw new socket timeout except ( ) ; } final { poller . remov ( att , select kei . op write ) ; ( timedout refer . kei = null ) { poller . cancel kei ( refer . kei ) ; } refer . kei = null ; } return written ; }	public static byte serial ( serializ msg ) throw ioexcept { byte arrai output stream out = new byte arrai output stream ( ) ; object output stream out = new object output stream ( out ) ; out . write object ( msg ) ; out . flush ( ) ; byte data = out . byte arrai ( ) ; return data ; }	public static byte byte ( boolean bool , byte data , int offset ) { data offset = ( byte ) ( bool 1 : 0 ) ; return data ; }	public static void set content type ( http servlet respons respons , int mode ) { ( mode = = 0 ) { respons . set content type ( text html ; charset = constant . charset ) ; } els ( mode = = 1 ) { respons . set content type ( text xml ; charset = constant . charset ) ; } }	public set file convert html param fileset fileset convert . void add fileset ( file set fs ) { fileset . add ( fs ) ; }	public reset buffer void clear ( ) { buf size = 0 ; }	public cluster member gone see org . apach . catalina . ha . membership listen member disappear ( org . apach . catalina . ha . member ) void member disappear ( member member ) { try { ha member = channel . ha member ( ) ; ( log . info enabl ( ) ) log . info ( receiv member disappear : member ) ; notifi our interest lifecycl listen lifecycl . fire lifecycl event ( befor memberunregist event , member ) ; notifi our interest lifecycl listen lifecycl . fire lifecycl event ( after memberunregist event , member ) ; } catch ( except x ) { log . error ( unabl remov cluster node from replic system . , x ) ; } }	public releas ani resourc alloc thi directori context . void releas ( ) { action taken default implement }	public remov notif event listen from thi mbean . param listen listen remov ( ani all registr thi listen elimin ) param filter filter object us filter event notif actual deliv , code null code filter param handback handback object sent along event notif except listen found except thi listen regist mbean void remov notif listen ( notif listen listen , notif filter filter , object handback ) throw listen found except { remov notif listen ( listen ) ; }	public long get recoveri sleep time ( ) { return recoveri sleep time ; }	cast standard context right awai , need later . see org . apach . catalina . contain set contain ( org . apach . catalina . contain ) overrid public void set contain ( contain contain ) { super . set contain ( contain ) ; context = ( standard context ) contain ; }	public p proxi header direct specifi header which mod remoteip collect list all intermedi client ip address trust resolv actual remot ip . note intermedi remot iptrust proxi address ar record thi header , while ani intermedi remot ipintern proxi address ar discard . p p name http header hold list trust proxi ha been travers http request . p p valu thi header can comma delimit . p p default valu : code x forward code p void set proxi header ( string proxi header ) { thi . proxi header = proxi header ; }	public p name http header from which remot ip extract . p p valu thi header can comma delimit . p p default valu : code x forward code p param remot iphead void set remot ip header ( string remot ip header ) { thi . remot ip header = remot ip header ; }	public set ssl inform thi http connect . void set sslsupport ( sslsupport ssl support ) { thi . ssl support = ssl support ; }	public void set todir ( file todir ) { thi . todir = todir ; }	} overrid public void stop ( ) { thi . stop listen ( ) ; super . stop ( ) ; }	perform miscellean check after node ar visit . void post check ( ) throw jasper except { check var . name from attribut ha valid valu . iter string iter = name from tabl . kei set ( ) . iter ( ) ; while ( iter . ha next ( ) ) { string name from = iter . next ( ) ; name entri name entri = name tabl . get ( name from ) ; name entri name from entri = name from tabl . get ( name from ) ; node name from node = name from entri . get node ( ) ; ( name entri = = null ) { err . jsp error ( name from node , jsp . error . tagfil . name from . attribut , name from ) ; } els { node node = name entri . get node ( ) ; tag attribut info tag attr = name entri . get tag attribut info ( ) ; ( java . lang . string . equal ( tag attr . get type name ( ) ) tag attr . requir ( ) tag attr . can request time ( ) ) { err . jsp error ( name from node , jsp . error . tagfil . name from . bad attribut , name from , integ . string ( node . get start ( ) . get line number ( ) ) ) ; } } } }
public standard context add context ( standard host host , string context path , string dir ) { silenc ( context path ) ; standard context ctx = new standard context ( ) ; ctx . set path ( context path ) ; ctx . set doc base ( dir ) ; ctx . add lifecycl listen ( new fix context listen ( ) ) ; ( host = = null ) { host = get host ( ) ; } host . add child ( ctx ) ; return ctx ; }	public standard context add webapp ( standard host host , string url , string path ) throw servlet except { silenc ( url ) ; standard context ctx = new standard context ( ) ; ctx . set path ( url ) ; ctx . set doc base ( path ) ; ( default realm = = null ) { init simpl auth ( ) ; } ctx . set realm ( default realm ) ; ctx . add lifecycl listen ( new default web xml listen ( ) ) ; context config ctx cfg = new context config ( ) ; ctx . add lifecycl listen ( ctx cfg ) ; prevent from look ( find ll have dup error ) ctx cfg . set default web xml ( org apach catalin startup default xml ) ; ( host = = null ) { host = get host ( ) ; } host . add child ( ctx ) ; return ctx ; }	public add webapp us normal web inf web . xml found . param context path param base dir return throw servlet except standard context add webapp ( string context path , string base dir ) throw servlet except { return add webapp ( get host ( ) , context path , base dir ) ; }	public add exist servlet context class . name initialis . param context path context add servlet param servlet name servlet name ( us map ) param servlet servlet add return wrapper servlet standard wrapper add servlet ( string context path , string servlet name , servlet servlet ) { contain ctx = get host ( ) . find child ( context path ) ; return add servlet ( ( standard context ) ctx , servlet name , servlet ) ; }	public add user memori realm . all creat app us thi default , can replac us set realm ( ) . void add user ( string user , string pass ) { user pass . put ( user , pass ) ; }	public provid default configur context . thi programmat equival default web . xml . todo : normal tomcat , default web . xml found , us thi method param context path context set default void init webapp default ( string context path ) { contain ctx = get host ( ) . find child ( context path ) ; init webapp default ( ( standard context ) ctx ) ; }	public hostnam default host , default localhost . void set hostnam ( string s ) { hostnam = s ; }
privat creat jk statu link ul li b load balanc exampl : b http : localhost statu cmd = updat mime = txt w = lb lf = fals ls = true li li b worker exampl : b http : localhost statu cmd = updat mime = txt w = node1 l = lb wf = 1 wd = fals ws = fals li ul return creat jkstatu link string builder creat link ( ) { build url string builder sb = new string builder ( ) ; try { sb . append ( cmd = updat mime = txt ) ; sb . append ( w = ) ; sb . append ( urlencod . encod ( worker , get charset ( ) ) ) ; ( lbmode ) { http : localhost statu cmd = updat mime = txt w = lb lf = fals ls = true ( ( lb retri = null ) ) { 0 sb . append ( lr = ) ; sb . append ( lb retri ) ; } ( ( lb recovertim = null ) ) { 59 sb . append ( lt = ) ; sb . append ( lb recovertim ) ; } ( ( lb sticki session = null ) ) { sb . append ( ls = ) ; sb . append ( lb sticki session ) ; } ( ( lb forc session = null ) ) { sb . append ( lf = ) ; sb . append ( lb forc session ) ; } } els { http : localhost statu cmd = updat mime = txt w = node1 l = lb wf = 1 wd = fals ws = fals ( ( worker lb = null ) ) { must configur sb . append ( l = ) ; sb . append ( urlencod . encod ( worker lb , get charset ( ) ) ) ; } ( ( worker load factor = null ) ) { = 1 sb . append ( wf = ) ; sb . append ( worker load factor ) ; } ( ( worker disabl = null ) ) { sb . append ( wd = ) ; sb . append ( worker disabl ) ; } ( ( worker stop = null ) ) { sb . append ( ws = ) ; sb . append ( worker stop ) ; } ( ( worker redirect = null ) ) { other worker conrect lb s sb . append ( wr = ) ; } ( ( worker cluster domain = null ) ) { sb . append ( wc = ) ; sb . append ( urlencod . encod ( worker cluster domain , get charset ( ) ) ) ; } } } catch ( unsupport encod except e ) { throw new build except ( invalid charset attribut : get charset ( ) ) ; } return sb ; }	privat static find method store within cach . param method cach cach us store method instanc param method name method appli secur restrict return method instanc , null yet creat . method find method ( method method cach , string method name ) { ( method name . equal ignor case ( init method ) method cach init = null ) { return method cach init ; } els ( method name . equal ignor case ( destroi method ) method cach destroi = null ) { return method cach destroi ; } els ( method name . equal ignor case ( servic method ) method cach servic = null ) { return method cach servic ; } els ( method name . equal ignor case ( dofilt method ) method cach dofilt = null ) { return method cach dofilt ; } els ( method name . equal ignor case ( event method ) method cach event = null ) { return method cach event ; } els ( method name . equal ignor case ( dofilterev method ) method cach dofilterev = null ) { return method cach dofilterev ; } return null ; }	privat static build thi list avail extens so we do have re build thi list everi time we iter through list requir extens . all avail extens all code mainfest resourc code object ad code hash map code which return first depend list process pass . kei name implement version . note : list built onli depend need check ( perform optim ) . param resourc list code manifest resourc code object return hash map map avail extens arrai list extens build avail extens list ( arrai list manifest resourc resourc ) { arrai list extens avail list = null ; iter manifest resourc = resourc . iter ( ) ; while ( . ha next ( ) ) { manifest resourc mre = . next ( ) ; arrai list extens list = mre . get avail extens ( ) ; ( list = null ) { iter extens valu = list . iter ( ) ; while ( valu . ha next ( ) ) { extens ext = valu . next ( ) ; ( avail list = = null ) { avail list = new arrai list extens ( ) ; avail list . add ( ext ) ; } els { avail list . add ( ext ) ; } } } } return avail list ; }	privat pars specifi express tree pars node . void pars express ( string expr ) throw pars except { string node curr string node = null ; we cheat littl start artifici group right awai . make finish easier . push opp ( null ) ; express token et = new express token ( expr ) ; while ( et . ha more token ( ) ) { int token = et . next token ( ) ; ( token = express token . token string ) curr string node = null ; switch ( token ) { case express token . token string : ( curr string node = = null ) { curr string node = new string node ( et . get token valu ( ) ) ; node stack . add ( 0 , curr string node ) ; } els { add exist curr string node . valu . append ( ) ; curr string node . valu . append ( et . get token valu ( ) ) ; } break ; case express token . token : push opp ( new node ( ) ) ; break ; case express token . token : push opp ( new node ( ) ) ; break ; case express token . token : push opp ( new node ( ) ) ; break ; case express token . token eq : push opp ( new equal node ( ) ) ; break ; case express token . token eq : push opp ( new node ( ) ) ; sneak regular node . resolv when next opp come along . opp stack . add ( 0 , new equal node ( ) ) ; break ; case express token . token rbrace : closeout current group resolv group ( ) ; break ; case express token . token lbrace : push group marker push opp ( null ) ; break ; case express token . token ge : push opp ( new node ( ) ) ; similar stategi eq abov , except thi less than opp stack . add ( 0 , new less than node ( ) ) ; break ; case express token . token le : push opp ( new node ( ) ) ; similar stategi eq abov , except thi greater than opp stack . add ( 0 , new greater than node ( ) ) ; break ; case express token . token gt : push opp ( new greater than node ( ) ) ; break ; case express token . token lt : push opp ( new less than node ( ) ) ; break ; case express token . token end : break ; } } finish off rest opp resolv group ( ) ; ( node stack . size ( ) = = 0 ) { throw new pars except ( node creat . , et . get index ( ) ) ; } ( node stack . size ( ) 1 ) { throw new pars except ( extra node creat . , et . get index ( ) ) ; } ( opp stack . size ( ) = 0 ) { throw new pars except ( unus opp node exist . , et . get index ( ) ) ; } root = node stack . get ( 0 ) ; }	privat propfind helper method . param req servlet request param resourc resourc object associ thi context param gener xml xml respons propfind request param path path current resourc param type propfind type param properti vector propfind type find properti name , thi vector contain those properti void pars properti ( http servlet request req , xmlwriter gener xml , string path , int type , vector string properti vector ) { ( upper case ( ) avoid problem window system ) ( path . upper case ( ) . start ( web inf ) path . upper case ( ) . start ( meta inf ) ) return ; cach entri cach entri = resourc . lookup cach ( path ) ; gener xml . write element ( null , respons , xmlwriter . open ) ; string statu = new string ( http 1 . 1 webdav statu . sc ok webdav statu . get statu text ( webdav statu . sc ok ) ) ; gener href element gener xml . write element ( null , href , xmlwriter . open ) ; string href = req . get context path ( ) req . get servlet path ( ) ; ( ( href . end ( ) ) ( path . start ( ) ) ) href = path . substr ( 1 ) ; els href = path ; ( ( cach entri . context = null ) ( href . end ( ) ) ) href = ; gener xml . write text ( rewrit url ( href ) ) ; gener xml . write element ( null , href , xmlwriter . close ) ; string resourc name = path ; int last slash = path . last index ( ) ; ( last slash = 1 ) resourc name = resourc name . substr ( last slash 1 ) ; switch ( type ) { case find all prop : gener xml . write element ( null , propstat , xmlwriter . open ) ; gener xml . write element ( null , prop , xmlwriter . open ) ; gener xml . write properti ( null , creationd , get isocr date ( cach entri . attribut . get creation ( ) ) ) ; gener xml . write element ( null , displaynam , xmlwriter . open ) ; gener xml . write data ( resourc name ) ; gener xml . write element ( null , displaynam , xmlwriter . close ) ; ( cach entri . resourc = null ) { gener xml . write properti ( null , getlastmodifi , fast http date format . format date ( cach entri . attribut . get last modifi ( ) , null ) ) ; gener xml . write properti ( null , getcontentlength , string . valu ( cach entri . attribut . get content length ( ) ) ) ; string content type = get servlet context ( ) . get mime type ( cach entri . name ) ; ( content type = null ) { gener xml . write properti ( null , getcontenttyp , content type ) ; } gener xml . write properti ( null , getetag , cach entri . attribut . get etag ( ) ) ; gener xml . write element ( null , resourcetyp , xmlwriter . content ) ; } els { gener xml . write element ( null , resourcetyp , xmlwriter . open ) ; gener xml . write element ( null , collect , xmlwriter . content ) ; gener xml . write element ( null , resourcetyp , xmlwriter . close ) ; } gener xml . write properti ( null , sourc , ) ; string support lock = lockentri lockscop exclus lockscop locktyp write locktyp lockentri lockentri lockscop share lockscop locktyp write locktyp lockentri ; gener xml . write element ( null , supportedlock , xmlwriter . open ) ; gener xml . write text ( support lock ) ; gener xml . write element ( null , supportedlock , xmlwriter . close ) ; gener lock discoveri ( path , gener xml ) ; gener xml . write element ( null , prop , xmlwriter . close ) ; gener xml . write element ( null , statu , xmlwriter . open ) ; gener xml . write text ( statu ) ; gener xml . write element ( null , statu , xmlwriter . close ) ; gener xml . write element ( null , propstat , xmlwriter . close ) ; break ; case find properti name : gener xml . write element ( null , propstat , xmlwriter . open ) ; gener xml . write element ( null , prop , xmlwriter . open ) ; gener xml . write element ( null , creationd , xmlwriter . content ) ; gener xml . write element ( null , displaynam , xmlwriter . content ) ; ( cach entri . resourc = null ) { gener xml . write element ( null , getcontentlanguag , xmlwriter . content ) ; gener xml . write element ( null , getcontentlength , xmlwriter . content ) ; gener xml . write element ( null , getcontenttyp , xmlwriter . content ) ; gener xml . write element ( null , getetag , xmlwriter . content ) ; gener xml . write element ( null , getlastmodifi , xmlwriter . content ) ; } gener xml . write element ( null , resourcetyp , xmlwriter . content ) ; gener xml . write element ( null , sourc , xmlwriter . content ) ; gener xml . write element ( null , lockdiscoveri , xmlwriter . content ) ; gener xml . write element ( null , prop , xmlwriter . close ) ; gener xml . write element ( null , statu , xmlwriter . open ) ; gener xml . write text ( statu ) ; gener xml . write element ( null , statu , xmlwriter . close ) ; gener xml . write element ( null , propstat , xmlwriter . close ) ; break ; case find properti : vector string properti found = new vector string ( ) ; pars list properti gener xml . write element ( null , propstat , xmlwriter . open ) ; gener xml . write element ( null , prop , xmlwriter . open ) ; enumer string properti = properti vector . element ( ) ; while ( properti . ha more element ( ) ) { string properti = properti . next element ( ) ; ( properti . equal ( creationd ) ) { gener xml . write properti ( null , creationd , get isocr date ( cach entri . attribut . get creation ( ) ) ) ; } els ( properti . equal ( displaynam ) ) { gener xml . write element ( null , displaynam , xmlwriter . open ) ; gener xml . write data ( resourc name ) ; gener xml . write element ( null , displaynam , xmlwriter . close ) ; } els ( properti . equal ( getcontentlanguag ) ) { ( cach entri . context = null ) { properti found . add element ( properti ) ; } els { gener xml . write element ( null , getcontentlanguag , xmlwriter . content ) ; } } els ( properti . equal ( getcontentlength ) ) { ( cach entri . context = null ) { properti found . add element ( properti ) ; } els { gener xml . write properti ( null , getcontentlength , ( string . valu ( cach entri . attribut . get content length ( ) ) ) ) ; } } els ( properti . equal ( getcontenttyp ) ) { ( cach entri . context = null ) { properti found . add element ( properti ) ; } els { gener xml . write properti ( null , getcontenttyp , get servlet context ( ) . get mime type ( cach entri . name ) ) ; } } els ( properti . equal ( getetag ) ) { ( cach entri . context = null ) { properti found . add element ( properti ) ; } els { gener xml . write properti ( null , getetag , cach entri . attribut . get etag ( ) ) ; } } els ( properti . equal ( getlastmodifi ) ) { ( cach entri . context = null ) { properti found . add element ( properti ) ; } els { gener xml . write properti ( null , getlastmodifi , fast http date format . format date ( cach entri . attribut . get last modifi ( ) , null ) ) ; } } els ( properti . equal ( resourcetyp ) ) { ( cach entri . context = null ) { gener xml . write element ( null , resourcetyp , xmlwriter . open ) ; gener xml . write element ( null , collect , xmlwriter . content ) ; gener xml . write element ( null , resourcetyp , xmlwriter . close ) ; } els { gener xml . write element ( null , resourcetyp , xmlwriter . content ) ; } } els ( properti . equal ( sourc ) ) { gener xml . write properti ( null , sourc , ) ; } els ( properti . equal ( supportedlock ) ) { support lock = lockentri lockscop exclus lockscop locktyp write locktyp lockentri lockentri lockscop share lockscop locktyp write locktyp lockentri ; gener xml . write element ( null , supportedlock , xmlwriter . open ) ; gener xml . write text ( support lock ) ; gener xml . write element ( null , supportedlock , xmlwriter . close ) ; } els ( properti . equal ( lockdiscoveri ) ) { ( gener lock discoveri ( path , gener xml ) ) properti found . add element ( properti ) ; } els { properti found . add element ( properti ) ; } } gener xml . write element ( null , prop , xmlwriter . close ) ; gener xml . write element ( null , statu , xmlwriter . open ) ; gener xml . write text ( statu ) ; gener xml . write element ( null , statu , xmlwriter . close ) ; gener xml . write element ( null , propstat , xmlwriter . close ) ; enumer string properti found list = properti found . element ( ) ; ( properti found list . ha more element ( ) ) { statu = new string ( http 1 . 1 webdav statu . sc found webdav statu . get statu text ( webdav statu . sc found ) ) ; gener xml . write element ( null , propstat , xmlwriter . open ) ; gener xml . write element ( null , prop , xmlwriter . open ) ; while ( properti found list . ha more element ( ) ) { gener xml . write element ( null , properti found list . next element ( ) , xmlwriter . content ) ; } gener xml . write element ( null , prop , xmlwriter . close ) ; gener xml . write element ( null , statu , xmlwriter . open ) ; gener xml . write text ( statu ) ; gener xml . write element ( null , statu , xmlwriter . close ) ; gener xml . write element ( null , propstat , xmlwriter . close ) ; } break ; } gener xml . write element ( null , respons , xmlwriter . close ) ; }	protect return uri convert . b2cconvert get uriconvert ( ) { return uriconvert ; }	protect byte serial delta request ( delta session session , delta request delta request ) throw ioexcept { try { session . lock ( ) ; return delta request . serial ( ) ; } final { session . unlock ( ) ; } }	return princip associ given user name . overrid protect princip get princip ( string usernam ) { dir context context = null ; princip princip = null ; try { ensur we have directori context avail context = open ( ) ; time befor give up . try { authent specifi usernam possibl princip = get princip ( context , usernam ) ; } catch ( commun except e ) { log except so we know s . contain log . warn ( sm . get string ( jndi realm . except ) , e ) ; close connect so we know reopen . ( context = null ) close ( context ) ; open new directori context . context = open ( ) ; try authent again . princip = get princip ( context , usernam ) ; } catch ( servic unavail except e ) { log except so we know s . contain log . warn ( sm . get string ( jndi realm . except ) , e ) ; close connect so we know reopen . ( context = null ) close ( context ) ; open new directori context . context = open ( ) ; try authent again . princip = get princip ( context , usernam ) ; } releas thi context releas ( context ) ; return authent princip ( ani ) return ( princip ) ; } catch ( name except e ) { log problem poster contain log . error ( sm . get string ( jndi realm . except ) , e ) ; close connect so get reopen next time ( context = null ) close ( context ) ; return authent thi request return ( null ) ; } }	protect convert blank string anoth string param could blank string convert necessari param sub blank string return instead blank string return non null string , either origin substitut string origin wa code null code empti ( ) string blank string ( string could blank , string sub blank ) { return ( ( . equal ( could blank ) could blank = = null ) sub blank : could blank ) ; }	protect string get path without file name ( string servlet path ) { string ret val = null ; int last slash = servlet path . last index ( ) ; ( last slash = 0 ) { cut off file name ret val = servlet path . substr ( 0 , last slash 1 ) ; } return ret val ; }	protect param jmx server connect param name throw except string jmx set ( mbean server connect jmx server connect , string name ) throw except { object real valu ; ( type = null ) { real valu = convert string type ( valu , type ) ; } els { ( convert ( ) ) { string m type = get mbean attribut type ( jmx server connect , name , attribut ) ; real valu = convert string type ( valu , m type ) ; } els real valu = valu ; } jmx server connect . set attribut ( new object name ( name ) , new attribut ( attribut , real valu ) ) ; return null ; }	protect reload web applic specifi context path . see manag servlet reload ( print writer , string ) param path context path applic restart return messag string string reload ( string path ) { string writer string writer = new string writer ( ) ; print writer print writer = new print writer ( string writer ) ; super . reload ( print writer , path ) ; return string writer . string ( ) ; }	protect check condit specifi option header ar satisfi . param request servlet request we ar process param respons servlet respons we ar creat param resourc attribut resourc inform return boolean true resourc meet all specifi condit , fals ani condit satisfi , which case request process stop boolean check header ( http servlet request request , http servlet respons respons , resourc attribut resourc attribut ) throw ioexcept { return check match ( request , respons , resourc attribut ) check modifi sinc ( request , respons , resourc attribut ) check none match ( request , respons , resourc attribut ) check unmodifi sinc ( request , respons , resourc attribut ) ; }	protect filter class . param name class name return true class should filter boolean filter ( string name ) { ( name = = null ) return fals ; look up packag string packag name = null ; int po = name . last index ( . ) ; ( po = 1 ) packag name = name . substr ( 0 , po ) ; els return fals ; ( int i = 0 ; i packag trigger . length ; i ) { ( packag name . start ( packag trigger i ) ) return true ; } return fals ; }	protect pars addit request paramet . boolean post pars request ( org . apach . coyot . request req , request request , org . apach . coyot . respons re , respons respons ) throw except { otherwis , us connector configur ( req . scheme ( ) . null ( ) ) { us processor specifi scheme determin secur state request . set secur ( req . scheme ( ) . equal ( http ) ) ; } els { us connector scheme secur configur , ( default http fals respect ) req . scheme ( ) . set string ( connector . get scheme ( ) ) ; request . set secur ( connector . get secur ( ) ) ; } fixm : code below doesnt belong here , thi onli have sens http11 , ajp13 . . thi point host header ha been process . overrid proxi port proxi host ar set string proxi name = connector . get proxi name ( ) ; int proxi port = connector . get proxi port ( ) ; ( proxi port = 0 ) { req . set server port ( proxi port ) ; } ( proxi name = null ) { req . server name ( ) . set string ( proxi name ) ; } pars session id befor decod remov path param pars session id ( req , request ) ; uri decod messag byte decod uri = req . decod uri ( ) ; decod uri . duplic ( req . request uri ( ) ) ; ( decod uri . get type ( ) = = messag byte . t byte ) { remov ani path paramet byte chunk uri bb = decod uri . get byte chunk ( ) ; int semicolon = uri bb . index ( ; , 0 ) ; ( semicolon 0 ) { decod uri . set byte ( uri bb . get buffer ( ) , uri bb . get start ( ) , semicolon ) ; } xx decod url try { req . get urldecod ( ) . convert ( decod uri , fals ) ; } catch ( ioexcept ioe ) { re . set statu ( 400 ) ; re . set messag ( invalid uri : ioe . get messag ( ) ) ; return fals ; } normal ( normal ( req . decod uri ( ) ) ) { re . set statu ( 400 ) ; re . set messag ( invalid uri ) ; return fals ; } charact decod convert uri ( decod uri , request ) ; check uri still normal ( check normal ( req . decod uri ( ) ) ) { re . set statu ( 400 ) ; re . set messag ( invalid uri charact encod ) ; return fals ; } } els { url char string , ha been sent us memori protocol handler , we have assum url ha been properli decod alreadi decod uri . char ( ) ; remov ani path paramet char chunk uri cc = decod uri . get char chunk ( ) ; int semicolon = uri cc . index ( ; ) ; ( semicolon 0 ) { decod uri . set char ( uri cc . get buffer ( ) , uri cc . get start ( ) , semicolon ) ; } } set remot princip string princip = req . get remot user ( ) . string ( ) ; ( princip = null ) { request . set user princip ( new coyot princip ( princip ) ) ; } set author type string authtyp = req . get auth type ( ) . string ( ) ; ( authtyp = null ) { request . set auth type ( authtyp ) ; } request map . messag byte server name ; ( connector . get us ipvhost ( ) ) { server name = req . local name ( ) ; ( server name . null ( ) ) { well , thei did ask re . action ( action code . action req local name attribut , null ) ; } } els { server name = req . server name ( ) ; } ( request . async start ( ) ) { todo servlet3 async reset map data , should prolli done elsewher request . get map data ( ) . recycl ( ) ; } connector . get mapper ( ) . map ( server name , decod uri , request . get map data ( ) ) ; request . set context ( ( context ) request . get map data ( ) . context ) ; request . set wrapper ( ( wrapper ) request . get map data ( ) . wrapper ) ; filter trace method ( connector . get allow trace ( ) req . method ( ) . equal ignor case ( trace ) ) { wrapper wrapper = request . get wrapper ( ) ; string header = null ; ( wrapper = null ) { string method = wrapper . get servlet method ( ) ; ( method = null ) { ( int i = 0 ; i method . length ; i ) { ( trace . equal ( method i ) ) { continu ; } ( header = = null ) { header = method i ; } els { header = , method i ; } } } } re . set statu ( 405 ) ; re . add header ( allow , header ) ; re . set messag ( trace method allow ) ; return fals ; } possibl redirect messag byte redirect path mb = request . get map data ( ) . redirect path ; ( redirect path mb . null ( ) ) { string redirect path = url encod . encod ( redirect path mb . string ( ) ) ; string queri = request . get queri string ( ) ; ( request . request session id from url ( ) ) { thi optim , thi veri common , shouldn t matter redirect path = redirect path ; global . session paramet name = request . get request session id ( ) ; } ( queri = null ) { thi optim , thi veri common , shouldn t matter redirect path = redirect path queri ; } respons . send redirect ( redirect path ) ; return fals ; } pars session id ( request . get servlet context ( ) . get effect session track mode ( ) . contain ( session track mode . url ) ) { we saw id url thi disabl remov can t handl when we pars url we don t have context point request . set request session id ( null ) ; request . set request session url ( fals ) ; } pars session cooki id ( req , request ) ; pars session ssl id ( request ) ; return true ; }	protect restor origin request from inform store our session . origin request longer present ( becaus session time out ) , return code fals code ; otherwis , return code true code . param request request restor param session session contain save inform boolean restor request ( request request , session session ) throw ioexcept { retriev remov save request object from our session save request save = ( save request ) session . get note ( constant . form request note ) ; session . remov note ( constant . form request note ) ; session . remov note ( constant . form princip note ) ; ( save = = null ) return ( fals ) ; modifi our current request reflect origin request . clear cooki ( ) ; iter cooki cooki = save . get cooki ( ) ; while ( cooki . ha next ( ) ) { request . add cooki ( cooki . next ( ) ) ; } mime header rmh = request . get coyot request ( ) . get mime header ( ) ; rmh . recycl ( ) ; boolean cachabl = get . equal ignor case ( save . get method ( ) ) head . equal ignor case ( save . get method ( ) ) ; iter string name = save . get header name ( ) ; while ( name . ha next ( ) ) { string name = name . next ( ) ; bz 43687 ( ( modifi sinc . equal ignor case ( name ) ( cachabl none match . equal ignor case ( name ) ) ) ) { iter string valu = save . get header valu ( name ) ; while ( valu . ha next ( ) ) { rmh . add valu ( name ) . set string ( valu . next ( ) ) ; } } } request . clear local ( ) ; iter local local = save . get local ( ) ; while ( local . ha next ( ) ) { request . add local ( local . next ( ) ) ; } request . get coyot request ( ) . get paramet ( ) . recycl ( ) ; request . get coyot request ( ) . get paramet ( ) . set queri string encod ( request . get connector ( ) . get uriencod ( ) ) ; ( post . equal ignor case ( save . get method ( ) ) ) { byte chunk bodi = save . get bodi ( ) ; ( bodi = null ) { request . get coyot request ( ) . action ( action code . action req set bodi replai , bodi ) ; set content type messag byte content type = messag byte . new instanc ( ) ; content type specifi , us default post string save content type = save . get content type ( ) ; ( save content type = = null ) { save content type = applic x www form urlencod ; } content type . set string ( save content type ) ; request . get coyot request ( ) . set content type ( content type ) ; } } request . get coyot request ( ) . method ( ) . set string ( save . get method ( ) ) ; request . get coyot request ( ) . queri string ( ) . set string ( save . get queri string ( ) ) ; request . get coyot request ( ) . request uri ( ) . set string ( save . get request uri ( ) ) ; return ( true ) ; }	protect boolean write ( select kei kei ) throw ioexcept { ( ( connect ( ) ) ( thi . socket channel = = null thi . data channel = = null ) ) { throw new ioexcept ( nio sender connect , thi should occur . ) ; } ( current = null ) { ( remain 0 ) { weve written everyth , we ar start new packag protect against buffer overwrit int byteswritten = udp base ( ) data channel . write ( writebuf ) : socket channel . write ( writebuf ) ; ( byteswritten = = 1 ) throw new eofexcept ( ) ; remain = byteswritten ; reset posit counter ( remain 0 ) { remain = 0 ; } } return ( remain = = 0 ) ; } messag send , we can consid complet return true ; }	protect return role associ gven user name . arrai list string get role ( string usernam ) { prepar statement stmt = null ; result set rs = null ; number tri numebr attempt connect databas dure thi login attempt ( we need open databas ) thi need rewritten wuth better pool support , exist code need signatur chang sinc prepar statement need cach connect . code below try twice sqlexcept so connect mai try open again . normal condit ( includ invalid login abov onli us onc . int number tri = 2 ; while ( number tri 0 ) { try { ensur we have open databas connect open ( ) ; try { accumul user s role arrai list string role list = new arrai list string ( ) ; stmt = role ( db connect , usernam ) ; rs = stmt . execut queri ( ) ; while ( rs . next ( ) ) { string role = rs . get string ( 1 ) ; ( null = role ) { role list . add ( role . trim ( ) ) ; } } rs . close ( ) ; rs = null ; return ( role list ) ; } final { ( rs = null ) { try { rs . close ( ) ; } catch ( sqlexcept e ) { contain log . warn ( sm . get string ( jdbc realm . abnorm close result set ) ) ; } } db connect . commit ( ) ; } } catch ( sqlexcept e ) { log problem poster contain log . error ( sm . get string ( jdbc realm . except ) , e ) ; close connect so get reopen next time ( db connect = null ) close ( db connect ) ; } number tri ; } return ( null ) ; }	return password associ given princip s user name . overrid protect synchron string get password ( string usernam ) { look up user s credenti string db credenti = null ; prepar statement stmt = null ; result set rs = null ; number tri numebr attempt connect databas dure thi login attempt ( we need open databas ) thi need rewritten wuth better pool support , exist code need signatur chang sinc prepar statement need cach connect . code below try twice sqlexcept so connect mai try open again . normal condit ( includ invalid login abov onli us onc . int number tri = 2 ; while ( number tri 0 ) { try { ensur we have open databas connect open ( ) ; try { stmt = credenti ( db connect , usernam ) ; rs = stmt . execut queri ( ) ; ( rs . next ( ) ) { db credenti = rs . get string ( 1 ) ; } rs . close ( ) ; rs = null ; ( db credenti = = null ) { return ( null ) ; } db credenti = db credenti . trim ( ) ; return db credenti ; } final { ( rs = null ) { try { rs . close ( ) ; } catch ( sqlexcept e ) { contain log . warn ( sm . get string ( jdbc realm . abnorm close result set ) ) ; } } db connect . commit ( ) ; } } catch ( sqlexcept e ) { log problem poster contain log . error ( sm . get string ( jdbc realm . except ) , e ) ; close connect so get reopen next time ( db connect = null ) close ( db connect ) ; } number tri ; } return ( null ) ; }	find specifi class our local repositori , possibl . found , throw code class found except code . param name name class load except class found except class wa found overrid public class find class ( string name ) throw class found except { ( log . debug enabl ( ) ) log . debug ( find class ( name ) ) ; cannot load anyth from local repositori class loader stop ( start ) { throw new class found except ( name ) ; } ( 1 ) permiss defin thi class when us secur manag ( secur manag = null ) { int i = name . last index ( . ) ; ( i = 0 ) { try { ( log . trace enabl ( ) ) log . trace ( secur manag . check packag definit ) ; secur manag . check packag definit ( name . substr ( 0 , i ) ) ; } catch ( except se ) { ( log . trace enabl ( ) ) log . trace ( except class found except , se ) ; throw new class found except ( name , se ) ; } } } ask our superclass locat thi class , possibl ( throw class found except found ) class clazz = null ; try { ( log . trace enabl ( ) ) log . trace ( find class intern ( name ) ) ; try { clazz = find class intern ( name ) ; } catch ( class found except cnfe ) { ( ha extern repositori ) { throw cnfe ; } } catch ( access control except ac ) { log . warn ( webapp class loader . find class intern ( name ) secur except : ac . get messag ( ) , ac ) ; throw new class found except ( name , ac ) ; } catch ( runtim except e ) { ( log . trace enabl ( ) ) log . trace ( runtim except rethrown , e ) ; throw e ; } ( ( clazz = = null ) ha extern repositori ) { try { clazz = super . find class ( name ) ; } catch ( access control except ac ) { log . warn ( webapp class loader . find class intern ( name ) secur except : ac . get messag ( ) , ac ) ; throw new class found except ( name , ac ) ; } catch ( runtim except e ) { ( log . trace enabl ( ) ) log . trace ( runtim except rethrown , e ) ; throw e ; } } ( clazz = = null ) { ( log . debug enabl ( ) ) log . debug ( return class found except ) ; throw new class found except ( name ) ; } } catch ( class found except e ) { ( log . trace enabl ( ) ) log . trace ( pass class found except ) ; throw e ; } return class we have locat ( log . trace enabl ( ) ) log . debug ( return class clazz ) ; ( log . trace enabl ( ) ) { class loader cl ; ( global . secur enabl ) { cl = access control . do privileg ( new privileg get class loader ( clazz ) ) ; } els { cl = clazz . get class loader ( ) ; } log . debug ( load cl . string ( ) ) ; } return ( clazz ) ; }	protect chang request session id param request current request param respons current respons param session id origin session id param new session id new session id node migrat void chang request session id ( request request , respons respons , string session id , string new session id ) { request . set request session id ( new session id ) ; ( request . request session id from cooki ( ) ) set new session cooki ( request , respons , new session id ) ; chang ( session id attribut = null . equal ( session id attribut ) ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jvm rout . set . orignalsessionid , session id attribut , session id ) ) ; } request . set attribut ( session id attribut , session id ) ; } }	protect chang session id send all cluster node param request current request param respons current respons param session id origin session id param new session id new session id node migrat param catalina session current session origin session id void chang session id ( request request , respons respons , string session id , string new session id , session catalina session ) { lifecycl . fire lifecycl event ( befor session migrat , catalina session ) ; fixm : set id trigger session listen , onli chanc registiert manag correct id catalina session . set id ( new session id ) ; set id also trigger reset delta request ( catalina session instanceof delta session ) ( ( delta session ) catalina session ) . reset delta request ( ) ; chang request session id ( request , respons , session id , new session id ) ; ( get cluster ( ) = null ) { now send chang all other clusternod cluster manag manag = ( cluster manag ) catalina session . get manag ( ) ; send session idclust backup ( manag , request , session id , new session id ) ; } lifecycl . fire lifecycl event ( after session migrat , catalina session ) ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jvm rout . chang session , session id , new session id ) ) ; } }	protect ask redirector close all stream . necessari call thi method befor leav task have stream flush content . you ar collect output properti , creat onli thi method call , otherwis you ll find unset . void close redirector ( ) { try { ( redirect output ) { redirector . complet ( ) ; } } catch ( ioexcept ioe ) { log ( error close redirector : ioe . get messag ( ) , project . msg err ) ; } due depend chain , ant could call task more than onc , thi prevent we attempt reus previuosli close stream . redirect out stream = null ; redirect out print stream = null ; redirect err stream = null ; redirect err print stream = null ; }	protect close socket see data sender disconnect ( ) see data sender close socket ( ) void close socket ( ) { ( connect ( ) ) { ( socket = null ) { try { socket . close ( ) ; } catch ( ioexcept x ) { } final { socket = null ; so out = null ; so = null ; } } set request count ( 0 ) ; set connect ( fals ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( idata sender . close socket , get address ( ) . get host address ( ) , new integ ( get port ( ) ) , new long ( 0 ) ) ) ; } }	protect creat mbean specifi connector nest compon . param connector connector which creat mbean except except except thrown dure mbean creation void creat mbean ( connector connector ) throw except { creat mbean connnector itself ( log . debug enabl ( ) ) log . debug ( creat mbean connector connector ) ; mbean util . creat mbean ( connector ) ; }	protect creat result properti name from attribut resultproperti param result result see creat properti ( string , object ) void creat properti ( object result ) { ( resultproperti = null ) { creat properti ( resultproperti , result ) ; } }	protect actual code which drain channel associ given kei . thi method assum kei ha been modifi prior invoc turn off select interest op read . when thi method complet re enabl op read call wakeup ( ) selector so selector resum watch thi channel . void drain socket ( ) throw except { input stream = socket . get input stream ( ) ; loop while data avail , channel non block byte buf = new byte 1024 ; int length = . read ( buf ) ; while ( length = 0 ) { int count = reader . append ( buf , 0 , length , true ) ; ( count 0 ) execut ( reader ) ; length = . read ( buf ) ; } }	protect call forward error page param request request we ar process param respons respons we ar creat param config login configur describ how authent should perform void forward error page ( request request , respons respons , login config config ) { request dispatch disp = context . get servlet context ( ) . get request dispatch ( config . get error page ( ) ) ; try { disp . forward ( request . get request ( ) , respons . get respons ( ) ) ; } catch ( throwabl t ) { log . warn ( unexpect error forward error page , t ) ; } }	handl error output err prioriti flush stream . param output error output log . should code null code . overrid protect void handl error flush ( string output ) { handl error output ( output ) ; redirect err print stream . flush ( ) ; }	protect handl output err prioriti error stream all other pritor output stream . param output output log . should code null code . void handl output ( string output , int prioriti ) { ( prioriti = = project . msg err ) { handl error output ( output ) ; } els { handl output ( output ) ; } }	protect push messag onli socket time wait ack need make auto retri when write messag fail . after send error close reopen socket again . after successful send updat stat warn : subclass must veri careful onli thread call thi push messag onc see close socket ( ) see open socket ( ) see write data ( channel messag ) param data data send sinc 5 . 5 . 10 void push messag ( byte data , boolean reconnect , boolean wait ack ) throw ioexcept { keepal ( ) ; ( reconnect ) close socket ( ) ; ( connect ( ) ) open socket ( ) ; so out . write ( data ) ; so out . flush ( ) ; ( wait ack ) wait ack ( ) ; sender state . get sender state ( get destin ( ) ) . set readi ( ) ; }	protect send all chang cross context session backup param contain cluster void send cross context session ( catalina cluster contain cluster ) { object session = cross context session . get ( ) ; ( session = null session instanceof list ( ( list session ) session ) . size ( ) 0 ) { ( iter session iter = ( ( list session ) session ) . iter ( ) ; iter . ha next ( ) ; ) { session session = iter . next ( ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( replic valv . cross context . send delta , session . get manag ( ) . get contain ( ) . get name ( ) ) ) ; send messag ( session , ( cluster manag ) session . get manag ( ) , contain cluster ) ; ( do statist ( ) ) { nr cross context send request ; } } } }	protect write system os jvm properti . param writer writer render void serverinfo ( print writer writer ) { ( debug = 1 ) log ( serverinfo ) ; try { string builder prop = new string builder ( ) ; prop . append ( ok server info ) ; prop . append ( n tomcat version : ) ; prop . append ( server info . get server info ( ) ) ; prop . append ( n os name : ) ; prop . append ( system . get properti ( os . name ) ) ; prop . append ( n os version : ) ; prop . append ( system . get properti ( os . version ) ) ; prop . append ( n os architectur : ) ; prop . append ( system . get properti ( os . arch ) ) ; prop . append ( n jvm version : ) ; prop . append ( system . get properti ( java . runtim . version ) ) ; prop . append ( n jvm vendor : ) ; prop . append ( system . get properti ( java . vm . vendor ) ) ; writer . println ( prop . string ( ) ) ; } catch ( throwabl t ) { get servlet context ( ) . log ( manag servlet . serverinfo , t ) ; writer . println ( sm . get string ( manag servlet . except , t . string ( ) ) ) ; } }	protect send session expir other cluster node param id session id void session expir ( string id ) { counter send evt session expir ; session messag msg = new session messag impl ( get name ( ) , session messag . evt session expir , null , id , id expir msg ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( delta manag . creat messag . expir , get name ( ) , id ) ) ; send ( msg ) ; }	protect string find cgi ( string path info , string web app root dir , string context path , string servlet path , string cgi path prefix ) { string path = null ; string name = null ; string scriptnam = null ; string cginam = ; ( ( web app root dir = null ) ( web app root dir . last index ( file . separ ) = = ( web app root dir . length ( ) 1 ) ) ) { strip trail from web app root dir web app root dir = web app root dir . substr ( 0 , ( web app root dir . length ( ) 1 ) ) ; } ( cgi path prefix = null ) { web app root dir = web app root dir file . separ cgi path prefix ; } ( debug = 2 ) { log ( find cgi : path = path info , web app root dir ) ; } file current locat = new file ( web app root dir ) ; string token dir walker = new string token ( path info , ) ; ( debug = 3 ) { log ( find cgi : current loc = current locat ) ; } while ( current locat . file ( ) dir walker . ha more element ( ) ) { ( debug = 3 ) { log ( find cgi : current loc = current locat ) ; } string next element = ( string ) dir walker . next element ( ) ; current locat = new file ( current locat , next element ) ; cginam = cginam next element ; } ( current locat . file ( ) ) { return new string { null , null , null , null } ; } els { ( debug = 2 ) { log ( find cgi : found cgi current locat ) ; } path = current locat . get absolut path ( ) ; name = current locat . get name ( ) ; ( . . equal ( context path ) ) { scriptnam = servlet path ; } els { scriptnam = context path servlet path ; } ( servlet path . equal ( cginam ) ) { scriptnam = scriptnam cginam ; } } ( debug = 1 ) { log ( find cgi calc : name = name , path = path , scriptnam = scriptnam , cginam = cginam ) ; } return new string { path , scriptnam , cginam , name } ; }	protect void setup socket ( ) throw ioexcept { ( mcast bind address = null ) { try { log . info ( attempt bind multicast socket address : port ) ; socket = new multicast socket ( new inet socket address ( address , port ) ) ; } catch ( bind except e ) { some plattform ( e . g . linux ) possibl bind multicast address . thi case onli bind port . log . info ( bind multicast address , fail . bind port onli . ) ; socket = new multicast socket ( port ) ; } } els { socket = new multicast socket ( port ) ; } hint we want disabl loop back ( local machin ) messag socket . set loopback mode ( local loopback disabl ) ; ( mcast bind address = null ) { ( log . info enabl ( ) ) log . info ( set multihom multicast interfac : mcast bind address ) ; socket . set interfac ( mcast bind address ) ; } forc so timeout so we don t block forev ( mcast so timeout = 0 ) mcast so timeout = ( int ) send frequenc ; ( log . info enabl ( ) ) log . info ( set cluster mcast so timeout mcast so timeout ) ; socket . set so timeout ( mcast so timeout ) ; ( mcast ttl = 0 ) { ( log . info enabl ( ) ) log . info ( set cluster mcast ttl mcast ttl ) ; socket . set time live ( mcast ttl ) ; } }	public input sourc resolv entiti ( string public id , string system id ) { context . log ( sm . get string ( webdavservlet . entern entiti ignor , public id , system id ) ) ; return new input sourc ( new string reader ( ignor extern entiti ) ) ; }	public return set { link group } s defin thi user databas . iter group get group ( ) { synchron ( group ) { return ( group . valu ( ) . iter ( ) ) ; } }	public cooki get cooki ( ) { ( cooki pars ) pars cooki ( ) ; return cooki ; }	return code princip code associ specifi usernam credenti , ; otherwis return code null code . param usernam usernam code princip code look up param credenti password other credenti us authent thi usernam overrid public princip authent ( string usernam , string credenti ) { return authent ( usernam , new jaascallback handler ( thi , usernam , credenti ) ) ; }	public cooki get cooki ( ) { ( request = = null ) { throw new illeg state except ( sm . get string ( request facad . null request ) ) ; } cooki ret = null ; clone return arrai onli secur manag place , so perform won t suffer nonsecur case ( secur util . packag protect enabl ( ) ) { ret = access control . do privileg ( new get cooki privileg action ( ) ) ; ( ret = null ) { ret = ret . clone ( ) ; } } els { ret = request . get cooki ( ) ; } return ret ; }	public map string , string get paramet map ( ) { ( request = = null ) { throw new illeg state except ( sm . get string ( request facad . null request ) ) ; } ( global . secur enabl ) { return access control . do privileg ( new get paramet map privileg action ( ) ) ; } els { return request . get paramet map ( ) ; } }	public set session id attribut fail node request . return return session id attribut . string get session id attribut ( ) { return session id attribut ; }	execut specifi command , base configur properti . input stream close upon complet thi task , whether wa execut successfulli . except except error occur overrid public string jmx execut ( mbean server connect jmx server connect ) throw except { ( get name ( ) = = null ) { throw new build except ( must specifi name ) ; } return jmx queri ( jmx server connect , get name ( ) ) ; }	public string pad left ( string str , int max char ) { string result = str ; int char add = max char str . length ( ) ; ( char add 0 ) { result = repeat ( , char add ) str ; } return result ; }	public see set heartbeat ( boolean ) return boolean boolean get heartbeat ( ) { return heartbeat ; }	return code true code specifi princip ha specifi secur role , within context thi realm ; otherwis return code fals code . thi method can overridden realm implement , default adequ when instanc code gener princip code us repres authent princip from thi realm . param princip princip whom role check param role secur role check boolean ha role ( princip princip , string role ) { should overriten jaasrealm avoid pretti ineffici convers ( ( princip = = null ) ( role = = null ) ( princip instanceof gener princip ) ) return ( fals ) ; gener princip gp = ( gener princip ) princip ; boolean result = gp . ha role ( role ) ; ( log . debug enabl ( ) ) { string name = princip . get name ( ) ; ( result ) log . debug ( sm . get string ( realm base . ha role success , name , role ) ) ; els log . debug ( sm . get string ( realm base . ha role failur , name , role ) ) ; } return ( result ) ; }	public boolean access ( ) { return thi . access ; }	public get valu resolv host flag . boolean resolv host ( ) { return resolv host ; }	public return code true code authent user princip possess specifi role name . param role role name valid boolean user role ( string role ) { have we got authent princip all ( user princip = = null ) return ( fals ) ; identifi realm we us check role assignmenet ( context = = null ) return ( fals ) ; realm realm = context . get realm ( ) ; ( realm = = null ) return ( fals ) ; check role alia defin secur role ref element ( wrapper = null ) { string real role = wrapper . find secur refer ( role ) ; ( ( real role = null ) realm . ha role ( user princip , real role ) ) return ( true ) ; } check role defin directli secur role return ( realm . ha role ( user princip , role ) ) ; }	overrid public boolean keepal ( ) { boolean result = fals ; ( iter entri member , nio sender >> i = nio sender . entri set ( ) . iter ( ) ; i . ha next ( ) ; ) { map . entri member , nio sender entri = i . next ( ) ; nio sender sender = entri . get valu ( ) ; ( sender . keepal ( ) ) { nio sender . remov ( entri . get kei ( ) ) ; i . remov ( ) ; result = true ; } els { try { sender . read ( null ) ; } catch ( ioexcept x ) { sender . disconnect ( ) ; sender . reset ( ) ; nio sender . remov ( entri . get kei ( ) ) ; i . remov ( ) ; result = true ; } catch ( except x ) { log . warn ( error dure keepal test sender : sender , x ) ; } } } clean up ani cancel kei ( result ) try { selector . select now ( ) ; } catch ( except ignor ) { } return result ; }	public phase 1 authent code subject code . return code true code authent succeed , code fals code thi code login modul code should ignor except login except authent fail boolean login ( ) throw login except { set up our callback handler request ( callback handler = = null ) throw new login except ( callback handler specifi ) ; callback callback = new callback 9 ; callback 0 = new name callback ( usernam : ) ; callback 1 = new password callback ( password : , fals ) ; callback 2 = new text input callback ( nonc ) ; callback 3 = new text input callback ( nc ) ; callback 4 = new text input callback ( cnonc ) ; callback 5 = new text input callback ( qop ) ; callback 6 = new text input callback ( realm name ) ; callback 7 = new text input callback ( md5a2 ) ; callback 8 = new text input callback ( auth method ) ; interact user retriev usernam password string usernam = null ; string password = null ; string nonc = null ; string nc = null ; string cnonc = null ; string qop = null ; string realm name = null ; string md5a2 = null ; string auth method = null ; try { callback handler . handl ( callback ) ; usernam = ( ( name callback ) callback 0 ) . get name ( ) ; password = new string ( ( ( password callback ) callback 1 ) . get password ( ) ) ; nonc = ( ( text input callback ) callback 2 ) . get text ( ) ; nc = ( ( text input callback ) callback 3 ) . get text ( ) ; cnonc = ( ( text input callback ) callback 4 ) . get text ( ) ; qop = ( ( text input callback ) callback 5 ) . get text ( ) ; realm name = ( ( text input callback ) callback 6 ) . get text ( ) ; md5a2 = ( ( text input callback ) callback 7 ) . get text ( ) ; auth method = ( ( text input callback ) callback 8 ) . get text ( ) ; } catch ( ioexcept e ) { throw new login except ( e . string ( ) ) ; } catch ( unsupport callback except e ) { throw new login except ( e . string ( ) ) ; } valid usernam password we have receiv ( auth method = = null ) { basic form princip = super . authent ( usernam , password ) ; } els ( auth method . equal ( constant . digest method ) ) { princip = super . authent ( usernam , password , nonc , nc , cnonc , qop , realm name , md5a2 ) ; } els ( auth method . equal ( constant . cert method ) ) { princip = super . get princip ( usernam ) ; } els { throw new login except ( unknown authent method ) ; } log . debug ( login usernam princip ) ; report result base success failur ( princip = null ) { return ( true ) ; } els { throw new fail login except ( usernam password incorrect ) ; } }	public return maximum number activ session allow , 1 limit . int get max activ session ( ) { return ( thi . max activ session ) ; }	public return maximum number activ session allow , 1 limit . int get max activ session ( ) { return ( thi . max activ session ) ; }	public get number requir extens return number requir extens int get requir extens count ( ) { return ( requir extens = null ) requir extens . size ( ) : 0 ; }	overrid public int read line ( byte b , int off , int len ) throw ioexcept { return super . read line ( b , off , len ) ; }	protect compar session get compar ( string sort ) { compar session compar = null ; ( creation time . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session . get creation time ( ) ) ; } } ; } els ( id . equal ignor case ( sort ) ) { compar = new base session compar string ( ) { overrid public compar string get compar object ( session session ) { return session . get id ( ) ; } } ; } els ( last access time . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session . get last access time ( ) ) ; } } ; } els ( max inact interv . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session . get max inact interv ( ) ) ; } } ; } els ( new . equal ignor case ( sort ) ) { compar = new base session compar boolean ( ) { overrid public compar boolean get compar object ( session session ) { return boolean . valu ( session . get session ( ) . new ( ) ) ; } } ; } els ( local . equal ignor case ( sort ) ) { compar = new base session compar string ( ) { overrid public compar string get compar object ( session session ) { return jsp helper . guess displai local from session ( session ) ; } } ; } els ( user . equal ignor case ( sort ) ) { compar = new base session compar string ( ) { overrid public compar string get compar object ( session session ) { return jsp helper . guess displai user from session ( session ) ; } } ; } els ( us time . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session util . get us time session ( session ) ) ; } } ; } els ( inact time . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session util . get inact time session ( session ) ) ; } } ; } els ( ttl . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { overrid public compar date get compar object ( session session ) { return new date ( session util . get ttlfor session ( session ) ) ; } } ; } todo : complet thi ttl , etc . return compar ; }	public static decod return specifi url encod byte arrai . param byte url encod byte arrai param enc encod us ; null , default encod us param queri thi queri string process except illeg argument except charact follow valid 2 digit hexadecim number string urldecod ( byte byte , string enc , boolean queri ) { ( byte = = null ) return ( null ) ; int len = byte . length ; int ix = 0 ; int ox = 0 ; while ( ix len ) { get byte test byte b = byte ix ; ( b = = queri ) { b = ( byte ) ; } els ( b = = ) { b = ( byte ) ( ( convert hex digit ( byte ix ) << 4 ) convert hex digit ( byte ix ) ) ; } byte ox = b ; } ( enc = null ) { try { return new string ( byte , 0 , ox , enc ) ; } catch ( except e ) { e . print stack trace ( ) ; } } return new string ( byte , 0 , ox ) ; }	public static byte encod ( byte binari data ) { int length data bit = binari data . length eightbit ; int fewer than24bit = length data bit twentyfourbitgroup ; int number triplet = length data bit twentyfourbitgroup ; byte encod data = null ; ( fewer than24bit = 0 ) { data divis 24 bit encod data = new byte ( number triplet 1 ) 4 ; } els { 16 8 bit encod data = new byte number triplet 4 ; } byte k = 0 , l = 0 , b1 = 0 , b2 = 0 , b3 = 0 ; int encod index = 0 ; int data index = 0 ; int i = 0 ; log . debug ( number triplet = number triplet ) ; ( i = 0 ; i number triplet ; i ) { data index = i 3 ; b1 = binari data data index ; b2 = binari data data index 1 ; b3 = binari data data index 2 ; log . debug ( b1 = b1 , b2 = b2 , b3 = b3 ) ; l = ( byte ) ( b2 0x0f ) ; k = ( byte ) ( b1 0x03 ) ; encod index = i 4 ; byte val1 = ( ( b1 sign ) = = 0 ) ( byte ) ( b1 >> 2 ) : ( byte ) ( ( b1 ) >> 2 0xc0 ) ; byte val2 = ( ( b2 sign ) = = 0 ) ( byte ) ( b2 >> 4 ) : ( byte ) ( ( b2 ) >> 4 0xf0 ) ; byte val3 = ( ( b3 sign ) = = 0 ) ( byte ) ( b3 >> 6 ) : ( byte ) ( ( b3 ) >> 6 0xfc ) ; encod data encod index = look up base64alphabet val1 ; log . debug ( val2 = val2 ) ; log . debug ( k4 = ( k << 4 ) ) ; log . debug ( vak = ( val2 ( k << 4 ) ) ) ; encod data encod index 1 = look up base64alphabet val2 ( k << 4 ) ; encod data encod index 2 = look up base64alphabet ( l << 2 ) val3 ; encod data encod index 3 = look up base64alphabet b3 0x3f ; } form integr number 6 bit group data index = i 3 ; encod index = i 4 ; ( fewer than24bit = = eightbit ) { b1 = binari data data index ; k = ( byte ) ( b1 0x03 ) ; log . debug ( b1 = b1 ) ; log . debug ( b1 << 2 = ( b1 >> 2 ) ) ; byte val1 = ( ( b1 sign ) = = 0 ) ( byte ) ( b1 >> 2 ) : ( byte ) ( ( b1 ) >> 2 0xc0 ) ; encod data encod index = look up base64alphabet val1 ; encod data encod index 1 = look up base64alphabet k << 4 ; encod data encod index 2 = pad ; encod data encod index 3 = pad ; } }	public static synchron boolean valid applic ( dir context dir context , standard context context ) throw ioexcept { string app name = context . get path ( ) ; arrai list manifest resourc app manifest resourc = new arrai list manifest resourc ( ) ; therefor valid ( dir context = = null ) return fals ; find manifest web applicaiton input stream input stream = null ; try { name enumer bind wne = dir context . list bind ( meta inf ) ; bind bind = wne . next element ( ) ; ( bind . get name ( ) . upper case ( ) . equal ( manifest . mf ) ) { resourc resourc = ( resourc ) dir context . lookup ( meta inf bind . get name ( ) ) ; input stream = resourc . stream content ( ) ; manifest manifest = new manifest ( input stream ) ; input stream . close ( ) ; input stream = null ; manifest resourc mre = new manifest resourc ( sm . get string ( extens valid . web applic manifest ) , manifest , manifest resourc . war ) ; app manifest resourc . add ( mre ) ; } } catch ( name except nex ) { applic doe contain manifest . mf file } catch ( element except nse ) { applic doe contain manifest . mf file } final { ( input stream = null ) { try { input stream . close ( ) ; } catch ( throwabl t ) { ignor } } } locat manifest all bundl jar name enumer bind ne = null ; try { ne = dir context . list bind ( web inf lib ) ; while ( ( ne = null ) ne . ha more element ( ) ) { bind bind = ne . next element ( ) ; ( bind . get name ( ) . lower case ( ) . end ( . jar ) ) { continu ; } object obj = dir context . lookup ( web inf lib bind . get name ( ) ) ; ( ( obj instanceof resourc ) ) { probabl directori name xxx . jar ignor continu ; } resourc resourc = ( resourc ) obj ; manifest jmanifest = get manifest ( resourc . stream content ( ) ) ; ( jmanifest = null ) { manifest resourc mre = new manifest resourc ( bind . get name ( ) , jmanifest , manifest resourc . applic ) ; app manifest resourc . add ( mre ) ; } } } catch ( name except nex ) { jump out check thi applic becaus ha resourc } return valid manifest resourc ( app name , app manifest resourc ) ; }	public static check see given system jar file contain manifest , add contain s manifest resourc . param jar file system jar whose manifest add void add system resourc ( file jar file ) throw ioexcept { manifest manifest = get manifest ( new file input stream ( jar file ) ) ; ( manifest = null ) { manifest resourc mre = new manifest resourc ( jar file . get absolut path ( ) , manifest , manifest resourc . system ) ; contain manifest resourc . add ( mre ) ; } }	public static perform work particular code subject code . here work grant code null code subject . param method name method appli secur restrict param target object code filter code which method call . param target type code class code arrai us instanci code method code object . param target argument code object code arrai contain runtim paramet instanc . param princip code princip code which secur privileg appli void do privileg ( final string method name , final filter target object , final class target type , final object target argument , princip princip ) throw java . lang . except { method method = null ; method method cach = null ; ( object cach . contain kei ( target object ) ) { method cach = object cach . get ( target object ) ; method = find method ( method cach , method name ) ; ( method = = null ) { method = creat method cach ( method cach , method name , target object , target type ) ; } } els { method = creat method cach ( method cach , method name , target object , target type ) ; } execut ( method , target object , target argument , princip ) ; }	return princip associ specifi usernam credenti , ; otherwis return code null code . ar ani error jdbc connect , execut queri anyth we return null ( don t authent ) . thi event also log , connect close so subsequ request automat re open . param usernam usernam princip look up param credenti password other credenti us authent thi usernam overrid public synchron princip authent ( string usernam , string credenti ) { number tri numebr attempt connect databas dure thi login attempt ( we need open databas ) thi need rewritten wuth better pool support , exist code need signatur chang sinc prepar statement need cach connect . code below try twice sqlexcept so connect mai try open again . normal condit ( includ invalid login abov onli us onc . int number tri = 2 ; while ( number tri 0 ) { try { ensur we have open databas connect open ( ) ; acquir princip object thi user princip princip = authent ( db connect , usernam , credenti ) ; return princip ( ani ) return ( princip ) ; } catch ( sqlexcept e ) { log problem poster contain log . error ( sm . get string ( jdbc realm . except ) , e ) ; close connect so get reopen next time ( db connect = null ) close ( db connect ) ; } number tri ; } worst case scenario return null ; }	public synchron void send messag ( member destin , channel messag msg ) throw channel except { long start = system . current time milli ( ) ; thi . set udp base ( ( msg . get option ( ) channel . send option udp ) = = channel . send option udp ) ; byte data = xbyte buffer . creat data packag ( ( channel data ) msg ) ; nio sender sender = setup send ( destin ) ; connect ( sender ) ; set data ( sender , data ) ; int remain = sender . length ; channel except cx = null ; try { loop until complet , error happen , we timeout long delta = system . current time milli ( ) start ; boolean wait ack = ( channel . send option us ack msg . get option ( ) ) = = channel . send option us ack ; while ( ( remain 0 ) ( delta get timeout ( ) ) ) { try { remain = do loop ( select timeout , get max retri attempt ( ) , wait ack , msg ) ; } catch ( except x ) { int faulti = ( cx = = null ) 0 : cx . get faulti member ( ) . length ; ( cx = = null ) { ( x instanceof channel except ) cx = ( channel except ) x ; els cx = new channel except ( parallel nio send fail . , x ) ; } els { ( x instanceof channel except ) cx . add faulti member ( ( ( channel except ) x ) . get faulti member ( ) ) ; } count down remain error ( faulti cx . get faulti member ( ) . length ) remain = ( cx . get faulti member ( ) . length faulti ) ; } bail out all remain sender ar fail ( cx = null cx . get faulti member ( ) . length = = remain ) throw cx ; delta = system . current time milli ( ) start ; } ( remain 0 ) { timeout ha occur channel except cxtimeout = new channel except ( oper ha time out ( get timeout ( ) ms . ) . ) ; ( cx = = null ) cx = new channel except ( oper ha time out ( get timeout ( ) ms . ) . ) ; ( int i = 0 ; i sender . length ; i ) { ( sender i . complet ( ) ) cx . add faulti member ( sender i . get destin ( ) , cxtimeout ) ; } throw cx ; } els ( cx = null ) { wa error throw cx ; } } catch ( except x ) { try { thi . disconnect ( ) ; } catch ( except ignor ) { } ( x instanceof channel except ) throw ( channel except ) x ; els throw new channel except ( x ) ; } }	public void add ( member member ) { op , sender creat upon deman }	add specifi cooki those includ thi respons . param cooki cooki ad public void add cooki intern ( final cooki cooki ) { ( commit ( ) ) return ; final string buffer sb = new string buffer ( ) ; web applic code can receiv illeg argument except from append cooki valu invok ( secur util . packag protect enabl ( ) ) { access control . do privileg ( new privileg action void ( ) { } } }	protect access log element creat log element ( ) { list access log element list = new arrai list access log element ( ) ; boolean replac = fals ; string builder buf = new string builder ( ) ; ( int i = 0 ; i pattern . length ( ) ; i ) { char ch = pattern . char ( i ) ; ( replac ) { code process { , behavior . . . i do enount close } i ignor { ( { = = ch ) { string builder name = new string builder ( ) ; int j = i 1 ; ( ; j pattern . length ( ) } = pattern . char ( j ) ; j ) { name . append ( pattern . char ( j ) ) ; } ( j 1 pattern . length ( ) ) { 1 wa account } which we increment now j ; list . add ( creat access log element ( name . string ( ) , pattern . char ( j ) ) ) ; i = j ; sinc we walk more than charact } els { d oh end string pretend we never did thi do process old wai list . add ( creat access log element ( ch ) ) ; } } els { list . add ( creat access log element ( ch ) ) ; } replac = fals ; } els ( ch = = ) { replac = true ; list . add ( new string element ( buf . string ( ) ) ) ; buf = new string builder ( ) ; } els { buf . append ( ch ) ; } } ( buf . length ( ) 0 ) { list . add ( new string element ( buf . string ( ) ) ) ; } return list . arrai ( new access log element 0 ) ; }	public iter string get handler ( ) { return handler . kei set ( ) . iter ( ) ; }	public modifc from watch dir war detect see org . apach . catalina . ha . deploi . file chang listen file modifi ( java . io . file ) void file modifi ( file new war ) { try { file deploi war = new file ( get deploi dir ( ) , new war . get name ( ) ) ; copi ( new war , deploi war ) ; string context name = get context name ( deploi war ) ; ( log . info enabl ( ) ) log . info ( instal webapp context name from deploi war . get absolut path ( ) ) ; try { remov ( context name , fals ) ; } catch ( except x ) { log . error ( remov , x ) ; } instal ( context name , deploi war . uri ( ) . url ( ) ) ; } catch ( except x ) { log . error ( unabl instal war file , x ) ; } }	log interest request paramet , invok next valv sequenc , log interest respons paramet . param request servlet request process param respons servlet respons creat except ioexcept input output error occur except servlet except servlet error occur overrid public void invok ( request request , respons respons ) throw ioexcept , servlet except { long totalstart = 0 ; thi happen befor request ( do statist ( ) ) { totalstart = system . current time milli ( ) ; } ( primari indic ) { creat primari indic ( request ) ; } context context = request . get context ( ) ; boolean cross context = context = null context instanceof standard context ( ( standard context ) context ) . get cross context ( ) ; try { ( cross context ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( replic valv . cross context . add ) ) ; fixm add pool arraylist cross context session . set ( new arrai list delta session ( ) ) ; } get next ( ) . invok ( request , respons ) ; ( context = null ) { manag manag = context . get manag ( ) ; ( manag = null manag instanceof cluster manag ) { cluster manag cluster manag = ( cluster manag ) manag ; catalina cluster contain cluster = ( catalina cluster ) get contain ( ) . get cluster ( ) ; ( contain cluster = = null ) { ( log . warn enabl ( ) ) log . warn ( sm . get string ( replic valv . noclust ) ) ; return ; } host level hopefulli ( contain cluster . get manag ( cluster manag . get name ( ) ) = = null ) return ; ( contain cluster . ha member ( ) ) { send replic messag ( request , totalstart , cross context , cluster manag , contain cluster ) ; } els { reset replic request ( request , cross context ) ; } } } } final { don t regist thi request session again ( cross context ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( replic valv . cross context . remov ) ) ; cross context session . remov ( ) onli exist java 5 regist arrai list pool cross context session . set ( null ) ; } } }	regist request track , whenev need . param request servlet request process param respons servlet respons creat except ioexcept input output error occur except servlet except servlet error occur overrid public void invok ( request request , respons respons ) throw ioexcept , servlet except { perform request get next ( ) . invok ( request , respons ) ; ( request . comet ( ) respons . close ( ) ) { start track thi connect , sinc thi begin event , comet mode http session session = request . get session ( true ) ; track conect webapp reload comet request . add ( request ) ; track connect session expir synchron ( session ) { request request = ( request ) session . get attribut ( comet request attribut ) ; ( request = = null ) { request = new request 1 ; request 0 = request ; session . set attribut ( comet request attribut , request ) ; } els { request new request = new request request . length 1 ; ( int i = 0 ; i request . length ; i ) { new request i = request i ; } new request request . length = request ; session . set attribut ( comet request attribut , new request ) ; } } } }	public render html list current activ context our virtual host , memori server statu inform . param request request param respons respons param messag messag displai void list ( http servlet request request , http servlet respons respons , string messag ) throw ioexcept { string new nonc = gener nonc ( ) ; request . get session ( ) . set attribut ( nonc session , new nonc ) ; print writer writer = respons . get writer ( ) ; html header section writer . print ( constant . html header section ) ; bodi header section object arg = new object 2 ; arg 0 = request . get context path ( ) ; arg 1 = sm . get string ( html host manag servlet . titl ) ; writer . print ( messag format . format ( constant . bodi header section , arg ) ) ; messag section arg = new object 3 ; arg 0 = sm . get string ( html host manag servlet . messag label ) ; ( messag = = null messag . length ( ) = = 0 ) { arg 1 = ok ; } els { arg 1 = request util . filter ( messag ) ; } writer . print ( messag format . format ( constant . messag section , arg ) ) ; manag section arg = new object 9 ; arg 0 = sm . get string ( html host manag servlet . manag ) ; arg 1 = respons . encod url ( request . get context path ( ) html list ) ; arg 2 = sm . get string ( html host manag servlet . list ) ; arg 3 = respons . encod url ( request . get context path ( ) sm . get string ( html host manag servlet . help html manag file ) ) ; arg 4 = sm . get string ( html host manag servlet . help html manag ) ; arg 5 = respons . encod url ( request . get context path ( ) sm . get string ( html host manag servlet . help manag file ) ) ; arg 6 = sm . get string ( html host manag servlet . help manag ) ; arg 7 = respons . encod url ( manag statu ) ; arg 8 = sm . get string ( statu servlet . titl ) ; writer . print ( messag format . format ( constant . manag section , arg ) ) ; host header section arg = new object 3 ; arg 0 = sm . get string ( html host manag servlet . host name ) ; arg 1 = sm . get string ( html host manag servlet . host alias ) ; arg 2 = sm . get string ( html host manag servlet . host task ) ; writer . print ( messag format . format ( host header section , arg ) ) ; host row section creat sort map host name . contain children = engin . find children ( ) ; string host name = new string children . length ; ( int i = 0 ; i children . length ; i ) host name i = children i . get name ( ) ; tree map string , string sort host name map = new tree map string , string ( ) ; ( int i = 0 ; i host name . length ; i ) { string displai path = host name i ; sort host name map . put ( displai path , host name i ) ; } string host start = sm . get string ( html host manag servlet . host start ) ; string host stop = sm . get string ( html host manag servlet . host stop ) ; string host remov = sm . get string ( html host manag servlet . host remov ) ; iter map . entri string , string >> iter = sort host name map . entri set ( ) . iter ( ) ; while ( iter . ha next ( ) ) { map . entri string , string entri = iter . next ( ) ; string host name = entri . get kei ( ) ; host host = ( host ) engin . find child ( host name ) ; ( host = null ) { arg = new object 2 ; arg 0 = request util . filter ( host name ) ; string alias = host . find alias ( ) ; string builder buf = new string builder ( ) ; ( alias . length 0 ) { buf . append ( alias 0 ) ; ( int j = 1 ; j alias . length ; j ) { buf . append ( , ) . append ( alias j ) ; } } ( buf . length ( ) = = 0 ) { buf . append ( nbsp ; ) ; arg 1 = buf . string ( ) ; } els { arg 1 = request util . filter ( buf . string ( ) ) ; } writer . print ( messag format . format ( host row detail section , arg ) ) ; arg = new object 7 ; arg 0 = respons . encod url ( request . get context path ( ) html start name = urlencod . encod ( host name , utf 8 ) ) ; arg 1 = host start ; arg 2 = respons . encod url ( request . get context path ( ) html stop name = urlencod . encod ( host name , utf 8 ) ) ; arg 3 = host stop ; arg 4 = respons . encod url ( request . get context path ( ) html remov name = urlencod . encod ( host name , utf 8 ) ) ; arg 5 = host remov ; arg 6 = new nonc ; ( host = = thi . host ) { writer . print ( messag format . format ( manag host row button section , arg ) ) ; } els { writer . print ( messag format . format ( host row button section , arg ) ) ; } } } add section arg = new object 7 ; arg 0 = sm . get string ( html host manag servlet . add titl ) ; arg 1 = sm . get string ( html host manag servlet . add host ) ; arg 2 = respons . encod url ( request . get context path ( ) html add ) ; arg 3 = sm . get string ( html host manag servlet . add name ) ; arg 4 = sm . get string ( html host manag servlet . add alias ) ; arg 5 = sm . get string ( html host manag servlet . add app base ) ; arg 6 = new nonc ; writer . print ( messag format . format ( add section start , arg ) ) ; arg = new object 3 ; arg 0 = sm . get string ( html host manag servlet . add auto deploi ) ; arg 1 = auto deploi ; arg 2 = check ; writer . print ( messag format . format ( add section boolean , arg ) ) ; arg 0 = sm . get string ( html host manag servlet . add deploi startup ) ; arg 1 = deploi startup ; arg 2 = check ; writer . print ( messag format . format ( add section boolean , arg ) ) ; arg 0 = sm . get string ( html host manag servlet . add deploi xml ) ; arg 1 = deploi xml ; arg 2 = check ; writer . print ( messag format . format ( add section boolean , arg ) ) ; arg 0 = sm . get string ( html host manag servlet . add unpack war ) ; arg 1 = unpack war ; arg 2 = check ; writer . print ( messag format . format ( add section boolean , arg ) ) ; arg 0 = sm . get string ( html host manag servlet . add xml namespac awar ) ; arg 1 = xml namespac awar ; arg 2 = ; writer . print ( messag format . format ( add section boolean , arg ) ) ; arg 0 = sm . get string ( html host manag servlet . add xml valid ) ; arg 1 = xml valid ; arg 2 = ; writer . print ( messag format . format ( add section boolean , arg ) ) ; arg 0 = sm . get string ( html host manag servlet . add manag ) ; arg 1 = manag ; arg 2 = check ; writer . print ( messag format . format ( add section boolean , arg ) ) ; arg = new object 1 ; arg 0 = sm . get string ( html host manag servlet . add button ) ; writer . print ( messag format . format ( add section end , arg ) ) ; server header section arg = new object 7 ; arg 0 = sm . get string ( html host manag servlet . server titl ) ; arg 1 = sm . get string ( html host manag servlet . server version ) ; arg 2 = sm . get string ( html host manag servlet . server jvmversion ) ; arg 3 = sm . get string ( html host manag servlet . server jvmvendor ) ; arg 4 = sm . get string ( html host manag servlet . server osnam ) ; arg 5 = sm . get string ( html host manag servlet . server osvers ) ; arg 6 = sm . get string ( html host manag servlet . server osarch ) ; writer . print ( messag format . format ( constant . server header section , arg ) ) ; server row section arg = new object 6 ; arg 0 = server info . get server info ( ) ; arg 1 = system . get properti ( java . runtim . version ) ; arg 2 = system . get properti ( java . vm . vendor ) ; arg 3 = system . get properti ( os . name ) ; arg 4 = system . get properti ( os . version ) ; arg 5 = system . get properti ( os . arch ) ; writer . print ( messag format . format ( constant . server row section , arg ) ) ; html tail section writer . print ( constant . html tail section ) ; finish up respons writer . flush ( ) ; writer . close ( ) ; }	public void list bean ( print writer writer , string qry ) { set object name name = null ; try { name = m bean server . queri name ( new object name ( qry ) , null ) ; writer . println ( ok number result : name . size ( ) ) ; writer . println ( ) ; } catch ( except e ) { writer . println ( error e . string ( ) ) ; return ; } iter object name = name . iter ( ) ; while ( . ha next ( ) ) { object name onam = . next ( ) ; writer . println ( name : onam . string ( ) ) ; try { mbean info minfo = m bean server . get mbean info ( onam ) ; can t null i thinl string code = minfo . get class name ( ) ; ( org . apach . common . model . base model mbean . equal ( code ) ) { code = ( string ) m bean server . get attribut ( onam , model type ) ; } writer . println ( model type : code ) ; mbean attribut info attr = minfo . get attribut ( ) ; object valu = null ; ( int i = 0 ; i attr . length ; i ) { ( attr i . readabl ( ) ) continu ; ( support ( attr i . get type ( ) ) ) continu ; string att name = attr i . get name ( ) ; ( att name . index ( = ) = 0 att name . index ( : ) = 0 att name . index ( ) = 0 ) { continu ; } try { valu = m bean server . get attribut ( onam , att name ) ; } catch ( throwabl t ) { log ( error get attribut onam att name t . string ( ) ) ; continu ; } ( valu = = null ) continu ; ( model type . equal ( att name ) ) continu ; string valu string = valu . string ( ) ; writer . println ( att name : escap ( valu string ) ) ; } } catch ( except e ) { ignor } writer . println ( ) ; } }	public cluster member gone see org . apach . catalina . ha . membership listen member disappear ( org . apach . catalina . ha . member ) void member disappear ( member member ) { try { ha member = channel . ha member ( ) ; ( log . info enabl ( ) ) log . info ( receiv member disappear : member ) ; notifi our interest lifecycl listen lifecycl . fire lifecycl event ( befor memberunregist event , member ) ; notifi our interest lifecycl listen lifecycl . fire lifecycl event ( after memberunregist event , member ) ; } catch ( except x ) { log . error ( unabl remov cluster node from replic system . , x ) ; } }	public remov exist web applic , attach specifi context path . thi applic successfulli remov , contain event type code remov event code sent all regist listen , remov code context code argument . delet web applic war file directori thei exist host s app base . param context path context path applic remov param undeploi boolean flag remov web applic from server except illeg argument except specifi context path malform ( must start slash ) except illeg argument except specifi context path doe identifi current instal web applic except ioexcept input output error occur dure remov void remov ( string context path , boolean undeploi ) throw ioexcept { ( log . info enabl ( ) ) log . info ( cluster wide remov web app context path ) ; member local member = get cluster ( ) . get local member ( ) ; undeploi messag msg = new undeploi messag ( local member , system . current time milli ( ) , undeploi : context path : system . current time milli ( ) , context path , undeploi ) ; ( log . debug enabl ( ) ) log . debug ( send cluster wide undeploy from context path ) ; cluster . send ( msg ) ; remov local ( undeploi ) { try { ( servic ( context path ) ) { add servic ( context path ) ; try { remov ( context path ) ; } final { remov servic ( context path ) ; } } els log . error ( local remov from context path fail , other manag ha app servic ) ; } catch ( except ex ) { log . error ( local remov from context path fail , ex ) ; } } }	public remov specifi request attribut exist . param name name request attribut remov void remov attribut ( string name ) { object valu = null ; boolean found = fals ; request ar per thread so synchron unnecessari ( read onli attribut . contain kei ( name ) ) { return ; } pass special attribut nativ layer ( name . start ( org . apach . tomcat . ) ) { coyot request . get attribut ( ) . remov ( name ) ; } found = attribut . contain kei ( name ) ; ( found ) { valu = attribut . get ( name ) ; attribut . remov ( name ) ; } els { return ; } notifi interest applic event listen object listen = context . get applic event listen ( ) ; ( ( listen = = null ) ( listen . length = = 0 ) ) return ; servlet request attribut event event = new servlet request attribut event ( context . get servlet context ( ) , get request ( ) , name , valu ) ; ( int i = 0 ; i listen . length ; i ) { ( ( listen i instanceof servlet request attribut listen ) ) continu ; servlet request attribut listen listen = ( servlet request attribut listen ) listen i ; try { listen . attribut remov ( event ) ; } catch ( throwabl t ) { context . get logger ( ) . error ( sm . get string ( coyot request . attribut event ) , t ) ; error valv pick thi execpt up displai user attribut . put ( global . except attr , t ) ; } } }	public remov exist connector . param name mbean name compon remov except except compon cannot remov void remov connector ( string name ) throw except { acquir refer compon remov object name onam = new object name ( name ) ; servic servic = get servic ( onam ) ; string port = onam . get kei properti ( port ) ; string address = onam . get kei properti ( address ) ; connector conn = servic . find connector ( ) ; ( int i = 0 ; i conn . length ; i ) { string conn address = string . valu ( conn i . get properti ( address ) ) ; string conn port = conn i . get port ( ) ; ( ( ( address . equal ( null ) ) ( ( conn address = = null ) port . equal ( conn port ) ) { servic . remov connector ( conn i ) ; conn i . destroi ( ) ; break ; } } els ( address . equal ( conn address ) ) ( port . equal ( conn port ) ) { remov thi compon from parent compon servic . remov connector ( conn i ) ; conn i . destroi ( ) ; break ; } } }	public remov exist context . param context name mbean name comon remov except except compon cannot remov void remov context ( string context name ) throw except { acquir refer compon remov object name onam = new object name ( context name ) ; string domain = onam . get domain ( ) ; standard servic servic = ( standard servic ) get servic ( onam ) ; engin engin = ( engin ) servic . get contain ( ) ; string name = onam . get kei properti ( name ) ; name = name . substr ( 2 ) ; int i = name . index ( ) ; string host name = name . substr ( 0 , i ) ; string path = name . substr ( i ) ; object name deploy = new object name ( domain : type = deploy , host = host name ) ; string path str = get path str ( path ) ; ( mserver . regist ( deploy ) ) { mserver . invok ( deploy , add servic , new object { path str } , new string { java . lang . string } ) ; mserver . invok ( deploy , unmanag app , new object { path str } , new string { java . lang . string } ) ; mserver . invok ( deploy , remov servic , new object { path str } , new string { java . lang . string } ) ; } els { log . warn ( deploy found host name ) ; host host = ( host ) engin . find child ( host name ) ; context context = ( context ) host . find child ( path str ) ; remov thi compon from parent compon host . remov child ( context ) ; ( context instanceof standard context ) try { ( ( standard context ) context ) . destroi ( ) ; } catch ( except e ) { log . warn ( error dure context context . get name ( ) destroi , e ) ; } } }	public remov exist host . param name mbean name comon remov except except compon cannot remov void remov host ( string name ) throw except { acquir refer compon remov object name onam = new object name ( name ) ; string host name = onam . get kei properti ( host ) ; servic servic = get servic ( onam ) ; engin engin = ( engin ) servic . get contain ( ) ; host host = ( host ) engin . find child ( host name ) ; remov thi compon from parent compon ( host = null ) { ( host instanceof standard host ) ( ( standard host ) host ) . destroi ( ) ; els engin . remov child ( host ) ; } }	public remov exist loader . param name mbean name comon remov except except compon cannot remov void remov loader ( string name ) throw except { object name onam = new object name ( name ) ; acquir refer compon remov contain base contain = get parent contain from child ( onam ) ; contain . set loader ( null ) ; }	public remov exist manag . param name mbean name comon remov except except compon cannot remov void remov manag ( string name ) throw except { object name onam = new object name ( name ) ; acquir refer compon remov contain base contain = get parent contain from child ( onam ) ; contain . set manag ( null ) ; }	public remov exist realm . param name mbean name comon remov except except compon cannot remov void remov realm ( string name ) throw except { object name onam = new object name ( name ) ; acquir refer compon remov contain base contain = get parent contain from child ( onam ) ; contain . set realm ( null ) ; }	public save session store . param session session store except ioexcept input output error occur void save ( session session ) throw ioexcept { object output stream oo = null ; byte arrai output stream bo = null ; byte arrai input stream bi = null ; input stream = null ; synchron ( thi ) { int number tri = 2 ; while ( number tri 0 ) { connect conn = get connect ( ) ; ( conn = = null ) { return ; } session alreadi exist db , remov insert again . todo : check id exist databas so us updat . remov ( session . get id intern ( ) ) ; try { bo = new byte arrai output stream ( ) ; oo = new object output stream ( new buffer output stream ( bo ) ) ; ( ( standard session ) session ) . write object data ( oo ) ; oo . close ( ) ; oo = null ; byte ob = bo . byte arrai ( ) ; int size = ob . length ; bi = new byte arrai input stream ( ob , 0 , size ) ; = new buffer input stream ( bi , size ) ; ( prepar save sql = = null ) { string save sql = insert session tabl ( session id col , session app col , session data col , session valid col , session max inact col , session last access col ) valu ( , , , , , ) ; prepar save sql = conn . prepar statement ( save sql ) ; } prepar save sql . set string ( 1 , session . get id intern ( ) ) ; prepar save sql . set string ( 2 , get name ( ) ) ; prepar save sql . set binari stream ( 3 , , size ) ; prepar save sql . set string ( 4 , session . valid ( ) 1 : 0 ) ; prepar save sql . set int ( 5 , session . get max inact interv ( ) ) ; prepar save sql . set long ( 6 , session . get last access time ( ) ) ; prepar save sql . execut ( ) ; break out after final block number tri = 0 ; } catch ( sqlexcept e ) { manag . get contain ( ) . get logger ( ) . error ( sm . get string ( get store name ( ) . sqlexcept , e ) ) ; ( db connect = null ) close ( db connect ) ; } catch ( ioexcept e ) { ignor } final { ( oo = null ) { oo . close ( ) ; } ( bi = null ) { bi . close ( ) ; } ( = null ) { . close ( ) ; } releas ( conn ) ; } number tri ; } } ( manag . get contain ( ) . get logger ( ) . debug enabl ( ) ) { manag . get contain ( ) . get logger ( ) . debug ( sm . get string ( get store name ( ) . save , session . get id intern ( ) , session tabl ) ) ; } }	set valu specif attribut thi mbean . param attribut identif attribut set new valu except attribut found except thi attribut support thi mbean except mbean except initi object throw except except reflect except java reflect except occur when invok getter overrid public void set attribut ( attribut attribut ) throw attribut found except , mbean except , reflect except { super . set attribut ( attribut ) ; context environ ce = null ; try { ce = ( context environ ) get manag resourc ( ) ; } catch ( instanc found except e ) { throw new mbean except ( e ) ; } catch ( invalid target object type except e ) { throw new mbean except ( e ) ; } cannot us side efect . s remov ad back each time modif resourc . name resourc nr = ce . get name resourc ( ) ; nr . remov environ ( ce . get name ( ) ) ; nr . add environ ( ce ) ; }	set valu specif attribut thi mbean . param attribut identif attribut set new valu except attribut found except thi attribut support thi mbean except mbean except initi object throw except except reflect except java reflect except occur when invok getter overrid public void set attribut ( attribut attribut ) throw attribut found except , mbean except , reflect except { super . set attribut ( attribut ) ; context resourc link crl = null ; try { crl = ( context resourc link ) get manag resourc ( ) ; } catch ( instanc found except e ) { throw new mbean except ( e ) ; } catch ( invalid target object type except e ) { throw new mbean except ( e ) ; } cannot us side efect . s remov ad back each time modif resourc . name resourc nr = crl . get name resourc ( ) ; nr . remov resourc link ( crl . get name ( ) ) ; nr . add resourc link ( crl ) ; }	set valu specif attribut thi mbean . param attribut identif attribut set new valu except attribut found except thi attribut support thi mbean except mbean except initi object throw except except reflect except java reflect except occur when invok getter overrid public void set attribut ( attribut attribut ) throw attribut found except , mbean except , reflect except { valid input paramet ( attribut = = null ) throw new runtim oper except ( new illeg argument except ( attribut null ) , attribut null ) ; string name = attribut . get name ( ) ; object valu = attribut . get valu ( ) ; ( name = = null ) throw new runtim oper except ( new illeg argument except ( attribut name null ) , attribut name null ) ; context resourc cr = null ; try { cr = ( context resourc ) get manag resourc ( ) ; } catch ( instanc found except e ) { throw new mbean except ( e ) ; } catch ( invalid target object type except e ) { throw new mbean except ( e ) ; } ( auth . equal ( name ) ) { cr . set auth ( ( string ) valu ) ; } els ( descript . equal ( name ) ) { cr . set descript ( ( string ) valu ) ; } els ( name . equal ( name ) ) { cr . set name ( ( string ) valu ) ; } els ( scope . equal ( name ) ) { cr . set scope ( ( string ) valu ) ; } els ( type . equal ( name ) ) { cr . set type ( ( string ) valu ) ; } els { cr . set properti ( name , valu ) ; } cannot us side efect . s remov ad back each time modif resourc . name resourc nr = cr . get name resourc ( ) ; nr . remov resourc ( cr . get name ( ) ) ; nr . add resourc ( cr ) ; }	public set specifi request attribut specifi valu . param name name request attribut set param valu associ valu void set attribut ( string name , object valu ) { name cannot null ( name = = null ) throw new illeg argument except ( sm . get string ( coyot request . set attribut . namenul ) ) ; null valu same remov attribut ( ) ( valu = = null ) { remov attribut ( name ) ; return ; } ( name . equal ( global . dispatch type attr ) ) { intern dispatch type = ( dispatch type ) valu ; return ; } els ( name . equal ( global . dispatch request path attr ) ) { request dispatch path = valu ; return ; } ( name . equal ( global . async support attr ) ) { thi . async support = ( boolean ) valu ; } object old valu = null ; boolean replac = fals ; request ar per thread so synchron unnecessari ( read onli attribut . contain kei ( name ) ) { return ; } old valu = attribut . put ( name , valu ) ; ( old valu = null ) { replac = true ; } pass special attribut nativ layer ( name . start ( org . apach . tomcat . ) ) { coyot request . set attribut ( name , valu ) ; } notifi interest applic event listen object listen = context . get applic event listen ( ) ; ( ( listen = = null ) ( listen . length = = 0 ) ) return ; servlet request attribut event event = null ; ( replac ) event = new servlet request attribut event ( context . get servlet context ( ) , get request ( ) , name , old valu ) ; els event = new servlet request attribut event ( context . get servlet context ( ) , get request ( ) , name , valu ) ; ( int i = 0 ; i listen . length ; i ) { ( ( listen i instanceof servlet request attribut listen ) ) continu ; servlet request attribut listen listen = ( servlet request attribut listen ) listen i ; try { ( replac ) { listen . attribut replac ( event ) ; } els { listen . attribut ad ( event ) ; } } catch ( throwabl t ) { context . get logger ( ) . error ( sm . get string ( coyot request . attribut event ) , t ) ; error valv pick thi execpt up displai user attribut . put ( global . except attr , t ) ; } } }	public param cluster cluster set . void set cluster ( catalina cluster cluster ) { thi . cluster = cluster ; }	public set content type thi respons . param type new content type void set content type ( string type ) { ( commit ( ) ) return ; ignor ani call from includ servlet ( includ ) return ; ignor charset get writer ( ) ha alreadi been call ( us writer ) { ( type = null ) { int index = type . index ( ; ) ; ( index = 1 ) { type = type . substr ( 0 , index ) ; } } } coyot respons . set content type ( type ) ; check see content type contain charset ( type = null ) { int index = type . index ( ; ) ; ( index = 1 ) { int len = type . length ( ) ; index ; while ( index len charact . space ( type . char ( index ) ) ) { index ; } ( index 7 len type . char ( index ) = = c type . char ( index 1 ) = = h type . char ( index 2 ) = = type . char ( index 3 ) = = r type . char ( index 4 ) = = s type . char ( index 5 ) = = e type . char ( index 6 ) = = t type . char ( index 7 ) = = = ) { charact encod set = true ; } } } }	public get coyot request . org . apach . coyot . request get coyot request ( ) { return ( thi . coyot request ) ; }	public void set reject session ( int reject session ) { thi . reject session = reject session ; }	overrid public long get timestamp ( ) { return serial timestamp ; }
privat param arg method call argument return return correct port throw servic except port s qname unknown port ( defin wsdl ) . object get proxi port qname class ( object arg ) throw servic except { qname name = ( qname ) arg 0 ; string name string = name . get local part ( ) ; class serviceendpoint class = ( class ) arg 1 ; ( iter port = servic . get port ( ) ; port . ha next ( ) ; ) { qname port name = ( qname ) port . next ( ) ; string portnam string = port name . get local part ( ) ; ( portnam string . equal ( name string ) ) { return servic . get port ( name , serviceendpoint class ) ; } } port have been found throw new servic except ( port compon ref : name found ) ; }	privat param arg method call argument return return correct port throw servic except port s qname unknown port remot get proxi port class ( object arg ) throw servic except { class serviceendpoint class = ( class ) arg 0 ; ( thi . port compon ref = = null ) return servic . get port ( serviceendpoint class ) ; qname portnam = ( qname ) thi . port compon ref . get ( serviceendpoint class . get name ( ) ) ; ( portnam = null ) { return servic . get port ( portnam , serviceendpoint class ) ; } els { return servic . get port ( serviceendpoint class ) ; } }	privat param port analyz port return return endpoint url given port string get soaploc ( port port ) { string endpoint = null ; list extens = port . get extens element ( ) ; ( iter i = extens . iter ( ) ; i . ha next ( ) ; ) { extens element ext = ( extens element ) i . next ( ) ; ( ext instanceof soapaddress ) { soapaddress addr = ( soapaddress ) ext ; endpoint = addr . get locat uri ( ) ; } } return endpoint ; }	privat void init handler chain ( qname port name , handler registri handler registri , handler info handlerref , arrai list soaprol add ) { handler chain handler list = ( handler chain ) handler registri . get handler chain ( port name ) ; handler list . add ( handlerref ) ; string soaprol regist = handler list . get role ( ) ; string soaprol = new string soaprol regist . length soaprol add . size ( ) ; int i ; ( i = 0 ; i soaprol regist . length ; i ) soaprol i = soaprol regist i ; ( int j = 0 ; j soaprol add . size ( ) ; j ) soaprol i j = ( string ) soaprol add . get ( j ) ; handler list . set role ( soaprol ) ; handler registri . set handler chain ( port name , handler list ) ; }	public object get object instanc ( object obj , name name , context name ctx , hashtabl environ ) throw except { ( obj instanceof servic ref ) { refer ref = ( refer ) obj ; class loader class loader tcl = thread . current thread ( ) . get context class loader ( ) ; ( tcl = = null ) tcl = thi . get class ( ) . get class loader ( ) ; servic factori factori = servic factori . new instanc ( ) ; javax . xml . rpc . servic servic = null ; servic interfac ref addr tmp = ref . get ( servic ref . servic interfac ) ; string servic interfac = null ; ( tmp = null ) servic interfac = ( string ) tmp . get content ( ) ; wsdl tmp = ref . get ( servic ref . wsdl ) ; string wsdl ref addr = null ; ( tmp = null ) wsdl ref addr = ( string ) tmp . get content ( ) ; port compon hashtabl port compon ref = new hashtabl ( ) ; creat qname object qname servic qname = null ; tmp = ref . get ( servic ref . servic local part ) ; ( tmp = null ) { string servic local part = ( string ) tmp . get content ( ) ; tmp = ref . get ( servic ref . servic namespac ) ; ( tmp = = null ) { servic qname = new qname ( servic local part ) ; } els { string servic namespac = ( string ) tmp . get content ( ) ; servic qname = new qname ( servic namespac , servic local part ) ; } } class servic interfac class = null ; creat servic object ( servic interfac = = null ) { ( servic qname = = null ) { throw new name except ( could creat servic ref instanc ) ; } try { ( wsdl ref addr = = null ) { servic = factori . creat servic ( servic qname ) ; } els { servic = factori . creat servic ( new url ( wsdl ref addr ) , servic qname ) ; } } catch ( throwabl t ) { name except ex = new name except ( could creat servic ) ; ex . init caus ( t ) ; throw ex ; } } els { load servic interfac try { servic interfac class = tcl . load class ( servic interfac ) ; } catch ( class found except e ) { name except ex = new name except ( could load servic interfac ) ; ex . init caus ( e ) ; throw ex ; } ( servic interfac class = = null ) { throw new name except ( could load servic interfac ) ; } try { ( wsdl ref addr = = null ) { ( servic . class . assign from ( servic interfac class ) ) { throw new name except ( servic interfac should extend javax . xml . rpc . servic ) ; } servic = factori . load servic ( servic interfac class ) ; } els { servic = factori . load servic ( new url ( wsdl ref addr ) , servic interfac class , new properti ( ) ) ; } } catch ( throwabl t ) { name except ex = new name except ( could creat servic ) ; ex . init caus ( t ) ; throw ex ; } } ( servic = = null ) { throw new name except ( cannot creat servic object ) ; } servic qname = servic . get servic name ( ) ; servic interfac class = servic . get class ( ) ; ( wsdl ref addr = null ) { try { wsdlfactori wsdlfactori = wsdlfactori . new instanc ( ) ; wsdlreader reader = wsdlfactori . new wsdlreader ( ) ; reader . set featur ( javax . wsdl . import document , true ) ; definit def = reader . read wsdl ( ( new url ( wsdl ref addr ) ) . extern form ( ) ) ; javax . wsdl . servic wsdlservic = def . get servic ( servic qname ) ; map port = wsdlservic . get port ( ) ; method m = servic interfac class . get method ( set endpoint address , new class { java . lang . string . class , java . lang . string . class } ) ; ( iter i = port . kei set ( ) . iter ( ) ; i . ha next ( ) ; ) { string port name = ( string ) i . next ( ) ; port port = wsdlservic . get port ( port name ) ; string endpoint = get soaploc ( port ) ; m . invok ( servic , new object { port . get name ( ) , endpoint } ) ; port compon ref . put ( endpoint , new qname ( port . get name ( ) ) ) ; } } catch ( throwabl t ) { name except ex = new name except ( error while read wsdl file ) ; ex . init caus ( t ) ; throw ex ; } } servic proxi proxi = new servic proxi ( servic ) ; us port compon ref ( int i = 0 ; i ref . size ( ) ; i ) ( servic ref . . equal ( ref . get ( i ) . get type ( ) ) ) { string serviceendpoint = ; string portlink = ; serviceendpoint = ( string ) ref . get ( i ) . get content ( ) ; ( servic ref . portcomponentlink . equal ( ref . get ( i 1 ) . get type ( ) ) ) { i ; portlink = ( string ) ref . get ( i ) . get content ( ) ; } port compon ref . put ( serviceendpoint , new qname ( portlink ) ) ; } proxi . set port compon ref ( port compon ref ) ; instanti servic proxi class class interfac = null ; class servic interfac = servic interfac class . get interfac ( ) ; ( servic interfac class = null ) { interfac = new class servic interfac . length 1 ; ( int i = 0 ; i servic interfac . length ; i ) { interfac i = servic interfac i ; } } els { interfac = new class 1 ; } interfac interfac . length 1 = javax . xml . rpc . servic . class ; object proxi instanc = null ; try { proxi instanc = proxi . new proxi instanc ( tcl , interfac , proxi ) ; } catch ( illeg argument except e ) { proxi instanc = proxi . new proxi instanc ( tcl , servic interfac , proxi ) ; } us handler ( ( ( servic ref ) ref ) . get handler size ( ) 0 ) { handler registri handler registri = servic . get handler registri ( ) ; arrai list soaprol = new arrai list ( ) ; while ( ( ( servic ref ) ref ) . get handler size ( ) 0 ) { handler ref handler = ( ( servic ref ) ref ) . get handler ( ) ; handler info handlerref = new handler info ( ) ; load handler class tmp = handler . get ( handler ref . handler class ) ; ( ( tmp = = null ) ( tmp . get content ( ) = = null ) ) break ; class handler class = null ; try { handler class = tcl . load class ( ( string ) tmp . get content ( ) ) ; } catch ( class found except e ) { break ; } load all data rel handler : soaphead , config init element , port name set arrai list header = new arrai list ( ) ; hashtabl config = new hashtabl ( ) ; arrai list port name = new arrai list ( ) ; ( int i = 0 ; i handler . size ( ) ; i ) ( handler ref . handler localpart . equal ( handler . get ( i ) . get type ( ) ) ) { string localpart = ; string namespac = ; localpart = ( string ) handler . get ( i ) . get content ( ) ; ( handler ref . handler namespac . equal ( handler . get ( i 1 ) . get type ( ) ) ) { i ; namespac = ( string ) handler . get ( i ) . get content ( ) ; } qname header = new qname ( namespac , localpart ) ; header . add ( header ) ; } els ( handler ref . handler paramnam . equal ( handler . get ( i ) . get type ( ) ) ) { string param name = ; string param valu = ; param name = ( string ) handler . get ( i ) . get content ( ) ; ( handler ref . handler paramvalu . equal ( handler . get ( i 1 ) . get type ( ) ) ) { i ; param valu = ( string ) handler . get ( i ) . get content ( ) ; } config . put ( param name , param valu ) ; } els ( handler ref . handler soaprol . equal ( handler . get ( i ) . get type ( ) ) ) { string soaprol = ; soaprol = ( string ) handler . get ( i ) . get content ( ) ; soaprol . add ( soaprol ) ; } els ( handler ref . handler portnam . equal ( handler . get ( i ) . get type ( ) ) ) { string port name = ; port name = ( string ) handler . get ( i ) . get content ( ) ; port name . add ( port name ) ; } set handler inform handlerref . set handler class ( handler class ) ; handlerref . set header ( ( qname ) header . arrai ( new qname header . size ( ) ) ) ; handlerref . set handler config ( config ) ; ( port name . empti ( ) ) { iter iter = port name . iter ( ) ; while ( iter . ha next ( ) ) init handler chain ( new qname ( ( string ) iter . next ( ) ) , handler registri , handlerref , soaprol ) ; } els { enumer e = port compon ref . element ( ) ; while ( e . ha more element ( ) ) init handler chain ( ( qname ) e . next element ( ) , handler registri , handlerref , soaprol ) ; } } } return proxi instanc ; } return null ; }
privat combin servlet path path info . path info code null code ignor . servlet path code null code code null code return . return combin path path info append servlet info string get combin path ( ) { ( servlet path = = null ) { return null ; } ( path info = = null ) { return servlet path ; } return servlet path path info ; }	privat void do forward ( servlet request request , servlet respons respons ) throw servlet except , ioexcept { reset ani output ha been buffer , keep header cooki ( respons . commit ( ) ) { throw new illeg state except ( sm . get string ( applic dispatch . forward . ) ) ; } try { respons . reset buffer ( ) ; } catch ( illeg state except e ) { throw e ; } set up handl specifi request respons state state = new state ( request , respons , fals ) ; ( global . strict servlet complianc ) { check srv . 8 . 2 srv . 14 . 2 . 5 . 1 complianc check same object ( request , respons ) ; } wrap respons ( state ) ; handl http name dispatch forward ( ( servlet path = = null ) ( path info = = null ) ) { applic http request wrequest = ( applic http request ) wrap request ( state ) ; http servlet request hrequest = state . hrequest ; wrequest . set request uri ( hrequest . get request uri ( ) ) ; wrequest . set context path ( hrequest . get context path ( ) ) ; wrequest . set servlet path ( hrequest . get servlet path ( ) ) ; wrequest . set path info ( hrequest . get path info ( ) ) ; wrequest . set queri string ( hrequest . get queri string ( ) ) ; process request ( request , respons , state ) ; } els handl http path base forward { applic http request wrequest = ( applic http request ) wrap request ( state ) ; string context path = context . get path ( ) ; http servlet request hrequest = state . hrequest ; ( hrequest . get attribut ( global . forward request uri attr ) = = null ) { wrequest . set attribut ( global . forward request uri attr , hrequest . get request uri ( ) ) ; wrequest . set attribut ( global . forward context path attr , hrequest . get context path ( ) ) ; wrequest . set attribut ( global . forward servlet path attr , hrequest . get servlet path ( ) ) ; wrequest . set attribut ( global . forward path info attr , hrequest . get path info ( ) ) ; wrequest . set attribut ( global . forward queri string attr , hrequest . get queri string ( ) ) ; } wrequest . set context path ( context path ) ; wrequest . set request uri ( request uri ) ; wrequest . set servlet path ( servlet path ) ; wrequest . set path info ( path info ) ; ( queri string = null ) { wrequest . set queri string ( queri string ) ; wrequest . set queri param ( queri string ) ; } process request ( request , respons , state ) ; } thi real close order support error process ( wrapper . get logger ( ) . debug enabl ( ) ) wrapper . get logger ( ) . debug ( disabl respons futher output ) ; ( respons instanceof respons facad ) { ( ( respons facad ) respons ) . finish ( ) ; } els { mai longer instanc request facad ( wrapper . get logger ( ) . debug enabl ( ) ) { wrapper . get logger ( ) . debug ( respons vehicul us wrapper : respons . get class ( ) . get name ( ) ) ; } close anywai try { print writer writer = respons . get writer ( ) ; writer . close ( ) ; } catch ( illeg state except e ) { try { servlet output stream stream = respons . get output stream ( ) ; stream . close ( ) ; } catch ( illeg state except f ) { ignor } catch ( ioexcept f ) { ignor } } catch ( ioexcept e ) { ignor } } }	provid default case explicit configur set return configur realm , jaa realm default overrid public realm get realm ( ) { realm configur = super . get realm ( ) ; thi can overriden engin , context host level ( configur = = null ) { configur = new jaasrealm ( ) ; thi . set realm ( configur ) ; } return configur ; }	public return descript inform about thi implement . string get info ( ) { return ( info ) ; }	public return origin document root thi context . thi can absolut pathnam , rel pathnam , url . onli set deploy ha chang doc root string get origin doc base ( ) { return ( thi . origin doc base ) ; }	public p return valv instanc ha been distinguish basic valv thi pipelin ( ani ) . valv get basic ( ) { return ( thi . basic ) ; }	public get server . xml lt ; host gt ; attribut s xml valid . return true valid enabl . boolean get xml valid ( ) { return xml valid ; }	public synchron remov specifi valv from pipelin associ thi contain , found ; otherwis , do noth . param valv valv remov void remov valv ( valv valv ) { pipelin . remov valv ( valv ) ; fire contain event ( remov valv event , valv ) ; }	public string get alias ( ) { synchron ( alias lock ) { return alias ; } }	public void destroi ( ) throw except { ( start ) { stop ( ) ; } initi = fals ; unregist thi compon ( onam = null ) { try { ( control = = onam ) { registri . get registri ( null , null ) . unregist compon ( onam ) ; ( log . debug enabl ( ) ) log . debug ( unregist onam ) ; } } catch ( throwabl t ) { log . error ( error unregist , t ) ; } } ( parent = null ) { parent . remov child ( thi ) ; } stop our child contain , ani contain children = find children ( ) ; ( int i = 0 ; i children . length ; i ) { remov child ( children i ) ; } }	public notifi all contain event listen particular event ha occur thi contain . default implement perform thi notif synchron us call thread . param type event type param data event data void fire contain event ( string type , object data ) { ( listen . size ( ) 1 ) return ; contain event event = new contain event ( thi , type , data ) ; contain listen list = new contain listen 0 ; synchron ( listen ) { list = listen . arrai ( list ) ; } ( int i = 0 ; i list . length ; i ) list i . contain event ( event ) ; }	overrid public void init ( ) { ( initi ) return ; initi = true ; ( onam = = null ) { regist jmx yet standalon mode try { ( domain = = null ) { domain = get name ( ) ; } ( log . debug enabl ( ) ) log . debug ( regist domain ) ; onam = new object name ( domain : type = engin ) ; control = onam ; registri . get registri ( null , null ) . regist compon ( thi , onam , null ) ; } catch ( throwabl t ) { log . info ( error regist , t ) ; } } ( mbean file = = null ) { string default mbean file = get base dir ( ) conf tomcat5 mbean . xml ; file f = new file ( default mbean file ) ; ( f . exist ( ) ) mbean file = f . get absolut path ( ) ; } ( mbean file = null ) { read engin mbean ( ) ; } ( mbean = null ) { try { registri . get registri ( null , null ) . invok ( mbean , init , fals ) ; } catch ( except e ) { log . error ( error init ( ) mbean file , e ) ; } } } ( servic = = null ) { consist . . . : we ar probabl embed mode try { servic = new standard servic ( ) ; servic . set contain ( thi ) ; servic . initi ( ) ; } catch ( throwabl t ) { log . error ( t ) ; } } }	public invok pre startup initi . thi us allow connector bind restrict port under unix oper environ . void initi ( ) throw lifecycl except { servic shouldn t us embed , so doesn t matter ( initi ) { ( log . info enabl ( ) ) log . info ( sm . get string ( standard servic . initi . initi ) ) ; return ; } initi = true ; ( onam = = null ) { try { hack server should deprec . . . contain engin = thi . get contain ( ) ; domain = engin . get name ( ) ; onam = new object name ( domain : type = servic , servic name = name ) ; thi . control = onam ; registri . get registri ( null , null ) . regist compon ( thi , onam , null ) ; executor executor = find executor ( ) ; ( int i = 0 ; i executor . length ; i ) { object name executor object name = new object name ( domain : type = executor , name = executor i . get name ( ) ) ; registri . get registri ( null , null ) . regist compon ( executor i , executor object name , null ) ; } } catch ( except e ) { log . error ( sm . get string ( standard servic . regist . fail , domain ) , e ) ; } } ( server = = null ) { server wa defin creat server = new standard server ( ) ; server . add servic ( thi ) ; } initi our defin connector synchron ( connector ) { ( int i = 0 ; i connector . length ; i ) { connector i . initi ( ) ; } } }	public remov specifi valv from pipelin associ thi contain , found ; otherwis , do noth . valv found remov , valv s code set contain ( null ) code method call implement code contain code . param valv valv remov void remov valv ( valv valv ) { valv current ; ( first = = valv ) { first = first . get next ( ) ; current = null ; } els { current = first ; } while ( current = null ) { ( current . get next ( ) = = valv ) { current . set next ( valv . get next ( ) ) ; break ; } current = current . get next ( ) ; } ( first = = basic ) first = null ; ( valv instanceof contain ) ( ( contain ) valv ) . set contain ( null ) ; stop thi valv necessari ( start ) { ( valv instanceof lifecycl ) { try { ( ( lifecycl ) valv ) . stop ( ) ; } catch ( lifecycl except e ) { log . error ( standard pipelin . remov valv : stop : , e ) ; } } unregist remov valav unregist valv ( valv ) ; } }	public p set valv instanc ha been distinguish basic valv thi pipelin ( ani ) . prioer set basic valv , valv s code set contain ( ) code call , implement code contain code , own contain argument . method mai throw code illeg argument except code thi valv choos associ thi contain , code illeg state except code alreadi associ differ contain . p param valv valv distinguish basic valv void set basic ( valv valv ) { chang compon necessari valv old basic = thi . basic ; ( old basic = = valv ) return ; stop old compon necessari ( old basic = null ) { ( start ( old basic instanceof lifecycl ) ) { try { ( ( lifecycl ) old basic ) . stop ( ) ; } catch ( lifecycl except e ) { log . error ( standard pipelin . set basic : stop , e ) ; } } ( old basic instanceof contain ) { try { ( ( contain ) old basic ) . set contain ( null ) ; } catch ( throwabl t ) { ignor } } } start new compon necessari ( valv = = null ) return ; ( valv instanceof contain ) { ( ( contain ) valv ) . set contain ( thi . contain ) ; } ( valv instanceof lifecycl ) { try { ( ( lifecycl ) valv ) . start ( ) ; } catch ( lifecycl except e ) { log . error ( standard pipelin . set basic : start , e ) ; return ; } } updat pipelin valv current = first ; while ( current = null ) { ( current . get next ( ) = = old basic ) { current . set next ( valv ) ; break ; } current = current . get next ( ) ; } thi . basic = valv ; }	public set java class name context implement class new web applic . param context class new context implement class void set context class ( string context class ) { string old context class = thi . context class ; thi . context class = context class ; support . fire properti chang ( context class , old context class , thi . context class ) ; }	public gracefulli termin activ us public method thi compon . thi method should last call given instanc thi compon . should also send lifecycl event type stop event ani regist listen . except lifecycl except thi compon detect fatal error need report void stop ( ) throw lifecycl except { valid updat our current compon state ( start ) { return ; } notifi our interest lifecycl listen lifecycl . fire lifecycl event ( befor stop event , null ) ; stop our defin connector first synchron ( connector ) { ( int i = 0 ; i connector . length ; i ) { connector i . paus ( ) ; } } heurist : sleep while ensur paus connector try { thread . sleep ( 1000 ) ; } catch ( interrupt except e ) { ignor } lifecycl . fire lifecycl event ( stop event , null ) ; ( log . info enabl ( ) ) log . info ( sm . get string ( standard servic . stop . name , thi . name ) ) ; start = fals ; stop our defin contain second ( contain = null ) { synchron ( contain ) { ( contain instanceof lifecycl ) { ( ( lifecycl ) contain ) . stop ( ) ; } } } stop our defin connector first synchron ( connector ) { ( int i = 0 ; i connector . length ; i ) { ( ( lifecycl ) connector i ) . stop ( ) ; } } synchron ( executor ) { ( int i = 0 ; i executor . size ( ) ; i ) { executor . get ( i ) . stop ( ) ; } } ( onam = = control ) { we regist ourself init ( ) . should typic case thi object just backward compat , nobodi should bother load explicit registri . get registri ( null , null ) . unregist compon ( onam ) ; executor executor = find executor ( ) ; ( int i = 0 ; i executor . length ; i ) { try { object name executor object name = new object name ( domain : type = executor , name = executor i . get name ( ) ) ; registri . get registri ( null , null ) . unregist compon ( executor object name ) ; } catch ( except e ) { ignor ( invalid , which cannot happen ) } } } notifi our interest lifecycl listen lifecycl . fire lifecycl event ( after stop event , null ) ; }
protect remov object bound specifi name from thi session . session doe have object bound thi name , thi method doe noth . p after thi method execut , object implement code http session bind listen code , contain call code valu unbound ( ) code object . param name name object remov from thi session . param notifi should we notifi interest listen thi attribut remov void remov attribut intern ( string name , boolean notifi ) { avoid npe ( name = = null ) return ; remov thi attribut from our collect object valu = attribut . remov ( name ) ; do we need do valu unbound ( ) attribut remov ( ) notif ( notifi ( valu = = null ) ) { return ; } call valu unbound ( ) method necessari http session bind event event = null ; ( valu instanceof http session bind listen ) { event = new http session bind event ( get session ( ) , name , valu ) ; ( ( http session bind listen ) valu ) . valu unbound ( event ) ; } notifi interest applic event listen context context = ( context ) manag . get contain ( ) ; object listen = context . get applic event listen ( ) ; ( listen = = null ) return ; ( int i = 0 ; i listen . length ; i ) { ( ( listen i instanceof http session attribut listen ) ) continu ; http session attribut listen listen = ( http session attribut listen ) listen i ; try { fire contain event ( context , befor session attribut remov , listen ) ; ( event = = null ) { event = new http session bind event ( get session ( ) , name , valu ) ; } listen . attribut remov ( event ) ; fire contain event ( context , after session attribut remov , listen ) ; } catch ( throwabl t ) { try { fire contain event ( context , after session attribut remov , listen ) ; } catch ( except e ) { ignor } manag . get contain ( ) . get logger ( ) . error ( sm . get string ( standard session . attribut event ) , t ) ; } } }	protect void set access count ( int count ) { ( access count = = null activ check ) access count = new atom integ ( ) ; ( access count = null ) super . access count . set ( count ) ; }	public read reader wrap input stream thi request . default implement wrap code buffer reader code around servlet input stream return code creat input stream ( ) code . except illeg state except code get input stream ( ) code ha alreadi been call thi request except ioexcept input output error occur buffer reader get reader ( ) throw ioexcept { ( us input stream ) throw new illeg state except ( sm . get string ( coyot request . get reader . ) ) ; us reader = true ; input buffer . check convert ( ) ; ( reader = = null ) { reader = new coyot reader ( input buffer ) ; } return reader ; }	public return code enumer code code string code object contain name object bound thi session . except illeg state except thi method call invalid session enumer string get attribut name ( ) { ( valid intern ( ) ) throw new illeg state except ( sm . get string ( standard session . get attribut name . ) ) ; return ( new enumer string ( attribut . kei set ( ) , true ) ) ; }	public object get attribut ( string name ) { return session . get attribut ( name ) ; }	public string get valu name ( ) { ( valid intern ( ) ) throw new illeg state except ( sm . get string ( standard session . get valu name . ) ) ; return ( kei ( ) ) ; }	public string get valu name ( ) { return session . get valu name ( ) ; }	public request dispatch get name dispatch ( string name ) { ( secur util . packag protect enabl ( ) ) { return ( request dispatch ) do privileg ( get name dispatch , new object { name } ) ; } els { return context . get name dispatch ( name ) ; } }	public default behavior thi method return get request dispatch ( string path ) wrap request object . request dispatch get request dispatch ( string path ) { return thi . request . get request dispatch ( path ) ; }	public rx task pool get task pool ( ) { return pool ; }	public deprec enumer string get servlet name ( ) { ( secur util . packag protect enabl ( ) ) { return ( enumer string ) do privileg ( get servlet name , null ) ; } els { return context . get servlet name ( ) ; } }	public return servlet context which thi session belong . servlet context get servlet context ( ) { ( manag = = null ) return ( null ) ; context context = ( context ) manag . get contain ( ) ; ( context = = null ) return ( null ) ; els return ( context . get servlet context ( ) ) ; }	public boolean secur ( ) { return fals ; }	public default behavior thi method return encod redirect url ( string url ) wrap respons object . string encod redirect url ( string url ) { return thi . get http servlet respons ( ) . encod redirect url ( url ) ; }	public encod session identifi associ thi respons specifi redirect url , necessari . param url url encod string encod redirect url ( string url ) { ( encod ( absolut ( url ) ) ) { return ( encod ( url , request . get session intern ( ) . get id intern ( ) ) ) ; } els { return ( url ) ; } }	public encod session identifi associ thi respons specifi url , necessari . param url url encod string encod url ( string url ) { string absolut = absolut ( url ) ; ( encod ( absolut ) ) { w3c spec clearli said ( url . equal ignor case ( ) ) { url = absolut ; } return ( encod ( url , request . get session intern ( ) . get id intern ( ) ) ) ; } els { return ( url ) ; } }	public default behavior thi method call encod url ( string url ) wrap respons object . deprec version 3 . 0 java servlet api string encod url ( string url ) { return thi . get http servlet respons ( ) . encod url ( url ) ; }	public string get address ( ) { return properti . get properti ( mcast address ) ; }	public string get bind ( ) { return properti . get properti ( mcast bind address ) ; }	public deprec us get manag templat ( ) . get class ( ) . get name ( ) instead . return string string get manag class name ( ) { return manag templat . get class ( ) . get name ( ) ; }	public return name version servlet contain . string get server info ( ) { return ( server info . get server info ( ) ) ; }	return descript inform about thi server . string get server info ( ) { return ( jsp cservlet context 1 . 0 ) ; }	public deprec java servlet api 2 . 1 , direct replac . enumer servlet get servlet ( ) { return ( new enumer servlet ( empti servlet ) ) ; }	public return empti enumer servlet . deprec thi method ha been deprec replac enumer servlet get servlet ( ) { return ( new vector servlet ( ) . element ( ) ) ; }	public boolean listen ( ) { return listen ; }	public return code true code client doe yet know about session , client choos join session . exampl , server us onli cooki base session , client ha disabl us cooki , session would new each request . except illeg state except thi method call invalid session boolean new ( ) { ( valid intern ( ) ) throw new illeg state except ( sm . get string ( standard session . new . ) ) ; return ( thi . new ) ; }	public return code boolean code indic whether servlet perman unavail . so , someth wrong servlet , system administr must take some correct action . return code true code servlet perman unavail ; code fals code servlet avail temporarili unavail boolean perman ( ) { return perman ; }	public default behavior thi method return request session id from url ( ) wrap request object . boolean request session id from url ( ) { return thi . get http servlet request ( ) . request session id from url ( ) ; }	public return code true code session identifi includ thi request came from request uri . boolean request session id from url ( ) { ( request session id = null ) return ( request session url ) ; els return ( fals ) ; }	read charact . char read char ( ) throw java . io . ioexcept { ( buf 0 ) { buf ; ( bufpo = = bufsiz ) bufpo = 0 ; return buffer bufpo ; } ( bufpo = max next char ind ) fill buff ( ) ; char c = buffer bufpo ; updat line column ( c ) ; return c ; }	public deprec see get end column int get column ( ) { return bufcolumn bufpo ; }	public int get max inact interv ( ) { return session . get max inact interv ( ) ; }	public int get port ( ) { string p = properti . get properti ( mcast port ) ; return new integ ( p ) . int valu ( ) ; }	public int get so timeout ( ) { return mcast so timeout ; }	public byte get domain ( ) { return domain ; }	public int get tx buf size ( ) { return tx buf size ; }	public long get selector timeout ( ) { return tcp selector timeout ; }	public static byte byte ( long n , byte b , int offset ) { b offset 7 = ( byte ) ( n ) ; n >> = 8 ; b offset 6 = ( byte ) ( n ) ; n >> = 8 ; b offset 5 = ( byte ) ( n ) ; n >> = 8 ; b offset 4 = ( byte ) ( n ) ; n >> = 8 ; b offset 3 = ( byte ) ( n ) ; n >> = 8 ; b offset 2 = ( byte ) ( n ) ; n >> = 8 ; b offset 1 = ( byte ) ( n ) ; n >> = 8 ; b offset 0 = ( byte ) ( n ) ; return b ; }	public static byte byte ( boolean bool , byte data , int offset ) { data offset = ( byte ) ( bool 1 : 0 ) ; return data ; }	public deprec string encod url ( string url ) { return null ; }	public add properti chang listen thi compon . param listen listen add void add properti chang listen ( properti chang listen listen ) { support . add properti chang listen ( listen ) ; }	public thi method call when begin match xml element encount . default implement deleg deprec method { link begin ( attribut ) begin } without code namespac code code name code paramet , retain backward compat . param namespac namespac uri match element , empti string parser namespac awar element ha namespac param name local name parser namespac awar , just element name otherwis param attribut attribut list thi element sinc digest 1 . 4 void begin ( string namespac , string name , attribut attribut ) throw except { begin ( attribut ) ; }	public thi method call when bodi match xml element encount . element ha bodi , thi method call all . default implement deleg deprec method { link bodi ( string ) bodi } without code namespac code code name code paramet , retain backward compat . param namespac namespac uri match element , empti string parser namespac awar element ha namespac param name local name parser namespac awar , just element name otherwis param text text bodi thi element sinc digest 1 . 4 void bodi ( string namespac , string name , string text ) throw except { bodi ( text ) ; }	public void broadcast ( channel messag messag ) throw channel except { ( impl = = null ( impl . start level channel . mbr tx seq ) = channel . mbr tx seq ) throw new channel except ( multicast send start enabl . ) ; byte data = xbyte buffer . creat data packag ( ( channel data ) messag ) ; ( data . length mcast servic impl . max packet size ) { throw new channel except ( packet length data . length exce max packet size mcast servic impl . max packet size byte . ) ; } datagram packet packet = new datagram packet ( data , 0 , data . length ) ; try { impl . send ( fals , packet ) ; } catch ( except x ) { throw new channel except ( x ) ; } }	public write specifi messag servlet log file . param messag messag written void log ( string messag ) { context . get logger ( ) . info ( messag ) ; }	public log specifi messag . param messag messag log void log ( string messag ) { my log writer . println ( messag ) ; }	public void log ( string msg ) { ( secur util . packag protect enabl ( ) ) { do privileg ( log , new object { msg } ) ; } els { context . log ( msg ) ; } }	public void remov attribut ( string name ) { session . remov attribut ( name ) ; }	public remov object bound specifi name from thi session . session doe have object bound thi name , thi method doe noth . p after thi method execut , object implement code http session bind listen code , contain call code valu unbound ( ) code object . param name name object remov from thi session . param notifi should we notifi interest listen thi attribut remov except illeg state except thi method call invalid session void remov attribut ( string name , boolean notifi ) { valid our current state ( valid intern ( ) ) throw new illeg state except ( sm . get string ( standard session . remov attribut . ) ) ; remov attribut intern ( name , notifi ) ; }	public void set address ( string addr ) { properti . set properti ( mcast address , addr ) ; }	public void set attribut ( string name , object valu ) { session . set attribut ( name , valu ) ; }	public void set bind ( string bindaddr ) { properti . set properti ( mcast bind address , bindaddr ) ; }	public param bind bind set . void set bind ( java . net . inet address bind ) { thi . bind = bind ; }	public set code catalina . base code system properti current work directori ha been set . deprec us init dir ( ) void set catalina base ( ) { init dir ( ) ; }	public void set drop time ( long time ) { properti . set properti ( member drop time , string . valu ( time ) ) ; }	public void set frequenc ( long time ) { properti . set properti ( mcast frequenc , string . valu ( time ) ) ; }	public set last modifi . param last modifi new last modifi valu void set last modifi ( long last modifi ) { thi . last modifi = last modifi ; thi . last modifi date = null ; ( attribut = null ) attribut . put ( last modifi , new date ( last modifi ) ) ; }	public void set local loopback disabl ( boolean local loopback disabl ) { properti . set properti ( local loopback disabl , string . valu ( local loopback disabl ) ) ; }	public set messag listen param listen messag listen todo implement thi org . apach . catalina . tribe . channel receiv method void set messag listen ( messag listen listen ) { thi . listen = listen ; }	public set namespac uri which thi rule relev , ani . param namespac uri namespac uri which thi rule relev , code null code match independ namespac . void set namespac uri ( string namespac uri ) { thi . namespac uri = namespac uri ; }	public param notifi listen failur notifi lifecycl listen failur set . void set notifi lifecycl listen failur ( boolean notifi listen failur ) { boolean old notifi listen failur = thi . notifi lifecycl listen failur ; thi . notifi lifecycl listen failur = notifi listen failur ; support . fire properti chang ( notifi lifecycl listen failur , old notifi listen failur , thi . notifi lifecycl listen failur ) ; }	public void set so timeout ( int mcast so timeout ) { thi . mcast so timeout = mcast so timeout ; properti . set properti ( mcast so timeout , string . valu ( mcast so timeout ) ) ; }	public default behavior thi method call set statu ( int sc ) wrap respons object . void set statu ( int sc ) { thi . get http servlet respons ( ) . set statu ( sc ) ; }	public disallow code set statu ( ) code call includ respons . param sc new statu code void set statu ( int sc ) { ( includ ) ( ( http servlet respons ) get respons ( ) ) . set statu ( sc ) ; }	public set http statu return thi respons . param statu new http statu void set statu ( int statu ) { set statu ( statu , null ) ; }	public void set statu ( int statu ) { }	public deprec us set port param tcp listen port int void set tcp listen port ( int tcp listen port ) { set port ( tcp listen port ) ; }	public void set tx buf size ( int tx buf size ) { thi . tx buf size = tx buf size ; }	public void stop server ( string argument ) { ( argument = null ) { argument ( argument ) ; } ( server = = null ) { creat execut our digest digest digest = creat stop digest ( ) ; digest . set class loader ( thread . current thread ( ) . get context class loader ( ) ) ; file file = config file ( ) ; try { input sourc = new input sourc ( file : file . get absolut path ( ) ) ; file input stream fi = new file input stream ( file ) ; . set byte stream ( fi ) ; digest . push ( thi ) ; digest . pars ( ) ; fi . close ( ) ; } catch ( except e ) { log . error ( catalina . stop : , e ) ; system . exit ( 1 ) ; } } stop exist server try { ( server . get port ( ) 0 ) { socket socket = new socket ( server . get address ( ) , server . get port ( ) ) ; output stream stream = socket . get output stream ( ) ; string shutdown = server . get shutdown ( ) ; ( int i = 0 ; i shutdown . length ( ) ; i ) stream . write ( shutdown . char ( i ) ) ; stream . flush ( ) ; stream . close ( ) ; socket . close ( ) ; } els { log . error ( sm . get string ( catalina . stop server ) ) ; system . exit ( 1 ) ; } } catch ( ioexcept e ) { log . error ( catalina . stop : , e ) ; system . exit ( 1 ) ; } }
public void begin ( string namespac , string name , attribut attribut ) throw except { ( login config set ) { throw new illeg argument except ( login config element limit 1 occurr ) ; } login config set = true ; }	public reset counter us valid web . xml file . void recycl ( ) { jsp config . jsp config set = fals ; session config . session config set = fals ; login config . login config set = fals ; }
privat static digest creat tld digest ( boolean namespac awar , boolean valid ) { digest digest = null ; ( namespac awar valid ) { ( tld digest 0 = = null ) { tld digest 0 = digest factori . new digest ( valid , namespac awar , new tld rule set ( ) ) ; } digest = tld digest 0 ; } els ( namespac awar valid ) { ( tld digest 1 = = null ) { tld digest 1 = digest factori . new digest ( valid , namespac awar , new tld rule set ( ) ) ; } digest = tld digest 1 ; } els ( namespac awar valid ) { ( tld digest 2 = = null ) { tld digest 2 = digest factori . new digest ( valid , namespac awar , new tld rule set ( ) ) ; } digest = tld digest 2 ; } els { ( tld digest 3 = = null ) { tld digest 3 = digest factori . new digest ( valid , namespac awar , new tld rule set ( ) ) ; } digest = tld digest 3 ; } return digest ; }	public get server . xml lt ; host gt ; attribut s xml valid . return true valid enabl . boolean get tld valid ( ) { return thi . tld valid ; }

protect identifi applic web . xml us obtain input sourc . input sourc get context web xml sourc ( ) { input stream stream = null ; input sourc sourc = null ; url url = null ; string alt ddname = null ; open applic web . xml file , exist servlet context servlet context = context . get servlet context ( ) ; ( servlet context = null ) { alt ddname = ( string ) servlet context . get attribut ( global . alt dd attr ) ; ( alt ddname = null ) { try { stream = new file input stream ( alt ddname ) ; url = new file ( alt ddname ) . uri ( ) . url ( ) ; } catch ( file found except e ) { log . error ( sm . get string ( context config . alt ddnot found , alt ddname ) ) ; } catch ( malform urlexcept e ) { log . error ( sm . get string ( context config . applic url ) ) ; } } els { stream = servlet context . get resourc stream ( constant . applic web xml ) ; try { url = servlet context . get resourc ( constant . applic web xml ) ; } catch ( malform urlexcept e ) { log . error ( sm . get string ( context config . applic url ) ) ; } } } ( stream = = null url = = null ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( context config . applic miss ) context ) ; } } els { sourc = new input sourc ( url . extern form ( ) ) ; sourc . set byte stream ( stream ) ; } return sourc ; }	protect synchron process stop event thi context . void stop ( ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( context config . stop ) ) ; int i ; remov children contain children = context . find children ( ) ; ( i = 0 ; i children . length ; i ) { context . remov child ( children i ) ; } remov applic paramet applic paramet applic paramet = context . find applic paramet ( ) ; ( i = 0 ; i applic paramet . length ; i ) { context . remov applic paramet ( applic paramet i . get name ( ) ) ; } remov secur constraint secur constraint secur constraint = context . find constraint ( ) ; ( i = 0 ; i secur constraint . length ; i ) { context . remov constraint ( secur constraint i ) ; } remov ejb context ejb context ejb = context . find ejb ( ) ; ( i = 0 ; i context ejb . length ; i ) { context . remov ejb ( context ejb i . get name ( ) ) ; } remov environ context environ context environ = context . find environ ( ) ; ( i = 0 ; i context environ . length ; i ) { context . remov environ ( context environ i . get name ( ) ) ; } remov error page error page error page = context . find error page ( ) ; ( i = 0 ; i error page . length ; i ) { context . remov error page ( error page i ) ; } remov filter def filter def filter def = context . find filter def ( ) ; ( i = 0 ; i filter def . length ; i ) { context . remov filter def ( filter def i ) ; } remov filter map filter map filter map = context . find filter map ( ) ; ( i = 0 ; i filter map . length ; i ) { context . remov filter map ( filter map i ) ; } remov local ejb context local ejb context local ejb = context . find local ejb ( ) ; ( i = 0 ; i context local ejb . length ; i ) { context . remov local ejb ( context local ejb i . get name ( ) ) ; } remov mime map string mime map = context . find mime map ( ) ; ( i = 0 ; i mime map . length ; i ) { context . remov mime map ( mime map i ) ; } remov paramet string paramet = context . find paramet ( ) ; ( i = 0 ; i paramet . length ; i ) { context . remov paramet ( paramet i ) ; } remov resourc env ref string resourc env ref = context . find resourc env ref ( ) ; ( i = 0 ; i resourc env ref . length ; i ) { context . remov resourc env ref ( resourc env ref i ) ; } remov resourc link context resourc link context resourc link = context . find resourc link ( ) ; ( i = 0 ; i context resourc link . length ; i ) { context . remov resourc link ( context resourc link i . get name ( ) ) ; } remov resourc context resourc context resourc = context . find resourc ( ) ; ( i = 0 ; i context resourc . length ; i ) { context . remov resourc ( context resourc i . get name ( ) ) ; } remov sercur role string secur role = context . find secur role ( ) ; ( i = 0 ; i secur role . length ; i ) { context . remov secur role ( secur role i ) ; } remov servlet map string servlet map = context . find servlet map ( ) ; ( i = 0 ; i servlet map . length ; i ) { context . remov servlet map ( servlet map i ) ; } fixm : remov statu page remov taglib string taglib = context . find taglib ( ) ; ( i = 0 ; i taglib . length ; i ) { context . remov taglib ( taglib i ) ; } remov welcom file string welcom file = context . find welcom file ( ) ; ( i = 0 ; i welcom file . length ; i ) { context . remov welcom file ( welcom file i ) ; } remov wrapper lifecycl string wrapper lifecycl = context . find wrapper lifecycl ( ) ; ( i = 0 ; i wrapper lifecycl . length ; i ) { context . remov wrapper lifecycl ( wrapper lifecycl i ) ; } remov wrapper listen string wrapper listen = context . find wrapper listen ( ) ; ( i = 0 ; i wrapper listen . length ; i ) { context . remov wrapper listen ( wrapper listen i ) ; } remov ( partial ) folder file creat anti lock host host = ( host ) context . get parent ( ) ; string app base = host . get app base ( ) ; string doc base = context . get doc base ( ) ; ( ( doc base = null ) ( origin doc base = null ) ) { file doc base file = new file ( doc base ) ; ( doc base file . absolut ( ) ) { doc base file = new file ( app base , doc base ) ; } expand war . delet ( doc base file ) ; } ok = true ; }
public get server . xml lt ; host gt ; attribut s xml namespac awar . return true namespac awaren enabl . boolean get xml namespac awar ( ) { return xml namespac awar ; }	public get server . xml lt ; host gt ; attribut s xml valid . return true valid enabl . boolean get xml valid ( ) { return xml valid ; }	public get instant where applic wa deploi . return 0l applic name deploi , instant which applic wa deploi long get deploy time ( string name ) { deploi applic app = deploi . get ( name ) ; ( app = = null ) { return 0l ; } els { return app . timestamp ; } }	public check statu specif webapp , us stuff like manag webapp . void check ( string name ) { deploi applic app = deploi . get ( name ) ; ( app = null ) { check resourc ( app ) ; } els { deploi app ( name ) ; } }
public enabl disabl name support . param us name new us name valu void set us name ( boolean us name ) { boolean old us name = thi . us name ; thi . us name = us name ; support . fire properti chang ( us name , new boolean ( old us name ) , new boolean ( thi . us name ) ) ; }	public gracefulli termin activ us public method thi compon . thi method should last call given instanc thi compon . except lifecycl except thi compon detect fatal error need report void stop ( ) throw lifecycl except { ( log . debug enabl ( ) ) log . debug ( stop embed server ) ; valid updat our current compon state ( start ) throw new lifecycl except ( sm . get string ( embed . start ) ) ; lifecycl . fire lifecycl event ( stop event , null ) ; start = fals ; stop our defin connector first ( int i = 0 ; i connector . length ; i ) { ( ( lifecycl ) connector i ) . stop ( ) ; } stop our defin engin second ( int i = 0 ; i engin . length ; i ) { ( engin i instanceof lifecycl ) ( ( lifecycl ) engin i ) . stop ( ) ; } }
public static get current connect from em ref em paramet creat new return server connect throw malform urlexcept throw ioexcept mbean server connect access jmxconnect ( project project , string url , string host , string port , string usernam , string password , string ref id ) throw malform urlexcept , ioexcept { mbean server connect jmx server connect = null ; boolean ref = project = null ref id = null ref id . length ( ) 0 ; ( ref ) { object pref = project . get refer ( ref id ) ; try { jmx server connect = ( mbean server connect ) pref ; } catch ( class cast except cce ) { ( project = null ) { project . log ( wrong object refer ref id pref . get class ( ) ) ; } return null ; } } ( jmx server connect = = null ) { jmx server connect = creat jmxconnect ( url , host , port , usernam , password ) ; } ( ref jmx server connect = null ) { project . add refer ( ref id , jmx server connect ) ; } return jmx server connect ; }	public void count down ( count down latch latch ) { ( latch = = null ) return ; latch . count down ( ) ; }	public thi method invok tomcat each queri . param request request object . param respons respons object . except ioexcept should thrown . except servlet except databas sqlexcept wrap servlet except . void invok ( request request , respons respons ) throw ioexcept , servlet except { final string empti = ; get next ( ) . invok ( request , respons ) ; string remot host = empti ; ( resolv host ) remot host = request . get remot host ( ) ; els remot host = request . get remot addr ( ) ; string user = empti ; ( request = null ) user = request . get remot user ( ) ; string queri = ; ( request = null ) queri = request . get request uri ( ) ; long byte = respons . get content count long ( ) ; ( byte 0 ) byte = 0 ; int statu = respons . get statu ( ) ; string virtual host = empti ; string method = empti ; string refer = empti ; string user agent = empti ; ( pattern . equal ( combin ) request = null ) { virtual host = request . get server name ( ) ; method = request . get method ( ) ; refer = request . get header ( refer ) ; user agent = request . get header ( user agent ) ; } synchron ( thi ) { int number tri = 2 ; while ( number tri 0 ) { try { open ( ) ; ps . set string ( 1 , remot host ) ; ps . set string ( 2 , user ) ; ps . set timestamp ( 3 , new timestamp ( get current time milli ( ) ) ) ; ps . set string ( 4 , queri ) ; ps . set int ( 5 , statu ) ; ( us long content length ) { ps . set long ( 6 , byte ) ; } els { ( byte integ . max valu ) byte = 1 ; ps . set int ( 6 , ( int ) byte ) ; } ( pattern . equal ( combin ) ) { ps . set string ( 7 , virtual host ) ; ps . set string ( 8 , method ) ; ps . set string ( 9 , refer ) ; ps . set string ( 10 , user agent ) ; } ps . execut updat ( ) ; return ; } catch ( sqlexcept e ) { log problem poster contain . get logger ( ) . error ( sm . get string ( jdbc access log valv . except ) , e ) ; close connect so get reopen next time ( conn = null ) close ( ) ; } number tri ; } } }	public void run ( ) { while ( run ) { try { event ( ) ; int kei count = 0 ; try { int i = wakeup counter . get ( ) ; ( i 0 ) kei count = selector . select now ( ) ; els { wakeup counter . set ( 1 ) ; kei count = selector . select ( 1000 ) ; } wakeup counter . set ( 0 ) ; ( run ) break ; } catch ( null pointer except x ) { sun bug 5076772 window jdk 1 . 5 ( selector = = null ) throw x ; ( log . debug enabl ( ) ) log . debug ( possibl encount sun bug 5076772 window jdk 1 . 5 , x ) ; continu ; } catch ( cancel kei except x ) { sun bug 5076772 window jdk 1 . 5 ( log . debug enabl ( ) ) log . debug ( possibl encount sun bug 5076772 window jdk 1 . 5 , x ) ; continu ; } catch ( throwabl x ) { log . error ( , x ) ; continu ; } iter select kei iter = kei count 0 selector . select kei ( ) . iter ( ) : null ; ani activ event . while ( run iter = null iter . ha next ( ) ) { select kei sk = iter . next ( ) ; kei attach attach = ( kei attach ) sk . attach ( ) ; try { attach . access ( ) ; iter . remov ( ) ; sk . interest op ( sk . interest op ( ) ( sk . readi op ( ) ) ) ; ( sk . readabl ( ) ) { count down ( attach . get read latch ( ) ) ; } ( sk . writabl ( ) ) { count down ( attach . get write latch ( ) ) ; } } catch ( cancel kei except ckx ) { ( sk = null ) sk . cancel ( ) ; count down ( attach . get read latch ( ) ) ; count down ( attach . get write latch ( ) ) ; } } while } catch ( throwabl t ) { log . error ( , t ) ; } } event . clear ( ) ; try { cancel all remain kei selector . select now ( ) ; } catch ( except ignor ) { ( log . debug enabl ( ) ) log . debug ( , ignor ) ; } try { close connector selector . close ( ) ; } catch ( except ignor ) { ( log . debug enabl ( ) ) log . debug ( , ignor ) ; } }
public stop catalina daemon . void stop ( ) throw except { method method = catalina daemon . get class ( ) . get method ( stop , ( class ) null ) ; method . invok ( catalina daemon , ( object ) null ) ; }	public stop standlon server . void stop server ( ) throw except { method method = catalina daemon . get class ( ) . get method ( stop server , ( class ) null ) ; method . invok ( catalina daemon , ( object ) null ) ; }
protect print usag inform thi applic . void usag ( ) { system . out . println ( usag : java org . apach . catalina . startup . catalina config { pathnam } nonam { start stop } ) ; }
public static main method , us test onli . param arg command line argument process void main ( string arg ) { ( daemon = = null ) { daemon = new bootstrap ( ) ; try { daemon . init ( ) ; } catch ( throwabl t ) { t . print stack trace ( ) ; return ; } } try { string command = start ; ( arg . length 0 ) { command = arg arg . length 1 ; } ( command . equal ( startd ) ) { arg 0 = start ; daemon . load ( arg ) ; daemon . start ( ) ; } els ( command . equal ( stopd ) ) { arg 0 = stop ; daemon . stop ( ) ; } els ( command . equal ( start ) ) { daemon . set await ( true ) ; daemon . load ( arg ) ; daemon . start ( ) ; } els ( command . equal ( stop ) ) { daemon . stop server ( arg ) ; } els { log . warn ( bootstrap : command command doe exist . ) ; } } catch ( throwabl t ) { t . print stack trace ( ) ; } }
privat make sure given custom action doe have ani invalid attribut . custom action declar attribut alwai belong same namespac , which identifi prefix name custom tag invoc . exampl , thi invoc : my : test = 1 b = 2 c = 3 , action test attribut , b , c all belong namespac identifi prefix my . abov invoc would equival : my : test my : = 1 my : b = 2 my : c = 3 action attribut mai have prefix differ from action invoc onli underli tag handler support dynam attribut , which case attribut differ prefix consid dynam attribut . void check xml attribut ( node . custom tag n , node . jsp attribut jsp attr , hashtabl string , object tag data attr ) throw jasper except { tag info tag info = n . get tag info ( ) ; ( tag info = = null ) { err . jsp error ( n , jsp . error . miss . tag info , n . get qname ( ) ) ; } tag attribut info tld attr = tag info . get attribut ( ) ; attribut attr = n . get attribut ( ) ; boolean check defer = page info . defer syntax allow liter ( ) ( tag info . get tag librari ( ) . get requir version ( ) . equal ( 2 . 0 ) tag info . get tag librari ( ) . get requir version ( ) . equal ( 1 . 2 ) ) ; ( int i = 0 ; attr = null i attr . get length ( ) ; i ) { boolean found = fals ; boolean runtim express = ( ( n . get root ( ) . xml syntax ( ) attr . get valu ( i ) . start ( = ) ) ( n . get root ( ) . xml syntax ( ) attr . get valu ( i ) . start ( = ) ) ) ; boolean el express = fals ; boolean defer = fals ; boolean defer valu liter = fals ; elnod . node el = null ; ( runtim express ) { el = elpars . pars ( attr . get valu ( i ) ) ; iter elnod node = el . iter ( ) ; while ( node . ha next ( ) ) { elnod node = node . next ( ) ; ( node instanceof elnod . root ) { ( ( ( elnod . root ) node ) . get type ( ) = = ) { el express = true ; } els ( check defer ( ( elnod . root ) node ) . get type ( ) = = ) { el express = true ; defer = true ; ( page info . elignor ( ) ) { defer valu liter = true ; } } } } } boolean express = runtim express ( el express ( page info . elignor ( ) ( true . equal ignor case ( page info . get elignor ( ) ) check defer defer ) ) ) ; ( int j = 0 ; tld attr = null j tld attr . length ; j ) { ( attr . get local name ( i ) . equal ( tld attr j . get name ( ) ) ( attr . get uri ( i ) = = null attr . get uri ( i ) . length ( ) = = 0 attr . get uri ( i ) . equal ( n . get uri ( ) ) ) ) { ( tld attr j . can request time ( ) tld attr j . defer method ( ) tld attr j . defer valu ( ) ) { jsp 2 . 1 ( express ) { ( defer valu liter page info . defer syntax allow liter ( ) ) { err . jsp error ( n , jsp . error . attribut . custom . non rt expr , tld attr j . get name ( ) ) ; } string expect type = null ; ( tld attr j . defer method ( ) ) { string litter must castabl what declar type attribut string m = tld attr j . get method signatur ( ) ; ( m = null ) { int rti = m . trim ( ) . index ( ) ; ( rti 0 ) { expect type = m . substr ( 0 , rti ) . trim ( ) ; } } els { expect type = java . lang . object ; } } ( tld attr j . defer valu ( ) ) { string litter must castabl what declar type attribut expect type = tld attr j . get expect type name ( ) ; } ( expect type = null ) { class expect class = string . class ; try { expect class = jsp util . class ( expect type , loader ) ; } catch ( class found except e ) { err . jsp error ( n , jsp . error . unknown attribut type , tld attr j . get name ( ) , expect type ) ; } check cast try { elsupport . check type ( attr . get valu ( i ) , expect class ) ; } catch ( except e ) { err . jsp error ( n , jsp . error . coerc type , tld attr j . get name ( ) , expect type , attr . get valu ( i ) ) ; } } jsp attr i = new node . jsp attribut ( tld attr j , attr . get qname ( i ) , attr . get uri ( i ) , attr . get local name ( i ) , attr . get valu ( i ) , fals , null , fals ) ; } els { ( defer tld attr j . defer method ( ) tld attr j . defer valu ( ) ) { defer express allow thi attribut err . jsp error ( n , jsp . error . attribut . custom . non rt expr , tld attr j . get name ( ) ) ; } ( defer tld attr j . can request time ( ) ) { onli defer express ar allow thi attribut err . jsp error ( n , jsp . error . attribut . custom . non rt expr , tld attr j . get name ( ) ) ; } ( el express ) { el express valid function ( el , n ) ; jsp attr i = new node . jsp attribut ( tld attr j , attr . get qname ( i ) , attr . get uri ( i ) , attr . get local name ( i ) , attr . get valu ( i ) , fals , el , fals ) ; elcontext impl ctx = new elcontext impl ( ) ; ctx . set function mapper ( get function mapper ( el ) ) ; try { jsp attr i . valid el ( thi . page info . get express factori ( ) , ctx ) ; } catch ( elexcept e ) { thi . err . jsp error ( n . get start ( ) , jsp . error . invalid . express , attr . get valu ( i ) , e . string ( ) ) ; } } els { runtim express jsp attr i = get jsp attribut ( tld attr j , attr . get qname ( i ) , attr . get uri ( i ) , attr . get local name ( i ) , attr . get valu ( i ) , n , fals ) ; } } } els { make sure valu doe contain ani . ( express ) { err . jsp error ( n , jsp . error . attribut . custom . non rt expr , tld attr j . get name ( ) ) ; } jsp attr i = new node . jsp attribut ( tld attr j , attr . get qname ( i ) , attr . get uri ( i ) , attr . get local name ( i ) , attr . get valu ( i ) , fals , null , fals ) ; } ( express ) { tag data attr . put ( attr . get qname ( i ) , tag data . request time valu ) ; } els { tag data attr . put ( attr . get qname ( i ) , attr . get valu ( i ) ) ; } found = true ; break ; } } ( found ) { ( tag info . ha dynam attribut ( ) ) { jsp attr i = get jsp attribut ( null , attr . get qname ( i ) , attr . get uri ( i ) , attr . get local name ( i ) , attr . get valu ( i ) , n , true ) ; } els { err . jsp error ( n , jsp . error . bad attribut , attr . get qname ( i ) , n . get local name ( ) ) ; } } } }	public void visit ( node . uninterpret tag n ) throw jasper except { ( n . get name attribut node ( ) . size ( ) = 0 ) { err . jsp error ( n , jsp . error . name attribut . invalid us ) ; } attribut attr = n . get attribut ( ) ; ( attr = null ) { int attr size = attr . get length ( ) ; node . jsp attribut jsp attr = new node . jsp attribut attr size ; ( int i = 0 ; i attr size ; i ) { jsp attr i = get jsp attribut ( null , attr . get qname ( i ) , attr . get uri ( i ) , attr . get local name ( i ) , attr . get valu ( i ) , n , fals ) ; } n . set jsp attribut ( jsp attr ) ; } visit bodi ( n ) ; }
add specifi date header specifi valu . param name name header set param valu date valu set void add date header ( string name , long valu ) { ( commit ( ) ) return ; ignor ani call from includ servlet ( includ ) { return ; } ( format = = null ) { format = new simpl date format ( date tool . http respons date header , local . us ) ; format . set time zone ( time zone . get time zone ( gmt ) ) ; } add header ( name , fast http date format . format date ( valu , format ) ) ; }	public add specifi header specifi valu . param name name header set param valu valu set void add header ( string name , string valu ) { ( commit ( ) ) return ; ignor ani call from includ servlet ( includ ) return ; coyot respons . add header ( name , valu ) ; }	public add specifi integ header specifi valu . param name name header set param valu integ valu set void add int header ( string name , int valu ) { ( commit ( ) ) return ; ignor ani call from includ servlet ( includ ) return ; add header ( name , valu ) ; }	public set specifi date header specifi valu . param name name header set param valu date valu set void set date header ( string name , long valu ) { ( commit ( ) ) return ; ignor ani call from includ servlet ( includ ) { return ; } ( format = = null ) { format = new simpl date format ( date tool . http respons date header , local . us ) ; format . set time zone ( time zone . get time zone ( gmt ) ) ; } set header ( name , fast http date format . format date ( valu , format ) ) ; }	public set specifi header specifi valu . param name name header set param valu valu set void set header ( string name , string valu ) { ( commit ( ) ) return ; ignor ani call from includ servlet ( includ ) return ; coyot respons . set header ( name , valu ) ; }	public set specifi integ header specifi valu . param name name header set param valu integ valu set void set int header ( string name , int valu ) { ( commit ( ) ) return ; ignor ani call from includ servlet ( includ ) return ; set header ( name , valu ) ; }
public return name all request attribut thi request , empti code enumer code ar none . enumer string get attribut name ( ) { ( secur ( ) ) { get attribut ( global . certif attr ) ; } return new enumer string ( attribut . kei set ( ) , true ) ; }
protect synchron check resourc redeploy reload . void check resourc ( deploi applic app ) { string resourc = app . redeploi resourc . kei set ( ) . arrai ( new string 0 ) ; ( int i = 0 ; i resourc . length ; i ) { file resourc = new file ( resourc i ) ; ( log . debug enabl ( ) ) log . debug ( check context app . name redeploi resourc resourc ) ; ( resourc . exist ( ) ) { long last modifi = app . redeploi resourc . get ( resourc i ) . long valu ( ) ; ( ( resourc . directori ( ) ) resourc . last modifi ( ) last modifi ) { undeploi applic ( log . info enabl ( ) ) log . info ( sm . get string ( host config . undeploi , app . name ) ) ; contain base context = ( contain base ) host . find child ( app . name ) ; try { host . remov child ( context ) ; } catch ( throwabl t ) { log . warn ( sm . get string ( host config . context . remov , app . name ) , t ) ; } try { context . destroi ( ) ; } catch ( throwabl t ) { log . warn ( sm . get string ( host config . context . destroi , app . name ) , t ) ; } delet other redeploi resourc ( int j = i 1 ; j resourc . length ; j ) { try { file current = new file ( resourc j ) ; current = current . get canon file ( ) ; ( ( current . get absolut path ( ) . start ( app base ( ) . get absolut path ( ) file . separ ) ) ( current . get absolut path ( ) . start ( config base ( ) . get absolut path ( ) ) ) ) { ( log . debug enabl ( ) ) log . debug ( delet current ) ; expand war . delet ( current ) ; } } catch ( ioexcept e ) { log . warn ( sm . get string ( host config . canonic , app . name ) , e ) ; } } deploi . remov ( app . name ) ; return ; } } els { long last modifi = app . redeploi resourc . get ( resourc i ) . long valu ( ) ; ( last modifi = = 0l ) { continu ; } undeploi applic ( log . info enabl ( ) ) log . info ( sm . get string ( host config . undeploi , app . name ) ) ; contain base context = ( contain base ) host . find child ( app . name ) ; try { host . remov child ( context ) ; } catch ( throwabl t ) { log . warn ( sm . get string ( host config . context . remov , app . name ) , t ) ; } try { context . destroi ( ) ; } catch ( throwabl t ) { log . warn ( sm . get string ( host config . context . destroi , app . name ) , t ) ; } delet all redeploi resourc ( int j = i 1 ; j resourc . length ; j ) { try { file current = new file ( resourc j ) ; current = current . get canon file ( ) ; ( ( current . get absolut path ( ) . start ( app base ( ) . get absolut path ( ) file . separ ) ) ( current . get absolut path ( ) . start ( config base ( ) . get absolut path ( ) ) ) ) { ( log . debug enabl ( ) ) log . debug ( delet current ) ; expand war . delet ( current ) ; } } catch ( ioexcept e ) { log . warn ( sm . get string ( host config . canonic , app . name ) , e ) ; } } delet reload resourc well ( remov ani remain . xml descriptor ) string resources2 = app . reload resourc . kei set ( ) . arrai ( new string 0 ) ; ( int j = 0 ; j resources2 . length ; j ) { try { file current = new file ( resources2 j ) ; current = current . get canon file ( ) ; ( ( current . get absolut path ( ) . start ( app base ( ) . get absolut path ( ) file . separ ) ) ( ( current . get absolut path ( ) . start ( config base ( ) . get absolut path ( ) ) ( current . get absolut path ( ) . end ( . xml ) ) ) ) ) { ( log . debug enabl ( ) ) log . debug ( delet current ) ; expand war . delet ( current ) ; } } catch ( ioexcept e ) { log . warn ( sm . get string ( host config . canonic , app . name ) , e ) ; } } deploi . remov ( app . name ) ; return ; } } resourc = app . reload resourc . kei set ( ) . arrai ( new string 0 ) ; ( int i = 0 ; i resourc . length ; i ) { file resourc = new file ( resourc i ) ; ( log . debug enabl ( ) ) log . debug ( check context app . name reload resourc resourc ) ; long last modifi = app . reload resourc . get ( resourc i ) . long valu ( ) ; ( ( resourc . exist ( ) last modifi = 0l ) ( resourc . last modifi ( ) = last modifi ) ) { reload applic ( log . info enabl ( ) ) log . info ( sm . get string ( host config . reload , app . name ) ) ; contain context = host . find child ( app . name ) ; try { ( ( lifecycl ) context ) . stop ( ) ; } catch ( except e ) { log . warn ( sm . get string ( host config . context . restart , app . name ) , e ) ; } web . xml ) we ll still get try start try { ( ( lifecycl ) context ) . start ( ) ; } catch ( except e ) { log . warn ( sm . get string ( host config . context . restart , app . name ) , e ) ; } updat time app . reload resourc . put ( resourc i , new long ( resourc . last modifi ( ) ) ) ; app . timestamp = system . current time milli ( ) ; return ; } } }
privat void pars file direct ( node parent ) throw jasper except { reader . set singl file ( true ) ; reader . skip until ( ) ; while ( reader . ha more input ( ) ) { start = reader . mark ( ) ; ( reader . match ( ) ) { pars comment ( parent ) ; } els ( reader . match ( ) ) { pars direct ( parent ) ; } els ( reader . match ( jsp : direct . ) ) { pars xmldirect ( parent ) ; } reader . skip until ( ) ; } }
protect compar session get compar ( string sort ) { compar session compar = null ; ( creation time . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { public compar date get compar object ( session session ) { return new date ( session . get creation time ( ) ) ; } } ; } els ( id . equal ignor case ( sort ) ) { compar = new base session compar string ( ) { public compar string get compar object ( session session ) { return session . get id ( ) ; } } ; } els ( last access time . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { public compar date get compar object ( session session ) { return new date ( session . get last access time ( ) ) ; } } ; } els ( max inact interv . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { public compar date get compar object ( session session ) { return new date ( session . get max inact interv ( ) ) ; } } ; } els ( new . equal ignor case ( sort ) ) { compar = new base session compar boolean ( ) { public compar boolean get compar object ( session session ) { return boolean . valu ( session . get session ( ) . new ( ) ) ; } } ; } els ( local . equal ignor case ( sort ) ) { compar = new base session compar string ( ) { public compar string get compar object ( session session ) { return jsp helper . guess displai local from session ( session ) ; } } ; } els ( user . equal ignor case ( sort ) ) { compar = new base session compar string ( ) { public compar string get compar object ( session session ) { return jsp helper . guess displai user from session ( session ) ; } } ; } els ( us time . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { public compar date get compar object ( session session ) { return new date ( session util . get us time session ( session ) ) ; } } ; } els ( inact time . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { public compar date get compar object ( session session ) { return new date ( session util . get inact time session ( session ) ) ; } } ; } els ( ttl . equal ignor case ( sort ) ) { compar = new base session compar date ( ) { public compar date get compar object ( session session ) { return new date ( session util . get ttlfor session ( session ) ) ; } } ; } todo : complet thi ttl , etc . return compar ; }	public void do get ( http servlet request request , http servlet respons respons ) throw ioexcept , servlet except { identifi request paramet we need obtain command from path info , per command secur can configur web . xml string command = request . get path info ( ) ; string path = request . get paramet ( path ) ; string deploi path = request . get paramet ( deploi path ) ; string deploi config = request . get paramet ( deploi config ) ; string deploi war = request . get paramet ( deploi war ) ; prepar our output writer gener respons messag respons . set content type ( text html ; charset = constant . charset ) ; string messag = ; process request command ( command = = null command . equal ( ) ) { command = = list } els ( command . equal ( deploi ) ) { messag = deploi intern ( deploi config , deploi path , deploi war ) ; } els ( command . equal ( list ) ) { list alwai displai noth do here } els ( command . equal ( reload ) ) { messag = reload ( path ) ; } els ( command . equal ( undeploi ) ) { messag = undeploi ( path ) ; } els ( command . equal ( expir ) ) { messag = expir session ( path , request ) ; } els ( command . equal ( session ) ) { try { do session ( path , request , respons ) ; return ; } catch ( except e ) { log ( htmlmanag servlet . session path , e ) ; messag = sm . get string ( manag servlet . except , e . string ( ) ) ; } } els ( command . equal ( start ) ) { messag = start ( path ) ; } els ( command . equal ( stop ) ) { messag = stop ( path ) ; } els { messag = sm . get string ( manag servlet . unknown command , command ) ; } list ( request , respons , messag ) ; }	public process post request specifi resourc . param request servlet request we ar process param respons servlet respons we ar creat except ioexcept input output error occur except servlet except servlet specifi error occur void do post ( http servlet request request , http servlet respons respons ) throw ioexcept , servlet except { identifi request paramet we need obtain command from path info , per command secur can configur web . xml string command = request . get path info ( ) ; ( command = = null command . equal ( upload ) ) { do get ( request , respons ) ; return ; } prepar our output writer gener respons messag respons . set content type ( text html ; charset = constant . charset ) ; string messag = upload ( request ) ; list ( request , respons , messag ) ; }
protect pars session id url . void pars session id ( org . apach . coyot . request req , request request ) { byte chunk uri bc = req . request uri ( ) . get byte chunk ( ) ; int semicolon = uri bc . index ( match , 0 , match . length ( ) , 0 ) ; ( semicolon 0 ) { pars session id , extract from decod request uri int start = uri bc . get start ( ) ; int end = uri bc . get end ( ) ; int session id start = semicolon match . length ( ) ; int semicolon2 = uri bc . index ( ; , session id start ) ; ( semicolon2 = 0 ) { request . set request session id ( new string ( uri bc . get buffer ( ) , start session id start , semicolon2 session id start ) ) ; extract session id from request uri byte buf = uri bc . get buffer ( ) ; ( int i = 0 ; i end start semicolon2 ; i ) { buf start semicolon i = buf start i semicolon2 ; } uri bc . set byte ( buf , start , end start semicolon2 semicolon ) ; } els { request . set request session id ( new string ( uri bc . get buffer ( ) , start session id start , ( end start ) session id start ) ) ; uri bc . set end ( start semicolon ) ; } request . set request session url ( true ) ; } els { request . set request session id ( null ) ; request . set request session url ( fals ) ; } }
public method void init ( ) throw except { ( initi ) return ; initi thread count default acceptor ( acceptor thread count = = 0 ) { acceptor thread count = 1 ; } ( server socket factori = = null ) { server socket factori = server socket factori . get default ( ) ; } ( server socket = = null ) { try { ( get address ( ) = = null ) { server socket = server socket factori . creat socket ( get port ( ) , get backlog ( ) ) ; } els { server socket = server socket factori . creat socket ( get port ( ) , get backlog ( ) , get address ( ) ) ; } } catch ( bind except ) { ( get address ( ) = = null ) throw new bind except ( . get messag ( ) null : get port ( ) ) ; els throw new bind except ( . get messag ( ) get address ( ) . string ( ) : get port ( ) ) ; } } ( server timeout = 0 ) server socket . set so timeout ( server timeout ) ; initi = true ; }
public void do get ( http servlet request req , http servlet respons re ) throw ioexcept { re . get writer ( ) . write ( hello world ) ; }	public test enabl jndi . void test enabl name ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp standard context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; you can customis context call api enabl jndi disabl default tomcat . enabl name ( ) ; context environ environ = new context environ ( ) ; environ . set type ( java . lang . string ) ; environ . set name ( hello world jndi . jndi env name ) ; environ . set valu ( tomcat user ) ; ctx . get name resourc ( ) . add environ ( environ ) ; tomcat . add servlet ( ctx , jndi servlet , new hello world jndi ( ) ) ; ctx . add servlet map ( , jndi servlet ) ; tomcat . start ( ) ; byte chunk re = get url ( http : localhost : get port ( ) ) ; assert equal ( re . string ( ) , hello , tomcat user ) ; }	start tomcat singl context servlet all programmat , server . xml web . xml us . throw except void test programmat ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; must have real doc base just us temp standard context ctx = tomcat . add context ( , system . get properti ( java . io . tmpdir ) ) ; you can custom context call api tomcat . add servlet ( ctx , my servlet , new hello world ( ) ) ; ctx . add servlet map ( , my servlet ) ; tomcat . start ( ) ; byte chunk re = get url ( http : localhost : get port ( ) ) ; assert equal ( re . string ( ) , hello world ) ; }	public void test singl webapp ( ) throw except { tomcat tomcat = get tomcat instanc ( ) ; current sandbox tomcat lite file app dir = new file ( output build webapp exampl ) ; app dir rel server home tomcat . add webapp ( null , exampl , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; byte chunk re = get url ( http : localhost : get port ( ) exampl servlet servlet hello world exampl ) ; assert true ( re . string ( ) . index ( h1 hello world h1 ) 0 ) ; }
privat final extens map . void intern map extens wrapper ( wrapper wrapper , char chunk path , map data map data ) { char buf = path . get buffer ( ) ; int path end = path . get end ( ) ; int servlet path = path . get offset ( ) ; int slash = 1 ; ( int i = path end 1 ; i = servlet path ; i ) { ( buf i = = ) { slash = i ; break ; } } ( slash = 0 ) { int period = 1 ; ( int i = path end 1 ; i slash ; i ) { ( buf i = = . ) { period = i ; break ; } } ( period = 0 ) { path . set offset ( period 1 ) ; path . set end ( path end ) ; int po = find ( wrapper , path ) ; ( ( po = 1 ) ( path . equal ( wrapper po . name ) ) ) { map data . wrapper path . set char ( buf , servlet path , path end servlet path ) ; map data . request path . set char ( buf , servlet path , path end servlet path ) ; map data . wrapper = wrapper po . object ; } path . set offset ( servlet path ) ; path . set end ( path end ) ; } } }
public int get max thread ( ) { return max thread ; }
public send action connector . param action code type action param param action paramet void action ( action code action code , object param ) { ( action code = = action code . action commit ) { commit current respons ( respons . commit ( ) ) return ; valid write respons header prepar respons ( ) ; try { output buffer . commit ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . action ack ) { yet , client specifi expect 100 continu ) ( ( respons . commit ( ) ) expect ) return ; input buffer . set swallow input ( true ) ; try { output buffer . send ack ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . action client flush ) { try { output buffer . flush ( ) ; } catch ( ioexcept e ) { set error flag error = true ; respons . set error except ( e ) ; } } els ( action code = = action code . action close ) { close end process current request , stop ani further transact client comet = fals ; try { output buffer . end request ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . action reset ) { reset respons note : thi must call befor respons commit output buffer . reset ( ) ; } els ( action code = = action code . action custom ) { do noth } els ( action code = = action code . action req host addr attribut ) { get remot host address ( remot addr = = null ( socket = 0 ) ) { try { long sa = address . get ( socket . apr remot , socket ) ; remot addr = address . getip ( sa ) ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . remot addr ( ) . set string ( remot addr ) ; } els ( action code = = action code . action req local name attribut ) { get local host name ( local name = = null ( socket = 0 ) ) { try { long sa = address . get ( socket . apr local , socket ) ; local name = address . getnameinfo ( sa , 0 ) ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . local name ( ) . set string ( local name ) ; } els ( action code = = action code . action req host attribut ) { get remot host name ( remot host = = null ( socket = 0 ) ) { try { long sa = address . get ( socket . apr remot , socket ) ; remot host = address . getnameinfo ( sa , 0 ) ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . remot host ( ) . set string ( remot host ) ; } els ( action code = = action code . action req local addr attribut ) { get local host address ( local addr = = null ( socket = 0 ) ) { try { long sa = address . get ( socket . apr local , socket ) ; local addr = address . getip ( sa ) ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . local addr ( ) . set string ( local addr ) ; } els ( action code = = action code . action req remoteport attribut ) { get remot port ( remot port = = 1 ( socket = 0 ) ) { try { long sa = address . get ( socket . apr remot , socket ) ; sockaddr addr = address . get info ( sa ) ; remot port = addr . port ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . set remot port ( remot port ) ; } els ( action code = = action code . action req localport attribut ) { get local port ( local port = = 1 ( socket = 0 ) ) { try { long sa = address . get ( socket . apr local , socket ) ; sockaddr addr = address . get info ( sa ) ; local port = addr . port ; } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . info ) , e ) ; } } request . set local port ( local port ) ; } els ( action code = = action code . action req ssl attribut ) { ( ssl ( socket = 0 ) ) { try { cipher suit object ssl o = sslsocket . get info s ( socket , ssl . ssl info cipher ) ; ( ssl o = null ) { request . set attribut ( apr endpoint . cipher suit kei , ssl o ) ; } get client certif certif chain present int cert length = sslsocket . get info i ( socket , ssl . ssl info client cert chain ) ; byte client cert = sslsocket . get info b ( socket , ssl . ssl info client cert ) ; x509certif cert = null ; ( client cert = null ) { cert = new x509certif cert length 1 ; certif factori cf = certif factori . get instanc ( x . 509 ) ; cert 0 = ( x509certif ) cf . gener certif ( new byte arrai input stream ( client cert ) ) ; ( int i = 0 ; i cert length ; i ) { byte data = sslsocket . get info b ( socket , ssl . ssl info client cert chain i ) ; cert i 1 = ( x509certif ) cf . gener certif ( new byte arrai input stream ( data ) ) ; } } ( cert = null ) { request . set attribut ( apr endpoint . certif kei , cert ) ; } user kei size ssl o = new integ ( sslsocket . get info i ( socket , ssl . ssl info cipher usekeys ) ) ; request . set attribut ( apr endpoint . kei size kei , ssl o ) ; ssl session id ssl o = sslsocket . get info s ( socket , ssl . ssl info session id ) ; ( ssl o = null ) { request . set attribut ( apr endpoint . session id kei , ssl o ) ; } todo provid hook enabl ssl session invalid . set apr endpoint . session mgr req attr } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . ssl ) , e ) ; } } } els ( action code = = action code . action req ssl certif ) { ( ssl ( socket = 0 ) ) { consum buffer request bodi , so doe interfer client s handshak messag input filter input filter = input buffer . get filter ( ) ; ( ( buffer input filter ) input filter constant . buffer filter ) . set limit ( max save post size ) ; input buffer . add activ filter ( input filter constant . buffer filter ) ; try { renegoci certif sslsocket . renegoti ( socket ) ; get client certif certif chain present int cert length = sslsocket . get info i ( socket , ssl . ssl info client cert chain ) ; byte client cert = sslsocket . get info b ( socket , ssl . ssl info client cert ) ; x509certif cert = null ; ( client cert = null ) { cert = new x509certif cert length 1 ; certif factori cf = certif factori . get instanc ( x . 509 ) ; cert 0 = ( x509certif ) cf . gener certif ( new byte arrai input stream ( client cert ) ) ; ( int i = 0 ; i cert length ; i ) { byte data = sslsocket . get info b ( socket , ssl . ssl info client cert chain i ) ; cert i 1 = ( x509certif ) cf . gener certif ( new byte arrai input stream ( data ) ) ; } } ( cert = null ) { request . set attribut ( apr endpoint . certif kei , cert ) ; } } catch ( except e ) { log . warn ( sm . get string ( http11processor . socket . ssl ) , e ) ; } } } els ( action code = = action code . action req set bodi replai ) { byte chunk bodi = ( byte chunk ) param ; input filter save bodi = new save request input filter ( bodi ) ; save bodi . set request ( request ) ; intern apr input buffer intern buffer = ( intern apr input buffer ) request . get input buffer ( ) ; intern buffer . add activ filter ( save bodi ) ; } els ( action code = = action code . action avail ) { request . set avail ( input buffer . avail ( ) ) ; } els ( action code = = action code . action comet begin ) { comet = true ; } els ( action code = = action code . action comet end ) { comet = fals ; } els ( action code = = action code . action comet close ) { op } els ( action code = = action code . action comet settimeout ) { op } els ( action code = = action code . action async start ) { todo servlet3 async } els ( action code = = action code . action async complet ) { todo servlet3 async } els ( action code = = action code . action async settimeout ) { todo servlet3 async } }
void init base dir ( ) { ( basedir = = null ) { basedir = system . get properti ( catalina . base ) ; } ( basedir = = null ) { basedir = system . get properti ( catalina . home ) ; } ( basedir = = null ) { creat temp dir . basedir = system . get properti ( user . dir ) tomcat . port ; file home = new file ( basedir ) ; home . mkdir ( ) ; ( home . absolut ( ) ) { try { basedir = home . get canon path ( ) ; } catch ( ioexcept e ) { basedir = home . get absolut path ( ) ; } } } system . set properti ( catalina . home , basedir ) ; system . set properti ( catalina . base , basedir ) ; }	public set log level warn logger log inform tomcat start up . thi prevent usual startup inform log consol . void set silent ( ) { ( string s : silenc ) { logger . get logger ( s ) . set level ( level . warn ) ; } }
public add context programmat mode , web . xml us . api call equival web . xml : context param ctx . add paramet ( name , valu ) ; error page error page ep = new error page ( ) ; ep . set error code ( 500 ) ; ep . set locat ( error . html ) ; ctx . add error page ( ep ) ; ctx . add mime map ( ext , type ) ; note : you reload context , all your configur lost . you need reload support , consid us lifecycl listen provid your configur . todo : add rest param host null default host param context path root context . param dir base dir context , static file . must exist , rel server home standard context add context ( string context path , string base dir ) { return add context ( get host ( ) , context path , base dir ) ; }	public standard wrapper add servlet ( string context path , string servlet name , string servlet class ) { contain ctx = get host ( ) . find child ( context path ) ; return add servlet ( ( standard context ) ctx , servlet name , servlet class ) ; }	public static us exist servlet , class . name initi perform standard wrapper add servlet ( standard context ctx , string servlet name , servlet servlet ) { do class name set init param standard wrapper sw = new exist standard wrapper ( servlet ) ; sw . set name ( servlet name ) ; ctx . add child ( sw ) ; return sw ; }	public static provid default configur context . thi programmat equival default web . xml . todo : normal tomcat , default web . xml found , us thi method void init webapp default ( standard context ctx ) { default servlet standard wrapper servlet = add servlet ( ctx , default , org . apach . catalina . servlet . default servlet ) ; servlet . set load startup ( 1 ) ; jsp servlet ( class name avoid load all dep ) servlet = add servlet ( ctx , jsp , org . apach . jasper . servlet . jsp servlet ) ; servlet . add init paramet ( fork , fals ) ; servlet . set load startup ( 3 ) ; servlet map ctx . add servlet map ( , default ) ; ctx . add servlet map ( . jsp , jsp ) ; ctx . add servlet map ( . jspx , jsp ) ; session ctx . set manag ( new standard manag ( ) ) ; ctx . set session timeout ( 30 ) ; mime map ( int i = 0 ; i default mime map . length ; ) { ctx . add mime map ( default mime map i , default mime map i ) ; } welcom file ctx . add welcom file ( index . html ) ; ctx . add welcom file ( index . htm ) ; ctx . add welcom file ( index . jsp ) ; }	public enabl jndi name which disabl default . void enabl name ( ) { make sure get server ( ) ha been call where name disabl get server ( ) ; system . set properti ( catalina . us name , true ) ; string valu = org . apach . name ; string old valu = system . get properti ( javax . name . context . url pkg prefix ) ; ( old valu = null ) { valu = valu : old valu ; } system . set properti ( javax . name . context . url pkg prefix , valu ) ; valu = system . get properti ( javax . name . context . initi context factori ) ; ( valu = = null ) { system . set properti ( javax . name . context . initi context factori , org . apach . name . java . java urlcontext factori ) ; } }	public static void init webapp default ( standard context ctx ) { default servlet standard wrapper servlet = add servlet ( ctx , default , org . apach . catalina . servlet . default servlet ) ; servlet . set load startup ( 1 ) ; jsp servlet ( class name avoid load all dep ) servlet = add servlet ( ctx , jsp , org . apach . jasper . servlet . jsp servlet ) ; servlet . add init paramet ( fork , fals ) ; servlet . set load startup ( 3 ) ; servlet map ctx . add servlet map ( , default ) ; ctx . add servlet map ( . jsp , jsp ) ; ctx . add servlet map ( . jspx , jsp ) ; session ctx . set manag ( new standard manag ( ) ) ; ctx . set session timeout ( 30 ) ; mime map ( int i = 0 ; i default mime map . length ; ) { ctx . add mime map ( default mime map i , default mime map i ) ; } welcom file ctx . add welcom file ( index . html ) ; ctx . add welcom file ( index . htm ) ; ctx . add welcom file ( index . jsp ) ; }
privat class loader creat class loader ( string name , class loader parent ) throw except { string valu = catalina properti . get properti ( name . loader ) ; ( ( valu = = null ) ( valu . equal ( ) ) ) return parent ; arrai list string repositori locat = new arrai list string ( ) ; arrai list integ repositori type = new arrai list integ ( ) ; int i ; string token token = new string token ( valu , , ) ; while ( token . ha more element ( ) ) { string repositori = token . next token ( ) ; local repositori boolean replac = fals ; string befor = repositori ; while ( ( i = repositori . index ( catalina home token ) ) = 0 ) { replac = true ; ( i 0 ) { repositori = repositori . substr ( 0 , i ) get catalina home ( ) repositori . substr ( i catalina home token . length ( ) ) ; } els { repositori = get catalina home ( ) repositori . substr ( catalina home token . length ( ) ) ; } } while ( ( i = repositori . index ( catalina base token ) ) = 0 ) { replac = true ; ( i 0 ) { repositori = repositori . substr ( 0 , i ) get catalina base ( ) repositori . substr ( i catalina base token . length ( ) ) ; } els { repositori = get catalina base ( ) repositori . substr ( catalina base token . length ( ) ) ; } } ( replac log . debug enabl ( ) ) log . debug ( expand befor replac ) ; check jar url repositori try { new url ( repositori ) ; repositori locat . add ( repositori ) ; repositori type . add ( class loader factori . url ) ; continu ; } catch ( malform urlexcept e ) { ignor } ( repositori . end ( . jar ) ) { repositori = repositori . substr ( 0 , repositori . length ( ) . jar . length ( ) ) ; repositori locat . add ( repositori ) ; repositori type . add ( class loader factori . glob ) ; } els ( repositori . end ( . jar ) ) { repositori locat . add ( repositori ) ; repositori type . add ( class loader factori . jar ) ; } els { repositori locat . add ( repositori ) ; repositori type . add ( class loader factori . dir ) ; } } string locat = repositori locat . arrai ( new string 0 ) ; integ type = repositori type . arrai ( new integ 0 ) ; class loader class loader = class loader factori . creat class loader ( locat , type , parent ) ; retriev mbean server mbean server m bean server = null ; ( mbean server factori . find mbean server ( null ) . size ( ) 0 ) { m bean server = mbean server factori . find mbean server ( null ) . get ( 0 ) ; } els { m bean server = manag factori . get platform mbean server ( ) ; } regist server classload object name object name = new object name ( catalina : type = server class loader , name = name ) ; m bean server . regist mbean ( class loader , object name ) ; return class loader ; }
session inform web applic specifi context path . displai profil session thi access time list number session each 10 minut interv up 10 hour . param writer writer render param path context path applic list session inform param idl expir all session idl time ge ; idl thi context protect void session ( print writer writer , string path , int idl ) { ( debug = 1 ) { log ( session : session inform web applic path ) ; ( idl = 0 ) log ( session : session expir idl minut path ) ; } ( ( path = = null ) ( path . start ( ) path . equal ( ) ) ) { writer . println ( sm . get string ( manag servlet . invalid path , request util . filter ( path ) ) ) ; return ; } string displai path = path ; ( path . equal ( ) ) path = ; try { context context = ( context ) host . find child ( path ) ; ( context = = null ) { writer . println ( sm . get string ( manag servlet . context , request util . filter ( displai path ) ) ) ; return ; } manag manag = context . get manag ( ) ; ( manag = = null ) { writer . println ( sm . get string ( manag servlet . manag , request util . filter ( displai path ) ) ) ; return ; } int max count = 60 ; int max inact interv = manag . get max inact interv ( ) 60 ; int histo interv = max inact interv max count ; ( histo interv max count max inact interv ) histo interv ; max count = max inact interv histo interv ; ( histo interv max count max inact interv ) max count ; writer . println ( sm . get string ( manag servlet . session , displai path ) ) ; writer . println ( sm . get string ( manag servlet . sessiondefaultmax , max inact interv ) ) ; session session = manag . find session ( ) ; int timeout = new int max count ; int notimeout = 0 ; int expir = 0 ; long now = system . current time milli ( ) ; ( int i = 0 ; i session . length ; i ) { int time = ( int ) ( ( now session i . get thi access time intern ( ) ) 1000 ) ; ( idl = 0 time = idl 60 ) { session i . expir ( ) ; idl ; } time = time 60 histo interv ; ( time 0 ) notimeout ; } } }
privat final extens map . void intern map extens wrapper ( wrapper wrapper , char chunk path , map data map data ) { char buf = path . get buffer ( ) ; int path end = path . get end ( ) ; int servlet path = path . get offset ( ) ; int slash = 1 ; ( int i = path end 1 ; i = servlet path ; i ) { ( buf i = = ) { slash = i ; break ; } } ( slash = 0 ) { int period = 1 ; ( int i = path end 1 ; i slash ; i ) { ( buf i = = . ) { period = i ; break ; } } ( period = 0 ) { path . set offset ( period 1 ) ; path . set end ( path end ) ; int po = find ( wrapper , path ) ; ( ( po = 1 ) ( path . equal ( wrapper po . name ) ) ) { map data . wrapper path . set char ( buf , servlet path , path end servlet path ) ; map data . request path . set char ( buf , servlet path , path end servlet path ) ; map data . wrapper = wrapper po . object ; } path . set offset ( servlet path ) ; path . set end ( path end ) ; } } }
protect invok when queri execut , call execut execut queri execut batch fail . param queri queri wa execut fail param arg argument execut param name name method us execut { link abstract creat statement interceptor execut } param start time queri execut start param t except happen return sql wa execut string quot ; batch quot ; wa batch execut string report fail queri ( string queri , object arg , final string name , long start , throwabl t ) { extract queri string string sql = ( queri = = null arg = null arg . length 0 ) ( string ) arg 0 : queri ; we do batch execut , we name queri batch ( sql = = null compar ( execut 3 , name ) ) { sql = batch ; } return sql ; }	protect invok when queri execut , call execut execut queri execut batch succeed wa within time threshold param queri queri wa execut fail param arg argument execut param name name method us execut { link abstract creat statement interceptor execut } param start time queri execut start param delta time execut took return sql wa execut string quot ; batch quot ; wa batch execut string report queri ( string queri , object arg , final string name , long start , long delta ) { extract queri string string sql = ( queri = = null arg = null arg . length 0 ) ( string ) arg 0 : queri ; we do batch execut , we name queri batch ( sql = = null compar ( execut 3 , name ) ) { sql = batch ; } return sql ; }	protect invok when queri execut , call execut execut queri execut batch succeed wa exceed time threshold param queri queri wa execut fail param arg argument execut param name name method us execut { link abstract creat statement interceptor execut } param start time queri execut start param delta time execut took return sql wa execut string quot ; batch quot ; wa batch execut string report slow queri ( string queri , object arg , final string name , long start , long delta ) { extract queri string string sql = ( queri = = null arg = null arg . length 0 ) ( string ) arg 0 : queri ; we do batch execut , we name queri batch ( sql = = null compar ( execut 3 , name ) ) { sql = batch ; } return sql ; }	creat statement interceptor monitor queri respons time overrid public object creat statement ( object proxi , method method , object arg , object statement , long time ) { try { object result = null ; string name = method . get name ( ) ; string sql = null ; constructor constructor = null ; ( compar ( statement 0 , name ) ) { creat statement constructor = get constructor ( 0 , statement . class ) ; } els ( compar ( statement 1 , name ) ) { prepar statement sql = ( string ) arg 0 ; constructor = get constructor ( 1 , prepar statement . class ) ; ( sql = null ) { prepar statement ( sql , time ) ; } } els ( compar ( statement 2 , name ) ) { prepar call sql = ( string ) arg 0 ; constructor = get constructor ( 2 , callabl statement . class ) ; prepar call ( sql , time ) ; } els { so we better bail out let system continu return statement ; } result = constructor . new instanc ( new object { new statement proxi ( statement , sql ) } ) ; return result ; } catch ( except x ) { log . warn ( unabl creat statement proxi slow queri report . , x ) ; } return statement ; }	{ inherit doc } overrid public object invok ( object proxi , method method , object arg ) throw throwabl { ( compar ( close val , method ) ) { close invok ( ) ; return super . invok ( proxi , method , arg ) ; } els { boolean process = fals ; process = process ( statement , method , process ) ; ( process ) { long start = system . current time milli ( ) ; object statement = super . invok ( proxi , method , arg ) ; long delta = system . current time milli ( ) start ; return creat statement ( proxi , method , arg , statement , delta ) ; } els { return super . invok ( proxi , method , arg ) ; } } }	public object invok ( object proxi , method method , object arg ) throw throwabl { get name method comparison final string name = method . get name ( ) ; wa close invok boolean close = compar ( jdbc interceptor . close val , name ) ; allow close call multipl time ( close close ) return null ; ar we call close ( compar ( jdbc interceptor . isclos val , name ) ) return boolean . valu ( close ) ; we ar call anyth els , bail out ( close ) throw new sqlexcept ( statement close . ) ; boolean process = fals ; check see we ar about execut queri process = process ( execut , method , process ) ; we ar execut , get current time long start = ( process ) system . current time milli ( ) : 0 ; object result = null ; try { execut queri result = method . invok ( deleg , arg ) ; } catch ( throwabl t ) { report fail queri ( queri , arg , name , start , t ) ; ( t instanceof invoc target except ) { invoc target except = ( invoc target except ) t ; throw . get caus ( ) = null . get caus ( ) : ; } els { throw t ; } } measur time long delta = ( process ) ( system . current time milli ( ) start ) : long . min valu ; see we meet requir measur ( delta threshold ) { try { report slow queri report slow queri ( queri , arg , name , start , delta ) ; } catch ( except t ) { ( log . warn enabl ( ) ) log . warn ( unabl process slow queri , t ) ; } } els ( process ) { report queri ( queri , arg , name , start , delta ) ; } perform close cleanup ( close ) { close = true ; deleg = null ; } return result ; }
overrid protect void tear down ( ) throw except { driver . reset ( ) ; ds . close ( true ) ; super . tear down ( ) ; }	public void test brutal non fair ( ) throw except { ds . get pool properti ( ) . set remov abandon ( fals ) ; ds . get pool properti ( ) . set remov abandon timeout ( 1 ) ; ds . get pool properti ( ) . set min evict idl time milli ( 100 ) ; ds . get pool properti ( ) . set time between evict run milli ( 10 ) ; ds . get connect ( ) . close ( ) ; final int iter = 100000 10 ; final atom integ loopcount = new atom integ ( 0 ) ; final runnabl run = new runnabl ( ) { public void run ( ) { try { while ( loopcount . increment get ( ) iter ) { connect con = ds . get connect ( ) ; con . close ( ) ; } } catch ( except x ) { stop test loopcount . set ( iter ) ; x . print stack trace ( ) ; } } } ; thread thread = new thread 20 ; ( int i = 0 ; i thread . length ; i ) { thread i = new thread ( run ) ; } ( int i = 0 ; i thread . length ; i ) { thread i . start ( ) ; } try { while ( loopcount . get ( ) iter ) { assert true ( size comparison ( less than 11 ) : , ds . get pool ( ) . get size ( ) = 10 ) ; ds . get pool ( ) . test all idl ( ) ; ds . get pool ( ) . check abandon ( ) ; ds . get pool ( ) . check idl ( ) ; } } catch ( except x ) { stop test loopcount . set ( iter ) ; x . print stack trace ( ) ; } ( int i = 0 ; i thread . length ; i ) { thread i . join ( ) ; } system . out . println ( connect count : driver . connect count . get ( ) ) ; system . out . println ( di connect count : driver . disconnect count . get ( ) ) ; assert equal ( size comparison : , 10 , ds . get pool ( ) . get size ( ) ) ; assert equal ( idl comparison : , 10 , ds . get pool ( ) . get idl ( ) ) ; assert equal ( us comparison : , 0 , ds . get pool ( ) . get activ ( ) ) ; assert equal ( connect count , 10 , driver . connect count . get ( ) ) ; }
public { inherit doc } throw unsupport oper thi oper support e element ( ) { throw new unsupport oper except ( e element ( ) ) ; }	public { inherit doc } throw unsupport oper thi oper support e element ( ) { throw new unsupport oper except ( e element ( ) ) ; }	public { inherit doc } throw unsupport oper thi oper support e peek ( ) { throw new unsupport oper except ( e peek ( ) ) ; }	public { inherit doc } throw unsupport oper thi oper support e peek ( ) { throw new unsupport oper except ( e peek ( ) ) ; }	public { inherit doc } boolean add ( e e ) { return offer ( e ) ; }	public { inherit doc } boolean add ( e e ) { return offer ( e ) ; }	public { inherit doc } boolean add all ( collect extend e c ) { iter i = c . iter ( ) ; while ( i . ha next ( ) ) { e e = ( e ) i . next ( ) ; offer ( e ) ; } return true ; }	public { inherit doc } boolean add all ( collect extend e c ) { iter i = c . iter ( ) ; while ( i . ha next ( ) ) { e e = ( e ) i . next ( ) ; offer ( e ) ; } return true ; }	public { inherit doc } boolean empti ( ) { return size ( ) = = 0 ; }	public { inherit doc } boolean empti ( ) { return size ( ) = = 0 ; }	public { inherit doc } throw unsupport oper thi oper support boolean remov all ( collect c ) { throw new unsupport oper except ( boolean remov all ( collect c ) ) ; }	public { inherit doc } throw unsupport oper thi oper support boolean remov all ( collect c ) { throw new unsupport oper except ( boolean remov all ( collect c ) ) ; }	public { inherit doc } throw unsupport oper thi oper support t t arrai ( t ) { throw new unsupport oper except ( t t arrai ( t ) ) ; }	public { inherit doc } throw unsupport oper thi oper support t t arrai ( t ) { throw new unsupport oper except ( t t arrai ( t ) ) ; }	public { inherit doc } throw unsupport oper thi oper support int drain ( collect super e c , int max element ) { throw new unsupport oper except ( int drain ( collect super e c , int max element ) ) ; }	public { inherit doc } throw unsupport oper thi oper support int drain ( collect super e c , int max element ) { throw new unsupport oper except ( int drain ( collect super e c , int max element ) ) ; }	public { inherit doc } throw unsupport oper thi oper support void clear ( ) { throw new unsupport oper except ( void clear ( ) ) ; }	public { inherit doc } throw unsupport oper thi oper support void clear ( ) { throw new unsupport oper except ( void clear ( ) ) ; }
protect void do post ( http servlet request req , http servlet respons resp ) throw servlet except , ioexcept { just echo paramet valu back plain text resp . set content type ( text plain ) ; print writer out = resp . get writer ( ) ; assum valu per attribut enumer string name = req . get paramet name ( ) ; while ( name . ha more element ( ) ) { string name = name . next element ( ) ; out . println ( name = req . get paramet ( name ) ) ; } }	public void test bug37794 ( ) throw except { bug37794client client = new bug37794client ( ) ; edg case around zero unlimit client . do request ( 1 , fals ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; unlimit client . do request ( 0 , fals ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; 1 byte too small should fail client . do request ( 1 , fals ) ; assert true ( client . response500 ( ) ) ; client . reset ( ) ; edg case around actual content length client . reset ( ) ; too small should fail client . do request ( 6 , fals ) ; assert true ( client . response500 ( ) ) ; client . reset ( ) ; just enough should pass client . do request ( 7 , fals ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; 1 extra should pass client . do request ( 8 , fals ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; much larger client . reset ( ) ; plenti space should pass client . do request ( 8096 , fals ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; check case insensit client . reset ( ) ; plenti space should pass client . do request ( 8096 , true ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; }	public boolean respons bodi ok ( ) { ( get respons bodi ( ) = = null ) { return fals ; } ( get respons bodi ( ) . contain ( = 1 ) ) { return fals ; } ( get respons bodi ( ) . contain ( b = 2 ) ) { return fals ; } return true ; }	public void connect ( ) throw unknown host except , ioexcept { socket = new socket ( localhost , 8080 ) ; output stream os = socket . get output stream ( ) ; writer = new output stream writer ( os ) ; input stream = socket . get input stream ( ) ; reader r = new input stream reader ( ) ; reader = new buffer reader ( r ) ; }	public void do get ( http servlet request req , http servlet respons re ) throw ioexcept { re . get writer ( ) . write ( hello world ) ; }	public void test bug37794 ( ) throw except { bug37794client client = new bug37794client ( ) ; edg case around zero unlimit client . do request ( 1 , fals ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; unlimit client . do request ( 0 , fals ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; 1 byte too small should fail client . do request ( 1 , fals ) ; assert true ( client . response500 ( ) ) ; client . reset ( ) ; edg case around actual content length client . reset ( ) ; too small should fail client . do request ( 6 , fals ) ; assert true ( client . response500 ( ) ) ; client . reset ( ) ; just enough should pass client . do request ( 7 , fals ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; client . reset ( ) ; 1 extra should pass client . do request ( 8 , fals ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; much larger client . reset ( ) ; plenti space should pass client . do request ( 8096 , fals ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; check case insensit client . reset ( ) ; plenti space should pass client . do request ( 8096 , true ) ; assert true ( client . response200 ( ) ) ; assert true ( client . respons bodi ok ( ) ) ; }	public void test launch time ( ) throw except { tomcat . add context ( null , , base ) ; tomcat . start ( ) ; }	public start tomcat singl context servlet all programmat , server . xml web . xml us . throw except void test programmat ( ) throw except { standard context ctx = tomcat . add context ( , temp dir . get absolut path ( ) ) ; you can custom context call api tomcat . add servlet ( ctx , my servlet , new hello world ( ) ) ; ctx . add servlet map ( , my servlet ) ; tomcat . start ( ) ; byte chunk re = get url ( http : localhost : port ) ; assert equal ( re . string ( ) , hello world ) ; }	public void test singl webapp ( ) throw except { current sandbox tomcat lite file app dir = new file ( base output build webapp exampl ) ; app dir rel server home tomcat . add webapp ( null , exampl , app dir . get absolut path ( ) ) ; tomcat . start ( ) ; byte chunk re = get url ( http : localhost : port exampl servlet servlet hello world exampl ) ; assert true ( re . string ( ) . index ( h1 hello world h1 ) 0 ) ; }
void set up ( ) throw except { t0 = system . current time milli ( ) ; temp dir = new file ( output tmp ) ; temp dir . mkdir ( ) ; tomcat = new tomcat ( ) ; tomcat . get host ( ) . set app base ( temp dir . get absolut path ( ) ) ; tomcat . set base dir ( temp dir . get absolut path ( ) ) ; each test run same port thei mai interfer each other ( unix least ) port ; tomcat . set port ( port ) ; }	public void tear down ( ) throw except { tomcat . stop ( ) ; system . err . println ( test time : ( system . current time milli ( ) t0 ) ) ; }
static produc string repres call el interpret . param express string contain zero more { } express param expect type expect type interpret result param fnmapvar variabl point function map . param xml escap true result should do xml escap return string repres call el interpret . string interpret call ( boolean tag file , string express , class expect type , string fnmapvar , boolean xml escap ) { determin which context object us . string jsp ctxt = null ; ( tag file ) jsp ctxt = thi . get jsp context ( ) ; els jsp ctxt = jspx page context ; determin whether us expect type s textual name , s primit , name correspond box type . string target type = expect type . get name ( ) ; string primit convert method = null ; ( expect type . primit ( ) ) { ( expect type . equal ( boolean . type ) ) { target type = boolean . class . get name ( ) ; primit convert method = boolean valu ; } els ( expect type . equal ( byte . type ) ) { target type = byte . class . get name ( ) ; primit convert method = byte valu ; } els ( expect type . equal ( charact . type ) ) { target type = charact . class . get name ( ) ; primit convert method = char valu ; } els ( expect type . equal ( short . type ) ) { target type = short . class . get name ( ) ; primit convert method = short valu ; } els ( expect type . equal ( integ . type ) ) { target type = integ . class . get name ( ) ; primit convert method = int valu ; } els ( expect type . equal ( long . type ) ) { target type = long . class . get name ( ) ; primit convert method = long valu ; } els ( expect type . equal ( float . type ) ) { target type = float . class . get name ( ) ; primit convert method = float valu ; } els ( expect type . equal ( doubl . type ) ) { target type = doubl . class . get name ( ) ; primit convert method = doubl valu ; } } ( primit convert method = null ) { xml escap = fals ; } build up base call interpret . xxx we us proprietari call interpret now current standard machineri ineffici requir lot wrapper adapt . thi should all clear up onc el interpret move out jstl own project . futur , thi should replac code call express evalu . pars express ( ) cach result express object . interpret call would simpli select pre cach express evalu . note page context impl implement variabl resolv gener servlet simpl tag implement function mapper , so machineri alreadi place ( mroth ) . target type = java sourc type ( target type ) ; string buffer call = new string buffer ( ( target type ) org . apach . jasper . runtim . page context impl . proprietari evalu ( gener . quot ( express ) , target type . class , ( page context ) jsp ctxt , fnmapvar , xml escap ) ) ; add primit convert method we need . ( primit convert method = null ) { call . insert ( 0 , ( ) ; call . append ( ) . primit convert method ( ) ) ; } return call . string ( ) ; }
public void servic ( http servlet request request , http servlet respons respons ) throw servlet except , ioexcept { string jsp uri = null ; string jsp file = ( string ) request . get attribut ( constant . jsp file ) ; ( jsp file = null ) { jsp specifi via jsp file servlet declar jsp uri = jsp file ; } els { check see request jsp ha been target request dispatch . includ ( ) jsp uri = ( string ) request . get attribut ( constant . inc servlet path ) ; ( jsp uri = null ) { request jsp ha been target request dispatch . includ ( ) . path assembl from relev javax . servlet . includ . request attribut string path info = ( string ) request . get attribut ( javax . servlet . includ . path info ) ; ( path info = null ) { jsp uri = path info ; } } els { request jsp ha been target request dispatch . includ ( ) . reconstruct path from request s get servlet path ( ) get path info ( ) jsp uri = request . get servlet path ( ) ; string path info = request . get path info ( ) ; ( path info = null ) { jsp uri = path info ; } } } ( log . debug enabl ( ) ) { log . debug ( jsp engin jsp uri ) ; log . debug ( t servlet path : request . get servlet path ( ) ) ; log . debug ( t path info : request . get path info ( ) ) ; log . debug ( t real path : context . get real path ( jsp uri ) ) ; log . debug ( t request uri : request . get request uri ( ) ) ; log . debug ( t queri string : request . get queri string ( ) ) ; log . debug ( t request param : ) ; enumer string e = request . get paramet name ( ) ; while ( e . ha more element ( ) ) { string name = e . next element ( ) ; log . debug ( t t name = request . get paramet ( name ) ) ; } } try { boolean precompil = pre compil ( request ) ; servic jsp file ( request , respons , jsp uri , null , precompil ) ; } catch ( runtim except e ) { throw e ; } catch ( servlet except e ) { throw e ; } catch ( ioexcept e ) { throw e ; } catch ( throwabl e ) { throw new servlet except ( e ) ; } }

protect clear refer . void clear refer ( ) { deregist ani jdbc driver regist webapp webapp forgot . thi made unnecessari complex becaus ) driver manag check class loader call class ( would much easier check context class loader ) b ) us reflect would creat depend driver manag implement which can , ha , chang . we can t just creat instanc jdbc leak prevent load common class loader ( sinc s . class file catalina home lib directori ) . thi would fail driver manag s check class loader call class . so , we load byte via our parent class loader defin class thi class loader so jdbc leak prevent look like webapp class driver manag . onli app clean up after themselv . . . input stream = get resourc stream ( org apach catalina loader jdbc leak prevent . class ) ; cheat we know roughli how big class ( 1k ) allow plenti room grow byte class byte = new byte 4096 ; int offset = 0 ; try { int read = . read ( class byte , offset , 4096 offset ) ; while ( read 1 ) { offset = read ; read = . read ( class byte , offset , 4096 offset ) ; } class lp class = defin class ( org . apach . catalina . loader . jdbc leak prevent , class byte , 0 , offset ) ; object obj = lp class . new instanc ( ) ; obj . get class ( ) . get method ( clear jdbc driver registr ) . invok ( obj ) ; } catch ( except e ) { so mani thing go wrong abov . . . log . warn ( sm . get string ( webapp class loader . jdbc remov fail ) , e ) ; } final { ( = null ) { try { . close ( ) ; } catch ( ioexcept ioe ) { log . warn ( sm . get string ( webapp class loader . jdbc remov stream error ) , ioe ) ; } } } workaround appar garbag collect bug ( enabl clear refer ) { iter resourc entri load class = ( ( hash map string , resourc entri ) resourc entri . clone ( ) ) . valu ( ) . iter ( ) ; while ( load class . ha next ( ) ) { resourc entri entri = load class . next ( ) ; ( entri . load class = null ) { class clazz = entri . load class ; try { field field = clazz . get declar field ( ) ; ( int i = 0 ; i field . length ; i ) { field field = field i ; int mod = field . get modifi ( ) ; ( field . get type ( ) . primit ( ) ( field . get name ( ) . index ( ) = 1 ) ) { continu ; } ( modifi . static ( mod ) ) { try { field . set access ( true ) ; ( modifi . final ( mod ) ) { ( ( ( field . get type ( ) . get name ( ) . start ( java . ) ) ( field . get type ( ) . get name ( ) . start ( javax . ) ) ) ) { null instanc ( field . get ( null ) ) ; } } els { field . set ( null , null ) ; ( log . debug enabl ( ) ) { log . debug ( set field field . get name ( ) null class clazz . get name ( ) ) ; } } } catch ( throwabl t ) { ( log . debug enabl ( ) ) { log . debug ( could set field field . get name ( ) null class clazz . get name ( ) , t ) ; } } } } } catch ( throwabl t ) { ( log . debug enabl ( ) ) { log . debug ( could clean field class clazz . get name ( ) , t ) ; } } } } } clear introspect util cach . introspect util . clear ( ) ; clear classload refer common log org . apach . juli . log . log factori . releas ( thi ) ; clear classload refer vm s bean introspector java . bean . introspector . flush cach ( ) ; }
protect chang session id send all cluster node param request current request param respons current respons param session id origin session id param new session id new session id node migrat param catalina session current session origin session id void chang session id ( request request , respons respons , string session id , string new session id , session catalina session ) { lifecycl . fire lifecycl event ( befor session migrat , catalina session ) ; fixm : set id trigger session listen , onli chanc registiert manag correct id catalina session . set id ( new session id ) ; set id also trigger reset delta request ( catalina session instanceof delta session ) ( ( delta session ) catalina session ) . reset delta request ( ) ; chang request session id ( request , respons , session id , new session id ) ; now send chang all other clusternod cluster manag manag = ( cluster manag ) catalina session . get manag ( ) ; send session idclust backup ( manag , request , session id , new session id ) ; lifecycl . fire lifecycl event ( after session migrat , catalina session ) ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jvm rout . chang session , session id , new session id ) ) ; } }	public detect possibl jvmrout chang cluster backup node . . param request tomcat request process param respons tomcat respons process except ioexcept input output error ha occur except servlet except servlet error ha occur void invok ( request request , respons respons ) throw ioexcept , servlet except { ( get enabl ( ) get cluster ( ) = null request . get context ( ) = null request . get context ( ) . get distribut ( ) ) { valv cluster can access manag other cluster handl turnov host level hopefulli manag manag = request . get context ( ) . get manag ( ) ; ( manag = null manag instanceof cluster manag get cluster ( ) . get manag ( ( ( cluster manag ) manag ) . get name ( ) ) = null ) handl possibl turnov ( request , respons ) ; } pass thi request next valv our pipelin get next ( ) . invok ( request , respons ) ; }	public prepar begin activ us public method thi compon . thi method should call after code configur ( ) code , befor ani public method compon ar util . except lifecycl except thi compon detect fatal error prevent thi compon from us void start ( ) throw lifecycl except { valid updat our current compon state ( start ) throw new lifecycl except ( sm . get string ( jvm rout . valv . alreadi start ) ) ; lifecycl . fire lifecycl event ( start event , null ) ; start = true ; ( cluster = = null ) { contain host contain = get contain ( ) ; ( setup context . xml context . xml . default ) ( ( host contain instanceof host ) ) { ( log . warn enabl ( ) ) log . warn ( sm . get string ( jvm rout . configur . warn ) ) ; host contain = host contain . get parent ( ) ; } ( host contain instanceof host ( ( host ) host contain ) . get cluster ( ) = null ) { cluster = ( catalina cluster ) ( ( host ) host contain ) . get cluster ( ) ; } els { contain engin = host contain . get parent ( ) ; ( engin instanceof engin ( ( engin ) engin ) . get cluster ( ) = null ) { cluster = ( catalina cluster ) ( ( engin ) engin ) . get cluster ( ) ; } } } ( cluster = = null ) { throw new runtim except ( cluster support contain contain . get name ( ) ) ; } ( log . info enabl ( ) ) log . info ( sm . get string ( jvm rout . valv . start ) ) ; }
public when request ha been complet , replic valv notifi manag , manag decid whether ani replic need . need replic , manag creat session messag replic . cluster determin where get sent . param session id session id just complet . return session messag sent , cluster messag request complet ( string session id ) { delta session session = null ; try { session = ( delta session ) find session ( session id ) ; delta request delta request = session . get delta request ( ) ; session . lock ( ) ; session messag msg = null ; boolean delta request = fals ; synchron ( delta request ) { delta request = delta request . get size ( ) 0 ; ( delta request ) { counter send evt session delta ; byte data = serial delta request ( session , delta request ) ; msg = new session messag impl ( get name ( ) , session messag . evt session delta , data , session id , session id system . current time milli ( ) ) ; session . reset delta request ( ) ; } } ( delta request ) { ( session . primari session ( ) ) { counter send evt session access ; msg = new session messag impl ( get name ( ) , session messag . evt session access , null , session id , session id system . current time milli ( ) ) ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( delta manag . creat messag . access chang primari , get name ( ) , session id ) ) ; } } } els { log onli outsid synch block ( log . debug enabl ( ) ) { log . debug ( sm . get string ( delta manag . creat messag . delta , get name ( ) , session id ) ) ; } } session . set primari session ( true ) ; check see we need send out access messag ( ( msg = = null ) ) { long repl delta = system . current time milli ( ) session . get last time replic ( ) ; ( repl delta ( get max inact interv ( ) 1000 ) ) { counter send evt session access ; msg = new session messag impl ( get name ( ) , session messag . evt session access , null , session id , session id system . current time milli ( ) ) ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( delta manag . creat messag . access , get name ( ) , session id ) ) ; } } } updat last replic time ( msg = null ) session . set last time replic ( system . current time milli ( ) ) ; return msg ; } catch ( ioexcept x ) { log . error ( sm . get string ( delta manag . creat messag . unabl creat delta request , session id ) , x ) ; return null ; } final { ( session = null ) session . unlock ( ) ; } }
public perform intern process requir invalid thi session , without trigger except session ha alreadi expir . param notifi should we notifi listen about demis thi session void expir ( boolean notifi ) { mark thi session expir need ( expir ) return ; synchron ( thi ) { ( manag = = null ) return ; expir = true ; notifi interest applic event listen fixm assum we call listen revers order context context = ( context ) manag . get contain ( ) ; object listen = context . get applic lifecycl listen ( ) ; ( notifi ( listen = null ) ) { http session event event = new http session event ( get session ( ) ) ; ( int i = 0 ; i listen . length ; i ) { int j = ( listen . length 1 ) i ; ( ( listen j instanceof http session listen ) ) continu ; http session listen listen = ( http session listen ) listen j ; try { fire contain event ( context , befor session destroi , listen ) ; listen . session destroi ( event ) ; fire contain event ( context , after session destroi , listen ) ; } catch ( throwabl t ) { try { fire contain event ( context , after session destroi , listen ) ; } catch ( except e ) { ignor } manag . get contain ( ) . get logger ( ) . error ( sm . get string ( standard session . session event ) , t ) ; } } } ( activ check ) { access count . set ( 0 ) ; } set valid ( fals ) ; comput how long thi session ha been aliv , updat session manag s relat properti accordingli long time now = system . current time milli ( ) ; int time aliv = ( int ) ( ( time now creation time ) 1000 ) ; synchron ( manag ) { ( time aliv manag . get session max aliv time ( ) ) { manag . set session max aliv time ( time aliv ) ; } int num expir = manag . get expir session ( ) ; num expir ; manag . set expir session ( num expir ) ; int averag = manag . get session averag aliv time ( ) ; averag = ( ( averag ( num expir 1 ) ) time aliv ) num expir ; manag . set session averag aliv time ( averag ) ; } remov thi session from our manag s activ session manag . remov ( thi ) ; notifi interest session event listen ( notifi ) { fire session event ( session . session destroi event , null ) ; } call logout method ( princip instanceof gener princip ) { gener princip gp = ( gener princip ) princip ; try { gp . logout ( ) ; } catch ( except e ) { manag . get contain ( ) . get logger ( ) . error ( sm . get string ( standard session . logoutfail ) , e ) ; } } we have complet expir thi session expir = fals ; unbind ani object associ thi session string kei = kei ( ) ; ( int i = 0 ; i kei . length ; i ) remov attribut intern ( kei i , notifi ) ; } }
public void set udp tx buf size ( int udp tx buf size ) { thi . udp tx buf size = udp tx buf size ; }	public void start ( ) throw ioexcept { ( executor = = null ) { executor = new thread pool executor ( min thread , max thread , 60 , time unit . second , new link block queue runnabl ( ) ) ; task queue taskqueu = new task queue ( ) ; task thread factori tf = new task thread factori ( tribe task receiv ) ; executor = new thread pool executor ( min thread , max thread , max idl time , time unit . millisecond , taskqueu , tf ) ; taskqueu . set parent ( ( thread pool executor ) executor ) ; } }
protect perform actual jaa authent princip authent ( string usernam , callback handler callback handler ) { establish login context us authent try { login context login context = null ; ( app name = = null ) app name = tomcat ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . begin login , usernam , app name ) ) ; what login modul contain class loader class loader ocl = null ; ( us context class loader ( ) ) { ocl = thread . current thread ( ) . get context class loader ( ) ; thread . current thread ( ) . set context class loader ( thi . get class ( ) . get class loader ( ) ) ; } try { login context = new login context ( app name , callback handler ) ; } catch ( throwabl e ) { log . error ( sm . get string ( jaa realm . unexpect error ) , e ) ; return ( null ) ; } final { ( us context class loader ( ) ) { thread . current thread ( ) . set context class loader ( ocl ) ; } } ( log . debug enabl ( ) ) log . debug ( login context creat usernam ) ; negoti login via thi login context subject subject = null ; try { login context . login ( ) ; subject = login context . get subject ( ) ; ( subject = = null ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . fail login , usernam ) ) ; return ( null ) ; } } catch ( account expir except e ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . account expir , usernam ) ) ; return ( null ) ; } catch ( credenti expir except e ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . credenti expir , usernam ) ) ; return ( null ) ; } catch ( fail login except e ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . fail login , usernam ) ) ; return ( null ) ; } catch ( login except e ) { log . warn ( sm . get string ( jaa realm . login except , usernam ) , e ) ; return ( null ) ; } catch ( throwabl e ) { log . error ( sm . get string ( jaa realm . unexpect error ) , e ) ; return ( null ) ; } ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . login context creat , usernam ) ) ; return appropri princip thi authent subject princip princip = creat princip ( usernam , subject ) ; ( princip = = null ) { log . debug ( sm . get string ( jaa realm . authent failur , usernam ) ) ; return ( null ) ; } ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jaa realm . authent success , usernam ) ) ; } return ( princip ) ; } catch ( throwabl t ) { log . error ( error , t ) ; return null ; } }	protect identifi return code java . secur . princip code instanc repres authent user specifi code subject code . princip construct scan list princip return jaaslogin modul . first code princip code object match class name suppli user class user princip . thi object return tha caller . ani remain princip object return login modul ar map role , onli respect class match role class class . user princip cannot construct , return code null code . param subject code subject code repres log user princip creat princip ( string usernam , subject subject ) { prepar scan princip thi subject list string role = new arrai list string ( ) ; princip user princip = null ; scan princip thi subject iter princip princip = subject . get princip ( ) . iter ( ) ; while ( princip . ha next ( ) ) { princip princip = princip . next ( ) ; string princip class = princip . get class ( ) . get name ( ) ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jaa realm . check princip , princip , princip class ) ) ; } ( user princip = = null user class . contain ( princip class ) ) { user princip = princip ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jaa realm . user princip success , princip . get name ( ) ) ) ; } } ( role class . contain ( princip class ) ) { role . add ( princip . get name ( ) ) ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jaa realm . role princip add , princip . get name ( ) ) ) ; } } } print failur messag need ( user princip = = null ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jaa realm . user princip failur ) ) ; log . debug ( sm . get string ( jaa realm . role princip failur ) ) ; } } els { ( role . size ( ) = = 0 ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jaa realm . role princip failur ) ) ; } } } return result princip our authent user return new gener princip ( thi , usernam , null , role , user princip ) ; }	protect return code princip code associ given user name . princip get princip ( string usernam ) { return authent ( usernam , new jaascallback handler ( thi , usernam , null , null , null , null , null , null , null , constant . cert method ) ) ; }	public princip get user princip ( ) { ( user princip = null ) { return user princip ; } els { return thi ; } }	public perform intern process requir invalid thi session , without trigger except session ha alreadi expir . param notifi should we notifi listen about demis thi session void expir ( boolean notifi ) { mark thi session expir need ( expir ) return ; synchron ( thi ) { ( manag = = null ) return ; expir = true ; notifi interest applic event listen fixm assum we call listen revers order context context = ( context ) manag . get contain ( ) ; object listen = context . get applic lifecycl listen ( ) ; ( notifi ( listen = null ) ) { http session event event = new http session event ( get session ( ) ) ; ( int i = 0 ; i listen . length ; i ) { int j = ( listen . length 1 ) i ; ( ( listen j instanceof http session listen ) ) continu ; http session listen listen = ( http session listen ) listen j ; try { fire contain event ( context , befor session destroi , listen ) ; listen . session destroi ( event ) ; fire contain event ( context , after session destroi , listen ) ; } catch ( throwabl t ) { try { fire contain event ( context , after session destroi , listen ) ; } catch ( except e ) { ignor } manag . get contain ( ) . get logger ( ) . error ( sm . get string ( standard session . session event ) , t ) ; } } } ( activ check ) { access count . set ( 0 ) ; } set valid ( fals ) ; comput how long thi session ha been aliv , updat session manag s relat properti accordingli long time now = system . current time milli ( ) ; int time aliv = ( int ) ( ( time now creation time ) 1000 ) ; synchron ( manag ) { ( time aliv manag . get session max aliv time ( ) ) { manag . set session max aliv time ( time aliv ) ; } int num expir = manag . get expir session ( ) ; num expir ; manag . set expir session ( num expir ) ; int averag = manag . get session averag aliv time ( ) ; averag = ( ( averag ( num expir 1 ) ) time aliv ) num expir ; manag . set session averag aliv time ( averag ) ; } remov thi session from our manag s activ session manag . remov ( thi ) ; notifi interest session event listen ( notifi ) { fire session event ( session . session destroi event , null ) ; } we have complet expir thi session expir = fals ; unbind ani object associ thi session string kei = kei ( ) ; ( int i = 0 ; i kei . length ; i ) remov attribut intern ( kei i , notifi ) ; } }
appli diff exist object . param diff byte param offset int param length int throw ioexcept void appli diff ( byte diff , int offset , int length ) throw ioexcept , class found except { try { lock ( ) ; replic stream stream = ( ( cluster manag ) get manag ( ) ) . get replic stream ( diff , offset , length ) ; get delta request ( ) . read extern ( stream ) ; class loader context loader = thread . current thread ( ) . get context class loader ( ) ; try { class loader loader = get class loader ( ) ; ( loader = null loader . length 0 ) thread . current thread ( ) . set context class loader ( loader 0 ) ; get delta request ( ) . execut ( thi ) ; } final { thread . current thread ( ) . set context class loader ( context loader ) ; } } final { unlock ( ) ; } }
privat gener end part static portion servlet . void gener postambl ( ) { out . pop indent ( ) ; out . printil ( } catch ( throwabl t ) { ) ; out . push indent ( ) ; out . printil ( ( ( t instanceof skip page except ) ) { ) ; out . push indent ( ) ; out . printil ( out = jspx out ; ) ; out . printil ( ( out = null out . get buffer size ( ) = 0 ) ) ; out . push indent ( ) ; out . printil ( try { out . clear buffer ( ) ; } catch ( java . io . ioexcept e ) { } ) ; out . pop indent ( ) ; out . printil ( ( jspx page context = null ) jspx page context . handl page except ( t ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; out . pop indent ( ) ; out . printil ( } final { ) ; out . push indent ( ) ; out . printil ( jspx factori . releas page context ( jspx page context ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; close servic method out . pop indent ( ) ; out . printil ( } ) ; gener method , helper class , etc . gen common postambl ( ) ; }	public void set trim direct whitespac ( boolean trim direct whitespac ) { thi . trim direct whitespac = trim direct whitespac ; }	privat gener xml prolog , which includ xml declar xml doctyp declar . void gener xml prolog ( node . node page ) { xml declar gener under follow condit : omit xml declar attribut jsp : output action set fals jsp document without jsp : root string omit xml decl = page info . get omit xml decl ( ) ; ( ( omit xml decl = null jsp util . boolean valu ( omit xml decl ) ) ( omit xml decl = = null page . get root ( ) . xml syntax ( ) page info . ha jsp root ( ) ctxt . tag file ( ) ) ) { string c type = page info . get content type ( ) ; string char set = c type . substr ( c type . index ( charset = ) 8 ) ; out . printil ( out . write ( xml version = 1 . 0 encod = char set n ) ; ) ; } output doctyp declar doctyp root element appear . doctyp public appear : doctyp name public doctyp public doctyp system els doctyp name system doctyp system string doctyp name = page info . get doctyp name ( ) ; ( doctyp name = null ) { string doctyp public = page info . get doctyp public ( ) ; string doctyp system = page info . get doctyp system ( ) ; out . printin ( out . write ( doctyp ) ; out . print ( doctyp name ) ; ( doctyp public = = null ) { out . print ( system ) ; } els { out . print ( public ) ; out . print ( doctyp public ) ; out . print ( ) ; } out . print ( doctyp system ) ; out . println ( n ) ; ) ; } }	public void visit ( node . get properti n ) throw jasper except { string name = n . get text attribut ( name ) ; string properti = n . get text attribut ( properti ) ; n . set begin java line ( out . get java line ( ) ) ; ( bean info . check variabl ( name ) ) { bean defin us us bean , introspect compil time class bean = bean info . get bean type ( name ) ; string bean name = jsp util . get canon name ( bean ) ; java . lang . reflect . method meth = jsp runtim librari . get read method ( bean , properti ) ; string method name = meth . get name ( ) ; out . printil ( out . write ( org . apach . jasper . runtim . jsp runtim librari . string ( ( ( ( bean name ) jspx page context . find attribut ( name ) ) . method name ( ) ) ) ) ; ) ; } els { object could custom action associ variabl info entri thi name . get class name introspect runtim . out . printil ( out . write ( org . apach . jasper . runtim . jsp runtim librari . string ( org . apach . jasper . runtim . jsp runtim librari . handl get properti ( jspx page context . get attribut ( name , page context . page scope ) , properti ) ) ) ; ) ; } n . set end java line ( out . get java line ( ) ) ; }
protect check whether credenti present user match those retriev from directori . param context directori context param info user authent param credenti authent credenti except name except directori server error occur boolean compar credenti ( dir context context , user info , string credenti ) throw name except { ( info = = null credenti = = null ) return ( fals ) ; string password = info . password ; ( password = = null ) return ( fals ) ; valid credenti specifi user ( contain log . trace enabl ( ) ) contain log . trace ( valid credenti ) ; boolean valid = fals ; ( ha messag digest ( ) ) { hex encod parent class . ( password . start ( { sha } ) ) { sync sinc super . digest ( ) doe thi same thing synchron ( thi ) { password = password . substr ( 5 ) ; md . reset ( ) ; md . updat ( credenti . get byte ( ) ) ; string digest password = new string ( base64 . encod ( md . digest ( ) ) ) ; valid = password . equal ( digest password ) ; } } els ( password . start ( { ssha } ) ) { sync sinc super . digest ( ) doe thi same thing synchron ( thi ) { password = password . substr ( 6 ) ; md . reset ( ) ; md . updat ( credenti . get byte ( ) ) ; decod store password . byte chunk pwbc = new byte chunk ( password . length ( ) ) ; try { pwbc . append ( password . get byte ( ) , 0 , password . length ( ) ) ; } catch ( ioexcept e ) { should never happen contain log . error ( could append password byte chunk : , e ) ; } char chunk decod = new char chunk ( ) ; base64 . decod ( pwbc , decod ) ; char pwarrai = decod . get buffer ( ) ; split decod password hash salt . final int saltpo = 20 ; byte hash = new byte saltpo ; ( int i = 0 ; i hash . length ; i ) { hash i = ( byte ) pwarrai i ; } byte salt = new byte pwarrai . length saltpo ; ( int i = 0 ; i salt . length ; i ) salt i = ( byte ) pwarrai i saltpo ; md . updat ( salt ) ; byte dp = md . digest ( ) ; valid = arrai . equal ( dp , hash ) ; } end synchron ( thi ) block } els { hex hash should compar case insensit valid = ( digest ( credenti ) . equal ignor case ( password ) ) ; } } els valid = ( digest ( credenti ) . equal ( password ) ) ; return ( valid ) ; }
public void test ( ) throw except { init ( ) ; thi . datasourc . get pool properti ( ) . set max activ ( 10 ) ; thi . datasourc . get pool properti ( ) . set valid queri ( select 1 ) ; thi . datasourc . get pool properti ( ) . set test borrow ( true ) ; thi . threadcount = 10 ; thi . transfer properti c3p0 ( ) ; thi . c3p0datasourc . get connect ( ) . close ( ) ; latch = new count down latch ( threadcount ) ; long start = system . current time milli ( ) ; ( int i = 0 ; i threadcount ; i ) { test thread t = new test thread ( ) ; t . set name ( tomcat pool valid i ) ; t . d = thi . c3p0datasourc ; t . start ( ) ; } latch . await ( ) ; long delta = system . current time milli ( ) start ; system . out . println ( test test complet : delta ms . iter : ( threadcount thi . iter ) ) ; tear down ( ) ; }	public void test ( ) throw except { init ( ) ; thi . datasourc . get pool properti ( ) . set max activ ( 10 ) ; thi . datasourc . get pool properti ( ) . set valid queri ( select 1 ) ; thi . datasourc . get pool properti ( ) . set test borrow ( true ) ; thi . threadcount = 20 ; thi . transfer properti c3p0 ( ) ; thi . c3p0datasourc . get connect ( ) . close ( ) ; latch = new count down latch ( threadcount ) ; long start = system . current time milli ( ) ; ( int i = 0 ; i threadcount ; i ) { test thread t = new test thread ( ) ; t . set name ( tomcat pool valid i ) ; t . d = thi . c3p0datasourc ; t . start ( ) ; } latch . await ( ) ; long delta = system . current time milli ( ) start ; system . out . println ( test test complet : delta ms . iter : ( threadcount thi . iter ) ) ; tear down ( ) ; }	public void test ( ) throw except { init ( ) ; thi . datasourc . get pool properti ( ) . set max activ ( 10 ) ; thi . datasourc . get pool properti ( ) . set valid queri ( select 1 ) ; thi . datasourc . get pool properti ( ) . set test borrow ( true ) ; thi . threadcount = 10 ; thi . transfer properti ( ) ; thi . t datasourc . get connect ( ) . close ( ) ; latch = new count down latch ( threadcount ) ; long start = system . current time milli ( ) ; ( int i = 0 ; i threadcount ; i ) { test thread t = new test thread ( ) ; t . set name ( tomcat dbcp valid i ) ; t . d = thi . t datasourc ; t . start ( ) ; } latch . await ( ) ; long delta = system . current time milli ( ) start ; system . out . println ( test test complet : delta ms . iter : ( threadcount thi . iter ) ) ; tear down ( ) ; }	public void test ( ) throw except { init ( ) ; thi . datasourc . get pool properti ( ) . set max activ ( 10 ) ; thi . datasourc . get pool properti ( ) . set valid queri ( select 1 ) ; thi . datasourc . get pool properti ( ) . set test borrow ( true ) ; thi . threadcount = 20 ; thi . transfer properti ( ) ; thi . t datasourc . get connect ( ) . close ( ) ; latch = new count down latch ( threadcount ) ; long start = system . current time milli ( ) ; ( int i = 0 ; i threadcount ; i ) { test thread t = new test thread ( ) ; t . set name ( tomcat dbcp valid i ) ; t . d = thi . t datasourc ; t . start ( ) ; } latch . await ( ) ; long delta = system . current time milli ( ) start ; system . out . println ( test test complet : delta ms . iter : ( threadcount thi . iter ) ) ; tear down ( ) ; }	public void test fast sql ( ) throw except { int count = 3 ; thi . init ( ) ; thi . datasourc . set max activ ( 1 ) ; thi . datasourc . set jdbc interceptor ( slow queri report . class . get name ( ) ) ; connect con = thi . datasourc . get connect ( ) ; string slow sql = select 1 ; ( int i = 0 ; i count ; i ) { statement st = con . creat statement ( ) ; result set rs = st . execut queri ( slow sql ) ; rs . close ( ) ; st . close ( ) ; } map string , slow queri report . queri stat map = slow queri report . get pool stat ( datasourc . get pool ( ) . get name ( ) ) ; assert null ( map ) ; assert equal ( 0 , map . size ( ) ) ; connect pool pool = datasourc . get pool ( ) ; con . close ( ) ; tear down ( ) ; assert null ( slow queri report . get pool stat ( pool . get name ( ) ) ) ; }	public void test pool ( ) throw except { init ( ) ; thi . datasourc . get pool properti ( ) . set max activ ( 10 ) ; thi . datasourc . get pool properti ( ) . set valid queri ( select 1 ) ; thi . datasourc . get pool properti ( ) . set test borrow ( true ) ; thi . datasourc . get pool properti ( ) . set fair queue ( fals ) ; thi . threadcount = 10 ; thi . transfer properti ( ) ; thi . datasourc . get connect ( ) . close ( ) ; latch = new count down latch ( threadcount ) ; long start = system . current time milli ( ) ; ( int i = 0 ; i threadcount ; i ) { test thread t = new test thread ( ) ; t . set name ( tomcat pool valid i ) ; t . d = thi . datasourc ; t . start ( ) ; } latch . await ( ) ; long delta = system . current time milli ( ) start ; system . out . println ( test pool test complet : delta ms . iter : ( threadcount thi . iter ) ) ; tear down ( ) ; }	public void test pool fair ( ) throw except { init ( ) ; thi . datasourc . get pool properti ( ) . set max activ ( 10 ) ; thi . datasourc . get pool properti ( ) . set valid queri ( select 1 ) ; thi . datasourc . get pool properti ( ) . set test borrow ( true ) ; thi . datasourc . get pool properti ( ) . set fair queue ( true ) ; thi . threadcount = 10 ; thi . transfer properti ( ) ; thi . datasourc . get connect ( ) . close ( ) ; latch = new count down latch ( threadcount ) ; long start = system . current time milli ( ) ; ( int i = 0 ; i threadcount ; i ) { test thread t = new test thread ( ) ; t . set name ( tomcat pool valid i ) ; t . d = thi . datasourc ; t . start ( ) ; } latch . await ( ) ; long delta = system . current time milli ( ) start ; system . out . println ( test pool fair test complet : delta ms . iter : ( threadcount thi . iter ) ) ; tear down ( ) ; }	public void test pool ( ) throw except { init ( ) ; thi . datasourc . get pool properti ( ) . set max activ ( 10 ) ; thi . datasourc . get pool properti ( ) . set valid queri ( select 1 ) ; thi . datasourc . get pool properti ( ) . set test borrow ( true ) ; thi . datasourc . get pool properti ( ) . set fair queue ( fals ) ; thi . threadcount = 20 ; thi . transfer properti ( ) ; thi . datasourc . get connect ( ) . close ( ) ; latch = new count down latch ( threadcount ) ; long start = system . current time milli ( ) ; ( int i = 0 ; i threadcount ; i ) { test thread t = new test thread ( ) ; t . set name ( tomcat pool valid i ) ; t . d = thi . datasourc ; t . start ( ) ; } latch . await ( ) ; long delta = system . current time milli ( ) start ; system . out . println ( test pool test complet : delta ms . iter : ( threadcount thi . iter ) ) ; tear down ( ) ; }	public void test pool fair ( ) throw except { init ( ) ; thi . datasourc . get pool properti ( ) . set max activ ( 10 ) ; thi . datasourc . get pool properti ( ) . set valid queri ( select 1 ) ; thi . datasourc . get pool properti ( ) . set test borrow ( true ) ; thi . datasourc . get pool properti ( ) . set fair queue ( true ) ; thi . threadcount = 20 ; thi . transfer properti ( ) ; thi . datasourc . get connect ( ) . close ( ) ; latch = new count down latch ( threadcount ) ; long start = system . current time milli ( ) ; ( int i = 0 ; i threadcount ; i ) { test thread t = new test thread ( ) ; t . set name ( tomcat pool valid i ) ; t . d = thi . datasourc ; t . start ( ) ; } latch . await ( ) ; long delta = system . current time milli ( ) start ; system . out . println ( test pool fair test complet : delta ms . iter : ( threadcount thi . iter ) ) ; tear down ( ) ; }
public void connect ( ) throw sqlexcept { ( releas . get ( ) ) throw new sqlexcept ( connect onc releas , can t reestablish . ) ; ( connect = null ) { try { thi . disconnect ( fals ) ; } catch ( except x ) { log . debug ( unabl disconnect previou connect . , x ) ; } catch } end java . sql . driver driver = null ; try { driver = ( java . sql . driver ) class . name ( pool properti . get driver class name ( ) , true , pool connect . class . get class loader ( ) ) . new instanc ( ) ; } catch ( java . lang . except cn ) { ( log . debug enabl ( ) ) { log . debug ( unabl instanti jdbc driver . , cn ) ; } sqlexcept ex = new sqlexcept ( cn . get messag ( ) ) ; ex . init caus ( cn ) ; throw ex ; } string driver url = pool properti . get url ( ) ; string usr = pool properti . get usernam ( ) ; string pwd = pool properti . get password ( ) ; pool properti . get db properti ( ) . set properti ( user , usr ) ; pool properti . get db properti ( ) . set properti ( password , pwd ) ; try { connect = driver . connect ( driver url , pool properti . get db properti ( ) ) ; } catch ( except x ) { ( log . debug enabl ( ) ) { log . debug ( unabl connect databas . , x ) ; } ( parent . jmx pool = null ) { parent . jmx pool . notifi ( org . apach . tomcat . jdbc . pool . jmx . connect pool . notifi connect , connect pool . get stack trace ( x ) ) ; } ( x instanceof sqlexcept ) { throw ( sqlexcept ) x ; } els { sqlexcept ex = new sqlexcept ( x . get messag ( ) ) ; ex . init caus ( x ) ; throw ex ; } } set up default state , unless we expect interceptor do ( pool properti . get jdbc interceptor ( ) = = null pool properti . get jdbc interceptor ( ) . index ( connect state . class . get name ( ) ) 0 ) { ( pool properti . get default read onli ( ) = null ) connect . set read onli ( pool properti . get default read onli ( ) . boolean valu ( ) ) ; ( pool properti . get default auto commit ( ) = null ) connect . set auto commit ( pool properti . get default auto commit ( ) . boolean valu ( ) ) ; ( pool properti . get default catalog ( ) = null ) connect . set catalog ( pool properti . get default catalog ( ) ) ; ( pool properti . get default transact isol ( ) = data sourc factori . unknown transactionisol ) connect . set transact isol ( pool properti . get default transact isol ( ) ) ; } thi . discard = fals ; thi . last connect = system . current time milli ( ) ; }
privat method us initi secur manag data . void init secur ( ) { setup permiss collect thi web app context base permiss configur root web app context directori , add file read permiss directori . polici polici = polici . get polici ( ) ; ( polici = null ) { try { get permiss web app context string doc base = context . get real path ( ) ; ( doc base = = null ) { doc base = option . get scratch dir ( ) . string ( ) ; } string code base = doc base ; ( code base . end ( file . separ ) ) { code base = code base file . separ ; } file context dir = new file ( code base ) ; url url = context dir . get canon file ( ) . uri ( ) . url ( ) ; code sourc = new code sourc ( url , ( certif ) null ) ; permiss collect = polici . get permiss ( code sourc ) ; creat file read permiss web app context directori ( doc base . end ( file . separ ) ) { permiss collect . add ( new file permiss ( doc base , read ) ) ; doc base = doc base file . separ ; } els { permiss collect . add ( new file permiss ( doc base . substr ( 0 , doc base . length ( ) 1 ) , read ) ) ; } doc base = doc base ; permiss collect . add ( new file permiss ( doc base , read ) ) ; creat file read permiss web app tempdir ( work ) directori string work dir = option . get scratch dir ( ) . string ( ) ; ( work dir . end ( file . separ ) ) { permiss collect . add ( new file permiss ( work dir , read ) ) ; work dir = work dir file . separ ; } work dir = work dir ; permiss collect . add ( new file permiss ( work dir , read ) ) ; allow jsp access org . apach . jasper . runtim . http jsp base permiss collect . add ( new runtim permiss ( access class packag . org . apach . jasper . runtim ) ) ; ( parent class loader instanceof urlclass loader ) { url url = ( ( urlclass loader ) parent class loader ) . get url ( ) ; string jar url = null ; string jndi url = null ; ( int i = 0 ; i url . length ; i ) { ( jndi url = = null url i . string ( ) . start ( jndi : ) ) { jndi url = url i . string ( ) ; } ( jar url = = null url i . string ( ) . start ( jar : jndi : ) ) { jar url = url i . string ( ) ; jar url = jar url . substr ( 0 , jar url . length ( ) 2 ) ; jar url = jar url . substr ( 0 , jar url . last index ( ) ) ; } } ( jar url = null ) { permiss collect . add ( new file permiss ( jar url , read ) ) ; permiss collect . add ( new file permiss ( jar url . substr ( 4 ) , read ) ) ; } ( jndi url = null ) permiss collect . add ( new file permiss ( jndi url , read ) ) ; } } catch ( except e ) { context . log ( secur init context fail , e ) ; } } }
protect void setup socket ( ) throw ioexcept { ( mcast bind address = null ) { try { log . info ( attempt bind multicast socket address : port ) ; socket = new multicast socket ( new inet socket address ( address , port ) ) ; } catch ( bind except e ) { some plattform ( e . g . linux ) possibl bind multicast address . thi case onli bind port . log . info ( bind multicast address , fail . bind port onli . ) ; socket = new multicast socket ( port ) ; } } els { socket = new multicast socket ( port ) ; } hint we don t need loop back messag socket . set loopback mode ( true ) ; ( mcast bind address = null ) { ( log . info enabl ( ) ) log . info ( set multihom multicast interfac : mcast bind address ) ; socket . set interfac ( mcast bind address ) ; } forc so timeout so we don t block forev ( mcast so timeout = 0 ) mcast so timeout = ( int ) send frequenc ; ( log . info enabl ( ) ) log . info ( set cluster mcast so timeout mcast so timeout ) ; socket . set so timeout ( mcast so timeout ) ; ( mcast ttl = 0 ) { ( log . info enabl ( ) ) log . info ( set cluster mcast ttl mcast ttl ) ; socket . set time live ( mcast ttl ) ; } }	public void set recoveri sleep time ( long recoveri sleep time ) { properti . set properti ( recoveri sleep time , string . valu ( recoveri sleep time ) ) ; }	public void start ( int level ) throw java . lang . except { ha properti ( properti , mcast port ) ; ha properti ( properti , mcast address ) ; ha properti ( properti , member drop time ) ; ha properti ( properti , mcast frequenc ) ; ha properti ( properti , tcp listen port ) ; ha properti ( properti , tcp listen host ) ; ha properti ( properti , tcp secur port ) ; ha properti ( properti , udp listen port ) ; ( impl = null ) { impl . start ( level ) ; return ; } string host = get properti ( ) . get properti ( tcp listen host ) ; int port = integ . pars int ( get properti ( ) . get properti ( tcp listen port ) ) ; int secur port = integ . pars int ( get properti ( ) . get properti ( tcp secur port ) ) ; int udp port = integ . pars int ( get properti ( ) . get properti ( udp listen port ) ) ; ( local member = = null ) { local member = new member impl ( host , port , 100 ) ; local member . set uniqu id ( uuidgener . random uuid ( true ) ) ; } els { local member . set hostnam ( host ) ; local member . set port ( port ) ; local member . set member aliv time ( 100 ) ; } local member . set secur port ( secur port ) ; local member . set udp port ( udp port ) ; ( thi . payload = null ) local member . set payload ( payload ) ; ( thi . domain = null ) local member . set domain ( domain ) ; local member . set servic start time ( system . current time milli ( ) ) ; java . net . inet address bind = null ; ( properti . get properti ( mcast bind address ) = null ) { bind = java . net . inet address . get name ( properti . get properti ( mcast bind address ) ) ; } int ttl = 1 ; int so timeout = 1 ; ( properti . get properti ( mcast ttl ) = null ) { try { ttl = integ . pars int ( properti . get properti ( mcast ttl ) ) ; } catch ( except x ) { log . error ( unabl pars mcast ttl = properti . get properti ( mcast ttl ) , x ) ; } } ( properti . get properti ( mcast so timeout ) = null ) { try { so timeout = integ . pars int ( properti . get properti ( mcast so timeout ) ) ; } catch ( except x ) { log . error ( unabl pars mcast so timeout = properti . get properti ( mcast so timeout ) , x ) ; } } impl = new mcast servic impl ( local member , long . pars long ( properti . get properti ( mcast frequenc ) ) , long . pars long ( properti . get properti ( member drop time ) ) , integ . pars int ( properti . get properti ( mcast port ) ) , bind , java . net . inet address . get name ( properti . get properti ( mcast address ) ) , ttl , so timeout , thi , thi ) ; string valu = properti . get properti ( recoveri enabl , true ) ; boolean rec enabl = boolean . valu ( valu ) . boolean valu ( ) ; impl . set recoveri enabl ( rec enabl ) ; int rec cnt = integ . pars int ( properti . get properti ( recoveri counter , 10 ) ) ; impl . set recoveri counter ( rec cnt ) ; long rec slp time = long . pars long ( properti . get properti ( recoveri sleep time , 5000 ) ) ; impl . set recoveri sleep time ( rec slp time ) ; impl . start ( level ) ; }
protect handl receiv new session creat other node ( creat backup primari fals ) param msg param sender void handl session creat ( session messag msg , member sender ) { counter receiv evt session creat ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( delta manag . receiv messag . creat new session , get name ( ) , msg . get session id ( ) ) ) ; delta session session = ( delta session ) creat empti session ( ) ; session . set manag ( thi ) ; session . set valid ( true ) ; session . set primari session ( fals ) ; session . set creation time ( msg . get timestamp ( ) ) ; us contain max inact interv so session expir correctli case primari transfer session . set max inact interv ( get max inact interv ( ) ) ; session . access ( ) ; ( notifi session listen replic ) session . set id ( msg . get session id ( ) ) ; els session . set id intern ( msg . get session id ( ) ) ; session . reset delta request ( ) ; session . end access ( ) ; }
public replic ani chang object sinc last time object ha primari , ie , object proxi backup , replic br param complet set true , object replic backup set fals , onli object implement replic map entri dirti ( ) return true replic void replic ( object kei , boolean complet ) { ( log . trace enabl ( ) ) log . trace ( replic invok kei : kei ) ; map entri entri = ( map entri ) super . get ( kei ) ; ( entri = = null ) return ; ( entri . serializ ( ) ) return ; ( entri . primari ( ) entri . get backup node ( ) = null entri . get backup node ( ) . length 0 ) { object valu = entri . get valu ( ) ; check see we need replic thi object dirti ( ) complet boolean repl = complet ( ( valu instanceof replic map entri ) ( ( replic map entri ) valu ) . dirti ( ) ) ; ( repl ) { ( log . trace enabl ( ) ) log . trace ( replic : kei , chang made ) ; return ; } check see messag diffabl boolean diff = ( ( valu instanceof replic map entri ) ( ( replic map entri ) valu ) . diffabl ( ) ) ; map messag msg = null ; ( diff ) { replic map entri rentri = ( replic map entri ) entri . get valu ( ) ; try { rentri . lock ( ) ; construct diff messag msg = new map messag ( map context name , map messag . msg backup , true , ( serializ ) entri . get kei ( ) , null , rentri . get diff ( ) , entri . get primari ( ) , entri . get backup node ( ) ) ; } catch ( ioexcept x ) { log . error ( unabl diff object . replic entir object instead . , x ) ; } final { rentri . unlock ( ) ; } } ( msg = = null ) { construct complet msg = new map messag ( map context name , map messag . msg backup , fals , ( serializ ) entri . get kei ( ) , ( serializ ) entri . get valu ( ) , null , entri . get primari ( ) , entri . get backup node ( ) ) ; } try { ( channel = null entri . get backup node ( ) = null entri . get backup node ( ) . length 0 ) { channel . send ( entri . get backup node ( ) , msg , channel send option ) ; } } catch ( channel except x ) { log . error ( unabl replic data . , x ) ; } } end }
protect param context path param dir param file void deploi directori ( string context path , file dir , string file ) { deploi applic deploi app = new deploi applic ( context path ) ; ( deploy exist ( context path ) ) return ; deploi applic thi directori ( log . info enabl ( ) ) log . info ( sm . get string ( host config . deploi dir , file ) ) ; try { context context = null ; file xml = new file ( dir , constant . applic context xml ) ; ( deploi xml xml . exist ( ) ) { deploi descriptor ( ) instead synchron ( digest ) { try { context = ( context ) digest . pars ( xml ) ; ( context = = null ) { log . error ( sm . get string ( host config . deploi descriptor . error , xml ) ) ; return ; } } final { digest . reset ( ) ; } } file xml copi = new file ( config base ( ) , file . xml ) ; input stream = null ; output stream os = null ; try { = new file input stream ( xml ) ; os = new file output stream ( xml copi ) ; iotool . flow ( , os ) ; don t catch ioe let outer try catch handl } final { try { ( = null ) . close ( ) ; } catch ( ioexcept e ) { ignor } try { ( os = null ) os . close ( ) ; } catch ( ioexcept e ) { ignor } } context . set config file ( xml copi . get absolut path ( ) ) ; deploi app . redeploi resourc . put ( xml copi . get absolut path ( ) , new long ( xml copi . last modifi ( ) ) ) ; } els { context = ( context ) class . name ( context class ) . new instanc ( ) ; } ( context instanceof lifecycl ) { class clazz = class . name ( host . get config class ( ) ) ; lifecycl listen listen = ( lifecycl listen ) clazz . new instanc ( ) ; ( ( lifecycl ) context ) . add lifecycl listen ( listen ) ; } context . set path ( context path ) ; context . set doc base ( file ) ; host . add child ( context ) ; deploi app . redeploi resourc . put ( dir . get absolut path ( ) , new long ( dir . last modifi ( ) ) ) ; add watch resourc ( deploi app , dir . get absolut path ( ) , context ) ; } catch ( throwabl t ) { log . error ( sm . get string ( host config . deploi dir . error , file ) , t ) ; } deploi . put ( context path , deploi app ) ; }	protect param context path param war param file void deploi war ( string context path , file war , string file ) { ( deploy exist ( context path ) ) return ; check nest meta inf context . xml jar file jar = null ; jar entri entri = null ; input stream istream = null ; buffer output stream ostream = null ; file xml = new file ( config base ( ) , file . substr ( 0 , file . last index ( . ) ) . xml ) ; ( deploi xml xml . exist ( ) ) { try { jar = new jar file ( war ) ; entri = jar . get jar entri ( constant . applic context xml ) ; ( entri = null ) { istream = jar . get input stream ( entri ) ; ostream = new buffer output stream ( new file output stream ( xml ) , 1024 ) ; byte buffer = new byte 1024 ; while ( true ) { int n = istream . read ( buffer ) ; ( n 0 ) { break ; } ostream . write ( buffer , 0 , n ) ; } ostream . flush ( ) ; ostream . close ( ) ; ostream = null ; istream . close ( ) ; istream = null ; entri = null ; jar . close ( ) ; jar = null ; } } catch ( except e ) { ignor continu ( ostream = null ) { try { ostream . close ( ) ; } catch ( throwabl t ) { ignor } ostream = null ; } ( istream = null ) { try { istream . close ( ) ; } catch ( throwabl t ) { ignor } istream = null ; } } final { entri = null ; ( jar = null ) { try { jar . close ( ) ; } catch ( throwabl t ) { ignor } jar = null ; } } } deploi applic deploi app = new deploi applic ( context path ) ; deploi applic thi war file ( log . info enabl ( ) ) log . info ( sm . get string ( host config . deploi jar , file ) ) ; try { context context = null ; ( deploi xml xml . exist ( ) ) { synchron ( digest ) { try { context = ( context ) digest . pars ( xml ) ; ( context = = null ) { log . error ( sm . get string ( host config . deploi descriptor . error , file ) ) ; return ; } } final { digest . reset ( ) ; } } context . set config file ( xml . get absolut path ( ) ) ; deploi app . redeploi resourc . put ( xml . get absolut path ( ) , new long ( xml . last modifi ( ) ) ) ; } els { context = ( context ) class . name ( context class ) . new instanc ( ) ; } popul redeploi resourc war file deploi app . redeploi resourc . put ( war . get absolut path ( ) , new long ( war . last modifi ( ) ) ) ; ( context instanceof lifecycl ) { class clazz = class . name ( host . get config class ( ) ) ; lifecycl listen listen = ( lifecycl listen ) clazz . new instanc ( ) ; ( ( lifecycl ) context ) . add lifecycl listen ( listen ) ; } context . set path ( context path ) ; context . set doc base ( file ) ; host . add child ( context ) ; start context ( unpack war ( context . get doc base ( ) = null ) ) { string name = null ; string path = context . get path ( ) ; ( path . equal ( ) ) { name = root ; } els { ( path . start ( ) ) { name = path . substr ( 1 ) ; } els { name = path ; } } name = name . replac ( , ) ; file doc base = new file ( name ) ; ( doc base . absolut ( ) ) { doc base = new file ( app base ( ) , name ) ; } deploi app . redeploi resourc . put ( doc base . get absolut path ( ) , new long ( doc base . last modifi ( ) ) ) ; add watch resourc ( deploi app , doc base . get absolut path ( ) , context ) ; } els { add watch resourc ( deploi app , null , context ) ; } } catch ( throwabl t ) { log . error ( sm . get string ( host config . deploi jar . error , file ) , t ) ; } deploi . put ( context path , deploi app ) ; }
protect fire contain event context implement code org . apach . catalina . core . standard context code . param context context which fire event param type event type param data event data except except occur dure event fire void fire contain event ( context context , string type , object data ) throw except { ( org . apach . catalina . core . standard context . equal ( context . get class ( ) . get name ( ) ) ) { contain event ar support return ; } note : race condit harmless , so do synchron ( contain event method = = null ) { contain event method = context . get class ( ) . get method ( fire contain event , contain event type ) ; } object contain event param = new object 2 ; contain event param 0 = type ; contain event param 1 = data ; contain event method . invok ( context , contain event param ) ; }
public synchron renam exist log file someth els . open old log file name up onc again . intend call jmx agent . param new file name file name move log file entri return true file wa rotat error boolean rotat ( string new file name ) { ( current log file = null ) { file holder = current log file ; close ( ) ; try { holder . renam ( new file ( new file name ) ) ; } catch ( throwabl e ) { log . error ( rotat fail , e ) ; } make sure date correct current date = new date ( system . current time milli ( ) ) ; date stamp = file date formatt . format ( current date ) ; open ( ) ; return true ; } els { return fals ; } }	public log specifi messag log file , switch file date ha chang sinc previou log call . param messag messag log void log ( string messag ) { ( rotat ) { onli do logfil switch check onc second , max . long systim = system . current time milli ( ) ; ( ( systim rotat last check ) 1000 ) { we need new current date current date = new date ( systim ) ; rotat last check = systim ; check chang date string ts date = file date formatt . format ( current date ) ; date ha chang , switch log file ( date stamp . equal ( ts date ) ) { synchron ( thi ) { ( date stamp . equal ( ts date ) ) { close ( ) ; date stamp = ts date ; open ( ) ; } } } } } case someth extern rotat file instead ( check exist ) { synchron ( thi ) { ( current log file = null current log file . exist ( ) ) { try { close ( ) ; } catch ( throwabl e ) { log . info ( least thi wasn t swallow , e ) ; } make sure date correct current date = new date ( system . current time milli ( ) ) ; date stamp = file date formatt . format ( current date ) ; open ( ) ; } } } log thi messag ( writer = null ) { writer . println ( messag ) ; ( buffer ) { writer . flush ( ) ; } } }
protect after read request header , we have setup request filter . void prepar request ( ) { http11 = true ; http09 = fals ; content delimit = fals ; expect = fals ; ( ssl support = null ) { request . scheme ( ) . set string ( http ) ; } messag byte protocol mb = request . protocol ( ) ; ( protocol mb . equal ( constant . http 11 ) ) { http11 = true ; protocol mb . set string ( constant . http 11 ) ; } els ( protocol mb . equal ( constant . http 10 ) ) { http11 = fals ; keep aliv = fals ; protocol mb . set string ( constant . http 10 ) ; } els ( protocol mb . equal ( ) ) { http 0 . 9 http09 = true ; http11 = fals ; keep aliv = fals ; } els { unsupport protocol http11 = fals ; error = true ; send 505 ; unsupport http version ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . request . prepar ) unsupport http version protocol mb ) ; } respons . set statu ( 505 ) ; } messag byte method mb = request . method ( ) ; ( method mb . equal ( constant . get ) ) { method mb . set string ( constant . get ) ; } els ( method mb . equal ( constant . post ) ) { method mb . set string ( constant . post ) ; } mime header header = request . get mime header ( ) ; check connect header messag byte connect valu mb = header . get valu ( connect ) ; ( connect valu mb = null ) { byte chunk connect valu bc = connect valu mb . get byte chunk ( ) ; ( find byte ( connect valu bc , constant . close byte ) = 1 ) { keep aliv = fals ; } els ( find byte ( connect valu bc , constant . keepal byte ) = 1 ) { keep aliv = true ; } } messag byte expect mb = null ; ( http11 ) expect mb = header . get valu ( expect ) ; ( ( expect mb = null ) ( expect mb . index ignor case ( 100 continu , 0 ) = 1 ) ) { input buffer . set swallow input ( fals ) ; expect = true ; } check user agent header ( ( restrict user agent = null ) ( ( http11 ) ( keep aliv ) ) ) { messag byte user agent valu mb = header . get valu ( user agent ) ; keep aliv flag accordingli ( user agent valu mb = null ) { string user agent valu = user agent valu mb . string ( ) ; ( int i = 0 ; i restrict user agent . length ; i ) { ( restrict user agent i . matcher ( user agent valu ) . match ( ) ) { http11 = fals ; keep aliv = fals ; break ; } } } } check full uri ( includ protocol : host : port ) byte chunk uri bc = request . request uri ( ) . get byte chunk ( ) ; ( uri bc . start ignor case ( http , 0 ) ) { int po = uri bc . index ( : , 0 , 3 , 4 ) ; int uri bcstart = uri bc . get start ( ) ; int slash po = 1 ; ( po = 1 ) { byte uri b = uri bc . get byte ( ) ; slash po = uri bc . index ( , po 3 ) ; ( slash po = = 1 ) { slash po = uri bc . get length ( ) ; set uri request . request uri ( ) . set byte ( uri b , uri bcstart po 1 , 1 ) ; } els { request . request uri ( ) . set byte ( uri b , uri bcstart slash po , uri bc . get length ( ) slash po ) ; } messag byte host mb = header . set valu ( host ) ; host mb . set byte ( uri b , uri bcstart po 3 , slash po po 3 ) ; } } input filter setup input filter input filter = input buffer . get filter ( ) ; pars transfer encod header messag byte transfer encod valu mb = null ; ( http11 ) transfer encod valu mb = header . get valu ( transfer encod ) ; ( transfer encod valu mb = null ) { string transfer encod valu = transfer encod valu mb . string ( ) ; pars comma separ list . ident code ar ignor int start po = 0 ; int comma po = transfer encod valu . index ( , ) ; string encod name = null ; while ( comma po = 1 ) { encod name = transfer encod valu . substr ( start po , comma po ) . lower case ( ) . trim ( ) ; ( add input filter ( input filter , encod name ) ) { unsupport transfer encod error = true ; 501 unimpl respons . set statu ( 501 ) ; } start po = comma po 1 ; comma po = transfer encod valu . index ( , , start po ) ; } encod name = transfer encod valu . substr ( start po ) . lower case ( ) . trim ( ) ; ( add input filter ( input filter , encod name ) ) { unsupport transfer encod error = true ; 501 unimpl ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . request . prepar ) unsupport transfer encod encod name ) ; } respons . set statu ( 501 ) ; } } pars content length header long content length = request . get content length long ( ) ; ( content length = 0 content delimit ) { input buffer . add activ filter ( input filter constant . ident filter ) ; content delimit = true ; } messag byte valu mb = header . get valu ( host ) ; check host header ( http11 ( valu mb = = null ) ) { error = true ; 400 bad request ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . request . prepar ) host header miss ) ; } respons . set statu ( 400 ) ; } pars host ( valu mb ) ; ( content delimit ) { s content length ( broken http 1 . 0 http 1 . 1 ) , assum client broken didn t send bodi input buffer . add activ filter ( input filter constant . void filter ) ; content delimit = true ; } }
public long get servic start time ( ) { return thi . servic start time ; }	public synchron stop servic throw ioexcept servic fail disconnect from socket boolean stop ( int level ) throw ioexcept { boolean valid = fals ; ( ( level channel . mbr rx seq ) = = channel . mbr rx seq ) { valid = true ; do run receiv = fals ; ( receiv = null ) receiv . interrupt ( ) ; receiv = null ; } ( ( level channel . mbr tx seq ) = = channel . mbr tx seq ) { valid = true ; do run sender = fals ; ( sender = null ) sender . interrupt ( ) ; sender = null ; } ( valid ) { throw new illeg argument except ( invalid stop level . onli accept level ar channel . mbr rx seq channel . mbr tx seq ) ; } start level = ( start level ( level ) ) ; we re shut down , send shutdown messag close socket ( start level = = 0 ) { send stop messag member . set command ( member . shutdown payload ) ; member . get data ( true , true ) ; send ( fals ) ; leav mcast group try { socket . leav group ( address ) ; } catch ( except ignor ) { } try { socket . close ( ) ; } catch ( except ignor ) { } servic start time = long . max valu ; } return ( start level = = 0 ) ; }	public synchron start servic param level 1 start receiv , level 2 start sender throw ioexcept servic fail start throw illeg state except servic alreadi start void start ( int level ) throw ioexcept { boolean valid = fals ; ( ( level channel . mbr rx seq ) = = channel . mbr rx seq ) { ( receiv = null ) throw new illeg state except ( mcast servic . receiv alreadi run . ) ; try { ( sender = = null ) socket . join group ( address ) ; } catch ( ioexcept iox ) { log . error ( unabl join multicast group , make sure your system ha multicast enabl . ) ; throw iox ; } do run receiv = true ; receiv = new receiv thread ( ) ; receiv . set daemon ( true ) ; receiv . start ( ) ; valid = true ; } ( ( level channel . mbr tx seq ) = = channel . mbr tx seq ) { ( sender = null ) throw new illeg state except ( mcast servic . send alreadi run . ) ; ( receiv = = null ) socket . join group ( address ) ; make sure least packet get out send ( fals ) ; do run sender = true ; servic start time = system . current time milli ( ) ; sender = new sender thread ( send frequenc ) ; sender . set daemon ( true ) ; sender . start ( ) ; we have start receiv , yet wait membership establish valid = true ; } ( valid ) { throw new illeg argument except ( invalid start level . onli accept level ar channel . mbr rx seq channel . mbr tx seq ) ; } paus , onc twice wait member ( level ) ; start level = ( start level level ) ; }
public static synchron get string manag particular packag . manag packag alreadi exist , reus , els new string manag creat return . param packag name packag name string manag get manag ( string packag name ) { string manag mgr = manag . get ( packag name ) ; ( mgr = = null ) { mgr = new string manag ( packag name ) ; manag . put ( packag name , mgr ) ; } return mgr ; }
protect static find return error page instanc specifi except s class , error page instanc closest superclass which definit . associ error page instanc found , return code null code . param context context which search param except except which find error page error page find error page ( context context , throwabl except ) { ( except = = null ) return ( null ) ; class clazz = except . get class ( ) ; string name = clazz . get name ( ) ; while ( object . class . equal ( clazz ) ) { error page error page = context . find error page ( name ) ; ( error page = null ) return ( error page ) ; clazz = clazz . get superclass ( ) ; ( clazz = = null ) break ; name = clazz . get name ( ) ; } return ( null ) ; }
privat unregist host . void unregist host ( object name object name ) throw except { string name = object name . get kei properti ( host ) ; ( name = null ) { host host = ( host ) server factori . get server ( ) . find servic ( domain ) . get contain ( ) . find child ( name ) ; mapper . remov host ( name ) ; host . remov contain listen ( thi ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( mapper listen . unregist host , name , domain ) ) ; } }	protect creat mbean specifi servic nest compon . param servic servic which creat mbean except except except thrown dure mbean creation void creat mbean ( servic servic ) throw except { creat mbean servic itself ( log . debug enabl ( ) ) log . debug ( creat mbean servic servic ) ; mbean util . creat mbean ( servic ) ; ( servic instanceof standard servic ) { ( ( standard servic ) servic ) . add properti chang listen ( thi ) ; } creat mbean correspond connector connector connector = servic . find connector ( ) ; ( int j = 0 ; j connector . length ; j ) { creat mbean ( connector j ) ; } creat mbean associ engin friend engin engin = ( engin ) servic . get contain ( ) ; ( engin = null ) { creat mbean ( engin ) ; } }	protect deregist mbean specifi connector nest compon . param connector connector which deregist mbean except except except thrown dure mbean destruct void destroi mbean ( connector connector , servic servic ) throw except { deregist mbean connector itself ( log . debug enabl ( ) ) log . debug ( destroi mbean connector connector ) ; mbean util . destroi mbean ( connector , servic ) ; }	protect deregist mbean specifi context nest compon . param context context which deregist mbean except except except thrown dure mbean destruct void destroi mbean ( context context ) throw except { deregist ourselv contain listen context . remov contain listen ( thi ) ; destroi mbean associ nest compon realm h realm = context . get parent ( ) . get realm ( ) ; realm c realm = context . get realm ( ) ; ( ( c realm = null ) ( c realm = h realm ) ) { ( log . debug enabl ( ) ) log . debug ( destroi mbean realm c realm ) ; mbean util . destroi mbean ( c realm ) ; } manag c manag = context . get manag ( ) ; ( c manag = null ) { ( log . debug enabl ( ) ) log . debug ( destroi mbean manag c manag ) ; mbean util . destroi mbean ( c manag ) ; } loader c loader = context . get loader ( ) ; ( c loader = null ) { ( log . debug enabl ( ) ) log . debug ( destroi mbean loader c loader ) ; mbean util . destroi mbean ( c loader ) ; } destroi mbean name resourc ( ani ) name resourc resourc = context . get name resourc ( ) ; ( resourc = null ) { destroi mbean ( resourc ) ; } deregist mbean context itself ( log . debug enabl ( ) ) log . debug ( destroi mbean context context ) ; mbean util . destroi mbean ( context ) ; ( context instanceof standard context ) { ( ( standard context ) context ) . remov properti chang listen ( thi ) ; } }	protect deregist mbean specifi engin nest compon . param engin engin which destroi mbean except except except thrown dure mbean destruct void destroi mbean ( engin engin ) throw except { deregist ourselv contain listen engin . remov contain listen ( thi ) ; deregist mbean each child host contain host = engin . find children ( ) ; ( int k = 0 ; k host . length ; k ) { destroi mbean ( ( host ) host k ) ; } deregist mbean associ nest compon realm e realm = engin . get realm ( ) ; ( e realm = null ) { ( log . debug enabl ( ) ) log . debug ( destroi mbean realm e realm ) ; mbean util . destroi mbean ( e realm ) ; } deregist mbean engin itself ( log . debug enabl ( ) ) { log . debug ( destroi mbean engin engin ) ; } mbean util . destroi mbean ( engin ) ; }	protect deregist mbean specifi host nest compon . param host host which destroi mbean except except except thrown dure mbean destruct void destroi mbean ( host host ) throw except { deregist ourselv contain listen host . remov contain listen ( thi ) ; deregist mbean each child context contain context = host . find children ( ) ; ( int k = 0 ; k context . length ; k ) { destroi mbean ( ( context ) context k ) ; } deregist mbean associ nest compon realm e realm = host . get parent ( ) . get realm ( ) ; realm h realm = host . get realm ( ) ; ( ( h realm = null ) ( h realm = e realm ) ) { ( log . debug enabl ( ) ) log . debug ( destroi mbean realm h realm ) ; mbean util . destroi mbean ( h realm ) ; } deregist mbean host itself ( log . debug enabl ( ) ) { log . debug ( destroi mbean host host ) ; } mbean util . destroi mbean ( host ) ; }	protect deregist mbean specifi server relat compon . param server server which destroi mbean except except except thrown dure mbean destruct void destroi mbean ( server server ) throw except { destroi mbean global name resourc ( ani ) name resourc resourc = server . get global name resourc ( ) ; ( resourc = null ) { destroi mbean ( resourc ) ; } destroi mbean each child servic servic servic = server . find servic ( ) ; ( int i = 0 ; i servic . length ; i ) { destroi mbean ( servic i ) ; } destroi mbean server itself ( log . debug enabl ( ) ) { log . debug ( destroi mbean server server ) ; } mbean util . destroi mbean ( server ) ; ( server instanceof standard server ) { ( ( standard server ) server ) . remov properti chang listen ( thi ) ; } }	protect deregist mbean specifi servic nest compon . param servic servic which destroi mbean except except except thrown dure mbean destruct void destroi mbean ( servic servic ) throw except { deregist mbean associ engin engin engin = ( engin ) servic . get contain ( ) ; ( engin = null ) { destroi mbean ( engin ) ; } deregist mbean servic itself ( log . debug enabl ( ) ) { log . debug ( destroi mbean servic servic ) ; } mbean util . destroi mbean ( servic ) ; ( servic instanceof standard servic ) { ( ( standard servic ) servic ) . remov properti chang listen ( thi ) ; } }	public primari entri point startup shutdown event . param event event ha occur void lifecycl event ( lifecycl event event ) { lifecycl lifecycl = event . get lifecycl ( ) ; ( lifecycl . start event . equal ( event . get type ( ) ) ) { ( lifecycl instanceof server ) { creat mbean ( ) ; } we ar embed . ( lifecycl instanceof servic ) { try { mbean factori factori = new mbean factori ( ) ; creat mbean ( factori ) ; creat mbean ( ( servic ) lifecycl ) ; } catch ( except ex ) { log . error ( creat mbean factori ) ; } } ignor event from standard context object avoid reregist context ( lifecycl instanceof standard context ) return ; creat mbean ( ) ; } els ( lifecycl . stop event . equal ( event . get type ( ) ) ) { try { ( lifecycl instanceof server ) { destroi mbean ( ( server ) lifecycl ) ; } ( lifecycl instanceof servic ) { destroi mbean ( ( servic ) lifecycl ) ; } } catch ( mbean except t ) { except e = t . get target except ( ) ; ( e = = null ) { e = t ; } log . error ( destroi mbean : mbean except , e ) ; } catch ( throwabl t ) { log . error ( destroi mbean : throwabl , t ) ; } fixm : rmi adaptor should stop ; howev , thi undocu mx4j , report exist mx4j bug db thi doesn t work } ( ( context . reload event . equal ( event . get type ( ) ) ) ( lifecycl . start event . equal ( event . get type ( ) ) ) ) { context lose previou handl server ( lifecycl instanceof standard context ) { context privileg , give refer servlet context attribut standard context context = ( standard context ) lifecycl ; ( context . get privileg ( ) ) { context . get servlet context ( ) . set attribut ( global . mbean registri attr , mbean util . creat registri ( ) ) ; context . get servlet context ( ) . set attribut ( global . mbean server attr , mbean util . creat server ( ) ) ; } } } }	static creat code object name code thi code valv code object . param domain domain which thi name creat param valv valv name except malform object name except name cannot creat object name creat object name ( string domain , valv valv ) throw malform object name except { ( valv instanceof valv base ) { object name name = ( ( valv base ) valv ) . get object name ( ) ; ( name = null ) return name ; } object name name = null ; contain contain = null ; string class name = valv . get class ( ) . get name ( ) ; int period = class name . last index ( . ) ; ( period = 0 ) class name = class name . substr ( period 1 ) ; ( valv instanceof contain ) { contain = ( ( contain ) valv ) . get contain ( ) ; } ( contain = = null ) { throw new malform object name except ( cannot creat mbean non contain valv valv ) ; } ( contain instanceof engin ) { string local = ; int seq = get seq ( local ) ; string ext = ; ( seq 0 ) { ext = , seq = seq ; } name = new object name ( domain : type = valv , name = class name ext local ) ; } els ( contain instanceof host ) { string local = , host = contain . get name ( ) ; int seq = get seq ( local ) ; string ext = ; ( seq 0 ) { ext = , seq = seq ; } name = new object name ( domain : type = valv , name = class name ext local ) ; } els ( contain instanceof context ) { string path = ( ( context ) contain ) . get path ( ) ; ( path . length ( ) 1 ) { path = ; } host host = ( host ) contain . get parent ( ) ; string local = , path = path , host = host . get name ( ) ; int seq = get seq ( local ) ; string ext = ; ( seq 0 ) { ext = , seq = seq ; } name = new object name ( domain : type = valv , name = class name ext local ) ; } return ( name ) ; }	static deregist mbean thi code connector code object . param connector connector manag except except mbean cannot deregist void destroi mbean ( connector connector , servic servic ) throw except { connector . set servic ( servic ) ; string mname = creat manag name ( connector ) ; manag bean manag = registri . find manag bean ( mname ) ; ( manag = = null ) { return ; } string domain = manag . get domain ( ) ; ( domain = = null ) domain = mserver . get default domain ( ) ; object name onam = creat object name ( domain , connector ) ; connector . set servic ( null ) ; ( mserver . regist ( onam ) ) { mserver . unregist mbean ( onam ) ; } }	static deregist mbean thi code context code object . param context context manag except except mbean cannot deregist void destroi mbean ( context context ) throw except { string mname = creat manag name ( context ) ; manag bean manag = registri . find manag bean ( mname ) ; ( manag = = null ) { return ; } string domain = manag . get domain ( ) ; ( domain = = null ) domain = mserver . get default domain ( ) ; object name onam = creat object name ( domain , context ) ; ( mserver . regist ( onam ) ) mserver . unregist mbean ( onam ) ; }	static deregist mbean thi code context resourc code object . param resourc context resourc manag except except mbean cannot deregist void destroi mbean ( context resourc resourc ) throw except { string mname = creat manag name ( resourc ) ; manag bean manag = registri . find manag bean ( mname ) ; ( manag = = null ) { return ; } string domain = manag . get domain ( ) ; ( domain = = null ) domain = mserver . get default domain ( ) ; object name onam = creat object name ( domain , resourc ) ; ( mserver . regist ( onam ) ) mserver . unregist mbean ( onam ) ; }	static deregist mbean thi code engin code object . param engin engin manag except except mbean cannot deregist void destroi mbean ( engin engin ) throw except { string mname = creat manag name ( engin ) ; manag bean manag = registri . find manag bean ( mname ) ; ( manag = = null ) { return ; } string domain = manag . get domain ( ) ; ( domain = = null ) domain = mserver . get default domain ( ) ; object name onam = creat object name ( domain , engin ) ; ( mserver . regist ( onam ) ) mserver . unregist mbean ( onam ) ; }	static deregist mbean thi code host code object . param host host manag except except mbean cannot deregist void destroi mbean ( host host ) throw except { string mname = creat manag name ( host ) ; manag bean manag = registri . find manag bean ( mname ) ; ( manag = = null ) { return ; } string domain = manag . get domain ( ) ; ( domain = = null ) domain = mserver . get default domain ( ) ; object name onam = creat object name ( domain , host ) ; ( mserver . regist ( onam ) ) mserver . unregist mbean ( onam ) ; }	static deregist mbean thi code name resourc code object . param resourc name resourc manag except except mbean cannot deregist void destroi mbean ( name resourc resourc ) throw except { string mname = creat manag name ( resourc ) ; manag bean manag = registri . find manag bean ( mname ) ; ( manag = = null ) { return ; } string domain = manag . get domain ( ) ; ( domain = = null ) domain = mserver . get default domain ( ) ; object name onam = creat object name ( domain , resourc ) ; ( mserver . regist ( onam ) ) mserver . unregist mbean ( onam ) ; }	static deregist mbean thi code server code object . param server server manag except except mbean cannot deregist void destroi mbean ( server server ) throw except { string mname = creat manag name ( server ) ; manag bean manag = registri . find manag bean ( mname ) ; ( manag = = null ) { return ; } string domain = manag . get domain ( ) ; ( domain = = null ) domain = mserver . get default domain ( ) ; object name onam = creat object name ( domain , server ) ; ( mserver . regist ( onam ) ) mserver . unregist mbean ( onam ) ; }	static deregist mbean thi code user databas code object . param user databas user databas manag except except mbean cannot deregist void destroi mbean ( user databas user databas ) throw except { string mname = creat manag name ( user databas ) ; manag bean manag = registri . find manag bean ( mname ) ; ( manag = = null ) { return ; } string domain = manag . get domain ( ) ; ( domain = = null ) domain = mserver . get default domain ( ) ; object name onam = creat object name ( domain , user databas ) ; ( mserver . regist ( onam ) ) mserver . unregist mbean ( onam ) ; }
protect return list role associ given user . ani role present user s directori entri ar supplement directori search . role ar associ thi user , zero length list return . param context directori context we ar search param user user check except name except directori server error occur list string get role ( dir context context , user user ) throw name except { ( user = = null ) return ( null ) ; string dn = user . dn ; string usernam = user . usernam ; ( dn = = null usernam = = null ) return ( null ) ; ( contain log . trace enabl ( ) ) contain log . trace ( get role ( dn ) ) ; start role retriev from user entri arrai list string list = user . role ; ( list = = null ) { list = new arrai list string ( ) ; } ( common role = null ) list . add ( common role ) ; ( contain log . trace enabl ( ) ) { contain log . trace ( found list . size ( ) user intern role ) ; ( int i = 0 ; i list . size ( ) ; i ) contain log . trace ( found user intern role list . get ( i ) ) ; } ar we configur do role search ( ( role format = = null ) ( role name = = null ) ) return ( list ) ; set up paramet appropri search string filter = role format . format ( new string { do rfc2254encod ( dn ) , usernam } ) ; search control control = new search control ( ) ; ( role subtre ) control . set search scope ( search control . subtre scope ) ; els control . set search scope ( search control . onelevel scope ) ; control . set return attribut ( new string { role name } ) ; perform configur search process result name enumer search result result = context . search ( role base , filter , control ) ; ( result = = null ) should never happen , just case . . . return ( list ) ; hash map string , string group map = new hash map string , string ( ) ; try { while ( result . ha more ( ) ) { search result result = result . next ( ) ; attribut attr = result . get attribut ( ) ; ( attr = = null ) continu ; string dname = get distinguish name ( context , role base , result ) ; string name = get attribut valu ( role name , attr ) ; ( name = null dname = null ) { group map . put ( dname , name ) ; } } } catch ( partial result except ex ) { ( ad compat ) throw ex ; } set string kei = group map . kei set ( ) ; ( contain log . trace enabl ( ) ) { contain log . trace ( found kei . size ( ) direct role ) ; ( iter string i = kei . iter ( ) ; i . ha next ( ) ; ) { object k = i . next ( ) ; contain log . trace ( found direct role k group map . get ( k ) ) ; } } hash set string recurs set = new hash set string ( ) ; hash map string , string recurs map = new hash map string , string ( ) ; ( iter string i = kei . iter ( ) ; i . ha next ( ) ; ) { string k = i . next ( ) ; get role recurs ( 0 , context , recurs map , recurs set , group map . get ( k ) , k ) ; } hash set string result set = new hash set string ( list ) ; result set . add all ( recurs map . valu ( ) ) ; ( contain log . trace enabl ( ) ) { contain log . trace ( return result set . size ( ) role ) ; ( iter string i = result set . iter ( ) ; i . ha next ( ) ; ) contain log . trace ( found role i . next ( ) ) ; } return new arrai list string ( result set ) ; }	protect check credenti bind directori user param context directori context param user user authent param credenti authent credenti except name except directori server error occur boolean bind user ( dir context context , user user , string credenti ) throw name except { ( credenti = = null user = = null ) return ( fals ) ; string dn = user . dn ; ( dn = = null ) return ( fals ) ; valid credenti specifi user ( contain log . trace enabl ( ) ) { contain log . trace ( valid credenti bind user ) ; } set up secur environ bind user context . add environ ( context . secur princip , dn ) ; context . add environ ( context . secur credenti , credenti ) ; elicit ldap bind oper boolean valid = fals ; try { ( contain log . trace enabl ( ) ) { contain log . trace ( bind dn ) ; } context . get attribut ( , null ) ; valid = true ; } catch ( authent except e ) { ( contain log . trace enabl ( ) ) { contain log . trace ( bind attempt fail ) ; } } restor origin secur environ ( connect name = null ) { context . add environ ( context . secur princip , connect name ) ; } els { context . remov from environ ( context . secur princip ) ; } ( connect password = null ) { context . add environ ( context . secur credenti , connect password ) ; } els { context . remov from environ ( context . secur credenti ) ; } return ( valid ) ; }	public set search subtre role flag . param role subtre new search flag void set role subtre ( boolean role subtre ) { thi . role subtre = role subtre ; }	public set user role name attribut name thi realm . param user role name new user role name attribut name void set user role name ( string user role name ) { thi . user role name = user role name ; }
privat enumer string do get attribut name scope ( int scope ) { switch ( scope ) { case page scope : return new enumer string ( attribut . kei set ( ) . iter ( ) ) ; case request scope : return request . get attribut name ( ) ; case session scope : ( session = = null ) { throw new illeg state except ( local . get messag ( jsp . error . page . session ) ) ; } return session . get attribut name ( ) ; case applic scope : return context . get attribut name ( ) ; default : throw new illeg argument except ( invalid scope ) ; } }	int do get attribut scope ( string name ) { ( attribut . get ( name ) = null ) return page scope ; ( request . get attribut ( name ) = null ) return request scope ; ( session = null ) { ( session . get attribut ( name ) = null ) return session scope ; } ( context . get attribut ( name ) = null ) return applic scope ; return 0 ; }	void do remov attribut ( string name ) { try { remov attribut ( name , page scope ) ; remov attribut ( name , request scope ) ; ( session = null ) { remov attribut ( name , session scope ) ; } remov attribut ( name , applic scope ) ; } catch ( except ex ) { we remov much we can , simpli ignor possibl except } }
public synchron load initi instanc thi servlet , alreadi least initi instanc . thi can us , exampl , load servlet ar mark deploy descriptor load server startup time . servlet load servlet ( ) throw servlet except { noth do we alreadi have instanc instanc pool ( singl thread model ( instanc = null ) ) return instanc ; print stream out = system . out ; ( swallow output ) { system log handler . start captur ( ) ; } servlet servlet ; try { long t1 = system . current time milli ( ) ; thi servlet realli jsp file , get right class . hold your nose thi kludg avoid have do special case catalina specif code jasper also requir servlet path replac jsp file element content order complet effect string actual class = servlet class ; ( ( actual class = = null ) ( jsp file = null ) ) { wrapper jsp wrapper = ( wrapper ) ( ( context ) get parent ( ) ) . find child ( constant . jsp servlet name ) ; ( jsp wrapper = null ) { actual class = jsp wrapper . get servlet class ( ) ; merg init paramet string param name = jsp wrapper . find init paramet ( ) ; ( int i = 0 ; i param name . length ; i ) { ( paramet . get ( param name i ) = = null ) { paramet . put ( param name i , jsp wrapper . find init paramet ( param name i ) ) ; } } } } complain servlet class ha been specifi ( actual class = = null ) { unavail ( null ) ; throw new servlet except ( sm . get string ( standard wrapper . class , get name ( ) ) ) ; } instanc manag instanc manag = ( ( standard context ) get parent ( ) ) . get instanc manag ( ) ; try { servlet = ( servlet ) instanc manag . new instanc ( actual class ) ; } catch ( class cast except e ) { unavail ( null ) ; restor context class loader throw new servlet except ( sm . get string ( standard wrapper . servlet , actual class ) , e ) ; } catch ( throwabl e ) { unavail ( null ) ; http : issu . apach . org bugzilla show bug . cgi id = 36630 ( log . debug enabl ( ) ) { log . debug ( sm . get string ( standard wrapper . instanti , actual class ) , e ) ; } restor context class loader throw new servlet except ( sm . get string ( standard wrapper . instanti , actual class ) , e ) ; } special handl contain servlet instanc ( ( servlet instanceof contain servlet ) ( contain provid servlet ( actual class ) ( ( context ) get parent ( ) ) . get privileg ( ) ) ) { ( ( contain servlet ) servlet ) . set wrapper ( thi ) ; } class load time = ( int ) ( system . current time milli ( ) t1 ) ; call initi method thi servlet try { instanc support . fire instanc event ( instanc event . befor init event , servlet ) ; ( global . secur enabl ) { object arg = new object { ( facad ) } ; secur util . do privileg ( init , servlet , class type , arg ) ; arg = null ; } els { servlet . init ( facad ) ; } invok jsp init jsp page ( ( load startup = 0 ) ( jsp file = null ) ) { invok jsp init dummi request req = new dummi request ( ) ; req . set servlet path ( jsp file ) ; req . set queri string ( jsp precompil = true ) ; dummi respons re = new dummi respons ( ) ; ( global . secur enabl ) { object arg = new object { req , re } ; secur util . do privileg ( servic , servlet , class type us servic , arg ) ; arg = null ; } els { servlet . servic ( req , re ) ; } } instanc support . fire instanc event ( instanc event . after init event , servlet ) ; } catch ( unavail except f ) { instanc support . fire instanc event ( instanc event . after init event , servlet , f ) ; unavail ( f ) ; throw f ; } catch ( servlet except f ) { instanc support . fire instanc event ( instanc event . after init event , servlet , f ) ; said so , so do call unavail ( null ) . throw f ; } catch ( throwabl f ) { get servlet context ( ) . log ( standard wrapper . throwabl , f ) ; instanc support . fire instanc event ( instanc event . after init event , servlet , f ) ; said so , so do call unavail ( null ) . throw new servlet except ( sm . get string ( standard wrapper . init except , get name ( ) ) , f ) ; } regist our newli initi instanc singl thread model = servlet instanceof singl thread model ; ( singl thread model ) { ( instanc pool = = null ) instanc pool = new stack servlet ( ) ; } fire contain event ( load , thi ) ; load time = system . current time milli ( ) t1 ; } final { ( swallow output ) { string log = system log handler . stop captur ( ) ; ( log = null log . length ( ) 0 ) { ( get servlet context ( ) = null ) { get servlet context ( ) . log ( log ) ; } els { out . println ( log ) ; } } } } return servlet ; }
protect given ldap search string , return string certain charact escap accord rfc 2254 guidelin . charact map follow : char replac 2a ( 28 ) 29 5c 0 00 param string string escap accord rfc 2254 guidelin return string escap encod result string do rfc2254encod ( string string ) { string buffer buf = new string buffer ( string . length ( ) ) ; ( int i = 0 ; i string . length ( ) ; i ) { char c = string . char ( i ) ; switch ( c ) { case : buf . append ( 5c ) ; break ; case : buf . append ( 2a ) ; break ; case ( : buf . append ( 28 ) ; break ; case ) : buf . append ( 29 ) ; break ; case 0 : buf . append ( 00 ) ; break ; default : buf . append ( c ) ; break ; } } return buf . string ( ) ; }
public close stream , flush first . onc stream ha been close , further write ( ) flush ( ) invoc caus ioexcept thrown . close previous close stream , howev , ha effect . throw ioexcept i o error occur void close ( ) throw ioexcept { ( writer = null ) { writer . close ( ) ; } els { close = true ; } }	set writer which all output written . void set writer ( writer writer ) { thi . writer = writer ; close = fals ; ( writer = null ) { call page context . push bodi ( ) ) befor set 0 . ( buffer size = 0 ) { buffer size save = buffer size ; buffer size = 0 ; } } els { buffer size = buffer size save ; clear bodi ( ) ; } }
public process pipelin http request us specifi input output stream . throw ioexcept error dure i o oper socket state process ( nio channel socket ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set up socket thi . socket = socket ; input buffer . set socket ( socket ) ; output buffer . set socket ( socket ) ; input buffer . set selector pool ( endpoint . get selector pool ( ) ) ; output buffer . set selector pool ( endpoint . get selector pool ( ) ) ; error flag error = fals ; keep aliv = true ; comet = fals ; long so timeout = endpoint . get so timeout ( ) ; int keep aliv timeout = endpoint . get keep aliv timeout ( ) ; boolean kept aliv = fals ; boolean open socket = fals ; boolean recycl = true ; final kei attach ka = ( kei attach ) socket . get attach ( fals ) ; while ( error keep aliv comet ) { alwai default our so timeout ka . set timeout ( so timeout ) ; pars request header try { ( disabl upload timeout kept aliv so timeout 0 ) { socket . get iochannel ( ) . socket ( ) . set so timeout ( ( int ) so timeout ) ; } ( input buffer . pars request line ( kept aliv ) ) { data avail yet , sinc we might have read part request line , we can t recycl processor open socket = true ; recycl = fals ; ( input buffer . get pars request line phase ( ) 2 ) { keep aliv timeout here ( keep aliv timeout 0 ) ka . set timeout ( keep aliv timeout ) ; } break ; } kept aliv = true ; ( input buffer . pars header ( ) ) { we ve read part request , don t recycl instead associ socket open socket = true ; recycl = fals ; break ; } request . set start time ( system . current time milli ( ) ) ; ( disabl upload timeout ) { onli bodi , request header socket . get iochannel ( ) . socket ( ) . set so timeout ( timeout ) ; } } catch ( ioexcept e ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . header . pars ) , e ) ; } error = true ; break ; } catch ( throwabl t ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . header . pars ) , t ) ; } 400 bad request respons . set statu ( 400 ) ; error = true ; } set up filter , pars some request header rp . set stage ( org . apach . coyot . constant . stage prepar ) ; try { prepar request ( ) ; } catch ( throwabl t ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . request . prepar ) , t ) ; } 400 intern server error respons . set statu ( 400 ) ; error = true ; } ( max keep aliv request = = 1 ) keep aliv = fals ; ( max keep aliv request 0 ka . decrement keep aliv ( ) = 0 ) keep aliv = fals ; process request adapt ( error ) { try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; adapt . servic ( request , respons ) ; commit , so we can t try set header . ( keep aliv error ) { avoid check twice . error = respons . get error except ( ) = null statu drop connect ( respons . get statu ( ) ) ; } comet support select kei kei = socket . get iochannel ( ) . kei ( socket . get poller ( ) . get selector ( ) ) ; ( kei = null ) { nio endpoint . kei attach attach = ( nio endpoint . kei attach ) kei . attach ( ) ; ( attach = null ) { attach . set comet ( comet ) ; ( comet ) { integ comettimeout = ( integ ) request . get attribut ( org . apach . tomcat . comet . timeout ) ; ( comettimeout = null ) attach . set timeout ( comettimeout . long valu ( ) ) ; } } } } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { log . error ( sm . get string ( http11processor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; error = true ; } } finish handl request ( comet ) { servlet ha reject . ( error ) input buffer . set swallow input ( fals ) ; end request ( ) ; } error , updat statist counter ( error ) { respons . set statu ( 500 ) ; } request . updat counter ( ) ; ( comet ) { next request input buffer . next request ( ) ; output buffer . next request ( ) ; } do sendfil need : add socket sendfil end ( sendfil data = null error ) { ka . set sendfil data ( sendfil data ) ; sendfil data . keep aliv = keep aliv ; select kei kei = socket . get iochannel ( ) . kei ( socket . get poller ( ) . get selector ( ) ) ; do first write thi thread , might well open socket = socket . get poller ( ) . process sendfil ( kei , ka , true , true ) ; break ; } rp . set stage ( org . apach . coyot . constant . stage keepal ) ; } while rp . set stage ( org . apach . coyot . constant . stage end ) ; ( comet ) { ( error ) { recycl ( ) ; return socket state . close ; } els { return socket state . long ; } } els { ( recycl ) { recycl ( ) ; } return ( open socket ) ( socket state . open ) : socket state . close ; return ( open socket ) ( recycl socket state . open : socket state . long ) : socket state . close ; } }	public process pipelin http request us specifi input output stream . throw ioexcept error dure i o oper socket state process ( long socket ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set remot address remot addr = null ; remot host = null ; local addr = null ; local name = null ; remot port = 1 ; local port = 1 ; set up socket thi . socket = socket ; input buffer . set socket ( socket ) ; output buffer . set socket ( socket ) ; error flag error = fals ; comet = fals ; keep aliv = true ; int keep aliv left = max keep aliv request ; long so timeout = endpoint . get so timeout ( ) ; boolean kept aliv = fals ; boolean open socket = fals ; while ( error keep aliv comet ) { pars request header try { ( disabl upload timeout kept aliv so timeout 0 ) { socket . timeout set ( socket , so timeout 1000 ) ; } ( input buffer . pars request line ( kept aliv ) ) { thi mean data avail right now ( long keepal ) , so processor should recycl method should return true open socket = true ; add socket poller endpoint . get poller ( ) . add ( socket ) ; break ; } request . set start time ( system . current time milli ( ) ) ; kept aliv = true ; ( disabl upload timeout ) { socket . timeout set ( socket , timeout 1000 ) ; } input buffer . pars header ( ) ; } catch ( ioexcept e ) { error = true ; break ; } catch ( throwabl t ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . header . pars ) , t ) ; } 400 bad request respons . set statu ( 400 ) ; error = true ; } set up filter , pars some request header rp . set stage ( org . apach . coyot . constant . stage prepar ) ; try { prepar request ( ) ; } catch ( throwabl t ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . request . prepar ) , t ) ; } 400 intern server error respons . set statu ( 400 ) ; error = true ; } ( max keep aliv request 0 keep aliv left = = 0 ) keep aliv = fals ; process request adapt ( error ) { try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; adapt . servic ( request , respons ) ; commit , so we can t try set header . ( keep aliv error ) { avoid check twice . error = respons . get error except ( ) = null statu drop connect ( respons . get statu ( ) ) ; } } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { log . error ( sm . get string ( http11processor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; error = true ; } } finish handl request ( comet ) { servlet ha reject . ( error ) input buffer . set swallow input ( fals ) ; end request ( ) ; } error , updat statist counter ( error ) { respons . set statu ( 500 ) ; } request . updat counter ( ) ; ( comet ) { next request input buffer . next request ( ) ; output buffer . next request ( ) ; } do sendfil need : add socket sendfil end ( sendfil data = null error ) { sendfil data . socket = socket ; sendfil data . keep aliv = keep aliv ; ( endpoint . get sendfil ( ) . add ( sendfil data ) ) { open socket = true ; break ; } } rp . set stage ( org . apach . coyot . constant . stage keepal ) ; } rp . set stage ( org . apach . coyot . constant . stage end ) ; ( comet ) { ( error ) { input buffer . next request ( ) ; output buffer . next request ( ) ; recycl ( ) ; return socket state . close ; } els { return socket state . long ; } } els { recycl ( ) ; return ( open socket ) socket state . open : socket state . close ; } }	public read request line . thi function meant us dure http request header pars . do attempt read request bodi us . throw ioexcept except occur dure underli socket read oper , given buffer big enough accomod whole line . return true data properli fed ; fals data avail immedi thread should freed boolean pars request line ( boolean us avail data ) throw ioexcept { int start = 0 ; skip blank line byte chr = 0 ; do { read new byte need ( po = last valid ) { ( us avail data ) { return fals ; } ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } chr = buf po ; } while ( ( chr = = constant . cr ) ( chr = = constant . lf ) ) ; po ; mark current buffer posit start = po ; ( po = last valid ) { ( us avail data ) { return fals ; } ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } read method name method name alwai us ascii boolean space = fals ; while ( space ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } spec sai singl sp also sai toler ht ( buf po = = constant . sp buf po = = constant . ht ) { space = true ; request . method ( ) . set byte ( buf , start , po start ) ; } po ; } spec sai singl sp also sai toler multipl ht while ( space ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } ( buf po = = constant . sp buf po = = constant . ht ) { po ; } els { space = fals ; } } mark current buffer posit start = po ; int end = 0 ; int question po = 1 ; read uri boolean eol = fals ; while ( space ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } spec sai singl sp also sai toler ht ( buf po = = constant . sp buf po = = constant . ht ) { space = true ; end = po ; } els ( ( buf po = = constant . cr ) ( buf po = = constant . lf ) ) { http 0 . 9 style request eol = true ; space = true ; end = po ; } els ( ( buf po = = constant . question ) ( question po = = 1 ) ) { question po = po ; } po ; } request . unpars uri ( ) . set byte ( buf , start , end start ) ; ( question po = 0 ) { request . queri string ( ) . set byte ( buf , question po 1 , end question po 1 ) ; request . request uri ( ) . set byte ( buf , start , question po start ) ; } els { request . request uri ( ) . set byte ( buf , start , end start ) ; } spec sai singl sp also sai toler multipl ht while ( space ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } ( buf po = = constant . sp buf po = = constant . ht ) { po ; } els { space = fals ; } } mark current buffer posit start = po ; end = 0 ; while ( eol ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } ( buf po = = constant . cr ) { end = po ; } els ( buf po = = constant . lf ) { ( end = = 0 ) end = po ; eol = true ; } po ; } ( ( end start ) 0 ) { request . protocol ( ) . set byte ( buf , start , end start ) ; } els { request . protocol ( ) . set string ( ) ; } return true ; }	public read request line . thi function meant us dure http request header pars . do attempt read request bodi us . throw ioexcept except occur dure underli socket read oper , given buffer big enough accomod whole line . return true data properli fed ; fals data avail immedi thread should freed boolean pars request line ( boolean us avail data ) throw ioexcept { check state ( pars request line ) return true ; ( pars request line phase = = 0 ) { byte chr = 0 ; do { read new byte need ( po = last valid ) { ( us avail data ) { return fals ; } do simpl read short timeout ( read socket ( true , fals ) = = 0 ) return fals ; } chr = buf po ; } while ( ( chr = = constant . cr ) ( chr = = constant . lf ) ) ; po ; pars request line start = po ; pars request line phase = 1 ; } ( pars request line phase = = 1 ) { mark current buffer posit ( po = last valid ) { ( us avail data ) { return fals ; } do simpl read short timeout ( read socket ( true , fals ) = = 0 ) return fals ; } pars request line phase = 2 ; } ( pars request line phase = = 2 ) { read method name method name alwai us ascii boolean space = fals ; while ( space ) { read new byte need ( po = last valid ) { ( request line pars fill ( true , fals ) ) return fals ; } ( buf po = = constant . sp buf po = = constant . ht ) { space = true ; request . method ( ) . set byte ( buf , pars request line start , po pars request line start ) ; } po ; } pars request line start = po ; pars request line phase = 3 ; } ( pars request line phase = = 3 ) { spec sai singl sp also toler multipl ht boolean space = true ; while ( space ) { read new byte need ( po = last valid ) { ( request line pars fill ( true , fals ) ) return fals ; } ( buf po = = constant . sp buf po = = constant . ht ) { po ; } els { space = fals ; } } mark current buffer posit int end = 0 ; while ( space ) { read new byte need ( po = last valid ) { ( request line pars fill ( true , fals ) ) return fals ; } ( buf po = = constant . sp buf po = = constant . ht ) { space = true ; end = po ; } els ( ( buf po = = constant . cr ) ( buf po = = constant . lf ) ) { http 0 . 9 style request pars request line eol = true ; space = true ; end = po ; } els ( ( buf po = = constant . question ) ( pars request line qpo = = 1 ) ) { pars request line qpo = po ; } po ; } request . unpars uri ( ) . set byte ( buf , pars request line start , end pars request line start ) ; ( pars request line qpo = 0 ) { request . queri string ( ) . set byte ( buf , pars request line qpo 1 , end pars request line qpo 1 ) ; request . request uri ( ) . set byte ( buf , pars request line start , pars request line qpo pars request line start ) ; } els { request . request uri ( ) . set byte ( buf , pars request line start , end pars request line start ) ; } pars request line start = po ; pars request line phase = 4 ; } ( pars request line phase = = 4 ) { spec sai singl sp also toler multipl ht boolean space = true ; while ( space ) { read new byte need ( po = last valid ) { ( request line pars fill ( true , fals ) ) return fals ; } ( buf po = = constant . sp buf po = = constant . ht ) { po ; } els { space = fals ; } } mark current buffer posit end = 0 ; while ( pars request line eol ) { read new byte need ( po = last valid ) { ( requ line pars fill ( true , fals ) ) return fals ; } ( buf po = = constant . cr ) { end = po ; } els ( buf po = = constant . lf ) { ( end = = 0 ) end = po ; pars request line eol = true ; } po ; } ( ( end pars request line start ) 0 ) { request . protocol ( ) . set byte ( buf , pars request line start , end pars request line start ) ; } els { request . protocol ( ) . set string ( ) ; } pars request line = fals ; pars request line phase = 0 ; pars request line eol = fals ; pars request line start = 0 ; return true ; } throw new illeg state except ( invalid request line pars phase : pars request line phase ) ; }	public read request line . thi function meant us dure http request header pars . do attempt read request bodi us . throw ioexcept except occur dure underli socket read oper , given buffer big enough accomod whole line . void pars request line ( ) throw ioexcept { int start = 0 ; skip blank line byte chr = 0 ; do { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } chr = buf po ; } while ( ( chr = = constant . cr ) ( chr = = constant . lf ) ) ; po ; mark current buffer posit start = po ; read method name method name alwai us ascii boolean space = fals ; while ( space ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } spec sai singl sp also sai toler ht ( buf po = = constant . sp buf po = = constant . ht ) { space = true ; request . method ( ) . set byte ( buf , start , po start ) ; } po ; } spec sai singl sp also sai toler multipl ht while ( space ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } ( buf po = = constant . sp buf po = = constant . ht ) { po ; } els { space = fals ; } } mark current buffer posit start = po ; int end = 0 ; int question po = 1 ; read uri boolean eol = fals ; while ( space ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } spec sai singl sp also sai toler ht ( buf po = = constant . sp buf po = = constant . ht ) { space = true ; end = po ; } els ( ( buf po = = constant . cr ) ( buf po = = constant . lf ) ) { http 0 . 9 style request eol = true ; space = true ; end = po ; } els ( ( buf po = = constant . question ) ( question po = = 1 ) ) { question po = po ; } po ; } request . unpars uri ( ) . set byte ( buf , start , end start ) ; ( question po = 0 ) { request . queri string ( ) . set byte ( buf , question po 1 , end question po 1 ) ; request . request uri ( ) . set byte ( buf , start , question po start ) ; } els { request . request uri ( ) . set byte ( buf , start , end start ) ; } spec sai singl sp also sai toler multipl ht while ( space ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } ( buf po = = constant . sp buf po = = constant . ht ) { po ; } els { space = fals ; } } mark current buffer posit start = po ; end = 0 ; while ( eol ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } ( buf po = = constant . cr ) { end = po ; } els ( buf po = = constant . lf ) { ( end = = 0 ) end = po ; eol = true ; } po ; } ( ( end start ) 0 ) { request . protocol ( ) . set byte ( buf , start , end start ) ; } els { request . protocol ( ) . set string ( ) ; } }
public load class specifi name , search us follow algorithm until find return class . class cannot found , return code class found except code . ul li call code find load class ( string ) code check class ha alreadi been load . ha , same code class code object return . li li code deleg code properti set code true code , call code load class ( ) code method parent class loader , ani . li li call code find class ( ) code find thi class our local defin repositori . li li call code load class ( ) code method our parent class loader , ani . li ul class wa found us abov step , code resolv code flag code true code , thi method call code resolv class ( class ) code result class object . param name name class load param resolv code true code resolv class except class found except class wa found class load class ( string name , boolean resolv ) throw class found except { ( log . debug enabl ( ) ) log . debug ( load class ( name , resolv ) ) ; class clazz = null ; log access stop classload ( start ) { try { throw new illeg state except ( ) ; } catch ( illeg state except e ) { log . info ( sm . get string ( webapp class loader . stop , name ) , e ) ; } } ( 0 ) check our previous load local class cach clazz = find load class0 ( name ) ; ( clazz = null ) { ( log . debug enabl ( ) ) log . debug ( return class from cach ) ; ( resolv ) resolv class ( clazz ) ; return ( clazz ) ; } ( 0 . 1 ) check our previous load class cach clazz = find load class ( name ) ; ( clazz = null ) { ( log . debug enabl ( ) ) log . debug ( return class from cach ) ; ( resolv ) resolv class ( clazz ) ; return ( clazz ) ; } webapp from overrid j2se class try { clazz = system . load class ( name ) ; ( clazz = null ) { ( resolv ) resolv class ( clazz ) ; return ( clazz ) ; } } catch ( class found except e ) { ignor } ( 0 . 5 ) permiss access thi class when us secur manag ( secur manag = null ) { int i = name . last index ( . ) ; ( i = 0 ) { try { secur manag . check packag access ( name . substr ( 0 , i ) ) ; } catch ( secur except se ) { string error = secur violat , attempt us restrict class : name ; log . info ( error , se ) ; throw new class found except ( error , se ) ; } } } boolean deleg load = deleg filter ( name ) ; ( 1 ) deleg our parent request ( deleg load ) { ( log . debug enabl ( ) ) log . debug ( deleg parent classloader1 parent ) ; class loader loader = parent ; ( loader = = null ) loader = system ; try { clazz = loader . load class ( name ) ; ( clazz = null ) { ( log . debug enabl ( ) ) log . debug ( load class from parent ) ; ( resolv ) resolv class ( clazz ) ; return ( clazz ) ; } } catch ( class found except e ) { ignor } } ( 2 ) search local repositori ( log . debug enabl ( ) ) log . debug ( search local repositori ) ; try { clazz = find class ( name ) ; ( clazz = null ) { ( log . debug enabl ( ) ) log . debug ( load class from local repositori ) ; ( resolv ) resolv class ( clazz ) ; return ( clazz ) ; } } catch ( class found except e ) { ignor } ( 3 ) deleg parent uncondition ( deleg load ) { ( log . debug enabl ( ) ) log . debug ( deleg parent classload end : parent ) ; class loader loader = parent ; ( loader = = null ) loader = system ; try { clazz = loader . load class ( name ) ; ( clazz = null ) { ( log . debug enabl ( ) ) log . debug ( load class from parent ) ; ( resolv ) resolv class ( clazz ) ; return ( clazz ) ; } } catch ( class found except e ) { ignor } } throw new class found except ( name ) ; }

protect void process ssi ( http servlet request req , http servlet respons re , url resourc ) throw ioexcept { ssiextern resolv ssi extern resolv = new ssiservlet extern resolv ( get servlet context ( ) , req , re , virtual webapp rel , debug , input encod ) ; ssiprocessor ssi processor = new ssiprocessor ( ssi extern resolv , debug ) ; print writer print writer = null ; string writer string writer = null ; ( buffer ) { string writer = new string writer ( ) ; print writer = new print writer ( string writer ) ; } els { print writer = re . get writer ( ) ; } urlconnect resourc info = resourc . open connect ( ) ; input stream resourc input stream = resourc info . get input stream ( ) ; string encod = resourc info . get content encod ( ) ; ( encod = = null ) { encod = input encod ; } input stream reader isr ; ( encod = = null ) { isr = new input stream reader ( resourc input stream ) ; } els { isr = new input stream reader ( resourc input stream , encod ) ; } buffer reader buffer reader = new buffer reader ( isr ) ; long last modifi = ssi processor . process ( buffer reader , resourc info . get last modifi ( ) , print writer ) ; ( last modifi 0 ) { re . set date header ( last modifi , last modifi ) ; } ( buffer ) { print writer . flush ( ) ; string text = string writer . string ( ) ; re . get writer ( ) . write ( text ) ; } }

public boolean offer ( runnabl o ) { we can t do ani check ( parent = = null ) return super . offer ( o ) ; we ar max out thread , simpli queue object ( parent . get pool size ( ) = = parent . get maximum pool size ( ) ) return super . offer ( o ) ; we have idl thread , just add queue ( parent . get activ count ( ) ( parent . get pool size ( ) ) ) return super . offer ( o ) ; we have less thread than maximum forc creation new thread ( parent . get pool size ( ) parent . get maximum pool size ( ) ) return fals ; we reach here , we need add queue return super . offer ( o ) ; }
public jk handler mehod int invok ( msg msg , msg context ep ) throw ioexcept { ( ep . log time enabl ( ) ) ep . set long ( msg context . timer pre request , system . current time milli ( ) ) ; request req = ep . get request ( ) ; respons re = req . get respons ( ) ; ( log . debug enabl ( ) ) log . debug ( invok req re req . request uri ( ) . string ( ) ) ; re . set note ( ep note , ep ) ; ep . set statu ( msg context . jk statu head ) ; request info rp = req . get request processor ( ) ; rp . set stage ( constant . stage servic ) ; try { adapt . servic ( req , re ) ; } catch ( except ex ) { log . info ( error servic request req , ex ) ; } ( ep . get statu ( ) = msg context . jk statu close ) { re . finish ( ) ; } req . recycl ( ) ; req . updat counter ( ) ; re . recycl ( ) ; ep . recycl ( ) ; ( ep . get statu ( ) = = msg context . jk statu error ) { return error ; } ep . set statu ( msg context . jk statu new ) ; rp . set stage ( constant . stage keepal ) ; return ok ; }
public string find instanc listen ( ) { return ( instanc listen ) ; }	public object clone ( ) { synchron ( member ) { membership clone = new membership ( local , member compar ) ; clone . map = ( hash map member impl , mbr entri ) map . clone ( ) ; clone . member = new member impl member . length ; system . arraycopi ( member , 0 , clone . member , 0 , member . length ) ; return clone ; } }	public string find servlet map ( ) { synchron ( servlet map ) { string result = new string servlet map . size ( ) ; return ( servlet map . kei set ( ) . arrai ( result ) ) ; } }	public secur constraint find constraint ( ) { return ( constraint ) ; }	public string find secur role ( ) { return ( secur role ) ; }	public string find wrapper listen ( ) { return ( wrapper listen ) ; }	public synchron add member thi compon sort arrai member compar param member member add mbr entri add member ( member impl member ) { synchron ( member ) { mbr entri entri = new mbr entri ( member ) ; ( map . contain kei ( member ) ) { map . put ( member , entri ) ; member impl result = new member impl member . length 1 ; ( int i = 0 ; i member . length ; i ) result i = member i ; result member . length = member ; member = result ; arrai . sort ( member , member compar ) ; } return entri ; } }	public string get alias ( ) { return alias ; }	public add alia name should map thi same host . param alia alia ad void add alia ( string alia ) { alia = alia . lower case ( ) ; skip duplic alias ( int i = 0 ; i alias . length ; i ) { ( alias i . equal ( alia ) ) return ; } add thi alia list string new alias = new string alias . length 1 ; ( int i = 0 ; i alias . length ; i ) new alias i = alias i ; new alias alias . length = alia ; alias = new alias ; inform interest listen fire contain event ( add alia event , alia ) ; }	public add new listen class name set listen configur thi applic . param listen java class name listen class void add applic listen ( string listen ) { synchron ( applic listen ) { string result = new string applic listen . length 1 ; ( int i = 0 ; i applic listen . length ; i ) { ( listen . equal ( applic listen i ) ) { log . info ( sm . get string ( standard context . duplic listen , listen ) ) ; return ; } result i = applic listen i ; } result applic listen . length = listen ; applic listen = result ; } fire contain event ( add applic listen , listen ) ; fixm add instanc alreadi start }	public add new applic paramet thi applic . param paramet new applic paramet void add applic paramet ( applic paramet paramet ) { synchron ( applic paramet ) { string new name = paramet . get name ( ) ; ( int i = 0 ; i applic paramet . length ; i ) { ( new name . equal ( applic paramet i . get name ( ) ) applic paramet i . get overrid ( ) ) return ; } applic paramet result = new applic paramet applic paramet . length 1 ; system . arraycopi ( applic paramet , 0 , result , 0 , applic paramet . length ) ; result applic paramet . length = paramet ; applic paramet = result ; } fire contain event ( add applic paramet , paramet ) ; }	public string find alias ( ) { return ( thi . alias ) ; }	public add secur constraint set thi web applic . void add constraint ( secur constraint constraint ) { valid propos constraint secur collect collect = constraint . find collect ( ) ; ( int i = 0 ; i collect . length ; i ) { string pattern = collect i . find pattern ( ) ; ( int j = 0 ; j pattern . length ; j ) { pattern j = adjust urlpattern ( pattern j ) ; ( valid urlpattern ( pattern j ) ) throw new illeg argument except ( sm . get string ( standard context . secur constraint . pattern , pattern j ) ) ; } } add thi constraint set our web applic synchron ( constraint ) { secur constraint result = new secur constraint constraint . length 1 ; ( int i = 0 ; i constraint . length ; i ) result i = constraint i ; result constraint . length = constraint ; constraint = result ; } }	public add filter map thi context end current set filter map . param filter map filter map ad except illeg argument except specifi filter name doe match exist filter definit , filter map malform void add filter map ( filter map filter map ) { valid filter map ( filter map ) ; add thi filter map our regist set synchron ( filter map ) { filter map result = new filter map filter map . length 1 ; system . arraycopi ( filter map , 0 , result , 0 , filter map . length ) ; result filter map . length = filter map ; filter map = result ; } fire contain event ( add filter map , filter map ) ; }	public add filter map thi context befor map defin deploy descriptor after ani other map ad via thi method . param filter map filter map ad except illeg argument except specifi filter name doe match exist filter definit , filter map malform void add filter map befor ( filter map filter map ) { valid filter map ( filter map ) ; add thi filter map our regist set synchron ( filter map ) { filter map result = new filter map filter map . length 1 ; system . arraycopi ( filter map , 0 , result , 0 , filter map insert point ) ; result filter map insert point = filter map ; system . arraycopi ( filter map , filter map insert point , result , filter map . length filter map insert point 1 , filter map insert point ) ; filter map insert point ; result filter map . length = filter map ; filter map = result ; } fire contain event ( add filter map , filter map ) ; }	public add lifecycl event listen thi compon . param listen listen add void add instanc listen ( instanc listen listen ) { synchron ( listen ) { instanc listen result = new instanc listen listen . length 1 ; ( int i = 0 ; i listen . length ; i ) result i = listen i ; result listen . length = listen ; listen = result ; } }	public add classnam instanc listen ad each wrapper append thi context . param listen java class name instanc listen class void add instanc listen ( string listen ) { synchron ( instanc listen ) { string result = new string instanc listen . length 1 ; ( int i = 0 ; i instanc listen . length ; i ) result i = instanc listen i ; result instanc listen . length = listen ; instanc listen = result ; } fire contain event ( add instanc listen , listen ) ; }	public lifecycl listen find lifecycl listen ( ) { return listen ; }	public add new secur role thi web applic . param role new secur role void add secur role ( string role ) { synchron ( secur role ) { string result = new string secur role . length 1 ; ( int i = 0 ; i secur role . length ; i ) result i = secur role i ; result secur role . length = role ; secur role = result ; } fire contain event ( add secur role , role ) ; }	public add new servlet map , replac ani exist map specifi pattern . param pattern url pattern map param name name correspond servlet execut param jsp wild card true name identifi jsp servlet pattern contain wildcard ; fals otherwis except illeg argument except specifi servlet name known thi context void add servlet map ( string pattern , string name , boolean jsp wild card ) { valid propos map ( find child ( name ) = = null ) throw new illeg argument except ( sm . get string ( standard context . servlet map . name , name ) ) ; pattern = adjust urlpattern ( request util . urldecod ( pattern ) ) ; ( valid urlpattern ( pattern ) ) throw new illeg argument except ( sm . get string ( standard context . servlet map . pattern , pattern ) ) ; add thi map our regist set synchron ( servlet map ) { string name2 = servlet map . get ( pattern ) ; ( name2 = null ) { don t allow more than servlet same pattern wrapper wrapper = ( wrapper ) find child ( name2 ) ; wrapper . remov map ( pattern ) ; mapper . remov wrapper ( pattern ) ; } servlet map . put ( pattern , name ) ; } wrapper wrapper = ( wrapper ) find child ( name ) ; wrapper . add map ( pattern ) ; updat context mapper mapper . add wrapper ( pattern , wrapper , jsp wild card ) ; fire contain event ( add servlet map , pattern ) ; }	public add new watch resourc set recogn thi context . param name new watch resourc file name void add watch resourc ( string name ) { synchron ( watch resourc ) { string result = new string watch resourc . length 1 ; ( int i = 0 ; i watch resourc . length ; i ) result i = watch resourc i ; result watch resourc . length = name ; watch resourc = result ; } fire contain event ( add watch resourc , name ) ; }	public add new welcom file set recogn thi context . param name new welcom file name void add welcom file ( string name ) { synchron ( welcom file ) { complet replac those from default conf web . xml file ( replac welcom file ) { welcom file = new string 0 ; set replac welcom file ( fals ) ; } string result = new string welcom file . length 1 ; ( int i = 0 ; i welcom file . length ; i ) result i = welcom file i ; result welcom file . length = name ; welcom file = result ; } post welcom file ( ) ; fire contain event ( add welcom file , name ) ; }	public add classnam lifecycl listen ad each wrapper append thi context . param listen java class name lifecycl listen class void add wrapper lifecycl ( string listen ) { synchron ( wrapper lifecycl ) { string result = new string wrapper lifecycl . length 1 ; ( int i = 0 ; i wrapper lifecycl . length ; i ) result i = wrapper lifecycl i ; result wrapper lifecycl . length = listen ; wrapper lifecycl = result ; } fire contain event ( add wrapper lifecycl , listen ) ; }	public add classnam contain listen ad each wrapper append thi context . param listen java class name contain listen class void add wrapper listen ( string listen ) { synchron ( wrapper listen ) { string result = new string wrapper listen . length 1 ; ( int i = 0 ; i wrapper listen . length ; i ) result i = wrapper listen i ; result wrapper listen . length = listen ; wrapper listen = result ; } fire contain event ( add wrapper listen , listen ) ; }	public destroi need clean up context complet . problem undo all config start ( ) restor fresh state imposs . after stop ( ) destroi ( ) init ( ) start ( ) we should have same state fresh start wa done i . e read modifi web . xml , etc . thi can onli done complet remov context object remap new , clean up everyth . xxx should thi done stop ( ) void destroi ( ) throw except { ( onam = null ) { send j2ee . object . delet notif notif notif = new notif ( j2ee . object . delet , thi . get object name ( ) , sequenc number ) ; broadcast . send notif ( notif ) ; } super . destroi ( ) ; notifi our interest lifecycl listen lifecycl . fire lifecycl event ( destroi event , null ) ; instanc listen = new string 0 ; }	public remov specifi alia name from alias thi host . param alia alia name remov void remov alia ( string alia ) { alia = alia . lower case ( ) ; synchron ( alias ) { make sure thi alia current present int n = 1 ; ( int i = 0 ; i alias . length ; i ) { ( alias i . equal ( alia ) ) { n = i ; break ; } } ( n 0 ) return ; remov specifi alia int j = 0 ; string result = new string alias . length 1 ; ( int i = 0 ; i alias . length ; i ) { ( i = n ) result j = alias i ; } alias = result ; } inform interest listen fire contain event ( remov alia event , alia ) ; }	public remov specifi applic listen class from set listen thi applic . param listen java class name listen remov void remov applic listen ( string listen ) { synchron ( applic listen ) { make sure thi welcom file current present int n = 1 ; ( int i = 0 ; i applic listen . length ; i ) { ( applic listen i . equal ( listen ) ) { n = i ; break ; } } ( n 0 ) return ; remov specifi constraint int j = 0 ; string result = new string applic listen . length 1 ; ( int i = 0 ; i applic listen . length ; i ) { ( i = n ) result j = applic listen i ; } applic listen = result ; } inform interest listen fire contain event ( remov applic listen , listen ) ; fixm behavior alreadi start }	public remov applic paramet specifi name from set thi applic . param name name applic paramet remov void remov applic paramet ( string name ) { synchron ( applic paramet ) { make sure thi paramet current present int n = 1 ; ( int i = 0 ; i applic paramet . length ; i ) { ( name . equal ( applic paramet i . get name ( ) ) ) { n = i ; break ; } } ( n 0 ) return ; remov specifi paramet int j = 0 ; applic paramet result = new applic paramet applic paramet . length 1 ; ( int i = 0 ; i applic paramet . length ; i ) { ( i = n ) result j = applic paramet i ; } applic paramet = result ; } inform interest listen fire contain event ( remov applic paramet , name ) ; }	public remov specifi secur constraint from thi web applic . param constraint constraint remov void remov constraint ( secur constraint constraint ) { synchron ( constraint ) { make sure thi constraint current present int n = 1 ; ( int i = 0 ; i constraint . length ; i ) { ( constraint i . equal ( constraint ) ) { n = i ; break ; } } ( n 0 ) return ; remov specifi constraint int j = 0 ; secur constraint result = new secur constraint constraint . length 1 ; ( int i = 0 ; i constraint . length ; i ) { ( i = n ) result j = constraint i ; } constraint = result ; } inform interest listen fire contain event ( remov constraint , constraint ) ; }	public remov filter map from thi context . param filter map filter map remov void remov filter map ( filter map filter map ) { synchron ( filter map ) { make sure thi filter map current present int n = 1 ; ( int i = 0 ; i filter map . length ; i ) { ( filter map i = = filter map ) { n = i ; break ; } } ( n 0 ) return ; remov specifi filter map filter map result = new filter map filter map . length 1 ; system . arraycopi ( filter map , 0 , result , 0 , n ) ; system . arraycopi ( filter map , n 1 , result , n , ( filter map . length 1 ) n ) ; ( n filter map insert point ) { filter map insert point ; } filter map = result ; } inform interest listen fire contain event ( remov filter map , filter map ) ; }	public remov lifecycl event listen from thi compon . param listen listen remov void remov instanc listen ( instanc listen listen ) { synchron ( listen ) { int n = 1 ; ( int i = 0 ; i listen . length ; i ) { ( listen i = = listen ) { n = i ; break ; } } ( n 0 ) return ; instanc listen result = new instanc listen listen . length 1 ; int j = 0 ; ( int i = 0 ; i listen . length ; i ) { ( i = n ) result j = listen i ; } listen = result ; } }	public remov class name from set instanc listen class ad newli creat wrapper . param listen class name instanc listen class remov void remov instanc listen ( string listen ) { synchron ( instanc listen ) { make sure thi welcom file current present int n = 1 ; ( int i = 0 ; i instanc listen . length ; i ) { ( instanc listen i . equal ( listen ) ) { n = i ; break ; } } ( n 0 ) return ; remov specifi constraint int j = 0 ; string result = new string instanc listen . length 1 ; ( int i = 0 ; i instanc listen . length ; i ) { ( i = n ) result j = instanc listen i ; } instanc listen = result ; } inform interest listen fire contain event ( remov instanc listen , listen ) ; }	public remov lifecycl event listen from thi compon . param listen listen remov void remov lifecycl listen ( lifecycl listen listen ) { synchron ( listen ) { int n = 1 ; ( int i = 0 ; i listen . length ; i ) { ( listen i = = listen ) { n = i ; break ; } } ( n 0 ) return ; lifecycl listen result = new lifecycl listen listen . length 1 ; int j = 0 ; ( int i = 0 ; i listen . length ; i ) { ( i = n ) result j = listen i ; } listen = result ; } }	public synchron member impl expir ( long maxtim ) { ( ha member ( ) ) return empti member ; arrai list member impl list = null ; iter mbr entri i = map . valu ( ) . iter ( ) ; while ( i . ha next ( ) ) { mbr entri entri = i . next ( ) ; ( entri . ha expir ( maxtim ) ) { ( onli need list when member ar expir ( smaller gc ) list = = null ) list = new java . util . arrai list member impl ( ) ; list . add ( entri . get member ( ) ) ; } } ( list = null ) { member impl result = new member impl list . size ( ) ; list . arrai ( result ) ; ( int j = 0 ; j result . length ; j ) { remov member ( result j ) ; } return result ; } els { return empti member ; } }	public remov ani secur role specifi name . param role secur role remov void remov secur role ( string role ) { synchron ( secur role ) { make sure thi secur role current present int n = 1 ; ( int i = 0 ; i secur role . length ; i ) { ( role . equal ( secur role i ) ) { n = i ; break ; } } ( n 0 ) return ; remov specifi secur role int j = 0 ; string result = new string secur role . length 1 ; ( int i = 0 ; i secur role . length ; i ) { ( i = n ) result j = secur role i ; } secur role = result ; } inform interest listen fire contain event ( remov secur role , role ) ; }	public remov ani servlet map specifi pattern , exist ; otherwis , action taken . param pattern url pattern map remov void remov servlet map ( string pattern ) { string name = null ; synchron ( servlet map ) { name = servlet map . remov ( pattern ) ; } wrapper wrapper = ( wrapper ) find child ( name ) ; ( wrapper = null ) { wrapper . remov map ( pattern ) ; } mapper . remov wrapper ( pattern ) ; fire contain event ( remov servlet map , pattern ) ; }	public remov specifi watch resourc name from list associ thi context . param name name watch resourc remov void remov watch resourc ( string name ) { synchron ( watch resourc ) { make sure thi watch resourc current present int n = 1 ; ( int i = 0 ; i watch resourc . length ; i ) { ( watch resourc i . equal ( name ) ) { n = i ; break ; } } ( n 0 ) return ; remov specifi watch resourc int j = 0 ; string result = new string watch resourc . length 1 ; ( int i = 0 ; i watch resourc . length ; i ) { ( i = n ) result j = watch resourc i ; } watch resourc = result ; } fire contain event ( remov watch resourc , name ) ; }	public remov specifi welcom file name from list recogn thi context . param name name welcom file remov void remov welcom file ( string name ) { synchron ( welcom file ) { make sure thi welcom file current present int n = 1 ; ( int i = 0 ; i welcom file . length ; i ) { ( welcom file i . equal ( name ) ) { n = i ; break ; } } ( n 0 ) return ; remov specifi constraint int j = 0 ; string result = new string welcom file . length 1 ; ( int i = 0 ; i welcom file . length ; i ) { ( i = n ) result j = welcom file i ; } welcom file = result ; } inform interest listen post welcom file ( ) ; fire contain event ( remov welcom file , name ) ; }	public remov class name from set lifecycl listen class ad newli creat wrapper . param listen class name lifecycl listen class remov void remov wrapper lifecycl ( string listen ) { synchron ( wrapper lifecycl ) { make sure thi welcom file current present int n = 1 ; ( int i = 0 ; i wrapper lifecycl . length ; i ) { ( wrapper lifecycl i . equal ( listen ) ) { n = i ; break ; } } ( n 0 ) return ; remov specifi constraint int j = 0 ; string result = new string wrapper lifecycl . length 1 ; ( int i = 0 ; i wrapper lifecycl . length ; i ) { ( i = n ) result j = wrapper lifecycl i ; } wrapper lifecycl = result ; } inform interest listen fire contain event ( remov wrapper lifecycl , listen ) ; }	public remov class name from set contain listen class ad newli creat wrapper . param listen class name contain listen class remov void remov wrapper listen ( string listen ) { synchron ( wrapper listen ) { make sure thi welcom file current present int n = 1 ; ( int i = 0 ; i wrapper listen . length ; i ) { ( wrapper listen i . equal ( listen ) ) { n = i ; break ; } } ( n 0 ) return ; remov specifi constraint int j = 0 ; string result = new string wrapper listen . length 1 ; ( int i = 0 ; i wrapper listen . length ; i ) { ( i = n ) result j = wrapper listen i ; } wrapper listen = result ; } inform interest listen fire contain event ( remov wrapper listen , listen ) ; }

protect tree node convert ( tree node parent , node node ) { construct new tree node thi node tree node tree node = new tree node ( node . get node name ( ) , parent ) ; convert all attribut thi node name node map attribut = node . get attribut ( ) ; ( attribut = null ) { int n = attribut . get length ( ) ; ( int i = 0 ; i n ; i ) { node attribut = attribut . item ( i ) ; tree node . add attribut ( attribut . get node name ( ) , attribut . get node valu ( ) ) ; } } creat attach all children thi node node list children = node . get child node ( ) ; ( children = null ) { int n = children . get length ( ) ; ( int i = 0 ; i n ; i ) { node child = children . item ( i ) ; ( child instanceof comment ) continu ; ( child instanceof text ) { string bodi = ( ( text ) child ) . get data ( ) ; ( bodi = null ) { bodi = bodi . trim ( ) ; ( bodi . length ( ) 0 ) tree node . set bodi ( bodi ) ; } } els { convert ( tree node , child ) ; } } } return complet tree node graph return ( tree node ) ; }
public data input stream run ( ) { try { file f = new file ( dev random sourc ) ; ( f . exist ( ) ) return null ; random = new data input stream ( new file input stream ( f ) ) ; random . read long ( ) ; ( log . debug enabl ( ) ) log . debug ( open dev random sourc ) ; return random ; } catch ( ioexcept ex ) { return null ; } }	public us dev random type special devic . thi new code , mai reduc big delai gener random . you must specifi path random gener file . us dev urandom linux ( similar ) system . us dev random maximum secur ( mai block enough random exist ) . you can also us pipe gener random . code check file exist , default java random found . signific perform differ , veri visibl first call get session ( like first jsp ) so us avail . void set random file ( string s ) { session id ( good strang debug ) ( global . secur enabl ) { random = access control . do privileg ( new privileg set random file ( ) ) ; } els { try { dev random sourc = s ; file f = new file ( dev random sourc ) ; ( f . exist ( ) ) return ; random = new data input stream ( new file input stream ( f ) ) ; random . read long ( ) ; ( log . debug enabl ( ) ) log . debug ( open dev random sourc ) ; } catch ( ioexcept ex ) { try { random . close ( ) ; } catch ( except e ) { log . warn ( fail close random . ) ; } random = null ; } } }

public get string from underli resourc bundl return null string found . param kei desir resourc string return resourc string match i kei i from underli bundl null found . throw illeg argument except i kei i null . string get string ( string kei ) { ( kei = = null ) { string msg = kei mai have null valu ; throw new illeg argument except ( msg ) ; } string str = null ; try { str = bundl . get string ( kei ) ; } catch ( miss resourc except mre ) { bad : shouldn t mask except follow wai : str = cannot find messag associ kei kei due mre ; becaus hide fact string wa miss from call code . good : could just throw except ( wrap anoth ) would probabl caus much havoc exist code . better : consist contain pattern simpli return null . call code can do null check . str = null ; } return str ; }	public get string from underli resourc bundl format given object argument . thi argument can cours string object . param kei param arg string get string ( string kei , object arg ) { object arg = new object { arg } ; return get string ( kei , arg ) ; }	public get string from underli resourc bundl format given set argument . param kei param arg string get string ( string kei , object arg ) { string i string = null ; string valu = get string ( kei ) ; object barf out try { ensur argument ar null so pre 1 . 2 vm s don t barf ( arg = = null ) { arg = new object 1 ; } object non null arg = arg ; ( int i = 0 ; i arg . length ; i ) { ( arg i = = null ) { ( non null arg = = arg ) { non null arg = arg . clone ( ) ; } non null arg i = null ; } } ( valu = = null ) valu = kei ; messag format mf = new messag format ( valu ) ; mf . set local ( local ) ; i string = mf . format ( non null arg , new string buffer ( ) , null ) . string ( ) ; } catch ( illeg argument except iae ) { string buffer buf = new string buffer ( ) ; buf . append ( valu ) ; ( int i = 0 ; i arg . length ; i ) { buf . append ( arg i = arg i ) ; } i string = buf . string ( ) ; } return i string ; }
public prepar begin activ us public method thi compon . thi method should call after code configur ( ) code , befor ani public method compon ar util . except lifecycl except thi compon detect fatal error prevent thi compon from us void start ( ) throw lifecycl except { valid updat our current compon state ( start ) throw new lifecycl except ( sm . get string ( access log valv . alreadi start ) ) ; lifecycl . fire lifecycl event ( start event , null ) ; start = true ; initi time zone , date formatt , current date timezon = time zone . get default ( ) ; time zone dst = calcul time zone offset ( timezon . get raw offset ( ) ) ; calendar calendar = calendar . get instanc ( timezon ) ; int offset = calendar . get ( calendar . dst offset ) ; time zone dst = calcul time zone offset ( timezon . get raw offset ( ) offset ) ; ( file date format = = null file date format . length ( ) = = 0 ) file date format = yyyi mm dd ; file date formatt = new simpl date format ( file date format ) ; file date formatt . set time zone ( timezon ) ; dai formatt = new simpl date format ( dd ) ; dai formatt . set time zone ( timezon ) ; month formatt = new simpl date format ( mm ) ; month formatt . set time zone ( timezon ) ; year formatt = new simpl date format ( yyyi ) ; year formatt . set time zone ( timezon ) ; time formatt = new simpl date format ( hh : mm : ss ) ; time formatt . set time zone ( timezon ) ; current date = new date ( ) ; date stamp = file date formatt . format ( current date ) ; open ( ) ; }
public compil jsp file from current engin context . side effect , tag file ar referenc thi page ar also compil . param compil class true , gener both . java . class file fals , gener onli . java file param jspc mode true invok from jsp c , fals otherwis void compil ( boolean compil class , boolean jspc mode ) throw file found except , jasper except , except { ( err dispatch = = null ) { thi . err dispatch = new error dispatch ( jspc mode ) ; } try { string smap = gener java ( ) ; ( compil class ) { gener class ( smap ) ; } } final { ( tfp = null ctxt . prototyp mode ( ) ) { tfp . remov proto type file ( null ) ; } make sure object which ar onli us dure gener compil jsp page get dereferenc so thei can gc d reduc memori footprint . tfp = null ; err dispatch = null ; page info = null ; http : issu . apach . org bugzilla show bug . cgi id = 37062 ( thi . option . get develop ( ) ) { page node = null ; } ( ctxt . get writer ( ) = null ) { ctxt . get writer ( ) . close ( ) ; ctxt . set writer ( null ) ; } } }
public return error page entri specifi http error code , ani ; otherwis return code null code . param error code error code look up error page find error page ( int error code ) { ( error code = = 200 ) { return ( ok error page ) ; } els { return ( statu page . get ( new integ ( error code ) ) ) ; } }	public int find statu page ( ) { synchron ( statu page ) { int result = new int statu page . size ( ) ; iter integ element = statu page . kei set ( ) . iter ( ) ; int i = 0 ; while ( element . ha next ( ) ) result i = element . next ( ) . int valu ( ) ; return ( result ) ; } }	public add error page specifi error java except . param error page error page definit ad void add error page ( error page error page ) { valid input paramet ( error page = = null ) throw new illeg argument except ( sm . get string ( standard context . error page . requir ) ) ; string locat = error page . get locat ( ) ; ( ( locat = null ) locat . start ( ) ) { ( servlet22 ( ) ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( standard context . error page . warn , locat ) ) ; error page . set locat ( locat ) ; } els { throw new illeg argument except ( sm . get string ( standard context . error page . error , locat ) ) ; } } add specifi error page our intern collect string except type = error page . get except type ( ) ; ( except type = null ) { synchron ( except page ) { except page . put ( except type , error page ) ; } } els { synchron ( statu page ) { ( error page . get error code ( ) = = 200 ) { thi . ok error page = error page ; } statu page . put ( new integ ( error page . get error code ( ) ) , error page ) ; } } fire contain event ( add error page , error page ) ; }	public load initi all servlet mark load startup web applic deploy descriptor . param children arrai wrapper all current defin servlet ( includ those declar load startup ) void load startup ( contain children ) { collect load startup servlet need initi tree map integ , arrai list wrapper >> map = new tree map integ , arrai list wrapper >> ( ) ; ( int i = 0 ; i children . length ; i ) { wrapper wrapper = ( wrapper ) children i ; int load startup = wrapper . get load startup ( ) ; ( load startup 0 ) continu ; integ kei = new integ ( load startup ) ; arrai list wrapper list = map . get ( kei ) ; ( list = = null ) { list = new arrai list wrapper ( ) ; map . put ( kei , list ) ; } list . add ( wrapper ) ; } load collect load startup servlet iter integ kei = map . kei set ( ) . iter ( ) ; while ( kei . ha next ( ) ) { integ kei = kei . next ( ) ; arrai list wrapper list = map . get ( kei ) ; iter wrapper wrapper = list . iter ( ) ; while ( wrapper . ha next ( ) ) { wrapper wrapper = wrapper . next ( ) ; try { wrapper . load ( ) ; } catch ( servlet except e ) { get logger ( ) . error ( sm . get string ( standard wrapper . load except , get name ( ) ) , standard wrapper . get root caus ( e ) ) ; note : load error ( includ servlet throw unavail except from tht init ( ) method ) ar fatal applic startup } } } }	public remov error page specifi error code java languag except , exist ; otherwis , action taken . param error page error page definit remov void remov error page ( error page error page ) { string except type = error page . get except type ( ) ; ( except type = null ) { synchron ( except page ) { except page . remov ( except type ) ; } } els { synchron ( statu page ) { ( error page . get error code ( ) = = 200 ) { thi . ok error page = null ; } statu page . remov ( new integ ( error page . get error code ( ) ) ) ; } } fire contain event ( remov error page , error page ) ; }	public set anti jarlock featur thi context . param anti jarlock new flag valu void set anti jarlock ( boolean anti jarlock ) { boolean old anti jarlock = thi . anti jarlock ; thi . anti jarlock = anti jarlock ; support . fire properti chang ( anti jarlock , new boolean ( old anti jarlock ) , new boolean ( thi . anti jarlock ) ) ; }	public set anti resourc lock featur thi context . param anti resourc lock new flag valu void set anti resourc lock ( boolean anti resourc lock ) { boolean old anti resourc lock = thi . anti resourc lock ; thi . anti resourc lock = anti resourc lock ; support . fire properti chang ( anti resourc lock , new boolean ( old anti resourc lock ) , new boolean ( thi . anti resourc lock ) ) ; }	public set applic avail flag thi context . param avail new applic avail flag void set avail ( boolean avail ) { boolean old avail = thi . avail ; thi . avail = avail ; support . fire properti chang ( avail , new boolean ( old avail ) , new boolean ( thi . avail ) ) ; }	public set correctli configur flag thi context . thi can set fals startup listen detect fatal configur error avoid applic from made avail . param configur new correctli configur flag void set configur ( boolean configur ) { boolean old configur = thi . configur ; thi . configur = configur ; support . fire properti chang ( configur , new boolean ( old configur ) , new boolean ( thi . configur ) ) ; }	public set us cooki session id flag . param cooki new flag void set cooki ( boolean cooki ) { boolean old cooki = thi . cooki ; thi . cooki = cooki ; support . fire properti chang ( cooki , new boolean ( old cooki ) , new boolean ( thi . cooki ) ) ; }	public set allow cross servlet context flag . param cross context new cross context flag void set cross context ( boolean cross context ) { boolean old cross context = thi . cross context ; thi . cross context = cross context ; support . fire properti chang ( cross context , new boolean ( old cross context ) , new boolean ( thi . cross context ) ) ; }	public set follow standard deleg model flag us configur our class loader . param deleg new flag void set deleg ( boolean deleg ) { boolean old deleg = thi . deleg ; thi . deleg = deleg ; support . fire properti chang ( deleg , new boolean ( old deleg ) , new boolean ( thi . deleg ) ) ; }	public set distribut flag thi web applic . param distribut new distribut flag void set distribut ( boolean distribut ) { boolean old distribut = thi . distribut ; thi . distribut = distribut ; support . fire properti chang ( distribut , new boolean ( old distribut ) , new boolean ( thi . distribut ) ) ; bugzilla 32866 ( get manag ( ) = null ) { ( log . debug enabl ( ) ) { log . debug ( propag distribut = distribut manag ) ; } get manag ( ) . set distribut ( distribut ) ; } }	public set boolean annot pars thi web applic . param ignor annot boolean annot pars void set ignor annot ( boolean ignor annot ) { boolean old ignor annot = thi . ignor annot ; thi . ignor annot = ignor annot ; support . fire properti chang ( ignor annot , boolean . valu ( old ignor annot ) , boolean . valu ( thi . ignor annot ) ) ; }	public set default context overrid flag thi web applic . param overrid new overrid flag void set overrid ( boolean overrid ) { boolean old overrid = thi . overrid ; thi . overrid = overrid ; support . fire properti chang ( overrid , new boolean ( old overrid ) , new boolean ( thi . overrid ) ) ; }	public set privileg flag thi web applic . param privileg new privileg flag void set privileg ( boolean privileg ) { boolean old privileg = thi . privileg ; thi . privileg = privileg ; support . fire properti chang ( privileg , new boolean ( old privileg ) , new boolean ( thi . privileg ) ) ; }	public set reload flag thi web applic . param reload new reload flag void set reload ( boolean reload ) { boolean old reload = thi . reload ; thi . reload = reload ; support . fire properti chang ( reload , new boolean ( old reload ) , new boolean ( thi . reload ) ) ; }	public set replac welcom file properti . param replac welcom file new properti valu void set replac welcom file ( boolean replac welcom file ) { boolean old replac welcom file = thi . replac welcom file ; thi . replac welcom file = replac welcom file ; support . fire properti chang ( replac welcom file , new boolean ( old replac welcom file ) , new boolean ( thi . replac welcom file ) ) ; }	public set default session timeout ( minut ) thi web applic . param timeout new default session timeout void set session timeout ( int timeout ) { int old session timeout = thi . session timeout ; srv . 13 . 4 ( deploy descriptor ) : timeout 0 less , contain ensur default behaviour session never time out . thi . session timeout = ( timeout = = 0 ) 1 : timeout ; support . fire properti chang ( session timeout , new integ ( old session timeout ) , new integ ( thi . session timeout ) ) ; }	public set valu swallow output flag . set true , system . out system . err redirect logger dure servlet execut . param swallow output new valu void set swallow output ( boolean swallow output ) { boolean old swallow output = thi . swallow output ; thi . swallow output = swallow output ; support . fire properti chang ( swallow output , new boolean ( old swallow output ) , new boolean ( thi . swallow output ) ) ; }	public set valu unload delai flag , which repres amount ms contain wait when unload servlet . set thi small valu mai caus more request fail complet when stop web applic . param unload delai new valu void set unload delai ( long unload delai ) { long old unload delai = thi . unload delai ; thi . unload delai = unload delai ; support . fire properti chang ( unload delai , new long ( old unload delai ) , new long ( thi . unload delai ) ) ; }	public set us http onli cooki session cooki flag . param us http onli set code true code us http onli cooki session cooki void set us http onli ( boolean us http onli ) { boolean old us http onli = thi . us http onli ; thi . us http onli = us http onli ; support . fire properti chang ( us http onli , new boolean ( old us http onli ) , new boolean ( thi . us http onli ) ) ; }
protect void tear down ( ) throw except { ( int i = 0 ; i channel . length ; i ) { channel i . stop ( channel . default ) ; } }	public static void print arrai ( byte data ) { system . out . print ( { ) ; ( int i = 0 ; i data . length ; i ) { system . out . print ( data i ) ; system . out . print ( , ) ; } system . out . println ( } size : data . length ) ; }	public wait until proper shutdown command receiv , return . thi keep main thread aliv thread pool listen http connect daemon thread . void await ( ) { neg valu don t wait port tomcat embed we just don t like port ( port = = 2 ) { undocu yet embed app ar around , aliv . return ; } ( port = = 1 ) { while ( true ) { try { thread . sleep ( 10000 ) ; } catch ( interrupt except ex ) { } ( stop await ) return ; } } set up server socket wait server socket server socket = null ; try { server socket = new server socket ( port , 1 , inet address . get name ( address ) ) ; } catch ( ioexcept e ) { log . error ( standard server . await : creat address : port : , e ) ; system . exit ( 1 ) ; } loop wait connect valid command while ( true ) { wait next connect socket socket = null ; input stream stream = null ; try { socket = server socket . accept ( ) ; ten second socket . set so timeout ( 10 1000 ) ; stream = socket . get input stream ( ) ; } catch ( access control except ac ) { log . warn ( standard server . accept secur except : ac . get messag ( ) , ac ) ; continu ; } catch ( ioexcept e ) { log . error ( standard server . await : accept : , e ) ; system . exit ( 1 ) ; } read set charact from socket string buffer command = new string buffer ( ) ; cut off avoid do s attack int expect = 1024 ; while ( expect shutdown . length ( ) ) { ( random = = null ) random = new random ( system . current time milli ( ) ) ; expect = ( random . next int ( ) 1024 ) ; } while ( expect 0 ) { int ch = 1 ; try { ch = stream . read ( ) ; } catch ( ioexcept e ) { log . warn ( standard server . await : read : , e ) ; ch = 1 ; } ( control charact eof termin loop ch 32 ) break ; command . append ( ( char ) ch ) ; expect ; } close socket now we ar done try { socket . close ( ) ; } catch ( ioexcept e ) { ignor } match against our command string boolean match = command . string ( ) . equal ( shutdown ) ; ( match ) { break ; } els log . warn ( standard server . await : invalid command command . string ( ) receiv ) ; } close server socket return try { server socket . close ( ) ; } catch ( ioexcept e ) { ignor } }	public void messag receiv ( serializ s , member m ) { data d = ( data ) s ; ( data . verifi ( d ) ) { system . err . println ( error ) ; } els { count ; ( ( count 1000 ) = = 0 ) { system . err . println ( success : count ) ; } } }	public void messag receiv ( serializ s , member m ) { try { data d = ( data ) s ; ( data . verifi ( d ) ) { system . err . println ( error unabl verifi data packag ) ; } els { long c = count . add get ( 1 ) ; ( ( c 1000 ) = = 0 ) { system . err . println ( success : c ) ; } int nr = d . get number ( ) ; ( nr = 0 nr nr . length ) { max idx = math . max ( max idx , nr ) ; nr nr = 1 ; } } } catch ( except x ) { x . print stack trace ( ) ; } }	public void messag receiv ( serializ s , member m ) { try { data d = ( data ) s ; ( data . verifi ( d ) ) { system . err . println ( error unabl verifi data packag ) ; } els { long c = count . add get ( 1 ) ; ( ( c 1000 ) = = 0 ) { system . err . println ( success : c ) ; } int nr = d . get number ( ) ; ( nr = 0 nr nr . length ) { max idx = math . max ( max idx , nr ) ; nr nr = 1 ; } } } catch ( except x ) { x . print stack trace ( ) ; } }	public void print stat ( print stream stream ) { stream . println ( normal : err cnt ) ; stream . println ( failur : err cnt ) ; stream . println ( total : ( err cnt err cnt ) ) ; }	public void run ( ) { system . out . println ( shut down . . . ) ; creat exit thread forc shutdown jvm wont exit cleanli system exit exit = new system exit ( 5000 ) ; exit . set daemon ( true ) ; exit . start ( ) ; try { stop channel channel . stop ( channel . default ) ; } catch ( except x ) { x . print stack trace ( ) ; } system . out . println ( channel stop . ) ; }
public us event updat connect state . param request servlet request process param respons servlet respons creat except ioexcept input output error occur except servlet except servlet error occur void event ( request request , respons respons , comet event event ) throw ioexcept , servlet except { perform request boolean ok = fals ; try { get next ( ) . event ( request , respons , event ) ; ok = true ; } final { ( ok respons . close ( ) ( event . get event type ( ) = = comet event . event type . end ) ( event . get event type ( ) = = comet event . event type . error ( event . get event sub type ( ) = = comet event . event sub type . timeout ) ) ) { remov connect from webapp reload track comet request . remov ( request ) ; remov connect from session expir track note : can t get session ha been invalid ok sinc session listen have done clean up http session session = request . get session ( fals ) ; ( session = null ) { synchron ( session ) { request req = ( request ) session . get attribut ( comet request attribut ) ; ( req = null ) { boolean found = fals ; ( int i = 0 ; found ( i req . length ) ; i ) { found = ( req i = = request ) ; } ( found ) { ( req . length 1 ) { request new connect info = new request req . length 1 ; int po = 0 ; ( int i = 0 ; i req . length ; i ) { ( req i = request ) { new connect info po = req i ; } } session . set attribut ( comet request attribut , new connect info ) ; } els { session . remov attribut ( comet request attribut ) ; } } } } } } } }
process pipelin http request us specifi input output stream . param input stream from which http request read param output stream which us output http respons throw ioexcept error dure i o oper public void process ( socket socket ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set remot address remot addr = null ; remot host = null ; local addr = null ; local name = null ; remot port = 1 ; local port = 1 ; set up i o thi . socket = socket ; input buffer . set input stream ( socket . get input stream ( ) ) ; output buffer . set output stream ( socket . get output stream ( ) ) ; error flag error = fals ; keep aliv = true ; int keep aliv left = max keep aliv request ; int so timeout = socket . get so timeout ( ) ; int old so timeout = so timeout ; int thread ratio = ( endpoint . get current thread busi ( ) 100 ) endpoint . get max thread ( ) ; ( thread ratio 75 ) { keep aliv left = 1 ; } ( so timeout = old so timeout ) { try { socket . set so timeout ( so timeout ) ; } catch ( throwabl t ) { log . debug ( sm . get string ( http11processor . socket . timeout ) , t ) ; error = true ; } } boolean kept aliv = fals ; while ( start error keep aliv ) { pars request header try { ( disabl upload timeout kept aliv ) { ( keep aliv timeout 0 ) { socket . set so timeout ( keep aliv timeout ) ; } } } } }

protect process head request specifi resourc . param request servlet request we ar process param respons servlet respons we ar creat except ioexcept input output error occur except servlet except servlet specifi error occur void do head ( http servlet request request , http servlet respons respons ) throw ioexcept , servlet except { serv request resourc , without data content serv resourc ( request , respons , fals ) ; }	public async context start async ( servlet request servlet request , servlet respons servlet respons ) throw illeg state except { todo servlet3 return null ; }
protect adjust doc base . void fix doc base ( ) throw ioexcept { host host = ( host ) context . get parent ( ) ; string app base = host . get app base ( ) ; boolean unpack war = true ; ( host instanceof standard host ) { unpack war = ( ( standard host ) host ) . unpack war ( ) ( ( standard context ) context ) . get unpack war ( ) ; } file canon app base = new file ( app base ) ; ( canon app base . absolut ( ) ) { canon app base = canon app base . get canon file ( ) ; } els { canon app base = new file ( system . get properti ( catalina . base ) , app base ) . get canon file ( ) ; } string doc base = context . get doc base ( ) ; ( doc base = = null ) { try guess doc base accord path string path = context . get path ( ) ; ( path = = null ) { return ; } ( path . equal ( ) ) { doc base = root ; } els { ( path . start ( ) ) { doc base = path . substr ( 1 ) . replac ( , ) ; } els { doc base = path . replac ( , ) ; } } } file file = new file ( doc base ) ; ( file . absolut ( ) ) { doc base = ( new file ( canon app base , doc base ) ) . get path ( ) ; } els { doc base = file . get canon path ( ) ; } file = new file ( doc base ) ; string orig doc base = doc base ; string context path = context . get path ( ) ; ( context path . equal ( ) ) { context path = root ; } els { ( context path . last index ( ) 0 ) { context path = context path . substr ( 1 ) . replac ( , ) ; } } ( doc base . lower case ( ) . end ( . war ) file . directori ( ) unpack war ) { url war = new url ( jar : ( new file ( doc base ) ) . uri ( ) . url ( ) ) ; doc base = expand war . expand ( host , war , context path ) ; file = new file ( doc base ) ; doc base = file . get canon path ( ) ; ( context instanceof standard context ) { ( ( standard context ) context ) . set origin doc base ( orig doc base ) ; } } els { file doc dir = new file ( doc base ) ; ( doc dir . exist ( ) ) { file war file = new file ( doc base . war ) ; ( war file . exist ( ) ) { ( unpack war ) { url war = new url ( jar : war file . uri ( ) . url ( ) ) ; doc base = expand war . expand ( host , war , context path ) ; file = new file ( doc base ) ; doc base = file . get canon path ( ) ; } els { doc base = war file . get canon path ( ) ; } } ( context instanceof standard context ) { ( ( standard context ) context ) . set origin doc base ( orig doc base ) ; } } } ( doc base . start ( canon app base . get path ( ) ) ) { doc base = doc base . substr ( canon app base . get path ( ) . length ( ) ) ; doc base = doc base . replac ( file . separ char , ) ; ( doc base . start ( ) ) { doc base = doc base . substr ( 1 ) ; } } els { doc base = doc base . replac ( file . separ char , ) ; } context . set doc base ( doc base ) ; }
public authent user check exist certif chain , option ask trust manag valid we trust thi user . param request request we ar process param respons respons we ar creat param config login configur describ how authent should perform except ioexcept input output error occur boolean authent ( request request , respons respons , login config config ) throw ioexcept { have we alreadi authent someon princip princip = request . get user princip ( ) ; string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( princip = null ) { ( contain log . debug enabl ( ) ) contain log . debug ( alreadi authent princip . get name ( ) ) ; associ session ani exist sso session order get coordin session invalid logout string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( sso id = null ) associ ( sso id , request . get session intern ( true ) ) ; return ( true ) ; } retriev certif chain thi client ( contain log . debug enabl ( ) ) contain log . debug ( look up certif ) ; x509certif cert = ( x509certif ) request . get attribut ( global . certif attr ) ; ( ( cert = = null ) ( cert . length 1 ) ) { request . get coyot request ( ) . action ( action code . action req ssl certif , null ) ; cert = ( x509certif ) request . get attribut ( global . certif attr ) ; } ( ( cert = = null ) ( cert . length 1 ) ) { ( contain log . debug enabl ( ) ) contain log . debug ( certif includ thi request ) ; respons . send error ( http servlet respons . sc bad request , sm . get string ( authent . certif ) ) ; return ( fals ) ; } authent specifi certif chain princip = context . get realm ( ) . authent ( cert ) ; ( princip = = null ) { ( contain log . debug enabl ( ) ) contain log . debug ( realm . authent ( ) return fals ) ; respons . send error ( http servlet respons . sc unauthor , sm . get string ( authent . unauthor ) ) ; return ( fals ) ; } cach princip ( request ) record thi authent regist ( request , respons , princip , constant . cert method , null , null ) ; return ( true ) ; }
privat creat name tag handler pool whose tag handler mai ( re ) us servic thi action . return name tag handler pool string creat tag handler pool name ( string prefix , string short name , attribut attr , boolean ha empti bodi ) { string pool name = null ; pool name = jspx tag pool prefix short name ; ( attr = null ) { string attr name = new string attr . get length ( ) ; ( int i = 0 ; i attr name . length ; i ) { attr name i = attr . get qname ( i ) ; } arrai . sort ( attr name , collect . revers order ( ) ) ; ( attr name . length 0 ) { pool name = pool name ; } ( int i = 0 ; i attr name . length ; i ) { pool name = pool name attr name i ; } } ( ha empti bodi ) { pool name = pool name nobodi ; } return jsp util . make java identifi ( pool name ) ; }	privat gener xml prolog , which includ xml declar xml doctyp declar . void gener xml prolog ( node . node page ) { xml declar gener under follow condit : omit xml declar attribut jsp : output action set fals jsp document without jsp : root string omit xml decl = page info . get omit xml decl ( ) ; ( ( omit xml decl = null jsp util . boolean valu ( omit xml decl ) ) ( omit xml decl = = null page . get root ( ) . xml syntax ( ) page info . ha jsp root ( ) ctxt . tag file ( ) ) ) { string c type = page info . get content type ( ) ; string char set = c type . substr ( c type . index ( charset = ) 8 ) ; out . printil ( out . write ( xml version = 1 . 0 encod = char set n ) ; ) ; } output doctyp declar doctyp root element appear . doctyp public appear : doctyp name public doctyp public doctyp system els doctyp name system doctyp system string doctyp name = page info . get doctyp name ( ) ; ( doctyp name = null ) { string doctyp public = page info . get doctyp public ( ) ; string doctyp system = page info . get doctyp system ( ) ; out . printin ( out . write ( doctyp ) ; out . print ( doctyp name ) ; ( doctyp public = = null ) { out . print ( system ) ; } els { out . print ( public ) ; out . print ( doctyp public ) ; out . print ( ) ; } out . print ( doctyp system ) ; out . println ( n ) ; ) ; } }
protect lock method . void do lock ( http servlet request req , http servlet respons resp ) throw servlet except , ioexcept { ( read onli ) { resp . send error ( webdav statu . sc forbidden ) ; return ; } ( lock ( req ) ) { resp . send error ( webdav statu . sc lock ) ; return ; } lock info lock = new lock info ( ) ; pars lock request pars depth header string depth str = req . get header ( depth ) ; ( depth str = = null ) { lock . depth = infin ; } els { ( depth str . equal ( 0 ) ) { lock . depth = 0 ; } els { lock . depth = infin ; } } pars timeout header int lock durat = default timeout ; string lock durat str = req . get header ( timeout ) ; ( lock durat str = = null ) { lock durat = default timeout ; } els { int comma po = lock durat str . index ( , ) ; multipl timeout , just us first ( comma po = 1 ) { lock durat str = lock durat str . substr ( 0 , comma po ) ; } ( lock durat str . start ( second ) ) { lock durat = ( new integ ( lock durat str . substr ( 7 ) ) ) . int valu ( ) ; } els { ( lock durat str . equal ignor case ( infin ) ) { lock durat = max timeout ; } els { try { lock durat = ( new integ ( lock durat str ) ) . int valu ( ) ; } catch ( number format except e ) { lock durat = max timeout ; } } } ( lock durat = = 0 ) { lock durat = default timeout ; } ( lock durat max timeout ) { lock durat = max timeout ; } } lock . expir = system . current time milli ( ) ( lock durat 1000 ) ; int lock request type = lock creation ; node lock info node = null ; document builder document builder = get document builder ( ) ; try { document document = document builder . pars ( new input sourc ( req . get input stream ( ) ) ) ; get root element document element root element = document . get document element ( ) ; lock info node = root element ; } catch ( ioexcept e ) { lock request type = lock refresh ; } catch ( saxexcept e ) { lock request type = lock refresh ; } ( lock info node = null ) { read lock inform node list child list = lock info node . get child node ( ) ; string writer str writer = null ; domwrit dom writer = null ; node lock scope node = null ; node lock type node = null ; node lock owner node = null ; ( int i = 0 ; i child list . get length ( ) ; i ) { node current node = child list . item ( i ) ; switch ( current node . get node type ( ) ) { case node . text node : break ; case node . element node : string node name = current node . get node name ( ) ; ( node name . end ( lockscop ) ) { lock scope node = current node ; } ( node name . end ( locktyp ) ) { lock type node = current node ; } ( node name . end ( owner ) ) { lock owner node = current node ; } break ; } } ( lock scope node = null ) { child list = lock scope node . get child node ( ) ; ( int i = 0 ; i child list . get length ( ) ; i ) { node current node = child list . item ( i ) ; switch ( current node . get node type ( ) ) { case node . text node : break ; case node . element node : string temp scope = current node . get node name ( ) ; ( temp scope . index ( : ) = 1 ) { lock . scope = temp scope . substr ( temp scope . index ( : ) 1 ) ; } els { lock . scope = temp scope ; } break ; } } ( lock . scope = = null ) { bad request resp . set statu ( webdav statu . sc bad request ) ; } } els { bad request resp . set statu ( webdav statu . sc bad request ) ; } ( lock type node = null ) { child list = lock type node . get child node ( ) ; ( int i = 0 ; i child list . get length ( ) ; i ) { node current node = child list . item ( i ) ; switch ( current node . get node type ( ) ) { case node . text node : break ; case node . element node : string temp type = current node . get node name ( ) ; ( temp type . index ( : ) = 1 ) { lock . type = temp type . substr ( temp type . index ( : ) 1 ) ; } els { lock . type = temp type ; } break ; } } ( lock . type = = null ) { bad request resp . set statu ( webdav statu . sc bad request ) ; } } els { bad request resp . set statu ( webdav statu . sc bad request ) ; } ( lock owner node = null ) { child list = lock owner node . get child node ( ) ; ( int i = 0 ; i child list . get length ( ) ; i ) { node current node = child list . item ( i ) ; switch ( current node . get node type ( ) ) { case node . text node : lock . owner = current node . get node valu ( ) ; break ; case node . element node : str writer = new string writer ( ) ; dom writer = new domwrit ( str writer , true ) ; dom writer . set qualifi name ( fals ) ; dom writer . print ( current node ) ; lock . owner = str writer . string ( ) ; break ; } } ( lock . owner = = null ) { bad request resp . set statu ( webdav statu . sc bad request ) ; } } els { lock . owner = new string ( ) ; } } string path = get rel path ( req ) ; lock . path = path ; boolean exist = true ; object object = null ; try { object = resourc . lookup ( path ) ; } catch ( name except e ) { exist = fals ; } enumer lock info lock list = null ; ( lock request type = = lock creation ) { gener lock id string lock token str = req . get servlet path ( ) lock . type lock . scope req . get user princip ( ) lock . depth lock . owner lock . token lock . expir system . current time milli ( ) secret ; string lock token = md5encod . encod ( md5helper . digest ( lock token str . get byte ( ) ) ) ; ( ( exist ) ( object instanceof dir context ) ( lock . depth = = infin ) ) { lock collect ( all member resourc ) check child resourc thi collect alreadi lock vector string lock path = new vector string ( ) ; lock list = collect lock . element ( ) ; while ( lock list . ha more element ( ) ) { lock info current lock = lock list . next element ( ) ; ( current lock . ha expir ( ) ) { resourc lock . remov ( current lock . path ) ; continu ; } ( ( current lock . path . start ( lock . path ) ) ( ( current lock . exclus ( ) ) ( lock . exclus ( ) ) ) ) { child collect thi collect lock lock path . add element ( current lock . path ) ; } } lock list = resourc lock . element ( ) ; while ( lock list . ha more element ( ) ) { lock info current lock = lock list . next element ( ) ; ( current lock . ha expir ( ) ) { resourc lock . remov ( current lock . path ) ; continu ; } ( ( current lock . path . start ( lock . path ) ) ( ( current lock . exclus ( ) ) ( lock . exclus ( ) ) ) ) { child resourc thi collect lock lock path . add element ( current lock . path ) ; } } ( lock path . empti ( ) ) { child path wa lock we gener multistatu error report enumer string lock path list = lock path . element ( ) ; resp . set statu ( webdav statu . sc conflict ) ; xmlwriter gener xml = new xmlwriter ( ) ; gener xml . write xmlheader ( ) ; gener xml . write element ( null , multistatu gener namespac declar ( ) , xmlwriter . open ) ; while ( lock path list . ha more element ( ) ) { gener xml . write element ( null , respons , xmlwriter . open ) ; gener xml . write element ( null , href , xmlwriter . open ) ; gener xml . write text ( lock path list . next element ( ) ) ; gener xml . write element ( null , href , xmlwriter . close ) ; gener xml . write element ( null , statu , xmlwriter . open ) ; gener xml . write text ( http 1 . 1 webdav statu . sc lock webdav statu . get statu text ( webdav statu . sc lock ) ) ; gener xml . write element ( null , statu , xmlwriter . close ) ; gener xml . write element ( null , respons , xmlwriter . close ) ; } gener xml . write element ( null , multistatu , xmlwriter . close ) ; writer writer = resp . get writer ( ) ; writer . write ( gener xml . string ( ) ) ; writer . close ( ) ; return ; } boolean add lock = true ; check alreadi share lock thi path lock list = collect lock . element ( ) ; while ( lock list . ha more element ( ) ) { lock info current lock = lock list . next element ( ) ; ( current lock . path . equal ( lock . path ) ) { ( current lock . exclus ( ) ) { resp . send error ( webdav statu . sc lock ) ; return ; } els { ( lock . exclus ( ) ) { resp . send error ( webdav statu . sc lock ) ; return ; } } current lock . token . add element ( lock token ) ; lock = current lock ; add lock = fals ; } } ( add lock ) { lock . token . add element ( lock token ) ; collect lock . add element ( lock ) ; } } els { lock singl resourc retriev alreadi exist lock resourc lock info present lock = resourc lock . get ( lock . path ) ; ( present lock = null ) { ( ( present lock . exclus ( ) ) ( lock . exclus ( ) ) ) { either lock exclus , lock can t grant resp . send error ( webdav statu . sc precondit fail ) ; return ; } els { present lock . token . add element ( lock token ) ; lock = present lock ; } } els { lock . token . add element ( lock token ) ; resourc lock . put ( lock . path , lock ) ; check resourc exist thi path exist = true ; try { object = resourc . lookup ( path ) ; } catch ( name except e ) { exist = fals ; } ( exist ) { creat lock null resourc int slash = lock . path . last index ( ) ; string parent path = lock . path . substr ( 0 , slash ) ; vector string lock null = lock null resourc . get ( parent path ) ; ( lock null = = null ) { lock null = new vector string ( ) ; lock null resourc . put ( parent path , lock null ) ; } lock null . add element ( lock . path ) ; } add lock token header rfc 2518 8 . 10 . 1 onli do thi newli creat lock resp . add header ( lock token , opaquelocktoken : lock token ) ; } } } ( lock request type = = lock refresh ) { string header = req . get header ( ) ; ( header = = null ) header = ; check resourc lock lock info renew = resourc lock . get ( path ) ; enumer string token list = null ; ( lock = null ) { least token lock must have been given token list = renew . token . element ( ) ; while ( token list . ha more element ( ) ) { string token = token list . next element ( ) ; ( header . index ( token ) = 1 ) { renew . expir = lock . expir ; lock = renew ; } } } check inherit collect lock enumer lock info collect lock list = collect lock . element ( ) ; while ( collect lock list . ha more element ( ) ) { renew = collect lock list . next element ( ) ; ( path . equal ( renew . path ) ) { token list = renew . token . element ( ) ; while ( token list . ha more element ( ) ) { string token = token list . next element ( ) ; ( header . index ( token ) = 1 ) { renew . expir = lock . expir ; lock = renew ; } } } } } set statu , gener xml respons contain lock inform xmlwriter gener xml = new xmlwriter ( ) ; gener xml . write xmlheader ( ) ; gener xml . write element ( null , prop gener namespac declar ( ) , xmlwriter . open ) ; gener xml . write element ( null , lockdiscoveri , xmlwriter . open ) ; lock . xml ( gener xml ) ; gener xml . write element ( null , lockdiscoveri , xmlwriter . close ) ; gener xml . write element ( null , prop , xmlwriter . close ) ; resp . set statu ( webdav statu . sc ok ) ; resp . set content type ( text xml ; charset = utf 8 ) ; writer writer = resp . get writer ( ) ; writer . write ( gener xml . string ( ) ) ; writer . close ( ) ; }	protect propfind method . void do propfind ( http servlet request req , http servlet respons resp ) throw servlet except , ioexcept { ( list ) { get allow method string buffer method allow = determin method allow ( resourc , req ) ; resp . add header ( allow , method allow . string ( ) ) ; resp . send error ( webdav statu . sc method allow ) ; return ; } string path = get rel path ( req ) ; ( path . end ( ) ) path = path . substr ( 0 , path . length ( ) 1 ) ; ( ( path . upper case ( ) . start ( web inf ) ) ( path . upper case ( ) . start ( meta inf ) ) ) { resp . send error ( webdav statu . sc forbidden ) ; return ; } properti which ar displai . vector string properti = null ; propfind depth int depth = infin ; propfind type int type = find all prop ; string depth str = req . get header ( depth ) ; ( depth str = = null ) { depth = infin ; } els { ( depth str . equal ( 0 ) ) { depth = 0 ; } els ( depth str . equal ( 1 ) ) { depth = 1 ; } els ( depth str . equal ( infin ) ) { depth = infin ; } } node prop node = null ; ( req . get input stream ( ) . avail ( ) 0 ) { document builder document builder = get document builder ( ) ; try { document document = document builder . pars ( new input sourc ( req . get input stream ( ) ) ) ; get root element document element root element = document . get document element ( ) ; node list child list = root element . get child node ( ) ; ( int i = 0 ; i child list . get length ( ) ; i ) { node current node = child list . item ( i ) ; switch ( current node . get node type ( ) ) { case node . text node : break ; case node . element node : ( current node . get node name ( ) . end ( prop ) ) { type = find properti ; prop node = current node ; } ( current node . get node name ( ) . end ( propnam ) ) { type = find properti name ; } ( current node . get node name ( ) . end ( allprop ) ) { type = find all prop ; } break ; } } } catch ( saxexcept e ) { someth went wrong us default . } catch ( ioexcept e ) { someth went wrong us default . } } ( type = = find properti ) { properti = new vector string ( ) ; node list child list = prop node . get child node ( ) ; ( int i = 0 ; i child list . get length ( ) ; i ) { node current node = child list . item ( i ) ; switch ( current node . get node type ( ) ) { case node . text node : break ; case node . element node : string node name = current node . get node name ( ) ; string properti name = null ; ( node name . index ( : ) = 1 ) { properti name = node name . substr ( node name . index ( : ) 1 ) ; } els { properti name = node name ; } href live properti which handl differ properti . add element ( properti name ) ; break ; } } } boolean exist = true ; object object = null ; try { object = resourc . lookup ( path ) ; } catch ( name except e ) { exist = fals ; int slash = path . last index ( ) ; ( slash = 1 ) { string parent path = path . substr ( 0 , slash ) ; vector string current lock null resourc = lock null resourc . get ( parent path ) ; ( current lock null resourc = null ) { enumer string lock null resourc list = current lock null resourc . element ( ) ; while ( lock null resourc list . ha more element ( ) ) { string lock null path = lock null resourc list . next element ( ) ; ( lock null path . equal ( path ) ) { resp . set statu ( webdav statu . sc multi statu ) ; resp . set content type ( text xml ; charset = utf 8 ) ; creat multistatu object xmlwriter gener xml = new xmlwriter ( resp . get writer ( ) ) ; gener xml . write xmlheader ( ) ; gener xml . write element ( null , multistatu gener namespac declar ( ) , xmlwriter . open ) ; pars lock null properti ( req , gener xml , lock null path , type , properti ) ; gener xml . write element ( null , multistatu , xmlwriter . close ) ; gener xml . send data ( ) ; return ; } } } } } ( exist ) { resp . send error ( http servlet respons . sc found , path ) ; return ; } resp . set statu ( webdav statu . sc multi statu ) ; resp . set content type ( text xml ; charset = utf 8 ) ; creat multistatu object xmlwriter gener xml = new xmlwriter ( resp . get writer ( ) ) ; gener xml . write xmlheader ( ) ; gener xml . write element ( null , multistatu gener namespac declar ( ) , xmlwriter . open ) ; ( depth = = 0 ) { pars properti ( req , gener xml , path , type , properti ) ; } els { stack alwai contain object current level stack string stack = new stack string ( ) ; stack . push ( path ) ; stack object level below stack string stack below = new stack string ( ) ; while ( ( stack . empti ( ) ) ( depth = 0 ) ) { string current path = stack . pop ( ) ; pars properti ( req , gener xml , current path , type , properti ) ; try { object = resourc . lookup ( current path ) ; } catch ( name except e ) { continu ; } ( ( object instanceof dir context ) ( depth 0 ) ) { try { name enumer name class pair enumer = resourc . list ( current path ) ; while ( enumer . ha more element ( ) ) { name class pair nc pair = enumer . next element ( ) ; string new path = current path ; ( ( new path . end ( ) ) ) new path = ; new path = nc pair . get name ( ) ; stack below . push ( new path ) ; } } catch ( name except e ) { resp . send error ( http servlet respons . sc intern server error , path ) ; return ; } displai lock null resourc present collect string lock path = current path ; ( lock path . end ( ) ) lock path = lock path . substr ( 0 , lock path . length ( ) 1 ) ; vector string current lock null resourc = lock null resourc . get ( lock path ) ; ( current lock null resourc = null ) { enumer string lock null resourc list = current lock null resourc . element ( ) ; while ( lock null resourc list . ha more element ( ) ) { string lock null path = lock null resourc list . next element ( ) ; pars lock null properti ( req , gener xml , lock null path , type , properti ) ; } } } ( stack . empti ( ) ) { depth ; stack = stack below ; stack below = new stack string ( ) ; } gener xml . send data ( ) ; } } gener xml . write element ( null , multistatu , xmlwriter . close ) ; gener xml . send data ( ) ; }	public void init ( ) throw servlet except { super . init ( ) ; ( get servlet config ( ) . get init paramet ( secret ) = null ) secret = get servlet config ( ) . get init paramet ( secret ) ; load md5 helper us calcul signatur . try { md5helper = messag digest . get instanc ( md5 ) ; } catch ( algorithm except e ) { throw new unavail except ( md5 ) ; } }	public get xml represent thi lock token . thi method append xml fragment given xml writer . void xml ( xmlwriter gener xml ) { gener xml . write element ( null , activelock , xmlwriter . open ) ; gener xml . write element ( null , locktyp , xmlwriter . open ) ; gener xml . write element ( null , type , xmlwriter . content ) ; gener xml . write element ( null , locktyp , xmlwriter . close ) ; gener xml . write element ( null , lockscop , xmlwriter . open ) ; gener xml . write element ( null , scope , xmlwriter . content ) ; gener xml . write element ( null , lockscop , xmlwriter . close ) ; gener xml . write element ( null , depth , xmlwriter . open ) ; ( depth = = infin ) { gener xml . write text ( infin ) ; } els { gener xml . write text ( 0 ) ; } gener xml . write element ( null , depth , xmlwriter . close ) ; gener xml . write element ( null , owner , xmlwriter . open ) ; gener xml . write text ( owner ) ; gener xml . write element ( null , owner , xmlwriter . close ) ; gener xml . write element ( null , timeout , xmlwriter . open ) ; long timeout = ( expir system . current time milli ( ) ) 1000 ; gener xml . write text ( second timeout ) ; gener xml . write element ( null , timeout , xmlwriter . close ) ; gener xml . write element ( null , locktoken , xmlwriter . open ) ; enumer string token list = token . element ( ) ; while ( token list . ha more element ( ) ) { gener xml . write element ( null , href , xmlwriter . open ) ; gener xml . write text ( opaquelocktoken : token list . next element ( ) ) ; gener xml . write element ( null , href , xmlwriter . close ) ; } gener xml . write element ( null , locktoken , xmlwriter . close ) ; gener xml . write element ( null , activelock , xmlwriter . close ) ; }
privat compar page encod specifi variou place , throw except case page encod mismatch . param page dir enc valu page encod attribut page direct param page dir page direct node throw jasper except case page encod mismatch string compar page encod ( string page dir enc , node . page direct page dir ) throw jasper except { node . root root = page dir . get root ( ) ; string config enc = root . get jsp config page encod ( ) ; string page dir enc = page dir enc . upper case ( ) ; compar page encod attribut page direct encod specifi jsp config element whose url pattern match thi page . treat utf 16 , utf 16be , utf 16le ident . ( config enc = null ) { config enc = config enc . upper case ( ) ; ( page dir enc . equal ( config enc ) ( page dir enc . start ( utf 16 ) config enc . start ( utf 16 ) ) ) { err . jsp error ( page dir , jsp . error . config pagedir encod mismatch , config enc , page dir enc ) ; } els { return config enc ; } } compar page encod attribut page direct encod specifi xml prolog ( onli xml syntax , onli jsp document contain xml prolog encod declar ) . treat utf 16 , utf 16be , utf 16le ident . ( ( root . xml syntax ( ) root . encod specifi prolog ( ) ) root . bom present ( ) ) { string page enc = root . get page encod ( ) . upper case ( ) ; ( page dir enc . equal ( page enc ) ( page dir enc . start ( utf 16 ) page enc . start ( utf 16 ) ) ) { err . jsp error ( page dir , jsp . error . prolog pagedir encod mismatch , page enc , page dir enc ) ; } els { return page enc ; } } return page dir enc ; }	privat compar page encod specifi variou place , throw except case page encod mismatch . param page dir enc valu page encod attribut page direct param page dir page direct node throw jasper except case page encod mismatch void compar tag encod ( string page dir enc , node . tag direct page dir ) throw jasper except { node . root root = page dir . get root ( ) ; compar page encod attribut page direct encod specifi xml prolog ( onli xml syntax , onli jsp document contain xml prolog encod declar ) . treat utf 16 , utf 16be , utf 16le ident . ( ( root . xml syntax ( ) root . encod specifi prolog ( ) ) root . bom present ( ) ) { string page enc = root . get page encod ( ) ; ( page dir enc . equal ( page enc ) ( page dir enc . start ( utf 16 ) page enc . start ( utf 16 ) ) ) { err . jsp error ( page dir , jsp . error . prolog pagedir encod mismatch , page enc , page dir enc ) ; } } }
privat pars tag file direct given tag file turn them tag info . param elem tag file element tld param uri locat tld , case tag file specifi rel param jar file jar file , case tag file packag jar return tag info correspod tag file direct tag file info creat tag file info ( tree node elem , string uri , url jar file url ) throw jasper except { string name = null ; string path = null ; iter tree node list = elem . find children ( ) ; while ( list . ha next ( ) ) { tree node child = list . next ( ) ; string tname = child . get name ( ) ; ( name . equal ( tname ) ) { name = child . get bodi ( ) ; } els ( path . equal ( tname ) ) { path = child . get bodi ( ) ; } els ( exampl . equal ( tname ) ) { ignor exampl element : bugzilla 33538 } els ( tag extens . equal ( tname ) ) { ignor tag extens element : bugzilla 33538 } els ( icon . equal ( tname ) displai name . equal ( tname ) descript . equal ( tname ) ) { ignor element : bugzilla 38015 } els { ( log . warn enabl ( ) ) { log . warn ( local . get messag ( jsp . warn . unknown . element . . tagfil , tname ) ) ; } } } ( path . start ( meta inf tag ) ) { tag file packag jar ctxt . set tag file jar url ( path , jar file url ) ; } els ( path . start ( web inf tag ) ) { err . jsp error ( jsp . error . tagfil . illeg path , path ) ; } tag info tag info = tag file processor . pars tag file direct ( parser control , name , path , thi ) ; return new tag file info ( name , path , tag info ) ; }	privat pars jsp page tag file given path name . param file name name jsp page tag file pars . param parent parent node ( non null when process includ direct ) param tag file true file pars tag file , fals regular jsp page param direct onli true file pars tag file we ar onli interest direct need construct tag file info . param jar file jar file from which read jsp page tag file , null jsp page tag file read from filesystem node . node do pars ( string file name , node parent , url jar file url ) throw file found except , jasper except , ioexcept { node . node pars page = null ; encod specifi prolog = fals ; bom present = fals ; default page encod = fals ; jar file jar file = get jar file ( jar file url ) ; string ab file name = resolv file name ( file name ) ; string jsp config page enc = get jsp config page encod ( ab file name ) ; figur out what type jsp document encod type we ar deal determin syntax encod ( ab file name , jar file , jsp config page enc ) ; ( parent = null ) { includ resourc , add depend list ( jar file = = null ) { compil . get page info ( ) . add depend ( ab file name ) ; } els { compil . get page info ( ) . add depend ( jar file url . extern form ( ) ab file name . substr ( 1 ) ) ; } } ( ( xml encod specifi prolog ) bom present ) { make sure encod explicitli specifi xml prolog ( ani ) match jsp config element ( ani ) , treat utf 16 , utf 16be , utf 16le ident . ( jsp config page enc = null jsp config page enc . equal ( sourc enc ) ( jsp config page enc . start ( utf 16 ) sourc enc . start ( utf 16 ) ) ) { err . jsp error ( jsp . error . prolog config encod mismatch , sourc enc , jsp config page enc ) ; } } dispatch appropri parser ( xml ) { jsp document ( xml syntax ) input stream jspx page creat properli close jsp document parser . pars page = jsp document parser . pars ( thi , ab file name , jar file , parent , tag file , direct onli , sourc enc , jsp config page enc , encod specifi prolog , bom present ) ; } els { standard syntax input stream reader stream reader = null ; try { stream reader = jsp util . get reader ( ab file name , sourc enc , jar file , ctxt , err , skip ) ; jsp reader jsp reader = new jsp reader ( ctxt , ab file name , sourc enc , stream reader , err ) ; pars page = parser . pars ( thi , jsp reader , parent , tag file , direct onli , jar file url , sourc enc , jsp config page enc , default page encod , bom present ) ; } final { ( stream reader = null ) { try { stream reader . close ( ) ; } catch ( except ani ) { } } } } ( jar file = null ) { try { jar file . close ( ) ; } catch ( throwabl t ) { } } base dir stack . pop ( ) ; return pars page ; }	public tag librari info get tag librari info ( ) { collect tag librari info coll = pi . get taglib ( ) ; return coll . arrai ( new tag librari info 0 ) ; }	public tag info get tag info ( ) throw jasper except { ( name = = null ) { xxx get from tag file name } ( bodycont = = null ) { bodycont = tag info . bodi content scriptless ; } string tag class name = jsp util . get tag handler class name ( path , err ) ; tag variabl info tag variabl info = new tag variabl info variabl vector . size ( ) ; variabl vector . copi ( tag variabl info ) ; tag attribut info tag attribut info = new tag attribut info attribut vector . size ( ) ; attribut vector . copi ( tag attribut info ) ; return new jasper tag info ( name , tag class name , bodycont , descript , tag lib info , tei , tag attribut info , displai name , small icon , larg icon , tag variabl info , dynam attr map name ) ; }	public static input stream get input stream ( string fname , jar file jar file , jsp compil context ctxt , error dispatch err ) throw jasper except , ioexcept { input stream = null ; ( jar file = null ) { string jar entri name = fname . substr ( 1 , fname . length ( ) ) ; zip entri jar entri = jar file . get entri ( jar entri name ) ; ( jar entri = = null ) { err . jsp error ( jsp . error . file . . found , fname ) ; } = jar file . get input stream ( jar entri ) ; } els { = ctxt . get resourc stream ( fname ) ; } ( = = null ) { err . jsp error ( jsp . error . file . . found , fname ) ; } return ; }	public static get fulli qualifi class name tag handler correspond given tag file path . param path tag file path param err error dispatch return fulli qualifi class name tag handler correspond given tag file path string get tag handler class name ( string path , error dispatch err ) throw jasper except { string class name = null ; int begin = 0 ; int index ; index = path . last index ( . tag ) ; ( index = = 1 ) { err . jsp error ( jsp . error . tagfil . bad suffix , path ) ; } s tempt remov . tag suffix here , we can t . we remov , fulli qualifi class name thi tag could conflict packag name other tag . instanc , tag file web inf tag foo . tag would have fulli qualifi class name org . apach . jsp . tag . web . foo which would conflict packag name tag file web inf tag foo bar . tag index = path . index ( web inf tag ) ; ( index = 1 ) { class name = org . apach . jsp . tag . web . ; begin = index web inf tag . length ( ) ; } els { index = path . index ( meta inf tag ) ; ( index = 1 ) { class name = org . apach . jsp . tag . meta . ; begin = index meta inf tag . length ( ) ; } els { err . jsp error ( jsp . error . tagfil . illeg path , path ) ; } } class name = make java packag ( path . substr ( begin ) ) ; return class name ; }	privat compil load tagfil . class load tag file ( compil compil , string tag file path , tag info tag info , page info parent page info ) throw jasper except { jsp compil context ctxt = compil . get compil context ( ) ; jsp runtim context rctxt = ctxt . get runtim context ( ) ; jsp servlet wrapper wrapper = rctxt . get wrapper ( tag file path ) ; synchron ( rctxt ) { ( wrapper = = null ) { wrapper = new jsp servlet wrapper ( ctxt . get servlet context ( ) , ctxt . get option ( ) , tag file path , tag info , ctxt . get runtim context ( ) , ctxt . get tag file jar url ( tag file path ) ) ; rctxt . add wrapper ( tag file path , wrapper ) ; us same classload classpath compil tag file wrapper . get jsp engin context ( ) . set class loader ( ( urlclass loader ) ctxt . get class loader ( ) ) ; wrapper . get jsp engin context ( ) . set class path ( ctxt . get class path ( ) ) ; } els { make sure jsp compil context get latest tag info tag file . tag info instanc wa creat last time tag file wa scan direct , tag file mai have been modifi sinc . wrapper . get jsp engin context ( ) . set tag info ( tag info ) ; } class tag clazz ; int trip count = wrapper . inc trip count ( ) ; try { ( trip count 0 ) { when trip count greater than zero , circular depend exist . circularili depend tag file compil prototyp mode , avoid infinit recurs . jsp servlet wrapper temp wrapper = new jsp servlet wrapper ( ctxt . get servlet context ( ) , ctxt . get option ( ) , tag file path , tag info , ctxt . get runtim context ( ) , ctxt . get tag file jar url ( tag file path ) ) ; tag clazz = temp wrapper . load tag file prototyp ( ) ; temp vector . add ( temp wrapper . get jsp engin context ( ) . get compil ( ) ) ; } els { tag clazz = wrapper . load tag file ( ) ; } } final { wrapper . dec trip count ( ) ; } can onli obtain from tag instanc . try { object tag = tag clazz . new instanc ( ) ; ( tag instanceof jsp sourc depend ) { iter string iter = ( ( jsp sourc depend ) tag ) . get depend ( ) . iter ( ) ; while ( iter . ha next ( ) ) { parent page info . add depend ( iter . next ( ) ) ; } } } catch ( except e ) { ignor error } return tag clazz ; } }	perform miscellean check after node ar visit . void post check ( ) throw jasper except { check var . name from attribut ha valid valu . iter string iter = name from tabl . kei set ( ) . iter ( ) ; while ( iter . ha next ( ) ) { string name from = iter . next ( ) ; name entri name entri = name tabl . get ( name from ) ; name entri name from entri = name from tabl . get ( name from ) ; node name from node = name from entri . get node ( ) ; ( name entri = = null ) { err . jsp error ( name from node , jsp . error . tagfil . name from . attribut , name from ) ; } els { node node = name entri . get node ( ) ; tag attribut info tag attr = name entri . get tag attribut info ( ) ; ( java . lang . string . equal ( tag attr . get type name ( ) ) tag attr . requir ( ) tag attr . can request time ( ) ) { err . jsp error ( name from node , jsp . error . tagfil . name from . bad attribut , name from , integ . string ( node . get start ( ) . get line number ( ) ) ) ; } } } }
public load class specifi name , search us follow algorithm until find return class . class cannot found , return code class found except code . ul li call code find load class ( string ) code check class ha alreadi been load . ha , same code class code object return . li li code deleg code properti set code true code , call code load class ( ) code method parent class loader , ani . li li call code find class ( ) code find thi class our local defin repositori . li li call code load class ( ) code method our parent class loader , ani . li ul class wa found us abov step , code resolv code flag code true code , thi method call code resolv class ( class ) code result class object . param name name class load param resolv code true code resolv class except class found except class wa found class load class ( final string name , boolean resolv ) throw class found except { class clazz = null ; ( 0 ) check our previous load class cach clazz = find load class ( name ) ; ( clazz = null ) { ( resolv ) resolv class ( clazz ) ; return ( clazz ) ; } ( . 5 ) permiss access thi class when us secur manag ( secur manag = null ) { int dot = name . last index ( . ) ; ( dot = 0 ) { try { do call secur manag sinc default , we grant packag . ( org . apach . jasper . runtim . equal ignor case ( name . substr ( 0 , dot ) ) ) { secur manag . check packag access ( name . substr ( 0 , dot ) ) ; } } catch ( secur except se ) { string error = secur violat , attempt us restrict class : name ; se . print stack trace ( ) ; throw new class found except ( error ) ; } } } ( name . start ( constant . jsp packag name ) ) { class org . apach . jsp , therefor , have our parent load clazz = parent . load class ( name ) ; ( resolv ) resolv class ( clazz ) ; return clazz ; } return find class ( name ) ; }
protect open ( necessari ) return databas connect us thi realm . except sqlexcept databas error occur connect open ( ) throw sqlexcept { do noth databas connect alreadi open ( db connect = null ) return ( db connect ) ; instanti our databas driver necessari ( driver = = null ) { try { class clazz = class . name ( driver name ) ; driver = ( driver ) clazz . new instanc ( ) ; } catch ( throwabl e ) { throw new sqlexcept ( e . get messag ( ) ) ; } } open new connect properti prop = new properti ( ) ; ( connect name = null ) prop . put ( user , connect name ) ; ( connect password = null ) prop . put ( password , connect password ) ; db connect = driver . connect ( connect url , prop ) ; db connect . set auto commit ( fals ) ; return ( db connect ) ; }
protect compar get compar ( string sort ) { compar compar = null ; ( creation time . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return new date ( session . get creation time ( ) ) ; } } ; } els ( id . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return session . get id ( ) ; } } ; } els ( last access time . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return new date ( session . get last access time ( ) ) ; } } ; } els ( max inact interv . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return new date ( session . get max inact interv ( ) ) ; } } ; } els ( new . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return boolean . valu ( session . get session ( ) . new ( ) ) ; } } ; } els ( local . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return jsp helper . guess displai local from session ( session ) ; } } ; } els ( user . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return jsp helper . guess displai user from session ( session ) ; } } ; } els ( us time . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return new date ( session util . get us time session ( session ) ) ; } } ; } els ( inact time . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return new date ( session util . get inact time session ( session ) ) ; } } ; } els ( ttl . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return new date ( session util . get ttlfor session ( session ) ) ; } } ; } todo : complet thi ttl , etc . return compar ; }	public render html list current activ context our virtual host , memori server statu inform . param request request param respons respons param messag messag displai void list ( http servlet request request , http servlet respons respons , string messag ) throw ioexcept { ( debug = 1 ) log ( list : list context virtual host host . get name ( ) ) ; print writer writer = respons . get writer ( ) ; html header section writer . print ( constant . html header section ) ; bodi header section object arg = new object 2 ; arg 0 = request . get context path ( ) ; arg 1 = sm . get string ( html manag servlet . titl ) ; writer . print ( messag format . format ( constant . bodi header section , arg ) ) ; messag section arg = new object 3 ; arg 0 = sm . get string ( html manag servlet . messag label ) ; ( messag = = null messag . length ( ) = = 0 ) { arg 1 = ok ; } els { arg 1 = request util . filter ( messag ) ; } writer . print ( messag format . format ( constant . messag section , arg ) ) ; manag section arg = new object 9 ; arg 0 = sm . get string ( html manag servlet . manag ) ; arg 1 = respons . encod url ( request . get context path ( ) html list ) ; arg 2 = sm . get string ( html manag servlet . list ) ; arg 3 = respons . encod url ( request . get context path ( ) sm . get string ( html manag servlet . help html manag file ) ) ; arg 4 = sm . get string ( html manag servlet . help html manag ) ; arg 5 = respons . encod url ( request . get context path ( ) sm . get string ( html manag servlet . help manag file ) ) ; arg 6 = sm . get string ( html manag servlet . help manag ) ; arg 7 = respons . encod url ( request . get context path ( ) statu ) ; arg 8 = sm . get string ( statu servlet . titl ) ; writer . print ( messag format . format ( constant . manag section , arg ) ) ; app header section arg = new object 6 ; arg 0 = sm . get string ( html manag servlet . app titl ) ; arg 1 = sm . get string ( html manag servlet . app path ) ; arg 2 = sm . get string ( html manag servlet . app name ) ; arg 3 = sm . get string ( html manag servlet . app avail ) ; arg 4 = sm . get string ( html manag servlet . app session ) ; arg 5 = sm . get string ( html manag servlet . app task ) ; writer . print ( messag format . format ( app header section , arg ) ) ; app row section creat sort map deploi applic context path . contain children = host . find children ( ) ; string context path = new string children . length ; ( int i = 0 ; i children . length ; i ) context path i = children i . get name ( ) ; tree map sort context path map = new tree map ( ) ; ( int i = 0 ; i context path . length ; i ) { string displai path = context path i ; sort context path map . put ( displai path , context path i ) ; } string app start = sm . get string ( html manag servlet . app start ) ; string app stop = sm . get string ( html manag servlet . app stop ) ; string app reload = sm . get string ( html manag servlet . app reload ) ; string app undeploi = sm . get string ( html manag servlet . app undeploi ) ; string app expir = sm . get string ( html manag servlet . app expir ) ; iter iter = sort context path map . entri set ( ) . iter ( ) ; boolean highlight = true ; boolean deploi = true ; string highlight color = null ; while ( iter . ha next ( ) ) { bugzilla 34818 , altern row color highlight = highlight ; ( highlight ) { highlight color = c3f3c3 ; } els { highlight color = ffffff ; } map . entri entri = ( map . entri ) iter . next ( ) ; string displai path = ( string ) entri . get kei ( ) ; string context path = ( string ) entri . get valu ( ) ; context context = ( context ) host . find child ( context path ) ; ( displai path . equal ( ) ) { displai path = ; } ( context = null ) { try { deploi = deploi ( context path ) ; } catch ( except e ) { assum fals failur safeti deploi = fals ; } arg = new object 6 ; arg 0 = displai path ; arg 1 = context . get displai name ( ) ; ( arg 1 = = null ) { arg 1 = nbsp ; ; } arg 2 = new boolean ( context . get avail ( ) ) ; arg 3 = respons . encod url ( request . get context path ( ) html session path = displai path ) ; ( context . get manag ( ) = null ) { arg 4 = new integ ( context . get manag ( ) . get activ session ( ) ) ; } els { arg 4 = new integ ( 0 ) ; } arg 5 = highlight color ; writer . print ( messag format . format ( app row detail section , arg ) ) ; arg = new object 14 ; arg 0 = respons . encod url ( request . get context path ( ) html start path = displai path ) ; arg 1 = app start ; arg 2 = respons . encod url ( request . get context path ( ) html stop path = displai path ) ; arg 3 = app stop ; arg 4 = respons . encod url ( request . get context path ( ) html reload path = displai path ) ; arg 5 = app reload ; arg 6 = respons . encod url ( request . get context path ( ) html undeploi path = displai path ) ; arg 7 = app undeploi ; arg 8 = respons . encod url ( request . get context path ( ) html expir path = displai path ) ; arg 9 = app expir ; arg 10 = sm . get string ( html manag servlet . expir . explain ) ; manag manag = context . get manag ( ) ; ( manag = = null ) { arg 11 = sm . get string ( html manag servlet . manag ) ; } els { arg 11 = new integ ( context . get manag ( ) . get max inact interv ( ) 60 ) ; } arg 12 = sm . get string ( html manag servlet . expir . unit ) ; arg 13 = highlight color ; ( context . get path ( ) . equal ( thi . context . get path ( ) ) ) { writer . print ( messag format . format ( manag app row button section , arg ) ) ; } els ( context . get avail ( ) deploi ) { writer . print ( messag format . format ( start deploi app row button section , arg ) ) ; } els ( context . get avail ( ) deploi ) { writer . print ( messag format . format ( start nondeploi app row button section , arg ) ) ; } els ( context . get avail ( ) deploi ) { writer . print ( messag format . format ( stop deploi app row button section , arg ) ) ; } els { writer . print ( messag format . format ( stop nondeploi app row button section , arg ) ) ; } } } deploi section arg = new object 7 ; arg 0 = sm . get string ( html manag servlet . deploi titl ) ; arg 1 = sm . get string ( html manag servlet . deploi server ) ; arg 2 = respons . encod url ( request . get context path ( ) html deploi ) ; arg 3 = sm . get string ( html manag servlet . deploi path ) ; arg 4 = sm . get string ( html manag servlet . deploi config ) ; arg 5 = sm . get string ( html manag servlet . deploi war ) ; arg 6 = sm . get string ( html manag servlet . deploi button ) ; writer . print ( messag format . format ( deploi section , arg ) ) ; arg = new object 4 ; arg 0 = sm . get string ( html manag servlet . deploi upload ) ; arg 1 = respons . encod url ( request . get context path ( ) html upload ) ; arg 2 = sm . get string ( html manag servlet . deploi upload file ) ; arg 3 = sm . get string ( html manag servlet . deploi button ) ; writer . print ( messag format . format ( upload section , arg ) ) ; server header section arg = new object 7 ; arg 0 = sm . get string ( html manag servlet . server titl ) ; arg 1 = sm . get string ( html manag servlet . server version ) ; arg 2 = sm . get string ( html manag servlet . server jvmversion ) ; arg 3 = sm . get string ( html manag servlet . server jvmvendor ) ; arg 4 = sm . get string ( html manag servlet . server osnam ) ; arg 5 = sm . get string ( html manag servlet . server osvers ) ; arg 6 = sm . get string ( html manag servlet . server osarch ) ; writer . print ( messag format . format ( constant . server header section , arg ) ) ; server row section arg = new object 6 ; arg 0 = server info . get server info ( ) ; arg 1 = system . get properti ( java . runtim . version ) ; arg 2 = system . get properti ( java . vm . vendor ) ; arg 3 = system . get properti ( os . name ) ; arg 4 = system . get properti ( os . version ) ; arg 5 = system . get properti ( os . arch ) ; writer . print ( messag format . format ( constant . server row section , arg ) ) ; html tail section writer . print ( constant . html tail section ) ; finish up respons writer . flush ( ) ; writer . close ( ) ; }	public set context path thi context . p b implement note b : context path us name context , becaus must uniqu . param path new context path void set path ( string path ) { xxx us host name set name ( request util . urldecod ( path ) ) ; }
privat when interpret el attribut valu , liter outsid el must unescap el processor unescap them . therefor , make sure onli el express ar process el processor . string attribut valu el ( boolean tag , string tx , class expect type , string map name ) { ( tx = = null ) return null ; int size = tx . length ( ) ; string buffer output = new string buffer ( size ) ; boolean el = fals ; int i = 0 ; int mark = 0 ; char ch ; while ( i size ) { ch = tx . char ( i ) ; start el express ( el i 1 size ch = = tx . char ( i 1 ) = = { ) { ( mark i ) { ( output . length ( ) 0 ) { output . append ( ) ; } output . append ( quot ( tx . substr ( mark , i ) ) ) ; } mark = i ; el = true ; i = 2 ; } els ( ch = = i 1 size ( tx . char ( i 1 ) = = tx . char ( i 1 ) = = } ) ) { skip escap } i = 2 ; } els ( el ch = = } ) { end el express ( output . length ( ) 0 ) { output . append ( ) ; } output . append ( jsp util . interpret call ( tag , tx . substr ( mark , i 1 ) , expect type , map name , fals ) ) ; mark = i 1 ; el = fals ; i ; } els { noth see here move next charact i ; } } ( el mark i ) { ( output . length ( ) 0 ) { output . append ( ) ; } output . append ( quot ( tx . substr ( mark , i ) ) ) ; } return output . string ( ) ; }
public logic void start ( ) throw except { ( start ) return ; contain hcontain = get cluster ( ) . get contain ( ) ; ( ( hcontain instanceof host ) ) { log . error ( farm war deploy can onli work host cluster subel ) ; return ; } host = ( host ) hcontain ; check correct engin host setup contain econtain = host . get parent ( ) ; ( econtain = = null econtain instanceof engin ) { log . error ( farm war deploy can onli work parent host . get name ( ) engin ) ; return ; } engin engin = ( engin ) econtain ; string hostnam = null ; hostnam = host . get name ( ) ; try { onam = new object name ( engin . get name ( ) : type = deploy , host = hostnam ) ; } catch ( except e ) { log . error ( can t construct mbean object name e ) ; return ; } ( watch enabl ) { watcher = new war watcher ( thi , new file ( get watch dir ( ) ) ) ; ( log . info enabl ( ) ) { log . info ( cluster deploy watch get watch dir ( ) chang . ) ; } } config base = new file ( system . get properti ( catalina . base ) , conf ) ; ( engin = null ) { config base = new file ( config base , engin . get name ( ) ) ; } ( host = null ) { config base = new file ( config base , hostnam ) ; } retriev mbean server m bean server = registri . get registri ( null , null ) . get mbean server ( ) ; start = true ; count = 0 ; get cluster ( ) . add cluster listen ( thi ) ; ( log . info enabl ( ) ) log . info ( cluster farm war deploy start . ) ; }
privat void gener custom end ( node . custom tag n , string tag handler var , string tag eval var , string tag push bodi count var ) { ( n . ha empti bodi ( ) ) { ( n . implement iter tag ( ) ) { out . printin ( int eval do after bodi = ) ; out . print ( tag handler var ) ; out . println ( . do after bodi ( ) ; ) ; synchron begin nest script variabl sync script var ( n , variabl info . begin ) ; sync script var ( n , variabl info . nest ) ; out . printil ( ( eval do after bodi = javax . servlet . jsp . tagext . bodi tag . eval bodi again ) ) ; out . push indent ( ) ; out . printil ( break ; ) ; out . pop indent ( ) ; out . pop indent ( ) ; out . printil ( } while ( true ) ; ) ; } restor script var ( n , variabl info . nest ) ; ( n . implement bodi tag ( ) ) { out . printin ( ( ) ; out . print ( tag eval var ) ; out . println ( = javax . servlet . jsp . tagext . tag . eval bodi includ ) { ) ; out . push indent ( ) ; out . printil ( out = jspx page context . pop bodi ( ) ; ) ; ( n . implement try catch final ( ) ) { out . printin ( tag push bodi count var ) ; out . println ( 0 ; ) ; } els ( push bodi count var = null ) { out . printin ( push bodi count var ) ; out . println ( 0 ; ) ; } out . pop indent ( ) ; out . printil ( } ) ; } eval bodi out . pop indent ( ) ; out . printil ( } ) ; } out . printin ( ( ) ; out . print ( tag handler var ) ; out . println ( . do end tag ( ) = = javax . servlet . jsp . tagext . tag . skip page ) { ) ; out . push indent ( ) ; ( n . implement try catch final ( ) ) { ( pool enabl ( n . implement jsp id consum ( ) ) ) { out . printin ( n . get tag handler pool name ( ) ) ; out . print ( . reus ( ) ; out . print ( tag handler var ) ; out . println ( ) ; ) ; } els { out . printin ( tag handler var ) ; out . println ( . releas ( ) ; ) ; write destroi instanc ( tag handler var ) ; } } ( tag file fragment ) { out . printil ( throw new skip page except ( ) ; ) ; } els { out . printil ( ( method nest 0 ) return true ; : return ; ) ; } out . pop indent ( ) ; out . printil ( } ) ; synchron begin script variabl sync script var ( n , variabl info . begin ) ; try catch final ( n . implement try catch final ( ) ) { try out . pop indent ( ) ; out . printil ( } catch ( throwabl jspx except ) { ) ; out . push indent ( ) ; out . printin ( while ( ) ; out . print ( tag push bodi count var ) ; out . println ( 0 0 ) ) ; out . push indent ( ) ; out . printil ( out = jspx page context . pop bodi ( ) ; ) ; out . pop indent ( ) ; out . printin ( tag handler var ) ; out . println ( . do catch ( jspx except ) ; ) ; out . pop indent ( ) ; out . printil ( } final { ) ; out . push indent ( ) ; out . printin ( tag handler var ) ; out . println ( . do final ( ) ; ) ; } ( pool enabl ) { out . printin ( n . get tag handler pool name ( ) ) ; out . print ( . reus ( ) ; out . print ( tag handler var ) ; out . println ( ) ; ) ; } els { out . printin ( tag handler var ) ; out . println ( . releas ( ) ; ) ; write destroi instanc ( tag handler var ) ; } ( n . implement try catch final ( ) ) { out . pop indent ( ) ; out . printil ( } ) ; } declar synchron end script variabl ( must do thi outsid try catch final block ) declar script var ( n , variabl info . end ) ; sync script var ( n , variabl info . end ) ; restor script var ( n , variabl info . begin ) ; }
public static todo rfc2965 field also need pass void append cooki valu ( string buffer header buf , int version , string name , string valu , string path , string domain , string comment , int max ag , boolean secur , boolean http onli ) { string buffer buf = new string buffer ( ) ; servlet implement check name buf . append ( name ) ; buf . append ( = ) ; servlet implement doe check anyth els version = mayb quote2 ( version , buf , valu , true ) ; add version 1 specif inform ( version = = 1 ) { version = 1 . . . requir buf . append ( ; version = 1 ) ; comment = comment ( comment = null ) { buf . append ( ; comment = ) ; mayb quote2 ( version , buf , comment ) ; } } add domain inform , present ( domain = null ) { buf . append ( ; domain = ) ; mayb quote2 ( version , buf , domain ) ; } todo rfc2965 discard ( max ag = 0 ) { ( version = = 0 ) { wdy , dd mon yy hh : mm : ss gmt ( expir netscap format ) buf . append ( ; expir = ) ; expir immedi we need set time past ( max ag = = 0 ) buf . append ( ancient date ) ; els synchron ( old cooki format ) { old cooki format . format ( new date ( system . current time milli ( ) max ag 1000l ) , buf , new field posit ( 0 ) ) ; } } els { buf . append ( ; max ag = ) ; buf . append ( max ag ) ; } } path = path ( path = null ) { buf . append ( ; path = ) ; ( version = = 0 ) { mayb quote2 ( version , buf , path ) ; } els { mayb quote2 ( version , buf , path , server cooki . tspecials2no slash , fals ) ; } } secur ( secur ) { buf . append ( ; secur ) ; } http onli ( http onli ) { buf . append ( ; http onli ) ; } header buf . append ( buf ) ; }
privat static void execut ( final method method , final object target object , final object target argument , princip princip ) throw java . lang . except { try { subject subject = null ; privileg except action pea = new privileg except action ( ) { public object run ( ) throw except { method . invok ( target object , target argument ) ; return null ; } } ; first argument alwai request object ( target argument = null target argument 0 instanceof http servlet request ) { http servlet request request = ( http servlet request ) target argument 0 ; boolean ha subject = fals ; http session session = request . get session ( fals ) ; ( session = null ) { subject = ( subject ) session . get attribut ( global . subject attr ) ; ha subject = ( subject = null ) ; } ( subject = = null ) { subject = new subject ( ) ; ( princip = null ) { subject . get princip ( ) . add ( princip ) ; } } ( session = null ha subject ) { session . set attribut ( global . subject attr , subject ) ; } } subject . do privileg ( subject , pea , null ) ; } catch ( privileg action except pe ) { throwabl e = ( ( invoc target except ) pe . get except ( ) ) . get target except ( ) ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( secur util . do privileg ) , e ) ; } ( e instanceof unavail except ) throw ( unavail except ) e ; } }

privat void guarante iter ( ) { while ( thi . itr = = null thi . idx thi . size ) { thi . itr = thi . resolv thi . idx . get featur descriptor ( thi . context , thi . base ) ; thi . idx ; } }	public featur descriptor next ( ) { object result = null ; ( thi . itr = null ) { ( thi . itr . ha next ( ) ) { result = thi . itr . next ( ) ; ( thi . itr . ha next ( ) ) { thi . itr = null ; thi . guarante iter ( ) ; } } } return ( featur descriptor ) result ; }	public class get type ( elcontext context , object base , object properti ) throw null pointer except , properti found except , elexcept { context . set properti resolv ( fals ) ; int sz = thi . size ; class type ; ( int i = 0 ; i sz ; i ) { type = thi . resolv i . get type ( context , base , properti ) ; ( context . properti resolv ( ) ) { return type ; } } return null ; }
public compil jsp file from current engin context . side effect , tag file ar referenc thi page ar also compil . param compil class true , gener both . java . class file fals , gener onli . java file param jspc mode true invok from jsp c , fals otherwis void compil ( boolean compil class , boolean jspc mode ) throw file found except , jasper except , except { ( err dispatch = = null ) { thi . err dispatch = new error dispatch ( jspc mode ) ; } try { string smap = gener java ( ) ; ( compil class ) { gener class ( smap ) ; } } final { ( tfp = null ) { tfp . remov proto type file ( null ) ; } make sure object which ar onli us dure gener compil jsp page get dereferenc so thei can gc d reduc memori footprint . tfp = null ; err dispatch = null ; page info = null ; http : issu . apach . org bugzilla show bug . cgi id = 37062 ( thi . option . get develop ( ) ) { page node = null ; } ( ctxt . get writer ( ) = null ) { ctxt . get writer ( ) . close ( ) ; ctxt . set writer ( null ) ; } } }
privat static final find map elemnt given name sort arrai map element . thi return index closest inferior equal item given arrai . int find ignor case ( map element map , char chunk name , int start , int end ) { int = 0 ; int b = map . length 1 ; special case : 1 0 ( b = = 1 ) { return 1 ; } ( compar ignor case ( name , start , end , map 0 . name ) 0 ) { return 1 ; } ( b = = 0 ) { return 0 ; } int i = 0 ; while ( true ) { i = ( b ) 2 ; int result = compar ignor case ( name , start , end , map i . name ) ; ( result = = 1 ) { = i ; } els ( result = = 0 ) { return i ; } els { b = i ; } ( ( b ) = = 1 ) { int result2 = compar ignor case ( name , start , end , map b . name ) ; ( result2 0 ) { return ; } els { return b ; } } } }	privat protect method void regist engin ( ) throw except { object name engin name = new object name ( domain : type = engin ) ; ( m bean server . regist ( engin name ) ) return ; string default host = ( string ) m bean server . get attribut ( engin name , default host ) ; object name host name = new object name ( domain : type = host , host = default host ) ; ( m bean server . regist ( host name ) ) { get host list string str = domain : type = host , ; object name object name = new object name ( str ) ; set set = m bean server . queri mbean ( object name , null ) ; iter iter = set . iter ( ) ; string alias ; boolean regist alia = fals ; while ( iter . ha next ( ) ) { ( regist alia ) break ; object instanc oi = ( object instanc ) iter . next ( ) ; host name = oi . get object name ( ) ; alias = ( string ) m bean server . invok ( host name , find alias , null , null ) ; ( int i = 0 ; i alias . length ; i ) { ( alias i . equal ignor case ( default host ) ) { regist alia = true ; break ; } } } ( regist alia log . warn enabl ( ) ) log . warn ( sm . get string ( mapper listen . unknown default host , default host ) ) ; } thi should probablt call later ( default host = null ) { mapper . set default host name ( default host ) ; } }	privat regist host . void regist host ( object name object name ) throw except { string name = object name . get kei properti ( host ) ; ( name = null ) { string alias = ( string ) m bean server . invok ( object name , find alias , null , null ) ; mapper . add host ( name , alias , object name ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( mapper listen . regist host , name , domain ) ) ; } }	privat unregist host . void unregist host ( object name object name ) throw except { string name = object name . get kei properti ( host ) ; mapper . remov host ( name ) ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( mapper listen . unregist host , name , domain ) ) ; }	public string get host ( ) { string host n = new string host . length ; ( int i = 0 ; i host . length ; i ) { host n i = host i . name ; } return host n ; }	public notif listen method void handl notif ( notif notif , java . lang . object handback ) { ( notif instanceof mbean server notif ) { object name object name = ( ( mbean server notif ) notif ) . get mbean name ( ) ; string j2ee type = object name . get kei properti ( j2ee type ) ; string engin name = null ; ( j2ee type = null ) { ( ( j2ee type . equal ( web modul ) ) ( j2ee type . equal ( servlet ) ) ) { ( m bean server . regist ( object name ) ) { try { engin name = ( string ) m bean server . get attribut ( object name , engin name ) ; } catch ( except e ) { ignor } } } } deploy time , engin name alwai = null . ( ( . equal ( domain ) ) ( domain . equal ( object name . get domain ( ) ) ) ( ( domain . equal ( engin name ) ) ( engin name = null ) ) ) { return ; } ( log . debug enabl ( ) ) log . debug ( handl object name type : notif . get type ( ) ) ; ( notif . get type ( ) . equal ( mbean server notif . registr notif ) ) { string type = object name . get kei properti ( type ) ; ( host . equal ( type ) domain . equal ( object name . get domain ( ) ) ) { try { regist host ( object name ) ; } catch ( except e ) { log . warn ( error regist host object name , e ) ; } } ( j2ee type = null ) { ( j2ee type . equal ( web modul ) ) { try { regist context ( object name ) ; } catch ( throwabl t ) { log . warn ( error regist context object name , t ) ; } } els ( j2ee type . equal ( servlet ) ) { try { regist wrapper ( object name ) ; } catch ( throwabl t ) { log . warn ( error regist wrapper object name , t ) ; } } } } els ( notif . get type ( ) . equal ( mbean server notif . unregistr notif ) ) { string type = object name . get kei properti ( type ) ; ( host . equal ( type ) domain . equal ( object name . get domain ( ) ) ) { try { unregist host ( object name ) ; } catch ( except e ) { log . warn ( error unregist host object name , e ) ; } } ( j2ee type = null ) { ( j2ee type . equal ( web modul ) ) { try { unregist context ( object name ) ; } catch ( throwabl t ) { log . warn ( error unregist webapp object name , t ) ; } } } } } }
protect servlet context path get servlet context path from virtual path ( string virtual path ) throw ioexcept { ( virtual path . start ( ) virtual path . start ( ) ) { return new servlet context path ( context , get absolut path ( virtual path ) ) ; } els { string normal = ssiservlet request util . normal ( virtual path ) ; ( virtual webapp rel ) { return new servlet context path ( context , normal ) ; } els { servlet context norm context = context . get context ( normal ) ; ( norm context = = null ) { throw new ioexcept ( couldn t get context path : normal ) ; } file1 . shtml vs app name1 file1 . shtml ( root context ( norm context ) ) { string context = get path without context ( normal ) ; ( context = = null ) { throw new ioexcept ( couldn t remov context from path : normal ) ; } return new servlet context path ( norm context , context ) ; } els { return new servlet context path ( norm context , normal ) ; } } } }	protect string get path without context ( string servlet path ) { string ret val = null ; int second slash = servlet path . index ( , 1 ) ; ( second slash = 0 ) { cut off context ret val = servlet path . substr ( second slash ) ; } return ret val ; }	protect string get path without file name ( string servlet path ) { string ret val = null ; int last slash = servlet path . last index ( ) ; ( last slash = 0 ) { cut off file name ret val = servlet path . substr ( 0 , last slash 1 ) ; } return ret val ; }
void intern do filter ( servlet request request , servlet respons respons ) throw ioexcept , servlet except { call next filter ( po n ) { applic filter config filter config = filter po ; filter filter = null ; try { filter = filter config . get filter ( ) ; support . fire instanc event ( instanc event . befor filter event , filter , request , respons ) ; ( global . secur enabl ) { final servlet request req = request ; final servlet respons re = respons ; princip princip = ( ( http servlet request ) req ) . get user princip ( ) ; object arg = new object { req , re , thi } ; secur util . do privileg ( do filter , filter , class type , arg ) ; arg = null ; } els { filter . do filter ( request , respons , thi ) ; } support . fire instanc event ( instanc event . after filter event , filter , request , respons ) ; } catch ( ioexcept e ) { ( filter = null ) support . fire instanc event ( instanc event . after filter event , filter , request , respons , e ) ; throw e ; } catch ( servlet except e ) { ( filter = null ) support . fire instanc event ( instanc event . after filter event , filter , request , respons , e ) ; throw e ; } catch ( runtim except e ) { ( filter = null ) support . fire instanc event ( instanc event . after filter event , filter , request , respons , e ) ; throw e ; } catch ( throwabl e ) { ( filter = null ) support . fire instanc event ( instanc event . after filter event , filter , request , respons , e ) ; throw new servlet except ( sm . get string ( filter chain . filter ) , e ) ; } return ; } we fell off end chain call servlet instanc try { ( global . strict servlet complianc ) { last servic request . set ( request ) ; last servic respons . set ( respons ) ; } support . fire instanc event ( instanc event . befor servic event , servlet , request , respons ) ; ( ( request instanceof http servlet request ) ( respons instanceof http servlet respons ) ) { ( global . secur enabl ) { final servlet request req = request ; final servlet respons re = respons ; princip princip = ( ( http servlet request ) req ) . get user princip ( ) ; object arg = new object { req , re } ; secur util . do privileg ( servic , servlet , class type us servic , arg , princip ) ; arg = null ; } els { servlet . servic ( ( http servlet request ) request , ( http servlet respons ) respons ) ; } } els { servlet . servic ( request , respons ) ; } support . fire instanc event ( instanc event . after servic event , servlet , request , respons ) ; } catch ( ioexcept e ) { support . fire instanc event ( instanc event . after servic event , servlet , request , respons , e ) ; throw e ; } catch ( servlet except e ) { support . fire instanc event ( instanc event . after servic event , servlet , request , respons , e ) ; throw e ; } catch ( runtim except e ) { support . fire instanc event ( instanc event . after servic event , servlet , request , respons , e ) ; throw e ; } catch ( throwabl e ) { support . fire instanc event ( instanc event . after servic event , servlet , request , respons , e ) ; throw new servlet except ( sm . get string ( filter chain . servlet ) , e ) ; } final { ( global . strict servlet complianc ) { last servic request . set ( null ) ; last servic respons . set ( null ) ; } } }	public static perform work particular code subject code . here work grant code null code subject . param method name method appli secur restrict param target object code filter code which method call . param target type code class code arrai us instanci code method code object . param target argument code object code arrai contain runtim paramet instanc . void do privileg ( final string method name , final filter target object , final class target type , final object target argument ) throw java . lang . except { method method = null ; method method cach = null ; ( object cach . contain kei ( target object ) ) { method cach = ( method ) object cach . get ( target object ) ; method = find method ( method cach , method name ) ; ( method = = null ) { method = creat method cach ( method cach , method name , target object , target type ) ; } } els { method = creat method cach ( method cach , method name , target object , target type ) ; } execut ( method , target object , target argument , null ) ; }
privat pars jsp page tag file given path name . param file name name jsp page tag file pars . param parent parent node ( non null when process includ direct ) param tag file true file pars tag file , fals regular jsp page param direct onli true file pars tag file we ar onli interest direct need construct tag file info . param jar file jar file from which read jsp page tag file , null jsp page tag file read from filesystem node . node do pars ( string file name , node parent , url jar file url ) throw file found except , jasper except , ioexcept { node . node pars page = null ; encod specifi prolog = fals ; bom present = fals ; default page encod = fals ; jar file jar file = get jar file ( jar file url ) ; string ab file name = resolv file name ( file name ) ; string jsp config page enc = get jsp config page encod ( ab file name ) ; figur out what type jsp document encod type we ar deal determin syntax encod ( ab file name , jar file , jsp config page enc ) ; ( parent = null ) { includ resourc , add depend list compil . get page info ( ) . add depend ( ab file name ) ; } ( ( xml encod specifi prolog ) bom present ) { make sure encod explicitli specifi xml prolog ( ani ) match jsp config element ( ani ) , treat utf 16 , utf 16be , utf 16le ident . ( jsp config page enc = null jsp config page enc . equal ( sourc enc ) ( jsp config page enc . start ( utf 16 ) sourc enc . start ( utf 16 ) ) ) { err . jsp error ( jsp . error . prolog config encod mismatch , sourc enc , jsp config page enc ) ; } } dispatch appropri parser ( xml ) { jsp document ( xml syntax ) input stream jspx page creat properli close jsp document parser . pars page = jsp document parser . pars ( thi , ab file name , jar file , parent , tag file , direct onli , sourc enc , jsp config page enc , encod specifi prolog , bom present ) ; } els { standard syntax input stream reader stream reader = null ; try { stream reader = jsp util . get reader ( ab file name , sourc enc , jar file , ctxt , err , skip ) ; jsp reader jsp reader = new jsp reader ( ctxt , ab file name , sourc enc , stream reader , err ) ; pars page = parser . pars ( thi , jsp reader , parent , tag file , direct onli , jar file url , sourc enc , jsp config page enc , default page encod , bom present ) ; } final { ( stream reader = null ) { try { stream reader . close ( ) ; } catch ( except ani ) { } } } } ( jar file = null ) { try { jar file . close ( ) ; } catch ( throwabl t ) { } } base dir stack . pop ( ) ; return pars page ; }
protect handl http statu code java except forward control locat includ specifi error page object . assum caller ha alreadi record ani request attribut ar forward thi page . return code true code we successfulli util specifi error page locat , code fals code default error report should render . param request request process param respons respons gener param error page error page direct we ar obei boolean custom ( request request , respons respons , error page error page ) { ( contain . get logger ( ) . debug enabl ( ) ) contain . get logger ( ) . debug ( process error page ) ; request . set path info ( error page . get locat ( ) ) ; try { reset respons possibl ( els illeg state except ) hre . reset ( ) ; reset respons ( keep real error code messag ) integ statu code obj = ( integ ) request . get attribut ( global . statu code attr ) ; int statu code = statu code obj . int valu ( ) ; string messag = ( string ) request . get attribut ( global . error messag attr ) ; respons . reset ( statu code , messag ) ; forward control specifi locat servlet context servlet context = request . get context ( ) . get servlet context ( ) ; request dispatch rd = servlet context . get request dispatch ( error page . get locat ( ) ) ; rd . forward ( request . get request ( ) , respons . get respons ( ) ) ; we forward , respons suspend again respons . set suspend ( fals ) ; indic we have successfulli process thi custom page return ( true ) ; } catch ( throwabl t ) { report our failur process thi custom page contain . get logger ( ) . error ( except process error page , t ) ; return ( fals ) ; } }	protect static find return error page instanc specifi except s class , error page instanc closest superclass which definit . associ error page instanc found , return code null code . param context context which search param except except which find error page error page find error page ( context context , throwabl except ) { ( except = = null ) return ( null ) ; class clazz = except . get class ( ) ; string name = clazz . get name ( ) ; while ( object . class . equal ( clazz ) ) { error page error page = context . find error page ( name ) ; ( error page = null ) return ( error page ) ; clazz = clazz . get superclass ( ) ; ( clazz = = null ) break ; name = clazz . get name ( ) ; } return ( null ) ; }

protect restor origin request from inform store our session . origin request longer present ( becaus session time out ) , return code fals code ; otherwis , return code true code . param request request restor param session session contain save inform boolean restor request ( request request , session session ) throw ioexcept { retriev remov save request object from our session save request save = ( save request ) session . get note ( constant . form request note ) ; session . remov note ( constant . form request note ) ; session . remov note ( constant . form princip note ) ; ( save = = null ) return ( fals ) ; modifi our current request reflect origin request . clear cooki ( ) ; iter cooki = save . get cooki ( ) ; while ( cooki . ha next ( ) ) { request . add cooki ( ( cooki ) cooki . next ( ) ) ; } mime header rmh = request . get coyot request ( ) . get mime header ( ) ; rmh . recycl ( ) ; boolean cachabl = get . equal ignor case ( save . get method ( ) ) head . equal ignor case ( save . get method ( ) ) ; iter name = save . get header name ( ) ; while ( name . ha next ( ) ) { string name = ( string ) name . next ( ) ; bz 43687 ( ( modifi sinc . equal ignor case ( name ) ( cachabl none match . equal ignor case ( name ) ) ) ) { iter valu = save . get header valu ( name ) ; while ( valu . ha next ( ) ) { rmh . add valu ( name ) . set string ( ( string ) valu . next ( ) ) ; } } } request . clear local ( ) ; iter local = save . get local ( ) ; while ( local . ha next ( ) ) { request . add local ( ( local ) local . next ( ) ) ; } request . get coyot request ( ) . get paramet ( ) . recycl ( ) ; ( post . equal ignor case ( save . get method ( ) ) ) { byte chunk bodi = save . get bodi ( ) ; ( bodi = null ) { request . get coyot request ( ) . action ( action code . action req set bodi replai , bodi ) ; set content type messag byte content type = messag byte . new instanc ( ) ; content type specifi , us default post string save content type = save . get content type ( ) ; ( save content type = = null ) { save content type = applic x www form urlencod ; } content type . set string ( save content type ) ; request . get coyot request ( ) . set content type ( content type ) ; } } request . get coyot request ( ) . method ( ) . set string ( save . get method ( ) ) ; request . get coyot request ( ) . queri string ( ) . set string ( save . get queri string ( ) ) ; request . get coyot request ( ) . request uri ( ) . set string ( save . get request uri ( ) ) ; return ( true ) ; }


protect call post construct method specifi instanc recurs from deepest superclass actual class . param instanc object call postconstruct method param clazz ( super ) class examin post construct annot . throw illeg access except post construct method inaccess . throw java . lang . reflect . invoc target except call fail void post construct ( object instanc , class clazz ) throw illeg access except , invoc target except { class super class = clazz . get superclass ( ) ; ( super class = object . class ) { post construct ( instanc , super class ) ; } method method = clazz . get declar method ( ) ; method post construct = null ; ( method method : method ) { ( method . annot present ( post construct . class ) ) { ( ( post construct = null ) ( method . get paramet type ( ) . length = 0 ) ( modifi . static ( method . get modifi ( ) ) ) ( method . get except type ( ) . length 0 ) ( method . get return type ( ) . get name ( ) . equal ( void ) ) ) { throw new illeg argument except ( invalid post construct annot ) ; } post construct = method ; } } method invok ( post construct = null ) { boolean access = post construct . access ( ) ; post construct . set access ( true ) ; post construct . invok ( instanc ) ; post construct . set access ( access ) ; } }	class load class ( string class name , class loader class loader ) throw class found except { ( class name . start ( org . apach . catalina ) ) { return contain class loader . load class ( class name ) ; } try { class clazz = contain class loader . load class ( class name ) ; ( contain servlet . class . assign from ( clazz ) ) { return clazz ; } } catch ( throwabl t ) { ignor } return class loader . load class ( class name ) ; }	public void destroi instanc ( object instanc ) throw illeg access except , invoc target except { ( ignor annot ) { pre destroi ( instanc , instanc . get class ( ) ) ; } }
public get etag . return strong etag avail , els weak etag . string get etag ( ) { string result = null ; ( attribut = null ) { attribut attribut = attribut . get ( etag ) ; ( attribut = null ) { try { result = attribut . get ( ) . string ( ) ; } catch ( name except e ) { valu attribut ; } } } ( result = = null ) { ( strong etag = null ) { strong etag must alwai calcul resourc result = strong etag ; } els { weak etag content length last modifi ( weak etag = = null ) { long content length = get content length ( ) ; long last modifi = get last modifi ( ) ; ( ( content length = 0 ) ( last modifi = 0 ) ) { weak etag = w content length last modifi ; } } result = weak etag ; } } return result ; }	public type mutat . param resourc type new resourc type void set resourc type ( string resourc type ) { collect = resourc type . equal ( collect type ) ; ( attribut = null ) attribut . put ( type , resourc type ) ; }
protect pars addit request paramet . boolean post pars request ( org . apach . coyot . request req , request request , org . apach . coyot . respons re , respons respons ) throw except { otherwis , us connector configur ( req . scheme ( ) . null ( ) ) { us processor specifi scheme determin secur state request . set secur ( req . scheme ( ) . equal ( http ) ) ; } els { us connector scheme secur configur , ( default http fals respect ) req . scheme ( ) . set string ( connector . get scheme ( ) ) ; request . set secur ( connector . get secur ( ) ) ; } fixm : code below doesnt belong here , thi onli have sens http11 , ajp13 . . thi point host header ha been process . overrid proxi port proxi host ar set string proxi name = connector . get proxi name ( ) ; int proxi port = connector . get proxi port ( ) ; ( proxi port = 0 ) { req . set server port ( proxi port ) ; } ( proxi name = null ) { req . server name ( ) . set string ( proxi name ) ; } pars session id pars session id ( req , request ) ; uri decod messag byte decod uri = req . decod uri ( ) ; decod uri . duplic ( req . request uri ( ) ) ; ( decod uri . get type ( ) = = messag byte . t byte ) { remov ani path paramet byte chunk uri bb = decod uri . get byte chunk ( ) ; int semicolon = uri bb . index ( ; , 0 ) ; ( semicolon 0 ) { decod uri . set byte ( uri bb . get buffer ( ) , uri bb . get start ( ) , semicolon ) ; } xx decod url try { req . get urldecod ( ) . convert ( decod uri , fals ) ; } catch ( ioexcept ioe ) { re . set statu ( 400 ) ; re . set messag ( invalid uri : ioe . get messag ( ) ) ; return fals ; } normal ( normal ( req . decod uri ( ) ) ) { re . set statu ( 400 ) ; re . set messag ( invalid uri ) ; return fals ; } charact decod convert uri ( decod uri , request ) ; check uri still normal ( check normal ( req . decod uri ( ) ) ) { re . set statu ( 400 ) ; re . set messag ( invalid uri charact encod ) ; return fals ; } } els { url char string , ha been sent us memori protocol handler , we have assum url ha been properli decod alreadi decod uri . char ( ) ; remov ani path paramet char chunk uri cc = decod uri . get char chunk ( ) ; int semicolon = uri cc . index ( ; ) ; ( semicolon 0 ) { decod uri . set char ( uri cc . get buffer ( ) , uri cc . get start ( ) , semicolon ) ; } } set remot princip string princip = req . get remot user ( ) . string ( ) ; ( princip = null ) { request . set user princip ( new coyot princip ( princip ) ) ; } set author type string authtyp = req . get auth type ( ) . string ( ) ; ( authtyp = null ) { request . set auth type ( authtyp ) ; } request map . messag byte server name ; ( connector . get us ipvhost ( ) ) { server name = req . local name ( ) ; ( server name . null ( ) ) { well , thei did ask re . action ( action code . action req local name attribut , null ) ; } } els { server name = req . server name ( ) ; } connector . get mapper ( ) . map ( server name , decod uri , request . get map data ( ) ) ; request . set context ( ( context ) request . get map data ( ) . context ) ; request . set wrapper ( ( wrapper ) request . get map data ( ) . wrapper ) ; filter trace method ( connector . get allow trace ( ) req . method ( ) . equal ignor case ( trace ) ) { wrapper wrapper = request . get wrapper ( ) ; string header = null ; ( wrapper = null ) { string method = wrapper . get servlet method ( ) ; ( method = null ) { ( int i = 0 ; i method . length ; i ) { ( trace . equal ( method i ) ) { continu ; } ( header = = null ) { header = method i ; } els { header = , method i ; } } } } re . set statu ( 405 ) ; re . add header ( allow , header ) ; re . set messag ( trace method allow ) ; return fals ; } possibl redirect messag byte redirect path mb = request . get map data ( ) . redirect path ; ( redirect path mb . null ( ) ) { string redirect path = url encod . encod ( redirect path mb . string ( ) ) ; string queri = request . get queri string ( ) ; ( request . request session id from url ( ) ) { thi optim , thi veri common , shouldn t matter redirect path = redirect path ; global . session paramet name = request . get request session id ( ) ; } ( queri = null ) { thi optim , thi veri common , shouldn t matter redirect path = redirect path queri ; } respons . send redirect ( redirect path ) ; return fals ; } pars session id pars session cooki id ( req , request ) ; return true ; }

privat void add inject target ( inject resourc , map string , map string , string >> inject map ) { list inject target inject target = resourc . get inject target ( ) ; ( inject target = null inject target . size ( ) 0 ) { string jndi name = resourc . get name ( ) ; ( inject target inject target : inject target ) { string clazz = inject target . get target class ( ) ; map string , string inject = inject map . get ( clazz ) ; ( inject = = null ) { inject = new hash map string , string ( ) ; inject map . put ( clazz , inject ) ; } inject . put ( inject target . get target name ( ) , jndi name ) ; } } }	privat void process cach ( file tld cach ) throw ioexcept { read cach return ; try { file input stream = new file input stream ( tld cach ) ; object input stream oi = new object input stream ( ) ; string list = ( string ) oi . read object ( ) ; ( log . debug enabl ( ) ) log . debug ( reus tld cach tld cach list . length ) ; ( int i = 0 ; list = null i list . length ; i ) { context . add applic listen ( list i ) ; } oi . close ( ) ; } catch ( class found except ex ) { ex . print stack trace ( ) ; } }	privat return map path all jar file ar access webapp scan tld . map alwai includ all jar under web inf lib , well share jar classload deleg chain webapp s classload . latter constitut tomcat specif extens tld search order defin jsp spec . allow tag librari packag jar file share web applic simpli drop them locat all web applic have access ( e . g . , catalina home common lib ) . set share jar scan tld narrow down tt tld jar tt class variabl , which contain name jar ar known contain ani tld . return map jar file path map string , file get jar path ( ) { hash map string , file jar path map = null ; class loader webapp loader = thread . current thread ( ) . get context class loader ( ) ; class loader loader = webapp loader ; while ( loader = null ) { ( loader instanceof urlclass loader ) { url url = ( ( urlclass loader ) loader ) . get url ( ) ; ( int i = 0 ; i url . length ; i ) { check url us file protocol , els ignor ( file . equal ( url i . get protocol ( ) ) ) { continu ; } file file = null ; try { file = new file ( url i . uri ( ) ) ; } catch ( urisyntax except e ) { ignor , probabl unencod char file = new file ( url i . get file ( ) ) ; } try { file = file . get canon file ( ) ; } catch ( ioexcept e ) { ignor } ( file . exist ( ) ) { continu ; } string path = file . get absolut path ( ) ; ( path . end ( . jar ) ) { continu ; } scan all jar from web inf lib , plu ani share jar ar known contain ani tld ( loader = = webapp loader tld jar = = null tld jar . contain ( file . get name ( ) ) ) { ( jar path map = = null ) { jar path map = new hash map string , file ( ) ; jar path map . put ( path , file ) ; } els ( jar path map . contain kei ( path ) ) { jar path map . put ( path , file ) ; } } } } loader = loader . get parent ( ) ; } return jar path map ; }	privat scan tld content specifi input stream , regist ani applic event listen found . b note b respons caller close input stream after thi method return . param resourc stream input stream contain tag librari descriptor except except except occur while scan thi tld void tld scan stream ( input sourc resourc stream ) throw except { ( tld digest = = null ) { tld digest = creat tld digest ( ) ; } synchron ( tld digest ) { try { tld digest . push ( thi ) ; tld digest . pars ( resourc stream ) ; } final { tld digest . reset ( ) ; } } }	privat map string , map string , string >> build inject map ( name resourc name resourc ) { map string , map string , string >> inject map = new hash map string , map string , string >> ( ) ; ( inject resourc : name resourc . find local ejb ( ) ) { add inject target ( resourc , inject map ) ; } ( inject resourc : name resourc . find ejb ( ) ) { add inject target ( resourc , inject map ) ; } ( inject resourc : name resourc . find environ ( ) ) { add inject target ( resourc , inject map ) ; } ( inject resourc : name resourc . find messag destin ref ( ) ) { add inject target ( resourc , inject map ) ; } ( inject resourc : name resourc . find resourc env ref ( ) ) { add inject target ( resourc , inject map ) ; } ( inject resourc : name resourc . find resourc ( ) ) { add inject target ( resourc , inject map ) ; } ( inject resourc : name resourc . find servic ( ) ) { add inject target ( resourc , inject map ) ; } return inject map ; }	public void init ( ) throw except { ( thi . get parent ( ) = = null ) { object name parent name = get parent name ( ) ; ( mserver . regist ( parent name ) ) { ( log . debug enabl ( ) ) log . debug ( host , creat parent name ) ; standard host host = new standard host ( ) ; host . set name ( host name ) ; host . set auto deploi ( fals ) ; registri . get registri ( null , null ) . regist compon ( host , parent name , null ) ; we could do hard wai . . . mserver . invok ( parent name , init , new object { } , new string { } ) ; same thing easier : host . init ( ) ; } add main configur listen lifecycl listen config = null ; try { string config class name = null ; try { config class name = string . valu ( mserver . get attribut ( parent name , config class ) ) ; } catch ( attribut found except e ) { ignor , s normal host mai have thi option attribut } ( config class name = null ) { class clazz = class . name ( config class name ) ; config = ( lifecycl listen ) clazz . new instanc ( ) ; } els { config = new context config ( ) ; } } catch ( except e ) { log . warn ( error creat context config parent name , e ) ; throw e ; } thi . add lifecycl listen ( config ) ; ( log . debug enabl ( ) ) { log . debug ( add child parent name thi ) ; } try { mserver . invok ( parent name , add child , new object { thi } , new string { org . apach . catalina . contain } ) ; } catch ( except e ) { destroi ( ) ; throw e ; } s possibl add child mai have start us ( initi ) { return ; } } super . init ( ) ; notifi our interest lifecycl listen lifecycl . fire lifecycl event ( init event , null ) ; send j2ee . state . start notif ( thi . get object name ( ) = null ) { notif notif = new notif ( j2ee . state . start , thi . get object name ( ) , sequenc number ) ; broadcast . send notif ( notif ) ; } }
public main file get file ( ) { return file ; }	public write messag file . ( msg . get messag number ( ) = = msg . get total nr msg ( ) ) output stream close after write . param msg file messag messag contain data written throw illeg argument except factori open read close throw ioexcept file write error occur return return true file complet outputstream close , fals otherwis . boolean write messag ( file messag msg ) throw illeg argument except , ioexcept { ( open write ) throw new illeg argument except ( can t write messag , thi factori read . ) ; ( log . debug enabl ( ) ) log . debug ( messag msg data msg . get data ( ) data length msg . get data length ( ) out out ) ; ( out = null ) { out . write ( msg . get data ( ) , 0 , msg . get data length ( ) ) ; nr messag process ; out . flush ( ) ; ( msg . get messag number ( ) = = msg . get total nr msg ( ) ) { out . close ( ) ; cleanup ( ) ; return true ; } end } els { ( log . warn enabl ( ) ) log . warn ( receiv messag again sender act timeout short path : msg . get context path ( ) war : msg . get file name ( ) data : msg . get data ( ) data length : msg . get data length ( ) ) ; } return fals ; }	public close factori , stream set all refer null void cleanup ( ) { ( = null ) try { . close ( ) ; } catch ( except ignor ) { } ( out = null ) try { out . close ( ) ; } catch ( except ignor ) { } = null ; out = null ; size = 0 ; close = true ; data = null ; nr messag process = 0 ; total nr messag = 0 ; }	public logic void start ( ) throw except { ( start ) return ; get cluster ( ) . add cluster listen ( thi ) ; ( watch enabl ) { watcher = new war watcher ( thi , new file ( get watch dir ( ) ) ) ; ( log . info enabl ( ) ) log . info ( cluster deploy watch get watch dir ( ) chang . ) ; } check correct engin host setup object parent = get cluster ( ) . get contain ( ) ; engin engin = null ; string hostnam = null ; ( parent instanceof host ) { host = ( host ) parent ; engin = ( engin ) host . get parent ( ) ; hostnam = host . get name ( ) ; } els { engin = ( engin ) parent ; hostnam = engin . get default host ( ) ; } try { onam = new object name ( engin . get name ( ) : type = deploy , host = hostnam ) ; } catch ( except e ) { log . error ( can t construct mbean object name e ) ; } config base = new file ( system . get properti ( catalina . base ) , conf ) ; ( engin = null ) { config base = new file ( config base , engin . get name ( ) ) ; } els ( host = null ) { config base = new file ( config base , host . get name ( ) ) ; } retriev mbean server m bean server = registri . get registri ( null , null ) . get mbean server ( ) ; start = true ; count = 0 ; ( log . info enabl ( ) ) log . info ( cluster farm war deploy start . ) ; }
public void append head ( respons re ) throw ioexcept { ( log . debug enabl ( ) ) log . debug ( commit send header re re . get mime header ( ) ) ; c2bconvert c2b = mc . get convert ( ) ; output msg . reset ( ) ; output msg . append byte ( ajp constant . jk ajp13 send header ) ; output msg . append int ( re . get statu ( ) ) ; string messag = null ; ( org . apach . coyot . constant . us custom statu msg header ) { messag = re . get messag ( ) ; } ( messag = = null ) { messag = http messag . get messag ( re . get statu ( ) ) ; } els { messag = messag . replac ( n , ) . replac ( r , ) ; } temp mb . set string ( messag ) ; c2b . convert ( temp mb ) ; output msg . append byte ( temp mb ) ; xxx add header mime header header = re . get mime header ( ) ; string content type = re . get content type ( ) ; ( content type = null ) { header . set valu ( content type ) . set string ( content type ) ; } string content languag = re . get content languag ( ) ; ( content languag = null ) { header . set valu ( content languag ) . set string ( content languag ) ; } long content length = re . get content length long ( ) ; ( content length = 0 ) { header . set valu ( content length ) . set long ( content length ) ; } int num header = header . size ( ) ; output msg . append int ( num header ) ; ( int i = 0 ; i num header ; i ) { messag byte h n = header . get name ( i ) ; header sc convers s littl benefit thi direct c2b . convert ( h n ) ; output msg . append byte ( h n ) ; messag byte h v = header . get valu ( i ) ; c2b . convert ( h v ) ; output msg . append byte ( h v ) ; } mc . get sourc ( ) . send ( output msg , mc ) ; }
protect serv specifi resourc , option includ data content . param request servlet request we ar process param respons servlet respons we ar creat param content should content includ except ioexcept input output error occur except servlet except servlet specifi error occur void serv resourc ( http servlet request request , http servlet respons respons , boolean content ) throw ioexcept , servlet except { identifi request resourc path string path = get rel path ( request ) ; ( debug 0 ) { ( content ) log ( default servlet . serv resourc : serv resourc path header data ) ; els log ( default servlet . serv resourc : serv resourc path header onli ) ; } cach entri cach entri = resourc . lookup cach ( path ) ; ( cach entri . exist ) { check we re includ so we can return appropri miss resourc name error string request uri = ( string ) request . get attribut ( global . includ request uri attr ) ; ( request uri = = null ) { request uri = request . get request uri ( ) ; } els { we re includ , respons . send error ( ) below go ignor resourc includ us . therefor , onli wai we can let includ resourc know includ warn messag respons respons . get writer ( ) . write ( sm . get string ( default servlet . miss resourc , request uri ) ) ; } respons . send error ( http servlet respons . sc found , request uri ) ; return ; } end , return found ( cach entri . context = = null ) { ( path . end ( ) ( path . end ( ) ) ) { check we re includ so we can return appropri miss resourc name error string request uri = ( string ) request . get attribut ( global . includ request uri attr ) ; ( request uri = = null ) { request uri = request . get request uri ( ) ; } respons . send error ( http servlet respons . sc found , request uri ) ; return ; } } satisfi . ( cach entri . context = = null ) { check header boolean includ = ( request . get attribut ( global . includ context path attr ) = null ) ; ( includ check header ( request , respons , cach entri . attribut ) ) { return ; } } find content type . string content type = cach entri . attribut . get mime type ( ) ; ( content type = = null ) { content type = get servlet context ( ) . get mime type ( cach entri . name ) ; cach entri . attribut . set mime type ( content type ) ; } arrai list rang rang = null ; long content length = 1l ; ( cach entri . context = null ) { suppress them ( list ) { respons . send error ( http servlet respons . sc found , request . get request uri ( ) ) ; return ; } content type = text html ; charset = utf 8 ; } els { pars rang specifi rang = pars rang ( request , respons , cach entri . attribut ) ; etag header respons . set header ( etag , get etag ( cach entri . attribut ) ) ; last modifi header respons . set header ( last modifi , cach entri . attribut . get last modifi http ( ) ) ; get content length content length = cach entri . attribut . get content length ( ) ; ( silent ) when set output buffer size ( content length = = 0l ) { content = fals ; } } servlet output stream ostream = null ; print writer writer = null ; ( content ) { try retriev servlet output stream try { ostream = respons . get output stream ( ) ; } catch ( illeg state except e ) { try serv text file ( ( content type = = null ) ( content type . start ( text ) ) ( content type . end ( xml ) ) ) { writer = respons . get writer ( ) ; } els { throw e ; } } } ( ( cach entri . context = null ) ( ( ( rang = = null ) ( rang . empti ( ) ) ) ( request . get header ( rang ) = = null ) ) ( rang = = full ) ) { set appropri output header ( content type = null ) { ( debug 0 ) log ( default servlet . serv file : content type = content type ) ; respons . set content type ( content type ) ; } ( ( cach entri . resourc = null ) ( content length = 0 ) ) { ( debug 0 ) log ( default servlet . serv file : content length = content length ) ; ( content length integ . max valu ) { respons . set content length ( ( int ) content length ) ; } els { set content length string abl us long respons . set header ( content length , content length ) ; } } input stream render result = null ; ( cach entri . context = null ) { ( content ) { serv directori browser render result = render ( request . get context path ( ) , cach entri ) ; } } copi input stream our output stream ( request ) ( content ) { try { respons . set buffer size ( output ) ; } catch ( illeg state except e ) { silent catch } ( ostream = null ) { ( check sendfil ( request , respons , cach entri , content length , null ) ) copi ( cach entri , render result , ostream ) ; } els { copi ( cach entri , render result , writer ) ; } } } els { ( ( rang = = null ) ( rang . empti ( ) ) ) return ; partial content respons . respons . set statu ( http servlet respons . sc partial content ) ; ( rang . size ( ) = = 1 ) { rang rang = rang . get ( 0 ) ; respons . add header ( content rang , byte rang . start rang . end rang . length ) ; long length = rang . end rang . start 1 ; ( length integ . max valu ) { respons . set content length ( ( int ) length ) ; } els { set content length string abl us long respons . set header ( content length , length ) ; } ( content type = null ) { ( debug 0 ) log ( default servlet . serv file : content type = content type ) ; respons . set content type ( content type ) ; } ( content ) { try { respons . set buffer size ( output ) ; } catch ( illeg state except e ) { silent catch } ( ostream = null ) { ( check sendfil ( request , respons , cach entri , rang . end rang . start 1 , rang ) ) copi ( cach entri , ostream , rang ) ; } els { copi ( cach entri , writer , rang ) ; } } } els { respons . set content type ( multipart byterang ; boundari = mime separ ) ; ( content ) { try { respons . set buffer size ( output ) ; } catch ( illeg state except e ) { silent catch } ( ostream = null ) { copi ( cach entri , ostream , rang . iter ( ) , content type ) ; } els { copi ( cach entri , writer , rang . iter ( ) , content type ) ; } } } } }	public initi thi servlet . void init ( ) throw servlet except { ( get servlet config ( ) . get init paramet ( debug ) = null ) debug = integ . pars int ( get servlet config ( ) . get init paramet ( debug ) ) ; ( get servlet config ( ) . get init paramet ( input ) = null ) input = integ . pars int ( get servlet config ( ) . get init paramet ( input ) ) ; ( get servlet config ( ) . get init paramet ( output ) = null ) output = integ . pars int ( get servlet config ( ) . get init paramet ( output ) ) ; list = boolean . pars boolean ( get servlet config ( ) . get init paramet ( list ) ) ; ( get servlet config ( ) . get init paramet ( readonli ) = null ) read onli = boolean . pars boolean ( get servlet config ( ) . get init paramet ( readonli ) ) ; ( get servlet config ( ) . get init paramet ( sendfil size ) = null ) sendfil size = integ . pars int ( get servlet config ( ) . get init paramet ( sendfil size ) ) 1024 ; file encod = get servlet config ( ) . get init paramet ( file encod ) ; global xslt file = get servlet config ( ) . get init paramet ( global xslt file ) ; local xslt file = get servlet config ( ) . get init paramet ( local xslt file ) ; readm file = get servlet config ( ) . get init paramet ( readm file ) ; saniti check specifi buffer size ( input 256 ) input = 256 ; ( output 256 ) output = 256 ; ( debug 0 ) { log ( default servlet . init : input buffer size = input , output buffer size = output ) ; } load proxi dir context . resourc = ( proxi dir context ) get servlet context ( ) . get attribut ( global . resourc attr ) ; ( resourc = = null ) { try { resourc = ( proxi dir context ) new initi context ( ) . lookup ( resourc jndi name ) ; } catch ( name except e ) { fail throw new servlet except ( resourc , e ) ; } } ( resourc = = null ) { throw new unavail except ( resourc ) ; } }
privat void do includ ( servlet request request , servlet respons respons ) throw servlet except , ioexcept { set up handl specifi request respons state state = new state ( request , respons , true ) ; ( global . strict servlet complianc ) { check srv . 8 . 2 srv . 14 . 2 . 5 . 1 complianc check same object ( request , respons ) ; } creat wrap respons us thi request wrap respons ( state ) ; handl http name dispatch includ ( name = null ) { applic http request wrequest = ( applic http request ) wrap request ( state ) ; wrequest . set attribut ( global . name dispatch attr , name ) ; ( servlet path = null ) wrequest . set servlet path ( servlet path ) ; wrequest . set attribut ( applic filter factori . dispatch type attr , integ . valu ( applic filter factori . includ ) ) ; wrequest . set attribut ( applic filter factori . dispatch request path attr , servlet path ) ; invok ( state . outer request , state . outer respons , state ) ; } els handl http path base includ { applic http request wrequest = ( applic http request ) wrap request ( state ) ; string context path = context . get path ( ) ; ( request uri = null ) wrequest . set attribut ( global . includ request uri attr , request uri ) ; ( context path = null ) wrequest . set attribut ( global . includ context path attr , context path ) ; ( servlet path = null ) wrequest . set attribut ( global . includ servlet path attr , servlet path ) ; ( path info = null ) wrequest . set attribut ( global . includ path info attr , path info ) ; ( queri string = null ) { wrequest . set attribut ( global . includ queri string attr , queri string ) ; wrequest . set queri param ( queri string ) ; } wrequest . set attribut ( applic filter factori . dispatch type attr , integ . valu ( applic filter factori . includ ) ) ; wrequest . set attribut ( applic filter factori . dispatch request path attr , servlet path ) ; invok ( state . outer request , state . outer respons , state ) ; } }	privat prepar request base filter configur . param request servlet request we ar process param respons servlet respons we ar creat param state rd state except ioexcept input output error occur except servlet except servlet error occur void process request ( servlet request request , servlet respons respons , state state ) throw ioexcept , servlet except { integ di int = ( integ ) request . get attribut ( applic filter factori . dispatch type attr ) ; ( di int = null ) { ( di int . int valu ( ) = applic filter factori . error ) { state . outer request . set attribut ( applic filter factori . dispatch request path attr , servlet path ) ; state . outer request . set attribut ( applic filter factori . dispatch type attr , integ . valu ( applic filter factori . forward ) ) ; invok ( state . outer request , respons , state ) ; } els { invok ( state . outer request , respons , state ) ; } } }
protect access log element creat log element ( ) { list access log element list = new arrai list access log element ( ) ; boolean replac = fals ; string buffer buf = new string buffer ( ) ; ( int i = 0 ; i pattern . length ( ) ; i ) { char ch = pattern . char ( i ) ; ( replac ) { code process { , behavior . . . i do enount close } i ignor { ( { = = ch ) { string buffer name = new string buffer ( ) ; int j = i 1 ; ( ; j pattern . length ( ) } = pattern . char ( j ) ; j ) { name . append ( pattern . char ( j ) ) ; } ( j 1 pattern . length ( ) ) { 1 wa account } which we increment now j ; list . add ( creat access log element ( name . string ( ) , pattern . char ( j ) ) ) ; i = j ; sinc we walk more than charact } els { d oh end string pretend we never did thi do process old wai list . add ( creat access log element ( ch ) ) ; } } els { list . add ( creat access log element ( ch ) ) ; } replac = fals ; } els ( ch = = ) { replac = true ; list . add ( new string element ( buf . string ( ) ) ) ; buf = new string buffer ( ) ; } els { buf . append ( ch ) ; } } ( buf . length ( ) 0 ) { list . add ( new string element ( buf . string ( ) ) ) ; } return ( access log element ) list . arrai ( new access log element 0 ) ; }
public void final ( ) { try { disconnect ( ) ; } catch ( except ignor ) { } }

public return code true code all requir extens depend have been meet thi code manifest resourc code object . return boolean true all extens depend have been satisfi boolean fulfil ( ) { ( requir extens = = null ) { return fals ; } iter = requir extens . iter ( ) ; while ( . ha next ( ) ) { extens ext = ( extens ) . next ( ) ; ( ext . fulfil ( ) ) return fals ; } return true ; }
public void includ ( string rel url path , boolean flush ) throw servlet except , ioexcept { xxx includ ( rel url path , fals ) ; }
public final function namespac : name ( , b , c ) void function ( ) throw pars except { bgen ( jjtree ) function ast function jjtn000 = new ast function ( jjtfunction ) ; boolean jjtc000 = true ; jjtree . open node scope ( jjtn000 ) ; token t0 = null ; token t1 = null ; try { switch ( ( jj ntk = = 1 ) jj ntk ( ) : jj ntk ) { case identifi : t0 = jj consum token ( identifi ) ; jj consum token ( colon ) ; break ; default : jj la1 30 = jj gen ; ; } t1 = jj consum token ( identifi ) ; ( t0 = null ) { jjtn000 . set prefix ( t0 . imag . substr ( 0 , t0 . imag . length ( ) 1 ) ) ; jjtn000 . set local name ( t1 . imag ) ; } els { jjtn000 . set local name ( t1 . imag ) ; } jj consum token ( lparen ) ; switch ( ( jj ntk = = 1 ) jj ntk ( ) : jj ntk ) { case integ liter : case float point liter : case string liter : case true : case fals : case null : case lparen : case not0 : case not1 : case empti : case minu : case identifi : express ( ) ; label 10 : while ( true ) { switch ( ( jj ntk = = 1 ) jj ntk ( ) : jj ntk ) { case comma : ; break ; default : jj la1 31 = jj gen ; break label 10 ; } jj consum token ( comma ) ; express ( ) ; } break ; default : jj la1 32 = jj gen ; ; } jj consum token ( rparen ) ; } catch ( throwabl jjte000 ) { ( jjtc000 ) { jjtree . clear node scope ( jjtn000 ) ; jjtc000 = fals ; } els { jjtree . pop node ( ) ; } ( jjte000 instanceof runtim except ) { { ( true ) throw ( runtim except ) jjte000 ; } } ( jjte000 instanceof pars except ) { { ( true ) throw ( pars except ) jjte000 ; } } { ( true ) throw ( error ) jjte000 ; } } final { ( jjtc000 ) { jjtree . close node scope ( jjtn000 , true ) ; } } }
privat add thi node bodi given parent . void add parent ( node parent ) { ( parent = null ) { thi . parent = parent ; node parent bodi = parent . get bodi ( ) ; ( parent bodi = = null ) { parent bodi = new node ( ) ; parent . set bodi ( parent bodi ) ; } parent bodi . add ( thi ) ; } }	public return enclos root thi root . usual repres page includ thi . root get parent root ( ) { return parent root ; }	public return uniqu temporari variabl name store result . ( thi probabl could go elsewher , s conveni here ) string get temporari variabl name ( ) { ( temporari variabl name = = null ) { temporari variabl name = jsp util . next temporari variabl name ( ) ; } return temporari variabl name ; }	public string get temporari variabl name ( ) { return jsp util . next temporari variabl name ( ) ; }	public static valid syntax all { } express within given string . param where approxim locat express jsp page param express string contain zero more { } express param err error dispatch us deprec now deleg org . apach . el packag void valid express ( mark where , string express , class expect type , function mapper function mapper , error dispatch err ) throw jasper except { try { jsp util . express evalu . pars express ( express , expect type , function mapper ) ; } catch ( elpars except e ) { err . jsp error ( where , jsp . error . invalid . express , express , e . string ( ) ) ; } catch ( elexcept e ) { err . jsp error ( where , jsp . error . invalid . express , express , e . string ( ) ) ; } }	protect string gener java ( ) throw except { string smap str = null ; long t1 , t2 , t3 , t4 ; t1 = t2 = t3 = t4 = 0 ; ( log . debug enabl ( ) ) { t1 = system . current time milli ( ) ; } setup page info area page info = new page info ( new bean repositori ( ctxt . get class loader ( ) , err dispatch ) , ctxt . get jsp file ( ) ) ; jsp config jsp config = option . get jsp config ( ) ; jsp config . jsp properti jsp properti = jsp config . find jsp properti ( ctxt . get jsp file ( ) ) ; current uri match pattern specifi jsp properti group web . xml , initi page info those properti . ( jsp properti . elignor ( ) = null ) { page info . set elignor ( jsp util . boolean valu ( jsp properti . elignor ( ) ) ) ; } ( jsp properti . script invalid ( ) = null ) { page info . set script invalid ( jsp util . boolean valu ( jsp properti . script invalid ( ) ) ) ; } ( jsp properti . get includ prelud ( ) = null ) { page info . set includ prelud ( jsp properti . get includ prelud ( ) ) ; } ( jsp properti . get includ coda ( ) = null ) { page info . set includ coda ( jsp properti . get includ coda ( ) ) ; } ( jsp properti . defer syntax allow liter ( ) = null ) { page info . set defer syntax allow liter ( jsp util . boolean valu ( jsp properti . defer syntax allow liter ( ) ) ) ; } ( jsp properti . trim direct whitespac ( ) = null ) { page info . set trim direct whitespac ( jsp util . boolean valu ( jsp properti . trim direct whitespac ( ) ) ) ; } ctxt . check output dir ( ) ; string java file name = ctxt . get servlet java file name ( ) ; servlet writer writer = null ; try { reset temporari variabl counter gener . jsp util . reset temporari variabl name ( ) ; pars file parser control parser ctl = new parser control ( ctxt , thi ) ; page node = parser ctl . pars ( ctxt . get jsp file ( ) ) ; ( ctxt . prototyp mode ( ) ) { gener prototyp . java file tag file writer = setup context writer ( java file name ) ; gener . gener ( writer , thi , page node ) ; writer . close ( ) ; writer = null ; return null ; } valid process attribut valid . valid ( thi , page node ) ; ( log . debug enabl ( ) ) { t2 = system . current time milli ( ) ; } collect page info collector . collect ( thi , page node ) ; compil ( necessari ) load tag file referenc thi compil unit . tfp = new tag file processor ( ) ; tfp . load tag file ( thi , page node ) ; ( log . debug enabl ( ) ) { t3 = system . current time milli ( ) ; } determin which custom tag need declar which script var script variabl . set ( page node , err dispatch ) ; optim tag plugin tag plugin manag tag plugin manag = option . get tag plugin manag ( ) ; tag plugin manag . appli ( page node , err dispatch , page info ) ; optim : concaten contigu templat text . text optim . concaten ( thi , page node ) ; gener static function mapper code . elfunct mapper . map ( thi , page node ) ; gener servlet . java file writer = setup context writer ( java file name ) ; gener . gener ( writer , thi , page node ) ; writer . close ( ) ; writer = null ; writer onli us dure compil , derefer jsp compil context when done allow gc d save memori . ctxt . set writer ( null ) ; ( log . debug enabl ( ) ) { t4 = system . current time milli ( ) ; log . debug ( gener java file name total = ( t4 t1 ) gener = ( t4 t3 ) valid = ( t2 t1 ) ) ; } } catch ( except e ) { ( writer = null ) { try { writer . close ( ) ; writer = null ; } catch ( except e1 ) { do noth } } remov gener . java file new file ( java file name ) . delet ( ) ; throw e ; } final { ( writer = null ) { try { writer . close ( ) ; } catch ( except e2 ) { do noth } } } jsr45 support ( option . smap suppress ( ) ) { smap str = smap util . gener smap ( ctxt , page node ) ; } ani proto type . java . class file wa gener , prototyp . java mai have been replac current compil ( tag file self referenc ) , . class file need remov , make sure javac would gener . class again from new . java file just gener . tfp . remov proto type file ( ctxt . get class file name ( ) ) ; return smap str ; }
public void set max keep aliv request ( int mkar ) { max keep aliv request = mkar ; }
public void lifecycl event ( lifecycl event event ) { ( lifecycl . init event . equal ( event . get type ( ) ) ) { apr initi = init ( ) ; ( apr initi ) { try { initi ssl ( ) ; } catch ( throwabl t ) { ( log . debug enabl ( ) ) { log . info ( sm . get string ( apr listen . ssl init ) ) ; } els { log . debug ( sm . get string ( apr listen . ssl init ) ) ; } } } } els ( lifecycl . after stop event . equal ( event . get type ( ) ) ) { ( apr initi ) { return ; } try { termin apr ( ) ; } catch ( throwabl t ) { ( log . debug enabl ( ) ) { log . info ( sm . get string ( apr listen . apr destroi ) ) ; } els { log . debug ( sm . get string ( apr listen . apr destroi ) , t ) ; } } } }
public initi endpoint . void init ( ) throw except { ( initi ) return ; creat root apr memori pool root pool = pool . creat ( 0 ) ; creat pool server socket server sock pool = pool . creat ( root pool ) ; creat apr address bound string address str = null ; ( address = = null ) { address str = null ; } els { address str = address . get host address ( ) ; } int famili = socket . apr inet ; ( librari . apr have ipv6 ) { ( address str = = null ) { ( os . bsd os . win32 os . win64 ) famili = socket . apr unspec ; } els ( address str . index ( : ) = 0 ) { famili = socket . apr unspec ; } } long inet address = address . info ( address str , famili , port , 0 , root pool ) ; creat apr server socket server sock = socket . creat ( famili , socket . sock stream , socket . apr proto tcp , root pool ) ; ( os . unix ) { socket . opt set ( server sock , socket . apr so reuseaddr , 1 ) ; } deal firewal tend drop inact socket socket . opt set ( server sock , socket . apr so keepal , 1 ) ; bind server socket int ret = socket . bind ( server sock , inet address ) ; ( ret = 0 ) { throw new except ( sm . get string ( endpoint . init . bind , ret , error . strerror ( ret ) ) ) ; } start listen server socket ret = socket . listen ( server sock , backlog ) ; ( ret = 0 ) { throw new except ( sm . get string ( endpoint . init . listen , ret , error . strerror ( ret ) ) ) ; } ( os . win32 os . win64 ) { window set reuseaddr flag after bind listen socket . opt set ( server sock , socket . apr so reuseaddr , 1 ) ; } sendfil usag system which don t support caus major problem ( us sendfil librari . apr ha sendfil ) { us sendfil = fals ; } initi thread count default acceptor , poller sendfil ( acceptor thread count = = 0 ) { fixm : doesn t seem work well multipl accept thread acceptor thread count = 1 ; } ( poller thread count = = 0 ) { ( ( os . win32 os . win64 ) ( poller size 1024 ) ) { maximum per poller get reason perform 1024 poller thread count = poller size 1024 ; adjust poller size so won t reach limit poller size = poller size ( poller size 1024 ) ; } els { explicit poller size limit poller thread count = 1 ; } } ( sendfil thread count = = 0 ) { ( ( os . win32 os . win64 ) ( sendfil size 1024 ) ) { maximum per poller get reason perform 1024 sendfil thread count = sendfil size 1024 ; adjust poller size so won t reach limit sendfil size = sendfil size ( sendfil size 1024 ) ; } els { explicit poller size limit fixm : default per cpu sendfil thread count = 1 ; } } other platform thi call noop return apr enotimpl . ( socket . opt set ( server sock , socket . apr tcp defer accept , 1 ) = = statu . apr enotimpl ) { defer accept = fals ; } initi ssl need ( sslenabl ) { ssl protocol int valu = ssl . ssl protocol all ; ( sslv2 . equal ignor case ( sslprotocol ) ) { valu = ssl . ssl protocol sslv2 ; } els ( sslv3 . equal ignor case ( sslprotocol ) ) { valu = ssl . ssl protocol sslv3 ; } els ( tlsv1 . equal ignor case ( sslprotocol ) ) { valu = ssl . ssl protocol tlsv1 ; } els ( sslv2 sslv3 . equal ignor case ( sslprotocol ) ) { valu = ssl . ssl protocol sslv2 ssl . ssl protocol sslv3 ; } creat ssl context ssl context = sslcontext . make ( root pool , valu , ssl . ssl mode server ) ; list cipher client permit negoti sslcontext . set cipher suit ( ssl context , sslcipher suit ) ; load server kei certif sslcontext . set certif ( ssl context , sslcertif file , sslcertif kei file , sslpassword , ssl . ssl aidx rsa ) ; set certif chain file sslcontext . set certif chain file ( ssl context , sslcertif chain file , fals ) ; support client certif sslcontext . set cacertif ( ssl context , sslcacertif file , sslcacertif path ) ; set revoc sslcontext . set carevoc ( ssl context , sslcarevoc file , sslcarevoc path ) ; client certif verif valu = ssl . ssl cverifi none ; ( option . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi option ; } els ( requir . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi requir ; } els ( option ca . equal ignor case ( sslverifi client ) ) { valu = ssl . ssl cverifi option ca ; } sslcontext . set verifi ( ssl context , valu , sslverifi depth ) ; now , sendfil support ssl us sendfil = fals ; } initi = true ; }
protect string replac ( string str ) { string result = str ; int po start = result . index ( { ) ; ( po start = 1 ) { int po end = result . index ( } ) ; ( po end = 1 ) { string prop name = result . substr ( po start 2 , po end ) ; string replac = system . get properti ( prop name ) ; ( replac = null ) { ( po start 0 ) { result = result . substr ( 0 , po start ) replac replac ( result . substr ( po end 1 ) ) ; } els { result = replac replac ( result . substr ( po end 1 ) ) ; } } } } return result ; }	retriev configur associ specifi classload . doe exist , creat . param class loader classload which we retriev build configur protect class loader log info get class loader info ( class loader class loader ) { ( class loader = = null ) { class loader = class loader . get system class loader ( ) ; } class loader log info info = ( class loader log info ) class loader logger . get ( class loader ) ; ( info = = null ) { final class loader class loader param = class loader ; access control . do privileg ( new privileg action ( ) { } } }	protect load specifi configur . param input stream properti file param class loader which configur load throw ioexcept someth wrong happen dure load void read configur ( input stream , class loader class loader ) throw ioexcept { class loader log info info = ( class loader log info ) class loader logger . get ( class loader ) ; try { info . prop . load ( ) ; } catch ( ioexcept e ) { report error system . err . println ( configur error ) ; e . print stack trace ( ) ; } final { try { . close ( ) ; } catch ( throwabl t ) { } } creat handler root logger thi classload string root handler = info . prop . get properti ( . handler ) ; string handler = info . prop . get properti ( handler ) ; logger local root logger = info . root node . logger ; ( handler = null ) { string token tok = new string token ( handler , , ) ; while ( tok . ha more token ( ) ) { string handler name = ( tok . next token ( ) . trim ( ) ) ; string handler class name = handler name ; string prefix = ; ( handler class name . length ( ) = 0 ) { continu ; } 10webapp foo hanlder . ) ( charact . digit ( handler class name . char ( 0 ) ) ) { int po = handler class name . index ( . ) ; ( po = 0 ) { prefix = handler class name . substr ( 0 , po 1 ) ; handler class name = handler class name . substr ( po 1 ) ; } } try { thi . prefix . set ( prefix ) ; handler handler = ( handler ) class loader . load class ( handler class name ) . new instanc ( ) ; specif strongli impli all configur should done dure creation handler object . thi includ set level , filter , formatt encod . thi . prefix . set ( null ) ; info . handler . put ( handler name , handler ) ; ( root handler = = null ) { local root logger . add handler ( handler ) ; } } catch ( except e ) { report error system . err . println ( handler error ) ; e . print stack trace ( ) ; } } } }	protect static set parent child relationship between two specifi logger . param logger param parent void do set parent logger ( final logger logger , final logger parent ) { access control . do privileg ( new privileg action ( ) { public object run ( ) { logger . set parent ( parent ) ; return null ; } } ) ; }	public get valu specifi properti classload local configur . param name properti name string get properti ( string name ) { class loader class loader = thread . current thread ( ) . get context class loader ( ) ; string prefix = ( string ) thi . prefix . get ( ) ; ( prefix = null ) { name = prefix name ; } class loader log info info = get class loader info ( class loader ) ; string result = info . prop . get properti ( name ) ; properti . ( ( result = = null ) ( info . prop . empti ( ) ) ) { class loader current = class loader . get parent ( ) ; while ( current = null ) { info = ( class loader log info ) class loader logger . get ( current ) ; ( info = null ) { result = info . prop . get properti ( name ) ; ( ( result = null ) ( info . prop . empti ( ) ) ) { break ; } } current = current . get parent ( ) ; } ( result = = null ) { result = super . get properti ( name ) ; } } simpl properti replac ( mostli folder name ) ( result = null ) { result = replac ( result ) ; } return result ; }	public synchron get enumer logger name current defin classload local configur . enumer string get logger name ( ) { class loader class loader = thread . current thread ( ) . get context class loader ( ) ; return collect . enumer ( get class loader info ( class loader ) . logger . kei set ( ) ) ; }
public alloc initi instanc thi servlet readi have code servic ( ) code method call . servlet class doe implement code singl thread model code , ( onli ) initi instanc mai return immedi . servlet class implement code singl thread model code , wrapper implement must ensur thi instanc alloc again until dealloc call code dealloc ( ) code . except servlet except servlet init ( ) method threw except except servlet except load error occur servlet alloc ( ) throw servlet except { we ar current unload thi servlet , throw except ( unload ) throw new servlet except ( sm . get string ( standard wrapper . unload , get name ( ) ) ) ; boolean new instanc = fals ; singl thread model , return same instanc everi time ( singl thread model ) { load initi our instanc necessari ( instanc = = null ) { synchron ( thi ) { ( instanc = = null ) { try { ( log . debug enabl ( ) ) log . debug ( alloc non stm instanc ) ; instanc = load servlet ( ) ; condit unload . bug 43683 , test case 3 ( singl thread model ) { new instanc = true ; count alloc ; } } catch ( servlet except e ) { throw e ; } catch ( throwabl e ) { throw new servlet except ( sm . get string ( standard wrapper . alloc ) , e ) ; } } } } ( singl thread model ) { ( log . trace enabl ( ) ) log . trace ( return non stm instanc ) ; time creation ( new instanc ) { count alloc ; } return ( instanc ) ; } } synchron ( instanc pool ) { while ( count alloc = n instanc ) { alloc new instanc possibl , els wait ( n instanc max instanc ) { try { instanc pool . push ( load servlet ( ) ) ; n instanc ; } catch ( servlet except e ) { throw e ; } catch ( throwabl e ) { throw new servlet except ( sm . get string ( standard wrapper . alloc ) , e ) ; } } els { try { instanc pool . wait ( ) ; } catch ( interrupt except e ) { ; } } } ( log . trace enabl ( ) ) log . trace ( return alloc stm instanc ) ; count alloc ; return ( servlet ) instanc pool . pop ( ) ; } }	public return number activ alloc thi servlet , even thei ar all same instanc ( true servlet do implement code singl thread model code . int get count alloc ( ) { return ( thi . count alloc ) ; }	synchron unload all initi instanc thi servlet , after call code destroi ( ) code method each instanc . thi can us , exampl , prior shut down entir servlet engin , prior reload all class from loader associ our loader s repositori . except servlet except except thrown destroi ( ) method void unload ( ) throw servlet except { noth do we have never load instanc ( singl thread model ( instanc = = null ) ) return ; unload = true ; ( possibl more than onc non stm ) ( count alloc 0 ) { int n retri = 0 ; long delai = unload delai 20 ; while ( ( n retri 21 ) ( count alloc 0 ) ) { ( ( n retri 10 ) = = 0 ) { log . info ( sm . get string ( standard wrapper . wait , new integ ( count alloc ) ) ) ; } try { thread . sleep ( delai ) ; } catch ( interrupt except e ) { ; } n retri ; } } print stream out = system . out ; ( swallow output ) { system log handler . start captur ( ) ; } call servlet destroi ( ) method try { instanc support . fire instanc event ( instanc event . befor destroi event , instanc ) ; ( global . secur enabl ) { secur util . do privileg ( destroi , instanc ) ; secur util . remov ( instanc ) ; } els { instanc . destroi ( ) ; } instanc support . fire instanc event ( instanc event . after destroi event , instanc ) ; annot process ( ( ( context ) get parent ( ) ) . get ignor annot ( ) ) { ( ( standard context ) get parent ( ) ) . get instanc manag ( ) . destroi instanc ( instanc ) ; } } catch ( throwabl t ) { instanc support . fire instanc event ( instanc event . after destroi event , instanc , t ) ; instanc = null ; instanc pool = null ; n instanc = 0 ; fire contain event ( unload , thi ) ; unload = fals ; throw new servlet except ( sm . get string ( standard wrapper . destroi except , get name ( ) ) , t ) ; } final { write captur output ( swallow output ) { string log = system log handler . stop captur ( ) ; ( log = null log . length ( ) 0 ) { ( get servlet context ( ) = null ) { get servlet context ( ) . log ( log ) ; } els { out . println ( log ) ; } } } } deregist destroi instanc instanc = null ; ( singl thread model ( instanc pool = null ) ) { try { while ( instanc pool . empti ( ) ) { servlet s = ( servlet ) instanc pool . pop ( ) ; ( global . secur enabl ) { secur util . do privileg ( destroi , s ) ; secur util . remov ( instanc ) ; } els { s . destroi ( ) ; } annot process ( ( ( context ) get parent ( ) ) . get ignor annot ( ) ) { ( ( standard context ) get parent ( ) ) . get instanc manag ( ) . destroi instanc ( s ) ; } } } catch ( throwabl t ) { instanc pool = null ; n instanc = 0 ; unload = fals ; fire contain event ( unload , thi ) ; throw new servlet except ( sm . get string ( standard wrapper . destroi except , get name ( ) ) , t ) ; } instanc pool = null ; n instanc = 0 ; } singl thread model = fals ; unload = fals ; fire contain event ( unload , thi ) ; }	public return thi previous alloc servlet pool avail instanc . thi servlet class doe implement singl thread model , action actual requir . param servlet servlet return except servlet except dealloc error occur void dealloc ( servlet servlet ) throw servlet except { singl thread model , action requir ( singl thread model ) { count alloc ; return ; } unlock free thi instanc synchron ( instanc pool ) { count alloc ; instanc pool . push ( servlet ) ; instanc pool . notifi ( ) ; } }
protect return code princip code associ given user name . princip get princip ( string usernam ) { return ( null ) ; }	public return code princip code associ specifi usernam digest , ; otherwis return code null code . param usernam usernam code princip code look up param client digest digest us authent thi usernam param nonc server gener nonc param nc nonc count param cnonc client gener nonc param qop qualiti protect apli messag param realm name realm name param md5a2 second md5 digest us calcul digest md5 ( method : uri ) princip authent ( string usernam , string client digest , string nonc , string nc , string cnonc , string qop , string realm name , string md5a2 ) { return authent ( usernam , new jaascallback handler ( thi , usernam , client digest , nonc , nc , cnonc , qop , realm name , md5a2 ) ) ; }	public return code princip code associ specifi usernam credenti , ; otherwis return code null code . param usernam usernam code princip code look up param credenti password other credenti us authent thi usernam princip authent ( string usernam , string credenti ) { return authent ( usernam , new jaascallback handler ( thi , usernam , credenti ) ) ; }	public phase 1 authent code subject code . return code true code authent succeed , code fals code thi code login modul code should ignor except login except authent fail boolean login ( ) throw login except { set up our callback handler request ( callback handler = = null ) throw new login except ( callback handler specifi ) ; callback callback = new callback 8 ; callback 0 = new name callback ( usernam : ) ; callback 1 = new password callback ( password : , fals ) ; callback 2 = new text input callback ( nonc ) ; callback 3 = new text input callback ( nc ) ; callback 4 = new text input callback ( cnonc ) ; callback 5 = new text input callback ( qop ) ; callback 6 = new text input callback ( realm name ) ; callback 7 = new text input callback ( md5a2 ) ; interact user retriev usernam password string usernam = null ; string password = null ; string nonc = null ; string nc = null ; string cnonc = null ; string qop = null ; string realm name = null ; string md5a2 = null ; try { callback handler . handl ( callback ) ; usernam = ( ( name callback ) callback 0 ) . get name ( ) ; password = new string ( ( ( password callback ) callback 1 ) . get password ( ) ) ; nonc = ( ( text input callback ) callback 2 ) . get text ( ) ; nc = ( ( text input callback ) callback 3 ) . get text ( ) ; cnonc = ( ( text input callback ) callback 4 ) . get text ( ) ; qop = ( ( text input callback ) callback 5 ) . get text ( ) ; realm name = ( ( text input callback ) callback 6 ) . get text ( ) ; md5a2 = ( ( text input callback ) callback 7 ) . get text ( ) ; } catch ( ioexcept e ) { throw new login except ( e . string ( ) ) ; } catch ( unsupport callback except e ) { throw new login except ( e . string ( ) ) ; } valid usernam password we have receiv ( md5a2 = = null ) { us digest princip = super . authent ( usernam , password ) ; } els { must us digest princip = super . authent ( usernam , password , nonc , nc , cnonc , qop , realm name , md5a2 ) ; } log . debug ( login usernam princip ) ; report result base success failur ( princip = null ) { return ( true ) ; } els { throw new fail login except ( usernam password incorrect ) ; } }	public retriev inform request provid code callback code . thi implement onli recogn { link name callback } , { link password callback } { link text input callback } . { link text input callback } u pass variou addit paramet requir digest authent . param callback set code callback code s process except ioexcept input output error occur except unsupport callback except login method request unsupport callback type void handl ( callback callback ) throw ioexcept , unsupport callback except { ( int i = 0 ; i callback . length ; i ) { ( callback i instanceof name callback ) { ( realm . get contain ( ) . get logger ( ) . trace enabl ( ) ) realm . get contain ( ) . get logger ( ) . trace ( sm . get string ( jaa callback . usernam , usernam ) ) ; ( ( name callback ) callback i ) . set name ( usernam ) ; } els ( callback i instanceof password callback ) { final char passwordcont ; ( password = null ) { passwordcont = password . char arrai ( ) ; } els { passwordcont = new char 0 ; } ( ( password callback ) callback i ) . set password ( passwordcont ) ; } els ( callback i instanceof text input callback ) { text input callback cb = ( ( text input callback ) callback i ) ; ( cb . get prompt ( ) . equal ( nonc ) ) { cb . set text ( nonc ) ; } els ( cb . get prompt ( ) . equal ( nc ) ) { cb . set text ( nc ) ; } els ( cb . get prompt ( ) . equal ( cnonc ) ) { cb . set text ( cnonc ) ; } els ( cb . get prompt ( ) . equal ( qop ) ) { cb . set text ( qop ) ; } els ( cb . get prompt ( ) . equal ( realm name ) ) { cb . set text ( realm name ) ; } els ( cb . get prompt ( ) . equal ( md5a2 ) ) { cb . set text ( md5a2 ) ; } els { throw new unsupport callback except ( callback i ) ; } } els { throw new unsupport callback except ( callback i ) ; } } }
protect return short name thi code realm code implement . string get name ( ) { return ( name ) ; }	public return code princip code associ specifi usernam credenti , ; otherwis return code null code . ar ani error jdbc connect , execut queri anyth we return null ( don t authent ) . thi event also log , connect close so subsequ request automat re open . param usernam usernam code princip code look up param credenti password other credenti us authent thi usernam princip authent ( string usernam , string credenti ) { establish login context us authent try { login context login context = null ; ( app name = = null ) app name = tomcat ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . begin login , usernam , app name ) ) ; what login modul contain class loader class loader ocl = null ; ( us context class loader ( ) ) { ocl = thread . current thread ( ) . get context class loader ( ) ; thread . current thread ( ) . set context class loader ( thi . get class ( ) . get class loader ( ) ) ; } try { login context = new login context ( app name , new jaascallback handler ( thi , usernam , credenti ) ) ; } catch ( throwabl e ) { log . error ( sm . get string ( jaa realm . unexpect error ) , e ) ; return ( null ) ; } final { ( us context class loader ( ) ) { thread . current thread ( ) . set context class loader ( ocl ) ; } } ( log . debug enabl ( ) ) log . debug ( login context creat usernam ) ; negoti login via thi login context subject subject = null ; try { login context . login ( ) ; subject = login context . get subject ( ) ; ( subject = = null ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . fail login , usernam ) ) ; return ( null ) ; } } catch ( account expir except e ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . account expir , usernam ) ) ; return ( null ) ; } catch ( credenti expir except e ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . credenti expir , usernam ) ) ; return ( null ) ; } catch ( fail login except e ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . fail login , usernam ) ) ; return ( null ) ; } catch ( login except e ) { log . warn ( sm . get string ( jaa realm . login except , usernam ) , e ) ; return ( null ) ; } catch ( throwabl e ) { log . error ( sm . get string ( jaa realm . unexpect error ) , e ) ; return ( null ) ; } ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . login context creat , usernam ) ) ; return appropri princip thi authent subject princip princip = creat princip ( usernam , subject ) ; ( princip = = null ) { log . debug ( sm . get string ( jaa realm . authent failur , usernam ) ) ; return ( null ) ; } ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jaa realm . authent success , usernam ) ) ; } return ( princip ) ; } catch ( throwabl t ) { log . error ( error , t ) ; return null ; } }	public phase 1 authent code subject code . return code true code authent succeed , code fals code thi code login modul code should ignor except login except authent fail boolean login ( ) throw login except { set up our callback handler request ( callback handler = = null ) throw new login except ( callback handler specifi ) ; callback callback = new callback 2 ; callback 0 = new name callback ( usernam : ) ; callback 1 = new password callback ( password : , fals ) ; interact user retriev usernam password string usernam = null ; string password = null ; try { callback handler . handl ( callback ) ; usernam = ( ( name callback ) callback 0 ) . get name ( ) ; password = new string ( ( ( password callback ) callback 1 ) . get password ( ) ) ; } catch ( ioexcept e ) { throw new login except ( e . string ( ) ) ; } catch ( unsupport callback except e ) { throw new login except ( e . string ( ) ) ; } valid usernam password we have receiv princip = super . authent ( usernam , password ) ; log . debug ( login usernam princip ) ; report result base success failur ( princip = null ) { return ( true ) ; } els { throw new fail login except ( usernam password incorrect ) ; } }	public retriev inform request provid code callback code . thi implement onli recogn code name callback code code password callback code instanc . param callback set code callback code s process except ioexcept input output error occur except unsupport callback except login method request unsupport callback type void handl ( callback callback ) throw ioexcept , unsupport callback except { ( int i = 0 ; i callback . length ; i ) { ( callback i instanceof name callback ) { ( realm . get contain ( ) . get logger ( ) . trace enabl ( ) ) realm . get contain ( ) . get logger ( ) . trace ( sm . get string ( jaa callback . usernam , usernam ) ) ; ( ( name callback ) callback i ) . set name ( usernam ) ; } els ( callback i instanceof password callback ) { final char passwordcont ; ( password = null ) { passwordcont = password . char arrai ( ) ; } els { passwordcont = new char 0 ; } ( ( password callback ) callback i ) . set password ( passwordcont ) ; } els { throw new unsupport callback except ( callback i ) ; } } }	public set list comma delimit class repres individu user . class list must implement code java . secur . princip code . suppli list class pars when { link start ( ) } call . void set user class name ( string user class name ) { thi . user class name = user class name ; }
public void paus ( ) throw except { ( int i = 0 ; i w env . get handler count ( ) ; i ) { ( w env . get handler ( i ) = null ) { w env . get handler ( i ) . paus ( ) ; } } }
protect synchron return password associ given princip s user name . string get password ( string usernam ) { look up user s credenti string db credenti = null ; prepar statement stmt = null ; result set rs = null ; number tri numebr attempt connect databas dure thi login attempt ( we need open databas ) thi need rewritten wuth better pool support , exist code need signatur chang sinc prepar statement need cach connect . code below try twice sqlexcept so connect mai try open again . normal condit ( includ invalid login abov onli us onc . int number tri = 2 ; while ( number tri 0 ) { try { ensur we have open databas connect open ( ) ; try { stmt = credenti ( db connect , usernam ) ; rs = stmt . execut queri ( ) ; ( rs . next ( ) ) { db credenti = rs . get string ( 1 ) ; } rs . close ( ) ; rs = null ; ( db credenti = = null ) { return ( null ) ; } db credenti = db credenti . trim ( ) ; return db credenti ; } final { ( rs = null ) { try { rs . close ( ) ; } catch ( sqlexcept e ) { contain log . warn ( sm . get string ( jdbc realm . abnorm close result set ) ) ; } } db connect . commit ( ) ; } } catch ( sqlexcept e ) { log problem poster contain log . error ( sm . get string ( jdbc realm . except ) , e ) ; close connect so get reopen next time ( db connect = null ) close ( db connect ) ; } number tri ; } return ( null ) ; }
public configur set instanti applic event listen thi context . return code true code all listen wre initi successfulli , code fals code otherwis . boolean listen start ( ) { ( log . debug enabl ( ) ) log . debug ( configur applic event listen ) ; instanti requir listen string listen = find applic listen ( ) ; object result = new object listen . length ; boolean ok = true ; ( int i = 0 ; i result . length ; i ) { ( get logger ( ) . debug enabl ( ) ) get logger ( ) . debug ( configur event listen class listen i ) ; try { result i = instanc manag . new instanc ( listen i ) ; } catch ( throwabl t ) { get logger ( ) . error ( sm . get string ( standard context . applic listen , listen i ) , t ) ; ok = fals ; } } ( ok ) { get logger ( ) . error ( sm . get string ( standard context . applic skip ) ) ; return ( fals ) ; } sort listen two arrai arrai list object event listen = new arrai list object ( ) ; arrai list object lifecycl listen = new arrai list object ( ) ; ( int i = 0 ; i result . length ; i ) { ( ( result i instanceof servlet context attribut listen ) ( result i instanceof servlet request attribut listen ) ( result i instanceof servlet request listen ) ( result i instanceof http session attribut listen ) ) { event listen . add ( result i ) ; } ( ( result i instanceof servlet context listen ) ( result i instanceof http session listen ) ) { lifecycl listen . add ( result i ) ; } } set applic event listen ( event listen . arrai ( ) ) ; set applic lifecycl listen ( lifecycl listen . arrai ( ) ) ; send applic start event ( get logger ( ) . debug enabl ( ) ) get logger ( ) . debug ( send applic start event ) ; object instanc = get applic lifecycl listen ( ) ; ( instanc = = null ) return ( ok ) ; servlet context event event = new servlet context event ( get servlet context ( ) ) ; ( int i = 0 ; i instanc . length ; i ) { ( instanc i = = null ) continu ; ( ( instanc i instanceof servlet context listen ) ) continu ; servlet context listen listen = ( servlet context listen ) instanc i ; try { fire contain event ( befor context initi , listen ) ; listen . context initi ( event ) ; fire contain event ( after context initi , listen ) ; } catch ( throwabl t ) { fire contain event ( after context initi , listen ) ; get logger ( ) . error ( sm . get string ( standard context . listen start , instanc i . get class ( ) . get name ( ) ) , t ) ; ok = fals ; } } return ( ok ) ; }
public string read line ( ) throw ioexcept { ( line buffer = = null ) { line buffer = new char max line length ; } string result = null ; int po = 0 ; int end = 1 ; int skip = 1 ; string buffer aggreg = null ; while ( end 0 ) { mark ( max line length ) ; while ( ( po max line length ) ( end 0 ) ) { int n read = read ( line buffer , po , max line length po ) ; ( n read 0 ) { ( po = = 0 ) { return null ; } end = po ; skip = po ; } ( int i = po ; ( i ( po n read ) ) ( end 0 ) ; i ) { ( line buffer i = = line sep 0 ) { end = i ; skip = i 1 ; char nextchar ; ( i = = ( po n read 1 ) ) { nextchar = ( char ) read ( ) ; } els { nextchar = line buffer i 1 ; } ( nextchar = = line sep 1 ) { skip ; } } els ( line buffer i = = line sep 1 ) { end = i ; skip = i 1 ; } } ( n read 0 ) { po = n read ; } } ( end 0 ) { ( aggreg = = null ) { aggreg = new string buffer ( ) ; } aggreg . append ( line buffer ) ; po = 0 ; } els { reset ( ) ; skip ( skip ) ; } } ( aggreg = = null ) { result = new string ( line buffer , 0 , end ) ; } els { aggreg . append ( line buffer , 0 , end ) ; result = aggreg . string ( ) ; } return result ; }
protect void run ( ) throw ioexcept { remind : thi method feel too big ; should re written ( readi ( ) ) { throw new ioexcept ( thi . get class ( ) . get name ( ) : readi run . ) ; } ( debug = 1 ) { log ( run cgi ( envp = env , command = command ) ) ; } ( ( command . index ( file . separ . file . separ ) = 0 ) ( command . index ( file . separ . . ) = 0 ) ( command . index ( . . file . separ ) = 0 ) ) { throw new ioexcept ( thi . get class ( ) . get name ( ) illeg charact cgi command path ( . . . ) detect . run cgi command . ) ; } origin content structur thi section taken from http : develop . java . sun . com develop bug parad bug 4216884 . html major modif martin dengler runtim rt = null ; input stream cgi output = null ; buffer reader command std err = null ; buffer output stream command std = null ; process proc = null ; int buf read = 1 ; creat queri argument string buffer cmd arg = new string buffer ( ) ; ( command . index ( ) 0 ) { cmd arg . append ( command ) ; } els { space us delimit , so need us quot cmd arg . append ( ) ; cmd arg . append ( command ) ; cmd arg . append ( ) ; } ( int i = 0 ; i param . size ( ) ; i ) { cmd arg . append ( ) ; string param = ( string ) param . get ( i ) ; ( param . index ( ) 0 ) { cmd arg . append ( param ) ; } els { space us delimit , so need us quot cmd arg . append ( ) ; cmd arg . append ( param ) ; cmd arg . append ( ) ; } } string buffer command = new string buffer ( cgi execut ) ; command . append ( ) ; command . append ( cmd arg . string ( ) ) ; cmd arg = command ; try { rt = runtim . get runtim ( ) ; proc = rt . exec ( cmd arg . string ( ) , hash string arrai ( env ) , wd ) ; string s content length = ( string ) env . get ( content length ) ; ( . equal ( s content length ) ) { command std = new buffer output stream ( proc . get output stream ( ) ) ; iotool . flow ( stdin , command std ) ; command std . flush ( ) ; command std . close ( ) ; } we want wait process exit , process . wait ( ) useless our situat ; see http : develop . java . sun . com develop bug parad bug 4223650 . html boolean run = true ; command std err = new buffer reader ( new input stream reader ( proc . get error stream ( ) ) ) ; final buffer reader std err rdr = command std err ; new thread ( ) { public void run ( ) { send log ( std err rdr ) ; } ; } . start ( ) ; input stream cgi header stream = new httpheader input stream ( proc . get input stream ( ) ) ; buffer reader cgi header reader = new buffer reader ( new input stream reader ( cgi header stream ) ) ; while ( run ) { try { set header string line = null ; while ( ( ( line = cgi header reader . read line ( ) ) = null ) ( . equal ( line ) ) ) { ( debug = 2 ) { log ( run cgi : add header ( line ) ) ; } ( line . start ( http ) ) { respons . set statu ( get scfrom http statu line ( line ) ) ; } els ( line . index ( : ) = 0 ) { string header = line . substr ( 0 , line . index ( : ) ) . trim ( ) ; string valu = line . substr ( line . index ( : ) 1 ) . trim ( ) ; ( header . equal ignor case ( statu ) ) { respons . set statu ( get scfrom cgistatu header ( valu ) ) ; } els { respons . add header ( header , valu ) ; } } els { log ( run cgi : bad header line line ) ; } } write output byte b buf = new byte 2048 ; output stream out = respons . get output stream ( ) ; cgi output = proc . get input stream ( ) ; try { while ( ( buf read = cgi output . read ( b buf ) ) = 1 ) { ( debug = 4 ) { log ( run cgi : output buf read byte data ) ; } out . write ( b buf , 0 , buf read ) ; } } final { extern process could hang ( buf read = 1 ) { while ( ( buf read = cgi output . read ( b buf ) ) = 1 ) { } } } throw except aliv proc . exit valu ( ) ; run = fals ; } catch ( illeg thread state except e ) { try { thread . sleep ( 500 ) ; } catch ( interrupt except ignor ) { } } } replac process . wait ( ) close output stream us cgi output . close ( ) ; } catch ( ioexcept e ) { log ( caught except e ) ; throw e ; } final { ( debug 4 ) { log ( run final block ) ; } ( proc = null ) { proc . destroi ( ) ; proc = null ; } } }
protect param context path param context xml param file void deploi descriptor ( string context path , file context xml , string file ) { ( deploy exist ( context path ) ) { return ; } deploi applic deploi app = new deploi applic ( context path ) ; assum thi configur descriptor deploi ( log . debug enabl ( ) ) { log . debug ( sm . get string ( host config . deploi descriptor , file ) ) ; } context context = null ; try { synchron ( digest ) { try { context = ( context ) digest . pars ( context xml ) ; ( context = = null ) { log . error ( sm . get string ( host config . deploi descriptor . error , file ) ) ; return ; } } final { digest . reset ( ) ; } } ( context instanceof lifecycl ) { class clazz = class . name ( host . get config class ( ) ) ; lifecycl listen listen = ( lifecycl listen ) clazz . new instanc ( ) ; ( ( lifecycl ) context ) . add lifecycl listen ( listen ) ; } context . set config file ( context xml . get absolut path ( ) ) ; context . set path ( context path ) ; add associ doc base redeploi list s war boolean war = fals ; boolean extern = fals ; ( context . get doc base ( ) = null ) { file doc base = new file ( context . get doc base ( ) ) ; ( doc base . absolut ( ) ) { doc base = new file ( app base ( ) , context . get doc base ( ) ) ; } extern doc base , regist . xml redeploi first ( doc base . get canon path ( ) . start ( app base ( ) . get absolut path ( ) ) ) { extern = true ; deploi app . redeploi resourc . put ( context xml . get absolut path ( ) , new long ( context xml . last modifi ( ) ) ) ; deploi app . redeploi resourc . put ( doc base . get absolut path ( ) , new long ( doc base . last modifi ( ) ) ) ; ( doc base . get absolut path ( ) . lower case ( ) . end ( . war ) ) { war = true ; } } els { log . warn ( sm . get string ( host config . deploi descriptor . local doc base specifi , doc base ) ) ; ignor specifi doc base context . set doc base ( null ) ; } } host . add child ( context ) ; get path war expand war app base string name = null ; string path = context . get path ( ) ; ( path . equal ( ) ) { name = root ; } els { ( path . start ( ) ) { name = path . substr ( 1 ) ; } els { name = path ; } } default app base dir name file expand doc base = new file ( app base ( ) , name ) ; ( context . get doc base ( ) = null ) { first assum doc base absolut expand doc base = new file ( context . get doc base ( ) ) ; ( expand doc base . absolut ( ) ) { doc base specifi rel , must rel app base expand doc base = new file ( app base ( ) , context . get doc base ( ) ) ; } } watch insid ( war unpack war ) { deploi app . redeploi resourc . put ( expand doc base . get absolut path ( ) , new long ( expand doc base . last modifi ( ) ) ) ; deploi app . redeploi resourc . put ( context xml . get absolut path ( ) , new long ( context xml . last modifi ( ) ) ) ; add watch resourc ( deploi app , expand doc base . get absolut path ( ) , context ) ; } els { find exist match war expand folder file war doc base = new file ( expand doc base . get absolut path ( ) . war ) ; ( war doc base . exist ( ) ) { deploi app . redeploi resourc . put ( war doc base . get absolut path ( ) , new long ( war doc base . last modifi ( ) ) ) ; } ( expand doc base . exist ( ) ) { deploi app . redeploi resourc . put ( expand doc base . get absolut path ( ) , new long ( expand doc base . last modifi ( ) ) ) ; add watch resourc ( deploi app , expand doc base . get absolut path ( ) , context ) ; } els { add watch resourc ( deploi app , null , context ) ; } add context xml list file which should trigger redeploy ( extern ) { deploi app . redeploi resourc . put ( context xml . get absolut path ( ) , new long ( context xml . last modifi ( ) ) ) ; } } } catch ( throwabl t ) { log . error ( sm . get string ( host config . deploi descriptor . error , file ) , t ) ; } ( context = null host . find child ( context . get name ( ) ) = null ) { deploi . put ( context path , deploi app ) ; } }
public synchron get from first session master backup from all cluster session see find session master member ( ) void get all cluster session ( ) { ( cluster = null cluster . get member ( ) . length 0 ) { long befor send time = system . current time milli ( ) ; member mbr = find session master member ( ) ; ( mbr = = null ) { domain member found return ; } session messag msg = new session messag impl ( thi . get name ( ) , session messag . evt get all session , null , get all , get all get name ( ) ) ; set refer time state transfer creat send time = befor send time ; request session state counter send evt get all session ; state transfer = fals ; fixm thi send call block deploi thread , when sender wait ack enabl try { synchron ( receiv messag queue ) { receiv queue = true ; } cluster . send ( msg , mbr ) ; ( log . warn enabl ( ) ) log . warn ( sm . get string ( delta manag . wait session state , get name ( ) , mbr ) ) ; fixm sender ack mode thi method check onli state transfer resend problem wait send all session ( befor send time ) ; } final { synchron ( receiv messag queue ) { ( iter iter = receiv messag queue . iter ( ) ; iter . ha next ( ) ; ) { session messag smsg = ( session messag ) iter . next ( ) ; ( state timestamp drop ) { messag receiv ( smsg , smsg . get address ( ) = null ( member ) smsg . get address ( ) : null ) ; } els { ( smsg . get event type ( ) = session messag . evt get all session smsg . get timestamp ( ) = state transfer creat send time ) { fixm handl evt get all session later messag receiv ( smsg , smsg . get address ( ) = null ( member ) smsg . get address ( ) : null ) ; } els { ( log . warn enabl ( ) ) { log . warn ( sm . get string ( delta manag . drop messag , get name ( ) , smsg . get event type string ( ) , new date ( state transfer creat send time ) , new date ( smsg . get timestamp ( ) ) ) ) ; } } } } receiv messag queue . clear ( ) ; receiv queue = fals ; } } } els { ( log . info enabl ( ) ) log . info ( sm . get string ( delta manag . member , get name ( ) ) ) ; } }
public void get byte ( messag byte mb ) { int length = get int ( ) ; ( ( length = = 0x ffff ) ( length = = 1 ) ) { mb . recycl ( ) ; return ; } mb . set byte ( buf , po , length ) ; po = length ; skip termin 0 po ; }
public synchron stop servic throw ioexcept servic fail disconnect from socket boolean stop ( int level ) throw ioexcept { boolean valid = fals ; ( ( level channel . mbr rx seq ) = = channel . mbr rx seq ) { valid = true ; do run receiv = fals ; ( receiv = null ) receiv . interrupt ( ) ; receiv = null ; } ( ( level channel . mbr tx seq ) = = channel . mbr tx seq ) { valid = true ; do run sender = fals ; ( sender = null ) sender . interrupt ( ) ; sender = null ; } ( valid ) { throw new illeg argument except ( invalid stop level . onli accept level ar channel . mbr rx seq channel . mbr tx seq ) ; } start level = ( start level ( level ) ) ; we re shut down , send shutdown messag close socket ( start level = = 0 ) { send stop messag member . set command ( member . shutdown payload ) ; member . get data ( true , true ) ; send ( fals ) ; leav mcast group try { socket . leav group ( address ) ; } catch ( except ignor ) { } servic start time = long . max valu ; } return ( start level = = 0 ) ; }
public return unmodifi map header field . map get header field ( ) { ( connect ) { try connect ( silent ) try { connect ( ) ; } catch ( ioexcept e ) { } } ( attribut = = null ) return ( collect . empti map ) ; hash map header field = new hash map ( attribut . size ( ) ) ; name enumer attribut enum = attribut . get id ( ) ; try { while ( attribut enum . ha more ( ) ) { string attribut id = ( string ) attribut enum . next ( ) ; attribut attribut = attribut . get ( attribut id ) ; ( attribut = = null ) continu ; arrai list attribut valu list = new arrai list ( attribut . size ( ) ) ; name enumer attribut valu = attribut . get all ( ) ; while ( attribut valu . ha more ( ) ) { attribut valu list . add ( attribut valu . next ( ) . string ( ) ) ; } should op attribut . size ( ) didn t lie attribut valu list . trim size ( ) ; header field . put ( attribut id , collect . unmodifi list ( attribut valu list ) ) ; } } catch ( name except ne ) { shouldn t happen } return collect . unmodifi map ( header field ) ; }	public return name specifi header field . string get header field ( string name ) { ( connect ) { try connect ( silent ) try { connect ( ) ; } catch ( ioexcept e ) { } } ( attribut = = null ) return ( null ) ; name enumer attribut enum = attribut . get id ( ) ; try { while ( attribut enum . ha more ( ) ) { string attribut id = ( string ) attribut enum . next ( ) ; ( attribut id . equal ignor case ( name ) ) { attribut attribut = attribut . get ( attribut id ) ; ( attribut = = null ) return null ; return attribut . get ( attribut . size ( ) 1 ) . string ( ) ; } } } catch ( name except ne ) { shouldn t happen } return ( null ) ; }	public return last modifi date . long get last modifi ( ) { ( connect ) { try connect ( silent ) try { connect ( ) ; } catch ( ioexcept e ) { } } ( attribut = = null ) return 0 ; attribut last modifi = attribut . get ( resourc attribut . last modifi ) ; ( last modifi = null ) { try { date lm date = ( date ) last modifi . get ( ) ; return lm date . get time ( ) ; } catch ( except e ) { } } return 0 ; }
public read request line . thi function meant us dure http request header pars . do attempt read request bodi us . throw ioexcept except occur dure underli socket read oper , given buffer big enough accomod whole line . return true data properli fed ; fals data avail immedi thread should freed boolean pars request line ( boolean us avail data ) throw ioexcept { int start = 0 ; skip blank line byte chr = 0 ; do { read new byte need ( po = last valid ) { ( us avail data ) { return fals ; } ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } chr = buf po ; } while ( ( chr = = constant . cr ) ( chr = = constant . lf ) ) ; po ; mark current buffer posit start = po ; ( po = last valid ) { ( us avail data ) { return fals ; } ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } read method name method name alwai us ascii boolean space = fals ; while ( space ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } ( buf po = = constant . sp ) { space = true ; request . method ( ) . set byte ( buf , start , po start ) ; } po ; } mark current buffer posit start = po ; int end = 0 ; int question po = 1 ; read uri space = fals ; boolean eol = fals ; while ( space ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } ( buf po = = constant . sp ) { space = true ; end = po ; } els ( ( buf po = = constant . cr ) ( buf po = = constant . lf ) ) { http 0 . 9 style request eol = true ; space = true ; end = po ; } els ( ( buf po = = constant . question ) ( question po = = 1 ) ) { question po = po ; } po ; } request . unpars uri ( ) . set byte ( buf , start , end start ) ; ( question po = 0 ) { request . queri string ( ) . set byte ( buf , question po 1 , end question po 1 ) ; request . request uri ( ) . set byte ( buf , start , question po start ) ; } els { request . request uri ( ) . set byte ( buf , start , end start ) ; } mark current buffer posit start = po ; end = 0 ; while ( eol ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } ( buf po = = constant . cr ) { end = po ; } els ( buf po = = constant . lf ) { ( end = = 0 ) end = po ; eol = true ; } po ; } ( ( end start ) 0 ) { request . protocol ( ) . set byte ( buf , start , end start ) ; } els { request . protocol ( ) . set string ( ) ; } return true ; }	public read request line . thi function meant us dure http request header pars . do attempt read request bodi us . throw ioexcept except occur dure underli socket read oper , given buffer big enough accomod whole line . return true data properli fed ; fals data avail immedi thread should freed boolean pars request line ( boolean us avail data ) throw ioexcept { check state ( pars request line ) return true ; ( pars request line phase = = 0 ) { byte chr = 0 ; do { read new byte need ( po = last valid ) { ( us avail data ) { return fals ; } do simpl read short timeout ( read socket ( true , fals ) = = 0 ) return fals ; } chr = buf po ; } while ( ( chr = = constant . cr ) ( chr = = constant . lf ) ) ; po ; pars request line start = po ; pars request line phase = 1 ; } ( pars request line phase = = 1 ) { mark current buffer posit ( po = last valid ) { ( us avail data ) { return fals ; } do simpl read short timeout ( read socket ( true , fals ) = = 0 ) return fals ; } pars request line phase = 2 ; } ( pars request line phase = = 2 ) { read method name method name alwai us ascii boolean space = fals ; while ( space ) { read new byte need ( po = last valid ) { ( request line pars fill ( true , fals ) ) return fals ; } ( buf po = = constant . sp ) { space = true ; request . method ( ) . set byte ( buf , pars request line start , po pars request line start ) ; } po ; } pars request line start = po ; pars request line phase = 3 ; } ( pars request line phase = = 3 ) { mark current buffer posit int end = 0 ; read uri boolean space = fals ; while ( space ) { read new byte need ( po = last valid ) { ( request line pars fill ( true , fals ) ) return fals ; } ( buf po = = constant . sp ) { space = true ; end = po ; } els ( ( buf po = = constant . cr ) ( buf po = = constant . lf ) ) { http 0 . 9 style request pars request line eol = true ; space = true ; end = po ; } els ( ( buf po = = constant . question ) ( pars request line qpo = = 1 ) ) { pars request line qpo = po ; } po ; } request . unpars uri ( ) . set byte ( buf , pars request line start , end pars request line start ) ; ( pars request line qpo = 0 ) { request . queri string ( ) . set byte ( buf , pars request line qpo 1 , end pars request line qpo 1 ) ; request . request uri ( ) . set byte ( buf , pars request line start , pars request line qpo pars request line start ) ; } els { request . request uri ( ) . set byte ( buf , pars request line start , end pars request line start ) ; } pars request line start = po ; pars request line phase = 4 ; } ( pars request line phase = = 4 ) { mark current buffer posit end = 0 ; while ( pars request line eol ) { read new byte need ( po = last valid ) { ( requ line pars fill ( true , fals ) ) return fals ; } ( buf po = = constant . cr ) { end = po ; } els ( buf po = = constant . lf ) { ( end = = 0 ) end = po ; pars request line eol = true ; } po ; } ( ( end pars request line start ) 0 ) { request . protocol ( ) . set byte ( buf , pars request line start , end pars request line start ) ; } els { request . protocol ( ) . set string ( ) ; } pars request line = fals ; pars request line phase = 0 ; pars request line eol = fals ; pars request line start = 0 ; return true ; } throw new illeg state except ( invalid request line pars phase : pars request line phase ) ; }	public read request line . thi function meant us dure http request header pars . do attempt read request bodi us . throw ioexcept except occur dure underli socket read oper , given buffer big enough accomod whole line . void pars request line ( ) throw ioexcept { int start = 0 ; skip blank line byte chr = 0 ; do { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } chr = buf po ; } while ( ( chr = = constant . cr ) ( chr = = constant . lf ) ) ; po ; mark current buffer posit start = po ; read method name method name alwai us ascii boolean space = fals ; while ( space ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } ( buf po = = constant . sp ) { space = true ; request . method ( ) . set byte ( buf , start , po start ) ; } po ; } mark current buffer posit start = po ; int end = 0 ; int question po = 1 ; read uri space = fals ; boolean eol = fals ; while ( space ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } ( buf po = = constant . sp ) { space = true ; end = po ; } els ( ( buf po = = constant . cr ) ( buf po = = constant . lf ) ) { http 0 . 9 style request eol = true ; space = true ; end = po ; } els ( ( buf po = = constant . question ) ( question po = = 1 ) ) { question po = po ; } po ; } request . unpars uri ( ) . set byte ( buf , start , end start ) ; ( question po = 0 ) { request . queri string ( ) . set byte ( buf , question po 1 , end question po 1 ) ; request . request uri ( ) . set byte ( buf , start , question po start ) ; } els { request . request uri ( ) . set byte ( buf , start , end start ) ; } mark current buffer posit start = po ; end = 0 ; while ( eol ) { read new byte need ( po = last valid ) { ( fill ( ) ) throw new eofexcept ( sm . get string ( iib . eof . error ) ) ; } ( buf po = = constant . cr ) { end = po ; } els ( buf po = = constant . lf ) { ( end = = 0 ) end = po ; eol = true ; } po ; } ( ( end start ) 0 ) { request . protocol ( ) . set byte ( buf , start , end start ) ; } els { request . protocol ( ) . set string ( ) ; } }
privat compar page encod specifi variou place , throw except case page encod mismatch . param page dir enc valu page encod attribut page direct param page dir page direct node throw jasper except case page encod mismatch string compar page encod ( string page dir enc , node . page direct page dir ) throw jasper except { node . root root = page dir . get root ( ) ; string config enc = root . get jsp config page encod ( ) ; compar page encod attribut page direct encod specifi jsp config element whose url pattern match thi page . treat utf 16 , utf 16be , utf 16le ident . ( config enc = null ) { ( page dir enc . equal ( config enc ) ( page dir enc . start ( utf 16 ) config enc . start ( utf 16 ) ) ) { err . jsp error ( page dir , jsp . error . config pagedir encod mismatch , config enc , page dir enc ) ; } els { return config enc ; } } compar page encod attribut page direct encod specifi xml prolog ( onli xml syntax , onli jsp document contain xml prolog encod declar ) . treat utf 16 , utf 16be , utf 16le ident . ( ( root . xml syntax ( ) root . encod specifi prolog ( ) ) root . bom present ( ) ) { string page enc = root . get page encod ( ) ; ( page dir enc . equal ( page enc ) ( page dir enc . start ( utf 16 ) page enc . start ( utf 16 ) ) ) { err . jsp error ( page dir , jsp . error . prolog pagedir encod mismatch , page enc , page dir enc ) ; } els { return page enc ; } } return page dir enc ; }	public void visit ( node . variabl direct n ) throw jasper except { do noth , sinc thi variabl direct ha alreadi been valid tag file processor when creat tag info object from tag file which direct appear }
privat map string , map string , string >> build inject map ( name resourc name resourc ) { map string , map string , string >> inject map = new hash map string , map string , string >> ( ) ; ( inject resourc : name resourc . find local ejb ( ) ) { add inject target ( resourc , inject map ) ; } ( inject resourc : name resourc . find ejb ( ) ) { add inject target ( resourc , inject map ) ; } ( inject resourc : name resourc . find environ ( ) ) { add inject target ( resourc , inject map ) ; } ( inject resourc : name resourc . find messag destin ref ( ) ) { add inject target ( resourc , inject map ) ; } ( inject resourc : name resourc . find resourc env ref ( ) ) { add inject target ( resourc , inject map ) ; } ( inject resourc : name resourc . find resourc ( ) ) { add inject target ( resourc , inject map ) ; } ( inject resourc : name resourc . find servic ( ) ) { add inject target ( resourc , inject map ) ; } return inject map ; }
privat check xml element given tag name custom action , return correspond node object . node pars custom action ( string q name , string local name , string uri , attribut non taglib attr , attribut non taglib xmln attr , attribut taglib attr , mark start , node parent ) throw saxexcept { check thi user defin ( custom ) tag tag librari info tag lib info = page info . get taglib ( uri ) ; ( tag lib info = = null ) { return null ; } tag info tag info = tag lib info . get tag ( local name ) ; tag file info tag file info = tag lib info . get tag file ( local name ) ; ( tag info = = null tag file info = = null ) { throw new saxexcept ( local . get messag ( jsp . error . xml . bad tag , local name , uri ) ) ; } class tag handler class = null ; ( tag info = null ) { string handler class name = tag info . get tag class name ( ) ; try { tag handler class = ctxt . get class loader ( ) . load class ( handler class name ) ; } catch ( except e ) { throw new saxexcept ( local . get messag ( jsp . error . loadclass . taghandl , handler class name , q name ) , e ) ; } } string prefix = ; int colon = q name . index ( : ) ; ( colon = 1 ) { prefix = q name . substr ( 0 , colon ) ; } node . custom tag ret = null ; ( tag info = null ) { ret = new node . custom tag ( q name , prefix , local name , uri , non taglib attr , non taglib xmln attr , taglib attr , start , parent , tag info , tag handler class ) ; } els { ret = new node . custom tag ( q name , prefix , local name , uri , non taglib attr , non taglib xmln attr , taglib attr , start , parent , tag file info ) ; } return ret ; }	privat check given uri qname see thei hijack jsp prefix , which would case q name contain jsp prefix uri wa differ from http : java . sun . com jsp page . param uri uri check param q name qname check void check prefix ( string uri , string q name ) { int index = q name . index ( : ) ; ( index = 1 ) { string prefix = q name . substr ( 0 , index ) ; page info . add prefix ( prefix ) ; ( jsp . equal ( prefix ) jsp uri . equal ( uri ) ) { page info . set jsp prefix hijack ( true ) ; } } }	public receiv notif start element . thi method assign given tag attribut 3 bucket : xmln attribut repres ( standard custom ) tag librari . xmln attribut do repres tag librari . all remain attribut . each xmln attribut repres custom tag librari , correspond tag librari info object ad set custom tag librari . void start element ( string uri , string local name , string q name , attribut attr ) throw saxexcept { attribut impl taglib attr = null ; attribut impl non taglib attr = null ; attribut impl non taglib xmln attr = null ; process char ( ) ; check prefix ( uri , q name , attr ) ; ( direct onli ( jsp uri . equal ( uri ) local name . start ( direct action ) ) ) { return ; } jsp : text must have ani subel ( jsp uri . equal ( uri ) text action . equal ( current . get local name ( ) ) ) { throw new saxpars except ( local . get messag ( jsp . error . text . ha subel ) , locat ) ; } start mark = new mark ( ctxt , path , locat . get line number ( ) , locat . get column number ( ) ) ; ( attr = null ) { notic due bug underli sax parser , attribut must enumer descend order . boolean taglib = fals ; ( int i = attr . get length ( ) 1 ; i = 0 ; i ) { taglib = fals ; string attr qname = attr . get qname ( i ) ; ( attr qname . start ( xmln ) ) { ( non taglib attr = = null ) { non taglib attr = new attribut impl ( ) ; } non taglib attr . add attribut ( attr . get uri ( i ) , attr . get local name ( i ) , attr . get qname ( i ) , attr . get type ( i ) , attr . get valu ( i ) ) ; } els { ( attr qname . start ( xmln : jsp ) ) { taglib = true ; } els { string attr uri = attr . get valu ( i ) ; taglib info thi uri alreadi establish start prefix map taglib = page info . ha taglib ( attr uri ) ; } ( taglib ) { ( taglib attr = = null ) { taglib attr = new attribut impl ( ) ; } taglib attr . add attribut ( attr . get uri ( i ) , attr . get local name ( i ) , attr . get qname ( i ) , attr . get type ( i ) , attr . get valu ( i ) ) ; } els { ( non taglib xmln attr = = null ) { non taglib xmln attr = new attribut impl ( ) ; } non taglib xmln attr . add attribut ( attr . get uri ( i ) , attr . get local name ( i ) , attr . get qname ( i ) , attr . get type ( i ) , attr . get valu ( i ) ) ; } } } } node node = null ; ( tag depend pend jsp uri . equal ( uri ) local name . equal ( bodi action ) ) { tag depend pend = fals ; tag depend nest ; current = pars standard action ( q name , local name , non taglib attr , non taglib xmln attr , taglib attr , start mark , current ) ; return ; } ( tag depend pend jsp uri . equal ( uri ) local name . equal ( attribut action ) ) { current = pars standard action ( q name , local name , non taglib attr , non taglib xmln attr , taglib attr , start mark , current ) ; return ; } ( tag depend pend ) { tag depend pend = fals ; tag depend nest ; } ( tag depend nest 0 ) { node = new node . uninterpret tag ( q name , local name , non taglib attr , non taglib xmln attr , taglib attr , start mark , current ) ; } els ( jsp uri . equal ( uri ) ) { node = pars standard action ( q name , local name , non taglib attr , non taglib xmln attr , taglib attr , start mark , current ) ; } els { node = pars custom action ( q name , local name , uri , non taglib attr , non taglib xmln attr , taglib attr , start mark , current ) ; ( node = = null ) { node = new node . uninterpret tag ( q name , local name , non taglib attr , non taglib xmln attr , taglib attr , start mark , current ) ; } els { custom action string bodi type = get bodi type ( ( node . custom tag ) node ) ; ( scriptless bodi node = = null bodi type . equal ignor case ( tag info . bodi content scriptless ) ) { scriptless bodi node = node ; } } } }
privat valid syntax propos code lt ; url pattern gt ; code conform specif requir . param url pattern url pattern valid boolean valid urlpattern ( string url pattern ) { ( url pattern = = null ) return ( fals ) ; ( url pattern . index ( n ) = 0 url pattern . index ( r ) = 0 ) { return ( fals ) ; } ( url pattern . start ( . ) ) { ( url pattern . index ( ) 0 ) return ( true ) ; els return ( fals ) ; } ( ( url pattern . start ( ) ) ( url pattern . index ( . ) 0 ) ) return ( true ) ; els return ( fals ) ; }	public add url pattern part thi web resourc collect . void add pattern ( string pattern ) { ( pattern = = null ) return ; bugzilla 34805 : add friendli warn . ( pattern . end ( ) ) { ( pattern . char ( pattern . length ( ) 1 ) = ) { ( log . debug enabl ( ) ) { log . warn ( suspici url pattern : pattern see http : java . sun . com about java communityprocess first jsr053 servlet23 pfd . pdf section 11 . 2 ) ; } } } pattern = request util . urldecod ( pattern ) ; string result = new string pattern . length 1 ; ( int i = 0 ; i pattern . length ; i ) { result i = pattern i ; } result pattern . length = pattern ; pattern = result ; }
public string find compress mime type ( ) { return ( compress mime type ) ; }	public string find compress mime type ( ) { return ( compress mime type ) ; }	public string find compress mime type ( ) { return ( compress mime type ) ; }
protect void creat output dir ( ) { string path = null ; ( tag file ( ) ) { string tag name = tag info . get tag class name ( ) ; path = tag name . replac ( . , ) ; path = path . substr ( 0 , path . last index ( ) ) ; } els { path = get servlet packag name ( ) . replac ( . , ) ; } append servlet tag handler path scratch dir try { base url = option . get scratch dir ( ) . url ( ) ; string out url string = base url . string ( ) path ; url out url = new url ( out url string ) ; output dir = out url . get file ( ) file . separ ; ( make output dir ( ) ) { throw new illeg state except ( local . get messag ( jsp . error . outputfold ) ) ; } } catch ( malform urlexcept e ) { throw new illeg state except ( local . get messag ( jsp . error . outputfold ) , e ) ; } }	public static creat return new class loader , base configur default specifi directori path : param unpack arrai pathnam unpack directori should ad repositori class loader , code null code unpack directori consid param pack arrai pathnam directori contain jar file should ad repositori class loader , code null code directori jar file consid param url arrai url remot repositori , design either jar resourc uncompress directori should ad repositori class loader , code null code directori jar file consid param parent parent class loader new class loader , code null code system class loader . except except error occur construct class loader class loader creat class loader ( file unpack , file pack , url url , class loader parent ) throw except { ( log . debug enabl ( ) ) log . debug ( creat new class loader ) ; construct class path thi class loader arrai list list = new arrai list ( ) ; add unpack directori ( unpack = null ) { ( int i = 0 ; i unpack . length ; i ) { file file = unpack i ; ( file . exist ( ) file . can read ( ) ) continu ; file = new file ( file . get canon path ( ) file . separ ) ; url url = file . url ( ) ; ( log . debug enabl ( ) ) log . debug ( includ directori url ) ; list . add ( url ) ; } } add pack directori jar file ( pack = null ) { ( int i = 0 ; i pack . length ; i ) { file directori = pack i ; ( directori . directori ( ) directori . exist ( ) directori . can read ( ) ) continu ; string filenam = directori . list ( ) ; ( int j = 0 ; j filenam . length ; j ) { string filenam = filenam j . lower case ( ) ; ( filenam . end ( . jar ) ) continu ; file file = new file ( directori , filenam j ) ; ( log . debug enabl ( ) ) log . debug ( includ jar file file . get absolut path ( ) ) ; url url = file . url ( ) ; list . add ( url ) ; } } } construct class loader itself url arrai = ( url ) list . arrai ( new url list . size ( ) ) ; standard class loader class loader = null ; ( parent = = null ) class loader = new standard class loader ( arrai ) ; els class loader = new standard class loader ( arrai , parent ) ; return ( class loader ) ; }	public static creat return new class loader , base configur default specifi directori path : param locat arrai string contain class directori , jar file , jar directori url should ad repositori class loader . type given member param type . param type arrai type member param locat . possibl valu ar dir ( class directori ) , jar ( singl jar file ) , glob ( directori jar file ) url ( url ) . param parent parent class loader new class loader , code null code system class loader . except except error occur construct class loader class loader creat class loader ( string locat , integ type , class loader parent ) throw except { ( log . debug enabl ( ) ) log . debug ( creat new class loader ) ; construct class path thi class loader arrai list list = new arrai list ( ) ; ( locat = null type = null locat . length = = type . length ) { ( int i = 0 ; i locat . length ; i ) { string locat = locat i ; ( type i = = url ) { url url = new url ( locat ) ; ( log . debug enabl ( ) ) log . debug ( includ url url ) ; list . add ( url ) ; } els ( type i = = dir ) { file directori = new file ( locat ) ; directori = new file ( directori . get canon path ( ) ) ; ( directori . exist ( ) directori . directori ( ) directori . can read ( ) ) continu ; url url = directori . url ( ) ; ( log . debug enabl ( ) ) log . debug ( includ directori url ) ; list . add ( url ) ; } els ( type i = = jar ) { file file = new file ( locat ) ; file = new file ( file . get canon path ( ) ) ; ( file . exist ( ) file . can read ( ) ) continu ; url url = file . url ( ) ; ( log . debug enabl ( ) ) log . debug ( includ jar file url ) ; list . add ( url ) ; } els ( type i = = glob ) { file directori = new file ( locat ) ; ( directori . exist ( ) directori . directori ( ) directori . can read ( ) ) continu ; ( log . debug enabl ( ) ) log . debug ( includ directori glob directori . get absolut path ( ) ) ; string filenam = directori . list ( ) ; ( int j = 0 ; j filenam . length ; j ) { string filenam = filenam j . lower case ( ) ; ( filenam . end ( . jar ) ) continu ; file file = new file ( directori , filenam j ) ; file = new file ( file . get canon path ( ) ) ; ( file . exist ( ) file . can read ( ) ) continu ; ( log . debug enabl ( ) ) log . debug ( includ glob jar file file . get absolut path ( ) ) ; url url = file . url ( ) ; list . add ( url ) ; } } } } construct class loader itself url arrai = ( url ) list . arrai ( new url list . size ( ) ) ; ( log . debug enabl ( ) ) ( int i = 0 ; i arrai . length ; i ) { log . debug ( locat i arrai i ) ; } standard class loader class loader = null ; ( parent = = null ) class loader = new standard class loader ( arrai ) ; els class loader = new standard class loader ( arrai , parent ) ; return ( class loader ) ; }
protect deploi war file . void deploi war ( file app base , string file ) { ( file = = null ) return ; ( int i = 0 ; i file . length ; i ) { ( file i . equal ignor case ( meta inf ) ) continu ; ( file i . equal ignor case ( web inf ) ) continu ; file dir = new file ( app base , file i ) ; ( file i . lower case ( ) . end ( . war ) ) { calcul context path make sure uniqu string context path = file i ; int period = context path . last index ( . ) ; ( period = 0 ) context path = context path . substr ( 0 , period ) ; ( context path . equal ( root ) ) context path = ; ( servic ( context path ) ) continu ; string file = file i ; deploi war ( context path , dir , file ) ; } } }
public process get request specifi resourc . param request servlet request we ar process param respons servlet respons we ar creat except ioexcept input output error occur except servlet except servlet specifi error occur void do get ( http servlet request request , http servlet respons respons ) throw ioexcept , servlet except { verifi we were access us invok servlet ( request . get attribut ( global . invok attr ) = null ) throw new unavail except ( sm . get string ( manag servlet . cannot invok ) ) ; identifi request paramet we need string command = request . get path info ( ) ; ( command = = null ) command = request . get servlet path ( ) ; string config = request . get paramet ( config ) ; string path = request . get paramet ( path ) ; string type = request . get paramet ( type ) ; string war = request . get paramet ( war ) ; string tag = request . get paramet ( tag ) ; boolean updat = fals ; ( ( request . get paramet ( updat ) = null ) ( request . get paramet ( updat ) . equal ( true ) ) ) { updat = true ; } prepar our output writer gener respons messag respons . set content type ( text plain ; charset = constant . charset ) ; print writer writer = respons . get writer ( ) ; process request command ( note deploi list here ) ( command = = null ) { writer . println ( sm . get string ( manag servlet . command ) ) ; } els ( command . equal ( deploi ) ) { ( war = null config = null ) { deploi ( writer , config , path , war , updat ) ; } els { deploi ( writer , path , tag ) ; } } els ( command . equal ( instal ) ) { deprec deploi ( writer , config , path , war , fals ) ; } els ( command . equal ( list ) ) { list ( writer ) ; } els ( command . equal ( reload ) ) { reload ( writer , path ) ; } els ( command . equal ( remov ) ) { deprec undeploi ( writer , path ) ; } els ( command . equal ( resourc ) ) { resourc ( writer , type ) ; } els ( command . equal ( role ) ) { role ( writer ) ; } els ( command . equal ( save ) ) { save ( writer , path ) ; } els ( command . equal ( serverinfo ) ) { serverinfo ( writer ) ; } els ( command . equal ( expir ) ) { expir session ( writer , path , request ) ; } els ( command . equal ( start ) ) { start ( writer , path ) ; } els ( command . equal ( stop ) ) { stop ( writer , path ) ; } els ( command . equal ( undeploi ) ) { undeploi ( writer , path ) ; } els { writer . println ( sm . get string ( manag servlet . unknown command , command ) ) ; } finish up respons writer . flush ( ) ; writer . close ( ) ; }
privat creat name tag handler pool whose tag handler mai ( re ) us servic thi action . return name tag handler pool string creat tag handler pool name ( string prefix , string short name , attribut attr , boolean ha empti bodi ) { string pool name = null ; pool name = jspx tag pool prefix short name ; ( attr = null ) { string attr name = new string attr . get length ( ) ; ( int i = 0 ; i attr name . length ; i ) { attr name i = attr . get qname ( i ) ; } arrai . sort ( attr name , collect . revers order ( ) ) ; ( int i = 0 ; i attr name . length ; i ) { pool name = pool name attr name i ; } } ( ha empti bodi ) { pool name = pool name nobodi ; } return jsp util . make java identifi ( pool name ) ; }

compil servlet from . java file . class file void gener class ( string smap ) throw file found except , jasper except , except { long t1 = 0 ; ( log . debug enabl ( ) ) { t1 = system . current time milli ( ) ; } string java encod = ctxt . get option ( ) . get java encod ( ) ; string java file name = ctxt . get servlet java file name ( ) ; string classpath = ctxt . get class path ( ) ; string sep = system . get properti ( path . separ ) ; string buffer error report = new string buffer ( ) ; string buffer info = new string buffer ( ) ; info . append ( compil : java file name = java file name n ) ; info . append ( classpath = classpath n ) ; start captur system . err output thi thread system log handler . set thread ( ) ; initi javac task get project ( ) ; javac javac = ( javac ) project . creat task ( javac ) ; initi classpath path path = new path ( project ) ; path . set path ( system . get properti ( java . class . path ) ) ; info . append ( cp = system . get properti ( java . class . path ) n ) ; string token token = new string token ( classpath , sep ) ; while ( token . ha more element ( ) ) { string path element = token . next token ( ) ; file repositori = new file ( path element ) ; path . set locat ( repositori ) ; info . append ( cp = repositori n ) ; } ( log . debug enabl ( ) ) log . debug ( us classpath : system . get properti ( java . class . path ) sep classpath ) ; initi sourcepath path src path = new path ( project ) ; src path . set locat ( option . get scratch dir ( ) ) ; info . append ( work dir = option . get scratch dir ( ) n ) ; initi set java extens string ext = system . get properti ( java . ext . dir ) ; ( ext = null ) { path extdir = new path ( project ) ; extdir . set path ( ext ) ; javac . set extdir ( extdir ) ; info . append ( extens dir = ext n ) ; } see bugzilla 31257 ( ctxt . get option ( ) . get fork ( ) ) { string endors = system . get properti ( java . endors . dir ) ; ( endors = null ) { javac . implement specif argument endors arg = javac . creat compil arg ( ) ; endors arg . set line ( j djava . endors . dir = endors ) ; info . append ( endors dir = endors n ) ; } els { info . append ( endors dir specifi n ) ; } } configur compil object javac . set encod ( java encod ) ; javac . set classpath ( path ) ; javac . set debug ( ctxt . get option ( ) . get class debug info ( ) ) ; javac . set srcdir ( src path ) ; javac . set tempdir ( option . get scratch dir ( ) ) ; javac . set optim ( ctxt . get option ( ) . get class debug info ( ) ) ; javac . set fork ( ctxt . get option ( ) . get fork ( ) ) ; info . append ( src dir = src path n ) ; set java compil us ( option . get compil ( ) = null ) { javac . set compil ( option . get compil ( ) ) ; info . append ( compil = option . get compil ( ) n ) ; } ( option . get compil target vm ( ) = null ) { javac . set target ( option . get compil target vm ( ) ) ; info . append ( compil target vm = option . get compil target vm ( ) n ) ; } ( option . get compil sourc vm ( ) = null ) { javac . set sourc ( option . get compil sourc vm ( ) ) ; info . append ( compil sourc vm = option . get compil sourc vm ( ) n ) ; } build includ path pattern set . name entri includ = javac . creat includ ( ) ; includ . set name ( ctxt . get java path ( ) ) ; info . append ( includ = ctxt . get java path ( ) n ) ; build except = null ; try { ( ctxt . get option ( ) . get fork ( ) ) { javac . execut ( ) ; } els { synchron ( javac lock ) { javac . execut ( ) ; } } } catch ( build except e ) { = e ; log . error ( local . get messag ( jsp . error . javac ) , e ) ; log . error ( local . get messag ( jsp . error . javac . env ) info . string ( ) ) ; } error report . append ( logger . get report ( ) ) ; stop captur system . err output thi thread string error captur = system log handler . unset thread ( ) ; ( error captur = null ) { error report . append ( system . get properti ( line . separ ) ) ; error report . append ( error captur ) ; } ( ctxt . keep gener ( ) ) { file java file = new file ( java file name ) ; java file . delet ( ) ; } ( = null ) { string error report string = error report . string ( ) ; log . error ( local . get messag ( jsp . error . compil , java file name , error report string ) ) ; javac error detail javac error = error dispatch . pars javac error ( error report string , java file name , page node ) ; ( javac error = null ) { err dispatch . javac error ( javac error ) ; } els { err dispatch . javac error ( error report string , ) ; } } ( log . debug enabl ( ) ) { long t2 = system . current time milli ( ) ; log . debug ( compil ctxt . get servlet java file name ( ) ( t2 t1 ) ms ) ; } logger = null ; project = null ; ( ctxt . prototyp mode ( ) ) { return ; } jsr45 support ( option . smap suppress ( ) ) { smap util . instal smap ( smap ) ; } }
protect process applic configur file , exist . void applic web config ( ) { string alt ddname = null ; open applic web . xml file , exist input stream stream = null ; servlet context servlet context = context . get servlet context ( ) ; ( servlet context = null ) { alt ddname = ( string ) servlet context . get attribut ( global . alt dd attr ) ; ( alt ddname = null ) { try { stream = new file input stream ( alt ddname ) ; } catch ( file found except e ) { log . error ( sm . get string ( context config . alt ddnot found , alt ddname ) ) ; } } els { stream = servlet context . get resourc stream ( constant . applic web xml ) ; } } ( stream = = null ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( context config . applic miss ) context ) ; } return ; } long t1 = system . current time milli ( ) ; ( web digest = = null ) { web digest = creat web digest ( ) ; } url url = null ; process applic web . xml file synchron ( web digest ) { try { ( alt ddname = null ) { url = new file ( alt ddname ) . url ( ) ; } els { url = servlet context . get resourc ( constant . applic web xml ) ; } ( url = null ) { input sourc = new input sourc ( url . extern form ( ) ) ; . set byte stream ( stream ) ; ( context instanceof standard context ) { ( ( standard context ) context ) . set replac welcom file ( true ) ; } web digest . push ( context ) ; web digest . set error handler ( new context error handler ( ) ) ; ( log . debug enabl ( ) ) { log . debug ( pars applic web . xml file url . extern form ( ) ) ; } web digest . pars ( ) ; ( pars except = null ) { ok = fals ; } } els { log . info ( web . xml , us default context ) ; } } catch ( saxpars except e ) { log . error ( sm . get string ( context config . applic pars , url . extern form ( ) ) , e ) ; log . error ( sm . get string ( context config . applic posit , e . get line number ( ) , e . get column number ( ) ) ) ; ok = fals ; } catch ( except e ) { log . error ( sm . get string ( context config . applic pars , url . extern form ( ) ) , e ) ; ok = fals ; } final { web digest . reset ( ) ; pars except = null ; try { ( stream = null ) { stream . close ( ) ; } } catch ( ioexcept e ) { log . error ( sm . get string ( context config . applic close ) , e ) ; } } } web rule set . recycl ( ) ; long t2 = system . current time milli ( ) ; ( context instanceof standard context ) { ( ( standard context ) context ) . set startup time ( t2 t1 ) ; } }	protect process default configur file , exist . default config must read contain loader so contain servlet can load void default web config ( ) { long t1 = system . current time milli ( ) ; open default web . xml file , exist ( default web xml = = null context instanceof standard context ) { default web xml = ( ( standard context ) context ) . get default web xml ( ) ; } set default we don t have ani overrid ( default web xml = = null ) get default web xml ( ) ; file file = new file ( thi . default web xml ) ; ( file . absolut ( ) ) { file = new file ( get base dir ( ) , thi . default web xml ) ; } input stream stream = null ; input sourc sourc = null ; try { ( file . exist ( ) ) { us get resourc get resourc stream stream = get class ( ) . get class loader ( ) . get resourc stream ( default web xml ) ; ( stream = null ) { sourc = new input sourc ( get class ( ) . get class loader ( ) . get resourc ( default web xml ) . string ( ) ) ; } ( stream = = null ) { mayb embed stream = get class ( ) . get class loader ( ) . get resourc stream ( web emb . xml ) ; ( stream = null ) { sourc = new input sourc ( get class ( ) . get class loader ( ) . get resourc ( web emb . xml ) . string ( ) ) ; } } ( stream = = null ) { log . info ( default web . xml ) ; } } els { sourc = new input sourc ( file : file . get absolut path ( ) ) ; stream = new file input stream ( file ) ; context . add watch resourc ( file . get absolut path ( ) ) ; } } catch ( except e ) { log . error ( sm . get string ( context config . default miss ) default web xml file , e ) ; } ( web digest = = null ) { web digest = creat web digest ( ) ; } ( stream = null ) { process default web config ( web digest , stream , sourc ) ; web rule set . recycl ( ) ; } long t2 = system . current time milli ( ) ; ( ( t2 t1 ) 200 ) log . debug ( process default web . xml file ( t2 t1 ) ) ; stream = null ; sourc = null ; string resourc name = get host config path ( constant . host web xml ) ; file = new file ( get config base ( ) , resourc name ) ; try { ( file . exist ( ) ) { us get resourc get resourc stream stream = get class ( ) . get class loader ( ) . get resourc stream ( resourc name ) ; ( stream = null ) { sourc = new input sourc ( get class ( ) . get class loader ( ) . get resourc ( resourc name ) . string ( ) ) ; } } els { sourc = new input sourc ( file : file . get absolut path ( ) ) ; stream = new file input stream ( file ) ; } } catch ( except e ) { log . error ( sm . get string ( context config . default miss ) resourc name file , e ) ; } ( stream = null ) { process default web config ( web digest , stream , sourc ) ; web rule set . recycl ( ) ; } }	protect process init event thi context . void init ( ) { call from standard context . init ( ) ( log . debug enabl ( ) ) log . debug ( sm . get string ( context config . init ) ) ; context . set configur ( fals ) ; ok = true ; context config ( ) ; try { fix doc base ( ) ; } catch ( ioexcept e ) { log . error ( sm . get string ( context config . fix doc base ) , e ) ; } }	protect process context . xml . void process context config ( file base dir , string resourc name ) { ( log . debug enabl ( ) ) log . debug ( process context context . get name ( ) configur file base dir resourc name ) ; input sourc sourc = null ; input stream stream = null ; file file = base dir ; ( resourc name = null ) { file = new file ( base dir , resourc name ) ; } try { ( file . exist ( ) ) { ( resourc name = null ) { us get resourc get resourc stream stream = get class ( ) . get class loader ( ) . get resourc stream ( resourc name ) ; ( stream = null ) { sourc = new input sourc ( get class ( ) . get class loader ( ) . get resourc ( resourc name ) . string ( ) ) ; } } } els { sourc = new input sourc ( file : file . get absolut path ( ) ) ; stream = new file input stream ( file ) ; add watch resourc so cascad reload occur default config file modifi ad remov context . add watch resourc ( file . get absolut path ( ) ) ; } } catch ( except e ) { log . error ( sm . get string ( context config . context miss , resourc name file ) , e ) ; } ( sourc = = null ) return ; ( context digest = = null ) { context digest = creat context digest ( ) ; } synchron ( context digest ) { try { sourc . set byte stream ( stream ) ; context digest . set class loader ( thi . get class ( ) . get class loader ( ) ) ; context digest . set us context class loader ( fals ) ; context digest . push ( context . get parent ( ) ) ; context digest . push ( context ) ; context digest . set error handler ( new context error handler ( ) ) ; context digest . pars ( sourc ) ; ( pars except = null ) { ok = fals ; } ( log . debug enabl ( ) ) log . debug ( successfulli process context context . get name ( ) configur file base dir resourc name ) ; } catch ( saxpars except e ) { log . error ( sm . get string ( context config . context pars , context . get name ( ) ) , e ) ; log . error ( sm . get string ( context config . default posit , e . get line number ( ) , e . get column number ( ) ) ) ; ok = fals ; } catch ( except e ) { log . error ( sm . get string ( context config . context pars , context . get name ( ) ) , e ) ; ok = fals ; } final { context digest . reset ( ) ; pars except = null ; try { ( stream = null ) { stream . close ( ) ; } } catch ( ioexcept e ) { log . error ( sm . get string ( context config . context close ) , e ) ; } } } }
privat return map path all jar file ar access webapp scan tld . map alwai includ all jar under web inf lib , well share jar classload deleg chain webapp s classload . latter constitut tomcat specif extens tld search order defin jsp spec . allow tag librari packag jar file share web applic simpli drop them locat all web applic have access ( e . g . , catalina home common lib ) . set share jar scan tld narrow down tt tld jar tt class variabl , which contain name jar ar known contain ani tld . return map jar file path map string , file get jar path ( ) { hash map string , file jar path map = null ; class loader webapp loader = thread . current thread ( ) . get context class loader ( ) ; class loader loader = webapp loader ; while ( loader = null ) { ( loader instanceof urlclass loader ) { url url = ( ( urlclass loader ) loader ) . get url ( ) ; ( int i = 0 ; i url . length ; i ) { expect file url , ar xx encod depend class loader thi definit clean us jar url either over file custom jndi handler , lot less buggi overal file file = null ; try { file = new file ( url i . uri ( ) ) ; } catch ( urisyntax except e ) { ignor , probabl unencod char file = new file ( url i . get file ( ) ) ; } try { file = file . get canon file ( ) ; } catch ( ioexcept e ) { ignor } ( file . exist ( ) ) { continu ; } string path = file . get absolut path ( ) ; ( path . end ( . jar ) ) { continu ; } scan all jar from web inf lib , plu ani share jar ar known contain ani tld ( loader = = webapp loader tld jar = = null tld jar . contain ( file . get name ( ) ) ) { ( jar path map = = null ) { jar path map = new hash map string , file ( ) ; jar path map . put ( path , file ) ; } els ( jar path map . contain kei ( path ) ) { jar path map . put ( path , file ) ; } } } } loader = loader . get parent ( ) ; } return jar path map ; }
privat static get full path , base host name context path . string get jndiuri ( string host name , string path ) { ( path . start ( ) ) return host name path ; els return host name path ; }
protect string pars param valu ( string buffer cmd , int start , int count ) { int val index = 0 ; boolean insid = fals ; string val = new string count ; string buffer sb = new string buffer ( ) ; char end quot = 0 ; ( int b idx = start ; b idx cmd . length ( ) ; b idx ) { ( insid ) { while ( b idx cmd . length ( ) quot ( cmd . char ( b idx ) ) ) b idx ; ( b idx = cmd . length ( ) ) break ; insid = insid ; end quot = cmd . char ( b idx ) ; } els { boolean escap = fals ; ( ; b idx cmd . length ( ) ; b idx ) { char c = cmd . char ( b idx ) ; check escap ( c = = escap ) { escap = true ; continu ; } we reach other stop ( c = = end quot escap ) break ; we need leav escap string ( c = = escap ) sb . append ( ) ; escap = fals ; sb . append ( c ) ; } signal error ( b idx = = cmd . length ( ) ) return null ; val val index = sb . string ( ) ; clear buffer sb . delet ( 0 , sb . length ( ) ) ; insid = insid ; } } return val ; }
protect string encod ( string valu , string encod ) { string ret val = null ; ( encod . equal ignor case ( url ) ) { ret val = url encod . encod ( valu ) ; } els ( encod . equal ignor case ( none ) ) { ret val = valu ; } els ( encod . equal ignor case ( entiti ) ) { sure how thi realli differ than none ret val = valu ; } els { thi shouldn t possibl throw new illeg argument except ( unknown encod : encod ) ; } return ret val ; }	public appli variabl substitut specifi string return new resolv string . string substitut variabl ( string val ) { need done ( val . index ( ) 0 ) return val ; string buffer sb = new string buffer ( val ) ; ( int i = 0 ; i sb . length ( ) ; ) { find next ( ; i sb . length ( ) ; i ) { ( sb . char ( i ) = = ) { i ; break ; } } ( i = = sb . length ( ) ) break ; check see escap ( i 1 sb . char ( i 2 ) = = ) { sb . delet char ( i 2 ) ; i ; continu ; } int name start = i ; int start = i 1 ; int end = 1 ; int name end = 1 ; char end char = ; check { } wrap var ( sb . char ( i ) = = { ) { name start ; end char = } ; } find end var refer ( ; i sb . length ( ) ; i ) { ( sb . char ( i ) = = end char ) break ; } end = i ; name end = end ; ( end char = = } ) end ; we should now have enough extract var name string var name = sb . substr ( name start , name end ) ; string valu = get variabl valu ( var name ) ; ( valu = = null ) valu = ; replac var name valu sb . replac ( start , end , valu ) ; start search next after valu wa just substitut . i = start valu . length ( ) ; } return sb . string ( ) ; }	public long process ( ssimedi ssi mediat , string command name , string param name , string param valu , print writer writer ) { long last modifi = 0 ; string encod = default encod ; string error messag = ssi mediat . get config err msg ( ) ; ( int i = 0 ; i param name . length ; i ) { string param name = param name i ; string param valu = param valu i ; ( param name . equal ignor case ( var ) ) { string variabl valu = ssi mediat . get variabl valu ( param valu , encod ) ; ( variabl valu = = null ) { variabl valu = miss variabl valu ; } writer . write ( variabl valu ) ; last modifi = system . current time milli ( ) ; } els ( param name . equal ignor case ( encod ) ) { ( valid encod ( param valu ) ) { encod = param valu ; } els { ssi mediat . log ( echo invalid encod : param valu ) ; writer . write ( error messag ) ; } } els { ssi mediat . log ( echo invalid attribut : param name ) ; writer . write ( error messag ) ; } } return last modifi ; }
proprietari method evalu el express . xxx thi method should go awai onc el interpret move out jstl own project . now , thi necessari becaus standard machineri too slow . param express express evalu param expect type expect result type param page context page context param function map map prefix name method return result evalu public static object proprietari evalu ( final string express , final class expect type , final page context page context , final protect function mapper function map , final boolean escap ) throw elexcept { object ret valu ; final express factori expr factori = jsp factori . get default factori ( ) . get jsp applic context ( page context . get servlet context ( ) ) . get express factori ( ) ; ( secur util . packag protect enabl ( ) ) { try { ret valu = access control . do privileg ( new privileg except action ( ) { } } } }
public ( non javadoc ) see java . io . externaliz read extern ( java . io . object input ) void read extern ( object input ) throw ioexcept , class found except { thi . function = ( map ) . read object ( ) ; }
public boolean offer ( runnabl o ) { we can t do ani check ( parent = = null ) return super . offer ( o ) ; we ar max out thread , simpli queue object ( parent . get pool size ( ) = = parent . get maximum pool size ( ) ) return super . offer ( o ) ; thi approxim , so could us some tune ( parent . get activ count ( ) ( parent . get pool size ( ) ) ) return super . offer ( o ) ; we have less thread than maximum forc creation new thread ( parent . get pool size ( ) parent . get maximum pool size ( ) ) return fals ; we reach here , we need add queue return super . offer ( o ) ; }	public int get pool size ( ) { return ( executor = null ) executor . get pool size ( ) : 0 ; }
public perform access control base specifi author constraint . return code true code thi constraint satisfi process should continu , code fals code otherwis . param request request we ar process param respons respons we ar creat param constraint secur constraint we ar enforc param context context which client thi class attach . except ioexcept input output error occur boolean ha resourc permiss ( request request , respons respons , secur constraint constraint , context context ) throw ioexcept { ( constraint = = null constraint . length = = 0 ) return ( true ) ; specif allow access form login form error page j secur check action login config config = context . get login config ( ) ; ( ( config = null ) ( constant . form method . equal ( config . get auth method ( ) ) ) ) { string request uri = request . get request path mb ( ) . string ( ) ; string login page = config . get login page ( ) ; ( login page . equal ( request uri ) ) { ( log . debug enabl ( ) ) log . debug ( allow access login page login page ) ; return ( true ) ; } string error page = config . get error page ( ) ; ( error page . equal ( request uri ) ) { ( log . debug enabl ( ) ) log . debug ( allow access error page error page ) ; return ( true ) ; } ( request uri . end ( constant . form action ) ) { ( log . debug enabl ( ) ) log . debug ( allow access usernam password submiss ) ; return ( true ) ; } } which user princip have we alreadi authent princip princip = request . get princip ( ) ; boolean statu = fals ; boolean denyfromal = fals ; ( int i = 0 ; i constraint . length ; i ) { secur constraint constraint = constraint i ; string role ; ( constraint . get all role ( ) ) { mean all role defin web . xml role = request . get context ( ) . find secur role ( ) ; } els { role = constraint . find auth role ( ) ; } ( role = = null ) role = new string 0 ; ( log . debug enabl ( ) ) log . debug ( check role princip ) ; ( role . length = = 0 constraint . get all role ( ) ) { ( constraint . get auth constraint ( ) ) { ( log . debug enabl ( ) ) log . debug ( role ) ; list role mean access all statu = fals ; denyfromal = true ; } els { ( log . debug enabl ( ) ) log . debug ( pass all access ) ; return ( true ) ; } } els ( princip = = null ) { ( log . debug enabl ( ) ) log . debug ( user authent , cannot grant access ) ; statu = fals ; } els ( denyfromal ) { ( int j = 0 ; j role . length ; j ) { ( ha role ( princip , role j ) ) statu = true ; ( log . debug enabl ( ) ) log . debug ( role found : role j ) ; } } } ( all role mode = all role mode . strict mode statu princip = null ) { ( log . debug enabl ( ) ) { log . debug ( check all role mode : all role mode ) ; } check all role ( role name = ) ( int i = 0 ; i constraint . length ; i ) { secur constraint constraint = constraint i ; string role ; all role mode exist , set ( constraint . get all role ( ) ) { ( all role mode = = all role mode . auth onli mode ) { ( log . debug enabl ( ) ) { log . debug ( grant access role name = , auth onli ) ; } statu = true ; break ; } all role mode . strict auth onli mode must zero role role = request . get context ( ) . find secur role ( ) ; ( role . length = = 0 all role mode = = all role mode . strict auth onli mode ) { ( log . debug enabl ( ) ) { log . debug ( grant access role name = , strict auth onli ) ; } statu = true ; break ; } } } } return forbidden messag deni access thi resourc ( statu ) { respons . send error ( http servlet respons . sc forbidden , sm . get string ( realm base . forbidden ) ) ; } return statu ; }
public boolean readi ( ) throw ioexcept { return ( avail ( ) 0 ) ; }	public int read ( ) throw ioexcept { return cb . substract ( ) ; }	public int read ( byte b , int off , int len ) throw ioexcept { return bb . substract ( b , off , len ) ; }	public int read ( char cbuf ) throw ioexcept { return read ( cbuf , 0 , cbuf . length ) ; }	public int read ( char cbuf , int off , int len ) throw ioexcept { return cb . substract ( cbuf , off , len ) ; }	public int read byte ( ) throw ioexcept { return bb . substract ( ) ; }	public long skip ( long n ) throw ioexcept { ( n 0 ) { throw new illeg argument except ( ) ; } long n read = 0 ; while ( n read n ) { ( cb . get length ( ) = n ) { cb . set offset ( cb . get start ( ) ( int ) n ) ; n read = n ; } els { n read = cb . get length ( ) ; cb . set offset ( cb . get end ( ) ) ; int read = 0 ; ( cb . get char ( ) . length ( n n read ) ) { read = cb . get char ( ) . length ; } els { read = ( int ) ( n n read ) ; } int nb = real read char ( cb . get char ( ) , 0 , read ) ; ( nb 0 ) break ; } } return n read ; }	public void mark ( int read ahead limit ) throw ioexcept { ( cb . get length ( ) = 0 ) { cb . set offset ( 0 ) ; cb . set end ( 0 ) ; } els { ( ( cb . get buffer ( ) . length ( 2 size ) ) ( cb . get length ( ) ) ( cb . get start ( ) ) ) { system . arraycopi ( cb . get buffer ( ) , cb . get start ( ) , cb . get buffer ( ) , 0 , cb . get length ( ) ) ; cb . set end ( cb . get length ( ) ) ; cb . set offset ( 0 ) ; } } int offset = read ahead limit ; ( offset size ) { offset = size ; } cb . set limit ( cb . get start ( ) offset ) ; mark po = cb . get start ( ) ; }	public void reset ( ) throw ioexcept { ( state = = char state ) { ( mark po 0 ) { cb . recycl ( ) ; mark po = 1 ; throw new ioexcept ( ) ; } els { cb . set offset ( mark po ) ; } } els { bb . recycl ( ) ; } }
public us event updat connect state . param request servlet request process param respons servlet respons creat except ioexcept input output error occur except servlet except servlet error occur void event ( request request , respons respons , comet event event ) throw ioexcept , servlet except { perform request boolean ok = fals ; try { get next ( ) . event ( request , respons , event ) ; ok = true ; } final { ( ok respons . close ( ) ( event . get event type ( ) = = comet event . event type . end ) ( event . get event type ( ) = = comet event . event type . error ( event . get event sub type ( ) = = comet event . event sub type . timeout ) ) ) { remov from track list , connect done http session session = request . get session ( true ) ; synchron ( session ) { connect info connect info = connect . get ( session . get id ( ) ) ; ( connect info = null ) { boolean found = fals ; ( int i = 0 ; found ( i connect info . length ) ; i ) { found = ( connect info i . request = = request ) ; } ( found ) { connect info new connect info = new connect info connect info . length 1 ; int po = 0 ; ( int i = 0 ; i connect info . length ; i ) { ( connect info i . request = request ) { new connect info po = connect info i ; } } connect . put ( session . get id ( ) , new connect info ) ; } } } } } }	public regist request track , whenev need . param request servlet request process param respons servlet respons creat except ioexcept input output error occur except servlet except servlet error occur void invok ( request request , respons respons ) throw ioexcept , servlet except { perform request get next ( ) . invok ( request , respons ) ; ( request . comet ( ) respons . close ( ) ) { start track thi connect , sinc thi begin event , comet mode http session session = request . get session ( true ) ; connect info new connect info = new connect info ( ) ; new connect info . request = request ; new connect info . respons = respons ; new connect info . event = request . get event ( ) ; synchron ( session ) { string id = session . get id ( ) ; connect info connect info = connect . get ( id ) ; ( connect info = = null ) { connect info = new connect info 1 ; connect info 0 = new connect info ; connect . put ( id , connect info ) ; } els { connect info new connect info = new connect info connect info . length 1 ; ( int i = 0 ; i connect info . length ; i ) { new connect info i = connect info i ; } new connect info connect info . length = new connect info ; connect . put ( id , new connect info ) ; } } } }	public void lifecycl event ( lifecycl event event ) { ( event . get type ( ) = = lifecycl . befor stop event ) { webapp get stop , so all current connect should close close all comet connect associ thi session iter connect info iter = connect . valu ( ) . iter ( ) ; while ( iter . ha next ( ) ) { connect info connect info = iter . next ( ) ; ( connect info = null ) { ( int i = 0 ; i connect info . length ; i ) { connect info connect info = connect info i ; try { ( ( comet event impl ) connect info . event ) . set event type ( comet event . event type . end ) ; ( ( comet event impl ) connect info . event ) . set event sub type ( comet event . event sub type . webapp reload ) ; get next ( ) . event ( connect info . request , connect info . respons , connect info . event ) ; connect info . event . close ( ) ; } catch ( except e ) { contain . get logger ( ) . warn ( sm . get string ( comet connect manag valv . event ) , e ) ; } } } } connect . clear ( ) ; } }	public void session destroi ( http session event se ) { close all comet connect associ thi session connect info connect info = connect . remov ( se . get session ( ) . get id ( ) ) ; ( connect info = null ) { ( int i = 0 ; i connect info . length ; i ) { connect info connect info = connect info i ; try { ( ( comet event impl ) connect info . event ) . set event type ( comet event . event type . end ) ; ( ( comet event impl ) connect info . event ) . set event sub type ( comet event . event sub type . session end ) ; get next ( ) . event ( connect info . request , connect info . respons , connect info . event ) ; connect info . event . close ( ) ; } catch ( except e ) { contain . get logger ( ) . warn ( sm . get string ( comet connect manag valv . event ) , e ) ; } } } }	public gracefulli termin activ us public method thi compon . thi method should last call given instanc thi compon . except lifecycl except thi compon detect fatal error need report void stop ( ) throw lifecycl except { valid updat our current compon state ( start ) throw new lifecycl except ( sm . get string ( semaphor valv . start ) ) ; lifecycl . fire lifecycl event ( stop event , null ) ; start = fals ; ( contain instanceof context ) { ( ( lifecycl ) contain ) . remov lifecycl listen ( thi ) ; } webapp get stop , so all current connect should close close all comet connect associ thi session note : thi onli done contain wa context ( otherwis , thi need done befor stop , servlet would dealloc alreadi ) iter connect info iter = connect . valu ( ) . iter ( ) ; while ( iter . ha next ( ) ) { connect info connect info = iter . next ( ) ; ( connect info = null ) { ( int i = 0 ; i connect info . length ; i ) { connect info connect info = connect info i ; try { connect info . event . close ( ) ; } catch ( except e ) { contain . get logger ( ) . warn ( sm . get string ( comet connect manag valv . event ) , e ) ; } } } } connect . clear ( ) ; }
public method void init ( ) throw except { ( initi ) return ; initi thread count default acceptor ( acceptor thread count = = 0 ) { acceptor thread count = 1 ; } ( server socket factori = = null ) { server socket factori = server socket factori . get default ( ) ; } ( server socket = = null ) { try { ( address = = null ) { server socket = server socket factori . creat socket ( port , backlog ) ; } els { server socket = server socket factori . creat socket ( port , backlog , address ) ; } } catch ( bind except ) { throw new bind except ( . get messag ( ) : port ) ; } } ( server timeout = 0 ) server socket . set so timeout ( server timeout ) ; initi = true ; }
public print writer get writer ( ) throw unsupport encod except { ( writer = = null ) { output stream writer w ; w = new output stream writer ( bodi , get charact encod ( ) ) ; writer = new print writer ( w ) ; } return writer ; }	public servlet output stream get output stream ( ) throw ioexcept { return bodi ; }	public string get charact encod ( ) { return resp . get charact encod ( ) ; }	public dispatch client request protect code servic code method . s need overrid thi method . param req { link http servlet request } object contain request client made servlet param re { link http servlet respons } object contain respons servlet return client except ioexcept input output error occur while servlet handl http request except servlet except http request cannot handl see javax . servlet . servlet servic void servic ( servlet request req , servlet respons re ) throw servlet except , ioexcept { http servlet request request ; http servlet respons respons ; try { request = ( http servlet request ) req ; respons = ( http servlet respons ) re ; } catch ( class cast except e ) { throw new servlet except ( non http request respons ) ; } servic ( request , respons ) ; }	public servlet respons interfac method void set content length ( int len ) { resp . set content length ( len ) ; did set content length = true ; }	public void servic ( servlet request req , servlet respons re ) throw servlet except , ioexcept { http servlet request request ; http servlet respons respons ; try { request = ( http servlet request ) req ; respons = ( http servlet respons ) re ; } catch ( class cast except e ) { throw new servlet except ( non http request respons ) ; } servic ( request , respons ) ; }
protect return xsl templat inputstream ( possibl ) input stream find xslt input stream ( dir context directori ) throw ioexcept , servlet except { ( local xslt file = null ) { try { object obj = directori . lookup ( local xslt file ) ; ( ( obj = null ) ( obj instanceof resourc ) ) { input stream = ( ( resourc ) obj ) . stream content ( ) ; ( = null ) return ; } } catch ( name except e ) { throw new servlet except ( error open xslt resourc , e ) ; } } open read file fell swoop reduc chanc chanc leav handl open . ( global xslt file = null ) { file input stream fi = null ; try { file f = new file ( global xslt file ) ; ( f . exist ( ) ) { fi = new file input stream ( f ) ; byte b = new byte ( int ) f . length ( ) ; danger fi . read ( b ) ; return new byte arrai input stream ( b ) ; } } final { ( fi = null ) fi . close ( ) ; } } return null ; }	protect get readm file string . string get readm ( dir context directori ) throw ioexcept , servlet except { ( readm file = null ) { try { object obj = directori . lookup ( readm file ) ; ( ( obj = null ) ( obj instanceof resourc ) ) { string writer buffer = new string writer ( ) ; input stream = ( ( resourc ) obj ) . stream content ( ) ; copi rang ( new input stream reader ( ) , new print writer ( buffer ) ) ; return buffer . string ( ) ; } } catch ( name except e ) { throw new servlet except ( error open readm resourc , e ) ; } } return null ; }
protect boolean process socket ( nio channel socket , socket statu statu , boolean dispatch ) { try { kei attach attach = ( kei attach ) socket . get attach ( fals ) ; get reset upon next reg attach . set comet notifi ( fals ) ; ( executor = = null ) { get worker thread ( ) . assign ( socket , statu ) ; } els { socket processor sc = processor cach . poll ( ) ; ( sc = = null ) sc = new socket processor ( socket , statu ) ; els sc . reset ( socket , statu ) ; ( dispatch ) executor . execut ( sc ) ; els sc . run ( ) ; } } catch ( throwabl t ) { thi mean we got oom similar creat thread , pool queue ar full log . error ( sm . get string ( endpoint . process . fail ) , t ) ; return fals ; } return true ; }
public find specifi class our local repositori , possibl . found , throw code class found except code . param name name class load except class found except class wa found class find class ( string name ) throw class found except { ( log . debug enabl ( ) ) log . debug ( find class ( name ) ) ; cannot load anyth from local repositori class loader stop ( start ) { throw new class found except ( name ) ; } ( 1 ) permiss defin thi class when us secur manag ( secur manag = null ) { int i = name . last index ( . ) ; ( i = 0 ) { try { ( log . trace enabl ( ) ) log . trace ( secur manag . check packag definit ) ; secur manag . check packag definit ( name . substr ( 0 , i ) ) ; } catch ( except se ) { ( log . trace enabl ( ) ) log . trace ( except class found except , se ) ; throw new class found except ( name , se ) ; } } } ask our superclass locat thi class , possibl ( throw class found except found ) class clazz = null ; try { ( log . trace enabl ( ) ) log . trace ( find class intern ( name ) ) ; try { clazz = find class intern ( name ) ; } catch ( class found except cnfe ) { ( ha extern repositori ) { throw cnfe ; } } catch ( access control except ac ) { throw new class found except ( name , ac ) ; } catch ( runtim except e ) { ( log . trace enabl ( ) ) log . trace ( runtim except rethrown , e ) ; throw e ; } ( ( clazz = = null ) ha extern repositori ) { try { synchron ( thi ) { clazz = super . find class ( name ) ; } } catch ( access control except ac ) { throw new class found except ( name , ac ) ; } catch ( runtim except e ) { ( log . trace enabl ( ) ) log . trace ( runtim except rethrown , e ) ; throw e ; } } ( clazz = = null ) { ( log . debug enabl ( ) ) log . debug ( return class found except ) ; throw new class found except ( name ) ; } } catch ( class found except e ) { ( log . trace enabl ( ) ) log . trace ( pass class found except ) ; throw e ; } return class we have locat ( log . trace enabl ( ) ) log . debug ( return class clazz ) ; ( ( log . trace enabl ( ) ) ( clazz = null ) ) log . debug ( load clazz . get class loader ( ) ) ; return ( clazz ) ; }	public object run ( ) { return find resourc intern ( file , path ) ; }
public add new listen class name set listen configur thi applic . param listen java class name listen class void add applic listen ( string listen ) { synchron ( applic listen ) { string result = new string applic listen . length 1 ; ( int i = 0 ; i applic listen . length ; i ) { ( listen . equal ( applic listen i ) ) return ; result i = applic listen i ; } result applic listen . length = listen ; applic listen = result ; } fire contain event ( add applic listen , listen ) ; fixm add instanc alreadi start }
protect get ssl server s truststor . kei store get trust store ( string keystor type ) throw ioexcept { kei store trust store = null ; string trust store file = ( string ) attribut . get ( truststor file ) ; ( trust store file = = null ) { trust store file = system . get properti ( javax . net . ssl . trust store ) ; } ( log . debug enabl ( ) ) { log . debug ( truststor = trust store file ) ; } string trust store password = ( string ) attribut . get ( truststor pass ) ; ( trust store password = = null ) { trust store password = system . get properti ( javax . net . ssl . trust store password ) ; } ( trust store password = = null ) { trust store password = get keystor password ( ) ; } ( log . debug enabl ( ) ) { log . debug ( trust pass = trust store password ) ; } string truststor type = ( string ) attribut . get ( truststor type ) ; ( truststor type = = null ) { truststor type = keystor type ; } ( log . debug enabl ( ) ) { log . debug ( trust type = truststor type ) ; } ( trust store file = null trust store password = null ) { trust store = get store ( truststor type , trust store file , trust store password ) ; } return trust store ; }
public render html list current activ context our virtual host , memori server statu inform . param request request param respons respons param messag messag displai void list ( http servlet request request , http servlet respons respons , string messag ) throw ioexcept { ( debug = 1 ) log ( list : list context virtual host host . get name ( ) ) ; print writer writer = respons . get writer ( ) ; html header section writer . print ( constant . html header section ) ; bodi header section object arg = new object 2 ; arg 0 = request . get context path ( ) ; arg 1 = sm . get string ( html manag servlet . titl ) ; writer . print ( messag format . format ( constant . bodi header section , arg ) ) ; messag section arg = new object 3 ; arg 0 = sm . get string ( html manag servlet . messag label ) ; ( messag = = null messag . length ( ) = = 0 ) { arg 1 = ok ; } els { arg 1 = request util . filter ( messag ) ; } writer . print ( messag format . format ( constant . messag section , arg ) ) ; manag section arg = new object 9 ; arg 0 = sm . get string ( html manag servlet . manag ) ; arg 1 = respons . encod url ( request . get context path ( ) html list ) ; arg 2 = sm . get string ( html manag servlet . list ) ; arg 3 = respons . encod url ( request . get context path ( ) sm . get string ( html manag servlet . help html manag file ) ) ; arg 4 = sm . get string ( html manag servlet . help html manag ) ; arg 5 = respons . encod url ( request . get context path ( ) sm . get string ( html manag servlet . help manag file ) ) ; arg 6 = sm . get string ( html manag servlet . help manag ) ; arg 7 = respons . encod url ( request . get context path ( ) statu ) ; arg 8 = sm . get string ( statu servlet . titl ) ; writer . print ( messag format . format ( constant . manag section , arg ) ) ; app header section arg = new object 6 ; arg 0 = sm . get string ( html manag servlet . app titl ) ; arg 1 = sm . get string ( html manag servlet . app path ) ; arg 2 = sm . get string ( html manag servlet . app name ) ; arg 3 = sm . get string ( html manag servlet . app avail ) ; arg 4 = sm . get string ( html manag servlet . app session ) ; arg 5 = sm . get string ( html manag servlet . app task ) ; writer . print ( messag format . format ( app header section , arg ) ) ; app row section creat sort map deploi applic context path . contain children = host . find children ( ) ; string context path = new string children . length ; ( int i = 0 ; i children . length ; i ) context path i = children i . get name ( ) ; tree map sort context path map = new tree map ( ) ; ( int i = 0 ; i context path . length ; i ) { string displai path = context path i ; sort context path map . put ( displai path , context path i ) ; } string app start = sm . get string ( html manag servlet . app start ) ; string app stop = sm . get string ( html manag servlet . app stop ) ; string app reload = sm . get string ( html manag servlet . app reload ) ; string app undeploi = sm . get string ( html manag servlet . app undeploi ) ; string app expir = sm . get string ( html manag servlet . app expir ) ; iter iter = sort context path map . entri set ( ) . iter ( ) ; boolean highlight = true ; boolean deploi = true ; string highlight color = null ; while ( iter . ha next ( ) ) { bugzilla 34818 , altern row color highlight = highlight ; ( highlight ) { highlight color = c3f3c3 ; } els { highlight color = ffffff ; } map . entri entri = ( map . entri ) iter . next ( ) ; string displai path = ( string ) entri . get kei ( ) ; string context path = ( string ) entri . get kei ( ) ; context context = ( context ) host . find child ( context path ) ; ( displai path . equal ( ) ) { displai path = ; } ( context = null ) { try { deploi = deploi ( context path ) ; } catch ( except e ) { assum fals failur safeti deploi = fals ; } arg = new object 6 ; arg 0 = displai path ; arg 1 = context . get displai name ( ) ; ( arg 1 = = null ) { arg 1 = nbsp ; ; } arg 2 = new boolean ( context . get avail ( ) ) ; arg 3 = respons . encod url ( request . get context path ( ) html session path = displai path ) ; ( context . get manag ( ) = null ) { arg 4 = new integ ( context . get manag ( ) . get activ session ( ) ) ; } els { arg 4 = new integ ( 0 ) ; } arg 5 = highlight color ; writer . print ( messag format . format ( app row detail section , arg ) ) ; arg = new object 14 ; arg 0 = respons . encod url ( request . get context path ( ) html start path = displai path ) ; arg 1 = app start ; arg 2 = respons . encod url ( request . get context path ( ) html stop path = displai path ) ; arg 3 = app stop ; arg 4 = respons . encod url ( request . get context path ( ) html reload path = displai path ) ; arg 5 = app reload ; arg 6 = respons . encod url ( request . get context path ( ) html undeploi path = displai path ) ; arg 7 = app undeploi ; arg 8 = respons . encod url ( request . get context path ( ) html expir path = displai path ) ; arg 9 = app expir ; arg 10 = sm . get string ( html manag servlet . expir . explain ) ; arg 11 = new integ ( context . get manag ( ) . get max inact interv ( ) 60 ) ; arg 12 = sm . get string ( html manag servlet . expir . unit ) ; arg 13 = highlight color ; ( context . get path ( ) . equal ( thi . context . get path ( ) ) ) { writer . print ( messag format . format ( manag app row button section , arg ) ) ; } els ( context . get avail ( ) deploi ) { writer . print ( messag format . format ( start deploi app row button section , arg ) ) ; } els ( context . get avail ( ) deploi ) { writer . print ( messag format . format ( start nondeploi app row button section , arg ) ) ; } els ( context . get avail ( ) deploi ) { writer . print ( messag format . format ( stop deploi app row button section , arg ) ) ; } els { writer . print ( messag format . format ( stop nondeploi app row button section , arg ) ) ; } } } deploi section arg = new object 7 ; arg 0 = sm . get string ( html manag servlet . deploi titl ) ; arg 1 = sm . get string ( html manag servlet . deploi server ) ; arg 2 = respons . encod url ( request . get context path ( ) html deploi ) ; arg 3 = sm . get string ( html manag servlet . deploi path ) ; arg 4 = sm . get string ( html manag servlet . deploi config ) ; arg 5 = sm . get string ( html manag servlet . deploi war ) ; arg 6 = sm . get string ( html manag servlet . deploi button ) ; writer . print ( messag format . format ( deploi section , arg ) ) ; arg = new object 4 ; arg 0 = sm . get string ( html manag servlet . deploi upload ) ; arg 1 = respons . encod url ( request . get context path ( ) html upload ) ; arg 2 = sm . get string ( html manag servlet . deploi upload file ) ; arg 3 = sm . get string ( html manag servlet . deploi button ) ; writer . print ( messag format . format ( upload section , arg ) ) ; server header section arg = new object 7 ; arg 0 = sm . get string ( html manag servlet . server titl ) ; arg 1 = sm . get string ( html manag servlet . server version ) ; arg 2 = sm . get string ( html manag servlet . server jvmversion ) ; arg 3 = sm . get string ( html manag servlet . server jvmvendor ) ; arg 4 = sm . get string ( html manag servlet . server osnam ) ; arg 5 = sm . get string ( html manag servlet . server osvers ) ; arg 6 = sm . get string ( html manag servlet . server osarch ) ; writer . print ( messag format . format ( constant . server header section , arg ) ) ; server row section arg = new object 6 ; arg 0 = server info . get server info ( ) ; arg 1 = system . get properti ( java . runtim . version ) ; arg 2 = system . get properti ( java . vm . vendor ) ; arg 3 = system . get properti ( os . name ) ; arg 4 = system . get properti ( os . version ) ; arg 5 = system . get properti ( os . arch ) ; writer . print ( messag format . format ( constant . server row section , arg ) ) ; html tail section writer . print ( constant . html tail section ) ; finish up respons writer . flush ( ) ; writer . close ( ) ; }
protect pars crlf end chunk . boolean pars crlf ( ) throw ioexcept { boolean eol = fals ; while ( eol ) { ( po = last valid ) { ( read byte ( ) = 0 ) throw new ioexcept ( invalid crlf ) ; } ( buf po = = constant . cr ) { } els ( buf po = = constant . lf ) { eol = true ; } els { throw new ioexcept ( invalid crlf ) ; } po ; } return true ; }	public int do read ( byte chunk chunk , request req ) throw ioexcept { ( end chunk ) return 1 ; ( need crlfpars ) { need crlfpars = fals ; pars crlf ( ) ; } ( remain = 0 ) { ( pars chunk header ( ) ) { throw new ioexcept ( invalid chunk header ) ; } ( end chunk ) { pars end chunk ( ) ; return 1 ; } } int result = 0 ; ( po = last valid ) { read byte ( ) ; } ( remain ( last valid po ) ) { result = last valid po ; remain = remain result ; chunk . set byte ( buf , po , result ) ; po = last valid ; } els { result = remain ; chunk . set byte ( buf , po , remain ) ; po = po remain ; remain = 0 ; need crlfpars = true ; } return result ; }
privat pars taglib direct follow syntax : direct : : = ( s attribut ) void pars taglib direct ( node parent ) throw jasper except { attribut attr = pars attribut ( ) ; string uri = attr . get valu ( uri ) ; string prefix = attr . get valu ( prefix ) ; ( prefix = null ) { mark prev mark = page info . get non custom tag prefix ( prefix ) ; ( prev mark = null ) { err . jsp error ( reader . mark ( ) , jsp . error . prefix . us befor dcl , prefix , prev mark . get file ( ) , prev mark . get line number ( ) ) ; } ( uri = null ) { string uri prev = page info . get uri ( prefix ) ; ( uri prev = null uri prev . equal ( uri ) ) { err . jsp error ( reader . mark ( ) , jsp . error . prefix . refin , prefix , uri , uri prev ) ; } ( page info . get taglib ( uri ) = = null ) { tag librari info impl impl = null ; ( ctxt . get option ( ) . cach ( ) ) { impl = ( tag librari info impl ) ctxt . get option ( ) . get cach ( ) . get ( uri ) ; } ( impl = = null ) { string locat = ctxt . get tld locat ( uri ) ; impl = new tag librari info impl ( ctxt , parser control , page info , prefix , uri , locat , err ) ; ( ctxt . get option ( ) . cach ( ) ) { ctxt . get option ( ) . get cach ( ) . put ( uri , impl ) ; } } page info . add taglib ( uri , impl ) ; } page info . add prefix map ( prefix , uri ) ; } els { string tagdir = attr . get valu ( tagdir ) ; ( tagdir = null ) { string urn tagdir = urn jsptagdir tagdir ; ( page info . get taglib ( urn tagdir ) = = null ) { page info . add taglib ( urn tagdir , new implicit tag librari info ( ctxt , parser control , page info , prefix , tagdir , err ) ) ; } page info . add prefix map ( prefix , urn tagdir ) ; } } } new node . taglib direct ( attr , start , parent ) ; }
privat add thi node bodi given parent . void add parent ( node parent ) { ( parent = null ) { thi . parent = parent ; node parent bodi = parent . get bodi ( ) ; ( parent bodi = = null ) { parent bodi = new node ( ) ; parent . set bodi ( parent bodi ) ; } parent bodi . add ( thi ) ; } }
public method get invok ( string anam , object param , string signatur , base model mbean bean , object resourc ) throw mbean except , reflect except { method method = null ; ( method = = null ) { ( param = = null ) param = new object 0 ; ( signatur = = null ) signatur = new string 0 ; ( param . length = signatur . length ) throw new runtim oper except ( new illeg argument except ( inconsist argument signatur ) , inconsist argument signatur ) ; acquir model mbean oper info inform request oper oper info op info = ( oper info ) oper . get ( anam ) ; ( op info = = null ) throw new mbean except ( new servic found except ( cannot find oper anam ) , cannot find oper anam ) ; prepar signatur requir java reflect api fixm should we us signatur from op info class type = new class signatur . length ; ( int i = 0 ; i signatur . length ; i ) { type i = base model mbean . get attribut class ( signatur i ) ; } locat method invok , either thi mbean itself correspond manag resourc fixm access method superinterfac object object = null ; except except = null ; try { object = thi ; method = object . get class ( ) . get method ( anam , type ) ; } catch ( method except e ) { except = e ; ; } try { ( ( method = = null ) ( resourc = null ) ) { object = resourc ; method = object . get class ( ) . get method ( anam , type ) ; } } catch ( method except e ) { except = e ; } ( method = = null ) { throw new reflect except ( except , cannot find method anam thi signatur ) ; } invok att map . put ( mkei , method ) ; } return method ; }	public method get setter ( string anam , base model mbean bean , object resourc ) throw attribut found except , mbean except , reflect except { cach mai need getter , realli bad idea setter , thi far less frequent . ( method ) set att map . get ( name ) ; method m = null ; ( m = = null ) { attribut info attr info = ( attribut info ) attribut . get ( anam ) ; ( attr info = = null ) throw new attribut found except ( cannot find attribut anam ) ; look up actual oper us string set method = attr info . get set method ( ) ; ( set method = = null ) throw new attribut found except ( cannot find attribut anam set method name ) ; string arg type = attr info . get type ( ) ; class signatur = new class { base model mbean . get attribut class ( arg type ) } ; object object = null ; method except except = null ; try { object = thi ; m = object . get class ( ) . get method ( set method , signatur ) ; } catch ( method except e ) { except = e ; ; } ( m = = null resourc = null ) { try { object = resourc ; m = object . get class ( ) . get method ( set method , signatur ) ; except = null ; } catch ( method except e ) { except = e ; } } ( except = null ) throw new reflect except ( except , cannot find setter method set method resourc ) ; set att map . put ( name , m ) ; } return m ; }
public void set valu ( evalu context ctx , object valu ) throw elexcept { target t = get target ( ctx ) ; ctx . set properti resolv ( fals ) ; ctx . get elresolv ( ) . set valu ( ctx , t . base , t . properti , valu ) ; }
public get creation date . return creation date valu date get creation date ( ) { ( creation = = 1l ) { creation = file . last modifi ( ) ; } return super . get creation date ( ) ; }	public get last modifi date . return last modifi date valu date get last modifi date ( ) { ( last modifi = = 1l ) { last modifi = file . last modifi ( ) ; } return super . get last modifi date ( ) ; }	public input stream stream content ( ) throw ioexcept { ( binari content = = null ) { input stream = new file input stream ( file ) ; } return super . stream content ( ) ; }	public get creation time . return creation time valu long get creation ( ) { ( creation = 1l ) return creation ; creation = file . last modifi ( ) ; return creation ; }
protect pars addit request paramet . boolean post pars request ( org . apach . coyot . request req , request request , org . apach . coyot . respons re , respons respons ) throw except { otherwis , us connector configur ( req . scheme ( ) . null ( ) ) { us processor specifi scheme determin secur state request . set secur ( req . scheme ( ) . equal ( http ) ) ; } els { us connector scheme secur configur , ( default http fals respect ) req . scheme ( ) . set string ( connector . get scheme ( ) ) ; request . set secur ( connector . get secur ( ) ) ; } fixm : code below doesnt belong here , thi onli have sens http11 , ajp13 . . thi point host header ha been process . overrid proxi port proxi host ar set string proxi name = connector . get proxi name ( ) ; int proxi port = connector . get proxi port ( ) ; ( proxi port = 0 ) { req . set server port ( proxi port ) ; } ( proxi name = null ) { req . server name ( ) . set string ( proxi name ) ; } pars session id pars session id ( req , request ) ; uri decod messag byte decod uri = req . decod uri ( ) ; decod uri . duplic ( req . request uri ( ) ) ; ( decod uri . get type ( ) = = messag byte . t byte ) { remov ani path paramet byte chunk uri bb = decod uri . get byte chunk ( ) ; int semicolon = uri bb . index ( ; , 0 ) ; ( semicolon 0 ) { decod uri . set byte ( uri bb . get buffer ( ) , uri bb . get start ( ) , semicolon ) ; } xx decod url try { req . get urldecod ( ) . convert ( decod uri , fals ) ; } catch ( ioexcept ioe ) { re . set statu ( 400 ) ; re . set messag ( invalid uri : ioe . get messag ( ) ) ; return fals ; } normal ( normal ( req . decod uri ( ) ) ) { re . set statu ( 400 ) ; re . set messag ( invalid uri ) ; return fals ; } charact decod convert uri ( decod uri , request ) ; } els { url char string , ha been sent us memori protocol handler , we have assum url ha been properli decod alreadi decod uri . char ( ) ; remov ani path paramet char chunk uri cc = decod uri . get char chunk ( ) ; int semicolon = uri cc . index ( ; ) ; ( semicolon 0 ) { decod uri . set char ( uri cc . get buffer ( ) , uri cc . get start ( ) , semicolon ) ; } } set remot princip string princip = req . get remot user ( ) . string ( ) ; ( princip = null ) { request . set user princip ( new coyot princip ( princip ) ) ; } set author type string authtyp = req . get auth type ( ) . string ( ) ; ( authtyp = null ) { request . set auth type ( authtyp ) ; } request map . messag byte server name ; ( connector . get us ipvhost ( ) ) { server name = req . local name ( ) ; ( server name . null ( ) ) { well , thei did ask re . action ( action code . action req local name attribut , null ) ; } } els { server name = req . server name ( ) ; } connector . get mapper ( ) . map ( server name , decod uri , request . get map data ( ) ) ; request . set context ( ( context ) request . get map data ( ) . context ) ; request . set wrapper ( ( wrapper ) request . get map data ( ) . wrapper ) ; filter trace method ( connector . get allow trace ( ) req . method ( ) . equal ignor case ( trace ) ) { wrapper wrapper = request . get wrapper ( ) ; string header = null ; ( wrapper = null ) { string method = wrapper . get servlet method ( ) ; ( method = null ) { ( int i = 0 ; i method . length ; i ) { ( trace . equal ( method i ) ) { continu ; } ( header = = null ) { header = method i ; } els { header = , method i ; } } } } re . set statu ( 405 ) ; re . add header ( allow , header ) ; re . set messag ( trace method allow ) ; return fals ; } possibl redirect messag byte redirect path mb = request . get map data ( ) . redirect path ; ( redirect path mb . null ( ) ) { string redirect path = redirect path mb . string ( ) ; string queri = request . get queri string ( ) ; ( request . request session id from url ( ) ) { thi optim , thi veri common , shouldn t matter redirect path = redirect path ; global . session paramet name = request . get request session id ( ) ; } ( queri = null ) { thi optim , thi veri common , shouldn t matter redirect path = redirect path queri ; } respons . send redirect ( redirect path ) ; return fals ; } pars session id pars session cooki id ( req , request ) ; return true ; }
public void set properti resolv ( boolean resolv ) { thi . el context . set properti resolv ( resolv ) ; }
protect final number coerc ( final object obj ) { ( number ( obj ) ) { return coerc ( ( number ) obj ) ; } ( obj instanceof string ) { return coerc ( ( string ) obj ) ; } ( obj = = null . equal ( obj ) ) { return coerc ( zero ) ; } class obj type = obj . get class ( ) ; ( charact . class . equal ( obj type ) charact . type = = obj type ) { return coerc ( new short ( ( short ) ( ( charact ) obj ) . char valu ( ) ) ) ; } throw new illeg argument except ( messag factori . get ( el . convert , obj , obj type ) ) ; }
protect compar get compar ( string sort ) { compar compar = null ; ( creation time . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return new date ( session . get creation time ( ) ) ; } } ; } els ( id . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return session . get id ( ) ; } } ; } els ( last access time . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return new date ( session . get last access time ( ) ) ; } } ; } els ( max inact interv . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return new date ( session . get max inact interv ( ) ) ; } } ; } els ( new . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return boolean . valu ( session . get session ( ) . new ( ) ) ; } } ; } els ( local . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return jsp helper . guess displai local from session ( session ) ; } } ; } els ( user . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return jsp helper . guess displai user from session ( session ) ; } } ; } els ( us time . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return new date ( session util . get us time session ( session ) ) ; } } ; } els ( inact time . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return new date ( session util . get inact time session ( session ) ) ; } } ; } els ( ttl . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return new date ( session util . get ttlfor session ( session ) ) ; } } ; } todo : complet thi ttl , etc . return compar ; }
protect identifi return code java . secur . princip code instanc repres authent user specifi code subject code . princip construct scan list princip return jaaslogin modul . first code princip code object match class name suppli user class user princip . thi object return tha caller . ani remain princip object return login modul ar map role , onli respect class match role class class . user princip cannot construct , return code null code . param subject code subject code repres log user princip creat princip ( string usernam , subject subject ) { prepar scan princip thi subject list string role = new arrai list string ( ) ; princip user princip = null ; scan princip thi subject iter princip = subject . get princip ( ) . iter ( ) ; while ( princip . ha next ( ) ) { princip princip = ( princip ) princip . next ( ) ; string princip class = princip . get class ( ) . get name ( ) ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jaa realm . check princip , princip , princip class ) ) ; } ( user princip = = null user class . contain ( princip class ) ) { user princip = princip ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jaa realm . user princip success , princip . get name ( ) ) ) ; } } ( role class . contain ( princip class ) ) { role . add ( princip . get name ( ) ) ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jaa realm . role princip add , princip . get name ( ) ) ) ; } } } print failur messag need ( user princip = = null ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jaa realm . user princip failur ) ) ; log . debug ( sm . get string ( jaa realm . role princip failur ) ) ; } } els { ( role . size ( ) = = 0 ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jaa realm . role princip failur ) ) ; } } } return result princip our authent user return new gener princip ( thi , usernam , null , role , user princip ) ; }	protect pars comma delimit list class name , store class name provid list . each class must implement codejava . secur . princip code . param class name string comma delimit list fulli qualifi class name . param class name list list which class name store . list clear befor popul . void pars class name ( string class name string , list string class name list ) { class name list . clear ( ) ; ( class name string = = null ) return ; string class name = class name string . split ( , ) ; ( int i = 0 ; i class name . length ; i ) { ( class name i . length ( ) = = 0 ) continu ; try { class princip class = class . name ( class name i ) ; ( princip . class . assign from ( princip class ) ) { class name list . add ( class name i ) ; } els { log . error ( class class name i implement java . secur . princip class ad . ) ; } } catch ( class found except e ) { log . error ( class class name i found class ad . ) ; } } }	public return code princip code associ specifi usernam credenti , ; otherwis return code null code . ar ani error jdbc connect , execut queri anyth we return null ( don t authent ) . thi event also log , connect close so subsequ request automat re open . param usernam usernam code princip code look up param credenti password other credenti us authent thi usernam princip authent ( string usernam , string credenti ) { establish login context us authent try { login context login context = null ; ( app name = = null ) app name = tomcat ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . begin login , usernam , app name ) ) ; what login modul contain class loader class loader ocl = null ; ( us context class loader ( ) ) { ocl = thread . current thread ( ) . get context class loader ( ) ; thread . current thread ( ) . set context class loader ( thi . get class ( ) . get class loader ( ) ) ; } try { login context = new login context ( app name , new jaascallback handler ( thi , usernam , credenti ) ) ; } catch ( throwabl e ) { log . error ( sm . get string ( jaa realm . unexpect error ) , e ) ; return ( null ) ; } final { ( us context class loader ( ) ) { thread . current thread ( ) . set context class loader ( ocl ) ; } } ( log . debug enabl ( ) ) log . debug ( login context creat usernam ) ; negoti login via thi login context subject subject = null ; try { login context . login ( ) ; subject = login context . get subject ( ) ; ( subject = = null ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . fail login , usernam ) ) ; return ( null ) ; } } catch ( account expir except e ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . account expir , usernam ) ) ; return ( null ) ; } catch ( credenti expir except e ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . credenti expir , usernam ) ) ; return ( null ) ; } catch ( fail login except e ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . fail login , usernam ) ) ; return ( null ) ; } catch ( login except e ) { log . warn ( sm . get string ( jaa realm . login except , usernam ) , e ) ; return ( null ) ; } catch ( throwabl e ) { log . error ( sm . get string ( jaa realm . unexpect error ) , e ) ; return ( null ) ; } ( log . debug enabl ( ) ) log . debug ( sm . get string ( jaa realm . login context creat , usernam ) ) ; return appropri princip thi authent subject princip princip = creat princip ( usernam , subject ) ; ( princip = = null ) { log . debug ( sm . get string ( jaa realm . authent failur , usernam ) ) ; return ( null ) ; } ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jaa realm . authent success , usernam ) ) ; } return ( princip ) ; } catch ( throwabl t ) { log . error ( error , t ) ; return null ; } }	public string get role class name ( ) { return ( thi . role class name ) ; }	public string get user class name ( ) { return ( thi . user class name ) ; }	public set list comma delimit class repres role . class list must implement code java . secur . princip code . when thi accessor call ( exampl , code digest code instanc pars configur file ) , pars class name store result string ( s ) code arrai list code field code role class code . void set role class name ( string role class name ) { thi . role class name = role class name ; pars class name ( role class name , role class ) ; }	public set list comma delimit class repres individu user . class list must implement code java . secur . princip code . when thi accessor call ( exampl , code digest code instanc pars configur file ) , pars class name store result string ( s ) code arrai list code field code user class code . void set user class name ( string user class name ) { thi . user class name = user class name ; pars class name ( user class name , user class ) ; }	public prepar activ us public method thi code compon code . except lifecycl except thi compon detect fatal error prevent from start void start ( ) throw lifecycl except { perform normal superclass initi super . start ( ) ; }
public clear ani content written buffer . except illeg state except thi respons ha alreadi been commit void reset ( ) { ( includ ) ignor ani call from includ servlet return ; coyot respons . reset ( ) ; output buffer . reset ( ) ; }
privat return context rel path , begin , repres canon version specifi path after . . . element ar resolv out . specifi path attempt go outsid boundari current context ( i . e . too mani . . path element ar present ) , return code null code instead . param path path normal string normal ( string path ) { ( path = = null ) { return null ; } string normal = path ; normal slash add lead slash necessari ( normal . index ( ) = 0 ) normal = normal . replac ( , ) ; resolv occurr . . normal path while ( true ) { int index = normal . index ( . . ) ; ( index 0 ) break ; ( index = = 0 ) try go outsid our context return ( null ) ; int index2 = normal . last index ( , index 1 ) ; normal = normal . substr ( 0 , index2 ) normal . substr ( index 3 ) ; } return normal path we have complet return ( normal ) ; }	public return request resourc code input stream code . path must specifi accord rule describ under code get resourc code . resourc can identifi , return code null code . param path path desir resourc . input stream get resourc stream ( string path ) { path = normal ( path ) ; ( path = = null ) return ( null ) ; dir context resourc = context . get resourc ( ) ; ( resourc = null ) { try { object resourc = resourc . lookup ( path ) ; ( resourc instanceof resourc ) return ( ( ( resourc ) resourc ) . stream content ( ) ) ; } catch ( except e ) { } } return ( null ) ; }
public process post request specifi resourc . param request servlet request we ar process param respons servlet respons we ar creat except ioexcept input output error occur except servlet except servlet specifi error occur void do post ( http servlet request request , http servlet respons respons ) throw ioexcept , servlet except { identifi request paramet we need string command = request . get path info ( ) ; ( command = = null command . equal ( upload ) ) { do get ( request , respons ) ; return ; } prepar our output writer gener respons messag respons . set content type ( text html ; charset = constant . charset ) ; string messag = ; creat new file upload handler disk file upload upload = new disk file upload ( ) ; get tempdir file tempdir = ( file ) get servlet context ( ) . get attribut ( javax . servlet . context . tempdir ) ; set upload paramet upload . set size max ( 1 ) ; upload . set repositori path ( tempdir . get canon path ( ) ) ; pars request string basenam = null ; string war = null ; file item war upload = null ; try { list item = upload . pars request ( request ) ; process upload field iter iter = item . iter ( ) ; while ( iter . ha next ( ) ) { file item item = ( file item ) iter . next ( ) ; ( item . form field ( ) ) { ( item . get field name ( ) . equal ( deploi war ) war upload = = null ) { war upload = item ; } els { item . delet ( ) ; } } } while ( true ) { ( war upload = = null ) { messag = sm . get string ( html manag servlet . deploi upload file ) ; break ; } war = war upload . get name ( ) ; ( war . lower case ( ) . end ( . war ) ) { messag = sm . get string ( html manag servlet . deploi upload war , war ) ; break ; } get filenam upload name includ path ( war . last index ( ) = 0 ) { war = war . substr ( war . last index ( ) 1 ) ; } ( war . last index ( ) = 0 ) { war = war . substr ( war . last index ( ) 1 ) ; } identifi app base own host thi context ( ani ) basenam = war . substr ( 0 , war . lower case ( ) . index ( . war ) ) ; file file = new file ( get app base ( ) , war ) ; ( file . exist ( ) ) { messag = sm . get string ( html manag servlet . deploi upload war exist , war ) ; break ; } string path = null ; ( basenam . equal ( root ) ) { path = ; } els { path = basenam ; } ( servic ( path ) ) { add servic ( path ) ; try { war upload . write ( file ) ; perform new deploy check ( path ) ; } final { remov servic ( path ) ; } } break ; } } catch ( except e ) { messag = sm . get string ( html manag servlet . deploi upload fail , e . get messag ( ) ) ; log ( messag , e ) ; } final { ( war upload = null ) { war upload . delet ( ) ; } war upload = null ; } list ( request , respons , messag ) ; }
protect http11apr processor creat processor ( ) { http11apr processor processor = new http11apr processor ( proto . max http header size , proto . endpoint ) ; processor . set adapt ( proto . adapt ) ; processor . set max keep aliv request ( proto . max keep aliv request ) ; processor . set timeout ( proto . timeout ) ; processor . set disabl upload timeout ( proto . disabl upload timeout ) ; processor . set compress ( proto . compress ) ; processor . set compress min size ( proto . compress min size ) ; processor . set compress user agent ( proto . compress user agent ) ; processor . set compress mime type ( proto . compress mime type ) ; processor . set restrict user agent ( proto . restrict user agent ) ; processor . set socket buffer ( proto . socket buffer ) ; processor . set max save post size ( proto . max save post size ) ; processor . set server ( proto . server ) ; regist ( processor ) ; return processor ; }	protect http11processor creat processor ( ) { http11processor processor = new http11processor ( proto . max http header size , proto . endpoint ) ; processor . set adapt ( proto . adapt ) ; processor . set max keep aliv request ( proto . max keep aliv request ) ; processor . set keep aliv timeout ( proto . keep aliv timeout ) ; processor . set timeout ( proto . timeout ) ; processor . set disabl upload timeout ( proto . disabl upload timeout ) ; processor . set compress ( proto . compress ) ; processor . set compress min size ( proto . compress min size ) ; processor . set compress user agent ( proto . compress user agent ) ; processor . set compress mime type ( proto . compress mime type ) ; processor . set restrict user agent ( proto . restrict user agent ) ; processor . set socket buffer ( proto . socket buffer ) ; processor . set max save post size ( proto . max save post size ) ; processor . set server ( proto . server ) ; regist ( processor ) ; return processor ; }	public http11nio processor creat processor ( ) { http11nio processor processor = new http11nio processor ( proto . ep . get socket properti ( ) . get rx buf size ( ) , proto . ep . get socket properti ( ) . get tx buf size ( ) , proto . max http header size , proto . ep ) ; processor . set adapt ( proto . adapt ) ; processor . set max keep aliv request ( proto . max keep aliv request ) ; processor . set timeout ( proto . timeout ) ; processor . set disabl upload timeout ( proto . disabl upload timeout ) ; processor . set compress ( proto . compress ) ; processor . set compress min size ( proto . compress min size ) ; processor . set compress user agent ( proto . compress user agent ) ; processor . set compress mime type ( proto . compress mime type ) ; processor . set restrict user agent ( proto . restrict user agent ) ; processor . set socket buffer ( proto . socket buffer ) ; processor . set max save post size ( proto . max save post size ) ; processor . set server ( proto . server ) ; regist ( processor ) ; return processor ; }
public static param fname param page param err msg buf param line num param ctxt return javac error detail error detail throw jasper except javac error detail creat javac error ( string fname , node . node page , string buffer err msg buf , int line num , jsp compil context ctxt ) throw jasper except { javac error detail javac error ; attempt map javac error line number line jsp page error visitor err visitor = new error visitor ( line num ) ; page . visit ( err visitor ) ; node err node = err visitor . get jsp sourc node ( ) ; ( ( err node = null ) ( err node . get start ( ) = null ) ) { javac error = new javac error detail ( fname , line num , err node . get start ( ) . get file ( ) , err node . get start ( ) . get line number ( ) , err msg buf , ctxt ) ; } els { javac error line number cannot map jsp page line number . exampl , thi case scriptlet miss close brace , which caus havoc try catch final block code gener place around all gener code : result thi , javac error line number outsid rang begin end java line number were gener scriptlet , therefor cannot map start line number scriptlet jsp page . includ just javac error info error detail . javac error = new javac error detail ( fname , line num , err msg buf ) ; } return javac error ; }
privat copi resourc . param req servlet request param resp servlet respons return boolean true copi success boolean copi resourc ( http servlet request req , http servlet respons resp ) throw servlet except , ioexcept { pars destin header string destin path = req . get header ( destin ) ; ( destin path = = null ) { resp . send error ( webdav statu . sc bad request ) ; return fals ; } remov url encod from destin destin path = request util . urldecod ( destin path , utf8 ) ; int protocol index = destin path . index ( : ) ; ( protocol index = 0 ) { destin url contain protocol , we can safe trim everyth upto first charact after : int first separ = destin path . index ( , protocol index 4 ) ; ( first separ 0 ) { destin path = ; } els { destin path = destin path . substr ( first separ ) ; } } els { string host name = req . get server name ( ) ; ( ( host name = null ) ( destin path . start ( host name ) ) ) { destin path = destin path . substr ( host name . length ( ) ) ; } int port index = destin path . index ( : ) ; ( port index = 0 ) { destin path = destin path . substr ( port index ) ; } ( destin path . start ( : ) ) { int first separ = destin path . index ( ) ; ( first separ 0 ) { destin path = ; } els { destin path = destin path . substr ( first separ ) ; } } } normalis destin path ( remov . . . ) destin path = normal ( destin path ) ; string context path = req . get context path ( ) ; ( ( context path = null ) ( destin path . start ( context path ) ) ) { destin path = destin path . substr ( context path . length ( ) ) ; } string path info = req . get path info ( ) ; ( path info = null ) { string servlet path = req . get servlet path ( ) ; ( ( servlet path = null ) ( destin path . start ( servlet path ) ) ) { destin path = destin path . substr ( servlet path . length ( ) ) ; } } ( debug 0 ) log ( dest path : destin path ) ; ( ( destin path . upper case ( ) . start ( web inf ) ) ( destin path . upper case ( ) . start ( meta inf ) ) ) { resp . send error ( webdav statu . sc forbidden ) ; return fals ; } string path = get rel path ( req ) ; ( ( path . upper case ( ) . start ( web inf ) ) ( path . upper case ( ) . start ( meta inf ) ) ) { resp . send error ( webdav statu . sc forbidden ) ; return fals ; } ( destin path . equal ( path ) ) { resp . send error ( webdav statu . sc forbidden ) ; return fals ; } pars overwrit header boolean overwrit = true ; string overwrit header = req . get header ( overwrit ) ; ( overwrit header = null ) { ( overwrit header . equal ignor case ( t ) ) { overwrit = true ; } els { overwrit = fals ; } } overwrit destin boolean exist = true ; try { resourc . lookup ( destin path ) ; } catch ( name except e ) { exist = fals ; } ( overwrit ) { delet destin resourc , exist ( exist ) { ( delet resourc ( destin path , req , resp , true ) ) { return fals ; } } els { resp . set statu ( webdav statu . sc creat ) ; } } els { destin exist , s conflict ( exist ) { resp . send error ( webdav statu . sc precondit fail ) ; return fals ; } } copi sourc destin hashtabl string , integ error list = new hashtabl string , integ ( ) ; boolean result = copi resourc ( resourc , error list , path , destin path ) ; ( ( result ) ( error list . empti ( ) ) ) { send report ( req , resp , error list ) ; return fals ; } remov ani lock null resourc which would present destin path lock null resourc . remov ( destin path ) ; return true ; }
protect void regist jmx ( standard context ctx ) { string parent name = ctx . get name ( ) ; parent name = ( . equal ( parent name ) ) : parent name ; string host name = ctx . get parent ( ) . get name ( ) ; host name = ( host name = = null ) default : host name ; string domain = ctx . get domain ( ) ; string web mod = host name parent name ; string onam str = domain : j2ee type = servlet , name = get name ( ) , web modul = web mod , j2eeapplic = ctx . get j2eeapplic ( ) , j2eeserv = ctx . get j2eeserv ( ) ; try { onam = new object name ( onam str ) ; control = onam ; registri . get registri ( null , null ) . regist compon ( thi , onam , null ) ; send j2ee . object . creat notif ( thi . get object name ( ) = null ) { notif notif = new notif ( j2ee . object . creat , thi . get object name ( ) , sequenc number ) ; broadcast . send notif ( notif ) ; } } catch ( except ex ) { log . info ( error regist servlet jmx thi ) ; } ( jsp servlet ) { regist jsp monitor mbean onam str = domain : type = jsp monitor , name = get name ( ) , web modul = web mod , j2eeapplic = ctx . get j2eeapplic ( ) , j2eeserv = ctx . get j2eeserv ( ) ; try { jsp monitor = new object name ( onam str ) ; registri . get registri ( null , null ) . regist compon ( instanc , jsp monitor , null ) ; } catch ( except ex ) { log . info ( error regist jsp monitor jmx instanc ) ; } } }
protect overrid default servlet implement onli us path info . servlet path non null , becaus web dav servlet ha been map url other than configur edit differ url than normal view . param request servlet request we ar process string get rel path ( http servlet request request ) { ar we process request dispatch . includ ( ) ( request . get attribut ( global . includ request uri attr ) = null ) { string result = ( string ) request . get attribut ( global . includ path info attr ) ; ( ( result = = null ) ( result . equal ( ) ) ) result = ; return ( result ) ; } , extract desir path directli from request string result = request . get path info ( ) ; ( ( result = = null ) ( result . equal ( ) ) ) { result = ; } return ( result ) ; }
protect remov socket from poller . param data sendfil data which should remov void remov ( sendfil data data ) { int rv = poll . remov ( sendfil pollset , data . socket ) ; ( rv = = statu . apr success ) { sendfil count ; } sendfil data . remov ( data ) ; }	protect boolean process socket ( long socket , socket statu statu ) { try { ( executor = = null ) { get worker thread ( ) . assign ( socket , statu ) ; } els { executor . execut ( new socket event processor ( socket , statu ) ) ; } } catch ( throwabl t ) { thi mean we got oom similar creat thread , pool queue ar full log . error ( sm . get string ( endpoint . process . fail ) , t ) ; return fals ; } return true ; }
public int find statu page ( ) { synchron ( statu page ) { int result = new int statu page . size ( ) ; iter element = statu page . kei set ( ) . iter ( ) ; int i = 0 ; while ( element . ha next ( ) ) result i = ( ( integ ) element . next ( ) ) . int valu ( ) ; return ( result ) ; } }
public void member disappear ( member member ) { boolean remov = fals ; synchron ( map member ) { remov = ( map member . remov ( member ) = null ) ; } iter i = super . entri set ( ) . iter ( ) ; while ( i . ha next ( ) ) { map . entri e = ( map . entri ) i . next ( ) ; map entri entri = ( map entri ) super . get ( e . get kei ( ) ) ; ( entri = = null ) continu ; ( entri . primari ( ) set ( member , entri . get backup node ( ) ) ) { ( log . debug enabl ( ) ) log . debug ( 1 primari choos new backup ) ; try { member backup = publish entri info ( entri . get kei ( ) , entri . get valu ( ) ) ; entri . set backup node ( backup ) ; entri . set primari ( channel . get local member ( fals ) ) ; } catch ( channel except x ) { log . error ( unabl reloc entri . get kei ( ) new backup node , x ) ; } } els ( member . equal ( entri . get primari ( ) ) ) { ( log . debug enabl ( ) ) log . debug ( 2 primari disappear ) ; entri . set primari ( null ) ; } end ( entri . proxi ( ) entri . get primari ( ) = = null entri . get backup node ( ) = null entri . get backup node ( ) . length = = 1 entri . get backup node ( ) 0 . equal ( member ) ) { remov proxi have backup nor primari ( log . debug enabl ( ) ) log . debug ( 3 remov orphan proxi ) ; i . remov ( ) ; } els ( entri . get primari ( ) = = null entri . backup ( ) entri . get backup node ( ) = null entri . get backup node ( ) . length = = 1 entri . get backup node ( ) 0 . equal ( channel . get local member ( fals ) ) ) { try { ( log . debug enabl ( ) ) log . debug ( 4 backup becom primari ) ; entri . set primari ( channel . get local member ( fals ) ) ; entri . set backup ( fals ) ; entri . set proxi ( fals ) ; member backup = publish entri info ( entri . get kei ( ) , entri . get valu ( ) ) ; entri . set backup node ( backup ) ; ( map owner = null ) map owner . object made primai ( entri . get kei ( ) , entri . get valu ( ) ) ; } catch ( channel except x ) { log . error ( unabl reloc entri . get kei ( ) new backup node , x ) ; } } } while }
protect sslengin creat sslengin ( ) { sslengin engin = ssl context . creat sslengin ( ) ; engin . set need client auth ( get client auth ( ) ) ; engin . set us client mode ( fals ) ; ( ciphersarr . length 0 ) engin . set enabl cipher suit ( ciphersarr ) ; ( ssl enabl protocolsarr . length 0 ) engin . set enabl protocol ( ssl enabl protocolsarr ) ; return engin ; }	public initi endpoint . void init ( ) throw except { ( initi ) return ; server sock = server socket channel . open ( ) ; server sock . socket ( ) . set perform prefer ( socket properti . get perform connect time ( ) , socket properti . get perform latenc ( ) , socket properti . get perform bandwidth ( ) ) ; inet socket address addr = ( address = null new inet socket address ( address , port ) : new inet socket address ( port ) ) ; server sock . socket ( ) . bind ( addr , backlog ) ; mimic apr behavior server sock . configur block ( true ) ; initi thread count default acceptor , poller ( acceptor thread count = = 0 ) { fixm : doesn t seem work well multipl accept thread acceptor thread count = 1 ; } ( poller thread count = 0 ) { minimum poller thread poller thread count = 1 ; } initi ssl need ( sslenabl ( ) ) { initi ssl char passphras = get keystor pass ( ) . char arrai ( ) ; kei store ks = kei store . get instanc ( get keystor type ( ) ) ; ks . load ( new file input stream ( get keystor file ( ) ) , passphras ) ; kei store ts = kei store . get instanc ( get keystor type ( ) ) ; ts . load ( new file input stream ( get keystor file ( ) ) , passphras ) ; kei manag factori kmf = kei manag factori . get instanc ( get algorithm ( ) ) ; kmf . init ( ks , passphras ) ; trust manag factori tmf = trust manag factori . get instanc ( get algorithm ( ) ) ; tmf . init ( ts ) ; ssl context = sslcontext . get instanc ( get ssl protocol ( ) ) ; ssl context . init ( kmf . get kei manag ( ) , tmf . get trust manag ( ) , null ) ; } ( oom parachut 0 ) reclaim parachut ( true ) ; initi = true ; }	public void set sslenabl ( boolean sslenabl ) { ep . set sslenabl ( sslenabl ) ; }	public void set ssl protocol ( string s ) { ssl protocol = s ; }
privat void check same object ( servlet request app request , servlet respons app respons ) throw servlet except { servlet request origin request = applic filter chain . get last servic request ( ) ; servlet respons origin respons = applic filter chain . get last servic respons ( ) ; some forward , eg from valv set origin valu ( origin request = = null origin respons = = null ) { return ; } boolean same = fals ; servlet request dispatch request = app request ; find request wa pass servic method while ( origin request instanceof servlet request wrapper ( ( servlet request wrapper ) origin request ) . get request ( ) = null ) { origin request = ( ( servlet request wrapper ) origin request ) . get request ( ) ; } compar dispatch request while ( same ) { ( origin request . equal ( dispatch request ) ) { same = true ; } ( same dispatch request instanceof servlet request wrapper ) { dispatch request = ( ( servlet request wrapper ) dispatch request ) . get request ( ) ; } els { break ; } } ( same ) { throw new servlet except ( sm . get string ( applic dispatch . spec violat . request ) ) ; } same = fals ; servlet respons dispatch respons = app respons ; find respons wa pass servic method while ( origin respons instanceof servlet respons wrapper ( ( servlet respons wrapper ) origin respons ) . get respons ( ) = null ) { origin respons = ( ( servlet respons wrapper ) origin respons ) . get respons ( ) ; } compar dispatch respons while ( same ) { ( origin respons . equal ( dispatch respons ) ) { same = true ; } ( same dispatch respons instanceof servlet respons wrapper ) { dispatch respons = ( ( servlet respons wrapper ) dispatch respons ) . get respons ( ) ; } els { break ; } } ( same ) { throw new servlet except ( sm . get string ( applic dispatch . spec violat . respons ) ) ; } }	ask resourc repres thi request dispatch process associ request , creat ( append ) associ respons . p strong implement note strong : thi implement assum filter ar appli forward includ resourc , becaus thei were alreadi done origin request . param request servlet request we ar process param respons servlet respons we ar creat except ioexcept input output error occur except servlet except servlet error occur void invok ( servlet request request , servlet respons respons , state state ) throw ioexcept , servlet except { check see context classload current context classload . s , we re save , set context classload context classload class loader old ccl = thread . current thread ( ) . get context class loader ( ) ; class loader context class loader = context . get loader ( ) . get class loader ( ) ; ( old ccl = context class loader ) { thread . current thread ( ) . set context class loader ( context class loader ) ; } els { old ccl = null ; } initi local variabl we mai need http servlet respons hrespons = ( http servlet respons ) respons ; servlet servlet = null ; ioexcept io except = null ; servlet except servlet except = null ; runtim except runtim except = null ; boolean unavail = fals ; check servlet mark unavail ( wrapper . unavail ( ) ) { wrapper . get logger ( ) . warn ( sm . get string ( applic dispatch . unavail , wrapper . get name ( ) ) ) ; long avail = wrapper . get avail ( ) ; ( ( avail 0l ) ( avail long . max valu ) ) hrespons . set date header ( retri after , avail ) ; hrespons . send error ( http servlet respons . sc servic unavail , sm . get string ( applic dispatch . unavail , wrapper . get name ( ) ) ) ; unavail = true ; } alloc servlet instanc process thi request try { ( unavail ) { servlet = wrapper . alloc ( ) ; } } catch ( servlet except e ) { wrapper . get logger ( ) . error ( sm . get string ( applic dispatch . alloc except , wrapper . get name ( ) ) , standard wrapper . get root caus ( e ) ) ; servlet except = e ; servlet = null ; } catch ( throwabl e ) { wrapper . get logger ( ) . error ( sm . get string ( applic dispatch . alloc except , wrapper . get name ( ) ) , e ) ; servlet except = new servlet except ( sm . get string ( applic dispatch . alloc except , wrapper . get name ( ) ) , e ) ; servlet = null ; } get filter chain here applic filter factori factori = applic filter factori . get instanc ( ) ; applic filter chain filter chain = factori . creat filter chain ( request , wrapper , servlet ) ; call servic ( ) method alloc servlet instanc try { string jsp file = wrapper . get jsp file ( ) ; ( jsp file = null ) request . set attribut ( global . jsp file attr , jsp file ) ; els request . remov attribut ( global . jsp file attr ) ; support . fire instanc event ( instanc event . befor dispatch event , servlet , request , respons ) ; includ forward ( ( servlet = null ) ( filter chain = null ) ) { filter chain . do filter ( request , respons ) ; } servlet servic method call filter chain request . remov attribut ( global . jsp file attr ) ; support . fire instanc event ( instanc event . after dispatch event , servlet , request , respons ) ; } catch ( client abort except e ) { request . remov attribut ( global . jsp file attr ) ; support . fire instanc event ( instanc event . after dispatch event , servlet , request , respons ) ; io except = e ; } catch ( ioexcept e ) { request . remov attribut ( global . jsp file attr ) ; support . fire instanc event ( instanc event . after dispatch event , servlet , request , respons ) ; wrapper . get logger ( ) . error ( sm . get string ( applic dispatch . servic except , wrapper . get name ( ) ) , e ) ; io except = e ; } catch ( unavail except e ) { request . remov attribut ( global . jsp file attr ) ; support . fire instanc event ( instanc event . after dispatch event , servlet , request , respons ) ; wrapper . get logger ( ) . error ( sm . get string ( applic dispatch . servic except , wrapper . get name ( ) ) , e ) ; servlet except = e ; wrapper . unavail ( e ) ; } catch ( servlet except e ) { request . remov attribut ( global . jsp file attr ) ; support . fire instanc event ( instanc event . after dispatch event , servlet , request , respons ) ; throwabl root caus = standard wrapper . get root caus ( e ) ; ( ( root caus instanceof client abort except ) ) { wrapper . get logger ( ) . error ( sm . get string ( applic dispatch . servic except , wrapper . get name ( ) ) , root caus ) ; } servlet except = e ; } catch ( runtim except e ) { request . remov attribut ( global . jsp file attr ) ; support . fire instanc event ( instanc event . after dispatch event , servlet , request , respons ) ; wrapper . get logger ( ) . error ( sm . get string ( applic dispatch . servic except , wrapper . get name ( ) ) , e ) ; runtim except = e ; } releas filter chain ( ani ) thi request try { ( filter chain = null ) filter chain . releas ( ) ; } catch ( throwabl e ) { wrapper . get logger ( ) . error ( sm . get string ( standard wrapper . releas filter , wrapper . get name ( ) ) , e ) ; fixm : except handl need simpil what standard wrapper valu } dealloc alloc servlet instanc try { ( servlet = null ) { wrapper . dealloc ( servlet ) ; } } catch ( servlet except e ) { wrapper . get logger ( ) . error ( sm . get string ( applic dispatch . dealloc except , wrapper . get name ( ) ) , e ) ; servlet except = e ; } catch ( throwabl e ) { wrapper . get logger ( ) . error ( sm . get string ( applic dispatch . dealloc except , wrapper . get name ( ) ) , e ) ; servlet except = new servlet except ( sm . get string ( applic dispatch . dealloc except , wrapper . get name ( ) ) , e ) ; } reset old context class loader ( old ccl = null ) thread . current thread ( ) . set context class loader ( old ccl ) ; unwrap request respons need see bugzilla 30949 unwrap request ( state ) ; unwrap respons ( state ) ; rethrow except wa thrown invok servlet ( io except = null ) throw io except ; ( servlet except = null ) throw servlet except ; ( runtim except = null ) throw runtim except ; }
protect load ani current activ session were previous unload appropri persist mechan , ani . persist support , thi method return without do anyth . except class found except serial class cannot found dure reload except ioexcept input output error occur void do load ( ) throw class found except , ioexcept { ( log . debug enabl ( ) ) log . debug ( start : load persist session ) ; initi our intern data structur session . clear ( ) ; open input stream specifi pathnam , ani file file = file ( ) ; ( file = = null ) return ; ( log . debug enabl ( ) ) log . debug ( sm . get string ( standard manag . load , pathnam ) ) ; file input stream fi = null ; object input stream oi = null ; loader loader = null ; class loader class loader = null ; try { fi = new file input stream ( file . get absolut path ( ) ) ; buffer input stream bi = new buffer input stream ( fi ) ; ( contain = null ) loader = contain . get loader ( ) ; ( loader = null ) class loader = loader . get class loader ( ) ; ( class loader = null ) { ( log . debug enabl ( ) ) log . debug ( creat custom object input stream class loader ) ; oi = new custom object input stream ( bi , class loader ) ; } els { ( log . debug enabl ( ) ) log . debug ( creat standard object input stream ) ; oi = new object input stream ( bi ) ; } } catch ( file found except e ) { ( log . debug enabl ( ) ) log . debug ( persist data file found ) ; return ; } catch ( ioexcept e ) { log . error ( sm . get string ( standard manag . load . ioe , e ) , e ) ; ( oi = null ) { try { oi . close ( ) ; } catch ( ioexcept f ) { ; } oi = null ; } throw e ; } load previous unload activ session synchron ( session ) { try { integ count = ( integ ) oi . read object ( ) ; int n = count . int valu ( ) ; ( log . debug enabl ( ) ) log . debug ( load n persist session ) ; ( int i = 0 ; i n ; i ) { standard session session = get new session ( ) ; session . read object data ( oi ) ; session . set manag ( thi ) ; session . put ( session . get id intern ( ) , session ) ; session . activ ( ) ; session . end access ( ) ; } } catch ( class found except e ) { log . error ( sm . get string ( standard manag . load . cnfe , e ) , e ) ; ( oi = null ) { try { oi . close ( ) ; } catch ( ioexcept f ) { ; } oi = null ; } throw e ; } catch ( ioexcept e ) { log . error ( sm . get string ( standard manag . load . ioe , e ) , e ) ; ( oi = null ) { try { oi . close ( ) ; } catch ( ioexcept f ) { ; } oi = null ; } throw e ; } final { close input stream try { ( oi = null ) oi . close ( ) ; } catch ( ioexcept f ) { ignor } delet persist storag file ( file = null file . exist ( ) ) file . delet ( ) ; } } ( log . debug enabl ( ) ) log . debug ( finish : load persist session ) ; }
public static decod return specifi url encod string . when byte arrai convert string , system default charact encod us . . . thi mai differ than some other server . param str url encod string except illeg argument except charact follow valid 2 digit hexadecim number string urldecod ( string str ) { return urldecod ( str , null ) ; }	public static decod return specifi url encod string . param str url encod string param enc encod us ; null , default encod us except illeg argument except charact follow valid 2 digit hexadecim number string urldecod ( string str , string enc ) { ( str = = null ) return ( null ) ; us specifi encod extract byte out given string so encod lost . encod specifi , let us platform default byte byte = null ; try { ( enc = = null ) { byte = str . get byte ( ) ; } els { byte = str . get byte ( enc ) ; } } catch ( unsupport encod except uee ) { } return urldecod ( byte , enc ) ; }	public static decod return specifi url encod byte arrai . param byte url encod byte arrai except illeg argument except charact follow valid 2 digit hexadecim number string urldecod ( byte byte ) { return urldecod ( byte , null ) ; }	public static decod return specifi url encod byte arrai . param byte url encod byte arrai param enc encod us ; null , default encod us except illeg argument except charact follow valid 2 digit hexadecim number string urldecod ( byte byte , string enc ) { ( byte = = null ) return ( null ) ; int len = byte . length ; int ix = 0 ; int ox = 0 ; while ( ix len ) { get byte test byte b = byte ix ; ( b = = ) { b = ( byte ) ; } els ( b = = ) { b = ( byte ) ( ( convert hex digit ( byte ix ) << 4 ) convert hex digit ( byte ix ) ) ; } byte ox = b ; } ( enc = null ) { try { return new string ( byte , 0 , ox , enc ) ; } catch ( except e ) { e . print stack trace ( ) ; } } return new string ( byte , 0 , ox ) ; }	public static append request paramet from specifi string specifi map . presum specifi map access from ani other thread , so synchron perform . p strong implement note strong : url decod perform individu pars name valu element , rather than entir queri string ahead time , properli deal case where name valu includ encod = charact would otherwis interpret delimit . param map map accumul result paramet param data input string contain request paramet except illeg argument except data malform void pars paramet ( map map , string data , string encod ) throw unsupport encod except { ( ( data = null ) ( data . length ( ) 0 ) ) { us specifi encod extract byte out given string so encod lost . encod specifi , let us platform default byte byte = null ; try { ( encod = = null ) { byte = data . get byte ( ) ; } els { byte = data . get byte ( encod ) ; } } catch ( unsupport encod except uee ) { } pars paramet ( map , byte , encod ) ; } }
public void process request ( http servlet request request ) { add remov ( submit = = null ) add item ( item ) ; ( submit . equal ( add ) ) add item ( item ) ; }	public string get item ( ) { string s = new string v . size ( ) ; v . copi ( s ) ; return s ; }
public construct return filter chain implement wrap execut specifi servlet instanc . we should execut filter chain all , return code null code . param request servlet request we ar process param servlet servlet instanc wrap applic filter chain creat filter chain ( servlet request request , wrapper wrapper , servlet servlet ) { get dispatch type int dispatch = 1 ; ( request . get attribut ( dispatch type attr ) = null ) { integ dispatch int = ( integ ) request . get attribut ( dispatch type attr ) ; dispatch = dispatch int . int valu ( ) ; } string request path = null ; object attribut = request . get attribut ( dispatch request path attr ) ; ( attribut = null ) { request path = attribut . string ( ) ; } http servlet request hreq = null ; ( request instanceof http servlet request ) hreq = ( http servlet request ) request ; servlet execut , return null ( servlet = = null ) return ( null ) ; boolean comet = fals ; creat initi filter chain object applic filter chain filter chain = null ; ( request instanceof request ) { request req = ( request ) request ; ( global . secur enabl ) { secur : do recycl filter chain = new applic filter chain ( ) ; } els { filter chain = ( applic filter chain ) req . get filter chain ( ) ; ( filter chain = = null ) { filter chain = new applic filter chain ( ) ; req . set filter chain ( filter chain ) ; } } comet = req . comet ( ) ; } els { request dispatch us filter chain = new applic filter chain ( ) ; } filter chain . set servlet ( servlet ) ; filter chain . set support ( ( ( standard wrapper ) wrapper ) . get instanc support ( ) ) ; acquir filter map thi context standard context context = ( standard context ) wrapper . get parent ( ) ; filter map filter map = context . find filter map ( ) ; ar filter map , we ar done ( ( filter map = = null ) ( filter map . length = = 0 ) ) return ( filter chain ) ; acquir inform we need match filter map string servlet name = wrapper . get name ( ) ; add relev path map filter thi filter chain ( int i = 0 ; i filter map . length ; i ) { ( match dispatch ( filter map i , dispatch ) ) { continu ; } ( match filter url ( filter map i , request path ) ) continu ; applic filter config filter config = ( applic filter config ) context . find filter config ( filter map i . get filter name ( ) ) ; ( filter config = = null ) { fixm log configur problem ; continu ; } boolean comet filter = fals ; ( comet ) { try { comet filter = filter config . get filter ( ) instanceof comet filter ; } catch ( except e ) { note : try catch becaus get filter ha lot declar except . howev , filter alloc much earlier } ( comet filter ) { filter chain . add filter ( filter config ) ; } } els { filter chain . add filter ( filter config ) ; } } add filter match servlet name second ( int i = 0 ; i filter map . length ; i ) { ( match dispatch ( filter map i , dispatch ) ) { continu ; } ( match filter servlet ( filter map i , servlet name ) ) continu ; applic filter config filter config = ( applic filter config ) context . find filter config ( filter map i . get filter name ( ) ) ; ( filter config = = null ) { fixm log configur problem ; continu ; } boolean comet filter = fals ; ( comet ) { try { comet filter = filter config . get filter ( ) instanceof comet filter ; } catch ( except e ) { note : try catch becaus get filter ha lot declar except . howev , filter alloc much earlier } ( comet filter ) { filter chain . add filter ( filter config ) ; } } els { filter chain . add filter ( filter config ) ; } } return complet filter chain return ( filter chain ) ; }
public p add set rule instanc defin thi rule set specifi code digest code instanc , associ them our namespac uri ( ani ) . thi method should onli call digest instanc . p param digest digest instanc which new rule instanc should ad . void add rule instanc ( digest digest ) { session config = new set session config ( ) ; jsp config = new set jsp config ( ) ; login config = new set login config ( ) ; digest . add rule ( prefix web app , new set public id rule ( set public id ) ) ; digest . add rule ( prefix web app , new ignor annot rule ( ) ) ; digest . add call method ( prefix web app context param , add paramet , 2 ) ; digest . add call param ( prefix web app context param param name , 0 ) ; digest . add call param ( prefix web app context param param valu , 1 ) ; digest . add call method ( prefix web app displai name , set displai name , 0 ) ; digest . add rule ( prefix web app distribut , new set distribut rule ( ) ) ; digest . add object creat ( prefix web app ejb local ref , org . apach . catalina . deploi . context local ejb ) ; digest . add rule ( prefix web app ejb local ref , new set next name rule ( add local ejb , org . apach . catalina . deploi . context local ejb ) ) ; digest . add call method ( prefix web app ejb local ref descript , set descript , 0 ) ; digest . add call method ( prefix web app ejb local ref ejb link , set link , 0 ) ; digest . add call method ( prefix web app ejb local ref ejb ref name , set name , 0 ) ; digest . add call method ( prefix web app ejb local ref ejb ref type , set type , 0 ) ; digest . add call method ( prefix web app ejb local ref local , set local , 0 ) ; digest . add call method ( prefix web app ejb local ref local home , set home , 0 ) ; digest . add object creat ( prefix web app ejb ref , org . apach . catalina . deploi . context ejb ) ; digest . add rule ( prefix web app ejb ref , new set next name rule ( add ejb , org . apach . catalina . deploi . context ejb ) ) ; digest . add call method ( prefix web app ejb ref descript , set descript , 0 ) ; digest . add call method ( prefix web app ejb ref ejb link , set link , 0 ) ; digest . add call method ( prefix web app ejb ref ejb ref name , set name , 0 ) ; digest . add call method ( prefix web app ejb ref ejb ref type , set type , 0 ) ; digest . add call method ( prefix web app ejb ref home , set home , 0 ) ; digest . add call method ( prefix web app ejb ref remot , set remot , 0 ) ; digest . add object creat ( prefix web app env entri , org . apach . catalina . deploi . context environ ) ; digest . add rule ( prefix web app env entri , new set next name rule ( add environ , org . apach . catalina . deploi . context environ ) ) ; digest . add call method ( prefix web app env entri descript , set descript , 0 ) ; digest . add call method ( prefix web app env entri env entri name , set name , 0 ) ; digest . add call method ( prefix web app env entri env entri type , set type , 0 ) ; digest . add call method ( prefix web app env entri env entri valu , set valu , 0 ) ; digest . add object creat ( prefix web app error page , org . apach . catalina . deploi . error page ) ; digest . add set next ( prefix web app error page , add error page , org . apach . catalina . deploi . error page ) ; digest . add call method ( prefix web app error page error code , set error code , 0 ) ; digest . add call method ( prefix web app error page except type , set except type , 0 ) ; digest . add call method ( prefix web app error page locat , set locat , 0 ) ; digest . add object creat ( prefix web app filter , org . apach . catalina . deploi . filter def ) ; digest . add set next ( prefix web app filter , add filter def , org . apach . catalina . deploi . filter def ) ; digest . add call method ( prefix web app filter descript , set descript , 0 ) ; digest . add call method ( prefix web app filter displai name , set displai name , 0 ) ; digest . add call method ( prefix web app filter filter class , set filter class , 0 ) ; digest . add call method ( prefix web app filter filter name , set filter name , 0 ) ; digest . add call method ( prefix web app filter larg icon , set larg icon , 0 ) ; digest . add call method ( prefix web app filter small icon , set small icon , 0 ) ; digest . add call method ( prefix web app filter init param , add init paramet , 2 ) ; digest . add call param ( prefix web app filter init param param name , 0 ) ; digest . add call param ( prefix web app filter init param param valu , 1 ) ; digest . add object creat ( prefix web app filter map , org . apach . catalina . deploi . filter map ) ; digest . add set next ( prefix web app filter map , add filter map , org . apach . catalina . deploi . filter map ) ; digest . add call method ( prefix web app filter map filter name , set filter name , 0 ) ; digest . add call method ( prefix web app filter map servlet name , add servlet name , 0 ) ; digest . add call method ( prefix web app filter map url pattern , add urlpattern , 0 ) ; digest . add call method ( prefix web app filter map dispatch , set dispatch , 0 ) ; digest . add call method ( prefix web app listen listen class , add applic listen , 0 ) ; digest . add rule ( prefix web app jsp config , jsp config ) ; digest . add call method ( prefix web app jsp config jsp properti group url pattern , add jsp map , 0 ) ; digest . add call method ( prefix web app listen listen class , add applic listen , 0 ) ; digest . add rule ( prefix web app login config , login config ) ; digest . add object creat ( prefix web app login config , org . apach . catalina . deploi . login config ) ; digest . add set next ( prefix web app login config , set login config , org . apach . catalina . deploi . login config ) ; digest . add call method ( prefix web app login config auth method , set auth method , 0 ) ; digest . add call method ( prefix web app login config realm name , set realm name , 0 ) ; digest . add call method ( prefix web app login config form login config form error page , set error page , 0 ) ; digest . add call method ( prefix web app login config form login config form login page , set login page , 0 ) ; digest . add call method ( prefix web app mime map , add mime map , 2 ) ; digest . add call param ( prefix web app mime map extens , 0 ) ; digest . add call param ( prefix web app mime map mime type , 1 ) ; digest . add object creat ( prefix web app resourc env ref , org . apach . catalina . deploi . context resourc env ref ) ; digest . add rule ( prefix web app resourc env ref , new set next name rule ( add resourc env ref , org . apach . catalina . deploi . context resourc env ref ) ) ; digest . add call method ( prefix web app resourc env ref resourc env ref name , set name , 0 ) ; digest . add call method ( prefix web app resourc env ref resourc env ref type , set type , 0 ) ; digest . add object creat ( prefix web app messag destin , org . apach . catalina . deploi . messag destin ) ; digest . add set next ( prefix web app messag destin , add messag destin , org . apach . catalina . deploi . messag destin ) ; digest . add call method ( prefix web app messag destin descript , set descript , 0 ) ; digest . add call method ( prefix web app messag destin displai name , set displai name , 0 ) ; digest . add call method ( prefix web app messag destin icon larg icon , set larg icon , 0 ) ; digest . add call method ( prefix web app messag destin icon small icon , set small icon , 0 ) ; digest . add call method ( prefix web app messag destin messag destin name , set name , 0 ) ; digest . add object creat ( prefix web app messag destin ref , org . apach . catalina . deploi . messag destin ref ) ; digest . add set next ( prefix web app messag destin ref , add messag destin ref , org . apach . catalina . deploi . messag destin ref ) ; digest . add call method ( prefix web app messag destin ref descript , set descript , 0 ) ; digest . add call method ( prefix web app messag destin ref messag destin link , set link , 0 ) ; digest . add call method ( prefix web app messag destin ref messag destin ref name , set name , 0 ) ; digest . add call method ( prefix web app messag destin ref messag destin type , set type , 0 ) ; digest . add call method ( prefix web app messag destin ref messag destin usag , set usag , 0 ) ; digest . add object creat ( prefix web app resourc ref , org . apach . catalina . deploi . context resourc ) ; digest . add rule ( prefix web app resourc ref , new set next name rule ( add resourc , org . apach . catalina . deploi . context resourc ) ) ; digest . add call method ( prefix web app resourc ref descript , set descript , 0 ) ; digest . add call method ( prefix web app resourc ref re auth , set auth , 0 ) ; digest . add call method ( prefix web app resourc ref re ref name , set name , 0 ) ; digest . add call method ( prefix web app resourc ref re share scope , set scope , 0 ) ; digest . add call method ( prefix web app resourc ref re type , set type , 0 ) ; digest . add object creat ( prefix web app secur constraint , org . apach . catalina . deploi . secur constraint ) ; digest . add set next ( prefix web app secur constraint , add constraint , org . apach . catalina . deploi . secur constraint ) ; digest . add rule ( prefix web app secur constraint auth constraint , new set auth constraint rule ( ) ) ; digest . add call method ( prefix web app secur constraint auth constraint role name , add auth role , 0 ) ; digest . add call method ( prefix web app secur constraint displai name , set displai name , 0 ) ; digest . add call method ( prefix web app secur constraint user data constraint transport guarante , set user constraint , 0 ) ; digest . add object creat ( prefix web app secur constraint web resourc collect , org . apach . catalina . deploi . secur collect ) ; digest . add set next ( prefix web app secur constraint web resourc collect , add collect , org . apach . catalina . deploi . secur collect ) ; digest . add call method ( prefix web app secur constraint web resourc collect http method , add method , 0 ) ; digest . add call method ( prefix web app secur constraint web resourc collect url pattern , add pattern , 0 ) ; digest . add call method ( prefix web app secur constraint web resourc collect web resourc name , set name , 0 ) ; digest . add call method ( prefix web app secur role role name , add secur role , 0 ) ; digest . add object creat ( prefix web app servic ref , org . apach . catalina . deploi . context servic ) ; digest . add rule ( prefix web app servic ref , new set next name rule ( add servic , org . apach . catalina . deploi . context servic ) ) ; digest . add call method ( prefix web app servic ref descript , set descript , 0 ) ; digest . add call method ( prefix web app servic ref displai name , set displaynam , 0 ) ; digest . add call method ( prefix web app servic ref icon , set icon , 0 ) ; digest . add call method ( prefix web app servic ref servic ref name , set name , 0 ) ; digest . add call method ( prefix web app servic ref servic interfac , set type , 0 ) ; digest . add call method ( prefix web app servic ref wsdl file , set wsdlfile , 0 ) ; digest . add call method ( prefix web app servic ref jaxrpc map file , set jaxrpcmappingfil , 0 ) ; digest . add rule ( prefix web app servic ref servic qname , new servic qname rule ( ) ) ; digest . add rule ( prefix web app servic ref port compon ref , new call method multi rule ( add portcompon , 2 , 1 ) ) ; digest . add call param ( prefix web app servic ref port compon ref servic endpoint interfac , 0 ) ; digest . add rule ( prefix web app servic ref port compon ref port compon link , new call param multi rule ( 1 ) ) ; digest . add object creat ( prefix web app servic ref handler , org . apach . catalina . deploi . context handler ) ; digest . add rule ( prefix web app servic ref handler , new set next rule ( add handler , org . apach . catalina . deploi . context handler ) ) ; digest . add call method ( prefix web app servic ref handler handler name , set name , 0 ) ; digest . add call method ( prefix web app servic ref handler handler class , set handlerclass , 0 ) ; digest . add call method ( prefix web app servic ref handler init param , set properti , 2 ) ; digest . add call param ( prefix web app servic ref handler init param param name , 0 ) ; digest . add call param ( prefix web app servic ref handler init param param valu , 1 ) ; digest . add rule ( prefix web app servic ref handler soap header , new soap header rule ( ) ) ; digest . add call method ( prefix web app servic ref handler soap role , add soap role , 0 ) ; digest . add call method ( prefix web app servic ref handler port name , add port name , 0 ) ; digest . add rule ( prefix web app servlet , new wrapper creat rule ( ) ) ; digest . add set next ( prefix web app servlet , add child , org . apach . catalina . contain ) ; digest . add call method ( prefix web app servlet init param , add init paramet , 2 ) ; digest . add call param ( prefix web app servlet init param param name , 0 ) ; digest . add call param ( prefix web app servlet init param param valu , 1 ) ; digest . add call method ( prefix web app servlet jsp file , set jsp file , 0 ) ; digest . add call method ( prefix web app servlet load startup , set load startup string , 0 ) ; digest . add call method ( prefix web app servlet run role name , set run , 0 ) ; digest . add call method ( prefix web app servlet secur role ref , add secur refer , 2 ) ; digest . add call param ( prefix web app servlet secur role ref role link , 1 ) ; digest . add call param ( prefix web app servlet secur role ref role name , 0 ) ; digest . add call method ( prefix web app servlet servlet class , set servlet class , 0 ) ; digest . add call method ( prefix web app servlet servlet name , set name , 0 ) ; digest . add rule ( prefix web app servlet map , new call method multi rule ( add servlet map , 2 , 0 ) ) ; digest . add call param ( prefix web app servlet map servlet name , 1 ) ; digest . add rule ( prefix web app servlet map url pattern , new call param multi rule ( 0 ) ) ; digest . add rule ( prefix web app session config , session config ) ; digest . add call method ( prefix web app session config session timeout , set session timeout , 1 , new class { integ . type } ) ; digest . add call param ( prefix web app session config session timeout , 0 ) ; digest . add call method ( prefix web app taglib , add taglib , 2 ) ; digest . add call param ( prefix web app taglib taglib locat , 1 ) ; digest . add call param ( prefix web app taglib taglib uri , 0 ) ; digest . add call method ( prefix web app welcom file list welcom file , add welcom file , 0 ) ; digest . add call method ( prefix web app local encod map list local encod map , add local encod map paramet , 2 ) ; digest . add call param ( prefix web app local encod map list local encod map local , 0 ) ; digest . add call param ( prefix web app local encod map list local encod map encod , 1 ) ; }	public void begin ( string namespac , string name , attribut attribut ) throw except { ( login config set ) { throw new illeg argument except ( login config element limit 1 occur ) ; } login config set = true ; }	public void bodi ( string text ) throw except { string namespaceuri = null ; string localpart = text ; int colon = text . index ( : ) ; ( colon = 0 ) { string prefix = text . substr ( 0 , colon ) ; namespaceuri = digest . find namespac uri ( prefix ) ; localpart = text . substr ( colon 1 ) ; } context handler context handler = ( context handler ) digest . peek ( ) ; context handler . add soap header ( localpart , namespaceuri ) ; }

public add environ entri thi web applic . param environ new environ entri void add environ ( context environ environ ) { ( entri . contain kei ( environ . get name ( ) ) ) { ( find environ ( environ . get name ( ) ) . get overrid ( ) ) { remov environ ( environ . get name ( ) ) ; } els { return ; } } entri . put ( environ . get name ( ) , environ . get type ( ) ) ; synchron ( env ) { environ . set name resourc ( thi ) ; env . put ( environ . get name ( ) , environ ) ; } support . fire properti chang ( environ , null , environ ) ; }
find name function mapper el . reus previous gener possibl . param function arrai list elnod . function instanc repres function el return previou gener function mapper name can us thi el ; null none found . string match map ( arrai list function ) { string map name = null ; ( int i = 0 ; i function . size ( ) ; i ) { elnod . function f = ( elnod . function ) function . get ( i ) ; string tem name = ( string ) g map . get ( f . get prefix ( ) : f . get name ( ) : f . get uri ( ) ) ; ( tem name = = null ) { return null ; } ( map name = = null ) { map name = tem name ; } els ( tem name . equal ( map name ) ) { all previou match , match . return null ; } } return map name ; }	privat creat function mapper , need , from elnod void do map ( elnod . node el ) throw jasper except { onli care about function elnod s class fvisitor extend elnod . visitor { arrai list func = new arrai list ( ) ; hash map kei map = new hash map ( ) ; } }	privat void do map ( node . jsp attribut attr ) throw jasper except { ( attr = null ) { do map ( attr . get el ( ) ) ; } }	public static void map ( compil compil , node . node page ) throw jasper except { curr func = 0 ; elfunct mapper map = new elfunct mapper ( ) ; map . err = compil . get error dispatch ( ) ; map . ds = new string buffer ( ) ; map . ss = new string buffer ( ) ; page . visit ( map . new elfunct visitor ( ) ) ; append declar root node string ds = map . ds . string ( ) ; ( ds . length ( ) 0 ) { node root = page . get root ( ) ; new node . declar ( map . ss . string ( ) , null , root ) ; new node . declar ( static { n ds } n , null , root ) ; } }	privat void do map ( elnod . node el ) throw jasper except { onli care about function elnod s class fvisitor extend elnod . visitor { arrai list func = new arrai list ( ) ; hash map kei map = new hash map ( ) ; public void visit ( elnod . function n ) throw jasper except { string kei = n . get prefix ( ) : n . get name ( ) ; ( kei map . contain kei ( kei ) ) { kei map . put ( kei , ) ; func . add ( n ) ; } } } ( el = = null ) { return ; } first locat all uniqu function thi el fvisitor fv = new fvisitor ( ) ; el . visit ( fv ) ; arrai list function = fv . func ; ( function . size ( ) = = 0 ) { return ; } reus previou map possibl string dec name = match map ( function ) ; ( dec name = null ) { el . set map name ( dec name ) ; return ; } gener declar map static dec name = get map name ( ) ; ss . append ( static privat org . apach . jasper . runtim . protect function mapper dec name ; n ) ; ds . append ( dec name = ) ; ds . append ( org . apach . jasper . runtim . protect function mapper ) ; special case onli function map string func method = null ; ( function . size ( ) = = 1 ) { func method = . get map function ; } els { ds . append ( . get instanc ( ) ; n ) ; func method = dec name . map function ; } setup argument either get map function map function ( int i = 0 ; i function . size ( ) ; i ) { elnod . function f = ( elnod . function ) function . get ( i ) ; function info func info = f . get function info ( ) ; string kei = f . get prefix ( ) : f . get name ( ) ; ds . append ( func method ( kei , func info . get function class ( ) . class , f . get method name ( ) , new class { ) ; string param = f . get paramet ( ) ; ( int k = 0 ; k param . length ; k ) { ( k = 0 ) { ds . append ( , ) ; } int i arrai = param k . index ( ) ; ( i arrai 0 ) { ds . append ( param k . class ) ; } els { string base type = param k . substr ( 0 , i arrai ) ; ds . append ( java . lang . reflect . arrai . new instanc ( ) ; ds . append ( base type ) ; ds . append ( . class , ) ; count number arrai dimens int count = 0 ; ( int jj = i arrai ; jj param k . length ( ) ; jj ) { ( param k . char ( jj ) = = ) { count ; } } ( count = = 1 ) { ds . append ( 0 ) . get class ( ) ) ; } els { ds . append ( new int count ) . get class ( ) ) ; } } } ds . append ( } ) ; n ) ; put current name global function map g map . put ( f . get prefix ( ) : f . get name ( ) : f . get uri ( ) , dec name ) ; } el . set map name ( dec name ) ; }	public void visit ( node . custom tag n ) throw jasper except { node . jsp attribut attr = n . get jsp attribut ( ) ; ( int i = 0 ; attr = null i attr . length ; i ) { do map ( attr i ) ; } visit bodi ( n ) ; }	public void visit ( node . elexpress n ) throw jasper except { do map ( n . get el ( ) ) ; }	public void visit ( node . jsp element n ) throw jasper except { node . jsp attribut attr = n . get jsp attribut ( ) ; ( int i = 0 ; attr = null i attr . length ; i ) { do map ( attr i ) ; } do map ( n . get name attribut ( ) ) ; visit bodi ( n ) ; }	public void visit ( node . plug n ) throw jasper except { do map ( n . get height ( ) ) ; do map ( n . get width ( ) ) ; visit bodi ( n ) ; }	public void visit ( node . set properti n ) throw jasper except { do map ( n . get valu ( ) ) ; visit bodi ( n ) ; }	public void visit ( node . uninterpret tag n ) throw jasper except { node . jsp attribut attr = n . get jsp attribut ( ) ; ( int i = 0 ; attr = null i attr . length ; i ) { do map ( attr i ) ; } visit bodi ( n ) ; }	public void visit ( node . us bean n ) throw jasper except { do map ( n . get bean name ( ) ) ; visit bodi ( n ) ; }
protect pars rang header . param request servlet request we ar process param respons servlet respons we ar creat return vector rang arrai list pars rang ( http servlet request request , http servlet respons respons , resourc attribut resourc attribut ) throw ioexcept { check rang string header valu = request . get header ( rang ) ; ( header valu = null ) { long header valu time = ( 1l ) ; try { header valu time = request . get date header ( rang ) ; } catch ( illeg argument except e ) { ; } string e tag = get etag ( resourc attribut ) ; long last modifi = resourc attribut . get last modifi ( ) ; ( header valu time = = ( 1l ) ) { etag , entir entiti return . ( e tag . equal ( header valu . trim ( ) ) ) return full ; } els { return . ( last modifi ( header valu time 1000 ) ) return full ; } } long file length = resourc attribut . get content length ( ) ; ( file length = = 0 ) return null ; retriev rang header ( ani specifi string rang header = request . get header ( rang ) ; ( rang header = = null ) return null ; ad new ) . ( rang header . start ( byte ) ) { respons . add header ( content rang , byte file length ) ; respons . send error ( http servlet respons . sc request rang satisfi ) ; return null ; } rang header = rang header . substr ( 6 ) ; vector which contain all rang which ar successfulli pars . arrai list result = new arrai list ( ) ; string token comma token = new string token ( rang header , , ) ; pars rang list while ( comma token . ha more token ( ) ) { string rang definit = comma token . next token ( ) . trim ( ) ; rang current rang = new rang ( ) ; current rang . length = file length ; int dash po = rang definit . index ( ) ; ( dash po = = 1 ) { respons . add header ( content rang , byte file length ) ; respons . send error ( http servlet respons . sc request rang satisfi ) ; return null ; } ( dash po = = 0 ) { try { long offset = long . pars long ( rang definit ) ; current rang . start = file length offset ; current rang . end = file length 1 ; } catch ( number format except e ) { respons . add header ( content rang , byte file length ) ; respons . send error ( http servlet respons . sc request rang satisfi ) ; return null ; } } els { try { current rang . start = long . pars long ( rang definit . substr ( 0 , dash po ) ) ; ( dash po rang definit . length ( ) 1 ) current rang . end = long . pars long ( rang definit . substr ( dash po 1 , rang definit . length ( ) ) ) ; els current rang . end = file length 1 ; } catch ( number format except e ) { respons . add header ( content rang , byte file length ) ; respons . send error ( http servlet respons . sc request rang satisfi ) ; return null ; } } ( current rang . valid ( ) ) { respons . add header ( content rang , byte file length ) ; respons . send error ( http servlet respons . sc request rang satisfi ) ; return null ; } result . add ( current rang ) ; } return result ; }	protect check modifi sinc condit satisfi . param request servlet request we ar process param respons servlet respons we ar creat param resourc info file object return boolean true resourc meet specifi condit , fals condit satisfi , which case request process stop boolean check modifi sinc ( http servlet request request , http servlet respons respons , resourc attribut resourc attribut ) throw ioexcept { try { long header valu = request . get date header ( modifi sinc ) ; long last modifi = resourc attribut . get last modifi ( ) ; ( header valu = 1 ) { ignor . ( ( request . get header ( none match ) = = null ) ( last modifi header valu 1000 ) ) { entiti ha been modifi sinc date specifi client . thi error case . respons . set statu ( http servlet respons . sc modifi ) ; return fals ; } } } catch ( illeg argument except illeg argument ) { return true ; } return true ; }	protect check none match condit satisfi . param request servlet request we ar process param respons servlet respons we ar creat param resourc info file object return boolean true resourc meet specifi condit , fals condit satisfi , which case request process stop boolean check none match ( http servlet request request , http servlet respons respons , resourc attribut resourc attribut ) throw ioexcept { string e tag = get etag ( resourc attribut ) ; string header valu = request . get header ( none match ) ; ( header valu = null ) { boolean condit satisfi = fals ; ( header valu . equal ( ) ) { string token comma token = new string token ( header valu , , ) ; while ( condit satisfi comma token . ha more token ( ) ) { string current token = comma token . next token ( ) ; ( current token . trim ( ) . equal ( e tag ) ) condit satisfi = true ; } } els { condit satisfi = true ; } ( condit satisfi ) { back . ( ( get . equal ( request . get method ( ) ) ) ( head . equal ( request . get method ( ) ) ) ) { respons . set statu ( http servlet respons . sc modifi ) ; return fals ; } els { respons . send error ( http servlet respons . sc precondit fail ) ; return fals ; } } } return true ; }
public invok next valv sequenc . when invok return , check respons state , output error report necessari . param request servlet request process param respons servlet respons creat except ioexcept input output error occur except servlet except servlet error occur void invok ( request request , respons respons ) throw ioexcept , servlet except { perform request get next ( ) . invok ( request , respons ) ; throwabl throwabl = ( throwabl ) request . get attribut ( global . except attr ) ; ( respons . app commit ( ) ) { return ; } ( throwabl = null ) { respons error respons . set error ( ) ; reset respons ( possibl ) try { respons . reset ( ) ; } catch ( illeg state except e ) { ; } respons . send error ( http servlet respons . sc intern server error ) ; } respons . set suspend ( fals ) ; try { report ( request , respons , throwabl ) ; } catch ( throwabl tt ) { ; } }
privat secur constraint result arrai ( arrai list result ) { ( result = = null ) { return null ; } secur constraint arrai = new secur constraint result . size ( ) ; result . arrai ( arrai ) ; return arrai ; }	public void init ( ) { thi . contain log = contain . get logger ( ) ; ( initi contain = null ) return ; initi = true ; ( contain = = null ) { object name parent = null ; regist parent try { ( host = = null ) { global parent = new object name ( domain : type = engin ) ; } els ( path = = null ) { parent = new object name ( domain : type = host , host = host ) ; } els { parent = new object name ( domain : j2ee type = web modul , name = host path ) ; } ( mserver . regist ( parent ) ) { ( log . debug enabl ( ) ) log . debug ( regist parent ) ; mserver . set attribut ( parent , new attribut ( realm , thi ) ) ; } } catch ( except e ) { log . error ( parent avail yet : parent ) ; } } ( onam = = null ) { regist try { contain base cb = ( contain base ) contain ; onam = new object name ( cb . get domain ( ) : type = realm cb . get contain suffix ( ) ) ; registri . get registri ( null , null ) . regist compon ( thi , onam , null ) ; ( log . debug enabl ( ) ) log . debug ( regist realm onam ) ; } catch ( throwabl e ) { log . error ( can t regist onam , e ) ; } } }
public return uniqu temporari variabl name store result . ( thi probabl could go elsewher , s conveni here ) string get temporari variabl name ( ) { return temporari variabl name ; }
protect compar get compar ( string sort ) { compar compar = null ; ( creation time . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return new date ( session . get creation time ( ) ) ; } } ; } els ( id . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return session . get id ( ) ; } } ; } els ( last access time . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return new date ( session . get last access time ( ) ) ; } } ; } els ( max inact interv . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return new date ( session . get max inact interv ( ) ) ; } } ; } els ( new . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return boolean . valu ( session . get session ( ) . new ( ) ) ; } } ; } els ( local . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return jsp helper . guess displai local from session ( session ) ; } } ; } els ( user . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return jsp helper . guess displai user from session ( session ) ; } } ; } els ( us time . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return new date ( session util . get us time session ( session ) ) ; } } ; } els ( inact time . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return new date ( session util . get inact time session ( session ) ) ; } } ; } els ( ttl . equal ignor case ( sort ) ) { compar = new base session compar ( ) { public compar get compar object ( session session ) { return new date ( session util . get ttlfor session ( session ) ) ; } } ; } todo : complet thi ttl , etc . return compar ; }
protect access log element creat log element ( ) { list access log element list = new arrai list access log element ( ) ; boolean replac = fals ; string buffer buf = new string buffer ( ) ; ( int i = 0 ; i pattern . length ( ) ; i ) { char ch = pattern . char ( i ) ; ( replac ) { code process { , behavior . . . i do enount close } i ignor { ( { = = ch ) { string buffer name = new string buffer ( ) ; int j = i 1 ; ( ; j pattern . length ( ) } = pattern . char ( j ) ; j ) { name . append ( pattern . char ( j ) ) ; } ( j 1 pattern . length ( ) ) { 1 wa account } which we increment now j ; list . add ( creat access log element ( name . string ( ) , pattern . char ( j ) ) ) ; i = j ; sinc we walk more than charact } els { d oh end string pretend we never did thi do process old wai list . add ( creat access log element ( ch ) ) ; } } els { list . add ( creat access log element ( ch ) ) ; } replac = fals ; } els ( ch = = ) { replac = true ; list . add ( new string element ( buf . string ( ) ) ) ; buf = new string buffer ( ) ; } els { buf . append ( ch ) ; } } ( buf . length ( ) 0 ) { list . add ( new string element ( buf . string ( ) ) ) ; } return ( access log element ) list . arrai ( new access log element 0 ) ; }
protect restor origin request from inform store our session . origin request longer present ( becaus session time out ) , return code fals code ; otherwis , return code true code . param request request restor param session session contain save inform boolean restor request ( request request , session session ) throw ioexcept { retriev remov save request object from our session save request save = ( save request ) session . get note ( constant . form request note ) ; session . remov note ( constant . form request note ) ; session . remov note ( constant . form princip note ) ; ( save = = null ) return ( fals ) ; modifi our current request reflect origin request . clear cooki ( ) ; iter cooki = save . get cooki ( ) ; while ( cooki . ha next ( ) ) { request . add cooki ( ( cooki ) cooki . next ( ) ) ; } mime header rmh = request . get coyot request ( ) . get mime header ( ) ; rmh . recycl ( ) ; iter name = save . get header name ( ) ; while ( name . ha next ( ) ) { string name = ( string ) name . next ( ) ; iter valu = save . get header valu ( name ) ; while ( valu . ha next ( ) ) { rmh . add valu ( name ) . set string ( ( string ) valu . next ( ) ) ; } } request . clear local ( ) ; iter local = save . get local ( ) ; while ( local . ha next ( ) ) { request . add local ( ( local ) local . next ( ) ) ; } request . get coyot request ( ) . get paramet ( ) . recycl ( ) ; ( post . equal ignor case ( save . get method ( ) ) ) { byte chunk bodi = save . get bodi ( ) ; ( bodi = null ) { request . get coyot request ( ) . action ( action code . action req set bodi replai , bodi ) ; set content type messag byte content type = messag byte . new instanc ( ) ; content type . set string ( applic x www form urlencod ) ; request . get coyot request ( ) . set content type ( content type ) ; } } request . get coyot request ( ) . method ( ) . set string ( save . get method ( ) ) ; request . get coyot request ( ) . queri string ( ) . set string ( save . get queri string ( ) ) ; request . get coyot request ( ) . request uri ( ) . set string ( save . get request uri ( ) ) ; return ( true ) ; }	protect save origin request inform our session . param request request save param session session contain save inform throw ioexcept void save request ( request request , session session ) throw ioexcept { creat popul save request object thi request save request save = new save request ( ) ; cooki cooki = request . get cooki ( ) ; ( cooki = null ) { ( int i = 0 ; i cooki . length ; i ) save . add cooki ( cooki i ) ; } enumer name = request . get header name ( ) ; while ( name . ha more element ( ) ) { string name = ( string ) name . next element ( ) ; enumer valu = request . get header ( name ) ; while ( valu . ha more element ( ) ) { string valu = ( string ) valu . next element ( ) ; save . add header ( name , valu ) ; } } enumer local = request . get local ( ) ; while ( local . ha more element ( ) ) { local local = ( local ) local . next element ( ) ; save . add local ( local ) ; } ( post . equal ignor case ( request . get method ( ) ) ) { byte chunk bodi = new byte chunk ( ) ; bodi . set limit ( request . get connector ( ) . get max save post size ( ) ) ; byte buffer = new byte 4096 ; int byte read ; input stream = request . get input stream ( ) ; while ( ( byte read = . read ( buffer ) ) = 0 ) { bodi . append ( buffer , 0 , byte read ) ; } save . set bodi ( bodi ) ; } save . set method ( request . get method ( ) ) ; save . set queri string ( request . get queri string ( ) ) ; save . set request uri ( request . get request uri ( ) ) ; stash save request our session later us session . set note ( constant . form request note , save ) ; }	public void set bodi ( byte chunk bodi ) { thi . bodi = bodi ; }
public connector creat connector ( string address , int port , string protocol ) { connector connector = null ; ( address = null ) { inet address . string ( ) return string form hostnam liter ip . get latter part , so address can pars ( back ) inet address us inet address . get name ( ) . int index = address . index ( ) ; ( index = 1 ) { address = address . substr ( index 1 ) ; } } ( log . debug enabl ( ) ) { log . debug ( creat connector address = ( ( address = = null ) all : address ) port = port protocol = protocol ) ; } try { ( protocol . equal ( ajp ) ) { connector = new connector ( org . apach . jk . server . jk coyot handler ) ; } els ( protocol . equal ( memori ) ) { connector = new connector ( org . apach . coyot . memori . memori protocol handler ) ; } els ( protocol . equal ( http ) ) { connector = new connector ( ) ; } els ( protocol . equal ( http ) ) { connector = new connector ( ) ; connector . set scheme ( http ) ; connector . set secur ( true ) ; fixm set ssl properti } ( address = null ) { introspect util . set properti ( connector , address , address ) ; } introspect util . set properti ( connector , port , port ) ; } catch ( except e ) { log . error ( couldn t creat connector . ) ; } return ( connector ) ; }
public process pipelin http request us specifi input output stream . throw ioexcept error dure i o oper socket state process ( nio channel socket ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set remot address remot addr = null ; remot host = null ; local addr = null ; local name = null ; remot port = 1 ; local port = 1 ; set up socket thi . socket = socket ; input buffer . set socket ( socket ) ; output buffer . set socket ( socket ) ; input buffer . set selector pool ( endpoint . get selector pool ( ) ) ; output buffer . set selector pool ( endpoint . get selector pool ( ) ) ; error flag error = fals ; keep aliv = true ; int keep aliv left = max keep aliv request ; long so timeout = endpoint . get so timeout ( ) ; int limit = 0 ; ( endpoint . get first read timeout ( ) 0 endpoint . get first read timeout ( ) 1 ) { limit = endpoint . get max thread ( ) 2 ; } boolean kept aliv = fals ; boolean open socket = fals ; boolean recycl = true ; while ( error keep aliv comet ) { pars request header try { ( disabl upload timeout kept aliv so timeout 0 ) { socket . get iochannel ( ) . socket ( ) . set so timeout ( ( int ) so timeout ) ; input buffer . read timeout = so timeout ; } ( input buffer . pars request line ( kept aliv ( endpoint . get current thread busi ( ) = limit ) ) ) { thi mean data avail right now ( long keepal ) , so processor should recycl method should return true open socket = true ; add socket poller socket . get poller ( ) . add ( socket ) ; break ; } kept aliv = true ; ( input buffer . pars header ( ) ) { open socket = true ; socket . get poller ( ) . add ( socket ) ; recycl = fals ; break ; } request . set start time ( system . current time milli ( ) ) ; ( disabl upload timeout ) { onli bodi , request header socket . get iochannel ( ) . socket ( ) . set so timeout ( ( int ) timeout ) ; input buffer . read timeout = so timeout ; } } catch ( ioexcept e ) { error = true ; break ; } catch ( throwabl t ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . header . pars ) , t ) ; } 400 bad request respons . set statu ( 400 ) ; error = true ; } set up filter , pars some request header rp . set stage ( org . apach . coyot . constant . stage prepar ) ; try { prepar request ( ) ; } catch ( throwabl t ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . request . prepar ) , t ) ; } 400 intern server error respons . set statu ( 400 ) ; error = true ; } ( max keep aliv request 0 keep aliv left = = 0 ) keep aliv = fals ; process request adapt ( error ) { try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; adapt . servic ( request , respons ) ; commit , so we can t try set header . ( keep aliv error ) { avoid check twice . error = respons . get error except ( ) = null statu drop connect ( respons . get statu ( ) ) ; } comet support select kei kei = socket . get iochannel ( ) . kei ( socket . get poller ( ) . get selector ( ) ) ; ( kei = null ) { nio endpoint . kei attach attach = ( nio endpoint . kei attach ) kei . attach ( ) ; ( attach = null ) { attach . set comet ( comet ) ; ( comet ) { integ comettimeout = ( integ ) request . get attribut ( org . apach . tomcat . comet . timeout ) ; ( comettimeout = null ) attach . set timeout ( comettimeout . long valu ( ) ) ; } } } } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { log . error ( sm . get string ( http11processor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; error = true ; } } finish handl request ( comet ) { end request ( ) ; } error , updat statist counter ( error ) { respons . set statu ( 500 ) ; } request . updat counter ( ) ; do sendfil need : add socket sendfil end ( sendfil data = null error ) { kei attach ka = ( kei attach ) socket . get attach ( fals ) ; ka . set sendfil data ( sendfil data ) ; sendfil data . keep aliv = keep aliv ; select kei kei = socket . get iochannel ( ) . kei ( socket . get poller ( ) . get selector ( ) ) ; do first write thi thread , might well open socket = socket . get poller ( ) . process sendfil ( kei , ka , true ) ; break ; } rp . set stage ( org . apach . coyot . constant . stage keepal ) ; } rp . set stage ( org . apach . coyot . constant . stage end ) ; ( comet ) { ( error ) { recycl ( ) ; return socket state . close ; } els { return socket state . long ; } } els { ( recycl ) recycl ( ) ; return ( open socket ) socket state . open : socket state . close ; } }	public process pipelin http request us specifi input output stream . throw ioexcept error dure i o oper socket state process ( long socket ) throw ioexcept { request info rp = request . get request processor ( ) ; rp . set stage ( org . apach . coyot . constant . stage pars ) ; set remot address remot addr = null ; remot host = null ; local addr = null ; local name = null ; remot port = 1 ; local port = 1 ; set up socket thi . socket = socket ; input buffer . set socket ( socket ) ; output buffer . set socket ( socket ) ; error flag error = fals ; keep aliv = true ; int keep aliv left = max keep aliv request ; long so timeout = endpoint . get so timeout ( ) ; boolean kept aliv = fals ; boolean open socket = fals ; while ( error keep aliv comet ) { pars request header try { ( disabl upload timeout kept aliv so timeout 0 ) { socket . timeout set ( socket , so timeout 1000 ) ; } ( input buffer . pars request line ( kept aliv ) ) { thi mean data avail right now ( long keepal ) , so processor should recycl method should return true open socket = true ; add socket poller endpoint . get poller ( ) . add ( socket ) ; break ; } request . set start time ( system . current time milli ( ) ) ; kept aliv = true ; ( disabl upload timeout ) { socket . timeout set ( socket , timeout 1000 ) ; } input buffer . pars header ( ) ; } catch ( ioexcept e ) { error = true ; break ; } catch ( throwabl t ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . header . pars ) , t ) ; } 400 bad request respons . set statu ( 400 ) ; error = true ; } set up filter , pars some request header rp . set stage ( org . apach . coyot . constant . stage prepar ) ; try { prepar request ( ) ; } catch ( throwabl t ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( http11processor . request . prepar ) , t ) ; } 400 intern server error respons . set statu ( 400 ) ; error = true ; } ( max keep aliv request 0 keep aliv left = = 0 ) keep aliv = fals ; process request adapt ( error ) { try { rp . set stage ( org . apach . coyot . constant . stage servic ) ; adapt . servic ( request , respons ) ; commit , so we can t try set header . ( keep aliv error ) { avoid check twice . error = respons . get error except ( ) = null statu drop connect ( respons . get statu ( ) ) ; } } catch ( interrupt ioexcept e ) { error = true ; } catch ( throwabl t ) { log . error ( sm . get string ( http11processor . request . process ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; error = true ; } } finish handl request ( comet ) { end request ( ) ; } error , updat statist counter ( error ) { respons . set statu ( 500 ) ; } request . updat counter ( ) ; do sendfil need : add socket sendfil end ( sendfil data = null error ) { sendfil data . socket = socket ; sendfil data . keep aliv = keep aliv ; ( endpoint . get sendfil ( ) . add ( sendfil data ) ) { open socket = true ; break ; } } rp . set stage ( org . apach . coyot . constant . stage keepal ) ; } rp . set stage ( org . apach . coyot . constant . stage end ) ; ( comet ) { ( error ) { recycl ( ) ; return socket state . close ; } els { return socket state . long ; } } els { recycl ( ) ; return ( open socket ) socket state . open : socket state . close ; } }	public void end request ( ) { finish handl request try { input buffer . end request ( ) ; } catch ( ioexcept e ) { error = true ; } catch ( throwabl t ) { log . error ( sm . get string ( http11processor . request . finish ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; error = true ; } try { output buffer . end request ( ) ; } catch ( ioexcept e ) { error = true ; } catch ( throwabl t ) { log . error ( sm . get string ( http11processor . respons . finish ) , t ) ; error = true ; } next request input buffer . next request ( ) ; output buffer . next request ( ) ; }	public void end request ( ) { finish handl request try { input buffer . end request ( ) ; } catch ( ioexcept e ) { error = true ; } catch ( throwabl t ) { log . error ( sm . get string ( http11processor . request . finish ) , t ) ; 500 intern server error respons . set statu ( 500 ) ; error = true ; } try { output buffer . end request ( ) ; } catch ( ioexcept e ) { error = true ; } catch ( throwabl t ) { log . error ( sm . get string ( http11processor . respons . finish ) , t ) ; error = true ; } next request input buffer . next request ( ) ; output buffer . next request ( ) ; }	public end process current http request . note : all byte current request should have been alreadi consum . thi method onli reset all pointer so we ar readi pars next http request . void next request ( ) { recycl request object request . recycl ( ) ; copi leftov byte begin buffer ( last valid po 0 ) { int npo = 0 ; int opo = po ; while ( last valid opo opo npo ) { system . arraycopi ( buf , opo , buf , npo , opo npo ) ; npo = po ; opo = po ; } system . arraycopi ( buf , opo , buf , npo , last valid opo ) ; } recycl filter ( int i = 0 ; i = last activ filter ; i ) { activ filter i . recycl ( ) ; } reset pointer last valid = last valid po ; po = 0 ; last activ filter = 1 ; pars header = true ; header pars po = header pars posit . header start ; pars request line = true ; header data . recycl ( ) ; swallow input = true ; }
privat return map path all jar file ar access webapp scan tld . map alwai includ all jar under web inf lib , well share jar classload deleg chain webapp s classload . latter constitut tomcat specif extens tld search order defin jsp spec . allow tag librari packag jar file share web applic simpli drop them locat all web applic have access ( e . g . , catalina home common lib ) . set share jar scan tld narrow down tt tld jar tt class variabl , which contain name jar ar known contain ani tld . return map jar file path map get jar path ( ) { hash map jar path map = null ; class loader webapp loader = thread . current thread ( ) . get context class loader ( ) ; class loader loader = webapp loader ; while ( loader = null ) { ( loader instanceof urlclass loader ) { url url = ( ( urlclass loader ) loader ) . get url ( ) ; ( int i = 0 ; i url . length ; i ) { expect file url thi definit clean us jar url either over file custom jndi handler , lot less buggi overal file file = new file ( url i . get file ( ) ) ; try { file = file . get canon file ( ) ; } catch ( ioexcept e ) { ignor } ( file . exist ( ) ) { continu ; } string path = file . get absolut path ( ) ; ( path . end ( . jar ) ) { continu ; } scan all jar from web inf lib , plu ani share jar ar known contain ani tld ( loader = = webapp loader tld jar = = null tld jar . contain ( file . get name ( ) ) ) { ( jar path map = = null ) { jar path map = new hash map ( ) ; jar path map . put ( path , file ) ; } els ( jar path map . contain kei ( path ) ) { jar path map . put ( path , file ) ; } } } } loader = loader . get parent ( ) ; } return jar path map ; }	privat scan jar file specifi resourc path tld code meta inf code subdirectori , scan each tld applic event listen need regist . param resourc path resourc path jar file scan except except except occur while scan thi jar void tld scan jar ( string resourc path ) throw except { ( log . debug enabl ( ) ) { log . debug ( scan jar resourc path resourc path ) ; } url url = context . get servlet context ( ) . get resourc ( resourc path ) ; ( url = = null ) { throw new illeg argument except ( sm . get string ( context config . tld resourc path , resourc path ) ) ; } file file = new file ( url . get file ( ) ) ; file = file . get canon file ( ) ; tld scan jar ( file ) ; }
public void servic ( http servlet request request , http servlet respons respons , boolean precompil ) throw servlet except , ioexcept , file found except { try { ( ctxt . remov ( ) ) { throw new file found except ( jsp uri ) ; } ( ( avail 0l ) ( avail long . max valu ) ) { respons . set date header ( retri after , avail ) ; respons . send error ( http servlet respons . sc servic unavail , local . get messag ( jsp . error . unavail ) ) ; } ( 1 ) compil ( option . get develop ( ) first time ) { synchron ( thi ) { first time = fals ; follow set reload true , necessari ctxt . compil ( ) ; } } els { ( compil except = null ) { throw cach compil except throw compil except ; } } ( 2 ) ( re ) load servlet class file get servlet ( ) ; page precompil onli , return . ( precompil ) { return ; } } catch ( file found except ex ) { ctxt . increment remov ( ) ; string includ request uri = ( string ) request . get attribut ( javax . servlet . includ . request uri ) ; ( includ request uri = null ) { servlet engin . throw new servlet except ( ex ) ; } els { try { respons . send error ( http servlet respons . sc found , ex . get messag ( ) ) ; } catch ( illeg state except ) { log . error ( local . get messag ( jsp . error . file . . found , ex . get messag ( ) ) , ex ) ; } } } catch ( servlet except ex ) { ( option . get develop ( ) ) { throw handl jsp except ( ex ) ; } els { throw ex ; } } catch ( ioexcept ex ) { ( option . get develop ( ) ) { throw handl jsp except ( ex ) ; } els { throw ex ; } } catch ( illeg state except ex ) { ( option . get develop ( ) ) { throw handl jsp except ( ex ) ; } els { throw ex ; } } catch ( except ex ) { ( option . get develop ( ) ) { throw handl jsp except ( ex ) ; } els { throw new jasper except ( ex ) ; } } try { ( 3 ) servic request ( servlet instanceof singl thread model ) { page determin right befor servic synchron ( thi ) { servlet . servic ( request , respons ) ; } } els { servlet . servic ( request , respons ) ; } } catch ( unavail except ex ) { string includ request uri = ( string ) request . get attribut ( javax . servlet . includ . request uri ) ; ( includ request uri = null ) { servlet engin . throw ex ; } els { int unavail second = ex . get unavail second ( ) ; ( unavail second = 0 ) { arbitrari default unavail second = 60 ; } avail = system . current time milli ( ) ( unavail second 1000l ) ; respons . send error ( http servlet respons . sc servic unavail , ex . get messag ( ) ) ; } } catch ( servlet except ex ) { ( option . get develop ( ) ) { throw handl jsp except ( ex ) ; } els { throw ex ; } } catch ( ioexcept ex ) { ( option . get develop ( ) ) { throw handl jsp except ( ex ) ; } els { throw ex ; } } catch ( illeg state except ex ) { ( option . get develop ( ) ) { throw handl jsp except ( ex ) ; } els { throw ex ; } } catch ( except ex ) { ( option . get develop ( ) ) { throw handl jsp except ( ex ) ; } els { throw new jasper except ( ex ) ; } } }
public final void invok ( request request , respons respons ) throw ioexcept , servlet except { initi local variabl we mai need boolean unavail = fals ; throwabl throwabl = null ; thi should request attribut . . . long t1 = system . current time milli ( ) ; request count ; standard wrapper wrapper = ( standard wrapper ) get contain ( ) ; servlet servlet = null ; context context = ( context ) wrapper . get parent ( ) ; check applic mark unavail ( context . get avail ( ) ) { respons . send error ( http servlet respons . sc servic unavail , sm . get string ( standard context . unavail ) ) ; unavail = true ; } check servlet mark unavail ( unavail wrapper . unavail ( ) ) { contain . get logger ( ) . info ( sm . get string ( standard wrapper . unavail , wrapper . get name ( ) ) ) ; long avail = wrapper . get avail ( ) ; ( ( avail 0l ) ( avail long . max valu ) ) { respons . set date header ( retri after , avail ) ; respons . send error ( http servlet respons . sc servic unavail , sm . get string ( standard wrapper . unavail , wrapper . get name ( ) ) ) ; } els ( avail = = long . max valu ) { respons . send error ( http servlet respons . sc found , sm . get string ( standard wrapper . found , wrapper . get name ( ) ) ) ; } unavail = true ; } alloc servlet instanc process thi request try { ( unavail ) { servlet = wrapper . alloc ( ) ; } } catch ( unavail except e ) { long avail = wrapper . get avail ( ) ; ( ( avail 0l ) ( avail long . max valu ) ) { respons . set date header ( retri after , avail ) ; respons . send error ( http servlet respons . sc servic unavail , sm . get string ( standard wrapper . unavail , wrapper . get name ( ) ) ) ; } els ( avail = = long . max valu ) { respons . send error ( http servlet respons . sc found , sm . get string ( standard wrapper . found , wrapper . get name ( ) ) ) ; } } catch ( servlet except e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . alloc except , wrapper . get name ( ) ) , standard wrapper . get root caus ( e ) ) ; throwabl = e ; except ( request , respons , e ) ; servlet = null ; } catch ( throwabl e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . alloc except , wrapper . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; servlet = null ; } identifi request comet relat now servlet ha been alloc boolean comet = fals ; ( servlet instanceof comet processor request . get attribut ( org . apach . tomcat . comet . support ) = = boolean . true ) { comet = true ; } acknowleg request try { respons . send acknowledg ( ) ; } catch ( ioexcept e ) { request . remov attribut ( global . jsp file attr ) ; contain . get logger ( ) . warn ( sm . get string ( standard wrapper . acknowledg except , wrapper . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; } catch ( throwabl e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . acknowledg except , wrapper . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; servlet = null ; } messag byte request path mb = null ; ( request = null ) { request path mb = request . get request path mb ( ) ; } request . set attribut ( applic filter factori . dispatch type attr , applic filter factori . request integ ) ; request . set attribut ( applic filter factori . dispatch request path attr , request path mb ) ; creat filter chain thi request applic filter factori factori = applic filter factori . get instanc ( ) ; applic filter chain filter chain = factori . creat filter chain ( request , wrapper , servlet ) ; note : thi also call servlet s servic ( ) method try { string jsp file = wrapper . get jsp file ( ) ; ( jsp file = null ) request . set attribut ( global . jsp file attr , jsp file ) ; els request . remov attribut ( global . jsp file attr ) ; ( ( servlet = null ) ( filter chain = null ) ) { swallow output need ( context . get swallow output ( ) ) { try { system log handler . start captur ( ) ; ( comet ) { filter chain . do filter event ( request . get event ( ) ) ; request . set comet ( true ) ; } els { filter chain . do filter ( request . get request ( ) , respons . get respons ( ) ) ; } } final { string log = system log handler . stop captur ( ) ; ( log = null log . length ( ) 0 ) { context . get logger ( ) . info ( log ) ; } } } els { ( comet ) { filter chain . do filter event ( request . get event ( ) ) ; request . set comet ( true ) ; } els { filter chain . do filter ( request . get request ( ) , respons . get respons ( ) ) ; } } } request . remov attribut ( global . jsp file attr ) ; } catch ( client abort except e ) { request . remov attribut ( global . jsp file attr ) ; throwabl = e ; except ( request , respons , e ) ; } catch ( ioexcept e ) { request . remov attribut ( global . jsp file attr ) ; contain . get logger ( ) . error ( sm . get string ( standard wrapper . servic except , wrapper . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; } catch ( unavail except e ) { request . remov attribut ( global . jsp file attr ) ; contain . get logger ( ) . error ( sm . get string ( standard wrapper . servic except , wrapper . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; wrapper . unavail ( e ) ; long avail = wrapper . get avail ( ) ; ( ( avail 0l ) ( avail long . max valu ) ) { respons . set date header ( retri after , avail ) ; respons . send error ( http servlet respons . sc servic unavail , sm . get string ( standard wrapper . unavail , wrapper . get name ( ) ) ) ; } els ( avail = = long . max valu ) { respons . send error ( http servlet respons . sc found , sm . get string ( standard wrapper . found , wrapper . get name ( ) ) ) ; } do save except throwabl , becaus we do want do except ( request , respons , e ) process } catch ( servlet except e ) { request . remov attribut ( global . jsp file attr ) ; throwabl root caus = standard wrapper . get root caus ( e ) ; ( ( root caus instanceof client abort except ) ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . servic except , wrapper . get name ( ) ) , root caus ) ; } throwabl = e ; except ( request , respons , e ) ; } catch ( throwabl e ) { request . remov attribut ( global . jsp file attr ) ; contain . get logger ( ) . error ( sm . get string ( standard wrapper . servic except , wrapper . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; } releas filter chain ( ani ) thi request ( filter chain = null ) { ( request . comet ( ) ) { thi comet request , same chain us process all subsequ event . filter chain . reus ( ) ; } els { filter chain . releas ( ) ; } } dealloc alloc servlet instanc try { ( servlet = null ) { wrapper . dealloc ( servlet ) ; } } catch ( throwabl e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . dealloc except , wrapper . get name ( ) ) , e ) ; ( throwabl = = null ) { throwabl = e ; except ( request , respons , e ) ; } } unload releas thi instanc try { ( ( servlet = null ) ( wrapper . get avail ( ) = = long . max valu ) ) { wrapper . unload ( ) ; } } catch ( throwabl e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . unload except , wrapper . get name ( ) ) , e ) ; ( throwabl = = null ) { throwabl = e ; except ( request , respons , e ) ; } } long t2 = system . current time milli ( ) ; long time = t2 t1 ; process time = time ; ( time max time ) max time = time ; ( time min time ) min time = time ; }

protect load specifi configur . param input stream properti file param class loader which configur load throw ioexcept someth wrong happen dure load void read configur ( input stream , class loader class loader ) throw ioexcept { class loader log info info = ( class loader log info ) class loader logger . get ( class loader ) ; try { info . prop . load ( ) ; } catch ( ioexcept e ) { report error system . err . println ( configur error ) ; e . print stack trace ( ) ; } final { try { . close ( ) ; } catch ( throwabl t ) { } } creat handler root logger thi classload string root handler = info . prop . get properti ( . handler ) ; string handler = info . prop . get properti ( handler ) ; logger local root logger = info . root node . logger ; ( handler = null ) { string token tok = new string token ( handler , , ) ; while ( tok . ha more token ( ) ) { string handler name = ( tok . next token ( ) . trim ( ) ) ; string handler class name = handler name ; string prefix = ; ( handler class name . length ( ) = 0 ) { continu ; } 10webapp foo hanlder . ) ( charact . digit ( handler class name . char ( 0 ) ) ) { int po = handler class name . index ( . ) ; ( po = 0 ) { prefix = handler class name . substr ( 0 , po 1 ) ; handler class name = handler class name . substr ( po 1 ) ; } } try { thi . prefix . set ( prefix ) ; handler handler = ( handler ) class loader . load class ( handler class name ) . new instanc ( ) ; specif strongli impli all configur should done dure creation handler object . thi includ set level , filter , formatt encod . thi . prefix . set ( null ) ; info . handler . put ( handler name , handler ) ; ( root handler = = null ) { local root logger . add handler ( handler ) ; } } catch ( except e ) { report error system . err . println ( handler error ) ; e . print stack trace ( ) ; } } add handler root logger , ani ar defin us . handler properti . ( root handler = null ) { string token tok2 = new string token ( root handler , , ) ; while ( tok2 . ha more token ( ) ) { string handler name = ( tok2 . next token ( ) . trim ( ) ) ; handler handler = ( handler ) info . handler . get ( handler name ) ; ( handler = null ) { local root logger . add handler ( handler ) ; } } } } }
public servlet get servlet ( ) throw servlet except , ioexcept , file found except { ( reload ) { synchron ( thi ) { differ page , same page . ( reload ) { thi maintain origin protocol . destroi ( ) ; try { servlet class = ctxt . load ( ) ; servlet = ( servlet ) servlet class . new instanc ( ) ; annot processor annot processor = ( annot processor ) config . get servlet context ( ) . get attribut ( annot processor . class . get name ( ) ) ; ( annot processor = null ) { annot processor . process annot ( servlet ) ; annot processor . post construct ( servlet ) ; } } catch ( illeg access except e ) { throw new jasper except ( e ) ; } catch ( instanti except e ) { throw new jasper except ( e ) ; } catch ( except e ) { throw new jasper except ( e ) ; } servlet . init ( config ) ; ( first time ) { ctxt . get runtim context ( ) . increment jsp reload count ( ) ; } reload = fals ; } } } return servlet ; }
protect instal applic specifi path from specifi web applic archiv . param writer writer render result param config url context configur file instal param path context path applic instal param war url web applic archiv instal param updat true overrid ani exist webapp path void deploi ( print writer writer , string config , string path , string war , boolean updat ) { ( config = null config . length ( ) = = 0 ) { config = null ; } ( war = null war . length ( ) = = 0 ) { war = null ; } ( debug = 1 ) { ( config = null config . length ( ) 0 ) { ( war = null ) { log ( instal : instal context configur config from war ) ; } els { log ( instal : instal context configur config ) ; } } els { ( path = null path . length ( ) 0 ) { log ( instal : instal web applic path from war ) ; } els { log ( instal : instal web applic from war ) ; } } } ( path = = null path . length ( ) = = 0 path . start ( ) ) { writer . println ( sm . get string ( manag servlet . invalid path , request util . filter ( path ) ) ) ; return ; } string displai path = path ; ( . equal ( path ) ) { path = ; } check app alreadi exist , undeploi updat context context = ( context ) host . find child ( path ) ; ( updat ) { ( context = null ) { undeploi ( writer , displai path ) ; } context = ( context ) host . find child ( path ) ; } ( context = null ) { writer . println ( sm . get string ( manag servlet . alreadi context , displai path ) ) ; return ; } ( config = null ( config . start ( file : ) ) ) { config = config . substr ( file : . length ( ) ) ; } ( war = null ( war . start ( file : ) ) ) { war = war . substr ( file : . length ( ) ) ; } try { ( servic ( path ) ) { add servic ( path ) ; try { ( config = null ) { copi ( new file ( config ) , new file ( config base , get config file ( path ) . xml ) ) ; } ( war = null ) { ( war . end ( . war ) ) { copi ( new file ( war ) , new file ( get app base ( ) , get doc base ( path ) . war ) ) ; } els { copi ( new file ( war ) , new file ( get app base ( ) , get doc base ( path ) ) ) ; } } perform new deploy check ( path ) ; } final { remov servic ( path ) ; } } context = ( context ) host . find child ( path ) ; ( context = null context . get configur ( ) ) { writer . println ( sm . get string ( manag servlet . deploi , displai path ) ) ; } els { someth fail writer . println ( sm . get string ( manag servlet . deploi fail , displai path ) ) ; } } catch ( throwabl t ) { log ( manag servlet . instal displai path , t ) ; writer . println ( sm . get string ( manag servlet . except , t . string ( ) ) ) ; } }
public call cluster befor send other node . param member member void set address ( member member ) { thi . address = address ; }
public void expir ( boolean notifi , boolean notifi cluster ) { string expir id = get id intern ( ) ; super . expir ( notifi ) ; ( notifi cluster ) { ( log . debug enabl ( ) ) log . debug ( sm . get string ( delta session . notifi , ( ( delta manag ) manag ) . get name ( ) , new boolean ( primari session ( ) ) , expir id ) ) ; ( manag instanceof delta manag ) { ( ( delta manag ) manag ) . session expir ( expir id ) ; } } }
public remov object from thi map , also remov from param kei object return object object remov ( object kei ) { map entri entri = ( map entri ) super . remov ( kei ) ; try { ( get map member ( ) . length 0 ) { map messag msg = new map messag ( get map context name ( ) , map messag . msg remov , fals , ( serializ ) kei , null , null , null ) ; get channel ( ) . send ( get map member ( ) , msg , get channel send option ( ) ) ; } } catch ( channel except x ) { log . error ( unabl replic out data lazi replic map . remov oper , x ) ; } return entri = null entri . get valu ( ) : null ; }	public object set kei ( object kei ) { object old = thi . kei ; thi . kei = ( serializ ) kei ; return old ; }	public object set valu ( object valu ) { object old = thi . valu ; thi . valu = ( serializ ) valu ; return old ; }	public servlet context get servlet context ( ) { return ( ( repl appl context ) context ) . get facad ( ) ; }	public set entri set ( ) { link hash set set = new link hash set ( super . size ( ) ) ; iter i = super . entri set ( ) . iter ( ) ; while ( i . ha next ( ) ) { map . entri e = ( map . entri ) i . next ( ) ; map entri entri = ( map entri ) e . get valu ( ) ; ( entri . primari ( ) ) set . add ( entri ) ; } return collect . unmodifi set ( set ) ; }	public set kei set ( ) { todo implement should onli return kei where thi activ . link hash set set = new link hash set ( super . size ( ) ) ; iter i = super . entri set ( ) . iter ( ) ; while ( i . ha next ( ) ) { map . entri e = ( map . entri ) i . next ( ) ; map entri entri = ( map entri ) e . get valu ( ) ; ( entri . primari ( ) ) set . add ( entri . get kei ( ) ) ; } return collect . unmodifi set ( set ) ; }	public void clear ( ) { onli delet activ kei iter kei = kei set ( ) . iter ( ) ; while ( kei . ha next ( ) ) remov ( kei . next ( ) ) ; }	public copi all valu from map thi instanc param m map void put all ( map m ) { iter i = m . entri set ( ) . iter ( ) ; while ( i . ha next ( ) ) { map . entri entri = ( map . entri ) i . next ( ) ; put ( entri . get kei ( ) , entri . get valu ( ) ) ; } }	public bind specifi valu specifi context attribut name , replac ani exist valu name . param name attribut name bound param valu new attribut valu bound void set attribut ( string name , object valu ) { name cannot null ( name = = null ) throw new illeg argument except ( sm . get string ( applic context . set attribut . namenul ) ) ; null valu same remov attribut ( ) ( valu = = null ) { remov attribut ( name ) ; return ; } object old valu = null ; boolean replac = fals ; check read onli attribut ( read onli attribut . contain kei ( name ) ) return ; old valu = attribut . get ( name ) ; ( old valu = null ) replac = true ; attribut . put ( name , valu ) ; notifi interest applic event listen object listen = context . get applic event listen ( ) ; ( ( listen = = null ) ( listen . length = = 0 ) ) return ; servlet context attribut event event = null ; ( replac ) event = new servlet context attribut event ( context . get servlet context ( ) , name , old valu ) ; els event = new servlet context attribut event ( context . get servlet context ( ) , name , valu ) ; ( int i = 0 ; i listen . length ; i ) { ( ( listen i instanceof servlet context attribut listen ) ) continu ; servlet context attribut listen listen = ( servlet context attribut listen ) listen i ; try { ( replac ) { context . fire contain event ( befor context attribut replac , listen ) ; listen . attribut replac ( event ) ; context . fire contain event ( after context attribut replac , listen ) ; } els { context . fire contain event ( befor context attribut ad , listen ) ; listen . attribut ad ( event ) ; context . fire contain event ( after context attribut ad , listen ) ; } } catch ( throwabl t ) { ( replac ) context . fire contain event ( after context attribut replac , listen ) ; els context . fire contain event ( after context attribut ad , listen ) ; fixm should we do anyth besid log log ( sm . get string ( applic context . attribut event ) , t ) ; } } }	public void set attribut map ( abstract map map ) { thi . attribut = map ; }
protect after read request header , we have setup request filter . void prepar request ( ) { http11 = true ; http09 = fals ; content delimit = fals ; expect = fals ; ( ssl support = null ) { request . scheme ( ) . set string ( http ) ; } messag byte protocol mb = request . protocol ( ) ; ( protocol mb . equal ( constant . http 11 ) ) { http11 = true ; protocol mb . set string ( constant . http 11 ) ; } els ( protocol mb . equal ( constant . http 10 ) ) { http11 = fals ; keep aliv = fals ; protocol mb . set string ( constant . http 10 ) ; } els ( protocol mb . equal ( ) ) { http 0 . 9 http09 = true ; http11 = fals ; keep aliv = fals ; } els { unsupport protocol http11 = fals ; error = true ; send 505 ; unsupport http version respons . set statu ( 505 ) ; } messag byte method mb = request . method ( ) ; ( method mb . equal ( constant . get ) ) { method mb . set string ( constant . get ) ; } els ( method mb . equal ( constant . post ) ) { method mb . set string ( constant . post ) ; } mime header header = request . get mime header ( ) ; check connect header messag byte connect valu mb = header . get valu ( connect ) ; ( connect valu mb = null ) { byte chunk connect valu bc = connect valu mb . get byte chunk ( ) ; ( find byte ( connect valu bc , constant . close byte ) = 1 ) { keep aliv = fals ; } els ( find byte ( connect valu bc , constant . keepal byte ) = 1 ) { keep aliv = true ; } } messag byte expect mb = null ; ( http11 ) expect mb = header . get valu ( expect ) ; ( ( expect mb = null ) ( expect mb . index ignor case ( 100 continu , 0 ) = 1 ) ) { input buffer . set swallow input ( fals ) ; expect = true ; } check user agent header ( ( restrict user agent = null ) ( ( http11 ) ( keep aliv ) ) ) { messag byte user agent valu mb = header . get valu ( user agent ) ; keep aliv flag accordingli ( user agent valu mb = null ) { string user agent valu = user agent valu mb . string ( ) ; ( int i = 0 ; i restrict user agent . length ; i ) { ( restrict user agent i . matcher ( user agent valu ) . match ( ) ) { http11 = fals ; keep aliv = fals ; break ; } } } } check full uri ( includ protocol : host : port ) byte chunk uri bc = request . request uri ( ) . get byte chunk ( ) ; ( uri bc . start ignor case ( http , 0 ) ) { int po = uri bc . index ( : , 0 , 3 , 4 ) ; int uri bcstart = uri bc . get start ( ) ; int slash po = 1 ; ( po = 1 ) { byte uri b = uri bc . get byte ( ) ; slash po = uri bc . index ( , po 3 ) ; ( slash po = = 1 ) { slash po = uri bc . get length ( ) ; set uri request . request uri ( ) . set byte ( uri b , uri bcstart po 1 , 1 ) ; } els { request . request uri ( ) . set byte ( uri b , uri bcstart slash po , uri bc . get length ( ) slash po ) ; } messag byte host mb = header . set valu ( host ) ; host mb . set byte ( uri b , uri bcstart po 3 , slash po po 3 ) ; } } input filter setup input filter input filter = input buffer . get filter ( ) ; pars transfer encod header messag byte transfer encod valu mb = null ; ( http11 ) transfer encod valu mb = header . get valu ( transfer encod ) ; ( transfer encod valu mb = null ) { string transfer encod valu = transfer encod valu mb . string ( ) ; pars comma separ list . ident code ar ignor int start po = 0 ; int comma po = transfer encod valu . index ( , ) ; string encod name = null ; while ( comma po = 1 ) { encod name = transfer encod valu . substr ( start po , comma po ) . lower case ( ) . trim ( ) ; ( add input filter ( input filter , encod name ) ) { unsupport transfer encod error = true ; 501 unimpl respons . set statu ( 501 ) ; } start po = comma po 1 ; comma po = transfer encod valu . index ( , , start po ) ; } encod name = transfer encod valu . substr ( start po ) . lower case ( ) . trim ( ) ; ( add input filter ( input filter , encod name ) ) { unsupport transfer encod error = true ; 501 unimpl respons . set statu ( 501 ) ; } } pars content length header long content length = request . get content length long ( ) ; ( content length = 0 content delimit ) { input buffer . add activ filter ( input filter constant . ident filter ) ; content delimit = true ; } messag byte valu mb = header . get valu ( host ) ; check host header ( http11 ( valu mb = = null ) ) { error = true ; 400 bad request respons . set statu ( 400 ) ; } pars host ( valu mb ) ; ( content delimit ) { s content length ( broken http 1 . 0 http 1 . 1 ) , assum client broken didn t send bodi input buffer . add activ filter ( input filter constant . void filter ) ; content delimit = true ; } }
protect identifi return code java . secur . princip code instanc repres authent user specifi code subject code . princip construct scan list princip return jaaslogin modul . first code princip code object match class name suppli user class user princip . thi object return tha caller . ani remain princip object return login modul ar map role , onli respect class match role class class . user princip cannot construct , return code null code . param subject code subject code repres log user princip creat princip ( string usernam , subject subject ) { prepar scan princip thi subject carri forward string password = null ; list role = new arrai list ( ) ; princip user princip = null ; scan princip thi subject iter princip = subject . get princip ( ) . iter ( ) ; while ( princip . ha next ( ) ) { princip princip = ( princip ) princip . next ( ) ; string princip class = princip . get class ( ) . get name ( ) ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jaa realm . check princip , princip , princip class ) ) ; } ( user princip = = null user class . contain ( princip class ) ) { user princip = princip ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jaa realm . user princip success , princip . get name ( ) ) ) ; } } ( role class . contain ( princip class ) ) { role . add ( princip . get name ( ) ) ; ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jaa realm . role princip add , princip . get name ( ) ) ) ; } } } print failur messag need ( user princip = = null ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jaa realm . user princip failur ) ) ; log . debug ( sm . get string ( jaa realm . role princip failur ) ) ; } } els { ( role . size ( ) = = 0 ) { ( log . debug enabl ( ) ) { log . debug ( sm . get string ( jaa realm . role princip failur ) ) ; } } } return result princip our authent user return new gener princip ( thi , usernam , null , role , user princip ) ; }	public void set contain ( contain contain ) { super . set contain ( contain ) ; ( app name = = null ) { string name = contain . get name ( ) ; name = make legal jaa ( name ) ; app name = name ; log . info ( set jaa app name app name ) ; } }	public set list comma delimit class repres role . class list must implement code java . secur . princip code . when thi accessor call ( exampl , code digest code instanc pars configur file ) , pars class name store result string ( s ) code arrai list code field code role class code . void set role class name ( string role class name ) { thi . role class name = role class name ; role class . clear ( ) ; string temp = thi . role class name ; ( temp = = null ) { return ; } while ( true ) { int comma = temp . index ( , ) ; ( comma 0 ) { break ; } role class . add ( temp . substr ( 0 , comma ) . trim ( ) ) ; temp = temp . substr ( comma 1 ) ; } temp = temp . trim ( ) ; ( temp . length ( ) 0 ) { role class . add ( temp ) ; } }	public set list comma delimit class repres individu user . class list must implement code java . secur . princip code . when thi accessor call ( exampl , code digest code instanc pars configur file ) , pars class name store result string ( s ) code arrai list code field code user class code . void set user class name ( string user class name ) { thi . user class name = user class name ; user class . clear ( ) ; string temp = thi . user class name ; ( temp = = null ) { return ; } while ( true ) { int comma = temp . index ( , ) ; ( comma 0 ) { break ; } user class . add ( temp . substr ( 0 , comma ) . trim ( ) ) ; temp = temp . substr ( comma 1 ) ; } temp = temp . trim ( ) ; ( temp . length ( ) 0 ) { user class . add ( temp ) ; } }
protect void gener class ( string smap ) throw file found except , jasper except , except { long t1 = 0 ; ( log . debug enabl ( ) ) { t1 = system . current time milli ( ) ; } final string sourc file = ctxt . get servlet java file name ( ) ; final string output dir = ctxt . get option ( ) . get scratch dir ( ) . get absolut path ( ) ; string packag name = ctxt . get servlet packag name ( ) ; final string target class name = ( ( packag name . length ( ) = 0 ) ( packag name . ) : ) ctxt . get servlet class name ( ) ; final class loader class loader = ctxt . get jsp loader ( ) ; string file name = new string { sourc file } ; string class name = new string { target class name } ; final arrai list problem list = new arrai list ( ) ; class compil unit implement icompil unit { string class name ; string sourc file ; compil unit ( string sourc file , string class name ) { thi . class name = class name ; thi . sourc file = sourc file ; } public char get file name ( ) { return sourc file . char arrai ( ) ; } public char get content ( ) { char result = null ; try { input stream reader reader = new input stream reader ( new file input stream ( sourc file ) , ctxt . get option ( ) . get java encod ( ) ) ; reader reader = new buffer reader ( reader ) ; ( reader = null ) { char char = new char 8192 ; string buffer buf = new string buffer ( ) ; int count ; while ( ( count = reader . read ( char , 0 , char . length ) ) 0 ) { buf . append ( char , 0 , count ) ; } result = new char buf . length ( ) ; buf . get char ( 0 , result . length , result , 0 ) ; } } catch ( ioexcept e ) { log . error ( compil error , e ) ; } return result ; } public char get main type name ( ) { int dot = class name . last index ( . ) ; ( dot 0 ) { return class name . substr ( dot 1 ) . char arrai ( ) ; } return class name . char arrai ( ) ; } public char get packag name ( ) { string token izer = new string token ( class name , . ) ; char result = new char izer . count token ( ) 1 ; ( int i = 0 ; i result . length ; i ) { string tok = izer . next token ( ) ; result i = tok . char arrai ( ) ; } return result ; } } final inam environ env = new inam environ ( ) { public name environ answer find type ( char compound type name ) { string result = ; string sep = ; ( int i = 0 ; i compound type name . length ; i ) { result = sep ; result = new string ( compound type name i ) ; sep = . ; } return find type ( result ) ; } public name environ answer find type ( char type name , char packag name ) { string result = ; string sep = ; ( int i = 0 ; i packag name . length ; i ) { result = sep ; result = new string ( packag name i ) ; sep = . ; } result = sep ; result = new string ( type name ) ; return find type ( result ) ; } } }
public synchron prepar activ us public method thi compon . except lifecycl except thi compon detect fatal error prevent from start void start ( ) throw lifecycl except { perform normal superclass initi super . start ( ) ; valid exist our databas file file file = new file ( pathnam ) ; ( file . absolut ( ) ) file = new file ( system . get properti ( catalina . base ) , pathnam ) ; ( file . exist ( ) file . can read ( ) ) throw new lifecycl except ( sm . get string ( memori realm . load exist , file . get absolut path ( ) ) ) ; load content databas file ( log . debug enabl ( ) ) log . debug ( sm . get string ( memori realm . load path , file . get absolut path ( ) ) ) ; digest digest = get digest ( ) ; try { synchron ( digest ) { digest . push ( thi ) ; digest . pars ( file ) ; } } catch ( except e ) { throw new lifecycl except ( memori realm . read xml , e ) ; } final { digest . reset ( ) ; } }
protect check modifi sinc condit satisfi . param request servlet request we ar process param respons servlet respons we ar creat param resourc info file object return boolean true resourc meet specifi condit , fals condit satisfi , which case request process stop boolean check modifi sinc ( http servlet request request , http servlet respons respons , resourc attribut resourc attribut ) throw ioexcept { try { long header valu = request . get date header ( modifi sinc ) ; long last modifi = resourc attribut . get last modifi ( ) ; ( header valu = 1 ) { ignor . ( ( request . get header ( none match ) = = null ) ( last modifi = header valu 1000 ) ) { entiti ha been modifi sinc date specifi client . thi error case . respons . set statu ( http servlet respons . sc modifi ) ; return fals ; } } } catch ( illeg argument except illeg argument ) { return true ; } return true ; }	protect check unmodifi sinc condit satisfi . param request servlet request we ar process param respons servlet respons we ar creat param resourc info file object return boolean true resourc meet specifi condit , fals condit satisfi , which case request process stop boolean check unmodifi sinc ( http servlet request request , http servlet respons respons , resourc attribut resourc attribut ) throw ioexcept { try { long last modifi = resourc attribut . get last modifi ( ) ; long header valu = request . get date header ( unmodifi sinc ) ; ( header valu = 1 ) { ( last modifi ( header valu 1000 ) ) { entiti ha been modifi sinc date specifi client . thi error case . respons . send error ( http servlet respons . sc precondit fail ) ; return fals ; } } } catch ( illeg argument except illeg argument ) { return true ; } return true ; }
public load initi all servlet mark load startup web applic deploy descriptor . param children arrai wrapper all current defin servlet ( includ those declar load startup ) void load startup ( contain children ) { collect load startup servlet need initi tree map map = new tree map ( ) ; ( int i = 0 ; i children . length ; i ) { wrapper wrapper = ( wrapper ) children i ; int load startup = wrapper . get load startup ( ) ; ( load startup 0 ) continu ; ( arbitrarili put them last load startup = = 0 ) load startup = integ . max valu ; integ kei = new integ ( load startup ) ; arrai list list = ( arrai list ) map . get ( kei ) ; ( list = = null ) { list = new arrai list ( ) ; map . put ( kei , list ) ; } list . add ( wrapper ) ; } load collect load startup servlet iter kei = map . kei set ( ) . iter ( ) ; while ( kei . ha next ( ) ) { integ kei = ( integ ) kei . next ( ) ; arrai list list = ( arrai list ) map . get ( kei ) ; iter wrapper = list . iter ( ) ; while ( wrapper . ha next ( ) ) { wrapper wrapper = ( wrapper ) wrapper . next ( ) ; try { wrapper . load ( ) ; } catch ( servlet except e ) { get logger ( ) . error ( sm . get string ( standard wrapper . load except , get name ( ) ) , standard wrapper . get root caus ( e ) ) ; note : load error ( includ servlet throw unavail except from tht init ( ) method ) ar fatal applic startup } } } }
public final void invok ( request request , respons respons ) throw ioexcept , servlet except { initi local variabl we mai need boolean unavail = fals ; throwabl throwabl = null ; thi should request attribut . . . long t1 = system . current time milli ( ) ; request count ; standard wrapper wrapper = ( standard wrapper ) get contain ( ) ; servlet servlet = null ; context context = ( context ) wrapper . get parent ( ) ; check applic mark unavail ( context . get avail ( ) ) { respons . send error ( http servlet respons . sc servic unavail , sm . get string ( standard context . unavail ) ) ; unavail = true ; } check servlet mark unavail ( unavail wrapper . unavail ( ) ) { contain . get logger ( ) . info ( sm . get string ( standard wrapper . unavail , wrapper . get name ( ) ) ) ; long avail = wrapper . get avail ( ) ; ( ( avail 0l ) ( avail long . max valu ) ) { respons . set date header ( retri after , avail ) ; respons . send error ( http servlet respons . sc servic unavail , sm . get string ( standard wrapper . unavail , wrapper . get name ( ) ) ) ; } els ( avail = = long . max valu ) { respons . send error ( http servlet respons . sc found , sm . get string ( standard wrapper . found , wrapper . get name ( ) ) ) ; } unavail = true ; } alloc servlet instanc process thi request try { ( unavail ) { servlet = wrapper . alloc ( ) ; } } catch ( unavail except e ) { long avail = wrapper . get avail ( ) ; ( ( avail 0l ) ( avail long . max valu ) ) { respons . set date header ( retri after , avail ) ; respons . send error ( http servlet respons . sc servic unavail , sm . get string ( standard wrapper . unavail , wrapper . get name ( ) ) ) ; } els ( avail = = long . max valu ) { respons . send error ( http servlet respons . sc found , sm . get string ( standard wrapper . found , wrapper . get name ( ) ) ) ; } } catch ( servlet except e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . alloc except , wrapper . get name ( ) ) , standard wrapper . get root caus ( e ) ) ; throwabl = e ; except ( request , respons , e ) ; servlet = null ; } catch ( throwabl e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . alloc except , wrapper . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; servlet = null ; } identifi request comet relat now servlet ha been alloc ( servlet instanceof comet processor request . get attribut ( org . apach . tomcat . comet . support ) = = boolean . true ) { request . set comet ( true ) ; } acknowleg request try { respons . send acknowledg ( ) ; } catch ( ioexcept e ) { request . remov attribut ( global . jsp file attr ) ; contain . get logger ( ) . warn ( sm . get string ( standard wrapper . acknowledg except , wrapper . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; } catch ( throwabl e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . acknowledg except , wrapper . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; servlet = null ; } messag byte request path mb = null ; ( request = null ) { request path mb = request . get request path mb ( ) ; } request . set attribut ( applic filter factori . dispatch type attr , applic filter factori . request integ ) ; request . set attribut ( applic filter factori . dispatch request path attr , request path mb ) ; creat filter chain thi request applic filter factori factori = applic filter factori . get instanc ( ) ; applic filter chain filter chain = factori . creat filter chain ( request , wrapper , servlet ) ; note : thi also call servlet s servic ( ) method try { string jsp file = wrapper . get jsp file ( ) ; ( jsp file = null ) request . set attribut ( global . jsp file attr , jsp file ) ; els request . remov attribut ( global . jsp file attr ) ; ( ( servlet = null ) ( filter chain = null ) ) { swallow output need ( context . get swallow output ( ) ) { try { system log handler . start captur ( ) ; ( request . comet ( ) ) { filter chain . do filter event ( request . get event ( ) ) ; } els { filter chain . do filter ( request . get request ( ) , respons . get respons ( ) ) ; } } final { string log = system log handler . stop captur ( ) ; ( log = null log . length ( ) 0 ) { context . get logger ( ) . info ( log ) ; } } } els { ( request . comet ( ) ) { filter chain . do filter event ( request . get event ( ) ) ; } els { filter chain . do filter ( request . get request ( ) , respons . get respons ( ) ) ; } } } request . remov attribut ( global . jsp file attr ) ; } catch ( client abort except e ) { request . remov attribut ( global . jsp file attr ) ; throwabl = e ; except ( request , respons , e ) ; } catch ( ioexcept e ) { request . remov attribut ( global . jsp file attr ) ; contain . get logger ( ) . warn ( sm . get string ( standard wrapper . servic except , wrapper . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; } catch ( unavail except e ) { request . remov attribut ( global . jsp file attr ) ; contain . get logger ( ) . warn ( sm . get string ( standard wrapper . servic except , wrapper . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; wrapper . unavail ( e ) ; long avail = wrapper . get avail ( ) ; ( ( avail 0l ) ( avail long . max valu ) ) { respons . set date header ( retri after , avail ) ; respons . send error ( http servlet respons . sc servic unavail , sm . get string ( standard wrapper . unavail , wrapper . get name ( ) ) ) ; } els ( avail = = long . max valu ) { respons . send error ( http servlet respons . sc found , sm . get string ( standard wrapper . found , wrapper . get name ( ) ) ) ; } do save except throwabl , becaus we do want do except ( request , respons , e ) process } catch ( servlet except e ) { request . remov attribut ( global . jsp file attr ) ; throwabl root caus = standard wrapper . get root caus ( e ) ; ( ( root caus instanceof client abort except ) ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . servic except , wrapper . get name ( ) ) , root caus ) ; } throwabl = e ; except ( request , respons , e ) ; } catch ( throwabl e ) { request . remov attribut ( global . jsp file attr ) ; contain . get logger ( ) . error ( sm . get string ( standard wrapper . servic except , wrapper . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; } releas filter chain ( ani ) thi request ( filter chain = null ) { ( request . comet ( ) ) { thi comet request , same chain us process all subsequ event . filter chain . reus ( ) ; } els { filter chain . releas ( ) ; } } dealloc alloc servlet instanc try { ( servlet = null ) { wrapper . dealloc ( servlet ) ; } } catch ( throwabl e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . dealloc except , wrapper . get name ( ) ) , e ) ; ( throwabl = = null ) { throwabl = e ; except ( request , respons , e ) ; } } unload releas thi instanc try { ( ( servlet = null ) ( wrapper . get avail ( ) = = long . max valu ) ) { wrapper . unload ( ) ; } } catch ( throwabl e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . unload except , wrapper . get name ( ) ) , e ) ; ( throwabl = = null ) { throwabl = e ; except ( request , respons , e ) ; } } long t2 = system . current time milli ( ) ; long time = t2 t1 ; process time = time ; ( time max time ) max time = time ; ( time min time ) min time = time ; }	public process comet event . main differ here ar us send error ( respons commit ) , avoid creat new filter chain ( which would work pointless ) , few veri minor tweak . param request servlet request process param respons servlet respons creat except ioexcept input output error occur , thrown subsequ invok valv , filter , servlet except servlet except servlet error occur , thrown subsequ invok valv , filter , servlet void event ( request request , respons respons , comet event event ) throw ioexcept , servlet except { initi local variabl we mai need throwabl throwabl = null ; thi should request attribut . . . long t1 = system . current time milli ( ) ; fixm : add flag count total amount event process request count ; standard wrapper wrapper = ( standard wrapper ) get contain ( ) ; servlet servlet = null ; context context = ( context ) wrapper . get parent ( ) ; check applic mark unavail boolean unavail = context . get avail ( ) wrapper . unavail ( ) ; alloc servlet instanc process thi request try { ( unavail ) { servlet = wrapper . alloc ( ) ; } } catch ( unavail except e ) { respons alreadi commit , so s possibl do anyth } catch ( servlet except e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . alloc except , wrapper . get name ( ) ) , standard wrapper . get root caus ( e ) ) ; throwabl = e ; except ( request , respons , e ) ; servlet = null ; } catch ( throwabl e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . alloc except , wrapper . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; servlet = null ; } messag byte request path mb = null ; ( request = null ) { request path mb = request . get request path mb ( ) ; } request . set attribut ( applic filter factori . dispatch type attr , applic filter factori . request integ ) ; request . set attribut ( applic filter factori . dispatch request path attr , request path mb ) ; get current ( unchang ) filter chain thi request applic filter chain filter chain = ( applic filter chain ) request . get filter chain ( ) ; note : thi also call servlet s event ( ) method try { string jsp file = wrapper . get jsp file ( ) ; ( jsp file = null ) request . set attribut ( global . jsp file attr , jsp file ) ; els request . remov attribut ( global . jsp file attr ) ; ( ( servlet = null ) ( filter chain = null ) ) { swallow output need ( context . get swallow output ( ) ) { try { system log handler . start captur ( ) ; filter chain . do filter event ( request . get event ( ) ) ; } final { string log = system log handler . stop captur ( ) ; ( log = null log . length ( ) 0 ) { context . get logger ( ) . info ( log ) ; } } } els { filter chain . do filter event ( request . get event ( ) ) ; } } request . remov attribut ( global . jsp file attr ) ; } catch ( client abort except e ) { request . remov attribut ( global . jsp file attr ) ; throwabl = e ; except ( request , respons , e ) ; } catch ( ioexcept e ) { request . remov attribut ( global . jsp file attr ) ; contain . get logger ( ) . warn ( sm . get string ( standard wrapper . servic except , wrapper . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; } catch ( unavail except e ) { request . remov attribut ( global . jsp file attr ) ; contain . get logger ( ) . warn ( sm . get string ( standard wrapper . servic except , wrapper . get name ( ) ) , e ) ; do save except throwabl , becaus we do want do except ( request , respons , e ) process } catch ( servlet except e ) { request . remov attribut ( global . jsp file attr ) ; throwabl root caus = standard wrapper . get root caus ( e ) ; ( ( root caus instanceof client abort except ) ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . servic except , wrapper . get name ( ) ) , root caus ) ; } throwabl = e ; except ( request , respons , e ) ; } catch ( throwabl e ) { request . remov attribut ( global . jsp file attr ) ; contain . get logger ( ) . error ( sm . get string ( standard wrapper . servic except , wrapper . get name ( ) ) , e ) ; throwabl = e ; except ( request , respons , e ) ; } releas filter chain ( ani ) thi request ( filter chain = null ) { filter chain . reus ( ) ; } dealloc alloc servlet instanc try { ( servlet = null ) { wrapper . dealloc ( servlet ) ; } } catch ( throwabl e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . dealloc except , wrapper . get name ( ) ) , e ) ; ( throwabl = = null ) { throwabl = e ; except ( request , respons , e ) ; } } unload releas thi instanc try { ( ( servlet = null ) ( wrapper . get avail ( ) = = long . max valu ) ) { wrapper . unload ( ) ; } } catch ( throwabl e ) { contain . get logger ( ) . error ( sm . get string ( standard wrapper . unload except , wrapper . get name ( ) ) , e ) ; ( throwabl = = null ) { throwabl = e ; except ( request , respons , e ) ; } } long t2 = system . current time milli ( ) ; long time = t2 t1 ; process time = time ; ( time max time ) max time = time ; ( time min time ) min time = time ; }
page context intern get page context ( servlet servlet , servlet request request , servlet respons respons , string error page url , boolean need session , int buffer size , boolean autoflush ) { try { page context pc ; ( us pool ) { pc = ( page context ) pool . get ( ) ; ( pc = = null ) { pc = new page context impl ( ) ; } } els { pc = new page context impl ( ) ; } pc . initi ( servlet , request , respons , error page url , need session , buffer size , autoflush ) ; return pc ; } catch ( throwabl ex ) { fixm : need do someth reason here log . fatal ( except initi page context , ex ) ; return null ; } }	privat void intern releas page context ( page context pc ) { pc . releas ( ) ; ( us pool ( pc instanceof page context impl ) ) { pool . put ( pc ) ; } }	privat void intern releas page context ( page context pc ) { pc . releas ( ) ; ( us pool ( pc instanceof page context impl ) ) { pool . put ( pc ) ; } }
privat gener static initi preambl . exampl , depend list , el function map , prefix map . ( share servlet tag handler preambl gener ) void gen preambl static initi ( ) throw jasper except { static data get depend ( ) out . printil ( privat static java . util . list jspx depend ; ) ; out . println ( ) ; list depend = page info . get depend ( ) ; iter iter = depend . iter ( ) ; ( depend . empti ( ) ) { out . printil ( static { ) ; out . push indent ( ) ; out . printin ( jspx depend = new java . util . arrai list ( ) ; out . print ( depend . size ( ) ) ; out . println ( ) ; ) ; while ( iter . ha next ( ) ) { out . printin ( jspx depend . add ( ) ; out . print ( ( string ) iter . next ( ) ) ; out . println ( ) ; ) ; } out . pop indent ( ) ; out . printil ( } ) ; out . println ( ) ; } }	gener jsp init ( ) method instanti tag handler pool . tag file , jsp init ha invok manual , servlet config object explicitli pass . jsp 2 . 1 , we also instanti express factori void gener init ( ) { ( ctxt . tag file ( ) ) { out . printil ( privat void jsp init ( servlet config config ) { ) ; } els { out . printil ( public void jsp init ( ) { ) ; } out . push indent ( ) ; ( pool enabl ) { ( int i = 0 ; i tag handler pool name . size ( ) ; i ) { out . printin ( tag handler pool name . element ( i ) ) ; out . print ( = org . apach . jasper . runtim . tag handler pool . get tag handler pool ( ) ; ( ctxt . tag file ( ) ) { out . print ( config ) ; } els { out . print ( get servlet config ( ) ) ; } out . println ( ) ; ) ; } } out . printin ( var expressionfactori ) ; out . print ( = jsp factori . get default factori ( ) . get jsp applic context ( ) ; ( ctxt . tag file ( ) ) { out . print ( config ) ; } els { out . print ( get servlet config ( ) ) ; } out . println ( . get servlet context ( ) ) . get express factori ( ) ; ) ; out . printin ( var annotationprocessor ) ; out . print ( = ( org . apach . annot processor ) ) ; ( ctxt . tag file ( ) ) { out . print ( config ) ; } els { out . print ( get servlet config ( ) ) ; } out . println ( . get servlet context ( ) . get attribut ( org . apach . annot processor . class . get name ( ) ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; out . println ( ) ; }	privat gener end part static portion servlet . void gener postambl ( node . node page ) { out . pop indent ( ) ; out . printil ( } catch ( throwabl t ) { ) ; out . push indent ( ) ; out . printil ( ( ( t instanceof skip page except ) ) { ) ; out . push indent ( ) ; out . printil ( out = jspx out ; ) ; out . printil ( ( out = null out . get buffer size ( ) = 0 ) ) ; out . push indent ( ) ; out . printil ( try { out . clear buffer ( ) ; } catch ( java . io . ioexcept e ) { } ) ; out . pop indent ( ) ; out . printil ( ( jspx page context = null ) jspx page context . handl page except ( t ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; out . pop indent ( ) ; out . printil ( } final { ) ; out . push indent ( ) ; out . printil ( ( jspx factori = null ) jspx factori . releas page context ( jspx page context ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; close servic method out . pop indent ( ) ; out . printil ( } ) ; gener method , helper class , etc . gen common postambl ( ) ; }	privat gener begin static portion servlet . void gener preambl ( node . node page ) throw jasper except { string servlet packag name = ctxt . get servlet packag name ( ) ; string servlet class name = ctxt . get servlet class name ( ) ; string servic method name = constant . servic method name ; first packag name : gen preambl packag ( servlet packag name ) ; gener import gen preambl import ( ) ; gener class declar out . printin ( public final class ) ; out . print ( servlet class name ) ; out . print ( extend ) ; out . println ( page info . get extend ( ) ) ; out . printin ( implement org . apach . jasper . runtim . jsp sourc depend ) ; ( page info . thread safe ( ) ) { out . println ( , ) ; out . printin ( singl thread model ) ; } out . println ( { ) ; out . push indent ( ) ; class bodi begin here gener declar ( page ) ; static initi here gen preambl static initi ( ) ; class variabl declar gen preambl class variabl declar ( servlet class name ) ; constructor gener constructor ( class name ) ; method here gen preambl method ( ) ; now servic method out . printin ( public void ) ; out . print ( servic method name ) ; out . println ( ( http servlet request request , http servlet respons respons ) ) ; out . println ( throw java . io . ioexcept , servlet except { ) ; out . push indent ( ) ; out . println ( ) ; local variabl declar out . printil ( jsp factori jspx factori = null ; ) ; out . printil ( page context page context = null ; ) ; ( page info . session ( ) ) out . printil ( http session session = null ; ) ; ( page info . error page ( ) ) { out . printil ( throwabl except = org . apach . jasper . runtim . jsp runtim librari . get throwabl ( request ) ; ) ; out . printil ( ( except = null ) { ) ; out . push indent ( ) ; out . printil ( respons . set statu ( http servlet respons . sc intern server error ) ; ) ; out . pop indent ( ) ; out . printil ( } ) ; } out . printil ( servlet context applic = null ; ) ; out . printil ( servlet config config = null ; ) ; out . printil ( jsp writer out = null ; ) ; out . printil ( object page = thi ; ) ; out . printil ( jsp writer jspx out = null ; ) ; out . printil ( page context jspx page context = null ; ) ; out . println ( ) ; declar temporari script var ( page ) ; out . println ( ) ; out . printil ( try { ) ; out . push indent ( ) ; out . printil ( jspx factori = jsp factori . get default factori ( ) ; ) ; out . printin ( respons . set content type ( ) ; out . print ( quot ( page info . get content type ( ) ) ) ; out . println ( ) ; ) ; ( ctxt . get option ( ) . xpower ( ) ) { out . printil ( respons . add header ( x power , jsp 2 . 1 ) ; ) ; } out . printil ( page context = jspx factori . get page context ( thi , request , respons , ) ; out . printin ( t t t ) ; out . print ( quot ( page info . get error page ( ) ) ) ; out . print ( , page info . session ( ) ) ; out . print ( , page info . get buffer ( ) ) ; out . print ( , page info . auto flush ( ) ) ; out . println ( ) ; ) ; out . printil ( jspx page context = page context ; ) ; out . printil ( applic = page context . get servlet context ( ) ; ) ; out . printil ( config = page context . get servlet config ( ) ; ) ; ( page info . session ( ) ) out . printil ( session = page context . get session ( ) ; ) ; out . printil ( out = page context . get out ( ) ; ) ; out . printil ( jspx out = out ; ) ; out . println ( ) ; }
privat return code true code specifi servlet name match requir specifi filter map ; otherwis return code fals code . param filter map filter map check param servlet name servlet name check boolean match filter servlet ( filter map filter map , string servlet name ) { ( servlet name = = null ) { return ( fals ) ; } els { string servlet name = filter map . get servlet name ( ) ; ( int i = 0 ; i servlet name . length ; i ) { ( servlet name . equal ( servlet name i ) ) { return ( true ) ; } } return fals ; } }	privat return code true code context rel request path match requir specifi filter map ; otherwis , return code fals code . param filter map filter map check param request path context rel request path thi request boolean match filter url ( filter map filter map , string request path ) { name dispatch ( filter map . get all match ( ) ) return ( true ) ; ( request path = = null ) return ( fals ) ; match context rel request path string test path = filter map . get urlpattern ( ) ; ( int i = 0 ; i test path . length ; i ) { ( match filter url ( test path i , request path ) ) { return ( true ) ; } } match return ( fals ) ; }	public string get urlpattern ( ) { return ( thi . url pattern ) ; }	public void add servlet name ( string servlet name ) { string result = new string servlet name . length 1 ; system . arraycopi ( servlet name , 0 , result , 0 , servlet name . length ) ; result servlet name . length = servlet name ; servlet name = result ; }	public void add urlpattern ( string url pattern ) { ( . equal ( url pattern ) ) { thi . all match = true ; } els { string result = new string url pattern . length 1 ; system . arraycopi ( url pattern , 0 , result , 0 , url pattern . length ) ; result url pattern . length = request util . urldecod ( url pattern ) ; url pattern = result ; } }
public perform block write us bytebuff data written selector block . code selector code paramet null , perform busi write could take up lot cpu cycl . param buf byte buffer buffer contain data , we write long code ( buf . ha remain ( ) = = true ) code param socket socket channel socket write data param selector selector selector us block , null busi write initi param write timeout long timeout thi write oper millisecond , 1 mean timeout return int return number byte written throw eofexcept write return 1 throw socket timeout except write time out throw ioexcept io except occur underli socket logic int write ( byte buffer buf , nio channel socket , selector selector , long write timeout ) throw ioexcept { select kei kei = null ; int written = 0 ; boolean timedout = fals ; assum we can write int keycount = 1 ; start timeout timer long time = system . current time milli ( ) ; try { while ( ( timedout ) buf . ha remain ( ) ) { ( keycount 0 ) { onli write we were regist write write data int cnt = socket . write ( buf ) ; ( cnt = = 1 ) throw new eofexcept ( ) ; written = cnt ; ( cnt 0 ) { reset our timeout timer time = system . current time milli ( ) ; we successfulli wrote , try again without selector continu ; } } ( selector = null ) { regist op write selector ( kei = = null ) kei = socket . get iochannel ( ) . regist ( selector , select kei . op write ) ; els kei . interest op ( select kei . op write ) ; keycount = selector . select ( write timeout ) ; } ( write timeout 0 ( selector = = null keycount = = 0 ) ) timedout = ( system . current time milli ( ) time ) = write timeout ; } while ( timedout ) throw new socket timeout except ( ) ; } final { ( kei = null ) { kei . cancel ( ) ; remov kei from thi selector ( selector = null ) selector . select now ( ) ; } } return written ; }
public void set content length ( int length ) { }	public void write gzip ( byte b , int off , int len ) throw ioexcept { ( debug 1 ) { system . out . println ( write gzip , len = len ) ; } ( debug 2 ) { system . out . print ( write gzip ( ) ; system . out . write ( b , off , len ) ; system . out . println ( ) ) ; } ( gzipstream = = null ) { ( debug 1 ) { system . out . println ( new gzipoutput stream ) ; } respons . add header ( content encod , gzip ) ; gzipstream = new gzipoutput stream ( output ) ; } gzipstream . write ( b , off , len ) ; }
public boolean get displai sourc fragment ( ) { return displai sourc fragment ; }
protect regist specifi princip associ specifi valu singl sign identifi . param sso id singl sign identifi regist param princip associ user princip identifi param auth type authent type us authent thi user princip param usernam usernam us authent thi user param password password us authent thi user void regist ( string sso id , princip princip , string auth type , string usernam , string password ) { ( contain log . debug enabl ( ) ) contain log . debug ( regist sso id sso id user ( princip = null princip . get name ( ) : ) auth type auth type ) ; synchron ( cach ) { cach . put ( sso id , new singl sign entri ( princip , auth type , usernam , password ) ) ; } }	public get usernam provid user part authent process . string get usernam ( ) { return ( thi . usernam ) ; }	public authent user check exist certif chain , option ask trust manag valid we trust thi user . param request request we ar process param respons respons we ar creat param config login configur describ how authent should perform except ioexcept input output error occur boolean authent ( request request , respons respons , login config config ) throw ioexcept { have we alreadi authent someon princip princip = request . get user princip ( ) ; string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( princip = null ) { ( contain log . debug enabl ( ) ) contain log . debug ( alreadi authent princip . get name ( ) ) ; associ session ani exist sso session order get coordin session invalid logout string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( sso id = null ) associ ( sso id , request . get session intern ( true ) ) ; return ( true ) ; } retriev certif chain thi client ( contain log . debug enabl ( ) ) contain log . debug ( look up certif ) ; x509certif cert = ( x509certif ) request . get attribut ( global . certif attr ) ; ( ( cert = = null ) ( cert . length 1 ) ) { request . get coyot request ( ) . action ( action code . action req ssl certif , null ) ; cert = ( x509certif ) request . get attribut ( global . certif attr ) ; } ( ( cert = = null ) ( cert . length 1 ) ) { ( contain log . debug enabl ( ) ) contain log . debug ( certif includ thi request ) ; respons . send error ( http servlet respons . sc bad request , sm . get string ( authent . certif ) ) ; return ( fals ) ; } authent specifi certif chain princip = context . get realm ( ) . authent ( cert ) ; ( princip = = null ) { ( contain log . debug enabl ( ) ) contain log . debug ( realm . authent ( ) return fals ) ; respons . send error ( http servlet respons . sc unauthor , sm . get string ( authent . unauthor ) ) ; return ( fals ) ; } cach princip ( request ) record thi authent regist ( request , respons , princip , constant . cert method , null , null ) ; return ( true ) ; }	public synchron session find session ( ) { return ( thi . session ) ; }
protect regist authent princip authent type our request , current session ( ) , our singl sign valv , . set appropri cooki return . param request servlet request we ar process param respons servlet respons we ar gener param princip authent princip regist param auth type authent type regist param usernam usernam us authent ( ani ) param password password us authent ( ani ) void regist ( request request , respons respons , princip princip , string auth type , string usernam , string password ) { ( log . debug enabl ( ) ) log . debug ( authent princip . get name ( ) type auth type ) ; cach authent inform our request request . set auth type ( auth type ) ; request . set user princip ( princip ) ; session session = request . get session intern ( fals ) ; cach authent inform our session , ani ( cach ) { ( session = null ) { session . set auth type ( auth type ) ; session . set princip ( princip ) ; ( usernam = null ) session . set note ( constant . sess usernam note , usernam ) ; els session . remov note ( constant . sess usernam note ) ; ( password = null ) session . set note ( constant . sess password note , password ) ; els session . remov note ( constant . sess password note ) ; } } construct cooki return client ( sso = = null ) return ; onli creat new sso entri sso did alreadi set note exist entri ( would do subsequ request digest ssl authent context ) string sso id = ( string ) request . get note ( constant . req ssoid note ) ; ( sso id = = null ) { construct cooki return client sso id = gener session id ( ) ; cooki cooki = new cooki ( constant . singl sign cooki , sso id ) ; cooki . set max ag ( 1 ) ; cooki . set path ( ) ; bugzilla 34724 string sso domain = sso . get cooki domain ( ) ; ( sso domain = null ) { cooki . set domain ( sso domain ) ; } respons . add cooki ( cooki ) ; regist thi princip our sso valv sso . regist ( sso id , princip , auth type , usernam , password ) ; request . set note ( constant . req ssoid note , sso id ) ; } els { updat sso session latest authent data sso . updat ( sso id , princip , auth type , usernam , password ) ; } sso entri never clear we don t associ session ( session = = null ) session = request . get session intern ( true ) ; sso . associ ( sso id , session ) ; }
privat privat method void servic jsp file ( http servlet request request , http servlet respons respons , string jsp uri , throwabl except , boolean precompil ) throw servlet except , ioexcept { jsp servlet wrapper wrapper = ( jsp servlet wrapper ) rctxt . get wrapper ( jsp uri ) ; ( wrapper = = null ) { synchron ( thi ) { wrapper = ( jsp servlet wrapper ) rctxt . get wrapper ( jsp uri ) ; ( wrapper = = null ) { creat unnecessari directori file . ( null = = context . get resourc ( jsp uri ) ) { respons . send error ( http servlet respons . sc found , jsp uri ) ; return ; } boolean error page = except = null ; wrapper = new jsp servlet wrapper ( config , option , jsp uri , error page , rctxt ) ; rctxt . add wrapper ( jsp uri , wrapper ) ; } } } wrapper . servic ( request , respons , precompil ) ; }
public void lifecycl event ( lifecycl event event ) { ( lifecycl . init event . equal ( event . get type ( ) ) ) { try { set jsp factori thi . get class ( ) . get class loader ( ) . load class ( org . apach . jasper . compil . jsp runtim context ) ; } catch ( throwabl t ) { should occur , obvious log . warn ( couldn t initi jasper , t ) ; } anoth possibl do directli : jsp factori . set default factori ( new jsp factori impl ( ) ) ; } }

privat configur from code log manag code properti . void configur ( ) { timestamp ts = new timestamp ( system . current time milli ( ) ) ; string ts string = ts . string ( ) . substr ( 0 , 19 ) ; date = ts string . substr ( 0 , 10 ) ; log manag manag = log manag . get log manag ( ) ; string class name = file handler . class . get name ( ) ; class loader cl = thread . current thread ( ) . get context class loader ( ) ; retriev configur log file name directori = get properti ( class name . directori , log ) ; prefix = get properti ( class name . prefix , juli . ) ; suffix = get properti ( class name . suffix , . log ) ; get log level handler set level ( level . pars ( get properti ( class name . level , level . all ) ) ) ; get filter configur string filter name = get properti ( class name . filter , null ) ; ( filter name = null ) { try { set filter ( ( filter ) cl . load class ( filter name ) . new instanc ( ) ) ; } catch ( except e ) { ignor } } set formatt string formatt name = get properti ( class name . formatt , null ) ; ( formatt name = null ) { try { set formatt ( ( formatt ) cl . load class ( formatt name ) . new instanc ( ) ) ; } catch ( except e ) { ignor } } els { set formatt ( new simpl formatt ( ) ) ; } set error manag set error manag ( new error manag ( ) ) ; }
privat void compar tag encod ( string page dir enc , node . tag direct page dir ) throw jasper except { node . root root = page dir . get root ( ) ; compar page encod attribut page direct encod specifi xml prolog ( onli xml syntax , onli jsp document contain xml prolog encod declar ) . treat utf 16 , utf 16be , utf 16le ident . ( ( root . xml syntax ( ) root . encod specifi prolog ( ) ) root . bom present ( ) ) { string page enc = root . get page encod ( ) ; ( page dir enc . equal ( page enc ) ( page dir enc . start ( utf 16 ) page enc . start ( utf 16 ) ) ) { err . jsp error ( page dir , jsp . error . prolog pagedir encod mismatch , page enc , page dir enc ) ; } } }
public static string string ( byte chunk bc ) { still train ( bc cach = = null ) { string valu = bc . string intern ( ) ; ( byte enabl ) { train , everyth sync synchron ( bc stat ) { we just calcul ( bc cach = null ) { return valu ; } string ( bc count train threshold ) { long t1 = system . current time milli ( ) ; sort entri accord occurr tree map temp map = new tree map ( ) ; iter entri = bc stat . kei set ( ) . iter ( ) ; while ( entri . ha next ( ) ) { byte entri entri = ( byte entri ) entri . next ( ) ; int count = ( int ) bc stat . get ( entri ) ; integ count = new integ ( count 0 ) ; add list count arrai list list = ( arrai list ) temp map . get ( count ) ; ( list = = null ) { creat list list = new arrai list ( ) ; temp map . put ( count , list ) ; } list . add ( entri ) ; } alloc arrai right size int size = bc stat . size ( ) ; ( size cach size ) { size = cach size ; } byte entri tempbc cach = new byte entri size ; fill up us alphabet order dumb insert sort byte chunk temp chunk = new byte chunk ( ) ; int n = 0 ; while ( n size ) { object kei = temp map . last kei ( ) ; arrai list list = ( arrai list ) temp map . get ( kei ) ; byte entri list2 = ( byte entri ) list . arrai ( new byte entri list . size ( ) ) ; ( int i = 0 ; i list . size ( ) n size ; i ) { byte entri entri = ( byte entri ) list . get ( i ) ; temp chunk . set byte ( entri . name , 0 , entri . name . length ) ; int insert po = find closest ( temp chunk , tempbc cach , n ) ; ( insert po = = n ) { tempbc cach n 1 = entri ; } els { system . arraycopi ( tempbc cach , insert po 1 , tempbc cach , insert po 2 , n insert po 1 ) ; tempbc cach insert po 1 = entri ; } n ; } temp map . remov ( kei ) ; } bc count = 0 ; bc stat . clear ( ) ; bc cach = tempbc cach ; ( log . debug enabl ( ) ) { long t2 = system . current time milli ( ) ; log . debug ( byte cach gener time : ( t2 t1 ) ms ) ; } } els { bc count ; alloc new byte entri lookup byte entri entri = new byte entri ( ) ; entri . valu = valu ; int count = ( int ) bc stat . get ( entri ) ; ( count = = null ) { int end = bc . get end ( ) ; int start = bc . get start ( ) ; creat byte arrai copi byte entri . name = new byte bc . get length ( ) ; system . arraycopi ( bc . get buffer ( ) , start , entri . name , 0 , end start ) ; set encod entri . enc = bc . get encod ( ) ; initi occurr count count = new int 1 ; count 0 = 1 ; set stat hash map bc stat . put ( entri , count ) ; } els { count 0 = count 0 1 ; } } } } return valu ; } els { access count ; find correspond string string result = find ( bc ) ; ( result = = null ) { return bc . string intern ( ) ; } note : we don t care about safeti stat hit count ; return result ; } }	public static string string ( char chunk cc ) { still train ( cc cach = = null ) { string valu = cc . string intern ( ) ; ( char enabl ) { train , everyth sync synchron ( cc stat ) { we just calcul ( cc cach = null ) { return valu ; } string ( cc count train threshold ) { long t1 = system . current time milli ( ) ; sort entri accord occurr tree map temp map = new tree map ( ) ; iter entri = cc stat . kei set ( ) . iter ( ) ; while ( entri . ha next ( ) ) { char entri entri = ( char entri ) entri . next ( ) ; int count = ( int ) cc stat . get ( entri ) ; integ count = new integ ( count 0 ) ; add list count arrai list list = ( arrai list ) temp map . get ( count ) ; ( list = = null ) { creat list list = new arrai list ( ) ; temp map . put ( count , list ) ; } list . add ( entri ) ; } alloc arrai right size int size = cc stat . size ( ) ; ( size cach size ) { size = cach size ; } char entri tempcc cach = new char entri size ; fill up us alphabet order dumb insert sort char chunk temp chunk = new char chunk ( ) ; int n = 0 ; while ( n size ) { object kei = temp map . last kei ( ) ; arrai list list = ( arrai list ) temp map . get ( kei ) ; char entri list2 = ( char entri ) list . arrai ( new char entri list . size ( ) ) ; ( int i = 0 ; i list . size ( ) n size ; i ) { char entri entri = ( char entri ) list . get ( i ) ; temp chunk . set char ( entri . name , 0 , entri . name . length ) ; int insert po = find closest ( temp chunk , tempcc cach , n ) ; ( insert po = = n ) { tempcc cach n 1 = entri ; } els { system . arraycopi ( tempcc cach , insert po 1 , tempcc cach , insert po 2 , n insert po 1 ) ; tempcc cach insert po 1 = entri ; } n ; } temp map . remov ( kei ) ; } cc count = 0 ; cc stat . clear ( ) ; cc cach = tempcc cach ; ( log . debug enabl ( ) ) { long t2 = system . current time milli ( ) ; log . debug ( char cach gener time : ( t2 t1 ) ms ) ; } } els { cc count ; alloc new char entri lookup char entri entri = new char entri ( ) ; entri . valu = valu ; int count = ( int ) cc stat . get ( entri ) ; ( count = = null ) { int end = cc . get end ( ) ; int start = cc . get start ( ) ; creat char arrai copi char entri . name = new char cc . get length ( ) ; system . arraycopi ( cc . get buffer ( ) , start , entri . name , 0 , end start ) ; initi occurr count count = new int 1 ; count 0 = 1 ; set stat hash map cc stat . put ( entri , count ) ; } els { count 0 = count 0 1 ; } } } } return valu ; } els { access count ; find correspond string string result = find ( cc ) ; ( result = = null ) { return cc . string intern ( ) ; } note : we don t care about safeti stat hit count ; return result ; } }
protect string find cgi ( string path info , string web app root dir , string context path , string servlet path , string cgi path prefix ) { string path = null ; string name = null ; string scriptnam = null ; string cginam = null ; ( ( web app root dir = null ) ( web app root dir . last index ( file . separ ) = = ( web app root dir . length ( ) 1 ) ) ) { strip trail from web app root dir web app root dir = web app root dir . substr ( 0 , ( web app root dir . length ( ) 1 ) ) ; } ( cgi path prefix = null ) { web app root dir = web app root dir file . separ cgi path prefix ; } ( debug = 2 ) { log ( find cgi : path = path info , web app root dir ) ; } file current locat = new file ( web app root dir ) ; string token dir walker = new string token ( path info , ) ; ( debug = 3 ) { log ( find cgi : current loc = current locat ) ; } while ( current locat . file ( ) dir walker . ha more element ( ) ) { ( debug = 3 ) { log ( find cgi : current loc = current locat ) ; } current locat = new file ( current locat , ( string ) dir walker . next element ( ) ) ; } ( current locat . file ( ) ) { return new string { null , null , null , null } ; } els { ( debug = 2 ) { log ( find cgi : found cgi current locat ) ; } path = current locat . get absolut path ( ) ; name = current locat . get name ( ) ; cginam = ( current locat . get parent ( ) file . separ ) . substr ( web app root dir . length ( ) ) name ; ( . . equal ( context path ) ) { scriptnam = servlet path cginam ; } els { scriptnam = context path servlet path cginam ; } } ( debug = 1 ) { log ( find cgi calc : name = name , path = path , scriptnam = scriptnam , cginam = cginam ) ; } return new string { path , scriptnam , cginam , name } ; }
protect return input stream html represent content thi directori . param context path context path which our intern path ar rel input stream render html ( string context path , cach entri cach entri ) throw ioexcept , servlet except { string name = cach entri . name ; number charact trim from begin filenam int trim = name . length ( ) ; ( name . end ( ) ) trim = 1 ; ( name . equal ( ) ) trim = 1 ; prepar writer buffer area byte arrai output stream stream = new byte arrai output stream ( ) ; output stream writer os writer = new output stream writer ( stream , utf8 ) ; print writer writer = new print writer ( os writer ) ; string buffer sb = new string buffer ( ) ; rewrit url ( context path ) expens . cach result later reus string rewritten context path = rewrit url ( context path ) ; render page header sb . append ( html r n ) ; sb . append ( head r n ) ; sb . append ( titl ) ; sb . append ( sm . get string ( directori . titl , name ) ) ; sb . append ( titl r n ) ; sb . append ( style ) ; sb . append ( org . apach . catalina . util . tomcat css . tomcat css ) ; sb . append ( style ) ; sb . append ( head r n ) ; sb . append ( bodi ) ; sb . append ( h1 ) ; sb . append ( sm . get string ( directori . titl , name ) ) ; render link our parent ( requir ) string parent directori = name ; ( parent directori . end ( ) ) { parent directori = parent directori . substr ( 0 , parent directori . length ( ) 1 ) ; } int slash = parent directori . last index ( ) ; ( slash = 0 ) { string parent = name . substr ( 0 , slash ) ; sb . append ( href = ) ; sb . append ( rewritten context path ) ; ( parent . equal ( ) ) parent = ; sb . append ( rewrit url ( parent ) ) ; ( parent . end ( ) ) sb . append ( ) ; sb . append ( ) ; sb . append ( b ) ; sb . append ( sm . get string ( directori . parent , parent ) ) ; sb . append ( b ) ; sb . append ( ) ; } sb . append ( h1 ) ; sb . append ( hr size = 1 noshad = noshad ) ; sb . append ( tabl width = 100 cellspac = 0 cellpad = 5 align = center r n ) ; render column head sb . append ( tr r n ) ; sb . append ( td align = left font size = 1 strong ) ; sb . append ( sm . get string ( directori . filenam ) ) ; sb . append ( strong font td r n ) ; sb . append ( td align = center font size = 1 strong ) ; sb . append ( sm . get string ( directori . size ) ) ; sb . append ( strong font td r n ) ; sb . append ( td align = right font size = 1 strong ) ; sb . append ( sm . get string ( directori . last modifi ) ) ; sb . append ( strong font td r n ) ; sb . append ( tr ) ; try { render directori entri within thi directori name enumer enumer = resourc . list ( cach entri . name ) ; boolean shade = fals ; while ( enumer . ha more element ( ) ) { name class pair nc pair = ( name class pair ) enumer . next element ( ) ; string resourc name = nc pair . get name ( ) ; string trim = resourc name ; ( trim . equal ignor case ( web inf ) trim . equal ignor case ( meta inf ) ) continu ; cach entri child cach entri = resourc . lookup cach ( cach entri . name resourc name ) ; ( child cach entri . exist ) { continu ; } sb . append ( tr ) ; ( shade ) sb . append ( bgcolor = eeeeee ) ; sb . append ( r n ) ; shade = shade ; sb . append ( td align = left nbsp ; nbsp ; r n ) ; sb . append ( href = ) ; sb . append ( rewritten context path ) ; resourc name = rewrit url ( name resourc name ) ; sb . append ( resourc name ) ; ( child cach entri . context = null ) sb . append ( ) ; sb . append ( tt ) ; sb . append ( trim ) ; ( child cach entri . context = null ) sb . append ( ) ; sb . append ( tt td r n ) ; sb . append ( td align = right tt ) ; ( child cach entri . context = null ) sb . append ( nbsp ; ) ; els sb . append ( render size ( child cach entri . attribut . get content length ( ) ) ) ; sb . append ( tt td r n ) ; sb . append ( td align = right tt ) ; sb . append ( child cach entri . attribut . get last modifi http ( ) ) ; sb . append ( tt td r n ) ; sb . append ( tr r n ) ; } } catch ( name except e ) { someth went wrong throw new servlet except ( error access resourc , e ) ; } render page footer sb . append ( tabl r n ) ; sb . append ( hr size = 1 noshad = noshad ) ; string readm = get readm ( cach entri . context ) ; ( readm = null ) { sb . append ( readm ) ; sb . append ( hr size = 1 noshad = noshad ) ; } sb . append ( h3 ) . append ( server info . get server info ( ) ) . append ( h3 ) ; sb . append ( bodi r n ) ; sb . append ( html r n ) ; return input stream underli byte writer . write ( sb . string ( ) ) ; writer . flush ( ) ; return ( new byte arrai input stream ( stream . byte arrai ( ) ) ) ; }	protect return input stream html represent content thi directori . param context path context path which our intern path ar rel input stream render xml ( string context path , cach entri cach entri , input stream xslt input stream ) throw ioexcept , servlet except { string buffer sb = new string buffer ( ) ; sb . append ( xml version = 1 . 0 ) ; sb . append ( list ) ; sb . append ( context path = ) ; sb . append ( context path ) ; sb . append ( ) ; sb . append ( directori = ) ; sb . append ( cach entri . name ) ; sb . append ( ) ; sb . append ( ha parent = ) . append ( cach entri . name . equal ( ) ) ; sb . append ( ) ; sb . append ( entri ) ; try { render directori entri within thi directori name enumer enumer = resourc . list ( cach entri . name ) ; rewrit url ( context path ) expens . cach result later reus string rewritten context path = rewrit url ( context path ) ; while ( enumer . ha more element ( ) ) { name class pair nc pair = ( name class pair ) enumer . next element ( ) ; string resourc name = nc pair . get name ( ) ; string trim = resourc name ; ( trim . equal ignor case ( web inf ) trim . equal ignor case ( meta inf ) trim . equal ignor case ( local xslt file ) ) continu ; cach entri child cach entri = resourc . lookup cach ( cach entri . name resourc name ) ; ( child cach entri . exist ) { continu ; } sb . append ( entri ) ; sb . append ( type = ) . append ( ( child cach entri . context = null ) dir : file ) . append ( ) ; sb . append ( url path = ) . append ( rewritten context path ) . append ( rewrit url ( cach entri . name resourc name ) ) . append ( ( child cach entri . context = null ) : ) . append ( ) ; ( child cach entri . resourc = null ) { sb . append ( size = ) . append ( render size ( child cach entri . attribut . get content length ( ) ) ) . append ( ) ; } sb . append ( date = ) . append ( child cach entri . attribut . get last modifi http ( ) ) . append ( ) ; sb . append ( ) ; sb . append ( trim ) ; ( child cach entri . context = null ) sb . append ( ) ; sb . append ( entri ) ; } } catch ( name except e ) { someth went wrong throw new servlet except ( error access resourc , e ) ; } sb . append ( entri ) ; string readm = get readm ( cach entri . context ) ; ( readm = null ) { sb . append ( readm cdata ) ; sb . append ( readm ) ; sb . append ( readm ) ; } sb . append ( list ) ; try { transform factori t factori = transform factori . new instanc ( ) ; sourc xml sourc = new stream sourc ( new string reader ( sb . string ( ) ) ) ; sourc xsl sourc = new stream sourc ( xslt input stream ) ; transform transform = t factori . new transform ( xsl sourc ) ; byte arrai output stream stream = new byte arrai output stream ( ) ; output stream writer os writer = new output stream writer ( stream , utf8 ) ; stream result out = new stream result ( os writer ) ; transform . transform ( xml sourc , out ) ; os writer . flush ( ) ; return ( new byte arrai input stream ( stream . byte arrai ( ) ) ) ; } catch ( transform except e ) { throw new servlet except ( xsl transform error , e ) ; } }

protect pars request paramet . void pars paramet ( ) { paramet pars = true ; paramet paramet = coyot request . get paramet ( ) ; get charact encod ( ) mai have been overridden search hidden form field contain request encod string enc = get charact encod ( ) ; boolean us bodi encod uri = connector . get us bodi encod uri ( ) ; ( enc = null ) { paramet . set encod ( enc ) ; ( us bodi encod uri ) { paramet . set queri string encod ( enc ) ; } } els { paramet . set encod ( org . apach . coyot . constant . default charact encod ) ; ( us bodi encod uri ) { paramet . set queri string encod ( org . apach . coyot . constant . default charact encod ) ; } } paramet . handl queri paramet ( ) ; ( us input stream us reader ) return ; ( get method ( ) . equal ignor case ( post ) ) return ; string content type = get content type ( ) ; ( content type = = null ) content type = ; int semicolon = content type . index ( ; ) ; ( semicolon = 0 ) { content type = content type . substr ( 0 , semicolon ) . trim ( ) ; } els { content type = content type . trim ( ) ; } ( ( applic x www form urlencod . equal ( content type ) ) ) return ; int len = get content length ( ) ; ( len 0 ) { int max post size = connector . get max post size ( ) ; ( ( max post size 0 ) ( len max post size ) ) { context . get logger ( ) . info ( sm . get string ( coyot request . post too larg ) ) ; throw new illeg state except ( post too larg ) ; } try { byte form data = null ; ( len cach post len ) { ( post data = = null ) post data = new byte cach post len ; form data = post data ; } els { form data = new byte len ; } int actual len = read post bodi ( form data , len ) ; ( actual len = = len ) { paramet . process paramet ( form data , 0 , len ) ; } } catch ( throwabl t ) { ignor ; } } }	public void process paramet ( byte byte , int start , int len , string enc ) { int end = start len ; int po = start ; ( debug 0 ) log ( byte : new string ( byte , start , len ) ) ; do { boolean eq = fals ; int val start = 1 ; int val end = 1 ; int name start = po ; int name end = byte chunk . index ( byte , name start , end , = ) ; workaround b c encod int name end2 = byte chunk . index ( byte , name start , end , ) ; ( ( name end2 = 1 ) ( name end = = 1 name end name end2 ) ) { name end = name end2 ; eq = true ; val start = name end ; val end = name end ; ( debug 0 ) log ( equal name start name end new string ( byte , name start , name end name start ) ) ; } ( name end = = 1 ) name end = end ; ( eq ) { val start = ( name end end ) name end 1 : end ; val end = byte chunk . index ( byte , val start , end , ) ; ( val end = = 1 ) val end = ( val start end ) end : val start ; } po = val end 1 ; ( name end = name start ) { continu ; invalid chunk s better ignor xxx log } tmp name . set byte ( byte , name start , name end name start ) ; tmp valu . set byte ( byte , val start , val end val start ) ; try { add param ( url decod ( tmp name , enc ) , url decod ( tmp valu , enc ) ) ; } catch ( ioexcept e ) { except dure charact decod : skip paramet } tmp name . recycl ( ) ; tmp valu . recycl ( ) ; } while ( po end ) ; }
system properti replac given string . param str origin string return modifi string string replac ( string str ) { string result = str . trim ( ) ; ( result . start ( { ) ) { int po = result . index ( } ) ; ( po = 1 ) { string prop name = result . substr ( 2 , po ) ; string replac = system . get properti ( prop name ) ; ( replac = null ) { result = replac result . substr ( po 1 ) ; } } } return result ; }
protect return short name thi realm implement . string get name ( ) { return ( name ) ; }	protect releas our us thi connect so can recycl . param db connect connect releas void releas ( connect db connect ) { op sinc we ar pool anyth ; }
privat make sure given custom action doe have ani invalid attribut . custom action declar attribut alwai belong same namespac , which identifi prefix name custom tag invoc . exampl , thi invoc : my : test = 1 b = 2 c = 3 , action test attribut , b , c all belong namespac identifi prefix my . abov invoc would equival : my : test my : = 1 my : b = 2 my : c = 3 action attribut mai have prefix differ from action invoc onli underli tag handler support dynam attribut , which case attribut differ prefix consid dynam attribut . void check xml attribut ( node . custom tag n , node . jsp attribut jsp attr , hashtabl string , object tag data attr ) throw jasper except { tag info tag info = n . get tag info ( ) ; ( tag info = = null ) { err . jsp error ( n , jsp . error . miss . tag info , n . get qname ( ) ) ; } tag attribut info tld attr = tag info . get attribut ( ) ; attribut attr = n . get attribut ( ) ; ( int i = 0 ; attr = null i attr . get length ( ) ; i ) { boolean found = fals ; ( int j = 0 ; tld attr = null j tld attr . length ; j ) { ( attr . get local name ( i ) . equal ( tld attr j . get name ( ) ) ( attr . get uri ( i ) = = null attr . get uri ( i ) . length ( ) = = 0 attr . get uri ( i ) . equal ( n . get uri ( ) ) ) ) { boolean check defer = tag info . get tag librari ( ) . get requir version ( ) . equal ( 2 . 0 ) ; boolean defer = fals ; boolean defer valu liter = fals ; boolean express = express ( n , attr . get valu ( i ) , check defer ) ; ( check defer attr . get valu ( i ) . index ( { ) = 1 ) { defer = true ; ( page info . elignor ( ) ) { defer valu liter = true ; } } ( tld attr j . can request time ( ) tld attr j . defer method ( ) tld attr j . defer valu ( ) ) { jsp 2 . 1 ( express ) { ( defer valu liter page info . defer syntax allow liter ( ) ) { err . jsp error ( n , jsp . error . attribut . custom . non rt expr , tld attr j . get name ( ) ) ; } string expect type = null ; ( tld attr j . defer method ( ) ) { string litter must castabl what declar type attribut string m = tld attr j . get method signatur ( ) ; ( m = null ) { int rti = m . trim ( ) . index ( ) ; ( rti 0 ) { expect type = m . substr ( 0 , rti ) . trim ( ) ; } } els { expect type = java . lang . object ; } } ( tld attr j . defer valu ( ) ) { string litter must castabl what declar type attribut expect type = tld attr j . get expect type name ( ) ; } ( expect type = null ) { class expect class = string . class ; try { expect class = jsp util . class ( expect type , loader ) ; } catch ( class found except e ) { err . jsp error ( n , jsp . error . unknown attribut type , tld attr j . get name ( ) , expect type ) ; } check cast try { elsupport . coerc type ( attr . get valu ( i ) , expect class ) ; } catch ( except e ) { err . jsp error ( n , jsp . error . coerc type , tld attr j . get name ( ) , expect type , attr . get valu ( i ) ) ; } } jsp attr i = new node . jsp attribut ( tld attr j , attr . get qname ( i ) , attr . get uri ( i ) , attr . get local name ( i ) , attr . get valu ( i ) , fals , null , fals ) ; } els { ( defer tld attr j . defer method ( ) tld attr j . defer valu ( ) ) { defer express allow thi attribut err . jsp error ( n , jsp . error . attribut . custom . non rt expr , tld attr j . get name ( ) ) ; } ( defer ( tld attr j . defer method ( ) tld attr j . defer valu ( ) ) ) { onli defer express ar allow thi attribut err . jsp error ( n , jsp . error . attribut . custom . non rt expr , tld attr j . get name ( ) ) ; } class expect type = string . class ; try { string type str = tld attr j . get type name ( ) ; ( tld attr j . fragment ( ) ) { expect type = jsp fragment . class ; } els ( type str = null ) { expect type = jsp util . class ( type str , loader ) ; } jsp attr i = get jsp attribut ( tld attr j , attr . get qname ( i ) , attr . get uri ( i ) , attr . get local name ( i ) , attr . get valu ( i ) , expect type , n , fals ) ; } catch ( class found except e ) { err . jsp error ( n , jsp . error . unknown attribut type , tld attr j . get name ( ) , tld attr j . get type name ( ) ) ; } } } els { make sure valu doe contain ani . ( express ) { err . jsp error ( n , jsp . error . attribut . custom . non rt expr , tld attr j . get name ( ) ) ; } jsp attr i = new node . jsp attribut ( tld attr j , attr . get qname ( i ) , attr . get uri ( i ) , attr . get local name ( i ) , attr . get valu ( i ) , fals , null , fals ) ; } ( jsp attr i . express ( ) ) { tag data attr . put ( attr . get qname ( i ) , tag data . request time valu ) ; } els { tag data attr . put ( attr . get qname ( i ) , attr . get valu ( i ) ) ; } found = true ; break ; } } ( found ) { ( tag info . ha dynam attribut ( ) ) { jsp attr i = get jsp attribut ( null , attr . get qname ( i ) , attr . get uri ( i ) , attr . get local name ( i ) , attr . get valu ( i ) , java . lang . object . class , n , true ) ; } els { err . jsp error ( n , jsp . error . bad attribut , attr . get qname ( i ) , n . get local name ( ) ) ; } } } }
privat creat return respons wrapper ha been insert appropri spot respons chain . servlet respons wrap respons ( ) { locat respons we should insert front servlet respons previou = null ; servlet respons current = outer respons ; while ( current = null ) { ( ( current instanceof servlet respons wrapper ) ) break ; ( current instanceof applic http respons ) break ; ( current instanceof applic respons ) break ; ( current instanceof respons ) break ; previou = current ; current = ( ( servlet respons wrapper ) current ) . get respons ( ) ; } instanti new wrapper thi point insert chain servlet respons wrapper = null ; ( ( current instanceof applic http respons ) ( current instanceof respons ) ( current instanceof http servlet respons ) ) wrapper = new applic http respons ( ( http servlet respons ) current , includ ) ; els wrapper = new applic respons ( current , includ ) ; ( previou = = null ) outer respons = wrapper ; els ( ( servlet respons wrapper ) previou ) . set respons ( wrapper ) ; wrap respons = wrapper ; return ( wrapper ) ; }	privat void do forward ( servlet request request , servlet respons respons ) throw servlet except , ioexcept { reset ani output ha been buffer , keep header cooki ( respons . commit ( ) ) { ( log . debug enabl ( ) ) log . debug ( forward commit respons ) ; throw new illeg state except ( sm . get string ( applic dispatch . forward . ) ) ; } try { respons . reset buffer ( ) ; } catch ( illeg state except e ) { ( log . debug enabl ( ) ) log . debug ( forward reset buffer ( ) return : e ) ; throw e ; } set up handl specifi request respons setup ( request , respons , fals ) ; identifi http specif request respons object ( ani ) http servlet request hrequest = null ; ( request instanceof http servlet request ) hrequest = ( http servlet request ) request ; http servlet respons hrespons = null ; ( respons instanceof http servlet respons ) hrespons = ( http servlet respons ) respons ; handl non http forward pass exist request respons ( ( hrequest = = null ) ( hrespons = = null ) ) { ( log . debug enabl ( ) ) log . debug ( non http forward ) ; process request ( hrequest , hrespons ) ; } }	privat void do includ ( servlet request request , servlet respons respons ) throw servlet except , ioexcept { set up handl specifi request respons setup ( request , respons , true ) ; creat wrap respons us thi request servlet respons wrespons = null ; servlet respons wrespons = wrap respons ( ) ; handl non http includ ( ( request instanceof http servlet request ) ( respons instanceof http servlet respons ) ) { ( log . debug enabl ( ) ) log . debug ( non http includ ) ; request . set attribut ( applic filter factori . dispatch type attr , integ . valu ( applic filter factori . includ ) ) ; request . set attribut ( applic filter factori . dispatch request path attr , orig servlet path ) ; invok ( request , outer respons ) ; } }	void intern do filter ( servlet request request , servlet respons respons ) throw ioexcept , servlet except { call next filter ( po n ) { applic filter config filter config = filter po ; filter filter = null ; try { filter = filter config . get filter ( ) ; support . fire instanc event ( instanc event . befor filter event , filter , request , respons ) ; ( system . get secur manag ( ) = null ) { final servlet request req = request ; final servlet respons re = respons ; princip princip = ( ( http servlet request ) req ) . get user princip ( ) ; object arg = new object { req , re , thi } ; secur util . do privileg ( do filter , filter , class type , arg ) ; arg = null ; } els { filter . do filter ( request , respons , thi ) ; } support . fire instanc event ( instanc event . after filter event , filter , request , respons ) ; } catch ( ioexcept e ) { ( filter = null ) support . fire instanc event ( instanc event . after filter event , filter , request , respons , e ) ; throw e ; } catch ( servlet except e ) { ( filter = null ) support . fire instanc event ( instanc event . after filter event , filter , request , respons , e ) ; throw e ; } catch ( runtim except e ) { ( filter = null ) support . fire instanc event ( instanc event . after filter event , filter , request , respons , e ) ; throw e ; } catch ( throwabl e ) { ( filter = null ) support . fire instanc event ( instanc event . after filter event , filter , request , respons , e ) ; throw new servlet except ( sm . get string ( filter chain . filter ) , e ) ; } return ; } we fell off end chain call servlet instanc try { support . fire instanc event ( instanc event . befor servic event , servlet , request , respons ) ; ( ( request instanceof http servlet request ) ( respons instanceof http servlet respons ) ) { ( system . get secur manag ( ) = null ) { final servlet request req = request ; final servlet respons re = respons ; princip princip = ( ( http servlet request ) req ) . get user princip ( ) ; object arg = new object { req , re } ; secur util . do privileg ( servic , servlet , class type us servic , arg , princip ) ; arg = null ; } els { servlet . servic ( ( http servlet request ) request , ( http servlet respons ) respons ) ; } } els { servlet . servic ( request , respons ) ; } support . fire instanc event ( instanc event . after servic event , servlet , request , respons ) ; } catch ( ioexcept e ) { support . fire instanc event ( instanc event . after servic event , servlet , request , respons , e ) ; throw e ; } catch ( servlet except e ) { support . fire instanc event ( instanc event . after servic event , servlet , request , respons , e ) ; throw e ; } catch ( runtim except e ) { support . fire instanc event ( instanc event . after servic event , servlet , request , respons , e ) ; throw e ; } catch ( throwabl e ) { support . fire instanc event ( instanc event . after servic event , servlet , request , respons , e ) ; throw new servlet except ( sm . get string ( filter chain . servlet ) , e ) ; } }
protect construct cgi environ suppli invok cgi script ; reli heavlii servlet api method find cgi param req request associ cgi invok return true environ wa set ok , fals wa problem environ wa set boolean set cgienviron ( http servlet request req ) throw ioexcept { thi method slightli ugli ; c est la vie . you cannot stop ugli , you can onli hope contain ( apolog marv albert regard mj ) hashtabl envp = new hashtabl ( ) ; add shell environ variabl ( ani ) envp . put all ( shell env ) ; add cgi environ variabl string s path info orig = null ; string s path translat orig = null ; string s path info cgi = null ; string s path translat cgi = null ; string s cgiful path = null ; string s cgiscript name = null ; string s cgiful name = null ; string s cginam = null ; string s cginam ; s path info orig = thi . path info ; s path info orig = s path info orig = = null : s path info orig ; s path translat orig = req . get path translat ( ) ; s path translat orig = s path translat orig = = null : s path translat orig ; ( web app root dir = = null ) { app ha been deploi explod form web app root dir = tmp dir . string ( ) ; expand cgiscript ( ) ; } s cginam = find cgi ( s path info orig , web app root dir , context path , servlet path , cgi path prefix ) ; s cgiful path = s cginam 0 ; s cgiscript name = s cginam 1 ; s cgiful name = s cginam 2 ; s cginam = s cginam 3 ; ( s cgiful path = = null s cgiscript name = = null s cgiful name = = null s cginam = = null ) { return fals ; } envp . put ( server softwar , tomcat ) ; envp . put ( server name , null blank ( req . get server name ( ) ) ) ; envp . put ( gatewai interfac , cgi 1 . 1 ) ; envp . put ( server protocol , null blank ( req . get protocol ( ) ) ) ; int port = req . get server port ( ) ; integ i port = ( port = = 0 new integ ( 1 ) : new integ ( port ) ) ; envp . put ( server port , i port . string ( ) ) ; envp . put ( request method , null blank ( req . get method ( ) ) ) ; envp . put ( request uri , null blank ( req . get request uri ( ) ) ) ; path info should determin us s cgiful name : 1 ) let s cgiful name end ( see method find cgi ) 2 ) let s cgiful name equal path info fragment which correspond actual cgi script . 3 ) thu , path info = request . get path info ( ) . substr ( s cgiful name . length ( ) ) ( see method find cgi , where real work done ) ( path info = = null ( path info . substr ( s cgiful name . length ( ) ) . length ( ) = 0 ) ) { s path info cgi = ; } els { s path info cgi = path info . substr ( s cgiful name . length ( ) ) ; } envp . put ( path info , s path info cgi ) ; path translat must determin after path info ( impli real cgi script ) ha been taken account . follow exampl demonstr : servlet info = servlet cgigw dir1 dir2 cgi1 trans1 trans2 cgifullpath = servlet cgigw dir1 dir2 cgi1 path info = trans1 trans2 web app root dir = servlet context . get real path ( ) path translat = servlet context . get real path ( trans1 trans2 ) , path translat = web app root dir s path info cgi ( unless s path info cgi null blank , cgi specif dictat path translat metavari should defin . ( s path info cgi = null ( . equal ( s path info cgi ) ) ) { s path translat cgi = context . get real path ( s path info cgi ) ; } els { s path translat cgi = null ; } ( s path translat cgi = = null . equal ( s path translat cgi ) ) { noop } els { envp . put ( path translat , null blank ( s path translat cgi ) ) ; } envp . put ( script name , null blank ( s cgiscript name ) ) ; envp . put ( queri string , null blank ( req . get queri string ( ) ) ) ; envp . put ( remot host , null blank ( req . get remot host ( ) ) ) ; envp . put ( remot addr , null blank ( req . get remot addr ( ) ) ) ; envp . put ( auth type , null blank ( req . get auth type ( ) ) ) ; envp . put ( remot user , null blank ( req . get remot user ( ) ) ) ; necessari full complianc envp . put ( remot ident , ) ; envp . put ( content type , null blank ( req . get content type ( ) ) ) ; note cgi spec sai content length must null ( ) undefin content , so we cannot put 0 1 per servlet api spec . int content length = req . get content length ( ) ; string s content length = ( content length = 0 : ( new integ ( content length ) ) . string ( ) ) ; envp . put ( content length , s content length ) ; enumer header = req . get header name ( ) ; string header = null ; while ( header . ha more element ( ) ) { header = null ; header = ( ( string ) header . next element ( ) ) . upper case ( ) ; remind : i forgot what previou remind mean ( author . equal ignor case ( header ) proxi author . equal ignor case ( header ) ) { noop per cgi specif section 11 . 2 } els { envp . put ( http header . replac ( , ) , req . get header ( header ) ) ; } } file f cgiful path = new file ( s cgiful path ) ; command = f cgiful path . get canon path ( ) ; kick envp . put ( x tomcat script path , command ) ; thi . env = envp ; return true ; }	protect string find cgi ( string path info , string web app root dir , string context path , string servlet path , string cgi path prefix ) { string path = null ; string name = null ; string scriptnam = null ; string cginam = null ; ( ( web app root dir = null ) ( web app root dir . last index ( file . separ ) = = ( web app root dir . length ( ) 1 ) ) ) { strip trail from web app root dir web app root dir = web app root dir . substr ( 0 , ( web app root dir . length ( ) 1 ) ) ; } ( cgi path prefix = null ) { web app root dir = web app root dir file . separ cgi path prefix ; } ( debug = 2 ) { log ( find cgi : path = path info , web app root dir ) ; } file current locat = new file ( web app root dir ) ; string token dir walker = new string token ( path info , ) ; ( debug = 3 ) { log ( find cgi : current loc = current locat ) ; } while ( current locat . file ( ) dir walker . ha more element ( ) ) { ( debug = 3 ) { log ( find cgi : current loc = current locat ) ; } current locat = new file ( current locat , ( string ) dir walker . next element ( ) ) ; } ( current locat . file ( ) ) { return new string { null , null , null , null } ; } els { ( debug = 2 ) { log ( find cgi : found cgi current locat ) ; } path = current locat . get absolut path ( ) ; name = current locat . get name ( ) ; cginam = current locat . get parent ( ) . substr ( web app root dir . length ( ) ) file . separ name ; ( . . equal ( context path ) ) { scriptnam = servlet path cginam ; } els { scriptnam = context path servlet path cginam ; } } ( debug = 1 ) { log ( find cgi calc : name = name , path = path , scriptnam = scriptnam , cginam = cginam ) ; } return new string { path , scriptnam , cginam , name } ; }
protect find specifi class local repositori . return load class , null class isn t found class find class intern ( string name ) throw class found except { ( valid ( name ) ) throw new class found except ( name ) ; string temp path = name . replac ( . , ) ; string class path = temp path . class ; resourc entri entri = null ; entri = find resourc intern ( name , class path ) ; ( entri = = null ) throw new class found except ( name ) ; class clazz = entri . load class ; ( clazz = null ) return clazz ; synchron ( thi ) { ( entri . binari content = = null entri . load class = = null ) throw new class found except ( name ) ; } look up packag string packag name = null ; int po = name . last index ( . ) ; ( po = 1 ) packag name = name . substr ( 0 , po ) ; packag pkg = null ; ( packag name = null ) { pkg = get packag ( packag name ) ; defin packag ( null ) ( pkg = = null ) { ( entri . manifest = = null ) { defin packag ( packag name , null , null , null , null , null , null , null ) ; } els { defin packag ( packag name , entri . manifest , entri . code base ) ; } } } creat code sourc object code sourc code sourc = new code sourc ( entri . code base , entri . certif ) ; ( secur manag = null ) { check seal ( pkg = null ) { boolean seal check = true ; ( pkg . seal ( ) ) { seal check = pkg . seal ( entri . code base ) ; } els { seal check = ( entri . manifest = = null ) packag seal ( packag name , entri . manifest ) ; } ( seal check ) throw new secur except ( seal violat load name : packag packag name seal . ) ; } } synchron ( thi ) { ( entri . load class = = null ) { clazz = defin class ( name , entri . binari content , 0 , entri . binari content . length , code sourc ) ; entri . load class = clazz ; entri . binari content = null ; entri . sourc = null ; entri . code base = null ; entri . manifest = null ; entri . certif = null ; } els { clazz = entri . load class ; } } return clazz ; }

public read byte . int do read ( byte chunk chunk , org . apach . coyot . request request ) throw ioexcept { int write length = 0 ; ( chunk . get limit ( ) 0 chunk . get limit ( ) input . get length ( ) ) { write length = chunk . get limit ( ) ; } els { write length = input . get length ( ) ; } input . substract ( chunk . get buffer ( ) , 0 , write length ) ; chunk . set offset ( 0 ) ; chunk . set end ( write length ) ; return write length ; }
public remov specifi valv from pipelin associ thi contain , found ; otherwis , do noth . valv found remov , valv s code set contain ( null ) code method call implement code contain code . param valv valv remov void remov valv ( valv valv ) { valv current ; ( first = = valv ) { first = first . get next ( ) ; current = null ; } els { current = first ; } while ( current = null ) { ( current . get next ( ) = = valv ) { current . set next ( valv . get next ( ) ) ; break ; } current = current . get next ( ) ; } ( valv instanceof contain ) ( ( contain ) valv ) . set contain ( null ) ; stop thi valv necessari ( start ) { ( valv instanceof lifecycl ) { try { ( ( lifecycl ) valv ) . stop ( ) ; } catch ( lifecycl except e ) { log . error ( standard pipelin . remov valv : stop : , e ) ; } } unregist remov valav unregist valv ( valv ) ; } }
public add environ entri thi web applic . param environ new environ entri void add environ ( context environ environ ) { ( entri . contain kei ( environ . get name ( ) ) ) { return ; } els { entri . put ( environ . get name ( ) , environ . get type ( ) ) ; } synchron ( env ) { environ . set name resourc ( thi ) ; env . put ( environ . get name ( ) , environ ) ; } support . fire properti chang ( environ , null , environ ) ; }
protect void run ( ) throw ioexcept { remind : thi method feel too big ; should re written ( readi ( ) ) { throw new ioexcept ( thi . get class ( ) . get name ( ) : readi run . ) ; } ( debug = 1 ) { log ( run cgi ( envp = env , command = command ) ) ; } ( ( command . index ( file . separ . file . separ ) = 0 ) ( command . index ( file . separ . . ) = 0 ) ( command . index ( . . file . separ ) = 0 ) ) { throw new ioexcept ( thi . get class ( ) . get name ( ) illeg charact cgi command path ( . . . ) detect . run cgi command . ) ; } origin content structur thi section taken from http : develop . java . sun . com develop bug parad bug 4216884 . html major modif martin dengler runtim rt = null ; input stream cgi output = null ; buffer reader command std err = null ; buffer output stream command std = null ; process proc = null ; int buf read = 1 ; creat queri argument string buffer cmd arg = new string buffer ( ) ; ( command . index ( ) 0 ) { cmd arg . append ( command ) ; } els { space us delimit , so need us quot cmd arg . append ( ) ; cmd arg . append ( command ) ; cmd arg . append ( ) ; } ( int i = 0 ; i param . size ( ) ; i ) { cmd arg . append ( ) ; string param = ( string ) param . get ( i ) ; ( param . index ( ) 0 ) { cmd arg . append ( param ) ; } els { space us delimit , so need us quot cmd arg . append ( ) ; cmd arg . append ( param ) ; cmd arg . append ( ) ; } } string buffer command = new string buffer ( cgi execut ) ; command . append ( ) ; command . append ( cmd arg . string ( ) ) ; cmd arg = command ; try { rt = runtim . get runtim ( ) ; proc = rt . exec ( cmd arg . string ( ) , hash string arrai ( env ) , wd ) ; string s content length = ( string ) env . get ( content length ) ; ( . equal ( s content length ) ) { command std = new buffer output stream ( proc . get output stream ( ) ) ; iotool . flow ( stdin , command std ) ; command std . flush ( ) ; command std . close ( ) ; } we want wait process exit , process . wait ( ) useless our situat ; see http : develop . java . sun . com develop bug parad bug 4223650 . html boolean run = true ; command std err = new buffer reader ( new input stream reader ( proc . get error stream ( ) ) ) ; final buffer reader std err rdr = command std err ; new thread ( ) { public void run ( ) { send log ( std err rdr ) ; } ; } . start ( ) ; input stream cgi header stream = new httpheader input stream ( proc . get input stream ( ) ) ; buffer reader cgi header reader = new buffer reader ( new input stream reader ( cgi header stream ) ) ; while ( run ) { try { set header string line = null ; while ( ( ( line = cgi header reader . read line ( ) ) = null ) ( . equal ( line ) ) ) { ( debug = 2 ) { log ( run cgi : add header ( line ) ) ; } ( line . start ( http ) ) { respons . set statu ( get scfrom http statu line ( line ) ) ; } els ( line . index ( : ) = 0 ) { string header = line . substr ( 0 , line . index ( : ) ) . trim ( ) ; string valu = line . substr ( line . index ( : ) 1 ) . trim ( ) ; ( header . equal ignor case ( statu ) ) { respons . set statu ( get scfrom cgistatu header ( valu ) ) ; } els { respons . add header ( header , valu ) ; } } els { log ( run cgi : bad header line line ) ; } } write output byte b buf = new byte 2048 ; output stream out = respons . get output stream ( ) ; cgi output = proc . get input stream ( ) ; try { while ( ( buf read = cgi output . read ( b buf ) ) = 1 ) { ( debug = 4 ) { log ( run cgi : output buf read byte data ) ; } out . write ( b buf , 0 , buf read ) ; } } final { extern process could hang ( buf read = 1 ) { while ( ( buf read = cgi output . read ( b buf ) ) = 1 ) { } } } throw except aliv proc . exit valu ( ) ; run = fals ; } catch ( illeg thread state except e ) { try { thread . sleep ( 500 ) ; } catch ( interrupt except ignor ) { } } } replac process . wait ( ) close output stream us cgi output . close ( ) ; } catch ( ioexcept e ) { log ( caught except e ) ; throw new ioexcept ( e . string ( ) ) ; } final { ( debug 4 ) { log ( run final block ) ; } ( proc = null ) { proc . destroi ( ) ; proc = null ; } } }
public final select appropri child wrapper process thi request , base specifi request uri . match wrapper can found , return appropri http error . param request request process param respons respons produc param valv context valv context us forward next valv except ioexcept input output error occur except servlet except servlet error occur void event ( request request , respons respons , comet event event ) throw ioexcept , servlet except { select wrapper us thi request wrapper wrapper = request . get wrapper ( ) ; normal request process fixm : thi could addit core api too object instanc = context . get applic event listen ( ) ; servlet request event event = null ; ( ( instanc = null ) ( instanc . length 0 ) ) { event = new servlet request event ( ( ( standard context ) contain ) . get servlet context ( ) , request . get request ( ) ) ; creat pre servic event ( int i = 0 ; i instanc . length ; i ) { ( instanc i = = null ) continu ; ( ( instanc i instanceof servlet request listen ) ) continu ; servlet request listen listen = ( servlet request listen ) instanc i ; try { listen . request initi ( event ) ; } catch ( throwabl t ) { contain . get logger ( ) . error ( sm . get string ( request listen valv . request init , instanc i . get class ( ) . get name ( ) ) , t ) ; servlet request sreq = request . get request ( ) ; sreq . set attribut ( global . except attr , t ) ; return ; } } } wrapper . get pipelin ( ) . get first ( ) . event ( request , respons , event ) ; ( ( instanc = null ) ( instanc . length 0 ) ) { creat post servic event ( int i = 0 ; i instanc . length ; i ) { ( instanc i = = null ) continu ; ( ( instanc i instanceof servlet request listen ) ) continu ; servlet request listen listen = ( servlet request listen ) instanc i ; try { listen . request destroi ( event ) ; } catch ( throwabl t ) { contain . get logger ( ) . error ( sm . get string ( request listen valv . request destroi , instanc i . get class ( ) . get name ( ) ) , t ) ; servlet request sreq = request . get request ( ) ; sreq . set attribut ( global . except attr , t ) ; } } } }	public final select appropri child wrapper process thi request , base specifi request uri . match wrapper can found , return appropri http error . param request request process param respons respons produc param valv context valv context us forward next valv except ioexcept input output error occur except servlet except servlet error occur void invok ( request request , respons respons ) throw ioexcept , servlet except { disallow ani direct access resourc under web inf meta inf messag byte request path mb = request . get request path mb ( ) ; ( ( request path mb . start ignor case ( meta inf , 0 ) ) ( request path mb . equal ignor case ( meta inf ) ) ( request path mb . start ignor case ( web inf , 0 ) ) ( request path mb . equal ignor case ( web inf ) ) ) { string request uri = request . get decod request uri ( ) ; found ( request uri , respons ) ; return ; } wait we ar reload while ( context . get paus ( ) ) { try { thread . sleep ( 1000 ) ; } catch ( interrupt except e ) { ; } } select wrapper us thi request wrapper wrapper = request . get wrapper ( ) ; ( wrapper = = null ) { string request uri = request . get decod request uri ( ) ; found ( request uri , respons ) ; return ; } normal request process object instanc = context . get applic event listen ( ) ; servlet request event event = null ; ( ( instanc = null ) ( instanc . length 0 ) ) { event = new servlet request event ( ( ( standard context ) contain ) . get servlet context ( ) , request . get request ( ) ) ; creat pre servic event ( int i = 0 ; i instanc . length ; i ) { ( instanc i = = null ) continu ; ( ( instanc i instanceof servlet request listen ) ) continu ; servlet request listen listen = ( servlet request listen ) instanc i ; try { listen . request initi ( event ) ; } catch ( throwabl t ) { contain . get logger ( ) . error ( sm . get string ( request listen valv . request init , instanc i . get class ( ) . get name ( ) ) , t ) ; servlet request sreq = request . get request ( ) ; sreq . set attribut ( global . except attr , t ) ; return ; } } } wrapper . get pipelin ( ) . get first ( ) . invok ( request , respons ) ; ( ( instanc = null ) ( instanc . length 0 ) ) { creat post servic event ( int i = 0 ; i instanc . length ; i ) { ( instanc i = = null ) continu ; ( ( instanc i instanceof servlet request listen ) ) continu ; servlet request listen listen = ( servlet request listen ) instanc i ; try { listen . request destroi ( event ) ; } catch ( throwabl t ) { contain . get logger ( ) . error ( sm . get string ( request listen valv . request destroi , instanc i . get class ( ) . get name ( ) ) , t ) ; servlet request sreq = request . get request ( ) ; sreq . set attribut ( global . except attr , t ) ; } } } }
protect return file object repres applic root directori our associ host . file get app base ( ) { ( app base = null ) { return app base ; } file file = new file ( host . get app base ( ) ) ; ( file . absolut ( ) ) file = new file ( system . get properti ( catalina . base ) , host . get app base ( ) ) ; try { app base = file . get canon file ( ) ; } catch ( ioexcept e ) { app base = file ; } return ( app base ) ; }	protect stop web applic specifi context path . see manag servlet stop ( print writer , string ) param path context path applic stop return messag string string stop ( string path ) { string writer string writer = new string writer ( ) ; print writer print writer = new print writer ( string writer ) ; super . stop ( print writer , path ) ; return string writer . string ( ) ; }	protect invok check method deploy . boolean servic ( string name ) throw except { string param = { name } ; string signatur = { java . lang . string } ; boolean result = ( boolean ) m bean server . invok ( onam , servic , param , signatur ) ; return result . boolean valu ( ) ; }	protect invok check method deploy . void add servic ( string name ) throw except { string param = { name } ; string signatur = { java . lang . string } ; m bean server . invok ( onam , add servic , param , signatur ) ; }	protect invok check method deploy . void check ( string name ) throw except { string param = { name } ; string signatur = { java . lang . string } ; m bean server . invok ( onam , check , param , signatur ) ; }	protect deploi war file . void deploi war ( file app base , string file ) { ( file = = null ) return ; boolean check addit deploy = fals ; ( int i = 0 ; i file . length ; i ) { ( file i . equal ignor case ( meta inf ) ) continu ; ( file i . equal ignor case ( web inf ) ) continu ; file dir = new file ( app base , file i ) ; ( file i . lower case ( ) . end ( . war ) ) { calcul context path make sure uniqu string context path = file i ; int period = context path . last index ( . ) ; ( period = 0 ) context path = context path . substr ( 0 , period ) ; ( context path . equal ( root ) ) context path = ; ( servic ( context path ) ) continu ; string file = file i ; deploi war ( context path , dir , file ) ; } } }	protect undeploi web applic specifi context path . param writer writer render param path context path applic remov void undeploi ( print writer writer , string path ) { ( debug = 1 ) log ( undeploi : undeploi web applic path ) ; ( ( path = = null ) ( path . start ( ) path . equal ( ) ) ) { writer . println ( sm . get string ( manag servlet . invalid path , request util . filter ( path ) ) ) ; return ; } string displai path = path ; ( path . equal ( ) ) path = ; try { valid context specifi applic context context = ( context ) host . find child ( path ) ; ( context = = null ) { writer . println ( sm . get string ( manag servlet . context , request util . filter ( displai path ) ) ) ; return ; } identifi app base own host thi context ( ani ) string app base = null ; file app base dir = null ; ( context . get parent ( ) instanceof host ) { app base = ( ( host ) context . get parent ( ) ) . get app base ( ) ; app base dir = new file ( app base ) ; ( app base dir . absolut ( ) ) { app base dir = new file ( system . get properti ( catalina . base ) , app base ) ; } } ( servic ( path ) ) { add servic ( path ) ; try { try stop context first nicer ( ( lifecycl ) context ) . stop ( ) ; } catch ( throwabl t ) { ignor } try { file war = new file ( get app base ( ) , get doc base ( path ) . war ) ; file dir = new file ( get app base ( ) , get doc base ( path ) ) ; file xml = new file ( config base , get config file ( path ) . xml ) ; ( war . exist ( ) ) { war . delet ( ) ; } els ( dir . exist ( ) ) { undeploi dir ( dir ) ; } els { xml . delet ( ) ; } perform new deploy check ( path ) ; } final { remov servic ( path ) ; } } writer . println ( sm . get string ( manag servlet . undeploi , displai path ) ) ; } catch ( throwabl t ) { log ( manag servlet . undeploi displai path , t ) ; writer . println ( sm . get string ( manag servlet . except , t . string ( ) ) ) ; } }	public get instant where applic wa deploi . return 0l applic name deploi , instant which applic wa deploi long get deploy time ( string name ) { deploi applic app = ( deploi applic ) deploi . get ( name ) ; ( app = = null ) { return 0l ; } els { return app . timestamp ; } }	public render html list current activ context our virtual host , memori server statu inform . param request request param respons respons param messag messag displai void list ( http servlet request request , http servlet respons respons , string messag ) throw ioexcept { ( debug = 1 ) log ( list : list context virtual host host . get name ( ) ) ; print writer writer = respons . get writer ( ) ; html header section writer . print ( constant . html header section ) ; bodi header section object arg = new object 2 ; arg 0 = request . get context path ( ) ; arg 1 = sm . get string ( html manag servlet . titl ) ; writer . print ( messag format . format ( constant . bodi header section , arg ) ) ; messag section arg = new object 3 ; arg 0 = sm . get string ( html manag servlet . messag label ) ; arg 1 = ( messag = = null messag . length ( ) = = 0 ) ok : messag ; writer . print ( messag format . format ( constant . messag section , arg ) ) ; manag section arg = new object 9 ; arg 0 = sm . get string ( html manag servlet . manag ) ; arg 1 = respons . encod url ( request . get context path ( ) html list ) ; arg 2 = sm . get string ( html manag servlet . list ) ; arg 3 = respons . encod url ( request . get context path ( ) sm . get string ( html manag servlet . help html manag file ) ) ; arg 4 = sm . get string ( html manag servlet . help html manag ) ; arg 5 = respons . encod url ( request . get context path ( ) sm . get string ( html manag servlet . help manag file ) ) ; arg 6 = sm . get string ( html manag servlet . help manag ) ; arg 7 = respons . encod url ( request . get context path ( ) statu ) ; arg 8 = sm . get string ( statu servlet . titl ) ; writer . print ( messag format . format ( constant . manag section , arg ) ) ; app header section arg = new object 6 ; arg 0 = sm . get string ( html manag servlet . app titl ) ; arg 1 = sm . get string ( html manag servlet . app path ) ; arg 2 = sm . get string ( html manag servlet . app name ) ; arg 3 = sm . get string ( html manag servlet . app avail ) ; arg 4 = sm . get string ( html manag servlet . app session ) ; arg 5 = sm . get string ( html manag servlet . app task ) ; writer . print ( messag format . format ( app header section , arg ) ) ; app row section creat sort map deploi applic context path . contain children = host . find children ( ) ; string context path = new string children . length ; ( int i = 0 ; i children . length ; i ) context path i = children i . get name ( ) ; tree map sort context path map = new tree map ( ) ; ( int i = 0 ; i context path . length ; i ) { string displai path = context path i ; sort context path map . put ( displai path , context path i ) ; } string app start = sm . get string ( html manag servlet . app start ) ; string app stop = sm . get string ( html manag servlet . app stop ) ; string app reload = sm . get string ( html manag servlet . app reload ) ; string app undeploi = sm . get string ( html manag servlet . app undeploi ) ; iter iter = sort context path map . entri set ( ) . iter ( ) ; boolean highlight = true ; string highlight color = null ; while ( iter . ha next ( ) ) { bugzilla 34818 , altern row color highlight = highlight ; ( highlight ) { highlight color = c3f3c3 ; } els { highlight color = ffffff ; } map . entri entri = ( map . entri ) iter . next ( ) ; string displai path = ( string ) entri . get kei ( ) ; string context path = ( string ) entri . get kei ( ) ; context context = ( context ) host . find child ( context path ) ; ( displai path . equal ( ) ) { displai path = ; } ( context = null ) { arg = new object 6 ; arg 0 = displai path ; arg 1 = context . get displai name ( ) ; ( arg 1 = = null ) { arg 1 = nbsp ; ; } arg 2 = new boolean ( context . get avail ( ) ) ; arg 3 = respons . encod url ( request . get context path ( ) html session path = displai path ) ; ( context . get manag ( ) = null ) { arg 4 = new integ ( context . get manag ( ) . get activ session ( ) ) ; } els { arg 4 = new integ ( 0 ) ; } arg 5 = highlight color ; writer . print ( messag format . format ( app row detail section , arg ) ) ; arg = new object 9 ; arg 0 = respons . encod url ( request . get context path ( ) html start path = displai path ) ; arg 1 = app start ; arg 2 = respons . encod url ( request . get context path ( ) html stop path = displai path ) ; arg 3 = app stop ; arg 4 = respons . encod url ( request . get context path ( ) html reload path = displai path ) ; arg 5 = app reload ; arg 6 = respons . encod url ( request . get context path ( ) html undeploi path = displai path ) ; arg 7 = app undeploi ; arg 8 = highlight color ; ( context . get path ( ) . equal ( thi . context . get path ( ) ) ) { writer . print ( messag format . format ( manag app row button section , arg ) ) ; } els ( context . get avail ( ) ) { writer . print ( messag format . format ( start app row button section , arg ) ) ; } els { writer . print ( messag format . format ( stop app row button section , arg ) ) ; } } } deploi section arg = new object 7 ; arg 0 = sm . get string ( html manag servlet . deploi titl ) ; arg 1 = sm . get string ( html manag servlet . deploi server ) ; arg 2 = respons . encod url ( request . get context path ( ) html deploi ) ; arg 3 = sm . get string ( html manag servlet . deploi path ) ; arg 4 = sm . get string ( html manag servlet . deploi config ) ; arg 5 = sm . get string ( html manag servlet . deploi war ) ; arg 6 = sm . get string ( html manag servlet . deploi button ) ; writer . print ( messag format . format ( deploi section , arg ) ) ; arg = new object 4 ; arg 0 = sm . get string ( html manag servlet . deploi upload ) ; arg 1 = respons . encod url ( request . get context path ( ) html upload ) ; arg 2 = sm . get string ( html manag servlet . deploi upload file ) ; arg 3 = sm . get string ( html manag servlet . deploi button ) ; writer . print ( messag format . format ( upload section , arg ) ) ; server header section arg = new object 7 ; arg 0 = sm . get string ( html manag servlet . server titl ) ; arg 1 = sm . get string ( html manag servlet . server version ) ; arg 2 = sm . get string ( html manag servlet . server jvmversion ) ; arg 3 = sm . get string ( html manag servlet . server jvmvendor ) ; arg 4 = sm . get string ( html manag servlet . server osnam ) ; arg 5 = sm . get string ( html manag servlet . server osvers ) ; arg 6 = sm . get string ( html manag servlet . server osarch ) ; writer . print ( messag format . format ( constant . server header section , arg ) ) ; server row section arg = new object 6 ; arg 0 = server info . get server info ( ) ; arg 1 = system . get properti ( java . runtim . version ) ; arg 2 = system . get properti ( java . vm . vendor ) ; arg 3 = system . get properti ( os . name ) ; arg 4 = system . get properti ( os . version ) ; arg 5 = system . get properti ( os . arch ) ; writer . print ( messag format . format ( constant . server row section , arg ) ) ; html tail section writer . print ( constant . html tail section ) ; finish up respons writer . flush ( ) ; writer . close ( ) ; }
privat creat name tag handler pool whose tag handler mai ( re ) us servic thi action . return name tag handler pool string creat tag handler pool name ( string prefix , string short name , attribut attr , boolean ha empti bodi ) { string pool name = null ; pool name = jspx tag pool prefix short name ; ( attr = null ) { string attr name = new string attr . get length ( ) ; ( int i = 0 ; i attr name . length ; i ) { attr name i = attr . get qname ( i ) ; } arrai . sort ( attr name , collect . revers order ( ) ) ; ( int i = 0 ; i attr name . length ; i ) { pool name = pool name attr name i ; } } ( ha empti bodi ) { pool name = pool name nobodi ; } return jsp util . make xml java identifi ( pool name ) ; }	privat creat tag variabl name concaten given prefix short name endcod make result string valid java identifi . string creat tag var name ( string full name , string prefix , string short name ) { string var name ; synchron ( tag var number ) { var name = prefix short name ; ( tag var number . get ( full name ) = null ) { integ i = ( integ ) tag var number . get ( full name ) ; var name = var name i . int valu ( ) ; tag var number . put ( full name , new integ ( i . int valu ( ) 1 ) ) ; } els { tag var number . put ( full name , new integ ( 1 ) ) ; var name = var name 0 ; } } return jsp util . make xml java identifi ( var name ) ; }
privat skip until el express ( { { ) reach , allow escap sequenc . return text string up el express string skip until el ( ) { char prev = 0 ; string buffer buf = new string buffer ( ) ; while ( ha next char ( ) ) { char ch = next char ( ) ; ( prev = = ) { prev = 0 ; ( ch = = ) { buf . append ( ) ; ( escap bs ) prev = ; } els ( ch = = ch = = ) { buf . append ( ch ) ; } els error } els ( prev = = prev = = ) { ( ch = = { ) { thi . type = prev ; prev = 0 ; break ; } buf . append ( prev ) ; } ( ch = = ch = = ch = = ) { prev = ch ; } els { buf . append ( ch ) ; } } ( prev = 0 ) { buf . append ( prev ) ; } return buf . string ( ) ; }
privat void gener setter ( node . custom tag n , string tag handler var , tag handler info handler info , boolean simpl tag ) throw jasper except { set context ( simpl tag ) { gener alia map string alia map var = null ; ( n . tag file ( ) ) { alia map var = gener alia map ( n , tag handler var ) ; } out . printin ( tag handler var ) ; ( alia map var = = null ) { out . println ( . set jsp context ( jspx page context ) ; ) ; } els { out . print ( . set jsp context ( jspx page context , ) ; out . print ( alia map var ) ; out . println ( ) ; ) ; } } els { out . printin ( tag handler var ) ; out . println ( . set page context ( jspx page context ) ; ) ; } set parent ( simpl tag ) { out . printin ( tag handler var ) ; out . print ( . set parent ( ) ; ( parent = null ) { ( simpl tag parent ) { out . print ( new javax . servlet . jsp . tagext . tag adapt ( ) ; out . print ( ( javax . servlet . jsp . tagext . simpl tag ) ) ; out . print ( parent ) ; out . println ( ) ) ; ) ; } els { out . print ( ( javax . servlet . jsp . tagext . tag ) ) ; out . print ( parent ) ; out . println ( ) ; ) ; } } els { out . println ( null ) ; ) ; } } els { pass null , sinc simpl tag instanc ar reus ( parent = null ) { out . printin ( tag handler var ) ; out . print ( . set parent ( ) ; out . print ( parent ) ; out . println ( ) ; ) ; } } need handl defer valu method node . jsp attribut attr = n . get jsp attribut ( ) ; ( int i = 0 ; attr = null i attr . length ; i ) { string attr valu = evalu attribut ( handler info , attr i , n , tag handler var ) ; mark m = n . get start ( ) ; out . printil ( m . get file ( ) ( m . get line number ( ) , m . get column number ( ) ) attr i . get tag attribut info ( ) ) ; ( attr i . dynam ( ) ) { out . printin ( tag handler var ) ; out . print ( . ) ; out . print ( set dynam attribut ( ) ; string uri = attr i . get uri ( ) ; ( . equal ( uri ) ( uri = = null ) ) { out . print ( null ) ; } els { out . print ( attr i . get uri ( ) ) ; } out . print ( , ) ; out . print ( attr i . get local name ( ) ) ; out . print ( , ) ; out . print ( attr valu ) ; out . println ( ) ; ) ; } els { out . printin ( tag handler var ) ; out . print ( . ) ; out . print ( handler info . get setter method ( attr i . get local name ( ) ) . get name ( ) ) ; out . print ( ( ) ; out . print ( attr valu ) ; out . println ( ) ; ) ; } } }
public determin compil necessari check time stamp jsp page correspond . class . java file . page ha depend , check also extend depend , so . thi method can overidden subclass compil . param check class true , check against . class file , fals , check against . java file . boolean out date ( boolean check class ) { string jsp = ctxt . get jsp file ( ) ; ( jsw = null ( ctxt . get option ( ) . get modif test interv ( ) 0 ) ) { ( jsw . get last modif test ( ) ( ctxt . get option ( ) . get modif test interv ( ) 1000 ) system . current time milli ( ) ) { return fals ; } els { jsw . set last modif test ( system . current time milli ( ) ) ; } } long jsp real last modifi = 0 ; try { url jsp url = ctxt . get resourc ( jsp ) ; ( jsp url = = null ) { ctxt . increment remov ( ) ; return fals ; } urlconnect uc = jsp url . open connect ( ) ; jsp real last modifi = uc . get last modifi ( ) ; uc . get input stream ( ) . close ( ) ; } catch ( except e ) { e . print stack trace ( ) ; return true ; } long target last modifi = 0 ; file target file ; ( check class ) { target file = new file ( ctxt . get class file name ( ) ) ; } els { target file = new file ( ctxt . get servlet java file name ( ) ) ; } ( target file . exist ( ) ) { return true ; } target last modifi = target file . last modifi ( ) ; ( check class jsw = null ) { jsw . set servlet class last modifi time ( target last modifi ) ; } ( target last modifi jsp real last modifi ) { ( log . debug enabl ( ) ) { log . debug ( compil : outdat : target file target last modifi ) ; } return true ; } direct ) have been chang . ( jsw = = null ) { return fals ; } list depend = jsw . get depend ( ) ; ( depend = = null ) { return fals ; } iter = depend . iter ( ) ; while ( . ha next ( ) ) { string includ = ( string ) . next ( ) ; try { url includ url = ctxt . get resourc ( includ ) ; ( includ url = = null ) { return true ; } urlconnect includ uconn = includ url . open connect ( ) ; long includ last modifi = includ uconn . get last modifi ( ) ; includ uconn . get input stream ( ) . close ( ) ; ( includ last modifi target last modifi ) { return true ; } } catch ( except e ) { e . print stack trace ( ) ; return true ; } } return fals ; }	public = = = = = = = = = = = = = = = = = = = = compil reload = = = = = = = = = = = = = = = = = = = = void compil ( ) throw jasper except , file found except { creat compil ( ) ; ( packag tag file jsp compil . out date ( ) ) { try { jsp loader = null ; jsp compil . compil ( ) ; jsw . set reload ( true ) ; jsw . set compil except ( null ) ; } catch ( jasper except ex ) { cach compil except jsw . set compil except ( ex ) ; throw ex ; } catch ( except ex ) { ex . print stack trace ( ) ; jasper except je = new jasper except ( local . get messag ( jsp . error . unabl . compil ) , ex ) ; cach compil except jsw . set compil except ( je ) ; throw je ; } } }	public = = = = = = = = = = = = = = = = = = = = remov = = = = = = = = = = = = = = = = = = = = void increment remov ( ) { ( remov 1 ) { jsp compil . remov gener file ( ) ; ( rctxt = null ) rctxt . remov wrapper ( jsp uri ) ; } remov ; }	public void servic ( http servlet request request , http servlet respons respons , boolean precompil ) throw servlet except , ioexcept , file found except { try { ( ctxt . remov ( ) ) { throw new file found except ( jsp uri ) ; } ( ( avail 0l ) ( avail long . max valu ) ) { respons . set date header ( retri after , avail ) ; respons . send error ( http servlet respons . sc servic unavail , local . get messag ( jsp . error . unavail ) ) ; } ( 1 ) compil ( option . get develop ( ) first time ) { synchron ( thi ) { first time = fals ; follow set reload true , necessari ctxt . compil ( ) ; } } els { ( compil except = null ) { throw cach compil except throw compil except ; } } ( 2 ) ( re ) load servlet class file get servlet ( ) ; page precompil onli , return . ( precompil ) { return ; } ( 3 ) servic request ( servlet instanceof singl thread model ) { page determin right befor servic synchron ( thi ) { servlet . servic ( request , respons ) ; } } els { servlet . servic ( request , respons ) ; } } catch ( unavail except ex ) { string includ request uri = ( string ) request . get attribut ( javax . servlet . includ . request uri ) ; ( includ request uri = null ) { servlet engin . throw ex ; } els { int unavail second = ex . get unavail second ( ) ; ( unavail second = 0 ) { arbitrari default unavail second = 60 ; } avail = system . current time milli ( ) ( unavail second 1000l ) ; respons . send error ( http servlet respons . sc servic unavail , ex . get messag ( ) ) ; } } catch ( file found except ex ) { ctxt . increment remov ( ) ; string includ request uri = ( string ) request . get attribut ( javax . servlet . includ . request uri ) ; ( includ request uri = null ) { servlet engin . throw new servlet except ( ex ) ; } els { try { respons . send error ( http servlet respons . sc found , ex . get messag ( ) ) ; } catch ( illeg state except ) { log . error ( local . get messag ( jsp . error . file . . found , ex . get messag ( ) ) , ex ) ; } } } catch ( servlet except ex ) { ( option . get develop ( ) ) { throw handl jsp except ( ex ) ; } els { throw ex ; } } catch ( ioexcept ex ) { ( option . get develop ( ) ) { throw handl jsp except ( ex ) ; } els { throw ex ; } } catch ( illeg state except ex ) { ( option . get develop ( ) ) { throw handl jsp except ( ex ) ; } els { throw ex ; } } catch ( except ex ) { ( option . get develop ( ) ) { throw handl jsp except ( ex ) ; } els { throw new jasper except ( ex ) ; } } }
public send action connector . param action code type action param param action paramet void action ( action code action code , object param ) { ( action code = = action code . action commit ) { ( respons . commit ( ) ) return ; valid write respons header try { prepar respons ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . action client flush ) { ( respons . commit ( ) ) { valid write respons header try { prepar respons ( ) ; } catch ( ioexcept e ) { set error flag error = true ; return ; } } try { flush ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . action close ) { transact client try { finish ( ) ; } catch ( ioexcept e ) { set error flag error = true ; } } els ( action code = = action code . action start ) { start = true ; } els ( action code = = action code . action stop ) { start = fals ; } els ( action code = = action code . action req ssl attribut ) { ( certif . null ( ) ) { byte chunk cert data = certif . get byte chunk ( ) ; x509certif jsse cert = null ; byte arrai input stream bai = new byte arrai input stream ( cert data . get byte ( ) , cert data . get start ( ) , cert data . get length ( ) ) ; fill first element . try { certif factori cf = certif factori . get instanc ( x . 509 ) ; x509certif cert = ( x509certif ) cf . gener certif ( bai ) ; jsse cert = new x509certif 1 ; jsse cert 0 = cert ; request . set attribut ( apr endpoint . certif kei , jsse cert ) ; } catch ( java . secur . cert . certif except e ) { log . error ( sm . get string ( ajpprocessor . cert . fail ) , e ) ; return ; } } } els ( action code = = action code . action req host attribut ) { get remot host name us dn resolut ( request . remot host ( ) . null ( ) ) { try { request . remot host ( ) . set string ( inet address . get name ( request . remot addr ( ) . string ( ) ) . get host name ( ) ) ; } catch ( ioexcept iex ) { ignor } } } els ( action code = = action code . action req local addr attribut ) { copi from local name now , which should simpli address request . local addr ( ) . set string ( request . local name ( ) . string ( ) ) ; } els ( action code = = action code . action req set bodi replai ) { set given byte content byte chunk bc = ( byte chunk ) param ; bodi byte . set byte ( bc . get byte ( ) , bc . get start ( ) , bc . get length ( ) ) ; first = fals ; empti = fals ; replai = true ; } }	public coyot action implement void action ( action code action code , object param ) { ( action code = = action code . action commit ) { ( log . debug enabl ( ) ) log . debug ( commit ) ; respons re = ( respons ) param ; ( re . commit ( ) ) { ( log . debug enabl ( ) ) log . debug ( respons alreadi commit ) ; } els { try { jk . append head ( re ) ; } catch ( ioexcept iex ) { log . warn ( unabl send header , iex ) ; set statu ( jk statu error ) ; } } } els ( action code = = action code . action reset ) { ( log . debug enabl ( ) ) log . debug ( reset ) ; } els ( action code = = action code . action client flush ) { ( log . debug enabl ( ) ) log . debug ( client flush ) ; try { sourc . flush ( null , thi ) ; } catch ( ioexcept iex ) { thi log elsewher , so debug onli here log . debug ( error dure flush , iex ) ; respons re = ( respons ) param ; re . set error except ( iex ) ; set statu ( jk statu error ) ; } } els ( action code = = action code . action close ) { ( log . debug enabl ( ) ) log . debug ( close ) ; respons re = ( respons ) param ; ( get statu ( ) = = jk statu close get statu ( ) = = jk statu error ) { doubl close mai happen forward ( log . debug enabl ( ) ) log . debug ( doubl close forward re . get request ( ) . request uri ( ) ) ; return ; } ( re . commit ( ) ) thi . action ( action code . action commit , param ) ; try { jk . end messag ( ) ; } catch ( ioexcept iex ) { log . warn ( error send end packet , iex ) ; set statu ( jk statu error ) ; } ( get statu ( ) = jk statu error ) { set statu ( jk statu close ) ; } ( log time . debug enabl ( ) ) log time ( re . get request ( ) , re ) ; } els ( action code = = action code . action req ssl attribut ) { request req = ( request ) param ; extract ssl certif inform ( request ) messag byte cert string = ( messag byte ) req . get note ( worker env . ssl cert note ) ; ( cert string = null cert string . null ( ) ) { byte chunk cert data = cert string . get byte chunk ( ) ; byte arrai input stream bai = new byte arrai input stream ( cert data . get byte ( ) , cert data . get start ( ) , cert data . get length ( ) ) ; fill first element . x509certif jsse cert = null ; try { certif factori cf = certif factori . get instanc ( x . 509 ) ; x509certif cert = ( x509certif ) cf . gener certif ( bai ) ; jsse cert = new x509certif 1 ; jsse cert 0 = cert ; } catch ( java . secur . cert . certif except e ) { log . error ( certif convert fail , e ) ; return ; } req . set attribut ( sslsupport . certif kei , jsse cert ) ; } } els ( action code = = action code . action req host attribut ) { request req = ( request ) param ; remot host set jk , get s name from s remot addr ( req . remot host ( ) . null ( ) ) { try { req . remot host ( ) . set string ( inet address . get name ( req . remot addr ( ) . string ( ) ) . get host name ( ) ) ; } catch ( ioexcept iex ) { ( log . debug enabl ( ) ) log . debug ( unabl resolv req . remot addr ( ) ) ; } } } els ( action code = = action code . action ack ) { ( log . trace enabl ( ) ) log . trace ( ack ) ; } els ( action code = = action code . action req set bodi replai ) { ( log . trace enabl ( ) ) log . trace ( replai ) ; byte chunk bc = ( byte chunk ) param ; jk . set replai ( bc ) ; } }
public compil ( need ) load tag file class load tag file ( ) throw jasper except { try { ( ctxt . remov ( ) ) { throw new file found except ( jsp uri ) ; } ( option . get develop ( ) first time ) { synchron ( thi ) { first time = fals ; ctxt . compil ( ) ; } } els { ( compil except = null ) { throw compil except ; } } ( reload ) { tag handler class = ctxt . load ( ) ; } } catch ( file found except ex ) { throw new jasper except ( ex ) ; } return tag handler class ; }	public get list file current page ha sourc depend . java . util . list get depend ( ) { try { object target ; ( tag file ) { ( reload ) { tag handler class = ctxt . load ( ) ; } target = tag handler class . new instanc ( ) ; } els { target = get servlet ( ) ; } ( target = null target instanceof jsp sourc depend ) { return ( ( java . util . list ) ( ( jsp sourc depend ) target ) . get depend ( ) ) ; } } catch ( throwabl ex ) { } return null ; }	public static final object coerc type ( final object obj , final class type ) throw illeg argument except { ( type = = null object . class . equal ( type ) ) { return obj ; } ( string . class . equal ( type ) ) { return coerc string ( obj ) ; } ( elarithmet . number type ( type ) ) { return coerc number ( obj , type ) ; } ( charact . class . equal ( type ) charact . type = = type ) { return coerc charact ( obj ) ; } ( boolean . class . equal ( type ) boolean . type = = type ) { return coerc boolean ( obj ) ; } ( obj = null type . assign from ( obj . get class ( ) ) ) { return obj ; } new spec ( obj = = null ) return null ; ( obj instanceof string ) { ( . equal ( obj ) ) return null ; properti editor editor = properti editor manag . find editor ( type ) ; ( editor = null ) { editor . set text ( ( string ) obj ) ; return editor . get valu ( ) ; } } throw new illeg argument except ( messag factori . get ( error . convert , obj , obj . get class ( ) , type ) ) ; }	public static final param obj return string coerc string ( final object obj ) { ( obj = = null ) { return ; } els ( obj instanceof string ) { return ( string ) obj ; } els { return obj . string ( ) ; } }	public static final param obj0 param obj1 return throw evalu except boolean equal ( final object obj0 , final object obj1 ) throw elexcept { ( obj0 = = obj1 ) { return true ; } els ( obj0 = = null obj1 = = null ) { return fals ; } els ( obj0 instanceof boolean obj1 instanceof boolean ) { return coerc boolean ( obj0 ) . equal ( coerc boolean ( obj1 ) ) ; } ( big decim op ( obj0 , obj1 ) ) { big decim bd0 = ( big decim ) coerc number ( obj0 , big decim . class ) ; big decim bd1 = ( big decim ) coerc number ( obj1 , big decim . class ) ; return bd0 . equal ( bd1 ) ; } ( doubl op ( obj0 , obj1 ) ) { doubl d0 = ( doubl ) coerc number ( obj0 , doubl . class ) ; doubl d1 = ( doubl ) coerc number ( obj1 , doubl . class ) ; return d0 . equal ( d1 ) ; } ( big integ op ( obj0 , obj1 ) ) { big integ bi0 = ( big integ ) coerc number ( obj0 , big integ . class ) ; big integ bi1 = ( big integ ) coerc number ( obj1 , big integ . class ) ; return bi0 . equal ( bi1 ) ; } ( long op ( obj0 , obj1 ) ) { long l0 = ( long ) coerc number ( obj0 , long . class ) ; long l1 = ( long ) coerc number ( obj1 , long . class ) ; return l0 . equal ( l1 ) ; } els { return obj0 . equal ( obj1 ) ; } }
public stream print writer ssicommand us . string get file text ( string origin path , boolean virtual ) throw ioexcept { try { servlet context path cs p = get servlet context path ( origin path , virtual ) ; servlet context context = cs p . get servlet context ( ) ; string path = cs p . get path ( ) ; request dispatch rd = context . get request dispatch ( path ) ; ( rd = = null ) { throw new ioexcept ( couldn t get request dispatch path : path ) ; } byte arrai servlet output stream baso = new byte arrai servlet output stream ( ) ; respons includ wrapper respons includ wrapper = new respons includ wrapper ( context , req , re , baso ) ; rd . includ ( req , respons includ wrapper ) ; we can t assum includ servlet flush output respons includ wrapper . flush output stream writer ( ) ; byte byte = baso . byte arrai ( ) ; assum platform default encod unless otherwis specifi string ret val ; ( input encod = = null ) { ret val = new string ( byte ) ; } els { ret val = new string ( byte , input encod ) ; } were includ , sure how els tell . ( ret val . equal ( ) ) { throw new ioexcept ( couldn t find file : path ) ; } return ret val ; } catch ( servlet except e ) { throw new ioexcept ( couldn t includ file : origin path becaus servlet except : e . get messag ( ) ) ; } }
protect boolean space ( char c ) { return c = = c = = n c = = t c = = r ; }	protect string pars param valu ( string buffer cmd , int start , int count ) { int val index = 0 ; boolean insid = fals ; string val = new string count ; string buffer sb = new string buffer ( ) ; ( int b idx = start ; b idx cmd . length ( ) ; b idx ) { ( insid ) { while ( b idx cmd . length ( ) cmd . char ( b idx ) = ) b idx ; ( b idx = cmd . length ( ) ) break ; insid = insid ; } els { boolean escap = fals ; ( ; b idx cmd . length ( ) ; b idx ) { char c = cmd . char ( b idx ) ; check escap ( c = = escap ) { escap = true ; continu ; } we reach other stop ( c = = escap ) break ; we need leav escap string ( c = = escap ) sb . append ( ) ; escap = fals ; sb . append ( c ) ; } signal error ( b idx = = cmd . length ( ) ) return null ; val val index = sb . string ( ) ; clear buffer sb . delet ( 0 , sb . length ( ) ) ; insid = insid ; } } return val ; }
execut cgi script desir environ , current work directori , input output stream p thi implement follow cgi specif recommed : ul li server should provid code queri code compon script uri command line argument script doe contain ani unencod = charact command line argument can gener unambigu manner . li server should set auth type metavari valu code auth scheme code token code author code wa suppli part request header . see code get cgienviron code method . li where applic , server should set current work directori directori which script locat befor invok . li server implement should defin behavior follow case : ul li u allow charact path info u : thi implement doe allow ascii nul nor ani charact which cannot url encod accord internet standard ; li u allow charact path segment u : thi implement doe allow non termin null segment path ioexcept mai thrown ; li u code . code code . . code path segment u : thi implement doe allow code . code code . . code path , charact result ioexcept thrown ; li u implement limit u : thi implement doe impos ani limit except document abov . thi implement mai limit servlet contain us hous thi implement . particular , all primari cgi variabl valu ar deriv either directli indirectli from contain s implement servlet api method . ul ul p except ioexcept problem dure read write occur see java . lang . runtim exec ( string command , string envp , file dir ) protect void run ( ) throw ioexcept { remind : thi method feel too big ; should re written ( readi ( ) ) { throw new ioexcept ( thi . get class ( ) . get name ( ) : readi run . ) ; } ( debug = 1 ) { log ( run cgi ( envp = env , command = command ) ) ; } ( ( command . index ( file . separ . file . separ ) = 0 ) ( command . index ( file . separ . . ) = 0 ) ( command . index ( . . file . separ ) = 0 ) ) { throw new ioexcept ( thi . get class ( ) . get name ( ) illeg charact cgi command path ( . . . ) detect . run cgi command . ) ; } origin content structur thi section taken from http : develop . java . sun . com develop bug parad bug 4216884 . html major modif martin dengler runtim rt = null ; input stream cgi output = null ; buffer reader command std err = null ; buffer output stream command std = null ; process proc = null ; int buf read = 1 ; creat queri argument string buffer cmd arg = new string buffer ( ) ; ( command . index ( ) 0 ) { cmd arg . append ( command ) ; } els { space us delimit , so need us quot cmd arg . append ( ) ; cmd arg . append ( command ) ; cmd arg . append ( ) ; } ( int i = 0 ; i param . size ( ) ; i ) { cmd arg . append ( ) ; string param = ( string ) param . get ( i ) ; ( param . index ( ) 0 ) { cmd arg . append ( param ) ; } els { space us delimit , so need us quot cmd arg . append ( ) ; cmd arg . append ( param ) ; cmd arg . append ( ) ; } } string buffer command = new string buffer ( cgi execut ) ; command . append ( ) ; command . append ( cmd arg . string ( ) ) ; cmd arg = command ; rt = runtim . get runtim ( ) ; proc = rt . exec ( cmd arg . string ( ) , hash string arrai ( env ) , wd ) ; string s content length = ( string ) env . get ( content length ) ; ( . equal ( s content length ) ) { command std = new buffer output stream ( proc . get output stream ( ) ) ; iotool . flow ( stdin , command std ) ; command std . flush ( ) ; command std . close ( ) ; } we want wait process exit , process . wait ( ) useless our situat ; see http : develop . java . sun . com develop bug parad bug 4223650 . html boolean run = true ; command std err = new buffer reader ( new input stream reader ( proc . get error stream ( ) ) ) ; final buffer reader std err rdr = command std err ; new thread ( ) { } }	protect void run ( ) throw ioexcept { remind : thi method feel too big ; should re written ( readi ( ) ) { throw new ioexcept ( thi . get class ( ) . get name ( ) : readi run . ) ; } ( debug = 1 ) { log ( run cgi ( envp = env , command = command ) ) ; } ( ( command . index ( file . separ . file . separ ) = 0 ) ( command . index ( file . separ . . ) = 0 ) ( command . index ( . . file . separ ) = 0 ) ) { throw new ioexcept ( thi . get class ( ) . get name ( ) illeg charact cgi command path ( . . . ) detect . run cgi command . ) ; } origin content structur thi section taken from http : develop . java . sun . com develop bug parad bug 4216884 . html major modif martin dengler runtim rt = null ; input stream cgi output = null ; buffer reader command std err = null ; buffer output stream command std = null ; process proc = null ; int buf read = 1 ; creat queri argument string buffer cmd arg = new string buffer ( ) ; ( command . index ( ) 0 ) { cmd arg . append ( command ) ; } els { space us delimit , so need us quot cmd arg . append ( ) ; cmd arg . append ( command ) ; cmd arg . append ( ) ; } ( int i = 0 ; i param . size ( ) ; i ) { cmd arg . append ( ) ; string param = ( string ) param . get ( i ) ; ( param . index ( ) 0 ) { cmd arg . append ( param ) ; } els { space us delimit , so need us quot cmd arg . append ( ) ; cmd arg . append ( param ) ; cmd arg . append ( ) ; } } string buffer command = new string buffer ( cgi execut ) ; command . append ( ) ; command . append ( cmd arg . string ( ) ) ; cmd arg = command ; rt = runtim . get runtim ( ) ; proc = rt . exec ( cmd arg . string ( ) , hash string arrai ( env ) , wd ) ; string s content length = ( string ) env . get ( content length ) ; ( . equal ( s content length ) ) { command std = new buffer output stream ( proc . get output stream ( ) ) ; iotool . flow ( stdin , command std ) ; command std . flush ( ) ; command std . close ( ) ; } we want wait process exit , process . wait ( ) useless our situat ; see http : develop . java . sun . com develop bug parad bug 4223650 . html boolean run = true ; command std err = new buffer reader ( new input stream reader ( proc . get error stream ( ) ) ) ; final buffer reader std err rdr = command std err ; new thread ( ) { public void run ( ) { send log ( std err rdr ) ; } ; } . start ( ) ; input stream cgi header stream = new httpheader input stream ( proc . get input stream ( ) ) ; buffer reader cgi header reader = new buffer reader ( new input stream reader ( cgi header stream ) ) ; while ( run ) { try { set header string line = null ; while ( ( ( line = cgi header reader . read line ( ) ) = null ) ( . equal ( line ) ) ) { ( debug = 2 ) { log ( run cgi : add header ( line ) ) ; } ( line . start ( http ) ) { respons . set statu ( get scfrom http statu line ( line ) ) ; } els ( line . index ( : ) = 0 ) { string header = line . substr ( 0 , line . index ( : ) ) . trim ( ) ; string valu = line . substr ( line . index ( : ) 1 ) . trim ( ) ; ( header . equal ignor case ( statu ) ) { respons . set statu ( get scfrom cgistatu header ( valu ) ) ; } els { respons . add header ( header , valu ) ; } } els { log ( run cgi : bad header line line ) ; } } write output byte b buf = new byte 2048 ; output stream out = respons . get output stream ( ) ; cgi output = proc . get input stream ( ) ; try { while ( ( buf read = cgi output . read ( b buf ) ) = 1 ) { ( debug = 4 ) { log ( run cgi : output buf read byte data ) ; } out . write ( b buf , 0 , buf read ) ; } } final { extern process could hang ( buf read = 1 ) { while ( ( buf read = cgi output . read ( b buf ) ) = 1 ) { } } } throw except aliv proc . exit valu ( ) ; run = fals ; } catch ( illeg thread state except e ) { try { thread . sleep ( 500 ) ; } catch ( interrupt except ignor ) { } } } replac process . wait ( ) close output stream us cgi output . close ( ) ; }
public object resolv variabl ( string p name ) throw elexcept { return thi . ctx . get elresolv ( ) . get valu ( thi . ctx , p name , null ) ; }
synchron unload all initi instanc thi servlet , after call code destroi ( ) code method each instanc . thi can us , exampl , prior shut down entir servlet engin , prior reload all class from loader associ our loader s repositori . except servlet except except thrown destroi ( ) method void unload ( ) throw servlet except { noth do we have never load instanc ( singl thread model ( instanc = = null ) ) return ; unload = true ; ( possibl more than onc non stm ) ( count alloc 0 ) { int n retri = 0 ; long delai = unload delai 20 ; while ( ( n retri 21 ) ( count alloc 0 ) ) { ( ( n retri 10 ) = = 0 ) { log . info ( sm . get string ( standard wrapper . wait , new integ ( count alloc ) ) ) ; } try { thread . sleep ( delai ) ; } catch ( interrupt except e ) { ; } n retri ; } } class loader old ctx class loader = thread . current thread ( ) . get context class loader ( ) ; class loader class loader = instanc . get class ( ) . get class loader ( ) ; print stream out = system . out ; ( swallow output ) { system log handler . start captur ( ) ; } call servlet destroi ( ) method try { instanc support . fire instanc event ( instanc event . befor destroi event , instanc ) ; thread . current thread ( ) . set context class loader ( class loader ) ; ( system . get secur manag ( ) = null ) { secur util . do privileg ( destroi , instanc ) ; secur util . remov ( instanc ) ; } els { instanc . destroi ( ) ; } instanc support . fire instanc event ( instanc event . after destroi event , instanc ) ; annot process ( ( ( context ) get parent ( ) ) . get ignor annot ( ) ) { annot processor . pre destroi ( instanc ) ; } } catch ( throwabl t ) { instanc support . fire instanc event ( instanc event . after destroi event , instanc , t ) ; instanc = null ; instanc pool = null ; n instanc = 0 ; fire contain event ( unload , thi ) ; unload = fals ; throw new servlet except ( sm . get string ( standard wrapper . destroi except , get name ( ) ) , t ) ; } final { restor context class loader thread . current thread ( ) . set context class loader ( old ctx class loader ) ; write captur output ( swallow output ) { string log = system log handler . stop captur ( ) ; ( log = null log . length ( ) 0 ) { ( get servlet context ( ) = null ) { get servlet context ( ) . log ( log ) ; } els { out . println ( log ) ; } } } } deregist destroi instanc instanc = null ; ( singl thread model ( instanc pool = null ) ) { try { thread . current thread ( ) . set context class loader ( class loader ) ; while ( instanc pool . empti ( ) ) { servlet s = ( servlet ) instanc pool . pop ( ) ; ( system . get secur manag ( ) = null ) { secur util . do privileg ( destroi , s ) ; secur util . remov ( instanc ) ; } els { s . destroi ( ) ; } annot process ( ( ( context ) get parent ( ) ) . get ignor annot ( ) ) { annot processor . pre destroi ( s ) ; } } } catch ( throwabl t ) { instanc pool = null ; n instanc = 0 ; unload = fals ; fire contain event ( unload , thi ) ; throw new servlet except ( sm . get string ( standard wrapper . destroi except , get name ( ) ) , t ) ; } final { restor context class loader thread . current thread ( ) . set context class loader ( old ctx class loader ) ; } instanc pool = null ; n instanc = 0 ; } singl thread model = fals ; unload = fals ; fire contain event ( unload , thi ) ; }
public synchron start thi context compon . except lifecycl except startup error occur void start ( ) throw lifecycl except { ( lazi ) return ; ( start ) { ( log . info enabl ( ) ) log . info ( sm . get string ( contain base . alreadi start , log name ( ) ) ) ; return ; } ( initi ) { try { init ( ) ; } catch ( except ex ) { throw new lifecycl except ( error initializa , ex ) ; } } ( log . debug enabl ( ) ) log . debug ( start ( . equal ( get name ( ) ) root : get name ( ) ) ) ; set jmx object name proper pipelin registr pre regist jmx ( ) ; ( ( onam = null ) ( registri . get registri ( null , null ) . get mbean server ( ) . regist ( onam ) ) ) { thing depend jmx registr , context must reregist again onc properli initi registri . get registri ( null , null ) . unregist compon ( onam ) ; } notifi our interest lifecycl listen lifecycl . fire lifecycl event ( befor start event , null ) ; set avail ( fals ) ; set configur ( fals ) ; boolean ok = true ; add miss compon necessari ( webapp resourc = = null ) { ( 1 ) requir loader ( log . debug enabl ( ) ) log . debug ( configur default resourc ) ; try { ( ( doc base = null ) ( doc base . end ( . war ) ) ( ( new file ( get base path ( ) ) ) . directori ( ) ) ) set resourc ( new wardir context ( ) ) ; els set resourc ( new file dir context ( ) ) ; } catch ( illeg argument except e ) { log . error ( error initi resourc : e . get messag ( ) ) ; ok = fals ; } } ( ok ) { ( resourc start ( ) ) { log . error ( error resourc start ( ) ) ; ok = fals ; } } realm ad after context ll set itself . ( realm = = null mserver = null ) { object name realm name = null ; try { realm name = new object name ( get engin name ( ) : type = realm , host = get hostnam ( ) , path = get path ( ) ) ; ( mserver . regist ( realm name ) ) { mserver . invok ( realm name , init , new object { } , new string { } ) ; } } catch ( throwabl t ) { ( log . debug enabl ( ) ) log . debug ( realm thi host realm name ) ; } } ( get loader ( ) = = null ) { class loader parent = null ; ( get privileg ( ) ) { ( log . debug enabl ( ) ) log . debug ( configur privileg default loader ) ; parent = thi . get class ( ) . get class loader ( ) ; } els { ( log . debug enabl ( ) ) log . debug ( configur non privileg default loader ) ; parent = get parent class loader ( ) ; } webapp loader webapp loader = new webapp loader ( parent ) ; webapp loader . set deleg ( get deleg ( ) ) ; set loader ( webapp loader ) ; } initi charact set mapper get charset mapper ( ) ; post work directori post work directori ( ) ; valid requir extens boolean depend check = true ; try { depend check = extens valid . valid applic ( get resourc ( ) , thi ) ; } catch ( ioexcept ioe ) { log . error ( error depend check , ioe ) ; depend check = fals ; } ( depend check ) { do make applic avail depenc check fail ok = fals ; } read catalina . us name environ variabl string us name properti = system . get properti ( catalina . us name ) ; ( ( us name properti = null ) ( us name properti . equal ( fals ) ) ) { us name = fals ; } ( ok us name ( ) ) { ( name context listen = = null ) { name context listen = new name context listen ( ) ; name context listen . set name ( get name context name ( ) ) ; add lifecycl listen ( name context listen ) ; } } standard contain startup ( log . debug enabl ( ) ) log . debug ( process standard contain startup ) ; bind thread class loader old ccl = bind thread ( ) ; boolean main ok = fals ; try { ( ok ) { start = true ; start our subordin compon , ani ( ( loader = null ) ( loader instanceof lifecycl ) ) ( ( lifecycl ) loader ) . start ( ) ; unbind thread unbind thread ( old ccl ) ; bind thread old ccl = bind thread ( ) ; initi logger again . other compon might have us too earli , so should reset . logger = null ; get logger ( ) ; ( ( logger = null ) ( logger instanceof lifecycl ) ) ( ( lifecycl ) logger ) . start ( ) ; ( ( cluster = null ) ( cluster instanceof lifecycl ) ) ( ( lifecycl ) cluster ) . start ( ) ; ( ( realm = null ) ( realm instanceof lifecycl ) ) ( ( lifecycl ) realm ) . start ( ) ; ( ( resourc = null ) ( resourc instanceof lifecycl ) ) ( ( lifecycl ) resourc ) . start ( ) ; start our child contain , ani contain children = find children ( ) ; ( int i = 0 ; i children . length ; i ) { ( children i instanceof lifecycl ) ( ( lifecycl ) children i ) . start ( ) ; } ani ( pipelin instanceof lifecycl ) { ( ( lifecycl ) pipelin ) . start ( ) ; } ( get process tld ( ) ) { process tld ( ) ; } notifi our interest lifecycl listen lifecycl . fire lifecycl event ( start event , null ) ; configur default manag none wa specifi ( manag = = null ) { ( ( get cluster ( ) = null ) distribut ) { try { set manag ( get cluster ( ) . creat manag ( get name ( ) ) ) ; } catch ( except ex ) { log . error ( standard context . cluster fail , ex ) ; ok = fals ; } } els { set manag ( new standard manag ( ) ) ; } } start manag ( ( manag = null ) ( manag instanceof lifecycl ) ) { ( ( lifecycl ) get manag ( ) ) . start ( ) ; } start contain background processor thread super . thread start ( ) ; main ok = true ; } } final { unbind thread unbind thread ( old ccl ) ; ( main ok ) { except occur regist jmx anywai , allow manag regist jmx ( ) ; } } ( get configur ( ) ) { log . error ( error get configur ) ; ok = fals ; } we put resourc servlet context ( ok ) get servlet context ( ) . set attribut ( global . resourc attr , get resourc ( ) ) ; initi associ mapper mapper . set context ( get path ( ) , welcom file , resourc ) ; bind thread old ccl = bind thread ( ) ; ar mani solut ) ( ignor annot ) { wrapper jsp servlet = ( wrapper ) find child ( constant . jsp servlet name ) ; jsp servlet . add init paramet ( org . apach . jasper . ignor annot , true ) ; } try { creat context attribut requir ( ok ) { post welcom file ( ) ; } ( ok ) { notifi our interest lifecycl listen lifecycl . fire lifecycl event ( after start event , null ) ; } configur call applic event listen filter ( ok ) { ( listen start ( ) ) { log . error ( error listen start ) ; ok = fals ; } } ( ok ) { ( filter start ( ) ) { log . error ( error filter start ) ; ok = fals ; } } load initi all load startup servlet ( ok ) { load startup ( find children ( ) ) ; } } final { unbind thread unbind thread ( old ccl ) ; } set avail statu depend upon startup success ( ok ) { ( log . debug enabl ( ) ) log . debug ( start complet ) ; set avail ( true ) ; } els { log . error ( sm . get string ( standard context . start fail , get name ( ) ) ) ; try { stop ( ) ; } catch ( throwabl t ) { log . error ( sm . get string ( standard context . start cleanup ) , t ) ; } set avail ( fals ) ; } jmx registr regist jmx ( ) ; start time = system . current time milli ( ) ; send j2ee . state . run notif ( ok ( thi . get object name ( ) = null ) ) { notif notif = new notif ( j2ee . state . run , thi . get object name ( ) , sequenc number ) ; broadcast . send notif ( notif ) ; } file startup ( get loader ( ) instanceof webapp loader ) { ( ( webapp loader ) get loader ( ) ) . close jar ( true ) ; } reiniti someth went wrong ( ok start ) { stop ( ) ; } cach context ( ) ; }
