================= fetch protected String getCommonSuperClass(final String type1, final String type2) { dd88d21^:weaver/src/org/aspectj/weaver/bcel/asm/StackMapAdder.java
// Implementation of getCommonSuperClass() that avoids Class.forName()
protected String getCommonSuperClass(final String type1, final String type2) {

			ResolvedType resolvedType1 = world.resolve(UnresolvedType.forName(type1.replace('/', '.')));
			ResolvedType resolvedType2 = world.resolve(UnresolvedType.forName(type2.replace('/', '.')));

			if (resolvedType1.isAssignableFrom(resolvedType2)) {
				return type1;
			}

			if (resolvedType2.isAssignableFrom(resolvedType1)) {
				return type2;
			}

			if (resolvedType1.isInterface() || resolvedType2.isInterface()) {
				return "java/lang/Object";
			} else {
				do {
					resolvedType1 = resolvedType1.getSuperclass();
				} while (!resolvedType1.isAssignableFrom(resolvedType2));
				return resolvedType1.getRawName().replace('.', '/');
			}
		}
================= fetch public ReferenceTypeDelegate getDelegate(ReferenceType referenceType) { dd88d21^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
/**
	 * See if we can create a delegate from a CompactTypeStructure - TODO better comment
	 */
public ReferenceTypeDelegate getDelegate(ReferenceType referenceType) {
		File f = classesFromName.get(referenceType.getName());
		if (f == null) {
			return null; // not heard of it
		}
		try {
			ClassParser parser = new ClassParser(f.toString());
			return world.buildBcelDelegate(referenceType, parser.parse(), true, false);
		} catch (IOException e) {
			IMessage msg = new Message("Failed to recover " + referenceType, referenceType.getSourceLocation(), false);
			buildManager.handler.handleMessage(msg);
		}
		return null;
	}
================= fetch public static Test suite() { dd88d21^:tests/src/org/aspectj/systemtest/AllTests17.java

public static Test suite() {
		TestSuite suite = new TestSuite("AspectJ System Test Suite - 1.7");
		// $JUnit-BEGIN$
		suite.addTest(AllTestsAspectJ174.suite()); 
		suite.addTest(AllTestsAspectJ173.suite()); 
		suite.addTest(AllTestsAspectJ172.suite());
		suite.addTest(AllTestsAspectJ171.suite());
		suite.addTest(AllTestsAspectJ170.suite());
		suite.addTest(AllTests16.suite());
		suite.addTest(AllTests15.suite());
		// $JUnit-END$
		return suite;
	}
================= fetch public void testAdviceDidNotMatch_pr152589() { dd88d21^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java

public void testAdviceDidNotMatch_pr152589() {
		initialiseProject("PR152589");
		build("PR152589");
		List warnings = getWarningMessages("PR152589");
		assertTrue("There should be no warnings:\n" + warnings, warnings.isEmpty());
		alter("PR152589", "inc1");
		build("PR152589");
		checkWasntFullBuild(); // the line number has changed... but nothing
		// structural about the code

		// checkWasFullBuild();
		warnings = getWarningMessages("PR152589");
		assertTrue("There should be no warnings after adding a whitespace:\n" + warnings, warnings.isEmpty());
	}
================= fetch public void testAspectPath_pr249212_c1() throws IOException { dd88d21^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
/**
	 * A change is made to an aspect on the aspectpath (staticinitialization() advice is added) for another project.
	 * <p>
	 * Managing the aspectpath is hard. We want to do a minimal build of this project which means recognizing what kind of changes
	 * have occurred on the aspectpath. Was it a regular class or an aspect? Was it a structural change to that aspect?
	 * <p>
	 * The filenames for .class files created that contain aspects is stored in the AjState.aspectClassFiles field. When a change is
	 * detected we can see who was managing the location where the change occurred and ask them if the .class file contained an
	 * aspect. Right now a change detected like this will cause a full build. We might improve the detection logic here but it isn't
	 * trivial:
	 * <ul>
	 * <li>Around advice is inlined. Changing the body of an around advice would not normally be thought of as a structural change
	 * (as it does not change the signature of the class) but due to inlining it is a change we would need to pay attention to as it
	 * will affect types previously woven with that advice.
	 * <li>Annotation style aspects include pointcuts in strings. Changes to these are considered non-structural but clearly they do
	 * affect what might be woven.
	 * </ul>
	 */
public void testAspectPath_pr249212_c1() throws IOException {
		String p1 = "AspectPathOne";
		String p2 = "AspectPathTwo";
		addSourceFolderForSourceFile(p2, getProjectRelativePath(p2, "src/C.java"), "src");
		initialiseProject(p1);
		initialiseProject(p2);
		configureAspectPath(p2, getProjectRelativePath(p1, "bin"));
		build(p1);
		build(p2);

		alter(p1, "inc1");
		build(p1); // Modify the aspect Asp2 to include staticinitialization()
		// advice
		checkWasFullBuild();
		Set s = getModelFor(p1).getModelChangesOnLastBuild();
		assertTrue("Should be empty as was full build:" + s, s.isEmpty());

		// prod the build of the second project with some extra info to tell it
		// more precisely about the change:
		addClasspathEntryChanged(p2, getProjectRelativePath(p1, "bin").toString());
		configureAspectPath(p2, getProjectRelativePath(p1, "bin"));
		build(p2);
		checkWasFullBuild();

		// dumptree(AsmManager.getDefault().getHierarchy().getRoot(), 0);
		// PrintWriter pw = new PrintWriter(System.out);
		// AsmManager.getDefault().dumprels(pw);
		// pw.flush();

		// Not incremental
		assertTrue("Should be empty as was full build:" + s, s.isEmpty());
		// Set s = AsmManager.getDefault().getModelChangesOnLastBuild();
		// checkIfContainsFile(AsmManager.getDefault().getModelChangesOnLastBuild
		// (), "C.java", true);
	}
================= fetch public void testPr148285() { dd88d21^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java

public void testPr148285() {
		String p = "PR148285_2";
		initialiseProject(p); // Single source file A.aj defines A and C
		build(p);
		checkWasFullBuild();
		alter(p, "inc1"); // Second source introduced C.java, defines C
		build(p);
		checkWasntFullBuild();
		List msgs = getErrorMessages(p);
		assertEquals("error message should be 'The type C is already defined' ", "The type C is already defined",
				((IMessage) msgs.get(0)).getMessage());
		alter("PR148285_2", "inc2"); // type C in A.aj is commented out
		build("PR148285_2");
		checkWasntFullBuild();
		msgs = getErrorMessages(p);
		assertTrue("There should be no errors reported:\n" + getErrorMessages(p), msgs.isEmpty());
	}
================= fetch private String getValue(String key, Shadow shadow) { 9319e34^:org.aspectj.matcher/src/org/aspectj/weaver/Checker.java
/**
	 * @param buf the buffer in which to insert the substitution
	 * @param shadow shadow from which to draw context info
	 * @param c the substitution character
	 */
private String getValue(String key, Shadow shadow) {
		if (key.equalsIgnoreCase("joinpoint")) {
			return shadow.toString();
		} else if (key.equalsIgnoreCase("joinpoint.kind")) {
			return shadow.getKind().getName();
		} else if (key.equalsIgnoreCase("joinpoint.signature")) {
			return shadow.getSignature().toString();
		} else if (key.equalsIgnoreCase("joinpoint.signature.declaringtype")) {
			return shadow.getSignature().getDeclaringType().toString();
		} else if (key.equalsIgnoreCase("joinpoint.signature.name")) {
			return shadow.getSignature().getName();
		} else if (key.equalsIgnoreCase("joinpoint.sourcelocation.sourcefile")) {
			ISourceLocation loc = shadow.getSourceLocation();
			if ((loc != null) && (loc.getSourceFile() != null)) {
				return loc.getSourceFile().toString();
			} else {
				return "UNKNOWN";
			}
		} else if (key.equalsIgnoreCase("joinpoint.sourcelocation.line")) {
			ISourceLocation loc = shadow.getSourceLocation();
			if (loc != null) {
				return Integer.toString(loc.getLine());
			} else {
				return "-1";
			}
		} else if (key.equalsIgnoreCase("advice.aspecttype")) {
			return getDeclaringType().getName();
		} else if (key.equalsIgnoreCase("advice.sourcelocation.line")) {
			ISourceLocation loc = getSourceLocation();
			if ((loc != null) && (loc.getSourceFile() != null)) {
				return Integer.toString(loc.getLine());
			} else {
				return "-1";
			}
		} else if (key.equalsIgnoreCase("advice.sourcelocation.sourcefile")) {
			ISourceLocation loc = getSourceLocation();
			if ((loc != null) && (loc.getSourceFile() != null)) {
				return loc.getSourceFile().toString();
			} else {
				return "UNKNOWN";
			}
		} else {
			return "UNKNOWN_KEY{" + key + "}";
		}
	}
================= fetch private void initBcelWorld(IMessageHandler handler) throws IOException { b2cd5fa^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/** init only on initial batch compile? no file-specific options */
private void initBcelWorld(IMessageHandler handler) throws IOException {
		List cp = buildConfig.getFullClasspath(); // pr145693
		// buildConfig.getBootclasspath();
		// cp.addAll(buildConfig.getClasspath());
		BcelWorld bcelWorld = new BcelWorld(cp, handler, null);
		bcelWorld.setBehaveInJava5Way(buildConfig.getBehaveInJava5Way());
		bcelWorld.setTiming(buildConfig.isTiming(), false);
		bcelWorld.setAddSerialVerUID(buildConfig.isAddSerialVerUID());
		bcelWorld.setXmlConfigured(buildConfig.isXmlConfigured());
		bcelWorld.setXmlFiles(buildConfig.getXmlFiles());
		bcelWorld.performExtraConfiguration(buildConfig.getXconfigurationInfo());
		bcelWorld.setTargetAspectjRuntimeLevel(buildConfig.getTargetAspectjRuntimeLevel());
		bcelWorld.setOptionalJoinpoints(buildConfig.getXJoinpoints());
		bcelWorld.setXnoInline(buildConfig.isXnoInline());
		bcelWorld.setXlazyTjp(buildConfig.isXlazyTjp());
		bcelWorld.setXHasMemberSupportEnabled(buildConfig.isXHasMemberEnabled());
		bcelWorld.setPinpointMode(buildConfig.isXdevPinpoint());
		bcelWorld.setErrorAndWarningThreshold(buildConfig.getOptions().errorThreshold.isSet(24), buildConfig.getOptions().warningThreshold.isSet(24));
		BcelWeaver bcelWeaver = new BcelWeaver(bcelWorld);
		bcelWeaver.setCustomMungerFactory(customMungerFactory);
		state.setWorld(bcelWorld);
		state.setWeaver(bcelWeaver);
		state.clearBinarySourceFiles();

		if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
			bcelWorld.getLint().loadDefaultProperties();
		} else {
			bcelWorld.getLint().setAll(buildConfig.getLintMode());
		}
		if (buildConfig.getLintSpecFile() != null) {
			bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
		}

		for (Iterator i = buildConfig.getAspectpath().iterator(); i.hasNext();) {
			File f = (File) i.next();
			if (!f.exists()) {
				IMessage message = new Message("invalid aspectpath entry: " + f.getName(), null, true);
				handler.handleMessage(message);
			} else {
				bcelWeaver.addLibraryJarFile(f);
			}
		}

		// String lintMode = buildConfig.getLintMode();

		File outputDir = buildConfig.getOutputDir();
		if (outputDir == null && buildConfig.getCompilationResultDestinationManager() != null) {
			// send all output from injars and inpath to the default output location
			// (will also later send the manifest there too)
			outputDir = buildConfig.getCompilationResultDestinationManager().getDefaultOutputLocation();
		}
		// ??? incremental issues
		for (File inJar : buildConfig.getInJars()) {
			List<UnwovenClassFile> unwovenClasses = bcelWeaver.addJarFile(inJar, outputDir, false);
			state.recordBinarySource(inJar.getPath(), unwovenClasses);
		}

		for (File inPathElement : buildConfig.getInpath()) {
			if (!inPathElement.isDirectory()) {
				// its a jar file on the inpath
				// the weaver method can actually handle dirs, but we don't call it, see next block
				List<UnwovenClassFile> unwovenClasses = bcelWeaver.addJarFile(inPathElement, outputDir, true);
				state.recordBinarySource(inPathElement.getPath(), unwovenClasses);
			} else {
				// add each class file in an in-dir individually, this gives us the best error reporting
				// (they are like 'source' files then), and enables a cleaner incremental treatment of
				// class file changes in indirs.
				File[] binSrcs = FileUtil.listFiles(inPathElement, binarySourceFilter);
				for (int j = 0; j < binSrcs.length; j++) {
					UnwovenClassFile ucf = bcelWeaver.addClassFile(binSrcs[j], inPathElement, outputDir);
					List<UnwovenClassFile> ucfl = new ArrayList<UnwovenClassFile>();
					ucfl.add(ucf);
					state.recordBinarySource(binSrcs[j].getPath(), ucfl);
				}
			}
		}

		bcelWeaver.setReweavableMode(buildConfig.isXNotReweavable());

		// check for org.aspectj.runtime.JoinPoint
		ResolvedType joinPoint = bcelWorld.resolve("org.aspectj.lang.JoinPoint");
		if (joinPoint.isMissing()) {
			IMessage message = new Message(
					"classpath error: unable to find org.aspectj.lang.JoinPoint (check that aspectjrt.jar is in your classpath)",
					null, true);
			handler.handleMessage(message);
		}
	}
================= fetch private void setAll(IMessage.Kind messageKind) { b2cd5fa^:org.aspectj.matcher/src/org/aspectj/weaver/Lint.java

private void setAll(IMessage.Kind messageKind) {
		for (Kind kind : kinds.values()) {
			kind.setKind(messageKind);
		}
	}
================= fetch public String getLintMode() { b2cd5fa^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java

public String getLintMode() {
		return lintMode;
	}
================= fetch public void setLintMode(String lintMode) { b2cd5fa^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java
// options...
public void setLintMode(String lintMode) {
		this.lintMode = lintMode;
		String lintValue = null;
		if (AJLINT_IGNORE.equals(lintMode)) {
			lintValue = AjCompilerOptions.IGNORE;
		} else if (AJLINT_WARN.equals(lintMode)) {
			lintValue = AjCompilerOptions.WARNING;
		} else if (AJLINT_ERROR.equals(lintMode)) {
			lintValue = AjCompilerOptions.ERROR;
		}

		if (lintValue != null) {
			Map<String, String> lintOptions = new HashMap<String, String>();
			lintOptions.put(AjCompilerOptions.OPTION_ReportInvalidAbsoluteTypeName, lintValue);
			lintOptions.put(AjCompilerOptions.OPTION_ReportInvalidWildcardTypeName, lintValue);
			lintOptions.put(AjCompilerOptions.OPTION_ReportUnresolvableMember, lintValue);
			lintOptions.put(AjCompilerOptions.OPTION_ReportTypeNotExposedToWeaver, lintValue);
			lintOptions.put(AjCompilerOptions.OPTION_ReportShadowNotInStructure, lintValue);
			lintOptions.put(AjCompilerOptions.OPTION_ReportUnmatchedSuperTypeInCall, lintValue);
			lintOptions.put(AjCompilerOptions.OPTION_ReportCannotImplementLazyTJP, lintValue);
			lintOptions.put(AjCompilerOptions.OPTION_ReportNeedSerialVersionUIDField, lintValue);
			lintOptions.put(AjCompilerOptions.OPTION_ReportIncompatibleSerialVersion, lintValue);
			options.set(lintOptions);
		}
	}
================= fetch public void setXlintfile(String xlintfile) { b2cd5fa^:testing/newsrc/org/aspectj/testing/CompileSpec.java

protected AjcTestCase.MessageSpec buildMessageSpec() {
		List infos = null;
		List warnings = new ArrayList();
		List errors = new ArrayList();
		List fails = new ArrayList();
		List weaveInfos = new ArrayList();
		for (Iterator iter = expected.iterator(); iter.hasNext();) {
			ExpectedMessageSpec exMsg = (ExpectedMessageSpec) iter.next();
			String kind = exMsg.getKind();
			if (kind.equals("info")) {
				if (infos == null) infos = new ArrayList();
				infos.add(exMsg.toMessage());
			} else if (kind.equals("warning")) {
				warnings.add(exMsg.toMessage());
			} else if (kind.equals("error")) {
				errors.add(exMsg.toMessage());				
			} else if (kind.equals("fail")) {
				fails.add(exMsg.toMessage());
			} else if (kind.equals("abort")) {
				fails.add(exMsg.toMessage());
			} else if (kind.equals("weave")) {
				weaveInfos.add(exMsg.toMessage());
			}
		}
		return new AjcTestCase.MessageSpec(infos,warnings,errors,fails,weaveInfos);
	}
================= fetch static WeavingAdaptor getWeaver(ClassLoader loader, IWeavingContext weavingConte 9e992d6^:loadtime/src/org/aspectj/weaver/loadtime/Aj.java

public static void checkQ() {
		synchronized (adaptorQueue) {
			Object o = adaptorQueue.poll();
			while (o != null) {
				AdaptorKey wo = (AdaptorKey) o;
				// boolean removed =
				WeaverContainer.weavingAdaptors.remove(wo);
				// DBG System.err.println("Evicting key " + wo + " = " + didit);
				o = adaptorQueue.poll();
			}
		}
	}
================= fetch private boolean doesAlreadyHaveAnnotation(ResolvedMember rm, DeclareAnnotation d 2393bef^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
	 * Check if a resolved member (field/method/ctor) already has an annotation, if it does then put out a warning and return true
	 */
private boolean doesAlreadyHaveAnnotation(ResolvedMember rm, DeclareAnnotation deca, List<Integer> reportedProblems) {
		if (rm.hasAnnotation(deca.getAnnotationType())) {
			if (world.getLint().elementAlreadyAnnotated.isEnabled()) {
				Integer uniqueID = new Integer(rm.hashCode() * deca.hashCode());
				if (!reportedProblems.contains(uniqueID)) {
					reportedProblems.add(uniqueID);
					world.getLint().elementAlreadyAnnotated.signal(new String[] { rm.toString(),
							deca.getAnnotationType().toString() }, rm.getSourceLocation(),
							new ISourceLocation[] { deca.getSourceLocation() });
				}
			}
			return true;
		}
		return false;
	}
================= fetch private boolean weaveDeclareAtField(LazyClassGen clazz) { 2393bef^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
	 * Weave any declare @field statements into the fields of the supplied class. This will attempt to apply them to the ITDs too.
	 * 
	 * Interesting case relating to public ITDd fields. The annotations are really stored against the interfieldinit method in the
	 * aspect, but the public field is placed in the target type and then is processed in the 2nd pass over fields that occurs. I
	 * think it would be more expensive to avoid putting the annotation on that inserted public field than just to have it put there
	 * as well as on the interfieldinit method.
	 */
private boolean weaveDeclareAtField(LazyClassGen clazz) {
		List<Integer> reportedProblems = new ArrayList<Integer>();
		List<DeclareAnnotation> allDecafs = world.getDeclareAnnotationOnFields();
		if (allDecafs.isEmpty()) {
			return false;
		}
		boolean typeIsChanged = false;
		List<ConcreteTypeMunger> relevantItdFields = getITDSubset(clazz, ResolvedTypeMunger.Field);
		if (relevantItdFields != null) {
			typeIsChanged = weaveAtFieldRepeatedly(allDecafs, relevantItdFields, reportedProblems);
		}

		List<DeclareAnnotation> decafs = getMatchingSubset(allDecafs, clazz.getType());
		if (decafs.isEmpty()) {
			return typeIsChanged;
		}

		List<BcelField> fields = clazz.getFieldGens();
		if (fields != null) {
			Set<DeclareAnnotation> unusedDecafs = new HashSet<DeclareAnnotation>();
			unusedDecafs.addAll(decafs);
			for (BcelField field : fields) {
				if (!field.getName().startsWith(NameMangler.PREFIX)) {
					// Single first pass
					Set<DeclareAnnotation> worthRetrying = new LinkedHashSet<DeclareAnnotation>();
					boolean modificationOccured = false;
					AnnotationAJ[] dontAddMeTwice = field.getAnnotations();

					// go through all the declare @field statements
					for (DeclareAnnotation decaf : decafs) {
						if (decaf.getAnnotation() == null) {
							return false;
						}
						if (decaf.matches(field, world)) {
							if (decaf.isRemover()) {
								AnnotationAJ annotation = decaf.getAnnotation();
								if (field.hasAnnotation(annotation.getType())) {
									// something to remove
									typeIsChanged = true;
									field.removeAnnotation(annotation);
									AsmRelationshipProvider.addDeclareAnnotationFieldRelationship(world.getModelAsAsmManager(),
											decaf.getSourceLocation(), clazz.getName(), field, true);
									reportFieldAnnotationWeavingMessage(clazz, field, decaf, true);
									dontAddMeTwice = removeFromAnnotationsArray(dontAddMeTwice, annotation);
								} else {
									worthRetrying.add(decaf);
								}
								unusedDecafs.remove(decaf);
							} else {
								if (!dontAddTwice(decaf, dontAddMeTwice)) {
									if (doesAlreadyHaveAnnotation(field, decaf, reportedProblems)) {
										// remove the declare @field since don't want an error when the annotation is already there
										unusedDecafs.remove(decaf);
										continue;
									}
									field.addAnnotation(decaf.getAnnotation());
								}
								AsmRelationshipProvider.addDeclareAnnotationFieldRelationship(world.getModelAsAsmManager(),
										decaf.getSourceLocation(), clazz.getName(), field, false);
								reportFieldAnnotationWeavingMessage(clazz, field, decaf, false);
								typeIsChanged = true;
								modificationOccured = true;
								unusedDecafs.remove(decaf);
							}
						} else if (!decaf.isStarredAnnotationPattern() || decaf.isRemover()) {
							worthRetrying.add(decaf); // an annotation is specified that might be put on by a subsequent decaf
						}
					}

					// Multiple secondary passes
					while (!worthRetrying.isEmpty() && modificationOccured) {
						modificationOccured = false;
						// lets have another go with any remaining ones
						List<DeclareAnnotation> forRemoval = new ArrayList<DeclareAnnotation>();
						for (Iterator<DeclareAnnotation> iter = worthRetrying.iterator(); iter.hasNext();) {
							DeclareAnnotation decaF = iter.next();

							if (decaF.matches(field, world)) {
								if (decaF.isRemover()) {
									AnnotationAJ annotation = decaF.getAnnotation();
									if (field.hasAnnotation(annotation.getType())) {
										// something to remove
										typeIsChanged = modificationOccured = true;
										forRemoval.add(decaF);
										field.removeAnnotation(annotation);
										AsmRelationshipProvider.addDeclareAnnotationFieldRelationship(world.getModelAsAsmManager(),
												decaF.getSourceLocation(), clazz.getName(), field, true);
										reportFieldAnnotationWeavingMessage(clazz, field, decaF, true);
									}
								} else {
									// below code is for recursive things
									unusedDecafs.remove(decaF);
									if (doesAlreadyHaveAnnotation(field, decaF, reportedProblems)) {
										continue;
									}
									field.addAnnotation(decaF.getAnnotation());
									AsmRelationshipProvider.addDeclareAnnotationFieldRelationship(world.getModelAsAsmManager(),
											decaF.getSourceLocation(), clazz.getName(), field, false);
									typeIsChanged = modificationOccured = true;
									forRemoval.add(decaF);
								}
							}
						}
						worthRetrying.removeAll(forRemoval);
					}
				}
			}
			checkUnusedDeclareAts(unusedDecafs, true);
		}
		return typeIsChanged;
	}
================= fetch private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) { 2393bef^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
	 * Weave any declare @method/@ctor statements into the members of the supplied class
	 */
private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {
		List<Integer> reportedProblems = new ArrayList<Integer>();

		List<DeclareAnnotation> allDecams = world.getDeclareAnnotationOnMethods();
		if (allDecams.isEmpty()) {
			return false;
		}

		boolean isChanged = false;

		// deal with ITDs
		List<ConcreteTypeMunger> itdMethodsCtors = getITDSubset(clazz, ResolvedTypeMunger.Method);
		itdMethodsCtors.addAll(getITDSubset(clazz, ResolvedTypeMunger.Constructor));
		if (!itdMethodsCtors.isEmpty()) {
			// Can't use the subset called 'decaMs' as it won't be right for
			// ITDs...
			isChanged = weaveAtMethodOnITDSRepeatedly(allDecams, itdMethodsCtors, reportedProblems);
		}

		// deal with all the other methods...
		List<LazyMethodGen> members = clazz.getMethodGens();
		List<DeclareAnnotation> decaMs = getMatchingSubset(allDecams, clazz.getType());
		if (decaMs.isEmpty()) {
			return false; // nothing to do
		}
		if (!members.isEmpty()) {
			Set<DeclareAnnotation> unusedDecams = new HashSet<DeclareAnnotation>();
			unusedDecams.addAll(decaMs);
			for (int memberCounter = 0; memberCounter < members.size(); memberCounter++) {
				LazyMethodGen mg = members.get(memberCounter);
				if (!mg.getName().startsWith(NameMangler.PREFIX)) {

					// Single first pass
					List<DeclareAnnotation> worthRetrying = new ArrayList<DeclareAnnotation>();
					boolean modificationOccured = false;
					List<AnnotationGen> annotationsToAdd = null;
					for (DeclareAnnotation decaM : decaMs) {

						if (decaM.matches(mg.getMemberView(), world)) {
							if (doesAlreadyHaveAnnotation(mg.getMemberView(), decaM, reportedProblems)) {
								// remove the declare @method since don't want
								// an error when the annotation is already there
								unusedDecams.remove(decaM);
								continue; // skip this one...
							}

							if (annotationsToAdd == null) {
								annotationsToAdd = new ArrayList<AnnotationGen>();
							}
							AnnotationGen a = ((BcelAnnotation) decaM.getAnnotation()).getBcelAnnotation();
							AnnotationGen ag = new AnnotationGen(a, clazz.getConstantPool(), true);
							annotationsToAdd.add(ag);
							mg.addAnnotation(decaM.getAnnotation());

							AsmRelationshipProvider.addDeclareAnnotationMethodRelationship(decaM.getSourceLocation(),
									clazz.getName(), mg.getMemberView(), world.getModelAsAsmManager());// getMethod());
							reportMethodCtorWeavingMessage(clazz, mg.getMemberView(), decaM, mg.getDeclarationLineNumber());
							isChanged = true;
							modificationOccured = true;
							// remove the declare @method since have matched
							// against it
							unusedDecams.remove(decaM);
						} else {
							if (!decaM.isStarredAnnotationPattern()) {
								worthRetrying.add(decaM); // an annotation is
								// specified that
								// might be put on
								// by a subsequent
								// decaf
							}
						}
					}

					// Multiple secondary passes
					while (!worthRetrying.isEmpty() && modificationOccured) {
						modificationOccured = false;
						// lets have another go
						List<DeclareAnnotation> forRemoval = new ArrayList<DeclareAnnotation>();
						for (DeclareAnnotation decaM : worthRetrying) {
							if (decaM.matches(mg.getMemberView(), world)) {
								if (doesAlreadyHaveAnnotation(mg.getMemberView(), decaM, reportedProblems)) {
									// remove the declare @method since don't
									// want an error when
									// the annotation is already there
									unusedDecams.remove(decaM);
									continue; // skip this one...
								}

								if (annotationsToAdd == null) {
									annotationsToAdd = new ArrayList<AnnotationGen>();
								}
								AnnotationGen a = ((BcelAnnotation) decaM.getAnnotation()).getBcelAnnotation();
								// create copy to get the annotation type into the right constant pool
								AnnotationGen ag = new AnnotationGen(a, clazz.getConstantPool(), true);
								annotationsToAdd.add(ag);
								mg.addAnnotation(decaM.getAnnotation());
								AsmRelationshipProvider.addDeclareAnnotationMethodRelationship(decaM.getSourceLocation(),
										clazz.getName(), mg.getMemberView(), world.getModelAsAsmManager());// getMethod());
								isChanged = true;
								modificationOccured = true;
								forRemoval.add(decaM);
								// remove the declare @method since have matched
								// against it
								unusedDecams.remove(decaM);
							}
						}
						worthRetrying.removeAll(forRemoval);
					}
					if (annotationsToAdd != null) {
						Method oldMethod = mg.getMethod();
						MethodGen myGen = new MethodGen(oldMethod, clazz.getClassName(), clazz.getConstantPool(), false);
						for (AnnotationGen a : annotationsToAdd) {
							myGen.addAnnotation(a);
						}
						Method newMethod = myGen.getMethod();
						members.set(memberCounter, new LazyMethodGen(newMethod, clazz));
					}

				}
			}
			checkUnusedDeclareAts(unusedDecams, false);
		}
		return isChanged;
	}
================= fetch private void reportFieldAnnotationWeavingMessage(LazyClassGen clazz, BcelField t 2393bef^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
// TAG: WeavingMessage
private void reportFieldAnnotationWeavingMessage(LazyClassGen clazz, BcelField theField, DeclareAnnotation decaf,
			boolean isRemove) {
		if (!getWorld().getMessageHandler().isIgnoring(IMessage.WEAVEINFO)) {
			world.getMessageHandler().handleMessage(
					WeaveMessage.constructWeavingMessage(
							isRemove ? WeaveMessage.WEAVEMESSAGE_REMOVES_ANNOTATION : WeaveMessage.WEAVEMESSAGE_ANNOTATES,
							new String[] { theField.getFieldAsIs().toString() + "' of type '" + clazz.getName(),
									clazz.getFileName(), decaf.getAnnotationString(), "field", decaf.getAspect().toString(),
									Utility.beautifyLocation(decaf.getSourceLocation()) }));
		}
	}
================= fetch public boolean weave() { 2393bef^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
	 * Weave a class and indicate through the return value whether the class was modified.
	 * 
	 * @return true if the class was modified
	 */
public boolean weave() {
		if (clazz.isWoven() && !clazz.isReweavable()) {
			if (world.getLint().nonReweavableTypeEncountered.isEnabled()) {
				world.getLint().nonReweavableTypeEncountered.signal(clazz.getType().getName(), ty.getSourceLocation());
			}
			// Integer uniqueID = new Integer(rm.hashCode() * deca.hashCode());
			// if (!reportedProblems.contains(uniqueID)) {
			// reportedProblems.add(uniqueID);
			// world.getLint().elementAlreadyAnnotated.signal(new String[] { rm.toString(),
			// world.showMessage(IMessage.ERROR, WeaverMessages.format(WeaverMessages.ALREADY_WOVEN, clazz.getType().getName()),
			// ty.getSourceLocation(), null);
			return false;
		}

		Set<String> aspectsAffectingType = null;
		if (inReweavableMode || clazz.getType().isAspect()) {
			aspectsAffectingType = new HashSet<String>();
		}

		boolean isChanged = false;

		// we want to "touch" all aspects
		if (clazz.getType().isAspect()) {
			isChanged = true;
		}

		WeaverStateInfo typeWeaverState = (world.isOverWeaving() ? getLazyClassGen().getType().getWeaverState() : null);
		// start by munging all typeMungers
		for (ConcreteTypeMunger o : typeMungers) {
			if (!(o instanceof BcelTypeMunger)) {
				// ???System.err.println("surprising: " + o);
				continue;
			}
			BcelTypeMunger munger = (BcelTypeMunger) o;

			if (typeWeaverState != null && typeWeaverState.isAspectAlreadyApplied(munger.getAspectType())) {
				continue;
			}
			boolean typeMungerAffectedType = munger.munge(this);
			if (typeMungerAffectedType) {
				isChanged = true;
				if (inReweavableMode || clazz.getType().isAspect()) {
					aspectsAffectingType.add(munger.getAspectType().getSignature());
				}
			}
		}

		// Weave special half type/half shadow mungers...
		isChanged = weaveDeclareAtMethodCtor(clazz) || isChanged;
		isChanged = weaveDeclareAtField(clazz) || isChanged;

		// XXX do major sort of stuff
		// sort according to: Major: type hierarchy
		// within each list: dominates
		// don't forget to sort addedThisInitialiers according to dominates
		addedSuperInitializersAsList = new ArrayList<IfaceInitList>(addedSuperInitializers.values());
		addedSuperInitializersAsList = PartialOrder.sort(addedSuperInitializersAsList);
		if (addedSuperInitializersAsList == null) {
			throw new BCException("circularity in inter-types");
		}

		// this will create a static initializer if there isn't one
		// this is in just as bad taste as NOPs
		LazyMethodGen staticInit = clazz.getStaticInitializer();
		staticInit.getBody().insert(genInitInstructions(addedClassInitializers, true));

		// now go through each method, and match against each method. This
		// sets up each method's {@link LazyMethodGen#matchedShadows} field,
		// and it also possibly adds to {@link #initializationShadows}.
		List<LazyMethodGen> methodGens = new ArrayList<LazyMethodGen>(clazz.getMethodGens());
		for (LazyMethodGen member : methodGens) {
			if (!member.hasBody()) {
				continue;
			}
			if (world.isJoinpointSynchronizationEnabled() && world.areSynchronizationPointcutsInUse()
					&& member.getMethod().isSynchronized()) {
				transformSynchronizedMethod(member);
			}
			boolean shadowMungerMatched = match(member);
			if (shadowMungerMatched) {
				// For matching mungers, add their declaring aspects to the list
				// that affected this type
				if (inReweavableMode || clazz.getType().isAspect()) {
					aspectsAffectingType.addAll(findAspectsForMungers(member));
				}
				isChanged = true;
			}
		}

		// now we weave all but the initialization shadows
		for (LazyMethodGen methodGen : methodGens) {
			if (!methodGen.hasBody()) {
				continue;
			}
			implement(methodGen);
		}

		// if we matched any initialization shadows, we inline and weave
		if (!initializationShadows.isEmpty()) {
			// Repeat next step until nothing left to inline...cant go on
			// infinetly as compiler will have detected and reported
			// "Recursive constructor invocation"
			List<LazyMethodGen> recursiveCtors = new ArrayList<LazyMethodGen>();
			while (inlineSelfConstructors(methodGens, recursiveCtors)) {
			}
			positionAndImplement(initializationShadows);
		}

		// now proceed with late type mungers
		if (lateTypeMungers != null) {
			for (Iterator<ConcreteTypeMunger> i = lateTypeMungers.iterator(); i.hasNext();) {
				BcelTypeMunger munger = (BcelTypeMunger) i.next();
				if (munger.matches(clazz.getType())) {
					boolean typeMungerAffectedType = munger.munge(this);
					if (typeMungerAffectedType) {
						isChanged = true;
						if (inReweavableMode || clazz.getType().isAspect()) {
							aspectsAffectingType.add(munger.getAspectType().getSignature());
						}
					}
				}
			}
		}

		// FIXME AV - see #75442, for now this is not enough to fix the bug,
		// comment that out until we really fix it
		// // flush to save some memory
		// PerObjectInterfaceTypeMunger.unregisterFromAsAdvisedBy(clazz.getType()
		// );

		// finally, if we changed, we add in the introduced methods.
		if (isChanged) {
			clazz.getOrCreateWeaverStateInfo(inReweavableMode);
			weaveInAddedMethods(); // FIXME asc are these potentially affected
			// by declare annotation?
		}

		if (inReweavableMode) {
			WeaverStateInfo wsi = clazz.getOrCreateWeaverStateInfo(true);
			wsi.addAspectsAffectingType(aspectsAffectingType);
			wsi.setUnwovenClassFileData(ty.getJavaClass().getBytes());
			wsi.setReweavable(true);
		} else {
			clazz.getOrCreateWeaverStateInfo(false).setReweavable(false);
		}

		// tidyup, reduce ongoing memory usage of BcelMethods that hang around
		for (LazyMethodGen mg : methodGens) {
			BcelMethod method = mg.getMemberView();
			if (method != null) {
				method.wipeJoinpointSignatures();
			}
		}

		return isChanged;
	}
================= fetch public static Type makeBcelType(UnresolvedType type) { 2393bef^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java

static String[] makeBcelTypesAsClassNames(UnresolvedType[] types) {
		String[] ret = new String[types.length];
		for (int i = 0, len = types.length; i < len; i++) {
			ret[i] = types[i].getName();
		}
		return ret;
	}
================= fetch public void addParameterAnnotation(int parameterNumber, AnnotationAJ anno) { 2393bef^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

public void addParameterAnnotation(int parameterNumber, AnnotationAJ anno) {
		initialize();
		if (memberView == null) {
			if (newParameterAnnotations == null) {
				// time to create it
				int pcount = getArgumentTypes().length;
				newParameterAnnotations = new AnnotationAJ[pcount][];
				for (int i = 0; i < pcount; i++) {
					if (i == parameterNumber) {
						newParameterAnnotations[i] = new AnnotationAJ[1];
						newParameterAnnotations[i][0] = anno;
					} else {
						newParameterAnnotations[i] = NO_ANNOTATIONAJ;
					}
				}
			} else {
				AnnotationAJ[] currentAnnoArray = newParameterAnnotations[parameterNumber];
				AnnotationAJ[] newAnnoArray = new AnnotationAJ[currentAnnoArray.length + 1];
				System.arraycopy(currentAnnoArray, 0, newAnnoArray, 0, currentAnnoArray.length);
				newAnnoArray[currentAnnoArray.length] = anno;
				newParameterAnnotations[parameterNumber] = newAnnoArray;
			}
		} else {
			memberView.addParameterAnnotation(parameterNumber, anno);
		}
	}
================= fetch public void demote(ResolvedType type) { 2393bef^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java
/**
	 * Force demote a type.
	 */
public void demote(ResolvedType type) {
		typeMap.demote(type);
	}
================= fetch private void registerOptions(final BcelWeaver weaver, final ClassLoader loader, 0c0adc5^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
	 * Configure the weaver according to the option directives TODO av - don't know if it is that good to reuse, since we only allow
	 * a small subset of options in LTW
	 * 
	 * @param weaver
	 * @param loader
	 * @param definitions
	 */
private void registerOptions(final BcelWeaver weaver, final ClassLoader loader, final List<Definition> definitions) {
		StringBuffer allOptions = new StringBuffer();
		for (Definition definition : definitions) {
			allOptions.append(definition.getWeaverOptions()).append(' ');
		}

		Options.WeaverOption weaverOption = Options.parse(allOptions.toString(), loader, getMessageHandler());

		// configure the weaver and world
		// AV - code duplicates AspectJBuilder.initWorldAndWeaver()
		World world = weaver.getWorld();
		setMessageHandler(weaverOption.messageHandler);
		world.setXlazyTjp(weaverOption.lazyTjp);
		world.setXHasMemberSupportEnabled(weaverOption.hasMember);
		world.setTiming(weaverOption.timers, true);
		world.setOptionalJoinpoints(weaverOption.optionalJoinpoints);
		world.setPinpointMode(weaverOption.pinpoint);
		weaver.setReweavableMode(weaverOption.notReWeavable);
		world.performExtraConfiguration(weaverOption.xSet);
		world.setXnoInline(weaverOption.noInline);
		// AMC - autodetect as per line below, needed for AtAjLTWTests.testLTWUnweavable
		world.setBehaveInJava5Way(LangUtil.is15VMOrGreater());
		world.setAddSerialVerUID(weaverOption.addSerialVersionUID);

		/* First load defaults */
		bcelWorld.getLint().loadDefaultProperties();

		/* Second overlay LTW defaults */
		bcelWorld.getLint().adviceDidNotMatch.setKind(null);

		/* Third load user file using -Xlintfile so that -Xlint wins */
		if (weaverOption.lintFile != null) {
			InputStream resource = null;
			try {
				resource = loader.getResourceAsStream(weaverOption.lintFile);
				Exception failure = null;
				if (resource != null) {
					try {
						Properties properties = new Properties();
						properties.load(resource);
						world.getLint().setFromProperties(properties);
					} catch (IOException e) {
						failure = e;
					}
				}
				if (failure != null || resource == null) {
					warn("Cannot access resource for -Xlintfile:" + weaverOption.lintFile, failure);
					// world.getMessageHandler().handleMessage(new Message(
					// "Cannot access resource for -Xlintfile:"+weaverOption.lintFile,
					// IMessage.WARNING,
					// failure,
					// null));
				}
			} finally {
				try {
					resource.close();
				} catch (Throwable t) {
				}
			}
		}

		/* Fourth override with -Xlint */
		if (weaverOption.lint != null) {
			if (weaverOption.lint.equals("default")) {// FIXME should be AjBuildConfig.AJLINT_DEFAULT but yetanother deps..
				bcelWorld.getLint().loadDefaultProperties();
			} else {
				bcelWorld.getLint().setAll(weaverOption.lint);
				if (weaverOption.lint.equals("ignore")) {
					bcelWorld.setAllLintIgnored();
				}
			}
		}
		// TODO proceedOnError option
	}
================= fetch public static WeaverOption parse(String options, ClassLoader laoder, IMessageHan 0c0adc5^:loadtime/src/org/aspectj/weaver/loadtime/Options.java

public static WeaverOption parse(String options, ClassLoader laoder, IMessageHandler imh) {
		WeaverOption weaverOption = new WeaverOption(imh);

		if (LangUtil.isEmpty(options)) {
			return weaverOption;
		}
		// the first option wins
		List flags = LangUtil.anySplit(options, " ");
		Collections.reverse(flags);

		// do a first round on the message handler since it will report the options themselves
		for (Iterator iterator = flags.iterator(); iterator.hasNext();) {
			String arg = (String) iterator.next();
			if (arg.startsWith(OPTIONVALUED_messageHandler)) {
				if (arg.length() > OPTIONVALUED_messageHandler.length()) {
					String handlerClass = arg.substring(OPTIONVALUED_messageHandler.length()).trim();
					try {
						Class handler = Class.forName(handlerClass, false, laoder);
						weaverOption.messageHandler = ((IMessageHandler) handler.newInstance());
					} catch (Throwable t) {
						weaverOption.messageHandler.handleMessage(new Message("Cannot instantiate message handler " + handlerClass,
								IMessage.ERROR, t, null));
					}
				}
			}
		}

		// configure the other options
		for (Iterator iterator = flags.iterator(); iterator.hasNext();) {
			String arg = (String) iterator.next();
			if (arg.equals(OPTION_15)) {
				weaverOption.java5 = true;
			} else if (arg.equalsIgnoreCase(OPTION_lazyTjp)) {
				weaverOption.lazyTjp = true;
			} else if (arg.equalsIgnoreCase(OPTION_noinline)) {
				weaverOption.noInline = true;
			} else if (arg.equalsIgnoreCase(OPTION_addSerialVersionUID)) {
				weaverOption.addSerialVersionUID = true;
			} else if (arg.equalsIgnoreCase(OPTION_noWarn) || arg.equalsIgnoreCase(OPTION_noWarnNone)) {
				weaverOption.noWarn = true;
			} else if (arg.equalsIgnoreCase(OPTION_proceedOnError)) {
				weaverOption.proceedOnError = true;
			} else if (arg.equalsIgnoreCase(OPTION_reweavable)) {
				weaverOption.notReWeavable = false;
			} else if (arg.equalsIgnoreCase(OPTION_showWeaveInfo)) {
				weaverOption.showWeaveInfo = true;
			} else if (arg.equalsIgnoreCase(OPTION_hasMember)) {
				weaverOption.hasMember = true;
			} else if (arg.startsWith(OPTIONVALUED_joinpoints)) {
				if (arg.length() > OPTIONVALUED_joinpoints.length()) {
					weaverOption.optionalJoinpoints = arg.substring(OPTIONVALUED_joinpoints.length()).trim();
				}
			} else if (arg.equalsIgnoreCase(OPTION_verbose)) {
				weaverOption.verbose = true;
			} else if (arg.equalsIgnoreCase(OPTION_debug)) {
				weaverOption.debug = true;
			} else if (arg.equalsIgnoreCase(OPTION_pinpoint)) {
				weaverOption.pinpoint = true;
			} else if (arg.startsWith(OPTIONVALUED_messageHandler)) {
				// handled in first round
			} else if (arg.startsWith(OPTIONVALUED_Xlintfile)) {
				if (arg.length() > OPTIONVALUED_Xlintfile.length()) {
					weaverOption.lintFile = arg.substring(OPTIONVALUED_Xlintfile.length()).trim();
				}
			} else if (arg.startsWith(OPTIONVALUED_Xlint)) {
				if (arg.length() > OPTIONVALUED_Xlint.length()) {
					weaverOption.lint = arg.substring(OPTIONVALUED_Xlint.length()).trim();
				}
			} else if (arg.startsWith(OPTIONVALUED_Xset)) {
				if (arg.length() > OPTIONVALUED_Xlint.length()) {
					weaverOption.xSet = arg.substring(OPTIONVALUED_Xset.length()).trim();
				}
			} else if (arg.equalsIgnoreCase(OPTION_timers)) {
				weaverOption.timers = true;
			} else {
				weaverOption.messageHandler.handleMessage(new Message("Cannot configure weaver with option '" + arg
						+ "': unknown option", IMessage.WARNING, null, null));
			}
		}

		// refine message handler configuration
		if (weaverOption.noWarn) {
			weaverOption.messageHandler.ignore(IMessage.WARNING);
		}
		if (weaverOption.verbose) {
			weaverOption.messageHandler.dontIgnore(IMessage.INFO);
		}
		if (weaverOption.debug) {
			weaverOption.messageHandler.dontIgnore(IMessage.DEBUG);
		}
		if (weaverOption.showWeaveInfo) {
			weaverOption.messageHandler.dontIgnore(IMessage.WEAVEINFO);
		}

		return weaverOption;
	}
================= fetch public static void checkQ() { 0c0adc5^:loadtime/src/org/aspectj/weaver/loadtime/Aj.java
/**
	 * Process the reference queue that contains stale AdaptorKeys - the keys are put on the queue when their classloader referent
	 * is garbage collected and so the associated adaptor (weaver) should be removed from the map
	 */
public static void checkQ() {
		synchronized (adaptorQueue) {
			Object o = adaptorQueue.poll();
			while (o != null) {
				AdaptorKey wo = (AdaptorKey) o;
				// boolean removed =
				WeaverContainer.weavingAdaptors.remove(wo);
				// DBG System.err.println("Evicting key " + wo + " = " + didit);
				o = adaptorQueue.poll();
			}
		}
	}
================= fetch public void initialize() { 0c0adc5^:loadtime/src/org/aspectj/weaver/loadtime/Aj.java
/**
	 * Weave
	 * 
	 * @param className
	 * @param bytes
	 * @param loader
	 * @return weaved bytes
	 */
public byte[] preProcess(String className, byte[] bytes, ClassLoader loader, ProtectionDomain protectionDomain) {
		// TODO AV needs to doc that
		if (loader == null || className == null || loader.getClass().getName().equals(deleLoader)) {
			// skip boot loader, null classes (hibernate), or those from a reflection loader
			return bytes;
		}

		if (trace.isTraceEnabled())
			trace.enter("preProcess", this, new Object[] { className, bytes, loader });
		if (trace.isTraceEnabled())
			trace.event("preProcess", this, new Object[] { loader.getParent(), Thread.currentThread().getContextClassLoader() });

		try {
			synchronized (loader) {

				if (SimpleCacheFactory.isEnabled()) {
					byte[] cacheBytes= laCache.getAndInitialize(className, bytes,loader,protectionDomain);
					if (cacheBytes!=null){
							return cacheBytes;
					}
				}

				WeavingAdaptor weavingAdaptor = WeaverContainer.getWeaver(loader, weavingContext);
				if (weavingAdaptor == null) {
					if (trace.isTraceEnabled())
						trace.exit("preProcess");
					return bytes;
				}
				try {
					weavingAdaptor.setActiveProtectionDomain(protectionDomain);
					byte[] newBytes = weavingAdaptor.weaveClass(className, bytes, false);
					Dump.dumpOnExit(weavingAdaptor.getMessageHolder(), true);
					if (trace.isTraceEnabled())
						trace.exit("preProcess", newBytes);
					if (SimpleCacheFactory.isEnabled()) {
						laCache.put(className, bytes, newBytes);
					}
					return newBytes;
				} finally {
					weavingAdaptor.setActiveProtectionDomain(null);
				}
			}

			/* Don't like to do this but JVMTI swallows all exceptions */
		} catch (Throwable th) {
			trace.error(className, th);
			Dump.dumpWithException(th);
			// FIXME AV wondering if we should have the option to fail (throw runtime exception) here
			// would make sense at least in test f.e. see TestHelper.handleMessage()
			if (trace.isTraceEnabled())
				trace.exit("preProcess", th);
			return bytes;
		} finally {
			CompilationAndWeavingContext.resetForThread();
		}
	}
================= fetch public void testSuperItdCtor_413378() throws Exception { 0c0adc5^:tests/src/org/aspectj/systemtest/ajc174/Ajc174Tests.java

public void testSuperItdCtor_413378() throws Exception {
		runTest("super itd ctor");
	}
================= fetch private boolean mungeNewConstructor(BcelClassWeaver weaver, NewConstructorTypeMu 302c14e^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java

private boolean mungeNewConstructor(BcelClassWeaver weaver, NewConstructorTypeMunger newConstructorTypeMunger) {

		final LazyClassGen currentClass = weaver.getLazyClassGen();
		final InstructionFactory fact = currentClass.getFactory();

		ResolvedMember newConstructorMember = newConstructorTypeMunger.getSyntheticConstructor();
		ResolvedType onType = newConstructorMember.getDeclaringType().resolve(weaver.getWorld());
		if (onType.isRawType()) {
			onType = onType.getGenericType();
		}

		if (onType.isAnnotation()) {
			signalError(WeaverMessages.ITDC_ON_ANNOTATION_NOT_ALLOWED, weaver, onType);
			return false;
		}

		if (onType.isEnum()) {
			signalError(WeaverMessages.ITDC_ON_ENUM_NOT_ALLOWED, weaver, onType);
			return false;
		}

		if (!onType.equals(currentClass.getType())) {
			return false;
		}

		ResolvedMember explicitConstructor = newConstructorTypeMunger.getExplicitConstructor();
		// int declaredParameterCount =
		// newConstructorTypeMunger.getDeclaredParameterCount();
		LazyMethodGen mg = makeMethodGen(currentClass, newConstructorMember);
		mg.setEffectiveSignature(newConstructorTypeMunger.getSignature(), Shadow.ConstructorExecution, true);

		// pr98901
		// For copying the annotations across, we have to discover the real
		// member in the aspect
		// which is holding them.
		if (weaver.getWorld().isInJava5Mode()) {

			ResolvedMember interMethodDispatcher = AjcMemberMaker.postIntroducedConstructor(aspectType, onType,
					newConstructorTypeMunger.getSignature().getParameterTypes());
			AnnotationAJ annotationsOnRealMember[] = null;
			ResolvedMember realMember = getRealMemberForITDFromAspect(aspectType, interMethodDispatcher, true);
			// 266602 - consider it missing to mean that the corresponding aspect had errors
			if (realMember == null) {
				// signalWarning("Unable to apply any annotations attached to " + munger.getSignature(), weaver);
				// throw new BCException("Couldn't find ITD init member '" + interMethodBody + "' on aspect " + aspectType);
			} else {
				annotationsOnRealMember = realMember.getAnnotations();
			}
			if (annotationsOnRealMember != null) {
				for (int i = 0; i < annotationsOnRealMember.length; i++) {
					AnnotationAJ annotationX = annotationsOnRealMember[i];
					AnnotationGen a = ((BcelAnnotation) annotationX).getBcelAnnotation();
					AnnotationGen ag = new AnnotationGen(a, weaver.getLazyClassGen().getConstantPool(), true);
					mg.addAnnotation(new BcelAnnotation(ag, weaver.getWorld()));
				}
			}
			// the below loop fixes the very special (and very stupid)
			// case where an aspect declares an annotation
			// on an ITD it declared on itself.
			List<DeclareAnnotation> allDecams = weaver.getWorld().getDeclareAnnotationOnMethods();
			for (Iterator<DeclareAnnotation> i = allDecams.iterator(); i.hasNext();) {
				DeclareAnnotation decaMC = i.next();
				if (decaMC.matches(explicitConstructor, weaver.getWorld()) && mg.getEnclosingClass().getType() == aspectType) {
					mg.addAnnotation(decaMC.getAnnotation());
				}
			}
		}

		// Might have to remove the default constructor - b275032
		// TODO could have tagged the type munger when the fact we needed to do this was detected earlier
		if (mg.getArgumentTypes().length == 0) {
			LazyMethodGen toRemove = null;
			for (LazyMethodGen object : currentClass.getMethodGens()) {
				if (object.getName().equals("<init>") && object.getArgumentTypes().length == 0) {
					toRemove = object;
				}
			}
			if (toRemove != null) {
				currentClass.removeMethodGen(toRemove);
			}
		}

		currentClass.addMethodGen(mg);
		// weaver.addLazyMethodGen(freshConstructor);

		InstructionList body = mg.getBody();

		// add to body: push arts for call to pre, from actual args starting at
		// 1 (skipping this), going to
		// declared argcount + 1
		UnresolvedType[] declaredParams = newConstructorTypeMunger.getSignature().getParameterTypes();
		Type[] paramTypes = mg.getArgumentTypes();
		int frameIndex = 1;
		for (int i = 0, len = declaredParams.length; i < len; i++) {
			body.append(InstructionFactory.createLoad(paramTypes[i], frameIndex));
			frameIndex += paramTypes[i].getSize();
		}
		// do call to pre
		Member preMethod = AjcMemberMaker.preIntroducedConstructor(aspectType, onType, declaredParams);
		body.append(Utility.createInvoke(fact, null, preMethod));

		// create a local, and store return pre stuff into it.
		int arraySlot = mg.allocateLocal(1);
		body.append(InstructionFactory.createStore(Type.OBJECT, arraySlot));

		// put this on the stack
		body.append(InstructionConstants.ALOAD_0);

		// unpack pre args onto stack
		UnresolvedType[] superParamTypes = explicitConstructor.getParameterTypes();

		for (int i = 0, len = superParamTypes.length; i < len; i++) {
			body.append(InstructionFactory.createLoad(Type.OBJECT, arraySlot));
			body.append(Utility.createConstant(fact, i));
			body.append(InstructionFactory.createArrayLoad(Type.OBJECT));
			body.append(Utility.createConversion(fact, Type.OBJECT, BcelWorld.makeBcelType(superParamTypes[i])));
		}

		// call super/this

		body.append(Utility.createInvoke(fact, null, explicitConstructor));

		// put this back on the stack

		body.append(InstructionConstants.ALOAD_0);

		// unpack params onto stack
		Member postMethod = AjcMemberMaker.postIntroducedConstructor(aspectType, onType, declaredParams);
		UnresolvedType[] postParamTypes = postMethod.getParameterTypes();

		for (int i = 1, len = postParamTypes.length; i < len; i++) {
			body.append(InstructionFactory.createLoad(Type.OBJECT, arraySlot));
			body.append(Utility.createConstant(fact, superParamTypes.length + i - 1));
			body.append(InstructionFactory.createArrayLoad(Type.OBJECT));
			body.append(Utility.createConversion(fact, Type.OBJECT, BcelWorld.makeBcelType(postParamTypes[i])));
		}

		// call post
		body.append(Utility.createInvoke(fact, null, postMethod));

		// don't forget to return!!
		body.append(InstructionConstants.RETURN);

		return true;
	}
================= fetch private void addNeededSuperCallMethods(BcelClassWeaver weaver, ResolvedType onTy 302c14e^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java

private void addNeededSuperCallMethods(BcelClassWeaver weaver, ResolvedType onType, Set<ResolvedMember> neededSuperCalls) {
		LazyClassGen gen = weaver.getLazyClassGen();

		for (Iterator<ResolvedMember> iter = neededSuperCalls.iterator(); iter.hasNext();) {
			ResolvedMember superMethod = iter.next();
			if (weaver.addDispatchTarget(superMethod)) {
				// System.err.println("super type: " +
				// superMethod.getDeclaringType() + ", " + gen.getType());
				boolean isSuper = !superMethod.getDeclaringType().equals(gen.getType());
				String dispatchName;
				if (isSuper) {
					dispatchName = NameMangler.superDispatchMethod(onType, superMethod.getName());
				} else {
					dispatchName = NameMangler.protectedDispatchMethod(onType, superMethod.getName());
				}
				superMethod = superMethod.resolve(weaver.getWorld());
				LazyMethodGen dispatcher = makeDispatcher(gen, dispatchName, superMethod, weaver.getWorld(), isSuper);

				weaver.addLazyMethodGen(dispatcher);
			}
		}
	}
================= fetch public static Test suite() { 302c14e^:tests/src/org/aspectj/systemtest/AllTests17.java

public static Test suite() {
		TestSuite suite = new TestSuite("AspectJ System Test Suite - 1.7");
		// $JUnit-BEGIN$
		suite.addTest(AllTestsAspectJ173.suite()); 
		suite.addTest(AllTestsAspectJ172.suite());
		suite.addTest(AllTestsAspectJ171.suite());
		suite.addTest(AllTestsAspectJ170.suite());
		suite.addTest(AllTests16.suite());
		suite.addTest(AllTests15.suite());
		// $JUnit-END$
		return suite;
	}
Progress : [####------------------------------------] 11%================= fetch public ReferenceTypeDelegate getDelegate(ReferenceType referenceType) { e6cb508^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
/**
	 * See if we can create a delegate from a CompactTypeStructure - TODO better comment
	 */
public ReferenceTypeDelegate getDelegate(ReferenceType referenceType) {
		File f = classesFromName.get(referenceType.getName());
		if (f == null) {
			return null; // not heard of it
		}
		try {
			ClassParser parser = new ClassParser(f.toString());
			return world.buildBcelDelegate(referenceType, parser.parse(), true, false);
		} catch (IOException e) {
			System.err.println("Failed to recover " + referenceType);
			e.printStackTrace();
		}
		return null;
	}
================= fetch public ReferenceType findDerivativeType(ResolvedType[] typeParameters) { 3f6e166^:org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java
/**
	 * Look for a derivative type with the specified type parameters.  This can avoid creating an
	 * unnecessary new (duplicate) with the same information in it.  This method also cleans up
	 * any reference entries that have been null'd by a GC.
	 * 
	 * @param typeParameters the type parameters to use when searching for the derivative type.
	 * @return an existing derivative type or null if there isn't one
	 */
public ReferenceType findDerivativeType(ResolvedType[] typeParameters) {
		List<WeakReference<ReferenceType>> forRemoval = new ArrayList<WeakReference<ReferenceType>>();
		for (WeakReference<ReferenceType> derivativeTypeRef: derivativeTypes) {
			ReferenceType derivativeType = derivativeTypeRef.get();
			if (derivativeType==null) {
				forRemoval.add(derivativeTypeRef);
			} else {
				if (derivativeType.isRawType()) {
					continue;
				}
				if (equal(derivativeType.typeParameters,typeParameters)) {
					return derivativeType; // this escape route wont remove the empty refs
				}
			}
		}
		derivativeTypes.removeAll(forRemoval);
		return null;
	}
================= fetch public void addParent(ResolvedType newParent) { 3f6e166^:org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java

@Override
	public void addParent(ResolvedType newParent) {
		if (this.isRawType()) {
			throw new IllegalStateException(
					"The raw type should never be accumulating new interfaces, they should be on the generic type.  Type is "
							+ this.getName());
		}
		if (newParent.isClass()) {
			newSuperclass = newParent;
			superclassReference = new WeakReference<ResolvedType>(null);
		} else {
			if (newInterfaces == null) {
				newInterfaces = new ResolvedType[1];
				newInterfaces[0] = newParent;
			} else {
				ResolvedType[] existing = getDelegate().getDeclaredInterfaces();
				if (existing != null) {
					for (int i = 0; i < existing.length; i++) {
						if (existing[i].equals(newParent)) {
							return; // already has this interface
						}
					}
				}
				ResolvedType[] newNewInterfaces = new ResolvedType[newInterfaces.length + 1];
				System.arraycopy(newInterfaces, 0, newNewInterfaces, 1, newInterfaces.length);
				newNewInterfaces[0] = newParent;
				newInterfaces = newNewInterfaces;
			}
			if (this.isGenericType()) {
				for (WeakReference<ReferenceType> derivativeTypeRef : derivativeTypes) {
					ReferenceType derivativeType = derivativeTypeRef.get();
					if (derivativeType!=null) {
						derivativeType.parameterizedInterfaces.clear();
					}
				}
			}
			parameterizedInterfaces.clear();
		}
	}
================= fetch public void checkDuplicates(ReferenceType newRt) { 3f6e166^:org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java

public void checkDuplicates(ReferenceType newRt) {
	  List<WeakReference<ReferenceType>> forRemoval = new ArrayList<WeakReference<ReferenceType>>();
	  for (WeakReference<ReferenceType> derivativeTypeReference: derivativeTypes) {
		  ReferenceType derivativeType = derivativeTypeReference.get();
		  if (derivativeType==null) {
			  forRemoval.add(derivativeTypeReference);
		  } else {
			  if (derivativeType.getTypekind()!=newRt.getTypekind()) {
				  continue; // cannot be this one
			  }
			  if (equal2(newRt.getTypeParameters(),derivativeType.getTypeParameters())) {
				  if (TypeMap.useExpendableMap) {
					  throw new IllegalStateException();
				  }
			  }
		  }
	  }
	  derivativeTypes.removeAll(forRemoval);
	}
================= fetch public void setDelegate(ReferenceTypeDelegate delegate) { 3f6e166^:org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java

public void setDelegate(ReferenceTypeDelegate delegate) {
		// Don't copy from BcelObjectType to EclipseSourceType - the context may
		// be tidied (result null'd) after previous weaving
		if (this.delegate != null && this.delegate.copySourceContext()
				&& this.delegate.getSourceContext() != SourceContextImpl.UNKNOWN_SOURCE_CONTEXT) {
			((AbstractReferenceTypeDelegate) delegate).setSourceContext(this.delegate.getSourceContext());
		}
		this.delegate = delegate;
		List<WeakReference<ReferenceType>> forRemoval = new ArrayList<WeakReference<ReferenceType>>();
		for (WeakReference<ReferenceType> derivativeRef : derivativeTypes) {
			ReferenceType derivative = derivativeRef.get();
			if (derivative!=null) {
				derivative.setDelegate(delegate);
			} else {
				forRemoval.add(derivativeRef);
			}
		}
		derivativeTypes.removeAll(forRemoval);

		// If we are raw, we have a generic type - we should ensure it uses the
		// same delegate
		if (isRawType() && getGenericType() != null) {
			ReferenceType genType = (ReferenceType) getGenericType();
			if (genType.getDelegate() != delegate) { // avoids circular updates
				genType.setDelegate(delegate);
			}
		}
		clearParameterizationCaches();
		ensureConsistent();
	}
================= fetch synchronized void addDependentType(ReferenceType dependent) { 3f6e166^:org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java

synchronized void addDependentType(ReferenceType dependent) {
//		checkDuplicates(dependent);
		this.derivativeTypes.add(new WeakReference<ReferenceType>(dependent));
	}
================= fetch public void weaveParentTypeMungers(ResolvedType onType) { ff0859d^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
/**
	 * Weaves new parents and annotations onto a type ("declare parents" and "declare @type")
	 * 
	 * Algorithm: 1. First pass, do parents then do annotations. During this pass record: - any parent mungers that don't match but
	 * have a non-wild annotation type pattern - any annotation mungers that don't match 2. Multiple subsequent passes which go over
	 * the munger lists constructed in the first pass, repeatedly applying them until nothing changes. FIXME asc confirm that
	 * algorithm is optimal ??
	 */
public void weaveParentTypeMungers(ResolvedType onType) {
		if (onType.isRawType()) {
			onType = onType.getGenericType();
		}
		onType.clearInterTypeMungers();

		List<DeclareParents> decpToRepeat = new ArrayList<DeclareParents>();

		boolean aParentChangeOccurred = false;
		boolean anAnnotationChangeOccurred = false;
		// First pass - apply all decp mungers
		for (DeclareParents decp : declareParentsList) {
			boolean typeChanged = applyDeclareParents(decp, onType);
			if (typeChanged) {
				aParentChangeOccurred = true;
			} else {
				decpToRepeat.add(decp);
			}
		}

		// Still first pass - apply all dec @type mungers
		for (DeclareAnnotation decA : xcutSet.getDeclareAnnotationOnTypes()) {
			boolean typeChanged = applyDeclareAtType(decA, onType, true);
			if (typeChanged) {
				anAnnotationChangeOccurred = true;
			}
		}

		while ((aParentChangeOccurred || anAnnotationChangeOccurred) && !decpToRepeat.isEmpty()) {
			anAnnotationChangeOccurred = aParentChangeOccurred = false;
			List<DeclareParents> decpToRepeatNextTime = new ArrayList<DeclareParents>();
			for (Iterator<DeclareParents> iter = decpToRepeat.iterator(); iter.hasNext();) {
				DeclareParents decp = iter.next();
				boolean typeChanged = applyDeclareParents(decp, onType);
				if (typeChanged) {
					aParentChangeOccurred = true;
				} else {
					decpToRepeatNextTime.add(decp);
				}
			}

			for (DeclareAnnotation decA : xcutSet.getDeclareAnnotationOnTypes()) {
				boolean typeChanged = applyDeclareAtType(decA, onType, false);
				if (typeChanged) {
					anAnnotationChangeOccurred = true;
				}
			}
			decpToRepeat = decpToRepeatNextTime;
		}
	}
================= fetch public ResolvedMember lookupResolvedMember(ResolvedMember aMember, boolean allow 4e34477^:org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java
/**
	 * Looks for the first member in the hierarchy matching aMember. This method differs from lookupMember(Member) in that it takes
	 * into account parameters which are type variables - which clearly an unresolved Member cannot do since it does not know
	 * anything about type variables.
	 */
public ResolvedMember lookupResolvedMember(ResolvedMember aMember, boolean allowMissing, boolean eraseGenerics) {
		Iterator<ResolvedMember> toSearch = null;
		ResolvedMember found = null;
		if ((aMember.getKind() == Member.METHOD) || (aMember.getKind() == Member.CONSTRUCTOR)) {
			// toSearch = getMethodsWithoutIterator(true, allowMissing, !eraseGenerics).iterator();
			toSearch = getMethodsIncludingIntertypeDeclarations(!eraseGenerics, true);
		} else {
			assert aMember.getKind() == Member.FIELD;
			toSearch = getFields();
		}
		while (toSearch.hasNext()) {
			ResolvedMember candidate = toSearch.next();
			if (eraseGenerics) {
				if (candidate.hasBackingGenericMember()) {
					candidate = candidate.getBackingGenericMember();
				}
			}
			// OPTIMIZE speed up matches? optimize order of checks
			if (candidate.matches(aMember, eraseGenerics)) {
				found = candidate;
				break;
			}
		}

		return found;
	}
================= fetch public static ResolvedMember perObjectBind(UnresolvedType declaringType) { be5a530^:org.aspectj.matcher/src/org/aspectj/weaver/AjcMemberMaker.java

public static ResolvedMember perObjectBind(UnresolvedType declaringType) {
		return new ResolvedMemberImpl(Member.METHOD, declaringType, PUBLIC_STATIC, NameMangler.PEROBJECT_BIND_METHOD,
				"(Ljava/lang/Object;)V");
	}
================= fetch protected void resolveAnnotationValues(ResolvedType annotationType, IScope scope edb41e3^:org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java
/**
	 * Resolve any annotation values specified, checking they are all well formed (valid names, valid values)
	 * 
	 * @param annotationType the annotation type for which the values have been specified
	 * @param scope the scope within which to resolve type references (eg. Color.GREEN)
	 */
protected void resolveAnnotationValues(ResolvedType annotationType, IScope scope) {
		if (annotationValues == null) {
			return;
		}
		// Check any values specified are OK:
		// - the value names are for valid annotation fields
		// - the specified values are of the correct type
		// - for enums, check the specified values can be resolved in the specified scope
		Map<String,String> replacementValues = new HashMap<String,String>();
		Set<String> keys = annotationValues.keySet();
		ResolvedMember[] ms = annotationType.getDeclaredMethods();
		for (String k: keys) {
			String key = k;
			// a trailing ! indicates the the user expressed key!=value rather than key=value as a match constraint
			if (k.endsWith("!")) {
				key = key.substring(0, k.length() - 1);
			}
			String v = annotationValues.get(k);
			boolean validKey = false;
			for (int i = 0; i < ms.length; i++) {
				ResolvedMember resolvedMember = ms[i];
				if (resolvedMember.getName().equals(key) && resolvedMember.isAbstract()) {
					validKey = true;
					ResolvedType t = resolvedMember.getReturnType().resolve(scope.getWorld());
					if (t.isEnum()) {
						// value must be an enum reference X.Y
						int pos = v.lastIndexOf(".");
						if (pos == -1) {
							IMessage m = MessageUtil.error(
									WeaverMessages.format(WeaverMessages.INVALID_ANNOTATION_VALUE, v, "enum"), getSourceLocation());
							scope.getWorld().getMessageHandler().handleMessage(m);
						} else {
							String typename = v.substring(0, pos);
							ResolvedType rt = scope.lookupType(typename, this).resolve(scope.getWorld());
							v = rt.getSignature() + v.substring(pos + 1); // from 'Color.RED' to 'Lp/Color;RED'
							replacementValues.put(k, v);
							break;
						}
					} else if (t.isPrimitiveType()) {
						if (t.getSignature() == "I") {
							try {
								int value = Integer.parseInt(v);
								replacementValues.put(k, Integer.toString(value));
								break;
							} catch (NumberFormatException nfe) {
								IMessage m = MessageUtil.error(
										WeaverMessages.format(WeaverMessages.INVALID_ANNOTATION_VALUE, v, "int"),
										getSourceLocation());
								scope.getWorld().getMessageHandler().handleMessage(m);
							}
						} else if (t.getSignature() == "F") {
							try {
								float value = Float.parseFloat(v);
								replacementValues.put(k, Float.toString(value));
								break;
							} catch (NumberFormatException nfe) {
								IMessage m = MessageUtil.error(
										WeaverMessages.format(WeaverMessages.INVALID_ANNOTATION_VALUE, v, "float"),
										getSourceLocation());
								scope.getWorld().getMessageHandler().handleMessage(m);
							}

						} else if (t.getSignature() == "Z") {
							if (v.equalsIgnoreCase("true") || v.equalsIgnoreCase("false")) {
								// is it ok !
							} else {
								IMessage m = MessageUtil.error(
										WeaverMessages.format(WeaverMessages.INVALID_ANNOTATION_VALUE, v, "boolean"),
										getSourceLocation());
								scope.getWorld().getMessageHandler().handleMessage(m);
							}
						} else if (t.getSignature() == "S") {
							try {
								short value = Short.parseShort(v);
								replacementValues.put(k, Short.toString(value));
								break;
							} catch (NumberFormatException nfe) {
								IMessage m = MessageUtil.error(
										WeaverMessages.format(WeaverMessages.INVALID_ANNOTATION_VALUE, v, "short"),
										getSourceLocation());
								scope.getWorld().getMessageHandler().handleMessage(m);
							}
						} else if (t.getSignature() == "J") {
							try {
								replacementValues.put(k, Long.toString(Long.parseLong(v)));
								break;
							} catch (NumberFormatException nfe) {
								IMessage m = MessageUtil.error(
										WeaverMessages.format(WeaverMessages.INVALID_ANNOTATION_VALUE, v, "long"),
										getSourceLocation());
								scope.getWorld().getMessageHandler().handleMessage(m);
							}
						} else if (t.getSignature() == "D") {
							try {
								replacementValues.put(k, Double.toString(Double.parseDouble(v)));
								break;
							} catch (NumberFormatException nfe) {
								IMessage m = MessageUtil.error(
										WeaverMessages.format(WeaverMessages.INVALID_ANNOTATION_VALUE, v, "double"),
										getSourceLocation());
								scope.getWorld().getMessageHandler().handleMessage(m);
							}
						} else if (t.getSignature() == "B") {
							try {
								replacementValues.put(k, Byte.toString(Byte.parseByte(v)));
								break;
							} catch (NumberFormatException nfe) {
								IMessage m = MessageUtil.error(
										WeaverMessages.format(WeaverMessages.INVALID_ANNOTATION_VALUE, v, "byte"),
										getSourceLocation());
								scope.getWorld().getMessageHandler().handleMessage(m);
							}
						} else if (t.getSignature() == "C") {
							if (v.length() != 3) { // '?'
								IMessage m = MessageUtil.error(
										WeaverMessages.format(WeaverMessages.INVALID_ANNOTATION_VALUE, v, "char"),
										getSourceLocation());
								scope.getWorld().getMessageHandler().handleMessage(m);
							} else {
								replacementValues.put(k, v.substring(1, 2));
								break;
							}
						} else {
							throw new RuntimeException("Not implemented for " + t);
						}
					} else if (t.equals(ResolvedType.JL_STRING)) {
						// nothing to do, it will be OK
					} else if (t.equals(ResolvedType.JL_CLASS)) {
						String typename = v.substring(0, v.lastIndexOf('.')); // strip off '.class'
						ResolvedType rt = scope.lookupType(typename, this).resolve(scope.getWorld());
						if (rt.isMissing()) {
							IMessage m = MessageUtil.error("Unable to resolve type '" + v + "' specified for value '" + k + "'",
									getSourceLocation());
							scope.getWorld().getMessageHandler().handleMessage(m);
						}
						replacementValues.put(k, rt.getSignature());
						break;
					} else {
						if (t.isAnnotation()) {
							if (v.indexOf("(") != -1) {
								throw new RuntimeException(
										"Compiler limitation: annotation values can only currently be marker annotations (no values): "
												+ v);
							}
							String typename = v.substring(1);
							ResolvedType rt = scope.lookupType(typename, this).resolve(scope.getWorld());
							if (rt.isMissing()) {
								IMessage m = MessageUtil.error(
										"Unable to resolve type '" + v + "' specified for value '" + k + "'", getSourceLocation());
								scope.getWorld().getMessageHandler().handleMessage(m);
							}
							replacementValues.put(k, rt.getSignature());
							break;
						} else {
							throw new RuntimeException("Compiler limitation: annotation value support not implemented for type "
									+ t);
						}
					}
				}
			}
			if (!validKey) {
				IMessage m = MessageUtil.error(WeaverMessages.format(WeaverMessages.UNKNOWN_ANNOTATION_VALUE, annotationType, k),
						getSourceLocation());
				scope.getWorld().getMessageHandler().handleMessage(m);
			}
		}
		annotationValues.putAll(replacementValues);
	}
Progress : [####------------------------------------] 12%================= fetch public String getSignature() { 46f9079^:org.aspectj.matcher/src/org/aspectj/weaver/TypeVariable.java
/**
	 * Return complete signature, e.g. "T extends Number" would return "T:Ljava/lang/Number;" note: MAY INCLUDE P types if bounds
	 * are parameterized types
	 */
public String getSignature() {
		StringBuffer sb = new StringBuffer();
		sb.append(name);
		sb.append(":");
		sb.append(superclass.getSignature());
		if (superInterfaces.length != 0) {
			sb.append(":");
			for (int i = 0; i < superInterfaces.length; i++) {
				UnresolvedType iBound = superInterfaces[i];
				sb.append(iBound.getSignature());
			}
		}
		return sb.toString();
	}
================= fetch public String getSignatureForAttribute() { 46f9079^:org.aspectj.matcher/src/org/aspectj/weaver/TypeVariable.java
/**
	 * @return signature for inclusion in an attribute, there must be no 'P' in it signatures
	 */
public String getSignatureForAttribute() {
		StringBuffer sb = new StringBuffer();
		sb.append(name);
		sb.append(":");
		if (superInterfaces.length == 0) {
			sb.append(((ResolvedType) superclass).getSignatureForAttribute());
		}
		if (superInterfaces.length != 0) {
			sb.append(":");
			for (int i = 0; i < superInterfaces.length; i++) {
				ResolvedType iBound = (ResolvedType) superInterfaces[i];
				sb.append(iBound.getSignatureForAttribute());
			}
		}
		return sb.toString();
	}
================= fetch public void testPSignatures_pr399590() throws Exception { 46f9079^:tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java

public void testPSignatures_pr399590() throws Exception {
		runTest("p signatures 1");
		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(),"Cage");
		String sss = jc.getSignatureAttribute().getSignature();
		assertEquals("<T:LAnimal<+LCage<TT;>;>;>LBar;", sss);
		jc = getClassFrom(ajc.getSandboxDirectory(),"Cage2");
		sss = jc.getSignatureAttribute().getSignature();
		assertEquals("<T:LAnimal2<+LCage2<TT;>;>;>LBar2;Ljava/io/Serializable;", sss);
		jc = getClassFrom(ajc.getSandboxDirectory(),"Cage2");
	}
================= fetch public void testPSignatures_pr399590_2() throws Exception { 46f9079^:tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java
// extends two classes
public void testPSignatures_pr399590_2() throws Exception {
		runTest("p signatures 2");
		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(),"Cage");
		String sss = jc.getSignatureAttribute().getSignature();
		assertEquals("<T:LAnimal<+LCage<TT;LIntf;>;LIntf;>;Q:Ljava/lang/Object;>LBar;", sss);
		jc = getClassFrom(ajc.getSandboxDirectory(),"Cage2");
		sss = jc.getSignatureAttribute().getSignature();
		assertEquals("<T:LAnimal2<+LCage2<TT;LIntf2;>;LIntf2;>;Q:Ljava/lang/Object;>LBar2;Ljava/io/Serializable;", sss);
		jc = getClassFrom(ajc.getSandboxDirectory(),"Cage2");
	}
================= fetch public void testPSignatures_pr399590_3() throws Exception { 46f9079^:tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java
// super
public void testPSignatures_pr399590_3() throws Exception {
		runTest("p signatures 3");
		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(),"Cage");
		String sss = jc.getSignatureAttribute().getSignature();
		assertEquals("<T:LAnimal<-LXXX<TT;>;>;>LBar;", sss);
		jc = getClassFrom(ajc.getSandboxDirectory(),"Cage2");
		sss = jc.getSignatureAttribute().getSignature();
		assertEquals("<T:LAnimal2<-LXXX2<TT;>;>;>LBar2;Ljava/io/Serializable;", sss);
		jc = getClassFrom(ajc.getSandboxDirectory(),"Cage2");
	}
================= fetch public void testPSignatures_pr399590_4() throws Exception { 46f9079^:tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java
// super
public void testPSignatures_pr399590_4() throws Exception {
		runTest("p signatures 4");
		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(),"Cage");
		String sss = jc.getSignatureAttribute().getSignature();
		assertEquals("<T:LAnimal<-LXXX<TT;>;LYYY;>;>LBar;", sss);
		jc = getClassFrom(ajc.getSandboxDirectory(),"Cage2");
		sss = jc.getSignatureAttribute().getSignature();
		assertEquals("<T:LAnimal2<-LXXX2<TT;>;LYYY2;>;>LBar2;Ljava/io/Serializable;", sss);
		jc = getClassFrom(ajc.getSandboxDirectory(),"Cage2");
	}
================= fetch public void testPSignatures_pr399590_5() throws Exception { 46f9079^:tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java
// unbound
public void testPSignatures_pr399590_5() throws Exception {
		runTest("p signatures 5");
		JavaClass jc = getClassFrom(ajc.getSandboxDirectory(),"Cage");
		String sss = jc.getSignatureAttribute().getSignature();
		assertEquals("<T:LAnimal<*>;>LBar;", sss);
		jc = getClassFrom(ajc.getSandboxDirectory(),"Cage2");
		sss = jc.getSignatureAttribute().getSignature();
		assertEquals("<T:LAnimal2<*>;>LBar2;Ljava/io/Serializable;", sss);
		jc = getClassFrom(ajc.getSandboxDirectory(),"Cage2");
	}
================= fetch public UnresolvedType parameterize(Map<String, UnresolvedType> typeBindings) { 4af4b1e^:org.aspectj.matcher/src/org/aspectj/weaver/BoundedReferenceType.java

@Override
	public UnresolvedType parameterize(Map<String, UnresolvedType> typeBindings) {
		if (this.kind == UNBOUND) {
			return this;
		}
		ReferenceType[] parameterizedAdditionalInterfaces = new ReferenceType[additionalInterfaceBounds == null ? 0
				: additionalInterfaceBounds.length];
		for (int i = 0; i < parameterizedAdditionalInterfaces.length; i++) {
			parameterizedAdditionalInterfaces[i] = (ReferenceType) additionalInterfaceBounds[i].parameterize(typeBindings);
		}
		if (this.kind == EXTENDS) {
			return new BoundedReferenceType((ReferenceType) getUpperBound().parameterize(typeBindings), true, world,
					parameterizedAdditionalInterfaces);
		} else {
			// (this.kind == SUPER)
			return new BoundedReferenceType((ReferenceType) getLowerBound().parameterize(typeBindings), false, world,
					parameterizedAdditionalInterfaces);
		}
	}
================= fetch public boolean hasAnnotation(UnresolvedType ofType) { d524403^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java
/**
	 * WARNING: This method does not have a complete implementation.
	 * 
	 * The aim is that it converts Eclipse annotation objects to the AspectJ form of annotations (the type AnnotationAJ). The
	 * AnnotationX objects returned are wrappers over either a Bcel annotation type or the AspectJ AnnotationAJ type. The minimal
	 * implementation provided here is for processing the RetentionPolicy and Target annotation types - these are the only ones
	 * which the weaver will attempt to process from an EclipseSourceType.
	 * 
	 * More notes: The pipeline has required us to implement this. With the pipeline we can be weaving a type and asking questions
	 * of annotations before they have been turned into Bcel objects - ie. when they are still in EclipseSourceType form. Without
	 * the pipeline we would have converted everything to Bcel objects before proceeding with weaving. Because the pipeline won't
	 * start weaving until all aspects have been compiled and the fact that no AspectJ constructs match on the values within
	 * annotations, this code only needs to deal with converting system annotations that the weaver needs to process
	 * (RetentionPolicy, Target).
	 */
public AnnotationAJ[] getAnnotations() {
		if (annotations != null) {
			return annotations; // only do this once
		}
		if (!annotationsFullyResolved) {
			TypeDeclaration.resolveAnnotations(declaration.staticInitializerScope, declaration.annotations, binding);
			annotationsFullyResolved = true;
		}
		Annotation[] as = declaration.annotations;
		if (as == null || as.length == 0) {
			annotations = AnnotationAJ.EMPTY_ARRAY;
		} else {
			annotations = new AnnotationAJ[as.length];
			for (int i = 0; i < as.length; i++) {
				annotations[i] = convertEclipseAnnotation(as[i], factory.getWorld());
			}
		}
		return annotations;
	}
================= fetch public boolean hasUnsatisfiedDependency(ResolvedType aspectType) { 96ebaae^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java

@Override
	public boolean hasUnsatisfiedDependency(ResolvedType aspectType) {
		if (!aspectRequiredTypesProcessed) {
			if (aspectRequiredTypes != null) {
				List<String> forRemoval = new ArrayList<String>();
				for (Map.Entry<String, String> entry : aspectRequiredTypes.entrySet()) {
					ResolvedType rt = this.resolve(UnresolvedType.forName(entry.getValue()));
					if (!rt.isMissing()) {
						forRemoval.add(entry.getKey());
					} else {
						if (!getMessageHandler().isIgnoring(IMessage.INFO)) {
							getMessageHandler().handleMessage(
									MessageUtil.info("deactivating aspect '" + aspectType.getName() + "' as it requires type '"
											+ rt.getName() + "' which cannot be found on the classpath"));
						}
					}
				}
				for (String key : forRemoval) {
					aspectRequiredTypes.remove(key);
				}
			}
			aspectRequiredTypesProcessed = true;
		}
		if (aspectRequiredTypes == null) {
			return false;
		}
		return aspectRequiredTypes.containsKey(aspectType.getName());
	}
================= fetch public void addAspectRequires(String name, String requiredType) { 96ebaae^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java

public void addAspectRequires(String name, String requiredType) {
		if (aspectRequiredTypes == null) {
			aspectRequiredTypes = new HashMap<String, String>();
		}
		aspectRequiredTypes.put(name, requiredType);
	}
================= fetch public void testAnnotationValueError_pr389752_2() { 96ebaae^:tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java

public void testAnnotationValueError_pr389752_2() {
		runTest("annotation value error 2");
	}
================= fetch public void testInconsistentClassFile_pr389750() { 96ebaae^:tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java

public void testInconsistentClassFile_pr389750() {
		runTest("inconsistent class file");
	}
================= fetch public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, I 3e5af0f^:org.aspectj.matcher/src/org/aspectj/weaver/patterns/AndPointcut.java

public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, IntMap bindings) {
		AndPointcut ret = new AndPointcut(left.concretize(inAspect, declaringType, bindings), right.concretize(inAspect,
				declaringType, bindings));
		ret.copyLocationFrom(this);
		return ret;
	}
================= fetch public Pointcut parameterizeWith(Map typeVariableMap, World w) { 3e5af0f^:org.aspectj.matcher/src/org/aspectj/weaver/patterns/AndPointcut.java

public Pointcut parameterizeWith(Map typeVariableMap, World w) {
		AndPointcut ret = new AndPointcut(left.parameterizeWith(typeVariableMap, w), right.parameterizeWith(typeVariableMap, w));
		ret.copyLocationFrom(this);
		return ret;
	}
================= fetch protected String getCommonSuperClass(final String type1, final String type2) { fc55431^:weaver/src/org/aspectj/weaver/bcel/asm/StackMapAdder.java
// Implementation of getCommonSuperClass() that avoids Class.forName()
protected String getCommonSuperClass(final String type1, final String type2) {

			ResolvedType resolvedType1 = world.resolve(UnresolvedType.forName(type1.replace('/', '.')));
			ResolvedType resolvedType2 = world.resolve(UnresolvedType.forName(type2.replace('/', '.')));

			if (resolvedType1.isAssignableFrom(resolvedType2)) {
				return type1;
			}

			if (resolvedType2.isAssignableFrom(resolvedType1)) {
				return type2;
			}

			if (resolvedType1.isInterface() || resolvedType2.isInterface()) {
				return "java/lang/Object";
			} else {
				do {
					resolvedType1 = resolvedType1.getSuperclass();
				} while (!resolvedType1.isAssignableFrom(resolvedType2));
				return resolvedType1.getName().replace('.', '/');
			}
		}
Progress : [#####-----------------------------------] 13%================= fetch protected void writeIndex (File indexFile, Collection<? extends IndexEntry> entr df1823b^:weaver/src/org/aspectj/weaver/tools/cache/AbstractIndexedFileCacheBacking.java

protected void writeIndex (File indexFile, Collection<? extends IndexEntry> entries) throws IOException {
        File    indexDir=indexFile.getParentFile();
        if ((!indexDir.exists()) && (!indexDir.mkdirs())) {
            throw new IOException("Failed to create path to " + indexFile.getAbsolutePath());
        }

        int             numEntries=LangUtil.isEmpty(entries) ? 0 : entries.size();
        IndexEntry[]    entryValues=(numEntries <= 0) ? null : entries.toArray(new IndexEntry[numEntries]);
        // if no entries, simply delete the index file
        if (LangUtil.isEmpty(entryValues)) {
            if (indexFile.exists() && (!indexFile.delete())) {
                throw new StreamCorruptedException("Failed to clean up index file at " + indexFile.getAbsolutePath());
            }

            return;
        }

        ObjectOutputStream oos=new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(indexFile), 4096));
        try {
            oos.writeObject(entryValues);
        } finally {
            close(oos, indexFile);
        }
    }
================= fetch public DefaultFileCacheBackingTest () { df1823b^:weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java

================= fetch public File getIndexFile () { df1823b^:weaver/src/org/aspectj/weaver/tools/cache/AbstractIndexedFileCacheBacking.java

protected Map<String, IndexEntry> readIndex () {
    	return readIndex(getCacheDirectory(), getIndexFile());
    }
================= fetch public static Test suite() { df1823b^:weaver/testsrc/org/aspectj/weaver/tools/cache/CacheTests.java

public static Test suite() {
		TestSuite suite = new TestSuite(CacheTests.class.getName());
		suite.addTestSuite(SimpleClassCacheTest.class);
		suite.addTestSuite(WeavedClassCacheTest.class);
		suite.addTestSuite(DefaultCacheKeyResolverTest.class);
		suite.addTestSuite(DefaultFileCacheBackingTest.class);
		return suite;
	}
================= fetch public static boolean isEmpty(Object[] ra) { df1823b^:util/src/org/aspectj/util/LangUtil.java
/** @return ((null == ra) || (0 == ra.length)) */
public static boolean isEmpty(Object[] ra) {
		return ((null == ra) || (0 == ra.length));
	}
================= fetch public void dontIgnore(IMessage.Kind kind) { df1823b^:weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java

public void dontIgnore(IMessage.Kind kind) {
		}
================= fetch public void ignore(IMessage.Kind kind) { df1823b^:weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java

public void ignore(IMessage.Kind kind) {
		}
================= fetch public void put(CachedClassEntry entry, byte[] originalBytes) { df1823b^:weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java

public void put(CachedClassEntry entry, byte[] originalBytes) {
		File	cacheDirectory = getCacheDirectory();
		String	refKey = entry.getKey();
		IndexEntry ie = index.get(refKey);
		File 	cacheFile = new File(cacheDirectory, refKey);
		final boolean	writeEntryBytes;
		// check if original bytes changed or the ignored/generated flags
		if ((ie != null)
		 && ((ie.ignored != entry.isIgnored()) || (ie.generated != entry.isGenerated()) || (crc(originalBytes) != ie.crcClass))) {
			delete(cacheFile);
			writeEntryBytes = true;
		} else {
			writeEntryBytes = !cacheFile.exists();
		}

		if (writeEntryBytes) {
			ie = new IndexEntry();
			ie.key = entry.getKey();
			ie.generated = entry.isGenerated();
			ie.ignored = entry.isIgnored();
			if (!entry.isIgnored()) {
				ie.crcClass = crc(originalBytes);
				ie.crcWeaved = write(cacheFile, entry.getBytes());
			}
			addIndexEntry(ie);
		}
	}
================= fetch public void testGetCachingClassHandler() throws Exception { df1823b^:weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java

public void testGetCachingClassHandler() throws Exception {
		WeavedClassCache cache = createCache();
		GeneratedClassHandler newHandle = cache.getCachingClassHandler();
		assertTrue(generatedClassHandler != newHandle);
		assertTrue(newHandle instanceof GeneratedCachedClassHandler);
	}
================= fetch private boolean weaveAndDefineConceteAspects() { 9a3cc2b^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java

boolean weaveAndDefineConceteAspects() {
		if (trace.isTraceEnabled()) {
			trace.enter("weaveAndDefineConceteAspects", this, concreteAspects);
		}
		boolean success = true;

		for (ConcreteAspectCodeGen gen : concreteAspects) {
			String name = gen.getClassName();
			byte[] bytes = gen.getBytes();

			try {
				byte[] newBytes = weaveClass(name, bytes, true);
				this.generatedClassHandler.acceptClass(name, newBytes);
			} catch (IOException ex) {
				trace.error("weaveAndDefineConceteAspects", ex);
				error("exception weaving aspect '" + name + "'", ex);
			}
		}

		if (trace.isTraceEnabled()) {
			trace.exit("weaveAndDefineConceteAspects", success);
		}
		return success;
	}
================= fetch private void addIndexEntry(IndexEntry ie) { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java

private void addIndexEntry(IndexEntry ie) {
		synchronized (LOCK) {
			index.put(ie.key, ie);
			writeIndex();
		}
	}
================= fetch private void readIndex() { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java

private void readIndex() {
		synchronized (LOCK) {
			IndexEntry[] idx = readIndex(new File(cacheDirectory, INDEX_FILE));
			for (IndexEntry ie : idx) {
				File cacheFile = new File(cacheDirectory, ie.key);
				if (cacheFile.canRead() || ie.ignored) {
					index.put(ie.key, ie);
				}
			}
		}
	}
================= fetch private void removeIndexEntry(String key) { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java

private void removeIndexEntry(String key) {
		synchronized (LOCK) {
			index.remove(key);
			writeIndex();
		}
	}
================= fetch private void writeIndex() { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java

private void writeIndex() {
		synchronized (LOCK) {
			if (!cacheDirectory.exists())
				cacheDirectory.mkdirs();
			File indexFile = new File(cacheDirectory, INDEX_FILE);
			FileOutputStream fos = null;
			ObjectOutputStream oos = null;
			try {
				delete(indexFile);
				fos = new FileOutputStream(indexFile);
				oos = new ObjectOutputStream(fos);
				oos.writeObject(index.values().toArray(new IndexEntry[0]));
			} catch (Exception e) {
				throw new RuntimeException(e);
			} finally {
				close(fos, indexFile);
				close(oos, indexFile);
			}
		}
	}
================= fetch protected Boolean initialValue() { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java
/**
	 * Weave a class using aspects previously supplied to the adaptor.
	 * 
	 * @param name the name of the class
	 * @param bytes the class bytes
	 * @param mustWeave if true then this class *must* get woven (used for concrete aspects generated from XML)
	 * @return the woven bytes
	 * @exception IOException weave failed
	 */
public byte[] weaveClass(String name, byte[] bytes, boolean mustWeave) throws IOException {
		if (trace == null) {
			// Pr231945: we are likely to be under tomcat and ENABLE_CLEAR_REFERENCES hasn't been set
			System.err
					.println("AspectJ Weaver cannot continue to weave, static state has been cleared.  Are you under Tomcat? In order to weave '"
							+ name
							+ "' during shutdown, 'org.apache.catalina.loader.WebappClassLoader.ENABLE_CLEAR_REFERENCES=false' must be set (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=231945).");
			return bytes;
		}
		if (weaverRunning.get()) {
			// System.out.println("AJC: avoiding re-entrant call to transform " + name);
			return bytes;
		}
		try {
			weaverRunning.set(true);
			if (trace.isTraceEnabled()) {
				trace.enter("weaveClass", this, new Object[] { name, bytes });
			}

			if (!enabled) {
				if (trace.isTraceEnabled()) {
					trace.exit("weaveClass", false);
				}
				return bytes;
			}

			boolean debugOn = !messageHandler.isIgnoring(Message.DEBUG);

			try {
				delegateForCurrentClass = null;
				name = name.replace('/', '.');
				if (couldWeave(name, bytes)) {
					if (accept(name, bytes)) {

						// Determine if we have the weaved class cached
						CachedClassReference cacheKey = null;
						byte[] original_bytes = bytes;
						if (cache != null && !mustWeave) {
							cacheKey = cache.createCacheKey(name, bytes);
							CachedClassEntry entry = cache.get(cacheKey);
							if (entry != null) {
								// If the entry has been explicitly ignored
								// return the original bytes
								if (entry.isIgnored()) {
									return bytes;
								}
								return entry.getBytes();
							}
						}

						// TODO @AspectJ problem
						// Annotation style aspects need to be included regardless in order to get
						// a valid aspectOf()/hasAspect() generated in them. However - if they are excluded
						// (via include/exclude in aop.xml) they really should only get aspectOf()/hasAspect()
						// and not be included in the full set of aspects being applied by 'this' weaver
						if (debugOn) {
							debug("weaving '" + name + "'");
						}
						bytes = getWovenBytes(name, bytes);
						// temporarily out - searching for @Aspect annotated types is a slow thing to do - we should
						// expect the user to name them if they want them woven - just like code style
						// } else if (shouldWeaveAnnotationStyleAspect(name, bytes)) {
						// if (mustWeave) {
						// if (bcelWorld.getLint().mustWeaveXmlDefinedAspects.isEnabled()) {
						// bcelWorld.getLint().mustWeaveXmlDefinedAspects.signal(name, null);
						// }
						// }
						// // an @AspectJ aspect needs to be at least munged by the aspectOf munger
						// if (debugOn) {
						// debug("weaving '" + name + "'");
						// }
						// bytes = getAtAspectJAspectBytes(name, bytes);

						// Add the weaved class to the cache only if there
						// has been an actual change
						// JVK: Is there a better way to check if the class has
						// been transformed without carrying up some value
						// from the depths?
						if (cacheKey != null) {
							// If no transform has been applied, mark the class
							// as ignored.
							if (Arrays.equals(original_bytes, bytes)) {
								cache.ignore(cacheKey);
							} else {
								cache.put(cacheKey, bytes);
							}
						}
					} else if (debugOn) {
						debug("not weaving '" + name + "'");
					}
				} else if (debugOn) {
					debug("cannot weave '" + name + "'");
				}
			} finally {
				delegateForCurrentClass = null;
			}

			if (trace.isTraceEnabled()) {
				trace.exit("weaveClass", bytes);
			}
			return bytes;
		} finally {
			weaverRunning.set(false);
		}
	}
================= fetch protected CachedClassReference(String key, CacheKeyResolver resolver) { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/CachedClassReference.java

================= fetch protected DefaultFileCacheBacking(File cacheDirectory, CacheKeyResolver resolver 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java

================= fetch protected WeavedClassCache(GeneratedClassHandler existingClassHandler, 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java

================= fetch protected long write(File file, byte[] bytes) { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java

protected long write(File file, byte[] bytes) {
		if (file.exists()) {
			return -1;
		}
		synchronized (LOCK) {
			if (file.exists()) {
				return -1;
			}
			OutputStream out = null;
			ObjectOutputStream crcOut = null;
			CRC32 checksum = new CRC32();
			try {
				out = new FileOutputStream(file);
				out.write(bytes);
				checksum.update(bytes);
				return checksum.getValue();
			} catch (FileNotFoundException e) {
				MessageUtil.error("Error writing (File Not Found) " + file.getName() + ": " + e.getLocalizedMessage());
			} catch (IOException e) {
				MessageUtil.error("Error writing " + file.getName());

			} finally {
				close(out, file);
			}
			// delete the file if there was an exception writing it
			delete(file);
		}
		return -1;
	}
================= fetch protected static void delete(File file) { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java

protected static void delete(File file) {
		if (file.exists()) {
			file.delete();
		}
	}
================= fetch public CacheBacking createBacking(String scope) { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/DefaultCacheFactory.java

public CacheBacking createBacking(String scope) {
		return DefaultFileCacheBacking.createBacking(scope, createResolver());
	}
================= fetch public CacheStatistics getStats() { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java
/**
	 * Get all weaved classes which have been cached
	 *
	 * @return
	 */
protected CachedClassEntry[] getWeavedClasses() {
		return getEntries(resolver.getWeavedRegex());
	}
================= fetch public CachedClassEntry get(CachedClassReference ref) { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java

CachedClassEntry get(CachedClassReference ref) {
		IndexEntry ie = index.get(ref.getKey());
		if (ie != null && ie.ignored) {
			return new CachedClassEntry(ref, WeavedClassCache.ZERO_BYTES, CachedClassEntry.EntryType.IGNORED);
		}
		File cacheFile = new File(cacheDirectory, ref.getKey());
		if (cacheFile.canRead()) {
			if (ie == null) {
				// no index, delete
				delete(cacheFile);
				return null;
			}
			byte[] bytes = read(cacheFile, ie.crc);
			if (bytes != null) {
				if (!ie.generated) {
					return new CachedClassEntry(ref, bytes, CachedClassEntry.EntryType.WEAVED);
				} else {
					return new CachedClassEntry(ref, bytes, CachedClassEntry.EntryType.GENERATED);
				}
			}
		}
		return null;
	}
================= fetch public CachedClassEntry get(CachedClassReference ref) { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java
/**
	 * Get a cache value
	 *
	 * @param ref reference to the cache entry, created through createCacheKey
	 * @return the CacheEntry, or null if no entry exists in the cache
	 */
public CachedClassEntry get(CachedClassReference ref) {
		CachedClassEntry entry = backing.get(ref);
		if (entry == null) {
			stats.miss();
		} else {
			stats.hit();
			if (entry.isGenerated()) stats.generated();
			if (entry.isWeaved()) stats.weaved();
			if (entry.isIgnored()) stats.ignored();
		}
		return entry;
	}
================= fetch public CachedClassEntry get(CachedClassReference ref) { 9a3cc2b^:weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java

public CachedClassEntry get(CachedClassReference ref) {
			return cache.get(ref.getKey());
		}
================= fetch public ClassLoaderWeavingAdaptor(final ClassLoader deprecatedLoader, final IWeav 9a3cc2b^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java

================= fetch public GeneratedCachedClassHandler(WeavedClassCache cache, GeneratedClassHandler 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/GeneratedCachedClassHandler.java

================= fetch public String getClassLoaderName() { 9a3cc2b^:loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java
/**
	 * Implement method from WeavingClassLoader
	 */
public URL[] getAspectURLs() {
		return aspectURLs;
	}
================= fetch public String getClassName() { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/CachedClassReference.java

public String getClassName() {
		return className;
	}
================= fetch public boolean accept(File file, String s) { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java

public String[] getKeys(final String regex) {
		File[] files = cacheDirectory.listFiles(new FilenameFilter() {
			public boolean accept(File file, String s) {
				if (s.matches(regex)) {
					return true;
				}
				return false;
			}
		});
		if (files == null) {
			return new String[0];
		}
		String[] keys = new String[files.length];
		for (int i = 0; i < files.length; i++) {
			keys[i] = files[i].getName();
		}
		return keys;
	}
================= fetch public static CacheBacking createBacking(File cacheDir, CacheKeyResolver resolve 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java

public static IndexEntry[] readIndex(File indexFile) {
		IndexEntry[] iea = new IndexEntry[0];
		FileInputStream fis = null;
		ObjectInputStream ois = null;
		try {
			if (!indexFile.canRead()) {
				return iea;
			}
			fis = new FileInputStream(indexFile);
			ois = new ObjectInputStream(fis);
			iea = (IndexEntry[]) ois.readObject();
		} catch (Exception e) {
			delete(indexFile);
		} finally {
			close(fis, indexFile);
			close(ois, indexFile);
		}
		return iea;
	}
================= fetch public static CacheBacking createBacking(String scope, CacheKeyResolver resolver 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java

public String[] getKeys(final String regex) {
		File[] files = cacheDirectory.listFiles(new FilenameFilter() {
================= fetch public static boolean isEmpty(Collection<?> collection) { 9a3cc2b^:util/src/org/aspectj/util/LangUtil.java
/**
	 * Split string as classpath, delimited at File.pathSeparator. Entries are not trimmed, but empty entries are ignored.
	 * 
	 * @param classpath the String to split - may be null or empty
	 * @return String[] of classpath entries
	 */
public static String[] splitClasspath(String classpath) {
		if (LangUtil.isEmpty(classpath)) {
			return new String[0];
		}
		StringTokenizer st = new StringTokenizer(classpath, File.pathSeparator);
		ArrayList<String> result = new ArrayList<String>(st.countTokens());
		while (st.hasMoreTokens()) {
			String entry = st.nextToken();
			if (!LangUtil.isEmpty(entry)) {
				result.add(entry);
			}
		}
		return (String[]) result.toArray(new String[0]);
	}
================= fetch public static boolean isEnabled() { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java
/**
	 * Has caching been enabled through the System property,
	 * WEAVED_CLASS_CACHE_ENABLED
	 *
	 * @return true if caching is enabled
	 */
public static boolean isEnabled() {
		return System.getProperty(WEAVED_CLASS_CACHE_ENABLED) != null;
	}
================= fetch public void acceptClass(String name, byte[] bytes) { 9a3cc2b^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java

================= fetch public void acceptClass(String name, byte[] bytes) { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/GeneratedCachedClassHandler.java

public void acceptClass(String name, byte[] bytes) {
		// The cache expects classNames in dot form
		CachedClassReference ref = cache.createGeneratedCacheKey(name.replace('/', '.'));
		cache.put(ref, bytes);
		if (nextGeneratedClassHandler != null) {
			nextGeneratedClassHandler.acceptClass(name, bytes);
		}
	}
================= fetch public void acceptResult(IUnwovenClassFile result) { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java

public IWeaveRequestor getRequestor() {
			return new IWeaveRequestor() {

				public void acceptResult(IUnwovenClassFile result) {
					if (wovenClass == null) {
						wovenClass = result;
						String name = result.getClassName();
						if (shouldDump(name.replace('/', '.'), false)) {
							dump(name, result.getBytes(), false);
						}
					} else {
						// Classes generated by weaver e.g. around closure advice
						String className = result.getClassName();
						generatedClasses.put(className, result);
						generatedClasses.put(wovenClass.getClassName(), result);
						generatedClassHandler.acceptClass(className, result.getBytes());
					}
				}
================= fetch public void clear() { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java

public void clear() {
		synchronized (LOCK) {
			FileUtil.deleteContents(cacheDirectory);
		}
	}
================= fetch public void clear() { 9a3cc2b^:weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java

public void clear() {
			cache.clear();
		}
================= fetch public void ignore(CachedClassReference ref) { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java
/**
	 * Put a cache entry to indicate that the class should not be
	 * weaved; the original bytes of the class should be used.
	 *
	 * @param ref
	 */
public void ignore(CachedClassReference ref) {
		stats.putIgnored();
		backing.put(new CachedClassEntry(ref, ZERO_BYTES, CachedClassEntry.EntryType.IGNORED));
	}
================= fetch public void ignore(IMessage.Kind kind) { 9a3cc2b^:weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java

public void ignore(IMessage.Kind kind) {
		}
================= fetch public void put(CachedClassEntry entry) { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java

public void put(CachedClassEntry entry) {
		File cacheFile = new File(cacheDirectory, entry.getKey());
		if (!cacheFile.exists()) {
			IndexEntry ie = new IndexEntry();
			ie.key = entry.getKey();
			ie.generated = entry.isGenerated();
			ie.ignored = entry.isIgnored();
			if (!entry.isIgnored()) {
				ie.crc = write(cacheFile, entry.getBytes());
			}
			addIndexEntry(ie);
		}
	}
================= fetch public void put(CachedClassReference ref, byte[] weavedBytes) { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java
/**
	 * Put a class in the cache
	 *
	 * @param ref		 reference to the entry, as created through createCacheKey
	 * @param weavedBytes bytes to cache
	 */
public void put(CachedClassReference ref, byte[] weavedBytes) {
		CachedClassEntry.EntryType type = CachedClassEntry.EntryType.WEAVED;
		if (ref.getKey().matches(resolver.getGeneratedRegex())) {
			type = CachedClassEntry.EntryType.GENERATED;
		}
		backing.put(new CachedClassEntry(ref, weavedBytes, type));
		stats.put();
	}
================= fetch public void remove(CachedClassReference ref) { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java

protected byte[] read(File file, long expectedCRC) {
		CRC32 checksum = new CRC32();
		synchronized (LOCK) {
			FileInputStream fis = null;
			try {
				fis = new FileInputStream(file);
				byte[] bytes = FileUtil.readAsByteArray(fis);
				checksum.update(bytes);
				if (checksum.getValue() == expectedCRC) {
					return bytes;
				}
			} catch (FileNotFoundException e) {
				// file disappeared
				MessageUtil.error("File not found " + file.getName());
			} catch (IOException e) {
				MessageUtil.error("Error reading cached class " + e.getLocalizedMessage());
			} finally {
				close(fis, file);
			}
			// delete the file if there was an exception reading it
			// or the expected checksum does not match
			delete(file);
		}
		return null;
	}
================= fetch public void reset() { 9a3cc2b^:weaver/src/org/aspectj/weaver/tools/cache/CacheStatistics.java

public void reset() {
		hits = 0;
		misses = 0;
		weaved = 0;
		generated = 0;
		ignored = 0;
		puts = 0;
		puts_ignored = 0;
	}
================= fetch public void setUp() throws Exception { 9a3cc2b^:weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java

public void setUp() throws Exception {
		if (root == null) {
			File tempFile = File.createTempFile("aspectj", "test");
			File tempDir = tempFile.getParentFile();
			root = new File(tempDir, "aspectj-test-cache");
		}
	}
================= fetch public void testCache() throws Exception { 9a3cc2b^:weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java

public void testCache() throws Exception {
		reset();
		WeavedClassCache cache = createCache();
		CacheStatistics stats = cache.getStats();
		CachedClassReference ref = cache.createCacheKey(FAKE_CLASS, FAKE_BYTES);
		assertNull(cache.get(ref));
		cache.put(ref, FAKE_BYTES);
		assertNotNull(cache.get(ref));

		assertEquals(new String(FAKE_BYTES), new String(cache.get(ref).getBytes()));

		assertEquals(1, cache.getWeavedClasses().length);
		assertEquals(ref.getKey(), cache.getWeavedClasses()[0].getKey());

		ref = cache.createGeneratedCacheKey(FAKE_CLASS);
		assertNull(cache.get(ref));
		cache.put(ref, FAKE_BYTES);
		assertNotNull(cache.get(ref));
		assertEquals(new String(FAKE_BYTES), new String(cache.get(ref).getBytes()));

		assertEquals(1, cache.getGeneratedClasses().length);
		assertEquals(ref.getKey(), cache.getGeneratedClasses()[0].getKey());

		assertEquals(4, stats.getHits());
		assertEquals(2, stats.getMisses());


	}
================= fetch public void testClear() { 9a3cc2b^:weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java

public void testClear() {
		CacheBacking backing = DefaultFileCacheBacking.createBacking(root, resolver);
		backing.put(new CachedClassEntry(fakeRef, FAKE_BYTES, CachedClassEntry.EntryType.WEAVED));
		assertNotNull(backing.get(fakeRef));
		backing.clear();
		assertNull(backing.get(fakeRef));
	}
================= fetch public void testCreateBacking() throws Exception { 9a3cc2b^:weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java

public void testCreateBacking() throws Exception {
		CacheBacking backing = DefaultFileCacheBacking.createBacking(root, resolver);
		assertNotNull(backing);
		assertTrue(root.exists());
		assertTrue(root.isDirectory());
	}
================= fetch public void testGet() throws Exception { 9a3cc2b^:weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java

public void testGet() throws Exception {
		CacheBacking backing = DefaultFileCacheBacking.createBacking(root, resolver);
		assertNull(backing.get(fakeRef));
		backing.put(new CachedClassEntry(fakeRef, FAKE_BYTES, CachedClassEntry.EntryType.WEAVED));
		File cachedFile = new File(root, fakeRef.getKey());
		assertTrue(cachedFile.isFile());
		assertEquals(FAKE_BYTES.length, cachedFile.length());
		CRC32 expectedCRC = new CRC32();
		expectedCRC.update(FAKE_BYTES);
		assertTrue(indexEntryExists(fakeRef.getKey(), expectedCRC.getValue()));
		CachedClassEntry entry = backing.get(fakeRef);
		assertEquals(FAKE_BYTES.length, entry.getBytes().length);

	}
================= fetch public void testGetCachingClassHandler() throws Exception { 9a3cc2b^:weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java

public void testGetCachingClassHandler() throws Exception {
		WeavedClassCache cache = createCache();
		GeneratedClassHandler newHandle = cache.getCachingClassHandler();
		assertTrue(generatedClassHandler != newHandle);
		assertTrue(newHandle instanceof GeneratedCachedClassHandler);
	}
================= fetch public void testGetKeys() throws Exception { 9a3cc2b^:weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java

public void testGetKeys() throws Exception {
		CacheBacking backing = DefaultFileCacheBacking.createBacking(root, resolver);
		backing.put(createTestEntry("apple"));
		backing.put(createTestEntry("apply"));
		backing.put(createTestEntry("orange"));
		String[] matches = backing.getKeys("app.*");
		assertEquals(2, matches.length);
		matches = backing.getKeys("orange");
		assertEquals(1, matches.length);
		assertEquals("orange", matches[0]);
	}
================= fetch public void testMultiFile() throws Exception { 9a3cc2b^:weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java

public void testMultiFile() throws Exception {
		CachedClassEntry entry;
		File cachedFile;
		CRC32 expectedCRC = new CRC32();
		expectedCRC.update(FAKE_BYTES);
		CacheBacking backing = DefaultFileCacheBacking.createBacking(root, resolver);
		// add weaved
		CachedClassReference wref = resolver.weavedKey(FAKE_CLASS + "WEAVED", FAKE_BYTES);
		entry = new CachedClassEntry(wref, FAKE_BYTES, CachedClassEntry.EntryType.WEAVED);
		backing.put(entry);
		cachedFile = new File(root, wref.getKey());
		assertTrue(cachedFile.exists());
		assertTrue(cachedFile.isFile());
		assertTrue(indexEntryExists(wref.getKey(), expectedCRC.getValue()));

		// add generated
		CachedClassReference gref = resolver.generatedKey(FAKE_CLASS + "GENERATED");
		entry = new CachedClassEntry(gref, FAKE_BYTES, CachedClassEntry.EntryType.GENERATED);
		backing.put(entry);
		cachedFile = new File(root, gref.getKey());
		assertTrue(cachedFile.exists());
		assertTrue(cachedFile.isFile());
		assertTrue(indexEntryExists(gref.getKey(), expectedCRC.getValue()));

		// add ignored
		CachedClassReference iref = resolver.generatedKey(FAKE_CLASS + "IGNORED");
		entry = new CachedClassEntry(iref, FAKE_BYTES, CachedClassEntry.EntryType.IGNORED);
		backing.put(entry);
		cachedFile = new File(root, iref.getKey());
		assertFalse(cachedFile.exists());
		assertTrue(indexEntryExists(iref.getKey(), expectedCRC.getValue()));

		backing.remove(wref);
		backing.remove(gref);
		backing.remove(iref);
	}
================= fetch public void testPut() throws Exception { 9a3cc2b^:weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java

public void testPut() throws Exception {
		CacheBacking backing = DefaultFileCacheBacking.createBacking(root, resolver);
		backing.put(new CachedClassEntry(fakeRef, FAKE_BYTES, CachedClassEntry.EntryType.WEAVED));
		File cachedFile = new File(root, fakeRef.getKey());
		assertTrue(cachedFile.exists());
		assertTrue(cachedFile.isFile());
		assertEquals(FAKE_BYTES.length, cachedFile.length());
	}
================= fetch public void testRemove() throws Exception { 9a3cc2b^:weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java

public void testRemove() throws Exception {
		CacheBacking backing = DefaultFileCacheBacking.createBacking(root, resolver);
		backing.put(new CachedClassEntry(fakeRef, FAKE_BYTES, CachedClassEntry.EntryType.WEAVED));
		File cachedFile = new File(root, fakeRef.getKey());
		assertTrue(cachedFile.exists());
		assertTrue(cachedFile.isFile());
		CRC32 expectedCRC = new CRC32();
		expectedCRC.update(FAKE_BYTES);
		assertTrue(indexEntryExists(fakeRef.getKey(), expectedCRC.getValue()));
		backing.remove(fakeRef);
		cachedFile = new File(root, fakeRef.getKey());
		assertFalse("CacheFile Still exists!" + cachedFile.getAbsolutePath(), cachedFile.exists());
		assertFalse(cachedFile.isFile());
		assertFalse(indexEntryExists(fakeRef.getKey(), expectedCRC.getValue()));
	}
================= fetch public void testRemove() throws Exception { 9a3cc2b^:weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java

public void testRemove() throws Exception {
		reset();
		WeavedClassCache cache = createCache();
		CachedClassReference ref = cache.createCacheKey(FAKE_CLASS, FAKE_BYTES);
		assertNull(cache.get(ref));
		cache.put(ref, FAKE_BYTES);
		assertNotNull(cache.get(ref));
		cache.remove(ref);
		assertNull(cache.get(ref));
	}
================= fetch private boolean mungeNewMethod(SourceTypeBinding sourceType, ResolvedType onType b8ebdc3^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseTypeMunger.java

private boolean mungeNewMethod(SourceTypeBinding sourceType, ResolvedType onType, NewMethodTypeMunger munger,
			boolean isExactTargetType) {
		InterTypeMethodBinding binding = new InterTypeMethodBinding(world, munger, aspectType, sourceMethod);

		if (!isExactTargetType) {
			// we're munging an interface ITD onto a topmost implementor
			ResolvedMember existingMember = onType.lookupMemberIncludingITDsOnInterfaces(getSignature());
			if (existingMember != null) {
				// already have an implementation, so don't do anything
				if (onType == existingMember.getDeclaringType() && Modifier.isFinal(munger.getSignature().getModifiers())) {
					// final modifier on default implementation is taken to mean that
					// no-one else can provide an implementation
					MethodBinding offendingBinding = sourceType.getExactMethod(binding.selector, binding.parameters,
							sourceType.scope.compilationUnitScope());
					sourceType.scope.problemReporter().finalMethodCannotBeOverridden(offendingBinding, binding);
				}
				// so that we find methods from our superinterfaces later on...
				findOrCreateInterTypeMemberFinder(sourceType);
				return false;
			}
		}

		// retain *only* the visibility modifiers and abstract when putting methods on an interface...
		if (sourceType.isInterface()) {
			boolean isAbstract = (binding.modifiers & ClassFileConstants.AccAbstract) != 0;
			binding.modifiers = (binding.modifiers & (ClassFileConstants.AccPublic | ClassFileConstants.AccProtected | ClassFileConstants.AccPrivate));
			if (isAbstract) {
				binding.modifiers |= ClassFileConstants.AccAbstract;
			}
		}
		if (munger.getSignature().isVarargsMethod()) {
			binding.modifiers |= ClassFileConstants.AccVarargs;
		}
		findOrCreateInterTypeMemberFinder(sourceType).addInterTypeMethod(binding);
		return true;
	}
================= fetch protected void resolveAnnotationValues(ResolvedType annotationType, IScope scope 0d69bd3^:org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java
/**
	 * Resolve any annotation values specified, checking they are all well formed (valid names, valid values)
	 * 
	 * @param annotationType the annotation type for which the values have been specified
	 * @param scope the scope within which to resolve type references (eg. Color.GREEN)
	 */
protected void resolveAnnotationValues(ResolvedType annotationType, IScope scope) {
		if (annotationValues == null) {
			return;
		}
		// Check any values specified are OK:
		// - the value names are for valid annotation fields
		// - the specified values are of the correct type
		// - for enums, check the specified values can be resolved in the specified scope
		Set<String> keys = annotationValues.keySet();
		ResolvedMember[] ms = annotationType.getDeclaredMethods();
		for (Iterator<String> kIter = keys.iterator(); kIter.hasNext();) {
			String k = kIter.next();
			String key = k;
			// a trailing ! indicates the the user expressed key!=value rather than key=value as a match constraint
			if (k.endsWith("!")) {
				key = key.substring(0, k.length() - 1);
			}
			String v = annotationValues.get(k);
			boolean validKey = false;
			for (int i = 0; i < ms.length; i++) {
				ResolvedMember resolvedMember = ms[i];
				if (resolvedMember.getName().equals(key) && resolvedMember.isAbstract()) {
					validKey = true;
					ResolvedType t = resolvedMember.getReturnType().resolve(scope.getWorld());
					if (t.isEnum()) {
						// value must be an enum reference X.Y
						int pos = v.lastIndexOf(".");
						if (pos == -1) {
							IMessage m = MessageUtil.error(
									WeaverMessages.format(WeaverMessages.INVALID_ANNOTATION_VALUE, v, "enum"), getSourceLocation());
							scope.getWorld().getMessageHandler().handleMessage(m);
						} else {
							String typename = v.substring(0, pos);
							ResolvedType rt = scope.lookupType(typename, this).resolve(scope.getWorld());
							v = rt.getSignature() + v.substring(pos + 1); // from 'Color.RED' to 'Lp/Color;RED'
							annotationValues.put(k, v);
						}
					} else if (t.isPrimitiveType()) {
						if (t.getSignature() == "I") {
							try {
								int value = Integer.parseInt(v);
								annotationValues.put(k, Integer.toString(value));
							} catch (NumberFormatException nfe) {
								IMessage m = MessageUtil.error(
										WeaverMessages.format(WeaverMessages.INVALID_ANNOTATION_VALUE, v, "int"),
										getSourceLocation());
								scope.getWorld().getMessageHandler().handleMessage(m);
							}
						} else if (t.getSignature() == "F") {
							try {
								float value = Float.parseFloat(v);
								annotationValues.put(k, Float.toString(value));
							} catch (NumberFormatException nfe) {
								IMessage m = MessageUtil.error(
										WeaverMessages.format(WeaverMessages.INVALID_ANNOTATION_VALUE, v, "float"),
										getSourceLocation());
								scope.getWorld().getMessageHandler().handleMessage(m);
							}

						} else if (t.getSignature() == "Z") {
							if (v.equalsIgnoreCase("true") || v.equalsIgnoreCase("false")) {
								// is it ok !
							} else {
								IMessage m = MessageUtil.error(
										WeaverMessages.format(WeaverMessages.INVALID_ANNOTATION_VALUE, v, "boolean"),
										getSourceLocation());
								scope.getWorld().getMessageHandler().handleMessage(m);
							}
						} else if (t.getSignature() == "S") {
							try {
								short value = Short.parseShort(v);
								annotationValues.put(k, Short.toString(value));
							} catch (NumberFormatException nfe) {
								IMessage m = MessageUtil.error(
										WeaverMessages.format(WeaverMessages.INVALID_ANNOTATION_VALUE, v, "short"),
										getSourceLocation());
								scope.getWorld().getMessageHandler().handleMessage(m);
							}
						} else if (t.getSignature() == "J") {
							try {
								long value = Long.parseLong(v);
								annotationValues.put(k, Long.toString(value));
							} catch (NumberFormatException nfe) {
								IMessage m = MessageUtil.error(
										WeaverMessages.format(WeaverMessages.INVALID_ANNOTATION_VALUE, v, "long"),
										getSourceLocation());
								scope.getWorld().getMessageHandler().handleMessage(m);
							}
						} else if (t.getSignature() == "D") {
							try {
								double value = Double.parseDouble(v);
								annotationValues.put(k, Double.toString(value));
							} catch (NumberFormatException nfe) {
								IMessage m = MessageUtil.error(
										WeaverMessages.format(WeaverMessages.INVALID_ANNOTATION_VALUE, v, "double"),
										getSourceLocation());
								scope.getWorld().getMessageHandler().handleMessage(m);
							}
						} else if (t.getSignature() == "B") {
							try {
								byte value = Byte.parseByte(v);
								annotationValues.put(k, Byte.toString(value));
							} catch (NumberFormatException nfe) {
								IMessage m = MessageUtil.error(
										WeaverMessages.format(WeaverMessages.INVALID_ANNOTATION_VALUE, v, "byte"),
										getSourceLocation());
								scope.getWorld().getMessageHandler().handleMessage(m);
							}
						} else if (t.getSignature() == "C") {
							if (v.length() != 3) { // '?'
								IMessage m = MessageUtil.error(
										WeaverMessages.format(WeaverMessages.INVALID_ANNOTATION_VALUE, v, "char"),
										getSourceLocation());
								scope.getWorld().getMessageHandler().handleMessage(m);
							} else {
								annotationValues.put(k, v.substring(1, 2));
							}
						} else {
							throw new RuntimeException("Not implemented for " + t);
						}
					} else if (t.equals(ResolvedType.JL_STRING)) {
						// nothing to do, it will be OK
					} else if (t.equals(ResolvedType.JL_CLASS)) {
						String typename = v.substring(0, v.lastIndexOf('.')); // strip off '.class'
						ResolvedType rt = scope.lookupType(typename, this).resolve(scope.getWorld());
						if (rt.isMissing()) {
							IMessage m = MessageUtil.error("Unable to resolve type '" + v + "' specified for value '" + k + "'",
									getSourceLocation());
							scope.getWorld().getMessageHandler().handleMessage(m);
						}
						annotationValues.put(k, rt.getSignature());
					} else {
						if (t.isAnnotation()) {
							if (v.indexOf("(") != -1) {
								throw new RuntimeException(
										"Compiler limitation: annotation values can only currently be marker annotations (no values): "
												+ v);
							}
							String typename = v.substring(1);
							ResolvedType rt = scope.lookupType(typename, this).resolve(scope.getWorld());
							if (rt.isMissing()) {
								IMessage m = MessageUtil.error(
										"Unable to resolve type '" + v + "' specified for value '" + k + "'", getSourceLocation());
								scope.getWorld().getMessageHandler().handleMessage(m);
							}
							annotationValues.put(k, rt.getSignature());
						} else {
							throw new RuntimeException("Compiler limitation: annotation value support not implemented for type "
									+ t);
						}
					}
				}
			}
			if (!validKey) {
				IMessage m = MessageUtil.error(WeaverMessages.format(WeaverMessages.UNKNOWN_ANNOTATION_VALUE, annotationType, k),
						getSourceLocation());
				scope.getWorld().getMessageHandler().handleMessage(m);
			} else {
				break;
			}
		}
	}
================= fetch public String stringify() { 0d69bd3^:org.aspectj.matcher/src/org/aspectj/weaver/EnumAnnotationValue.java

public String stringify() {
		return value;
	}
================= fetch public boolean hasNameValuePair(String n, String v) { 0d69bd3^:org.aspectj.matcher/src/org/aspectj/weaver/StandardAnnotation.java

public List<AnnotationNameValuePair> getNameValuePairs() {
		return nvPairs;
	}
================= fetch public void testInconsistentClassFile_pr389750_4() { 0d69bd3^:tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java

public void testInconsistentClassFile_pr389750_4() {
		runTest("inconsistent class file 4");
	}
================= fetch public static Test suite() { b9c7a19^:tests/src/org/aspectj/systemtest/AllTests17.java

public static Test suite() {
		TestSuite suite = new TestSuite("AspectJ System Test Suite - 1.7");
		// $JUnit-BEGIN$
		suite.addTest(AllTestsAspectJ171.suite());
		suite.addTest(AllTestsAspectJ170.suite());
		suite.addTest(AllTests16.suite());
		suite.addTest(AllTests15.suite());
		// $JUnit-END$
		return suite;
	}
================= fetch public static long makeLongPos(int start, int end) { b9c7a19^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AstUtil.java

public static Statement[] remove(int i, Statement[] statements) {
		int len = statements.length;
		Statement[] ret = new Statement[len - 1];
		System.arraycopy(statements, 0, ret, 0, i);
		System.arraycopy(statements, i + 1, ret, i, len - i - 1);
		return ret;
	}
================= fetch public void resolve(ClassScope upperScope) { b9c7a19^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java

public void resolve(ClassScope upperScope) {
		if (munger == null)
			ignoreFurtherInvestigation = true;
		if (binding == null)
			ignoreFurtherInvestigation = true;
		if (ignoreFurtherInvestigation)
			return;

		if (!Modifier.isStatic(declaredModifiers)) {
			this.arguments = AstUtil.insert(AstUtil.makeFinalArgument("ajc$this_".toCharArray(), onTypeBinding), this.arguments);
			binding.parameters = AstUtil.insert(onTypeBinding, binding.parameters);
		}

		super.resolve(upperScope);
	}
================= fetch public MethodGen pack() { c2ff74f^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
// ---- packing!
public MethodGen pack() {
		forceSyntheticForAjcMagicMembers();

		// killNops();
		int flags = getAccessFlags();
		if (enclosingClass.getWorld().isJoinpointSynchronizationEnabled()
				&& enclosingClass.getWorld().areSynchronizationPointcutsInUse()) {
			flags = getAccessFlagsWithoutSynchronized();
		}
		MethodGen gen = new MethodGen(flags, getReturnType(), getArgumentTypes(), null, // getArgumentNames(),
				getName(), getEnclosingClass().getName(), new InstructionList(), getEnclosingClass().getConstantPool());
		for (int i = 0, len = declaredExceptions.length; i < len; i++) {
			gen.addException(declaredExceptions[i]);
		}

		for (Attribute attr : attributes) {
			gen.addAttribute(attr);
		}

		if (newAnnotations != null) {
			for (AnnotationAJ element : newAnnotations) {
				gen.addAnnotation(new AnnotationGen(((BcelAnnotation) element).getBcelAnnotation(), gen.getConstantPool(), true));
			}
		}

		if (newParameterAnnotations != null) {
			for (int i = 0; i < newParameterAnnotations.length; i++) {
				AnnotationAJ[] annos = newParameterAnnotations[i];
				for (int j = 0; j < annos.length; j++) {
					gen.addParameterAnnotation(i,
							new AnnotationGen(((BcelAnnotation) annos[j]).getBcelAnnotation(), gen.getConstantPool(), true));
				}
			}
		}

		if (memberView != null && memberView.getAnnotations() != null && memberView.getAnnotations().length != 0) {
			AnnotationAJ[] ans = memberView.getAnnotations();
			for (int i = 0, len = ans.length; i < len; i++) {
				AnnotationGen a = ((BcelAnnotation) ans[i]).getBcelAnnotation();
				gen.addAnnotation(new AnnotationGen(a, gen.getConstantPool(), true));
			}
		}

		if (isSynthetic) {
			if (enclosingClass.getWorld().isInJava5Mode()) {
				gen.setModifiers(gen.getModifiers() | ACC_SYNTHETIC);
			}
			// belt and braces, do the attribute even on Java 5 in addition to
			// the modifier flag
			ConstantPool cpg = gen.getConstantPool();
			int index = cpg.addUtf8("Synthetic");
			gen.addAttribute(new Synthetic(index, 0, new byte[0], cpg));
		}

		if (hasBody()) {
			if (this.enclosingClass.getWorld().shouldFastPackMethods()) {
				if (isAdviceMethod() || getName().equals("<clinit>")) {
					packBody(gen);
				} else {
					optimizedPackBody(gen);
				}
			} else {
				packBody(gen);
			}
			gen.setMaxLocals();
			gen.setMaxStack();
		} else {
			gen.setInstructionList(null);
		}
		return gen;
	}
Progress : [#####-----------------------------------] 14%================= fetch private void resolveAndSetPointcut(MethodDeclaration methodDeclaration, Annotati 55ebaa1^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java

private void resolveAndSetPointcut(MethodDeclaration methodDeclaration, Annotation adviceAnn) {
		int[] pcLocation = new int[2];
		String pointcutExpression = getStringLiteralFor("pointcut", adviceAnn, pcLocation);
		if (pointcutExpression == null)
			pointcutExpression = getStringLiteralFor("value", adviceAnn, pcLocation);
		try {
			// +1 to give first char of pointcut string
			ISourceContext context = new EclipseSourceContext(unit.compilationResult, pcLocation[0] + 1);
			PatternParser pp = new PatternParser(pointcutExpression, context);
			Pointcut pc = pp.parsePointcut();
			pp.checkEof();
			FormalBinding[] bindings = buildFormalAdviceBindingsFrom(methodDeclaration);
			pc.resolve(new EclipseScope(bindings, methodDeclaration.scope));
			EclipseFactory factory = EclipseFactory.fromScopeLookupEnvironment(methodDeclaration.scope);
			// now create a ResolvedPointcutDefinition,make an attribute out of
			// it, and add it to the method
			UnresolvedType[] paramTypes = new UnresolvedType[bindings.length];
			for (int i = 0; i < paramTypes.length; i++)
				paramTypes[i] = bindings[i].getType();
			ResolvedPointcutDefinition resPcutDef = new ResolvedPointcutDefinition(factory.fromBinding(((TypeDeclaration) typeStack
					.peek()).binding), methodDeclaration.modifiers, "anonymous", paramTypes, pc);
			AjAttribute attr = new AjAttribute.PointcutDeclarationAttribute(resPcutDef);
			((AjMethodDeclaration) methodDeclaration).addAttribute(new EclipseAttributeAdapter(attr));
		} catch (ParserException pEx) {
			methodDeclaration.scope.problemReporter().parseError(pcLocation[0] + pEx.getLocation().getStart(),
					pcLocation[0] + pEx.getLocation().getEnd(), -1, pointcutExpression.toCharArray(), pointcutExpression,
					new String[] { pEx.getMessage() });
		}
	}
================= fetch public void unhandledException(TypeBinding exceptionType, ASTNode location) { 76d695f^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java

public void unhandledException(TypeBinding exceptionType, ASTNode location) {
		if (!factory.getWorld().getDeclareSoft().isEmpty()) {
			Shadow callSite = factory.makeShadow(location, referenceContext);
			Shadow enclosingExec = factory.makeShadow(referenceContext);
			// PR 72157 - calls to super / this within a constructor are not part of the cons join point.
			if ((callSite == null) && (enclosingExec.getKind() == Shadow.ConstructorExecution)
					&& (location instanceof ExplicitConstructorCall)) {
				super.unhandledException(exceptionType, location);
				return;
			}
			// System.err.println("about to show error for unhandled exception: " + new String(exceptionType.sourceName()) +
			// " at " + location + " in " + referenceContext);

			for (Iterator i = factory.getWorld().getDeclareSoft().iterator(); i.hasNext();) {
				DeclareSoft d = (DeclareSoft) i.next();
				// We need the exceptionType to match the type in the declare soft statement
				// This means it must either be the same type or a subtype
				ResolvedType throwException = factory.fromEclipse((ReferenceBinding) exceptionType);
				FuzzyBoolean isExceptionTypeOrSubtype = d.getException().matchesInstanceof(throwException);
				if (!isExceptionTypeOrSubtype.alwaysTrue())
					continue;

				if (callSite != null) {
					FuzzyBoolean match = d.getPointcut().match(callSite);
					if (match.alwaysTrue()) {
						// System.err.println("matched callSite: " + callSite + " with " + d);
						return;
					} else if (!match.alwaysFalse()) {
						// !!! need this check to happen much sooner
						// throw new RuntimeException("unimplemented, shouldn't have fuzzy match here");
					}
				}
				if (enclosingExec != null) {
					FuzzyBoolean match = d.getPointcut().match(enclosingExec);
					if (match.alwaysTrue()) {
						// System.err.println("matched enclosingExec: " + enclosingExec + " with " + d);
						return;
					} else if (!match.alwaysFalse()) {
						// !!! need this check to happen much sooner
						// throw new RuntimeException("unimplemented, shouldn't have fuzzy match here");
					}
				}
			}
		}

		// ??? is this always correct
		if (location instanceof Proceed) {
			return;
		}

		super.unhandledException(exceptionType, location);
	}
================= fetch public void methodMustOverride(AbstractMethodDeclaration method, long compliance cbb6f5a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java
/**
	 * Overrides the implementation in ProblemReporter and is ITD aware. To report a *real* problem with an ITD marked @override,
	 * the other methodMustOverride() method is used.
	 */
public void methodMustOverride(AbstractMethodDeclaration method, long complianceLevel) {

		// ignore ajc$ methods
		if (new String(method.selector).startsWith("ajc$"))
			return;
		ResolvedMember possiblyErroneousRm = factory.makeResolvedMember(method.binding);

		ResolvedType onTypeX = factory.fromEclipse(method.binding.declaringClass);
		// Can't use 'getInterTypeMungersIncludingSupers()' since that will exclude abstract ITDs
		// on any super classes - so we have to trawl up ourselves.. I wonder if this problem
		// affects other code in the problem reporter that looks through ITDs...
		ResolvedType supertypeToLookAt = onTypeX.getSuperclass();
		while (supertypeToLookAt != null) {
			List itMungers = supertypeToLookAt.getInterTypeMungers();
			for (Iterator i = itMungers.iterator(); i.hasNext();) {
				ConcreteTypeMunger m = (ConcreteTypeMunger) i.next();
				ResolvedMember sig = m.getSignature();
				if (sig == null)
					continue; // we aren't interested in other kinds of munger
				UnresolvedType dType = sig.getDeclaringType();
				if (dType == null)
					continue;
				ResolvedType resolvedDeclaringType = dType.resolve(factory.getWorld());
				ResolvedMember rm = AjcMemberMaker.interMethod(sig, m.getAspectType(), resolvedDeclaringType.isInterface());
				if (ResolvedType.matches(rm, possiblyErroneousRm)) {
					// match, so dont need to report a problem!
					return;
				}
			}
			supertypeToLookAt = supertypeToLookAt.getSuperclass();
		}
		// report the error...
		super.methodMustOverride(method,complianceLevel);
	}
================= fetch private void addMethodDispatch(LazyClassGen gen, ResolvedMember method, Resolved 7c6e936^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java

private void addMethodDispatch(LazyClassGen gen, ResolvedMember method, ResolvedMember accessMethod) {
		LazyMethodGen mg = makeMethodGen(gen, accessMethod);
		InstructionList il = new InstructionList();
		InstructionFactory fact = gen.getFactory();
		// Type fieldType = BcelWorld.makeBcelType(field.getType());
		Type[] paramTypes = BcelWorld.makeBcelTypes(method.getParameterTypes());

		int pos = 0;

		if (!Modifier.isStatic(method.getModifiers())) {
			il.append(InstructionConstants.ALOAD_0);
			pos++;
		}
		for (int i = 0, len = paramTypes.length; i < len; i++) {
			Type paramType = paramTypes[i];
			il.append(InstructionFactory.createLoad(paramType, pos));
			pos += paramType.getSize();
		}
		il.append(Utility.createInvoke(fact, (BcelWorld) aspectType.getWorld(), method));
		il.append(InstructionFactory.createReturn(BcelWorld.makeBcelType(method.getReturnType())));

		mg.getBody().insert(il);

		gen.addMethodGen(mg);
	}
================= fetch public void checkInterTypeMungers() { 7c6e936^:org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java
/**
	 * Check: 1) That we don't have any abstract type mungers unless this type is abstract. 2) That an abstract ITDM on an interface
	 * is declared public. (Compiler limitation) (PR70794)
	 */
public void checkInterTypeMungers() {
		if (isAbstract()) {
			return;
		}

		boolean itdProblem = false;

		for (ConcreteTypeMunger munger : getInterTypeMungersIncludingSupers()) {
			itdProblem = checkAbstractDeclaration(munger) || itdProblem; // Rule 2
		}

		if (itdProblem) {
			return; // If the rules above are broken, return right now
		}

		for (ConcreteTypeMunger munger : getInterTypeMungersIncludingSupers()) {
			if (munger.getSignature() != null && munger.getSignature().isAbstract()) { // Rule 1
				if (munger.getMunger().getKind() == ResolvedTypeMunger.MethodDelegate2) {
					// ignore for @AJ ITD as munger.getSignature() is the
					// interface method hence abstract
				} else {
					world.getMessageHandler()
							.handleMessage(
									new Message("must implement abstract inter-type declaration: " + munger.getSignature(), "",
											IMessage.ERROR, getSourceLocation(), null,
											new ISourceLocation[] { getMungerLocation(munger) }));
				}
			}
		}
	}
================= fetch public UnresolvedType fromBinding(TypeBinding binding) { bf949d3^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java
// ??? going back and forth between strings and bindings is a waste of cycles
public UnresolvedType fromBinding(TypeBinding binding) {
		if (binding instanceof HelperInterfaceBinding) {
			return ((HelperInterfaceBinding) binding).getTypeX();
		}
		if (binding == null || binding.qualifiedSourceName() == null) {
			return ResolvedType.MISSING;
		}
		// first piece of generics support!
		if (binding instanceof TypeVariableBinding) {
			TypeVariableBinding tb = (TypeVariableBinding) binding;
			UnresolvedTypeVariableReferenceType utvrt = (UnresolvedTypeVariableReferenceType) fromTypeVariableBinding(tb);
			return utvrt;
		}

		// handle arrays since the component type may need special treatment too...
		if (binding instanceof ArrayBinding) {
			ArrayBinding aBinding = (ArrayBinding) binding;
			UnresolvedType componentType = fromBinding(aBinding.leafComponentType);
			return UnresolvedType.makeArray(componentType, aBinding.dimensions);
		}

		if (binding instanceof WildcardBinding) {
			WildcardBinding eWB = (WildcardBinding) binding;
			// Repair the bound
			// e.g. If the bound for the wildcard is a typevariable, e.g. '? extends E' then
			// the type variable in the unresolvedtype will be correct only in name. In that
			// case let's set it correctly based on the one in the eclipse WildcardBinding
			UnresolvedType theBound = null;
			if (eWB.bound instanceof TypeVariableBinding) {
				theBound = fromTypeVariableBinding((TypeVariableBinding) eWB.bound);
			} else {
				theBound = fromBinding(eWB.bound);
			}
			// if (eWB.boundKind == WildCard.SUPER) {
			//
			// }
			WildcardedUnresolvedType theType = (WildcardedUnresolvedType) TypeFactory.createTypeFromSignature(CharOperation
					.charToString(eWB.genericTypeSignature()));
			// if (theType.isGenericWildcard() && theType.isSuper()) theType.setLowerBound(theBound);
			// if (theType.isGenericWildcard() && theType.isExtends()) theType.setUpperBound(theBound);
			return theType;
		}

		if (binding instanceof ParameterizedTypeBinding) {
			if (binding instanceof RawTypeBinding) {
				// special case where no parameters are specified!
				return UnresolvedType.forRawTypeName(getName(binding));
			}
			ParameterizedTypeBinding ptb = (ParameterizedTypeBinding) binding;

			UnresolvedType[] arguments = null;

			if (ptb.arguments != null) { // null can mean this is an inner type of a Parameterized Type with no bounds of its own
				// (pr100227)
				arguments = new UnresolvedType[ptb.arguments.length];
				for (int i = 0; i < arguments.length; i++) {
					arguments[i] = fromBinding(ptb.arguments[i]);
				}
			}

			String baseTypeSignature = null;

			ResolvedType baseType = getWorld().resolve(UnresolvedType.forName(getName(binding)), true);
			if (!baseType.isMissing()) {
				// can legitimately be missing if a bound refers to a type we haven't added to the world yet...
				// pr168044 - sometimes (whilst resolving types) we are working with 'half finished' types and so (for example) the
				// underlying generic type for a raw type hasnt been set yet
				// if (!baseType.isGenericType() && arguments!=null) baseType = baseType.getGenericType();
				baseTypeSignature = baseType.getErasureSignature();
			} else {
				baseTypeSignature = UnresolvedType.forName(getName(binding)).getSignature();
			}

			// Create an unresolved parameterized type. We can't create a resolved one as the
			// act of resolution here may cause recursion problems since the parameters may
			// be type variables that we haven't fixed up yet.
			if (arguments == null) {
				arguments = new UnresolvedType[0];
			}
			// StringBuffer parameterizedSig = new StringBuffer();
			// parameterizedSig.append(ResolvedType.PARAMETERIZED_TYPE_IDENTIFIER);
			//
			// // String parameterizedSig = new
			// StringBuffer().append(ResolvedType.PARAMETERIZED_TYPE_IDENTIFIER).append(CharOperation
			// .charToString(binding.genericTypeSignature()).substring(1)).toString();
			// return TypeFactory.createUnresolvedParameterizedType(parameterizedSig,baseTypeSignature,arguments);
			return TypeFactory.createUnresolvedParameterizedType(baseTypeSignature, arguments);
		}

		// Convert the source type binding for a generic type into a generic UnresolvedType
		// notice we can easily determine the type variables from the eclipse object
		// and we can recover the generic signature from it too - so we pass those
		// to the forGenericType() method.
		if (binding.isGenericType() && !binding.isParameterizedType() && !binding.isRawType()) {
			TypeVariableBinding[] tvbs = binding.typeVariables();
			TypeVariable[] tVars = new TypeVariable[tvbs.length];
			for (int i = 0; i < tvbs.length; i++) {
				TypeVariableBinding eclipseV = tvbs[i];
				tVars[i] = ((TypeVariableReference) fromTypeVariableBinding(eclipseV)).getTypeVariable();
			}
			// TODO asc generics - temporary guard....
			if (!(binding instanceof SourceTypeBinding)) {
				throw new RuntimeException("Cant get the generic sig for " + binding.debugName());
			}
			return UnresolvedType.forGenericType(getName(binding), tVars,
					CharOperation.charToString(((SourceTypeBinding) binding).genericSignature()));
		}

		// LocalTypeBinding have a name $Local$, we can get the real name by using the signature....
		if (binding instanceof LocalTypeBinding) {
			LocalTypeBinding ltb = (LocalTypeBinding) binding;
			if (ltb.constantPoolName() != null && ltb.constantPoolName().length > 0) {
				return UnresolvedType.forSignature(new String(binding.signature()));
			} else {
				// we're reporting a problem and don't have a resolved name for an
				// anonymous local type yet, report the issue on the enclosing type
				return UnresolvedType.forSignature(new String(ltb.enclosingType.signature()));
			}
		}

		// was: UnresolvedType.forName(getName(binding));
		UnresolvedType ut = UnresolvedType.forSignature(new String(binding.signature()));
		return ut;
	}
================= fetch public static Test suite() { bf949d3^:tests/src/org/aspectj/systemtest/AllTests17.java

public static Test suite() {
		TestSuite suite = new TestSuite("AspectJ System Test Suite - JDK 1.7");
		// $JUnit-BEGIN$
		suite.addTest(AllTestsAspectJ170.suite());
		suite.addTest(AllTests16.suite());
		suite.addTest(AllTests15.suite());
		// $JUnit-END$
		return suite;
	}
================= fetch public static String dumpOnExit(IMessageHolder messageHolder, boolean reset) { 5d0e186^:org.aspectj.matcher/src/org/aspectj/weaver/Dump.java

public static String dumpOnExit(IMessageHolder messageHolder, boolean reset) {
		if (trace.isTraceEnabled()) {
			trace.enter("dumpOnExit", null, messageHolder);
		}
		String fileName = UNKNOWN_FILENAME;

		if (!shouldDumpOnExit(messageHolder)) {
			fileName = DUMP_EXCLUDED;
		} else {
			Dump dump = null;
			try {
				dump = new Dump(conditionKind.toString());
				fileName = dump.getFileName();
				dump.dumpDefault(messageHolder);
			} finally {
				if (dump != null) {
					dump.close();
				}
			}
		}

		if (reset) {
			messageHolder.clearMessages();
		}

		if (trace.isTraceEnabled()) {
			trace.exit("dumpOnExit", fileName);
		}
		return fileName;
	}
================= fetch public static String dumpWithException(IMessageHolder messageHolder, Throwable t 5d0e186^:org.aspectj.matcher/src/org/aspectj/weaver/Dump.java

public static String dumpWithException(IMessageHolder messageHolder, Throwable th) {
		if (trace.isTraceEnabled()) {
			trace.enter("dumpWithException", null, new Object[] { messageHolder, th });
		}

		String fileName = UNKNOWN_FILENAME;
		Dump dump = null;
		try {
			dump = new Dump(th.getClass().getName());
			fileName = dump.getFileName();
			dump.dumpException(messageHolder, th);
		} finally {
			if (dump != null) {
				dump.close();
			}
		}

		if (trace.isTraceEnabled()) {
			trace.exit("dumpWithException", fileName);
		}
		return fileName;
	}
Progress : [######----------------------------------] 15%================= fetch private void createAnyBridgeMethodsForCovariance(BcelClassWeaver weaver, NewMeth a748303^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
/**
	 * Create any bridge method required because of covariant returns being used. This method is used in the case where an ITD is
	 * applied to some type and it may be in an override relationship with a method from the supertype - but due to covariance there
	 * is a mismatch in return values. Example of when required: Super defines: Object m(String s) Sub defines: String m(String s)
	 * then we need a bridge method in Sub called 'Object m(String s)' that forwards to 'String m(String s)'
	 */
private void createAnyBridgeMethodsForCovariance(BcelClassWeaver weaver, NewMethodTypeMunger munger,
			ResolvedMember unMangledInterMethod, ResolvedType onType, LazyClassGen gen, Type[] paramTypes) {
		// PERFORMANCE BOTTLENECK? Might need investigating, method analysis
		// between types in a hierarchy just seems expensive...
		// COVARIANCE BRIDGING
		// Algorithm: Step1. Check in this type - has someone already created
		// the bridge method?
		// Step2. Look above us - do we 'override' a method and yet differ in
		// return type (i.e. covariance)
		// Step3. Create a forwarding bridge method
		// ResolvedType superclass = onType.getSuperclass();
		boolean quitRightNow = false;

		String localMethodName = unMangledInterMethod.getName();
		String localParameterSig = unMangledInterMethod.getParameterSignature();
		String localReturnTypeESig = unMangledInterMethod.getReturnType().getErasureSignature();

		// Step1
		boolean alreadyDone = false; // Compiler might have done it
		ResolvedMember[] localMethods = onType.getDeclaredMethods();
		for (int i = 0; i < localMethods.length; i++) {
			ResolvedMember member = localMethods[i];
			if (member.getName().equals(localMethodName)) {
				// Check the params
				if (member.getParameterSignature().equals(localParameterSig)) {
					alreadyDone = true;
				}
			}
		}

		// Step2
		if (!alreadyDone) {
			// Use the iterator form of 'getMethods()' so we do as little work as necessary
			ResolvedType supertype = onType.getSuperclass();
			if (supertype != null) {
				for (Iterator<ResolvedMember> iter = supertype.getMethods(true, true); iter.hasNext() && !quitRightNow;) {
					ResolvedMember aMethod = iter.next();
					if (aMethod.getName().equals(localMethodName) && aMethod.getParameterSignature().equals(localParameterSig)) {
						// check the return types, if they are different we need a
						// bridging method.
						if (!aMethod.getReturnType().getErasureSignature().equals(localReturnTypeESig)
								&& !Modifier.isPrivate(aMethod.getModifiers())) {
							// Step3
							createBridgeMethod(weaver.getWorld(), munger, unMangledInterMethod, gen, paramTypes, aMethod);
							quitRightNow = true;
						}
					}
				}
			}
		}
	}
================= fetch private void createBridgeMethod(BcelWorld world, NewMethodTypeMunger munger, Res a748303^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
/**
	 * Create a bridge method for a particular munger.
	 * 
	 * @param world
	 * @param munger
	 * @param unMangledInterMethod the method to bridge 'to' that we have already created in the 'subtype'
	 * @param clazz the class in which to put the bridge method
	 * @param paramTypes Parameter types for the bridge method, passed in as an optimization since the caller is likely to have
	 *        already created them.
	 * @param theBridgeMethod
	 */
private void createBridgeMethod(BcelWorld world, NewMethodTypeMunger munger, ResolvedMember unMangledInterMethod,
			LazyClassGen clazz, Type[] paramTypes, ResolvedMember theBridgeMethod) {
		InstructionList body;
		InstructionFactory fact;
		int pos = 0;

		LazyMethodGen bridgeMethod = makeMethodGen(clazz, theBridgeMethod); // The
		// bridge
		// method
		// in
		// this
		// type
		// will
		// have
		// the
		// same
		// signature
		// as
		// the
		// one
		// in
		// the
		// supertype
		bridgeMethod.setAccessFlags(bridgeMethod.getAccessFlags() | 0x00000040 /*
																				 * BRIDGE = 0x00000040
																				 */);
		// UnresolvedType[] newParams =
		// munger.getSignature().getParameterTypes();
		Type returnType = BcelWorld.makeBcelType(theBridgeMethod.getReturnType());
		body = bridgeMethod.getBody();
		fact = clazz.getFactory();

		if (!Modifier.isStatic(unMangledInterMethod.getModifiers())) {
			body.append(InstructionFactory.createThis());
			pos++;
		}
		for (int i = 0, len = paramTypes.length; i < len; i++) {
			Type paramType = paramTypes[i];
			body.append(InstructionFactory.createLoad(paramType, pos));
			// if (!bridgingSetter.getParameterTypes()[i].getErasureSignature().
			// equals
			// (unMangledInterMethod.getParameterTypes()[i].getErasureSignature
			// ())) {
			// System.err.println("Putting in cast from "+paramType+" to "+
			// bridgingToParms[i]);
			// body.append(fact.createCast(paramType,bridgingToParms[i]));
			// }
			pos += paramType.getSize();
		}

		body.append(Utility.createInvoke(fact, world, unMangledInterMethod));
		body.append(InstructionFactory.createReturn(returnType));
		clazz.addMethodGen(bridgeMethod);
	}
================= fetch public ResolvedType parameterizedWith(UnresolvedType[] typeParameters) { a748303^:org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java

public ResolvedType parameterizedWith(UnresolvedType[] typeParameters) {
		if (!(isGenericType() || isParameterizedType())) {
			return this;
		}
		return TypeFactory.createParameterizedType(this.getGenericType(), typeParameters, getWorld());
	}
================= fetch public UnresolvedType parameterize(Map<String, UnresolvedType> typeBindings) { a748303^:org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java
/**
	 * Iff I am a parameterized type, and any of my parameters are type variable references, return a version with those type
	 * parameters replaced in accordance with the passed bindings.
	 */
@Override
	public UnresolvedType parameterize(Map<String, UnresolvedType> typeBindings) {
		if (!isParameterizedType()) {
			return this;// throw new IllegalStateException(
		}
		// "Can't parameterize a type that is not a parameterized type"
		// );
		boolean workToDo = false;
		for (int i = 0; i < typeParameters.length; i++) {
			if (typeParameters[i].isTypeVariableReference() || (typeParameters[i] instanceof BoundedReferenceType)) {
				workToDo = true;
			}
		}
		if (!workToDo) {
			return this;
		} else {
			UnresolvedType[] newTypeParams = new UnresolvedType[typeParameters.length];
			for (int i = 0; i < newTypeParams.length; i++) {
				newTypeParams[i] = typeParameters[i];
				if (newTypeParams[i].isTypeVariableReference()) {
					TypeVariableReferenceType tvrt = (TypeVariableReferenceType) newTypeParams[i];
					UnresolvedType binding = typeBindings.get(tvrt.getTypeVariable().getName());
					if (binding != null) {
						newTypeParams[i] = binding;
					}
				} else if (newTypeParams[i] instanceof BoundedReferenceType) {
					BoundedReferenceType brType = (BoundedReferenceType) newTypeParams[i];
					newTypeParams[i] = brType.parameterize(typeBindings);
					// brType.parameterize(typeBindings)
				}
			}
			return TypeFactory.createParameterizedType(getGenericType(), newTypeParams, getWorld());
		}
	}
================= fetch public void testGenericAspectAround382723_4() { a748303^:tests/src/org/aspectj/systemtest/ajc170/Ajc170Tests.java

public void testGenericAspectAround382723_4() {
		runTest("generic aspect 4");
	}
================= fetch private void makePublic(TypeBinding binding) { ba9d43c^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java

private void makePublic(TypeBinding binding) {
		if (binding == null || !binding.isValidBinding())
			return; // has already produced an error
		if (binding instanceof ReferenceBinding) {
			ReferenceBinding rb = (ReferenceBinding) binding;
			if (!rb.isPublic())
				handler.notePrivilegedTypeAccess(rb, null); // ???
		} else if (binding instanceof ArrayBinding) {
			makePublic(((ArrayBinding) binding).leafComponentType);
		} else {
			return;
		}
	}
================= fetch public String toString() { 89c178f^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java

private static File isAspectjtoolsjar(String path) {
		if (null == path) {
			return null;
		}
		final String prefix = "aspectj";
		final String infix = "tools";
		final String altInfix = "-tools";
		final String suffix = ".jar";
		final int prefixLength = 7; // prefix.length();
		final int minLength = 16;
		// prefixLength + infix.length() + suffix.length();
		if (!path.endsWith(suffix)) {
			return null;
		}
		int loc = path.lastIndexOf(prefix);
		if ((-1 != loc) && ((loc + minLength) <= path.length())) {
			String rest = path.substring(loc + prefixLength);
			if (-1 != rest.indexOf(File.pathSeparator)) {
				return null;
			}
			if (rest.startsWith(infix) || rest.startsWith(altInfix)) {
				File result = new File(path);
				if (result.canRead() && result.isFile()) {
					return result;
				}
			}
		}
		return null;
	}
================= fetch private int getScore(Pointcut p) { f85631f^:org.aspectj.matcher/src/org/aspectj/weaver/patterns/PointcutEvaluationExpenseComparator.java
// a higher score means a more expensive evaluation
private int getScore(Pointcut p) {
		if (p.couldMatchKinds() == Shadow.NO_SHADOW_KINDS_BITS) {
			return MATCHES_NOTHING;
		}
		if (p instanceof WithinPointcut) {
			return WITHIN;
		}
		if (p instanceof WithinAnnotationPointcut) {
			return ATWITHIN;
		}
		if (p instanceof KindedPointcut) {
			KindedPointcut kp = (KindedPointcut) p;
			Shadow.Kind kind = kp.getKind();
			if (kind == Shadow.AdviceExecution) {
				return ADVICEEXECUTION;
			} else if ((kind == Shadow.ConstructorCall) || (kind == Shadow.MethodCall)) {
				return CALL;
			} else if ((kind == Shadow.ConstructorExecution) || (kind == Shadow.MethodExecution) || (kind == Shadow.Initialization)
					|| (kind == Shadow.PreInitialization)) {
				return EXE_INIT_PREINIT;
			} else if (kind == Shadow.ExceptionHandler) {
				return HANDLER;
			} else if ((kind == Shadow.FieldGet) || (kind == Shadow.FieldSet)) {
				return GET_OR_SET;
			} else if (kind == Shadow.StaticInitialization) {
				return STATICINIT;
			} else {
				return OTHER;
			}
		}
		if (p instanceof AnnotationPointcut) {
			return ANNOTATION;
		}
		if (p instanceof ArgsPointcut) {
			return ARGS;
		}
		if (p instanceof ArgsAnnotationPointcut) {
			return AT_ARGS;
		}
		if (p instanceof CflowPointcut || p instanceof ConcreteCflowPointcut) {
			return CFLOW;
		}
		if (p instanceof HandlerPointcut) {
			return HANDLER;
		}
		if (p instanceof IfPointcut) {
			return IF;
		}
		if (p instanceof ThisOrTargetPointcut) {
			return THIS_OR_TARGET;
		}
		if (p instanceof ThisOrTargetAnnotationPointcut) {
			return AT_THIS_OR_TARGET;
		}
		if (p instanceof WithincodePointcut) {
			return WITHINCODE;
		}
		if (p instanceof WithinCodeAnnotationPointcut) {
			return ATWITHINCODE;
		}
		if (p instanceof NotPointcut) {
			return getScore(((NotPointcut) p).getNegatedPointcut());
		}
		if (p instanceof AndPointcut) {
			int leftScore = getScore(((AndPointcut) p).getLeft());
			int rightScore = getScore(((AndPointcut) p).getRight());
			if (leftScore < rightScore) {
				return leftScore;
			} else {
				return rightScore;
			}
		}
		if (p instanceof OrPointcut) {
			int leftScore = getScore(((OrPointcut) p).getLeft());
			int rightScore = getScore(((OrPointcut) p).getRight());
			if (leftScore > rightScore) {
				return leftScore;
			} else {
				return rightScore;
			}
		}
		return OTHER;
	}
Progress : [######----------------------------------] 16%================= fetch private int getRank(String tvname) { 549d227^:org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java

@Override
	public TypeVariable[] getTypeVariables() {
		if (this.typeVariables == null) {
			this.typeVariables = getDelegate().getTypeVariables();
			for (int i = 0; i < this.typeVariables.length; i++) {
				this.typeVariables[i].resolve(world);
			}
		}
		return this.typeVariables;
	}
================= fetch public PerClause getPerClause() { 549d227^:org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java
// }
@Override
	public Collection<ResolvedMember> getPrivilegedAccesses() {
		return getDelegate().getPrivilegedAccesses();
	}
================= fetch public ReferenceType(ResolvedType theGenericType, ResolvedType[] theParameters, 549d227^:org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java

public static ReferenceType fromTypeX(UnresolvedType tx, World world) {
		ReferenceType rt = new ReferenceType(tx.getErasureSignature(), world);
		rt.typeKind = tx.typeKind;
		return rt;
	}
================= fetch public ResolvedType resolve(World world) { 549d227^:org.aspectj.matcher/src/org/aspectj/weaver/UnresolvedTypeVariableReferenceType.java

@Override
	public ResolvedType resolve(World world) {
		TypeVariableDeclaringElement typeVariableScope = world.getTypeVariableLookupScope();
		TypeVariable resolvedTypeVariable = null;
		TypeVariableReferenceType tvrt = null;
		if (typeVariableScope == null) {
			// throw new BCException("There is no scope in which to lookup type variables!");
			// FIXME asc correct thing to do is go bang, but to limp along, lets cope with the scope missing
			resolvedTypeVariable = typeVariable.resolve(world);
			tvrt = new TypeVariableReferenceType(resolvedTypeVariable, world);
		} else {
			boolean foundOK = false;
			resolvedTypeVariable = typeVariableScope.getTypeVariableNamed(typeVariable.getName());
			// FIXME asc remove this when the shared type var stuff is sorted
			if (resolvedTypeVariable == null) {
				resolvedTypeVariable = typeVariable.resolve(world);
			} else {
				foundOK = true;
			}
			tvrt = new TypeVariableReferenceType(resolvedTypeVariable, world);
			tvrt.fixedUp = foundOK;
		}

		return tvrt;
	}
================= fetch public ResolvedType resolveGenericTypeFor(UnresolvedType anUnresolvedType, boole 549d227^:org.aspectj.matcher/src/org/aspectj/weaver/World.java
/**
	 * Attempt to resolve a type that should be a generic type.
	 */
public ResolvedType resolveGenericTypeFor(UnresolvedType anUnresolvedType, boolean allowMissing) {
		// Look up the raw type by signature
		String rawSignature = anUnresolvedType.getRawType().getSignature();
		ResolvedType rawType = typeMap.get(rawSignature);
		if (rawType == null) {
			rawType = resolve(UnresolvedType.forSignature(rawSignature), allowMissing);
			typeMap.put(rawSignature, rawType);
		}
		if (rawType.isMissing()) {
			return rawType;
		}

		// Does the raw type know its generic form? (It will if we created the
		// raw type from a source type, it won't if its been created just
		// through
		// being referenced, e.g. java.util.List
		ResolvedType genericType = rawType.getGenericType();

		// There is a special case to consider here (testGenericsBang_pr95993
		// highlights it)
		// You may have an unresolvedType for a parameterized type but it
		// is backed by a simple type rather than a generic type. This occurs
		// for
		// inner types of generic types that inherit their enclosing types
		// type variables.
		if (rawType.isSimpleType() && (anUnresolvedType.typeParameters == null || anUnresolvedType.typeParameters.length == 0)) {
			rawType.world = this;
			return rawType;
		}

		if (genericType != null) {
			genericType.world = this;
			((ReferenceType) genericType).addDependentType((ReferenceType) rawType);
			return genericType;
		} else {
			// Fault in the generic that underpins the raw type ;)
			ReferenceTypeDelegate delegate = resolveDelegate((ReferenceType) rawType);
			ReferenceType genericRefType = makeGenericTypeFrom(delegate, ((ReferenceType) rawType));
			((ReferenceType) rawType).setGenericType(genericRefType);
			genericRefType.setDelegate(delegate);
			((ReferenceType) rawType).setDelegate(delegate);
			return genericRefType;
		}
	}
================= fetch public TypeVariable getTypeVariable() { 549d227^:org.aspectj.matcher/src/org/aspectj/weaver/TypeVariableReferenceType.java

public TypeVariable getTypeVariable() {
		// if (!fixedUp)
		// throw new BCException("ARGH"); // fix it up now?
		return typeVariable;
	}
================= fetch public TypeVariableReferenceType(TypeVariable typeVariable, World world) { 549d227^:org.aspectj.matcher/src/org/aspectj/weaver/TypeVariableReferenceType.java

================= fetch public WeaverStateInfo getWeaverState() { 549d227^:org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java
/**
	 * It is possible this type has multiple type variables but the interface we are about to parameterize only uses a subset - this
	 * method determines the subset to use by looking at the type variable names used. For example: <code>
	 * class Foo<T extends String,E extends Number> implements SuperInterface<T> {}
	 * </code> where <code>
	 * interface SuperInterface<Z> {}
	 * </code> In that example, a use of the 'Foo' raw type should know that it implements the SuperInterface<String>.
	 */
private UnresolvedType[] determineThoseTypesToUse(ResolvedType parameterizedInterface, UnresolvedType[] paramTypes) {
		// What are the type parameters for the supertype?
		UnresolvedType[] tParms = parameterizedInterface.getTypeParameters();
		UnresolvedType[] retVal = new UnresolvedType[tParms.length];

		// Go through the supertypes type parameters, if any of them is a type
		// variable, use the
		// real type variable on the declaring type.

		// it is possibly overkill to look up the type variable - ideally the
		// entry in the type parameter list for the
		// interface should be the a ref to the type variable in the current
		// type ... but I'm not 100% confident right now.
		for (int i = 0; i < tParms.length; i++) {
			UnresolvedType tParm = tParms[i];
			if (tParm.isTypeVariableReference()) {
				TypeVariableReference tvrt = (TypeVariableReference) tParm;
				TypeVariable tv = tvrt.getTypeVariable();
				int rank = getRank(tv.getName());
				// -1 probably means it is a reference to a type variable on the
				// outer generic type (see pr129566)
				if (rank != -1) {
					retVal[i] = paramTypes[rank];
				} else {
					retVal[i] = tParms[i];
				}
			} else {
				retVal[i] = tParms[i];
			}

		}
		return retVal;
	}
================= fetch public World getWorld() { 549d227^:org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java

public World getWorld() {
		return world;
	}
================= fetch public boolean equals(Object other) { 549d227^:org.aspectj.matcher/src/org/aspectj/weaver/UnresolvedType.java
/**
	 * Equality is checked based on the underlying signature.
	 */
@Override
	public boolean equals(Object other) {
		if (!(other instanceof UnresolvedType)) {
			return false;
		}
		return signature.equals(((UnresolvedType) other).signature);
	}
================= fetch public boolean isGroovyObject() { 549d227^:org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java

public boolean isGroovyObject() {
		if ((bits & GroovyObjectInitialized) == 0) {
			ResolvedType[] intfaces = getDeclaredInterfaces();
			boolean done = false;
			// TODO do we need to walk more of these? (i.e. the interfaces interfaces and supertypes supertype). Check what groovy
			// does in the case where a hierarchy is involved and there are types in between GroovyObject/GroovyObjectSupport and
			// the type
			if (intfaces != null) {
				for (ResolvedType intface : intfaces) {
					if (intface.getName().equals("groovy.lang.GroovyObject")) {
						bits |= IsGroovyObject;
						done = true;
						break;
					}
				}
			}
			if (!done) {
				// take a look at the supertype
				if (getSuperclass().getName().equals("groovy.lang.GroovyObjectSupport")) {
					bits |= IsGroovyObject;
				}
			}
			bits |= GroovyObjectInitialized;
		}
		return (bits & IsGroovyObject) != 0;
	}
================= fetch public static ReferenceType createParameterizedType(ResolvedType aBaseType, Unre 549d227^:org.aspectj.matcher/src/org/aspectj/weaver/TypeFactory.java

public static ReferenceType createParameterizedType(ResolvedType aBaseType, UnresolvedType[] someTypeParameters, World inAWorld) {
		ResolvedType baseType = aBaseType;
		if (!aBaseType.isGenericType()) {
			// try and find the generic type...
			if (someTypeParameters != null && someTypeParameters.length > 0) {
				if (!aBaseType.isRawType()) {
					throw new IllegalStateException("Expecting raw type, not: " + aBaseType);
				}
				baseType = baseType.getGenericType();
				if (baseType == null) {
					throw new IllegalStateException("Raw type does not have generic type set");
				}
			} // else if someTypeParameters is null, then the base type is allowed to be non-generic, it's an inner
		}
		ResolvedType[] resolvedParameters = inAWorld.resolve(someTypeParameters);
		ReferenceType pType = new ReferenceType(baseType, resolvedParameters, inAWorld);
		// pType.setSourceContext(aBaseType.getSourceContext());
		return (ReferenceType) pType.resolve(inAWorld);
	}
================= fetch public void addAnnotation(AnnotationAJ annotationX) { 549d227^:org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java

@Override
	public void addAnnotation(AnnotationAJ annotationX) {
		if (annotations == null) {
			annotations = new AnnotationAJ[1];
			annotations[0] = annotationX;
		} else {
			AnnotationAJ[] newAnnotations = new AnnotationAJ[annotations.length + 1];
			System.arraycopy(annotations, 0, newAnnotations, 1, annotations.length);
			newAnnotations[0] = annotationX;
			annotations = newAnnotations;
		}
		addAnnotationType(annotationX.getType());
	}
================= fetch public void addParent(ResolvedType newParent) { 549d227^:org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java

@Override
	public void addParent(ResolvedType newParent) {
		if (newParent.isClass()) {
			newSuperclass = newParent;
			superclassReference = new WeakReference<ResolvedType>(null);
		} else {
			if (newInterfaces == null) {
				newInterfaces = new ResolvedType[1];
				newInterfaces[0] = newParent;
			} else {
				ResolvedType[] existing = getDelegate().getDeclaredInterfaces();
				if (existing != null) {
					for (int i = 0; i < existing.length; i++) {
						if (existing[i].equals(newParent)) {
							return; // already has this interface
						}
					}
				}
				ResolvedType[] newNewInterfaces = new ResolvedType[newInterfaces.length + 1];
				System.arraycopy(newInterfaces, 0, newNewInterfaces, 1, newInterfaces.length);
				newNewInterfaces[0] = newParent;
				newInterfaces = newNewInterfaces;
			}
			if (this.isGenericType()) {
				for (ReferenceType derivativeType : derivativeTypes) {
					derivativeType.parameterizedInterfaces.clear();
				}
			}
			parameterizedInterfaces.clear();
		}
	}
================= fetch public void addSourceTypeBinding(SourceTypeBinding binding, CompilationUnitDecla 549d227^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

public void addSourceTypeBinding(SourceTypeBinding binding, CompilationUnitDeclaration unit) {
		TypeDeclaration decl = binding.scope.referenceContext;

		// Deal with the raw/basic type to give us an entry in the world type map
		UnresolvedType simpleTx = null;
		if (binding.isGenericType()) {
			simpleTx = UnresolvedType.forRawTypeName(getName(binding));
		} else if (binding.isLocalType()) {
			LocalTypeBinding ltb = (LocalTypeBinding) binding;
			if (ltb.constantPoolName() != null && ltb.constantPoolName().length > 0) {
				simpleTx = UnresolvedType.forSignature(new String(binding.signature()));
			} else {
				simpleTx = UnresolvedType.forName(getName(binding));
			}
		} else {
			simpleTx = UnresolvedType.forName(getName(binding));
		}

		ReferenceType name = getWorld().lookupOrCreateName(simpleTx);

		// A type can change from simple > generic > simple across a set of compiles. We need
		// to ensure the entry in the typemap is promoted and demoted correctly. The call
		// to setGenericType() below promotes a simple to a raw. This call demotes it back
		// to simple
		// pr125405
		if (!binding.isRawType() && !binding.isGenericType() && name.getTypekind() == TypeKind.RAW) {
			name.demoteToSimpleType();
		}

		EclipseSourceType t = new EclipseSourceType(name, this, binding, decl, unit);

		// For generics, go a bit further - build a typex for the generic type
		// give it the same delegate and link it to the raw type
		if (binding.isGenericType()) {
			UnresolvedType complexTx = fromBinding(binding); // fully aware of any generics info
			ResolvedType cName = world.resolve(complexTx, true);
			ReferenceType complexName = null;
			if (!cName.isMissing()) {
				complexName = (ReferenceType) cName;
				complexName = (ReferenceType) complexName.getGenericType();
				if (complexName == null) {
					complexName = new ReferenceType(complexTx, world);
				}
			} else {
				complexName = new ReferenceType(complexTx, world);
			}
			name.setGenericType(complexName);
			complexName.setDelegate(t);
		}

		name.setDelegate(t);
		if (decl instanceof AspectDeclaration) {
			((AspectDeclaration) decl).typeX = name;
			((AspectDeclaration) decl).concreteName = t;
		}

		ReferenceBinding[] memberTypes = binding.memberTypes;
		for (int i = 0, length = memberTypes.length; i < length; i++) {
			addSourceTypeBinding((SourceTypeBinding) memberTypes[i], unit);
		}
	}
================= fetch public void checkq() { 549d227^:org.aspectj.matcher/src/org/aspectj/weaver/World.java

public void checkq() {
			if (!memoryProfiling) {
				return;
			}
			while (rq.poll() != null) {
				collectedTypes++;
			}
		}
================= fetch public void setDelegate(ReferenceTypeDelegate delegate) { 549d227^:org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java

public void setDelegate(ReferenceTypeDelegate delegate) {
		// Don't copy from BcelObjectType to EclipseSourceType - the context may
		// be tidied (result null'd) after previous weaving
		if (this.delegate != null && this.delegate.copySourceContext()
				&& this.delegate.getSourceContext() != SourceContextImpl.UNKNOWN_SOURCE_CONTEXT) {
			((AbstractReferenceTypeDelegate) delegate).setSourceContext(this.delegate.getSourceContext());
		}
		this.delegate = delegate;
		for (ReferenceType dependent : derivativeTypes) {
			dependent.setDelegate(delegate);
		}

		// If we are raw, we have a generic type - we should ensure it uses the
		// same delegate
		if (isRawType() && getGenericType() != null) {
			ReferenceType genType = (ReferenceType) getGenericType();
			if (genType.getDelegate() != delegate) { // avoids circular updates
				genType.setDelegate(delegate);
			}
		}
		clearParameterizationCaches();
		ensureConsistent();
	}
================= fetch synchronized void addDependentType(ReferenceType dependent) { 549d227^:org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java
// }
synchronized void addDependentType(ReferenceType dependent) {
		this.derivativeTypes.add(dependent);
	}
================= fetch public static void leavingPhase(ContextToken aToken) { 6defb4e^:bridge/src/org/aspectj/bridge/context/CompilationAndWeavingContext.java
/**
	 * Exit a phase, all stack entries from the one with the given token down will be removed.
	 */
public static void leavingPhase(ContextToken aToken) {
		Stack contextStack = getContextStack();
		while (!contextStack.isEmpty()) {
			ContextStackEntry entry = (ContextStackEntry) contextStack.pop();
			if (entry.contextToken == aToken) {
				break;
			}
		}
	}
================= fetch public static void reset() { 6defb4e^:bridge/src/org/aspectj/bridge/context/CompilationAndWeavingContext.java

public static void reset() {
		if (!multiThreaded) {
			contextMap.clear();
			contextStack.clear();
			formatterMap.clear();
			nextTokenId = 1;
		} else {
			contextMap.remove(Thread.currentThread());
			// TODO what about formatterMap?
			// TODO what about nextTokenId?
		}
	}
================= fetch public static void resetForThread() { 6defb4e^:bridge/src/org/aspectj/bridge/context/CompilationAndWeavingContext.java

private static Stack<ContextStackEntry> getContextStack() {
		if (!multiThreaded) {
			return contextStack;
		} else {
			Stack<ContextStackEntry> contextStack = contextMap.get(Thread.currentThread());
			if (contextStack == null) {
				contextStack = new Stack<ContextStackEntry>();
				contextMap.put(Thread.currentThread(), contextStack);
			}
			return contextStack;
		}
	}
================= fetch private static boolean handleDeclareParentsAnnotation(RuntimeAnnos runtimeAnnota f37c56e^:weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java
/**
	 * Read @DeclareParents
	 * 
	 * @param runtimeAnnotations
	 * @param struct
	 * @return true if found
	 */
private static boolean handleDeclareParentsAnnotation(RuntimeAnnos runtimeAnnotations, AjAttributeFieldStruct struct) {// ,
		// ResolvedPointcutDefinition
		// preResolvedPointcut)
		// {
		AnnotationGen decp = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREPARENTS_ANNOTATION);
		if (decp != null) {
			NameValuePair decpPatternNVP = getAnnotationElement(decp, VALUE);
			String decpPattern = decpPatternNVP.getValue().stringifyValue();
			if (decpPattern != null) {
				TypePattern typePattern = parseTypePattern(decpPattern, struct);
				ResolvedType fieldType = UnresolvedType.forSignature(struct.field.getSignature()).resolve(
						struct.enclosingType.getWorld());
				if (fieldType.isInterface()) {
					TypePattern parent = parseTypePattern(fieldType.getName(), struct);
					FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
					IScope binding = new BindingScope(struct.enclosingType, struct.context, bindings);
					// first add the declare implements like
					List<TypePattern> parents = new ArrayList<TypePattern>(1);
					parents.add(parent);
					DeclareParents dp = new DeclareParents(typePattern, parents, false);
					dp.resolve(binding); // resolves the parent and child parts
					// of the decp

					// resolve this so that we can use it for the
					// MethodDelegateMungers below.
					// eg. '@Coloured *' will change from a WildTypePattern to
					// an 'AnyWithAnnotationTypePattern' after this
					// resolution
					typePattern = typePattern.resolveBindings(binding, Bindings.NONE, false, false);
					// TODO kick ISourceLocation sl =
					// struct.bField.getSourceLocation(); ??
					// dp.setLocation(dp.getDeclaringType().getSourceContext(),
					// dp.getDeclaringType().getSourceLocation().getOffset(),
					// dp.getDeclaringType().getSourceLocation().getOffset());
					dp.setLocation(struct.context, -1, -1); // not ideal...
					struct.ajAttributes.add(new AjAttribute.DeclareAttribute(dp));

					// do we have a defaultImpl=xxx.class (ie implementation)
					String defaultImplClassName = null;
					NameValuePair defaultImplNVP = getAnnotationElement(decp, "defaultImpl");
					if (defaultImplNVP != null) {
						ClassElementValue defaultImpl = (ClassElementValue) defaultImplNVP.getValue();
						defaultImplClassName = UnresolvedType.forSignature(defaultImpl.getClassString()).getName();
						if (defaultImplClassName.equals("org.aspectj.lang.annotation.DeclareParents")) {
							defaultImplClassName = null;
						} else {
							// check public no arg ctor
							ResolvedType impl = struct.enclosingType.getWorld().resolve(defaultImplClassName, false);
							ResolvedMember[] mm = impl.getDeclaredMethods();
							int implModifiers = impl.getModifiers();
							boolean defaultVisibilityImpl = !(Modifier.isPrivate(implModifiers)
									|| Modifier.isProtected(implModifiers) || Modifier.isPublic(implModifiers));
							boolean hasNoCtorOrANoArgOne = true;
							ResolvedMember foundOneOfIncorrectVisibility = null;
							for (int i = 0; i < mm.length; i++) {
								ResolvedMember resolvedMember = mm[i];
								if (resolvedMember.getName().equals("<init>")) {
									hasNoCtorOrANoArgOne = false;

									if (resolvedMember.getParameterTypes().length == 0) {
										if (defaultVisibilityImpl) { // default
											// visibility
											// implementation
											if (resolvedMember.isPublic() || resolvedMember.isDefault()) {
												hasNoCtorOrANoArgOne = true;
											} else {
												foundOneOfIncorrectVisibility = resolvedMember;
											}
										} else if (Modifier.isPublic(implModifiers)) { // public
											// implementation
											if (resolvedMember.isPublic()) {
												hasNoCtorOrANoArgOne = true;
											} else {
												foundOneOfIncorrectVisibility = resolvedMember;
											}
										}
									}
								}
								if (hasNoCtorOrANoArgOne) {
									break;
								}
							}
							if (!hasNoCtorOrANoArgOne) {
								if (foundOneOfIncorrectVisibility != null) {
									reportError(
											"@DeclareParents: defaultImpl=\""
													+ defaultImplClassName
													+ "\" has a no argument constructor, but it is of incorrect visibility.  It must be at least as visible as the type.",
											struct);
								} else {
									reportError("@DeclareParents: defaultImpl=\"" + defaultImplClassName
											+ "\" has no public no-arg constructor", struct);
								}
							}
							if (!fieldType.isAssignableFrom(impl)) {
								reportError("@DeclareParents: defaultImpl=\"" + defaultImplClassName
										+ "\" does not implement the interface '" + fieldType.toString() + "'", struct);
							}
						}

					}

					// then iterate on field interface hierarchy (not object)
					boolean hasAtLeastOneMethod = false;
					Iterator<ResolvedMember> methodIterator = fieldType.getMethodsIncludingIntertypeDeclarations(false, true);
					while (methodIterator.hasNext()) {
						ResolvedMember method = methodIterator.next();

						// ResolvedMember[] methods = fieldType.getMethodsWithoutIterator(true, false, false).toArray(
						// new ResolvedMember[0]);
						// for (int i = 0; i < methods.length; i++) {
						// ResolvedMember method = methods[i];
						if (method.isAbstract()) {
							// moved to be detected at weave time if the target
							// doesnt implement the methods
							// if (defaultImplClassName == null) {
							// // non marker interface with no default impl
							// provided
							// reportError("@DeclareParents: used with a non marker interface and no defaultImpl=\"...\" provided",
							// struct);
							// return false;
							// }
							hasAtLeastOneMethod = true;
							// What we are saying here:
							// We have this method 'method' and we want to put a
							// forwarding method into a type that matches
							// typePattern that should delegate to the version
							// of the method in 'defaultImplClassName'

							// Now the method may be from a supertype but the
							// declaring type of the method we pass into the
							// type
							// munger is what is used to determine the type of
							// the field that hosts the delegate instance.
							// So here we create a modified method with an
							// alternative declaring type so that we lookup
							// the right field. See pr164016.
							MethodDelegateTypeMunger mdtm = new MethodDelegateTypeMunger(method, struct.enclosingType,
									defaultImplClassName, typePattern);
							mdtm.setFieldType(fieldType);
							mdtm.setSourceLocation(struct.enclosingType.getSourceLocation());
							struct.ajAttributes.add(new AjAttribute.TypeMunger(mdtm));
						}
					}
					// successfull so far, we thus need a bcel type munger to
					// have
					// a field hosting the mixin in the target type
					if (hasAtLeastOneMethod && defaultImplClassName != null) {
						ResolvedMember fieldHost = AjcMemberMaker.itdAtDeclareParentsField(null, fieldType, struct.enclosingType);
						struct.ajAttributes.add(new AjAttribute.TypeMunger(new MethodDelegateTypeMunger.FieldHostTypeMunger(
								fieldHost, struct.enclosingType, typePattern)));
					}

					return true;
				} else {
					reportError("@DeclareParents: can only be used on a field whose type is an interface", struct);
					return false;
				}
			}
		}
		return false;
	}
================= fetch private static int locateFirstBracket(StringBuffer signature) { 89756cd^:org.aspectj.matcher/src/org/aspectj/weaver/TypeFactory.java

private static UnresolvedType[] createTypeParams(String typeParameterSpecification) {
		String remainingToProcess = typeParameterSpecification;
		List<UnresolvedType> types = new ArrayList<UnresolvedType>();
		while (remainingToProcess.length() != 0) {
			int endOfSig = 0;
			int anglies = 0;
			boolean hadAnglies = false;
			boolean sigFound = false; // OPTIMIZE can this be done better?
			for (endOfSig = 0; (endOfSig < remainingToProcess.length()) && !sigFound; endOfSig++) {
				char thisChar = remainingToProcess.charAt(endOfSig);
				switch (thisChar) {
				case '<':
					anglies++;
					hadAnglies = true;
					break;
				case '>':
					anglies--;
					break;
				case '[':
					if (anglies == 0) {
						// the next char might be a [ or a primitive type ref (BCDFIJSZ)
						int nextChar = endOfSig + 1;
						while (remainingToProcess.charAt(nextChar) == '[') {
							nextChar++;
						}
						if ("BCDFIJSZ".indexOf(remainingToProcess.charAt(nextChar)) != -1) {
							// it is something like [I or [[S
							sigFound = true;
							endOfSig = nextChar;
							break;
						}
					}
					break;
				case ';':
					if (anglies == 0) {
						sigFound = true;
						break;
					}
				}
			}
			String forProcessing = remainingToProcess.substring(0, endOfSig);
			if (hadAnglies && forProcessing.charAt(0) == 'L') {
				forProcessing = "P" + forProcessing.substring(1);
			}
			types.add(createTypeFromSignature(forProcessing));
			remainingToProcess = remainingToProcess.substring(endOfSig);
		}
		UnresolvedType[] typeParams = new UnresolvedType[types.size()];
		types.toArray(typeParams);
		return typeParams;
	}
================= fetch public static UnresolvedType createTypeFromSignature(String signature) { 89756cd^:org.aspectj.matcher/src/org/aspectj/weaver/TypeFactory.java
/**
	 * Used by UnresolvedType.read, creates a type from a full signature.
	 */
public static UnresolvedType createTypeFromSignature(String signature) {
		// if (signature.equals(ResolvedType.MISSING_NAME)) {
		// return ResolvedType.MISSING;
		// }

		char firstChar = signature.charAt(0);
		if (firstChar == 'P') {
			// parameterized type, calculate signature erasure and type parameters
			// (see pr122458) It is possible for a parameterized type to have *no* type parameters visible in its signature.
			// This happens for an inner type of a parameterized type which simply inherits the type parameters
			// of its parent. In this case it is parameterized but theres no < in the signature.
			int startOfParams = signature.indexOf('<');

			if (startOfParams == -1) {
				// Should be an inner type of a parameterized type - could assert there is a '$' in the signature....
				String signatureErasure = "L" + signature.substring(1);
				return new UnresolvedType(signature, signatureErasure, UnresolvedType.NONE);
			} else {
				int endOfParams = locateMatchingEndAngleBracket(signature, startOfParams);
				StringBuffer erasureSig = new StringBuffer(signature);
				erasureSig.setCharAt(0, 'L');
				while (startOfParams != -1) {
					erasureSig.delete(startOfParams, endOfParams + 1);
					startOfParams = locateFirstBracket(erasureSig);
					if (startOfParams != -1) {
						endOfParams = locateMatchingEndAngleBracket(erasureSig, startOfParams);
					}
				}

				String signatureErasure = erasureSig.toString();// "L" + erasureSig.substring(1);

				// the type parameters of interest are only those that apply to the 'last type' in the signature
				// if the signature is 'PMyInterface<String>$MyOtherType;' then there are none...
				String lastType = null;
				int nestedTypePosition = signature.indexOf("$", endOfParams); // don't look for $ INSIDE the parameters
				if (nestedTypePosition != -1) {
					lastType = signature.substring(nestedTypePosition + 1);
				} else {
					lastType = new String(signature);
				}
				startOfParams = lastType.indexOf("<");
				UnresolvedType[] typeParams = UnresolvedType.NONE;
				if (startOfParams != -1) {
					endOfParams = locateMatchingEndAngleBracket(lastType, startOfParams);
					typeParams = createTypeParams(lastType.substring(startOfParams + 1, endOfParams));
				}
				StringBuilder s = new StringBuilder();
				int firstAngleBracket = signature.indexOf('<');
				s.append("P").append(signature.substring(1, firstAngleBracket));
				s.append('<');
				for (UnresolvedType typeParameter : typeParams) {
					s.append(typeParameter.getSignature());
				}
				s.append(">;");
				signature = s.toString();// 'P' + signature.substring(1);
				return new UnresolvedType(signature, signatureErasure, typeParams);
			}
			// can't replace above with convertSigToType - leads to stackoverflow
		} else if ((firstChar == '?' || firstChar == '*') && signature.length() == 1) {
			return WildcardedUnresolvedType.QUESTIONMARK;
		} else if (firstChar == '+') {
			// ? extends ...
			UnresolvedType upperBound = convertSigToType(signature.substring(1));
			WildcardedUnresolvedType wildcardedUT = new WildcardedUnresolvedType(signature, upperBound, null);
			return wildcardedUT;
		} else if (firstChar == '-') {
			// ? super ...
			UnresolvedType lowerBound = convertSigToType(signature.substring(1));
			WildcardedUnresolvedType wildcardedUT = new WildcardedUnresolvedType(signature, null, lowerBound);
			return wildcardedUT;
		} else if (firstChar == 'T') {
			String typeVariableName = signature.substring(1);
			if (typeVariableName.endsWith(";")) {
				typeVariableName = typeVariableName.substring(0, typeVariableName.length() - 1);
			}
			return new UnresolvedTypeVariableReferenceType(new TypeVariable(typeVariableName));
		} else if (firstChar == '[') {
			int dims = 0;
			while (signature.charAt(dims) == '[') {
				dims++;
			}
			UnresolvedType componentType = createTypeFromSignature(signature.substring(dims));
			return new UnresolvedType(signature, signature.substring(0, dims) + componentType.getErasureSignature());
		} else if (signature.length() == 1) { // could be a primitive
			switch (firstChar) {

			case 'V':
				return UnresolvedType.VOID;
			case 'Z':
				return UnresolvedType.BOOLEAN;
			case 'B':
				return UnresolvedType.BYTE;
			case 'C':
				return UnresolvedType.CHAR;
			case 'D':
				return UnresolvedType.DOUBLE;
			case 'F':
				return UnresolvedType.FLOAT;
			case 'I':
				return UnresolvedType.INT;
			case 'J':
				return UnresolvedType.LONG;
			case 'S':
				return UnresolvedType.SHORT;
			}
		} else if (firstChar == '@') {
			// missing type
			return ResolvedType.MISSING;
		} else if (firstChar == 'L') {
			// only an issue if there is also an angle bracket
			int leftAngleBracket = signature.indexOf('<');

			if (leftAngleBracket == -1) {
				return new UnresolvedType(signature);
			} else {
				int endOfParams = locateMatchingEndAngleBracket(signature, leftAngleBracket);
				StringBuffer erasureSig = new StringBuffer(signature);
				erasureSig.setCharAt(0, 'L');
				while (leftAngleBracket != -1) {
					erasureSig.delete(leftAngleBracket, endOfParams + 1);
					leftAngleBracket = locateFirstBracket(erasureSig);
					if (leftAngleBracket != -1) {
						endOfParams = locateMatchingEndAngleBracket(erasureSig, leftAngleBracket);
					}
				}

				String signatureErasure = erasureSig.toString();

				// TODO should consider all the intermediate parameterizations as well!
				// the type parameters of interest are only those that apply to the 'last type' in the signature
				// if the signature is 'PMyInterface<String>$MyOtherType;' then there are none...
				String lastType = null;
				int nestedTypePosition = signature.indexOf("$", endOfParams); // don't look for $ INSIDE the parameters
				if (nestedTypePosition != -1) {
					lastType = signature.substring(nestedTypePosition + 1);
				} else {
					lastType = new String(signature);
				}
				leftAngleBracket = lastType.indexOf("<");
				UnresolvedType[] typeParams = UnresolvedType.NONE;
				if (leftAngleBracket != -1) {
					endOfParams = locateMatchingEndAngleBracket(lastType, leftAngleBracket);
					typeParams = createTypeParams(lastType.substring(leftAngleBracket + 1, endOfParams));
				}
				StringBuilder s = new StringBuilder();
				int firstAngleBracket = signature.indexOf('<');
				s.append("P").append(signature.substring(1, firstAngleBracket));
				s.append('<');
				for (UnresolvedType typeParameter : typeParams) {
					s.append(typeParameter.getSignature());
				}
				s.append(">;");
				signature = s.toString();// 'P' + signature.substring(1);
				return new UnresolvedType(signature, signatureErasure, typeParams);
			}

		}
		return new UnresolvedType(signature);
	}
================= fetch private static String makeDeclaredSignature(ResolvedType aGenericType, Unresolve 942da06^:org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java

private static String makeDeclaredSignature(ResolvedType aGenericType, UnresolvedType[] someParameters) {
		StringBuffer ret = new StringBuffer();
		String rawSig = aGenericType.getErasureSignature();
		ret.append(rawSig.substring(0, rawSig.length() - 1));
		ret.append("<");
		for (int i = 0; i < someParameters.length; i++) {
			try {
				ret.append(((ReferenceType) someParameters[i]).getSignatureForAttribute());
			} catch (ClassCastException cce) {
				throw new IllegalStateException("DebugFor325731: expected a ReferenceType but was "+someParameters[i]+
						" of type "+someParameters[i].getClass().getName(),cce);
			}
		}
		ret.append(">;");
		return ret.toString();
	}
================= fetch private void clearParameterizationCaches() { 942da06^:org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java

private void clearParameterizationCaches() {
		parameterizedFields = null;
		parameterizedInterfaces.clear();
		parameterizedMethods = null;
		parameterizedPointcuts = null;
		superclassReference = new WeakReference<ResolvedType>(null);
	}
================= fetch public AnnotationAJ getAnnotationOfType(UnresolvedType ofType) { 942da06^:org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java

@Override
	public AnnotationAJ getAnnotationOfType(UnresolvedType ofType) {
		AnnotationAJ[] axs = getDelegate().getAnnotations();
		if (axs == null) {
			if (annotations != null) {
				String searchSig = ofType.getSignature();
				for (int i = 0; i < annotations.length; i++) {
					if (annotations[i].getTypeSignature().equals(searchSig)) {
						return annotations[i];
					}
				}
			}
			return null;
		}
		for (int i = 0; i < axs.length; i++) {
			if (axs[i].getTypeSignature().equals(ofType.getSignature())) {
				return axs[i];
			}
		}
		return null;
	}
================= fetch public WeaverStateInfo getWeaverState() { 942da06^:org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java
/**
	 * It is possible this type has multiple type variables but the interface we are about to parameterize only uses a subset - this
	 * method determines the subset to use by looking at the type variable names used. For example: <code>
	 * class Foo<T extends String,E extends Number> implements SuperInterface<T> {}
	 * </code> where <code>
	 * interface SuperInterface<Z> {}
	 * </code> In that example, a use of the 'Foo' raw type should know that it implements the SuperInterface<String>.
	 */
private UnresolvedType[] determineThoseTypesToUse(ResolvedType parameterizedInterface, UnresolvedType[] paramTypes) {
		// What are the type parameters for the supertype?
		UnresolvedType[] tParms = parameterizedInterface.getTypeParameters();
		UnresolvedType[] retVal = new UnresolvedType[tParms.length];

		// Go through the supertypes type parameters, if any of them is a type
		// variable, use the
		// real type variable on the declaring type.

		// it is possibly overkill to look up the type variable - ideally the
		// entry in the type parameter list for the
		// interface should be the a ref to the type variable in the current
		// type ... but I'm not 100% confident right now.
		for (int i = 0; i < tParms.length; i++) {
			UnresolvedType tParm = tParms[i];
			if (tParm.isTypeVariableReference()) {
				TypeVariableReference tvrt = (TypeVariableReference) tParm;
				TypeVariable tv = tvrt.getTypeVariable();
				int rank = getRank(tv.getName());
				// -1 probably means it is a reference to a type variable on the
				// outer generic type (see pr129566)
				if (rank != -1) {
					retVal[i] = paramTypes[rank];
				} else {
					retVal[i] = tParms[i];
				}
			} else {
				retVal[i] = tParms[i];
			}

		}
		return retVal;
	}
================= fetch public void addParent(ResolvedType newParent) { 942da06^:org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java

@Override
	public void addParent(ResolvedType newParent) {
		if (newParent.isClass()) {
			newSuperclass = newParent;
			superclassReference = new WeakReference<ResolvedType>(null);
		} else {
			if (newInterfaces == null) {
				newInterfaces = new ResolvedType[1];
				newInterfaces[0] = newParent;
			} else {
				ResolvedType[] existing = getDelegate().getDeclaredInterfaces();
				if (existing != null) {
					for (int i = 0; i < existing.length; i++) {
						if (existing[i].equals(newParent)) {
							return; // already has this interface
						}
					}
				}
				ResolvedType[] newNewInterfaces = new ResolvedType[newInterfaces.length + 1];
				System.arraycopy(newInterfaces, 0, newNewInterfaces, 1, newInterfaces.length);
				newNewInterfaces[0] = newParent;
				newInterfaces = newNewInterfaces;
			}
			if (this.isGenericType()) {
				for (ReferenceType derivativeType:derivativeTypes) {
					derivativeType.parameterizedInterfaces.clear();
				}
			}
			parameterizedInterfaces.clear();
		}
	}
================= fetch public void setGenericType(ReferenceType rt) { 942da06^:org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java

public void setGenericType(ReferenceType rt) {
		genericType = rt;
		// Should we 'promote' this reference type from simple to raw?
		// makes sense if someone is specifying that it has a generic form
		if (typeKind == TypeKind.SIMPLE) {
			typeKind = TypeKind.RAW;
			signatureErasure = signature;
		}
		if (typeKind==TypeKind.RAW){
			genericType.addDependentType(this);
		}
		if (this.isRawType() && rt.isRawType()) {
			new RuntimeException("PR341926 diagnostics: Incorrect setup for a generic type, raw type should not point to raw: "
					+ this.getName()).printStackTrace();
		}
	}
================= fetch private void copyResourcesFromFile(File f, String filename, File src) throws IOE 14a6eac^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

void copyResourcesFromFile(File f, String filename, File src) throws IOException {
		if (!acceptResource(filename, true)) {
			return;
		}
		FileInputStream fis = null;
		try {
			fis = new FileInputStream(f);
			byte[] bytes = FileUtil.readAsByteArray(fis);
			// String relativePath = files[i].getPath();

			writeResource(filename, bytes, src);
		} finally {
			if (fis != null) {
				fis.close();
			}
		}
	}
Progress : [######----------------------------------] 17%================= fetch public static Definition parse(final URL url) throws Exception { e71e287^:weaver/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java

public static Definition parse(final URL url) throws Exception {
		InputStream in = null;
		try {
			if (CACHE && parsedFiles.containsKey(url.toString())) {
				return parsedFiles.get(url.toString());
			}
			Definition def=null;
			
			if(LIGHTPARSER){	
				def = SimpleAOPParser.parse(url);
			}else{
				def = saxParsing(url);
			}
		
			if (CACHE && def.getAspectClassNames().size() > 0) {
				parsedFiles.put(url.toString(), def);
			}

			return def;
		} finally {
			try {
				in.close();
			} catch (Throwable t) {

			}
		}
	}
================= fetch private File getBinaryFile() { 0f506ab^:org.aspectj.matcher/src/org/aspectj/weaver/ShadowMunger.java
/**
	 * Returns the File with pathname to the class file, for example either C:\temp
	 * \ajcSandbox\workspace\ajcTest16957.tmp\simple.jar!pkg\BinaryAspect.class if the class file is in a jar file, or
	 * C:\temp\ajcSandbox\workspace\ajcTest16957.tmp!pkg\BinaryAspect.class if the class file is in a directory
	 */
private File getBinaryFile() {
		if (binaryFile == null) {
			String s = getDeclaringType().getBinaryPath();
			if (s.indexOf("!") == -1) {
				File f = getDeclaringType().getSourceLocation().getSourceFile();
				// Replace the source file suffix with .class
				int i = f.getPath().lastIndexOf('.');
				String path = null;
				if (i != -1) {
					path = f.getPath().substring(0, i) + ".class";
				} else {
					path = f.getPath() + ".class";
				}
				binaryFile = new File(s + "!" + path);
			} else {
				binaryFile = new File(s);
			}
		}
		return binaryFile;
	}
================= fetch public ISourceLocation getBinarySourceLocation(ISourceLocation sl) { 0f506ab^:org.aspectj.matcher/src/org/aspectj/weaver/ShadowMunger.java
/**
	 * Returns the binarySourceLocation for the given sourcelocation. This isn't cached because it's used when faulting in the
	 * binary nodes and is called with ISourceLocations for all advice, pointcuts and deows contained within the
	 * resolvedDeclaringAspect.
	 */
public ISourceLocation getBinarySourceLocation(ISourceLocation sl) {
		if (sl == null) {
			return null;
		}
		String sourceFileName = null;
		if (getDeclaringType() instanceof ReferenceType) {
			String s = ((ReferenceType) getDeclaringType()).getDelegate().getSourcefilename();
			int i = s.lastIndexOf('/');
			if (i != -1) {
				sourceFileName = s.substring(i + 1);
			} else {
				sourceFileName = s;
			}
		}
		ISourceLocation sLoc = new SourceLocation(getBinaryFile(), sl.getLine(), sl.getEndLine(),
				((sl.getColumn() == 0) ? ISourceLocation.NO_COLUMN : sl.getColumn()), sl.getContext(), sourceFileName);
		return sLoc;
	}
================= fetch private boolean doesAlreadyHaveAnnotation(LazyMethodGen rm, ResolvedMember itdfi 6ae463a^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

private Set<String> findAspectsForMungers(LazyMethodGen mg) {
		Set<String> aspectsAffectingType = new HashSet<String>();
		for (BcelShadow shadow : mg.matchedShadows) {
			for (ShadowMunger munger : shadow.getMungers()) {
				if (munger instanceof BcelAdvice) {
					BcelAdvice bcelAdvice = (BcelAdvice) munger;
					if (bcelAdvice.getConcreteAspect() != null) {
						aspectsAffectingType.add(bcelAdvice.getConcreteAspect().getSignature());
					}
				} else {
					// It is a 'Checker' - we don't need to remember aspects
					// that only contributed Checkers...
				}
			}
		}
		return aspectsAffectingType;
	}
================= fetch private boolean inlineSelfConstructors(List<LazyMethodGen> methodGens) { 6ae463a^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

private boolean inlineSelfConstructors(List<LazyMethodGen> methodGens) {
		boolean inlinedSomething = false;
		for (LazyMethodGen methodGen : methodGens) {
			if (!methodGen.getName().equals("<init>")) {
				continue;
			}
			InstructionHandle ih = findSuperOrThisCall(methodGen);
			if (ih != null && isThisCall(ih)) {
				LazyMethodGen donor = getCalledMethod(ih);
				inlineMethod(donor, methodGen, ih);
				inlinedSomething = true;
			}
		}
		return inlinedSomething;
	}
================= fetch private void matchInvokeInstruction(LazyMethodGen mg, InstructionHandle ih, Invo 6ae463a^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

private void matchInvokeInstruction(LazyMethodGen mg, InstructionHandle ih, InvokeInstruction invoke,
			BcelShadow enclosingShadow, List<BcelShadow> shadowAccumulator) {
		String methodName = invoke.getName(cpg);
		if (methodName.startsWith(NameMangler.PREFIX)) {
			Member jpSig = world.makeJoinPointSignatureForMethodInvocation(clazz, invoke);
			ResolvedMember declaredSig = jpSig.resolve(world);
			// System.err.println(method + ", declaredSig: " +declaredSig);
			if (declaredSig == null) {
				return;
			}

			if (declaredSig.getKind() == Member.FIELD) {
				Shadow.Kind kind;
				if (jpSig.getReturnType().equals(ResolvedType.VOID)) {
					kind = Shadow.FieldSet;
				} else {
					kind = Shadow.FieldGet;
				}

				if (canMatch(Shadow.FieldGet) || canMatch(Shadow.FieldSet)) {
					match(BcelShadow.makeShadowForMethodCall(world, mg, ih, enclosingShadow, kind, declaredSig), shadowAccumulator);
				}
			} else {
				AjAttribute.EffectiveSignatureAttribute effectiveSig = declaredSig.getEffectiveSignature();
				if (effectiveSig == null) {
					return;
				}
				// System.err.println("call to inter-type member: " +
				// effectiveSig);
				if (effectiveSig.isWeaveBody()) {
					return;
				}

				ResolvedMember rm = effectiveSig.getEffectiveSignature();
				fixParameterNamesForResolvedMember(rm, declaredSig);
				fixAnnotationsForResolvedMember(rm, declaredSig); // abracadabra

				if (canMatch(effectiveSig.getShadowKind())) {
					match(BcelShadow.makeShadowForMethodCall(world, mg, ih, enclosingShadow, effectiveSig.getShadowKind(), rm),
							shadowAccumulator);
				}
			}
		} else {
			if (canMatch(Shadow.MethodCall)) {
				boolean proceed = true;
				// overweaving needs to ignore some calls added by the previous weave
				if (world.isOverWeaving()) {
					String s = invoke.getClassName(mg.getConstantPool());
					// skip all the inc/dec/isValid/etc
					if (s.length() > 4
							&& s.charAt(4) == 'a'
							&& (s.equals("org.aspectj.runtime.internal.CFlowCounter")
									|| s.equals("org.aspectj.runtime.internal.CFlowStack") || s
									.equals("org.aspectj.runtime.reflect.Factory"))) {
						proceed = false;
					} else {
						if (methodName.equals("aspectOf")) {
							proceed = false;
						}
					}
				}
				if (proceed) {
					match(BcelShadow.makeMethodCall(world, mg, ih, enclosingShadow), shadowAccumulator);
				}
			}
		}
	}
================= fetch public boolean weave() { 6ae463a^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
	 * Weave a class and indicate through the return value whether the class was modified.
	 * 
	 * @return true if the class was modified
	 */
public boolean weave() {
		if (clazz.isWoven() && !clazz.isReweavable()) {
			world.showMessage(IMessage.ERROR, WeaverMessages.format(WeaverMessages.ALREADY_WOVEN, clazz.getType().getName()),
					ty.getSourceLocation(), null);
			return false;
		}

		Set<String> aspectsAffectingType = null;
		if (inReweavableMode || clazz.getType().isAspect()) {
			aspectsAffectingType = new HashSet<String>();
		}

		boolean isChanged = false;

		// we want to "touch" all aspects
		if (clazz.getType().isAspect()) {
			isChanged = true;
		}

		WeaverStateInfo typeWeaverState = (world.isOverWeaving() ? getLazyClassGen().getType().getWeaverState() : null);
		// start by munging all typeMungers
		for (ConcreteTypeMunger o : typeMungers) {
			if (!(o instanceof BcelTypeMunger)) {
				// ???System.err.println("surprising: " + o);
				continue;
			}
			BcelTypeMunger munger = (BcelTypeMunger) o;

			if (typeWeaverState != null && typeWeaverState.isAspectAlreadyApplied(munger.getAspectType())) {
				continue;
			}
			boolean typeMungerAffectedType = munger.munge(this);
			if (typeMungerAffectedType) {
				isChanged = true;
				if (inReweavableMode || clazz.getType().isAspect()) {
					aspectsAffectingType.add(munger.getAspectType().getSignature());
				}
			}
		}

		// Weave special half type/half shadow mungers...
		isChanged = weaveDeclareAtMethodCtor(clazz) || isChanged;
		isChanged = weaveDeclareAtField(clazz) || isChanged;

		// XXX do major sort of stuff
		// sort according to: Major: type hierarchy
		// within each list: dominates
		// don't forget to sort addedThisInitialiers according to dominates
		addedSuperInitializersAsList = new ArrayList<IfaceInitList>(addedSuperInitializers.values());
		addedSuperInitializersAsList = PartialOrder.sort(addedSuperInitializersAsList);
		if (addedSuperInitializersAsList == null) {
			throw new BCException("circularity in inter-types");
		}

		// this will create a static initializer if there isn't one
		// this is in just as bad taste as NOPs
		LazyMethodGen staticInit = clazz.getStaticInitializer();
		staticInit.getBody().insert(genInitInstructions(addedClassInitializers, true));

		// now go through each method, and match against each method. This
		// sets up each method's {@link LazyMethodGen#matchedShadows} field,
		// and it also possibly adds to {@link #initializationShadows}.
		List<LazyMethodGen> methodGens = new ArrayList<LazyMethodGen>(clazz.getMethodGens());
		for (LazyMethodGen member : methodGens) {
			if (!member.hasBody()) {
				continue;
			}
			if (world.isJoinpointSynchronizationEnabled() && world.areSynchronizationPointcutsInUse()
					&& member.getMethod().isSynchronized()) {
				transformSynchronizedMethod(member);
			}
			boolean shadowMungerMatched = match(member);
			if (shadowMungerMatched) {
				// For matching mungers, add their declaring aspects to the list
				// that affected this type
				if (inReweavableMode || clazz.getType().isAspect()) {
					aspectsAffectingType.addAll(findAspectsForMungers(member));
				}
				isChanged = true;
			}
		}

		// now we weave all but the initialization shadows
		for (LazyMethodGen methodGen : methodGens) {
			if (!methodGen.hasBody()) {
				continue;
			}
			implement(methodGen);
		}

		// if we matched any initialization shadows, we inline and weave
		if (!initializationShadows.isEmpty()) {
			// Repeat next step until nothing left to inline...cant go on
			// infinetly as compiler will have detected and reported
			// "Recursive constructor invocation"
			while (inlineSelfConstructors(methodGens)) {
			}
			positionAndImplement(initializationShadows);
		}

		// now proceed with late type mungers
		if (lateTypeMungers != null) {
			for (Iterator<ConcreteTypeMunger> i = lateTypeMungers.iterator(); i.hasNext();) {
				BcelTypeMunger munger = (BcelTypeMunger) i.next();
				if (munger.matches(clazz.getType())) {
					boolean typeMungerAffectedType = munger.munge(this);
					if (typeMungerAffectedType) {
						isChanged = true;
						if (inReweavableMode || clazz.getType().isAspect()) {
							aspectsAffectingType.add(munger.getAspectType().getSignature());
						}
					}
				}
			}
		}

		// FIXME AV - see #75442, for now this is not enough to fix the bug,
		// comment that out until we really fix it
		// // flush to save some memory
		// PerObjectInterfaceTypeMunger.unregisterFromAsAdvisedBy(clazz.getType()
		// );

		// finally, if we changed, we add in the introduced methods.
		if (isChanged) {
			clazz.getOrCreateWeaverStateInfo(inReweavableMode);
			weaveInAddedMethods(); // FIXME asc are these potentially affected
			// by declare annotation?
		}

		if (inReweavableMode) {
			WeaverStateInfo wsi = clazz.getOrCreateWeaverStateInfo(true);
			wsi.addAspectsAffectingType(aspectsAffectingType);
			wsi.setUnwovenClassFileData(ty.getJavaClass().getBytes());
			wsi.setReweavable(true);
		} else {
			clazz.getOrCreateWeaverStateInfo(false).setReweavable(false);
		}

		// tidyup, reduce ongoing memory usage of BcelMethods that hang around
		for (LazyMethodGen mg : methodGens) {
			BcelMethod method = mg.getMemberView();
			if (method != null) {
				method.wipeJoinpointSignatures();
			}
		}

		return isChanged;
	}
================= fetch public ResolvedType fromType(Type aType) { 167b801^:weaver5/java5-src/org/aspectj/weaver/reflect/JavaLangTypeToResolvedTypeConverter.java

public ResolvedType[] fromTypes(Type[] types) {
		ResolvedType[] ret = new ResolvedType[types.length];
		for (int i = 0; i < ret.length; i++) {
			ret[i] = fromType(types[i]);
		}
		return ret;
	}
================= fetch private void deleteNewAndDup() { e8ef5bf^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

private void deleteNewAndDup() {
		final ConstantPool cpg = getEnclosingClass().getConstantPool();
		int depth = 1;
		InstructionHandle ih = range.getStart();

		// Go back from where we are looking for 'NEW' that takes us to a stack depth of 0. INVOKESPECIAL <init>
		while (true) {
			Instruction inst = ih.getInstruction();
			if (inst.opcode == Constants.INVOKESPECIAL && ((InvokeInstruction) inst).getName(cpg).equals("<init>")) {
				depth++;
			} else if (inst.opcode == Constants.NEW) {
				depth--;
				if (depth == 0) {
					break;
				}
				// need a testcase to show this can really happen in a modern compiler - removed due to 315398
				// } else if (inst.opcode == Constants.DUP_X2) {
				// // This code seen in the wild (by Brad):
				// // 40: new #12; //class java/lang/StringBuffer
				// // STACK: STRINGBUFFER
				// // 43: dup
				// // STACK: STRINGBUFFER/STRINGBUFFER
				// // 44: aload_0
				// // STACK: STRINGBUFFER/STRINGBUFFER/THIS
				// // 45: dup_x2
				// // STACK: THIS/STRINGBUFFER/STRINGBUFFER/THIS
				// // 46: getfield #36; //Field value:Ljava/lang/String;
				// // STACK: THIS/STRINGBUFFER/STRINGBUFFER/STRING<value>
				// // 49: invokestatic #37; //Method java/lang/String.valueOf:(Ljava/lang/Object;)Ljava/lang/String;
				// // STACK: THIS/STRINGBUFFER/STRINGBUFFER/STRING
				// // 52: invokespecial #19; //Method java/lang/StringBuffer."<init>":(Ljava/lang/String;)V
				// // STACK: THIS/STRINGBUFFER
				// // 55: aload_1
				// // STACK: THIS/STRINGBUFFER/LOCAL1
				// // 56: invokevirtual #22; //Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
				// // STACK: THIS/STRINGBUFFER
				// // 59: invokevirtual #34; //Method java/lang/StringBuffer.toString:()Ljava/lang/String;
				// // STACK: THIS/STRING
				// // 62: putfield #36; //Field value:Ljava/lang/String;
				// // STACK: <empty>
				// // 65: return
				//
				// // if we attempt to match on the ctor call to StringBuffer.<init> then we get into trouble.
				// // if we simply delete the new/dup pair without fixing up the dup_x2 then the dup_x2 will fail due to there
				// // not being 3 elements on the stack for it to work with. The fix *in this situation* is to change it to
				// // a simple 'dup'
				//
				// // this fix is *not* very clean - but a general purpose decent solution will take much longer and this
				// // bytecode sequence has only been seen once in the wild.
				// ih.setInstruction(InstructionConstants.DUP);
			}
			ih = ih.getPrev();
		}
		// now IH points to the NEW. We're followed by the DUP, and that is followed
		// by the actual instruction we care about.
		InstructionHandle newHandle = ih;
		InstructionHandle endHandle = newHandle.getNext();
		InstructionHandle nextHandle;
		if (endHandle.getInstruction().opcode == Constants.DUP) {
			nextHandle = endHandle.getNext();
			retargetFrom(newHandle, nextHandle);
			retargetFrom(endHandle, nextHandle);
		} else if (endHandle.getInstruction().opcode == Constants.DUP_X1) {
			InstructionHandle dupHandle = endHandle;
			endHandle = endHandle.getNext();
			nextHandle = endHandle.getNext();
			boolean skipEndRepositioning = false;
			if (endHandle.getInstruction().opcode == Constants.SWAP) {
			} else if (endHandle.getInstruction().opcode == Constants.IMPDEP1) {
				skipEndRepositioning = true; // pr186884
			} else {
				// XXX see next XXX comment
				throw new RuntimeException("Unhandled kind of new " + endHandle);
			}
			// Now make any jumps to the 'new', the 'dup' or the 'end' now target the nextHandle
			retargetFrom(newHandle, nextHandle);
			retargetFrom(dupHandle, nextHandle);
			if (!skipEndRepositioning) {
				retargetFrom(endHandle, nextHandle);
			}
		} else {
			endHandle = newHandle;
			nextHandle = endHandle.getNext();
			retargetFrom(newHandle, nextHandle);
			// add a POP here... we found a NEW w/o a dup or anything else, so
			// we must be in statement context.
			getRange().insert(InstructionConstants.POP, Range.OutsideAfter);
		}
		// assert (dupHandle.getInstruction() instanceof DUP);

		try {
			range.getBody().delete(newHandle, endHandle);
		} catch (TargetLostException e) {
			throw new BCException("shouldn't happen");
		}
	}
================= fetch protected void prepareForMungers() { e8ef5bf^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

@Override
	protected void prepareForMungers() {
		// if we're a constructor call, we need to remove the new:dup or the new:dup_x1:swap,
		// and store all our arguments on the frame.

		// ??? This is a bit of a hack (for the Java langauge). We do this because
		// we sometime add code "outsideBefore" when dealing with weaving join points. We only
		// do this for exposing state that is on the stack. It turns out to just work for
		// everything except for constructor calls and exception handlers. If we were to clean
		// this up, every ShadowRange would have three instructionHandle points, the start of
		// the arg-setup code, the start of the running code, and the end of the running code.
		if (getKind() == ConstructorCall) {
			if (!world.isJoinpointArrayConstructionEnabled() || !this.getSignature().getDeclaringType().isArray()) {
				deleteNewAndDup(); // no new/dup for new array construction
			}
			initializeArgVars();
		} else if (getKind() == PreInitialization) { // pr74952
			ShadowRange range = getRange();
			range.insert(InstructionConstants.NOP, Range.InsideAfter);
		} else if (getKind() == ExceptionHandler) {

			ShadowRange range = getRange();
			InstructionList body = range.getBody();
			InstructionHandle start = range.getStart();

			// Create a store instruction to put the value from the top of the
			// stack into a local variable slot. This is a trimmed version of
			// what is in initializeArgVars() (since there is only one argument
			// at a handler jp and only before advice is supported) (pr46298)
			argVars = new BcelVar[1];
			// int positionOffset = (hasTarget() ? 1 : 0) + ((hasThis() && !getKind().isTargetSameAsThis()) ? 1 : 0);
			UnresolvedType tx = getArgType(0);
			argVars[0] = genTempVar(tx, "ajc$arg0");
			InstructionHandle insertedInstruction = range.insert(argVars[0].createStore(getFactory()), Range.OutsideBefore);

			// Now the exception range starts just after our new instruction.
			// The next bit of code changes the exception range to point at
			// the store instruction
			for (InstructionTargeter t : start.getTargetersCopy()) {
				if (t instanceof ExceptionRange) {
					ExceptionRange er = (ExceptionRange) t;
					er.updateTarget(start, insertedInstruction, body);
				}
			}
		}

		// now we ask each munger to request our state
		isThisJoinPointLazy = true;// world.isXlazyTjp(); // lazy is default now

		badAdvice = null;
		for (ShadowMunger munger : mungers) {
			munger.specializeOn(this);
		}

		initializeThisJoinPoint();

		if (thisJoinPointVar != null && !isThisJoinPointLazy && badAdvice != null && badAdvice.size() > 1) {
			// something stopped us making it a lazy tjp
			// can't build tjp lazily, no suitable test...
			int valid = 0;
			for (Iterator<BcelAdvice> iter = badAdvice.iterator(); iter.hasNext();) {
				BcelAdvice element = iter.next();
				ISourceLocation sLoc = element.getSourceLocation();
				if (sLoc != null && sLoc.getLine() > 0) {
					valid++;
				}
			}
			if (valid != 0) {
				ISourceLocation[] badLocs = new ISourceLocation[valid];
				int i = 0;
				for (Iterator<BcelAdvice> iter = badAdvice.iterator(); iter.hasNext();) {
					BcelAdvice element = iter.next();
					ISourceLocation sLoc = element.getSourceLocation();
					if (sLoc != null) {
						badLocs[i++] = sLoc;
					}
				}
				world.getLint().multipleAdviceStoppingLazyTjp
						.signal(new String[] { this.toString() }, getSourceLocation(), badLocs);
			}
		}
		badAdvice = null;

		// If we are an expression kind, we require our target/arguments on the stack
		// before we do our actual thing. However, they may have been removed
		// from the stack as the shadowMungers have requested state.
		// if any of our shadowMungers requested either the arguments or target,
		// the munger will have added code
		// to pop the target/arguments into temporary variables, represented by
		// targetVar and argVars. In such a case, we must make sure to re-push the
		// values.

		// If we are nonExpressionKind, we don't expect arguments on the stack
		// so this is moot. If our argVars happen to be null, then we know that
		// no ShadowMunger has squirrelled away our arguments, so they're still
		// on the stack.
		InstructionFactory fact = getFactory();
		if (getKind().argsOnStack() && argVars != null) {

			// Special case first (pr46298). If we are an exception handler and the instruction
			// just after the shadow is a POP then we should remove the pop. The code
			// above which generated the store instruction has already cleared the stack.
			// We also don't generate any code for the arguments in this case as it would be
			// an incorrect aload.
			if (getKind() == ExceptionHandler && range.getEnd().getNext().getInstruction().equals(InstructionConstants.POP)) {
				// easier than deleting it ...
				range.getEnd().getNext().setInstruction(InstructionConstants.NOP);
			} else {
				range.insert(BcelRenderer.renderExprs(fact, world, argVars), Range.InsideBefore);
				if (targetVar != null) {
					range.insert(BcelRenderer.renderExpr(fact, world, targetVar), Range.InsideBefore);
				}
				if (getKind() == ConstructorCall) {
					if (!world.isJoinpointArrayConstructionEnabled() || !this.getSignature().getDeclaringType().isArray()) {
						range.insert(InstructionFactory.createDup(1), Range.InsideBefore);
						range.insert(fact.createNew((ObjectType) BcelWorld.makeBcelType(getSignature().getDeclaringType())),
								Range.InsideBefore);
					}
				}
			}
		}
	}
================= fetch public World getIWorld() { e8ef5bf^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
// ---- overridden behaviour
@Override
	public World getIWorld() {
		return world;
	}
================= fetch private String getClassLoaderName(ClassLoader loader) { c6fb752^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java

private String getClassLoaderName(ClassLoader loader) {
		return weavingContext.getClassLoaderName();
	}
================= fetch private String looksLikeStartsWith(String typePattern) { c6fb752^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
	 * Checks if the type pattern looks like "com.foo..*"
	 */
private String looksLikeStartsWith(String typePattern) {
		if (hasSpaceAnnotationPlus(typePattern, 0) || typePattern.charAt(typePattern.length() - 1) != '*') {
			return null;
		}
		// now must looks like with "charsss..*" or "cha.rss..*" etc
		// note that "*" and "*..*" won't be fast matched
		// and that "charsss.*" will not neither
		int length = typePattern.length();
		if (typePattern.endsWith("..*") && length > 3) {
			if (typePattern.indexOf("..") == length - 3 // no ".." before last sequence
					&& typePattern.indexOf('*') == length - 1) { // no earlier '*'
				return typePattern.substring(0, length - 2).replace('$', '.'); // "charsss." or "char.rss." etc
			}
		}
		return null;
	}
================= fetch private boolean weaveAndDefineConceteAspects() { c6fb752^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java

boolean weaveAndDefineConceteAspects() {
		if (trace.isTraceEnabled()) {
			trace.enter("weaveAndDefineConceteAspects", this, concreteAspects);
		}
		boolean success = true;

		for (Iterator iterator = concreteAspects.iterator(); iterator.hasNext();) {
			ConcreteAspectCodeGen gen = (ConcreteAspectCodeGen) iterator.next();
			String name = gen.getClassName();
			byte[] bytes = gen.getBytes();

			try {
				byte[] newBytes = weaveClass(name, bytes, true);
				this.generatedClassHandler.acceptClass(name, newBytes);
			} catch (IOException ex) {
				trace.error("weaveAndDefineConceteAspects", ex);
				error("exception weaving aspect '" + name + "'", ex);
			}
		}

		if (trace.isTraceEnabled()) {
			trace.exit("weaveAndDefineConceteAspects", success);
		}
		return success;
	}
================= fetch private void registerIncludeExclude(final BcelWeaver weaver, final ClassLoader l c6fb752^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
	 * Register the include / exclude filters. We duplicate simple patterns in startWith filters that will allow faster matching
	 * without ResolvedType
	 * 
	 * @param weaver
	 * @param loader
	 * @param definitions
	 */
private void registerIncludeExclude(final BcelWeaver weaver, final ClassLoader loader, final List definitions) {
		String fastMatchInfo = null;
		for (Iterator iterator = definitions.iterator(); iterator.hasNext();) {
			Definition definition = (Definition) iterator.next();
			for (Iterator iterator1 = definition.getIncludePatterns().iterator(); iterator1.hasNext();) {
				hasIncludes = true;
				String include = (String) iterator1.next();
				fastMatchInfo = looksLikeStartsWith(include);
				if (fastMatchInfo != null) {
					m_includeStartsWith.add(fastMatchInfo);
				} else if (include.equals("*")) {
					includeStar = true;
				} else if ((fastMatchInfo = looksLikeExactName(include)) != null) {
					includeExactName.add(fastMatchInfo);
				} else {
					TypePattern includePattern = new PatternParser(include).parseTypePattern();
					includeTypePattern.add(includePattern);
				}
			}
			for (Iterator iterator1 = definition.getExcludePatterns().iterator(); iterator1.hasNext();) {
				hasExcludes = true;
				String exclude = (String) iterator1.next();
				fastMatchInfo = looksLikeStartsWith(exclude);
				if (fastMatchInfo != null) {
					excludeStartsWith.add(fastMatchInfo);
				} else if ((fastMatchInfo = looksLikeStarDotDotStarExclude(exclude)) != null) {
					excludeStarDotDotStar.add(fastMatchInfo);
				} else if ((fastMatchInfo = looksLikeExactName(exclude)) != null) {
					excludeExactName.add(exclude);
				} else if ((fastMatchInfo = looksLikeEndsWith(exclude)) != null) {
					excludeEndsWith.add(fastMatchInfo);
				} else if (exclude
						.equals("org.codehaus.groovy..* && !org.codehaus.groovy.grails.web.servlet.mvc.SimpleGrailsController*")) {
					// TODO need a more sophisticated analysis here, to allow for similar situations
					excludeSpecial.add(new String[] { "org.codehaus.groovy.",
							"org.codehaus.groovy.grails.web.servlet.mvc.SimpleGrailsController" });
					// for the related test:
					// } else if (exclude.equals("testdata..* && !testdata.sub.Oran*")) {
					// excludeSpecial.add(new String[] { "testdata.", "testdata.sub.Oran" });
				} else {
					TypePattern excludePattern = new PatternParser(exclude).parseTypePattern();
					excludeTypePattern.add(excludePattern);
				}
			}
		}
	}
================= fetch private void registerOptions(final BcelWeaver weaver, final ClassLoader loader, c6fb752^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
	 * Configure the weaver according to the option directives TODO av - don't know if it is that good to reuse, since we only allow
	 * a small subset of options in LTW
	 * 
	 * @param weaver
	 * @param loader
	 * @param definitions
	 */
private void registerOptions(final BcelWeaver weaver, final ClassLoader loader, final List definitions) {
		StringBuffer allOptions = new StringBuffer();
		for (Iterator iterator = definitions.iterator(); iterator.hasNext();) {
			Definition definition = (Definition) iterator.next();
			allOptions.append(definition.getWeaverOptions()).append(' ');
		}

		Options.WeaverOption weaverOption = Options.parse(allOptions.toString(), loader, getMessageHandler());

		// configure the weaver and world
		// AV - code duplicates AspectJBuilder.initWorldAndWeaver()
		World world = weaver.getWorld();
		setMessageHandler(weaverOption.messageHandler);
		world.setXlazyTjp(weaverOption.lazyTjp);
		world.setXHasMemberSupportEnabled(weaverOption.hasMember);
		world.setTiming(weaverOption.timers, true);
		world.setOptionalJoinpoints(weaverOption.optionalJoinpoints);
		world.setPinpointMode(weaverOption.pinpoint);
		weaver.setReweavableMode(weaverOption.notReWeavable);
		world.performExtraConfiguration(weaverOption.xSet);
		world.setXnoInline(weaverOption.noInline);
		// AMC - autodetect as per line below, needed for AtAjLTWTests.testLTWUnweavable
		world.setBehaveInJava5Way(LangUtil.is15VMOrGreater());
		world.setAddSerialVerUID(weaverOption.addSerialVersionUID);

		/* First load defaults */
		bcelWorld.getLint().loadDefaultProperties();

		/* Second overlay LTW defaults */
		bcelWorld.getLint().adviceDidNotMatch.setKind(null);

		/* Third load user file using -Xlintfile so that -Xlint wins */
		if (weaverOption.lintFile != null) {
			InputStream resource = null;
			try {
				resource = loader.getResourceAsStream(weaverOption.lintFile);
				Exception failure = null;
				if (resource != null) {
					try {
						Properties properties = new Properties();
						properties.load(resource);
						world.getLint().setFromProperties(properties);
					} catch (IOException e) {
						failure = e;
					}
				}
				if (failure != null || resource == null) {
					warn("Cannot access resource for -Xlintfile:" + weaverOption.lintFile, failure);
					// world.getMessageHandler().handleMessage(new Message(
					// "Cannot access resource for -Xlintfile:"+weaverOption.lintFile,
					// IMessage.WARNING,
					// failure,
					// null));
				}
			} finally {
				try {
					resource.close();
				} catch (Throwable t) {
				}
			}
		}

		/* Fourth override with -Xlint */
		if (weaverOption.lint != null) {
			if (weaverOption.lint.equals("default")) {// FIXME should be AjBuildConfig.AJLINT_DEFAULT but yetanother deps..
				bcelWorld.getLint().loadDefaultProperties();
			} else {
				bcelWorld.getLint().setAll(weaverOption.lint);
				if (weaverOption.lint.equals("ignore")) {
					bcelWorld.setAllLintIgnored();
				}
			}
		}
		// TODO proceedOnError option
	}
================= fetch public void initialize(final ClassLoader classLoader, IWeavingContext context) { c6fb752^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
	 * Load and cache the aop.xml/properties according to the classloader visibility rules
	 * 
	 * @param weaver
	 * @param loader
	 */
List<Definition> parseDefinitions(final ClassLoader loader) {
		if (trace.isTraceEnabled()) {
			trace.enter("parseDefinitions", this);
		}

		List<Definition> definitions = new ArrayList<Definition>();
		try {
			info("register classloader " + getClassLoaderName(loader));
			// TODO av underoptimized: we will parse each XML once per CL that see it

			// TODO av dev mode needed ? TBD -Daj5.def=...
			if (loader.equals(ClassLoader.getSystemClassLoader())) {
				String file = System.getProperty("aj5.def", null);
				if (file != null) {
					info("using (-Daj5.def) " + file);
					definitions.add(DocumentParser.parse((new File(file)).toURL()));
				}
			}

			String resourcePath = System.getProperty("org.aspectj.weaver.loadtime.configuration", AOP_XML);
			if (trace.isTraceEnabled()) {
				trace.event("parseDefinitions", this, resourcePath);
			}

			StringTokenizer st = new StringTokenizer(resourcePath, ";");

			while (st.hasMoreTokens()) {
				String nextDefinition = st.nextToken();
				if (nextDefinition.startsWith("file:")) {
					try {
						String fpath = new URL(nextDefinition).getFile();
						File configFile = new File(fpath);
						if (!configFile.exists()) {
							warn("configuration does not exist: " + nextDefinition);
						} else {
							definitions.add(DocumentParser.parse(configFile.toURL()));
						}
					} catch (MalformedURLException mue) {
						error("malformed definition url: " + nextDefinition);
					}
				} else {
					Enumeration<URL> xmls = weavingContext.getResources(nextDefinition);
					// System.out.println("? registerDefinitions: found-aop.xml=" + xmls.hasMoreElements() + ", loader=" + loader);

					Set<URL> seenBefore = new HashSet<URL>();
					while (xmls.hasMoreElements()) {
						URL xml = xmls.nextElement();
						if (trace.isTraceEnabled()) {
							trace.event("parseDefinitions", this, xml);
						}
						if (!seenBefore.contains(xml)) {
							info("using configuration " + weavingContext.getFile(xml));
							definitions.add(DocumentParser.parse(xml));
							seenBefore.add(xml);
						} else {
							warn("ignoring duplicate definition: " + xml);
						}
					}
				}
			}
			if (definitions.isEmpty()) {
				info("no configuration found. Disabling weaver for class loader " + getClassLoaderName(loader));
			}
		} catch (Exception e) {
			definitions.clear();
			warn("parse definitions failed", e);
		}

		if (trace.isTraceEnabled()) {
			trace.exit("parseDefinitions", definitions);
		}
		return definitions;
	}
Progress : [#######---------------------------------] 18%================= fetch private void writeBack(BcelWorld world) { 8553b30^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java

private void writeBack(BcelWorld world) {
		if (getConstantPool().getSize() > Short.MAX_VALUE) {
			reportClassTooBigProblem();
			return;
		}

		if (annotations.size() > 0) {
			for (AnnotationGen element : annotations) {
				myGen.addAnnotation(element);
			}
			// Attribute[] annAttributes =
			// org.aspectj.apache.bcel.classfile.Utility.getAnnotationAttributes(
			// getConstantPool(),annotations);
			// for (int i = 0; i < annAttributes.length; i++) {
			// Attribute attribute = annAttributes[i];
			// System.err.println("Adding attribute for "+attribute);
			// myGen.addAttribute(attribute);
			// }
		}

		// Add a weaver version attribute to the file being produced (if
		// necessary...)
		if (!myGen.hasAttribute("org.aspectj.weaver.WeaverVersion")) {
			myGen.addAttribute(Utility.bcelAttribute(new AjAttribute.WeaverVersionInfo(), getConstantPool()));
		}

		if (myType != null && myType.getWeaverState() != null) {
			myGen.addAttribute(Utility.bcelAttribute(new AjAttribute.WeaverState(myType.getWeaverState()), getConstantPool()));
		}

		// FIXME ATAJ needed only for slow Aspects.aspectOf() - keep or remove
		// make a lot of test fail since the test compare weaved class file
		// based on some test data as text files...
		// if (!myGen.isInterface()) {
		// addAjClassField();
		// }

		addAjcInitializers();

		// 17Feb05 - ASC - Skip this for now - it crashes IBM 1.4.2 jvms
		// (pr80430). Will be revisited when contents
		// of attribute are confirmed to be correct.
		boolean sourceDebugExtensionSupportSwitchedOn = false;

		if (sourceDebugExtensionSupportSwitchedOn) {
			calculateSourceDebugExtensionOffsets();
		}

		int len = methodGens.size();
		myGen.setMethods(Method.NoMethods);

		for (LazyMethodGen gen : methodGens) {
			// we skip empty clinits
			if (isEmptyClinit(gen)) {
				continue;
			}
			myGen.addMethod(gen.getMethod());
		}

		len = fields.size();
		myGen.setFields(Field.NoFields);
		for (int i = 0; i < len; i++) {
			BcelField gen = fields.get(i);
			myGen.addField(gen.getField(cp));
		}

		if (sourceDebugExtensionSupportSwitchedOn) {
			if (inlinedFiles.size() != 0) {
				if (hasSourceDebugExtensionAttribute(myGen)) {
					world.showMessage(IMessage.WARNING, WeaverMessages.format(WeaverMessages.OVERWRITE_JSR45, getFileName()), null,
							null);
				}
				// myGen.addAttribute(getSourceDebugExtensionAttribute());
			}
		}

		fixupGenericSignatureAttribute();
	}
================= fetch public void addLibraryJarFile(File inFile) throws IOException { 2302e94^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
/**
	 * Look for .class files that represent aspects in the supplied directory - return the list of accumulated aspects.
	 * 
	 * @param directory the directory in which to look for Aspect .class files
	 * @return the list of discovered aspects
	 * @throws FileNotFoundException
	 * @throws IOException
	 */
private List<ResolvedType> addAspectsFromDirectory(File directory) throws FileNotFoundException, IOException {
		List<ResolvedType> addedAspects = new ArrayList<ResolvedType>();
		File[] classFiles = FileUtil.listFiles(directory, new FileFilter() {
================= fetch public void ensureAdvancedConfigurationProcessed() { bb2aea4^:org.aspectj.matcher/src/org/aspectj/weaver/World.java

public void ensureAdvancedConfigurationProcessed() {

		// Check *once* whether the user has switched asm support off
		if (!checkedAdvancedConfiguration) {
			Properties p = getExtraConfiguration();
			if (p != null) {

				String s = p.getProperty(xsetBCEL_REPOSITORY_CACHING, xsetBCEL_REPOSITORY_CACHING_DEFAULT);
				bcelRepositoryCaching = s.equalsIgnoreCase("true");
				if (!bcelRepositoryCaching) {
					getMessageHandler().handleMessage(
							MessageUtil
									.info("[bcelRepositoryCaching=false] AspectJ will not use a bcel cache for class information"));
				}

				// ITD Versions
				// 1 is the first version in use up to AspectJ 1.6.8
				// 2 is from 1.6.9 onwards
				s = p.getProperty(xsetITD_VERSION, xsetITD_VERSION_DEFAULT);
				if (s.equals(xsetITD_VERSION_ORIGINAL)) {
					itdVersion = 1;
				}

				s = p.getProperty(xsetAVOID_FINAL, "false");
				if (s.equalsIgnoreCase("true")) {
					useFinal = false; // if avoidFinal=true, then set useFinal to false
				}

				s = p.getProperty(xsetMINIMAL_MODEL, "false");
				if (s.equalsIgnoreCase("true")) {
					minimalModel = true;
				}

				s = p.getProperty(xsetTARGETING_RUNTIME_1610, "false");
				if (s.equalsIgnoreCase("true")) {
					targettingRuntime1_6_10 = true;
				}

				s = p.getProperty(xsetFAST_PACK_METHODS, "true");
				fastMethodPacking = s.equalsIgnoreCase("true");

				s = p.getProperty(xsetPIPELINE_COMPILATION, xsetPIPELINE_COMPILATION_DEFAULT);
				shouldPipelineCompilation = s.equalsIgnoreCase("true");

				s = p.getProperty(xsetGENERATE_STACKMAPS, "false");
				shouldGenerateStackMaps = s.equalsIgnoreCase("true");

				s = p.getProperty(xsetCOMPLETE_BINARY_TYPES, xsetCOMPLETE_BINARY_TYPES_DEFAULT);
				completeBinaryTypes = s.equalsIgnoreCase("true");
				if (completeBinaryTypes) {
					getMessageHandler().handleMessage(
							MessageUtil.info("[completeBinaryTypes=true] Completion of binary types activated"));
				}

				s = p.getProperty(xsetTYPE_DEMOTION); // default is: ON (for ltw) OFF (for ctw)
				if (s != null) {
					boolean b = typeMap.demotionSystemActive;
					if (b && s.equalsIgnoreCase("false")) {
						System.out.println("typeDemotion=false: type demotion switched OFF");
						typeMap.demotionSystemActive = false;
					} else if (!b && s.equalsIgnoreCase("true")) {
						System.out.println("typeDemotion=true: type demotion switched ON");
						typeMap.demotionSystemActive = true;
					}
				}

				s = p.getProperty(xsetOVERWEAVING, "false");
				if (s.equalsIgnoreCase("true")) {
					overWeaving = true;
				}

				s = p.getProperty(xsetTYPE_DEMOTION_DEBUG, "false");
				if (s.equalsIgnoreCase("true")) {
					typeMap.debugDemotion = true;
				}
				s = p.getProperty(xsetTYPE_REFS, "true");
				if (s.equalsIgnoreCase("false")) {
					typeMap.policy = TypeMap.USE_SOFT_REFS;
				}

				runMinimalMemorySet = p.getProperty(xsetRUN_MINIMAL_MEMORY) != null;
				s = p.getProperty(xsetRUN_MINIMAL_MEMORY, "false");
				runMinimalMemory = s.equalsIgnoreCase("true");
				// if (runMinimalMemory)
				// getMessageHandler().handleMessage(MessageUtil.info(
				// "[runMinimalMemory=true] Optimizing bcel processing (and cost of performance) to use less memory"
				// ));

				s = p.getProperty(xsetDEBUG_STRUCTURAL_CHANGES_CODE, "false");
				forDEBUG_structuralChangesCode = s.equalsIgnoreCase("true");

				s = p.getProperty(xsetDEBUG_BRIDGING, "false");
				forDEBUG_bridgingCode = s.equalsIgnoreCase("true");

				s = p.getProperty(xsetOPTIMIZED_MATCHING, "true");
				optimizedMatching = s.equalsIgnoreCase("true");
				if (!optimizedMatching) {
					getMessageHandler().handleMessage(MessageUtil.info("[optimizedMatching=false] optimized matching turned off"));
				}

				s = p.getProperty(xsetTIMERS_PER_JOINPOINT, "25000");
				try {
					timersPerJoinpoint = Integer.parseInt(s);
				} catch (Exception e) {
					getMessageHandler().handleMessage(MessageUtil.error("unable to process timersPerJoinpoint value of " + s));
					timersPerJoinpoint = 25000;
				}

				s = p.getProperty(xsetTIMERS_PER_FASTMATCH_CALL, "250");
				try {
					timersPerType = Integer.parseInt(s);
				} catch (Exception e) {
					getMessageHandler().handleMessage(MessageUtil.error("unable to process timersPerType value of " + s));
					timersPerType = 250;
				}

			}
			try {
				String value = System.getProperty("aspectj.overweaving", "false");
				if (value.equalsIgnoreCase("true")) {
					System.out.println("ASPECTJ: aspectj.overweaving=true: overweaving switched ON");
					overWeaving = true;
				}
				value = System.getProperty("aspectj.typeDemotion", "false");
				if (value.equalsIgnoreCase("true")) {
					System.out.println("ASPECTJ: aspectj.typeDemotion=true: type demotion switched ON");
					typeMap.demotionSystemActive = true;
				}
				value = System.getProperty("aspectj.minimalModel", "false");
				if (value.equalsIgnoreCase("true")) {
					System.out.println("ASPECTJ: aspectj.minimalModel=true: minimal model switched ON");
					minimalModel = true;
				}
			} catch (Throwable t) {
				System.err.println("ASPECTJ: Unable to read system properties");
				t.printStackTrace();
			}
			checkedAdvancedConfiguration = true;
		}
	}
================= fetch public static Instruction createSuperInvoke(InstructionFactory fact, BcelWorld w f7b1193^:weaver/src/org/aspectj/weaver/bcel/Utility.java

public static Instruction createSuperInvoke(InstructionFactory fact, BcelWorld world, Member signature) {
		short kind;
		if (Modifier.isInterface(signature.getModifiers())) {
			throw new RuntimeException("bad");
		} else if (Modifier.isPrivate(signature.getModifiers()) || signature.getName().equals("<init>")) {
			throw new RuntimeException("unimplemented, possibly bad");
		} else if (Modifier.isStatic(signature.getModifiers())) {
			throw new RuntimeException("bad");
		} else {
			kind = Constants.INVOKESPECIAL;
		}

		return fact.createInvoke(signature.getDeclaringType().getName(), signature.getName(),
				BcelWorld.makeBcelType(signature.getReturnType()), BcelWorld.makeBcelTypes(signature.getParameterTypes()), kind);
	}
================= fetch public static void appendConversion(InstructionList il, InstructionFactory fact, f7b1193^:weaver/src/org/aspectj/weaver/bcel/Utility.java

public static void appendConversion(InstructionList il, InstructionFactory fact, ResolvedType fromType, ResolvedType toType) {
		if (!toType.isConvertableFrom(fromType) && !fromType.isConvertableFrom(toType)) {
			throw new BCException("can't convert from " + fromType + " to " + toType);
		}
		// XXX I'm sure this test can be simpler but my brain hurts and this
		// works
		if (!toType.getWorld().isInJava5Mode()) {
			if (toType.needsNoConversionFrom(fromType)) {
				return;
			}
		} else {
			if (toType.needsNoConversionFrom(fromType) && !(toType.isPrimitiveType() ^ fromType.isPrimitiveType())) {
				return;
			}
		}
		if (toType.equals(ResolvedType.VOID)) {
			// assert fromType.equals(UnresolvedType.OBJECT)
			il.append(InstructionFactory.createPop(fromType.getSize()));
		} else if (fromType.equals(ResolvedType.VOID)) {
			// assert toType.equals(UnresolvedType.OBJECT)
			il.append(InstructionFactory.createNull(Type.OBJECT));
			return;
		} else if (fromType.equals(UnresolvedType.OBJECT)) {
			Type to = BcelWorld.makeBcelType(toType);
			if (toType.isPrimitiveType()) {
				String name = toType.toString() + "Value";
				il.append(fact.createInvoke("org.aspectj.runtime.internal.Conversions", name, to, new Type[] { Type.OBJECT },
						Constants.INVOKESTATIC));
			} else {
				il.append(fact.createCheckCast((ReferenceType) to));
			}
		} else if (toType.equals(UnresolvedType.OBJECT)) {
			// assert fromType.isPrimitive()
			Type from = BcelWorld.makeBcelType(fromType);
			String name = fromType.toString() + "Object";
			il.append(fact.createInvoke("org.aspectj.runtime.internal.Conversions", name, Type.OBJECT, new Type[] { from },
					Constants.INVOKESTATIC));
		} else if (toType.getWorld().isInJava5Mode() && validBoxing.get(toType.getSignature() + fromType.getSignature()) != null) {
			// XXX could optimize by using any java boxing code that may be just
			// before the call...
			Type from = BcelWorld.makeBcelType(fromType);
			Type to = BcelWorld.makeBcelType(toType);
			String name = validBoxing.get(toType.getSignature() + fromType.getSignature());
			if (toType.isPrimitiveType()) {
				il.append(fact.createInvoke("org.aspectj.runtime.internal.Conversions", name, to, new Type[] { Type.OBJECT },
						Constants.INVOKESTATIC));
			} else {
				il.append(fact.createInvoke("org.aspectj.runtime.internal.Conversions", name, Type.OBJECT, new Type[] { from },
						Constants.INVOKESTATIC));
				il.append(fact.createCheckCast((ReferenceType) to));
			}
		} else if (fromType.isPrimitiveType()) {
			// assert toType.isPrimitive()
			Type from = BcelWorld.makeBcelType(fromType);
			Type to = BcelWorld.makeBcelType(toType);
			try {
				Instruction i = fact.createCast(from, to);
				if (i != null) {
					il.append(i);
				} else {
					il.append(fact.createCast(from, Type.INT));
					il.append(fact.createCast(Type.INT, to));
				}
			} catch (RuntimeException e) {
				il.append(fact.createCast(from, Type.INT));
				il.append(fact.createCast(Type.INT, to));
			}
		} else {
			Type to = BcelWorld.makeBcelType(toType);
			// assert ! fromType.isPrimitive() && ! toType.isPrimitive()
			il.append(fact.createCheckCast((ReferenceType) to));
		}
	}
================= fetch private static String lastbit(String fqname) { 95e70d2^:weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java
/**
	 * Extract the method argument names. First we try the debug info attached to the method (the LocalVariableTable) - if we cannot
	 * find that we look to use the argNames value that may have been supplied on the associated annotation. If that fails we just
	 * don't know and return an empty string.
	 * 
	 * @param method
	 * @param argNamesFromAnnotation
	 * @param methodStruct
	 * @return method argument names
	 */
private static String[] getMethodArgumentNames(Method method, String argNamesFromAnnotation,
			AjAttributeMethodStruct methodStruct) {
		if (method.getArgumentTypes().length == 0) {
			return EMPTY_STRINGS;
		}

		final int startAtStackIndex = method.isStatic() ? 0 : 1;
		final List<MethodArgument> arguments = new ArrayList<MethodArgument>();
		LocalVariableTable lt = method.getLocalVariableTable();
		if (lt != null) {
			LocalVariable[] lvt = lt.getLocalVariableTable();
			for (int j = 0; j < lvt.length; j++) {
				LocalVariable localVariable = lvt[j];
				if (localVariable.getStartPC() == 0) {
					if (localVariable.getIndex() >= startAtStackIndex) {
						arguments.add(new MethodArgument(localVariable.getName(), localVariable.getIndex()));
					}
				}
			}
			if (arguments.size() == 0) {
				// could be cobertura code where some extra bytecode has been stuffed in at the start of the method
				// but the local variable table hasn't been repaired - for example:
				// LocalVariable(start_pc = 6, length = 40, index = 0:com.example.ExampleAspect this)
				// LocalVariable(start_pc = 6, length = 40, index = 1:org.aspectj.lang.ProceedingJoinPoint pjp)
				// LocalVariable(start_pc = 6, length = 40, index = 2:int __cobertura__line__number__)
				// LocalVariable(start_pc = 6, length = 40, index = 3:int __cobertura__branch__number__)
				LocalVariable localVariable = lvt[0];
				if (localVariable.getStartPC() != 0) {
					// looks suspicious so let's use this information
					for (int j = 0; j < lvt.length && arguments.size() < method.getArgumentTypes().length; j++) {
						localVariable = lvt[j];
						if (localVariable.getIndex() >= startAtStackIndex) {
							arguments.add(new MethodArgument(localVariable.getName(), localVariable.getIndex()));
						}
					}
				}
			}
		} else {
			// No debug info, do we have an annotation value we can rely on?
			if (argNamesFromAnnotation != null) {
				StringTokenizer st = new StringTokenizer(argNamesFromAnnotation, " ,");
				List<String> args = new ArrayList<String>();
				while (st.hasMoreTokens()) {
					args.add(st.nextToken());
				}
				if (args.size() != method.getArgumentTypes().length) {
					StringBuffer shortString = new StringBuffer().append(lastbit(method.getReturnType().toString())).append(" ")
							.append(method.getName());
					if (method.getArgumentTypes().length > 0) {
						shortString.append("(");
						for (int i = 0; i < method.getArgumentTypes().length; i++) {
							shortString.append(lastbit(method.getArgumentTypes()[i].toString()));
							if ((i + 1) < method.getArgumentTypes().length) {
								shortString.append(",");
							}

						}
						shortString.append(")");
					}
					reportError("argNames annotation value does not specify the right number of argument names for the method '"
							+ shortString.toString() + "'", methodStruct);
					return EMPTY_STRINGS;
				}
				return args.toArray(new String[] {});
			}
		}

		if (arguments.size() != method.getArgumentTypes().length) {
			return EMPTY_STRINGS;
		}

		// sort by index
		Collections.sort(arguments, new Comparator<MethodArgument>() {
Progress : [#######---------------------------------] 19%================= fetch private void createAnyBridgeMethodsForCovariance(BcelClassWeaver weaver, NewMeth a8e6797^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
/**
	 * Create any bridge method required because of covariant returns being used. This method is used in the case where an ITD is
	 * applied to some type and it may be in an override relationship with a method from the supertype - but due to covariance there
	 * is a mismatch in return values. Example of when required: Super defines: Object m(String s) Sub defines: String m(String s)
	 * then we need a bridge method in Sub called 'Object m(String s)' that forwards to 'String m(String s)'
	 */
private void createAnyBridgeMethodsForCovariance(BcelClassWeaver weaver, NewMethodTypeMunger munger,
			ResolvedMember unMangledInterMethod, ResolvedType onType, LazyClassGen gen, Type[] paramTypes) {
		// PERFORMANCE BOTTLENECK? Might need investigating, method analysis
		// between types in a hierarchy just seems expensive...
		// COVARIANCE BRIDGING
		// Algorithm: Step1. Check in this type - has someone already created
		// the bridge method?
		// Step2. Look above us - do we 'override' a method and yet differ in
		// return type (i.e. covariance)
		// Step3. Create a forwarding bridge method
		// ResolvedType superclass = onType.getSuperclass();
		boolean quitRightNow = false;

		String localMethodName = unMangledInterMethod.getName();
		String localParameterSig = unMangledInterMethod.getParameterSignature();
		String localReturnTypeESig = unMangledInterMethod.getReturnType().getErasureSignature();

		// Step1
		boolean alreadyDone = false; // Compiler might have done it
		ResolvedMember[] localMethods = onType.getDeclaredMethods();
		for (int i = 0; i < localMethods.length; i++) {
			ResolvedMember member = localMethods[i];
			if (member.getName().equals(localMethodName)) {
				// Check the params
				if (member.getParameterSignature().equals(localParameterSig)) {
					alreadyDone = true;
				}
			}
		}

		// Step2
		if (!alreadyDone) {
			// Use the iterator form of 'getMethods()' so we do as little work
			// as necessary
			for (Iterator<ResolvedMember> iter = onType.getSuperclass().getMethods(true, true); iter.hasNext() && !quitRightNow;) {
				ResolvedMember aMethod = iter.next();
				if (aMethod.getName().equals(localMethodName) && aMethod.getParameterSignature().equals(localParameterSig)) {
					// check the return types, if they are different we need a
					// bridging method.
					if (!aMethod.getReturnType().getErasureSignature().equals(localReturnTypeESig)
							&& !Modifier.isPrivate(aMethod.getModifiers())) {
						// Step3
						createBridgeMethod(weaver.getWorld(), munger, unMangledInterMethod, gen, paramTypes, aMethod);
						quitRightNow = true;
					}
				}
			}
		}
	}
================= fetch public ResolvedType getOuterClass() { 945402f^:weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java

public ResolvedType getOuterClass() {
		if (!isNested()) {
			throw new IllegalStateException("Can't get the outer class of a non-nested type");
		}

		// try finding outer class name from InnerClasses attribute assigned to this class
		for (Attribute attr : javaClass.getAttributes()) {
			if (attr instanceof InnerClasses) {
				// search for InnerClass entry that has current class as inner and some other class as outer
				InnerClass[] innerClss = ((InnerClasses) attr).getInnerClasses();
				ConstantPool cpool = javaClass.getConstantPool();
				for (InnerClass innerCls : innerClss) {

					// skip entries that miss any necessary component, 0 index means "undefined", from JVM Spec 2nd ed. par. 4.7.5
					if (innerCls.getInnerClassIndex() == 0 || innerCls.getOuterClassIndex() == 0) {
						continue;
					}

					// resolve inner class name, check if it matches current class name
					ConstantClass innerClsInfo = (ConstantClass) cpool.getConstant(innerCls.getInnerClassIndex());

					// class names in constant pool use '/' instead of '.', from JVM Spec 2nd ed. par. 4.2
					String innerClsName = cpool.getConstantUtf8(innerClsInfo.getNameIndex()).getValue().replace('/', '.');

					if (innerClsName.compareTo(className) == 0) {
						// resolve outer class name
						ConstantClass outerClsInfo = (ConstantClass) cpool.getConstant(innerCls.getOuterClassIndex());

						// class names in constant pool use '/' instead of '.', from JVM Spec 2nd ed. par. 4.2
						String outerClsName = cpool.getConstantUtf8(outerClsInfo.getNameIndex()).getValue().replace('/', '.');

						UnresolvedType outer = UnresolvedType.forName(outerClsName);
						return outer.resolve(getResolvedTypeX().getWorld());
					}
				}
			}
		}

		// try finding outer class name by assuming standard class name mangling convention of javac for this class
		int lastDollar = className.lastIndexOf('$');
		String superClassName = className.substring(0, lastDollar);
		UnresolvedType outer = UnresolvedType.forName(superClassName);
		return outer.resolve(getResolvedTypeX().getWorld());
	}
================= fetch public ReferenceType getUpperBound() { 80785bf^:org.aspectj.matcher/src/org/aspectj/weaver/TypeVariableReferenceType.java

public ReferenceType getUpperBound() {
		return (ReferenceType) typeVariable.resolve(world).getUpperBound();
	}
================= fetch public ResolvedType resolve(UnresolvedType ty, boolean allowMissing) { 80785bf^:org.aspectj.matcher/src/org/aspectj/weaver/World.java
/**
	 * Resolve a type. This the hub of type resolution. The resolved type is added to the type map by signature.
	 */
public ResolvedType resolve(UnresolvedType ty, boolean allowMissing) {

		// special resolution processing for already resolved types.
		if (ty instanceof ResolvedType) {
			ResolvedType rty = (ResolvedType) ty;
			rty = resolve(rty);
			return rty;
		}

		// dispatch back to the type variable reference to resolve its
		// constituent parts
		// don't do this for other unresolved types otherwise you'll end up in a
		// loop
		if (ty.isTypeVariableReference()) {
			return ty.resolve(this);
		}

		// if we've already got a resolved type for the signature, just return
		// it
		// after updating the world
		String signature = ty.getSignature();
		ResolvedType ret = typeMap.get(signature);
		if (ret != null) {
			ret.world = this; // Set the world for the RTX
			return ret;
		} else if (signature.equals("?") || signature.equals("*")) {
			// might be a problem here, not sure '?' should make it to here as a
			// signature, the
			// proper signature for wildcard '?' is '*'
			// fault in generic wildcard, can't be done earlier because of init
			// issues
			// TODO ought to be shared single instance representing this
			ResolvedType something = getWildcard();
			typeMap.put("?", something);
			return something;
		}

		// no existing resolved type, create one
		if (ty.isArray()) {
			ResolvedType componentType = resolve(ty.getComponentType(), allowMissing);
			// String brackets =
			// signature.substring(0,signature.lastIndexOf("[")+1);
			ret = new ArrayReferenceType(signature, "[" + componentType.getErasureSignature(), this, componentType);
		} else {
			ret = resolveToReferenceType(ty, allowMissing);
			if (!allowMissing && ret.isMissing()) {
				ret = handleRequiredMissingTypeDuringResolution(ty);
			}
			if (completeBinaryTypes) {
				completeBinaryType(ret);
			}
		}

		// Pulling in the type may have already put the right entry in the map
		ResolvedType result = typeMap.get(signature);
		if (result == null && !ret.isMissing()) {
			ret = ensureRawTypeIfNecessary(ret);
			typeMap.put(signature, ret);
			return ret;
		}
		if (result == null) {
			return ret;
		} else {
			return result;
		}
	}
================= fetch public TypeVariable getTypeVariable() { 80785bf^:org.aspectj.matcher/src/org/aspectj/weaver/TypeVariableReferenceType.java

public TypeVariable getTypeVariable() {
		// if (!fixedUp) throw new BCException("ARGH"); // fix it up now?
		return typeVariable;
	}
================= fetch public void setAdditionalInterfaceBounds(UnresolvedType[] superInterfaces) { 80785bf^:org.aspectj.matcher/src/org/aspectj/weaver/TypeVariable.java
// only used when resolving
public void setAdditionalInterfaceBounds(UnresolvedType[] superInterfaces) {
		if (isResolved) {
			throw new IllegalStateException("Why set this late?");
		}
		this.firstbound = null;
		this.superInterfaces = superInterfaces;
	}
Progress : [########--------------------------------] 20%================= fetch private FileUtil() { 5648105^:util/src/org/aspectj/util/FileUtil.java

public static List<String> makeClasspath(URL[] urls) {
		List<String> ret = new LinkedList<String>();
		if (urls != null) {
			for (int i = 0; i < urls.length; i++) {
				ret.add(urls[i].getPath());
			}
		}
		return ret;
	}
================= fetch public IProgramElement getRoot() { 6249672^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java

public IProgramElement getRoot() {
		return root;
	}
================= fetch public String toSummaryString() { 6249672^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java

public String toSummaryString() {
		StringBuilder s = new StringBuilder();
		s.append("FileMap has "+fileMap.size()+" entries\n");
		s.append("HandleMap has "+handleMap.size()+" entries\n");
		s.append("TypeMap has "+handleMap.size()+" entries\n");
		s.append("FileMap:\n");
		for (Map.Entry<String,IProgramElement> fileMapEntry: fileMap.entrySet()) {
			s.append(fileMapEntry).append("\n");
		}
		s.append("TypeMap:\n");
		for (Map.Entry<String,IProgramElement> typeMapEntry: typeMap.entrySet()) {
			s.append(typeMapEntry).append("\n");
		}
		s.append("HandleMap:\n");
		for (Map.Entry<String,IProgramElement> handleMapEntry: handleMap.entrySet()) {
			s.append(handleMapEntry).append("\n");
		}
		return s.toString();
	}
================= fetch public void flushFileMap() { 6249672^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java

public void flushFileMap() {
		fileMap.clear();
	}
================= fetch public void forget(IProgramElement compilationUnitNode,IProgramElement typeNode) 6249672^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java

public void forget(IProgramElement compilationUnitNode,IProgramElement typeNode) {
		String k = null;
		synchronized (this) {
			// handle map
			// type map
			for (Map.Entry<String,IProgramElement> typeMapEntry: typeMap.entrySet()) {
				if (typeMapEntry.getValue()==typeNode) {
					k = typeMapEntry.getKey();
					break;
				}
			}
			if (k!=null) {
				typeMap.remove(k);
			}
		}
		
		if (compilationUnitNode!=null) {
			k = null;
			for (Map.Entry<String,IProgramElement> entry: fileMap.entrySet()) {
				if (entry.getValue()==compilationUnitNode) {
					k = entry.getKey();break;
				}
			}
			if (k!=null) {
				fileMap.remove(k);
			}
		}
	}
================= fetch public void updateHandleMap(Set<String> deletedFiles) { 6249672^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java
// TODO rename this method ... it does more than just the handle map
public void updateHandleMap(Set<String> deletedFiles) {
		// Only delete the entries we need to from the handle map - for performance reasons
		List<String> forRemoval = new ArrayList<String>();
		Set<String> k = null;
		synchronized (this) {
			k = handleMap.keySet();
			for (String handle : k) {
				IProgramElement ipe = handleMap.get(handle);
				if (deletedFiles.contains(getCanonicalFilePath(ipe))) {
					forRemoval.add(handle);
				}
			}
			for (String handle : forRemoval) {
				handleMap.remove(handle);
			}
			forRemoval.clear();
			k = typeMap.keySet();
			for (String typeName : k) {
				IProgramElement ipe = typeMap.get(typeName);
				if (deletedFiles.contains(getCanonicalFilePath(ipe))) {
					forRemoval.add(typeName);
				}
			}
			for (String typeName : forRemoval) {
				typeMap.remove(typeName);
			}
			forRemoval.clear();
		}
		for (Map.Entry<String, IProgramElement> entry : fileMap.entrySet()) {
			String filePath = entry.getKey();
			if (deletedFiles.contains(getCanonicalFilePath(entry.getValue()))) {
				forRemoval.add(filePath);
			}
		}
		for (String filePath : forRemoval) {
			fileMap.remove(filePath);
		}
	}
================= fetch private ByteArrayOutputStream getOutxmlContents(List aspectNames) { 03c43f5^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/**
	 * Returns a map where the keys are File objects corresponding to all the output directories and the values are a list of
	 * aspects which are sent to that ouptut directory
	 */
private Map<File, List<String>> findOutputDirsForAspects() {
		Map<File, List<String>> outputDirsToAspects = new HashMap<File, List<String>>();
		Map<String, char[]> aspectNamesToFileNames = state.getAspectNamesToFileNameMap();
		if (buildConfig.getCompilationResultDestinationManager() == null
				|| buildConfig.getCompilationResultDestinationManager().getAllOutputLocations().size() == 1) {
			// we only have one output directory...which simplifies things
			File outputDir = buildConfig.getOutputDir();
			if (buildConfig.getCompilationResultDestinationManager() != null) {
				outputDir = buildConfig.getCompilationResultDestinationManager().getDefaultOutputLocation();
			}
			List<String> aspectNames = new ArrayList<String>();
			if (aspectNamesToFileNames != null) {
				Set<String> keys = aspectNamesToFileNames.keySet();
				for (String name : keys) {
					aspectNames.add(name);
				}
			}
			outputDirsToAspects.put(outputDir, aspectNames);
		} else {
			List outputDirs = buildConfig.getCompilationResultDestinationManager().getAllOutputLocations();
			for (Iterator iterator = outputDirs.iterator(); iterator.hasNext();) {
				File outputDir = (File) iterator.next();
				outputDirsToAspects.put(outputDir, new ArrayList<String>());
			}
			Set<Map.Entry<String, char[]>> entrySet = aspectNamesToFileNames.entrySet();
			for (Iterator<Map.Entry<String, char[]>> iterator = entrySet.iterator(); iterator.hasNext();) {
				Map.Entry<String, char[]> entry = iterator.next();
				String aspectName = entry.getKey();
				char[] fileName = entry.getValue();
				File outputDir = buildConfig.getCompilationResultDestinationManager().getOutputLocationForClass(
						new File(new String(fileName)));
				if (!outputDirsToAspects.containsKey(outputDir)) {
					outputDirsToAspects.put(outputDir, new ArrayList<String>());
				}
				((List) outputDirsToAspects.get(outputDir)).add(aspectName);
			}
		}
		return outputDirsToAspects;
	}
================= fetch private boolean needToSkipPointcutParserTests() { 2a8d684^:org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java

private boolean needToSkipPointcutParserTests() {
		if (!LangUtil.is15VMOrGreater())
			return false;
		try {
			Class.forName("org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate", false, this.getClass()
					.getClassLoader());// ReflectionBasedReferenceTypeDelegate.class.getClassLoader());
		} catch (ClassNotFoundException cnfEx) {
			return true;
		}
		return false;
	}
================= fetch private void checkNoMatch(ShadowMatch sMatch, Object thisObj, Object targetObj, 2a8d684^:org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java

private void checkNoMatch(ShadowMatch sMatch, Object thisObj, Object targetObj, Object[] args) {
		assertFalse("no match expected", sMatch.matchesJoinPoint(thisObj, targetObj, args).matches());
	}
================= fetch public void testBinding() throws Exception { 2a8d684^:org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java

public void testBinding() throws Exception {
		if (needToSkip)
			return;
		PointcutParser parser = PointcutParser
				.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());
		PointcutParameter ex = parser.createPointcutParameter("ex", Exception.class);
		PointcutParameter ioEx = parser.createPointcutParameter("ioEx", IOException.class);

		PointcutExpression thisEx = parser.parsePointcutExpression("this(ex)", Exception.class, new PointcutParameter[] { ex });

		PointcutExpression targetIOEx = parser.parsePointcutExpression("target(ioEx)", Exception.class,
				new PointcutParameter[] { ioEx });

		Method toString = Object.class.getMethod("toString", new Class[0]);

		ShadowMatch sMatch = thisEx.matchesMethodCall(toString, toString);
		Exception exceptionParameter = new Exception();
		IOException ioExceptionParameter = new IOException();
		JoinPointMatch jpMatch = sMatch.matchesJoinPoint(exceptionParameter, null, null);
		assertTrue("should match", jpMatch.matches());
		PointcutParameter[] bindings = jpMatch.getParameterBindings();
		assertEquals("one binding", 1, bindings.length);
		assertEquals("should be exceptionParameter", exceptionParameter, bindings[0].getBinding());
		assertEquals("ex", bindings[0].getName());

		sMatch = targetIOEx.matchesMethodCall(toString, toString);
		jpMatch = sMatch.matchesJoinPoint(exceptionParameter, ioExceptionParameter, null);
		assertTrue("should match", jpMatch.matches());
		bindings = jpMatch.getParameterBindings();
		assertEquals("one binding", 1, bindings.length);
		assertEquals("should be ioExceptionParameter", ioExceptionParameter, bindings[0].getBinding());
		assertEquals("ioEx", bindings[0].getName());

	}
================= fetch public void testMatchJP() throws Exception { 2a8d684^:org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java

public void testMatchJP() throws Exception {
		if (needToSkip)
			return;

		PointcutParser parser = PointcutParser
				.getPointcutParserSupportingAllPrimitivesAndUsingSpecifiedClassloaderForResolution(this.getClass().getClassLoader());
		PointcutExpression thisEx = parser.parsePointcutExpression("this(Exception)");
		PointcutExpression thisIOEx = parser.parsePointcutExpression("this(java.io.IOException)");

		PointcutExpression targetEx = parser.parsePointcutExpression("target(Exception)");
		PointcutExpression targetIOEx = parser.parsePointcutExpression("target(java.io.IOException)");

		Method toString = Object.class.getMethod("toString", new Class[0]);

		checkMatches(thisEx.matchesMethodCall(toString, toString), new Exception(), null, null);
		checkNoMatch(thisIOEx.matchesMethodCall(toString, toString), new Exception(), null, null);
		checkNoMatch(targetEx.matchesMethodCall(toString, toString), new Exception(), new Object(), null);
		checkNoMatch(targetIOEx.matchesMethodCall(toString, toString), new Exception(), new Exception(), null);

		checkMatches(thisEx.matchesMethodCall(toString, toString), new IOException(), null, null);
		checkMatches(thisIOEx.matchesMethodCall(toString, toString), new IOException(), null, null);

		checkNoMatch(thisEx.matchesMethodCall(toString, toString), new Object(), null, null);
		checkNoMatch(thisIOEx.matchesMethodCall(toString, toString), new Exception(), null, null);
		checkMatches(targetEx.matchesMethodCall(toString, toString), new Exception(), new Exception(), null);
		checkNoMatch(targetIOEx.matchesMethodCall(toString, toString), new Exception(), new Exception(), null);

		checkMatches(targetIOEx.matchesMethodCall(toString, toString), new Exception(), new IOException(), null);
	}
================= fetch public void visit(Instanceof instanceofTest) { 2a8d684^:org.aspectj.matcher/src/org/aspectj/weaver/reflect/ShadowMatchImpl.java

public void visit(Instanceof instanceofTest) {
			ReflectionVar v = (ReflectionVar) instanceofTest.getVar();
			Object value = v.getBindingAtJoinPoint(thisObject, targetObject, args);
			World world = v.getType().getWorld();
			ResolvedType desiredType = instanceofTest.getType().resolve(world);
			ResolvedType actualType = world.resolve(value.getClass().getName());
			matches = desiredType.isAssignableFrom(actualType);
		}
================= fetch private boolean hasStructuralChanges(ClassFileReader reader, CompactTypeStructur 88fab6a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
/**
	 * Compare the class structure of the new intermediate (unwoven) class with the existingResolvedType of the same class that we
	 * have in the world, looking for any structural differences (and ignoring aj members resulting from weaving....)
	 * 
	 * Some notes from Andy... lot of problems here, which I've eventually resolved by building the compactstructure based on a
	 * classfilereader, rather than on a ResolvedType. There are accessors for inner types and funky fields that the compiler
	 * creates to support the language - for non-static inner types it also mangles ctors to be prefixed with an instance of the
	 * surrounding type.
	 * 
	 * @param reader
	 * @param existingType
	 * @return
	 */
private boolean hasStructuralChanges(ClassFileReader reader, CompactTypeStructureRepresentation existingType) {
		if (existingType == null) {
			return true;
		}

		// modifiers
		if (!modifiersEqual(reader.getModifiers(), existingType.modifiers)) {
			return true;
		}

		// generic signature
		if (!CharOperation.equals(reader.getGenericSignature(), existingType.genericSignature)) {
			return true;
		}

		// superclass name
		if (!CharOperation.equals(reader.getSuperclassName(), existingType.superclassName)) {
			return true;
		}

		// have annotations changed on the type?
		IBinaryAnnotation[] newAnnos = reader.getAnnotations();
		if (newAnnos == null || newAnnos.length == 0) {
			if (existingType.annotations != null && existingType.annotations.length != 0) {
				return true;
			}
		} else {
			IBinaryAnnotation[] existingAnnos = existingType.annotations;
			if (existingAnnos == null || existingAnnos.length != newAnnos.length) {
				return true;
			}
			// Does not allow for an order switch
			// Does not cope with a change in values set on the annotation (hard to create a testcase where this is a problem tho)
			for (int i = 0; i < newAnnos.length; i++) {
				if (!CharOperation.equals(newAnnos[i].getTypeName(), existingAnnos[i].getTypeName())) {
					return true;
				}
			}

		}

		// interfaces
		char[][] existingIfs = existingType.interfaces;
		char[][] newIfsAsChars = reader.getInterfaceNames();
		if (newIfsAsChars == null) {
			newIfsAsChars = EMPTY_CHAR_ARRAY;
		} // damn I'm lazy...
		if (existingIfs == null) {
			existingIfs = EMPTY_CHAR_ARRAY;
		}
		if (existingIfs.length != newIfsAsChars.length) {
			return true;
		}
		new_interface_loop: for (int i = 0; i < newIfsAsChars.length; i++) {
			for (int j = 0; j < existingIfs.length; j++) {
				if (CharOperation.equals(existingIfs[j], newIfsAsChars[i])) {
					continue new_interface_loop;
				}
			}
			return true;
		}

		// fields
		// CompactMemberStructureRepresentation[] existingFields = existingType.fields;
		IBinaryField[] newFields = reader.getFields();
		if (newFields == null) {
			newFields = CompactTypeStructureRepresentation.NoField;
		}

		// all redundant for now ... could be an optimization at some point...
		// remove any ajc$XXX fields from those we compare with
		// the existing fields - bug 129163
		// List nonGenFields = new ArrayList();
		// for (int i = 0; i < newFields.length; i++) {
		// IBinaryField field = newFields[i];
		// //if (!CharOperation.prefixEquals(NameMangler.AJC_DOLLAR_PREFIX,field.getName())) { // this would skip ajc$ fields
		// //if ((field.getModifiers()&0x1000)==0) // 0x1000 => synthetic - this will skip synthetic fields (eg. this$0)
		// nonGenFields.add(field);
		// //}
		// }
		IBinaryField[] existingFs = existingType.binFields;
		if (newFields.length != existingFs.length) {
			return true;
		}
		new_field_loop: for (int i = 0; i < newFields.length; i++) {
			IBinaryField field = newFields[i];
			char[] fieldName = field.getName();
			for (int j = 0; j < existingFs.length; j++) {
				if (CharOperation.equals(existingFs[j].getName(), fieldName)) {
					IBinaryField existing = existingFs[j];
					if (!modifiersEqual(field.getModifiers(), existing.getModifiers())) {
						return true;
					}
					if (!CharOperation.equals(existing.getTypeName(), field.getTypeName())) {
						return true;
					}

					char[] existingGSig = existing.getGenericSignature();
					char[] fieldGSig = field.getGenericSignature();
					if ((existingGSig == null && fieldGSig != null) || (existingGSig != null && fieldGSig == null)) {
						return true;
					}
					if (existingGSig != null) {
						if (!CharOperation.equals(existingGSig, fieldGSig)) {
							return true;
						}
					}

					continue new_field_loop;
				}
			}
			return true;
		}

		// methods
		// CompactMemberStructureRepresentation[] existingMethods = existingType.methods;
		IBinaryMethod[] newMethods = reader.getMethods();
		if (newMethods == null) {
			newMethods = CompactTypeStructureRepresentation.NoMethod;
		}

		// all redundant for now ... could be an optimization at some point...

		// Ctors in a non-static inner type have an 'extra parameter' of the enclosing type.
		// If skippableDescriptorPrefix gets set here then it is set to the descriptor portion
		// for this 'extra parameter'. For an inner class of pkg.Foo the skippable descriptor
		// prefix will be '(Lpkg/Foo;' - so later when comparing <init> methods we know what to
		// compare.
		// IF THIS CODE NEEDS TO GET MORE COMPLICATED, I THINK ITS WORTH RIPPING IT ALL OUT AND
		// CREATING THE STRUCTURAL CHANGES OBJECT BASED ON CLASSREADER OUTPUT RATHER THAN
		// THE RESOLVEDTYPE - THEN THERE WOULD BE NO NEED TO TREAT SOME METHODS IN A PECULIAR
		// WAY.
		// char[] skippableDescriptorPrefix = null;
		// char[] enclosingTypeName = reader.getEnclosingTypeName();
		// boolean isStaticType = Modifier.isStatic(reader.getModifiers());
		// if (!isStaticType && enclosingTypeName!=null) {
		// StringBuffer sb = new StringBuffer();
		// sb.append("(L").append(new String(enclosingTypeName)).append(";");
		// skippableDescriptorPrefix = sb.toString().toCharArray();
		// }
		//
		//
		// // remove the aspectOf, hasAspect, clinit and ajc$XXX methods
		// // from those we compare with the existing methods - bug 129163
		// List nonGenMethods = new ArrayList();
		// for (int i = 0; i < newMethods.length; i++) {
		// IBinaryMethod method = newMethods[i];
		// // if ((method.getModifiers() & 0x1000)!=0) continue; // 0x1000 => synthetic - will cause us to skip access$0 - is this
		// always safe?
		// char[] methodName = method.getSelector();
		// // if (!CharOperation.equals(methodName,NameMangler.METHOD_ASPECTOF) &&
		// // !CharOperation.equals(methodName,NameMangler.METHOD_HASASPECT) &&
		// // !CharOperation.equals(methodName,NameMangler.STATIC_INITIALIZER) &&
		// // !CharOperation.prefixEquals(NameMangler.AJC_DOLLAR_PREFIX,methodName) &&
		// // !CharOperation.prefixEquals(NameMangler.CLINIT,methodName)) {
		// nonGenMethods.add(method);
		// // }
		// }
		IBinaryMethod[] existingMs = existingType.binMethods;
		if (newMethods.length != existingMs.length) {
			return true;
		}
		new_method_loop: for (int i = 0; i < newMethods.length; i++) {
			IBinaryMethod method = newMethods[i];
			char[] methodName = method.getSelector();
			for (int j = 0; j < existingMs.length; j++) {
				if (CharOperation.equals(existingMs[j].getSelector(), methodName)) {
					// candidate match
					if (!CharOperation.equals(method.getMethodDescriptor(), existingMs[j].getMethodDescriptor())) {
						// ok, the descriptors don't match, but is this a funky ctor on a non-static inner
						// type?
						// boolean mightBeOK =
						// skippableDescriptorPrefix!=null && // set for inner types
						// CharOperation.equals(methodName,NameMangler.INIT) && // ctor
						// CharOperation.prefixEquals(skippableDescriptorPrefix,method.getMethodDescriptor()); // checking for
						// prefix on the descriptor
						// if (mightBeOK) {
						// // OK, so the descriptor starts something like '(Lpkg/Foo;' - we now may need to look at the rest of the
						// // descriptor if it takes >1 parameter.
						// // eg. could be (Lpkg/C;Ljava/lang/String;) where the skippablePrefix is (Lpkg/C;
						// char [] md = method.getMethodDescriptor();
						// char[] remainder = CharOperation.subarray(md, skippableDescriptorPrefix.length, md.length);
						// if (CharOperation.equals(remainder,BRACKET_V)) continue new_method_loop; // no other parameters to worry
						// about
						// char[] comparableSig = CharOperation.subarray(existingMethods[j].signature, 1,
						// existingMethods[j].signature.length);
						// boolean match = CharOperation.equals(comparableSig, remainder);
						// if (match) continue new_method_loop;
						// }
						continue; // might be overloading
					} else {
						// matching sigs
						IBinaryMethod existing = existingMs[j];
						if (!modifiersEqual(method.getModifiers(), existing.getModifiers())) {
							return true;
						}

						if (exceptionClausesDiffer(existing, method)) {
							return true;
						}

						char[] existingGSig = existing.getGenericSignature();
						char[] methodGSig = method.getGenericSignature();
						if ((existingGSig == null && methodGSig != null) || (existingGSig != null && methodGSig == null)) {
							return true;
						}
						if (existingGSig != null) {
							if (!CharOperation.equals(existingGSig, methodGSig)) {
								return true;
							}
						}

						continue new_method_loop;
					}
				}
			}
			return true; // (no match found)
		}

		// check for differences in inner types
		// TODO could make order insensitive
		IBinaryNestedType[] binaryNestedTypes = reader.getMemberTypes();
		IBinaryNestedType[] existingBinaryNestedTypes = existingType.getMemberTypes();
		if ((binaryNestedTypes == null && existingBinaryNestedTypes != null)
				|| (binaryNestedTypes != null && existingBinaryNestedTypes == null)) {
			return true;
		}
		if (binaryNestedTypes != null) {
			int bnLength = binaryNestedTypes.length;
			for (int m = 0; m < bnLength; m++) {
				IBinaryNestedType bnt = binaryNestedTypes[m];
				IBinaryNestedType existingBnt = existingBinaryNestedTypes[m];
				if (!CharOperation.equals(bnt.getName(), existingBnt.getName())) {
					return true;
				}
			}
		}
		return false;
	}
================= fetch public ReferenceTypeDelegate getDelegate(ReferenceType referenceType) { 88fab6a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
/**
	 * See if we can create a delegate from a CompactTypeStructure - TODO better comment
	 */
public ReferenceTypeDelegate getDelegate(ReferenceType referenceType) {
		File f = classesFromName.get(referenceType.getName());
		if (f == null) {
			return null; // not heard of it
		}
		try {
			ClassParser parser = new ClassParser(f.toString());
			return world.buildBcelDelegate(referenceType, parser.parse(), true, false);
		} catch (IOException e) {
			System.err.println("Failed to recover "+referenceType);
			e.printStackTrace();
		}
		return null;
	}
================= fetch public static int getModifierFlag(String name) { e0e1330^:org.aspectj.matcher/src/org/aspectj/weaver/patterns/ModifiersPattern.java

public static int getModifierFlag(String name) {
		if (modifierFlags == null) {
			modifierFlags = new HashMap();
			int flag = 1;
			while (flag <= Modifier.STRICT) {
				String flagName = Modifier.toString(flag);
				modifierFlags.put(flagName, new Integer(flag));
				flag = flag << 1;
			}
		}
		Integer flag = (Integer) modifierFlags.get(name);
		if (flag == null) {
			return -1;
		}
		return flag.intValue();
	}
================= fetch public void write(CompressingDataOutputStream s) throws IOException { e0e1330^:org.aspectj.matcher/src/org/aspectj/weaver/patterns/ModifiersPattern.java

public void write(CompressingDataOutputStream s) throws IOException {
		// s.writeByte(MODIFIERS_PATTERN);
		s.writeShort(requiredModifiers);
		s.writeShort(forbiddenModifiers);
	}
Progress : [########--------------------------------] 21%================= fetch public PerClause getPerClause() { ce16a06^:org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java
// }
@Override
	public Collection<ResolvedMember> getPrivilegedAccesses() {
		return getDelegate().getPrivilegedAccesses();
	}
================= fetch public int demote(boolean atEndOfCompile) { f631ad6^:org.aspectj.matcher/src/org/aspectj/weaver/World.java
/**
		 * Go through any types added during the previous file weave. If any are suitable for demotion, then put them in the
		 * expendable map where GC can claim them at some point later. Demotion means: the type is not an aspect, the type is not
		 * java.lang.Object, the type is not primitive and the type is not affected by type mungers in any way. Further refinements
		 * of these conditions may allow for more demotions.
		 * 
		 * @return number of types demoted
		 */
public int demote(boolean atEndOfCompile) {
			if (!demotionSystemActive) {
				return 0;
			}
			if (debugDemotion) {
				System.out.println("Demotion running " + addedSinceLastDemote);
			}
			boolean isLtw = w.isLoadtimeWeaving();
			int demotionCounter = 0;
			if (isLtw) {
				// Loadtime weaving demotion strategy
				for (String key : addedSinceLastDemote) {
					ResolvedType type = tMap.get(key);
					if (type != null && !type.isAspect() && !type.equals(UnresolvedType.OBJECT) && !type.isPrimitiveType()) {
						if (type.isParameterizedOrRawType()) {
							type = type.getGenericType();
						}
						List<ConcreteTypeMunger> typeMungers = type.getInterTypeMungers();
						if (typeMungers == null || typeMungers.size() == 0) {
							tMap.remove(key);
							insertInExpendableMap(key, type);
							demotionCounter++;
						}
					}
				}
				addedSinceLastDemote.clear();
			} else {
				// Compile time demotion strategy
				List<String> forRemoval = new ArrayList<String>();
				for (String key : addedSinceLastDemote) {
					ResolvedType type = tMap.get(key);
					if (type == null) {
						// TODO not 100% sure why it is not there, where did it go?
						forRemoval.add(key);
						continue;
					}
					if (!writtenClasses.contains(type.getName())) { // COSTLY
						continue;
					}
					if (type != null && !type.isAspect() && !type.equals(UnresolvedType.OBJECT) && !type.isPrimitiveType()) {
						if (type.isParameterizedOrRawType()) {
							type = type.getGenericType();
						}
						List<ConcreteTypeMunger> typeMungers = type.getInterTypeMungers();
						if (typeMungers == null || typeMungers.size() == 0) {
							/*
							 * if (type.isNested()) { try { ReferenceType rt = (ReferenceType) w.resolve(type.getOutermostType());
							 * if (!rt.isMissing()) { ReferenceTypeDelegate delegate = ((ReferenceType) type).getDelegate(); boolean
							 * isWeavable = delegate == null ? false : delegate.isExposedToWeaver(); boolean hasBeenWoven = delegate
							 * == null ? false : delegate.hasBeenWoven(); if (isWeavable && !hasBeenWoven) { // skip demotion of
							 * this inner type for now continue; } } } catch (ClassCastException cce) { cce.printStackTrace();
							 * System.out.println("outer of " + key + " is not a reftype? " + type.getOutermostType()); // throw new
							 * IllegalStateException(cce); } }
							 */
							ReferenceTypeDelegate delegate = ((ReferenceType) type).getDelegate();
							boolean isWeavable = delegate == null ? false : delegate.isExposedToWeaver();
							boolean hasBeenWoven = delegate == null ? false : delegate.hasBeenWoven();
							if (!isWeavable || hasBeenWoven) {
								if (debugDemotion) {
									System.out.println("Demoting " + key);
								}
								forRemoval.add(key);
								tMap.remove(key);
								insertInExpendableMap(key, type);
								demotionCounter++;
							}
						} else {
							// no need to try this again, it will never be demoted
							writtenClasses.remove(type.getName());
							forRemoval.add(key);
						}
					} else {
						writtenClasses.remove(type.getName());
						// no need to try this again, it will never be demoted
						forRemoval.add(key);
					}
				}
				addedSinceLastDemote.removeAll(forRemoval);
			}
			if (debugDemotion) {
				System.out.println("Demoted " + demotionCounter + " types.  Types remaining in fixed set #" + tMap.keySet().size()
						+ ".  addedSinceLastDemote size is " + addedSinceLastDemote.size());
				System.out.println("writtenClasses.size() = " + writtenClasses.size() + ": " + writtenClasses);
			}
			if (atEndOfCompile) {
				if (debugDemotion) {
					System.out.println("Clearing writtenClasses");
				}
				writtenClasses.clear();
			}
			return demotionCounter;
		}
================= fetch public void testIncrementalCtorItdHandle_280383() throws Exception { 6b35ea4^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java

public void testIncrementalCtorItdHandle_280383() throws Exception {
		String p = "pr280383";
		initialiseProject(p);
		build(p);
		printModel(p);
		IRelationshipMap irm = getModelFor(p).getRelationshipMap();
		List rels = irm.get("=pr280383<f{AnAspect.java'AnAspect)f.AClass.f_AClass_new");
		assertNotNull(rels);
	}
================= fetch public void testIncrementalFqItds_280380_3() throws Exception { 6b35ea4^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java

public void testIncrementalFqItds_280380_3() throws Exception {
		String p = "pr280380";
		initialiseProject(p);
		build(p);
		// printModel(p);
		assertEquals(4, getModelFor(p).getRelationshipMap().getEntries().size());
		// Hid:1:(targets=3) =pr280380<f{AClass.java[AClass (aspect declarations) =pr280380<g*AnAspect.aj}AnAspect)AClass.xxxx
		// Hid:2:(targets=3) =pr280380<f{AClass.java[AClass (aspect declarations) =pr280380<g*AnAspect.aj}AnAspect)AClass.y
		// Hid:3:(targets=3) =pr280380<f{AClass.java[AClass (aspect declarations) =pr280380<g*AnAspect.aj}AnAspect)AClass.AClass_new
		// Hid:4:(targets=1) =pr280380<g*AnAspect.aj}AnAspect)AClass.y (declared on) =pr280380<f{AClass.java[AClass
		// Hid:5:(targets=1) =pr280380<g*AnAspect.aj}AnAspect)AClass.AClass_new (declared on) =pr280380<f{AClass.java[AClass
		// Hid:6:(targets=1) =pr280380<g*AnAspect.aj}AnAspect)AClass.xxxx (declared on) =pr280380<f{AClass.java[AClass
		printModel(p);
		assertNotNull(getModelFor(p).getRelationshipMap().get("=pr280380<g*AnAspect.aj'AnAspect,AClass.xxxx"));
		alter(p, "inc2");
		build(p);
		assertNoErrors(p);
		printModel(p);
		// On this build the relationship should have changed to include the fully qualified target
		assertEquals(4, getModelFor(p).getRelationshipMap().getEntries().size());
		assertNotNull(getModelFor(p).getRelationshipMap().get("=pr280380<g*AnAspect.aj'AnAspect,AClass.xxxx"));
		// Hid:1:(targets=3) =pr280380<f{AClass.java[AClass (aspect declarations) =pr280380<g*AnAspect.aj}AnAspect)AClass.xxxx
		// Hid:2:(targets=3) =pr280380<f{AClass.java[AClass (aspect declarations) =pr280380<g*AnAspect.aj}AnAspect)AClass.y
		// Hid:3:(targets=3) =pr280380<f{AClass.java[AClass (aspect declarations) =pr280380<g*AnAspect.aj}AnAspect)AClass.AClass_new
		// Hid:4:(targets=1) =pr280380<g*AnAspect.aj}AnAspect)AClass.y (declared on) =pr280380<f{AClass.java[AClass
		// Hid:5:(targets=1) =pr280380<g*AnAspect.aj}AnAspect)AClass.AClass_new (declared on) =pr280380<f{AClass.java[AClass
		// Hid:6:(targets=1) =pr280380<g*AnAspect.aj}AnAspect)AClass.xxxx (declared on) =pr280380<f{AClass.java[AClass
	}
================= fetch private void collectAllITDsAndDeclares(SourceTypeBinding sourceType, Collection 16adee6^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java
/**
	 * Find all the ITDs and Declares, but it is important we do this from the supertypes down to the subtypes.
	 * 
	 * @param sourceType
	 * @param yetToProcess
	 */
private void collectAllITDsAndDeclares(SourceTypeBinding sourceType, Collection yetToProcess) {
		// Look at the supertype first
		ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.COLLECTING_ITDS_AND_DECLARES,
				sourceType.sourceName);

		yetToProcess.remove(sourceType);
		// look out our direct supertype
		doSupertypesFirst(sourceType.superclass(), yetToProcess);

		// now check our membertypes (pr119570)
		ReferenceBinding[] memberTypes = sourceType.memberTypes;
		for (int i = 0, length = memberTypes.length; i < length; i++) {
			SourceTypeBinding rb = (SourceTypeBinding) memberTypes[i];
			if (!rb.superclass().equals(sourceType)) {
				doSupertypesFirst(rb.superclass(), yetToProcess);
			}
		}

		buildInterTypeAndPerClause(sourceType.scope);
		addCrosscuttingStructures(sourceType.scope);
		CompilationAndWeavingContext.leavingPhase(tok);
	}
================= fetch private void weaveInterTypeDeclarations(CompilationUnitScope unit, List<Concrete 16adee6^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java

private void weaveInterTypeDeclarations(CompilationUnitScope unit, List<ConcreteTypeMunger> typeMungers,
			List<DeclareParents> declareParents, List<DeclareAnnotation> declareAnnotationOnTypes) {
		for (int i = 0, length = unit.topLevelTypes.length; i < length; i++) {
			weaveInterTypeDeclarations(unit.topLevelTypes[i], typeMungers, declareParents, declareAnnotationOnTypes, false);
		}
	}
================= fetch private void weaveInterTypeDeclarations(SourceTypeBinding sourceType) { 16adee6^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java

private void weaveInterTypeDeclarations(SourceTypeBinding sourceType) {
		if (!factory.areTypeMungersFinished()) {
			if (!pendingTypesToWeave.contains(sourceType)) {
				pendingTypesToWeave.add(sourceType);

				// inner type ITD support - may need this for some incremental cases...
				// List<ConcreteTypeMunger> ctms = factory.getWorld().getCrosscuttingMembersSet().getTypeMungersOfKind(
				// ResolvedTypeMunger.InnerClass);
				// // List<ConcreteTypeMunger> innerTypeMungers = new ArrayList<ConcreteTypeMunger>();
				// // for (ConcreteTypeMunger ctm : ctms) {
				// // if (ctm.getMunger() != null && ctm.getMunger().getKind() == ResolvedTypeMunger.InnerClass) {
				// // innerTypeMungers.add(ctm);
				// // }
				// // }
				// // that includes the innertype one...
				// // doPendingWeaves at this level is about applying inner class
				// BinaryTypeBinding t = (BinaryTypeBinding) sourceType;
				// for (ConcreteTypeMunger ctm : innerTypeMungers) {
				// NewMemberClassTypeMunger nmctm = (NewMemberClassTypeMunger) ctm.getMunger();
				// ReferenceBinding[] rbs = t.memberTypes;
				// UnresolvedType ut = factory.fromBinding(t);
				// if (ut.equals(nmctm.getTargetType())) {
				// // got a match here
				// SourceTypeBinding aspectTypeBinding = (SourceTypeBinding) factory.makeTypeBinding(ctm.getAspectType());
				//
				// char[] mungerMemberTypeName = ("$" + nmctm.getMemberTypeName()).toCharArray();
				// ReferenceBinding innerTypeBinding = null;
				// for (ReferenceBinding innerType : aspectTypeBinding.memberTypes) {
				// char[] compounded = CharOperation.concatWith(innerType.compoundName, '.');
				// if (org.aspectj.org.eclipse.jdt.core.compiler.CharOperation.endsWith(compounded, mungerMemberTypeName)) {
				// innerTypeBinding = innerType;
				// break;
				// }
				// }
				// // may be unresolved if the aspect type binding was a BinaryTypeBinding
				// if (innerTypeBinding instanceof UnresolvedReferenceBinding) {
				// innerTypeBinding = BinaryTypeBinding
				// .resolveType(innerTypeBinding, factory.getLookupEnvironment(), true);
				// }
				// t.memberTypes(); // cause initialization
				// t.memberTypes = new ReferenceBinding[] { innerTypeBinding };
				//
				// int stop = 1;
				// // The inner type from the aspect should be put into the membertypebindings for this
				//
				// }
				// }

			}
		} else {
			weaveInterTypeDeclarations(sourceType, factory.getTypeMungers(), factory.getDeclareParents(),
					factory.getDeclareAnnotationOnTypes(), true);
		}
	}
================= fetch private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr 16adee6^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java

private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<ConcreteTypeMunger> typeMungers,
			List<DeclareParents> declareParents, List<DeclareAnnotation> declareAnnotationOnTypes, boolean skipInners) {

		ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.WEAVING_INTERTYPE_DECLARATIONS,
				sourceType.sourceName);

		ResolvedType onType = factory.fromEclipse(sourceType);

		// AMC we shouldn't need this when generic sigs are fixed??
		if (onType.isRawType()) {
			onType = onType.getGenericType();
		}

		WeaverStateInfo info = onType.getWeaverState();

		// this test isnt quite right - there will be a case where we fail to
		// flag a problem
		// with a 'dangerous interface' because the type is reweavable when we
		// should have
		// because the type wasn't going to be rewoven... if that happens, we
		// should perhaps
		// move this test and dangerous interface processing to the end of this
		// method and
		// make it conditional on whether any of the typeMungers passed into
		// here actually
		// matched this type.
		if (info != null && !info.isOldStyle() && !info.isReweavable()) {
			processTypeMungersFromExistingWeaverState(sourceType, onType);
			CompilationAndWeavingContext.leavingPhase(tok);
			return;
		}

		// Check if the type we are looking at is the topMostImplementor of a
		// dangerous interface -
		// report a problem if it is.
		for (Iterator i = dangerousInterfaces.entrySet().iterator(); i.hasNext();) {
			Map.Entry entry = (Map.Entry) i.next();
			ResolvedType interfaceType = (ResolvedType) entry.getKey();
			if (onType.isTopmostImplementor(interfaceType)) {
				factory.showMessage(IMessage.ERROR, onType + ": " + entry.getValue(), onType.getSourceLocation(), null);
			}
		}

		boolean needOldStyleWarning = (info != null && info.isOldStyle());

		onType.clearInterTypeMungers();
		onType.ensureConsistent();

		// FIXME asc perf Could optimize here, after processing the expected set
		// of types we may bring
		// binary types that are not exposed to the weaver, there is no need to
		// attempt declare parents
		// or declare annotation really - unless we want to report the
		// not-exposed to weaver
		// messages...

		List decpToRepeat = new ArrayList();
		List<DeclareAnnotation> decaToRepeat = new ArrayList<DeclareAnnotation>();
		boolean anyNewParents = false;
		boolean anyNewAnnotations = false;

		// first pass
		// try and apply all decps - if they match, then great. If they don't
		// then
		// check if they are starred-annotation patterns. If they are not
		// starred
		// annotation patterns then they might match later...remember that...
		for (Iterator i = declareParents.iterator(); i.hasNext();) {
			DeclareParents decp = (DeclareParents) i.next();
			if (!decp.isMixin()) {
				boolean didSomething = doDeclareParents(decp, sourceType);
				if (didSomething) {
					if (factory.pushinCollector != null) {
						factory.pushinCollector.tagAsMunged(sourceType, decp.getParents().get(0));
					}
					anyNewParents = true;
				} else {
					if (!decp.getChild().isStarAnnotation()) {
						decpToRepeat.add(decp);
					}
				}
			}
		}

		for (Iterator<DeclareAnnotation> i = declareAnnotationOnTypes.iterator(); i.hasNext();) {
			DeclareAnnotation deca = i.next();
			boolean didSomething = doDeclareAnnotations(deca, sourceType, true);
			if (didSomething) {
				anyNewAnnotations = true;
			} else {
				if (!deca.getTypePattern().isStar()) {
					decaToRepeat.add(deca);
				}
			}
		}

		// now lets loop over and over until we have done all we can
		while ((anyNewAnnotations || anyNewParents) && (!decpToRepeat.isEmpty() || !decaToRepeat.isEmpty())) {
			anyNewParents = anyNewAnnotations = false;
			List forRemoval = new ArrayList();
			for (Iterator i = decpToRepeat.iterator(); i.hasNext();) {
				DeclareParents decp = (DeclareParents) i.next();
				boolean didSomething = doDeclareParents(decp, sourceType);
				if (didSomething) {
					if (factory.pushinCollector != null) {
						factory.pushinCollector.tagAsMunged(sourceType, decp.getParents().get(0));
					}
					anyNewParents = true;
					forRemoval.add(decp);
				}
			}
			decpToRepeat.removeAll(forRemoval);

			forRemoval.clear();
			for (Iterator i = declareAnnotationOnTypes.iterator(); i.hasNext();) {
				DeclareAnnotation deca = (DeclareAnnotation) i.next();
				boolean didSomething = doDeclareAnnotations(deca, sourceType, false);
				if (didSomething) {
					if (factory.pushinCollector != null) {
						factory.pushinCollector.tagAsMunged(sourceType, deca.getAnnotationString());
					}
					anyNewAnnotations = true;
					forRemoval.add(deca);
				}
			}
			decaToRepeat.removeAll(forRemoval);
		}

		for (Iterator<ConcreteTypeMunger> i = typeMungers.iterator(); i.hasNext();) {
			EclipseTypeMunger munger = (EclipseTypeMunger) i.next();
			if (munger.matches(onType)) {
				if (needOldStyleWarning) {
					factory.showMessage(IMessage.WARNING, "The class for " + onType
							+ " should be recompiled with ajc-1.1.1 for best results", onType.getSourceLocation(), null);
					needOldStyleWarning = false;
				}
				onType.addInterTypeMunger(munger, true);
				if (munger.getMunger() != null && munger.getMunger().getKind() == ResolvedTypeMunger.InnerClass) {
					// Must do these right now, because if we do an ITD member afterwards it may attempt to reference the
					// type being applied (the call above 'addInterTypeMunger' will fail for these ITDs if it needed
					// it to be in place)
					if (munger.munge(sourceType, onType)) {
						if (factory.pushinCollector != null) {
							factory.pushinCollector.tagAsMunged(sourceType, munger.getSourceMethod());
						}
					}
				}
			}
		}

		onType.checkInterTypeMungers();
		for (Iterator i = onType.getInterTypeMungers().iterator(); i.hasNext();) {
			EclipseTypeMunger munger = (EclipseTypeMunger) i.next();
			if (munger.getMunger() == null || munger.getMunger().getKind() != ResolvedTypeMunger.InnerClass) {
				if (munger.munge(sourceType, onType)) {
					if (factory.pushinCollector != null) {
						factory.pushinCollector.tagAsMunged(sourceType, munger.getSourceMethod());
					}
				}
			}
		}

		// Call if you would like to do source weaving of declare
		// @method/@constructor
		// at source time... no need to do this as it can't impact anything, but
		// left here for
		// future generations to enjoy. Method source is commented out at the
		// end of this module
		// doDeclareAnnotationOnMethods();

		// Call if you would like to do source weaving of declare @field
		// at source time... no need to do this as it can't impact anything, but
		// left here for
		// future generations to enjoy. Method source is commented out at the
		// end of this module
		// doDeclareAnnotationOnFields();

		if (skipInners) {
			CompilationAndWeavingContext.leavingPhase(tok);
			return;
		}

		ReferenceBinding[] memberTypes = sourceType.memberTypes;
		for (int i = 0, length = memberTypes.length; i < length; i++) {
			if (memberTypes[i] instanceof SourceTypeBinding) {
				weaveInterTypeDeclarations((SourceTypeBinding) memberTypes[i], typeMungers, declareParents,
						declareAnnotationOnTypes, false);
			}
		}
		CompilationAndWeavingContext.leavingPhase(tok);
	}
================= fetch private void weaveIntertypes(List<SourceTypeBinding> typesToProcess, SourceTypeB 16adee6^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java
/**
	 * Weave the parents and intertype decls into a given type. This method looks at the supertype and superinterfaces for the
	 * specified type and recurses to weave those first if they are in the full list of types we are going to process during this
	 * compile... it stops recursing the first time it hits a type we aren't going to process during this compile. This could cause
	 * problems if you supply 'pieces' of a hierarchy, i.e. the bottom and the top, but not the middle - but what the hell are you
	 * doing if you do that?
	 */
private void weaveIntertypes(List<SourceTypeBinding> typesToProcess, SourceTypeBinding typeToWeave,
			List<ConcreteTypeMunger> typeMungers, List<DeclareParents> declareParents,
			List<DeclareAnnotation> declareAnnotationOnTypes) {
		// Look at the supertype first
		ReferenceBinding superType = typeToWeave.superclass();
		if (typesToProcess.contains(superType) && superType instanceof SourceTypeBinding) {
			// System.err.println("Recursing to supertype "+new
			// String(superType.getFileName()));
			weaveIntertypes(typesToProcess, (SourceTypeBinding) superType, typeMungers, declareParents, declareAnnotationOnTypes);
		}
		// Then look at the superinterface list
		ReferenceBinding[] interfaceTypes = typeToWeave.superInterfaces();
		for (int i = 0; i < interfaceTypes.length; i++) {
			ReferenceBinding binding = interfaceTypes[i];
			if (typesToProcess.contains(binding) && binding instanceof SourceTypeBinding) {
				// System.err.println("Recursing to superinterface "+new
				// String(binding.getFileName()));
				weaveIntertypes(typesToProcess, (SourceTypeBinding) binding, typeMungers, declareParents, declareAnnotationOnTypes);
			}
		}
		weaveInterTypeDeclarations(typeToWeave, typeMungers, declareParents, declareAnnotationOnTypes, false);
		typesToProcess.remove(typeToWeave);
	}
================= fetch public void completeTypeBindings() { 16adee6^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java
// ??? duplicates some of super's code
public void completeTypeBindings() {
		AsmManager.setCompletingTypeBindings(true);
		ContextToken completeTypeBindingsToken = CompilationAndWeavingContext.enteringPhase(
				CompilationAndWeavingContext.COMPLETING_TYPE_BINDINGS, "");
		// builtInterTypesAndPerClauses = false;
		// pendingTypesToWeave = new ArrayList();
		stepCompleted = BUILD_TYPE_HIERARCHY;

		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.CHECK_AND_SET_IMPORTS,
					units[i].compilationResult.fileName);
			units[i].scope.checkAndSetImports();
			CompilationAndWeavingContext.leavingPhase(tok);
		}
		stepCompleted = CHECK_AND_SET_IMPORTS;

		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.CONNECTING_TYPE_HIERARCHY,
					units[i].compilationResult.fileName);
			units[i].scope.connectTypeHierarchy();
			CompilationAndWeavingContext.leavingPhase(tok);
		}
		stepCompleted = CONNECT_TYPE_HIERARCHY;

		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.BUILDING_FIELDS_AND_METHODS,
					units[i].compilationResult.fileName);
			// units[i].scope.checkParameterizedTypes(); do this check a little
			// later, after ITDs applied to stbs
			units[i].scope.buildFieldsAndMethods();
			CompilationAndWeavingContext.leavingPhase(tok);
		}

		// would like to gather up all TypeDeclarations at this point and put
		// them in the factory
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			SourceTypeBinding[] b = units[i].scope.topLevelTypes;
			for (int j = 0; j < b.length; j++) {
				factory.addSourceTypeBinding(b[j], units[i]);
			}
		}

		// We won't find out about anonymous types until later though, so
		// register to be
		// told about them when they turn up.
		AnonymousClassPublisher.aspectOf().setAnonymousClassCreationListener(this);

		// need to build inter-type declarations for all AspectDeclarations at
		// this point
		// this MUST be done in order from super-types to subtypes
		List<SourceTypeBinding> typesToProcess = new ArrayList<SourceTypeBinding>();
		List<SourceTypeBinding> aspectsToProcess = new ArrayList<SourceTypeBinding>();
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			CompilationUnitScope cus = units[i].scope;
			SourceTypeBinding[] stbs = cus.topLevelTypes;
			for (int j = 0; j < stbs.length; j++) {
				SourceTypeBinding stb = stbs[j];
				typesToProcess.add(stb);
				TypeDeclaration typeDeclaration = stb.scope.referenceContext;
				if (typeDeclaration instanceof AspectDeclaration) {
					aspectsToProcess.add(stb);
				}
			}
		}
		factory.getWorld().getCrosscuttingMembersSet().reset();

		// Need to do these before the other ITDs
		for (SourceTypeBinding aspectToProcess : aspectsToProcess) {
			processInterTypeMemberTypes(aspectToProcess.scope);
		}

		while (typesToProcess.size() > 0) {
			// removes types from the list as they are processed...
			collectAllITDsAndDeclares(typesToProcess.get(0), typesToProcess);
		}

		factory.finishTypeMungers();

		// now do weaving
		List<ConcreteTypeMunger> typeMungers = factory.getTypeMungers();

		List<DeclareParents> declareParents = factory.getDeclareParents();
		List<DeclareAnnotation> declareAnnotationOnTypes = factory.getDeclareAnnotationOnTypes();

		doPendingWeaves();

		// We now have some list of types to process, and we are about to apply
		// the type mungers.
		// There can be situations where the order of types passed to the
		// compiler causes the
		// output from the compiler to vary - THIS IS BAD. For example, if we
		// have class A
		// and class B extends A. Also, an aspect that 'declare parents: A+
		// implements Serializable'
		// then depending on whether we see A first, we may or may not make B
		// serializable.

		// The fix is to process them in the right order, ensuring that for a
		// type we process its
		// supertypes and superinterfaces first. This algorithm may have
		// problems with:
		// - partial hierarchies (e.g. suppose types A,B,C are in a hierarchy
		// and A and C are to be woven but not B)
		// - weaving that brings new types in for processing (see
		// pendingTypesToWeave.add() calls) after we thought
		// we had the full list.
		//
		// but these aren't common cases (he bravely said...)
		boolean typeProcessingOrderIsImportant = declareParents.size() > 0 || declareAnnotationOnTypes.size() > 0; // DECAT

		if (typeProcessingOrderIsImportant) {
			typesToProcess = new ArrayList();
			for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
				CompilationUnitScope cus = units[i].scope;
				SourceTypeBinding[] stbs = cus.topLevelTypes;
				for (int j = 0; j < stbs.length; j++) {
					SourceTypeBinding stb = stbs[j];
					typesToProcess.add(stb);
				}
			}

			while (typesToProcess.size() > 0) {
				// A side effect of weaveIntertypes() is that the processed type
				// is removed from the collection
				weaveIntertypes(typesToProcess, typesToProcess.get(0), typeMungers, declareParents, declareAnnotationOnTypes);
			}

		} else {
			// Order isn't important
			for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
				weaveInterTypeDeclarations(units[i].scope, typeMungers, declareParents, declareAnnotationOnTypes);
			}
		}

		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			units[i].scope.checkParameterizedTypes();
		}

		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			SourceTypeBinding[] b = units[i].scope.topLevelTypes;
			for (int j = 0; j < b.length; j++) {
				ContextToken tok = CompilationAndWeavingContext.enteringPhase(
						CompilationAndWeavingContext.RESOLVING_POINTCUT_DECLARATIONS, b[j].sourceName);
				resolvePointcutDeclarations(b[j].scope);
				CompilationAndWeavingContext.leavingPhase(tok);
			}
		}

		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			SourceTypeBinding[] b = units[i].scope.topLevelTypes;
			for (int j = 0; j < b.length; j++) {
				ContextToken tok = CompilationAndWeavingContext.enteringPhase(
						CompilationAndWeavingContext.ADDING_DECLARE_WARNINGS_AND_ERRORS, b[j].sourceName);
				addAdviceLikeDeclares(b[j].scope);
				CompilationAndWeavingContext.leavingPhase(tok);
			}
		}

		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			units[i] = null; // release unnecessary reference to the parsed unit
		}

		stepCompleted = BUILD_FIELDS_AND_METHODS;
		lastCompletedUnitIndex = lastUnitIndex;
		AsmManager.setCompletingTypeBindings(false);
		factory.getWorld().getCrosscuttingMembersSet().verify();
		CompilationAndWeavingContext.leavingPhase(completeTypeBindingsToken);
	}
================= fetch private void printExpendableMap(Map m) { 85fd25d^:loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java

private void printExpendableMap(Map m) {
		for (Object o : m.keySet()) {
			String sig = (String) o;
			System.out.println(sig + "=" + m.get(sig));
		}
	}
================= fetch private void printMaps(TypeMap map) { 85fd25d^:loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java

private void printMaps(TypeMap map) {
		printExpendableMap(map.getExpendableMap());
		printMainMap(map.getMainMap());
	}
================= fetch protected boolean accept(String className, byte[] bytes) { 85fd25d^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
	 * Determine whether a type should be accepted for weaving, by checking it against any includes/excludes.
	 * 
	 * @param className the name of the type to possibly accept
	 * @param bytes the bytecode for the type (in case we need to look inside, eg. annotations)
	 * @return true if it should be accepted for weaving
	 */
@Override
	protected boolean accept(String className, byte[] bytes) {

		if (!hasExcludes && !hasIncludes) {
			return true;
		}

		// still try to avoid ResolvedType if we have simple patterns
		String fastClassName = className.replace('/', '.').replace('$', '.');
		for (String excludeStartsWithString : excludeStartsWith) {
			if (fastClassName.startsWith(excludeStartsWithString)) {
				return false;
			}
		}

		// Fast exclusion of patterns like: "*..*CGLIB*"
		if (!excludeStarDotDotStar.isEmpty()) {
			for (String namePiece : excludeStarDotDotStar) {
				int index = fastClassName.lastIndexOf('.');
				if (fastClassName.indexOf(namePiece, index + 1) != -1) {
					return false;
				}
			}
		}

		if (!excludeEndsWith.isEmpty()) {
			for (String lastPiece : excludeEndsWith) {
				if (fastClassName.endsWith(lastPiece)) {
					return false;
				}
			}
		}

		// Fast exclusion of exact names
		if (!excludeExactName.isEmpty()) {
			for (String name : excludeExactName) {
				if (fastClassName.equals(name)) {
					return false;
				}
			}
		}

		if (!excludeSpecial.isEmpty()) {
			for (String[] entry : excludeSpecial) {
				String excludeThese = entry[0];
				String exceptThese = entry[1];
				if (fastClassName.startsWith(excludeThese) && !fastClassName.startsWith(exceptThese)) {
					return false;
				}
			}
		}

		/*
		 * Bug 120363 If we have an exclude pattern that cannot be matched using "starts with" then we cannot fast accept
		 */
		boolean didSomeIncludeMatching = false;
		if (excludeTypePattern.isEmpty()) {
			if (includeStar) {
				return true;
			}
			if (!includeExactName.isEmpty()) {
				didSomeIncludeMatching = true;
				for (String exactname : includeExactName) {
					if (fastClassName.equals(exactname)) {
						return true;
					}
				}
			}
			boolean fastAccept = false;// defaults to false if no fast include
			for (int i = 0; i < m_includeStartsWith.size(); i++) {
				didSomeIncludeMatching = true;
				fastAccept = fastClassName.startsWith(m_includeStartsWith.get(i));
				if (fastAccept) {
					return true;
				}
			}
			// We may have processed all patterns now... check that and return
			if (includeTypePattern.isEmpty()) {
				return !didSomeIncludeMatching;
			}
		}

		boolean accept;
		try {
			ensureDelegateInitialized(className, bytes);

			ResolvedType classInfo = delegateForCurrentClass.getResolvedTypeX();

			// exclude are "AND"ed
			for (TypePattern typePattern : excludeTypePattern) {
				if (typePattern.matchesStatically(classInfo)) {
					// exclude match - skip
					return false;
				}
			}
			// include are "OR"ed
			if (includeStar) {
				return true;
			}
			if (!includeExactName.isEmpty()) {
				didSomeIncludeMatching = true;
				for (String exactname : includeExactName) {
					if (fastClassName.equals(exactname)) {
						return true;
					}
				}
			}
			for (int i = 0; i < m_includeStartsWith.size(); i++) {
				didSomeIncludeMatching = true;
				boolean fastaccept = fastClassName.startsWith(m_includeStartsWith.get(i));
				if (fastaccept) {
					return true;
				}
			}
			accept = !didSomeIncludeMatching; // only true if no includes at all
			for (TypePattern typePattern : includeTypePattern) {
				accept = typePattern.matchesStatically(classInfo);
				if (accept) {
					break;
				}
				// goes on if this include did not match ("OR"ed)
			}
		} finally {
			this.bcelWorld.demote();
		}
		return accept;
	}
================= fetch public TestClassLoaderWeavingAdaptor getAdaptor(String[] includePatterns, String 85fd25d^:loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java

public TestClassLoaderWeavingAdaptor getAdaptor(String[] includePatterns, String[] excludePatterns) {
		try {
			URLClassLoader loader = new URLClassLoader(new URL[] { new File("../loadtime/bin").toURI().toURL(),
					new File("../loadtime/testdata/anaspect.jar").toURI().toURL() }, null);
			TestWeavingContext wc = new TestWeavingContext(loader);
			Definition d = new Definition();
			if (includePatterns != null) {
				for (String s : includePatterns) {
					d.getIncludePatterns().add(s);
				}
			}
			if (excludePatterns != null) {
				for (String s : excludePatterns) {
					d.getExcludePatterns().add(s);
				}
			}
			// need some random aspect or the weaver will shut down!
			d.getAspectClassNames().add("AnAspect");
			wc.addDefinition(d);
			TestClassLoaderWeavingAdaptor adaptor = new TestClassLoaderWeavingAdaptor();
			adaptor.initialize(loader, wc);
			return adaptor;
		} catch (Exception e) {
			throw new RuntimeException(e);
		}
	}
================= fetch public static SyntheticRepository createRepos(String cpentry) { 85fd25d^:loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java

public static SyntheticRepository createRepos(String cpentry) {
		ClassPath cp = new ClassPath(cpentry + File.pathSeparator + System.getProperty("java.class.path"));
		return SyntheticRepository.getInstance(cp);
	}
================= fetch public void addDefinition(Definition d) { 85fd25d^:loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java

public void addDefinition(Definition d) {
			testList.add(d);
		}
================= fetch public void testAcceptanceSpeedStarDotDotStar() throws Exception { 85fd25d^:loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java
// }
public void testAcceptanceSpeedStarDotDotStar() throws Exception {
		URLClassLoader loader = new URLClassLoader(new URL[] { new File("../loadtime/bin").toURI().toURL(),
				new File("../loadtime/testdata/anaspect.jar").toURI().toURL() }, null);

		JavaClass jc = getClassFrom("../loadtime/bin", "org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptorTest$TestOne");
		byte[] bs = jc.getBytes();
		jc = getClassFrom("../loadtime/bin", "org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptorTest$TestOneCGLIB");
		byte[] bs2 = jc.getBytes();
		// InputStream is = loader.getResourceAsStream("org.aspectj.weaver.loadtime.ClassLoaderWeaverAdaptorTests$TestOne");
		assertNotNull(bs);
		TestWeavingContext wc = new TestWeavingContext(loader);
		Definition d = new Definition();
		d.getExcludePatterns().add("*..*CGLIB*");
		d.getAspectClassNames().add("AnAspect");
		wc.addDefinition(d);
		ClassLoaderWeavingAdaptor adaptor = new ClassLoaderWeavingAdaptor();
		adaptor.initialize(loader, wc);
		boolean exist = adaptor.generatedClassesExistFor("Junk");
		assertFalse("There should be no generated classes", exist);

		// before:
		// Acceptance 331ms
		// Rejection 3368ms

		// after:
		// Acceptance 343ms
		// Rejection 80ms

		long stime = System.currentTimeMillis();
		for (int i = 0; i < 100000; i++) {
			boolean b = adaptor.accept("org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptorTest$TestOne", bs);
			assertTrue("Should be accepted", b);
		}
		long etime = System.currentTimeMillis();
		System.out.println("Acceptance " + (etime - stime) + "ms");
		stime = System.currentTimeMillis();
		for (int i = 0; i < 100000; i++) {
			adaptor.delegateForCurrentClass = null;
			boolean b = adaptor.accept("org.aspectj.weaver.loadtime.ClassLoaderWeavingAdaptorTest$TestOneCGLIB", bs2);
			assertFalse("Should not be accepting CGLIB", b);
		}
		etime = System.currentTimeMillis();
		System.out.println("Rejection " + (etime - stime) + "ms");

	}
================= fetch private void ensureAnnotationTypesResolved() { fe049ea^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java
/**
	 * Ensure the annotation types have been resolved, where resolved means the eclipse type bindings have been converted to their
	 * ResolvedType representations. This does not deeply resolve the annotations, it only does the type names.
	 */
private void ensureAnnotationTypesResolved() {
		if (!annotationTypesAreResolved) {
			Annotation[] as = declaration.annotations;
			if (as == null) {
				annotationTypes = ResolvedType.NONE;
			} else {
				annotationTypes = new ResolvedType[as.length];
				for (int a = 0; a < as.length; a++) {
					TypeBinding tb = as[a].type.resolveType(declaration.staticInitializerScope);
					if (tb == null) {
						annotationTypes[a] = ResolvedType.MISSING;
					} else {
						annotationTypes[a] = factory.fromTypeBindingToRTX(tb);
					}
				}
			}
			annotationTypesAreResolved = true;
		}
	}
Progress : [########--------------------------------] 22%================= fetch private boolean isNamePatternStar() { 767bb85^:org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildTypePattern.java
/**
	 * returns those possible matches which I match exactly the last element of
	 */
private String[] preMatch(String[] possibleMatches) {
		// if (namePatterns.length != 1) return CollectionUtil.NO_STRINGS;

		List ret = new ArrayList();
		for (int i = 0, len = possibleMatches.length; i < len; i++) {
			char[][] names = splitNames(possibleMatches[i], true); // ??? not most efficient
			if (namePatterns[0].matches(names[names.length - 1])) {
				ret.add(possibleMatches[i]);
				continue;
			}
			if (possibleMatches[i].indexOf("$") != -1) {
				names = splitNames(possibleMatches[i], false); // ??? not most efficient
				if (namePatterns[0].matches(names[names.length - 1])) {
					ret.add(possibleMatches[i]);
				}
			}
		}
		return (String[]) ret.toArray(new String[ret.size()]);
	}
================= fetch protected boolean couldEverMatchSameTypesAs(TypePattern other) { 767bb85^:org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildTypePattern.java
// names). More work required on our part to get this right...
public static char[][] splitNames(String s, boolean convertDollar) {
		List ret = new ArrayList();
		int startIndex = 0;
		while (true) {
			int breakIndex = s.indexOf('.', startIndex); // what about /
			if (convertDollar && (breakIndex == -1)) {
				breakIndex = s.indexOf('$', startIndex); // we treat $ like . here
			}
			if (breakIndex == -1) {
				break;
			}
			char[] name = s.substring(startIndex, breakIndex).toCharArray();
			ret.add(name);
			startIndex = breakIndex + 1;
		}
		ret.add(s.substring(startIndex).toCharArray());
		return (char[][]) ret.toArray(new char[ret.size()][]);
	}
================= fetch public BindingScope(ResolvedType type, ISourceContext sourceContext, FormalBindi 767bb85^:org.aspectj.matcher/src/org/aspectj/weaver/BindingScope.java

================= fetch public FormalBinding lookupFormal(String name) { 767bb85^:org.aspectj.matcher/src/org/aspectj/weaver/patterns/SimpleScope.java

public FormalBinding lookupFormal(String name) {
		for (int i = 0, len = bindings.length; i < len; i++) {
			if (bindings[i].getName().equals(name))
				return bindings[i];
		}
		return null;
	}
================= fetch public ISourceLocation makeSourceLocation(IHasPosition location) { 767bb85^:org.aspectj.matcher/src/org/aspectj/weaver/BindingScope.java

public ISourceLocation makeSourceLocation(IHasPosition location) {
		return m_sourceContext.makeSourceLocation(location);
	}
================= fetch public ResolvedType getEnclosingType() { 767bb85^:org.aspectj.matcher/src/org/aspectj/weaver/BindingScope.java

public ResolvedType getEnclosingType() {
		return m_enclosingType;
	}
================= fetch public SimpleScope(World world, FormalBinding[] bindings) { 767bb85^:org.aspectj.matcher/src/org/aspectj/weaver/patterns/SimpleScope.java

================= fetch public UnresolvedType lookupType(String name, IHasPosition location) { 767bb85^:org.aspectj.matcher/src/org/aspectj/weaver/BindingScope.java

public UnresolvedType lookupType(String name, IHasPosition location) {
		// bug 126560
		if (m_enclosingType != null) {
			// add the package we're in to the list of imported
			// prefixes so that we can find types in the same package
			String pkgName = m_enclosingType.getPackageName();
			if (pkgName != null && !pkgName.equals("")) {
				String[] currentImports = getImportedPrefixes();
				String[] newImports = new String[currentImports.length + 1];
				for (int i = 0; i < currentImports.length; i++) {
					newImports[i] = currentImports[i];
				}
				newImports[currentImports.length] = pkgName.concat(".");
				setImportedPrefixes(newImports);
			}
		}
		return super.lookupType(name, location);
	}
================= fetch public UnresolvedType lookupType(String name, IHasPosition location) { 767bb85^:org.aspectj.matcher/src/org/aspectj/weaver/patterns/SimpleScope.java
// XXX doesn't report any problems
public UnresolvedType lookupType(String name, IHasPosition location) {
		for (int i = 0; i < importedNames.length; i++) {
			String importedName = importedNames[i];
			// // make sure we're matching against the
			// // type name rather than part of it
			// if (importedName.endsWith("." + name)) {
			if (importedName.endsWith(name)) {
				return world.resolve(importedName);
			}
		}

		for (int i = 0; i < importedPrefixes.length; i++) {
			String importedPrefix = importedPrefixes[i];
			ResolvedType tryType = world.resolve(UnresolvedType.forName(importedPrefix + name), true);
			if (!tryType.isMissing()) {
				return tryType;
			}
		}

		return world.resolve(UnresolvedType.forName(name), true);
	}
================= fetch public static Test suite() { 767bb85^:org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/PatternsTests.java

public static Test suite() {
		TestSuite suite = new TestSuite(PatternsTests.class.getName());
		// $JUnit-BEGIN$
		suite.addTestSuite(AndOrNotTestCase.class);
		suite.addTestSuite(BindingTestCase.class);
		suite.addTestSuite(DeclareErrorOrWarningTestCase.class);
		suite.addTestSuite(ModifiersPatternTestCase.class);
		suite.addTestSuite(NamePatternParserTestCase.class);
		suite.addTestSuite(NamePatternTestCase.class);
		suite.addTestSuite(ParserTestCase.class);
		suite.addTestSuite(SignaturePatternTestCase.class);
		suite.addTestSuite(ThisOrTargetTestCase.class);
		suite.addTestSuite(TypePatternListTestCase.class);
		suite.addTestSuite(TypePatternTestCase.class);
		suite.addTestSuite(WithinTestCase.class);
		suite.addTestSuite(ArgsTestCase.class);
		// suite.addTestSuite(AnnotationPatternTestCase.class);
		// suite.addTestSuite(AnnotationPatternMatchingTestCase.class);
		suite.addTestSuite(PointcutRewriterTest.class);
		suite.addTestSuite(VisitorTestCase.class);
		// $JUnit-END$
		return suite;
	}
================= fetch public void message(IMessage.Kind kind, IHasPosition location, String message) { 767bb85^:org.aspectj.matcher/src/org/aspectj/weaver/patterns/SimpleScope.java

public void message(IMessage.Kind kind, IHasPosition location, String message) {
		getMessageHandler().handleMessage(new Message(message, kind, null, makeSourceLocation(location)));

	}
================= fetch public void setImportedPrefixes(String[] importedPrefixes) { 767bb85^:org.aspectj.matcher/src/org/aspectj/weaver/patterns/SimpleScope.java

public static FormalBinding[] makeFormalBindings(UnresolvedType[] types, String[] names) {
		int len = types.length;
		FormalBinding[] bindings = new FormalBinding[len];
		for (int i = 0; i < len; i++) {
			bindings[i] = new FormalBinding(types[i], names[i], i);
		}
		return bindings;
	}
================= fetch public void testImportMatchWithInners() { 767bb85^:org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/TypePatternTestCase.java

public void testImportMatchWithInners() {
		checkImportMatch("*Entry", new String[] { "java.util.", "java.util.Map$" }, ZERO_STRINGS, "java.util.Map$Entry", true);

		checkImportMatch("java.util.Map.*Entry", ZERO_STRINGS, ZERO_STRINGS, "java.util.Map$Entry", true);

		checkImportMatch("*Entry", new String[] { "java.util.", }, ZERO_STRINGS, "java.util.Map$Entry", false);

		checkImportMatch("*.Entry", new String[] { "java.util.", }, ZERO_STRINGS, "java.util.Map$Entry", true);

		checkImportMatch("Map.*", new String[] { "java.util.", }, ZERO_STRINGS, "java.util.Map$Entry", true);

		checkImportMatch("Map.*", ZERO_STRINGS, new String[] { "java.util.Map" }, "java.util.Map$Entry", true);
	}
================= fetch private void ensureGenericSignatureUnpacked() { 92a52a2^:weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java

public GenericSignature.FormalTypeParameter[] getAllFormals() {
		ensureGenericSignatureUnpacked();
		if (formalsForResolution == null) {
			return new GenericSignature.FormalTypeParameter[0];
		} else {
			return formalsForResolution;
		}
	}
================= fetch public static Advice makeCflowEntry(World world, Pointcut entry, boolean isBelow 0e5ecd3^:org.aspectj.matcher/src/org/aspectj/weaver/Advice.java

public static Advice makeCflowEntry(World world, Pointcut entry, boolean isBelow, Member stackField, int nFreeVars,
			List innerCflowEntries, ResolvedType inAspect) {
		Advice ret = world.createAdviceMunger(isBelow ? AdviceKind.CflowBelowEntry : AdviceKind.CflowEntry, entry, stackField, 0,
				entry, inAspect);
		ret.innerCflowEntries = innerCflowEntries;
		ret.nFreeVars = nFreeVars;
		return ret;
	}
================= fetch private void ensureAspectJAttributesUnpacked() { cf0ee0c^:weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java

private AjAttribute.Aspect processAttributes(List<AjAttribute> attributeList, List<ResolvedPointcutDefinition> pointcuts,
			boolean fromAnnotations) {
		AjAttribute.Aspect deferredAspectAttribute = null;
		for (AjAttribute a : attributeList) {
			if (a instanceof AjAttribute.Aspect) {
				if (fromAnnotations) {
					deferredAspectAttribute = (AjAttribute.Aspect) a;
				} else {
					perClause = ((AjAttribute.Aspect) a).reify(this.getResolvedTypeX());
					isCodeStyleAspect = true;
				}
			} else if (a instanceof AjAttribute.PointcutDeclarationAttribute) {
				pointcuts.add(((AjAttribute.PointcutDeclarationAttribute) a).reify());
			} else if (a instanceof AjAttribute.WeaverState) {
				weaverState = ((AjAttribute.WeaverState) a).reify();
			} else if (a instanceof AjAttribute.TypeMunger) {
				typeMungers.add(((AjAttribute.TypeMunger) a).reify(getResolvedTypeX().getWorld(), getResolvedTypeX()));
			} else if (a instanceof AjAttribute.DeclareAttribute) {
				declares.add(((AjAttribute.DeclareAttribute) a).getDeclare());
			} else if (a instanceof AjAttribute.PrivilegedAttribute) {
				AjAttribute.PrivilegedAttribute privAttribute = (AjAttribute.PrivilegedAttribute) a;
				privilegedAccess = privAttribute.getAccessedMembers();
			} else if (a instanceof AjAttribute.SourceContextAttribute) {
				if (getResolvedTypeX().getSourceContext() instanceof SourceContextImpl) {
					AjAttribute.SourceContextAttribute sca = (AjAttribute.SourceContextAttribute) a;
					((SourceContextImpl) getResolvedTypeX().getSourceContext()).configureFromAttribute(sca.getSourceFileName(), sca
							.getLineBreaks());

					setSourcefilename(sca.getSourceFileName());
				}
			} else if (a instanceof AjAttribute.WeaverVersionInfo) {
				wvInfo = (AjAttribute.WeaverVersionInfo) a; // Set the weaver
				// version used to
				// build this type
			} else {
				throw new BCException("bad attribute " + a);
			}
		}
		return deferredAspectAttribute;
	}
================= fetch protected Boolean initialValue() { cf0ee0c^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java
/**
	 * Weave a class using aspects previously supplied to the adaptor.
	 * 
	 * @param name the name of the class
	 * @param bytes the class bytes
	 * @param mustWeave if true then this class *must* get woven (used for concrete aspects generated from XML)
	 * @return the woven bytes
	 * @exception IOException weave failed
	 */
public byte[] weaveClass(String name, byte[] bytes, boolean mustWeave) throws IOException {
		if (trace==null) {
			// Pr231945: we are likely to be under tomcat and ENABLE_CLEAR_REFERENCES hasn't been set
			System.err.println("AspectJ Weaver cannot continue to weave, static state has been cleared.  Are you under Tomcat? In order to weave '"+name+
					"' during shutdown, 'org.apache.catalina.loader.WebappClassLoader.ENABLE_CLEAR_REFERENCES=false' must be set (see https://bugs.eclipse.org/bugs/show_bug.cgi?id=231945).");
			return bytes;
		}
		if (weaverRunning.get()) {
			// System.out.println("AJC: avoiding re-entrant call to transform " + name);
			return bytes;
		}
		try {
			weaverRunning.set(true);
			if (trace.isTraceEnabled()) {
				trace.enter("weaveClass", this, new Object[] { name, bytes });
			}

			if (!enabled) {
				if (trace.isTraceEnabled()) {
					trace.exit("weaveClass", false);
				}
				return bytes;
			}

			boolean debugOn = !messageHandler.isIgnoring(Message.DEBUG);

			try {
				delegateForCurrentClass = null;
				name = name.replace('/', '.');
				if (couldWeave(name, bytes)) {
					if (accept(name, bytes)) {
						// TODO @AspectJ problem
						// Annotation style aspects need to be included regardless in order to get
						// a valid aspectOf()/hasAspect() generated in them. However - if they are excluded
						// (via include/exclude in aop.xml) they really should only get aspectOf()/hasAspect()
						// and not be included in the full set of aspects being applied by 'this' weaver
						if (debugOn) {
							debug("weaving '" + name + "'");
						}
						bytes = getWovenBytes(name, bytes);
						// temporarily out - searching for @Aspect annotated types is a slow thing to do - we should
						// expect the user to name them if they want them woven - just like code style
						// } else if (shouldWeaveAnnotationStyleAspect(name, bytes)) {
						// if (mustWeave) {
						// if (bcelWorld.getLint().mustWeaveXmlDefinedAspects.isEnabled()) {
						// bcelWorld.getLint().mustWeaveXmlDefinedAspects.signal(name, null);
						// }
						// }
						// // an @AspectJ aspect needs to be at least munged by the aspectOf munger
						// if (debugOn) {
						// debug("weaving '" + name + "'");
						// }
						// bytes = getAtAspectJAspectBytes(name, bytes);
					} else if (debugOn) {
						debug("not weaving '" + name + "'");
					}
				} else if (debugOn) {
					debug("cannot weave '" + name + "'");
				}
			} finally {
				delegateForCurrentClass = null;
			}

			if (trace.isTraceEnabled()) {
				trace.exit("weaveClass", bytes);
			}
			return bytes;
		} finally {
			weaverRunning.set(false);
		}
	}
================= fetch public BcelObjectType addSourceObjectType(String classname, byte[] bytes, boolea cf0ee0c^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java

public BcelObjectType addSourceObjectType(String classname, byte[] bytes, boolean artificial) {
		BcelObjectType ret = null;
		String signature = UnresolvedType.forName(classname).getSignature();

		ResolvedType fromTheMap = typeMap.get(signature);

		if (fromTheMap != null && !(fromTheMap instanceof ReferenceType)) {
			// what on earth is it then? See pr 112243
			StringBuffer exceptionText = new StringBuffer();
			exceptionText.append("Found invalid (not a ReferenceType) entry in the type map. ");
			exceptionText.append("Signature=[" + signature + "] Found=[" + fromTheMap + "] Class=[" + fromTheMap.getClass() + "]");
			throw new BCException(exceptionText.toString());
		}

		ReferenceType nameTypeX = (ReferenceType) fromTheMap;

		if (nameTypeX == null) {
			JavaClass jc = Utility.makeJavaClass(classname, bytes);
			if (jc.isGeneric() && isInJava5Mode()) {
				nameTypeX = ReferenceType.fromTypeX(UnresolvedType.forRawTypeName(jc.getClassName()), this);
				ret = buildBcelDelegate(nameTypeX, jc, artificial, true);
				ReferenceType genericRefType = new ReferenceType(UnresolvedType.forGenericTypeSignature(signature, ret
						.getDeclaredGenericSignature()), this);
				nameTypeX.setDelegate(ret);
				genericRefType.setDelegate(ret);
				nameTypeX.setGenericType(genericRefType);
				typeMap.put(signature, nameTypeX);
			} else {
				nameTypeX = new ReferenceType(signature, this);
				ret = buildBcelDelegate(nameTypeX, jc, artificial, true);
				typeMap.put(signature, nameTypeX);
			}
		} else {
			Object o = nameTypeX.getDelegate();
			if (!(o instanceof BcelObjectType)) {
				throw new IllegalStateException("For " + classname + " should be BcelObjectType, but is " + o.getClass());
			}
			ret = (BcelObjectType) o;
			// byte[] bs = ret.javaClass.getBytes();
			// if (bs.length != bytes.length) {
			// throw new RuntimeException("Shit");
			// }
			if (ret.isArtificial()) {
				// System.out.println("Rebuilding " + nameTypeX.getName());
				ret = buildBcelDelegate(nameTypeX, Utility.makeJavaClass(classname, bytes), artificial, true);
			} else {
				ret.setExposedToWeaver(true);
			}
		}
		return ret;
	}
================= fetch public void evictWeavingState() { cf0ee0c^:weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java
// --- state management
public void evictWeavingState() {
		// Can't chuck all this away
		if (getResolvedTypeX().getWorld().couldIncrementalCompileFollow()) {
			return;
		}

		if (javaClass != null) {
			// Force retrieval of any lazy information
			ensureAnnotationsUnpacked();
			ensureGenericInfoProcessed();

			getDeclaredInterfaces();
			getDeclaredFields();
			getDeclaredMethods();
			// The lazyClassGen is preserved for aspects - it exists to enable
			// around advice
			// inlining since the method will need 'injecting' into the affected
			// class. If
			// XnoInline is on, we can chuck away the lazyClassGen since it
			// won't be required
			// later.
			if (getResolvedTypeX().getWorld().isXnoInline()) {
				lazyClassGen = null;
			}

			// discard expensive bytecode array containing reweavable info
			if (weaverState != null) {
				weaverState.setReweavable(false);
				weaverState.setUnwovenClassFileData(null);
			}
			for (int i = methods.length - 1; i >= 0; i--) {
				methods[i].evictWeavingState();
			}
			for (int i = fields.length - 1; i >= 0; i--) {
				fields[i].evictWeavingState();
			}
			javaClass = null;

			this.artificial = true;
			// setSourceContext(SourceContextImpl.UNKNOWN_SOURCE_CONTEXT); //
			// bit naughty
			// interfaces=null; // force reinit - may get us the right
			// instances!
			// superClass=null;
		}
	}
================= fetch private int getScore(Pointcut p) { 1e28b92^:org.aspectj.matcher/src/org/aspectj/weaver/patterns/PointcutEvaluationExpenseComparator.java
// a higher score means a more expensive evaluation
private int getScore(Pointcut p) {
		if (p.couldMatchKinds() == Shadow.NO_SHADOW_KINDS_BITS) {
			return MATCHES_NOTHING;
		}
		if (p instanceof WithinPointcut) {
			return WITHIN;
		}
		if (p instanceof WithinAnnotationPointcut) {
			return ATWITHIN;
		}
		if (p instanceof KindedPointcut) {
			KindedPointcut kp = (KindedPointcut) p;
			Shadow.Kind kind = kp.getKind();
			if (kind == Shadow.AdviceExecution) {
				return ADVICEEXECUTION;
			} else if ((kind == Shadow.ConstructorCall) || (kind == Shadow.MethodCall)) {
				return CALL;
			} else if ((kind == Shadow.ConstructorExecution) || (kind == Shadow.MethodExecution) || (kind == Shadow.Initialization)
					|| (kind == Shadow.PreInitialization)) {
				return EXE_INIT_PREINIT;
			} else if (kind == Shadow.ExceptionHandler) {
				return HANDLER;
			} else if ((kind == Shadow.FieldGet) || (kind == Shadow.FieldSet)) {
				return GET_OR_SET;
			} else if (kind == Shadow.StaticInitialization) {
				return STATICINIT;
			} else {
				return OTHER;
			}
		}
		if (p instanceof AnnotationPointcut) {
			return ANNOTATION;
		}
		if (p instanceof ArgsPointcut) {
			return ARGS;
		}
		if (p instanceof ArgsAnnotationPointcut) {
			return AT_ARGS;
		}
		if (p instanceof CflowPointcut) {
			return CFLOW;
		}
		if (p instanceof HandlerPointcut) {
			return HANDLER;
		}
		if (p instanceof IfPointcut) {
			return IF;
		}
		if (p instanceof ThisOrTargetPointcut) {
			return THIS_OR_TARGET;
		}
		if (p instanceof ThisOrTargetAnnotationPointcut) {
			return AT_THIS_OR_TARGET;
		}
		if (p instanceof WithincodePointcut) {
			return WITHINCODE;
		}
		if (p instanceof WithinCodeAnnotationPointcut) {
			return ATWITHINCODE;
		}
		if (p instanceof NotPointcut) {
			return getScore(((NotPointcut) p).getNegatedPointcut());
		}
		if (p instanceof AndPointcut) {
			return getScore(((AndPointcut) p).getLeft());
		}
		if (p instanceof OrPointcut) {
			return getScore(((OrPointcut) p).getLeft());
		}
		return OTHER;
	}
================= fetch public int compare(Pointcut p1, Pointcut p2) { 1e28b92^:org.aspectj.matcher/src/org/aspectj/weaver/patterns/PointcutEvaluationExpenseComparator.java

public int compare(Pointcut p1, Pointcut p2) {

		// important property for a well-defined comparator
		if (p1.equals(p2)) {
			return 0;
		}
		int result = getScore(p1) - getScore(p2);
		if (result == 0) {
			// they have the same evaluation expense, but are not 'equal'
			// sort by hashCode
			result = p1.hashCode() - p2.hashCode();
			if (result == 0) {
				/* not allowed if ne */return -1;
			}
		}
		return result;
	}
================= fetch public void testOrderingInAnd() { 1e28b92^:org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/PointcutRewriterTest.java

public void testOrderingInAnd() {
		Pointcut bigLongPC = getPointcut("cflow(this(Foo)) && @args(X) && args(X) && @this(Foo) && @target(Boo) && this(Moo) && target(Boo) && @annotation(Moo) && @withincode(Boo) && withincode(new(..)) && set(* *)&& @within(Foo) && within(Foo)");
		Pointcut rewritten = prw.rewrite(bigLongPC);
		assertEquals(
				"((((((((((((within(Foo) && @within(Foo)) && set(* *)) && withincode(new(..))) && @withincode(Boo)) && target(Boo)) && this(Moo)) && @annotation(Moo)) && @target(Boo)) && @this(Foo)) && args(X)) && @args(X)) && cflow(this(Foo)))",
				rewritten.toString());
	}
================= fetch private static ISourceLocation getBinarySourceLocation(ResolvedType aspect, ISou 3be69a2^:weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java
/**
	 * Returns the binarySourceLocation for the given sourcelocation. This isn't cached because it's used when faulting in the
	 * binary nodes and is called with ISourceLocations for all advice, pointcuts and deows contained within the
	 * resolvedDeclaringAspect.
	 */
private static ISourceLocation getBinarySourceLocation(ResolvedType aspect, ISourceLocation sl) {
		if (sl == null) {
			return null;
		}
		String sourceFileName = null;
		if (aspect instanceof ReferenceType) {
			String s = ((ReferenceType) aspect).getDelegate().getSourcefilename();
			int i = s.lastIndexOf('/');
			if (i != -1) {
				sourceFileName = s.substring(i + 1);
			} else {
				sourceFileName = s;
			}
		}
		ISourceLocation sLoc = new SourceLocation(getBinaryFile(aspect), sl.getLine(), sl.getEndLine(),
				((sl.getColumn() == 0) ? ISourceLocation.NO_COLUMN : sl.getColumn()), sl.getContext(), sourceFileName);
		return sLoc;
	}
================= fetch private static void addPointcuts(AsmManager model, String sourcefilename, Resolv 3be69a2^:weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java

private static void addPointcuts(AsmManager model, String sourcefilename, ResolvedType aspect,
			IProgramElement containingAspect, ResolvedMember[] pointcuts) {
		for (int i = 0; i < pointcuts.length; i++) {
			ResolvedMember pointcut = pointcuts[i];
			if (pointcut instanceof ResolvedPointcutDefinition) {
				ResolvedPointcutDefinition rpcd = (ResolvedPointcutDefinition) pointcut;
				Pointcut p = rpcd.getPointcut();
				ISourceLocation sLoc = (p == null ? null : p.getSourceLocation());
				if (sLoc == null) {
					sLoc = rpcd.getSourceLocation();
				}
				ISourceLocation pointcutLocation = createSourceLocation(sourcefilename, aspect, sLoc);
				ProgramElement pointcutElement = new ProgramElement(model, pointcut.getName(), IProgramElement.Kind.POINTCUT,
						pointcutLocation, pointcut.getModifiers(), NO_COMMENT, Collections.EMPTY_LIST);
				containingAspect.addChild(pointcutElement);
			}
		}
	}
================= fetch public static void addDeclareAnnotationMethodRelationship(ISourceLocation source 3be69a2^:weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java
/**
	 * Add a relationship for a matching declare annotation method or declare annotation constructor. Locating the method is a messy
	 * (for messy read 'fragile') bit of code that could break at any moment but it's working for my simple testcase.
	 */
public static void addDeclareAnnotationMethodRelationship(ISourceLocation sourceLocation, String affectedTypeName,
			ResolvedMember affectedMethod, AsmManager model) {
		if (model == null) {
			return;
		}

		String pkg = null;
		String type = affectedTypeName;
		int packageSeparator = affectedTypeName.lastIndexOf(".");
		if (packageSeparator != -1) {
			pkg = affectedTypeName.substring(0, packageSeparator);
			type = affectedTypeName.substring(packageSeparator + 1);
		}

		IHierarchy hierarchy = model.getHierarchy();

		IProgramElement typeElem = hierarchy.findElementForType(pkg, type);
		if (typeElem == null)
			return;

		StringBuffer parmString = new StringBuffer("(");
		UnresolvedType[] args = affectedMethod.getParameterTypes();
		// Type[] args = method.getArgumentTypes();
		for (int i = 0; i < args.length; i++) {
			String s = args[i].getName();// Utility.signatureToString(args[i].
			// getName()getSignature(), false);
			parmString.append(s);
			if ((i + 1) < args.length)
				parmString.append(",");
		}
		parmString.append(")");
		IProgramElement methodElem = null;

		if (affectedMethod.getName().startsWith("<init>")) {
			// its a ctor
			methodElem = hierarchy.findElementForSignature(typeElem, IProgramElement.Kind.CONSTRUCTOR, type + parmString);
			if (methodElem == null && args.length == 0)
				methodElem = typeElem; // assume default ctor
		} else {
			// its a method
			methodElem = hierarchy.findElementForSignature(typeElem, IProgramElement.Kind.METHOD, affectedMethod.getName()
					+ parmString);
		}

		if (methodElem == null)
			return;

		try {
			String targetHandle = methodElem.getHandleIdentifier();
			if (targetHandle == null)
				return;

			IProgramElement sourceNode = hierarchy.findElementForSourceLine(sourceLocation);
			String sourceHandle = sourceNode.getHandleIdentifier();
			if (sourceHandle == null)
				return;

			IRelationshipMap mapper = model.getRelationshipMap();
			IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATES, false, true);
			foreward.addTarget(targetHandle);

			IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATED_BY, false, true);
			back.addTarget(sourceHandle);
		} catch (Throwable t) { // I'm worried about that code above, this will
			// make sure we don't explode if it plays up
			t.printStackTrace(); // I know I know .. but I don't want to lose
			// it!
		}
	}
Progress : [#########-------------------------------] 23%================= fetch private void removeSingleNode(IProgramElement progElem) { 728ecb8^:asm/src/org/aspectj/asm/AsmManager.java
/**
	 * Removes a specified program element from the structure model. We go to the parent of the program element, ask for all its
	 * children and remove the node we want to delete from the list of children.
	 */
private void removeSingleNode(IProgramElement progElem) {
		if (progElem == null) {
			throw new IllegalStateException("AsmManager.removeNode(): programElement unexpectedly null");
		}
		boolean deleteOK = false;
		IProgramElement parent = progElem.getParent();
		List kids = parent.getChildren();
		for (int i = 0; i < kids.size(); i++) {
			if (kids.get(i).equals(progElem)) {
				kids.remove(i);
				deleteOK = true;
				break;
			}
		}
		if (!deleteOK) {
			throw new RuntimeException("Unable to delete the node from the model.  trying to delete node for handle "
					+ progElem.getHandleIdentifier());
		}
	}
================= fetch private static List genModifiers(int modifiers) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public static IProgramElement.Accessibility genAccessibility(int modifiers) {
		if ((modifiers & AccPublic) != 0)
			return IProgramElement.Accessibility.PUBLIC;
		if ((modifiers & AccPrivate) != 0)
			return IProgramElement.Accessibility.PRIVATE;
		if ((modifiers & AccProtected) != 0)
			return IProgramElement.Accessibility.PROTECTED;
		if ((modifiers & AccPrivileged) != 0)
			return IProgramElement.Accessibility.PRIVILEGED;
		else
			return IProgramElement.Accessibility.PACKAGE;
	}
================= fetch public ProgramElement(AsmManager asm, String name, Kind kind, List children) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

================= fetch public String getCorrespondingType(boolean getFullyQualifiedType) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public String getCorrespondingType(boolean getFullyQualifiedType) {
		String returnType = (String) kvpairs.get("returnType");
		if (returnType == null)
			returnType = "";
		if (getFullyQualifiedType) {
			return returnType;
		}
		int index = returnType.lastIndexOf(".");
		if (index != -1) {
			return returnType.substring(index);
		}
		return returnType;
	}
================= fetch public String getDeclaringType() { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public String getDeclaringType() {
		String dt = (String) kvpairs.get("declaringType");
		if (dt == null)
			return ""; // assumption that not having one means "" is at HtmlDecorator line 111
		return dt;
	}
================= fetch public String getFormalComment() { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public String getFormalComment() {
		return (String) kvpairs.get("formalComment");
		// return formalComment;
	}
================= fetch public String getPackageName() { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public String getPackageName() {
		if (kind == Kind.PACKAGE)
			return getName();
		if (getParent() == null) {
			return "";
		}
		return getParent().getPackageName();
	}
================= fetch public String toLongString() { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public String toLongString() {
		final StringBuffer buffer = new StringBuffer();
		HierarchyWalker walker = new HierarchyWalker() {
			private int depth = 0;
================= fetch public String toSignatureString(boolean getFullyQualifiedArgTypes) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public String toSignatureString(boolean getFullyQualifiedArgTypes) {
		StringBuffer sb = new StringBuffer();
		sb.append(name);

		List ptypes = getParameterTypes();
		if (ptypes != null && (!ptypes.isEmpty() || this.kind.equals(IProgramElement.Kind.METHOD))
				|| this.kind.equals(IProgramElement.Kind.CONSTRUCTOR) || this.kind.equals(IProgramElement.Kind.ADVICE)
				|| this.kind.equals(IProgramElement.Kind.POINTCUT) || this.kind.equals(IProgramElement.Kind.INTER_TYPE_METHOD)
				|| this.kind.equals(IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR)) {
			sb.append('(');
			for (Iterator it = ptypes.iterator(); it.hasNext();) {
				char[] arg = (char[]) it.next();
				if (getFullyQualifiedArgTypes) {
					sb.append(arg);
				} else {
					int index = CharOperation.lastIndexOf('.', arg);
					if (index != -1) {
						sb.append(CharOperation.subarray(arg, index + 1, arg.length));
					} else {
						sb.append(arg);
					}
				}
				if (it.hasNext())
					sb.append(",");
			}
			sb.append(')');
		}

		return sb.toString();
	}
================= fetch public void addChild(IProgramElement child) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public void addChild(IProgramElement child) {
		if (children == null || children == Collections.EMPTY_LIST)
			children = new ArrayList();
		children.add(child);
		child.setParent(this);
	}
================= fetch public void addChild(int position, IProgramElement child) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public void addChild(int position, IProgramElement child) {
		if (children == null || children == Collections.EMPTY_LIST)
			children = new ArrayList();
		children.add(position, child);
		child.setParent(this);
	}
================= fetch public void preProcess(IProgramElement node) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public String toLongString() {
		final StringBuffer buffer = new StringBuffer();
		HierarchyWalker walker = new HierarchyWalker() {
			private int depth = 0;

			public void preProcess(IProgramElement node) {
				for (int i = 0; i < depth; i++)
					buffer.append(' ');
				buffer.append(node.toString());
				buffer.append('\n');
				depth += 2;
			}
================= fetch public void setBytecodeName(String s) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public void setBytecodeName(String s) {
		if (kvpairs == Collections.EMPTY_MAP)
			kvpairs = new HashMap();
		kvpairs.put("bytecodeName", s);
	}
================= fetch public void setChildren(List children) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public void setChildren(List children) {
		this.children = children;
		if (children == null)
			return;
		for (Iterator it = children.iterator(); it.hasNext();) {
			((IProgramElement) it.next()).setParent(this);
		}
	}
================= fetch public void setCorrespondingType(String s) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public void setCorrespondingType(String s) {
		if (kvpairs == Collections.EMPTY_MAP)
			kvpairs = new HashMap();
		kvpairs.put("returnType", s);
		// this.returnType = s;
	}
================= fetch public void setDeclaringType(String t) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public void setDeclaringType(String t) {
		if (t != null && t.length() > 0) {
			if (kvpairs == Collections.EMPTY_MAP)
				kvpairs = new HashMap();
			kvpairs.put("declaringType", t);
		}
	}
================= fetch public void setDetails(String string) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public void setDetails(String string) {
		if (kvpairs == Collections.EMPTY_MAP)
			kvpairs = new HashMap();
		kvpairs.put("details", string);
	}
================= fetch public void setExtraInfo(ExtraInformation info) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public void setExtraInfo(ExtraInformation info) {
		if (kvpairs == Collections.EMPTY_MAP)
			kvpairs = new HashMap();
		kvpairs.put("ExtraInformation", info);
	}
================= fetch public void setFormalComment(String txt) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public void setFormalComment(String txt) {
		if (txt != null && txt.length() > 0) {
			if (kvpairs == Collections.EMPTY_MAP)
				kvpairs = new HashMap();
			kvpairs.put("formalComment", txt);
		}
	}
================= fetch public void setImplementor(boolean value) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public void setImplementor(boolean value) {
		if (kvpairs == Collections.EMPTY_MAP)
			kvpairs = new HashMap();
		if (value)
			kvpairs.put("isImplementor", "true");
		else
			kvpairs.remove("isImplementor");
		// this.implementor = value;
	}
================= fetch public void setMessage(IMessage message) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public void setMessage(IMessage message) {
		if (kvpairs == Collections.EMPTY_MAP)
			kvpairs = new HashMap();
		kvpairs.put("message", message);
		// this.message = message;
	}
================= fetch public void setOverrider(boolean value) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public void setOverrider(boolean value) {
		if (kvpairs == Collections.EMPTY_MAP)
			kvpairs = new HashMap();
		if (value)
			kvpairs.put("isOverrider", "true");
		else
			kvpairs.remove("isOverrider");
		// this.overrider = value;
	}
================= fetch public void setParameterNames(List list) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public void setParameterNames(List list) {
		if (list == null || list.size() == 0)
			return;
		if (kvpairs == Collections.EMPTY_MAP)
			kvpairs = new HashMap();
		kvpairs.put("parameterNames", list);
		// parameterNames = list;
	}
================= fetch public void setParentTypes(List ps) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public void setParentTypes(List ps) {
		if (kvpairs == Collections.EMPTY_MAP)
			kvpairs = new HashMap();
		kvpairs.put("parentTypes", ps);
	}
================= fetch public void setRelations(List relations) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public void setRelations(List relations) {
		if (relations.size() > 0) {
			if (kvpairs == Collections.EMPTY_MAP)
				kvpairs = new HashMap();
			kvpairs.put("relations", relations);
			// this.relations = relations;
		}
	}
================= fetch public void setRunnable(boolean value) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public void setRunnable(boolean value) {
		if (kvpairs == Collections.EMPTY_MAP)
			kvpairs = new HashMap();
		if (value)
			kvpairs.put("isRunnable", "true");
		else
			kvpairs.remove("isRunnable");
		// this.runnable = value;
	}
================= fetch public void setSourceSignature(String string) { a502da8^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public void setSourceSignature(String string) {
		if (kvpairs == Collections.EMPTY_MAP)
			kvpairs = new HashMap();
		// System.err.println(name+" SourceSig=>"+string);
		kvpairs.put("sourceSignature", string);
		// sourceSignature = string;
	}
================= fetch private static void appendNLabel(StringBuffer sink, String label, int numItems) b21eb05^:org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java
/**
	 * append nothing if numItems is 0, numItems + label + (numItems > 1? "s" : "") otherwise, prefixing with " " if sink has
	 * content
	 */
private static void appendNLabel(StringBuffer sink, String label, int numItems) {
		if (0 == numItems) {
			return;
		}
		if (0 < sink.length()) {
			sink.append(", ");
		}
		sink.append(numItems + " ");
		if (!LangUtil.isEmpty(label)) {
			sink.append(label);
		}
		if (1 < numItems) {
			sink.append("s");
		}
	}
================= fetch public void run(String[] args, IMessageHolder holder) { b21eb05^:org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java
/**
	 * Run without using System.exit(..), putting all messages in holder:
	 * <ul>
	 * <li>ERROR: compiler error</li>
	 * <li>WARNING: compiler warning</li>
	 * <li>FAIL: command error (bad arguments, exception thrown)</li>
	 * </ul>
	 * This handles incremental behavior:
	 * <ul>
	 * <li>If args include "-incremental", repeat for every input char until 'q' is entered.
	 * <li>
	 * <li>If args include "-incrementalTagFile {file}", repeat every time we detect that {file} modification time has changed.</li>
	 * <li>Either way, list files recompiled each time if args includes "-verbose".</li>
	 * <li>Exit when the commmand/compiler throws any Throwable.</li>
	 * </ul>
	 * When complete, this contains all the messages of the final run of the command and/or any FAIL messages produced in running
	 * the command, including any Throwable thrown by the command itself.
	 * 
	 * @param args the String[] command line for the compiler
	 * @param holder the MessageHandler sink for messages.
	 */
public void run(String[] args, IMessageHolder holder) {

		PrintStream logStream = null;
		FileOutputStream fos = null;
		String logFileName = parmInArgs("-log", args);
		if (null != logFileName) {
			File logFile = new File(logFileName);
			try {
				logFile.createNewFile();
				fos = new FileOutputStream(logFileName, true);
				logStream = new PrintStream(fos, true);
			} catch (Exception e) {
				fail(holder, "Couldn't open log file: " + logFileName, e);
			}
			Date now = new Date();
			logStream.println(now.toString());
			if (flagInArgs("-verbose", args)) {
				ourHandler.setInterceptor(new LogModeMessagePrinter(true, logStream));
			} else {
				ourHandler.ignore(IMessage.INFO);
				ourHandler.setInterceptor(new LogModeMessagePrinter(false, logStream));
			}
			holder = ourHandler;
		}

		if (LangUtil.isEmpty(args)) {
			args = new String[] { "-?" };
		} else if (controller.running()) {
			fail(holder, "already running with controller: " + controller, null);
			return;
		}
		args = controller.init(args, holder);
		if (0 < holder.numMessages(IMessage.ERROR, true)) {
			return;
		}
		ICommand command = ReflectionFactory.makeCommand(commandName, holder);
		if (0 < holder.numMessages(IMessage.ERROR, true)) {
			return;
		}
		try {
			outer: while (true) {
				boolean passed = command.runCommand(args, holder);
				if (report(passed, holder) && controller.incremental()) {
					while (controller.doRepeatCommand(command)) {
						holder.clearMessages();
						if (controller.buildFresh()) {
							continue outer;
						} else {
							passed = command.repeatCommand(holder);
						}
						if (!report(passed, holder)) {
							break;
						}
					}
				}
				break;
			}
		} catch (AbortException ae) {
			if (ae.isSilent()) {
				quit();
			} else {
				IMessage message = ae.getIMessage();
				Throwable thrown = ae.getThrown();
				if (null == thrown) { // toss AbortException wrapper
					if (null != message) {
						holder.handleMessage(message);
					} else {
						fail(holder, "abort without message", ae);
					}
				} else if (null == message) {
					fail(holder, "aborted", thrown);
				} else {
					String mssg = MessageUtil.MESSAGE_MOST.renderToString(message);
					fail(holder, mssg, thrown);
				}
			}
		} catch (Throwable t) {
			fail(holder, "unexpected exception", t);
		} finally {
			if (logStream != null) {
				logStream.close();
				logStream = null;
			}
			if (fos != null) {
				try {
					fos.close();
				} catch (IOException e) {
					fail(holder, "unexpected exception", e);
				}
				fos = null;
			}
		}
	}
================= fetch void setController(CommandController controller) { b21eb05^:org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java
// for unit testing...
void setController(CommandController controller) {
		this.controller = controller;
	}
================= fetch public String getAnnotationDefaultValue() { 94d0a4e^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseResolvedMember.java

private Annotation[] getEclipseAnnotations() {
		TypeDeclaration tDecl = getTypeDeclaration();
		if (tDecl != null) {// if the code is broken then tDecl may be null
			if (realBinding instanceof MethodBinding) {
				MethodBinding methodBinding = (MethodBinding) realBinding;
				AbstractMethodDeclaration methodDecl = tDecl.declarationOf(methodBinding);
				if (methodDecl == null) {
					// pr284862
					// bindings may have been trashed by InterTypeMemberFinder.addInterTypeMethod() - and so we need to take
					// a better look. Really this EclipseResolvedMember is broken...

					// Grab the set of bindings with matching selector
					MethodBinding[] mb = ((MethodBinding) realBinding).declaringClass.getMethods(methodBinding.selector);
					if (mb!=null) {
					for (int m = 0, max = mb.length; m < max; m++) {
						MethodBinding candidate = mb[m];
						if (candidate instanceof InterTypeMethodBinding) {
							if (InterTypeMemberFinder.matches(mb[m], methodBinding)) {
								InterTypeMethodBinding intertypeMethodBinding = (InterTypeMethodBinding) candidate;
								Annotation[] annos = intertypeMethodBinding.sourceMethod.annotations;
								return annos;
							}
						}
					}
					}
					return null; // give up! kind of assuming here that the code has other problems (and they will be reported)
				}
				return methodDecl.annotations;
			} else if (realBinding instanceof FieldBinding) {
				FieldDeclaration fieldDecl = tDecl.declarationOf((FieldBinding) realBinding);
				return fieldDecl.annotations;
			}
		}
		return null;
	}
================= fetch private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, Collection 4b43dc6^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java

private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, Collection typeMungers, Collection declareParents,
			Collection declareAnnotationOnTypes, boolean skipInners) {

		ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.WEAVING_INTERTYPE_DECLARATIONS,
				sourceType.sourceName);

		ResolvedType onType = factory.fromEclipse(sourceType);

		// AMC we shouldn't need this when generic sigs are fixed??
		if (onType.isRawType()) {
			onType = onType.getGenericType();
		}

		WeaverStateInfo info = onType.getWeaverState();

		// this test isnt quite right - there will be a case where we fail to
		// flag a problem
		// with a 'dangerous interface' because the type is reweavable when we
		// should have
		// because the type wasn't going to be rewoven... if that happens, we
		// should perhaps
		// move this test and dangerous interface processing to the end of this
		// method and
		// make it conditional on whether any of the typeMungers passed into
		// here actually
		// matched this type.
		if (info != null && !info.isOldStyle() && !info.isReweavable()) {
			processTypeMungersFromExistingWeaverState(sourceType, onType);
			CompilationAndWeavingContext.leavingPhase(tok);
			return;
		}

		// Check if the type we are looking at is the topMostImplementor of a
		// dangerous interface -
		// report a problem if it is.
		for (Iterator i = dangerousInterfaces.entrySet().iterator(); i.hasNext();) {
			Map.Entry entry = (Map.Entry) i.next();
			ResolvedType interfaceType = (ResolvedType) entry.getKey();
			if (onType.isTopmostImplementor(interfaceType)) {
				factory.showMessage(IMessage.ERROR, onType + ": " + entry.getValue(), onType.getSourceLocation(), null);
			}
		}

		boolean needOldStyleWarning = (info != null && info.isOldStyle());

		onType.clearInterTypeMungers();

		// FIXME asc perf Could optimize here, after processing the expected set
		// of types we may bring
		// binary types that are not exposed to the weaver, there is no need to
		// attempt declare parents
		// or declare annotation really - unless we want to report the
		// not-exposed to weaver
		// messages...

		List decpToRepeat = new ArrayList();
		List decaToRepeat = new ArrayList();
		boolean anyNewParents = false;
		boolean anyNewAnnotations = false;

		// first pass
		// try and apply all decps - if they match, then great. If they don't
		// then
		// check if they are starred-annotation patterns. If they are not
		// starred
		// annotation patterns then they might match later...remember that...
		for (Iterator i = declareParents.iterator(); i.hasNext();) {
			DeclareParents decp = (DeclareParents) i.next();
			if (!decp.isMixin()) {
				boolean didSomething = doDeclareParents(decp, sourceType);
				if (didSomething) {
					anyNewParents = true;
				} else {
					if (!decp.getChild().isStarAnnotation()) {
						decpToRepeat.add(decp);
					}
				}
			}
		}

		for (Iterator i = declareAnnotationOnTypes.iterator(); i.hasNext();) {
			DeclareAnnotation deca = (DeclareAnnotation) i.next();
			boolean didSomething = doDeclareAnnotations(deca, sourceType, true);
			if (didSomething) {
				anyNewAnnotations = true;
			} else {
				if (!deca.getTypePattern().isStar()) {
					decaToRepeat.add(deca);
				}
			}
		}

		// now lets loop over and over until we have done all we can
		while ((anyNewAnnotations || anyNewParents) && (!decpToRepeat.isEmpty() || !decaToRepeat.isEmpty())) {
			anyNewParents = anyNewAnnotations = false;
			List forRemoval = new ArrayList();
			for (Iterator i = decpToRepeat.iterator(); i.hasNext();) {
				DeclareParents decp = (DeclareParents) i.next();
				boolean didSomething = doDeclareParents(decp, sourceType);
				if (didSomething) {
					anyNewParents = true;
					forRemoval.add(decp);
				}
			}
			decpToRepeat.removeAll(forRemoval);

			forRemoval.clear();
			for (Iterator i = declareAnnotationOnTypes.iterator(); i.hasNext();) {
				DeclareAnnotation deca = (DeclareAnnotation) i.next();
				boolean didSomething = doDeclareAnnotations(deca, sourceType, false);
				if (didSomething) {
					anyNewAnnotations = true;
					forRemoval.add(deca);
				}
			}
			decaToRepeat.removeAll(forRemoval);
		}

		for (Iterator i = typeMungers.iterator(); i.hasNext();) {
			EclipseTypeMunger munger = (EclipseTypeMunger) i.next();
			if (munger.matches(onType)) {
				if (needOldStyleWarning) {
					factory.showMessage(IMessage.WARNING, "The class for " + onType
							+ " should be recompiled with ajc-1.1.1 for best results", onType.getSourceLocation(), null);
					needOldStyleWarning = false;
				}
				onType.addInterTypeMunger(munger, true);
			}
		}

		onType.checkInterTypeMungers();
		for (Iterator i = onType.getInterTypeMungers().iterator(); i.hasNext();) {
			EclipseTypeMunger munger = (EclipseTypeMunger) i.next();
			munger.munge(sourceType, onType);
		}

		// Call if you would like to do source weaving of declare
		// @method/@constructor
		// at source time... no need to do this as it can't impact anything, but
		// left here for
		// future generations to enjoy. Method source is commented out at the
		// end of this module
		// doDeclareAnnotationOnMethods();

		// Call if you would like to do source weaving of declare @field
		// at source time... no need to do this as it can't impact anything, but
		// left here for
		// future generations to enjoy. Method source is commented out at the
		// end of this module
		// doDeclareAnnotationOnFields();

		if (skipInners) {
			CompilationAndWeavingContext.leavingPhase(tok);
			return;
		}

		ReferenceBinding[] memberTypes = sourceType.memberTypes;
		for (int i = 0, length = memberTypes.length; i < length; i++) {
			if (memberTypes[i] instanceof SourceTypeBinding) {
				weaveInterTypeDeclarations((SourceTypeBinding) memberTypes[i], typeMungers, declareParents,
						declareAnnotationOnTypes, false);
			}
		}
		CompilationAndWeavingContext.leavingPhase(tok);
	}
Progress : [#########-------------------------------] 24%================= fetch private IProgramElement findClassInNodes(Collection nodes, String name, String t 749078d^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java

private IProgramElement findClassInNodes(Collection nodes, String name, String typeName) {
		String baseName;
		String innerName;
		int dollar = name.indexOf('$');
		if (dollar == -1) {
			baseName = name;
			innerName = null;
		} else {
			baseName = name.substring(0, dollar);
			innerName = name.substring(dollar + 1);
		}

		for (Iterator j = nodes.iterator(); j.hasNext();) {
			IProgramElement classNode = (IProgramElement) j.next();
			if (baseName.equals(classNode.getName())) {
				if (innerName == null)
					return classNode;
				else
					return findClassInNodes(classNode.getChildren(), innerName, typeName);
			} else if (name.equals(classNode.getName())) {
				return classNode;
			} else if (typeName.equals(classNode.getBytecodeSignature())) {
				return classNode;
			} else if (classNode.getChildren() != null && !classNode.getChildren().isEmpty()) {
				IProgramElement node = findClassInNodes(classNode.getChildren(), name, typeName);
				if (node != null) {
					return node;
				}
			}
		}
		return null;
	}
================= fetch private IProgramElement findElementForHandle(IProgramElement parent, String hand 749078d^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java

private IProgramElement findElementForHandle(IProgramElement parent, String handle) {
		for (Iterator it = parent.getChildren().iterator(); it.hasNext();) {
			IProgramElement node = (IProgramElement) it.next();
			String nodeHid = node.getHandleIdentifier();
			if (handle.equals(nodeHid)) {
				return node;
			} else {
				if (handle.startsWith(nodeHid)) {
					// it must be down here if it is anywhere
					IProgramElement childSearch = findElementForHandle(node, handle);
					if (childSearch != null)
						return childSearch;
				}
			}
		}
		return null;
	}
================= fetch private boolean hasMoreSpecificChild(IProgramElement node, String sourceFilePath 749078d^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java

private boolean hasMoreSpecificChild(IProgramElement node, String sourceFilePath, int lineNumber, int offSet) {
		for (Iterator it = node.getChildren().iterator(); it.hasNext();) {
			IProgramElement child = (IProgramElement) it.next();
			if (matches(child, sourceFilePath, lineNumber, offSet))
				return true;
		}
		return false;
	}
================= fetch public IProgramElement findElementForHandleOrCreate(String handle, boolean creat 749078d^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java
// findElementForHandle() to mirror behaviour before pr141730
public IProgramElement findElementForHandleOrCreate(String handle, boolean create) {
		// try the cache first...
		IProgramElement ipe = (IProgramElement) handleMap.get(handle);
		if (ipe != null) {
			return ipe;
		}

		ipe = findElementForHandle(root, handle);
		if (ipe == null && create) {
			ipe = createFileStructureNode(getFilename(handle));
		}
		if (ipe != null) {
			cache(handle, ipe);
		}
		return ipe;
	}
================= fetch public IProgramElement findElementForLabel(IProgramElement parent, IProgramEleme 749078d^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java

public IProgramElement findElementForLabel(IProgramElement parent, IProgramElement.Kind kind, String label) {

		for (Iterator it = parent.getChildren().iterator(); it.hasNext();) {
			IProgramElement node = (IProgramElement) it.next();
			if (node.getKind() == kind && label.equals(node.toLabelString())) {
				return node;
			} else {
				IProgramElement childSearch = findElementForLabel(node, kind, label);
				if (childSearch != null)
					return childSearch;
			}
		}
		return null;
	}
================= fetch public IProgramElement findElementForSignature(IProgramElement parent, IProgramE 749078d^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java
/**
	 * Returns the first match
	 * 
	 * @param parent
	 * @param kind not null
	 * @return null if not found
	 */
public IProgramElement findElementForSignature(IProgramElement parent, IProgramElement.Kind kind, String signature) {
		for (Iterator it = parent.getChildren().iterator(); it.hasNext();) {
			IProgramElement node = (IProgramElement) it.next();
			if (node.getKind() == kind && signature.equals(node.toSignatureString())) {
				return node;
			} else {
				IProgramElement childSearch = findElementForSignature(node, kind, signature);
				if (childSearch != null)
					return childSearch;
			}
		}
		return null;
	}
================= fetch public IProgramElement findElementForType(String packageName, String typeName) { 749078d^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java
/**
	 * Look for any package nodes matching the specified package name. There may be multiple in the case where the types within a
	 * package are split across source folders.
	 * 
	 * @param packagename the packagename being searched for
	 * @return a list of package nodes that match that name
	 */
public List/* IProgramElement */findMatchingPackages(String packagename) {
		List children = root.getChildren();
		// The children might be source folders or packages
		if (children.size() == 0) {
			return Collections.EMPTY_LIST;
		}
		if (((IProgramElement) children.get(0)).getKind() == IProgramElement.Kind.SOURCE_FOLDER) {
			String searchPackageName = (packagename == null ? "" : packagename); // default package means match on ""
			// dealing with source folders
			List matchingPackageNodes = new ArrayList();
			for (Iterator iterator = children.iterator(); iterator.hasNext();) {
				IProgramElement sourceFolder = (IProgramElement) iterator.next();
				List possiblePackageNodes = sourceFolder.getChildren();
				for (Iterator iterator2 = possiblePackageNodes.iterator(); iterator2.hasNext();) {
					IProgramElement possiblePackageNode = (IProgramElement) iterator2.next();
					if (possiblePackageNode.getKind() == IProgramElement.Kind.PACKAGE) {
						if (possiblePackageNode.getName().equals(searchPackageName)) {
							matchingPackageNodes.add(possiblePackageNode);
						}
					}
				}
			}
			// 'binaries' will be checked automatically by the code above as it is represented as a SOURCE_FOLDER
			return matchingPackageNodes;
		} else {
			// dealing directly with packages below the root, no source folders. Therefore at most one
			// thing to return in the list
			if (packagename == null) {
				// default package
				List result = new ArrayList();
				result.add(root);
				return result;
			}
			List result = new ArrayList();
			for (Iterator iterator = children.iterator(); iterator.hasNext();) {
				IProgramElement possiblePackage = (IProgramElement) iterator.next();
				if (possiblePackage.getKind() == IProgramElement.Kind.PACKAGE && possiblePackage.getName().equals(packagename)) {
					result.add(possiblePackage);
				}
				if (possiblePackage.getKind() == IProgramElement.Kind.SOURCE_FOLDER) { // might be 'binaries'
					if (possiblePackage.getName().equals("binaries")) {
						for (Iterator iter2 = possiblePackage.getChildren().iterator(); iter2.hasNext();) {
							IProgramElement possiblePackage2 = (IProgramElement) iter2.next();
							if (possiblePackage2.getKind() == IProgramElement.Kind.PACKAGE
									&& possiblePackage2.getName().equals(packagename)) {
								result.add(possiblePackage2);
								break; // ok to break here, can't be another entry under binaries
							}
						}
					}
				}
			}
			if (result.isEmpty()) {
				return Collections.EMPTY_LIST;
			} else {
				return result;
			}
		}
	}
================= fetch public void updateHandleMap(Set deletedFiles) { 749078d^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java
// TODO rename this method ... it does more than just the handle map
public void updateHandleMap(Set deletedFiles) {
		// Only delete the entries we need to from the handle map - for performance reasons
		List forRemoval = new ArrayList();
		Set k = handleMap.keySet();
		for (Iterator iter = k.iterator(); iter.hasNext();) {
			String handle = (String) iter.next();
			IProgramElement ipe = (IProgramElement) handleMap.get(handle);
			if (deletedFiles.contains(getCanonicalFilePath(ipe)))
				forRemoval.add(handle);
		}
		for (Iterator iter = forRemoval.iterator(); iter.hasNext();) {
			String handle = (String) iter.next();
			handleMap.remove(handle);
		}
		forRemoval.clear();
		k = typeMap.keySet();
		for (Iterator iter = k.iterator(); iter.hasNext();) {
			String typeName = (String) iter.next();
			IProgramElement ipe = (IProgramElement) typeMap.get(typeName);
			if (deletedFiles.contains(getCanonicalFilePath(ipe)))
				forRemoval.add(typeName);
		}
		for (Iterator iter = forRemoval.iterator(); iter.hasNext();) {
			String typeName = (String) iter.next();
			typeMap.remove(typeName);
		}
		forRemoval.clear();
		k = fileMap.keySet();
		for (Iterator iter = k.iterator(); iter.hasNext();) {
			String filePath = (String) iter.next();
			IProgramElement ipe = (IProgramElement) fileMap.get(filePath);
			if (deletedFiles.contains(getCanonicalFilePath(ipe)))
				forRemoval.add(filePath);
		}
		for (Iterator iter = forRemoval.iterator(); iter.hasNext();) {
			String filePath = (String) iter.next();
			fileMap.remove(filePath);
		}
	}
================= fetch protected boolean accept(String className, byte[] bytes) { a968890^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
	 * Determine whether a type should be accepted for weaving, by checking it against any includes/excludes.
	 * 
	 * @param className the name of the type to possibly accept
	 * @param bytes the bytecode for the type (in case we need to look inside, eg. annotations)
	 * @return true if it should be accepted for weaving
	 */
@Override
	protected boolean accept(String className, byte[] bytes) {

		if (!hasExcludes && !hasIncludes) {
			return true;
		}

		// still try to avoid ResolvedType if we have simple patterns
		String fastClassName = className.replace('/', '.').replace('$', '.');
		for (String excludeStartsWithString : excludeStartsWith) {
			if (fastClassName.startsWith(excludeStartsWithString)) {
				return false;
			}
		}

		// Fast exclusion of patterns like: "*..*CGLIB*"
		if (!excludeStarDotDotStar.isEmpty()) {
			for (String namePiece : excludeStarDotDotStar) {
				int index = fastClassName.lastIndexOf('.');
				if (fastClassName.indexOf(namePiece, index + 1) != -1) {
					return false;
				}
			}
		}

		if (!excludeEndsWith.isEmpty()) {
			for (String lastPiece : excludeEndsWith) {
				if (fastClassName.endsWith(lastPiece)) {
					return false;
				}
			}
		}

		// Fast exclusion of exact names
		if (!excludeExactName.isEmpty()) {
			for (String name : excludeExactName) {
				if (fastClassName.equals(name)) {
					return false;
				}
			}
		}

		if (!excludeSpecial.isEmpty()) {
			for (String[] entry : excludeSpecial) {
				String excludeThese = entry[0];
				String exceptThese = entry[1];
				if (fastClassName.startsWith(excludeThese) && !fastClassName.startsWith(exceptThese)) {
					return false;
				}
			}
		}

		/*
		 * Bug 120363 If we have an exclude pattern that cannot be matched using "starts with" then we cannot fast accept
		 */
		boolean didSomeIncludeMatching = false;
		if (excludeTypePattern.isEmpty()) {
			if (includeStar) {
				return true;
			}
			if (!includeExactName.isEmpty()) {
				didSomeIncludeMatching = true;
				for (String exactname : includeExactName) {
					if (fastClassName.equals(exactname)) {
						return true;
					}
				}
			}
			boolean fastAccept = false;// defaults to false if no fast include
			for (int i = 0; i < m_includeStartsWith.size(); i++) {
				didSomeIncludeMatching = true;
				fastAccept = fastClassName.startsWith(m_includeStartsWith.get(i));
				if (fastAccept) {
					return true;
				}
			}
			// We may have processed all patterns now... check that and return
			if (includeTypePattern.isEmpty()) {
				return !didSomeIncludeMatching;
			}
		}

		boolean accept;
		try {
			ensureDelegateInitialized(className, bytes);

			ResolvedType classInfo = delegateForCurrentClass.getResolvedTypeX();

			// exclude are "AND"ed
			for (TypePattern typePattern : excludeTypePattern) {
				if (typePattern.matchesStatically(classInfo)) {
					// exclude match - skip
					return false;
				}
			}
			// include are "OR"ed
			accept = !didSomeIncludeMatching; // only true if no includes at all
			for (TypePattern typePattern : includeTypePattern) {
				accept = typePattern.matchesStatically(classInfo);
				if (accept) {
					break;
				}
				// goes on if this include did not match ("OR"ed)
			}
		} finally {
			this.bcelWorld.demote();
		}
		return accept;
	}
================= fetch private void raiseCantFindType(String key) { a23c7e4^:org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java

private void raiseCantFindType(String key) {
		if (issuedCantFindTypeError)
			return;
		String message = WeaverMessages.format(key, getName());
		message += "\n" + CompilationAndWeavingContext.getCurrentContext();
		world.getLint().cantFindType.signal(message, null);
		// MessageUtil.error(world.getMessageHandler(),message);
		issuedCantFindTypeError = true;
	}
================= fetch private void raiseCantFindType(String key, String insert) { a23c7e4^:org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java

private void raiseCantFindType(String key, String insert) {
		if (issuedCantFindTypeError)
			return;
		String message = WeaverMessages.format(key, getName(), insert);
		message += "\n" + CompilationAndWeavingContext.getCurrentContext();
		world.getLint().cantFindType.signal(message, null);
		// MessageUtil.error(world.getMessageHandler(),message);
		issuedCantFindTypeError = true;
	}
================= fetch public List getInterTypeMungers() { a23c7e4^:org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java

public List getInterTypeMungers() {
		return Collections.EMPTY_LIST;
	}
================= fetch public List getInterTypeMungersIncludingSupers() { a23c7e4^:org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java

public List getInterTypeMungersIncludingSupers() {
		return Collections.EMPTY_LIST;
	}
================= fetch public List getInterTypeParentMungers() { a23c7e4^:org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java

public List getInterTypeParentMungers() {
		return Collections.EMPTY_LIST;
	}
================= fetch public List getInterTypeParentMungersIncludingSupers() { a23c7e4^:org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java

public List getInterTypeParentMungersIncludingSupers() {
		return Collections.EMPTY_LIST;
	}
================= fetch public MissingResolvedTypeWithKnownSignature(String signature, String signatureE a23c7e4^:org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java
/*
	 * (non-Javadoc)
	 * 
	 * @see org.aspectj.weaver.ResolvedType#getDeclaredPointcuts()
	 */
public ResolvedMember[] getDeclaredPointcuts() {
		raiseCantFindType(WeaverMessages.CANT_FIND_TYPE_POINTCUTS);
		return NO_MEMBERS;
	}
================= fetch public MissingResolvedTypeWithKnownSignature(String signature, World world) { a23c7e4^:org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java

================= fetch public ResolvedType getSuperclass() { a23c7e4^:org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java
/*
	 * (non-Javadoc)
	 * 
	 * @see org.aspectj.weaver.ResolvedType#getSuperclass()
	 */
public ResolvedType getSuperclass() {
		raiseCantFindType(WeaverMessages.CANT_FIND_TYPE_SUPERCLASS);
		return ResolvedType.MISSING;
	}
================= fetch public boolean hasAnnotation(UnresolvedType ofType) { a23c7e4^:org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java
/*
	 * (non-Javadoc)
	 * 
	 * @see org.aspectj.weaver.AnnotatedElement#hasAnnotation(org.aspectj.weaver.UnresolvedType)
	 */
public boolean hasAnnotation(UnresolvedType ofType) {
		raiseCantFindType(WeaverMessages.CANT_FIND_TYPE_ANNOTATION);
		return false;
	}
================= fetch public boolean isAssignableFrom(ResolvedType other) { a23c7e4^:org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java
/*
	 * (non-Javadoc)
	 * 
	 * @see org.aspectj.weaver.ResolvedType#isAssignableFrom(org.aspectj.weaver.ResolvedType)
	 */
boolean isAssignableFrom(ResolvedType other) {
		raiseCantFindType(WeaverMessages.CANT_FIND_TYPE_ASSIGNABLE, other.getName());
		return false;
	}
================= fetch public boolean isAssignableFrom(ResolvedType other, boolean allowMissing) { a23c7e4^:org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java

public boolean isAssignableFrom(ResolvedType other, boolean allowMissing) {
		if (allowMissing)
			return false;
		else
			return isAssignableFrom(other);
	}
================= fetch public int getModifiers() { a23c7e4^:org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java
/*
	 * (non-Javadoc)
	 * 
	 * @see org.aspectj.weaver.ResolvedType#getModifiers()
	 */
public int getModifiers() {
		raiseCantFindType(WeaverMessages.CANT_FIND_TYPE_MODIFIERS);
		return 0;
	}
================= fetch public void raiseWarningOnJoinPointSignature(String signature) { a23c7e4^:org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java

public void raiseWarningOnJoinPointSignature(String signature) {
		if (issuedJoinPointWarning)
			return;
		String message = WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_JOINPOINT, getName(), signature);
		message += "\n" + CompilationAndWeavingContext.getCurrentContext();
		world.getLint().cantFindTypeAffectingJoinPointMatch.signal(message, null);
		// MessageUtil.warn(world.getMessageHandler(),message);
		issuedJoinPointWarning = true;
	}
================= fetch public void raiseWarningOnMissingInterfaceWhilstFindingMethods() { a23c7e4^:org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java

public void raiseWarningOnMissingInterfaceWhilstFindingMethods() {
		if (issuedMissingInterfaceWarning)
			return;
		String message = WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_INTERFACE_METHODS, getName(), signature);
		message += "\n" + CompilationAndWeavingContext.getCurrentContext();
		world.getLint().cantFindTypeAffectingJoinPointMatch.signal(message, null);
		// MessageUtil.warn(world.getMessageHandler(),message);
		issuedMissingInterfaceWarning = true;
	}
================= fetch public void tidy() { a23c7e4^:org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java

public void tidy() {
			}
Progress : [##########------------------------------] 25%================= fetch private static String lastbit(String fqname) { 35a9649^:weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java
/**
	 * Extract the method argument names. First we try the debug info attached to the method (the LocalVariableTable) - if we cannot
	 * find that we look to use the argNames value that may have been supplied on the associated annotation. If that fails we just
	 * don't know and return an empty string.
	 * 
	 * @param method
	 * @param argNamesFromAnnotation
	 * @param methodStruct
	 * @return method argument names
	 */
private static String[] getMethodArgumentNames(Method method, String argNamesFromAnnotation,
			AjAttributeMethodStruct methodStruct) {
		if (method.getArgumentTypes().length == 0) {
			return EMPTY_STRINGS;
		}

		final int startAtStackIndex = method.isStatic() ? 0 : 1;
		final List<MethodArgument> arguments = new ArrayList<MethodArgument>();
		LocalVariableTable lt = method.getLocalVariableTable();
		if (lt != null) {
			for (int j = 0; j < lt.getLocalVariableTable().length; j++) {
				LocalVariable localVariable = lt.getLocalVariableTable()[j];
				if (localVariable.getStartPC() == 0) {
					if (localVariable.getIndex() >= startAtStackIndex) {
						arguments.add(new MethodArgument(localVariable.getName(), localVariable.getIndex()));
					}
				}
			}
		} else {
			// No debug info, do we have an annotation value we can rely on?
			if (argNamesFromAnnotation != null) {
				StringTokenizer st = new StringTokenizer(argNamesFromAnnotation, " ,");
				List<String> args = new ArrayList<String>();
				while (st.hasMoreTokens()) {
					args.add(st.nextToken());
				}
				if (args.size() != method.getArgumentTypes().length) {
					StringBuffer shortString = new StringBuffer().append(lastbit(method.getReturnType().toString())).append(" ")
							.append(method.getName());
					if (method.getArgumentTypes().length > 0) {
						shortString.append("(");
						for (int i = 0; i < method.getArgumentTypes().length; i++) {
							shortString.append(lastbit(method.getArgumentTypes()[i].toString()));
							if ((i + 1) < method.getArgumentTypes().length) {
								shortString.append(",");
							}

						}
						shortString.append(")");
					}
					reportError("argNames annotation value does not specify the right number of argument names for the method '"
							+ shortString.toString() + "'", methodStruct);
					return EMPTY_STRINGS;
				}
				return args.toArray(new String[] {});
			}
		}

		if (arguments.size() != method.getArgumentTypes().length) {
			return EMPTY_STRINGS;
		}

		// sort by index
		Collections.sort(arguments, new Comparator() {
================= fetch protected Class defineClass(String name, byte[] b, CodeSource cs) throws IOExcep 4d200d1^:weaver/src/org/aspectj/weaver/bcel/ExtensibleURLClassLoader.java

protected byte[] getBytes (String name) throws IOException {
		byte[] b = null;
		ClassPathManager.ClassFile classFile = classPath.find(UnresolvedType.forName(name));
		if (classFile != null) {
			b = FileUtil.readAsByteArray(classFile.getInputStream());
		}
		return b;
	}
================= fetch private JavaClass lookupJavaClass(ClassPathManager classPath, String name) { 67ffda8^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java

private JavaClass lookupJavaClass(ClassPathManager classPath, String name) {
		if (classPath == null) {
			try {
				ensureRepositorySetup();
				JavaClass jc = delegate.loadClass(name);
				if (trace.isTraceEnabled())
					trace.event("lookupJavaClass", this, new Object[] { name, jc });
				return jc;
			} catch (ClassNotFoundException e) {
				if (trace.isTraceEnabled())
					trace.error("Unable to find class '" + name + "' in repository", e);
				return null;
			}
		}

		try {
			ClassPathManager.ClassFile file = classPath.find(UnresolvedType.forName(name));
			if (file == null)
				return null;

			ClassParser parser = new ClassParser(file.getInputStream(), file.getPath());

			JavaClass jc = parser.parse();
			file.close();
			return jc;
		} catch (IOException ioe) {
			return null;
		}
	}
================= fetch private static boolean addIfNotEmpty(String input, StringBuffer sink, String del b29f839^:util/src/org/aspectj/util/LangUtil.java
/**
	 * @param input ignored if null
	 * @param sink the StringBuffer to add input to - return false if null
	 * @param delimiter the String to append to input when added - ignored if
	 *            empty
	 * @return true if input + delimiter added to sink
	 */
private static boolean addIfNotEmpty(String input, StringBuffer sink, String delimiter) {
		if (LangUtil.isEmpty(input) || (null == sink)) {
			return false;
		}
		sink.append(input);
		if (!LangUtil.isEmpty(delimiter)) {
			sink.append(delimiter);
		}
		return true;
	}
================= fetch protected void doCompleting(Thrown thrown, int result) { b29f839^:util/src/org/aspectj/util/LangUtil.java
/**
		 * Subclasses implement this to get synchronous notice of completion.
		 * All pipes and processes should be complete at this time. To get the
		 * exceptions thrown for the pipes, use <code>getThrown()</code>. If
		 * there is an exception, the process completed abruptly (including
		 * side-effects of the user halting the process). If
		 * <code>userStopped()</code> is true, then some client asked that the
		 * process be destroyed using <code>stop()</code>. Otherwise, the result
		 * code should be the result value returned by the process.
		 * 
		 * @param thrown same as <code>getThrown().fromProcess</code>.
		 * @param result same as <code>getResult()</code>
		 * @see getThrown()
		 * @see getResult()
		 * @see stop()
		 */
protected void doCompleting(Thrown thrown, int result) {
		}
================= fetch public ProcessController() { b29f839^:util/src/org/aspectj/util/LangUtil.java

public static boolean sleepUntil(long time) {
		if (time == 0) {
			return true;
		} else if (time < 0) {
			throw new IllegalArgumentException("negative: " + time);
		}
		// final Thread thread = Thread.currentThread();
		long curTime = System.currentTimeMillis();
		for (int i = 0; (i < 100) && (curTime < time); i++) {
			try {
				Thread.sleep(time - curTime);
			} catch (InterruptedException e) {
				// ignore
			}
			curTime = System.currentTimeMillis();
		}
		return (curTime >= time);
	}
================= fetch public final boolean userStopped() { b29f839^:util/src/org/aspectj/util/LangUtil.java

public final boolean userStopped() {
			return userStopped;
		}
================= fetch public final int getResult() { b29f839^:util/src/org/aspectj/util/LangUtil.java

public final int getResult() {
			return result;
		}
================= fetch public final void setOutSnoop(ByteArrayOutputStream snoop) { b29f839^:util/src/org/aspectj/util/LangUtil.java

public final void setOutSnoop(ByteArrayOutputStream snoop) {
			outSnoop = snoop;
			if (null != outStream) {
				outStream.setSnoop(outSnoop);
			}
		}
================= fetch public static List anySplit(String input, String delim) { b29f839^:util/src/org/aspectj/util/LangUtil.java
/**
	 * Splits <code>input</code>, removing delimiter and trimming any white
	 * space. Returns an empty collection if the input is null. If delimiter is
	 * null or empty or if the input contains no delimiters, the input itself is
	 * returned after trimming white space.
	 * 
	 * @param input <code>String</code> to split.
	 * @param delim <code>String</code> separators for input.
	 * @return List of String of elements.
	 */
public static List anySplit(String input, String delim) {
		if (null == input) {
			return Collections.EMPTY_LIST;
		}
		ArrayList result = new ArrayList();

		if (LangUtil.isEmpty(delim) || (-1 == input.indexOf(delim))) {
			result.add(input.trim());
		} else {
			StringTokenizer st = new StringTokenizer(input, delim);
			while (st.hasMoreTokens()) {
				result.add(st.nextToken().trim());
			}
		}
		return result;
	}
================= fetch public static List commaSplit(String input) { b29f839^:util/src/org/aspectj/util/LangUtil.java
/**
	 * Split string as classpath, delimited at File.pathSeparator. Entries are
	 * not trimmed, but empty entries are ignored.
	 * 
	 * @param classpath the String to split - may be null or empty
	 * @return String[] of classpath entries
	 */
public static String[] splitClasspath(String classpath) {
		if (LangUtil.isEmpty(classpath)) {
			return new String[0];
		}
		StringTokenizer st = new StringTokenizer(classpath, File.pathSeparator);
		ArrayList result = new ArrayList(st.countTokens());
		while (st.hasMoreTokens()) {
			String entry = st.nextToken();
			if (!LangUtil.isEmpty(entry)) {
				result.add(entry);
			}
		}
		return (String[]) result.toArray(new String[0]);
	}
================= fetch public static List safeList(List list) { b29f839^:util/src/org/aspectj/util/LangUtil.java
/**
	 * Convert arrays safely. The number of elements in the result will be 1
	 * smaller for each element that is null or not assignable. This will use
	 * sink if it has exactly the right size. The result will always have the
	 * same component type as sink.
	 * 
	 * @return an array with the same component type as sink containing any
	 *         assignable elements in source (in the same order).
	 * @throws IllegalArgumentException if either is null
	 */
public static Object[] safeCopy(Object[] source, Object[] sink) {
		final Class sinkType = (null == sink ? Object.class : sink.getClass().getComponentType());
		final int sourceLength = (null == source ? 0 : source.length);
		final int sinkLength = (null == sink ? 0 : sink.length);

		final int resultSize;
		ArrayList result = null;
		if (0 == sourceLength) {
			resultSize = 0;
		} else {
			result = new ArrayList(sourceLength);
			for (int i = 0; i < sourceLength; i++) {
				if ((null != source[i]) && (sinkType.isAssignableFrom(source[i].getClass()))) {
					result.add(source[i]);
				}
			}
			resultSize = result.size();
		}
		if (resultSize != sinkLength) {
			sink = (Object[]) Array.newInstance(sinkType, result.size());
		}
		if (0 < resultSize) {
			sink = result.toArray(sink);
		}
		return sink;
	}
================= fetch public static String makeClasspath( // XXX dumb implementation b29f839^:util/src/org/aspectj/util/LangUtil.java
/**
	 * Gen classpath.
	 * 
	 * @param bootclasspath
	 * @param classpath
	 * @param classesDir
	 * @param outputJar
	 * @return String combining classpath elements
	 */
static String makeClasspath( // XXX dumb implementation
			String bootclasspath, String classpath, String classesDir, String outputJar) {
		StringBuffer sb = new StringBuffer();
		addIfNotEmpty(bootclasspath, sb, File.pathSeparator);
		addIfNotEmpty(classpath, sb, File.pathSeparator);
		if (!addIfNotEmpty(classesDir, sb, File.pathSeparator)) {
			addIfNotEmpty(outputJar, sb, File.pathSeparator);
		}
		return sb.toString();
	}
================= fetch public static String renderException(Throwable t) { b29f839^:util/src/org/aspectj/util/LangUtil.java
/**
	 * Renders exception <code>t</code> after unwrapping and eliding any test
	 * packages.
	 * 
	 * @param t <code>Throwable</code> to print.
	 * @see #maxStackTrace
	 */
public static String renderException(Throwable t) {
		return renderException(t, true);
	}
================= fetch public static String renderException(Throwable t, boolean elide) { b29f839^:util/src/org/aspectj/util/LangUtil.java
/**
	 * Renders exception <code>t</code>, unwrapping, optionally eliding and
	 * limiting total number of lines.
	 * 
	 * @param t <code>Throwable</code> to print.
	 * @param elide true to limit to 100 lines and elide test packages
	 * @see StringChecker#TEST_PACKAGES
	 */
public static String renderException(Throwable t, boolean elide) {
		if (null == t)
			return "null throwable";
		t = unwrapException(t);
		StringBuffer stack = stackToString(t, false);
		if (elide) {
			elideEndingLines(StringChecker.TEST_PACKAGES, stack, 100);
		}
		return stack.toString();
	}
================= fetch public static String renderExceptionShort(Throwable e) { b29f839^:util/src/org/aspectj/util/LangUtil.java
/**
	 * @return "({UnqualifiedExceptionClass}) {message}"
	 */
public static String renderExceptionShort(Throwable e) {
		if (null == e)
			return "(Throwable) null";
		return "(" + LangUtil.unqualifiedClassName(e) + ") " + e.getMessage();
	}
================= fetch public static String unqualifiedClassName(Class c) { b29f839^:util/src/org/aspectj/util/LangUtil.java
/**
	 * @return a String with the unqualified class name of the class (or "null")
	 */
public static String unqualifiedClassName(Class c) {
		if (null == c) {
			return "null";
		}
		String name = c.getName();
		int loc = name.lastIndexOf(".");
		if (-1 != loc) {
			name = name.substring(1 + loc);
		}
		return name;
	}
================= fetch public static Throwable unwrapException(Throwable t) { b29f839^:util/src/org/aspectj/util/LangUtil.java
/** @return Throwable input or tail of any wrapped exception chain */
public static Throwable unwrapException(Throwable t) {
		Throwable current = t;
		Throwable next = null;
		while (current != null) {
			// Java 1.2 exceptions that carry exceptions
			if (current instanceof InvocationTargetException) {
				next = ((InvocationTargetException) current).getTargetException();
			} else if (current instanceof ClassNotFoundException) {
				next = ((ClassNotFoundException) current).getException();
			} else if (current instanceof ExceptionInInitializerError) {
				next = ((ExceptionInInitializerError) current).getException();
			} else if (current instanceof PrivilegedActionException) {
				next = ((PrivilegedActionException) current).getException();
			} else if (current instanceof SQLException) {
				next = ((SQLException) current).getNextException();
			}
			// ...getException():
			// javax.naming.event.NamingExceptionEvent
			// javax.naming.ldap.UnsolicitedNotification
			// javax.xml.parsers.FactoryConfigurationError
			// javax.xml.transform.TransformerFactoryConfigurationError
			// javax.xml.transform.TransformerException
			// org.xml.sax.SAXException
			// 1.4: Throwable.getCause
			// java.util.logging.LogRecord.getThrown()
			if (null == next) {
				break;
			} else {
				current = next;
				next = null;
			}
		}
		return current;
	}
================= fetch public static boolean getBoolean(String propertyName, boolean defaultValue) { b29f839^:util/src/org/aspectj/util/LangUtil.java
/**
	 * Get System property as boolean, but use default value where the system
	 * property is not set.
	 * 
	 * @return true if value is set to true, false otherwise
	 */
public static boolean getBoolean(String propertyName, boolean defaultValue) {
		if (null != propertyName) {
			try {
				String value = System.getProperty(propertyName);
				if (null != value) {
					return Boolean.valueOf(value).booleanValue();
				}
			} catch (Throwable t) {
				// default below
			}
		}
		return defaultValue;
	}
================= fetch public static boolean is13VMOrGreater() { b29f839^:util/src/org/aspectj/util/LangUtil.java

public static boolean is13VMOrGreater() {
		return is13VMOrGreater;
	}
================= fetch public static boolean is14VMOrGreater() { b29f839^:util/src/org/aspectj/util/LangUtil.java

public static boolean is14VMOrGreater() {
		return is14VMOrGreater;
	}
================= fetch public static boolean is15VMOrGreater() { b29f839^:util/src/org/aspectj/util/LangUtil.java

public static boolean is15VMOrGreater() {
		return is15VMOrGreater;
	}
================= fetch public static boolean is16VMOrGreater() { b29f839^:util/src/org/aspectj/util/LangUtil.java

public static boolean is16VMOrGreater() {
		return is16VMOrGreater;
	}
================= fetch public static boolean sleepUntil(long time) { b29f839^:util/src/org/aspectj/util/LangUtil.java
/**
	 * Sleep until a particular time.
	 * 
	 * @param time the long time in milliseconds to sleep until
	 * @return true if delay succeeded, false if interrupted 100 times
	 */
public static boolean sleepUntil(long time) {
		if (time == 0) {
			return true;
		} else if (time < 0) {
			throw new IllegalArgumentException("negative: " + time);
		}
		// final Thread thread = Thread.currentThread();
		long curTime = System.currentTimeMillis();
		for (int i = 0; (i < 100) && (curTime < time); i++) {
			try {
				Thread.sleep(time - curTime);
			} catch (InterruptedException e) {
				// ignore
			}
			curTime = System.currentTimeMillis();
		}
		return (curTime >= time);
	}
================= fetch public static final void throwIaxIfNotAssignable(final Object ra[], final Class b29f839^:util/src/org/aspectj/util/LangUtil.java
/**
	 * Shorthand for
	 * "if not null or not assignable, throw IllegalArgumentException"
	 * 
	 * @param c the Class to check - use null to ignore type check
	 * @throws IllegalArgumentException "null {name}" if o is null
	 */
public static final void throwIaxIfNotAssignable(final Object ra[], final Class c, final String name) {
		throwIaxIfNull(ra, name);
		String label = (null == name ? "input" : name);
		for (int i = 0; i < ra.length; i++) {
			if (null == ra[i]) {
				String m = " null " + label + "[" + i + "]";
				throw new IllegalArgumentException(m);
			} else if (null != c) {
				Class actualClass = ra[i].getClass();
				if (!c.isAssignableFrom(actualClass)) {
					String message = label + " not assignable to " + c.getName();
					throw new IllegalArgumentException(message);
				}
			}
		}
	}
================= fetch public static final void throwIaxIfNull(final Object o, final String name) { b29f839^:util/src/org/aspectj/util/LangUtil.java
/**
	 * Shorthand for "if null, throw IllegalArgumentException"
	 * 
	 * @throws IllegalArgumentException "null {name}" if o is null
	 */
public static final void throwIaxIfNull(final Object o, final String name) {
		if (null == o) {
			String message = "null " + (null == name ? "input" : name);
			throw new IllegalArgumentException(message);
		}
	}
================= fetch public void run() { b29f839^:util/src/org/aspectj/util/LangUtil.java

public final Thread start() {
			if (!init) {
				throw new IllegalStateException("not initialized");
			}
			synchronized (this) {
				if (started) {
					throw new IllegalStateException("already started");
				}
				started = true;
			}
			try {
				process = Runtime.getRuntime().exec(command);
			} catch (IOException e) {
				stop(e, Integer.MIN_VALUE);
				return null;
			}
			errStream = new FileUtil.Pipe(process.getErrorStream(), System.err);
			if (null != errSnoop) {
				errStream.setSnoop(errSnoop);
			}
			outStream = new FileUtil.Pipe(process.getInputStream(), System.out);
			if (null != outSnoop) {
				outStream.setSnoop(outSnoop);
			}
			inStream = new FileUtil.Pipe(System.in, process.getOutputStream());
			// start 4 threads, process & pipes for in, err, out
			Runnable processRunner = new Runnable() {
				public void run() {
					Throwable thrown = null;
					int result = Integer.MIN_VALUE;
					try {
						// pipe threads are children
						new Thread(errStream).start();
						new Thread(outStream).start();
						new Thread(inStream).start();
						process.waitFor();
						result = process.exitValue();
					} catch (Throwable e) {
						thrown = e;
					} finally {
						stop(thrown, result);
					}
				}
			};
			Thread result = new Thread(processRunner, label);
			result.start();
			return result;
		}
================= fetch public void loadDefaultProperties() { 3d3d03b^:org.aspectj.matcher/src/org/aspectj/weaver/Lint.java

public void loadDefaultProperties() {
		InputStream s = getClass().getResourceAsStream("XlintDefault.properties");
		if (s == null) {
			MessageUtil.warn(world.getMessageHandler(), WeaverMessages.format(WeaverMessages.XLINTDEFAULT_LOAD_ERROR));
			return;
		}
		try {
			setFromProperties(s);
		} catch (IOException ioe) {
			MessageUtil.error(world.getMessageHandler(), WeaverMessages.format(WeaverMessages.XLINTDEFAULT_LOAD_PROBLEM, ioe
					.getMessage()));
		}

	}
================= fetch private void ensureAnnotationsUnpacked() { b664969^:weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java
// --- unpacking methods
private void ensureAnnotationsUnpacked() {
		if (annotationTypes == null) {
			AnnotationGen annos[] = javaClass.getAnnotations();
			if (annos == null || annos.length == 0) {
				annotationTypes = ResolvedType.NONE;
				annotations = AnnotationAJ.EMPTY_ARRAY;
			} else {
				World w = getResolvedTypeX().getWorld();
				annotationTypes = new ResolvedType[annos.length];
				annotations = new AnnotationAJ[annos.length];
				for (int i = 0; i < annos.length; i++) {
					AnnotationGen annotation = annos[i];
					annotationTypes[i] = w.resolve(UnresolvedType.forSignature(annotation.getTypeSignature()));
					annotations[i] = new BcelAnnotation(annotation, w);
				}
			}
		}
	}
================= fetch public boolean canAnnotationTargetType() { b664969^:weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java

public AnnotationTargetKind[] getAnnotationTargetKinds() {
		if ((bitflag & DISCOVERED_ANNOTATION_TARGET_KINDS) != 0)
			return annotationTargetKinds;
		bitflag |= DISCOVERED_ANNOTATION_TARGET_KINDS;
		annotationTargetKinds = null; // null means we have no idea or the
		// @Target annotation hasn't been used
		List targetKinds = new ArrayList();
		if (isAnnotation()) {
			AnnotationAJ[] annotationsOnThisType = getAnnotations();
			for (int i = 0; i < annotationsOnThisType.length; i++) {
				AnnotationAJ a = annotationsOnThisType[i];
				if (a.getTypeName().equals(UnresolvedType.AT_TARGET.getName())) {
					Set targets = a.getTargets();
					if (targets != null) {
						for (Iterator iterator = targets.iterator(); iterator.hasNext();) {
							String targetKind = (String) iterator.next();
							if (targetKind.equals("ANNOTATION_TYPE")) {
								targetKinds.add(AnnotationTargetKind.ANNOTATION_TYPE);
							} else if (targetKind.equals("CONSTRUCTOR")) {
								targetKinds.add(AnnotationTargetKind.CONSTRUCTOR);
							} else if (targetKind.equals("FIELD")) {
								targetKinds.add(AnnotationTargetKind.FIELD);
							} else if (targetKind.equals("LOCAL_VARIABLE")) {
								targetKinds.add(AnnotationTargetKind.LOCAL_VARIABLE);
							} else if (targetKind.equals("METHOD")) {
								targetKinds.add(AnnotationTargetKind.METHOD);
							} else if (targetKind.equals("PACKAGE")) {
								targetKinds.add(AnnotationTargetKind.PACKAGE);
							} else if (targetKind.equals("PARAMETER")) {
								targetKinds.add(AnnotationTargetKind.PARAMETER);
							} else if (targetKind.equals("TYPE")) {
								targetKinds.add(AnnotationTargetKind.TYPE);
							}
						}
					}
				}
			}
			if (!targetKinds.isEmpty()) {
				annotationTargetKinds = new AnnotationTargetKind[targetKinds.size()];
				return (AnnotationTargetKind[]) targetKinds.toArray(annotationTargetKinds);
			}
		}
		return annotationTargetKinds;
	}
================= fetch public boolean hasAnnotation(UnresolvedType ofType) { b664969^:weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java

public boolean hasAnnotation(UnresolvedType ofType) {
		ensureAnnotationsUnpacked();
		for (int i = 0; i < annotationTypes.length; i++) {
			ResolvedType ax = annotationTypes[i];
			if (ax.equals(ofType))
				return true;
		}
		return false;
	}
Progress : [##########------------------------------] 26%================= fetch public ResolvedType resolve(UnresolvedType ty, boolean allowMissing) { dd7d879^:org.aspectj.matcher/src/org/aspectj/weaver/World.java
/**
	 * Resolve a type. This the hub of type resolution. The resolved type is added to the type map by signature.
	 */
public ResolvedType resolve(UnresolvedType ty, boolean allowMissing) {

		// special resolution processing for already resolved types.
		if (ty instanceof ResolvedType) {
			ResolvedType rty = (ResolvedType) ty;
			rty = resolve(rty);
			return rty;
		}

		// dispatch back to the type variable reference to resolve its
		// constituent parts
		// don't do this for other unresolved types otherwise you'll end up in a
		// loop
		if (ty.isTypeVariableReference()) {
			return ty.resolve(this);
		}

		// if we've already got a resolved type for the signature, just return
		// it
		// after updating the world
		String signature = ty.getSignature();
		ResolvedType ret = typeMap.get(signature);
		if (ret != null) {
			ret.world = this; // Set the world for the RTX
			return ret;
		} else if (signature.equals("?") || signature.equals("*")) {
			// might be a problem here, not sure '?' should make it to here as a
			// signature, the
			// proper signature for wildcard '?' is '*'
			// fault in generic wildcard, can't be done earlier because of init
			// issues
			// TODO ought to be shared single instance representing this
			ResolvedType something = new BoundedReferenceType("*", "Ljava/lang/Object", this);
			typeMap.put("?", something);
			return something;
		}

		// no existing resolved type, create one
		if (ty.isArray()) {
			ResolvedType componentType = resolve(ty.getComponentType(), allowMissing);
			// String brackets =
			// signature.substring(0,signature.lastIndexOf("[")+1);
			ret = new ArrayReferenceType(signature, "[" + componentType.getErasureSignature(), this, componentType);
		} else {
			ret = resolveToReferenceType(ty, allowMissing);
			if (!allowMissing && ret.isMissing()) {
				ret = handleRequiredMissingTypeDuringResolution(ty);
			}
			if (completeBinaryTypes) {
				completeBinaryType(ret);
			}
		}

		// Pulling in the type may have already put the right entry in the map
		if (typeMap.get(signature) == null && !ret.isMissing()) {
			typeMap.put(signature, ret);
		}
		return ret;
	}
================= fetch public void checkPermission( java.security.Permission permission, 59d5c3b^:ajdoc/src/org/aspectj/tools/ajdoc/JavadocRunner.java

public void checkPermission( java.security.Permission permission,
					  Object context ) {
               if ( defaultSecurityManager  != null )
                 defaultSecurityManager.checkPermission( permission, context );
            }
================= fetch static boolean has14ToolsAvailable() { 59d5c3b^:ajdoc/src/org/aspectj/tools/ajdoc/JavadocRunner.java

static boolean has14ToolsAvailable() {
		try {
            Class jdMainClass = com.sun.tools.javadoc.Main.class;
			Class[] paramTypes = new Class[] {String[].class};
			jdMainClass.getMethod("execute", paramTypes);
        } catch (NoClassDefFoundError e) {
            return false;
        } catch (UnsupportedClassVersionError e) {
            return false;
        } catch (NoSuchMethodException e) {
			return false;
		}
		return true;
	}
================= fetch static void callJavadoc( String[] javadocargs ){ 59d5c3b^:ajdoc/src/org/aspectj/tools/ajdoc/JavadocRunner.java

static void callJavadoc( String[] javadocargs ){
        final SecurityManager defaultSecurityManager = System.getSecurityManager();

        System.setSecurityManager( new SecurityManager() {
================= fetch public boolean canAnnotationTargetType() { 3417cbe^:weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java

public AnnotationTargetKind[] getAnnotationTargetKinds() {
		if ((bitflag & DISCOVERED_ANNOTATION_TARGET_KINDS) != 0)
			return annotationTargetKinds;
		bitflag |= DISCOVERED_ANNOTATION_TARGET_KINDS;
		annotationTargetKinds = null; // null means we have no idea or the
		// @Target annotation hasn't been used
		List targetKinds = new ArrayList();
		if (isAnnotation()) {
			AnnotationGen[] annotationsOnThisType = javaClass.getAnnotations();
			for (int i = 0; i < annotationsOnThisType.length; i++) {
				AnnotationGen a = annotationsOnThisType[i];
				if (a.getTypeName().equals(UnresolvedType.AT_TARGET.getName())) {
					ArrayElementValueGen arrayValue = (ArrayElementValueGen) ((ElementNameValuePairGen) a.getValues().get(0))
							.getValue();
					ElementValueGen[] evs = arrayValue.getElementValuesArray();
					if (evs != null) {
						for (int j = 0; j < evs.length; j++) {
							String targetKind = ((EnumElementValueGen) evs[j]).getEnumValueString();
							if (targetKind.equals("ANNOTATION_TYPE")) {
								targetKinds.add(AnnotationTargetKind.ANNOTATION_TYPE);
							} else if (targetKind.equals("CONSTRUCTOR")) {
								targetKinds.add(AnnotationTargetKind.CONSTRUCTOR);
							} else if (targetKind.equals("FIELD")) {
								targetKinds.add(AnnotationTargetKind.FIELD);
							} else if (targetKind.equals("LOCAL_VARIABLE")) {
								targetKinds.add(AnnotationTargetKind.LOCAL_VARIABLE);
							} else if (targetKind.equals("METHOD")) {
								targetKinds.add(AnnotationTargetKind.METHOD);
							} else if (targetKind.equals("PACKAGE")) {
								targetKinds.add(AnnotationTargetKind.PACKAGE);
							} else if (targetKind.equals("PARAMETER")) {
								targetKinds.add(AnnotationTargetKind.PARAMETER);
							} else if (targetKind.equals("TYPE")) {
								targetKinds.add(AnnotationTargetKind.TYPE);
							}
						}
					}
				}
			}
			if (!targetKinds.isEmpty()) {
				annotationTargetKinds = new AnnotationTargetKind[targetKinds.size()];
				return (AnnotationTargetKind[]) targetKinds.toArray(annotationTargetKinds);
			}
		}
		return annotationTargetKinds;
	}
================= fetch public InputSource resolveEntity(String publicId, String systemId) throws SAXExc 66235e8^:weaver/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java

public InputSource resolveEntity(String publicId, String systemId) throws SAXException {
		if (publicId.equals(DTD_PUBLIC_ID) || publicId.equals(DTD_PUBLIC_ID_ALIAS)) {
			InputStream in = DTD_STREAM;
			if (in == null) {
				System.err.println("AspectJ - WARN - could not read DTD " + publicId);
				return null;
			} else {
				return new InputSource(in);
			}
		} else {
			System.err.println("AspectJ - WARN - unknown DTD " + publicId + " - consider using " + DTD_PUBLIC_ID);
			return null;
		}
	}
================= fetch public void generateDispatchMethod(ClassScope classScope, ClassFile classFile) { f9578da^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java

protected Shadow.Kind getShadowKindForBody() {
		return Shadow.MethodExecution;
	}
================= fetch private String checkRtJar(AjBuildConfig buildConfig) { 1b663a9^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/**
	 * This will return null if aspectjrt.jar is present and has the correct version. Otherwise it will return a string message
	 * indicating the problem.
	 */
private String checkRtJar(AjBuildConfig buildConfig) {
		// omitting dev info
		if (Version.text.equals(Version.DEVELOPMENT)) {
			// in the development version we can't do this test usefully
			// MessageUtil.info(holder, "running development version of aspectj compiler");
			return null;
		}

		if (buildConfig == null || buildConfig.getFullClasspath() == null)
			return "no classpath specified";

		String ret = null;
		for (Iterator it = buildConfig.getFullClasspath().iterator(); it.hasNext();) {
			File p = new File((String) it.next());
			// pr112830, allow variations on aspectjrt.jar of the form aspectjrtXXXXXX.jar
			if (p.isFile() && p.getName().startsWith("aspectjrt") && p.getName().endsWith(".jar")) {

				try {
					String version = null;
					Manifest manifest = new JarFile(p).getManifest();
					if (manifest == null) {
						ret = "no manifest found in " + p.getAbsolutePath() + ", expected " + Version.text;
						continue;
					}
					Attributes attr = manifest.getAttributes("org/aspectj/lang/");
					if (null != attr) {
						version = attr.getValue(Attributes.Name.IMPLEMENTATION_VERSION);
						if (null != version) {
							version = version.trim();
						}
					}
					// assume that users of development aspectjrt.jar know what they're doing
					if (Version.DEVELOPMENT.equals(version)) {
						// MessageUtil.info(holder,
						// "running with development version of aspectjrt.jar in " +
						// p.getAbsolutePath());
						return null;
					} else if (!Version.text.equals(version)) {
						ret = "bad version number found in " + p.getAbsolutePath() + " expected " + Version.text + " found "
								+ version;
						continue;
					}
				} catch (IOException ioe) {
					ret = "bad jar file found in " + p.getAbsolutePath() + " error: " + ioe;
				}
				return null; // this is the "OK" return value!
			} else {
				// might want to catch other classpath errors
			}
		}

		if (ret != null)
			return ret; // last error found in potentially matching jars...

		return "couldn't find aspectjrt.jar on classpath, checked: " + makeClasspathString(buildConfig);
	}
================= fetch private void setupModel(AjBuildConfig config) { 1b663a9^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/**
	 * Responsible for managing the ASM model between builds. Contains the policy for maintaining the persistance of elements in the
	 * model.
	 * 
	 * This code is driven before each 'fresh' (batch) build to create a new model.
	 */
private void setupModel(AjBuildConfig config) {
		if (!(config.isEmacsSymMode() || config.isGenerateModelMode())) {
			return;
		}
		// AsmManager.setCreatingModel(config.isEmacsSymMode() || config.isGenerateModelMode());
		// if (!AsmManager.isCreatingModel())
		// return;

		CompilationResultDestinationManager crdm = config.getCompilationResultDestinationManager();
		AsmManager structureModel = AsmManager.createNewStructureModel(crdm==null?Collections.EMPTY_MAP:crdm.getInpathMap());
		// AsmManager.getDefault().getRelationshipMap().clear();
		IHierarchy model = structureModel.getHierarchy();
		String rootLabel = "<root>";

		IProgramElement.Kind kind = IProgramElement.Kind.FILE_JAVA;
		if (buildConfig.getConfigFile() != null) {
			rootLabel = buildConfig.getConfigFile().getName();
			model.setConfigFile(buildConfig.getConfigFile().getAbsolutePath());
			kind = IProgramElement.Kind.FILE_LST;
		}
		model.setRoot(new ProgramElement(structureModel, rootLabel, kind, new ArrayList()));

		model.setFileMap(new HashMap());
		// setStructureModel(model);
		state.setStructureModel(structureModel);
		// state.setRelationshipMap(AsmManager.getDefault().getRelationshipMap());
	}
================= fetch public World getWorld() { 1b663a9^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

public World getWorld() {
		return getBcelWorld();
	}
================= fetch public void acceptResult(CompilationResult unitResult) { 1b663a9^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

public ICompilerRequestor getBatchRequestor() {
		return new ICompilerRequestor() {

			public void acceptResult(CompilationResult unitResult) {
				// end of compile, must now write the results to the output destination
				// this is either a jar file or a file in a directory
				boolean hasErrors = unitResult.hasErrors();
				if (!hasErrors || proceedOnError()) {
					Collection classFiles = unitResult.compiledTypes.values();
					boolean shouldAddAspectName = (buildConfig.getOutxmlName() != null);
					for (Iterator iter = classFiles.iterator(); iter.hasNext();) {
						ClassFile classFile = (ClassFile) iter.next();
						String filename = new String(classFile.fileName());
						String classname = filename.replace('/', '.');
						filename = filename.replace('/', File.separatorChar) + ".class";

						try {
							if (buildConfig.getOutputJar() == null) {
								String outfile = writeDirectoryEntry(unitResult, classFile, filename);
								if (environmentSupportsIncrementalCompilation) {
									if (!classname.endsWith("$ajcMightHaveAspect")) {
										ResolvedType type = getBcelWorld().resolve(classname);
										if (type.isAspect()) {
											state.recordAspectClassFile(outfile);
										}
									}
								}
							} else {
								writeZipEntry(classFile, filename);
							}
							if (shouldAddAspectName && !classname.endsWith("$ajcMightHaveAspect"))
								addAspectName(classname, unitResult.getFileName());
						} catch (IOException ex) {
							IMessage message = EclipseAdapterUtils.makeErrorMessage(new String(unitResult.fileName),
									CANT_WRITE_RESULT, ex);
							handler.handleMessage(message);
						}

					}
					state.noteNewResult(unitResult);
					unitResult.compiledTypes.clear(); // free up references to AjClassFile instances
				}

				if (unitResult.hasProblems() || unitResult.hasTasks()) {
					IProblem[] problems = unitResult.getAllProblems();
					for (int i = 0; i < problems.length; i++) {
						IMessage message = EclipseAdapterUtils.makeMessage(unitResult.compilationUnit, problems[i], getBcelWorld(),progressListener);
						handler.handleMessage(message);
					}
				}

			}
Progress : [##########------------------------------] 27%================= fetch private String getParameters(IProgramElement ipe) { 6dbb5f3^:asm/src/org/aspectj/asm/internal/JDTLikeHandleProvider.java
/**
	 * Only returns the count if it's not equal to 1
	 */
private char[] convertCount(char[] c) {
		if ((c.length == 1 && c[0] != ' ' && c[0] != '1') || c.length > 1) {
			return CharOperation.concat(countDelim, c);
		}
		return empty;
	}
================= fetch private boolean changedAndNeedsFullBuild(List oldPath, List newPath, boolean che b23cc1a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
/**
	 * Check the old and new paths, if they vary by length or individual elements then that is considered a change. Or if the last
	 * modified time of a path entry has changed (or last modified time of a classfile in that path entry has changed) then return
	 * true. The outputlocations are supplied so they can be 'ignored' in the comparison.
	 * 
	 * @param oldPath
	 * @param newPath
	 * @param checkClassFiles whether to examine individual class files within directories
	 * @param outputLocs the output locations that should be ignored if they occur on the paths being compared
	 * @return true if a change is detected that requires a full build
	 */
private boolean changedAndNeedsFullBuild(List oldPath, List newPath, boolean checkClassFiles, List outputLocs,
			Set alreadyAnalysedPaths) {
		// if (oldPath == null) {
		// oldPath = new ArrayList();
		// }
		// if (newPath == null) {
		// newPath = new ArrayList();
		// }
		if (oldPath.size() != newPath.size()) {
			return true;
		}
		for (int i = 0; i < oldPath.size(); i++) {
			if (!oldPath.get(i).equals(newPath.get(i))) {
				return true;
			}
			Object o = oldPath.get(i); // String on classpath, File on other paths
			File f = null;
			if (o instanceof String) {
				f = new File((String) o);
			} else {
				f = (File) o;
			}
			if (f.exists() && !f.isDirectory() && (f.lastModified() >= lastSuccessfulBuildTime)) {
				return true;
			}
			if (checkClassFiles && f.exists() && f.isDirectory()) {

				// We should use here a list/set of directories we know have or have not changed - some kind of
				// List<File> buildConfig.getClasspathEntriesWithChangedContents()
				// and then only proceed to look inside directories if it is one of these, ignoring others -
				// that should save a massive amount of processing for incremental builds in a multi project scenario

				boolean foundMatch = false;
				for (Iterator iterator = outputLocs.iterator(); !foundMatch && iterator.hasNext();) {
					File dir = (File) iterator.next();
					if (f.equals(dir)) {
						foundMatch = true;
					}
				}
				if (!foundMatch) {
					if (!alreadyAnalysedPaths.contains(f.getAbsolutePath())) { // Do not check paths more than once
						alreadyAnalysedPaths.add(f.getAbsolutePath());
						int classFileChanges = classFileChangedInDirSinceLastBuildRequiringFullBuild(f);
						if (classFileChanges == CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD)
							return true;
					}
				}
			}
		}
		return false;
	}
================= fetch private boolean classpathChangedAndNeedsFullBuild(List oldPath, List newPath, bo b23cc1a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
/**
	 * Check the old and new paths, if they vary by length or individual elements then that is considered a change. Or if the last
	 * modified time of a path entry has changed (or last modified time of a classfile in that path entry has changed) then return
	 * true. The outputlocations are supplied so they can be 'ignored' in the comparison.
	 * 
	 * @param oldPath
	 * @param newPath
	 * @param checkClassFiles whether to examine individual class files within directories
	 * @param outputLocs the output locations that should be ignored if they occur on the paths being compared
	 * @return true if a change is detected that requires a full build
	 */
private boolean classpathChangedAndNeedsFullBuild(List oldPath, List newPath, boolean checkClassFiles, List outputLocs,
			Set alreadyAnalysedPaths) {
		// if (oldPath == null) {
		// oldPath = new ArrayList();
		// }
		// if (newPath == null) {
		// newPath = new ArrayList();
		// }
		if (oldPath.size() != newPath.size()) {
			return true;
		}
		for (int i = 0; i < oldPath.size(); i++) {
			if (!oldPath.get(i).equals(newPath.get(i))) {
				return true;
			}
			File f = new File((String) oldPath.get(i));
			if (f.exists() && !f.isDirectory() && (f.lastModified() >= lastSuccessfulBuildTime)) {
				return true;
			}
			if (checkClassFiles && f.exists() && f.isDirectory()) {

				// We should use here a list/set of directories we know have or have not changed - some kind of
				// List<File> buildConfig.getClasspathEntriesWithChangedContents()
				// and then only proceed to look inside directories if it is one of these, ignoring others -
				// that should save a massive amount of processing for incremental builds in a multi project scenario

				boolean foundMatch = false;
				for (Iterator iterator = outputLocs.iterator(); !foundMatch && iterator.hasNext();) {
					File dir = (File) iterator.next();
					if (f.equals(dir)) {
						foundMatch = true;
					}
				}
				if (!foundMatch) {
					if (!alreadyAnalysedPaths.contains(f.getAbsolutePath())) { // Do not check paths more than once
						alreadyAnalysedPaths.add(f.getAbsolutePath());
						int classFileChanges = classFileChangedInDirSinceLastBuildRequiringFullBuild(f);
						if (classFileChanges == CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD)
							return true;
					}
				}
			}
		}
		return false;
	}
================= fetch private boolean hasAnyStructuralChangesSince(long lastSuccessfulBuildTime) { b23cc1a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
/**
	 * Determine if anything has changed since a given time.
	 */
private boolean hasAnyStructuralChangesSince(long lastSuccessfulBuildTime) {
		Set entries = structuralChangesSinceLastFullBuild.entrySet();
		for (Iterator iterator = entries.iterator(); iterator.hasNext();) {
			Map.Entry entry = (Map.Entry) iterator.next();
			Long l = (Long) entry.getValue();
			if (l != null) {
				long lvalue = l.longValue();
				if (lvalue > lastSuccessfulBuildTime) {
					if (listenerDefined()) {
						getListener().recordDecision(
								"Seems this has changed " + entry.getKey() + "modtime=" + lvalue + " lsbt="
										+ this.lastSuccessfulFullBuildTime + "   incoming check value=" + lastSuccessfulBuildTime);
					}
					return true;
				}
			}
		}
		return (this.lastSuccessfulFullBuildTime > lastSuccessfulBuildTime);
	}
================= fetch private boolean isTypeWeReferTo(File file) { b23cc1a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
/**
	 * If a class file has changed in a path on our classpath, it may not be for a type that any of our source files care about.
	 * This method checks if any of our source files have a dependency on the class in question and if not, we don't consider it an
	 * interesting change.
	 */
private boolean isTypeWeReferTo(File file) {
		String fpath = file.getAbsolutePath();
		int finalSeparator = fpath.lastIndexOf(File.separator);
		String baseDir = fpath.substring(0, finalSeparator);
		String theFile = fpath.substring(finalSeparator + 1);
		SoftHashMap classNames = (SoftHashMap) fileToClassNameMap.get(baseDir);
		if (classNames == null) {
			classNames = new SoftHashMap();
			fileToClassNameMap.put(baseDir, classNames);
		}
		char[] className = (char[]) classNames.get(theFile);
		if (className == null) {
			// if (listenerDefined())
			// getListener().recordDecision("Cache miss, looking up classname for : " + fpath);

			ClassFileReader cfr;
			try {
				cfr = ClassFileReader.read(file);
			} catch (ClassFormatException e) {
				return true;
			} catch (IOException e) {
				return true;
			}
			className = cfr.getName();
			classNames.put(theFile, className);
			// } else {
			// if (listenerDefined())
			// getListener().recordDecision("Cache hit, looking up classname for : " + fpath);
		}

		char[][][] qualifiedNames = null;
		char[][] simpleNames = null;
		if (CharOperation.indexOf('/', className) != -1) {
			qualifiedNames = new char[1][][];
			qualifiedNames[0] = CharOperation.splitOn('/', className);
			qualifiedNames = ReferenceCollection.internQualifiedNames(qualifiedNames);
		} else {
			simpleNames = new char[1][];
			simpleNames[0] = className;
			simpleNames = ReferenceCollection.internSimpleNames(simpleNames, true);
		}

		for (Iterator i = references.entrySet().iterator(); i.hasNext();) {
			Map.Entry entry = (Map.Entry) i.next();
			ReferenceCollection refs = (ReferenceCollection) entry.getValue();
			if (refs != null && refs.includes(qualifiedNames, simpleNames)) {
				if (listenerDefined()) {
					getListener().recordDecision(
							toString() + ": type " + new String(className) + " is depended upon by '" + entry.getKey() + "'");
				}
				affectedFiles.add(entry.getKey());
				if (affectedFiles.size() > MAX_AFFECTED_FILES_BEFORE_FULL_BUILD)
					return true;
				// return true;
			}
		}
		if (affectedFiles.size() > 0)
			return true;
		if (listenerDefined())
			getListener().recordDecision(toString() + ": type " + new String(className) + " is not depended upon by this state");

		return false;
	}
================= fetch private boolean pathChange(AjBuildConfig previousConfig, AjBuildConfig newConfig b23cc1a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
/**
	 * Return a list of the output locations - this includes any 'default' output location and then any known by a registered
	 * CompilationResultDestinationManager.
	 * 
	 * @param config the build configuration for which the output locations should be determined
	 * @return a list of file objects
	 */
private List /* File */getOutputLocations(AjBuildConfig config) {
		List outputLocs = new ArrayList();
		// Is there a default location?
		if (config.getOutputDir() != null) {
			try {
				outputLocs.add(config.getOutputDir().getCanonicalFile());
			} catch (IOException e) {
			}
		}
		if (config.getCompilationResultDestinationManager() != null) {
			List dirs = config.getCompilationResultDestinationManager().getAllOutputLocations();
			for (Iterator iterator = dirs.iterator(); iterator.hasNext();) {
				File f = (File) iterator.next();
				try {
					File cf = f.getCanonicalFile();
					if (!outputLocs.contains(cf)) {
						outputLocs.add(cf);
					}
				} catch (IOException e) {
				}
			}
		}
		return outputLocs;
	}
================= fetch private int classFileChangedInDirSinceLastBuildRequiringFullBuild(File dir) { b23cc1a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
/**
	 * Analyse .class files in the directory specified, if they have changed since the last successful build then see if we can
	 * determine which source files in our project depend on the change. If we can then we can still do an incremental build, if we
	 * can't then we have to do a full build.
	 * 
	 */
private int classFileChangedInDirSinceLastBuildRequiringFullBuild(File dir) {

		if (!dir.isDirectory()) {
			return CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD;
		}

		// Are we managing that output directory?
		AjState state = IncrementalStateManager.findStateManagingOutputLocation(dir);
		if (listenerDefined()) {
			if (state != null) {
				getListener().recordDecision("Found state instance managing output location : " + dir);
			} else {
				getListener().recordDecision("Failed to find a state instance managing output location : " + dir);
			}
		}
		

		// pr268827 - this guard will cause us to exit quickly if the state says there really is
		// nothing of interest. This will not catch the case where a user modifies the .class files outside of
		// eclipse because the state will not be aware of it. But that seems an unlikely scenario and
		// we are paying a heavy price to check it
		if (state != null && !state.hasAnyStructuralChangesSince(lastSuccessfulBuildTime)) {
			if (listenerDefined()) {
				getListener().recordDecision("No reported changes in that state");
			}
			return CLASS_FILE_NO_CHANGES;
		}
		
		if (state == null) {
			// This may be because the directory is the output path of a Java project upon which we depend
			// we need to call back into AJDT to ask about that projects state.
			CompilationResultDestinationManager crdm = buildConfig.getCompilationResultDestinationManager();
			if (crdm!=null) {
				int i = crdm.discoverChangesSince(dir,lastSuccessfulBuildTime);
				// 0 = dontknow if it has changed
				// 1 = definetly not changed at all
				// further numbers can determine more granular changes
				if (i==1) {
					if (listenerDefined()) {
						getListener().recordDecision("'"+dir+"' is apparently unchanged so not performing timestamp check");
					}
					return CLASS_FILE_NO_CHANGES;
				}
			}
		}

		List classFiles = FileUtil.listClassFiles(dir);

		for (Iterator iterator = classFiles.iterator(); iterator.hasNext();) {
			File classFile = (File) iterator.next();
			if (CHECK_STATE_FIRST && state != null) {
				if (state.isAspect(classFile)) {
					return CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD;
				}
				if (state.hasStructuralChangedSince(classFile, lastSuccessfulBuildTime)) {
					if (listenerDefined()) {
						getListener().recordDecision("Structural change detected in : " + classFile);
					}

					if (isTypeWeReferTo(classFile)) {
						if (affectedFiles.size() > MAX_AFFECTED_FILES_BEFORE_FULL_BUILD)
							return CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD;
					}
					// } else {
					// if (listenerDefined())
					// getListener().recordDecision("Change detected in " + classFile + " but it is not structural");
				}
			} else {
				long modTime = classFile.lastModified();
				if ((modTime + 1000) >= lastSuccessfulBuildTime) {
					// so the class on disk has changed since the last successful build for this state object

					// BUG? we stop on the first change that leads us to an incremental build, surely we need to continue and look
					// at all files incase another change means we need to incremental a bit more stuff?

					// To work out if it is a real change we should ask any state
					// object managing the output location whether the file has
					// structurally changed or not
					if (state != null) {
						if (state.isAspect(classFile)) {
							return CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD;
						}
						if (state.hasStructuralChangedSince(classFile, lastSuccessfulBuildTime)) {
							if (listenerDefined()) {
								getListener().recordDecision("Structural change detected in : " + classFile);
							}

							if (isTypeWeReferTo(classFile)) {
								if (affectedFiles.size() > MAX_AFFECTED_FILES_BEFORE_FULL_BUILD)
									return CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD;
							}
						} else {
							if (listenerDefined())
								getListener().recordDecision("Change detected in " + classFile + " but it is not structural");
						}
					} else {
						// No state object to ask, so it only matters if we know which type depends on this file
						if (isTypeWeReferTo(classFile)) {
							if (affectedFiles.size() > MAX_AFFECTED_FILES_BEFORE_FULL_BUILD)
								return CLASS_FILE_CHANGED_THAT_NEEDS_FULL_BUILD;
							return CLASS_FILE_CHANGED_THAT_NEEDS_INCREMENTAL_BUILD;
						} else {
							return CLASS_FILE_NO_CHANGES;
						}
					}
				}
			}
		}
		return CLASS_FILE_NO_CHANGES;
	}
================= fetch public boolean accept(File pathname) { b23cc1a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java

Collection getModifiedBinaryFiles(long lastBuildTime) {
		List ret = new ArrayList();
		// not our job to account for new and deleted files
		for (Iterator i = buildConfig.getBinaryFiles().iterator(); i.hasNext();) {
			AjBuildConfig.BinarySourceFile bsfile = (AjBuildConfig.BinarySourceFile) i.next();
			File file = bsfile.binSrc;
			if (!file.exists())
				continue;

			long modTime = file.lastModified();
			// System.out.println("check: " + file + " mod " + modTime + " build " + lastBuildTime);
			// need to add 1000 since lastModTime is only accurate to a second on some (all?) platforms
			if (modTime + 1000 >= lastBuildTime) {
				ret.add(bsfile);
			}
		}
		return ret;
	}
================= fetch public static void addRelationship(AsmManager model, ResolvedType onType, Resolv d5e900d^:weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java
/**
	 * Add a relationship for a type transformation (declare parents, intertype method declaration, declare annotation on type).
	 */
public static void addRelationship(AsmManager model, ResolvedType onType, ResolvedTypeMunger typeTransformer,
			ResolvedType originatingAspect) {
		if (model == null) {
			return;
		}

		if (World.createInjarHierarchy && isBinaryAspect(originatingAspect)) {
			createHierarchy(model, typeTransformer, originatingAspect);
		}

		if (originatingAspect.getSourceLocation() != null) {
			String sourceHandle = "";
			IProgramElement sourceNode = null;
			if (typeTransformer.getSourceLocation() != null && typeTransformer.getSourceLocation().getOffset() != -1) {
				sourceNode = model.getHierarchy().findElementForType(originatingAspect.getPackageName(),
						originatingAspect.getClassName());
				IProgramElement closer = model.getHierarchy().findCloserMatchForLineNumber(sourceNode,
						typeTransformer.getSourceLocation().getLine());
				if (closer != null) {
					sourceNode = closer;
				}
				sourceHandle = model.getHandleProvider().createHandleIdentifier(sourceNode);
			} else {
				sourceNode = model.getHierarchy().findElementForType(originatingAspect.getPackageName(),
						originatingAspect.getClassName());
				// sourceNode =
				// asm.getHierarchy().findElementForSourceLine(originatingAspect
				// .getSourceLocation());
				sourceHandle = model.getHandleProvider().createHandleIdentifier(sourceNode);
			}
			// sourceNode =
			// asm.getHierarchy().findElementForType(originatingAspect
			// .getPackageName(),
			// originatingAspect.getClassName());
			// // sourceNode =
			// asm.getHierarchy().findElementForSourceLine(munger
			// .getSourceLocation());
			// sourceHandle =
			// asm.getHandleProvider().createHandleIdentifier(sourceNode);
			if (sourceHandle == null)
				return;
			IProgramElement targetNode = model.getHierarchy().findElementForSourceLine(onType.getSourceLocation());
			String targetHandle = model.getHandleProvider().createHandleIdentifier(targetNode);
			if (targetHandle == null)
				return;

			IRelationshipMap mapper = model.getRelationshipMap();
			IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE_INTER_TYPE, INTER_TYPE_DECLARES, false,
					true);
			foreward.addTarget(targetHandle);

			IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE_INTER_TYPE, INTER_TYPE_DECLARED_BY, false,
					true);
			back.addTarget(sourceHandle);
			model.addAspectInEffectThisBuild(sourceNode.getSourceLocation().getSourceFile());
		}
	}
================= fetch public static ISourceLocation makeSourceLocation(ICompilationUnit unit, IProblem c732808^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java
/**
	 * Extract source location file, start and end lines, and context. Column is not extracted correctly.
	 * 
	 * @return ISourceLocation with correct file and lines but not column.
	 */
public static ISourceLocation makeSourceLocation(ICompilationUnit unit, IProblem problem) {
		int line = problem.getSourceLineNumber();
		File file = new File(new String(problem.getOriginatingFileName()));
		String context = makeLocationContext(unit, problem);
		// XXX 0 column is wrong but recoverable from makeLocationContext
		return new SourceLocation(file, line, line, 0, context);
	}
================= fetch public static String makeLocationContext(ICompilationUnit compilationUnit, IProb c732808^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java

public static String makeLocationContext(ICompilationUnit compilationUnit, IProblem problem) {
		// extra from the source the innacurate token
		// and "highlight" it using some underneath ^^^^^
		// put some context around too.

		// this code assumes that the font used in the console is fixed size

		// sanity .....
		int startPosition = problem.getSourceStart();
		int endPosition = problem.getSourceEnd();

		if ((startPosition > endPosition) || ((startPosition <= 0) && (endPosition <= 0)) || compilationUnit == null)
			//return Util.bind("problem.noSourceInformation"); //$NON-NLS-1$
			return "(no source information available)";

		final char SPACE = '\u0020';
		final char MARK = '^';
		final char TAB = '\t';
		char[] source = compilationUnit.getContents();
		// the next code tries to underline the token.....
		// it assumes (for a good display) that token source does not
		// contain any \r \n. This is false on statements !
		// (the code still works but the display is not optimal !)

		// compute the how-much-char we are displaying around the inaccurate token
		int begin = startPosition >= source.length ? source.length - 1 : startPosition;
		if (begin == -1)
			return "(no source information available)"; // Dont like this - why does it occur? pr152835
		int relativeStart = 0;
		int end = endPosition >= source.length ? source.length - 1 : endPosition;
		int relativeEnd = 0;
		label: for (relativeStart = 0;; relativeStart++) {
			if (begin == 0)
				break label;
			if ((source[begin - 1] == '\n') || (source[begin - 1] == '\r'))
				break label;
			begin--;
		}
		label: for (relativeEnd = 0;; relativeEnd++) {
			if ((end + 1) >= source.length)
				break label;
			if ((source[end + 1] == '\r') || (source[end + 1] == '\n')) {
				break label;
			}
			end++;
		}
		// extract the message form the source
		char[] extract = new char[end - begin + 1];
		System.arraycopy(source, begin, extract, 0, extract.length);
		char c;
		// remove all SPACE and TAB that begin the error message...
		int trimLeftIndex = 0;
		while ((((c = extract[trimLeftIndex++]) == TAB) || (c == SPACE)) && trimLeftIndex < extract.length) {
		}
		if (trimLeftIndex >= extract.length)
			return new String(extract) + "\n";
		System.arraycopy(extract, trimLeftIndex - 1, extract = new char[extract.length - trimLeftIndex + 1], 0, extract.length);
		relativeStart -= trimLeftIndex;
		// buffer spaces and tabs in order to reach the error position
		int pos = 0;
		char[] underneath = new char[extract.length]; // can't be bigger
		for (int i = 0; i <= relativeStart; i++) {
			if (extract[i] == TAB) {
				underneath[pos++] = TAB;
			} else {
				underneath[pos++] = SPACE;
			}
		}
		// mark the error position
		for (int i = startPosition + trimLeftIndex; // AMC if we took stuff off the start, take it into account!
		i <= (endPosition >= source.length ? source.length - 1 : endPosition); i++)
			underneath[pos++] = MARK;
		// resize underneathto remove 'null' chars
		System.arraycopy(underneath, 0, underneath = new char[pos], 0, pos);

		return new String(extract) + "\n" + new String(underneath); //$NON-NLS-2$ //$NON-NLS-1$
	}
================= fetch public void acceptResult(CompilationResult unitResult) { c732808^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

public ICompilerRequestor getBatchRequestor() {
		return new ICompilerRequestor() {

			public void acceptResult(CompilationResult unitResult) {
				// end of compile, must now write the results to the output destination
				// this is either a jar file or a file in a directory
				boolean hasErrors = unitResult.hasErrors();
				if (!hasErrors || proceedOnError()) {
					Collection classFiles = unitResult.compiledTypes.values();
					boolean shouldAddAspectName = (buildConfig.getOutxmlName() != null);
					for (Iterator iter = classFiles.iterator(); iter.hasNext();) {
						ClassFile classFile = (ClassFile) iter.next();
						String filename = new String(classFile.fileName());
						String classname = filename.replace('/', '.');
						filename = filename.replace('/', File.separatorChar) + ".class";

						try {
							if (buildConfig.getOutputJar() == null) {
								String outfile = writeDirectoryEntry(unitResult, classFile, filename);
								if (environmentSupportsIncrementalCompilation) {
									if (!classname.endsWith("$ajcMightHaveAspect")) {
										ResolvedType type = getBcelWorld().resolve(classname);
										if (type.isAspect()) {
											state.recordAspectClassFile(outfile);
										}
									}
								}
							} else {
								writeZipEntry(classFile, filename);
							}
							if (shouldAddAspectName && !classname.endsWith("$ajcMightHaveAspect"))
								addAspectName(classname, unitResult.getFileName());
						} catch (IOException ex) {
							IMessage message = EclipseAdapterUtils.makeErrorMessage(new String(unitResult.fileName),
									CANT_WRITE_RESULT, ex);
							handler.handleMessage(message);
						}

					}
					state.noteNewResult(unitResult);
					unitResult.compiledTypes.clear(); // free up references to AjClassFile instances
				}

				if (unitResult.hasProblems() || unitResult.hasTasks()) {
					IProblem[] problems = unitResult.getAllProblems();
					for (int i = 0; i < problems.length; i++) {
						IMessage message = EclipseAdapterUtils.makeMessage(unitResult.compilationUnit, problems[i], getBcelWorld());
						handler.handleMessage(message);
					}
				}

			}
================= fetch public IProgramElement findElementForType(String packageName, String typeName) { 7a7d6f0^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java
/**
	 * Look for any package nodes matching the specified package name. There may be multiple in the case where the types within a
	 * package are split across source folders.
	 * 
	 * @param packagename the packagename being searched for
	 * @return a list of package nodes that match that name
	 */
public List/* IProgramElement */findMatchingPackages(String packagename) {
		List children = root.getChildren();
		// The children might be source folders or packages
		if (children.size() == 0) {
			return Collections.EMPTY_LIST;
		}
		if (((IProgramElement) children.get(0)).getKind() == IProgramElement.Kind.SOURCE_FOLDER) {
			// dealing with source folders
			List matchingPackageNodes = new ArrayList();
			for (Iterator iterator = children.iterator(); iterator.hasNext();) {
				IProgramElement sourceFolder = (IProgramElement) iterator.next();
				List possiblePackageNodes = sourceFolder.getChildren();
				for (Iterator iterator2 = possiblePackageNodes.iterator(); iterator2.hasNext();) {
					IProgramElement possiblePackageNode = (IProgramElement) iterator2.next();
					if (possiblePackageNode.getKind() == IProgramElement.Kind.PACKAGE) {
						if (possiblePackageNode.getName().equals(packagename)) {
							matchingPackageNodes.add(possiblePackageNode);
						}
					}
				}
			}
			// 'binaries' will be checked automatically by the code above as it is represented as a SOURCE_FOLDER
			return matchingPackageNodes;
		} else {
			// dealing directly with packages below the root, no source folders. Therefore at most one
			// thing to return in the list
			if (packagename == null) {
				// default package
				List result = new ArrayList();
				result.add(root);
				return result;
			}
			for (Iterator iterator = children.iterator(); iterator.hasNext();) {
				IProgramElement possiblePackage = (IProgramElement) iterator.next();
				if (possiblePackage.getKind() == IProgramElement.Kind.PACKAGE) {
					if (possiblePackage.getName().equals(packagename)) {
						List result = new ArrayList();
						result.add(possiblePackage);
						return result;
					}
				}
				if (possiblePackage.getKind() == IProgramElement.Kind.SOURCE_FOLDER) { // might be 'binaries'
					if (possiblePackage.getName().equals("binaries")) {
						for (Iterator iter2 = possiblePackage.getChildren().iterator(); iter2.hasNext();) {
							IProgramElement possiblePackage2 = (IProgramElement) iter2.next();
							if (possiblePackage2.getKind() == IProgramElement.Kind.PACKAGE) {
								if (possiblePackage2.getName().equals(packagename)) {
									List result = new ArrayList();
									result.add(possiblePackage2);
									return result;
								}
							}
						}
					}
				}
			}
		}
		return Collections.EMPTY_LIST;
	}
Progress : [###########-----------------------------] 28%================= fetch private boolean pathChange(AjBuildConfig previousConfig, AjBuildConfig newConfig 5c49c0b^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
/**
	 * Return a list of the output locations - this includes any 'default' output location and then any known by a registered
	 * CompilationResultDestinationManager.
	 * 
	 * @param config the build configuration for which the output locations should be determined
	 * @return a list of file objects
	 */
private List /* File */getOutputLocations(AjBuildConfig config) {
		List outputLocs = new ArrayList();
		// Is there a default location?
		if (config.getOutputDir() != null) {
			try {
				outputLocs.add(config.getOutputDir().getCanonicalFile());
			} catch (IOException e) {
			}
		}
		if (config.getCompilationResultDestinationManager() != null) {
			List dirs = config.getCompilationResultDestinationManager().getAllOutputLocations();
			for (Iterator iterator = dirs.iterator(); iterator.hasNext();) {
				File f = (File) iterator.next();
				try {
					File cf = f.getCanonicalFile();
					if (!outputLocs.contains(cf)) {
						outputLocs.add(cf);
					}
				} catch (IOException e) {
				}
			}
		}
		return outputLocs;
	}
================= fetch private void removeAllResultsOfLastBuild() { 5c49c0b^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
/**
	 * Called when a path change is about to trigger a full build, but we haven't cleaned up from the last incremental build...
	 */
private void removeAllResultsOfLastBuild() {
		// remove all binarySourceFiles, and all classesFromName...
		for (Iterator iter = this.inputClassFilesBySource.values().iterator(); iter.hasNext();) {
			List cfs = (List) iter.next();
			for (Iterator iterator = cfs.iterator(); iterator.hasNext();) {
				ClassFile cf = (ClassFile) iterator.next();
				cf.deleteFromFileSystem(buildConfig);
			}
		}
		for (Iterator iterator = classesFromName.values().iterator(); iterator.hasNext();) {
			File f = (File) iterator.next();
			new ClassFile("", f).deleteFromFileSystem(buildConfig);
		}
		for (Iterator iter = resources.iterator(); iter.hasNext();) {
			String resource = (String) iter.next();
			List outputDirs = getOutputLocations(buildConfig);
			for (Iterator iterator = outputDirs.iterator(); iterator.hasNext();) {
				File dir = (File) iterator.next();
				File f = new File(dir, resource);
				if (f.exists()) {
					f.delete();
				}
			}
		}
	}
================= fetch private void writeDirectory(String directory, File srcloc) throws IOException { 5c49c0b^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/**
	 * Add a directory entry to the output zip file. Don't do anything if not writing out to a zip file. A directory entry is one
	 * whose filename ends with '/'
	 * 
	 * @param directory the directory path
	 * @param srcloc the src of the directory entry, for use when creating a warning message
	 * @throws IOException if something goes wrong creating the new zip entry
	 */
private void writeDirectory(String directory, File srcloc) throws IOException {
		if (state.hasResource(directory)) {
			IMessage msg = new Message("duplicate resource: '" + directory + "'", IMessage.WARNING, null, new SourceLocation(
					srcloc, 0));
			handler.handleMessage(msg);
			return;
		}
		if (zos != null) {
			ZipEntry newEntry = new ZipEntry(directory);
			zos.putNextEntry(newEntry);
			zos.closeEntry();
			state.recordResource(directory);
		}
		// Nothing to do if not writing to a zip file
	}
================= fetch private void writeResource(String filename, byte[] content, File srcLocation) th 5c49c0b^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void writeResource(String filename, byte[] content, File srcLocation) throws IOException {
		if (state.hasResource(filename)) {
			IMessage msg = new Message("duplicate resource: '" + filename + "'", IMessage.WARNING, null, new SourceLocation(
					srcLocation, 0));
			handler.handleMessage(msg);
			return;
		}
		if (filename.equals(buildConfig.getOutxmlName())) {
			ignoreOutxml = true;
			IMessage msg = new Message("-outxml/-outxmlfile option ignored because resource already exists: '" + filename + "'",
					IMessage.WARNING, null, new SourceLocation(srcLocation, 0));
			handler.handleMessage(msg);
		}
		if (zos != null) {
			ZipEntry newEntry = new ZipEntry(filename); // ??? get compression scheme right

			zos.putNextEntry(newEntry);
			zos.write(content);
			zos.closeEntry();
		} else {
			File destDir = buildConfig.getOutputDir();
			if (buildConfig.getCompilationResultDestinationManager() != null) {
				destDir = buildConfig.getCompilationResultDestinationManager().getOutputLocationForResource(srcLocation);
			}
			try {
				OutputStream fos = FileUtil.makeOutputStream(new File(destDir, filename));
				fos.write(content);
				fos.close();
			} catch (FileNotFoundException fnfe) {
				IMessage msg = new Message("unable to copy resource to output folder: '" + filename + "' - reason: "
						+ fnfe.getMessage(), IMessage.ERROR, null, new SourceLocation(srcLocation, 0));
				handler.handleMessage(msg);
			}
		}
		state.recordResource(filename);
	}
================= fetch public boolean hasResource(String resourceName) { 5c49c0b^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java

public boolean hasResource(String resourceName) {
		return this.resources.contains(resourceName);
	}
================= fetch public IProgramElement findCloserMatchForLineNumber(IProgramElement node, int li 2309f7b^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java
/**
	 * For a specified node, check if any of the children more accurately represent the specified line.
	 * 
	 * @param node where to start looking
	 * @param lineno the line number
	 * @return any closer match below 'node' or null if nothing is a more accurate match
	 */
public IProgramElement findCloserMatchForLineNumber(IProgramElement node, int lineno) {
		for (Iterator childrenIter = node.getChildren().iterator(); childrenIter.hasNext();) {
			IProgramElement child = (IProgramElement) childrenIter.next();
			ISourceLocation childLoc = child.getSourceLocation();
			if (childLoc != null) {
				if (childLoc.getLine() <= lineno && childLoc.getEndLine() >= lineno) {
					// This child is a better match for that line number
					IProgramElement evenCloserMatch = findCloserMatchForLineNumber(child, lineno);
					if (evenCloserMatch == null) {
						return child;
					} else {
						return evenCloserMatch;
					}
				} else if (child.getKind().isType()) { // types are a bit clueless about where they are... do other nodes have
					// similar problems??
					IProgramElement evenCloserMatch = findCloserMatchForLineNumber(child, lineno);
					if (evenCloserMatch != null) {
						return evenCloserMatch;
					}
				}
			}
		}
		return null;
	}
================= fetch private boolean mungeNewConstructor(BcelClassWeaver weaver, NewConstructorTypeMu 2f36e7f^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java

private boolean mungeNewConstructor(BcelClassWeaver weaver, NewConstructorTypeMunger newConstructorTypeMunger) {

		final LazyClassGen currentClass = weaver.getLazyClassGen();
		final InstructionFactory fact = currentClass.getFactory();

		ResolvedMember newConstructorMember = newConstructorTypeMunger.getSyntheticConstructor();
		ResolvedType onType = newConstructorMember.getDeclaringType().resolve(weaver.getWorld());
		if (onType.isRawType())
			onType = onType.getGenericType();

		if (onType.isAnnotation()) {
			signalError(WeaverMessages.ITDC_ON_ANNOTATION_NOT_ALLOWED, weaver, onType);
			return false;
		}

		if (onType.isEnum()) {
			signalError(WeaverMessages.ITDC_ON_ENUM_NOT_ALLOWED, weaver, onType);
			return false;
		}

		if (!onType.equals(currentClass.getType()))
			return false;

		ResolvedMember explicitConstructor = newConstructorTypeMunger.getExplicitConstructor();
		// int declaredParameterCount =
		// newConstructorTypeMunger.getDeclaredParameterCount();
		LazyMethodGen mg = makeMethodGen(currentClass, newConstructorMember);
		mg.setEffectiveSignature(newConstructorTypeMunger.getSignature(), Shadow.ConstructorExecution, true);

		// pr98901
		// For copying the annotations across, we have to discover the real
		// member in the aspect
		// which is holding them.
		if (weaver.getWorld().isInJava5Mode()) {

			ResolvedMember interMethodDispatcher = AjcMemberMaker.postIntroducedConstructor(aspectType, onType,
					newConstructorTypeMunger.getSignature().getParameterTypes());
			AnnotationAJ annotationsOnRealMember[] = null;
			ResolvedMember realMember = getRealMemberForITDFromAspect(aspectType, interMethodDispatcher, true);
			if (realMember == null)
				throw new BCException("Couldn't find ITD holder member '" + interMethodDispatcher + "' on aspect " + aspectType);
			annotationsOnRealMember = realMember.getAnnotations();
			if (annotationsOnRealMember != null) {
				for (int i = 0; i < annotationsOnRealMember.length; i++) {
					AnnotationAJ annotationX = annotationsOnRealMember[i];
					AnnotationGen a = ((BcelAnnotation) annotationX).getBcelAnnotation();
					AnnotationGen ag = new AnnotationGen(a, weaver.getLazyClassGen().getConstantPool(), true);
					mg.addAnnotation(new BcelAnnotation(ag, weaver.getWorld()));
				}
			}
			// the below loop fixes the very special (and very stupid)
			// case where an aspect declares an annotation
			// on an ITD it declared on itself.
			List allDecams = weaver.getWorld().getDeclareAnnotationOnMethods();
			for (Iterator i = allDecams.iterator(); i.hasNext();) {
				DeclareAnnotation decaMC = (DeclareAnnotation) i.next();
				if (decaMC.matches(explicitConstructor, weaver.getWorld()) && mg.getEnclosingClass().getType() == aspectType) {
					mg.addAnnotation(decaMC.getAnnotationX());
				}
			}
		}

		currentClass.addMethodGen(mg);
		// weaver.addLazyMethodGen(freshConstructor);

		InstructionList body = mg.getBody();

		// add to body: push arts for call to pre, from actual args starting at
		// 1 (skipping this), going to
		// declared argcount + 1
		UnresolvedType[] declaredParams = newConstructorTypeMunger.getSignature().getParameterTypes();
		Type[] paramTypes = mg.getArgumentTypes();
		int frameIndex = 1;
		for (int i = 0, len = declaredParams.length; i < len; i++) {
			body.append(InstructionFactory.createLoad(paramTypes[i], frameIndex));
			frameIndex += paramTypes[i].getSize();
		}
		// do call to pre
		Member preMethod = AjcMemberMaker.preIntroducedConstructor(aspectType, onType, declaredParams);
		body.append(Utility.createInvoke(fact, null, preMethod));

		// create a local, and store return pre stuff into it.
		int arraySlot = mg.allocateLocal(1);
		body.append(InstructionFactory.createStore(Type.OBJECT, arraySlot));

		// put this on the stack
		body.append(InstructionConstants.ALOAD_0);

		// unpack pre args onto stack
		UnresolvedType[] superParamTypes = explicitConstructor.getParameterTypes();

		for (int i = 0, len = superParamTypes.length; i < len; i++) {
			body.append(InstructionFactory.createLoad(Type.OBJECT, arraySlot));
			body.append(Utility.createConstant(fact, i));
			body.append(InstructionFactory.createArrayLoad(Type.OBJECT));
			body.append(Utility.createConversion(fact, Type.OBJECT, BcelWorld.makeBcelType(superParamTypes[i])));
		}

		// call super/this

		body.append(Utility.createInvoke(fact, null, explicitConstructor));

		// put this back on the stack

		body.append(InstructionConstants.ALOAD_0);

		// unpack params onto stack
		Member postMethod = AjcMemberMaker.postIntroducedConstructor(aspectType, onType, declaredParams);
		UnresolvedType[] postParamTypes = postMethod.getParameterTypes();

		for (int i = 1, len = postParamTypes.length; i < len; i++) {
			body.append(InstructionFactory.createLoad(Type.OBJECT, arraySlot));
			body.append(Utility.createConstant(fact, superParamTypes.length + i - 1));
			body.append(InstructionFactory.createArrayLoad(Type.OBJECT));
			body.append(Utility.createConversion(fact, Type.OBJECT, BcelWorld.makeBcelType(postParamTypes[i])));
		}

		// call post
		body.append(Utility.createInvoke(fact, null, postMethod));

		// don't forget to return!!
		body.append(InstructionConstants.RETURN);

		return true;
	}
================= fetch private boolean mungeNewField(BcelClassWeaver weaver, NewFieldTypeMunger munger) 2f36e7f^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java

private boolean mungeNewField(BcelClassWeaver weaver, NewFieldTypeMunger munger) {
		/* ResolvedMember initMethod = */munger.getInitMethod(aspectType);
		LazyClassGen gen = weaver.getLazyClassGen();
		ResolvedMember field = munger.getSignature();

		ResolvedType onType = weaver.getWorld().resolve(field.getDeclaringType(), munger.getSourceLocation());
		if (onType.isRawType())
			onType = onType.getGenericType();

		boolean onInterface = onType.isInterface();

		if (onType.isAnnotation()) {
			signalError(WeaverMessages.ITDF_ON_ANNOTATION_NOT_ALLOWED, weaver, onType);
			return false;
		}

		if (onType.isEnum()) {
			signalError(WeaverMessages.ITDF_ON_ENUM_NOT_ALLOWED, weaver, onType);
			return false;
		}

		ResolvedMember interMethodBody = munger.getInitMethod(aspectType);

		AnnotationAJ annotationsOnRealMember[] = null;
		// pr98901
		// For copying the annotations across, we have to discover the real
		// member in the aspect
		// which is holding them.
		if (weaver.getWorld().isInJava5Mode()) {
			// the below line just gets the method with the same name in
			// aspectType.getDeclaredMethods();
			ResolvedType toLookOn = aspectType;
			if (aspectType.isRawType())
				toLookOn = aspectType.getGenericType();
			ResolvedMember realMember = getRealMemberForITDFromAspect(toLookOn, interMethodBody, false);
			if (realMember == null)
				throw new BCException("Couldn't find ITD init member '" + interMethodBody + "' on aspect " + aspectType);
			annotationsOnRealMember = realMember.getAnnotations();
		}

		if (onType.equals(gen.getType())) {
			if (onInterface) {
				ResolvedMember itdfieldGetter = AjcMemberMaker.interFieldInterfaceGetter(field, onType, aspectType);
				LazyMethodGen mg = makeMethodGen(gen, itdfieldGetter);
				gen.addMethodGen(mg);

				LazyMethodGen mg1 = makeMethodGen(gen, AjcMemberMaker.interFieldInterfaceSetter(field, onType, aspectType));
				gen.addMethodGen(mg1);
			} else {
				weaver.addInitializer(this);
				FieldGen fg = makeFieldGen(gen, AjcMemberMaker.interFieldClassField(field, aspectType));

				if (annotationsOnRealMember != null) {
					for (int i = 0; i < annotationsOnRealMember.length; i++) {
						AnnotationAJ annotationX = annotationsOnRealMember[i];
						AnnotationGen a = ((BcelAnnotation) annotationX).getBcelAnnotation();
						AnnotationGen ag = new AnnotationGen(a, weaver.getLazyClassGen().getConstantPool(), true);
						fg.addAnnotation(ag);
					}
				}

				if (weaver.getWorld().isInJava5Mode()) {
					String basicSignature = field.getSignature();
					String genericSignature = field.getReturnType().resolve(weaver.getWorld()).getSignatureForAttribute();
					// String genericSignature =
					// ((ResolvedMemberImpl)field).getSignatureForAttribute();
					if (!basicSignature.equals(genericSignature)) {
						// Add a signature attribute to it
						fg.addAttribute(createSignatureAttribute(gen.getConstantPool(), genericSignature));
					}
				}
				gen.addField(fg, getSourceLocation());

			}
			return true;
		} else if (onInterface && gen.getType().isTopmostImplementor(onType)) {
			// wew know that we can't be static since we don't allow statics on
			// interfaces
			if (field.isStatic())
				throw new RuntimeException("unimplemented");
			weaver.addInitializer(this);
			// System.err.println("impl body on " + gen.getType() + " for " +
			// munger);

			Type fieldType = BcelWorld.makeBcelType(field.getType());

			FieldGen fg = makeFieldGen(gen, AjcMemberMaker.interFieldInterfaceField(field, onType, aspectType));

			if (annotationsOnRealMember != null) {
				for (int i = 0; i < annotationsOnRealMember.length; i++) {
					AnnotationAJ annotationX = annotationsOnRealMember[i];
					AnnotationGen a = ((BcelAnnotation) annotationX).getBcelAnnotation();
					AnnotationGen ag = new AnnotationGen(a, weaver.getLazyClassGen().getConstantPool(), true);
					fg.addAnnotation(ag);
				}
			}

			gen.addField(fg, getSourceLocation());
			// this uses a shadow munger to add init method to constructors
			// weaver.getShadowMungers().add(makeInitCallShadowMunger(initMethod)
			// );

			ResolvedMember itdfieldGetter = AjcMemberMaker.interFieldInterfaceGetter(field, gen.getType()/* onType */, aspectType);
			LazyMethodGen mg = makeMethodGen(gen, itdfieldGetter);
			InstructionList il = new InstructionList();
			InstructionFactory fact = gen.getFactory();
			if (field.isStatic()) {
				il.append(fact.createFieldAccess(gen.getClassName(), fg.getName(), fieldType, Constants.GETSTATIC));
			} else {
				il.append(InstructionConstants.ALOAD_0);
				il.append(fact.createFieldAccess(gen.getClassName(), fg.getName(), fieldType, Constants.GETFIELD));
			}
			il.append(InstructionFactory.createReturn(fieldType));
			mg.getBody().insert(il);

			gen.addMethodGen(mg);

			// Check if we need bridge methods for the field getter and setter
			if (munger.getDeclaredSignature() != null) { // is this munger a
				// parameterized
				// form of some
				// original munger?
				ResolvedMember toBridgeTo = munger.getDeclaredSignature().parameterizedWith(null,
						munger.getSignature().getDeclaringType().resolve(getWorld()), false, munger.getTypeVariableAliases());
				boolean needsbridging = false;
				if (!toBridgeTo.getReturnType().getErasureSignature().equals(
						munger.getSignature().getReturnType().getErasureSignature()))
					needsbridging = true;
				if (needsbridging) {
					ResolvedMember bridgingGetter = AjcMemberMaker.interFieldInterfaceGetter(toBridgeTo, gen.getType(), aspectType);
					createBridgeMethodForITDF(weaver, gen, itdfieldGetter, bridgingGetter);
				}
			}

			ResolvedMember itdfieldSetter = AjcMemberMaker.interFieldInterfaceSetter(field, gen.getType(), aspectType);
			LazyMethodGen mg1 = makeMethodGen(gen, itdfieldSetter);
			InstructionList il1 = new InstructionList();
			if (field.isStatic()) {
				il1.append(InstructionFactory.createLoad(fieldType, 0));
				il1.append(fact.createFieldAccess(gen.getClassName(), fg.getName(), fieldType, Constants.PUTSTATIC));
			} else {
				il1.append(InstructionConstants.ALOAD_0);
				il1.append(InstructionFactory.createLoad(fieldType, 1));
				il1.append(fact.createFieldAccess(gen.getClassName(), fg.getName(), fieldType, Constants.PUTFIELD));
			}
			il1.append(InstructionFactory.createReturn(Type.VOID));
			mg1.getBody().insert(il1);

			gen.addMethodGen(mg1);

			if (munger.getDeclaredSignature() != null) {
				ResolvedMember toBridgeTo = munger.getDeclaredSignature().parameterizedWith(null,
						munger.getSignature().getDeclaringType().resolve(getWorld()), false, munger.getTypeVariableAliases());
				boolean needsbridging = false;
				if (!toBridgeTo.getReturnType().getErasureSignature().equals(
						munger.getSignature().getReturnType().getErasureSignature())) {
					needsbridging = true;
				}
				if (needsbridging) {
					ResolvedMember bridgingSetter = AjcMemberMaker.interFieldInterfaceSetter(toBridgeTo, gen.getType(), aspectType);
					createBridgeMethodForITDF(weaver, gen, itdfieldSetter, bridgingSetter);
				}
			}

			return true;
		} else {
			return false;
		}
	}
================= fetch private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge 2f36e7f^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java

private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munger) {
		World w = weaver.getWorld();
		// Resolving it will sort out the tvars
		ResolvedMember unMangledInterMethod = munger.getSignature().resolve(w);
		// do matching on the unMangled one, but actually add them to the
		// mangled method
		ResolvedMember interMethodBody = munger.getDeclaredInterMethodBody(aspectType, w);
		ResolvedMember interMethodDispatcher = munger.getDeclaredInterMethodDispatcher(aspectType, w);
		ResolvedMember memberHoldingAnyAnnotations = interMethodDispatcher;
		ResolvedType onType = weaver.getWorld().resolve(unMangledInterMethod.getDeclaringType(), munger.getSourceLocation());
		LazyClassGen gen = weaver.getLazyClassGen();
		boolean mungingInterface = gen.isInterface();

		if (onType.isRawType())
			onType = onType.getGenericType();

		boolean onInterface = onType.isInterface();

		// Simple checks, can't ITD on annotations or enums
		if (onType.isAnnotation()) {
			signalError(WeaverMessages.ITDM_ON_ANNOTATION_NOT_ALLOWED, weaver, onType);
			return false;
		}

		if (onType.isEnum()) {
			signalError(WeaverMessages.ITDM_ON_ENUM_NOT_ALLOWED, weaver, onType);
			return false;
		}

		if (onInterface && gen.getLazyMethodGen(unMangledInterMethod.getName(), unMangledInterMethod.getSignature(), true) != null) {
			// this is ok, we could be providing the default implementation of a
			// method
			// that the target has already declared
			return false;
		}

		// If we are processing the intended ITD target type (might be an
		// interface)
		if (onType.equals(gen.getType())) {
			ResolvedMember mangledInterMethod = AjcMemberMaker.interMethod(unMangledInterMethod, aspectType, onInterface);

			LazyMethodGen newMethod = makeMethodGen(gen, mangledInterMethod);
			if (mungingInterface) {
				// we want the modifiers of the ITD to be used for all
				// *implementors* of the
				// interface, but the method itself we add to the interface must
				// be public abstract
				newMethod.setAccessFlags(Modifier.PUBLIC | Modifier.ABSTRACT);
			}

			// pr98901
			// For copying the annotations across, we have to discover the real
			// member in the aspect which is holding them.
			if (weaver.getWorld().isInJava5Mode()) {
				AnnotationAJ annotationsOnRealMember[] = null;
				ResolvedType toLookOn = aspectType;
				if (aspectType.isRawType())
					toLookOn = aspectType.getGenericType();
				ResolvedMember realMember = getRealMemberForITDFromAspect(toLookOn, memberHoldingAnyAnnotations, false);
				if (realMember == null)
					throw new BCException("Couldn't find ITD holder member '" + memberHoldingAnyAnnotations + "' on aspect "
							+ aspectType);
				annotationsOnRealMember = realMember.getAnnotations();

				if (annotationsOnRealMember != null) {
					for (int i = 0; i < annotationsOnRealMember.length; i++) {
						AnnotationAJ annotationX = annotationsOnRealMember[i];
						AnnotationGen a = ((BcelAnnotation) annotationX).getBcelAnnotation();
						AnnotationGen ag = new AnnotationGen(a, weaver.getLazyClassGen().getConstantPool(), true);
						newMethod.addAnnotation(new BcelAnnotation(ag, weaver.getWorld()));
					}
				}
				AnnotationAJ[][] pAnnos = realMember.getParameterAnnotations();
				int offset = newMethod.isStatic() ? 0 : 1;
				if (pAnnos != null && pAnnos.length != 0) {
					int param = 0;
					for (int i = offset; i < pAnnos.length; i++) {
						AnnotationAJ[] annosOnParam = pAnnos[i];
						if (annosOnParam != null && annosOnParam.length > 0) {
							for (int j = 0; j < annosOnParam.length; j++) {
								newMethod.addParameterAnnotation(param, annosOnParam[j]);
							}
						}
						param++;
					}
				}
				// the below loop fixes the very special (and very stupid)
				// case where an aspect declares an annotation
				// on an ITD it declared on itself.
				List allDecams = weaver.getWorld().getDeclareAnnotationOnMethods();
				for (Iterator i = allDecams.iterator(); i.hasNext();) {
					DeclareAnnotation decaMC = (DeclareAnnotation) i.next();
					if (decaMC.matches(unMangledInterMethod, weaver.getWorld())
							&& newMethod.getEnclosingClass().getType() == aspectType) {
						newMethod.addAnnotation(decaMC.getAnnotationX());
					}
				}
			}

			// If it doesn't target an interface and there is a body (i.e. it
			// isnt abstract)
			if (!onInterface && !Modifier.isAbstract(mangledInterMethod.getModifiers())) {
				InstructionList body = newMethod.getBody();
				InstructionFactory fact = gen.getFactory();
				int pos = 0;

				if (!unMangledInterMethod.isStatic()) {
					body.append(InstructionFactory.createThis());
					pos++;
				}
				Type[] paramTypes = BcelWorld.makeBcelTypes(mangledInterMethod.getParameterTypes());
				for (int i = 0, len = paramTypes.length; i < len; i++) {
					Type paramType = paramTypes[i];
					body.append(InstructionFactory.createLoad(paramType, pos));
					pos += paramType.getSize();
				}
				body.append(Utility.createInvoke(fact, weaver.getWorld(), interMethodBody));
				body.append(InstructionFactory.createReturn(BcelWorld.makeBcelType(mangledInterMethod.getReturnType())));

				if (weaver.getWorld().isInJava5Mode()) { // Don't need bridge
					// methods if not in
					// 1.5 mode.
					createAnyBridgeMethodsForCovariance(weaver, munger, unMangledInterMethod, onType, gen, paramTypes);
				}

			} else {
				// ??? this is okay
				// if (!(mg.getBody() == null)) throw new
				// RuntimeException("bas");
			}

			if (weaver.getWorld().isInJava5Mode()) {
				String basicSignature = mangledInterMethod.getSignature();
				String genericSignature = ((ResolvedMemberImpl) mangledInterMethod).getSignatureForAttribute();
				if (!basicSignature.equals(genericSignature)) {
					// Add a signature attribute to it
					newMethod.addAttribute(createSignatureAttribute(gen.getConstantPool(), genericSignature));
				}
			}
			// XXX make sure to check that we set exceptions properly on this
			// guy.
			weaver.addLazyMethodGen(newMethod);
			weaver.getLazyClassGen().warnOnAddedMethod(newMethod.getMethod(), getSignature().getSourceLocation());

			addNeededSuperCallMethods(weaver, onType, munger.getSuperMethodsCalled());

			return true;

		} else if (onInterface && !Modifier.isAbstract(unMangledInterMethod.getModifiers())) {

			// This means the 'gen' should be the top most implementor
			// - if it is *not* then something went wrong after we worked
			// out that it was the top most implementor (see pr49657)
			if (!gen.getType().isTopmostImplementor(onType)) {
				ResolvedType rtx = gen.getType().getTopmostImplementor(onType);
				if (!rtx.isExposedToWeaver()) {
					ISourceLocation sLoc = munger.getSourceLocation();
					weaver.getWorld().getMessageHandler().handleMessage(
							MessageUtil.error(WeaverMessages.format(WeaverMessages.ITD_NON_EXPOSED_IMPLEMENTOR, rtx,
									getAspectType().getName()), (sLoc == null ? getAspectType().getSourceLocation() : sLoc)));
				} else {
					// XXX what does this state mean?
					// We have incorrectly identified what is the top most
					// implementor and its not because
					// a type wasn't exposed to the weaver
				}
				return false;
			} else {

				ResolvedMember mangledInterMethod = AjcMemberMaker.interMethod(unMangledInterMethod, aspectType, false);

				LazyMethodGen mg = makeMethodGen(gen, mangledInterMethod);

				// From 98901#29 - need to copy annotations across
				if (weaver.getWorld().isInJava5Mode()) {
					AnnotationAJ annotationsOnRealMember[] = null;
					ResolvedType toLookOn = aspectType;
					if (aspectType.isRawType())
						toLookOn = aspectType.getGenericType();
					ResolvedMember realMember = getRealMemberForITDFromAspect(toLookOn, memberHoldingAnyAnnotations, false);
					if (realMember == null)
						throw new BCException("Couldn't find ITD holder member '" + memberHoldingAnyAnnotations + "' on aspect "
								+ aspectType);
					annotationsOnRealMember = realMember.getAnnotations();

					if (annotationsOnRealMember != null) {
						for (int i = 0; i < annotationsOnRealMember.length; i++) {
							AnnotationAJ annotationX = annotationsOnRealMember[i];
							AnnotationGen a = ((BcelAnnotation) annotationX).getBcelAnnotation();
							AnnotationGen ag = new AnnotationGen(a, weaver.getLazyClassGen().getConstantPool(), true);
							mg.addAnnotation(new BcelAnnotation(ag, weaver.getWorld()));
						}
					}

					AnnotationAJ[][] pAnnos = realMember.getParameterAnnotations();
					int offset = mg.isStatic() ? 0 : 1;
					if (pAnnos != null && pAnnos.length != 0) {
						int param = 0;
						for (int i = offset; i < pAnnos.length; i++) {
							AnnotationAJ[] annosOnParam = pAnnos[i];
							if (annosOnParam != null && annosOnParam.length > 0) {
								for (int j = 0; j < annosOnParam.length; j++) {
									mg.addParameterAnnotation(param, annosOnParam[j]);
								}
							}
							param++;
						}
					}
				}

				if (mungingInterface) {
					// we want the modifiers of the ITD to be used for all
					// *implementors* of the
					// interface, but the method itself we add to the interface
					// must be public abstract
					mg.setAccessFlags(Modifier.PUBLIC | Modifier.ABSTRACT);
				}

				Type[] paramTypes = BcelWorld.makeBcelTypes(mangledInterMethod.getParameterTypes());
				Type returnType = BcelWorld.makeBcelType(mangledInterMethod.getReturnType());

				InstructionList body = mg.getBody();
				InstructionFactory fact = gen.getFactory();
				int pos = 0;

				if (!mangledInterMethod.isStatic()) {
					body.append(InstructionFactory.createThis());
					pos++;
				}
				for (int i = 0, len = paramTypes.length; i < len; i++) {
					Type paramType = paramTypes[i];
					body.append(InstructionFactory.createLoad(paramType, pos));
					pos += paramType.getSize();
				}

				body.append(Utility.createInvoke(fact, weaver.getWorld(), interMethodBody));
				Type t = BcelWorld.makeBcelType(interMethodBody.getReturnType());
				if (!t.equals(returnType)) {
					body.append(fact.createCast(t, returnType));
				}
				body.append(InstructionFactory.createReturn(returnType));
				mg.definingType = onType;

				if (weaver.getWorld().isInJava5Mode()) {
					String basicSignature = mangledInterMethod.getSignature();
					String genericSignature = ((ResolvedMemberImpl) mangledInterMethod).getSignatureForAttribute();
					if (!basicSignature.equals(genericSignature)) {
						// Add a signature attribute to it
						mg.addAttribute(createSignatureAttribute(gen.getConstantPool(), genericSignature));
					}
				}

				weaver.addOrReplaceLazyMethodGen(mg);

				addNeededSuperCallMethods(weaver, onType, munger.getSuperMethodsCalled());

				// Work out if we need a bridge method for the new method added
				// to the topmostimplementor.
				if (munger.getDeclaredSignature() != null) { // Check if the
					// munger being
					// processed is
					// a
					// parameterized
					// form of some
					// original
					// munger.
					boolean needsbridging = false;
					ResolvedMember toBridgeTo = munger.getDeclaredSignature().parameterizedWith(null,
							munger.getSignature().getDeclaringType().resolve(getWorld()), false, munger.getTypeVariableAliases());
					if (!toBridgeTo.getReturnType().getErasureSignature().equals(
							munger.getSignature().getReturnType().getErasureSignature()))
						needsbridging = true;
					UnresolvedType[] originalParams = toBridgeTo.getParameterTypes();
					UnresolvedType[] newParams = munger.getSignature().getParameterTypes();
					for (int ii = 0; ii < originalParams.length; ii++) {
						if (!originalParams[ii].getErasureSignature().equals(newParams[ii].getErasureSignature()))
							needsbridging = true;
					}
					if (needsbridging) {
						ResolvedMember bridgerMethod = AjcMemberMaker.bridgerToInterMethod(unMangledInterMethod, gen.getType());
						ResolvedMember bridgingSetter = AjcMemberMaker.interMethodBridger(toBridgeTo, aspectType, false); // pr250493

						// FIXME asc ----------------8<---------------- extract
						// method
						LazyMethodGen bridgeMethod = makeMethodGen(gen, bridgingSetter);
						paramTypes = BcelWorld.makeBcelTypes(bridgingSetter.getParameterTypes());
						Type[] bridgingToParms = BcelWorld.makeBcelTypes(unMangledInterMethod.getParameterTypes());
						returnType = BcelWorld.makeBcelType(bridgingSetter.getReturnType());
						body = bridgeMethod.getBody();
						fact = gen.getFactory();
						pos = 0;

						if (!bridgingSetter.isStatic()) {
							body.append(InstructionFactory.createThis());
							pos++;
						}
						for (int i = 0, len = paramTypes.length; i < len; i++) {
							Type paramType = paramTypes[i];
							body.append(InstructionFactory.createLoad(paramType, pos));
							if (!bridgingSetter.getParameterTypes()[i].getErasureSignature().equals(
									unMangledInterMethod.getParameterTypes()[i].getErasureSignature())) {
								// System.err.println("Putting in cast from "+
								// paramType+" to "+bridgingToParms[i]);
								body.append(fact.createCast(paramType, bridgingToParms[i]));
							}
							pos += paramType.getSize();
						}

						body.append(Utility.createInvoke(fact, weaver.getWorld(), bridgerMethod));
						body.append(InstructionFactory.createReturn(returnType));
						gen.addMethodGen(bridgeMethod);
						// mg.definingType = onType;
						// FIXME asc (see above)
						// ---------------------8<--------------- extract method
					}

				}

				return true;
			}
		} else {
			return false;
		}
	}
================= fetch private void signalError(String msgid, BcelClassWeaver weaver, UnresolvedType on 2f36e7f^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java

private void signalError(String msgid, BcelClassWeaver weaver, UnresolvedType onType) {
		IMessage msg = MessageUtil.error(WeaverMessages.format(msgid, onType.getName()), getSourceLocation());
		weaver.getWorld().getMessageHandler().handleMessage(msg);
	}
================= fetch private File getBinaryFile() { 9f80317^:org.aspectj.matcher/src/org/aspectj/weaver/ShadowMunger.java
/**
	 * Returns the File with pathname to the class file, for example either C:\temp
	 * \ajcSandbox\workspace\ajcTest16957.tmp\simple.jar!pkg\BinaryAspect.class if the class file is in a jar file, or
	 * C:\temp\ajcSandbox\workspace\ajcTest16957.tmp!pkg\BinaryAspect.class if the class file is in a directory
	 */
private File getBinaryFile() {
		if (binaryFile == null) {
			String s = getDeclaringType().getBinaryPath();
			File f = getDeclaringType().getSourceLocation().getSourceFile();
			int i = f.getPath().lastIndexOf('.');
			String path = f.getPath().substring(0, i) + ".class";
			binaryFile = new File(s + "!" + path);
		}
		return binaryFile;
	}
================= fetch public String createHandleIdentifier(IProgramElement ipe) { 0af658e^:asm/src/org/aspectj/asm/internal/JDTLikeHandleProvider.java

public String createHandleIdentifier(IProgramElement ipe) {

		// AjBuildManager.setupModel --> top of the tree is either
		// <root> or the .lst file
		if (ipe == null || (ipe.getKind().equals(IProgramElement.Kind.FILE_JAVA) && ipe.getName().equals("<root>"))) {
			return "";
		} else if (ipe.getHandleIdentifier(false) != null) {
			// have already created the handle for this ipe
			// therefore just return it
			return ipe.getHandleIdentifier();
		} else if (ipe.getKind().equals(IProgramElement.Kind.FILE_LST)) {
			String configFile = asm.getHierarchy().getConfigFile();
			int start = configFile.lastIndexOf(File.separator);
			int end = configFile.lastIndexOf(".lst");
			if (end != -1) {
				configFile = configFile.substring(start + 1, end);
			} else {
				configFile = new StringBuffer("=").append(configFile.substring(start + 1)).toString();
			}
			ipe.setHandleIdentifier(configFile);
			return configFile;
		} else if (ipe.getKind() == IProgramElement.Kind.SOURCE_FOLDER) {
			StringBuffer sb = new StringBuffer();
			sb.append(createHandleIdentifier(ipe.getParent())).append("/");
			// pr249216 - escape any embedded slashes
			String folder = ipe.getName();
			if (folder.indexOf("/") != -1) {
				folder = folder.replace("/", "\\/");
			}
			sb.append(folder);
			String handle = sb.toString();
			ipe.setHandleIdentifier(handle);
			return handle;
		}
		IProgramElement parent = ipe.getParent();
		if (parent != null && parent.getKind().equals(IProgramElement.Kind.IMPORT_REFERENCE)) {
			// want to miss out '#import declaration' in the handle
			parent = ipe.getParent().getParent();
		}

		StringBuffer handle = new StringBuffer();
		// add the handle for the parent
		handle.append(createHandleIdentifier(parent));
		// add the correct delimiter for this ipe
		handle.append(HandleProviderDelimiter.getDelimiter(ipe));
		// add the name and any parameters unless we're an initializer
		// (initializer's names are '...')
		if (!ipe.getKind().equals(IProgramElement.Kind.INITIALIZER)) {
			if (ipe.getKind() == IProgramElement.Kind.CLASS && ipe.getName().endsWith("{..}")) {
				// format: 'new Runnable() {..}' but its anon-y-mouse
				// dont append anything, there may be a count to follow though (!<n>)
			} else {
				if (ipe.getKind() == IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR) {
					handle.append(ipe.getName()).append("_new").append(getParameters(ipe));
				} else {
					// if (ipe.getKind() == IProgramElement.Kind.PACKAGE && ipe.getName().equals("DEFAULT")) {
					// // the delimiter will be in there, but skip the word DEFAULT as it is just a placeholder
					// } else {
					if (ipe.getKind().isDeclareAnnotation()) {
						// escape the @ (pr249216c9)
						handle.append("declare \\@").append(ipe.getName().substring(9)).append(getParameters(ipe));
					} else {
						handle.append(ipe.getName()).append(getParameters(ipe));
					}
				}
				// }
			}
		}
		// add the count, for example '!2' if its the second ipe of its
		// kind in the aspect
		handle.append(getCount(ipe));

		ipe.setHandleIdentifier(handle.toString());
		return handle.toString();
	}
================= fetch private LazyClassGen weave(UnwovenClassFile classFile, BcelObjectType classType, 1b54b4b^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java

private LazyClassGen weave(UnwovenClassFile classFile, BcelObjectType classType, boolean dump) throws IOException {
		if (classType.isSynthetic()) { // Don't touch synthetic classes
			if (dump)
				dumpUnchanged(classFile);
			return null;
		}

		List shadowMungers = fastMatch(shadowMungerList, classType.getResolvedTypeX());
		List typeMungers = classType.getResolvedTypeX().getInterTypeMungers();

		classType.getResolvedTypeX().checkInterTypeMungers();

		// Decide if we need to do actual weaving for this class
		boolean mightNeedToWeave = shadowMungers.size() > 0 || typeMungers.size() > 0 || classType.isAspect()
				|| world.getDeclareAnnotationOnMethods().size() > 0 || world.getDeclareAnnotationOnFields().size() > 0;

		// May need bridge methods if on 1.5 and something in our hierarchy is
		// affected by ITDs
		boolean mightNeedBridgeMethods = world.isInJava5Mode() && !classType.isInterface()
				&& classType.getResolvedTypeX().getInterTypeMungersIncludingSupers().size() > 0;

		LazyClassGen clazz = null;
		if (mightNeedToWeave || mightNeedBridgeMethods) {
			clazz = classType.getLazyClassGen();
			// System.err.println("got lazy gen: " + clazz + ", " +
			// clazz.getWeaverState());
			try {
				boolean isChanged = false;

				if (mightNeedToWeave)
					isChanged = BcelClassWeaver.weave(world, clazz, shadowMungers, typeMungers, lateTypeMungerList);

				if (mightNeedBridgeMethods)
					isChanged = BcelClassWeaver.calculateAnyRequiredBridgeMethods(world, clazz) || isChanged;

				if (isChanged) {
					if (dump)
						dump(classFile, clazz);
					return clazz;
				}
			} catch (RuntimeException re) {
				String classDebugInfo = null;
				try {
					classDebugInfo = clazz.toLongString();
				} catch (Exception e) {
					// recover from crash whilst producing debug string
					classDebugInfo = clazz.getClassName();
				}
				String messageText = "trouble in: \n" + classDebugInfo;
				getWorld().getMessageHandler().handleMessage(new Message(messageText, IMessage.ABORT, re, null));
			} catch (Error re) {
				String classDebugInfo = null;
				try {
					classDebugInfo = clazz.toLongString();
				} catch (Exception e) {
					// recover from crash whilst producing debug string
					classDebugInfo = clazz.getClassName();
				}
				String messageText = "trouble in: \n" + classDebugInfo;
				getWorld().getMessageHandler().handleMessage(new Message(messageText, IMessage.ABORT, re, null));
			}
		}

		// this is very odd return behavior trying to keep everyone happy
		if (dump) {
			dumpUnchanged(classFile);
			return clazz;
		} else {
			// ATAJ: the class was not weaved, but since it gets there early it
			// may have new generated inner classes
			// attached to it to support LTW perX aspectOf support (see
			// BcelPerClauseAspectAdder)
			// that aggressively defines the inner <aspect>$mayHaveAspect
			// interface.
			if (clazz != null && !clazz.getChildClasses(world).isEmpty()) {
				return clazz;
			}
			return null;
		}
	}
================= fetch public BcelWorld getWorld() { 1b54b4b^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

public BcelWorld getWorld() {
		return world;
	}
================= fetch public boolean munge(BcelClassWeaver weaver) { 1b54b4b^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java

public boolean munge(BcelClassWeaver weaver) {
		ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.MUNGING_WITH, this);
		boolean changed = false;
		boolean worthReporting = true;

		if (munger.getKind() == ResolvedTypeMunger.Field) {
			changed = mungeNewField(weaver, (NewFieldTypeMunger) munger);
		} else if (munger.getKind() == ResolvedTypeMunger.Method) {
			changed = mungeNewMethod(weaver, (NewMethodTypeMunger) munger);
		} else if (munger.getKind() == ResolvedTypeMunger.MethodDelegate2) {
			changed = mungeMethodDelegate(weaver, (MethodDelegateTypeMunger) munger);
		} else if (munger.getKind() == ResolvedTypeMunger.FieldHost) {
			changed = mungeFieldHost(weaver, (MethodDelegateTypeMunger.FieldHostTypeMunger) munger);
		} else if (munger.getKind() == ResolvedTypeMunger.PerObjectInterface) {
			changed = mungePerObjectInterface(weaver, (PerObjectInterfaceTypeMunger) munger);
			worthReporting = false;
		} else if (munger.getKind() == ResolvedTypeMunger.PerTypeWithinInterface) {
			// PTWIMPL Transform the target type (add the aspect instance field)
			changed = mungePerTypeWithinTransformer(weaver);
			worthReporting = false;
		} else if (munger.getKind() == ResolvedTypeMunger.PrivilegedAccess) {
			changed = mungePrivilegedAccess(weaver, (PrivilegedAccessMunger) munger);
			worthReporting = false;
		} else if (munger.getKind() == ResolvedTypeMunger.Constructor) {
			changed = mungeNewConstructor(weaver, (NewConstructorTypeMunger) munger);
		} else if (munger.getKind() == ResolvedTypeMunger.Parent) {
			changed = mungeNewParent(weaver, (NewParentTypeMunger) munger);
		} else if (munger.getKind() == ResolvedTypeMunger.AnnotationOnType) {
			changed = mungeNewAnnotationOnType(weaver, (AnnotationOnTypeMunger) munger);
			worthReporting = false;
		} else {
			throw new RuntimeException("unimplemented");
		}

		if (changed && munger.changesPublicSignature()) {
			WeaverStateInfo info = weaver.getLazyClassGen().getOrCreateWeaverStateInfo(BcelClassWeaver.getReweavableMode());
			info.addConcreteMunger(this);
		}

		if (changed && worthReporting) {
			AsmRelationshipProvider.getDefault().addRelationship(((BcelWorld) getWorld()).getModelAsAsmManager(),
					weaver.getLazyClassGen().getType(), munger, getAspectType());
		}

		// TAG: WeavingMessage
		if (changed && worthReporting && munger != null && !weaver.getWorld().getMessageHandler().isIgnoring(IMessage.WEAVEINFO)) {
			String tName = weaver.getLazyClassGen().getType().getSourceLocation().getSourceFile().getName();
			if (tName.indexOf("no debug info available") != -1)
				tName = "no debug info available";
			else
				tName = getShortname(weaver.getLazyClassGen().getType().getSourceLocation().getSourceFile().getPath());
			String fName = getShortname(getAspectType().getSourceLocation().getSourceFile().getPath());
			if (munger.getKind().equals(ResolvedTypeMunger.Parent)) {
				// This message could come out of AjLookupEnvironment.addParent
				// if doing parents
				// munging at compile time only...
				NewParentTypeMunger parentTM = (NewParentTypeMunger) munger;
				if (parentTM.getNewParent().isInterface()) {
					weaver.getWorld().getMessageHandler().handleMessage(
							WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_DECLAREPARENTSIMPLEMENTS,
									new String[] { weaver.getLazyClassGen().getType().getName(), tName,
											parentTM.getNewParent().getName(), fName }, weaver.getLazyClassGen().getClassName(),
									getAspectType().getName()));
				} else {
					weaver.getWorld().getMessageHandler().handleMessage(
							WeaveMessage
									.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_DECLAREPARENTSEXTENDS, new String[] {
											weaver.getLazyClassGen().getType().getName(), tName, parentTM.getNewParent().getName(),
											fName }));
					// TAG: WeavingMessage DECLARE PARENTS: EXTENDS
					// reportDeclareParentsMessage(WeaveMessage.
					// WEAVEMESSAGE_DECLAREPARENTSEXTENDS,sourceType,parent);

				}
			} else if (munger.getKind().equals(ResolvedTypeMunger.FieldHost)) {
				// hidden
			} else {
				ResolvedMember declaredSig = munger.getSignature();
				// if (declaredSig==null) declaredSig= munger.getSignature();
				weaver.getWorld().getMessageHandler().handleMessage(
						WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_ITD, new String[] {
								weaver.getLazyClassGen().getType().getName(), tName, munger.getKind().toString().toLowerCase(),
								getAspectType().getName(), fName + ":'" + declaredSig + "'" }, weaver.getLazyClassGen()
								.getClassName(), getAspectType().getName()));
			}
		}

		CompilationAndWeavingContext.leavingPhase(tok);
		return changed;
	}
================= fetch public static boolean weave(BcelWorld world, LazyClassGen clazz, List shadowMung 1b54b4b^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

public static boolean weave(BcelWorld world, LazyClassGen clazz, List shadowMungers, List typeMungers, List lateTypeMungers) {
		boolean b = new BcelClassWeaver(world, clazz, shadowMungers, typeMungers, lateTypeMungers).weave();
		// System.out.println(clazz.getClassName() + ", " +
		// clazz.getType().getWeaverState());
		// clazz.print();
		return b;
	}
================= fetch public static void setReweavableMode(boolean mode) { 1b54b4b^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
// collect reweavable info
public static void setReweavableMode(boolean mode) {
		inReweavableMode = mode;
	}
================= fetch public void setReweavableMode(boolean xNotReweavable) { 1b54b4b^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java

public void setReweavableMode(boolean xNotReweavable) {
		if (trace.isTraceEnabled())
			trace.enter("setReweavableMode", this, xNotReweavable);
		inReweavableMode = !xNotReweavable;
		WeaverStateInfo.setReweavableModeDefaults(!xNotReweavable, false, true);
		BcelClassWeaver.setReweavableMode(!xNotReweavable);
		if (trace.isTraceEnabled())
			trace.exit("setReweavableMode");
	}
Progress : [###########-----------------------------] 29%================= fetch List extractArguments() { 1da1f7c^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
/**
     * Adjust args for size if necessary by creating
     * an argument file, which should be deleted by the client
     * after the compiler run has completed.
     * @param max the int maximum length of the command line (in char)
     * @return the temp File for the arguments (if generated), 
     *         for deletion when done.
     * @throws IllegalArgumentException if max is negative
     */
static String[] limitTo(String[] args, int max, 
        Location location) {       
        if (max < 0) {
            throw new IllegalArgumentException("negative max: " + max);
        }
        // sigh - have to count anyway for now
        int size = 0;
        for (int i = 0; (i < args.length) && (size < max); i++) {
            size += 1 + (null == args[i] ? 0 : args[i].length());    
        }
        if (size <= max) {
            return args;
        }
        File tmpFile = null;
        PrintWriter out = null;
        // adapted from DefaultCompilerAdapter.executeExternalCompile
        try {
            String userDirName = System.getProperty("user.dir");
            File userDir = new File(userDirName);
            tmpFile = File.createTempFile("argfile", "", userDir);
            out = new PrintWriter(new FileWriter(tmpFile));
            for (int i = 0; i < args.length; i++) {
                out.println(args[i]);
            }
            out.flush();
            return new String[] {"-argfile", tmpFile.getAbsolutePath()};
        } catch (IOException e) {
            throw new BuildException("Error creating temporary file", 
                                     e, location);
        } finally {
            if (out != null) {
                try {out.close();} catch (Throwable t) {}
            }
        }
    }
================= fetch String addOption(String prefix, String[] validOptions, String input) { 1da1f7c^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
/** @return null if added or ignoreString otherwise */
String addOption(String prefix, String[] validOptions, String input) {
        if (isEmpty(input)) {
            return null;
        }
        for (int i = 0; i < validOptions.length; i++) {
			if (input.equals(validOptions[i])) {
                if (isEmpty(prefix)) {
                    addFlag(input, true);
                } else {
                    addFlagged(prefix, input);
                }
                return null;
			}
		}
        return (null == prefix ? input : prefix + " " + input);
    }
================= fetch protected String validCommaList(String list, List valid, String label, int max) 1da1f7c^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java

protected String validCommaList(String list, List valid, String label, int max) {
    	StringBuffer result = new StringBuffer();
    	StringTokenizer st = new StringTokenizer(list, ",");
		int num = 0;
    	while (st.hasMoreTokens()) {
			String token = st.nextToken().trim();
			num++;
			if (num > max) {
				ignore("too many entries for -" 
					+ label 
					+ ": " 
					+ token); 
				break;
			}
			if (!valid.contains(token)) {
				ignore("bad commaList entry for -" 
					+ label 
					+ ": " 
					+ token); 
			} else {
				if (0 < result.length()) {
					result.append(",");
				}
				result.append(token);
			}
    	}
    	return (0 == result.length() ? null : result.toString());
    }
================= fetch protected int execInOtherVM(String[] args) { 1da1f7c^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
/**
     * Execute in another process using the same JDK
     * and the base directory of the project. XXX correct?
     * @param args
     * @return
     */
protected int execInOtherVM(String[] args) {
        try {			
			
            Project project = getProject();
			PumpStreamHandler handler = new LogStreamHandler(this,
					  verbose ? Project.MSG_VERBOSE : Project.MSG_INFO, 
					  Project.MSG_WARN);
		  
// replace above two lines with what follows as an aid to debugging when running the unit tests....
//            LogStreamHandler handler = new LogStreamHandler(this,
//                                 Project.MSG_INFO, Project.MSG_WARN) {
//
//            	ByteArrayOutputStream baos = new ByteArrayOutputStream();
//            	/* (non-Javadoc)
//				 * @see org.apache.tools.ant.taskdefs.PumpStreamHandler#createProcessOutputPump(java.io.InputStream, java.io.OutputStream)
//				 */
//				protected void createProcessErrorPump(InputStream is,
//						OutputStream os) {
//					super.createProcessErrorPump(is, baos);
//				}
//
//				/* (non-Javadoc)
//				 * @see org.apache.tools.ant.taskdefs.LogStreamHandler#stop()
//				 */
//				public void stop() {
//					byte[] written = baos.toByteArray();
//					System.err.print(new String(written));
//					super.stop();
//				}
//            };

			Execute exe = new Execute(handler);
            exe.setAntRun(project);
            exe.setWorkingDirectory(project.getBaseDir());
            exe.setCommandline(args);
            try {
                if (executingInOtherVM) {
                    String s = "already running in other vm?";
                    throw new BuildException(s, location);
                }
                executingInOtherVM = true;
                exe.execute();
            } finally {
                executingInOtherVM = false;
            }
            return exe.getExitValue();
        } catch (IOException e) {
            String m = "Error executing command " + Arrays.asList(args);
            throw new BuildException(m, e, location);
        }
    }
================= fetch protected void executeInSameVM(String[] args) { 1da1f7c^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
/**
     * Run the compile in the same VM by
     * loading the compiler (Main), 
     * setting up any message holders,
     * doing the compile,
     * and converting abort/failure and error messages
     * to BuildException, as appropriate.
     * @throws BuildException if abort or failure messages
     *         or if errors and failonerror.
     * 
     */
protected void executeInSameVM(String[] args) {
        if (null != maxMem) {
            log("maxMem ignored unless forked: " + maxMem, Project.MSG_WARN);
        }
        IMessageHolder holder = messageHolder;
        int numPreviousErrors;
        if (null == holder) {
            MessageHandler mhandler = new MessageHandler(true);
			final IMessageHandler delegate;
              delegate  = new AntMessageHandler(this.logger,this.verbose, false);
            mhandler.setInterceptor(delegate);
            holder = mhandler;
            numPreviousErrors = 0;
        } else {
            numPreviousErrors = holder.numMessages(IMessage.ERROR, true);
        }
        {
            Main newmain = new Main();
            newmain.setHolder(holder);
            newmain.setCompletionRunner(new Runnable() {
================= fetch public AjcTask() { 1da1f7c^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java

public String toString() {
            return "(no destination dir specified)";
        }
================= fetch public AntMessageHandler(TaskLogger logger, boolean taskVerbose, boolean handled 1da1f7c^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
/**
     * Adjust args for size if necessary by creating
     * an argument file, which should be deleted by the client
     * after the compiler run has completed.
     * @param max the int maximum length of the command line (in char)
     * @return the temp File for the arguments (if generated), 
     *         for deletion when done.
     * @throws IllegalArgumentException if max is negative
     */
static String[] limitTo(String[] args, int max, 
        Location location) {       
        if (max < 0) {
            throw new IllegalArgumentException("negative max: " + max);
        }
        // sigh - have to count anyway for now
        int size = 0;
        for (int i = 0; (i < args.length) && (size < max); i++) {
            size += 1 + (null == args[i] ? 0 : args[i].length());    
        }
        if (size <= max) {
            return args;
        }
        File tmpFile = null;
        PrintWriter out = null;
        // adapted from DefaultCompilerAdapter.executeExternalCompile
        try {
            String userDirName = System.getProperty("user.dir");
            File userDir = new File(userDirName);
            tmpFile = File.createTempFile("argfile", "", userDir);
            out = new PrintWriter(new FileWriter(tmpFile));
            for (int i = 0; i < args.length; i++) {
                out.println(args[i]);
            }
            out.flush();
            return new String[] {"-argfile", tmpFile.getAbsolutePath()};
        } catch (IOException e) {
            throw new BuildException("Error creating temporary file", 
                                     e, location);
        } finally {
            if (out != null) {
                try {out.close();} catch (Throwable t) {}
            }
        }
    }
================= fetch public String toString() { 1da1f7c^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java

private static File isAspectjtoolsjar(String path) {
        if (null == path) {
            return null;
        }
        final String prefix = "aspectj";        
        final String infix = "tools";        
        final String altInfix = "-tools";        
        final String suffix = ".jar";
        final int prefixLength = 7; // prefix.length();
        final int minLength = 16;
        // prefixLength + infix.length() + suffix.length();        
        if (!path.endsWith(suffix)) {
            return null;
        }
        int loc = path.lastIndexOf(prefix);
        if ((-1 != loc) && ((loc + minLength) <= path.length())) {
            String rest = path.substring(loc+prefixLength);
            if (-1 != rest.indexOf(File.pathSeparator)) {
                return null;
            }
            if (rest.startsWith(infix)
                || rest.startsWith(altInfix)) {
                File result = new File(path);
                if (result.canRead() && result.isFile()) {
                    return result;
                }
            }
        }        
        return null;
    }
================= fetch public boolean handleMessage(IMessage message) throws AbortException { 1da1f7c^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
/* (non-Javadoc)
	 * @see org.aspectj.bridge.IMessageHandler#handleMessage(org.aspectj.bridge.IMessage)
	 */
public boolean handleMessage(IMessage message) throws AbortException {
		Kind messageKind = message.getKind();
		String messageText = message.toString();
		if (messageKind == IMessage.ABORT) {
			this.logger.error(messageText);
		} else if (messageKind == IMessage.DEBUG) {
			this.logger.debug(messageText);
		} else if (messageKind == IMessage.ERROR) {
			this.logger.error(messageText);
		} else if (messageKind == IMessage.FAIL){
			this.logger.error(messageText);
		} else if (messageKind == IMessage.INFO) {
			if (this.taskLevelVerbose) {
				this.logger.info(messageText);
			}
			else {
				this.logger.verbose(messageText);				
			}
		} else if (messageKind == IMessage.WARNING) {
			this.logger.warning(messageText);
		} else if (messageKind == IMessage.WEAVEINFO) {
			this.logger.info(messageText);
		} else if (messageKind == IMessage.TASKTAG) {
			// ignore
		} else {
			throw new BuildException("Unknown message kind from AspectJ compiler: " + messageKind.toString());
		}
		return handledMessage;
	}
================= fetch public boolean isIgnoring(Kind kind) { 1da1f7c^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
/* (non-Javadoc)
	 * @see org.aspectj.bridge.IMessageHandler#isIgnoring(org.aspectj.bridge.IMessage.Kind)
	 */
public boolean isIgnoring(Kind kind) {
		return false;
	}
================= fetch public void dontIgnore(Kind kind) { 1da1f7c^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
/* (non-Javadoc)
	 * @see org.aspectj.bridge.IMessageHandler#dontIgnore(org.aspectj.bridge.IMessage.Kind)
	 */
public void dontIgnore(Kind kind) {
	}
================= fetch public void ignore(Kind kind) { 1da1f7c^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
/* (non-Javadoc)
	 * @see org.aspectj.bridge.IMessageHandler#ignore(org.aspectj.bridge.IMessage.Kind)
	 */
public void ignore(Kind kind) {
	}
================= fetch public void setMaxmem(String maxMem) { 1da1f7c^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
/** support for nested &lt;jvmarg&gt; elements */
public Commandline.Argument createJvmarg() {
    	return this.javaCmd.createVmArgument();
    }
================= fetch public void setXlint(String xlint) { 1da1f7c^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
/** -Xlint:{error|warning|info} - set default level for -Xlint messages
	 * @param xlint the String with one of error, warning, ignored 
	 */
public void setXlint(String xlint) {
    	xlint = validCommaList(xlint, VALID_XLINT, "Xlint", 1);
        cmd.addFlag("-Xlint:" + xlint, (null != xlint));
    }
================= fetch public void setXlintwarnings(boolean xlintwarnings) { 1da1f7c^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
/** 
	 * -Xlint - set default level of -Xlint messages to warning
	 * (same as </code>-Xlint:warning</code>)
	 */
public void setXlintwarnings(boolean xlintwarnings) {
        cmd.addFlag("-Xlint", xlintwarnings);
	}
================= fetch String stripWhitespaceAndComments(String s) { d9bd46d^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/ConfigParser.java

String stripWhitespaceAndComments(String s) {
		s = stripSingleLineComment(s, "//");
		s = stripSingleLineComment(s, "#");
		s = s.trim();
		if (s.startsWith("\"") && s.endsWith("\"")) {
			s = s.substring(1, s.length() - 1);
		}
		return s;
	}
================= fetch private static void addChildNodes(AsmManager asm, ShadowMunger munger, IProgramE 120b47f^:weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java

private static void addChildNodes(AsmManager asm, ShadowMunger munger, IProgramElement parent, Collection children) {
		int deCtr = 1;
		int dwCtr = 1;
		for (Iterator iter = children.iterator(); iter.hasNext();) {
			Object element = iter.next();
			if (element instanceof DeclareErrorOrWarning) {
				DeclareErrorOrWarning decl = (DeclareErrorOrWarning) element;
				int counter = 0;
				if (decl.isError()) {
					counter = deCtr++;
				} else {
					counter = dwCtr++;
				}
				parent.addChild(createDeclareErrorOrWarningChild(asm, munger, decl, counter));
			} else if (element instanceof Advice) {
				Advice advice = (Advice) element;
				parent.addChild(createAdviceChild(asm, advice));
			}
		}
	}
================= fetch public MethodArgument(String name, int indexOnStack) { 120b47f^:weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java

public int compare(Object o, Object o1) {
				MethodArgument mo = (MethodArgument) o;
				MethodArgument mo1 = (MethodArgument) o1;
				if (mo.indexOnStack == mo1.indexOnStack) {
					return 0;
				} else if (mo.indexOnStack > mo1.indexOnStack) {
					return 1;
				} else {
					return -1;
				}
			}
================= fetch public Pointcut getPointcut() { 120b47f^:weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java

public Pointcut getPointcut() {
			if (m_lazyPointcut == null) {
				m_lazyPointcut = m_pointcutUnresolved.resolve(m_binding);
				m_lazyPointcut.copyLocationFrom(m_pointcutUnresolved);
			}
			return m_lazyPointcut;
		}
================= fetch private String getParameters(IProgramElement ipe) { 155a888^:asm/src/org/aspectj/asm/internal/JDTLikeHandleProvider.java
/**
	 * Only returns the count if it's not equal to 1
	 */
private char[] convertCount(char[] c) {
		if ((c.length == 1 && c[0] != ' ' && c[0] != '1') || c.length > 1) {
			return CharOperation.concat(countDelim, c);
		}
		return empty;
	}
Progress : [############----------------------------] 30%================= fetch public void testItdCCE_pr250091() { cffe291^:tests/src/org/aspectj/systemtest/ajc163/Ajc163Tests.java

public void testItdCCE_pr250091() {
		runTest("itd cce");
	}
================= fetch private void deleteNewAndDup() { 7a398a2^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

private void deleteNewAndDup() {
		final ConstantPool cpg = getEnclosingClass().getConstantPool();
		int depth = 1;
		InstructionHandle ih = range.getStart();

		// Go back from where we are looking for 'NEW' that takes us to a stack depth of 0. INVOKESPECIAL <init>
		while (true) {
			Instruction inst = ih.getInstruction();
			if (inst.opcode == Constants.INVOKESPECIAL && ((InvokeInstruction) inst).getName(cpg).equals("<init>")) {
				depth++;
			} else if (inst.opcode == Constants.NEW) {
				depth--;
				if (depth == 0)
					break;
			} else if (inst.opcode == Constants.DUP_X2) {
				// This code seen in the wild (by Brad):
				// 40: new #12; //class java/lang/StringBuffer
				// STACK: STRINGBUFFER
				// 43: dup
				// STACK: STRINGBUFFER/STRINGBUFFER
				// 44: aload_0
				// STACK: STRINGBUFFER/STRINGBUFFER/THIS
				// 45: dup_x2
				// STACK: THIS/STRINGBUFFER/STRINGBUFFER/THIS
				// 46: getfield #36; //Field value:Ljava/lang/String;
				// STACK: THIS/STRINGBUFFER/STRINGBUFFER/STRING<value>
				// 49: invokestatic #37; //Method java/lang/String.valueOf:(Ljava/lang/Object;)Ljava/lang/String;
				// STACK: THIS/STRINGBUFFER/STRINGBUFFER/STRING
				// 52: invokespecial #19; //Method java/lang/StringBuffer."<init>":(Ljava/lang/String;)V
				// STACK: THIS/STRINGBUFFER
				// 55: aload_1
				// STACK: THIS/STRINGBUFFER/LOCAL1
				// 56: invokevirtual #22; //Method java/lang/StringBuffer.append:(Ljava/lang/String;)Ljava/lang/StringBuffer;
				// STACK: THIS/STRINGBUFFER
				// 59: invokevirtual #34; //Method java/lang/StringBuffer.toString:()Ljava/lang/String;
				// STACK: THIS/STRING
				// 62: putfield #36; //Field value:Ljava/lang/String;
				// STACK: <empty>
				// 65: return

				// if we attempt to match on the ctor call to StringBuffer.<init> then we get into trouble.
				// if we simply delete the new/dup pair without fixing up the dup_x2 then the dup_x2 will fail due to there
				// not being 3 elements on the stack for it to work with. The fix *in this situation* is to change it to
				// a simple 'dup'

				// this fix is *not* very clean - but a general purpose decent solution will take much longer and this
				// bytecode sequence has only been seen once in the wild.
				ih.setInstruction(InstructionConstants.DUP);
			}
			ih = ih.getPrev();
		}
		// now IH points to the NEW. We're followed by the DUP, and that is followed
		// by the actual instruction we care about.
		InstructionHandle newHandle = ih;
		InstructionHandle endHandle = newHandle.getNext();
		InstructionHandle nextHandle;
		if (endHandle.getInstruction().opcode == Constants.DUP) {
			nextHandle = endHandle.getNext();
			retargetFrom(newHandle, nextHandle);
			retargetFrom(endHandle, nextHandle);
		} else if (endHandle.getInstruction().opcode == Constants.DUP_X1) {
			InstructionHandle dupHandle = endHandle;
			endHandle = endHandle.getNext();
			nextHandle = endHandle.getNext();
			if (endHandle.getInstruction().opcode == Constants.SWAP) {
			} else {
				// XXX see next XXX comment
				throw new RuntimeException("Unhandled kind of new " + endHandle);
			}
			// Now make any jumps to the 'new', the 'dup' or the 'end' now target the nextHandle
			retargetFrom(newHandle, nextHandle);
			retargetFrom(dupHandle, nextHandle);
			retargetFrom(endHandle, nextHandle);
		} else {
			endHandle = newHandle;
			nextHandle = endHandle.getNext();
			retargetFrom(newHandle, nextHandle);
			// add a POP here... we found a NEW w/o a dup or anything else, so
			// we must be in statement context.
			getRange().insert(InstructionConstants.POP, Range.OutsideAfter);
		}
		// assert (dupHandle.getInstruction() instanceof DUP);

		try {
			range.getBody().delete(newHandle, endHandle);
		} catch (TargetLostException e) {
			throw new BCException("shouldn't happen");
		}
	}
================= fetch private void retargetFrom(InstructionHandle old, InstructionHandle fresh) { 7a398a2^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

private void retargetFrom(InstructionHandle old, InstructionHandle fresh) {
		InstructionTargeter[] sources = old.getTargetersArray();
		if (sources != null) {
			for (int i = sources.length - 1; i >= 0; i--) {
				if (sources[i] instanceof ExceptionRange) {
					ExceptionRange it = (ExceptionRange) sources[i];
					System.err.println("...");
					it.updateTarget(old, fresh, it.getBody());
				} else {
					sources[i].updateTarget(old, fresh);
				}
			}
		}
	}
================= fetch public void testAspectPath_pr247742_c16() throws IOException { 9b68a31^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java

public void testAspectPath_pr247742_c16() throws IOException {
		String bug = "AspectPathOne";
		String bug2 = "AspectPathTwo";
		addSourceFolderForSourceFile(bug2, getProjectRelativePath(bug2, "src/C.java"), "src");
		initialiseProject(bug);
		initialiseProject(bug2);
		configureAspectPath(bug2, getProjectRelativePath(bug, "bin"));
		build(bug);
		build(bug2);
//		dumptree(AsmManager.getDefault().getHierarchy().getRoot(), 0);
//		PrintWriter pw = new PrintWriter(System.out);
//		AsmManager.getDefault().dumprels(pw);
//		pw.flush();
		IProgramElement root = AsmManager.getDefault().getHierarchy().getRoot();
		assertEquals("=AspectPathTwo/binaries<pkg(Asp.class}Asp&before", findElementAtLine(root, 5).getHandleIdentifier());
		assertEquals("=AspectPathTwo/binaries<(Asp2.class}Asp2&before", findElementAtLine(root, 16).getHandleIdentifier());
	}
================= fetch public void testBrokenCodeCompilation() { 9b68a31^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java

public void testBrokenCodeCompilation() {
		initialiseProject("pr102733_1");
		// configureNonStandardCompileOptions("pr102733_1","-proceedOnError");
		build("pr102733_1");
		checkWasFullBuild();
		checkCompileWeaveCount("pr102733_1", 1, 0);
		assertTrue("There should be an error:\n" + getErrorMessages("pr102733_1"), !getErrorMessages("pr102733_1").isEmpty());
		build("pr102733_1"); // incremental
		checkCompileWeaveCount("pr102733_1", 0, 0);
		checkWasntFullBuild();
		alter("pr102733_1", "inc1"); // fix the error
		build("pr102733_1");
		checkWasntFullBuild();
		checkCompileWeaveCount("pr102733_1", 1, 1);
		assertTrue("There should be no errors:\n" + getErrorMessages("pr102733_1"), getErrorMessages("pr102733_1").isEmpty());
		alter("pr102733_1", "inc2"); // break it again
		build("pr102733_1");
		checkWasntFullBuild();
		checkCompileWeaveCount("pr102733_1", 1, 0);
		assertTrue("There should be an error:\n" + getErrorMessages("pr102733_1"), !getErrorMessages("pr102733_1").isEmpty());
	}
================= fetch public void testSpacewarHandles() { 9b68a31^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java

public void testSpacewarHandles() {
		// String p = "SpaceWar";
		String p = "Simpler";
		initialiseProject(p);
		build(p);
		dumptree(AsmManager.getDefault().getHierarchy().getRoot(), 0);
		// incomplete
	}
================= fetch public boolean hasAnnotation(UnresolvedType ofType) { f376a21^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseResolvedMember.java

public AnnotationAJ[] getAnnotations() {
		// long abits =
		realBinding.getAnnotationTagBits(); // ensure resolved
		Annotation[] annos = getEclipseAnnotations();
		if (annos == null)
			return null;
		// TODO errr missing in action - we need to implement this! Probably
		// using something like EclipseAnnotationConvertor -
		// itself not finished ;)
		throw new RuntimeException(
				"not yet implemented - please raise an AJ bug");
		// return super.getAnnotations();
	}
================= fetch public UnresolvedType ensureTargetTypeIsCorrect(UnresolvedType tx) { 78a483d^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
/*
	 * PR 72528 This method double checks the target type under certain conditions. The Java 1.4 compilers seem to take calls to
	 * clone methods on array types and create bytecode that looks like clone is being called on Object. If we advise a clone call
	 * with around advice we extract the call into a helper method which we can then refer to. Because the type in the bytecode for
	 * the call to clone is Object we create a helper method with an Object parameter - this is not correct as we have lost the fact
	 * that the actual type is an array type. If we don't do the check below we will create code that fails java verification. This
	 * method checks for the peculiar set of conditions and if they are true, it has a sneak peek at the code before the call to see
	 * what is on the stack.
	 */
public UnresolvedType ensureTargetTypeIsCorrect(UnresolvedType tx) {

		Member msig = getSignature();
		if (msig.getArity() == 0 && getKind() == MethodCall && msig.getName().charAt(0) == 'c' && tx.equals(ResolvedType.OBJECT)
				&& msig.getReturnType().equals(ResolvedType.OBJECT) && msig.getName().equals("clone")) {

			// Lets go back through the code from the start of the shadow
			InstructionHandle searchPtr = range.getStart().getPrev();
			while (Range.isRangeHandle(searchPtr) || searchPtr.getInstruction().isStoreInstruction()) { // ignore this instruction -
																										// it doesnt give us the
																										// info we want
				searchPtr = searchPtr.getPrev();
			}

			// A load instruction may tell us the real type of what the clone() call is on
			if (searchPtr.getInstruction().isLoadInstruction()) {
				LocalVariableTag lvt = LazyMethodGen.getLocalVariableTag(searchPtr, searchPtr.getInstruction().getIndex());
				if (lvt != null)
					return UnresolvedType.forSignature(lvt.getType());
			}
			// A field access instruction may tell us the real type of what the clone() call is on
			if (searchPtr.getInstruction() instanceof FieldInstruction) {
				FieldInstruction si = (FieldInstruction) searchPtr.getInstruction();
				Type t = si.getFieldType(getEnclosingClass().getConstantPool());
				return BcelWorld.fromBcel(t);
			}
			// A new array instruction obviously tells us it is an array type !
			if (searchPtr.getInstruction().opcode == Constants.ANEWARRAY) {
				// ANEWARRAY ana = (ANEWARRAY)searchPoint.getInstruction();
				// Type t = ana.getType(getEnclosingClass().getConstantPool());
				// Just use a standard java.lang.object array - that will work fine
				return BcelWorld.fromBcel(new ArrayType(Type.OBJECT, 1));
			}
			// A multi new array instruction obviously tells us it is an array type !
			if (searchPtr.getInstruction() instanceof MULTIANEWARRAY) {
				MULTIANEWARRAY ana = (MULTIANEWARRAY) searchPtr.getInstruction();
				// Type t = ana.getType(getEnclosingClass().getConstantPool());
				// t = new ArrayType(t,ana.getDimensions());
				// Just use a standard java.lang.object array - that will work fine
				return BcelWorld.fromBcel(new ArrayType(Type.OBJECT, ana.getDimensions()));
			}
			throw new BCException("Can't determine real target of clone() when processing instruction "
					+ searchPtr.getInstruction() + ".  Perhaps avoid selecting clone with your pointcut?");
		}
		return tx;
	}
================= fetch public Var getArgVar(int i) { 78a483d^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public Var getArgVar(int i) {
		initializeArgVars();
		return argVars[i];
	}
================= fetch public boolean arg0HoldsThis() { 78a483d^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
/**
	 * Is arg0 occupied with the value of this
	 */
public boolean arg0HoldsThis() {
		if (getKind().isEnclosingKind()) {
			return !getSignature().isStatic();
		} else if (enclosingShadow == null) {
			// XXX this is mostly right
			// this doesn't do the right thing for calls in the pre part of introduced constructors.
			return !enclosingMethod.isStatic();
		} else {
			return ((BcelShadow) enclosingShadow).arg0HoldsThis();
		}
	}
================= fetch public static BcelShadow makeMethodExecution(BcelWorld world, LazyMethodGen encl 78a483d^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public static BcelShadow makeMethodExecution(BcelWorld world, LazyMethodGen enclosingMethod) {
		return makeShadowForMethod(world, enclosingMethod, MethodExecution, enclosingMethod.getMemberView()); // world.
																												// makeMethodSignature
																												// (
																												// enclosingMethod))
																												// ;
	}
================= fetch public void initializeArgVars() { 78a483d^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public void initializeArgVars() {
		if (argVars != null)
			return;
		InstructionFactory fact = getFactory();
		int len = getArgCount();
		argVars = new BcelVar[len];
		int positionOffset = (hasTarget() ? 1 : 0) + ((hasThis() && !getKind().isTargetSameAsThis()) ? 1 : 0);

		if (getKind().argsOnStack()) {
			// we move backwards because we're popping off the stack
			for (int i = len - 1; i >= 0; i--) {
				UnresolvedType type = getArgType(i);
				BcelVar tmp = genTempVar(type, "ajc$arg" + i);
				range.insert(tmp.createStore(getFactory()), Range.OutsideBefore);
				int position = i;
				position += positionOffset;
				tmp.setPositionInAroundState(position);
				argVars[i] = tmp;
			}
		} else {
			int index = 0;
			if (arg0HoldsThis())
				index++;

			for (int i = 0; i < len; i++) {
				UnresolvedType type = getArgType(i);
				BcelVar tmp = genTempVar(type, "ajc$arg" + i);
				range.insert(tmp.createCopyFrom(fact, index), Range.OutsideBefore);
				argVars[i] = tmp;
				int position = i;
				position += positionOffset;
				// System.out.println("set position: " + tmp + ", " + position + " in " + this);
				// System.out.println("   hasThis: " + hasThis() + ", hasTarget: " + hasTarget());
				tmp.setPositionInAroundState(position);
				index += type.getSize();
			}
		}
	}
================= fetch public void initializeTargetAnnotationVars() { 78a483d^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public void initializeTargetAnnotationVars() {
		if (targetAnnotationVars != null)
			return;
		if (getKind().isTargetSameAsThis()) {
			if (hasThis())
				initializeThisAnnotationVars();
			targetAnnotationVars = thisAnnotationVars;
		} else {
			targetAnnotationVars = new HashMap();
			ResolvedType[] rtx = this.getTargetType().resolve(world).getAnnotationTypes(); // what about annotations we havent
																							// gotten yet but we will get in
																							// subclasses?
			for (int i = 0; i < rtx.length; i++) {
				ResolvedType typeX = rtx[i];
				targetAnnotationVars.put(typeX, new TypeAnnotationAccessVar(typeX, (BcelVar) getTargetVar()));
			}
			// populate.
		}
	}
================= fetch public void weaveAroundInline(BcelAdvice munger, boolean hasDynamicTest) { 78a483d^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
/*
	 * Implementation notes:
	 * 
	 * AroundInline still extracts the instructions of the original shadow into an extracted method. This allows inlining of even
	 * that advice that doesn't call proceed or calls proceed more than once.
	 * 
	 * It extracts the instructions of the original shadow into a method.
	 * 
	 * Then it extracts the instructions of the advice into a new method defined on this enclosing class. This new method can then
	 * be specialized as below.
	 * 
	 * Then it searches in the instructions of the advice for any call to the proceed method.
	 * 
	 * At such a call, there is stuff on the stack representing the arguments to proceed. Pop these into the frame.
	 * 
	 * Now build the stack for the call to the extracted method, taking values either from the join point state or from the new
	 * frame locs from proceed. Now call the extracted method. The right return value should be on the stack, so no cast is
	 * necessary.
	 * 
	 * If only one call to proceed is made, we can re-inline the original shadow. We are not doing that presently.
	 * 
	 * If the body of the advice can be determined to not alter the stack, or if this shadow doesn't care about the stack, i.e.
	 * method-execution, then the new method for the advice can also be re-lined. We are not doing that presently.
	 */
void weaveAroundInline(BcelAdvice munger, boolean hasDynamicTest) {

		// !!! THIS BLOCK OF CODE SHOULD BE IN A METHOD CALLED weaveAround(...);
		Member mungerSig = munger.getSignature();
		// Member originalSig = mungerSig; // If mungerSig is on a parameterized type, originalSig is the member on the generic type
		if (mungerSig instanceof ResolvedMember) {
			ResolvedMember rm = (ResolvedMember) mungerSig;
			if (rm.hasBackingGenericMember())
				mungerSig = rm.getBackingGenericMember();
		}
		ResolvedType declaringType = world.resolve(mungerSig.getDeclaringType(), true);
		if (declaringType.isMissing()) {
			world.getLint().cantFindType.signal(new String[] { WeaverMessages.format(
					WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE, declaringType.getClassName()) }, getSourceLocation(),
					new ISourceLocation[] { munger.getSourceLocation() });
			// IMessage msg = new Message(
			// WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE,declaringType.getClassName()),
			// "",IMessage.ERROR,getSourceLocation(),null,
			// new ISourceLocation[]{ munger.getSourceLocation()});
			// world.getMessageHandler().handleMessage(msg);
		}
		// ??? might want some checks here to give better errors
		ResolvedType rt = (declaringType.isParameterizedType() ? declaringType.getGenericType() : declaringType);
		BcelObjectType ot = BcelWorld.getBcelObjectType(rt);
		// if (ot==null) {
		// world.getMessageHandler().handleMessage(
		// MessageUtil.warn("Unable to find modifiable delegate for the aspect '"+rt.getName()+
		// "' containing around advice - cannot implement inlining",munger.getSourceLocation()));
		// weaveAroundClosure(munger, hasDynamicTest);
		// return;
		// }
		LazyMethodGen adviceMethod = ot.getLazyClassGen().getLazyMethodGen(mungerSig);
		if (!adviceMethod.getCanInline()) {
			weaveAroundClosure(munger, hasDynamicTest);
			return;
		}

		// specific test for @AJ proceedInInners
		if (munger.getConcreteAspect().isAnnotationStyleAspect()) {
			// if we can't find one proceed() we suspect that the call
			// is happening in an inner class so we don't inline it.
			// Note: for code style, this is done at Aspect compilation time.
			boolean canSeeProceedPassedToOther = false;
			InstructionHandle curr = adviceMethod.getBody().getStart();
			InstructionHandle end = adviceMethod.getBody().getEnd();
			ConstantPool cpg = adviceMethod.getEnclosingClass().getConstantPool();
			while (curr != end) {
				InstructionHandle next = curr.getNext();
				Instruction inst = curr.getInstruction();
				if ((inst instanceof InvokeInstruction)
						&& ((InvokeInstruction) inst).getSignature(cpg).indexOf("Lorg/aspectj/lang/ProceedingJoinPoint;") > 0) {
					// we may want to refine to exclude stuff returning jp ?
					// does code style skip inline if i write dump(thisJoinPoint) ?
					canSeeProceedPassedToOther = true;// we see one pjp passed around - dangerous
					break;
				}
				curr = next;
			}
			if (canSeeProceedPassedToOther) {
				// remember this decision to avoid re-analysis
				adviceMethod.setCanInline(false);
				weaveAroundClosure(munger, hasDynamicTest);
				return;
			}
		}

		// We can't inline around methods if they have around advice on them, this
		// is because the weaving will extract the body and hence the proceed call.
		// ??? should consider optimizations to recognize simple cases that don't require body extraction
		enclosingMethod.setCanInline(false);

		// start by exposing various useful things into the frame
		final InstructionFactory fact = getFactory();

		// now generate the aroundBody method
		// eg. "private static final void method_aroundBody0(M, M, String, org.aspectj.lang.JoinPoint)"
		LazyMethodGen extractedMethod = extractMethod(NameMangler.aroundCallbackMethodName(getSignature(), getEnclosingClass()),
				Modifier.PRIVATE, munger);

		// now extract the advice into its own method
		String adviceMethodName = NameMangler.aroundCallbackMethodName(getSignature(), getEnclosingClass()) + "$advice";

		List argVarList = new ArrayList();
		List proceedVarList = new ArrayList();
		int extraParamOffset = 0;

		// Create the extra parameters that are needed for passing to proceed
		// This code is very similar to that found in makeCallToCallback and should
		// be rationalized in the future

		if (thisVar != null) {
			argVarList.add(thisVar);
			proceedVarList.add(new BcelVar(thisVar.getType(), extraParamOffset));
			extraParamOffset += thisVar.getType().getSize();
		}

		if (targetVar != null && targetVar != thisVar) {
			argVarList.add(targetVar);
			proceedVarList.add(new BcelVar(targetVar.getType(), extraParamOffset));
			extraParamOffset += targetVar.getType().getSize();
		}
		for (int i = 0, len = getArgCount(); i < len; i++) {
			argVarList.add(argVars[i]);
			proceedVarList.add(new BcelVar(argVars[i].getType(), extraParamOffset));
			extraParamOffset += argVars[i].getType().getSize();
		}
		if (thisJoinPointVar != null) {
			argVarList.add(thisJoinPointVar);
			proceedVarList.add(new BcelVar(thisJoinPointVar.getType(), extraParamOffset));
			extraParamOffset += thisJoinPointVar.getType().getSize();
		}

		// We use the munger signature here because it allows for any parameterization of the mungers pointcut that
		// may have occurred ie. if the pointcut is p(T t) in the super aspect and that has become p(Foo t) in the sub aspect
		// then here the munger signature will have 'Foo' as an argument in it whilst the adviceMethod argument type will be
		// 'Object' - since
		// it represents the advice method in the superaspect which uses the erasure of the type variable p(Object t) - see
		// pr174449.

		Type[] adviceParameterTypes = BcelWorld.makeBcelTypes(munger.getSignature().getParameterTypes());
		// adviceMethod.getArgumentTypes();
		adviceMethod.getArgumentTypes(); // forces initialization ... dont like this but seems to be required for some tests to
											// pass, I think that means
		// there is a LazyMethodGen method that is not correctly setup to call initialize() when it is invoked - but I dont have
		// time right now to discover which
		Type[] extractedMethodParameterTypes = extractedMethod.getArgumentTypes();
		Type[] parameterTypes = new Type[extractedMethodParameterTypes.length + adviceParameterTypes.length + 1];
		int parameterIndex = 0;
		System.arraycopy(extractedMethodParameterTypes, 0, parameterTypes, parameterIndex, extractedMethodParameterTypes.length);
		parameterIndex += extractedMethodParameterTypes.length;

		parameterTypes[parameterIndex++] = BcelWorld.makeBcelType(adviceMethod.getEnclosingClass().getType());
		System.arraycopy(adviceParameterTypes, 0, parameterTypes, parameterIndex, adviceParameterTypes.length);
		// parameterTypes is [Bug, C, org.aspectj.lang.JoinPoint, X, org.aspectj.lang.ProceedingJoinPoint, java.lang.Object,
		// java.lang.Object]
		LazyMethodGen localAdviceMethod = new LazyMethodGen(Modifier.PRIVATE | Modifier.FINAL | Modifier.STATIC, BcelWorld
				.makeBcelType(mungerSig.getReturnType()), adviceMethodName, parameterTypes, new String[0], getEnclosingClass());

		String donorFileName = adviceMethod.getEnclosingClass().getInternalFileName();
		String recipientFileName = getEnclosingClass().getInternalFileName();
		// System.err.println("donor " + donorFileName);
		// System.err.println("recip " + recipientFileName);
		if (!donorFileName.equals(recipientFileName)) {
			localAdviceMethod.fromFilename = donorFileName;
			getEnclosingClass().addInlinedSourceFileInfo(donorFileName, adviceMethod.highestLineNumber);
		}

		getEnclosingClass().addMethodGen(localAdviceMethod);

		// create a map that will move all slots in advice method forward by extraParamOffset
		// in order to make room for the new proceed-required arguments that are added at
		// the beginning of the parameter list
		int nVars = adviceMethod.getMaxLocals() + extraParamOffset;
		IntMap varMap = IntMap.idMap(nVars);
		for (int i = extraParamOffset; i < nVars; i++) {
			varMap.put(i - extraParamOffset, i);
		}

		localAdviceMethod.getBody().insert(
				BcelClassWeaver.genInlineInstructions(adviceMethod, localAdviceMethod, varMap, fact, true));

		localAdviceMethod.setMaxLocals(nVars);

		// System.err.println(localAdviceMethod);

		// the shadow is now empty. First, create a correct call
		// to the around advice. This includes both the call (which may involve
		// value conversion of the advice arguments) and the return
		// (which may involve value conversion of the return value). Right now
		// we push a null for the unused closure. It's sad, but there it is.

		InstructionList advice = new InstructionList();
		// InstructionHandle adviceMethodInvocation;
		{
			for (Iterator i = argVarList.iterator(); i.hasNext();) {
				BcelVar var = (BcelVar) i.next();
				var.appendLoad(advice, fact);
			}
			// ??? we don't actually need to push NULL for the closure if we take care
			advice.append(munger.getAdviceArgSetup(this, null,
					(munger.getConcreteAspect().isAnnotationStyleAspect() && munger.getDeclaringAspect() != null && munger
							.getDeclaringAspect().resolve(world).isAnnotationStyleAspect()) ? this.loadThisJoinPoint()
							: new InstructionList(InstructionConstants.ACONST_NULL)));
			// adviceMethodInvocation =
			advice.append(Utility.createInvoke(fact, localAdviceMethod)); // (fact, getWorld(), munger.getSignature()));
			advice.append(Utility.createConversion(getFactory(), BcelWorld.makeBcelType(mungerSig.getReturnType()), extractedMethod
					.getReturnType(), world.isInJava5Mode()));
			if (!isFallsThrough()) {
				advice.append(InstructionFactory.createReturn(extractedMethod.getReturnType()));
			}
		}

		// now, situate the call inside the possible dynamic tests,
		// and actually add the whole mess to the shadow
		if (!hasDynamicTest) {
			range.append(advice);
		} else {
			InstructionList afterThingie = new InstructionList(InstructionConstants.NOP);
			InstructionList callback = makeCallToCallback(extractedMethod);
			if (terminatesWithReturn()) {
				callback.append(InstructionFactory.createReturn(extractedMethod.getReturnType()));
			} else {
				// InstructionHandle endNop = range.insert(fact.NOP, Range.InsideAfter);
				advice.append(InstructionFactory.createBranchInstruction(Constants.GOTO, afterThingie.getStart()));
			}
			range.append(munger.getTestInstructions(this, advice.getStart(), callback.getStart(), advice.getStart()));
			range.append(advice);
			range.append(callback);
			range.append(afterThingie);
		}

		// now search through the advice, looking for a call to PROCEED.
		// Then we replace the call to proceed with some argument setup, and a
		// call to the extracted method.

		// inlining support for code style aspects
		if (!munger.getDeclaringType().isAnnotationStyleAspect()) {
			String proceedName = NameMangler.proceedMethodName(munger.getSignature().getName());

			InstructionHandle curr = localAdviceMethod.getBody().getStart();
			InstructionHandle end = localAdviceMethod.getBody().getEnd();
			ConstantPool cpg = localAdviceMethod.getEnclosingClass().getConstantPool();
			while (curr != end) {
				InstructionHandle next = curr.getNext();
				Instruction inst = curr.getInstruction();
				if ((inst.opcode == Constants.INVOKESTATIC) && proceedName.equals(((InvokeInstruction) inst).getMethodName(cpg))) {

					localAdviceMethod.getBody().append(curr,
							getRedoneProceedCall(fact, extractedMethod, munger, localAdviceMethod, proceedVarList));
					Utility.deleteInstruction(curr, localAdviceMethod);
				}
				curr = next;
			}
			// and that's it.
		} else {
			// ATAJ inlining support for @AJ aspects
			// [TODO document @AJ code rule: don't manipulate 2 jps proceed at the same time.. in an advice body]
			InstructionHandle curr = localAdviceMethod.getBody().getStart();
			InstructionHandle end = localAdviceMethod.getBody().getEnd();
			ConstantPool cpg = localAdviceMethod.getEnclosingClass().getConstantPool();
			while (curr != end) {
				InstructionHandle next = curr.getNext();
				Instruction inst = curr.getInstruction();
				if ((inst instanceof INVOKEINTERFACE) && "proceed".equals(((INVOKEINTERFACE) inst).getMethodName(cpg))) {
					final boolean isProceedWithArgs;
					if (((INVOKEINTERFACE) inst).getArgumentTypes(cpg).length == 1) {
						// proceed with args as a boxed Object[]
						isProceedWithArgs = true;
					} else {
						isProceedWithArgs = false;
					}
					InstructionList insteadProceedIl = getRedoneProceedCallForAnnotationStyle(fact, extractedMethod, munger,
							localAdviceMethod, proceedVarList, isProceedWithArgs);
					localAdviceMethod.getBody().append(curr, insteadProceedIl);
					Utility.deleteInstruction(curr, localAdviceMethod);
				}
				curr = next;
			}
		}
	}
================= fetch String makeClasspathString(AjBuildConfig buildConfig) { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

String makeClasspathString(AjBuildConfig buildConfig) {
		if (buildConfig == null || buildConfig.getFullClasspath() == null) return "";
		StringBuffer buf = new StringBuffer();
		boolean first = true;
		for (Iterator it = buildConfig.getFullClasspath().iterator(); it.hasNext(); ) {
			if (first) { first = false; }
			else { buf.append(File.pathSeparator); }
			buf.append(it.next().toString());
		}
		return buf.toString();
	}
================= fetch private ByteArrayOutputStream getOutxmlContents(List aspectNames) { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/**
	 * Returns a map where the keys are File objects corresponding to
	 * all the output directories and the values are a list of aspects
	 * which are sent to that ouptut directory
	 */
private Map /* File --> List (String) */findOutputDirsForAspects() {
		Map outputDirsToAspects = new HashMap();
		Map aspectNamesToFileNames = state.getAspectNamesToFileNameMap();
		if (buildConfig.getCompilationResultDestinationManager() == null
				|| buildConfig.getCompilationResultDestinationManager().getAllOutputLocations().size() == 1) {
			// we only have one output directory...which simplifies things
			File outputDir = buildConfig.getOutputDir();
			if (buildConfig.getCompilationResultDestinationManager() != null) {
				outputDir = buildConfig.getCompilationResultDestinationManager().getDefaultOutputLocation();
			}
			List aspectNames = new ArrayList();
			if (aspectNamesToFileNames != null) {
				Set keys = aspectNamesToFileNames.keySet();
				for (Iterator iterator = keys.iterator(); iterator.hasNext();) {
					String name = (String) iterator.next();
					aspectNames.add(name);
				}				
			}
			outputDirsToAspects.put(outputDir, aspectNames);
		} else {
			List outputDirs = buildConfig.getCompilationResultDestinationManager().getAllOutputLocations();
			for (Iterator iterator = outputDirs.iterator(); iterator.hasNext();) {
				File outputDir = (File) iterator.next();
				outputDirsToAspects.put(outputDir,new ArrayList());
			}
			Set entrySet = aspectNamesToFileNames.entrySet();
			for (Iterator iterator = entrySet.iterator(); iterator.hasNext();) {
				Map.Entry entry = (Map.Entry) iterator.next();
				String aspectName = (String) entry.getKey();
				char[] fileName = (char[]) entry.getValue();
				File outputDir = buildConfig.getCompilationResultDestinationManager()
						.getOutputLocationForClass(new File(new String(fileName)));
				if(!outputDirsToAspects.containsKey(outputDir)) {
					outputDirsToAspects.put(outputDir,new ArrayList());
				}
				((List)outputDirsToAspects.get(outputDir)).add(aspectName);
			}
		}
		return outputDirsToAspects;
	}
================= fetch private String checkRtJar(AjBuildConfig buildConfig) { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/**
	 * This will return null if aspectjrt.jar is present and has the correct version.
	 * Otherwise it will return a string message indicating the problem.
	 */
private String checkRtJar(AjBuildConfig buildConfig) {
        // omitting dev info
		if (Version.text.equals(Version.DEVELOPMENT)) {
			// in the development version we can't do this test usefully
//			MessageUtil.info(holder, "running development version of aspectj compiler");
			return null;
		}
		
		
		if (buildConfig == null || buildConfig.getFullClasspath() == null) return "no classpath specified";
		
		
		String ret = null;
		for (Iterator it = buildConfig.getFullClasspath().iterator(); it.hasNext(); ) {
			File p = new File( (String)it.next() );
			// pr112830, allow variations on aspectjrt.jar of the form aspectjrtXXXXXX.jar
			if (p.isFile() && p.getName().startsWith("aspectjrt") && p.getName().endsWith(".jar")) {

				try {
                    String version = null;
                    Manifest manifest = new JarFile(p).getManifest();
                    if (manifest == null) {
                    	ret = "no manifest found in " + p.getAbsolutePath() + 
								", expected " + Version.text;
                    	continue;
                    }
                    Attributes attr = manifest.getAttributes("org/aspectj/lang/");
                    if (null != attr) {
                        version = attr.getValue(Attributes.Name.IMPLEMENTATION_VERSION);
                        if (null != version) {
                            version = version.trim();
                        }
                    }
					// assume that users of development aspectjrt.jar know what they're doing
					if (Version.DEVELOPMENT.equals(version)) {
//						MessageUtil.info(holder,
//							"running with development version of aspectjrt.jar in " + 
//							p.getAbsolutePath());
                        return null;
					} else if (!Version.text.equals(version)) {
						ret =  "bad version number found in " + p.getAbsolutePath() + 
								" expected " + Version.text + " found " + version;
						continue;
					}
				} catch (IOException ioe) {
					ret = "bad jar file found in " + p.getAbsolutePath() + " error: " + ioe;
				}
				return null; // this is the "OK" return value!
			} else {
				// might want to catch other classpath errors
			}
		}
		
		if (ret != null) return ret; // last error found in potentially matching jars...
		
		return "couldn't find aspectjrt.jar on classpath, checked: " + makeClasspathString(buildConfig);
	}
================= fetch private boolean acceptResource(String resourceName,boolean fromFile) { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private boolean acceptResource(String resourceName,boolean fromFile) {
		if (  
				(resourceName.startsWith("CVS/")) ||
				(resourceName.indexOf("/CVS/") != -1) ||
				(resourceName.endsWith("/CVS")) ||
				(resourceName.endsWith(".class")) ||
				(resourceName.startsWith(".svn/")) || 
				(resourceName.indexOf("/.svn/")!=-1) ||
				(resourceName.endsWith("/.svn")) ||
				// Do not copy manifests if either they are coming from a jar or we are writing to a jar
				(resourceName.toUpperCase().equals(MANIFEST_NAME) && (!fromFile || zos!=null))
		    )
		{
			return false;
		} else {
			return true;
		}
	}
================= fetch private boolean openOutputStream(File outJar) { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

================= fetch private void addAspectName (String name, char[] fileContainingAspect) { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void addAspectName (String name, char[] fileContainingAspect) {
				BcelWorld world = getBcelWorld();
				ResolvedType type = world.resolve(name);
//				System.err.println("? writeAspectName() type=" + type);
				if (type.isAspect()) {
					if (state.getAspectNamesToFileNameMap() == null) {
						state.initializeAspectNamesToFileNameMap();
					}
					if (!state.getAspectNamesToFileNameMap().containsKey(name)) {
						state.getAspectNamesToFileNameMap().put(name,
								fileContainingAspect);
					}
				}
			}
================= fetch private void closeOutputStream(File outJar) { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void closeOutputStream(File outJar) {
		try {
			if (zos != null) zos.close();
			zos = null;
			
			/* Ensure we don't write an incomplete JAR bug-71339 */
			if (handler.hasErrors()) {
				outJar.delete(); 
			}
		} catch (IOException ex) {
			IMessage message = 
				new Message("Unable to write outjar " 
								+ outJar.getPath() 
								+ "(" + ex.getMessage() 
								+ ")",
							new SourceLocation(outJar,0),
							true);
			handler.handleMessage(message);
		}
	}
================= fetch private void copyResourcesFromDirectory(File dir) throws IOException { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void copyResourcesFromDirectory(File dir) throws IOException {
		if (!COPY_INPATH_DIR_RESOURCES) return;
		// Get a list of all files (i.e. everything that isnt a directory)
		File[] files = FileUtil.listFiles(dir,new FileFilter() {
================= fetch private void copyResourcesFromFile(File f,String filename,File src) throws IOExc d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

void copyResourcesFromFile(File f,String filename,File src) throws IOException {
		if (!acceptResource(filename,true)) return;
		FileInputStream fis = null;
		try {
			fis = new FileInputStream(f);
			byte[] bytes = FileUtil.readAsByteArray(fis);
			// String relativePath = files[i].getPath();
			
			writeResource(filename,bytes,src);
		} finally {
			if (fis != null) fis.close();
		}	
	}
================= fetch private void copyResourcesFromJarFile(File jarFile) throws IOException { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void copyResourcesFromJarFile(File jarFile) throws IOException {
		JarInputStream inStream = null;
		try {
			inStream = new JarInputStream(new FileInputStream(jarFile));
			while (true) {
				ZipEntry entry = inStream.getNextEntry();
				if (entry == null) break;
			
				String filename = entry.getName();
//				System.out.println("? copyResourcesFromJarFile() filename='" + filename +"'");
				if (entry.isDirectory()) {
					writeDirectory(filename,jarFile);
				} else if (acceptResource(filename,false)) {
					byte[] bytes = FileUtil.readAsByteArray(inStream);
					writeResource(filename,bytes,jarFile);
				}
	
				inStream.closeEntry();
			}
		} finally {
			if (inStream != null) inStream.close();
		}
	}
================= fetch private void copyResourcesToDestination() throws IOException { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void copyResourcesToDestination() throws IOException {
		// resources that we need to copy are contained in the injars and inpath only
		for (Iterator i = buildConfig.getInJars().iterator(); i.hasNext(); ) {
			File inJar = (File)i.next();
			copyResourcesFromJarFile(inJar);
		}
		
		for (Iterator i = buildConfig.getInpath().iterator(); i.hasNext(); ) {
			File inPathElement = (File)i.next();
			if (inPathElement.isDirectory()) {				
				copyResourcesFromDirectory(inPathElement);
			} else {
				copyResourcesFromJarFile(inPathElement);
			}
		}	
		
		if (buildConfig.getSourcePathResources() != null) {
			for (Iterator i = buildConfig.getSourcePathResources().keySet().iterator(); i.hasNext(); ) {
				String resource = (String)i.next();
				File from = (File)buildConfig.getSourcePathResources().get(resource);
				copyResourcesFromFile(from,resource,from);
			}
		}
		
		writeManifest();
    }
================= fetch private void initBcelWorld(IMessageHandler handler) throws IOException { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/** init only on initial batch compile? no file-specific options */
private void initBcelWorld(IMessageHandler handler) throws IOException {
		List cp = 
		buildConfig.getFullClasspath(); // pr145693
		//buildConfig.getBootclasspath();
		//cp.addAll(buildConfig.getClasspath());
		BcelWorld bcelWorld = new BcelWorld(cp, handler, null);
		bcelWorld.setBehaveInJava5Way(buildConfig.getBehaveInJava5Way());
		bcelWorld.setAddSerialVerUID(buildConfig.isAddSerialVerUID());
		bcelWorld.performExtraConfiguration(buildConfig.getXconfigurationInfo());
		bcelWorld.setTargetAspectjRuntimeLevel(buildConfig.getTargetAspectjRuntimeLevel());
		bcelWorld.setOptionalJoinpoints(buildConfig.getXJoinpoints());
		bcelWorld.setXnoInline(buildConfig.isXnoInline());
		bcelWorld.setXlazyTjp(buildConfig.isXlazyTjp());
		bcelWorld.setXHasMemberSupportEnabled(buildConfig.isXHasMemberEnabled());
		bcelWorld.setPinpointMode(buildConfig.isXdevPinpoint());
		bcelWorld.setErrorAndWarningThreshold(buildConfig.getOptions().errorThreshold,buildConfig.getOptions().warningThreshold);
		BcelWeaver bcelWeaver = new BcelWeaver(bcelWorld);
		bcelWeaver.setCustomMungerFactory(customMungerFactory);
		state.setWorld(bcelWorld);
		state.setWeaver(bcelWeaver);
		state.clearBinarySourceFiles();
		
		if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
			bcelWorld.getLint().loadDefaultProperties();
		} else {
			bcelWorld.getLint().setAll(buildConfig.getLintMode());
		}
		if (buildConfig.getLintSpecFile() != null) {
			bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
		}
		
		for (Iterator i = buildConfig.getAspectpath().iterator(); i.hasNext();) {
			File f = (File) i.next();
			if (!f.exists()) {
				IMessage message = new Message("invalid aspectpath entry: "+f.getName(),null,true);
				handler.handleMessage(message);
			} else {
				bcelWeaver.addLibraryJarFile(f);
			}
		}

		// String lintMode = buildConfig.getLintMode();

		File outputDir = buildConfig.getOutputDir();
		if (outputDir == null
				&& buildConfig.getCompilationResultDestinationManager() != null) {
			// send all output from injars and inpath to the default output location
			// (will also later send the manifest there too)
			outputDir = buildConfig.getCompilationResultDestinationManager().getDefaultOutputLocation();
		}
		// ??? incremental issues
		for (Iterator i = buildConfig.getInJars().iterator(); i.hasNext();) {
			File inJar = (File) i.next();
			List unwovenClasses = bcelWeaver.addJarFile(inJar, outputDir, false);
			state.recordBinarySource(inJar.getPath(), unwovenClasses);
		}
		
		for (Iterator i = buildConfig.getInpath().iterator(); i.hasNext(); ) {
			File inPathElement = (File)i.next();
			if (!inPathElement.isDirectory()) {
				// its a jar file on the inpath
				// the weaver method can actually handle dirs, but we don't call it, see next block
				List unwovenClasses = bcelWeaver.addJarFile(inPathElement,outputDir,true);
				state.recordBinarySource(inPathElement.getPath(),unwovenClasses);
			} else {
				// add each class file in an in-dir individually, this gives us the best error reporting
				// (they are like 'source' files then), and enables a cleaner incremental treatment of
				// class file changes in indirs.
				File[] binSrcs = FileUtil.listFiles(inPathElement, binarySourceFilter);
				for (int j = 0; j < binSrcs.length; j++) {
					UnwovenClassFile ucf = bcelWeaver.addClassFile(binSrcs[j], inPathElement, outputDir);
					List ucfl = new ArrayList();
					ucfl.add(ucf);
					state.recordBinarySource(binSrcs[j].getPath(),ucfl);
				}
			}
		}
		
		bcelWeaver.setReweavableMode(buildConfig.isXNotReweavable());

		//check for org.aspectj.runtime.JoinPoint
		ResolvedType joinPoint = bcelWorld.resolve("org.aspectj.lang.JoinPoint");
		if (joinPoint.isMissing()) {
			IMessage message = 
				new Message("classpath error: unable to find org.aspectj.lang.JoinPoint (check that aspectjrt.jar is in your classpath)",
							null,
							true);
				handler.handleMessage(message);
		}
	}
================= fetch private void populateCompilerOptionsFromLintSettings(org.aspectj.org.eclipse.jdt d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/**
	 * Some AspectJ lint options need to be known about in the compiler. This is 
	 * how we pass them over...
	 * @param forCompiler
	 */
private void populateCompilerOptionsFromLintSettings(org.aspectj.org.eclipse.jdt.internal.compiler.Compiler forCompiler) {
		BcelWorld world = this.state.getBcelWorld();
		IMessage.Kind swallowedExceptionKind = world.getLint().swallowedExceptionInCatchBlock.getKind();
		Map optionsMap = new HashMap();
		optionsMap.put(CompilerOptions.OPTION_ReportSwallowedExceptionInCatchBlock, 
				       swallowedExceptionKind == null ? "ignore" : swallowedExceptionKind.toString());
		forCompiler.options.set(optionsMap);
	}
================= fetch private void setBuildConfig(AjBuildConfig buildConfig) { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
//    
private void setBuildConfig(AjBuildConfig buildConfig) {
		this.buildConfig = buildConfig;
		if (!this.environmentSupportsIncrementalCompilation) {
			this.environmentSupportsIncrementalCompilation = 
				(buildConfig.isIncrementalMode() || buildConfig.isIncrementalFileMode());
		}
		handler.reset();
	}
================= fetch private void setupModel(AjBuildConfig config) { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/**
     * Responsible for managing the ASM model between builds.  Contains the policy for
     * maintaining the persistance of elements in the model.
     * 
     * This code is driven before each 'fresh' (batch) build to create
     * a new model.
     */
private void setupModel(AjBuildConfig config) {
     	AsmManager.setCreatingModel(config.isEmacsSymMode() || config.isGenerateModelMode());
     	if (!AsmManager.isCreatingModel()) return;

		AsmManager.getDefault().createNewASM();
		// AsmManager.getDefault().getRelationshipMap().clear();
		IHierarchy model = AsmManager.getDefault().getHierarchy();
        String rootLabel = "<root>";
        	
		
        IProgramElement.Kind kind = IProgramElement.Kind.FILE_JAVA;
        if (buildConfig.getConfigFile() != null) {
           	rootLabel = buildConfig.getConfigFile().getName();
           	model.setConfigFile(buildConfig.getConfigFile().getAbsolutePath());
           	kind = IProgramElement.Kind.FILE_LST;  
        }
        model.setRoot(new ProgramElement(rootLabel, kind, new ArrayList()));
                
        model.setFileMap(new HashMap());
        setStructureModel(model);
		state.setStructureModel(model);
		state.setRelationshipMap(AsmManager.getDefault().getRelationshipMap());
    }
================= fetch private void writeDirectory(String directory, File srcloc) throws IOException { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/**
	 * Add a directory entry to the output zip file.  Don't do anything if not writing out to 
	 * a zip file.  A directory entry is one whose filename ends with '/'
	 * 
	 * @param directory the directory path
	 * @param srcloc the src of the directory entry, for use when creating a warning message
	 * @throws IOException if something goes wrong creating the new zip entry
	 */
private void writeDirectory(String directory, File srcloc) throws IOException {
		if (state.hasResource(directory)) {
			IMessage msg = new Message("duplicate resource: '" + directory + "'",
					   IMessage.WARNING,
					   null,
					   new SourceLocation(srcloc,0));
			handler.handleMessage(msg);
			return;
		}
		if (zos != null) {
			ZipEntry newEntry = new ZipEntry(directory);
			zos.putNextEntry(newEntry);
			zos.closeEntry();
			state.recordResource(directory);
		}
		// Nothing to do if not writing to a zip file
	}
================= fetch private void writeDirectoryEntry( d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void writeDirectoryEntry(
					CompilationResult unitResult, 
					ClassFile classFile, 
					String filename) 
			throws IOException {
				File destinationPath = buildConfig.getOutputDir();
				if (buildConfig.getCompilationResultDestinationManager() != null) {
					destinationPath = 
						buildConfig.getCompilationResultDestinationManager().getOutputLocationForClass(new File(new String(unitResult.fileName)));
				}
				String outFile;
				if (destinationPath == null) {
					outFile = new File(filename).getName();
					outFile = new File(extractDestinationPathFromSourceFile(unitResult), outFile).getPath();
				} else {
					outFile = new File(destinationPath, filename).getPath();
				}
				BufferedOutputStream os =
					FileUtil.makeOutputStream(new File(outFile));
				os.write(classFile.getBytes());
				os.close();
			}
================= fetch private void writeManifest () throws IOException { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/*
	 * If we are writing to an output directory copy the manifest but only
	 * if we already have one
	 */
private void writeManifest () throws IOException {
		Manifest manifest = getWeaver().getManifest(false);
		if (manifest != null && zos == null) {
			File outputDir = buildConfig.getOutputDir();
			if (buildConfig.getCompilationResultDestinationManager() != null) {
				// Manifests are only written if we have a jar on the inpath. Therefore,
				// we write the manifest to the defaultOutputLocation because this is
				// where we sent the classes that were on the inpath
				outputDir = buildConfig.getCompilationResultDestinationManager().getDefaultOutputLocation();
			}
			if (outputDir == null) return;
			OutputStream fos = FileUtil.makeOutputStream(new File(outputDir,MANIFEST_NAME));
			manifest.write(fos);
			fos.close();
		}
	}
================= fetch private void writeResource(String filename, byte[] content, File srcLocation) th d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void writeResource(String filename, byte[] content, File srcLocation) throws IOException {
		if (state.hasResource(filename)) {
			IMessage msg = new Message("duplicate resource: '" + filename + "'",
									   IMessage.WARNING,
									   null,
									   new SourceLocation(srcLocation,0));
			handler.handleMessage(msg);
			return;
		}
		if (filename.equals(buildConfig.getOutxmlName())) {
			ignoreOutxml = true;
			IMessage msg = new Message("-outxml/-outxmlfile option ignored because resource already exists: '" + filename + "'",
					   IMessage.WARNING,
					   null,
					   new SourceLocation(srcLocation,0));
			handler.handleMessage(msg);
		}
		if (zos != null) {
			ZipEntry newEntry = new ZipEntry(filename);  //??? get compression scheme right
			
			zos.putNextEntry(newEntry);
			zos.write(content);
			zos.closeEntry();
		} else {
			File destDir = buildConfig.getOutputDir();
			if (buildConfig.getCompilationResultDestinationManager() != null) {
				destDir = buildConfig.getCompilationResultDestinationManager().getOutputLocationForResource(srcLocation);
			}
			try {
				OutputStream fos = 
					FileUtil.makeOutputStream(new File(destDir,filename));
				fos.write(content);
				fos.close();
			} catch (FileNotFoundException fnfe) {
				IMessage msg = new Message("unable to copy resource to output folder: '" + filename + "' - reason: "+fnfe.getMessage(),
										   IMessage.ERROR,
										   null,
										   new SourceLocation(srcLocation,0));
				handler.handleMessage(msg);
			}
		}
		state.recordResource(filename);
	}
================= fetch private void writeZipEntry(ClassFile classFile, String name) d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void writeZipEntry(ClassFile classFile, String name) 
			throws IOException {
				name = name.replace(File.separatorChar,'/');
				ZipEntry newEntry = new ZipEntry(name);  //??? get compression scheme right
				
				zos.putNextEntry(newEntry);
				zos.write(classFile.getBytes());
				zos.closeEntry();
			}
================= fetch protected boolean doBuild( d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/** @throws AbortException if check for runtime fails */
protected boolean doBuild(
        AjBuildConfig buildConfig, 
        IMessageHandler baseHandler, 
        boolean batch) throws IOException, AbortException {
        boolean ret = true;
    	batchCompile = batch;
    	wasFullBuild = batch;
    	if (baseHandler instanceof ILifecycleAware) {
    		((ILifecycleAware)baseHandler).buildStarting(!batch);
    	}
    	CompilationAndWeavingContext.reset();
    	int phase = batch ? CompilationAndWeavingContext.BATCH_BUILD : CompilationAndWeavingContext.INCREMENTAL_BUILD;
    	ContextToken ct = CompilationAndWeavingContext.enteringPhase(phase ,buildConfig);
        try {
        	if (batch) {
        		this.state = new AjState(this);
        	}
        	
        	this.state.setCouldBeSubsequentIncrementalBuild(this.environmentSupportsIncrementalCompilation);
        	
            boolean canIncremental = state.prepareForNextBuild(buildConfig);
            if (!canIncremental && !batch) { // retry as batch?
             CompilationAndWeavingContext.leavingPhase(ct);
             if (state.listenerDefined()) state.getListener().recordDecision("Falling back to batch compilation");
            	return doBuild(buildConfig, baseHandler, true);
            }
            this.handler = 
                CountingMessageHandler.makeCountingMessageHandler(baseHandler);

    		if (buildConfig==null || buildConfig.isCheckRuntimeVersion()) {
	            if (DO_RUNTIME_VERSION_CHECK) {
	                String check = checkRtJar(buildConfig);
	                if (check != null) {
	                    if (FAIL_IF_RUNTIME_NOT_FOUND) {
	                        MessageUtil.error(handler, check);
	                        CompilationAndWeavingContext.leavingPhase(ct);
	                        return false;
	                    } else {
	                        MessageUtil.warn(handler, check);
	                    }
	                }
	            }
    		}

            // if (batch) {
                setBuildConfig(buildConfig);
            //}
            if (batch || !AsmManager.attemptIncrementalModelRepairs) {
//                if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) { 
                	setupModel(buildConfig);
//                }
            }
            if (batch) {
                initBcelWorld(handler);
            }
            if (handler.hasErrors()) {
               	CompilationAndWeavingContext.leavingPhase(ct);
                return false;
            }
            
            if (buildConfig.getOutputJar() != null) {
            	 if (!openOutputStream(buildConfig.getOutputJar())) {
                CompilationAndWeavingContext.leavingPhase(ct);
                return false;
            	 }
            }
            
            if (batch) {
                // System.err.println("XXXX batch: " + buildConfig.getFiles());
                if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) {  
                    getWorld().setModel(AsmManager.getDefault().getHierarchy());
                    // in incremental build, only get updated model?
                }
                binarySourcesForTheNextCompile = state.getBinaryFilesToCompile(true);
                performCompilation(buildConfig.getFiles());
                state.clearBinarySourceFiles(); // we don't want these hanging around...
                if (!proceedOnError() && handler.hasErrors()) {
                   	CompilationAndWeavingContext.leavingPhase(ct);
                  	if (AsmManager.isReporting())
    				    AsmManager.getDefault().reportModelInfo("After a batch build");
                    return false;
                }

				if (AsmManager.isReporting())
				    AsmManager.getDefault().reportModelInfo("After a batch build");
		
            } else {
// done already?
//                if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) {  
//                    bcelWorld.setModel(StructureModelManager.INSTANCE.getStructureModel());
//                }
                // System.err.println("XXXX start inc ");
                binarySourcesForTheNextCompile = state.getBinaryFilesToCompile(true);
                Set files = state.getFilesToCompile(true);
				if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode())
				if (AsmManager.attemptIncrementalModelRepairs)
				    AsmManager.getDefault().processDelta(files,state.getAddedFiles(),state.getDeletedFiles());
                boolean hereWeGoAgain = !(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
                for (int i = 0; (i < 5) && hereWeGoAgain; i++) {
                	   if (state.listenerDefined()) 
                		   state.getListener().recordInformation("Starting incremental compilation loop "+(i+1)+" of possibly 5");
                    // System.err.println("XXXX inc: " + files);
               
                    performCompilation(files);
                    if ((!proceedOnError() && handler.hasErrors()) || (progressListener!=null && progressListener.isCancelledRequested())) {
                        CompilationAndWeavingContext.leavingPhase(ct);
                        return false;
                    } 
                    
                    if (state.requiresFullBatchBuild()) {
                    	if (state.listenerDefined()) 
                 		   state.getListener().recordInformation(" Dropping back to full build");
                    	return batchBuild(buildConfig, baseHandler);
                    }
                    
                    binarySourcesForTheNextCompile = state.getBinaryFilesToCompile(false);
                    files = state.getFilesToCompile(false);
                    hereWeGoAgain = !(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
                    // TODO Andy - Needs some thought here...
                    // I think here we might want to pass empty addedFiles/deletedFiles as they were
                    // dealt with on the first call to processDelta - we are going through this loop
                    // again because in compiling something we found something else we needed to
                    // rebuild.  But what case causes this?
                    if (hereWeGoAgain) {
					  if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode())
					    if (AsmManager.attemptIncrementalModelRepairs)
						  AsmManager.getDefault().processDelta(files,state.getAddedFiles(),state.getDeletedFiles());
                    }
                }
                if (!files.isEmpty()) {
                   	CompilationAndWeavingContext.leavingPhase(ct);
                    return batchBuild(buildConfig, baseHandler);
                } else {                
                	if (AsmManager.isReporting()) 
			    	    AsmManager.getDefault().reportModelInfo("After an incremental build");
                }
            }

            // XXX not in Mik's incremental
            if (buildConfig.isEmacsSymMode()) {
                new org.aspectj.ajdt.internal.core.builder.EmacsStructureModelManager().externalizeModel();
            }
            
            // for bug 113554: support ajsym file generation for command line builds
            if (buildConfig.isGenerateCrossRefsMode()) {
	           File configFileProxy = new File(buildConfig.getOutputDir(),CROSSREFS_FILE_NAME);
	           AsmManager.getDefault().writeStructureModel(configFileProxy.getAbsolutePath());
            }
            
            // have to tell state we succeeded or next is not incremental
            state.successfulCompile(buildConfig,batch);

			// For a full compile, copy resources to the destination
			// - they should not get deleted on incremental and AJDT
			// will handle changes to them that require a recopying
            if (batch) {
            	copyResourcesToDestination();
            }
            
            if (buildConfig.getOutxmlName() != null) {
            	writeOutxmlFile();
            }
            
            /*boolean weaved = *///weaveAndGenerateClassFiles();
            // if not weaved, then no-op build, no model changes
            // but always returns true
            // XXX weaved not in Mik's incremental
            if (buildConfig.isGenerateModelMode()) {
                AsmManager.getDefault().fireModelUpdated();  
            }
           	CompilationAndWeavingContext.leavingPhase(ct);
            
        } finally {
        	if (baseHandler instanceof ILifecycleAware) {
        		((ILifecycleAware)baseHandler).buildFinished(!batch);
        	}
        	if (zos != null) {
        		closeOutputStream(buildConfig.getOutputJar());
        	}
            ret = !handler.hasErrors();
            if (getBcelWorld()!=null) getBcelWorld().tidyUp();
            if (getWeaver()!=null) getWeaver().tidyUp();
            // bug 59895, don't release reference to handler as may be needed by a nested call
            //handler = null;
        }
        return ret;
    }
================= fetch protected boolean proceedOnError() { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

boolean proceedOnError() {
		return buildConfig.getProceedOnError();
	}
================= fetch public AjBuildManager(IMessageHandler holder) { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

public BcelWorld getBcelWorld() { return state.getBcelWorld();}
================= fetch public FileSystem getLibraryAccess(String[] classpaths, String[] filenames) { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
//	}
public FileSystem getLibraryAccess(String[] classpaths, String[] filenames) {
		String defaultEncoding = buildConfig.getOptions().defaultEncoding;
		if ("".equals(defaultEncoding)) //$NON-NLS-1$
			defaultEncoding = null; //$NON-NLS-1$	
		// Bug 46671: We need an array as long as the number of elements in the classpath - *even though* not every
		// element of the classpath is likely to be a directory.  If we ensure every element of the array is set to
		// only look for BINARY, then we make sure that for any classpath element that is a directory, we won't build
		// a classpathDirectory object that will attempt to look for source when it can't find binary.
//		int[] classpathModes = new int[classpaths.length];
//		for (int i =0 ;i<classpaths.length;i++) classpathModes[i]=ClasspathDirectory.BINARY;
		return new FileSystem(classpaths, filenames, defaultEncoding,ClasspathLocation.BINARY);
	}
================= fetch public ICompilerAdapter getAdapter(org.aspectj.org.eclipse.jdt.internal.compiler d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/* (non-Javadoc)
	 * @see org.eclipse.jdt.internal.compiler.ICompilerAdapterFactory#getAdapter(org.eclipse.jdt.internal.compiler.Compiler)
	 */
public ICompilerAdapter getAdapter(org.aspectj.org.eclipse.jdt.internal.compiler.Compiler forCompiler) {
		// complete compiler config and return a suitable adapter...
		populateCompilerOptionsFromLintSettings(forCompiler);
		AjProblemReporter pr =
			new AjProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),
								  forCompiler.options, getProblemFactory());
		
		forCompiler.problemReporter = pr;
			
		AjLookupEnvironment le =
			new AjLookupEnvironment(forCompiler, forCompiler.options, pr, environment);
		EclipseFactory factory = new EclipseFactory(le,this);
		le.factory = factory;
		pr.factory = factory;
		
		forCompiler.lookupEnvironment = le;
		
		forCompiler.parser =
			new Parser(
				pr, 
				forCompiler.options.parseLiteralExpressionsAsConstants);
		if (getBcelWorld().shouldPipelineCompilation()) {
			IMessage message = MessageUtil.info("Pipelining compilation");
			handler.handleMessage(message);
			return new AjPipeliningCompilerAdapter(forCompiler,batchCompile,getBcelWorld(),getWeaver(),
					factory, 
					getInterimResultRequestor(),
					progressListener,
					this,  // IOutputFilenameProvider
					this,  // IBinarySourceProvider
					state.getBinarySourceMap(),
					buildConfig.isTerminateAfterCompilation(),
					buildConfig.getProceedOnError(),
					buildConfig.isNoAtAspectJAnnotationProcessing(),
					state);
		} else {
			return new AjCompilerAdapter(forCompiler,batchCompile,getBcelWorld(),getWeaver(),
							factory,
							getInterimResultRequestor(),
							progressListener,
							this,  // IOutputFilenameProvider
							this,  // IBinarySourceProvider
							state.getBinarySourceMap(),
							buildConfig.isTerminateAfterCompilation(),
							buildConfig.getProceedOnError(),
							buildConfig.isNoAtAspectJAnnotationProcessing(),
							state);
		}
	}
================= fetch public ICompilerRequestor getBatchRequestor() { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

ICompilerRequestor getBatchRequestor() {
		return new ICompilerRequestor() {
================= fetch public IHierarchy getStructureModel() { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/**
	 * Returns null if there is no structure model
	 */
public IHierarchy getStructureModel() {
		return structureModel;
	}
================= fetch public IProblemFactory getProblemFactory() { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/*
	 *  Build the set of compilation source units
	 */
public CompilationUnit[] getCompilationUnits(String[] filenames, String[] encodings) {
		int fileCount = filenames.length;
		CompilationUnit[] units = new CompilationUnit[fileCount];
//		HashtableOfObject knownFileNames = new HashtableOfObject(fileCount);

		String defaultEncoding = buildConfig.getOptions().defaultEncoding;
		if ("".equals(defaultEncoding)) //$NON-NLS-1$
			defaultEncoding = null; //$NON-NLS-1$

		for (int i = 0; i < fileCount; i++) {
			String encoding = encodings[i];
			if (encoding == null)
				encoding = defaultEncoding;
			units[i] = new CompilationUnit(null, filenames[i], encoding);
		}
		return units;
	}
================= fetch public Map getBinarySourcesForThisWeave() { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/* (non-Javadoc)
	 * @see org.aspectj.ajdt.internal.compiler.IBinarySourceProvider#getBinarySourcesForThisWeave()
	 */
public Map getBinarySourcesForThisWeave() {
		return binarySourcesForTheNextCompile;
	}
================= fetch public Object getCustomMungerFactory() { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

public Object getCustomMungerFactory() {
		return customMungerFactory;
	}
================= fetch public String extractDestinationPathFromSourceFile(CompilationResult result) { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

public String extractDestinationPathFromSourceFile(CompilationResult result) {
		ICompilationUnit compilationUnit = result.compilationUnit;
		if (compilationUnit != null) {
			char[] fileName = compilationUnit.getFileName();
			int lastIndex = CharOperation.lastIndexOf(java.io.File.separatorChar, fileName);
			if (lastIndex == -1) {
				return System.getProperty("user.dir"); //$NON-NLS-1$
			}
			return new String(CharOperation.subarray(fileName, 0, lastIndex));
		}
		return System.getProperty("user.dir"); //$NON-NLS-1$
	}
================= fetch public String formatEntry(int phaseId, Object data) { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

public void setState(AjState buildState) {
		state = buildState;
	}
================= fetch public String getOutputClassFileName(char[] eclipseClassFileName, CompilationRes d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/* (non-Javadoc)
	 * @see org.aspectj.ajdt.internal.compiler.AjCompiler.IOutputClassFileNameProvider#getOutputClassFileName(char[])
	 */
public String getOutputClassFileName(char[] eclipseClassFileName, CompilationResult result) {
		String filename = new String(eclipseClassFileName);
		filename = filename.replace('/', File.separatorChar) + ".class";
		File destinationPath = buildConfig.getOutputDir();
		if (buildConfig.getCompilationResultDestinationManager() != null) {
			File f = new File(new String(result.getFileName()));
			destinationPath = buildConfig.getCompilationResultDestinationManager().getOutputLocationForClass(f);
		}
		String outFile;
		if (destinationPath == null) {
			outFile = new File(filename).getName();
			outFile = new File(extractDestinationPathFromSourceFile(result), outFile).getPath();
		} else {
			outFile = new File(destinationPath, filename).getPath();
		}
		return outFile;		
	}
================= fetch public String toString() { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

public String toString() {
		StringBuffer buf = new StringBuffer();
		buf.append("AjBuildManager(");
		buf.append(")");
		return buf.toString();
	}
================= fetch public World getWorld() { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

public World getWorld() {
		return getBcelWorld();
	}
================= fetch public boolean accept(File f) { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void copyResourcesFromDirectory(File dir) throws IOException {
		if (!COPY_INPATH_DIR_RESOURCES) return;
		// Get a list of all files (i.e. everything that isnt a directory)
		File[] files = FileUtil.listFiles(dir,new FileFilter() {
			public boolean accept(File f) {
				boolean accept = !(f.isDirectory() || f.getName().endsWith(".class")) ;
				return accept;
			}
		});
		
		// For each file, add it either as a real .class file or as a resource
		for (int i = 0; i < files.length; i++) {
			// ASSERT: files[i].getAbsolutePath().startsWith(inFile.getAbsolutePath()
			// or we are in trouble...
			String filename = files[i].getAbsolutePath().substring(
			                    dir.getAbsolutePath().length()+1);
			copyResourcesFromFile(files[i],filename,dir);
		}		
	}
================= fetch public boolean wasFullBuild() { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

boolean wasFullBuild() {
		return wasFullBuild;
	}
================= fetch public void acceptResult(CompilationResult unitResult) { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

public ICompilerRequestor getBatchRequestor() {
		return new ICompilerRequestor() {
			
			public void acceptResult(CompilationResult unitResult) {
				// end of compile, must now write the results to the output destination
				// this is either a jar file or a file in a directory
				if (!unitResult.hasErrors() || proceedOnError()) {			
					Collection classFiles = unitResult.compiledTypes.values();
					boolean shouldAddAspectName = (buildConfig.getOutxmlName() != null);
					for (Iterator iter = classFiles.iterator(); iter.hasNext();) {
						ClassFile classFile = (ClassFile) iter.next();					
						String filename = new String(classFile.fileName());
						String classname = filename.replace('/', '.');
						filename = filename.replace('/', File.separatorChar) + ".class";
						try {
							if (buildConfig.getOutputJar() == null) {
								writeDirectoryEntry(unitResult, classFile,filename);
							} else {
								writeZipEntry(classFile,filename);
							}
							if (shouldAddAspectName) addAspectName(classname, unitResult.getFileName());
						} catch (IOException ex) {
							IMessage message = EclipseAdapterUtils.makeErrorMessage(
									new String(unitResult.fileName),
									CANT_WRITE_RESULT,
									ex);
							handler.handleMessage(message);
						}

					}
					unitResult.compiledTypes.clear(); // free up references to AjClassFile instances
				}
				
				if (unitResult.hasProblems() || unitResult.hasTasks()) {
					IProblem[] problems = unitResult.getAllProblems();
					for (int i=0; i < problems.length; i++) {
						IMessage message =
							EclipseAdapterUtils.makeMessage(unitResult.compilationUnit, problems[i],getBcelWorld());
						handler.handleMessage(message);
					}
				}

			}
================= fetch public void acceptResult(InterimCompilationResult result) { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

public IIntermediateResultsRequestor getInterimResultRequestor() {
		return new IIntermediateResultsRequestor() {
			public void acceptResult(InterimCompilationResult result) {
				if (progressListener != null) {
					compiledCount++;
					progressListener.setProgress((compiledCount/2.0)/sourceFileCount);
					progressListener.setText("compiled: " + result.fileName());
				}
				state.noteResult(result);
				
				if (progressListener!=null && progressListener.isCancelledRequested()) { 
					throw new AbortCompilation(true,
					  new OperationCanceledException("Compilation cancelled as requested"));
				}
			}
		};
	}
================= fetch public void environmentSupportsIncrementalCompilation(boolean itDoes) { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

public void environmentSupportsIncrementalCompilation(boolean itDoes) {
		this.environmentSupportsIncrementalCompilation = itDoes;
	}
================= fetch public void installGlobals(AjBuildConfig global) { // XXX relies on default valu d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java
/**
	 * Install global values into local config unless values conflict:
	 * <ul>
	 * <li>Collections are unioned</li>
	 * <li>values takes local value unless default and global set</li>
	 * <li>this only sets one of outputDir and outputJar as needed</li>
	 * <ul>
	 * This also configures super if javaOptions change.
	 * 
	 * @param global the AjBuildConfig to read globals from
	 */
public void installGlobals(AjBuildConfig global) { // XXX relies on default values
		// don't join the options - they already have defaults taken care of.
		// Map optionsMap = options.getMap();
		// join(optionsMap,global.getOptions().getMap());
		// options.set(optionsMap);
		join(aspectpath, global.aspectpath);
		join(classpath, global.classpath);
		if (null == configFile) {
			configFile = global.configFile; // XXX correct?
		}
		if (!isEmacsSymMode() && global.isEmacsSymMode()) {
			setEmacsSymMode(true);
		}
		join(files, global.files);
		if (!isGenerateModelMode() && global.isGenerateModelMode()) {
			setGenerateModelMode(true);
		}
		if (null == incrementalFile) {
			incrementalFile = global.incrementalFile;
		}
		if (!incrementalMode && global.incrementalMode) {
			incrementalMode = true;
		}

		if (isCheckRuntimeVersion() && !global.isCheckRuntimeVersion()) {
			setCheckRuntimeVersion(false);
		}

		join(inJars, global.inJars);
		join(inPath, global.inPath);
		if ((null == lintMode) || (AJLINT_DEFAULT.equals(lintMode))) {
			setLintMode(global.lintMode);
		}
		if (null == lintSpecFile) {
			lintSpecFile = global.lintSpecFile;
		}
		if (!isTerminateAfterCompilation() && global.isTerminateAfterCompilation()) {
			setTerminateAfterCompilation(true);
		}
		if ((null == outputDir) && (null == outputJar)) {
			if (null != global.outputDir) {
				outputDir = global.outputDir;
			}
			if (null != global.outputJar) {
				outputJar = global.outputJar;
			}
		}
		join(sourceRoots, global.sourceRoots);
		if (!isXnoInline() && global.isXnoInline()) {
			setXnoInline(true);
		}
		if (!isXserializableAspects() && global.isXserializableAspects()) {
			setXserializableAspects(true);
		}
		if (!isXlazyTjp() && global.isXlazyTjp()) {
			setXlazyTjp(true);
		}
		if (!getProceedOnError() && global.getProceedOnError()) {
			setProceedOnError(true);
		}
		setTargetAspectjRuntimeLevel(global.getTargetAspectjRuntimeLevel());
		setXJoinpoints(global.getXJoinpoints());
		if (!isXHasMemberEnabled() && global.isXHasMemberEnabled()) {
			setXHasMemberSupport(true);
		}
		if (!isXNotReweavable() && global.isXNotReweavable()) {
			setXnotReweavable(true);
		}
		setOutxmlName(global.getOutxmlName());
		setXconfigurationInfo(global.getXconfigurationInfo());
		setAddSerialVerUID(global.isAddSerialVerUID());
	}
================= fetch public void performCompilation(Collection files) { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

public void performCompilation(Collection files) {
		if (progressListener != null) {
			compiledCount=0;
			sourceFileCount = files.size();
			progressListener.setText("compiling source files");
		}
		//System.err.println("got files: " + files);
		String[] filenames = new String[files.size()];
		String[] encodings = new String[files.size()];
		//System.err.println("filename: " + this.filenames);
		int ii = 0;
        for (Iterator fIterator = files.iterator(); fIterator.hasNext();) {
            File f = (File) fIterator.next();
            filenames[ii++] = f.getPath();
        }
		
		List cps = buildConfig.getFullClasspath();
		Dump.saveFullClasspath(cps);
		String[] classpaths = new String[cps.size()];
		for (int i=0; i < cps.size(); i++) {
			classpaths[i] = (String)cps.get(i);
		}
		
		//System.out.println("compiling");
		environment = getLibraryAccess(classpaths, filenames);
		
		//if (!state.getClassNameToFileMap().isEmpty()) { // see pr133532 (disabled to state can be used to answer questions)
		environment = new StatefulNameEnvironment(environment, state.getClassNameToFileMap(),state);
		//}
		
		org.aspectj.ajdt.internal.compiler.CompilerAdapter.setCompilerAdapterFactory(this);
		org.aspectj.org.eclipse.jdt.internal.compiler.Compiler compiler = 
			new org.aspectj.org.eclipse.jdt.internal.compiler.Compiler(environment,
					DefaultErrorHandlingPolicies.proceedWithAllProblems(),
				    buildConfig.getOptions().getMap(),
					getBatchRequestor(),
					getProblemFactory());
		
		CompilerOptions options = compiler.options;

		options.produceReferenceInfo = true; //TODO turn off when not needed
		
		try {
		 	compiler.compile(getCompilationUnits(filenames, encodings));
		} catch (OperationCanceledException oce) {
			handler.handleMessage(new Message("build cancelled:"+oce.getMessage(),IMessage.WARNING,null,null));
		}
		// cleanup
		org.aspectj.ajdt.internal.compiler.CompilerAdapter.setCompilerAdapterFactory(null);
		AnonymousClassPublisher.aspectOf().setAnonymousClassCreationListener(null);
		environment.cleanup();
		environment = null;
	}
================= fetch public void setProgressListener(IProgressListener progressListener) { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

public void setProgressListener(IProgressListener progressListener) {
		this.progressListener = progressListener;
	}
================= fetch public void setState(AjState buildState) { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

public void setState(AjState buildState) {
		state = buildState;
	}
================= fetch void addAspectClassFilesToWeaver(List addedClassFiles) throws IOException { d5c2ead^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

void addAspectClassFilesToWeaver(List addedClassFiles) throws IOException {
		for (Iterator i = addedClassFiles.iterator(); i.hasNext(); ) {
			UnwovenClassFile classFile = (UnwovenClassFile) i.next();
			getWeaver().addClassFile(classFile);
		}
	}
Progress : [############----------------------------] 31%================= fetch protected void makeRectangular(){ 6d906dc^:docs/dist/doc/examples/introduction/Point.java

protected void makeRectangular(){
      if (!rectangular) {
	 x = rho * Math.sin(theta);
	 y = rho * Math.cos(theta);
	 rectangular = true;
      }
   }
================= fetch List parseDefinitions(final ClassLoader loader) { df49b5c^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
     * Load and cache the aop.xml/properties according to the classloader visibility rules
     *
     * @param weaver
     * @param loader
     */
List parseDefinitions(final ClassLoader loader) {
        if (trace.isTraceEnabled()) trace.enter("parseDefinitions", this);

        List definitions = new ArrayList();
    	try {
            info("register classloader " + getClassLoaderName(loader));
            //TODO av underoptimized: we will parse each XML once per CL that see it

            //TODO av dev mode needed ? TBD -Daj5.def=...
            if (loader.equals(ClassLoader.getSystemClassLoader())) {
                String file = System.getProperty("aj5.def", null);
                if (file != null) {
                    info("using (-Daj5.def) " + file);
                    definitions.add(DocumentParser.parse((new File(file)).toURL()));
                }
            }

            String resourcePath = System.getProperty("org.aspectj.weaver.loadtime.configuration",AOP_XML);
            if (trace.isTraceEnabled()) trace.event("parseDefinitions",this,resourcePath);
    		StringTokenizer st = new StringTokenizer(resourcePath,";");

    		while(st.hasMoreTokens()){
    			Enumeration xmls = weavingContext.getResources(st.nextToken());
//    			System.out.println("? registerDefinitions: found-aop.xml=" + xmls.hasMoreElements() + ", loader=" + loader);

    			Set seenBefore = new HashSet();
    			while (xmls.hasMoreElements()) {
    			    URL xml = (URL) xmls.nextElement();
    			    if (trace.isTraceEnabled()) trace.event("parseDefinitions",this,xml);
    			    if (!seenBefore.contains(xml)) {
    			    	info("using configuration " + weavingContext.getFile(xml));
    			    	definitions.add(DocumentParser.parse(xml));
        			    seenBefore.add(xml);
    			    }
    			    else {
    			    	warn("ignoring duplicate definition: " + xml);
    			    }
    			}
    		}
    		if (definitions.isEmpty()) {
        		info("no configuration found. Disabling weaver for class loader " + getClassLoaderName(loader));
    		}
        } catch (Exception e) {
        	definitions.clear();
            warn("parse definitions failed",e);
        }
        
        if (trace.isTraceEnabled()) trace.exit("parseDefinitions",definitions);
		return definitions;
    }
================= fetch protected void fillDeclaredMembers() { e9823aa^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java

protected void fillDeclaredMembers() {
		List declaredPointcuts = new ArrayList();
		List declaredMethods = new ArrayList();
		List declaredFields = new ArrayList();
		
		binding.methods();  // the important side-effect of this call is to make sure bindings are completed
		AbstractMethodDeclaration[] methods = declaration.methods;
		if (methods != null) {
			for (int i=0, len=methods.length; i < len; i++) {
				AbstractMethodDeclaration amd = methods[i];
				if (amd == null || amd.ignoreFurtherInvestigation) continue;
				if (amd instanceof PointcutDeclaration) {
					PointcutDeclaration d = (PointcutDeclaration)amd;
					ResolvedPointcutDefinition df = d.makeResolvedPointcutDefinition(factory);
					declaredPointcuts.add(df);
				} else if (amd instanceof InterTypeDeclaration) {				
					// these are handled in a separate pass
					continue;
				} else if (amd instanceof DeclareDeclaration && 
				           !(amd instanceof DeclareAnnotationDeclaration)) { // surfaces the annotated ajc$ method
					// these are handled in a separate pass
					continue;
				} else if (amd instanceof AdviceDeclaration) {
					// these are ignored during compilation and only used during weaving
					continue;
				}  else if ((amd.annotations != null) && isAnnotationStylePointcut(amd.annotations)) {
					// consider pointcuts defined via annotations
					ResolvedPointcutDefinition df = makeResolvedPointcutDefinition(amd);
					if (df!=null) declaredPointcuts.add(df);
				} else {
					if (amd.binding == null || !amd.binding.isValidBinding()) continue;
					ResolvedMember member = factory.makeResolvedMember(amd.binding);
					if (unit != null) {
						member.setSourceContext(new EclipseSourceContext(unit.compilationResult,amd.binding.sourceStart()));
						member.setPosition(amd.binding.sourceStart(),amd.binding.sourceEnd());
					}
					declaredMethods.add(member);
				}
			}
		}

		FieldBinding[] fields = binding.fields();
		for (int i=0, len=fields.length; i < len; i++) {
			FieldBinding f = fields[i];
			declaredFields.add(factory.makeResolvedMember(f));
		}
			
		this.declaredPointcuts = (ResolvedPointcutDefinition[])
			declaredPointcuts.toArray(new ResolvedPointcutDefinition[declaredPointcuts.size()]);
		this.declaredMethods = (ResolvedMember[])
			declaredMethods.toArray(new ResolvedMember[declaredMethods.size()]);
		this.declaredFields = (ResolvedMember[])
			declaredFields.toArray(new ResolvedMember[declaredFields.size()]);
	}
================= fetch public static AnnotationTypePattern read(VersionedDataInputStream s, ISourceCont be03167^:weaver/src/org/aspectj/weaver/patterns/AndAnnotationTypePattern.java

public static AnnotationTypePattern read(VersionedDataInputStream s, ISourceContext context) throws IOException {
		AnnotationTypePattern p = new AndAnnotationTypePattern(
				AnnotationTypePattern.read(s,context),
				AnnotationTypePattern.read(s,context));
		p.readLocation(context,s);
		if (s.getMajorVersion()>=WeaverVersionInfo.WEAVER_VERSION_MINOR_AJ160) {
			if (s.readBoolean()) p.setForParameterAnnotationMatch();			
		}
		return p;		
	}
================= fetch public static AnnotationTypePattern read(VersionedDataInputStream s, ISourceCont be03167^:weaver/src/org/aspectj/weaver/patterns/NotAnnotationTypePattern.java

public static AnnotationTypePattern read(VersionedDataInputStream s, ISourceContext context) throws IOException {
		AnnotationTypePattern ret = new NotAnnotationTypePattern(AnnotationTypePattern.read(s,context));
		ret.readLocation(context,s);
		if (s.getMajorVersion()>=WeaverVersionInfo.WEAVER_VERSION_MINOR_AJ160) {
			if (s.readBoolean()) ret.setForParameterAnnotationMatch();
		}
		return ret;
	}
================= fetch public static AnnotationTypePattern read(VersionedDataInputStream s, ISourceCont be03167^:weaver/src/org/aspectj/weaver/patterns/OrAnnotationTypePattern.java

public static AnnotationTypePattern read(VersionedDataInputStream s, ISourceContext context) throws IOException {
		AnnotationTypePattern p = new OrAnnotationTypePattern(
				AnnotationTypePattern.read(s,context),
				AnnotationTypePattern.read(s,context));
		p.readLocation(context,s);
		if (s.getMajorVersion()>=WeaverVersionInfo.WEAVER_VERSION_MINOR_AJ160) {
			if (s.readBoolean()) p.setForParameterAnnotationMatch();
		}
		return p;		
	}
================= fetch public static AnnotationTypePattern read(VersionedDataInputStream s,ISourceConte be03167^:weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java

public static AnnotationTypePattern read(VersionedDataInputStream s,ISourceContext context) throws IOException {
		WildAnnotationTypePattern ret;
		byte version = s.readByte();
		if (version > VERSION) {
			throw new BCException("ExactAnnotationTypePattern was written by a newer version of AspectJ");
		}
		TypePattern t = TypePattern.read(s,context);
		ret = new WildAnnotationTypePattern(t);
		ret.readLocation(context,s);
		if (s.getMajorVersion()>=WeaverVersionInfo.WEAVER_VERSION_MINOR_AJ160) {
			if (s.readBoolean()) ret.setForParameterAnnotationMatch();
		}
		if (s.getMajorVersion()>=WeaverVersionInfo.WEAVER_VERSION_MAJOR_AJ160M2) {
			int annotationValueCount = s.readInt();
			if (annotationValueCount>0) {
				Map aValues = new HashMap();
				for (int i=0;i<annotationValueCount;i++) {
					String key = s.readUTF();
					String val = s.readUTF();
					aValues.put(key,val);
				}
				ret.annotationValues = aValues;
			}
		}
		return ret;		
	}
================= fetch protected Test findResidueInternal(Shadow shadow, ExposedState state) { 248962b^:weaver/src/org/aspectj/weaver/patterns/IfPointcut.java

public static IfPointcut makeIfTruePointcut(State state) {
		IfPointcut ret = new IfTruePointcut();
		ret.state = state;
		return ret;
	}
Progress : [############----------------------------] 32%================= fetch private TypeBinding makeTypeBinding1(UnresolvedType typeX) { 3b2109a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

private TypeBinding makeTypeBinding1(UnresolvedType typeX) {
		if (typeX.isPrimitiveType()) { 
			if (typeX == ResolvedType.BOOLEAN) return TypeBinding.BOOLEAN;
			if (typeX == ResolvedType.BYTE) return TypeBinding.BYTE;
			if (typeX == ResolvedType.CHAR) return TypeBinding.CHAR;
			if (typeX == ResolvedType.DOUBLE) return TypeBinding.DOUBLE;
			if (typeX == ResolvedType.FLOAT) return TypeBinding.FLOAT;
			if (typeX == ResolvedType.INT) return TypeBinding.INT;
			if (typeX == ResolvedType.LONG) return TypeBinding.LONG;
			if (typeX == ResolvedType.SHORT) return TypeBinding.SHORT;
			if (typeX == ResolvedType.VOID) return TypeBinding.VOID;
			throw new RuntimeException("weird primitive type " + typeX);
		} else if (typeX.isArray()) {
			int dim = 0;
			while (typeX.isArray()) {
				dim++;
				typeX = typeX.getComponentType();
			}
			return lookupEnvironment.createArrayType(makeTypeBinding(typeX), dim);
		} else if (typeX.isParameterizedType()) {
		    // Converting back to a binding from a UnresolvedType
		    UnresolvedType[] typeParameters = typeX.getTypeParameters();
			ReferenceBinding baseTypeBinding = lookupBinding(typeX.getBaseName());
			TypeBinding[] argumentBindings = new TypeBinding[typeParameters.length];
			baseTypeForParameterizedType = baseTypeBinding;
			for (int i = 0; i < argumentBindings.length; i++) {
				indexOfTypeParameterBeingConverted = i;
				argumentBindings[i] = makeTypeBinding(typeParameters[i]);
			}
			indexOfTypeParameterBeingConverted = 0;
			baseTypeForParameterizedType = null;
			ParameterizedTypeBinding ptb = 
				lookupEnvironment.createParameterizedType(baseTypeBinding,argumentBindings,baseTypeBinding.enclosingType());
			return ptb;
		} else if (typeX.isTypeVariableReference()) {
//			return makeTypeVariableBinding((TypeVariableReference)typeX);
			return makeTypeVariableBindingFromAJTypeVariable(((TypeVariableReference)typeX).getTypeVariable());
		} else if (typeX.isRawType()) {
			ReferenceBinding baseTypeBinding = lookupBinding(typeX.getBaseName());
			RawTypeBinding rtb = lookupEnvironment.createRawType(baseTypeBinding,baseTypeBinding.enclosingType());
			return rtb;
		} else if (typeX.isGenericWildcard()) {
		    // translate from boundedreferencetype to WildcardBinding
			BoundedReferenceType brt = (BoundedReferenceType)typeX;
			// Work out 'kind' for the WildcardBinding
			int boundkind = Wildcard.UNBOUND;
			TypeBinding bound = null;
			if (brt.isExtends()) {
				boundkind = Wildcard.EXTENDS;
				bound = makeTypeBinding(brt.getUpperBound());
			} else if (brt.isSuper()) {
				boundkind = Wildcard.SUPER;
				bound = makeTypeBinding(brt.getLowerBound());
			}
			TypeBinding[] otherBounds = null;
			if (brt.getAdditionalBounds()!=null && brt.getAdditionalBounds().length!=0) otherBounds = makeTypeBindings(brt.getAdditionalBounds());
			WildcardBinding wb = lookupEnvironment.createWildcard(baseTypeForParameterizedType,indexOfTypeParameterBeingConverted,bound,otherBounds,boundkind);
			return wb;
		} else {
			return lookupBinding(typeX.getName());
		}
	}
================= fetch private void addIfAspect(byte[] bytes, String name, List toList) throws IOExcept 93b7bed^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java

void addIfAspect(byte[] bytes, String name, List toList) throws IOException {
		ClassParser parser = new ClassParser(new ByteArrayInputStream(bytes),name);
		JavaClass jc = parser.parse();
		ResolvedType type = world.addSourceObjectType(jc).getResolvedTypeX();
		String typeName = type.getName().replace('.', File.separatorChar);
		int end = name.indexOf(typeName);
		String binaryPath = name.substring(0,end-1);
		type.setBinaryPath(binaryPath);
		if (type.isAspect()) {
			toList.add(type);
		}		
	}
================= fetch public boolean accept(File pathname) { 93b7bed^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java

private List addAspectsFromDirectory(File dir) throws FileNotFoundException, IOException{
		List addedAspects = new ArrayList();
		File[] classFiles = FileUtil.listFiles(dir,new FileFilter(){
		
			public boolean accept(File pathname) {
				return pathname.getName().endsWith(".class");
			}
		
		});
		for (int i = 0; i < classFiles.length; i++) {
			FileInputStream fis = new FileInputStream(classFiles[i]);
			byte[] bytes = FileUtil.readAsByteArray(fis);
			addIfAspect(bytes,classFiles[i].getAbsolutePath(),addedAspects);
			fis.close();
		}
		return addedAspects;
	}
================= fetch private static void createBridgeMethod(BcelWorld world, LazyMethodGen whatToBrid f014275^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
	 * Create a single bridge method called 'theBridgeMethod' that bridges to 'whatToBridgeTo'
	 */
private static void createBridgeMethod(BcelWorld world, LazyMethodGen whatToBridgeToMethodGen, LazyClassGen clazz,ResolvedMember theBridgeMethod) {
		InstructionList body;
		InstructionFactory fact;
		int pos = 0;

		ResolvedMember whatToBridgeTo = whatToBridgeToMethodGen.getMemberView();
		
		if (whatToBridgeTo==null) {
			whatToBridgeTo = 
			  new ResolvedMemberImpl(Member.METHOD,
				whatToBridgeToMethodGen.getEnclosingClass().getType(),
				whatToBridgeToMethodGen.getAccessFlags(),
				whatToBridgeToMethodGen.getName(),
				whatToBridgeToMethodGen.getSignature());
		}
		LazyMethodGen bridgeMethod = makeBridgeMethod(clazz,theBridgeMethod); // The bridge method in this type will have the same signature as the one in the supertype
		bridgeMethod.setAccessFlags(bridgeMethod.getAccessFlags() | 0x00000040 /*BRIDGE    = 0x00000040*/ );
		Type returnType   = BcelWorld.makeBcelType(theBridgeMethod.getReturnType());
		Type[] paramTypes = BcelWorld.makeBcelTypes(theBridgeMethod.getParameterTypes());
		Type[] newParamTypes=whatToBridgeToMethodGen.getArgumentTypes();
		body = bridgeMethod.getBody();
		fact = clazz.getFactory();

		if (!whatToBridgeToMethodGen.isStatic()) {
		   body.append(InstructionFactory.createThis());
		   pos++;
		}
		for (int i = 0, len = paramTypes.length; i < len; i++) {
		  Type paramType = paramTypes[i];
		  body.append(InstructionFactory.createLoad(paramType, pos));
		  if (!newParamTypes[i].equals(paramTypes[i])) {
			  if (world.forDEBUG_bridgingCode) System.err.println("Bridging: Cast "+newParamTypes[i]+" from "+paramTypes[i]);
			  body.append(fact.createCast(paramTypes[i],newParamTypes[i]));
		  }
		  pos+=paramType.getSize();
		}

		body.append(Utility.createInvoke(fact, world,whatToBridgeTo));
		body.append(InstructionFactory.createReturn(returnType));
		clazz.addMethodGen(bridgeMethod);
	}
================= fetch private static int locateFirstBracket(StringBuffer signature) { a8739e3^:weaver/src/org/aspectj/weaver/TypeFactory.java

private static UnresolvedType[] createTypeParams(String typeParameterSpecification) {
		String remainingToProcess = typeParameterSpecification;
		List types = new ArrayList();
		while(!remainingToProcess.equals("")) {
			int endOfSig = 0;
			int anglies = 0;
			boolean sigFound = false;
			for (endOfSig = 0; (endOfSig < remainingToProcess.length()) && !sigFound; endOfSig++) {
				char thisChar = remainingToProcess.charAt(endOfSig);
				switch(thisChar) {
				case '<' : anglies++; break;
				case '>' : anglies--; break;
				case ';' : 
					if (anglies == 0) {
						sigFound = true;
						break;
					}
				}
			}
			types.add(createTypeFromSignature(remainingToProcess.substring(0,endOfSig)));
			remainingToProcess = remainingToProcess.substring(endOfSig);
		}
		UnresolvedType[] typeParams = new UnresolvedType[types.size()];
		types.toArray(typeParams);
		return typeParams;
	}
================= fetch public static IMessage makeMessage(ICompilationUnit unit, IProblem problem, Worl d3c3e32^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java
/** 
     * Extract message text and source location, including context. 
     * @param world 
     */
public static IMessage makeMessage(ICompilationUnit unit, IProblem problem, World world) { 
        ISourceLocation sourceLocation = makeSourceLocation(unit, problem);
        IProblem[] seeAlso = problem.seeAlso();
        ISourceLocation[] seeAlsoLocations = new ISourceLocation[seeAlso.length];
        for (int i = 0; i < seeAlso.length; i++) {
        	seeAlsoLocations[i] = new SourceLocation(new File(new String(seeAlso[i].getOriginatingFileName())),
        											 seeAlso[i].getSourceLineNumber());
													 
		}
		// We transform messages from AJ types to eclipse IProblems
		// and back to AJ types.  During their time as eclipse problems,
		// we remember whether the message originated from a declare
		// in the extraDetails.
		String extraDetails = problem.getSupplementaryMessageInfo();
		boolean declared = false;
		boolean isLintMessage = false;
		String lintkey = null;
		if (extraDetails!=null && extraDetails.endsWith("[deow=true]")) {
			declared = true;
			extraDetails = extraDetails.substring(0,extraDetails.length()-"[deow=true]".length());
		}
		if (extraDetails!=null && extraDetails.indexOf("[Xlint:")!=-1) {
			isLintMessage = true;
			lintkey = extraDetails.substring(extraDetails.indexOf("[Xlint:"));
			lintkey = lintkey.substring("[Xlint:".length());
			lintkey = lintkey.substring(0,lintkey.indexOf("]"));
		}
		
		// If the 'problem' represents a TO DO kind of thing then use the message kind that
		// represents this so AJDT sees it correctly.
		IMessage.Kind kind;
		if (problem.getID()==IProblem.Task) {
		  kind=IMessage.TASKTAG;
		} else {
		  if (problem.isError()) { kind = IMessage.ERROR; }
		  else                   { kind = IMessage.WARNING; }
		}
		IMessage msg = null;
		if (isLintMessage) {
		  msg = new LintMessage(
				   problem.getMessage(), 
				   extraDetails,
				   world.getLint().fromKey(lintkey),
				   kind,
				   sourceLocation, 
				   null,
				   seeAlsoLocations,
				   declared,
				   problem.getID(),
				   problem.getSourceStart(),problem.getSourceEnd());
		} else {
          msg = new Message(problem.getMessage(), 
        						   extraDetails,
								   kind,
								   sourceLocation, 
								   null,
								   seeAlsoLocations,
								   declared,
								   problem.getID(),
								   problem.getSourceStart(),problem.getSourceEnd());
		}
		return msg;
    }
================= fetch private static void assertGoodBranchInstruction( 5f97d46^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

private static void assertGoodBranchInstruction(
		BranchHandle ih,
		BranchInstruction inst,
		Set body,
		Stack ranges,
		String from)
	{
		if (ih.getTarget() != inst.getTarget()) {
			throw new BCException("bad branch instruction/handle pair in " + from);
		}
		InstructionHandle target = ih.getTarget();
		assertInBody(target, body, from);
		assertTargetedBy(target, inst, from);
		if (inst instanceof Select) {
			Select sel = (Select) inst;
            InstructionHandle[] itargets = sel.getTargets();
            for (int k = itargets.length - 1; k >= 0; k--) { 
				assertInBody(itargets[k], body, from);
				assertTargetedBy(itargets[k], inst, from);
            }
        }
	}
================= fetch private static void assertGoodHandle(InstructionHandle ih, Set body, Stack range 5f97d46^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

private static void assertGoodHandle(InstructionHandle ih, Set body, Stack ranges, String from) {
		Instruction inst = ih.getInstruction();
		if ((inst instanceof BranchInstruction) ^ (ih instanceof BranchHandle)) {
			throw new BCException("bad instruction/handle pair in " + from);
		}
		if (Range.isRangeHandle(ih)) {
			assertGoodRangeHandle(ih, body, ranges, from);
		} else if (inst instanceof BranchInstruction) {
			assertGoodBranchInstruction((BranchHandle) ih, (BranchInstruction) inst, body, ranges, from);
		}
	}
================= fetch private static void assertGoodRange(Range r, Set body, String from) { 5f97d46^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

private static void assertGoodRange(Range r, Set body, String from) {
		assertInBody(r.getStart(), body, from);
		assertRangeHandle(r.getStart(), from);
		assertTargetedBy(r.getStart(), r, from);

		assertInBody(r.getEnd(), body, from);
		assertRangeHandle(r.getEnd(), from);
		assertTargetedBy(r.getEnd(), r, from);
		
		if (r instanceof ExceptionRange) {
			ExceptionRange er = (ExceptionRange) r;
			assertInBody(er.getHandler(), body, from);
			assertTargetedBy(er.getHandler(), r, from);
		}    	
    }
================= fetch private static void assertGoodRangeHandle(InstructionHandle ih, Set body, Stack 5f97d46^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

private static void assertGoodRangeHandle(InstructionHandle ih, Set body, Stack ranges, String from) {
		Range r = getRangeAndAssertExactlyOne(ih, from);
		assertGoodRange(r, body, from);
		if (r.getStart() == ih) {
			ranges.push(r);
		} else if (r.getEnd() == ih) {
			if (ranges.peek() != r) throw new BCException("bad range inclusion in " + from);
			ranges.pop();
		}
    }
================= fetch private static void assertGoodTargeter( 5f97d46^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

private static void assertGoodTargeter(
        InstructionTargeter t,
        InstructionHandle ih,
        Set body,
        String from)
    {
    	assertTargets(t, ih, from);
		if (t instanceof Range) {
			assertGoodRange((Range) t, body, from);
		} else if (t instanceof BranchInstruction) {
			assertInBody(t, body, from);
		}
    }
================= fetch private static void assertInBody(Object ih, Set body, String from) { 5f97d46^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
/** ih is an InstructionHandle or a BranchInstruction */
private static void assertInBody(Object ih, Set body, String from) {
		if (! body.contains(ih)) throw new BCException("thing not in body in " + from);
	}
================= fetch private void addExceptionHandlers(MethodGen gen, Map map, LinkedList exnList) { 5f97d46^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

private void addExceptionHandlers(MethodGen gen, Map map, LinkedList exnList) {
		// now add exception handlers
        for (Iterator iter = exnList.iterator(); iter.hasNext();) {
            ExceptionRange r = (ExceptionRange) iter.next();
            if (r.isEmpty()) continue;
            gen.addExceptionHandler(
                remap(r.getRealStart(), map), 
                remap(r.getRealEnd(), map),
                remap(r.getHandler(), map),
                (r.getCatchType() == null)
                ? null 
                : (ObjectType) BcelWorld.makeBcelType(r.getCatchType()));
        }
	}
================= fetch private void match( 5f97d46^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

private void match(
		LazyMethodGen mg,
		InstructionHandle ih,
		BcelShadow enclosingShadow,
		List shadowAccumulator) 
	{
		Instruction i = ih.getInstruction();
		if ((i instanceof FieldInstruction) && 
			(canMatch(Shadow.FieldGet) || canMatch(Shadow.FieldSet))
		) {
			FieldInstruction fi = (FieldInstruction) i;
						
			if (fi instanceof PUTFIELD || fi instanceof PUTSTATIC) {
				// check for sets of constant fields.  We first check the previous 
				// instruction.  If the previous instruction is a LD_WHATEVER (push
				// constant on the stack) then we must resolve the field to determine
				// if it's final.  If it is final, then we don't generate a shadow.
				InstructionHandle prevHandle = ih.getPrev();
				Instruction prevI = prevHandle.getInstruction();
				if (Utility.isConstantPushInstruction(prevI)) {
					Member field = BcelWorld.makeFieldJoinPointSignature(clazz, (FieldInstruction) i);
					ResolvedMember resolvedField = field.resolve(world);
					if (resolvedField == null) {
						// we can't find the field, so it's not a join point.
					} else if (Modifier.isFinal(resolvedField.getModifiers())) {
						// it's final, so it's the set of a final constant, so it's
						// not a join point according to 1.0.6 and 1.1.
					} else {
						if (canMatch(Shadow.FieldSet))
							matchSetInstruction(mg, ih, enclosingShadow, shadowAccumulator);
					}						
				} else {
					if (canMatch(Shadow.FieldSet))
						matchSetInstruction(mg, ih, enclosingShadow, shadowAccumulator);
				}
			} else {
				if (canMatch(Shadow.FieldGet))
					matchGetInstruction(mg, ih, enclosingShadow, shadowAccumulator);
			}
		} else if (i instanceof InvokeInstruction) {
			InvokeInstruction ii = (InvokeInstruction) i;
			if (ii.getMethodName(clazz.getConstantPoolGen()).equals("<init>")) {
				if (canMatch(Shadow.ConstructorCall))
					match(
							BcelShadow.makeConstructorCall(world, mg, ih, enclosingShadow),
							shadowAccumulator);
			} else if (ii instanceof INVOKESPECIAL) {
				String onTypeName = ii.getClassName(cpg);
				if (onTypeName.equals(mg.getEnclosingClass().getName())) {
					// we are private
					matchInvokeInstruction(mg, ih, ii, enclosingShadow, shadowAccumulator);
				} else {
					// we are a super call, and this is not a join point in AspectJ-1.{0,1}
				}
			} else {
					matchInvokeInstruction(mg, ih, ii, enclosingShadow, shadowAccumulator);
			}
		} else if (world.isJoinpointArrayConstructionEnabled() && 
				   (i instanceof NEWARRAY || i instanceof ANEWARRAY || i instanceof MULTIANEWARRAY)) {
			if (canMatch(Shadow.ConstructorCall)) {
				boolean debug = false;
				if (debug) System.err.println("Found new array instruction: "+i);
				if (i instanceof ANEWARRAY) {
					ANEWARRAY arrayInstruction = (ANEWARRAY)i;
					ObjectType arrayType = arrayInstruction.getLoadClassType(clazz.getConstantPoolGen());
					if (debug) System.err.println("Array type is "+arrayType);
					BcelShadow ctorCallShadow = BcelShadow.makeArrayConstructorCall(world,mg,ih,enclosingShadow);
					match(ctorCallShadow,shadowAccumulator);
				} else if (i instanceof NEWARRAY) {
					NEWARRAY arrayInstruction = (NEWARRAY)i;
					Type arrayType = arrayInstruction.getType();
					if (debug) System.err.println("Array type is "+arrayType);
					BcelShadow ctorCallShadow = BcelShadow.makeArrayConstructorCall(world,mg,ih,enclosingShadow);
					match(ctorCallShadow,shadowAccumulator);
				} else if (i instanceof MULTIANEWARRAY) {
					MULTIANEWARRAY arrayInstruction = (MULTIANEWARRAY)i;
					ObjectType arrayType = arrayInstruction.getLoadClassType(clazz.getConstantPoolGen());
					if (debug) System.err.println("Array type is "+arrayType);
					BcelShadow ctorCallShadow = BcelShadow.makeArrayConstructorCall(world,mg,ih,enclosingShadow);
					match(ctorCallShadow,shadowAccumulator);
				}
			}
// see pr77166 if you are thinking about implementing this
//		} else if (i instanceof AALOAD ) {
//			AALOAD arrayLoad = (AALOAD)i;
//			Type arrayType = arrayLoad.getType(clazz.getConstantPoolGen());
//			BcelShadow arrayLoadShadow = BcelShadow.makeArrayLoadCall(world,mg,ih,enclosingShadow);
//			match(arrayLoadShadow,shadowAccumulator);
//		} else if (i instanceof AASTORE) {
//			// ... magic required
		} else if ( world.isJoinpointSynchronizationEnabled() &&
				   ((i instanceof MONITORENTER) || (i instanceof MONITOREXIT))) {
			// if (canMatch(Shadow.Monitoring)) {
			  if (i instanceof MONITORENTER) {
				  BcelShadow monitorEntryShadow = BcelShadow.makeMonitorEnter(world,mg,ih,enclosingShadow);
				  match(monitorEntryShadow,shadowAccumulator);
			  } else {
				  BcelShadow monitorExitShadow = BcelShadow.makeMonitorExit(world,mg,ih,enclosingShadow);
				  match(monitorExitShadow,shadowAccumulator);
			  }
			// }
		}
		// performance optimization... we only actually care about ASTORE instructions, 
		// since that's what every javac type thing ever uses to start a handler, but for
		// now we'll do this for everybody.
		if (!canMatch(Shadow.ExceptionHandler)) return;
		if (Range.isRangeHandle(ih)) return;
		InstructionTargeter[] targeters = ih.getTargeters();
		if (targeters != null) {
			for (int j = 0; j < targeters.length; j++) {
				InstructionTargeter t = targeters[j];
				if (t instanceof ExceptionRange) {
					// assert t.getHandler() == ih
					ExceptionRange er = (ExceptionRange) t;
					if (er.getCatchType() == null) continue;
					if (isInitFailureHandler(ih)) return;
					
					match(
						BcelShadow.makeExceptionHandler(
							world, 
							er,
							mg, ih, enclosingShadow),
						shadowAccumulator);
				}
			}
		}
	}
================= fetch private void matchInvokeInstruction(LazyMethodGen mg, 5f97d46^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

private void matchInvokeInstruction(LazyMethodGen mg,
		InstructionHandle ih,
		InvokeInstruction invoke,
		BcelShadow enclosingShadow,
		List shadowAccumulator) 
	{
		String methodName = invoke.getName(cpg);
		if (methodName.startsWith(NameMangler.PREFIX)) {
			Member jpSig =
				world.makeJoinPointSignatureForMethodInvocation(clazz, invoke);
			ResolvedMember declaredSig = jpSig.resolve(world);
			//System.err.println(method + ", declaredSig: "  +declaredSig);
			if (declaredSig == null) return;
			
			if (declaredSig.getKind() == Member.FIELD) {
				Shadow.Kind kind;
				if (jpSig.getReturnType().equals(ResolvedType.VOID)) {
					kind = Shadow.FieldSet;
				} else {
					kind = Shadow.FieldGet;
				}
				
				if (canMatch(Shadow.FieldGet) || canMatch(Shadow.FieldSet))
					match(BcelShadow.makeShadowForMethodCall(world, mg, ih, enclosingShadow,
							kind, declaredSig),
							shadowAccumulator);
			} else {
				AjAttribute.EffectiveSignatureAttribute effectiveSig =
					declaredSig.getEffectiveSignature();
				if (effectiveSig == null) return;
				//System.err.println("call to inter-type member: " + effectiveSig);
				if (effectiveSig.isWeaveBody()) return;

				
			    ResolvedMember rm = effectiveSig.getEffectiveSignature();
				
				fixAnnotationsForResolvedMember(rm,declaredSig); // abracadabra
			  
				if (canMatch(effectiveSig.getShadowKind())) 
					match(BcelShadow.makeShadowForMethodCall(world, mg, ih, enclosingShadow,
							effectiveSig.getShadowKind(), rm), shadowAccumulator);
			}
		} else {
			if (canMatch(Shadow.MethodCall))
				match(
						BcelShadow.makeMethodCall(world, mg, ih, enclosingShadow),
						shadowAccumulator);
		}
	}
================= fetch public static void assertGoodBody(InstructionList il, String from) { 5f97d46^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

public static void assertGoodBody(InstructionList il, String from) {
		if (true) return;  // only to be enabled for debugging
		if (il == null) return;
		Set body = new HashSet();
		Stack ranges = new Stack();
		for (InstructionHandle ih = il.getStart(); ih != null; ih = ih.getNext()) {
			body.add(ih);
			if (ih.getInstruction() instanceof BranchInstruction) {
				body.add(ih.getInstruction());
			}
		}
		
		for (InstructionHandle ih = il.getStart(); ih != null; ih = ih.getNext()) {
			assertGoodHandle(ih, body, ranges, from);
			InstructionTargeter[] ts = ih.getTargeters();
			if (ts != null) {
				for (int i = ts.length - 1; i >= 0; i--) {
					assertGoodTargeter(ts[i], ih, body, from);
				}
			}
		}
	}
Progress : [#############---------------------------] 33%================= fetch public boolean match(DefaultPointcut node, Object other) { bed3f4e^:org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTMatcher.java

public boolean match(DefaultPointcut node, Object other) {
		return (other instanceof DefaultPointcut);
	}
================= fetch public boolean match(DefaultTypePattern node, Object other) { bed3f4e^:org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTMatcher.java

public boolean match(DefaultTypePattern node, Object other) {
		return (other instanceof DefaultTypePattern);
	}
================= fetch public boolean match(SignaturePattern node, Object other) { bed3f4e^:org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTMatcher.java

public boolean match(SignaturePattern node, Object other) {
		return (other instanceof SignaturePattern);
	}
================= fetch public String toString() { 6bdb87d^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java

private static File isAspectjtoolsjar(String path) {
        if (null == path) {
            return null;
        }
        final String prefix = "aspectj";        
        final String infix = "tools";        
        final String altInfix = "-tools";        
        final String suffix = ".jar";
        final int prefixLength = 7; // prefix.length();
        final int minLength = 16;
        // prefixLength + infix.length() + suffix.length();        
        if (!path.endsWith(suffix)) {
            return null;
        }
        int loc = path.lastIndexOf(prefix);
        if ((-1 != loc) && ((loc + minLength) <= path.length())) {
            String rest = path.substring(loc+prefixLength);
            if (-1 != rest.indexOf(File.pathSeparator)) {
                return null;
            }
            if (rest.startsWith(infix)
                || rest.startsWith(altInfix)) {
                File result = new File(path);
                if (result.canRead() && result.isFile()) {
                    return result;
                }
            }
        }        
        return null;
    }
================= fetch private boolean doDeclareAnnotations(DeclareAnnotation decA, SourceTypeBinding s 8ce9dcf^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java

private boolean doDeclareAnnotations(DeclareAnnotation decA, SourceTypeBinding sourceType,boolean reportProblems) {
		ResolvedType rtx = factory.fromEclipse(sourceType);
		if (!decA.matches(rtx)) return false;
		if (!rtx.isExposedToWeaver()) return false;

		ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.PROCESSING_DECLARE_ANNOTATIONS, sourceType.sourceName);
	
		// Get the annotation specified in the declare
		UnresolvedType aspectType = decA.getAspect();
		if (aspectType instanceof ReferenceType) {
			ReferenceType rt = (ReferenceType) aspectType;
			if (rt.isParameterizedType() || rt.isRawType()) {
				aspectType = rt.getGenericType();
			}
		}
		TypeBinding tb = factory.makeTypeBinding(aspectType);
		
		// Hideousness follows:
		
		// There are multiple situations to consider here and they relate to the combinations of
		// where the annotation is coming from and where the annotation is going to be put:
		//
		// 1. Straight full build, all from source - the annotation is from a dec@type and
		//    is being put on some type.  Both types are real SourceTypeBindings. WORKS
		// 2. Incremental build, changing the affected type - the annotation is from a
		//    dec@type in a BinaryTypeBinding (so has to be accessed via bcel) and the
		//    affected type is a real SourceTypeBinding.  Mostly works (pr128665)
		// 3. ?
		
		SourceTypeBinding stb = (SourceTypeBinding)tb;
		Annotation[] toAdd = null;
		long abits = 0;
		
		// Might have to retrieve the annotation through BCEL and construct an eclipse one for it.
		if (stb instanceof BinaryTypeBinding) {
			ReferenceType rt = (ReferenceType)factory.fromEclipse(stb);
			ResolvedMember[] methods = rt.getDeclaredMethods();
			ResolvedMember decaMethod = null;
			String nameToLookFor = decA.getAnnotationMethod();
			for (int i = 0; i < methods.length; i++) {
				if (methods[i].getName().equals(nameToLookFor)) {decaMethod = methods[i];break;}
			}
			if (decaMethod!=null) { // could assert this ...
				AnnotationX[] axs = decaMethod.getAnnotations();
				toAdd = new Annotation[1];
				toAdd[0] = createAnnotationFromBcelAnnotation(axs[0],decaMethod.getSourceLocation().getOffset(),factory);
				// BUG BUG BUG - We dont test these abits are correct, in fact we'll be very lucky if they are.
				// What does that mean?  It means on an incremental compile you might get away with an
				// annotation that isn't allowed on a type being put on a type.
				abits = toAdd[0].resolvedType.getAnnotationTagBits(); 
			}		
		} else {
			// much nicer, its a real SourceTypeBinding so we can stay in eclipse land
			MethodBinding[]	mbs = stb.getMethods(decA.getAnnotationMethod().toCharArray());
			abits = mbs[0].getAnnotationTagBits(); // ensure resolved
			TypeDeclaration typeDecl = ((SourceTypeBinding)mbs[0].declaringClass).scope.referenceContext;
			AbstractMethodDeclaration methodDecl = typeDecl.declarationOf(mbs[0]);
			toAdd = methodDecl.annotations; // this is what to add
			toAdd[0] = createAnnotationCopy(toAdd[0]);
			if (toAdd[0].resolvedType!=null) // pr148536
			  abits = toAdd[0].resolvedType.getAnnotationTagBits();
		}
		
		if (sourceType instanceof BinaryTypeBinding) {
			// In this case we can't access the source type binding to add a new annotation, so let's put something
			// on the weaver type temporarily
			ResolvedType theTargetType = factory.fromEclipse(sourceType);
			TypeBinding theAnnotationType = toAdd[0].resolvedType;
			String sig = new String(theAnnotationType.signature());
			UnresolvedType bcelAnnotationType = UnresolvedType.forSignature(sig);
			String name = bcelAnnotationType.getName();
			if (theTargetType.hasAnnotation(bcelAnnotationType)) {
				CompilationAndWeavingContext.leavingPhase(tok);
				return false;
			}
			
			// FIXME asc tidy up this code that duplicates whats below!
			// Simple checks on the bits
			boolean giveupnow = false;
			if (((abits & TagBits.AnnotationTargetMASK)!=0)) {
				if ( isAnnotationTargettingSomethingOtherThanAnnotationOrNormal(abits)) {
					// error will have been already reported
					giveupnow = true;
				} else if (  (sourceType.isAnnotationType() && (abits & TagBits.AnnotationForAnnotationType)==0) ||
				      (!sourceType.isAnnotationType() && (abits & TagBits.AnnotationForType)==0) ) {
				
				  if (reportProblems) {
				    if (decA.isExactPattern()) {
				      factory.showMessage(IMessage.ERROR,
						WeaverMessages.format(WeaverMessages.INCORRECT_TARGET_FOR_DECLARE_ANNOTATION,rtx.getName(),toAdd[0].type,stringifyTargets(abits)),
						decA.getSourceLocation(), null);
				    } 
				    // dont put out the lint - the weaving process will do that
//				    else {
//					  if (factory.getWorld().getLint().invalidTargetForAnnotation.isEnabled()) {
//						  factory.getWorld().getLint().invalidTargetForAnnotation.signal(new String[]{rtx.getName(),toAdd[0].type.toString(),stringifyTargets(abits)},decA.getSourceLocation(),null);
//					  }
//				    }
				  }
				  giveupnow=true;
			    }
			}
			if (giveupnow) { 
				CompilationAndWeavingContext.leavingPhase(tok);
				return false;
			}
			
			theTargetType.addAnnotation(new AnnotationX(new FakeAnnotation(name,sig,(abits & TagBits.AnnotationRuntimeRetention)!=0),factory.getWorld()));
			CompilationAndWeavingContext.leavingPhase(tok);
			return true;
		}
		
		Annotation currentAnnotations[] = sourceType.scope.referenceContext.annotations;
		if (currentAnnotations!=null) 
		for (int i = 0; i < currentAnnotations.length; i++) {
			Annotation annotation = currentAnnotations[i];
			String a = CharOperation.toString(annotation.type.getTypeName());
			String b = CharOperation.toString(toAdd[0].type.getTypeName());
			// FIXME asc we have a lint for attempting to add an annotation twice to a method,
			// we could put it out here *if* we can resolve the problem of errors coming out
			// multiple times if we have cause to loop through here
			if (a.equals(b)) {
				CompilationAndWeavingContext.leavingPhase(tok);
				return false;
			}
		}
		
		if (((abits & TagBits.AnnotationTargetMASK)!=0)) {
			if ( (abits & (TagBits.AnnotationForAnnotationType | TagBits.AnnotationForType))==0) {
				// this means it specifies something other than annotation or normal type - error will have been already reported, just resolution process above
				CompilationAndWeavingContext.leavingPhase(tok);
				return false;
			}
			if (  (sourceType.isAnnotationType() && (abits & TagBits.AnnotationForAnnotationType)==0) ||
			      (!sourceType.isAnnotationType() && (abits & TagBits.AnnotationForType)==0) ) {
			
			if (reportProblems) {
			  if (decA.isExactPattern()) {
			    factory.showMessage(IMessage.ERROR,
					WeaverMessages.format(WeaverMessages.INCORRECT_TARGET_FOR_DECLARE_ANNOTATION,rtx.getName(),toAdd[0].type,stringifyTargets(abits)),
					decA.getSourceLocation(), null);
			  } 
			  // dont put out the lint - the weaving process will do that
//			  else {
//				if (factory.getWorld().getLint().invalidTargetForAnnotation.isEnabled()) {
//					factory.getWorld().getLint().invalidTargetForAnnotation.signal(new String[]{rtx.getName(),toAdd[0].type.toString(),stringifyTargets(abits)},decA.getSourceLocation(),null);
//				}
//			  }
			}
			CompilationAndWeavingContext.leavingPhase(tok);
			return false;
		  }
		}
		
		// Build a new array of annotations
		
		// remember the current set (rememberAnnotations only does something the first time it is called for a type)
		sourceType.scope.referenceContext.rememberAnnotations(); 
		
		AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decA.getSourceLocation(),rtx.getSourceLocation());
		Annotation abefore[] = sourceType.scope.referenceContext.annotations;
		Annotation[] newset = new Annotation[toAdd.length+(abefore==null?0:abefore.length)];
		System.arraycopy(toAdd,0,newset,0,toAdd.length);
		if (abefore!=null) {
			System.arraycopy(abefore,0,newset,toAdd.length,abefore.length);
		}
		sourceType.scope.referenceContext.annotations = newset;
		CompilationAndWeavingContext.leavingPhase(tok);
		return true;
	}
================= fetch protected void collectInterTypeMungers(List collector) { fe99e6b^:weaver/src/org/aspectj/weaver/ResolvedType.java

protected void collectInterTypeMungers(List collector) {
        for (Iterator iter = getDirectSupertypes(); iter.hasNext();) {
			ResolvedType superType = (ResolvedType) iter.next();
            superType.collectInterTypeMungers(collector);
		}
        
        outer:
        for (Iterator iter1 = collector.iterator(); iter1.hasNext();) {
            ConcreteTypeMunger superMunger = (ConcreteTypeMunger) iter1.next();
            if ( superMunger.getSignature() == null) continue;
            
            if ( !superMunger.getSignature().isAbstract()) continue;
            
            for (Iterator iter = getInterTypeMungers().iterator(); iter.hasNext();) {
                ConcreteTypeMunger  myMunger = (ConcreteTypeMunger) iter.next();
                if (conflictingSignature(myMunger.getSignature(), superMunger.getSignature())) {
                    iter1.remove();
                    continue outer;
                }
            }
            
            if (!superMunger.getSignature().isPublic()) continue;
            
            for (Iterator iter = getMethods(); iter.hasNext(); ) {
                ResolvedMember method = (ResolvedMember)iter.next();
                if (conflictingSignature(method, superMunger.getSignature())) {
                    iter1.remove();
                    continue outer;
                }
            }
        }
        
        collector.addAll(getInterTypeMungers());
    }
================= fetch public Set getAnnotations(Member onMember) { 6c54db9^:weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java

public ResolvedType[][] getParameterAnnotationTypes(Member onMember) {
		if (!(onMember instanceof AccessibleObject)) return NO_PARAMETER_ANNOTATIONS;
		// here we really want both the runtime visible AND the class visible annotations
		// so we bail out to Bcel and then chuck away the JavaClass so that we don't hog
		// memory.
		try {
			JavaClass jc = bcelRepository.loadClass(onMember.getDeclaringClass());
			org.aspectj.apache.bcel.classfile.annotation.Annotation[][] anns = null;
			if (onMember instanceof Method) {
				org.aspectj.apache.bcel.classfile.Method bcelMethod = jc.getMethod((Method)onMember);
				if (bcelMethod == null) {
					// pr220430
					//System.err.println("Unexpected problem in Java15AnnotationFinder: cannot retrieve annotations on method '"+onMember.getName()+"' in class '"+jc.getClassName()+"'");
				} else {
					anns = bcelMethod.getParameterAnnotations();
				}
			} else if (onMember instanceof Constructor) {
				org.aspectj.apache.bcel.classfile.Method bcelCons = jc.getMethod((Constructor)onMember);
				anns = bcelCons.getParameterAnnotations();
			} else if (onMember instanceof Field) {
				anns = null;
			}
			// the answer is cached and we don't want to hold on to memory
			bcelRepository.clear();
			if (anns == null) return NO_PARAMETER_ANNOTATIONS;
			ResolvedType[][] result = new ResolvedType[anns.length][];
			// CACHING??
			for (int i=0;i<anns.length;i++) {
				if (anns[i]!=null) {
					result[i] = new ResolvedType[anns[i].length];
					for (int j=0;j<anns[i].length;j++) {
						result[i][j] = world.resolve(UnresolvedType.forSignature(anns[i][j].getTypeSignature()));
					}
				}
			}
			return result;
		} catch (ClassNotFoundException cnfEx) {
			// just use reflection then
		}
		
		// reflection...
		AccessibleObject ao = (AccessibleObject) onMember;
		Annotation[][] anns = null;
		if (onMember instanceof Method) {
			anns = ((Method)ao).getParameterAnnotations();
		} else if (onMember instanceof Constructor) {
			anns = ((Constructor)ao).getParameterAnnotations();
		} else if (onMember instanceof Field) {
			anns = null;
		}
		if (anns == null) return NO_PARAMETER_ANNOTATIONS;
		ResolvedType[][] result = new ResolvedType[anns.length][];
		// CACHING??
		for (int i=0;i<anns.length;i++) {
			if (anns[i]!=null) {
				result[i] = new ResolvedType[anns[i].length];
				for (int j=0;j<anns[i].length;j++) {
					result[i][j] = UnresolvedType.forName(anns[i][j].annotationType().getName()).resolve(world);
				}
			}
		}
		return result;
	}
================= fetch private boolean acceptResource(String resourceName) { 906c849^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private boolean acceptResource(String resourceName) {
		if (  
				(resourceName.startsWith("CVS/")) ||
				(resourceName.indexOf("/CVS/") != -1) ||
				(resourceName.endsWith("/CVS")) ||
				(resourceName.endsWith(".class")) ||
				(resourceName.startsWith(".svn/")) || 
				(resourceName.indexOf("/.svn/")!=-1) ||
				(resourceName.endsWith("/.svn")) ||
				(resourceName.toUpperCase().equals(MANIFEST_NAME))
		    )
		{
			return false;
		} else {
			return true;
		}
	}
================= fetch private void copyResourcesFromFile(File f,String filename,File src) throws IOExc 906c849^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

void copyResourcesFromFile(File f,String filename,File src) throws IOException {
		if (!acceptResource(filename)) return;
		FileInputStream fis = null;
		try {
			fis = new FileInputStream(f);
			byte[] bytes = FileUtil.readAsByteArray(fis);
			// String relativePath = files[i].getPath();
			
			writeResource(filename,bytes,src);
		} finally {
			if (fis != null) fis.close();
		}	
	}
================= fetch private void copyResourcesFromJarFile(File jarFile) throws IOException { 906c849^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void copyResourcesFromJarFile(File jarFile) throws IOException {
		JarInputStream inStream = null;
		try {
			inStream = new JarInputStream(new FileInputStream(jarFile));
			while (true) {
				ZipEntry entry = inStream.getNextEntry();
				if (entry == null) break;
			
				String filename = entry.getName();
//				System.out.println("? copyResourcesFromJarFile() filename='" + filename +"'");
	
				if (!entry.isDirectory() && acceptResource(filename)) {
					byte[] bytes = FileUtil.readAsByteArray(inStream);
					writeResource(filename,bytes,jarFile);
				}
	
				inStream.closeEntry();
			}
		} finally {
			if (inStream != null) inStream.close();
		}
	}
================= fetch private void writeManifest () throws IOException { 906c849^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/*
	 * If we are writing to an output directory copy the manifest but only
	 * if we already have one
	 */
private void writeManifest () throws IOException {
		Manifest manifest = getWeaver().getManifest(false);
		if (manifest != null && zos == null) {
			File outputDir = buildConfig.getOutputDir();
			if (buildConfig.getCompilationResultDestinationManager() != null) {
				// Manifests are only written if we have a jar on the inpath. Therefore,
				// we write the manifest to the defaultOutputLocation because this is
				// where we sent the classes that were on the inpath
				outputDir = buildConfig.getCompilationResultDestinationManager().getDefaultOutputLocation();
			}
			if (outputDir == null) return;
			OutputStream fos = FileUtil.makeOutputStream(new File(outputDir,MANIFEST_NAME));
			manifest.write(fos);
			fos.close();
		}
	}
Progress : [#############---------------------------] 34%================= fetch private void raiseUnboundFormalError(String name, Pointcut userPointcut) { a31b3de^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
/**
	 * @param name
	 * @param userPointcut
	 */
private void raiseUnboundFormalError(String name, Pointcut userPointcut) {
		world.showMessage(IMessage.ERROR,
				WeaverMessages.format(WeaverMessages.UNBOUND_FORMAL,
										name),
				userPointcut.getSourceContext().makeSourceLocation(userPointcut),null);
	}
================= fetch public boolean isTargettingAspectJRuntime12() { caf8960^:weaver/src/org/aspectj/weaver/World.java

public boolean isTargettingAspectJRuntime12() {
		boolean b = false; // pr116679
		if (!isInJava5Mode()) b=true;
		else b = getTargetAspectjRuntimeLevel().equals(org.aspectj.weaver.Constants.RUNTIME_LEVEL_12);
		//System.err.println("Asked if targetting runtime 1.2 , returning: "+b);
		return b;
	}
================= fetch public void initialize(ReferenceType aType, Class aClass, ClassLoader classLoade 1bbe6f9^:weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java

@Override
	public void initialize(ReferenceType aType, Class aClass, ClassLoader classLoader, World aWorld) {
		super.initialize(aType, aClass, classLoader, aWorld);
		myType = AjTypeSystem.getAjType(aClass);
		annotationFinder = new Java15AnnotationFinder();
		argNameFinder = annotationFinder;
		annotationFinder.setClassLoader(this.classLoader);
		this.typeConverter = new JavaLangTypeToResolvedTypeConverter(aWorld);
	}
================= fetch public AnnotationX getAnnotationOfType(UnresolvedType ofType,Member onMember) { 9bbdb41^:weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java

public AnnotationX getAnnotationOfType(UnresolvedType ofType,Member onMember) {
		if (!(onMember instanceof AccessibleObject)) return null;
		// here we really want both the runtime visible AND the class visible annotations
		// so we bail out to Bcel and then chuck away the JavaClass so that we don't hog
		// memory.
		try {
			JavaClass jc = bcelRepository.loadClass(onMember.getDeclaringClass());
			org.aspectj.apache.bcel.classfile.annotation.Annotation[] anns = new org.aspectj.apache.bcel.classfile.annotation.Annotation[0];
			if (onMember instanceof Method) {
				org.aspectj.apache.bcel.classfile.Method bcelMethod = jc.getMethod((Method)onMember);
				if (bcelMethod == null) {
					System.err.println("Unexpected problem in Java15AnnotationFinder: cannot retrieve annotations on method '"+onMember.getName()+"' in class '"+jc.getClassName()+"'");
				} else {
					anns = bcelMethod.getAnnotations();
				}
			} else if (onMember instanceof Constructor) {
				org.aspectj.apache.bcel.classfile.Method bcelCons = jc.getMethod((Constructor)onMember);
				anns = bcelCons.getAnnotations();
			} else if (onMember instanceof Field) {
				org.aspectj.apache.bcel.classfile.Field bcelField = jc.getField((Field)onMember);
				anns = bcelField.getAnnotations();
			}
			// the answer is cached and we don't want to hold on to memory
			bcelRepository.clear();
			if (anns == null) anns = new org.aspectj.apache.bcel.classfile.annotation.Annotation[0];
			// convert to our Annotation type
			for (int i=0;i<anns.length;i++) {
				if (anns[i].getTypeSignature().equals(ofType.getSignature())) {
					return new AnnotationX(anns[i],world);
				}
			}
			return null;
		} catch (ClassNotFoundException cnfEx) {
			// just use reflection then
		}
		
		return null;
	}
================= fetch public Set getAnnotations(Member onMember) { 9bbdb41^:weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java

public ResolvedType[][] getParameterAnnotationTypes(Member onMember) {
		if (!(onMember instanceof AccessibleObject)) return NO_PARAMETER_ANNOTATIONS;
		// here we really want both the runtime visible AND the class visible annotations
		// so we bail out to Bcel and then chuck away the JavaClass so that we don't hog
		// memory.
		try {
			JavaClass jc = bcelRepository.loadClass(onMember.getDeclaringClass());
			org.aspectj.apache.bcel.classfile.annotation.Annotation[][] anns = null;
			if (onMember instanceof Method) {
				org.aspectj.apache.bcel.classfile.Method bcelMethod = jc.getMethod((Method)onMember);
				anns = bcelMethod.getParameterAnnotations();
			} else if (onMember instanceof Constructor) {
				org.aspectj.apache.bcel.classfile.Method bcelCons = jc.getMethod((Constructor)onMember);
				anns = bcelCons.getParameterAnnotations();
			} else if (onMember instanceof Field) {
				anns = null;
			}
			// the answer is cached and we don't want to hold on to memory
			bcelRepository.clear();
			if (anns == null) return NO_PARAMETER_ANNOTATIONS;
			ResolvedType[][] result = new ResolvedType[anns.length][];
			// CACHING??
			for (int i=0;i<anns.length;i++) {
				if (anns[i]!=null) {
					result[i] = new ResolvedType[anns[i].length];
					for (int j=0;j<anns[i].length;j++) {
						result[i][j] = world.resolve(UnresolvedType.forSignature(anns[i][j].getTypeSignature()));
					}
				}
			}
			return result;
		} catch (ClassNotFoundException cnfEx) {
			// just use reflection then
		}
		
		// reflection...
		AccessibleObject ao = (AccessibleObject) onMember;
		Annotation[][] anns = null;
		if (onMember instanceof Method) {
			anns = ((Method)ao).getParameterAnnotations();
		} else if (onMember instanceof Constructor) {
			anns = ((Constructor)ao).getParameterAnnotations();
		} else if (onMember instanceof Field) {
			anns = null;
		}
		if (anns == null) return NO_PARAMETER_ANNOTATIONS;
		ResolvedType[][] result = new ResolvedType[anns.length][];
		// CACHING??
		for (int i=0;i<anns.length;i++) {
			if (anns[i]!=null) {
				result[i] = new ResolvedType[anns[i].length];
				for (int j=0;j<anns[i].length;j++) {
					result[i][j] = UnresolvedType.forName(anns[i][j].annotationType().getName()).resolve(world);
				}
			}
		}
		return result;
	}
================= fetch public String getAnnotationDefaultValue(Member onMember) { 9bbdb41^:weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java

public String getAnnotationDefaultValue(Member onMember) {
		try {
			JavaClass jc = bcelRepository.loadClass(onMember.getDeclaringClass());
			if (onMember instanceof Method) {
				org.aspectj.apache.bcel.classfile.Method bcelMethod = jc.getMethod((Method)onMember);
				if (bcelMethod == null) {
					System.err.println("Unexpected problem in Java15AnnotationFinder: cannot retrieve annotations on method '"+onMember.getName()+"' in class '"+jc.getClassName()+"'");
				} else {
					Attribute[] attrs = bcelMethod.getAttributes();
					for (int i = 0; i < attrs.length; i++) {
						Attribute attribute = attrs[i];			
						if (attribute.getName().equals("AnnotationDefault")) {
							AnnotationDefault def = (AnnotationDefault)attribute;
							return def.getElementValue().stringifyValue();
						}
					}
					return null;
				}
			}
		} catch (ClassNotFoundException cnfEx) {
			// just use reflection then
		}
	
		return null;
	}
================= fetch public String toResolvedString(World world) { 5beab0e^:weaver/src/org/aspectj/weaver/Shadow.java

public String toResolvedString(World world) {
    	return getKind() + "(" + world.resolve(getSignature()).toGenericString() + ")";
    }
Progress : [##############--------------------------] 35%================= fetch public ASTNode convert(InterTypeFieldDeclaration fieldDecl) { 114db35^:org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTConverter.java

public ASTNode convert(InterTypeFieldDeclaration fieldDecl) {
		// ajh02: method added
		checkCanceled(); // ajh02: is this line needed?
		VariableDeclarationFragment variableDeclarationFragment = convertToVariableDeclarationFragment(fieldDecl);
		final org.aspectj.org.eclipse.jdt.core.dom.InterTypeFieldDeclaration fieldDeclaration = new org.aspectj.org.eclipse.jdt.core.dom.InterTypeFieldDeclaration(this.ast);
		fieldDeclaration.fragments().add(variableDeclarationFragment);
		IVariableBinding binding = null;
		if (this.resolveBindings) {
			recordNodes(variableDeclarationFragment, fieldDecl);
			binding = variableDeclarationFragment.resolveBinding();
		}
		fieldDeclaration.setSourceRange(fieldDecl.declarationSourceStart, fieldDecl.declarationSourceEnd - fieldDecl.declarationSourceStart + 1);
		Type type = convertType(fieldDecl.returnType);
		setTypeForField(fieldDeclaration, type, variableDeclarationFragment.getExtraDimensions());
		setModifiers(fieldDeclaration, fieldDecl);
		if (!(this.resolveBindings && binding == null)) {
			convert(fieldDecl.javadoc, fieldDeclaration);
		}
		return fieldDeclaration;
	}
================= fetch public ASTNode convert(org.aspectj.org.eclipse.jdt.internal.compiler.ast.Abstrac 114db35^:org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTConverter.java

public ASTNode convert(org.aspectj.org.eclipse.jdt.internal.compiler.ast.AbstractMethodDeclaration methodDeclaration) {
		checkCanceled();
		if (methodDeclaration instanceof org.aspectj.org.eclipse.jdt.internal.compiler.ast.AnnotationMethodDeclaration) {
			return convert((org.aspectj.org.eclipse.jdt.internal.compiler.ast.AnnotationMethodDeclaration) methodDeclaration);
		}
		MethodDeclaration methodDecl = new MethodDeclaration(this.ast);
		boolean isConstructor = methodDeclaration.isConstructor();
		methodDecl.setConstructor(isConstructor);
		
		////////////////// ajh02: added. ugh, polymorphism! Where are you!
		if (methodDeclaration instanceof DeclareDeclaration){
			return convert((DeclareDeclaration)methodDeclaration);
		} else if (methodDeclaration instanceof InterTypeFieldDeclaration){
			return convert((InterTypeFieldDeclaration) methodDeclaration);
		} else if (methodDeclaration instanceof InterTypeMethodDeclaration){
			methodDecl = new org.aspectj.org.eclipse.jdt.core.dom.InterTypeMethodDeclaration(this.ast);
		} else if (methodDeclaration instanceof InterTypeConstructorDeclaration){
			methodDecl = new org.aspectj.org.eclipse.jdt.core.dom.InterTypeMethodDeclaration(this.ast);
			methodDecl.setConstructor(true);
		} else if (methodDeclaration instanceof PointcutDeclaration){
			return convert((PointcutDeclaration) methodDeclaration);
		} else if (methodDeclaration instanceof AdviceDeclaration){
			return convert((AdviceDeclaration)methodDeclaration);
		}
		/////////////////////////
		
		// set modifiers after checking whether we're an itd, otherwise
		// the modifiers are not set on the correct object.
		setModifiers(methodDecl, methodDeclaration);

		// for ITD's use the declaredSelector
		final SimpleName methodName = new SimpleName(this.ast);
		if (methodDeclaration instanceof InterTypeDeclaration) {
			InterTypeDeclaration itd = (InterTypeDeclaration) methodDeclaration;
			methodName.internalSetIdentifier(new String(itd.getDeclaredSelector()));
		} else {
			methodName.internalSetIdentifier(new String(methodDeclaration.selector));
		}
		int start = methodDeclaration.sourceStart;
		int end = retrieveIdentifierEndPosition(start, methodDeclaration.sourceEnd);
		methodName.setSourceRange(start, end - start + 1);
		methodDecl.setName(methodName);
		
		org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference[] thrownExceptions = methodDeclaration.thrownExceptions;
		if (thrownExceptions != null) {
			int thrownExceptionsLength = thrownExceptions.length;
			for (int i = 0; i < thrownExceptionsLength; i++) {
				methodDecl.thrownExceptions().add(convert(thrownExceptions[i]));
			}
		}
		org.aspectj.org.eclipse.jdt.internal.compiler.ast.Argument[] parameters = methodDeclaration.arguments;
		if (parameters != null) {
			int parametersLength = parameters.length;
			for (int i = 0; i < parametersLength; i++) {
				methodDecl.parameters().add(convert(parameters[i]));
			}
		}
		org.aspectj.org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall explicitConstructorCall = null;
		if (isConstructor) {
			org.aspectj.org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration constructorDeclaration = (org.aspectj.org.eclipse.jdt.internal.compiler.ast.ConstructorDeclaration) methodDeclaration;
			explicitConstructorCall = constructorDeclaration.constructorCall;
			switch(this.ast.apiLevel) {
				case AST.JLS2_INTERNAL :
					// set the return type to VOID
					PrimitiveType returnType = new PrimitiveType(this.ast);
					returnType.setPrimitiveTypeCode(PrimitiveType.VOID);
					returnType.setSourceRange(methodDeclaration.sourceStart, 0);
					methodDecl.internalSetReturnType(returnType);
					break;
				case AST.JLS3 :
					methodDecl.setReturnType2(null);
			}
		} else if (methodDeclaration instanceof org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration) {
			org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration method = (org.aspectj.org.eclipse.jdt.internal.compiler.ast.MethodDeclaration) methodDeclaration;
			org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeReference typeReference = method.returnType;
			if (typeReference != null) {
				Type returnType = convertType(typeReference);
				// get the positions of the right parenthesis
				int rightParenthesisPosition = retrieveEndOfRightParenthesisPosition(end, method.bodyEnd);
				int extraDimensions = retrieveExtraDimension(rightParenthesisPosition, method.bodyEnd);
				methodDecl.setExtraDimensions(extraDimensions);
				setTypeForMethodDeclaration(methodDecl, returnType, extraDimensions);
			}
		}
		int declarationSourceStart = methodDeclaration.declarationSourceStart;
		int declarationSourceEnd = methodDeclaration.bodyEnd;
		methodDecl.setSourceRange(declarationSourceStart, declarationSourceEnd - declarationSourceStart + 1);
		int closingPosition = retrieveRightBraceOrSemiColonPosition(methodDeclaration.bodyEnd + 1, methodDeclaration.declarationSourceEnd);
		if (closingPosition != -1) {
			int startPosition = methodDecl.getStartPosition();
			methodDecl.setSourceRange(startPosition, closingPosition - startPosition + 1);

			org.aspectj.org.eclipse.jdt.internal.compiler.ast.Statement[] statements = methodDeclaration.statements;
			
			start = retrieveStartBlockPosition(methodDeclaration.sourceStart, declarationSourceEnd);
			end = retrieveEndBlockPosition(methodDeclaration.sourceStart, methodDeclaration.declarationSourceEnd);
			Block block = null;
			if (start != -1 && end != -1) {
				/*
				 * start or end can be equal to -1 if we have an interface's method.
				 */
				block = new Block(this.ast);
				block.setSourceRange(start, end - start + 1);
				methodDecl.setBody(block);
			}
			if (block != null && (statements != null || explicitConstructorCall != null)) {
				if (explicitConstructorCall != null && explicitConstructorCall.accessMode != org.aspectj.org.eclipse.jdt.internal.compiler.ast.ExplicitConstructorCall.ImplicitSuper) {
					block.statements().add(super.convert(explicitConstructorCall));
				}
				int statementsLength = statements == null ? 0 : statements.length;
				for (int i = 0; i < statementsLength; i++) {
					if (statements[i] instanceof org.aspectj.org.eclipse.jdt.internal.compiler.ast.LocalDeclaration) {
						checkAndAddMultipleLocalDeclaration(statements, i, block.statements());
					} else {
						block.statements().add(convert(statements[i]));
					}
				}
			}
			if (block != null && (Modifier.isAbstract(methodDecl.getModifiers()) || Modifier.isNative(methodDecl.getModifiers()))) {
				methodDecl.setFlags(methodDecl.getFlags() | ASTNode.MALFORMED);
			}
		} else {
			// syntax error in this method declaration
			if (!methodDeclaration.isNative() && !methodDeclaration.isAbstract()) {
				start = retrieveStartBlockPosition(methodDeclaration.sourceStart, declarationSourceEnd);
				end = methodDeclaration.bodyEnd;
				// try to get the best end position
				IProblem[] problems = methodDeclaration.compilationResult().problems;
				if (problems != null) {
					for (int i = 0, max = methodDeclaration.compilationResult().problemCount; i < max; i++) {
						IProblem currentProblem = problems[i];
						if (currentProblem.getSourceStart() == start && currentProblem.getID() == IProblem.ParsingErrorInsertToComplete) {
							end = currentProblem.getSourceEnd();
							break;
						}
					}
				}
				int startPosition = methodDecl.getStartPosition();
				methodDecl.setSourceRange(startPosition, end - startPosition + 1);
				if (start != -1 && end != -1) {
					/*
					 * start or end can be equal to -1 if we have an interface's method.
					 */
					Block block = new Block(this.ast);
					block.setSourceRange(start, end - start + 1);
					methodDecl.setBody(block);
				}
			}			
		}

		org.aspectj.org.eclipse.jdt.internal.compiler.ast.TypeParameter[] typeParameters = methodDeclaration.typeParameters();
		if (typeParameters != null) {
			switch(this.ast.apiLevel) {
				case AST.JLS2_INTERNAL :
					methodDecl.setFlags(methodDecl.getFlags() | ASTNode.MALFORMED);
					break;
				case AST.JLS3 :
					for (int i = 0, max = typeParameters.length; i < max; i++) {
						methodDecl.typeParameters().add(convert(typeParameters[i]));
					}
			}
		}
		
		// The javadoc comment is now got from list store in compilation unit declaration
		if (this.resolveBindings) {
			recordNodes(methodDecl, methodDeclaration);
			recordNodes(methodName, methodDeclaration);
			if (methodDecl.resolveBinding() != null) {
				convert(methodDeclaration.javadoc, methodDecl);
			}
		} else {
			convert(methodDeclaration.javadoc, methodDecl);
		}
		return methodDecl;
	}
================= fetch private boolean compareToExistingMembers(ConcreteTypeMunger munger, Iterator exi 797ec4d^:weaver/src/org/aspectj/weaver/ResolvedType.java
//??? returning too soon
private boolean compareToExistingMembers(ConcreteTypeMunger munger, Iterator existingMembers) {
		ResolvedMember sig = munger.getSignature();
		while (existingMembers.hasNext()) {
			
			ResolvedMember existingMember = (ResolvedMember)existingMembers.next();
			// don't worry about clashing with bridge methods
			if (existingMember.isBridgeMethod()) continue;
			//System.err.println("Comparing munger: "+sig+" with member "+existingMember);
			if (conflictingSignature(existingMember, munger.getSignature())) {
				//System.err.println("conflict: existingMember=" + existingMember + "   typeMunger=" + munger);
				//System.err.println(munger.getSourceLocation() + ", " + munger.getSignature() + ", " + munger.getSignature().getSourceLocation());
				
				if (isVisible(existingMember.getModifiers(), this, munger.getAspectType())) {
					int c = compareMemberPrecedence(sig, existingMember);
					//System.err.println("   c: " + c);
					if (c < 0) {
						// existingMember dominates munger
						checkLegalOverride(munger.getSignature(), existingMember);
						return false;
					} else if (c > 0) {
						// munger dominates existingMember
						checkLegalOverride(existingMember, munger.getSignature());
						//interTypeMungers.add(munger);  
						//??? might need list of these overridden abstracts
						continue;
					} else {
					  // bridge methods can differ solely in return type.
					  // FIXME this whole method seems very hokey - unaware of covariance/varargs/bridging - it
					  // could do with a rewrite !
					  boolean sameReturnTypes = (existingMember.getReturnType().equals(sig.getReturnType()));
					  if (sameReturnTypes)
						  getWorld().getMessageHandler().handleMessage(
							MessageUtil.error(WeaverMessages.format(WeaverMessages.ITD_MEMBER_CONFLICT,munger.getAspectType().getName(),
									existingMember),
							munger.getSourceLocation())
						  );
					}
				} else if (isDuplicateMemberWithinTargetType(existingMember,this,sig)) {
				    	getWorld().getMessageHandler().handleMessage(
							MessageUtil.error(WeaverMessages.format(WeaverMessages.ITD_MEMBER_CONFLICT,munger.getAspectType().getName(),
									existingMember),
							munger.getSourceLocation())
                    );
                    ;
				}
				//return;
			}
		}
		return true;
	}
================= fetch public static UnresolvedType createTypeFromSignature(String signature) { 579ec14^:weaver/src/org/aspectj/weaver/TypeFactory.java
/**
	 * Used by UnresolvedType.read, creates a type from a full signature.
	 * @param signature
	 * @return
	 */
public static UnresolvedType createTypeFromSignature(String signature) {
		if (signature.equals(ResolvedType.MISSING_NAME)) return ResolvedType.MISSING;
		char firstChar = signature.charAt(0);
		if (firstChar=='P') {
			// parameterized type, calculate signature erasure and type parameters
			// (see pr122458) It is possible for a parameterized type to have *no* type parameters visible in its signature.
			// This happens for an inner type of a parameterized type which simply inherits the type parameters
			// of its parent.  In this case it is parameterized but theres no < in the signature.
			
			int startOfParams = signature.indexOf('<');
			if (startOfParams==-1) {
				// Should be an inner type of a parameterized type - could assert there is a '$' in the signature....
				String signatureErasure = "L" + signature.substring(1);
				UnresolvedType[] typeParams = new UnresolvedType[0];
				return new UnresolvedType(signature,signatureErasure,typeParams);
			} else {
				int endOfParams = locateMatchingEndBracket(signature,startOfParams);//signature.lastIndexOf('>');
				StringBuffer erasureSig = new StringBuffer(signature);
				while (startOfParams!=-1) {
					erasureSig.delete(startOfParams,endOfParams+1);
					startOfParams = locateFirstBracket(erasureSig);
					if (startOfParams!=-1) endOfParams = locateMatchingEndBracket(erasureSig,startOfParams);
				}
				
				String signatureErasure = "L" + erasureSig.toString().substring(1);
				
				// the type parameters of interest are only those that apply to the 'last type' in the signature
				// if the signature is 'PMyInterface<String>$MyOtherType;' then there are none...
				String lastType = null;
				int nestedTypePosition = signature.indexOf("$");
				if (nestedTypePosition!=-1) lastType = signature.substring(nestedTypePosition+1);
				else                        lastType = new String(signature);
				startOfParams = lastType.indexOf("<");
				endOfParams = locateMatchingEndBracket(lastType,startOfParams);
				UnresolvedType[] typeParams = UnresolvedType.NONE;
				if (startOfParams!=-1) {
				  typeParams = createTypeParams(lastType.substring(startOfParams +1, endOfParams));
				}
				
				return new UnresolvedType(signature,signatureErasure,typeParams);
			}
			// can't replace above with convertSigToType - leads to stackoverflow
		} else if (signature.equals("?")){
			UnresolvedType ret = UnresolvedType.SOMETHING;
			ret.typeKind = TypeKind.WILDCARD;
			return ret;
		} else if(firstChar=='+') { 
			// ? extends ...
			UnresolvedType ret = new UnresolvedType(signature);
			ret.typeKind = TypeKind.WILDCARD;
			
//			UnresolvedType bound1 = UnresolvedType.forSignature(signature.substring(1));
//			UnresolvedType bound2 = convertSigToType(signature.substring(1));
			ret.setUpperBound(convertSigToType(signature.substring(1)));
			return ret;
		} else if (firstChar=='-') { 
			// ? super ...
//			UnresolvedType bound = UnresolvedType.forSignature(signature.substring(1));
//			UnresolvedType bound2 = convertSigToType(signature.substring(1));
			UnresolvedType ret = new UnresolvedType(signature);
			ret.typeKind = TypeKind.WILDCARD;
			ret.setLowerBound(convertSigToType(signature.substring(1)));
			return ret;
		} else if (firstChar=='T') {
			String typeVariableName = signature.substring(1);
			if (typeVariableName.endsWith(";")) {
				typeVariableName = typeVariableName.substring(0, typeVariableName.length() -1);
			}
			return new UnresolvedTypeVariableReferenceType(new TypeVariable(typeVariableName));
		} else if (firstChar=='[') { 
			int dims = 0;
			while (signature.charAt(dims)=='[') dims++;
			UnresolvedType componentType = createTypeFromSignature(signature.substring(dims));
			return new UnresolvedType(signature,
					signature.substring(0,dims)+componentType.getErasureSignature());
		} else if (signature.length()==1) { // could be a primitive
		  switch (firstChar) {
		  	  case 'V': return ResolvedType.VOID;
		  	  case 'Z': return ResolvedType.BOOLEAN;
			  case 'B': return ResolvedType.BYTE;
			  case 'C': return ResolvedType.CHAR;
			  case 'D': return ResolvedType.DOUBLE;
			  case 'F': return ResolvedType.FLOAT;
			  case 'I': return ResolvedType.INT;
			  case 'J': return ResolvedType.LONG;
			  case 'S': return ResolvedType.SHORT;
		  }
		}
		return new UnresolvedType(signature);
	}
================= fetch public void testTypeXForParameterizedTypes() { 579ec14^:weaver/testsrc/org/aspectj/weaver/TypeXTestCase.java

public void testTypeXForParameterizedTypes() {
		if (LangUtil.is15VMOrGreater()) { // no funny types pre 1.5
			World world = new BcelWorld();
			UnresolvedType stringType = UnresolvedType.forName("java/lang/String");
			ResolvedType listOfStringType = 
				TypeFactory.createParameterizedType(
								UnresolvedType.forName("java/util/List").resolve(world), 
								new UnresolvedType[] {stringType},
								world);
			assertEquals("1 type param",1,listOfStringType.typeParameters.length);
			assertEquals(stringType,listOfStringType.typeParameters[0]);
			assertTrue(listOfStringType.isParameterizedType());
			assertFalse(listOfStringType.isGenericType());
		}
	}
================= fetch public void methodMustOverride(AbstractMethodDeclaration method) { 4177bed^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java
/**
     * Overrides the implementation in ProblemReporter and is ITD aware.
     * To report a *real* problem with an ITD marked @override, the other methodMustOverride() method is used.
     */
public void methodMustOverride(AbstractMethodDeclaration method) {
    	MethodBinding binding = method.binding;
    	
    	// ignore ajc$ methods
    	if (new String(method.selector).startsWith("ajc$")) return;
		ResolvedMember possiblyErroneousRm = factory.makeResolvedMember(method.binding);
    	
    	ResolvedType onTypeX =  factory.fromEclipse(method.binding.declaringClass);
    	// Can't use 'getInterTypeMungersIncludingSupers()' since that will exclude abstract ITDs
    	// on any super classes - so we have to trawl up ourselves.. I wonder if this problem
    	// affects other code in the problem reporter that looks through ITDs...
    	ResolvedType supertypeToLookAt = onTypeX.getSuperclass();
    	while (supertypeToLookAt!=null) {
    		List itMungers = supertypeToLookAt.getInterTypeMungers();
	    	for (Iterator i = itMungers.iterator(); i.hasNext(); ) {
				ConcreteTypeMunger m = (ConcreteTypeMunger)i.next();
				ResolvedMember sig = m.getSignature();
				ResolvedMember rm = AjcMemberMaker.interMethod(sig,m.getAspectType(),
						sig.getDeclaringType().resolve(factory.getWorld()).isInterface());
				if (ResolvedType.matches(rm,possiblyErroneousRm)) {
					// match, so dont need to report a problem!
					return;
				}
			}
	    	supertypeToLookAt = supertypeToLookAt.getSuperclass();
    	}
    	// report the error...
    	super.methodMustOverride(method);
    }
================= fetch public String toString() { 5336603^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java

private static File isAspectjtoolsjar(String path) {
        if (null == path) {
            return null;
        }
        final String prefix = "aspectj";        
        final String infix = "tools";        
        final String altInfix = "-tools";        
        final String suffix = ".jar";
        final int prefixLength = 7; // prefix.length();
        final int minLength = 16;
        // prefixLength + infix.length() + suffix.length();        
        if (!path.endsWith(suffix)) {
            return null;
        }
        int loc = path.lastIndexOf(prefix);
        if ((-1 != loc) && ((loc + minLength) <= path.length())) {
            String rest = path.substring(loc+prefixLength);
            if (-1 != rest.indexOf(File.pathSeparator)) {
                return null;
            }
            if (rest.startsWith(infix)
                || rest.startsWith(altInfix)) {
                File result = new File(path);
                if (result.canRead() && result.isFile()) {
                    return result;
                }
            }
        }        
        return null;
    }
Progress : [##############--------------------------] 36%================= fetch public String getClassName () { e8d2556^:loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java
/**
     * Build the bytecode for the concrete aspect
     *
     * @return concrete aspect bytecode
     */
public byte[] getBytes() {
        if (!m_isValid) {
            throw new RuntimeException("Must validate first");
        }

        //TODO AV - abstract away from BCEL...
        // @Aspect //inherit clause from m_parent
        // @DeclarePrecedence("....") // if any
        // public class xxxName [extends xxxExtends] {
        //    [@Pointcut(xxxExpression-n)
        //    public void xxxName-n() {}]
        // }

        // @Aspect public class ...
        LazyClassGen cg = new LazyClassGen(
                m_concreteAspect.name.replace('.', '/'),
                (m_parent==null)?"java/lang/Object":m_parent.getName().replace('.', '/'),
                null,//TODO AV - we could point to the aop.xml that defines it and use JSR-45
                Modifier.PUBLIC + Constants.ACC_SUPER,
                EMPTY_STRINGS,
                m_world
        );
        AnnotationGen ag = new AnnotationGen(
                new ObjectType("org/aspectj/lang/annotation/Aspect"),
                Collections.EMPTY_LIST,
                true,
                cg.getConstantPoolGen()
        );
        cg.addAnnotation(ag.getAnnotation());
        if (m_concreteAspect.precedence != null) {
            SimpleElementValueGen svg = new SimpleElementValueGen(
                    ElementValueGen.STRING,
                    cg.getConstantPoolGen(),
                    m_concreteAspect.precedence
            );
            List elems = new ArrayList();
            elems.add(new ElementNameValuePairGen("value", svg, cg.getConstantPoolGen()));
            AnnotationGen agprec = new AnnotationGen(
                    new ObjectType("org/aspectj/lang/annotation/DeclarePrecedence"),
                    elems,
                    true,
                    cg.getConstantPoolGen()
            );
            cg.addAnnotation(agprec.getAnnotation());
        }

        // default constructor
        LazyMethodGen init = new LazyMethodGen(
                Modifier.PUBLIC,
                Type.VOID,
                "<init>",
                EMPTY_TYPES,
                EMPTY_STRINGS,
                cg
        );
        InstructionList cbody = init.getBody();
        cbody.append(InstructionConstants.ALOAD_0);
        cbody.append(cg.getFactory().createInvoke(
                (m_parent==null)?"java/lang/Object":m_parent.getName().replace('.', '/'),
                "<init>",
                Type.VOID,
                EMPTY_TYPES,
                Constants.INVOKESPECIAL
        ));
        cbody.append(InstructionConstants.RETURN);
        cg.addMethodGen(init);

        for (Iterator it = m_concreteAspect.pointcuts.iterator(); it.hasNext();) {
            Definition.Pointcut abstractPc = (Definition.Pointcut) it.next();

            LazyMethodGen mg = new LazyMethodGen(
                    Modifier.PUBLIC,//TODO AV - respect visibility instead of opening up?
                    Type.VOID,
                    abstractPc.name,
                    EMPTY_TYPES,
                    EMPTY_STRINGS,
                    cg
            );
            SimpleElementValueGen svg = new SimpleElementValueGen(
                    ElementValueGen.STRING,
                    cg.getConstantPoolGen(),
                    abstractPc.expression
            );
            List elems = new ArrayList();
            elems.add(new ElementNameValuePairGen("value", svg, cg.getConstantPoolGen()));
            AnnotationGen mag = new AnnotationGen(
                    new ObjectType("org/aspectj/lang/annotation/Pointcut"),
                    elems,
                    true,
                    cg.getConstantPoolGen()
            );
            AnnotationX max = new AnnotationX(mag.getAnnotation(), m_world);
            mg.addAnnotation(max);

            InstructionList body = mg.getBody();
            body.append(InstructionConstants.RETURN);

            cg.addMethodGen(mg);
        }

        // handle the perClause
        BcelPerClauseAspectAdder perClauseMunger = new BcelPerClauseAspectAdder(
                ResolvedType.forName(m_concreteAspect.name).resolve(m_world),
                m_perClause.getKind()
        );
        perClauseMunger.forceMunge(cg, false);

        //TODO AV - unsafe cast
        // register the fresh new class into the world repository as it does not exist on the classpath anywhere
        JavaClass jc = cg.getJavaClass((BcelWorld) m_world);
        ((BcelWorld) m_world).addSourceObjectType(jc);

        return jc.getBytes();
    }
================= fetch public boolean validate() { e8d2556^:loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java

public boolean validate() {
        if (!(m_world instanceof BcelWorld)) {
            reportError("Internal error: world must be of type BcelWorld");
            return false;
        }

        // name must be undefined so far
        ResolvedType current = m_world.resolve(m_concreteAspect.name, true);
        if (!current.isMissing()) {
            reportError("Attempt to concretize but chosen aspect name already defined: " + stringify());
            return false;
        }

        // it can happen that extends is null, for precedence only declaration
        if (m_concreteAspect.extend == null && m_concreteAspect.precedence != null) {
            if (m_concreteAspect.pointcuts.isEmpty()) {
                m_isValid = true;
                m_perClause = new PerSingleton();
                m_parent = null;
                return true;// no need to checks more in that special case
            } else {
                reportError("Attempt to use nested pointcuts without extends clause: "+stringify());
                return false;
            }
        }

        m_parent = m_world.resolve(m_concreteAspect.extend, true);
        // handle inner classes
        if (m_parent.isMissing()) {
            // fallback on inner class lookup mechanism
            String fixedName = m_concreteAspect.extend;
            int hasDot = fixedName.lastIndexOf('.');
            while (hasDot > 0) {
                char[] fixedNameChars = fixedName.toCharArray();
                fixedNameChars[hasDot] = '$';
                fixedName = new String(fixedNameChars);
                hasDot = fixedName.lastIndexOf('.');
                m_parent = m_world.resolve(UnresolvedType.forName(fixedName), true);
                if (!m_parent.isMissing()) {
                    break;
                }
            }
        }
        if (m_parent.isMissing()) {
            reportError("Cannot find m_parent aspect for: " + stringify());
            return false;
        }

        // extends must be abstract
        if (!m_parent.isAbstract()) {
            reportError("Attempt to concretize a non-abstract aspect: " + stringify());
            return false;
        }

        // m_parent must be aspect
        if (!m_parent.isAspect()) {
            reportError("Attempt to concretize a non aspect: " + stringify());
            return false;
        }

        // must have all abstractions defined
        List elligibleAbstractions = new ArrayList();
        
        Collection abstractMethods = getOutstandingAbstractMethods(m_parent);
        for (Iterator iter = abstractMethods.iterator(); iter.hasNext();) {
			ResolvedMember method = (ResolvedMember) iter.next();
			if ("()V".equals(method.getSignature())) {
			 String n = method.getName();
            	 if (n.startsWith("ajc$pointcut")) { // Allow for the abstract pointcut being from a code style aspect compiled with -1.5 (see test for 128744)
            		n = n.substring(14);
            		n = n.substring(0,n.indexOf("$"));
            		elligibleAbstractions.add(n);         
            	 } else if (hasPointcutAnnotation(method)) {
         			elligibleAbstractions.add(method.getName());
            	 } else {
             	 // error, an outstanding abstract method that can't be concretized in XML
            		 reportError("Abstract method '" + method.toString() + "' cannot be concretized in XML: " + stringify());
                  return false;
            	 }
            } else {
            	  if (method.getName().startsWith("ajc$pointcut") || hasPointcutAnnotation(method)) {
            		// it may be a pointcut but it doesn't meet the requirements for XML concretization
            		reportError("Abstract method '" + method.toString() + "' cannot be concretized as a pointcut (illegal signature, must have no arguments, must return void): " + stringify());
                 return false;
            	  } else {
            		// error, an outstanding abstract method that can't be concretized in XML
                 reportError("Abstract method '" + method.toString() + "' cannot be concretized in XML: " + stringify());
                 return false;
            	  }
            }
		}
        List pointcutNames = new ArrayList();
        for (Iterator it = m_concreteAspect.pointcuts.iterator(); it.hasNext();) {
            Definition.Pointcut abstractPc = (Definition.Pointcut) it.next();
            pointcutNames.add(abstractPc.name);
        }
        for (Iterator it = elligibleAbstractions.iterator(); it.hasNext();) {
            String elligiblePc = (String) it.next();
            if (!pointcutNames.contains(elligiblePc)) {
                reportError("Abstract pointcut '" + elligiblePc + "' not configured: " + stringify());
                return false;
            }
        }

        m_perClause = m_parent.getPerClause();
        m_isValid = true;
        return m_isValid;
    }
================= fetch private boolean configureBuildOptions( AjBuildConfig config, BuildOptionsAdapter c54fa62^:ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java
/**
	 * Populate options in a build configuration, using the Ajde BuildOptionsAdapter.
	 * Added by AMC 01.20.2003, bugzilla #29769
	 */
private boolean configureBuildOptions( AjBuildConfig config, BuildOptionsAdapter options, IMessageHandler handler) {
        LangUtil.throwIaxIfNull(options, "options");
        LangUtil.throwIaxIfNull(config, "config");
		Map optionsToSet = new HashMap();
        LangUtil.throwIaxIfNull(optionsToSet, "javaOptions");
        
        checkNotAskedForJava6Compliance(options);

        if (options.getSourceCompatibilityLevel() != null && options.getSourceCompatibilityLevel().equals(CompilerOptions.VERSION_1_5)) {
		    optionsToSet.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_5);
		    optionsToSet.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_5); 
		} else if (options.getSourceCompatibilityLevel() != null && options.getSourceCompatibilityLevel().equals(CompilerOptions.VERSION_1_4)) {
		    optionsToSet.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_4);	 
			optionsToSet.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_4);
		} 
		
		String enc = options.getCharacterEncoding();
		if (!LangUtil.isEmpty(enc)) {
			optionsToSet.put(CompilerOptions.OPTION_Encoding, enc );
		}

		String compliance = options.getComplianceLevel();
		if (!LangUtil.isEmpty(compliance)) {
			String version = CompilerOptions.VERSION_1_4;
			if ( compliance.equals( BuildOptionsAdapter.VERSION_13 ) ) {
				version = CompilerOptions.VERSION_1_3;
			}
			optionsToSet.put(CompilerOptions.OPTION_Compliance, version );	
			optionsToSet.put(CompilerOptions.OPTION_Source, version );
		}
				
		String sourceLevel = options.getSourceCompatibilityLevel();
		if (!LangUtil.isEmpty(sourceLevel)) {
			String slVersion = CompilerOptions.VERSION_1_4;
			if ( sourceLevel.equals( BuildOptionsAdapter.VERSION_13 ) ) {
				slVersion = CompilerOptions.VERSION_1_3;
			}
			// never set a lower source level than compliance level
			// Mik: prepended with 1.5 check
			if (sourceLevel.equals(CompilerOptions.VERSION_1_5)) {
			    optionsToSet.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_5);	
			} else {
				if (optionsToSet.containsKey(CompilerOptions.OPTION_Compliance)) {
					String setCompliance = (String) optionsToSet.get(CompilerOptions.OPTION_Compliance);
					if ( ! (setCompliance.equals(CompilerOptions.VERSION_1_4 )
				         && slVersion.equals(CompilerOptions.VERSION_1_3)) ) {
					    optionsToSet.put(CompilerOptions.OPTION_Source, slVersion);		
					} 
				}
			}
		}
	
		Set warnings = options.getWarnings();
		if (!LangUtil.isEmpty(warnings)) {
			// turn off all warnings	
			disableWarnings( optionsToSet );
			// then selectively enable those in the set
			enableWarnings( optionsToSet, warnings );
		} else if (warnings == null) {
			// set default warnings on...
			enableWarnings( optionsToSet, DEFAULT__AJDE_WARNINGS);
		}

		Set debugOptions = options.getDebugLevel();
		if (!LangUtil.isEmpty(debugOptions)) {
			// default is all options on, so just need to selectively
			// disable
			boolean sourceLine = false;
			boolean varAttr = false;
			boolean lineNo = false;
			Iterator it = debugOptions.iterator();
			while (it.hasNext()){
				String debug = (String) it.next();
				if ( debug.equals( BuildOptionsAdapter.DEBUG_ALL )) {
					sourceLine = true;
					varAttr = true;
					lineNo = true;
				} else if ( debug.equals( BuildOptionsAdapter.DEBUG_LINES )) {
					lineNo = true;
				}  else if ( debug.equals( BuildOptionsAdapter.DEBUG_SOURCE )) {
					sourceLine = true;
				}  else if ( debug.equals( BuildOptionsAdapter.DEBUG_VARS)) {
					varAttr = true;
				}
			}
			if (sourceLine) optionsToSet.put(CompilerOptions.OPTION_SourceFileAttribute,
											CompilerOptions.GENERATE);
			if (varAttr) optionsToSet.put(CompilerOptions.OPTION_LocalVariableAttribute,
											CompilerOptions.GENERATE);		
			if (lineNo)  optionsToSet.put(CompilerOptions.OPTION_LineNumberAttribute,
											CompilerOptions.GENERATE);
		}
		//XXX we can't turn off import errors in 3.0 stream
//		if ( options.getNoImportError() ) {
//			javaOptions.put( CompilerOptions.OPTION_ReportInvalidImport,
//				CompilerOptions.WARNING);	
//		}
				
		if ( options.getPreserveAllLocals() ) {
			optionsToSet.put( CompilerOptions.OPTION_PreserveUnusedLocal,
				CompilerOptions.PRESERVE);		
		}
        if ( !config.isIncrementalMode()
            && options.getIncrementalMode() ) {
                config.setIncrementalMode(true);
        }
        				
		Map jom = options.getJavaOptionsMap();
		if (jom!=null) {
			String version = (String)jom.get(CompilerOptions.OPTION_Compliance);
			if (version!=null && version.equals(CompilerOptions.VERSION_1_5)) {
				config.setBehaveInJava5Way(true);
			}
		}
		
		config.getOptions().set(optionsToSet);
		String toAdd = options.getNonStandardOptions();
        return LangUtil.isEmpty(toAdd) 
            ? true
            : configureNonStandardOptions( config, toAdd, handler );
        // ignored: lenient, porting, preprocess, strict, usejavac, workingdir
	}
================= fetch public void testCharacterEncoding() { c54fa62^:ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java
// The tests...
public void testCharacterEncoding() {
		buildOptions.setCharacterEncoding( "UTF-8" );
		buildConfig = compilerAdapter.genBuildConfig( configFile );
        assertTrue(configFile + " failed", null != buildConfig);			
		Map options = buildConfig.getOptions().getMap();
		String encoding = (String) options.get( CompilerOptions.OPTION_Encoding );
		assertEquals( "character encoding", "UTF-8", encoding );
	}
================= fetch public void testSourceCompatibilityLevelJava6() { c54fa62^:ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java

public void testSourceCompatibilityLevelJava6() {
		buildOptions.setSourceCompatibilityLevel(BuildOptionsAdapter.VERSION_16 );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
        assertTrue(configFile + " failed", null != buildConfig);            
		Map options = buildConfig.getOptions().getMap();
		String compliance = (String) options.get(CompilerOptions.OPTION_Compliance);
		String sourceLevel = (String) options.get(CompilerOptions.OPTION_Source);
		
		if (Ajde.getDefault().compilerIsJava6Compatible()) {
			assertEquals("expected compliance level to be 1.6 but found " + compliance, "1.6", compliance);
			assertEquals("expected source level to be 1.6 but found " + sourceLevel, "1.6", sourceLevel );
			assertTrue("expected to 'behaveInJava5Way' but aren't",buildConfig.getBehaveInJava5Way());			
		} else {
			List l = taskListManager.getSourceLineTasks();
			String expectedError = "Java 6.0 source level is unsupported";
			String found = ((SourceLineTask)l.get(0)).getContainedMessage().getMessage();
			assertEquals("Expected 'Java 6.0 compliance level is unsupported'" +
					" error message but found " + found ,expectedError,found);
		}
	}
================= fetch public void testSourceIncompatibilityLevel() { c54fa62^:ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java

public void testSourceIncompatibilityLevel() {
		// this config should "fail" and leave source level at 1.4
		buildOptions.setComplianceLevel( BuildOptionsAdapter.VERSION_14);
		buildOptions.setSourceCompatibilityLevel( BuildOptionsAdapter.VERSION_13);
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
        assertTrue(configFile + " failed", null != buildConfig);            
		Map options = buildConfig.getOptions().getMap();
		String compliance = (String) options.get(CompilerOptions.OPTION_Compliance);
		String sourceLevel = (String) options.get(CompilerOptions.OPTION_Source);		
		assertEquals( "compliance level", CompilerOptions.VERSION_1_4, compliance);
		assertEquals( "source level", CompilerOptions.VERSION_1_4, sourceLevel );		
	}
================= fetch private static FuzzyBoolean inStar(final TypePattern[] pattern, final ResolvedTy 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/TypePatternList.java

private static FuzzyBoolean inStar(final TypePattern[] pattern, final ResolvedType[] target, 
                                               int           pi,             int    ti, 
                                         final int           pLeft,         int    tLeft,
                                               int    starsLeft,     TypePattern.MatchKind kind) {
        // invariant: pLeft > 0, so we know we'll run out of stars and find a real char in pattern
        TypePattern patternChar = pattern[pi];
        while (patternChar == TypePattern.ELLIPSIS) {
            starsLeft--;
            patternChar = pattern[++pi];
        }
        while (true) {
            // invariant: if (tLeft > 0) then (ti < target.length)
            if (pLeft > tLeft) return FuzzyBoolean.NO;
            FuzzyBoolean ff = patternChar.matches(target[ti], kind);
            if (ff.maybeTrue()) {
                FuzzyBoolean xx = outOfStar(pattern, target, pi+1, ti+1, pLeft-1, tLeft-1, starsLeft, kind);
                if (xx.maybeTrue()) return ff.and(xx);
            } 
            ti++; tLeft--;
        }
    }
================= fetch private void setAdditionalInterfaceBoundsFromTypeVar() { 7b40e7e^:weaver/src/org/aspectj/weaver/TypeVariableReferenceType.java

public ReferenceType[] getAdditionalBounds() {
		if (!resolvedIfBounds) {
			setAdditionalInterfaceBoundsFromTypeVar();
			resolvedIfBounds = true;
		}
		return super.getAdditionalBounds();
	}
================= fetch private void verifyRuntimeRetention(World world, ResolvedType resolvedAnnotation 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.java

private void verifyRuntimeRetention(World world, ResolvedType resolvedAnnotationType) {
		if (!resolvedAnnotationType.isAnnotationWithRuntimeRetention()) { // default is class visibility
		    // default is class visibility
			IMessage m = MessageUtil.error(
					WeaverMessages.format(WeaverMessages.BINDING_NON_RUNTIME_RETENTION_ANNOTATION,annotationType.getName()),
					getSourceLocation());
			world.getMessageHandler().handleMessage(m);
			resolved = false;		    
		}
	}
================= fetch protected Collection getDeclares() { 7b40e7e^:weaver/src/org/aspectj/weaver/ReferenceType.java

protected Collection getPrivilegedAccesses() { return delegate.getPrivilegedAccesses(); }
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java

protected FuzzyBoolean matchInternal(Shadow shadow) {
		if (shadow.getKind() != Shadow.ExceptionHandler) return FuzzyBoolean.NO;
		
		exceptionType.resolve(shadow.getIWorld());
		
		// we know we have exactly one parameter since we're checking an exception handler
		return exceptionType.matches(
				shadow.getSignature().getParameterTypes()[0].resolve(shadow.getIWorld()), 
				TypePattern.STATIC);
	}
================= fetch protected Test findResidueInternal(Shadow shadow, ExposedState state) { 7b40e7e^:weaver/src/org/aspectj/weaver/internal/tools/PointcutDesignatorHandlerBasedPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.Pointcut#findResidueInternal(org.aspectj.weaver.Shadow, org.aspectj.weaver.patterns.ExposedState)
	 */
protected Test findResidueInternal(Shadow shadow, ExposedState state) {
		if (!this.matcher.mayNeedDynamicTest()) {
			return Literal.TRUE;
		} else {
			// could be more efficient here!
			matchInternal(shadow);
			return new MatchingContextBasedTest(this.matcher);
		}
	}
================= fetch public AnnotationPatternList parameterizeWith(Map typeVariableMap) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.java

public AnnotationPatternList parameterizeWith(Map typeVariableMap) {
		AnnotationTypePattern[] parameterizedPatterns = new AnnotationTypePattern[this.typePatterns.length];
		for (int i = 0; i < parameterizedPatterns.length; i++) {
			parameterizedPatterns[i] = this.typePatterns[i].parameterizeWith(typeVariableMap);
		}
		AnnotationPatternList ret = new AnnotationPatternList(parameterizedPatterns);
		ret.copyLocationFrom(this);
		return ret;
	}
================= fetch public AnnotationPatternList(List l) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.java

protected AnnotationTypePattern[] getAnnotationPatterns() {
		return typePatterns;
	}
================= fetch public AnnotationTypePattern remapAdviceFormals(IntMap bindings) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java

public boolean isAny() { return false; }
================= fetch public AnnotationTypePattern resolveBindings(IScope scope, Bindings bindings, 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java
/**
	 * This can modify in place, or return a new TypePattern if the type changes.
	 */
public AnnotationTypePattern resolveBindings(IScope scope, Bindings bindings, 
    								             boolean allowBinding)
    { 
	if (!scope.getWorld().isInJava5Mode()) {
		scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.ANNOTATIONS_NEED_JAVA5),
				getSourceLocation()));
		return this;
	}
	if (resolved) return this;
    	this.typePattern = typePattern.resolveBindings(scope,bindings,false,false);
    	resolved = true;
    	if (typePattern instanceof ExactTypePattern) {
    		ExactTypePattern et = (ExactTypePattern)typePattern;
			if (!et.getExactType().resolve(scope.getWorld()).isAnnotation()) {
				IMessage m = MessageUtil.error(
						WeaverMessages.format(WeaverMessages.REFERENCE_TO_NON_ANNOTATION_TYPE,et.getExactType().getName()),
						getSourceLocation());
				scope.getWorld().getMessageHandler().handleMessage(m);
				resolved = false;
			}
    		ExactAnnotationTypePattern eatp =  new ExactAnnotationTypePattern(et.getExactType().resolve(scope.getWorld()));
    		eatp.copyLocationFrom(this);
    		return eatp;
    	} else {
    		return this;
    	}
    }
================= fetch public AnnotationTypePattern resolveBindings(IScope scope, 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/AndAnnotationTypePattern.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.AnnotationTypePattern#resolveBindings(org.aspectj.weaver.patterns.IScope, org.aspectj.weaver.patterns.Bindings, boolean)
	 */
public AnnotationTypePattern resolveBindings(IScope scope,
			Bindings bindings, boolean allowBinding) {
		left = left.resolveBindings(scope,bindings,allowBinding);
		right =right.resolveBindings(scope,bindings,allowBinding);
		return this;
	}
================= fetch public AnnotationTypePattern resolveBindings(IScope scope, 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.AnnotationTypePattern#resolveBindings(org.aspectj.weaver.patterns.IScope, org.aspectj.weaver.patterns.Bindings, boolean)
	 */
public AnnotationTypePattern resolveBindings(IScope scope,
			Bindings bindings, boolean allowBinding) {
		if (resolved) return this;
		resolved = true;
		String simpleName = maybeGetSimpleName();
		if (simpleName != null) {
			FormalBinding formalBinding = scope.lookupFormal(simpleName);
			if (formalBinding != null) {
				if (bindings == null) {
					scope.message(IMessage.ERROR, this, "negation doesn't allow binding");
					return this;
				}
				if (!allowBinding) {
					scope.message(IMessage.ERROR, this, 
						"name binding only allowed in @pcds, args, this, and target");
					return this;
				}
				formalName = simpleName;
				bindingPattern = true;
				verifyIsAnnotationType(formalBinding.getType().resolve(scope.getWorld()),scope);
				BindingAnnotationTypePattern binding = new BindingAnnotationTypePattern(formalBinding);
				binding.copyLocationFrom(this);
				bindings.register(binding, scope);
				binding.resolveBinding(scope.getWorld());
				
				return binding;
			} 
		}

		// Non binding case
		String cleanname = annotationType.getName();
		annotationType = scope.getWorld().resolve(annotationType,true);
		
		// We may not have found it if it is in a package, lets look it up...
		if (ResolvedType.isMissing(annotationType)) {
			UnresolvedType type = null;
			while (ResolvedType.isMissing(type = scope.lookupType(cleanname,this))) {
				int lastDot = cleanname.lastIndexOf('.');
				if (lastDot == -1) break;
				cleanname = cleanname.substring(0,lastDot)+"$"+cleanname.substring(lastDot+1);
			}
			annotationType = scope.getWorld().resolve(type,true);
		}
		
		verifyIsAnnotationType((ResolvedType)annotationType,scope);
		return this;
	}
================= fetch public AnnotationTypePattern resolveBindings(IScope scope, 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/NotAnnotationTypePattern.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.AnnotationTypePattern#resolveBindings(org.aspectj.weaver.patterns.IScope, org.aspectj.weaver.patterns.Bindings, boolean)
	 */
public AnnotationTypePattern resolveBindings(IScope scope,
			Bindings bindings, boolean allowBinding) {
		negatedPattern = negatedPattern.resolveBindings(scope,bindings,allowBinding);
		return this;
	}
================= fetch public AnnotationTypePattern resolveBindings(IScope scope, 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/OrAnnotationTypePattern.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.AnnotationTypePattern#resolveBindings(org.aspectj.weaver.patterns.IScope, org.aspectj.weaver.patterns.Bindings, boolean)
	 */
public AnnotationTypePattern resolveBindings(IScope scope,
			Bindings bindings, boolean allowBinding) {
		left = left.resolveBindings(scope,bindings,allowBinding);
		right =right.resolveBindings(scope,bindings,allowBinding);
		return this;
	}
================= fetch public BoundedReferenceType(ReferenceType aBound, boolean isExtends, World world 7b40e7e^:weaver/src/org/aspectj/weaver/BoundedReferenceType.java

public ReferenceType[] getAdditionalBounds() {
		return additionalInterfaceBounds;
	}
================= fetch public Declare parameterizeWith(Map typeVariableBindingMap) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/DeclareAnnotation.java

public Declare parameterizeWith(Map typeVariableBindingMap) {
		DeclareAnnotation ret;
		if (this.kind == AT_TYPE) {
			ret = new DeclareAnnotation(kind,this.typePattern.parameterizeWith(typeVariableBindingMap));
		} else {
			ret = new DeclareAnnotation(kind, this.sigPattern.parameterizeWith(typeVariableBindingMap));
		}
		ret.annotationMethod = this.annotationMethod;
		ret.annotationString = this.annotationString;
		ret.containingAspect = this.containingAspect;
		ret.annotation = this.annotation;
		ret.copyLocationFrom(this);
		return ret;
	}
================= fetch public Declare parameterizeWith(Map typeVariableBindingMap) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/DeclareParents.java

public Declare parameterizeWith(Map typeVariableBindingMap) {
		DeclareParents ret = 
			new DeclareParents(
					child.parameterizeWith(typeVariableBindingMap),
					parents.parameterizeWith(typeVariableBindingMap),
					isExtends);
		ret.copyLocationFrom(this);
		return ret;
	}
================= fetch public Declare parameterizeWith(Map typeVariableBindingMap) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java

public Declare parameterizeWith(Map typeVariableBindingMap) {
		DeclareSoft ret = 
			new DeclareSoft(
					exception.parameterizeWith(typeVariableBindingMap),
					pointcut.parameterizeWith(typeVariableBindingMap));
		ret.copyLocationFrom(this);
		return ret;
	}
================= fetch public FuzzyBoolean matchesInstanceof(ResolvedType type) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/HasMemberTypePattern.java

public FuzzyBoolean matchesInstanceof(ResolvedType type) {
		throw new UnsupportedOperationException("hasmethod/field do not support instanceof matching");
	}
================= fetch public FuzzyBoolean matchesInstanceof(ResolvedType type) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/TypePattern.java
/**
	 * @see org.aspectj.weaver.patterns.TypePattern#matchesInstanceof(IType)
	 */
public FuzzyBoolean matchesInstanceof(ResolvedType type) {
		return FuzzyBoolean.NO;
	}
================= fetch public Object accept(PatternNodeVisitor visitor, Object data) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java

public Object accept(PatternNodeVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }
================= fetch public Object accept(PatternNodeVisitor visitor, Object data) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/DeclareParents.java

public Object accept(PatternNodeVisitor visitor, Object data) {
		return visitor.visit(this,data);
	}
================= fetch public Object accept(PatternNodeVisitor visitor, Object data) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java

public Object accept(PatternNodeVisitor visitor, Object data) {
		return visitor.visit(this,data);
	}
================= fetch public Object accept(PatternNodeVisitor visitor, Object data) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java

public Object accept(PatternNodeVisitor visitor, Object data) {
		return visitor.visit(this,data);
	}
================= fetch public Object accept(PatternNodeVisitor visitor, Object data) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/Pointcut.java

public Object accept(PatternNodeVisitor visitor, Object data) {
            return visitor.visit(this, data);
        }
================= fetch public Object accept(PatternNodeVisitor visitor, Object data) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/TypePattern.java

public Object accept(PatternNodeVisitor visitor, Object data) {
        return visitor.visit(this, data);
    }
================= fetch public PerClause concretize(ResolvedType inAspect) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java

public PerClause concretize(ResolvedType inAspect) {
		PerClause p = lookupConcretePerClause(inAspect.getSuperclass());
		if (p == null) {
			inAspect.getWorld().getMessageHandler().handleMessage(
			  MessageUtil.error(WeaverMessages.format(WeaverMessages.MISSING_PER_CLAUSE,inAspect.getSuperclass()), getSourceLocation())
			);
            return new PerSingleton().concretize(inAspect);// AV: fallback on something else NPE in AJDT
		} else {
            if (p.getKind() != kind) {
                inAspect.getWorld().getMessageHandler().handleMessage(
                  MessageUtil.error(WeaverMessages.format(WeaverMessages.WRONG_PER_CLAUSE,kind,p.getKind()),
                                    getSourceLocation())
                );
            }
            return p.concretize(inAspect);
        }
	}
================= fetch public PerClause getPerClause() { 7b40e7e^:weaver/src/org/aspectj/weaver/ReferenceType.java

public PerClause getPerClause() { 
		PerClause pclause = delegate.getPerClause();
		if (isParameterizedType()) { // could cache the result here...
			Map parameterizationMap = getAjMemberParameterizationMap();
			pclause = (PerClause)pclause.parameterizeWith(parameterizationMap);
		}
		return pclause;
	}
================= fetch public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, I 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/AndPointcut.java

public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, IntMap bindings) {
		AndPointcut ret =  new AndPointcut(left.concretize(inAspect, declaringType, bindings),
										   right.concretize(inAspect, declaringType, bindings));
		ret.copyLocationFrom(this);
		return ret;
	}
================= fetch public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, I 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/NotPointcut.java

public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, IntMap bindings) {
		Pointcut ret = new NotPointcut(body.concretize(inAspect, declaringType, bindings));
		ret.copyLocationFrom(this);
		return ret;
	}
================= fetch public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, I 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/OrPointcut.java

public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, IntMap bindings) {
		Pointcut ret = new OrPointcut(left.concretize(inAspect, declaringType, bindings),
								right.concretize(inAspect, declaringType, bindings));
		ret.copyLocationFrom(this);
		return ret;
	}
================= fetch public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/IfPointcut.java

public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType,  IntMap bindings) {
		//System.err.println("concretize: " + this + " already: " + partiallyConcretized);
		
		if (isDeclare(bindings.getEnclosingAdvice())) {
			// Enforce rule about which designators are supported in declare
			inAspect.getWorld().showMessage(IMessage.ERROR,
					WeaverMessages.format(WeaverMessages.IF_IN_DECLARE),
					bindings.getEnclosingAdvice().getSourceLocation(),
					null);
			return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
		}

		if (partiallyConcretized != null) {
			return partiallyConcretized;
		}

        final IfPointcut ret;
        if (extraParameterFlags < 0 && testMethod == null) {
            // @AJ style, we need to find the testMethod in the aspect defining the "if()" enclosing pointcut
            ResolvedPointcutDefinition def = bindings.peekEnclosingDefinition();
            if (def != null) {
                ResolvedType aspect = inAspect.getWorld().resolve(def.getDeclaringType());
                for (Iterator memberIter = aspect.getMethods(); memberIter.hasNext();) {
                    ResolvedMember method = (ResolvedMember) memberIter.next();
                    if (def.getName().equals(method.getName())
                        && def.getParameterTypes().length == method.getParameterTypes().length) {
                        boolean sameSig = true;
                        for (int j = 0; j < method.getParameterTypes().length; j++) {
                            UnresolvedType argJ = method.getParameterTypes()[j];
                            if (!argJ.equals(def.getParameterTypes()[j])) {
                                sameSig = false;
                                break;
                            }
                        }
                        if (sameSig) {
                            testMethod = method;
                            break;
                        }
                    }
                }
                if (testMethod == null) {
                    inAspect.getWorld().showMessage(
                            IMessage.ERROR,
                            "Cannot find if() body from '" + def.toString() + "' for '" + enclosingPointcutHint + "'",
                            this.getSourceLocation(),
                            null
                    );
                    return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
                }
            } else {
                testMethod = inAspect.getWorld().resolve(bindings.getAdviceSignature());
            }
            ret = new IfPointcut(enclosingPointcutHint);
            ret.testMethod = testMethod;
        } else {
            ret = new IfPointcut(testMethod, extraParameterFlags);
        }
        ret.copyLocationFrom(this);
        partiallyConcretized = ret;

		// It is possible to directly code your pointcut expression in a per clause
		// rather than defining a pointcut declaration and referencing it in your
		// per clause.  If you do this, we have problems (bug #62458).  For now,
		// let's police that you are trying to code a pointcut in a per clause and
		// put out a compiler error.
		if (bindings.directlyInAdvice() && bindings.getEnclosingAdvice()==null) {
			// Assumption: if() is in a per clause if we say we are directly in advice
			// but we have no enclosing advice.
			inAspect.getWorld().showMessage(IMessage.ERROR,
					WeaverMessages.format(WeaverMessages.IF_IN_PERCLAUSE),
					this.getSourceLocation(),null);
			return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
		}
		
		if (bindings.directlyInAdvice()) {
			ShadowMunger advice = bindings.getEnclosingAdvice();
			if (advice instanceof Advice) {
				ret.baseArgsCount = ((Advice)advice).getBaseParameterCount();
			} else {
				ret.baseArgsCount = 0;
			}
			ret.residueSource = advice.getPointcut().concretize(inAspect, inAspect, ret.baseArgsCount, advice);
		} else {
			ResolvedPointcutDefinition def = bindings.peekEnclosingDefinition();
			if (def == CflowPointcut.CFLOW_MARKER) {
				inAspect.getWorld().showMessage(IMessage.ERROR,
						WeaverMessages.format(WeaverMessages.IF_LEXICALLY_IN_CFLOW),
						getSourceLocation(), null);
				return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
			}
			ret.baseArgsCount = def.getParameterTypes().length;

            // for @style, we have implicit binding for JoinPoint.* things
            //FIXME AV - will lead to failure for "args(jp)" test(jp, thejp) / see args() implementation
            if (ret.extraParameterFlags < 0) {
                ret.baseArgsCount = 0;
                for (int i = 0; i < testMethod.getParameterTypes().length; i++) {
                    String argSignature = testMethod.getParameterTypes()[i].getSignature();
                    if (AjcMemberMaker.TYPEX_JOINPOINT.getSignature().equals(argSignature)
                        || AjcMemberMaker.TYPEX_PROCEEDINGJOINPOINT.getSignature().equals(argSignature)
                        || AjcMemberMaker.TYPEX_STATICJOINPOINT.getSignature().equals(argSignature)
                        || AjcMemberMaker.TYPEX_ENCLOSINGSTATICJOINPOINT.getSignature().equals(argSignature)) {
                        ;
                    } else {
                        ret.baseArgsCount++;
                    }
                }
            }

			IntMap newBindings = IntMap.idMap(ret.baseArgsCount);
			newBindings.copyContext(bindings);
			ret.residueSource = def.getPointcut().concretize(inAspect, declaringType, newBindings);
		}
		
		return ret;
	}
================= fetch public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java

public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType,  IntMap bindings) {
		Pointcut ret = new KindedPointcut(kind, signature, bindings.getEnclosingAdvice());
        ret.copyLocationFrom(this);
        return ret;
	}
================= fetch public Pointcut concretize1(ResolvedType searchStart, ResolvedType declaringType 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java
// and not one in a subtype that happens to have the same name.
public Pointcut concretize1(ResolvedType searchStart, ResolvedType declaringType, IntMap bindings) {
		if (concretizing) {
			//Thread.currentThread().dumpStack();
			searchStart.getWorld().getMessageHandler().handleMessage(
				MessageUtil.error(WeaverMessages.format(WeaverMessages.CIRCULAR_POINTCUT,this),
									getSourceLocation()));
			return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
		}
		
		try {
			concretizing = true;
		
			ResolvedPointcutDefinition pointcutDec;
			if (onType != null) {
				searchStart = onType.resolve(searchStart.getWorld());
				if (searchStart.isMissing()) {
					return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
				}
			
				if (onType.isTypeVariableReference()) {
					// need to replace on type with the binding for the type variable
					// in the declaring type
					if (declaringType.isParameterizedType()) {
						TypeVariable[] tvs = declaringType.getGenericType().getTypeVariables();
						String typeVariableName = ((TypeVariableReference)onType).getTypeVariable().getName();
						for (int i = 0; i < tvs.length; i++) {
							if (tvs[i].getName().equals(typeVariableName)) {
								ResolvedType realOnType = declaringType.getTypeParameters()[i].resolve(declaringType.getWorld());
								onType = realOnType;
								searchStart = realOnType;
								break;
							}
						}
					}
				}

			}

			if (declaringType == null) declaringType = searchStart;
			pointcutDec = declaringType.findPointcut(name);
			boolean foundMatchingPointcut = (pointcutDec != null && pointcutDec.isPrivate());
			if (!foundMatchingPointcut) {				
				pointcutDec = searchStart.findPointcut(name);
				if (pointcutDec == null) {
					searchStart.getWorld().getMessageHandler().handleMessage(
						MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_FIND_POINTCUT,name,searchStart.getName()), 
										getSourceLocation())
					);
					return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
				}
			}
			
			if (pointcutDec.isAbstract()) {
				//Thread.currentThread().dumpStack();
				ShadowMunger enclosingAdvice = bindings.getEnclosingAdvice();
				searchStart.getWorld().showMessage(IMessage.ERROR,
						WeaverMessages.format(WeaverMessages.ABSTRACT_POINTCUT,pointcutDec), 
						getSourceLocation(), 
						(null == enclosingAdvice) ? null : enclosingAdvice.getSourceLocation());
				return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
			}
					
			//System.err.println("start: " + searchStart);
			ResolvedType[] parameterTypes = searchStart.getWorld().resolve(pointcutDec.getParameterTypes());
			
			TypePatternList arguments = this.arguments.resolveReferences(bindings);
			
			IntMap newBindings = new IntMap();
			for (int i=0,len=arguments.size(); i < len; i++) {
				TypePattern p = arguments.get(i);
				if (p == TypePattern.NO) continue;
				// we are allowed to bind to pointcuts which use subtypes as this is type safe
				// this will be checked in ReferencePointcut.resolveBindings().  Can't check it here
				// as we don't know about any new parents added via decp.
			    if (p instanceof BindingTypePattern) {
			    	newBindings.put(i, ((BindingTypePattern)p).getFormalIndex());
			    }
			}

			if (searchStart.isParameterizedType()) {
				// build a type map mapping type variable names in the generic type to
				// the type parameters presented
				typeVariableMap = new HashMap();
				ResolvedType underlyingGenericType = searchStart.getGenericType();
				TypeVariable[] tVars = underlyingGenericType.getTypeVariables();
				ResolvedType[] typeParams = searchStart.getResolvedTypeParameters();
				for (int i = 0; i < tVars.length; i++) {
					typeVariableMap.put(tVars[i].getName(),typeParams[i]);
				}
			}
			
			newBindings.copyContext(bindings);
			newBindings.pushEnclosingDefinition(pointcutDec);
			try {
				Pointcut ret = pointcutDec.getPointcut();
				if (typeVariableMap != null && !hasBeenParameterized) {					
					ret = ret.parameterizeWith(typeVariableMap);
					ret.hasBeenParameterized=true;
				}
				return ret.concretize(searchStart, declaringType, newBindings);
			} finally {
				newBindings.popEnclosingDefinitition();
			}
			
		} finally {
			concretizing = false;
		}
	}
================= fetch public Pointcut parameterizeWith(Map typeVariableMap) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java

public Pointcut parameterizeWith(Map typeVariableMap) {
		ExactAnnotationTypePattern newPattern = (ExactAnnotationTypePattern) this.annotationTypePattern.parameterizeWith(typeVariableMap);
		if (newPattern.getAnnotationType() instanceof ResolvedType) {
			verifyRuntimeRetention((ResolvedType)newPattern.getResolvedAnnotationType());
		}
		ThisOrTargetAnnotationPointcut ret = new ThisOrTargetAnnotationPointcut(isThis,(ExactAnnotationTypePattern)annotationTypePattern.parameterizeWith(typeVariableMap));
		ret.copyLocationFrom(this);
		return ret;
	}
================= fetch public ResolvedMemberImpl parameterizedWith(UnresolvedType[] typeParameters, Res 7b40e7e^:weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.java
/**
	 * Called when asking a parameterized super-aspect for its pointcuts.
	 */
public ResolvedMemberImpl parameterizedWith(UnresolvedType[] typeParameters, ResolvedType newDeclaringType, boolean isParameterized) {
		TypeVariable[] typeVariables = getDeclaringType().resolve(newDeclaringType.getWorld()).getTypeVariables();
		if (isParameterized && (typeVariables.length != typeParameters.length)) {
			throw new IllegalStateException("Wrong number of type parameters supplied");
		}
		Map typeMap = new HashMap();
		boolean typeParametersSupplied = typeParameters!=null && typeParameters.length>0;
		if (typeVariables!=null) {
			// If no 'replacements' were supplied in the typeParameters array then collapse
			// type variables to their first bound.
			for (int i = 0; i < typeVariables.length; i++) {
				UnresolvedType ut = (!typeParametersSupplied?typeVariables[i].getFirstBound():typeParameters[i]);
				typeMap.put(typeVariables[i].getName(),ut);
			}
		}
		UnresolvedType parameterizedReturnType = parameterize(getGenericReturnType(),typeMap,isParameterized);
		UnresolvedType[] parameterizedParameterTypes = new UnresolvedType[getGenericParameterTypes().length];
		for (int i = 0; i < parameterizedParameterTypes.length; i++) {
			parameterizedParameterTypes[i] = 
				parameterize(getGenericParameterTypes()[i], typeMap,isParameterized);
		}
		ResolvedPointcutDefinition ret = new ResolvedPointcutDefinition(
					newDeclaringType,
					getModifiers(),
					getName(),
					parameterizedParameterTypes,
					parameterizedReturnType,
					pointcut.parameterizeWith(typeMap)
				);
		ret.setTypeVariables(getTypeVariables());
		ret.setSourceContext(getSourceContext());
		ret.setPosition(getStart(),getEnd());
		ret.setParameterNames(getParameterNames());
		return ret;
		//return this;
	}
================= fetch public ShadowMunger parameterizeWith(ResolvedType declaringType,Map typeVariable 7b40e7e^:weaver/src/org/aspectj/weaver/Checker.java

public ShadowMunger parameterizeWith(ResolvedType declaringType,Map typeVariableMap) {
		Checker ret = new Checker(
							getPointcut().parameterizeWith(typeVariableMap),
							getStart(),
							getEnd(),
							this.sourceContext);
		ret.msg = this.msg;
		ret.isError = this.isError;
		return ret;
	}
================= fetch public ShadowMunger parameterizeWith(ResolvedType declaringType,Map typeVariable 7b40e7e^:weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java

public ShadowMunger parameterizeWith(ResolvedType declaringType,Map typeVariableMap) {
		Pointcut pc = getPointcut().parameterizeWith(typeVariableMap);
		
		BcelAdvice ret = null;
		Member adviceSignature = signature;		
		// allows for around advice where the return value is a type variable (see pr115250)
		if (signature instanceof ResolvedMember && signature.getDeclaringType().isGenericType()) {
			adviceSignature = ((ResolvedMember)signature).parameterizedWith(declaringType.getTypeParameters(),declaringType,declaringType.isParameterizedType());
		}
		ret = new BcelAdvice(this.attribute,pc,adviceSignature,this.concreteAspect);
		return ret;
	}
================= fetch public SignaturePattern parameterizeWith(Map typeVariableMap) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java
/**
	 * return a copy of this signature pattern in which every type variable reference
	 * is replaced by the corresponding entry in the map.
	 */
public SignaturePattern parameterizeWith(Map typeVariableMap) {
		SignaturePattern ret = new SignaturePattern(
						kind,
						modifiers,
						returnType.parameterizeWith(typeVariableMap),
						declaringType.parameterizeWith(typeVariableMap),
						name,
						parameterTypes.parameterizeWith(typeVariableMap),
						throwsPattern.parameterizeWith(typeVariableMap),
						annotationPattern.parameterizeWith(typeVariableMap));
		ret.copyLocationFrom(this);
		return ret;
	}
================= fetch public String maybeGetCleanName() { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
/**
	 * If this type pattern has no '*' or '..' in it
	 */
public String maybeGetCleanName() {
		if (namePatterns.length == 0) {
			throw new RuntimeException("bad name: " + namePatterns);
		}
		//System.out.println("get clean: " + this);
		StringBuffer buf = new StringBuffer();
		for (int i=0, len=namePatterns.length; i < len; i++) {
			NamePattern p = namePatterns[i];
			String simpleName = p.maybeGetSimpleName();
			if (simpleName == null) return null;
			if (i > 0) buf.append(".");
			buf.append(simpleName);
		}
		//System.out.println(buf);
		return buf.toString();
	}
================= fetch public ThrowsPattern parameterizeWith(Map/*name -> resolved type*/ typeVariableM 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java

public ThrowsPattern parameterizeWith(Map/*name -> resolved type*/ typeVariableMap) {
    	ThrowsPattern ret = new ThrowsPattern(
    			required.parameterizeWith(typeVariableMap),
    			forbidden.parameterizeWith(typeVariableMap));
    	ret.copyLocationFrom(this);
    	return ret;
    }
================= fetch public ThrowsPattern resolveBindings(IScope scope, Bindings bindings) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java

public ThrowsPattern resolveBindings(IScope scope, Bindings bindings) {
    	if (this == ANY) return this;
    	required = required.resolveBindings(scope, bindings, false, false);
    	forbidden = forbidden.resolveBindings(scope, bindings, false, false);
    	return this;
    }
================= fetch public TypePattern getType() { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java

public boolean isThis() { return isThis; }
================= fetch public TypePattern parameterizeWith(Map typeVariableMap) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java
/**
	 * return a version of this type pattern with all type variables references replaced
	 * by the corresponding entry in the map.
	 */
public TypePattern parameterizeWith(Map typeVariableMap) {
		UnresolvedType newType = type;
		if (type.isTypeVariableReference()) {
			TypeVariableReference t = (TypeVariableReference) type;
			String key = t.getTypeVariable().getName();
			if (typeVariableMap.containsKey(key)) {
				newType = (UnresolvedType) typeVariableMap.get(key);
			}
		} else if (type.isParameterizedType()) {
			newType = type.parameterize(typeVariableMap);
		}
		ExactTypePattern ret = new ExactTypePattern(newType,includeSubtypes,isVarArgs);
		ret.annotationPattern = annotationPattern.parameterizeWith(typeVariableMap);
		ret.copyLocationFrom(this);
		return ret;
	}
================= fetch public TypePattern parameterizeWith(Map typeVariableMap) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java

public TypePattern parameterizeWith(Map typeVariableMap) {
		NamePattern[] newNamePatterns = new NamePattern[namePatterns.length];
		for(int i=0; i<namePatterns.length;i++) { newNamePatterns[i] = namePatterns[i]; }
		if (newNamePatterns.length == 1) {
			String simpleName = newNamePatterns[0].maybeGetSimpleName();
			if (simpleName != null) {
				if (typeVariableMap.containsKey(simpleName)) {
					String newName = ((ReferenceType)typeVariableMap.get(simpleName)).getName().replace('$','.');
					StringTokenizer strTok = new StringTokenizer(newName,".");
					newNamePatterns = new NamePattern[strTok.countTokens()];
					int index = 0;
					while(strTok.hasMoreTokens()) {
						newNamePatterns[index++] = new NamePattern(strTok.nextToken());
 					}
				}
			}
		}
		WildTypePattern ret = new WildTypePattern(
				newNamePatterns,
				includeSubtypes,
				dim,
				isVarArgs,
				typeParameters.parameterizeWith(typeVariableMap)
			);
		ret.annotationPattern = this.annotationPattern.parameterizeWith(typeVariableMap);
		if (additionalInterfaceBounds == null) {
			ret.additionalInterfaceBounds = null;
		} else {
			ret.additionalInterfaceBounds = new TypePattern[additionalInterfaceBounds.length];
			for (int i = 0; i < additionalInterfaceBounds.length; i++) {
				ret.additionalInterfaceBounds[i] = additionalInterfaceBounds[i].parameterizeWith(typeVariableMap);
			}
		}
		ret.upperBound = upperBound != null ? upperBound.parameterizeWith(typeVariableMap) : null;
		ret.lowerBound = lowerBound != null ? lowerBound.parameterizeWith(typeVariableMap) : null;
		ret.isGeneric = isGeneric;
		ret.knownMatches = knownMatches;
		ret.importedPrefixes = importedPrefixes;
		ret.copyLocationFrom(this);
		return ret;
	}
================= fetch public TypePattern remapAdviceFormals(IntMap bindings) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/BindingTypePattern.java

public TypePattern remapAdviceFormals(IntMap bindings) {			
		if (!bindings.hasKey(formalIndex)) {
			return new ExactTypePattern(type, false, isVarArgs);
		} else {
			int newFormalIndex = bindings.get(formalIndex);
			return new BindingTypePattern(type, newFormalIndex, isVarArgs);
		}
	}
================= fetch public TypePattern resolveBindings(IScope scope, Bindings bindings, 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java

public TypePattern resolveBindings(IScope scope, Bindings bindings, 
    								boolean allowBinding, boolean requireExactType)
    { 
		throw new BCException("trying to re-resolve");
		
	}
================= fetch public TypePattern resolveBindings( 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/AndTypePattern.java

public TypePattern resolveBindings(
		IScope scope,
		Bindings bindings,
		boolean allowBinding, boolean requireExactType)
	{
		if (requireExactType) return notExactType(scope);
		left = left.resolveBindings(scope, bindings, false, false);
		right = right.resolveBindings(scope, bindings, false, false);
		return this;
	}
================= fetch public TypePattern resolveBindings( 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/NotTypePattern.java

public TypePattern resolveBindings(
		IScope scope,
		Bindings bindings,
		boolean allowBinding, boolean requireExactType)
	{
		if (requireExactType) return notExactType(scope);
		negatedPattern = negatedPattern.resolveBindings(scope, bindings, false, false);
		return this;
	}
================= fetch public TypePattern resolveBindings( 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/OrTypePattern.java

public TypePattern resolveBindings(
		IScope scope,
		Bindings bindings,
		boolean allowBinding, boolean requireExactType)
	{
		if (requireExactType) return notExactType(scope);
		left = left.resolveBindings(scope, bindings, false, false);
		right = right.resolveBindings(scope, bindings, false, false);
		return this;
	}
================= fetch public TypePatternList getArguments() { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java

public TypePatternList getArguments() {
        return arguments;
    }
================= fetch public TypePatternList parameterizeWith(Map typeVariableMap) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/TypePatternList.java
/**
     * Return a version of this type pattern list in which all type variable references
     * are replaced by their corresponding entry in the map
     * @param typeVariableMap
     * @return
     */
public TypePatternList parameterizeWith(Map typeVariableMap) {
    	TypePattern[] parameterizedPatterns = new TypePattern[typePatterns.length];
    	for (int i = 0; i < parameterizedPatterns.length; i++) {
			parameterizedPatterns[i] = typePatterns[i].parameterizeWith(typeVariableMap);
		}
    	return new TypePatternList(parameterizedPatterns);
    }
================= fetch public TypeVariableReferenceType( 7b40e7e^:weaver/src/org/aspectj/weaver/TypeVariableReferenceType.java

================= fetch public UnresolvedType parameterize(Map typeBindings) { 7b40e7e^:weaver/src/org/aspectj/weaver/ResolvedType.java
/**
	 * Iff I am a parameterized type, and any of my parameters are type variable
	 * references, return a version with those type parameters replaced in accordance
	 * with the passed bindings.
	 */
public UnresolvedType parameterize(Map typeBindings) {
	  	if (!isParameterizedType()) throw new IllegalStateException("Can't parameterize a type that is not a parameterized type");
    	boolean workToDo = false;
    	for (int i = 0; i < typeParameters.length; i++) {
			if (typeParameters[i].isTypeVariableReference()) {
				workToDo = true;
			}
		}
    	if (!workToDo) {
    		return this;
    	} else {
    		UnresolvedType[] newTypeParams = new UnresolvedType[typeParameters.length];
    		for (int i = 0; i < newTypeParams.length; i++) {
				newTypeParams[i] = typeParameters[i];
				if (newTypeParams[i].isTypeVariableReference()) {
					TypeVariableReferenceType tvrt = (TypeVariableReferenceType) newTypeParams[i];
					UnresolvedType binding = (UnresolvedType) typeBindings.get(tvrt.getTypeVariable().getName());
					if (binding != null) newTypeParams[i] = binding;
				}
			}
    		return TypeFactory.createParameterizedType(getGenericType(), newTypeParams, getWorld());
    	}
    }
================= fetch public boolean munge(BcelClassWeaver weaver) { 7b40e7e^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java

public boolean munge(BcelClassWeaver weaver) {
		ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.MUNGING_WITH, this);
		boolean changed = false;
		boolean worthReporting = true;
		
		if (munger.getKind() == ResolvedTypeMunger.Field) {
			changed = mungeNewField(weaver, (NewFieldTypeMunger)munger);
		} else if (munger.getKind() == ResolvedTypeMunger.Method) {
			changed = mungeNewMethod(weaver, (NewMethodTypeMunger)munger);
        } else if (munger.getKind() == ResolvedTypeMunger.MethodDelegate) {
            changed = mungeMethodDelegate(weaver, (MethodDelegateTypeMunger)munger);
        } else if (munger.getKind() == ResolvedTypeMunger.FieldHost) {
            changed = mungeFieldHost(weaver, (MethodDelegateTypeMunger.FieldHostTypeMunger)munger);
		} else if (munger.getKind() == ResolvedTypeMunger.PerObjectInterface) {
			changed = mungePerObjectInterface(weaver, (PerObjectInterfaceTypeMunger)munger);
			worthReporting = false;
		} else if (munger.getKind() == ResolvedTypeMunger.PerTypeWithinInterface) {
			// PTWIMPL Transform the target type (add the aspect instance field)
			changed = mungePerTypeWithinTransformer(weaver);
			worthReporting = false;
		} else if (munger.getKind() == ResolvedTypeMunger.PrivilegedAccess) {
			changed = mungePrivilegedAccess(weaver, (PrivilegedAccessMunger)munger);
			worthReporting = false;
		} else if (munger.getKind() == ResolvedTypeMunger.Constructor) {
			changed = mungeNewConstructor(weaver, (NewConstructorTypeMunger)munger);
		} else if (munger.getKind() == ResolvedTypeMunger.Parent) {
			changed = mungeNewParent(weaver, (NewParentTypeMunger)munger);
		} else if (munger.getKind() == ResolvedTypeMunger.AnnotationOnType) {
			changed = mungeNewAnnotationOnType(weaver,(AnnotationOnTypeMunger)munger);
			worthReporting=false;
        } else {
			throw new RuntimeException("unimplemented");
		}
		
		if (changed && munger.changesPublicSignature()) {
			WeaverStateInfo info = 
				weaver.getLazyClassGen().getOrCreateWeaverStateInfo(BcelClassWeaver.getReweavableMode());
			info.addConcreteMunger(this);
		}

		if (changed && worthReporting) {
			if (munger.getKind().equals(ResolvedTypeMunger.Parent)) {
		  	  AsmRelationshipProvider.getDefault().addRelationship(weaver.getLazyClassGen().getType(), munger,getAspectType());
			} else {
		  	  AsmRelationshipProvider.getDefault().addRelationship(weaver.getLazyClassGen().getType(), munger,getAspectType());	
			}
		}
		
		// TAG: WeavingMessage
		if (changed && worthReporting  && munger!=null && !weaver.getWorld().getMessageHandler().isIgnoring(IMessage.WEAVEINFO)) {
			String tName = weaver.getLazyClassGen().getType().getSourceLocation().getSourceFile().getName();
			if (tName.indexOf("no debug info available")!=-1) tName = "no debug info available";
			else tName = getShortname(weaver.getLazyClassGen().getType().getSourceLocation().getSourceFile().getPath());
			String fName = getShortname(getAspectType().getSourceLocation().getSourceFile().getPath());
        	if (munger.getKind().equals(ResolvedTypeMunger.Parent)) {
        		// This message could come out of AjLookupEnvironment.addParent if doing parents
        		// munging at compile time only...
        		NewParentTypeMunger parentTM = (NewParentTypeMunger)munger;
        		if (parentTM.getNewParent().isInterface()) {
					weaver.getWorld().getMessageHandler().handleMessage(WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_DECLAREPARENTSIMPLEMENTS,
					new String[]{weaver.getLazyClassGen().getType().getName(),
					tName,parentTM.getNewParent().getName(),fName},
					weaver.getLazyClassGen().getClassName(), getAspectType().getName()));
        		} else {
                    weaver.getWorld().getMessageHandler().handleMessage(
                    WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_DECLAREPARENTSEXTENDS,
                        new String[]{weaver.getLazyClassGen().getType().getName(),
                            tName,parentTM.getNewParent().getName(),fName
                                }));
//                  TAG: WeavingMessage    DECLARE PARENTS: EXTENDS
//                  reportDeclareParentsMessage(WeaveMessage.WEAVEMESSAGE_DECLAREPARENTSEXTENDS,sourceType,parent);
                    
        		}
            } else if (munger.getKind().equals(ResolvedTypeMunger.FieldHost)) {
                ;//hidden
            } else {
        		ResolvedMember declaredSig = munger.getDeclaredSignature();
        		if (declaredSig==null) declaredSig= munger.getSignature();
        		weaver.getWorld().getMessageHandler().handleMessage(WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_ITD,
        		new String[]{weaver.getLazyClassGen().getType().getName(),
        			         tName,munger.getKind().toString().toLowerCase(),
        			         getAspectType().getName(),
        					 fName+":'"+declaredSig+"'"},
							 weaver.getLazyClassGen().getClassName(), getAspectType().getName()));
        	}	
		}
		
		CompilationAndWeavingContext.leavingPhase(tok);
		return changed;
	}
================= fetch public int couldMatchKinds() { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java

public int couldMatchKinds() {
		return Shadow.ALL_SHADOW_KINDS_BITS;
	}
================= fetch public int couldMatchKinds() { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java

public int couldMatchKinds() {
		return Shadow.ALL_SHADOW_KINDS_BITS;  // empty args() matches jps with no args
	}
================= fetch public int couldMatchKinds() { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java

public int couldMatchKinds() {
		return kindSet;
	}
================= fetch public int couldMatchKinds() { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java

public int couldMatchKinds() {
		return isThis ? thisKindSet : targetKindSet;
	}
================= fetch public int couldMatchKinds() { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java

public int couldMatchKinds() {
		return Shadow.ALL_SHADOW_KINDS_BITS;
	}
================= fetch public int couldMatchKinds() { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java

public int couldMatchKinds() {
		return matchedShadowKinds;
	}
================= fetch public int couldMatchKinds() { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java

public int couldMatchKinds() {
		return Shadow.ALL_SHADOW_KINDS_BITS;
	}
================= fetch public int couldMatchKinds() { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java

public int couldMatchKinds() {
		return matchedShadowKinds;
	}
================= fetch public static Declare read(VersionedDataInputStream s, ISourceContext context) t 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/Declare.java

public static Declare read(VersionedDataInputStream s, ISourceContext context) throws IOException {
		byte kind = s.readByte();
		switch (kind) {
			case ERROR_OR_WARNING:
				return DeclareErrorOrWarning.read(s, context);
			case DOMINATES:
				return DeclarePrecedence.read(s, context);
			case PARENTS:
				return DeclareParents.read(s, context);
			case SOFT:
				return DeclareSoft.read(s, context);
			case ANNOTATION:
				return DeclareAnnotation.read(s,context);
			default:
				throw new RuntimeException("unimplemented");
		}
	}
================= fetch public static Pointcut read(VersionedDataInputStream s, ISourceContext context) 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java

public static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {

		CflowPointcut ret = new CflowPointcut(Pointcut.read(s, context), s.readBoolean(), FileUtil.readIntArray(s));
		ret.readLocation(context, s);
		return ret;
	}
================= fetch public static TypeVariable read(VersionedDataInputStream s) throws IOException { 7b40e7e^:weaver/src/org/aspectj/weaver/TypeVariable.java

public static TypeVariable read(VersionedDataInputStream s) throws IOException {
    	
		//if (s.getMajorVersion()>=AjAttribute.WeaverVersionInfo.WEAVER_VERSION_MAJOR_AJ150) {
			
		String name = s.readUTF();
		UnresolvedType ubound = UnresolvedType.read(s);
		int iboundcount = s.readInt();
		UnresolvedType[] ibounds = null;
		if (iboundcount>0) {
			ibounds = new UnresolvedType[iboundcount];
			for (int i=0; i<iboundcount; i++) {
				ibounds[i] = UnresolvedType.read(s);
			}
		}
		
		TypeVariable newVariable = new TypeVariable(name,ubound,ibounds);
		return newVariable;		
    }
================= fetch public void assertState(State state) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/Pointcut.java

public void assertState(State state) {
		if (this.state != state) {
			throw new BCException("expected state: " + state + " got: " + this.state);
		}
	}
================= fetch public void postRead(ResolvedType enclosingType) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java

void postRead(ResolvedType enclosingType) {
		if (returnType != null) {
			returnType.postRead(enclosingType);
		} 
		if (declaringType != null) {
			declaringType.postRead(enclosingType);
		}
		if (parameterTypes != null) {
			parameterTypes.postRead(enclosingType);
		}
	}
================= fetch public void resolve(IScope scope) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/DeclareAnnotation.java

public void resolve(IScope scope) {
		if (!scope.getWorld().isInJava5Mode()) {
			String msg = null;
			if (kind == AT_TYPE) { msg = WeaverMessages.DECLARE_ATTYPE_ONLY_SUPPORTED_AT_JAVA5_LEVEL; }
			else if (kind == AT_METHOD) { msg = WeaverMessages.DECLARE_ATMETHOD_ONLY_SUPPORTED_AT_JAVA5_LEVEL;}
			else if (kind == AT_FIELD) { msg = WeaverMessages.DECLARE_ATFIELD_ONLY_SUPPORTED_AT_JAVA5_LEVEL;}
			else if (kind == AT_CONSTRUCTOR) { msg = WeaverMessages.DECLARE_ATCONS_ONLY_SUPPORTED_AT_JAVA5_LEVEL;}
			scope.message(MessageUtil.error(WeaverMessages.format(msg),
					getSourceLocation()));
			return;
		}
		if (typePattern != null) {
			typePattern = typePattern.resolveBindings(scope,Bindings.NONE,false,false);
		}
		if (sigPattern != null) {
			sigPattern = sigPattern.resolveBindings(scope,Bindings.NONE);
		}
		this.containingAspect = scope.getEnclosingType();
	}
================= fetch public void resolve(IScope scope) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java

public void resolve(IScope scope) {
    	pointcut = pointcut.resolve(scope);  	
    }
================= fetch public void resolve(World world) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/TypePattern.java

public void resolve(World world) {
        annotationPattern.resolve(world);
    }
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/ConcreteCflowPointcut.java

public void resolveBindings(IScope scope, Bindings bindings) {
		throw new RuntimeException("unimplemented");
	}
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/PerCflow.java

public void resolveBindings(IScope scope, Bindings bindings) {
    	// assert bindings == null;
    	entry.resolve(scope);  
    }
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/PerObject.java

public void resolveBindings(IScope scope, Bindings bindings) {
    	// assert bindings == null;
    	entry.resolve(scope);  
    }
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/PerSingleton.java

public void resolveBindings(IScope scope, Bindings bindings) {
    	// this method intentionally left blank
    }
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { 7b40e7e^:weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java

public void resolveBindings(IScope scope, Bindings bindings) {
		if (onTypeSymbolic != null) {
			onType = onTypeSymbolic.resolveExactType(scope, bindings);
			// in this case we've already signalled an error
			if (ResolvedType.isMissing(onType)) return;		
		}
		
		ResolvedType searchType;
		if (onType != null) {
			searchType = scope.getWorld().resolve(onType);
		} else {
			searchType = scope.getEnclosingType();
		}
		if (searchType.isTypeVariableReference()) {
			searchType = ((TypeVariableReference)searchType).getTypeVariable().getUpperBound().resolve(scope.getWorld());
		}
		
		
		arguments.resolveBindings(scope, bindings, true, true);
		//XXX ensure that arguments has no ..'s in it
		
		// check that I refer to a real pointcut declaration and that I match
		
		ResolvedPointcutDefinition pointcutDef = searchType.findPointcut(name);
		// if we're not a static reference, then do a lookup of outers
		if (pointcutDef == null && onType == null) {
			while (true) {
				UnresolvedType declaringType = searchType.getDeclaringType();
				if (declaringType == null) break;
				searchType = declaringType.resolve(scope.getWorld());
				pointcutDef = searchType.findPointcut(name);
				if (pointcutDef != null) {
					// make this a static reference
					onType = searchType;
					break;
				}
			}
		}
		
		if (pointcutDef == null) {
			scope.message(IMessage.ERROR, this, "can't find referenced pointcut " + name);
			return;
		} 
		
		// check visibility
		if (!pointcutDef.isVisible(scope.getEnclosingType())) {
			scope.message(IMessage.ERROR, this, "pointcut declaration " + pointcutDef + " is not accessible");
			return;
		}
		
		if (Modifier.isAbstract(pointcutDef.getModifiers())) {
			if (onType != null  && !onType.isTypeVariableReference()) {
				scope.message(IMessage.ERROR, this, 
								"can't make static reference to abstract pointcut");
				return;
			} else if (!searchType.isAbstract()) {
				scope.message(IMessage.ERROR, this,
								"can't use abstract pointcut in concrete context");
				return;
			}
		}
		
		
		ResolvedType[] parameterTypes = 
			scope.getWorld().resolve(pointcutDef.getParameterTypes());
		
		if (parameterTypes.length != arguments.size()) {
			scope.message(IMessage.ERROR, this, "incompatible number of arguments to pointcut, expected " +
						parameterTypes.length + " found " + arguments.size());
			return;
		}
				
		//if (onType == null) onType = pointcutDef.getDeclaringType();
		if (onType != null) {
			if (onType.isParameterizedType()) {
				// build a type map mapping type variable names in the generic type to
				// the type parameters presented
				typeVariableMap = new HashMap();
				ResolvedType underlyingGenericType = ((ResolvedType) onType).getGenericType();
				TypeVariable[] tVars = underlyingGenericType.getTypeVariables();
				ResolvedType[] typeParams = ((ResolvedType)onType).getResolvedTypeParameters();
				for (int i = 0; i < tVars.length; i++) {
					typeVariableMap.put(tVars[i].getName(),typeParams[i]);
				}
			} else if (onType.isGenericType()) {
				scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_REFERENCE_POINTCUT_IN_RAW_TYPE),
						getSourceLocation()));
			} 
		}
		
		for (int i=0,len=arguments.size(); i < len; i++) {
			TypePattern p = arguments.get(i);
			//we are allowed to bind to pointcuts which use subtypes as this is type safe
			if (typeVariableMap != null) {
				p = p.parameterizeWith(typeVariableMap);
			}
			if (p == TypePattern.NO) {
				scope.message(IMessage.ERROR, this,
								"bad parameter to pointcut reference");
				return;
			}
			
			boolean reportProblem = false;
			if (parameterTypes[i].isTypeVariableReference() && p.getExactType().isTypeVariableReference()) {
				UnresolvedType One = ((TypeVariableReference)parameterTypes[i]).getTypeVariable().getFirstBound();
				UnresolvedType Two = ((TypeVariableReference)p.getExactType()).getTypeVariable().getFirstBound();
				reportProblem = !One.resolve(scope.getWorld()).isAssignableFrom(Two.resolve(scope.getWorld()));
			} else {
				reportProblem = !p.matchesSubtypes(parameterTypes[i]) && 
			    !p.getExactType().equals(UnresolvedType.OBJECT);
			}
			if (reportProblem) {
				scope.message(IMessage.ERROR, p, "incompatible type, expected " +
						parameterTypes[i].getName() + " found " + p +".  Check the type specified in your pointcut");
				return;
			}
		}

	}
================= fetch protected String makeString(String[] names) { 757004c^:weaver/src/org/aspectj/weaver/MemberImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.Member#getParameterNames(org.aspectj.weaver.World)
	 */
public String[] getParameterNames(World world) {
    	return resolve(world).getParameterNames();
    }
================= fetch public Iterator getJoinPointSignatures(World inAWorld) { 757004c^:weaver/src/org/aspectj/weaver/MemberImpl.java
/**
     * All the signatures that a join point with this member as its signature has.
     */
public Iterator getJoinPointSignatures(World inAWorld) {
		if (joinPointSignatures == null) {
			joinPointSignatures = new JoinPointSignatureIterator(this,inAWorld);
		}
		joinPointSignatures.reset();
		return joinPointSignatures;
	}
================= fetch public int getModifiers(World world) { 757004c^:weaver/src/org/aspectj/weaver/MemberImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.Member#getExceptions(org.aspectj.weaver.World)
	 */
public UnresolvedType[] getExceptions(World world) {
        return resolve(world).getExceptions();
    }
================= fetch public boolean accept(File f) { efe6cc7^:ajdoc/src/org/aspectj/tools/ajdoc/Main.java

public static void main(String[] args) {
    	clearState();
    	if (!JavadocRunner.has14ToolsAvailable()) {
    		System.err.println("ajdoc requires a JDK 1.4 or later tools jar - exiting");
    		aborted = true;
    		return;
    	}
    	  
        // STEP 1: parse the command line and do other global setup
        sourcepath.addElement("."); // add the current directory to the classapth
        parseCommandLine(args);  
        rootDir = getRootDir();
        File[] inputFiles      = new File[filenames.size()];
        File[] signatureFiles  = new File[filenames.size()];
        try {
            // create the workingdir if it doesn't exist
            if ( !(new File( outputWorkingDir ).isDirectory()) ) {
                File dir = new File( outputWorkingDir );
                dir.mkdir();
                if (deleteTempFilesOnExit) dir.deleteOnExit();
            }

            for (int i = 0; i < filenames.size(); i++) {
                inputFiles[i]     = new File((String)filenames.elementAt(i));
                //signatureFiles[i] = createSignatureFile(inputFiles[i]);
            }

            // PHASE 0: call ajc
            ajcOptions.addElement("-noExit");
			ajcOptions.addElement("-XjavadocsInModel");  	// TODO: wrong option to force model gen
            ajcOptions.addElement("-d"); 
            ajcOptions.addElement(rootDir.getAbsolutePath());
			String[] argsToCompiler = new String[ajcOptions.size() + inputFiles.length];
            int i = 0;
            for ( ; i < ajcOptions.size(); i++ ) {
                argsToCompiler[i] = (String)ajcOptions.elementAt(i);
            }
            for ( int j = 0; j < inputFiles.length; j++) {
                argsToCompiler[i] = inputFiles[j].getAbsolutePath();
                //System.out.println(">> file to ajc: " + inputFiles[j].getAbsolutePath());
                i++;
            }

//            System.out.println(Arrays.asList(argsToCompiler));
            System.out.println( "> Calling ajc..." );
            CompilerWrapper.main(argsToCompiler);
            if (CompilerWrapper.hasErrors()) {
            	System.out.println(FAIL_MESSAGE);
            	aborted = true;
            	return;
            }
/*
            for (int ii = 0; ii < inputFiles.length; ii++) {
                String tempFP = inputFiles[ii].getAbsolutePath();
                tempFP = tempFP.substring(0, tempFP.length()-4);
                tempFP += "ajsym";
                System.out.println( ">> checking: " + tempFP);
                File tempF = new File(tempFP);
                if ( !tempF.exists() ) System.out.println( ">>> doesn't exist!" );
            }
*/
            for (int ii = 0; ii < filenames.size(); ii++) {
                signatureFiles[ii] = createSignatureFile(inputFiles[ii]);
            }

            // PHASE 1: generate Signature files (Java with DeclIDs and no bodies).
            System.out.println( "> Building signature files..." );
			try{
            StubFileGenerator.doFiles(declIDTable, inputFiles, signatureFiles);
			} catch (DocException d){
				System.err.println(d.getMessage());
	           // d.printStackTrace();
				return;
			}

            // PHASE 2: let Javadoc generate HTML (with DeclIDs)
            System.out.println( "> Calling javadoc..." );
            String[] javadocargs = null;
            if ( packageMode ) {
                int numExtraArgs = 2;
                if (authorStandardDocletSwitch) numExtraArgs++;
                if (versionStandardDocletSwitch) numExtraArgs++;
                javadocargs = new String[numExtraArgs + options.size() + packageList.size() +
                                         fileList.size() ];
                javadocargs[0] = "-sourcepath";
                javadocargs[1] = outputWorkingDir;
                int argIndex = 2;
                if (authorStandardDocletSwitch) {
                    javadocargs[argIndex] = "-author";
                    argIndex++;
                }
                if (versionStandardDocletSwitch) {
                    javadocargs[argIndex] = "-version";
                }
                //javadocargs[1] = getSourcepathAsString();
                for (int k = 0; k < options.size(); k++) {
                    javadocargs[numExtraArgs+k] = (String)options.elementAt(k);
                }
                for (int k = 0; k < packageList.size(); k++) {
                    javadocargs[numExtraArgs+options.size() + k] = (String)packageList.elementAt(k);
                }
                for (int k = 0; k < fileList.size(); k++) {
                    javadocargs[numExtraArgs+options.size() + packageList.size() + k] = (String)fileList.elementAt(k);
                }
            }
            else {
                javadocargs = new String[options.size() + signatureFiles.length];
                for (int k = 0; k < options.size(); k++) {
                    javadocargs[k] = (String)options.elementAt(k);
                }
                for (int k = 0; k < signatureFiles.length; k++) {
                    javadocargs[options.size() + k] = StructureUtil.translateAjPathName(signatureFiles[k].getCanonicalPath());
                }
            }
         
            JavadocRunner.callJavadoc(javadocargs);
            //for ( int o = 0; o < inputFiles.length; o++ ) {
            //    System.out.println( "file: " + inputFiles[o] );
            //}

            // PHASE 3: add AspectDoc specific stuff to the HTML (and remove the DeclIDS).
            /** We start with the known HTML files (the ones that correspond directly to the
            * input files.)  As we go along, we may learn that Javadoc split one .java file
            * into multiple .html files to handle inner classes or local classes.  The html
            * file decorator picks that up.
            */
            System.out.println( "> Decorating html files..." );
            HtmlDecorator.decorateHTMLFromInputFiles(declIDTable,
                                              rootDir,
                                              inputFiles,
                                              docModifier); 
            
            System.out.println( "> Removing generated tags (this may take a while)..." );
            removeDeclIDsFromFile("index-all.html", true);
            removeDeclIDsFromFile("serialized-form.html", true);
            if (packageList.size() > 0) {
	            for (int p = 0; p < packageList.size(); p++) {
	                removeDeclIDsFromFile(((String)packageList.elementAt(p)).replace('.','/') +
	                                       Config.DIR_SEP_CHAR +
	                                       "package-summary.html", true);
	            }
            } else {
				File[] files = rootDir.listFiles();
				if (files == null){
					System.err.println("Destination directory is not a directory: " + rootDir.toString());
					return;
				}
            	files = FileUtil.listFiles(rootDir, new FileFilter() {
            		public boolean accept(File f) {
						return f.getName().equals("package-summary.html");
					}
            	});
            	for (int j = 0; j < files.length; j++) {
            		removeDeclIDsFromFile(files[j].getAbsolutePath(), false);
            	}
            }
            System.out.println( "> Finished." );
        } catch (Throwable e) {
            handleInternalError(e);
            exit(-2);
        }
    }
================= fetch public static void main(String[] args) { efe6cc7^:ajdoc/src/org/aspectj/tools/ajdoc/Main.java

public static void main(String[] args) {
    	clearState();
    	if (!JavadocRunner.has14ToolsAvailable()) {
    		System.err.println("ajdoc requires a JDK 1.4 or later tools jar - exiting");
    		aborted = true;
    		return;
    	}
    	  
        // STEP 1: parse the command line and do other global setup
        sourcepath.addElement("."); // add the current directory to the classapth
        parseCommandLine(args);  
        rootDir = getRootDir();
        File[] inputFiles      = new File[filenames.size()];
        File[] signatureFiles  = new File[filenames.size()];
        try {
            // create the workingdir if it doesn't exist
            if ( !(new File( outputWorkingDir ).isDirectory()) ) {
                File dir = new File( outputWorkingDir );
                dir.mkdir();
                if (deleteTempFilesOnExit) dir.deleteOnExit();
            }

            for (int i = 0; i < filenames.size(); i++) {
                inputFiles[i]     = new File((String)filenames.elementAt(i));
                //signatureFiles[i] = createSignatureFile(inputFiles[i]);
            }

            // PHASE 0: call ajc
            ajcOptions.addElement("-noExit");
			ajcOptions.addElement("-XjavadocsInModel");  	// TODO: wrong option to force model gen
            ajcOptions.addElement("-d"); 
            ajcOptions.addElement(rootDir.getAbsolutePath());
			String[] argsToCompiler = new String[ajcOptions.size() + inputFiles.length];
            int i = 0;
            for ( ; i < ajcOptions.size(); i++ ) {
                argsToCompiler[i] = (String)ajcOptions.elementAt(i);
            }
            for ( int j = 0; j < inputFiles.length; j++) {
                argsToCompiler[i] = inputFiles[j].getAbsolutePath();
                //System.out.println(">> file to ajc: " + inputFiles[j].getAbsolutePath());
                i++;
            }

//            System.out.println(Arrays.asList(argsToCompiler));
            System.out.println( "> Calling ajc..." );
            CompilerWrapper.main(argsToCompiler);
            if (CompilerWrapper.hasErrors()) {
            	System.out.println(FAIL_MESSAGE);
            	aborted = true;
            	return;
            }
/*
            for (int ii = 0; ii < inputFiles.length; ii++) {
                String tempFP = inputFiles[ii].getAbsolutePath();
                tempFP = tempFP.substring(0, tempFP.length()-4);
                tempFP += "ajsym";
                System.out.println( ">> checking: " + tempFP);
                File tempF = new File(tempFP);
                if ( !tempF.exists() ) System.out.println( ">>> doesn't exist!" );
            }
*/
            for (int ii = 0; ii < filenames.size(); ii++) {
                signatureFiles[ii] = createSignatureFile(inputFiles[ii]);
            }

            // PHASE 1: generate Signature files (Java with DeclIDs and no bodies).
            System.out.println( "> Building signature files..." );
			try{
            StubFileGenerator.doFiles(declIDTable, inputFiles, signatureFiles);
			} catch (DocException d){
				System.err.println(d.getMessage());
	           // d.printStackTrace();
				return;
			}

            // PHASE 2: let Javadoc generate HTML (with DeclIDs)
            System.out.println( "> Calling javadoc..." );
            String[] javadocargs = null;
            if ( packageMode ) {
                int numExtraArgs = 2;
                if (authorStandardDocletSwitch) numExtraArgs++;
                if (versionStandardDocletSwitch) numExtraArgs++;
                javadocargs = new String[numExtraArgs + options.size() + packageList.size() +
                                         fileList.size() ];
                javadocargs[0] = "-sourcepath";
                javadocargs[1] = outputWorkingDir;
                int argIndex = 2;
                if (authorStandardDocletSwitch) {
                    javadocargs[argIndex] = "-author";
                    argIndex++;
                }
                if (versionStandardDocletSwitch) {
                    javadocargs[argIndex] = "-version";
                }
                //javadocargs[1] = getSourcepathAsString();
                for (int k = 0; k < options.size(); k++) {
                    javadocargs[numExtraArgs+k] = (String)options.elementAt(k);
                }
                for (int k = 0; k < packageList.size(); k++) {
                    javadocargs[numExtraArgs+options.size() + k] = (String)packageList.elementAt(k);
                }
                for (int k = 0; k < fileList.size(); k++) {
                    javadocargs[numExtraArgs+options.size() + packageList.size() + k] = (String)fileList.elementAt(k);
                }
            }
            else {
                javadocargs = new String[options.size() + signatureFiles.length];
                for (int k = 0; k < options.size(); k++) {
                    javadocargs[k] = (String)options.elementAt(k);
                }
                for (int k = 0; k < signatureFiles.length; k++) {
                    javadocargs[options.size() + k] = StructureUtil.translateAjPathName(signatureFiles[k].getCanonicalPath());
                }
            }
         
            JavadocRunner.callJavadoc(javadocargs);
            //for ( int o = 0; o < inputFiles.length; o++ ) {
            //    System.out.println( "file: " + inputFiles[o] );
            //}

            // PHASE 3: add AspectDoc specific stuff to the HTML (and remove the DeclIDS).
            /** We start with the known HTML files (the ones that correspond directly to the
            * input files.)  As we go along, we may learn that Javadoc split one .java file
            * into multiple .html files to handle inner classes or local classes.  The html
            * file decorator picks that up.
            */
            System.out.println( "> Decorating html files..." );
            HtmlDecorator.decorateHTMLFromInputFiles(declIDTable,
                                              rootDir,
                                              inputFiles,
                                              docModifier); 
            
            System.out.println( "> Removing generated tags (this may take a while)..." );
            removeDeclIDsFromFile("index-all.html", true);
            removeDeclIDsFromFile("serialized-form.html", true);
            if (packageList.size() > 0) {
	            for (int p = 0; p < packageList.size(); p++) {
	                removeDeclIDsFromFile(((String)packageList.elementAt(p)).replace('.','/') +
	                                       Config.DIR_SEP_CHAR +
	                                       "package-summary.html", true);
	            }
            } else {
				File[] files = rootDir.listFiles();
				if (files == null){
					System.err.println("Destination directory is not a directory: " + rootDir.toString());
					return;
				}
            	files = FileUtil.listFiles(rootDir, new FileFilter() {
================= fetch static void parseArgs(List vargs, File currentWorkingDir) { efe6cc7^:ajdoc/src/org/aspectj/tools/ajdoc/Main.java

static void parseArgs(List vargs, File currentWorkingDir) {
        boolean addNextAsOption     = false;
        boolean addNextAsArgFile    = false;
        boolean addNextToAJCOptions = false;
        boolean addNextAsDocDir     = false;
        boolean addNextAsClasspath  = false;
        boolean ignoreArg           = false;  // used for discrepancy betwen class/sourcepath in ajc/javadoc
        boolean addNextAsSourcePath = false;
        if ( vargs.size() == 0 ) {
            displayHelpAndExit( null );
        }
        for (int i = 0; i < vargs.size() ; i++) {
            String arg = (String)vargs.get(i);  
            ignoreArg = false;
            if ( addNextToAJCOptions ) {
                ajcOptions.addElement( arg );
                addNextToAJCOptions = false;
            }
            if ( addNextAsDocDir ) {
                docDir = arg;
                addNextAsDocDir = false;
            }
            if ( addNextAsClasspath ) {
                addNextAsClasspath = false;
            }
            if ( addNextAsSourcePath ) {
                setSourcepath( arg );
                addNextAsSourcePath = false;
                ignoreArg = true;
            }
            if ( arg.startsWith("@") ) {
                expandAtSignFile(arg.substring(1), currentWorkingDir);
            }
================= fetch public void implementOn(Shadow s) { 044542c^:weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java

public void implementOn(Shadow s) {
        hasMatchedAtLeastOnce=true;
        BcelShadow shadow = (BcelShadow) s;
        
        // remove any unnecessary exceptions if the compiler option is set to
        // error or warning and if this piece of advice throws exceptions
        // (bug 129282). This may be expanded to include other compiler warnings
        // at the moment it only deals with 'declared exception is not thrown'
        if (!shadow.getWorld().isIgnoringUnusedDeclaredThrownException() 
        		&& !thrownExceptions.isEmpty()) {
        	Member member = shadow.getSignature();
        	if (member instanceof BcelMethod) {
        		removeUnnecessaryProblems((BcelMethod)member, 
        				((BcelMethod)member).getDeclarationLineNumber());
			} else {
				// we're in a call shadow therefore need the line number of the
				// declared method (which may be in a different type). However,
		        // we want to remove the problems from the CompilationResult
				// held within the current type's EclipseSourceContext so need
				// the enclosing shadow too
				ResolvedMember resolvedMember = shadow.getSignature().resolve(shadow.getWorld());
				if (resolvedMember instanceof BcelMethod 
						&& shadow.getEnclosingShadow() instanceof BcelShadow) { 
					Member enclosingMember = shadow.getEnclosingShadow().getSignature();
					if (enclosingMember instanceof BcelMethod) {
						removeUnnecessaryProblems((BcelMethod)enclosingMember,
								((BcelMethod)resolvedMember).getDeclarationLineNumber());
					}
				}
			}
		}

        if (shadow.getIWorld().isJoinpointSynchronizationEnabled() &&
        		shadow.getKind()==Shadow.MethodExecution &&
        		(s.getSignature().getModifiers() & Modifier.SYNCHRONIZED)!=0) {
			Message m = new Message("advice matching the synchronized method shadow '"+shadow.toString()+
    				"' will be executed outside the lock rather than inside (compiler limitation)",shadow.getSourceLocation(),false,new ISourceLocation[]{getSourceLocation()});
        	  shadow.getIWorld().getMessageHandler().handleMessage(m);
        }
        
        //FIXME AV - see #75442, this logic is not enough so for now comment it out until we fix the bug
//        // callback for perObject AJC MightHaveAspect postMunge (#75442)
//        if (getConcreteAspect() != null
//                && getConcreteAspect().getPerClause() != null
//                && PerClause.PEROBJECT.equals(getConcreteAspect().getPerClause().getKind())) {
//            final PerObject clause;
//            if (getConcreteAspect().getPerClause() instanceof PerFromSuper) {
//                clause = (PerObject)((PerFromSuper) getConcreteAspect().getPerClause()).lookupConcretePerClause(getConcreteAspect());
//            } else {
//                clause = (PerObject) getConcreteAspect().getPerClause();
//            }
//            if (clause.isThis()) {
//                PerObjectInterfaceTypeMunger.registerAsAdvisedBy(s.getThisVar().getType(), getConcreteAspect());
//            } else {
//                PerObjectInterfaceTypeMunger.registerAsAdvisedBy(s.getTargetVar().getType(), getConcreteAspect());
//            }
//        }

        if (getKind() == AdviceKind.Before) {
            shadow.weaveBefore(this);
        } else if (getKind() == AdviceKind.AfterReturning) {
            shadow.weaveAfterReturning(this);
        } else if (getKind() == AdviceKind.AfterThrowing) {
            UnresolvedType catchType = 
                hasExtraParameter()
                ? getExtraParameterType()
                : UnresolvedType.THROWABLE;
            shadow.weaveAfterThrowing(this, catchType);
        } else if (getKind() == AdviceKind.After) {   
            shadow.weaveAfter(this);
        } else if (getKind() == AdviceKind.Around) {
            // Note: under regular LTW the aspect is usually loaded after the first use of any class affecteted by it
            // This means that as long as the aspect has not been thru the LTW, it's woven state is unknown
            // and thus canInline(s) will return false.
            // To force inlining (test), ones can do Class aspect = FQNAspect.class in the clinit of the target class
            // FIXME AV : for AJC compiled @AJ aspect (or any code style aspect), the woven state can never be known
            // if the aspect belongs to a parent classloader. In that case the aspect will never be inlined.
            // It might be dangerous to change that especially for @AJ aspect non compiled with AJC since if those
            // are not weaved (f.e. use of some limiteed LTW etc) then they cannot be prepared for inlining.
            // One solution would be to flag @AJ aspect with an annotation as "prepared" and query that one.
        	if (!canInline(s)) {
        		shadow.weaveAroundClosure(this, hasDynamicTests());
        	} else {
            	shadow.weaveAroundInline(this, hasDynamicTests());
        	}
        } else if (getKind() == AdviceKind.InterInitializer) {
        	 shadow.weaveAfterReturning(this);
        } else if (getKind().isCflow()) {
        	 shadow.weaveCflowEntry(this, getSignature());
        } else if (getKind() == AdviceKind.PerThisEntry) {
        	 shadow.weavePerObjectEntry(this, (BcelVar)shadow.getThisVar());
        } else if (getKind() == AdviceKind.PerTargetEntry) {
        	 shadow.weavePerObjectEntry(this, (BcelVar)shadow.getTargetVar());
        } else if (getKind() == AdviceKind.Softener) {
        	 shadow.weaveSoftener(this, ((ExactTypePattern)exceptionType).getType());
        } else if (getKind() == AdviceKind.PerTypeWithinEntry) {
             // PTWIMPL Entry to ptw is the static initialization of a type that matched the ptw type pattern
       	     shadow.weavePerTypeWithinAspectInitialization(this,shadow.getEnclosingType());
        } else {
            throw new BCException("unimplemented kind: " + getKind());
        }
    }
================= fetch public void testNPEWithLTWPointcutLibraryAndMissingAspectDependency_pr158957 () 044542c^:tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java

public void testNoInvalidAbsoluteTypeNameWarning_pr156904_4() {runTest("ensure no invalidAbsoluteTypeName when do match - 4");}
Progress : [##############--------------------------] 37%================= fetch private File getProjectOutputRelativePath(String p,String filename) { bc2f36f^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java

private File getProjectOutputRelativePath(String p,String filename) {
		File projDir = new File(getWorkingDir(),p);
		return new File(projDir,"bin"+File.separator+filename);
	}
================= fetch public void testBuildingTwoProjectsInTurns() { bc2f36f^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java

public void testBuildingTwoProjectsInTurns() {
		configureBuildStructureModel(true);
		initialiseProject("P1");
		initialiseProject("P2");
		build("P1");
		build("P2");
		build("P1");
		checkWasntFullBuild();
		build("P2");
		checkWasntFullBuild();
	}
================= fetch protected boolean doBuild( f7508cf^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/** @throws AbortException if check for runtime fails */
protected boolean doBuild(
        AjBuildConfig buildConfig, 
        IMessageHandler baseHandler, 
        boolean batch) throws IOException, AbortException {
        boolean ret = true;
    	batchCompile = batch;
    	wasFullBuild = batch;
    	if (baseHandler instanceof ILifecycleAware) {
    		((ILifecycleAware)baseHandler).buildStarting(!batch);
    	}
    	CompilationAndWeavingContext.reset();
    	int phase = batch ? CompilationAndWeavingContext.BATCH_BUILD : CompilationAndWeavingContext.INCREMENTAL_BUILD;
    	ContextToken ct = CompilationAndWeavingContext.enteringPhase(phase ,buildConfig);
        try {
        	if (batch) {
        		this.state = new AjState(this);
        	}
        	
        	this.state.setCouldBeSubsequentIncrementalBuild(this.environmentSupportsIncrementalCompilation);
        	
            boolean canIncremental = state.prepareForNextBuild(buildConfig);
            if (!canIncremental && !batch) { // retry as batch?
             CompilationAndWeavingContext.leavingPhase(ct);
             if (state.listenerDefined()) state.getListener().recordDecision("Falling back to batch compilation");
            	return doBuild(buildConfig, baseHandler, true);
            }
            this.handler = 
                CountingMessageHandler.makeCountingMessageHandler(baseHandler);

            if (DO_RUNTIME_VERSION_CHECK) {
                String check = checkRtJar(buildConfig);
                if (check != null) {
                    if (FAIL_IF_RUNTIME_NOT_FOUND) {
                        MessageUtil.error(handler, check);
                        CompilationAndWeavingContext.leavingPhase(ct);
                        return false;
                    } else {
                        MessageUtil.warn(handler, check);
                    }
                }
            }

            // if (batch) {
                setBuildConfig(buildConfig);
            //}
            if (batch || !AsmManager.attemptIncrementalModelRepairs) {
//                if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) { 
                	setupModel(buildConfig);
//                }
            }
            if (batch) {
                initBcelWorld(handler);
            }
            if (handler.hasErrors()) {
               	CompilationAndWeavingContext.leavingPhase(ct);
                return false;
            }
            
            if (buildConfig.getOutputJar() != null) {
            	 if (!openOutputStream(buildConfig.getOutputJar())) {
                CompilationAndWeavingContext.leavingPhase(ct);
                return false;
            	 }
            }
            
            if (batch) {
                // System.err.println("XXXX batch: " + buildConfig.getFiles());
                if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) {  
                    getWorld().setModel(AsmManager.getDefault().getHierarchy());
                    // in incremental build, only get updated model?
                }
                binarySourcesForTheNextCompile = state.getBinaryFilesToCompile(true);
                performCompilation(buildConfig.getFiles());
                state.clearBinarySourceFiles(); // we don't want these hanging around...
                if (handler.hasErrors()) {
                   	CompilationAndWeavingContext.leavingPhase(ct);
                   	if (AsmManager.isReporting())
    				    AsmManager.getDefault().reportModelInfo("After a failed batch build");
                    return false;
                }

				if (AsmManager.isReporting())
				    AsmManager.getDefault().reportModelInfo("After a batch build");
		
            } else {
// done already?
//                if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) {  
//                    bcelWorld.setModel(StructureModelManager.INSTANCE.getStructureModel());
//                }
                // System.err.println("XXXX start inc ");
                binarySourcesForTheNextCompile = state.getBinaryFilesToCompile(true);
                List files = state.getFilesToCompile(true);
				if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode())
				if (AsmManager.attemptIncrementalModelRepairs)
				    AsmManager.getDefault().processDelta(files,state.getAddedFiles(),state.getDeletedFiles());
                boolean hereWeGoAgain = !(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
                for (int i = 0; (i < 5) && hereWeGoAgain; i++) {
                	   if (state.listenerDefined()) 
                		   state.getListener().recordInformation("Starting incremental compilation loop "+(i+1)+" of possibly 5");
                    // System.err.println("XXXX inc: " + files);
               
                    performCompilation(files);
                    if (handler.hasErrors() || (progressListener!=null && progressListener.isCancelledRequested())) {
                        CompilationAndWeavingContext.leavingPhase(ct);
                        return false;
                    } 
                    
                    if (state.requiresFullBatchBuild()) {
                    	if (state.listenerDefined()) 
                 		   state.getListener().recordInformation(" Dropping back to full build");
                    	return batchBuild(buildConfig, baseHandler);
                    }
                    
                    binarySourcesForTheNextCompile = state.getBinaryFilesToCompile(false);
                    files = state.getFilesToCompile(false);
                    hereWeGoAgain = !(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
                    // TODO Andy - Needs some thought here...
                    // I think here we might want to pass empty addedFiles/deletedFiles as they were
                    // dealt with on the first call to processDelta - we are going through this loop
                    // again because in compiling something we found something else we needed to
                    // rebuild.  But what case causes this?
                    if (hereWeGoAgain) {
					  if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode())
					    if (AsmManager.attemptIncrementalModelRepairs)
						  AsmManager.getDefault().processDelta(files,state.getAddedFiles(),state.getDeletedFiles());
                    }
                }
                if (!files.isEmpty()) {
                   	CompilationAndWeavingContext.leavingPhase(ct);
                    return batchBuild(buildConfig, baseHandler);
                } else {                
                	if (AsmManager.isReporting()) 
			    	    AsmManager.getDefault().reportModelInfo("After an incremental build");
                }
            }

            // XXX not in Mik's incremental
            if (buildConfig.isEmacsSymMode()) {
                new org.aspectj.ajdt.internal.core.builder.EmacsStructureModelManager().externalizeModel();
            }
            
            // for bug 113554: support ajsym file generation for command line builds
            if (buildConfig.isGenerateCrossRefsMode()) {
                String configFileProxy = buildConfig.getOutputDir().getAbsolutePath() 
            		+ File.separator 
            		+ CROSSREFS_FILE_NAME; 
            	AsmManager.getDefault().writeStructureModel(configFileProxy);
            }
            
            // have to tell state we succeeded or next is not incremental
            state.successfulCompile(buildConfig,batch);

            copyResourcesToDestination();
            
            if (buildConfig.getOutxmlName() != null) {
            	writeOutxmlFile();
            }
            
            /*boolean weaved = *///weaveAndGenerateClassFiles();
            // if not weaved, then no-op build, no model changes
            // but always returns true
            // XXX weaved not in Mik's incremental
            if (buildConfig.isGenerateModelMode()) {
                AsmManager.getDefault().fireModelUpdated();  
            }
           	CompilationAndWeavingContext.leavingPhase(ct);
            
        } finally {
        	if (baseHandler instanceof ILifecycleAware) {
        		((ILifecycleAware)baseHandler).buildFinished(!batch);
        	}
        	if (zos != null) {
        		closeOutputStream(buildConfig.getOutputJar());
        	}
            ret = !handler.hasErrors();
            if (getBcelWorld()!=null) getBcelWorld().tidyUp();
            if (getWeaver()!=null) getWeaver().tidyUp();
            // bug 59895, don't release reference to handler as may be needed by a nested call
            //handler = null;
        }
        return ret;
    }
================= fetch private void addChildNodes(IProgramElement parent, Collection children) { d532892^:weaver/src/org/aspectj/weaver/ShadowMunger.java

private void addChildNodes(IProgramElement parent, Collection children) {
    	for (Iterator iter = children.iterator(); iter.hasNext();) {
			Object element = (Object) iter.next();
			if (element instanceof DeclareErrorOrWarning) {
				DeclareErrorOrWarning decl = (DeclareErrorOrWarning)element;
			   	IProgramElement deowNode = new ProgramElement(
		    			decl.isError() ? "declare error" : "declare warning",
		    			decl.isError() ? IProgramElement.Kind.DECLARE_ERROR : IProgramElement.Kind.DECLARE_WARNING,
		    			getBinarySourceLocation(decl.getSourceLocation()),
		    			decl.getDeclaringType().getModifiers(),
		    			null,null); 
		    	deowNode.setDetails("\"" + AsmRelationshipUtils.genDeclareMessage(decl.getMessage()) + "\"");
		    	parent.addChild(deowNode);
			} else if (element instanceof BcelAdvice) {
				BcelAdvice advice = (BcelAdvice)element;
				IProgramElement adviceNode = new ProgramElement(
		    			advice.kind.getName(),
		    			IProgramElement.Kind.ADVICE,
		    			getBinarySourceLocation(advice.getSourceLocation()),
		    			advice.signature.getModifiers(),null,Collections.EMPTY_LIST);
		    	adviceNode.setDetails(AsmRelationshipUtils.genPointcutDetails(advice.getPointcut()));
		    	parent.addChild(adviceNode);
			}
		}
    }
================= fetch public DeclareErrorOrWarning(boolean isError, Pointcut pointcut, String message) d532892^:weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java

================= fetch public String getNameSuffix() { d532892^:weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java

public String getNameSuffix() {
		return "eow";
	}
================= fetch public void testIPEsWithSameNameHaveUniqueHandles_set() { d532892^:tests/src/org/aspectj/systemtest/ajc153/JDTLikeHandleProviderTests.java

public void testIPEsWithSameNameHaveUniqueHandles_set() {
		runTest("ipes with same name have unique handles - set");
		IHierarchy top = AsmManager.getDefault().getHierarchy();
		String handle1 = "*Set.aj[C1~method?field-set(int C1.x)";
		assertNotNull("expected to find node with handle " + handle1 
				+ ", but did not",top.getElement(handle1));

		String handle2 = "*Set.aj[C1~method?field-set(int C1.x)!2";
		assertNotNull("expected to find node with handle " + handle2 
				+ ", but did not",top.getElement(handle2));
	}
================= fetch private TypePattern resolveBindingsFromFullyQualifiedTypeName(String fullyQualif 782ade2^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java

private TypePattern resolveBindingsFromFullyQualifiedTypeName(String fullyQualifiedName, IScope scope, Bindings bindings, 
			boolean allowBinding, boolean requireExactType) {
		String originalName = fullyQualifiedName;
		ResolvedType resolvedTypeInTheWorld = null;
		UnresolvedType type;
		
		//System.out.println("resolve: " + cleanName);
		//??? this loop has too many inefficiencies to count
		resolvedTypeInTheWorld = lookupTypeInWorld(scope.getWorld(), fullyQualifiedName);
		if (resolvedTypeInTheWorld.isGenericWildcard()) {
			type = resolvedTypeInTheWorld;
		} else {
			type = lookupTypeInScope(scope, fullyQualifiedName, this);
		}
		if ((type instanceof ResolvedType) && ((ResolvedType)type).isMissing()) {
			return resolveBindingsForMissingType(resolvedTypeInTheWorld, originalName, scope, bindings, allowBinding, requireExactType);
		} else {
			return resolveBindingsForExactType(scope,type,fullyQualifiedName,requireExactType);
		}
	}
================= fetch private UnresolvedType lookupTypeInScope(IScope scope, String typeName, IHasPosi 782ade2^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java

private UnresolvedType lookupTypeInScope(IScope scope, String typeName, IHasPosition location) {
		UnresolvedType type = null;
		while (ResolvedType.isMissing(type = scope.lookupType(typeName, location))) {
			int lastDot = typeName.lastIndexOf('.');
			if (lastDot == -1) break;
			typeName = typeName.substring(0, lastDot) + '$' + typeName.substring(lastDot+1);
		}
		return type;
	}
================= fetch public void testNPEWithCustomAgent_pr158005() { 782ade2^:tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java

public void testNPEWithCustomAgent_pr158005() {
	  runTest("NPE with custom agent");
  }
================= fetch protected File getSpecFile() { 7b831ff^:tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.java

protected File getSpecFile() {
    return new File("../tests/src/org/aspectj/systemtest/ajc150/ltw/ltw.xml");
  }
================= fetch public void startElement(String uri, String localName, String qName, Attributes 7b831ff^:loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java

public void startElement(String uri, String localName, String qName, Attributes attributes) throws SAXException {
        if (ASPECT_ELEMENT.equals(qName)) {
            String name = attributes.getValue(NAME_ATTRIBUTE);
            if (!isNull(name)) {
                m_definition.getAspectClassNames().add(name);
            }
        } else if (WEAVER_ELEMENT.equals(qName)) {
            String options = attributes.getValue(OPTIONS_ATTRIBUTE);
            if (!isNull(options)) {
                m_definition.appendWeaverOptions(options);
            }
            m_inWeaver = true;
        } else if (CONCRETE_ASPECT_ELEMENT.equals(qName)) {
            String name = attributes.getValue(NAME_ATTRIBUTE);
            String extend = attributes.getValue(EXTEND_ATTRIBUTE);
            String precedence = attributes.getValue(PRECEDENCE_ATTRIBUTE);
            if (!isNull(name)) {
                if (isNull(precedence) && !isNull(extend)) {//if no precedence, then extends must be there
                    m_lastConcreteAspect = new Definition.ConcreteAspect(name, extend);
                } else if (!isNull(precedence)) {
                    // wether a pure precedence def, or an extendsANDprecedence def.
                    m_lastConcreteAspect = new Definition.ConcreteAspect(name, extend, precedence);
                }
                m_definition.getConcreteAspects().add(m_lastConcreteAspect);
            }
        } else if (POINTCUT_ELEMENT.equals(qName) && m_lastConcreteAspect != null) {
            String name = attributes.getValue(NAME_ATTRIBUTE);
            String expression = attributes.getValue(EXPRESSION_ATTRIBUTE);
            if (!isNull(name) && !isNull(expression)) {
                m_lastConcreteAspect.pointcuts.add(new Definition.Pointcut(name, replaceXmlAnd(expression)));
            }
        } else if (ASPECTJ_ELEMENT.equals(qName)) {
            if (m_inAspectJ) {
                throw new SAXException("Found nested <aspectj> element");
            }
            m_inAspectJ = true;
        } else if (ASPECTS_ELEMENT.equals(qName)) {
            m_inAspects = true;
        } else if (INCLUDE_ELEMENT.equals(qName) && m_inWeaver) {
            String typePattern = attributes.getValue(WITHIN_ATTRIBUTE);
            if (!isNull(typePattern)) {
                m_definition.getIncludePatterns().add(typePattern);
            }
        } else if (EXCLUDE_ELEMENT.equals(qName) && m_inWeaver) {
            String typePattern = attributes.getValue(WITHIN_ATTRIBUTE);
            if (!isNull(typePattern)) {
                m_definition.getExcludePatterns().add(typePattern);
            }
        } else if (DUMP_ELEMENT.equals(qName) && m_inWeaver) {
            String typePattern = attributes.getValue(WITHIN_ATTRIBUTE);
            if (!isNull(typePattern)) {
                m_definition.getDumpPatterns().add(typePattern);
            }
            String beforeAndAfter = attributes.getValue(DUMP_BEFOREANDAFTER_ATTRIBUTE);
            if (isTrue(beforeAndAfter)) {
            	m_definition.setDumpBefore(true);
            }
        } else if (EXCLUDE_ELEMENT.equals(qName) && m_inAspects) {
            String typePattern = attributes.getValue(WITHIN_ATTRIBUTE);
            if (!isNull(typePattern)) {
                m_definition.getAspectExcludePatterns().add(typePattern);
            }
        } else if (INCLUDE_ELEMENT.equals(qName) && m_inAspects) {
            String typePattern = attributes.getValue(WITHIN_ATTRIBUTE);
            if (!isNull(typePattern)) {
                m_definition.getAspectIncludePatterns().add(typePattern);
            }
        } else {
            throw new SAXException("Unknown element while parsing <aspectj> element: " + qName);
        }
        super.startElement(uri, localName, qName, attributes);
    }
Progress : [###############-------------------------] 38%================= fetch public boolean hasMatchedSomething() { cd9fd11^:weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java

public boolean hasMatchedSomething() {
		return hasMatchedAtLeastOnce;
	}
================= fetch public boolean replaceWith(CrosscuttingMembers other,boolean careAboutShadowMung cd9fd11^:weaver/src/org/aspectj/weaver/CrosscuttingMembers.java
/**
	 * Updates the records if something has changed. This is called at most twice, firstly
	 * whilst collecting ITDs and declares. At this point the CrosscuttingMembers we're 
	 * comparing ourselves with doesn't know about shadowmungers. Therefore a straight comparison
	 * with the existing list of shadowmungers would return that something has changed
	 * even though it might not have, so in this first round we ignore the shadowMungers. 
	 * The second time this is called is whilst we're preparing to weave. At this point 
	 * we know everything in the system and so we're able to compare the shadowMunger list.
	 * (see bug 129163)
	 * 
	 * @param other
	 * @param careAboutShadowMungers
	 * @return true if something has changed since the last time this method was
	 *         called, false otherwise
	 */
public boolean replaceWith(CrosscuttingMembers other,boolean careAboutShadowMungers) {
		boolean changed = false;
		
		if (careAboutShadowMungers) {
			if (perClause == null || !perClause.equals(other.perClause)) {
				changed = true;
				perClause = other.perClause;
			}
		}
		
		//XXX all of the below should be set equality rather than list equality
		//System.err.println("old: " + shadowMungers + " new: " + other.shadowMungers);
		
  	    if (careAboutShadowMungers) {
		    // bug 129163: use set equality rather than list equality 
			Set theseShadowMungers = new HashSet();
			Set theseInlinedAroundMungers = new HashSet();
			for (Iterator iter = shadowMungers.iterator(); iter
					.hasNext();) {
				ShadowMunger munger = (ShadowMunger) iter.next();
				if (munger instanceof Advice) {
					Advice adviceMunger = (Advice)munger;
					// bug 154054: if we're around advice that has been inlined
					// then we need to do more checking than existing equals
					// methods allow
					if (!world.isXnoInline() && adviceMunger.getKind().equals(AdviceKind.Around)) {
						theseInlinedAroundMungers.add(adviceMunger);
					} else {
						theseShadowMungers.add(adviceMunger);
					}
				} else {
					theseShadowMungers.add(munger);
				}
			}
			Set tempSet = new HashSet();
			tempSet.addAll(other.shadowMungers);
			Set otherShadowMungers = new HashSet();
			Set otherInlinedAroundMungers = new HashSet();
			for (Iterator iter = tempSet.iterator(); iter.hasNext();) {
				ShadowMunger munger = (ShadowMunger) iter.next();
				if (munger instanceof Advice) {
					Advice adviceMunger = (Advice)munger;
					// bug 154054: if we're around advice that has been inlined
					// then we need to do more checking than existing equals
					// methods allow
					if (!world.isXnoInline() && adviceMunger.getKind().equals(AdviceKind.Around)) {
						otherInlinedAroundMungers.add(rewritePointcutInMunger(adviceMunger));
					} else {
						otherShadowMungers.add(rewritePointcutInMunger(adviceMunger));
					}
				} else {
					otherShadowMungers.add(rewritePointcutInMunger(munger));
				}
			}
			if (!theseShadowMungers.equals(otherShadowMungers)) {
				changed = true;
			}
			if (!equivalent(theseInlinedAroundMungers,otherInlinedAroundMungers)) {
				changed = true;
			}
			
			// replace the existing list of shadowmungers with the 
			// new ones in case anything like the sourcelocation has
			// changed, however, don't want this flagged as a change
			// which will force a full build - bug 134541
			shadowMungers = other.shadowMungers;
  	    }
  	    
		// bug 129163: use set equality rather than list equality and
  	    // if we dont care about shadow mungers then ignore those 
  	    // typeMungers which are created to help with the implementation 
  	    // of shadowMungers
		Set theseTypeMungers = new HashSet();
		Set otherTypeMungers = new HashSet();
		if (!careAboutShadowMungers) {
			for (Iterator iter = typeMungers.iterator(); iter.hasNext();) {
				Object o = iter.next();
				if (o instanceof BcelTypeMunger) {
					BcelTypeMunger typeMunger = (BcelTypeMunger) o;
					if (!typeMunger.existsToSupportShadowMunging()) {
						theseTypeMungers.add(typeMunger);
					}				
				} else {
					theseTypeMungers.add(o);
				}
			}
			
			for (Iterator iter = other.typeMungers.iterator(); iter.hasNext();) {
				Object o = iter.next();
				if (o instanceof BcelTypeMunger) {
					BcelTypeMunger typeMunger = (BcelTypeMunger) o;
					if (!typeMunger.existsToSupportShadowMunging()) {
						otherTypeMungers.add(typeMunger);
					}
				} else {
					otherTypeMungers.add(o);
				}
			}
		} else {
			theseTypeMungers.addAll(typeMungers);
			otherTypeMungers.addAll(other.typeMungers);
		}
  	    
  	    // initial go at equivalence logic rather than set compare (see pr133532)
//		if (theseTypeMungers.size()!=otherTypeMungers.size()) {
//			changed = true;
//			typeMungers = other.typeMungers;
//		} else {
//			boolean foundInequality=false;
//			for (Iterator iter = theseTypeMungers.iterator(); iter.hasNext() && !foundInequality;) {
//				Object thisOne = (Object) iter.next();
//				boolean foundInOtherSet = false;
//				for (Iterator iterator = otherTypeMungers.iterator(); iterator.hasNext();) {
//					Object otherOne = (Object) iterator.next();
//					if (thisOne instanceof ConcreteTypeMunger && otherOne instanceof ConcreteTypeMunger) {
//						if (((ConcreteTypeMunger)thisOne).equivalentTo(otherOne)) {
//							foundInOtherSet=true;
//						} else if (thisOne.equals(otherOne)) {
//							foundInOtherSet=true;
//						}
//					} else {
//						if (thisOne.equals(otherOne)) {
//							foundInOtherSet=true;
//						} 
//					}
//				}
//				if (!foundInOtherSet) foundInequality=true;
//			}
//			if (foundInequality) {
//				changed = true;
//				typeMungers = other.typeMungers;
////			} else {
////				typeMungers = other.typeMungers;
//			}
//		}
  	    if (!theseTypeMungers.equals(otherTypeMungers)) {
			changed = true;
			typeMungers = other.typeMungers;
		}

        if (!lateTypeMungers.equals(other.lateTypeMungers)) {
            changed = true;
            lateTypeMungers = other.lateTypeMungers;
        }

		if (!declareDominates.equals(other.declareDominates)) {
			changed = true;
			declareDominates = other.declareDominates;
		}
		
		if (!declareParents.equals(other.declareParents)) {
			changed = true;
			declareParents = other.declareParents;
		}
		
		if (!declareSofts.equals(other.declareSofts)) {
			changed = true;
			declareSofts = other.declareSofts;
		}
		
		// DECAT for when attempting to replace an aspect
		if (!declareAnnotationsOnType.equals(other.declareAnnotationsOnType)) {
			changed = true;
			declareAnnotationsOnType = other.declareAnnotationsOnType;
		}
		
		if (!declareAnnotationsOnField.equals(other.declareAnnotationsOnField)) {
			changed = true;
			declareAnnotationsOnField = other.declareAnnotationsOnField;
		}
		
		if (!declareAnnotationsOnMethods.equals(other.declareAnnotationsOnMethods)) {
			changed = true;
			declareAnnotationsOnMethods = other.declareAnnotationsOnMethods;
		}
		
		return changed;
	}
================= fetch public void testShouldFullBuildOnExceptionChange_pr154054() { cd9fd11^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
/**
	 * Retrieve program elements related to this one regardless of the relationship.  A JUnit assertion is
	 * made that the number that the 'expected' number are found.
	 * 
	 * @param programElement Program element whose related elements are to be found
	 * @param expected the number of expected related elements
	 */
private List/*IProgramElement*/ getRelatedElements(IProgramElement programElement,int expected) {
		List relatedElements = getRelatedElements(programElement);
		StringBuffer debugString = new StringBuffer();
		if (relatedElements!=null) {
			for (Iterator iter = relatedElements.iterator(); iter.hasNext();) {	
				String element = (String) iter.next();
				debugString.append(AsmManager.getDefault().getHierarchy().findElementForHandle(element).toLabelString()).append("\n");
			}
		}
		assertTrue("Should be "+expected+" element"+(expected>1?"s":"")+" related to this one '"+programElement+
				"' but found :\n "+debugString,relatedElements!=null && relatedElements.size()==1);
		return relatedElements;
	}
================= fetch protected UnresolvedType parameterize(UnresolvedType aType, Map typeVariableMap, ea4ff8a^:weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java

protected UnresolvedType parameterize(UnresolvedType aType, Map typeVariableMap, boolean inParameterizedType) {
		if (aType instanceof TypeVariableReference) {
			String variableName = ((TypeVariableReference)aType).getTypeVariable().getName();
			if (!typeVariableMap.containsKey(variableName)) {
				return aType; // if the type variable comes from the method (and not the type) thats OK
			}
			return (UnresolvedType) typeVariableMap.get(variableName);
		} else if (aType.isParameterizedType()) {
			if (inParameterizedType) {
				return aType.parameterize(typeVariableMap);
			} else {
				return aType.getRawType();
			}
		} else if (aType.isArray()) {
			// The component type might be a type variable (pr150095)
			int dims = 1;
			String sig = aType.getSignature();
			while (sig.charAt(dims)=='[') dims++;
			UnresolvedType componentSig = UnresolvedType.forSignature(sig.substring(dims));
			UnresolvedType arrayType = ResolvedType.makeArray(parameterize(componentSig,typeVariableMap,inParameterizedType),dims);
			return arrayType;
		}
		return aType;		
	}
================= fetch public ResolvedMemberImpl parameterizedWith(UnresolvedType[] typeParameters,Reso ea4ff8a^:weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java
/**
	 * Return a resolvedmember in which all the type variables in the signature
	 * have been replaced with the given bindings.
	 * The 'isParameterized' flag tells us whether we are creating a raw type
	 * version or not.  if (isParameterized) then List<T> will turn into 
	 * List<String> (for example) - if (!isParameterized) then List<T> will turn
	 * into List.
	 */
public ResolvedMemberImpl parameterizedWith(UnresolvedType[] typeParameters,ResolvedType newDeclaringType, boolean isParameterized,List aliases) {
		if (//isParameterized &&  <-- might need this bit...
				!getDeclaringType().isGenericType()) {
			throw new IllegalStateException("Can't ask to parameterize a member of non-generic type: "+getDeclaringType()+"  kind("+getDeclaringType().typeKind+")");
		}
		TypeVariable[] typeVariables = getDeclaringType().getTypeVariables();
		if (isParameterized && (typeVariables.length != typeParameters.length)) {
			throw new IllegalStateException("Wrong number of type parameters supplied");
		}
		Map typeMap = new HashMap();
		boolean typeParametersSupplied = typeParameters!=null && typeParameters.length>0;
		if (typeVariables!=null) {
			// If no 'replacements' were supplied in the typeParameters array then collapse
			// type variables to their first bound.
			for (int i = 0; i < typeVariables.length; i++) {
				UnresolvedType ut = (!typeParametersSupplied?typeVariables[i].getFirstBound():typeParameters[i]);
				typeMap.put(typeVariables[i].getName(),ut);
			}
		}
		// For ITDs on generic types that use type variables from the target type, the aliases
		// record the alternative names used throughout the ITD expression that must map to
		// the same value as the type variables real name.
		if (aliases!=null) {
			int posn = 0;
			for (Iterator iter = aliases.iterator(); iter.hasNext();) {
				String typeVariableAlias = (String) iter.next();
				typeMap.put(typeVariableAlias,(!typeParametersSupplied?typeVariables[posn].getFirstBound():typeParameters[posn]));
				posn++;
			}
		}
		
		UnresolvedType parameterizedReturnType = parameterize(getGenericReturnType(),typeMap,isParameterized);
		UnresolvedType[] parameterizedParameterTypes = new UnresolvedType[getGenericParameterTypes().length];
		for (int i = 0; i < parameterizedParameterTypes.length; i++) {
			parameterizedParameterTypes[i] = 
				parameterize(getGenericParameterTypes()[i], typeMap,isParameterized);
		}
		ResolvedMemberImpl ret = new ResolvedMemberImpl(
					getKind(),
					newDeclaringType,
					getModifiers(),
					parameterizedReturnType,
					getName(),
					parameterizedParameterTypes,
					getExceptions(),
					this
				);
		ret.setTypeVariables(getTypeVariables());
		ret.setSourceContext(getSourceContext());
		ret.setPosition(getStart(),getEnd());
		ret.setParameterNames(getParameterNames());
		return ret;
	}
================= fetch protected String genSourceSignature(FieldDeclaration fieldDeclaration) { fc39df1^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java
/**
	 * Doesn't print qualified allocation expressions.
	 */
protected String genSourceSignature(FieldDeclaration fieldDeclaration) {	
		StringBuffer output = new StringBuffer();
		if (fieldDeclaration.type == null) { // This is an enum value
			output.append(fieldDeclaration.name); // the "," or ";" has to be put on by whatever uses the sourceSignature
			return output.toString();
		} else {
			FieldDeclaration.printModifiers(fieldDeclaration.modifiers, output);
			fieldDeclaration.type.print(0, output).append(' ').append(fieldDeclaration.name);
		}
		
		if (fieldDeclaration.initialization != null
			&& !(fieldDeclaration.initialization instanceof QualifiedAllocationExpression)) {
			output.append(" = "); //$NON-NLS-1$
			if (fieldDeclaration.initialization instanceof ExtendedStringLiteral) {
				output.append("\"<extended string literal>\"");
			} else {
				fieldDeclaration.initialization.printExpression(0, output);
			}
		}
		
		output.append(';');
		return output.toString();
	}
================= fetch protected String generateJavadocComment(ASTNode astNode) { fc39df1^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java
/**
	 * Checks if comments should be added to the model before generating.
	 */
protected String generateJavadocComment(ASTNode astNode) {
		if (buildConfig != null && !buildConfig.isGenerateJavadocsInModelMode()) return null;
		
		StringBuffer sb = new StringBuffer(); // !!! specify length?
		boolean completed = false;
		int startIndex = -1;
		if (astNode instanceof MethodDeclaration) {
			startIndex = ((MethodDeclaration)astNode).declarationSourceStart;
		} else if (astNode instanceof FieldDeclaration) {
			startIndex = ((FieldDeclaration)astNode).declarationSourceStart;
		} else if (astNode instanceof TypeDeclaration) {
			startIndex = ((TypeDeclaration)astNode).declarationSourceStart;
		} 
		
		if (startIndex == -1) {
			return null;
		} else if (currCompilationResult.compilationUnit.getContents()[startIndex] == '/'  // look for /**
			&& currCompilationResult.compilationUnit.getContents()[startIndex+1] == '*'
			&& currCompilationResult.compilationUnit.getContents()[startIndex+2] == '*') {
			
			for (int i = startIndex; i < astNode.sourceStart && !completed; i++) {
				char curr = currCompilationResult.compilationUnit.getContents()[i];
				if (curr == '/' && sb.length() > 2 && sb.charAt(sb.length()-1) == '*') completed = true; // found */
				sb.append(currCompilationResult.compilationUnit.getContents()[i]);
			} 
			return sb.toString();
		} else {
			return null;
		}
		
	}
================= fetch public void testDeclareSoftAndInnerClasses_pr125981() { fc39df1^:tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java

public void testDeclareSoftAndInnerClasses_pr125981() {
	  runTest("declare soft and inner classes");
  }
================= fetch private ResolvedPointcutDefinition makeResolvedPointcutDefinition(AbstractMethod e56a69a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java

public ResolvedMember[] getDeclaredPointcuts() {
		if (declaredPointcuts == null) fillDeclaredMembers();
		return declaredPointcuts;
	}
================= fetch public boolean isAnnotationStyleAspect() { e56a69a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java

public boolean isAnnotationStyleAspect() {
        if (declaration.annotations == null) {
            return false;
        }
        ResolvedType[] annotations = getAnnotationTypes();
        for (int i = 0; i < annotations.length; i++) {
            if ("org.aspectj.lang.annotation.Aspect".equals(annotations[i].getName())) {
                return true;
            }
        }
        return false;
    }
================= fetch private static String makeDeclaredSignature(ResolvedType aGenericType, Unresolve 70ae0f8^:weaver/src/org/aspectj/weaver/ReferenceType.java

private static String makeDeclaredSignature(ResolvedType aGenericType, UnresolvedType[] someParameters) {	
		StringBuffer ret = new StringBuffer();
		String rawSig = aGenericType.getErasureSignature();
		ret.append(rawSig.substring(0,rawSig.length()-1));
		ret.append("<");
		for (int i = 0; i < someParameters.length; i++) {
			ret.append(someParameters[i].getSignature());			
		}
		ret.append(">;");
		return ret.toString();
	}
================= fetch public Constructor getConstructor() { 090de7e^:runtime/src/org/aspectj/runtime/reflect/ConstructorSignatureImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.runtime.reflect.MemberSignatureImpl#createAccessibleObject()
	 */
public Constructor getConstructor() {
		if (constructor == null) {
			try {
				constructor = declaringType.getDeclaredConstructor(getParameterTypes());
			} catch (Exception ex) {
				; // nothing we can do, caller will see null
			}
		}
		return constructor;
	}
================= fetch public Constructor getInitializer() { 090de7e^:runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.runtime.reflect.MemberSignatureImpl#createAccessibleObject()
	 */
public Constructor getInitializer() {
		if (constructor == null) {
			try {
				constructor = declaringType.getDeclaredConstructor(getParameterTypes());
			} catch (Exception ex) {
				; // nothing we can do, caller will see null
			}
		}
		return constructor;
	}
================= fetch public Field getField() { 090de7e^:runtime/src/org/aspectj/runtime/reflect/FieldSignatureImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.runtime.reflect.MemberSignatureImpl#createAccessibleObject()
	 */
public Field getField() {
		if (field == null) {
			try {
				field = declaringType.getDeclaredField(getName());
			} catch (Exception ex) {
				; // nothing we can do, caller will see null
			}
		}
		return field;
	}
================= fetch public void testReweavableAspectNotRegistered_pr129525 () { 090de7e^:tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java

public void testReweavableAspectNotRegistered_pr129525 () {
	  runTest("reweavableAspectNotRegistered error");
  }
Progress : [###############-------------------------] 39%================= fetch public String getClassLoaderName() { 14e8b7d^:loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java
/**
	 * @return classname@hashcode
	 */
public String getClassLoaderName() {
    	return ((loader!=null)?loader.getClass().getName()+"@"+Integer.toHexString(loader.hashCode()):"null");
	}
================= fetch public String getClassLoaderName() { 14e8b7d^:weaver/src/org/aspectj/weaver/tools/AbstractTrace.java

================= fetch protected String formatArgs(Object[] args) { 6be7097^:weaver/src/org/aspectj/weaver/tools/AbstractTrace.java
/** 
	 * Format arguments into a comma separated list
	 * 
	 * @param names array of argument names
	 * @param args array of arguments
	 * @return the formated list
	 */
protected String formatArgs(Object[] args) {
		StringBuffer sb = new StringBuffer();
		
		for (int i = 0; i < args.length; i++) {
			sb.append(formatObj(args[i]));
			if (i < args.length-1) sb.append(", ");
		}
		
		return sb.toString();
	}
================= fetch public String getClassLoaderName() { 6be7097^:loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java
/**
	 * @return classname@hashcode
	 */
public String getClassLoaderName() {
    	return ((loader!=null)?loader.getClass().getName()+"@"+loader.hashCode():"null");
	}
================= fetch public String getClassLoaderName() { 6be7097^:weaver/src/org/aspectj/weaver/tools/AbstractTrace.java

================= fetch public String toTraceString() { 6be7097^:weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.java

public void testEnterWithThisAndTraceable () {
		Object arg1 = new Traceable() {

			public String toTraceString() {
				return "Traceable";
			}
			
		};
		trace.enter("testEnterWithThisAndArgs",this,new Object[] { arg1 });
	}
================= fetch public void enter(String methodName, Object thiz, Object[] args) { 6be7097^:weaver5/java5-src/org/aspectj/weaver/tools/Jdk14Trace.java

public void enter(String methodName, Object thiz, Object[] args) {
		if (logger.isLoggable(Level.FINE)) {
			logger.entering(name,methodName,formatObj(thiz));
			if (args != null && logger.isLoggable(Level.FINER)) {
				logger.entering(name,methodName,args);
			}			
		}
	}
================= fetch public void event(String methodName, Object thiz, Object[] args) { 6be7097^:weaver5/java5-src/org/aspectj/weaver/tools/Jdk14Trace.java

public void event(String methodName, Object thiz, Object[] args) {
		if (logger.isLoggable(Level.FINE)) {
			logger.logp(Level.FINER,name,methodName,"EVENT",formatObj(thiz));
			if (args != null && logger.isLoggable(Level.FINER)) {
				logger.logp(Level.FINER,name,methodName,"EVENT",args);
			}			
		}
	}
================= fetch public void exit(String methodName, Object ret) { 6be7097^:weaver5/java5-src/org/aspectj/weaver/tools/Jdk14Trace.java

public void exit(String methodName, Object ret) {
		if (logger.isLoggable(Level.FINE)) {
			logger.exiting(name,methodName,ret);
		}
	}
================= fetch public void testEnterWithThisAndArray() { 6be7097^:weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.java

public void testEnterWithThisAndArray() {
		Object arg1 = new String[] { "s1", "s2" };
		Object arg2 = new char[] { 'a', 'b', 'c' };
		trace.enter("testEnterWithThisAndArgs",this,new Object[] { arg1, arg2 });
	}
================= fetch public void testEnterWithThisAndCollection() { 6be7097^:weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.java

public void testEnterWithThisAndCollection() {
		Object arg1 = new ArrayList();
		trace.enter("testEnterWithThisAndArgs",this,new Object[] { arg1 });
	}
================= fetch public OptionsFrame(IconRegistry icons) { 40cf610^:ajde/src/org/aspectj/ajde/ui/swing/OptionsFrame.java

================= fetch public void testVersion() { 40cf610^:bridge/testsrc/org/aspectj/bridge/VersionTest.java

public void testVersion() {
    	if (Version.time_text.equals("")) return;  // dev build, we can only test this on the build server.
        Date date = new Date(Version.time);
        SimpleDateFormat format = new SimpleDateFormat(Version.SIMPLE_DATE_FORMAT, Locale.getDefault());
        format.setTimeZone(TimeZone.getTimeZone("GMT"));
        String timeString = format.format(date);
        assertEquals(Version.time_text, timeString);
    }
================= fetch public void write(DataOutputStream s) throws IOException { 40cf610^:weaver/src/org/aspectj/weaver/AjAttribute.java

public void write(DataOutputStream s) throws IOException {}
================= fetch private void init(List classPath, List aspectPath) { 04fa1dc^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java

private void init(List classPath, List aspectPath) {
		createMessageHandler();
		
		info("using classpath: " + classPath); 
		info("using aspectpath: " + aspectPath); 
		
		bcelWorld = new BcelWorld(classPath,messageHandler,null);
		bcelWorld.setXnoInline(false);
		bcelWorld.getLint().loadDefaultProperties();
		if (LangUtil.is15VMOrGreater()) {
			bcelWorld.setBehaveInJava5Way(true);
		}

		weaver = new BcelWeaver(bcelWorld);
		registerAspectLibraries(aspectPath);
	}
================= fetch private void registerAspects(final BcelWeaver weaver, final ClassLoader loader, 04fa1dc^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
     * Register the aspect, following include / exclude rules
     *
     * @param weaver
     * @param loader
     * @param definitions
     */
private void registerAspects(final BcelWeaver weaver, final ClassLoader loader, final List definitions) {
    	if (trace.isTraceEnabled()) trace.enter("registerAspects",this, new Object[] { weaver, loader, definitions} );
        //TODO: the exclude aspect allow to exclude aspect defined upper in the CL hierarchy - is it what we want ??
        // if not, review the getResource so that we track which resource is defined by which CL

        //iterate aspectClassNames
        //exclude if in any of the exclude list
        for (Iterator iterator = definitions.iterator(); iterator.hasNext();) {
            Definition definition = (Definition) iterator.next();
            for (Iterator aspects = definition.getAspectClassNames().iterator(); aspects.hasNext();) {
                String aspectClassName = (String) aspects.next();
                if (acceptAspect(aspectClassName)) {
                	info("register aspect " + aspectClassName);
//                	System.err.println("? ClassLoaderWeavingAdaptor.registerAspects() aspectName=" + aspectClassName + ", loader=" + loader + ", bundle=" + weavingContext.getClassLoaderName());
                    /*ResolvedType aspect = */weaver.addLibraryAspect(aspectClassName);

                    //generate key for SC
                    if(namespace==null){
                    	namespace=new StringBuffer(aspectClassName);
                    }else{
                    	namespace = namespace.append(";"+aspectClassName);
                    }
                }
                else {
//                	warn("aspect excluded: " + aspectClassName);
                	lint("aspectExcludedByConfiguration", new String[] { aspectClassName, getClassLoaderName(loader) });
                }
            }
        }

        //iterate concreteAspects
        //exclude if in any of the exclude list - note that the user defined name matters for that to happen
        for (Iterator iterator = definitions.iterator(); iterator.hasNext();) {
            Definition definition = (Definition) iterator.next();
            for (Iterator aspects = definition.getConcreteAspects().iterator(); aspects.hasNext();) {
                Definition.ConcreteAspect concreteAspect = (Definition.ConcreteAspect) aspects.next();
                if (acceptAspect(concreteAspect.name)) {
                    ConcreteAspectCodeGen gen = new ConcreteAspectCodeGen(concreteAspect, weaver.getWorld());
                    if (!gen.validate()) {
                        error("Concrete-aspect '"+concreteAspect.name+"' could not be registered");
                        break;
                    }
                    this.generatedClassHandler.acceptClass(
                            concreteAspect.name,
                            gen.getBytes()
                    );
                    /*ResolvedType aspect = */weaver.addLibraryAspect(concreteAspect.name);

                    //generate key for SC
                    if(namespace==null){
                    	namespace=new StringBuffer(concreteAspect.name);
                    }else{
                    	namespace = namespace.append(";"+concreteAspect.name);
                    }
                }
            }
        }
//        System.out.println("ClassLoaderWeavingAdaptor.registerAspects() classloader=" + weavingContext.getClassLoaderName() + ", namespace=" + namespace);
        
        /* We didn't register any aspects so disable the adaptor */
        if (namespace == null) {
        	disable();
    		info("no aspects registered. Disabling weaver for class loader " + getClassLoaderName(loader));
        }

        if (trace.isTraceEnabled()) trace.exit("registerAspects",isEnabled());
    }
================= fetch protected Class defineClass(String name, byte[] b, CodeSource cs) throws IOExcep 04fa1dc^:loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java
/**
	 * Override to weave class using WeavingAdaptor 
	 */
protected Class defineClass(String name, byte[] b, CodeSource cs) throws IOException {
//		System.err.println("? WeavingURLClassLoader.defineClass(" + name + ", [" + b.length + "])");

		/* Avoid recursion during adaptor initialization */
		if (!initializingAdaptor) {
			
			/* Need to defer creation because of possible recursion during constructor execution */
			if (adaptor == null && !initializingAdaptor) {
				createAdaptor();
			}
			
			b = adaptor.weaveClass(name,b);
		}
		return super.defineClass(name, b, cs);
	}
================= fetch protected void disable () { 04fa1dc^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java

protected void disable () {
		enabled = false;
		messageHolder.flushMessages();
	}
================= fetch public WeavingURLClassLoader (URL[] urls, ClassLoader parent) { 04fa1dc^:loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java

================= fetch public boolean handleMessage(IMessage message) throws AbortException { 04fa1dc^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java

public void setDelegate (IMessageHandler messageHandler) {
			delegate = messageHandler;
		}
================= fetch public void testParsingBytecodeLess_pr152871() { 04fa1dc^:tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java

public void testLTWWorldWithAnnotationMatching_pr153572() { runTest("LTWWorld with annotation matching");}
================= fetch private static List makeClasspath(String cp) { 8549d86^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java

private static List makeClasspath(String cp) {
		List ret = new ArrayList();
		if (cp != null) {
			StringTokenizer tok = new StringTokenizer(cp,File.pathSeparator);
			while (tok.hasMoreTokens()) {
				ret.add(tok.nextToken());
			}
		}
		return ret;
	}
================= fetch private void defineClass(ClassLoader loader, String name, byte[] bytes) { 8549d86^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java

private void defineClass(ClassLoader loader, String name, byte[] bytes) {
    	if (trace.isTraceEnabled()) trace.enter("defineClass",this,new Object[] {loader,name,bytes});
    	Object clazz = null;
		info("generating class '" + name + "'");
		
		try {
			//TODO av protection domain, and optimize
			Method defineClass = ClassLoader.class.getDeclaredMethod(
					"defineClass", new Class[] { String.class,
							bytes.getClass(), int.class, int.class });
			defineClass.setAccessible(true);
			clazz = defineClass.invoke(loader, new Object[] { name, bytes,
					new Integer(0), new Integer(bytes.length) });
		} catch (InvocationTargetException e) {
			if (e.getTargetException() instanceof LinkageError) {
				warn("define generated class failed",e.getTargetException());
				//is already defined (happens for X$ajcMightHaveAspect interfaces since aspects are reweaved)
				// TODO maw I don't think this is OK and
			} else {
				warn("define generated class failed",e.getTargetException());
			}
		} catch (Exception e) {
			warn("define generated class failed",e);
		}

		if (trace.isTraceEnabled()) trace.exit("defineClass",clazz);
	}
================= fetch public boolean handleMessage(IMessage message) throws AbortException { 8549d86^:tests/java5/ataspectj/ataspectj/TestHelper.java

public boolean handleMessage(IMessage message) throws AbortException {
        boolean ret = super.handleMessage(message);
        if (message.getKind().isSameOrLessThan(IMessage.INFO)) {
            ;
        } else {
            // we do exit here since Assert.fail will only trigger a runtime exception that might
            // be catched by the weaver anyway
            System.err.println("*** Exiting - got a warning/fail/error/abort IMessage");
            System.exit(-1);
        }
        return ret;
    }
================= fetch public boolean isIgnoring(IMessage.Kind kind) { 8549d86^:loadtime/src/org/aspectj/weaver/loadtime/DefaultMessageHandler.java

public boolean isIgnoring(IMessage.Kind kind) {
        if (kind.equals(IMessage.WEAVEINFO)) {
            return !showWeaveInfo;
        }
        if (kind.isSameOrLessThan(IMessage.INFO)) {
            return !isVerbose;
        }
        return !showWarn;
    }
================= fetch public static WeaverOption parse(String options, ClassLoader laoder, IMessageHan 8549d86^:loadtime/src/org/aspectj/weaver/loadtime/Options.java

public static WeaverOption parse(String options, ClassLoader laoder, IMessageHandler imh) {
        WeaverOption weaverOption = new WeaverOption(imh);

        if (LangUtil.isEmpty(options)) {
            return weaverOption;
        }
        // the first option wins
        List flags = LangUtil.anySplit(options, " ");
        Collections.reverse(flags);

        // do a first round on the message handler since it will report the options themselves
        for (Iterator iterator = flags.iterator(); iterator.hasNext();) {
            String arg = (String) iterator.next();
            if (arg.startsWith(OPTIONVALUED_messageHandler)) {
                if (arg.length() > OPTIONVALUED_messageHandler.length()) {
                    String handlerClass = arg.substring(OPTIONVALUED_messageHandler.length()).trim();
                    try {
                        Class handler = Class.forName(handlerClass, false, laoder);
                        weaverOption.messageHandler = ((IMessageHandler) handler.newInstance());
                    } catch (Throwable t) {
                        weaverOption.messageHandler.handleMessage(
                                new Message(
                                        "Cannot instantiate message handler " + handlerClass,
                                        IMessage.ERROR,
                                        t,
                                        null
                                )
                        );
                    }
                }
            }
        }

        // configure the other options
        for (Iterator iterator = flags.iterator(); iterator.hasNext();) {
            String arg = (String) iterator.next();
            if (arg.equals(OPTION_15)) {
                weaverOption.java5 = true;
            } else if (arg.equalsIgnoreCase(OPTION_lazyTjp)) {
                weaverOption.lazyTjp = true;
            } else if (arg.equalsIgnoreCase(OPTION_noinline)) {
                weaverOption.noInline = true;
            } else if (arg.equalsIgnoreCase(OPTION_addSerialVersionUID)) {
            	weaverOption.addSerialVersionUID=true;
            } else if (arg.equalsIgnoreCase(OPTION_noWarn) || arg.equalsIgnoreCase(OPTION_noWarnNone)) {
                weaverOption.noWarn = true;
            } else if (arg.equalsIgnoreCase(OPTION_proceedOnError)) {
                weaverOption.proceedOnError = true;
            } else if (arg.equalsIgnoreCase(OPTION_reweavable)) {
                weaverOption.notReWeavable = false;
            } else if (arg.equalsIgnoreCase(OPTION_showWeaveInfo)) {
                weaverOption.showWeaveInfo = true;
            } else if (arg.equalsIgnoreCase(OPTION_hasMember)) {
                weaverOption.hasMember = true;
            } else if (arg.startsWith(OPTIONVALUED_joinpoints)) {
            	if (arg.length()>OPTIONVALUED_joinpoints.length()) 
            	weaverOption.optionalJoinpoints = arg.substring(OPTIONVALUED_joinpoints.length()).trim();
            }  else if (arg.equalsIgnoreCase(OPTION_verbose)) {
                weaverOption.verbose = true;
            } else if (arg.equalsIgnoreCase(OPTION_pinpoint)) {
                weaverOption.pinpoint = true;
            } else if (arg.startsWith(OPTIONVALUED_messageHandler)) {
                ;// handled in first round
            } else if (arg.startsWith(OPTIONVALUED_Xlintfile)) {
                if (arg.length() > OPTIONVALUED_Xlintfile.length()) {
                    weaverOption.lintFile = arg.substring(OPTIONVALUED_Xlintfile.length()).trim();
                }
            } else if (arg.startsWith(OPTIONVALUED_Xlint)) {
                if (arg.length() > OPTIONVALUED_Xlint.length()) {
                    weaverOption.lint = arg.substring(OPTIONVALUED_Xlint.length()).trim();
                }
            } else if (arg.startsWith(OPTIONVALUED_Xset)) {
                if (arg.length() > OPTIONVALUED_Xlint.length()) {
                    weaverOption.xSet = arg.substring(OPTIONVALUED_Xset.length()).trim();
                }            	
            } else {
                weaverOption.messageHandler.handleMessage(
                        new Message(
                                "Cannot configure weaver with option '" + arg + "': unknown option",
                                IMessage.WARNING,
                                null,
                                null
                        )
                );
            }
        }

        // refine message handler configuration
        if (weaverOption.noWarn) {
            weaverOption.messageHandler.dontIgnore(IMessage.WARNING);
        }
        if (weaverOption.verbose) {
            weaverOption.messageHandler.dontIgnore(IMessage.INFO);
        }
        if (weaverOption.showWeaveInfo) {
            weaverOption.messageHandler.dontIgnore(IMessage.WEAVEINFO);
        }

        return weaverOption;
    }
================= fetch public void addURL(URL url) { 8549d86^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java
/**
	 * Weave a class using aspects previously supplied to the adaptor.
	 * @param name the name of the class
	 * @param bytes the class bytes
	 * @return the woven bytes
     * @exception IOException weave failed
	 */
public byte[] weaveClass (String name, byte[] bytes) throws IOException {
		if (enabled) {
			try {
				delegateForCurrentClass=null; 
		    	if (trace.isTraceEnabled()) trace.enter("weaveClass",this,new Object[] {name,bytes});
				name = name.replace('/','.');
				if (couldWeave(name, bytes)) {
			        if (accept(name, bytes)) {
			            // TODO @AspectJ problem
			            // Annotation style aspects need to be included regardless in order to get
			            // a valid aspectOf()/hasAspect() generated in them.  However - if they are excluded
			            // (via include/exclude in aop.xml) they really should only get aspectOf()/hasAspect()
			            // and not be included in the full set of aspects being applied by 'this' weaver
						info("weaving '" + name + "'");
						bytes = getWovenBytes(name, bytes);
					} else if (shouldWeaveAnnotationStyleAspect(name, bytes)) {
			            // an @AspectJ aspect needs to be at least munged by the aspectOf munger
			            info("weaving '" + name + "'");
			            bytes = getAtAspectJAspectBytes(name, bytes);
					} else {
						info("not weaving '" + name + "'");
					}
		        } else {
					info("cannot weave '" + name + "'");
				}
	
				if (trace.isTraceEnabled()) trace.exit("weaveClass",bytes);
			} finally {
				delegateForCurrentClass=null;
			}
		}

        return bytes;
	}
================= fetch private void generatePerSingletonAjcClinitMethod(LazyClassGen classGen) { 945a257^:weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.java

private void generatePerSingletonAjcClinitMethod(LazyClassGen classGen) {
        InstructionFactory factory = classGen.getFactory();
        LazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.ajcPostClinitMethod(aspectType));
        flagAsSynthetic(method, true);
        classGen.addMethodGen(method);

        InstructionList il = method.getBody();
        il.append(factory.createNew(aspectType.getName()));
        il.append(InstructionConstants.DUP);
        il.append(factory.createInvoke(aspectType.getName(), "<init>", Type.VOID, Type.NO_ARGS, Constants.INVOKESPECIAL));
        il.append(Utility.createSet(factory,  AjcMemberMaker.perSingletonField(aspectType)));
        il.append(InstructionFactory.createReturn(Type.VOID));

        // patch <clinit> to delegate to ajc$postClinit at the end
        LazyMethodGen clinit = classGen.getStaticInitializer();
        il = new InstructionList();
        InstructionHandle tryStart = il.append(factory.createInvoke(aspectType.getName(), NameMangler.AJC_POST_CLINIT_NAME, Type.VOID, Type.NO_ARGS, Constants.INVOKESTATIC));
        BranchInstruction tryEnd = InstructionFactory.createBranchInstruction(Constants.GOTO, null);
        il.append(tryEnd);
        InstructionHandle handler = il.append(InstructionConstants.ASTORE_0);
        il.append(InstructionConstants.ALOAD_0);
        il.append(Utility.createSet(factory, AjcMemberMaker.initFailureCauseField(aspectType)));
        il.append(InstructionFactory.createReturn(Type.VOID));
        tryEnd.setTarget(il.getEnd());

        // replace the original "return" with a "nop"
        //TODO AV - a bit odd, looks like Bcel alters bytecode and has a IMPDEP1 in its representation
        if (clinit.getBody().getEnd().getInstruction().getOpcode() == Constants.IMPDEP1) {
            clinit.getBody().getEnd().getPrev().setInstruction(new NOP());
        }
        clinit.getBody().getEnd().setInstruction(new NOP());
        clinit.getBody().append(il);

        clinit.addExceptionHandler(
            tryStart, handler, handler, new ObjectType("java.lang.Throwable"), false
        );
    }
================= fetch public PerClause concretize(ResolvedType inAspect) { 945a257^:weaver/src/org/aspectj/weaver/patterns/PerSingleton.java

public PerClause concretize(ResolvedType inAspect) {
		PerSingleton ret = new PerSingleton();

        ret.copyLocationFrom(this);

		ret.inAspect = inAspect;

        //ATAJ: add a munger to add the aspectOf(..) to the @AJ aspects
        if (inAspect.isAnnotationStyleAspect()  && !inAspect.isAbstract()) {
            //TODO will those change be ok if we add a serializable aspect ?
            // dig: "can't be Serializable/Cloneable unless -XserializableAspects"
            inAspect.crosscuttingMembers.addLateTypeMunger(
                    inAspect.getWorld().makePerClauseAspect(inAspect, getKind())
            );
        }

        //ATAJ inline around advice support
        if (inAspect.isAnnotationStyleAspect() && !inAspect.getWorld().isXnoInline()) {
            inAspect.crosscuttingMembers.addTypeMunger(new BcelAccessForInlineMunger(inAspect));
        }

        return ret;
	}
================= fetch public void testPr141956_IncrementallyCompilingAtAj() { 945a257^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
/**
	 * Checks we aren't leaking mungers across compiles (accumulating multiple instances of the same one that
	 * all do the same thing).  On the first compile the munger is added late on - so at the time we set
	 * the count it is still zero.  On the subsequent compiles we know about this extra one.
	 */
public void testPr141956_IncrementallyCompilingAtAj() {
		initialiseProject("PR141956");
		build("PR141956");
		assertTrue("Should be zero but reports "+EclipseFactory.debug_mungerCount,EclipseFactory.debug_mungerCount==0);
		alter("PR141956","inc1");
		build("PR141956");
		assertTrue("Should be only one but reports "+EclipseFactory.debug_mungerCount,EclipseFactory.debug_mungerCount==1);
		alter("PR141956","inc1");
		build("PR141956");
		assertTrue("Should be only one but reports "+EclipseFactory.debug_mungerCount,EclipseFactory.debug_mungerCount==1);
		alter("PR141956","inc1");
		build("PR141956");
		assertTrue("Should be only one but reports "+EclipseFactory.debug_mungerCount,EclipseFactory.debug_mungerCount==1);
		alter("PR141956","inc1");
		build("PR141956");
		assertTrue("Should be only one but reports "+EclipseFactory.debug_mungerCount,EclipseFactory.debug_mungerCount==1);
	}
Progress : [################------------------------] 40%================= fetch private void ensureAnnotationsUnpacked() { 59123b0^:weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java
// --- unpacking methods
private void ensureAnnotationsUnpacked() {
		if (annotationTypes == null) {
    		Annotation annos[] = javaClass.getAnnotations();
    		if (annos==null || annos.length==0) {
    			annotationTypes = ResolvedType.NONE;
    			annotations     = AnnotationX.NONE;
    		} else {
    			World w = getResolvedTypeX().getWorld();
	    		annotationTypes = new ResolvedType[annos.length];
	    		annotations     = new AnnotationX[annos.length];
	    		for (int i = 0; i < annos.length; i++) {
					Annotation annotation = annos[i];
					annotationTypes[i] = w.resolve(UnresolvedType.forName(annotation.getTypeName()));
					annotations[i]     = new AnnotationX(annotation,w);
				}
    		}
    	}
	}
================= fetch public static ResolvedType resolve(World world, Class aClass) { 82e3e13^:weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java

public static ResolvedType resolve(World world, Class aClass) {
		// classes that represent arrays return a class name that is the signature of the array type, ho-hum...
		String className = aClass.getName();
		if (aClass.isArray()) {
			return world.resolve(UnresolvedType.forSignature(className));
		}
		else{
			return world.resolve(className);
		} 
	}
================= fetch public void testCompareSubclassDelegates() { 82e3e13^:weaver5/java5-testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java
// FIXME asc maybe.  The reflection list of methods returned doesn't include <clinit> (the static initializer) ... is that really a problem.
public void testCompareSubclassDelegates() {
    	
    	boolean barfIfClinitMissing = false;
        world.setBehaveInJava5Way(true);
        
        BcelWorld bcelWorld = new BcelWorld(getClass().getClassLoader(),IMessageHandler.THROW,null);
        bcelWorld.setBehaveInJava5Way(true);
        UnresolvedType javaUtilHashMap = UnresolvedType.forName("java.util.HashMap");
        ReferenceType rawType =(ReferenceType)bcelWorld.resolve(javaUtilHashMap );
        
        ReferenceType rawReflectType =(ReferenceType)world.resolve(javaUtilHashMap );
        ResolvedMember[] rms1 = rawType.getDelegate().getDeclaredMethods();
        ResolvedMember[] rms2 = rawReflectType.getDelegate().getDeclaredMethods();
        StringBuffer errors = new StringBuffer();
        Set one = new HashSet();
        for (int i = 0; i < rms1.length; i++) {
			one.add(rms1[i].toString());
		}
        Set two = new HashSet();
        for (int i = 0; i < rms2.length; i++) {
			two.add(rms2[i].toString());
		}
        for (int i = 0;i<rms2.length;i++) {
        	if (!one.contains(rms2[i].toString())) {
        		errors.append("Couldn't find "+rms2[i].toString()+" in the bcel set\n");
        	}
        }
        for (int i = 0;i<rms1.length;i++) {
        	if (!two.contains(rms1[i].toString())) {
        		if (!barfIfClinitMissing && rms1[i].getName().equals("<clinit>")) continue;
        		errors.append("Couldn't find "+rms1[i].toString()+" in the reflection set\n");
        	}
        }
        assertTrue("Errors:"+errors.toString(),errors.length()==0);
        
        // the good old ibm vm seems to offer clinit through its reflection support (see pr145322)
        if (rms1.length==rms2.length) return;
        if (barfIfClinitMissing) {
        	// the numbers must be exact
            assertEquals(rms1.length,rms2.length);        	
        } else {
        	// the numbers can be out by one in favour of bcel
        	if (rms1.length!=(rms2.length+1)) {
        		for (int i = 0; i < rms1.length; i++) {
					System.err.println("bcel"+i+" is "+rms1[i]);
				}
        		for (int i = 0; i < rms2.length; i++) {
					System.err.println("refl"+i+" is "+rms2[i]);
				}
        	}
        	assertTrue("Should be one extra (clinit) in BCEL case, but bcel="+rms1.length+" reflect="+rms2.length,rms1.length==rms2.length+1);
        }
    }
================= fetch public void testGetSuperclass() { 82e3e13^:weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java

public void testGetSuperclass() {
		assertTrue("Superclass of object should be null, but it is: "+objectType.getSuperclass(),objectType.getSuperclass()==null);
		assertEquals(objectType,world.resolve("java.lang.Class").getSuperclass());
		ResolvedType d = world.resolve("reflect.tests.D");
		assertEquals(world.resolve("reflect.tests.C"),d.getSuperclass());
	}
================= fetch public void unusedArgument(LocalDeclaration localDecl) { 07c2189^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java

public void unusedArgument(LocalDeclaration localDecl) {
    	// don't warn if this is an aj synthetic arg
    	String argType = new String(localDecl.type.resolvedType.signature());
    	if (argType.startsWith("Lorg/aspectj/runtime/internal")) return;
    	super.unusedArgument(localDecl);
    }
================= fetch private void registerOptions(final BcelWeaver weaver, final ClassLoader loader, 039be68^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
     * Configure the weaver according to the option directives
     * TODO av - don't know if it is that good to reuse, since we only allow a small subset of options in LTW
     *
     * @param weaver
     * @param loader
     * @param definitions
     */
private void registerOptions(final BcelWeaver weaver, final ClassLoader loader, final List definitions) {
        StringBuffer allOptions = new StringBuffer();
        for (Iterator iterator = definitions.iterator(); iterator.hasNext();) {
            Definition definition = (Definition) iterator.next();
            allOptions.append(definition.getWeaverOptions()).append(' ');
        }

        Options.WeaverOption weaverOption = Options.parse(allOptions.toString(), loader, getMessageHandler());

        // configure the weaver and world
        // AV - code duplicates AspectJBuilder.initWorldAndWeaver()
        World world = weaver.getWorld();
        setMessageHandler(weaverOption.messageHandler);
        world.setXlazyTjp(weaverOption.lazyTjp);
        world.setXHasMemberSupportEnabled(weaverOption.hasMember);
        world.setOptionalJoinpoints(weaverOption.optionalJoinpoints);
        world.setPinpointMode(weaverOption.pinpoint);
        weaver.setReweavableMode(weaverOption.notReWeavable);
        world.setXnoInline(weaverOption.noInline);
        // AMC - autodetect as per line below, needed for AtAjLTWTests.testLTWUnweavable
        world.setBehaveInJava5Way(LangUtil.is15VMOrGreater());
        world.setAddSerialVerUID(weaverOption.addSerialVersionUID);

        /* First load defaults */
		bcelWorld.getLint().loadDefaultProperties();
		
		/* Second overlay LTW defaults */
		bcelWorld.getLint().adviceDidNotMatch.setKind(null);
        
        /* Third load user file using -Xlintfile so that -Xlint wins */
        if (weaverOption.lintFile != null) {
            InputStream resource = null;
            try {
                resource = loader.getResourceAsStream(weaverOption.lintFile);
                Exception failure = null;
                if (resource != null) {
                    try {
                        Properties properties = new Properties();
                        properties.load(resource);
                        world.getLint().setFromProperties(properties);
                    } catch (IOException e) {
                        failure = e;
                    }
                }
                if (failure != null || resource == null) {
                	warn("Cannot access resource for -Xlintfile:"+weaverOption.lintFile,failure);
//                    world.getMessageHandler().handleMessage(new Message(
//                            "Cannot access resource for -Xlintfile:"+weaverOption.lintFile,
//                            IMessage.WARNING,
//                            failure,
//                            null));
                }
            } finally {
                try { resource.close(); } catch (Throwable t) {;}
            }
       } 
        
       /* Fourth override with -Xlint */
       if (weaverOption.lint != null) {
            if (weaverOption.lint.equals("default")) {//FIXME should be AjBuildConfig.AJLINT_DEFAULT but yetanother deps..
                bcelWorld.getLint().loadDefaultProperties();
            } else {
                bcelWorld.getLint().setAll(weaverOption.lint);
            }
        }
        //TODO proceedOnError option
    }
================= fetch public static WeaverOption parse(String options, ClassLoader laoder, IMessageHan 039be68^:loadtime/src/org/aspectj/weaver/loadtime/Options.java

public static WeaverOption parse(String options, ClassLoader laoder, IMessageHandler imh) {
        WeaverOption weaverOption = new WeaverOption(imh);

        if (LangUtil.isEmpty(options)) {
            return weaverOption;
        }
        // the first option wins
        List flags = LangUtil.anySplit(options, " ");
        Collections.reverse(flags);

        // do a first round on the message handler since it will report the options themselves
        for (Iterator iterator = flags.iterator(); iterator.hasNext();) {
            String arg = (String) iterator.next();
            if (arg.startsWith(OPTIONVALUED_messageHandler)) {
                if (arg.length() > OPTIONVALUED_messageHandler.length()) {
                    String handlerClass = arg.substring(OPTIONVALUED_messageHandler.length()).trim();
                    try {
                        Class handler = Class.forName(handlerClass, false, laoder);
                        weaverOption.messageHandler = ((IMessageHandler) handler.newInstance());
                    } catch (Throwable t) {
                        weaverOption.messageHandler.handleMessage(
                                new Message(
                                        "Cannot instantiate message handler " + handlerClass,
                                        IMessage.ERROR,
                                        t,
                                        null
                                )
                        );
                    }
                }
            }
        }

        // configure the other options
        for (Iterator iterator = flags.iterator(); iterator.hasNext();) {
            String arg = (String) iterator.next();
            if (arg.equals(OPTION_15)) {
                weaverOption.java5 = true;
            } else if (arg.equalsIgnoreCase(OPTION_lazyTjp)) {
                weaverOption.lazyTjp = true;
            } else if (arg.equalsIgnoreCase(OPTION_noinline)) {
                weaverOption.noInline = true;
            } else if (arg.equalsIgnoreCase(OPTION_addSerialVersionUID)) {
            	weaverOption.addSerialVersionUID=true;
            } else if (arg.equalsIgnoreCase(OPTION_noWarn) || arg.equalsIgnoreCase(OPTION_noWarnNone)) {
                weaverOption.noWarn = true;
            } else if (arg.equalsIgnoreCase(OPTION_proceedOnError)) {
                weaverOption.proceedOnError = true;
            } else if (arg.equalsIgnoreCase(OPTION_reweavable)) {
                weaverOption.notReWeavable = false;
            } else if (arg.equalsIgnoreCase(OPTION_showWeaveInfo)) {
                weaverOption.showWeaveInfo = true;
            } else if (arg.equalsIgnoreCase(OPTION_hasMember)) {
                weaverOption.hasMember = true;
            } else if (arg.startsWith(OPTIONVALUED_joinpoints)) {
            	if (arg.length()>OPTIONVALUED_joinpoints.length()) 
            	weaverOption.optionalJoinpoints = arg.substring(OPTIONVALUED_joinpoints.length()).trim();
            }  else if (arg.equalsIgnoreCase(OPTION_verbose)) {
                weaverOption.verbose = true;
            } else if (arg.equalsIgnoreCase(OPTION_pinpoint)) {
                weaverOption.pinpoint = true;
            } else if (arg.startsWith(OPTIONVALUED_messageHandler)) {
                ;// handled in first round
            } else if (arg.startsWith(OPTIONVALUED_Xlintfile)) {
                if (arg.length() > OPTIONVALUED_Xlintfile.length()) {
                    weaverOption.lintFile = arg.substring(OPTIONVALUED_Xlintfile.length()).trim();
                }
            } else if (arg.startsWith(OPTIONVALUED_Xlint)) {
                if (arg.length() > OPTIONVALUED_Xlint.length()) {
                    weaverOption.lint = arg.substring(OPTIONVALUED_Xlint.length()).trim();
                }
            } else {
                weaverOption.messageHandler.handleMessage(
                        new Message(
                                "Cannot configure weaver with option '" + arg + "': unknown option",
                                IMessage.WARNING,
                                null,
                                null
                        )
                );
            }
        }

        // refine message handler configuration
        if (weaverOption.noWarn) {
            weaverOption.messageHandler.dontIgnore(IMessage.WARNING);
        }
        if (weaverOption.verbose) {
            weaverOption.messageHandler.dontIgnore(IMessage.INFO);
        }
        if (weaverOption.showWeaveInfo) {
            weaverOption.messageHandler.dontIgnore(IMessage.WEAVEINFO);
        }

        return weaverOption;
    }
================= fetch public void testAspectsIncludeWithLintWarning () { 039be68^:tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.java

public void testAspectsIncludeWithLintWarning () {
  		runTest("Ensure weaver lint warning issued when an aspect is not used for weaving");
  	}
================= fetch public static String addExtraSourceLocations( a38edd3^:bridge/src/org/aspectj/bridge/MessageUtil.java

public static String addExtraSourceLocations(
		IMessage message,
		String baseMessage)
	{
		StringWriter buf = new StringWriter();
		PrintWriter writer = new PrintWriter(buf);
		writer.println(baseMessage);
		for (Iterator iter = message.getExtraSourceLocations().iterator(); iter.hasNext();) {
		    ISourceLocation element = (ISourceLocation) iter.next();
		    writer.print("\tsee also: " + element.toString());
		    if (iter.hasNext()) {
		        writer.println();
		    }
		}
		try { buf.close(); } 
		catch (IOException ioe) {} 
		return buf.getBuffer().toString();    
	}
================= fetch public ClassLoaderRepository( java.lang.ClassLoader loader ) { 387c3ac^:bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java

================= fetch public JavaClass findClass( String className ) { 387c3ac^:bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java
/**
   * Find an already defined JavaClass.
   */
public JavaClass findClass( String className ) {
    if ( loadedClasses.containsKey( className )) {
      return (JavaClass) loadedClasses.get( className );
    } else {
      return null;
    }
  }
================= fetch public JavaClass loadClass( String className ) 387c3ac^:bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java
/**
   * Lookup a JavaClass object from the Class Name provided.
   */
public JavaClass loadClass( String className ) 
    throws ClassNotFoundException
  {
    String classFile = className.replace('.', '/');

    JavaClass RC = findClass( className );
    if (RC != null) { return RC; }

    try {
      InputStream is = 
	loader.getResourceAsStream( classFile + ".class" );
	    
      if(is == null) {
	throw new ClassNotFoundException(className + " not found.");
      }

      ClassParser parser = new ClassParser( is, className );
      RC = parser.parse();
	    
      storeClass( RC );

      return RC;
    } catch (IOException e) {
      throw new ClassNotFoundException( e.toString() );
    }
  }
================= fetch public JavaClass loadClass(Class clazz) throws ClassNotFoundException { 387c3ac^:bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java

public JavaClass loadClass(Class clazz) throws ClassNotFoundException {
    return loadClass(clazz.getName());
  }
================= fetch public static Test suite() { 387c3ac^:bcel-builder/testsrc/org/aspectj/apache/bcel/classfile/tests/AllTests.java

public static Test suite() {
		TestSuite suite = new TestSuite("Tests for BCEL Java5 support");
		//$JUnit-BEGIN$
		suite.addTestSuite(RuntimeVisibleParameterAnnotationAttributeTest.class);
		suite.addTestSuite(AnnotationDefaultAttributeTest.class);
		suite.addTestSuite(EnclosingMethodAttributeTest.class);
		suite.addTestSuite(MethodAnnotationsTest.class);
		suite.addTestSuite(RuntimeVisibleAnnotationAttributeTest.class);
		suite.addTestSuite(EnumAccessFlagTest.class);
		suite.addTestSuite(LocalVariableTypeTableTest.class);
		suite.addTestSuite(VarargsTest.class);
		suite.addTestSuite(AnnotationAccessFlagTest.class);
		suite.addTestSuite(ElementValueGenTest.class);
		suite.addTestSuite(FieldAnnotationsTest.class);
		suite.addTestSuite(AnnotationGenTest.class);
		suite.addTestSuite(ParameterAnnotationsTest.class);
		suite.addTestSuite(GeneratingAnnotatedClassesTest.class);
		suite.addTestSuite(TypeAnnotationsTest.class);
		suite.addTestSuite(UtilTests.class);
		suite.addTestSuite(GenericSignatureParsingTest.class);
		suite.addTestSuite(GenericsErasureTesting.class);
		suite.addTestSuite(AnonymousClassTest.class);
		//$JUnit-END$
		return suite;
	}
================= fetch public void clear() { 387c3ac^:bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java
/** Clear all entries from cache.
   */
public void clear() {
    loadedClasses.clear();
  }
================= fetch public void removeClass(JavaClass clazz) { 387c3ac^:bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java
/**
   * Remove class from repository
   */
public void removeClass(JavaClass clazz) {
    loadedClasses.remove(clazz.getClassName());
  }
================= fetch public void storeClass( JavaClass clazz ) { 387c3ac^:bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java
/**
   * Store a new JavaClass into this Repository.
   */
public void storeClass( JavaClass clazz ) {
    loadedClasses.put( clazz.getClassName(),
		       clazz );
    clazz.setRepository( this );
  }
Progress : [################------------------------] 41%================= fetch private boolean shouldWeaveAnnotationStyleAspect(String name, byte[] bytes) { f239f2a^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java
/**
     * We allow @AJ aspect weaving so that we can add aspectOf() as part of the weaving
     * (and not part of the source compilation)
     *
     * @param name
     * @param bytes bytecode (from classloader), allow to NOT lookup stuff on disk again during resolve
     * @return true if @Aspect
     */
private boolean shouldWeaveAnnotationStyleAspect(String name, byte[] bytes) {
		// AV: instead of doing resolve that would lookup stuff on disk thru BCEL ClassLoaderRepository
        // we reuse bytes[] here to do a fast lookup for @Aspect annotation
		ensureDelegateInitialized(name,bytes);
		return (delegateForCurrentClass.isAnnotationStyleAspect());
	}
================= fetch public void addURL(URL url) { f239f2a^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java
/**
	 * Weave a class using aspects previously supplied to the adaptor.
	 * @param name the name of the class
	 * @param bytes the class bytes
	 * @return the woven bytes
     * @exception IOException weave failed
	 */
public byte[] weaveClass (String name, byte[] bytes) throws IOException {
		if (enabled) {
			try {
				delegateForCurrentClass=null; 
		    	if (trace.isTraceEnabled()) trace.enter("weaveClass",this,new Object[] {name,bytes});
				if (shouldWeave(name, bytes)) {
					info("weaving '" + name + "'");
					bytes = getWovenBytes(name, bytes);
				} else if (shouldWeaveAnnotationStyleAspect(name, bytes)) {
		            // an @AspectJ aspect needs to be at least munged by the aspectOf munger
		            info("weaving '" + name + "'");
		            bytes = getAtAspectJAspectBytes(name, bytes);
		        }
				else {
					info("not weaving '" + name + "'");
				}
	
				if (trace.isTraceEnabled()) trace.exit("weaveClass",bytes);
			} finally {
				delegateForCurrentClass=null;
			}
		}

        return bytes;
	}
================= fetch public void setSynchronizationPointcutsInUse() { f239f2a^:weaver/src/org/aspectj/weaver/World.java

public boolean areSynchronizationPointcutsInUse() {return synchronizationPointcutsInUse;}
================= fetch public void testAspectOfWhenAspectNotInInclude() { f239f2a^:tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java

public void testAspectOfWhenAspectNotInInclude() {
        runTest("AspectOfWhenAspectNotInInclude");
    }
================= fetch private boolean enforceDecpRule1_abstractMethodsImplemented(BcelClassWeaver weav ff2377a^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
/**
     * Rule 1: For the declare parents to be allowed, the target type must override and implement 
     *         inherited abstract methods (if the type is not declared abstract)
     */
private boolean enforceDecpRule1_abstractMethodsImplemented(BcelClassWeaver weaver, ISourceLocation mungerLoc,LazyClassGen newParentTarget, ResolvedType newParent) {
        boolean ruleCheckingSucceeded = true;
        if (!(newParentTarget.isAbstract() || newParentTarget.isInterface())) { // Ignore abstract classes or interfaces
            List methods = newParent.getMethodsWithoutIterator(false,true);
            for (Iterator i = methods.iterator(); i.hasNext();) {
                ResolvedMember o = (ResolvedMember)i.next();
                if (o.isAbstract() && !o.getName().startsWith("ajc$interField")) { // Ignore abstract methods of ajc$interField prefixed methods
                    ResolvedMember discoveredImpl = null;
                    List newParentTargetMethods = newParentTarget.getType().getMethodsWithoutIterator(false,true);
                    for (Iterator ii = newParentTargetMethods.iterator(); ii.hasNext() && discoveredImpl==null;) {
                        ResolvedMember gen2 = (ResolvedMember) ii.next();
                        if (gen2.getName().equals(o.getName()) && 
                            gen2.getParameterSignature().equals(o.getParameterSignature()) && !gen2.isAbstract()) {
                            discoveredImpl = gen2; // Found a valid implementation !
                        }
                    }     
                    if (discoveredImpl == null) {
                        // didnt find a valid implementation, lets check the ITDs on this type to see if they satisfy it
                        boolean satisfiedByITD = false;
                        for (Iterator ii = newParentTarget.getType().getInterTypeMungersIncludingSupers().iterator(); ii.hasNext(); ) {
                            ConcreteTypeMunger m = (ConcreteTypeMunger)ii.next();
                            if (m.getMunger().getKind() == ResolvedTypeMunger.Method) {
                                ResolvedMember sig = m.getSignature();
                                if (!Modifier.isAbstract(sig.getModifiers())) {
                                	
                                	// If the ITD shares a type variable with some target type, we need to tailor it for that
                                	// type
                                	if (m.isTargetTypeParameterized()) {
                            	        ResolvedType genericOnType = getWorld().resolve(sig.getDeclaringType()).getGenericType();
                                		m = m.parameterizedFor(newParent.discoverActualOccurrenceOfTypeInHierarchy(genericOnType));
                                    	sig = m.getSignature(); // possible sig change when type parameters filled in
                                	}
                                    if (ResolvedType
                                        .matches(
                                            AjcMemberMaker.interMethod(
                                                sig,m.getAspectType(),sig.getDeclaringType().resolve(weaver.getWorld()).isInterface()),o)) {
                                        satisfiedByITD = true;
                                    }
                                }
                            } else if (m.getMunger().getKind() == ResolvedTypeMunger.MethodDelegate) {
                                satisfiedByITD = true;//AV - that should be enough, no need to check more
                            }
                        }
                        if (!satisfiedByITD) {
                          error(weaver,
                                "The type " + newParentTarget.getName() + " must implement the inherited abstract method "+o.getDeclaringType()+"."+o.getName()+o.getParameterSignature(),
                                newParentTarget.getType().getSourceLocation(),new ISourceLocation[]{o.getSourceLocation(),mungerLoc});
                          ruleCheckingSucceeded=false;
                        }
                    }
                }
            }
        }
        return ruleCheckingSucceeded;
    }
================= fetch public static String getLicense(String module) { 7aa6cfe^:build/testsrc/org/aspectj/build/BuildModuleTests.java
/**
     * @param moduleDir
     * @return
     */
private static File[] findSourceRoots(File moduleDir) {
        ArrayList result = new ArrayList();
        for (Iterator iter = SOURCE_NAMES.iterator(); iter.hasNext();) {
            String name = (String) iter.next();
            File srcDir = new File(moduleDir, name);
            if (srcDir.canRead() && srcDir.isDirectory()) {
                result.add(srcDir);
            }
        }
        return (File[]) result.toArray(new File[0]);
    }
================= fetch private void notifyRequestor() { 9664058^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java

private void notifyRequestor() {
		for (Iterator iter = resultsPendingWeave.iterator(); iter.hasNext();) {
			InterimCompilationResult iresult = (InterimCompilationResult) iter.next();
			compiler.requestor.acceptResult(iresult.result().tagAsAccepted());
		}
	}
================= fetch private void postWeave() { 9664058^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java

private void postWeave() {
		if (debugPipeline)System.err.println("> postWeave()");
		IMessageHandler imh = weaver.getWorld().getMessageHandler();
		CflowPointcut.clearCaches();
		if (imh instanceof WeaverMessageHandler)
			  ((WeaverMessageHandler)imh).setCurrentResult(null);
		weaver.allWeavingComplete();
		weaver.tidyUp();
		if (imh instanceof WeaverMessageHandler)
		  ((WeaverMessageHandler)imh).resetCompiler(null);
		if (debugPipeline)System.err.println("< postWeave()");
	}
================= fetch private void queueForWeaving(InterimCompilationResult intRes) { 9664058^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java

private void queueForWeaving(InterimCompilationResult intRes) {
    	resultsPendingWeave.add(intRes);
    	if (pipelineStalled) {
    		if (resultsPendingWeave.size()>=toWaitFor) pipelineStalled = false;
    	}
    	if (pipelineStalled) return;
    	try {
    		weaveQueuedEntries();
    	} catch (IOException ex) {
			AbortCompilation ac = new AbortCompilation(null,ex);
			throw ac;
    	}
	}
================= fetch private void weaveQueuedEntries() throws IOException { 9664058^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java

private void weaveQueuedEntries() throws IOException {
		if (debugPipeline)System.err.println(">.weaveQueuedEntries()");
		for (Iterator iter = resultsPendingWeave.iterator(); iter.hasNext();) {
			InterimCompilationResult iresult = (InterimCompilationResult) iter.next();
			for (int i = 0; i < iresult.unwovenClassFiles().length; i++) {
				weaver.addClassFile(iresult.unwovenClassFiles()[i]);
			}			
		}
		ensureWeaverInitialized(); // by doing this only once, are we saying needToReweaveWorld can't change once the aspects have been stuffed into the weaver?
		if (weaver.needToReweaveWorld() && !isBatchCompile) return;
		weaver.weave(new WeaverAdapter(this,weaverMessageHandler,progressListener));
		resultsPendingWeave.clear(); // dont need to do those again
		this.eWorld.minicleanup();
		if (debugPipeline)System.err.println("<.weaveQueuedEntries()");
	}
================= fetch public void afterCompiling(CompilationUnitDeclaration[] units) { 9664058^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java

public void afterCompiling(CompilationUnitDeclaration[] units) {
		this.eWorld.cleanup();
		if (!weaverInitialized) { // nothing got compiled, doesnt mean there is nothing to do... (binary weaving)
			if (!(isXTerminateAfterCompilation || (reportedErrors && !proceedOnError))) {
//				acceptResult(unit.compilationResult);
//			} else {
				try {
					weaveQueuedEntries();
				} catch (IOException ex) {
					AbortCompilation ac = new AbortCompilation(null,ex);
					throw ac;
		    	}
			}
		}
		postWeave();
		try {
			// not great ... but one more check before we continue, see pr132314
			if (!reportedErrors && units!=null) {
				for (int i = 0; i < units.length; i++) {
					if (units[i]!=null && units[i].compilationResult!=null && units[i].compilationResult.hasErrors()) {
						reportedErrors = true;
						break;
					}
				}
			}
			if (isXTerminateAfterCompilation || (reportedErrors && !proceedOnError)) {
				// no point weaving... just tell the requestor we're done
				notifyRequestor();
			} else {
				// weave();  // notification happens as weave progresses...
//		        weaver.getWorld().flush(); // pr152257
			}
//		} catch (IOException ex) {
//			AbortCompilation ac = new AbortCompilation(null,ex);
//			throw ac;
		} catch (RuntimeException rEx) {
			if (rEx instanceof AbortCompilation) throw rEx; // Don't wrap AbortCompilation exceptions!

			// This will be unwrapped in Compiler.handleInternalException() and the nested
			// RuntimeException thrown back to the original caller - which is AspectJ
			// which will then then log it as a compiler problem.
			throw new AbortCompilation(true,rEx);
		}
	}
================= fetch public void beforeCompiling(ICompilationUnit[] sourceUnits) { 9664058^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java

public void beforeCompiling(ICompilationUnit[] sourceUnits) {
		resultsPendingWeave = new ArrayList();
		reportedErrors = false;		
	}
================= fetch public void testPr134471_IncrementallyRecompilingTheClassAffectedByDeclare() { 9664058^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
/**
	 * Retrieve program elements related to this one regardless of the relationship.  A JUnit assertion is
	 * made that the number that the 'expected' number are found.
	 * 
	 * @param programElement Program element whose related elements are to be found
	 * @param expected the number of expected related elements
	 */
private List/*IProgramElement*/ getRelatedElements(IProgramElement programElement,int expected) {
		List relatedElements = getRelatedElements(programElement);
		StringBuffer debugString = new StringBuffer();
		if (relatedElements!=null) {
			for (Iterator iter = relatedElements.iterator(); iter.hasNext();) {	
				String element = (String) iter.next();
				debugString.append(AsmManager.getDefault().getHierarchy().findElementForHandle(element).toLabelString()).append("\n");
			}
		}
		assertTrue("Should be "+expected+" element"+(expected>1?"s":"")+" related to this one '"+programElement+
				"' but found :\n "+debugString,relatedElements!=null && relatedElements.size()==1);
		return relatedElements;
	}
================= fetch public static void premain(String options, Instrumentation instrumentation) { bebb364^:loadtime5/java5-src/org/aspectj/weaver/loadtime/Agent.java

public static void premain(String options, Instrumentation instrumentation) {
        s_instrumentation = instrumentation;
        s_instrumentation.addTransformer(s_transformer);
    }
================= fetch public void testVerificationFailureForAspectOf_pr148693() { bebb364^:tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java

public void testMatchVolatileField_pr150671() {runTest("match volatile field");}
Progress : [################------------------------] 42%================= fetch private BcelVar generateReturnInstructions(List returns, InstructionList returnI e4ab0ae^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
/**
	 * Given a list containing all the return instruction handles for this shadow,
	 * finds the last return instruction and copies it, making this the ultimate
	 * return. If the shadow has a non-void return type, we also create a temporary
	 * variable to hold the return value, and load the value from this var before
	 * returning (see pr148007 for why we do this - it works around a JRockit bug,
	 * and is also closer to what javac generates)
	 * @param returns list of all the return instructions in the shadow
	 * @param returnInstructions instruction list into which the return instructions should
	 * be generated
	 * @return the variable holding the return value, if needed
	 */
private BcelVar generateReturnInstructions(List returns, InstructionList returnInstructions) {
		BcelVar returnValueVar = null;
    	InstructionHandle lastReturnHandle = (InstructionHandle)returns.get(returns.size() - 1);
    	Instruction newReturnInstruction = Utility.copyInstruction(lastReturnHandle.getInstruction());
    	if (this.hasANonVoidReturnType()) {
        	returnValueVar = genTempVar(this.getReturnType());
            returnValueVar.appendLoad(returnInstructions,getFactory());
    	} else {
    		returnInstructions.append(newReturnInstruction);
    	}
    	returnInstructions.append(newReturnInstruction);
    	return returnValueVar;
	}
================= fetch private List findReturnInstructions() { e4ab0ae^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
/**
	 * @return a list of all the return instructions in the range of this shadow
	 */
private List findReturnInstructions() {
		List returns = new ArrayList();
        for (InstructionHandle ih = range.getStart(); ih != range.getEnd(); ih = ih.getNext()) {
            if (ih.getInstruction() instanceof ReturnInstruction) {
                returns.add(ih);
            }
        }
		return returns;
	}
================= fetch public void removeUnnecessaryProblems(Member member, int problemLineNumber) { 54f7bb4^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseSourceContext.java

public void removeUnnecessaryProblems(Member member, int problemLineNumber) {
		if (result == null) return; 
		IProblem[] probs = result.getProblems();
		for (int i = 0; i < probs.length; i++) {
			IProblem problem = probs[i];
			if (problem == null) continue;
			if (problem.getID() == IProblem.UnusedMethodDeclaredThrownException 
					|| problem.getID() == IProblem.UnusedConstructorDeclaredThrownException) {
				if (problem.getSourceLineNumber() == problemLineNumber) {
					UnusedDeclaredThrownExceptionFilter filter = 
						new UnusedDeclaredThrownExceptionFilter(problem);
					result.removeProblems(filter);	
				}
			}
		}
	}
================= fetch public void initialize() { 397a19d^:loadtime/src/org/aspectj/weaver/loadtime/Aj.java
/**
     * Weave
     *
     * @param className
     * @param bytes
     * @param loader
     * @return weaved bytes
     */
public byte[] preProcess(String className, byte[] bytes, ClassLoader loader) {
		if (trace.isTraceEnabled()) trace.enter("preProcess",this,new Object[] {className,bytes,loader});
    	
        //TODO AV needs to doc that
        if (loader == null || className == null) {
            // skip boot loader or null classes (hibernate)
    		if (trace.isTraceEnabled()) trace.exit("preProcess",bytes);
            return bytes;
        }

        try {
            WeavingAdaptor weavingAdaptor = WeaverContainer.getWeaver(loader, weavingContext);
            if (weavingAdaptor == null) {
        		if (trace.isTraceEnabled()) trace.exit("preProcess",bytes);
            	return bytes;
            }
            return weavingAdaptor.weaveClass(className, bytes);
        } catch (Exception t) {
    		trace.error("preProcess",t);
            //FIXME AV wondering if we should have the option to fail (throw runtime exception) here
            // would make sense at least in test f.e. see TestHelper.handleMessage()
            t.printStackTrace();
    		if (trace.isTraceEnabled()) trace.exit("preProcess",bytes);
            return bytes;
        }
    }
================= fetch public boolean isBridgeMethod() { 357bbe9^:weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java

public boolean isBridgeMethod() {
    	return (modifiers & Constants.ACC_BRIDGE)!=0;
    }
================= fetch public void testVerificationFailureForAspectOf_pr148693() { 357bbe9^:tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java

public void testCantFindType_pr149322_03() {runTest("can't find type on interface call 3");}
================= fetch public static UnresolvedType forGenericTypeSignature(String sig,String declaredG 369de87^:weaver/src/org/aspectj/weaver/UnresolvedType.java

public static UnresolvedType forGenericTypeSignature(String sig,String declaredGenericSig) {
    	UnresolvedType ret = UnresolvedType.forSignature(sig);
    	ret.typeKind=TypeKind.GENERIC;
    	
    	ClassSignature csig = new GenericSignatureParser().parseAsClassSignature(declaredGenericSig);
    	
    	Signature.FormalTypeParameter[] ftps = csig.formalTypeParameters;
    	ret.typeVariables = new TypeVariable[ftps.length];
    	for (int i = 0; i < ftps.length; i++) {
			Signature.FormalTypeParameter parameter = ftps[i];
			Signature.ClassTypeSignature cts = (Signature.ClassTypeSignature)parameter.classBound;
			ret.typeVariables[i]=new TypeVariable(ftps[i].identifier,UnresolvedType.forSignature(cts.outerType.identifier+";"));
		}
    	ret.signatureErasure = sig;
    	ret.signature = ret.signatureErasure;
    	return ret;
    }
================= fetch public void testVerificationFailureForAspectOf_pr148693() { 369de87^:tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java

public void testCpathNoTypeCflowField_pr145693_3()           { runTest("cpathNoTypeCflowField"); }
Progress : [#################-----------------------] 43%================= fetch private void generateMethod(ClassFile classFile, MethodBinding methodBinding, Li 82f217f^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java
/*
	 * additionalAttributes allows us to pass some optional attributes we want to attach to the method we generate.
	 * Currently this is used for inline accessor methods that have been generated to allow private field references or
	 * private method calls to be inlined (PR71377).  In these cases the optional attribute is an effective signature
	 * attribute which means calls to these methods are able to masquerade as any join point (a field set, field get or
	 * method call).  The effective signature attribute is 'unwrapped' in BcelClassWeaver.matchInvokeInstruction()
	 */
private void generateMethod(ClassFile classFile, MethodBinding methodBinding, List additionalAttributes/*ResolvedMember realMember*/, BodyGenerator gen) {
//		EclipseFactory world = EclipseFactory.fromScopeLookupEnvironment(this.scope);
		classFile.generateMethodInfoHeader(methodBinding);
		int methodAttributeOffset = classFile.contentsOffset;
		
		int attributeNumber;
		if (additionalAttributes!=null) { // mini optimization
			List attrs = new ArrayList();
			attrs.addAll(AstUtil.getAjSyntheticAttribute());
			attrs.addAll(additionalAttributes);
			attributeNumber = classFile.generateMethodInfoAttribute(methodBinding, false, attrs);
		} else {
			attributeNumber = classFile.generateMethodInfoAttribute(methodBinding, false, AstUtil.getAjSyntheticAttribute());
		}

		int codeAttributeOffset = classFile.contentsOffset;
		classFile.generateCodeAttributeHeader();
		CodeStream codeStream = classFile.codeStream;
		
		// Use reset() rather than init()
		// XXX We need a scope to keep reset happy, initializerScope is *not* the right one, but it works !
//		 codeStream.init(classFile);
//		 codeStream.initializeMaxLocals(methodBinding);
		MethodDeclaration md = AstUtil.makeMethodDeclaration(methodBinding);
		md.scope = initializerScope;
		codeStream.reset(md,classFile);
		// body starts here
		gen.generate(codeStream);
		// body ends here
		if (codeStream.pcToSourceMapSize==0) codeStream.recordPositionsFrom(0,1);
		classFile.completeCodeAttribute(codeAttributeOffset);
		attributeNumber++;
		classFile.completeMethodInfo(methodAttributeOffset, attributeNumber);
	}
================= fetch public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r f6834c7^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java
/**
         * Extract AspectJ-specific options (except for argfiles).
         * Caller should warn when sourceroots is empty but in 
         * incremental mode.
         * Signals warnings or errors through handler set in constructor.
         */
public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.remove()
			int nextArgIndex = args.indexOf(arg)+1; // XXX assumes unique
            // trim arg?
			buildConfig.setXlazyTjp(true); // now default - MINOR could be pushed down and made default at a lower level
            if (LangUtil.isEmpty(arg)) {
                showWarning("empty arg found");
            } else if (arg.equals("-inpath")) {;
            	if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_Inpath, CompilerOptions.PRESERVE);
					
					List inPath = buildConfig.getInpath();
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
					while (st.hasMoreTokens()) {
						String filename = st.nextToken();
						File file = makeFile(filename);
						if (FileUtil.isZipFile(file)) {
							inPath.add(file);    
						} else {
							if (file.isDirectory()) {
								inPath.add(file);
							} else 
		            		
							showWarning("skipping missing, empty or corrupt inpath entry: " + filename);  
						}
					}
					buildConfig.setInPath(inPath);
					args.remove(args.get(nextArgIndex));            		
            	}
            } else if (arg.equals("-injars")) {;
				if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_InJARs, CompilerOptions.PRESERVE);
					
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
		            	if (FileUtil.isZipFile(jarFile)) {
			            	buildConfig.getInJars().add(jarFile);    
		            	} else {
		            		File dirFile = makeFile(filename);
		            		if (dirFile.isDirectory()) {
		            			buildConfig.getInJars().add(dirFile);
		            		} else 
		            		
                            showWarning("skipping missing, empty or corrupt injar: " + filename);  
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-aspectpath")) {;
				if (args.size() > nextArgIndex) {
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
                        if (FileUtil.isZipFile(jarFile) || jarFile.isDirectory()) {
			            	buildConfig.getAspectpath().add(jarFile);    
		            	} else {
                            showWarning("skipping missing, empty or corrupt aspectpath entry: " + filename);  
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-sourceroots")) {
				if (args.size() > nextArgIndex) {
					List sourceRoots = new ArrayList();
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	File f = makeFile(st.nextToken());
		            	if (f.isDirectory() && f.canRead()) {
			                sourceRoots.add(f);
		            	} else {
                            showError("bad sourceroot: " + f);
		            	}		            		
		            }
				    if (0 < sourceRoots.size()) {
						buildConfig.setSourceRoots(sourceRoots);	
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-sourceroots requires list of directories");
				}
			} else if (arg.equals("-outjar")) { 
				if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_OutJAR, CompilerOptions.GENERATE);
					File jarFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
					if (!jarFile.isDirectory()) {
						try {
							if (!jarFile.exists()) {
                                jarFile.createNewFile();
                            }
                            buildConfig.setOutputJar(jarFile);  
						} catch (IOException ioe) { 
                            showError("unable to create outjar file: " + jarFile);
						}
					} else {
						showError("invalid -outjar file: " + jarFile);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-outjar requires jar path argument");
				}
			} else if (arg.equals("-outxml")) { 
                buildConfig.setOutxmlName("META-INF/aop.xml");  
			} else if (arg.equals("-outxmlfile")) { 
				if (args.size() > nextArgIndex) {
					String name = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
	                buildConfig.setOutxmlName(name);  
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-outxmlfile requires file name argument");
				}
            } else if (arg.equals("-log")){
				// remove it as it's already been handled in org.aspectj.tools.ajc.Main
				args.remove(args.get(nextArgIndex));
            } else if (arg.equals("-messageHolder")) {
				// remove it as it's already been handled in org.aspectj.tools.ajc.Main
				args.remove(args.get(nextArgIndex));            	            
        	}else if (arg.equals("-incremental")) {
                buildConfig.setIncrementalMode(true);
            } else if (arg.equals("-XincrementalFile")) {
                if (args.size() > nextArgIndex) {
                    File file = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    buildConfig.setIncrementalFile(file);
                    if (!file.canRead()) {
                        showError("bad -XincrementalFile : " + file);
                        // if not created before recompile test, stop after first compile
                    }
                    args.remove(args.get(nextArgIndex));
                } else {
                    showError("-XincrementalFile requires file argument");
                }
			} else if (arg.equals("-crossrefs")) {
				buildConfig.setGenerateCrossRefsMode(true);
				buildConfig.setGenerateModelMode(true);
			} else if (arg.equals("-emacssym")) {
				buildConfig.setEmacsSymMode(true);
				buildConfig.setGenerateModelMode(true);
			} else if (arg.equals("-XjavadocsInModel")) {
				buildConfig.setGenerateModelMode(true);
				buildConfig.setGenerateJavadocsInModelMode(true);
			} else if (arg.equals("-Xdev:NoAtAspectJProcessing")) { 
				buildConfig.setNoAtAspectJAnnotationProcessing(true);
			} else if (arg.equals("-XaddSerialVersionUID")) {
				buildConfig.setAddSerialVerUID(true);
        	} else if (arg.equals("-Xdev:Pinpoint")) { 
				buildConfig.setXdevPinpointMode(true);
        	} else if (arg.startsWith("-Xjoinpoints:")) {
        		buildConfig.setXJoinpoints(arg.substring(13));
        	} else if (arg.equals("-noWeave") || arg.equals( "-XnoWeave")) {
				showWarning("the noweave option is no longer required and is being ignored");
        	} else if (arg.equals( "-XterminateAfterCompilation")) {
				buildConfig.setTerminateAfterCompilation(true);
			} else if (arg.equals("-XserializableAspects")) {
				buildConfig.setXserializableAspects(true);
			} else if (arg.equals("-XlazyTjp")) {
				// do nothing as this is now on by default
				showWarning("-XlazyTjp should no longer be used, build tjps lazily is now the default");
            } else if (arg.startsWith("-Xreweavable")) {
            	showWarning("-Xreweavable is on by default");
            	if (arg.endsWith(":compress")) {
            		showWarning("-Xreweavable:compress is no longer available - reweavable is now default");
            	}
			} else if (arg.startsWith("-Xset:")) {
				buildConfig.setXconfigurationInfo(arg.substring(6));
			} else if (arg.startsWith("-XnotReweavable")) {
            	buildConfig.setXnotReweavable(true);
			} else if (arg.equals("-XnoInline")) {
				buildConfig.setXnoInline(true);
            } else if (arg.equals("-XhasMember")) {
            	buildConfig.setXHasMemberSupport(true);
            }	else if (arg.startsWith("-showWeaveInfo")) {            	
            	 buildConfig.setShowWeavingInformation(true);
			} else if (arg.equals("-Xlintfile")) { 
				if (args.size() > nextArgIndex) {
					File lintSpecFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    // XXX relax restriction on props file suffix?
					if (lintSpecFile.canRead() && lintSpecFile.getName().endsWith(".properties")) {
						buildConfig.setLintSpecFile(lintSpecFile);	
					} else {
						showError("bad -Xlintfile file: " + lintSpecFile);
						buildConfig.setLintSpecFile(null);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-Xlintfile requires .properties file argument");
				}
            } else if (arg.equals("-Xlint")) {
//                buildConfig.getAjOptions().put(
//                    AjCompilerOptions.OPTION_Xlint,
//                    CompilerOptions.GENERATE);
                buildConfig.setLintMode(AjBuildConfig.AJLINT_DEFAULT);
            } else if (arg.startsWith("-Xlint:")) {
                if (7 < arg.length()) {
                    buildConfig.setLintMode(arg.substring(7));
                } else {
                    showError("invalid lint option " + arg);
                }
			} else if (arg.equals("-bootclasspath")) {
				if (args.size() > nextArgIndex) {
					String bcpArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer bcp = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(bcpArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    bcp.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        bcp.append(File.pathSeparator);
					    }
					}
					bootclasspath = bcp.toString();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-bootclasspath requires classpath entries");
				}
			} else if (arg.equals("-classpath") || arg.equals("-cp")) {
				if (args.size() > nextArgIndex) {
					String cpArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer cp = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(cpArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    cp.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        cp.append(File.pathSeparator);
					    }
					}
					classpath = cp.toString();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-classpath requires classpath entries");
				}
			} else if (arg.equals("-extdirs")) {
				if (args.size() > nextArgIndex) {
					String extdirsArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer ed = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(extdirsArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    ed.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        ed.append(File.pathSeparator);
					    }
					}					
					extdirs = ed.toString();
					args.remove(args.get(nextArgIndex));
                } else {
                    showError("-extdirs requires list of external directories");
                }
            // error on directory unless -d, -{boot}classpath, or -extdirs
            } else if (arg.equals("-d")) {
                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-classpath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-bootclasspath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-extdirs")) {
//                dirLookahead(arg, args, nextArgIndex);
            } else if (arg.equals("-proceedOnError")) {
            	buildConfig.setProceedOnError(true);
            } else if (new File(arg).isDirectory()) {
                showError("dir arg not permitted: " + arg);
            } else if (arg.startsWith("-Xajruntimetarget")) {
        		if (arg.endsWith(":1.2")) {
            		buildConfig.setTargetAspectjRuntimeLevel(Constants.RUNTIME_LEVEL_12);
        		} else if (arg.endsWith(":1.5")) {
            		buildConfig.setTargetAspectjRuntimeLevel(Constants.RUNTIME_LEVEL_15);
        		} else {
        			showError("-Xajruntimetarget:<level> only supports a target level of 1.2 or 1.5");
        		}
            } else if (arg.equals("-1.5")) {
            	buildConfig.setBehaveInJava5Way(true);
            	unparsedArgs.add("-1.5");
// this would enable the '-source 1.5' to do the same as '-1.5' but doesnt sound quite right as
// as an option right now as it doesnt mean we support 1.5 source code - people will get confused...
            } else if (arg.equals("-source")) {
            	if (args.size() > nextArgIndex) {
            		String level = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
            		if (level.equals("1.5")){
            			buildConfig.setBehaveInJava5Way(true);
            		}
            		unparsedArgs.add("-source");
            		unparsedArgs.add(level);
            		args.remove(args.get(nextArgIndex));
            	}
			} else {
                // argfile, @file parsed by superclass
                // no eclipse options parsed:
                // -d args, -help (handled), 
                // -classpath, -target, -1.3, -1.4, -source [1.3|1.4]
                // -nowarn, -warn:[...], -deprecation, -noImportError,
                // -g:[...], -preserveAllLocals,
                // -referenceInfo, -encoding, -verbose, -log, -time
                // -noExit, -repeat
				// (Actually, -noExit grabbed by Main)
		    	unparsedArgs.add(arg);
			}
        }
================= fetch private boolean enforceDecpRule4_compatibleReturnTypes(BcelClassWeaver weaver, R 2f2f568^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
/**
     * Rule 4. Can't have incompatible return types
     */
private boolean enforceDecpRule4_compatibleReturnTypes(BcelClassWeaver weaver, ResolvedMember superMethod, LazyMethodGen subMethod) {
        boolean cont = true;
        String superReturnTypeSig = superMethod.getReturnType().getSignature();
          String subReturnTypeSig   = subMethod.getReturnType().getSignature();
          if (!superReturnTypeSig.equals(subReturnTypeSig)) {
            // Allow for covariance - wish I could test this (need Java5...)
            ResolvedType subType   = weaver.getWorld().resolve(subMethod.getReturnType());
            ResolvedType superType = weaver.getWorld().resolve(superMethod.getReturnType());
            if (!superType.isAssignableFrom(subType)) {
                ISourceLocation sloc = subMethod.getSourceLocation();
                weaver.getWorld().getMessageHandler().handleMessage(MessageUtil.error(
                        "The return type is incompatible with "+superMethod.getDeclaringType()+"."+superMethod.getName()+superMethod.getParameterSignature(),
                        subMethod.getSourceLocation()));
                 cont=false;
            }
          }
        return cont;
    }
================= fetch private boolean mungeNewParent(BcelClassWeaver weaver, NewParentTypeMunger munge 2f2f568^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
/** 
     * For a long time, AspectJ did not allow binary weaving of declare parents.  This restriction is now lifted
     * but could do with more testing!
	 */
private boolean mungeNewParent(BcelClassWeaver weaver, NewParentTypeMunger munger) {
		LazyClassGen  newParentTarget = weaver.getLazyClassGen();
		ResolvedType newParent       = munger.getNewParent();
        
        boolean cont = true; // Set to false when we error, so we don't actually *do* the munge           
        cont = enforceDecpRule1_abstractMethodsImplemented(weaver, munger.getSourceLocation(),newParentTarget, newParent);
        cont = enforceDecpRule2_cantExtendFinalClass(weaver,munger.getSourceLocation(),newParentTarget,newParent) && cont;
                
        List methods = newParent.getMethodsWithoutIterator(false,true);
        for (Iterator iter = methods.iterator(); iter.hasNext();) {
		  ResolvedMember    superMethod = (ResolvedMember) iter.next();
          if (!superMethod.getName().equals("<init>")) {
		    LazyMethodGen   subMethod = findMatchingMethod(newParentTarget, superMethod);
            if (subMethod!=null && !subMethod.isBridgeMethod()) { // FIXME asc is this safe for all bridge methods?
              if (!(subMethod.isSynthetic() && superMethod.isSynthetic())) {
	              cont = enforceDecpRule3_visibilityChanges(weaver, newParent, superMethod, subMethod) && cont;
	              cont = enforceDecpRule4_compatibleReturnTypes(weaver, superMethod, subMethod)        && cont;
	              cont = enforceDecpRule5_cantChangeFromStaticToNonstatic(weaver,munger.getSourceLocation(),superMethod,subMethod) && cont;
              }
            }                
          }
        }
        if (!cont) return false; // A rule was violated and an error message already reported
             
        if (newParent.isClass()) { // Changing the supertype
             if (!attemptToModifySuperCalls(weaver,newParentTarget,newParent)) return false;
             newParentTarget.setSuperClass(newParent);
		} else { // Adding a new interface
			newParentTarget.addInterface(newParent,getSourceLocation());
		}
		return true;
	}
================= fetch public void setParameters(AbstractMethodDeclaration md, IProgramElement pe) { b59b036^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java
//	}
public void setParameters(AbstractMethodDeclaration md, IProgramElement pe) {
		Argument[] argArray = md.arguments;
		if (argArray == null) {
			pe.setParameterNames(Collections.EMPTY_LIST);
			pe.setParameterSignatures(Collections.EMPTY_LIST);
		} else {
			List names = new ArrayList();
			List paramSigs = new ArrayList();
			for (int i = 0; i < argArray.length; i++) {
				String argName = new String(argArray[i].name);
				//String argType = "<UnknownType>"; // pr135052
				if (acceptArgument(argName, argArray[i].type.toString())) {
					TypeReference typeR = argArray[i].type;
					if (typeR!=null) {
						TypeBinding typeB = typeR.resolvedType;
						if (typeB==null) {
							typeB = typeR.resolveType(md.scope);
						}
						EclipseFactory factory = EclipseFactory.fromScopeLookupEnvironment(md.scope);
						UnresolvedType ut = factory.fromBinding(typeB);
						paramSigs.add(ut.getSignature().toCharArray());
					}
					names.add(argName);
				}
			}
			pe.setParameterNames(names);
			if (!paramSigs.isEmpty()) {
				pe.setParameterSignatures(paramSigs);
			}
		}
	}
================= fetch public void acceptResult(UnwovenClassFile result) { 99d1c18^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java

public IWeaveRequestor getRequestor() {
			return new IWeaveRequestor() {

				public void acceptResult(UnwovenClassFile result) {
					if (wovenClass == null) {
						wovenClass = result;
						
						String name = result.getClassName();
						if (shouldDump(name.replace('/', '.'), false)) {
							dump(name, result.getBytes(), false);
						}
					}
					
					/* Classes generated by weaver e.g. around closure advice */
					else {
						String className = result.getClassName();
						System.err.println("? WeavingClassFileProvider.acceptResult() " + wovenClass.getClassName() + "->" + className);
						generatedClasses.put(className,result);
						generatedClasses.put(wovenClass.getClassName(),result);
						generatedClassHandler.acceptClass(className,result.getBytes());
					}
				}
Progress : [#################-----------------------] 44%================= fetch public Member makeJoinPointSignatureForArrayConstruction(LazyClassGen cg, Instru 792d1df^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java

public Member makeJoinPointSignatureForArrayConstruction(LazyClassGen cg, InstructionHandle handle) {
		Instruction i = handle.getInstruction();
		ConstantPoolGen cpg = cg.getConstantPoolGen();
		Member retval = null;

		if (i instanceof ANEWARRAY) {
			ANEWARRAY arrayInstruction = (ANEWARRAY)i;
			ObjectType ot = arrayInstruction.getLoadClassType(cpg);
			UnresolvedType ut = fromBcel(ot);
			ut = UnresolvedType.makeArray(ut,1);
			retval = MemberImpl.method(ut, Modifier.PUBLIC, ResolvedType.VOID, "<init>", new ResolvedType[]{ResolvedType.INT});
			
		} else if (i instanceof MULTIANEWARRAY) {
			MULTIANEWARRAY arrayInstruction = (MULTIANEWARRAY)i;
			UnresolvedType ut = null;
			short dimensions = arrayInstruction.getDimensions();
			ObjectType ot = arrayInstruction.getLoadClassType(cpg);
			if (ot!=null) {
				ut = fromBcel(ot);
				ut = UnresolvedType.makeArray(ut,dimensions);
			} else {
				Type t = arrayInstruction.getType(cpg);
				ut = fromBcel(t);
			}
			ResolvedType[] parms = new ResolvedType[dimensions];
			for (int ii=0;ii<dimensions;ii++) parms[ii] = ResolvedType.INT;
			retval = MemberImpl.method(ut, Modifier.PUBLIC, ResolvedType.VOID, "<init>", parms);
			
		} else if (i instanceof NEWARRAY) {
			NEWARRAY arrayInstruction = (NEWARRAY)i;
			Type ot = arrayInstruction.getType();
			UnresolvedType ut = fromBcel(ot);
			retval = MemberImpl.method(ut, Modifier.PUBLIC, ResolvedType.VOID, "<init>", new ResolvedType[]{ResolvedType.INT});
		} else {
			throw new BCException("Cannot create array construction signature for this non-array instruction:"+i);
		}
		return retval;
	}
================= fetch private NameMangler() { c9f311a^:weaver/src/org/aspectj/weaver/NameMangler.java

================= fetch private void addField(Field field) { c9f311a^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java

private void addField(Field field) {
		myGen.addField(field);
	}
================= fetch public FieldBinding internalMakeFieldBinding(ResolvedMember member,List aliases) c9f311a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java
/**
	 * Take a normal AJ member and convert it into an eclipse fieldBinding.
	 * Taking into account any aliases that it may include due to being
	 * a generic itd.  Any aliases are put into the typeVariableToBinding
	 * map so that they will be substituted as appropriate in the returned
	 * fieldbinding.
	 */
public FieldBinding internalMakeFieldBinding(ResolvedMember member,List aliases) {
		typeVariableToTypeBinding.clear();
		TypeVariableBinding[] tvbs = null;
		
		ReferenceBinding declaringType = (ReferenceBinding)makeTypeBinding(member.getDeclaringType());
		
		// If there are aliases, place them in the map
		if (aliases!=null && aliases.size()>0) {
			int i =0;
			for (Iterator iter = aliases.iterator(); iter.hasNext();) {
				String element = (String) iter.next();
				typeVariableToTypeBinding.put(element,declaringType.typeVariables()[i++]);
			}
		}
		
		currentType = declaringType;
		FieldBinding fb =  new FieldBinding(member.getName().toCharArray(),
				makeTypeBinding(member.getReturnType()),
				member.getModifiers(),
				currentType,
				Constant.NotAConstant);
		typeVariableToTypeBinding.clear();
		currentType = null;
		return fb;
	}
================= fetch public MethodBinding internalMakeMethodBinding(ResolvedMember member,List aliase c9f311a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java
//	}
private TypeVariableBinding[] makeTypeVariableBindingsFromAJTypeVariables(TypeVariable[] typeVariables) {
		int len = typeVariables.length;
		TypeVariableBinding[] ret = new TypeVariableBinding[len];
		for (int i = 0; i < len; i++) {
			ret[i] = makeTypeVariableBindingFromAJTypeVariable(typeVariables[i]);
		}
		return ret;
	}
================= fetch public MethodGen pack() { c9f311a^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
// ---- packing!
public MethodGen pack() {
    	//killNops();
    	int flags = getAccessFlags();
    	if (enclosingClass.getWorld().isJoinpointSynchronizationEnabled()) {
    	    flags = getAccessFlagsWithoutSynchronized();
    	}
        MethodGen gen =
            new MethodGen(
                flags,
                getReturnType(),
                getArgumentTypes(),
                null, //getArgumentNames(),
                getName(),
                getEnclosingClass().getName(),
                new InstructionList(),
                getEnclosingClass().getConstantPoolGen());
        for (int i = 0, len = declaredExceptions.length; i < len; i++) {
            gen.addException(declaredExceptions[i]);
        }
        
        for (int i = 0, len = attributes.length; i < len; i++) {
            gen.addAttribute(attributes[i]);
        }
        
        if (newAnnotations!=null) { 
			for (Iterator iter = newAnnotations.iterator(); iter.hasNext();) {
				AnnotationX element = (AnnotationX) iter.next();
				gen.addAnnotation(new AnnotationGen(element.getBcelAnnotation(),gen.getConstantPool(),true));
			}
        }
		
        if (memberView!=null && memberView.getAnnotations()!=null && memberView.getAnnotations().length!=0) {
		  AnnotationX[] ans = memberView.getAnnotations();
          for (int i = 0, len = ans.length; i < len; i++) {
			Annotation a= ans[i].getBcelAnnotation();
            gen.addAnnotation(new AnnotationGen(a,gen.getConstantPool(),true));
          }
        }
        
        if (isSynthetic) {
			ConstantPoolGen cpg = gen.getConstantPool();
			int index = cpg.addUtf8("Synthetic");
			gen.addAttribute(new Synthetic(index, 0, new byte[0], cpg.getConstantPool()));
        }
        
        if (hasBody()) {
            packBody(gen);
            gen.setMaxLocals();
            gen.setMaxStack();
        } else {
        	gen.setInstructionList(null);
        }
        return gen;
    }
================= fetch public void generateCode(ClassScope classScope, ClassFile classFile) { c9f311a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/DeclareDeclaration.java
/**
	 * A declare declaration exists in a classfile only as an attibute on the
	 * class.  Unlike advice and inter-type declarations, it has no corresponding
	 * method.
	 * **AMC** changed the above policy in the case of declare annotation, which uses a 
	 * corresponding method as the anchor for the declared annotation
	 */
public void generateCode(ClassScope classScope, ClassFile classFile) {
		classFile.extraAttributes.add(new EclipseAttributeAdapter(new AjAttribute.DeclareAttribute(declareDecl)));
		if (shouldDelegateCodeGeneration()) {
			super.generateCode(classScope,classFile);
		}
		return;
	}
================= fetch public void generateCode(ClassScope classScope, ClassFile classFile) { c9f311a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java
/**
	 * A pointcut declaration exists in a classfile only as an attibute on the
	 * class.  Unlike advice and inter-type declarations, it has no corresponding
	 * method.
	 */
public void generateCode(ClassScope classScope, ClassFile classFile) {
    	this.world = EclipseFactory.fromScopeLookupEnvironment(classScope);
		if (ignoreFurtherInvestigation) return ;
		classFile.extraAttributes.add(new EclipseAttributeAdapter(makeAttribute()));
		addVersionAttributeIfNecessary(classFile);
		
		if (generateSyntheticPointcutMethod) {
			super.generateCode(classScope,classFile);
		}
		return;
	}
================= fetch public void resolveStatements() { c9f311a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AdviceDeclaration.java
// override
public void resolveStatements() {
		if (binding == null || ignoreFurtherInvestigation) return;
		
		ClassScope upperScope = (ClassScope)scope.parent;  //!!! safety
		
		modifiers = checkAndSetModifiers(modifiers, upperScope);
		int bindingModifiers = (modifiers | (binding.modifiers & AccGenericSignature));
		binding.modifiers = bindingModifiers;
		
		if (kind == AdviceKind.AfterThrowing && extraArgument != null) {
			TypeBinding argTb = extraArgument.binding.type;
			TypeBinding expectedTb = upperScope.getJavaLangThrowable();
			if (!argTb.isCompatibleWith(expectedTb)) {
				scope.problemReporter().typeMismatchError(argTb, expectedTb, extraArgument);
				ignoreFurtherInvestigation = true;
				return;
			}
		}
		
		
		pointcutDesignator.finishResolveTypes(this, this.binding, 
			baseArgumentCount, upperScope.referenceContext.binding);
		
		if (binding == null || ignoreFurtherInvestigation) return;
		
		if (kind == AdviceKind.Around) {
			ReferenceBinding[] exceptions = 
				new ReferenceBinding[] { upperScope.getJavaLangThrowable() };
			proceedMethodBinding = new MethodBinding(Modifier.STATIC,
				"proceed".toCharArray(), binding.returnType,
				resize(baseArgumentCount+1, binding.parameters),
				exceptions, binding.declaringClass);
			proceedMethodBinding.selector =
				CharOperation.concat(selector, proceedMethodBinding.selector);
		}
		
		super.resolveStatements(); //upperScope);
		if (binding != null) determineExtraArgumentFlags();
		
		if (kind == AdviceKind.Around) {
			int n = proceedCalls.size();
//			EclipseFactory world = EclipseFactory.fromScopeLookupEnvironment(upperScope);
						
			//System.err.println("access to: " + Arrays.asList(handler.getMembers()));
			
			//XXX set these correctly
			formalsUnchangedToProceed = new boolean[baseArgumentCount];
			proceedCallSignatures = new ResolvedMember[0];
			proceedInInners = false;
			declaredExceptions = new UnresolvedType[0];
			
			for (int i=0; i < n; i++) {
				Proceed call = (Proceed)proceedCalls.get(i);
				if (call.inInner) {
					//System.err.println("proceed in inner: " + call);
					proceedInInners = true;
					//XXX wrong
					//proceedCallSignatures[i] = world.makeResolvedMember(call.binding);
				}
			}
			
			// ??? should reorganize into AspectDeclaration
			// if we have proceed in inners we won't ever be inlined so the code below is unneeded
			if (!proceedInInners) {
				PrivilegedHandler handler = (PrivilegedHandler)upperScope.referenceContext.binding.privilegedHandler;
				if (handler == null) {
					handler = new PrivilegedHandler((AspectDeclaration)upperScope.referenceContext);
					//upperScope.referenceContext.binding.privilegedHandler = handler;
				}
				
				this.traverse(new MakeDeclsPublicVisitor(), (ClassScope)null);
				
				AccessForInlineVisitor v = new AccessForInlineVisitor((AspectDeclaration)upperScope.referenceContext, handler);
				ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.ACCESS_FOR_INLINE, selector);
				this.traverse(v, (ClassScope) null);
				CompilationAndWeavingContext.leavingPhase(tok);
				
				// ??? if we found a construct that we can't inline, set
				//     proceedInInners so that we won't try to inline this body
				if (!v.isInlinable) proceedInInners = true;
			}
		}
	}
================= fetch public static void replaceInstruction( 426cbdc^:weaver/src/org/aspectj/weaver/bcel/Utility.java
/**
	 * replace an instruction handle with another instruction, in this case, a branch instruction.
	 * 
	 * @param ih the instruction handle to replace.
	 * @param branchInstruction the branch instruction to replace ih with
	 * @param enclosingMethod where to find ih's instruction list.
	 */
public static void replaceInstruction(
        InstructionHandle ih,
        BranchInstruction branchInstruction,
        LazyMethodGen enclosingMethod) 
    {
        
        InstructionList il = enclosingMethod.getBody();
        InstructionHandle fresh = il.append(ih, branchInstruction);
		deleteInstruction(ih, fresh, enclosingMethod);
    }
================= fetch public void weaveAfterReturning(BcelAdvice munger) { 426cbdc^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
/**
	 * We guarantee that the return value is on the top of the stack when
	 * munger.getAdviceInstructions() will be run
	 * (Unless we have a void return type in which case there's nothing)
	 */
public void weaveAfterReturning(BcelAdvice munger) {
        // InstructionFactory fact = getFactory();
        List returns = new ArrayList();
        Instruction ret = null;
        for (InstructionHandle ih = range.getStart(); ih != range.getEnd(); ih = ih.getNext()) {
            if (ih.getInstruction() instanceof ReturnInstruction) {
                returns.add(ih);
                ret = Utility.copyInstruction(ih.getInstruction());
            }
        }
        InstructionList retList;
        InstructionHandle afterAdvice;
        if (ret != null) {
            retList = new InstructionList(ret);
            afterAdvice = retList.getStart();
        } else /* if (munger.hasDynamicTests()) */ {
        	/*
        	 * 
 27:  getstatic       #72; //Field ajc$cflowCounter$0:Lorg/aspectj/runtime/internal/CFlowCounter;
 30:  invokevirtual   #87; //Method org/aspectj/runtime/internal/CFlowCounter.dec:()V
 33:  aload   6
 35:  athrow
 36:  nop
 37:  getstatic       #72; //Field ajc$cflowCounter$0:Lorg/aspectj/runtime/internal/CFlowCounter;
 40:  invokevirtual   #87; //Method org/aspectj/runtime/internal/CFlowCounter.dec:()V
 43:  d2i
 44:  invokespecial   #23; //Method java/lang/Object."<init>":()V
        	 */
            retList = new InstructionList(InstructionConstants.NOP);            
            afterAdvice = retList.getStart();
//        } else {
//        	retList = new InstructionList();
//        	afterAdvice = null;
        }

        InstructionList advice = new InstructionList();
        BcelVar tempVar = null;
        if (munger.hasExtraParameter()) {
            UnresolvedType tempVarType = getReturnType();
            if (tempVarType.equals(ResolvedType.VOID)) {
            	tempVar = genTempVar(UnresolvedType.OBJECT);
            	advice.append(InstructionConstants.ACONST_NULL);
            	tempVar.appendStore(advice, getFactory());
            } else {
	            tempVar = genTempVar(tempVarType);
	            advice.append(InstructionFactory.createDup(tempVarType.getSize()));
	            tempVar.appendStore(advice, getFactory());
            }
        }
        advice.append(munger.getAdviceInstructions(this, tempVar, afterAdvice));            

        if (ret != null) {
            InstructionHandle gotoTarget = advice.getStart();           
			for (Iterator i = returns.iterator(); i.hasNext();) {
				InstructionHandle ih = (InstructionHandle) i.next();
				Utility.replaceInstruction(
					ih,
					InstructionFactory.createBranchInstruction(
						Constants.GOTO,
						gotoTarget),
					enclosingMethod);
			}
            range.append(advice);
            range.append(retList);
        } else {            
            range.append(advice);
            range.append(retList);
        }
    }
================= fetch private static ResolvedMember isOverriding(ResolvedType typeToCheck,ResolvedMemb 13dde4e^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
     * Check if a particular method is overriding another - refactored into this helper so it
     * can be used from multiple places.
     */
private static ResolvedMember isOverriding(ResolvedType typeToCheck,ResolvedMember methodThatMightBeGettingOverridden,String mname,String mrettype,int mmods,boolean inSamePackage,UnresolvedType[] methodParamsArray) {
		// Check if we can be an override...
		if (methodThatMightBeGettingOverridden.isStatic()) return null; // we can't be overriding a static method
		if (methodThatMightBeGettingOverridden.isPrivate())  return null; // we can't be overriding a private method
		if (!methodThatMightBeGettingOverridden.getName().equals(mname))  return null; // names dont match (this will also skip <init> and <clinit> too)
		if (methodThatMightBeGettingOverridden.getParameterTypes().length!=methodParamsArray.length)  return null; // check same number of parameters
		if (!isVisibilityOverride(mmods,methodThatMightBeGettingOverridden,inSamePackage))  return null;
	
		if (debug) System.err.println("  Seriously considering this might be getting overridden "+methodThatMightBeGettingOverridden);
		
		// Look at erasures of parameters (List<String> erased is List)
		boolean sameParams = true;
		for (int p = 0;p<methodThatMightBeGettingOverridden.getParameterTypes().length;p++) {
		  if (!methodThatMightBeGettingOverridden.getParameterTypes()[p].getErasureSignature().equals(methodParamsArray[p].getErasureSignature())) sameParams = false;
		}
		
		// If the 'typeToCheck' represents a parameterized type then the method will be the parameterized form of the
		// generic method in the generic type.  So if the method was 'void m(List<T> lt, T t)' and the parameterized type here
		// is I<String> then the method we are looking at will be 'void m(List<String> lt, String t)' which when erased
		// is 'void m(List lt,String t)' - so if the parameters *do* match then there is a generic method we are
		// overriding
		
	    if (sameParams) {		    	
	    	// check for covariance
	    	if (typeToCheck.isParameterizedType()) {
				return methodThatMightBeGettingOverridden.getBackingGenericMember();
	    	} else if (!methodThatMightBeGettingOverridden.getReturnType().getErasureSignature().equals(mrettype)) {
	    		return methodThatMightBeGettingOverridden; // covariance
	    	}
	    } 
	    return null;
    }
================= fetch private static void createBridgeMethod(BcelWorld world, LazyMethodGen whatToBrid 13dde4e^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
	 * Create a single bridge method called 'theBridgeMethod' that bridges to 'whatToBridgeTo'
	 */
private static void createBridgeMethod(BcelWorld world, LazyMethodGen whatToBridgeToMethodGen, LazyClassGen clazz,ResolvedMember theBridgeMethod) {
		InstructionList body;
		InstructionFactory fact;
		int pos = 0;

		ResolvedMember whatToBridgeTo = whatToBridgeToMethodGen.getMemberView();
		
		if (whatToBridgeTo==null) {
			whatToBridgeTo = 
			  new ResolvedMemberImpl(Member.METHOD,
				whatToBridgeToMethodGen.getEnclosingClass().getType(),
				whatToBridgeToMethodGen.getAccessFlags(),
				whatToBridgeToMethodGen.getName(),
				whatToBridgeToMethodGen.getSignature());
		}
		LazyMethodGen bridgeMethod = makeBridgeMethod(clazz,theBridgeMethod); // The bridge method in this type will have the same signature as the one in the supertype
		bridgeMethod.setAccessFlags(bridgeMethod.getAccessFlags() | 0x00000040 /*BRIDGE    = 0x00000040*/ );
		Type returnType   = BcelWorld.makeBcelType(theBridgeMethod.getReturnType());
		Type[] paramTypes = BcelWorld.makeBcelTypes(theBridgeMethod.getParameterTypes());
		Type[] newParamTypes=whatToBridgeToMethodGen.getArgumentTypes();
		body = bridgeMethod.getBody();
		fact = clazz.getFactory();

		if (!whatToBridgeToMethodGen.isStatic()) {
		   body.append(InstructionFactory.createThis());
		   pos++;
		}
		for (int i = 0, len = paramTypes.length; i < len; i++) {
		  Type paramType = paramTypes[i];
		  body.append(InstructionFactory.createLoad(paramType, pos));
		  if (!newParamTypes[i].equals(paramTypes[i])) {
			  if (debug) System.err.println("Cast "+newParamTypes[i]+" from "+paramTypes[i]);
			  body.append(fact.createCast(paramTypes[i],newParamTypes[i]));
		  }
		  pos+=paramType.getSize();
		}

		body.append(Utility.createInvoke(fact, world,whatToBridgeTo));
		body.append(InstructionFactory.createReturn(returnType));
		clazz.addMethodGen(bridgeMethod);
	}
================= fetch public Properties getExtraConfiguration() { 13dde4e^:weaver/src/org/aspectj/weaver/World.java
/**
	 * may return null
	 */
public Properties getExtraConfiguration() {
		return extraConfiguration;
	}
================= fetch public boolean weave() { 13dde4e^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
// ----
public boolean weave() {
        if (clazz.isWoven() && !clazz.isReweavable()) {
        	world.showMessage(IMessage.ERROR, 
        		  WeaverMessages.format(WeaverMessages.ALREADY_WOVEN,clazz.getType().getName()),
				ty.getSourceLocation(), null);
        	return false;
        }
       

        Set aspectsAffectingType = null;
        if (inReweavableMode || clazz.getType().isAspect()) aspectsAffectingType = new HashSet();
        
        boolean isChanged = false;
        
        // we want to "touch" all aspects
        if (clazz.getType().isAspect()) isChanged = true;

        // start by munging all typeMungers
        for (Iterator i = typeMungers.iterator(); i.hasNext(); ) {
        	Object o = i.next();
        	if ( !(o instanceof BcelTypeMunger) ) {
        		//???System.err.println("surprising: " + o);
        		continue;
        	}
        	BcelTypeMunger munger = (BcelTypeMunger)o;
        	boolean typeMungerAffectedType = munger.munge(this);
        	if (typeMungerAffectedType) {
        		isChanged = true;
        		if (inReweavableMode || clazz.getType().isAspect()) aspectsAffectingType.add(munger.getAspectType().getName());
        	}
        }



        // Weave special half type/half shadow mungers... 
        isChanged = weaveDeclareAtMethodCtor(clazz) || isChanged;
        isChanged = weaveDeclareAtField(clazz)      || isChanged;
        
        // XXX do major sort of stuff
        // sort according to:  Major:  type hierarchy
        //                     within each list:  dominates
        // don't forget to sort addedThisInitialiers according to dominates
        addedSuperInitializersAsList = new ArrayList(addedSuperInitializers.values());
        addedSuperInitializersAsList = PartialOrder.sort(addedSuperInitializersAsList);        
        if (addedSuperInitializersAsList == null) {
        	throw new BCException("circularity in inter-types");
        }
      
        // this will create a static initializer if there isn't one
        // this is in just as bad taste as NOPs
        LazyMethodGen staticInit = clazz.getStaticInitializer();
        staticInit.getBody().insert(genInitInstructions(addedClassInitializers, true));
        
        // now go through each method, and match against each method.  This
        // sets up each method's {@link LazyMethodGen#matchedShadows} field, 
        // and it also possibly adds to {@link #initializationShadows}.
        List methodGens = new ArrayList(clazz.getMethodGens());
        for (Iterator i = methodGens.iterator(); i.hasNext();) {
            LazyMethodGen mg = (LazyMethodGen)i.next();
			if (! mg.hasBody()) continue;
			if (world.isJoinpointSynchronizationEnabled() && 
				world.areSynchronizationPointcutsInUse() && 
				mg.getMethod().isSynchronized()) {
				transformSynchronizedMethod(mg);
			}
			boolean shadowMungerMatched = match(mg);
			if (shadowMungerMatched) {
				// For matching mungers, add their declaring aspects to the list that affected this type
				if (inReweavableMode || clazz.getType().isAspect()) aspectsAffectingType.addAll(findAspectsForMungers(mg));
              isChanged = true;
			}
        }

        // now we weave all but the initialization shadows
		for (Iterator i = methodGens.iterator(); i.hasNext();) {
			LazyMethodGen mg = (LazyMethodGen)i.next();
			if (! mg.hasBody()) continue;
			implement(mg);
		}
			
        // if we matched any initialization shadows, we inline and weave
		if (!initializationShadows.isEmpty()) {
			// Repeat next step until nothing left to inline...cant go on 
			// infinetly as compiler will have detected and reported 
			// "Recursive constructor invocation"
			while (inlineSelfConstructors(methodGens));
			positionAndImplement(initializationShadows);
		}
		
        // now proceed with late type mungers
        if (lateTypeMungers != null) {
            for (Iterator i = lateTypeMungers.iterator(); i.hasNext(); ) {
                BcelTypeMunger munger = (BcelTypeMunger)i.next();
                if (munger.matches(clazz.getType())) {
                    boolean typeMungerAffectedType = munger.munge(this);
                    if (typeMungerAffectedType) {
                        isChanged = true;
                        if (inReweavableMode || clazz.getType().isAspect()) aspectsAffectingType.add(munger.getAspectType().getName());
                    }
                }
            }
        }

        //FIXME AV - see #75442, for now this is not enough to fix the bug, comment that out until we really fix it
//        // flush to save some memory
//        PerObjectInterfaceTypeMunger.unregisterFromAsAdvisedBy(clazz.getType());

		// finally, if we changed, we add in the introduced methods.
        if (isChanged) {
        	clazz.getOrCreateWeaverStateInfo(inReweavableMode);
			weaveInAddedMethods(); // FIXME asc are these potentially affected by declare annotation?
        }
        
        if (inReweavableMode) {
        	WeaverStateInfo wsi = clazz.getOrCreateWeaverStateInfo(true);
        	wsi.addAspectsAffectingType(aspectsAffectingType);
        	wsi.setUnwovenClassFileData(ty.getJavaClass().getBytes());
        	wsi.setReweavable(true);
        } else {
        	clazz.getOrCreateWeaverStateInfo(false).setReweavable(false);
        }
        
        return isChanged;
    }
================= fetch public static ResolvedMember checkForOverride(ResolvedType typeToCheck,String mn 13dde4e^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
     * This method recurses up a specified type looking for a method that overrides the one passed in.
     * 
     * @return the method being overridden or null if none is found
     */
public static ResolvedMember checkForOverride(ResolvedType typeToCheck,String mname,String mparams,String mrettype,int mmods,String mpkg,UnresolvedType[] methodParamsArray) {

    	if (typeToCheck==null) return null;
    	if (typeToCheck instanceof MissingResolvedTypeWithKnownSignature) return null; // we just can't tell !
    	
    	if (debug) System.err.println("  Checking for override of "+mname+" in "+typeToCheck);
    	
    	String packageName = typeToCheck.getPackageName();
    	if (packageName==null) packageName="";
    	boolean inSamePackage = packageName.equals(mpkg); // used when looking at visibility rules
    	
    	ResolvedMember [] methods = typeToCheck.getDeclaredMethods();
    	for (int ii=0;ii<methods.length;ii++) {
			ResolvedMember methodThatMightBeGettingOverridden = methods[ii]; // the method we are going to check			
			ResolvedMember isOverriding = isOverriding(typeToCheck,methodThatMightBeGettingOverridden,mname,mrettype,mmods,inSamePackage,methodParamsArray);
			if (isOverriding!=null) return isOverriding;
		}
		List l = typeToCheck.getInterTypeMungers();
		for (Iterator iterator = l.iterator(); iterator.hasNext();) {
			Object o = iterator.next();
			// FIXME asc if its not a BcelTypeMunger then its an EclipseTypeMunger ... do I need to worry about that?
			if (o instanceof BcelTypeMunger) {
				BcelTypeMunger element = (BcelTypeMunger)o;
				if (element.getMunger() instanceof NewMethodTypeMunger) {
					if (debug) System.err.println("Possible ITD candidate "+element);
					ResolvedMember aMethod = element.getSignature();
					ResolvedMember isOverriding = isOverriding(typeToCheck,aMethod,mname,mrettype,mmods,inSamePackage,methodParamsArray);
					if (isOverriding!=null) return isOverriding;
				}
			}
		}
		
		
		if (typeToCheck.equals(UnresolvedType.OBJECT)) return null; 
		
	    ResolvedType superclass = typeToCheck.getSuperclass();
		ResolvedMember overriddenMethod = checkForOverride(superclass,mname,mparams,mrettype,mmods,mpkg,methodParamsArray);
		if (overriddenMethod!=null) return overriddenMethod;
	    
		ResolvedType[] interfaces = typeToCheck.getDeclaredInterfaces();
		for (int i = 0; i < interfaces.length; i++) {
			ResolvedType anInterface = interfaces[i];
			overriddenMethod = checkForOverride(anInterface,mname,mparams,mrettype,mmods,mpkg,methodParamsArray);
			if (overriddenMethod!=null) return overriddenMethod;
		}
		return null;
    }
================= fetch public static boolean calculateAnyRequiredBridgeMethods(BcelWorld world,LazyClas 13dde4e^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
     * We need to determine if any methods in this type require bridge methods - this method should only
     * be called if necessary to do this calculation, i.e. we are on a 1.5 VM (where covariance/generics exist) and
     * the type hierarchy for the specified class has changed (via decp/itd).
     * 
     * See pr108101
     */
public static boolean calculateAnyRequiredBridgeMethods(BcelWorld world,LazyClassGen clazz) {
		if (!world.isInJava5Mode()) return false; // just double check... the caller should have already verified this
		if (clazz.isInterface()) return false; // dont bother if we're an interface
		boolean didSomething=false; // set if we build any bridge methods
		
		// So what methods do we have right now in this class?
		List /*LazyMethodGen*/ methods = clazz.getMethodGens();

		// Keep a set of all methods from this type - it'll help us to check if bridge methods 
		// have already been created, we don't want to do it twice!
		Set methodsSet = new HashSet();
		for (int i = 0; i < methods.size(); i++) {
			LazyMethodGen aMethod = (LazyMethodGen)methods.get(i);
			methodsSet.add(aMethod.getName()+aMethod.getSignature()); // e.g. "foo(Ljava/lang/String;)V"
		}
		
		// Now go through all the methods in this type
		for (int i = 0; i < methods.size(); i++) {
			
			// This is the local method that we *might* have to bridge to
			LazyMethodGen bridgeToCandidate  = (LazyMethodGen)methods.get(i);
			if (bridgeToCandidate.isBridgeMethod()) continue; // Doh!
			String name  = bridgeToCandidate.getName();
			String psig  = bridgeToCandidate.getParameterSignature();
			String rsig  = bridgeToCandidate.getReturnType().getSignature();
			
			//if (bridgeToCandidate.isAbstract()) continue;
			if (bridgeToCandidate.isStatic())      continue; // ignore static methods
			if (name.endsWith("init>")) continue; // Skip constructors and static initializers

			if (debug) System.err.println("Determining if we have to bridge to "+clazz.getName()+"."+name+""+bridgeToCandidate.getSignature());
			
			// Let's take a look at the superclass
			ResolvedType theSuperclass= clazz.getSuperClass();
			if (debug) System.err.println("Checking supertype "+theSuperclass);
			String pkgName = clazz.getPackageName();
			UnresolvedType[] bm = BcelWorld.fromBcel(bridgeToCandidate.getArgumentTypes());
			ResolvedMember overriddenMethod = checkForOverride(theSuperclass,name,psig,rsig,bridgeToCandidate.getAccessFlags(),pkgName,bm);
			if (overriddenMethod!=null) { 
				boolean alreadyHaveABridgeMethod = methodsSet.contains(overriddenMethod.getName()+overriddenMethod.getSignature());
				if (!alreadyHaveABridgeMethod) {
					if (debug) System.err.println("Bridging to "+overriddenMethod);
					createBridgeMethod(world, bridgeToCandidate, clazz, overriddenMethod);
					didSomething = true;
					continue; // look at the next method
				}
			}

			// Check superinterfaces
			String[] interfaces = clazz.getInterfaceNames();
			for (int j = 0; j < interfaces.length; j++) {
				if (debug) System.err.println("Checking superinterface "+interfaces[j]);
				ResolvedType interfaceType = world.resolve(interfaces[j]);
				overriddenMethod = checkForOverride(interfaceType,name,psig,rsig,bridgeToCandidate.getAccessFlags(),clazz.getPackageName(),bm);
				if (overriddenMethod!=null) { 
					boolean alreadyHaveABridgeMethod = methodsSet.contains(overriddenMethod.getName()+overriddenMethod.getSignature());
					if (!alreadyHaveABridgeMethod) {
						createBridgeMethod(world, bridgeToCandidate, clazz, overriddenMethod);
						didSomething=true;
						if (debug) System.err.println("Bridging to "+overriddenMethod);
						continue; // look at the next method
					}	
				}
			}
		}

		return didSomething;
	}
================= fetch public void ensureAdvancedConfigurationProcessed() { 13dde4e^:weaver/src/org/aspectj/weaver/World.java

public void ensureAdvancedConfigurationProcessed() {
	    	// Check *once* whether the user has switched asm support off
	    	if (!checkedAdvancedConfiguration) {
	        	Properties p = getExtraConfiguration();
	        	if (p!=null) {
	        		
				if (isASMAround) { // dont bother if its not...
	        		String s = p.getProperty(xsetACTIVATE_LIGHTWEIGHT_DELEGATES,"true");
	        		fastDelegateSupportEnabled = s.equalsIgnoreCase("true");
	        		if (!fastDelegateSupportEnabled) 
	        			getMessageHandler().handleMessage(MessageUtil.info("[activateLightweightDelegates=false] Disabling optimization to use lightweight delegates for non-woven types"));
				}
				
				String s = p.getProperty(xsetRUN_MINIMAL_MEMORY,"false");
	        		runMinimalMemory = s.equalsIgnoreCase("true");
//	        		if (runMinimalMemory) 
//	        			getMessageHandler().handleMessage(MessageUtil.info("[runMinimalMemory=true] Optimizing bcel processing (and cost of performance) to use less memory"));
	        		
	        		
	        		s = p.getProperty(xsetDEBUG_STRUCTURAL_CHANGES_CODE,"false");
	        		forDEBUG_structuralChangesCode = s.equalsIgnoreCase("true");
	        		
	    		}
	        	checkedAdvancedConfiguration=true;
        }
     }
================= fetch private boolean matchingBounds(TypeVariableReferenceType tvrt) { 791f8a7^:weaver/src/org/aspectj/weaver/TypeVariable.java
// XXX what about interfaces?
private boolean matchingBounds(TypeVariableReferenceType tvrt) {
		if (tvrt.getUpperBound() != getUpperBound()) return false;
		if (tvrt.hasLowerBound() != (getLowerBound() != null)) return false;
		if (tvrt.hasLowerBound() && tvrt.getLowerBound() != getLowerBound()) return false;
		// either we both have bounds, or neither of us have bounds
		if ((tvrt.additionalInterfaceBounds != null) != (additionalInterfaceBounds != null)) return false;
		if (additionalInterfaceBounds != null) {
			// we both have bounds, compare
			if (tvrt.additionalInterfaceBounds.length != additionalInterfaceBounds.length) return false;
			Set aAndNotB = new HashSet();
			Set bAndNotA = new HashSet();
			for (int i = 0; i < additionalInterfaceBounds.length; i++) {
				aAndNotB.add(additionalInterfaceBounds[i]);
			}
			for (int i = 0; i < tvrt.additionalInterfaceBounds.length; i++) {
				bAndNotA.add(tvrt.additionalInterfaceBounds[i]);
			}
			for (int i = 0; i < additionalInterfaceBounds.length; i++) {
				bAndNotA.remove(additionalInterfaceBounds[i]);
			}
			for (int i = 0; i < tvrt.additionalInterfaceBounds.length; i++) {
				aAndNotB.remove(tvrt.additionalInterfaceBounds[i]);
			}
			if (! (aAndNotB.isEmpty() && bAndNotA.isEmpty()) ) return false;
		}
		return true;
	}
================= fetch public String toString() { 008efca^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java

private static File isAspectjtoolsjar(String path) {
        if (null == path) {
            return null;
        }
        final String prefix = "aspectj";        
        final String infix = "tools";        
        final String altInfix = "-tools";        
        final String suffix = ".jar";
        final int prefixLength = 7; // prefix.length();
        final int minLength = 16;
        // prefixLength + infix.length() + suffix.length();        
        if (!path.endsWith(suffix)) {
            return null;
        }
        int loc = path.lastIndexOf(prefix);
        if ((-1 != loc) && ((loc + minLength) <= path.length())) {
            String rest = path.substring(loc+prefixLength);
            if (-1 != rest.indexOf(File.pathSeparator)) {
                return null;
            }
            if (rest.startsWith(infix)
                || rest.startsWith(altInfix)) {
                File result = new File(path);
                if (result.canRead() && result.isFile()) {
                    return result;
                }
            }
        }        
        return null;
    }
================= fetch public void execute() throws BuildException { 008efca^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
/**
     * Compile using ajc per settings.
     * @exception BuildException if the compilation has problems
     *             or if there were compiler errors and failonerror is true.
     */
public void execute() throws BuildException {
    	this.logger = new TaskLogger(this);
        if (executing) {
            throw new IllegalStateException("already executing");
        } else {
            executing = true;
        }
        setupOptions();
        verifyOptions();
        try {
            String[] args = makeCommand();
            logVerbose("ajc " + Arrays.asList(args));
            if (!fork) {
                executeInSameVM(args);
            } else { // when forking, Adapter handles failonerror
                executeInOtherVM(args);
            }
        } catch (BuildException e) {
            throw e;
        } catch (Throwable x) {
        	this.logger.error(Main.renderExceptionForUser(x));
            throw new BuildException("IGNORE -- See " 
            	+ LangUtil.unqualifiedClassName(x) 
            	+ " rendered to ant logger");
        } finally {
            executing = false;
            if (null != tmpOutjar) {
                tmpOutjar.delete();
            }
        }        
    }
================= fetch public void setIncremental(boolean incremental) { 008efca^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java

public void setIncremental(boolean incremental) {  
        cmd.addFlag("-incremental", incremental);
        inIncrementalMode = incremental;
    }
================= fetch public void testNoSuchFile() { 008efca^:taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java

public void testNoSuchFile() {
		AjcTask task = getTask("NoSuchFile.lst");
		task.setFailonerror(false);
		runTest(task, NO_EXCEPTION, MessageHolderChecker.ONE_ERROR_ONE_ABORT);
	}
Progress : [##################----------------------] 45%================= fetch private String getFilename(String hid) { 38cc0dd^:asm/src/org/aspectj/asm/AsmManager.java
// XXX shouldn't be aware of the delimiter
private String getFilename(String hid) {
		return hid.substring(0,hid.indexOf("|"));
	}
================= fetch private String getFilename(String hid) { 38cc0dd^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java
// XXX shouldn't be aware of the delimiter
private String getFilename(String hid) {
		return hid.substring(0,hid.indexOf("|"));
	}
================= fetch private void dumprelsStderr(String key) { 38cc0dd^:asm/src/org/aspectj/asm/AsmManager.java

private void dumprelsStderr(String key) {
		System.err.println("Relationships dump follows: "+key);
		IRelationshipMap irm = AsmManager.getDefault().getRelationshipMap();
		int ctr = 1;
		Set entries = irm.getEntries();
		for (Iterator iter = entries.iterator(); iter.hasNext();) {
			String hid = (String) iter.next();
			List rels =  irm.get(hid);
			for (Iterator iterator = rels.iterator(); iterator.hasNext();) {
				IRelationship ir = (IRelationship) iterator.next();
				List targets = ir.getTargets();
				for (Iterator iterator2 = targets.iterator();
					iterator2.hasNext();
					) {
					String thid = (String) iterator2.next();
					System.err.println("Hid:"+(ctr++)+":(targets="+targets.size()+") "+hid+" ("+ir.getName()+") "+thid);
				}
			}
		}
		System.err.println("End of relationships dump for: "+key);
	}
================= fetch public void updateHandleMap(Set deletedFiles) { 38cc0dd^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java
// TODO rename this method ... it does more than just the handle map
public void updateHandleMap(Set deletedFiles) {
		// Only delete the entries we need to from the handle map - for performance reasons
		List forRemoval = new ArrayList();
		Set k = handleMap.keySet();
		for (Iterator iter = k.iterator(); iter.hasNext();) {
			String handle = (String) iter.next();
			if (deletedFiles.contains(getFilename(handle))) forRemoval.add(handle);
		}
		for (Iterator iter = forRemoval.iterator(); iter.hasNext();) {
			String handle = (String) iter.next();
			handleMap.remove(handle);
		}
		forRemoval.clear();
		k = typeMap.keySet();
		for (Iterator iter = k.iterator(); iter.hasNext();) {
			String element = (String) iter.next();
			IProgramElement ipe = (IProgramElement)typeMap.get(element);
			if (deletedFiles.contains(getFilename(ipe.getHandleIdentifier()))) forRemoval.add(element);
		}
		for (Iterator iter = forRemoval.iterator(); iter.hasNext();) {
			String handle = (String) iter.next();
			typeMap.remove(handle);
		}
		forRemoval.clear();
		k = fileMap.keySet();
		for (Iterator iter = k.iterator(); iter.hasNext();) {
			String element = (String) iter.next();
			IProgramElement ipe = (IProgramElement)fileMap.get(element);
			if (deletedFiles.contains(getFilename(ipe.getHandleIdentifier()))) forRemoval.add(element);
		}
		for (Iterator iter = forRemoval.iterator(); iter.hasNext();) {
			String handle = (String) iter.next();
			fileMap.remove(handle);
		}
		
	}
================= fetch public JRockitAgent() { 75afb31^:loadtime/src/org/aspectj/weaver/loadtime/JRockitAgent.java
/**
     * Weave a class
     *
     * @param caller   classloader
     * @param name     of the class to weave
     * @param bytecode original
     * @return bytecode weaved
     */
public byte[] preProcess(ClassLoader caller, String name, byte[] bytecode) {
        if (caller == null || caller.getParent() == null) {
            return bytecode;
        } else {
            return s_preProcessor.preProcess(name, bytecode, caller);
        }
    }
================= fetch public static Test suite() { 75afb31^:loadtime/testsrc/LoadtimeModuleTests.java

public static Test suite() {
        TestSuite suite = new TestSuite(LoadtimeModuleTests.class.getName());

        suite.addTestSuite(DocumentParserTest.class);
        suite.addTestSuite(WeavingURLClassLoaderTest.class);
        return suite;
    }
================= fetch public void initialize() { 75afb31^:loadtime/src/org/aspectj/weaver/loadtime/Aj.java
/**
     * Weave
     *
     * @param className
     * @param bytes
     * @param loader
     * @return weaved bytes
     */
public byte[] preProcess(String className, byte[] bytes, ClassLoader loader) {
        //TODO AV needs to doc that
        if (loader == null || className == null) {
            // skip boot loader or null classes (hibernate)
            return bytes;
        }

        try {
            WeavingAdaptor weavingAdaptor = WeaverContainer.getWeaver(loader, weavingContext);
            if (weavingAdaptor == null) {
            	return bytes;
            }
            return weavingAdaptor.weaveClass(className, bytes);
        } catch (Throwable t) {
            //FIXME AV wondering if we should have the option to fail (throw runtime exception) here
            // would make sense at least in test f.e. see TestHelper.handleMessage()
            t.printStackTrace();
            return bytes;
        }
    }
================= fetch public CacheImpl() { f821ca3^:runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java

static boolean getUseCache () {
		return useCache;
	}
================= fetch public String get(int cacheOffset) { f821ca3^:runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java

public String get(int cacheOffset) {
          String[] cachedArray = array();
          if (cachedArray == null) {
 		     return null;
 		  }
 		  return cachedArray[cacheOffset];
		}
================= fetch public void set(int cacheOffset, String result) { f821ca3^:runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java

private String[] array() {
			return (String[])toStringCacheRef.get();
		}
================= fetch public void testToShortMiddleLongString () { f821ca3^:runtime/testsrc/org/aspectj/runtime/reflect/SignatureTest.java

public void testToShortMiddleLongString () {
		MethodSignatureImpl msi = new MethodSignatureImpl(0,"test",SignatureTest.class,new Class[] { String.class, Integer.TYPE }, new String[] { "s", "i" }, new Class[] {}, Runnable.class);
		String shortString = msi.toShortString();
		assertSame(shortString,msi.toShortString()); // should be cached.
		String middleString = msi.toString();
		assertSame(middleString,msi.toString()); // should be cached.
		String longString = msi.toLongString();
		assertSame(longString,msi.toLongString()); // should be cached.
		assertTrue("String representations should be different",!(shortString.equals(middleString) || middleString.equals(longString) || longString.equals(shortString)));
	}
================= fetch static boolean getUseCache () { f821ca3^:runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java

static boolean getUseCache () {
		return useCache;
	}
================= fetch private void writeOutxmlFile () throws IOException { 319a0d1^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void writeOutxmlFile () throws IOException {
		String filename = buildConfig.getOutxmlName();
//		System.err.println("? AjBuildManager.writeOutxmlFile() outxml=" + filename);
//		System.err.println("? AjBuildManager.writeOutxmlFile() outputDir=" + buildConfig.getOutputDir());
		
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		PrintStream ps = new PrintStream(baos);
		ps.println("<aspectj>");
		ps.println("<aspects>");
		if (state.getAspectNames() != null) {
			for (Iterator i = state.getAspectNames().iterator(); i.hasNext();) {
				String name = (String)i.next();
				ps.println("<aspect name=\"" + name + "\"/>");
			}			
		}
		ps.println("</aspects>");
		ps.println("</aspectj>");
		ps.println();
		ps.close();

		if (zos != null) {
			ZipEntry newEntry = new ZipEntry(filename);
			
			zos.putNextEntry(newEntry);
			zos.write(baos.toByteArray());
			zos.closeEntry();
		} else {
			OutputStream fos = 
				FileUtil.makeOutputStream(new File(buildConfig.getOutputDir(),filename));
			fos.write(baos.toByteArray());
			fos.close();
		}
	}
================= fetch private void writeResource(String filename, byte[] content, File srcLocation) th 319a0d1^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void writeResource(String filename, byte[] content, File srcLocation) throws IOException {
		if (state.hasResource(filename)) {
			IMessage msg = new Message("duplicate resource: '" + filename + "'",
									   IMessage.WARNING,
									   null,
									   new SourceLocation(srcLocation,0));
			handler.handleMessage(msg);
			return;
		}
		if (zos != null) {
			ZipEntry newEntry = new ZipEntry(filename);  //??? get compression scheme right
			
			zos.putNextEntry(newEntry);
			zos.write(content);
			zos.closeEntry();
		} else {
			File destDir = buildConfig.getOutputDir();
			if (buildConfig.getCompilationResultDestinationManager() != null) {
				destDir = buildConfig.getCompilationResultDestinationManager().getOutputLocationForResource(srcLocation);
			}
			try {
				OutputStream fos = 
					FileUtil.makeOutputStream(new File(destDir,filename));
				fos.write(content);
				fos.close();
			} catch (FileNotFoundException fnfe) {
				IMessage msg = new Message("unable to copy resource to output folder: '" + filename + "' - reason: "+fnfe.getMessage(),
										   IMessage.ERROR,
										   null,
										   new SourceLocation(srcLocation,0));
				handler.handleMessage(msg);
			}
		}
		state.recordResource(filename);
	}
================= fetch public Map getSourcePathResources() { 319a0d1^:ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java

public Map getSourcePathResources() {
		File srcBase = new File(getProjectSourcePath());
		File[] fromResources = FileUtil.listFiles(srcBase, new FileFilter() {
================= fetch public boolean accept(File f) { 319a0d1^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void copyResourcesFromDirectory(File dir) throws IOException {
		if (!COPY_INPATH_DIR_RESOURCES) return;
		// Get a list of all files (i.e. everything that isnt a directory)
		File[] files = FileUtil.listFiles(dir,new FileFilter() {
			public boolean accept(File f) {
				boolean accept = !(f.isDirectory() || f.getName().endsWith(".class")) ;
				return accept;
			}
		});
		
		// For each file, add it either as a real .class file or as a resource
		for (int i = 0; i < files.length; i++) {
			// ASSERT: files[i].getAbsolutePath().startsWith(inFile.getAbsolutePath()
			// or we are in trouble...
			String filename = files[i].getAbsolutePath().substring(
			                    dir.getAbsolutePath().length()+1);
			copyResourcesFromFile(files[i],filename,dir);
		}		
	}
================= fetch public boolean accept(File pathname) { 319a0d1^:ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java

public void setOutJar( String jar ){ this.outJar = jar; }
================= fetch public void testOutxmlfileToOutjar () { 319a0d1^:ajde/testsrc/org/aspectj/ajde/OutxmlTest.java
/**
	 * Aim: Test "-outxmlfile filename" option produces the correct 
	 * xml entry in outjar file
	 * 
	 */
public void testOutxmlfileToOutjar () {
//		System.out.println("OutxmlTest.testOutxmlToOutjar() outputpath='" + ideManager.getProjectProperties().getOutputPath() + "'");
		File outjar = openFile(OUTJAR_NAME);
		ideManager.getProjectProperties().setOutJar(outjar.getAbsolutePath());
		assertTrue("Build failed",doSynchronousBuild("outxmlfile-to-outjar.lst"));
		assertTrue("Build warnings",ideManager.getCompilationSourceLineTasks().isEmpty());
		
		File aopxml = openFile(BIN_DIR + "/" + CUSTOM_AOPXML_NAME);
		assertFalse(CUSTOM_AOPXML_NAME + " should not exisit",aopxml.exists());
		assertJarContainsEntry(outjar,CUSTOM_AOPXML_NAME);
	}
================= fetch private void registerAspects(final BcelWeaver weaver, final ClassLoader loader, 4513e92^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
     * Register the aspect, following include / exclude rules
     *
     * @param weaver
     * @param loader
     * @param definitions
     */
private void registerAspects(final BcelWeaver weaver, final ClassLoader loader, final List definitions) {
        //TODO: the exclude aspect allow to exclude aspect defined upper in the CL hierarchy - is it what we want ??
        // if not, review the getResource so that we track which resource is defined by which CL

        //iterate aspectClassNames
        //exclude if in any of the exclude list
        for (Iterator iterator = definitions.iterator(); iterator.hasNext();) {
            Definition definition = (Definition) iterator.next();
            for (Iterator aspects = definition.getAspectClassNames().iterator(); aspects.hasNext();) {
                String aspectClassName = (String) aspects.next();
                if (acceptAspect(aspectClassName)) {
                	info("register aspect " + aspectClassName);
                    /*ResolvedType aspect = */weaver.addLibraryAspect(aspectClassName);

                    //generate key for SC
                    if(namespace==null){
                    	namespace=new StringBuffer(aspectClassName);
                    }else{
                    	namespace = namespace.append(";"+aspectClassName);
                    }
                }
                else {
//                	warn("aspect excluded: " + aspectClassName);
                	lint("aspectExcludedByConfiguration", new String[] { aspectClassName, getClassLoaderName(loader) });
                }
            }
        }

        //iterate concreteAspects
        //exclude if in any of the exclude list - note that the user defined name matters for that to happen
        for (Iterator iterator = definitions.iterator(); iterator.hasNext();) {
            Definition definition = (Definition) iterator.next();
            for (Iterator aspects = definition.getConcreteAspects().iterator(); aspects.hasNext();) {
                Definition.ConcreteAspect concreteAspect = (Definition.ConcreteAspect) aspects.next();
                if (acceptAspect(concreteAspect.name)) {
                    ConcreteAspectCodeGen gen = new ConcreteAspectCodeGen(concreteAspect, weaver.getWorld());
                    if (!gen.validate()) {
                        error("Concrete-aspect '"+concreteAspect.name+"' could not be registered");
                        break;
                    }
                    this.generatedClassHandler.acceptClass(
                            concreteAspect.name,
                            gen.getBytes()
                    );
                    /*ResolvedType aspect = */weaver.addLibraryAspect(concreteAspect.name);

                    //generate key for SC
                    if(namespace==null){
                    	namespace=new StringBuffer(concreteAspect.name);
                    }else{
                    	namespace = namespace.append(";"+concreteAspect.name);
                    }
                }
            }
        }
    }
================= fetch public void addCrossReference(ISourceLocation from, ISourceLocation to, IRelatio 4513e92^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java

public void acceptClass(String name, byte[] bytes) {
                try {
                    if (shouldDump(name.replace('/', '.'), false)) {
                        dump(name, bytes, false);
                    }
                } catch (Throwable throwable) {
                    throwable.printStackTrace();
                }

                defineClass(loader, name, bytes);// could be done lazily using the hook
            }
================= fetch public void testDeclareAtMethodRelationship_pr143924() { 4513e92^:tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java

public void testMakePreMethodNPE_pr136393() { runTest("NPE in makePreMethod");}
Progress : [##################----------------------] 46%================= fetch private IScope buildResolutionScope(Class inScope, PointcutParameter[] formalPar 97cd71a^:weaver/src/org/aspectj/weaver/tools/PointcutParser.java

private IScope buildResolutionScope(Class inScope, PointcutParameter[] formalParameters) {
    	if (formalParameters == null) formalParameters = new PointcutParameter[0];
    	FormalBinding[] formalBindings = new FormalBinding[formalParameters.length];
    	for (int i = 0; i < formalBindings.length; i++) {
			formalBindings[i] = new FormalBinding(UnresolvedType.forName(formalParameters[i].getType().getName()),formalParameters[i].getName(),i);			
		}
    	if (inScope == null) {
    		return new SimpleScope(getWorld(),formalBindings);
    	} else {
    		ResolvedType inType = getWorld().resolve(inScope.getName());
    		ISourceContext sourceContext = new ISourceContext() {
================= fetch private ResolvedMember createGenericFieldMember(Field forField) { 97cd71a^:weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java
// for @AspectJ pointcuts compiled by javac only...
private String[] tryToDiscoverParameterNames(Pointcut pcut) {
		Method[] ms = pcut.getDeclaringType().getJavaClass().getDeclaredMethods();
		for(Method m : ms) {
			if (m.getName().equals(pcut.getName())) {
				return argNameFinder.getParameterNames(m);
			}
		}
		return null;
	}
================= fetch public void d() {} 97cd71a^:weaver5/java5-testsrc/org/aspectj/weaver/tools/Java15PointcutExpressionTest.java

public void c() {}
================= fetch public void testReferencePCsInOtherType() throws Exception { 97cd71a^:weaver5/java5-testsrc/org/aspectj/weaver/tools/Java15PointcutExpressionTest.java

public void testReferencePCsInOtherType() throws Exception {
		PointcutExpression ex = parser.parsePointcutExpression("org.aspectj.weaver.tools.Java15PointcutExpressionTest.ExternalReferrer.d()",ExternalReferrer.class,new PointcutParameter[0]);
		ShadowMatch sm = ex.matchesMethodExecution(a);
		assertTrue("should match",sm.alwaysMatches());
		sm = ex.matchesMethodExecution(b);
		assertTrue("does not match",sm.neverMatches());		
	}
================= fetch public void tidy() {} 97cd71a^:weaver/src/org/aspectj/weaver/tools/PointcutParser.java

public void tidy() {}
================= fetch private String genPrecedenceListLabel(TypePatternList list) { 26a8a86^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java

private String genPrecedenceListLabel(TypePatternList list) {
		String tpList = "";
		for (int i = 0; i < list.size(); i++) {
			tpList += genTypePatternLabel(list.get(i));
			if (i < list.size()-1) tpList += ", ";
		} 
		return tpList;
	}
================= fetch public boolean visit(ConstructorDeclaration constructorDeclaration, ClassScope s 26a8a86^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java
//	}
public boolean visit(ConstructorDeclaration constructorDeclaration, ClassScope scope) {
		if (constructorDeclaration.isDefaultConstructor) {
			stack.push(null); // a little wierd but does the job
			return true;	
		}
		StringBuffer argumentsSignature = new StringBuffer();
		argumentsSignature.append("(");
		if (constructorDeclaration.arguments!=null) {
		  for (int i = 0;i<constructorDeclaration.arguments.length;i++) {
			argumentsSignature.append(constructorDeclaration.arguments[i].type);
			if (i+1<constructorDeclaration.arguments.length) argumentsSignature.append(",");
		  }
		}
		argumentsSignature.append(")");
		IProgramElement peNode = new ProgramElement(
			new String(constructorDeclaration.selector)+argumentsSignature,
			IProgramElement.Kind.CONSTRUCTOR,	
			makeLocation(constructorDeclaration),
			constructorDeclaration.modifiers,
			null,null);
		
		peNode.setModifiers(constructorDeclaration.modifiers);
		peNode.setSourceSignature(genSourceSignature(constructorDeclaration));
		
		// Fix to enable us to anchor things from ctor nodes
		if (constructorDeclaration.binding != null) {
			String memberName = "";
			String memberBytecodeSignature = "";
			try {
		    	EclipseFactory factory = ((AjLookupEnvironment)constructorDeclaration.scope.environment()).factory;
				Member member = factory.makeResolvedMember(constructorDeclaration.binding);
				memberName = member.getName();
				memberBytecodeSignature = member.getSignature();
			} catch (BCException bce) {  // bad type name 
				memberName = "<undefined>";
			} catch (NullPointerException npe) {
				memberName = "<undefined>";
			} 
			peNode.setBytecodeName(memberName);
			peNode.setBytecodeSignature(memberBytecodeSignature);
		}
		
		
		((IProgramElement)stack.peek()).addChild(peNode);
		stack.push(peNode);
		return true;	
	}
================= fetch public void addDeclareAnnotationRelationship(ISourceLocation sourceLocation, Str 26a8a86^:weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java
/**
     * Add a relationship to the known set for a declare @field construct.  Locating the field is trickier than
     * it might seem since we have no line number info for it, we have to dig through the structure model under
     * the fields' type in order to locate it.  Currently just fails silently if any of the lookup code
     * doesn't find anything...
     */
public void addDeclareAnnotationRelationship(ISourceLocation sourceLocation, String typename,Field field) {
	    if (!AsmManager.isCreatingModel()) return;
	    
  	    String pkg  = null;
	    String type = typename;
	    int packageSeparator = typename.lastIndexOf(".");
	    if (packageSeparator!=-1) {
	  	  pkg  = typename.substring(0,packageSeparator);
	  	  type = typename.substring(packageSeparator+1);
	    }
	    
        IProgramElement typeElem = AsmManager.getDefault().getHierarchy().findElementForType(pkg,type);
        if (typeElem == null) return;
        
        IProgramElement fieldElem = AsmManager.getDefault().getHierarchy().findElementForSignature(typeElem,IProgramElement.Kind.FIELD,field.getName());
        if (fieldElem== null) return;

		String sourceHandle = 
            AsmManager.getDefault().getHandleProvider().createHandleIdentifier(sourceLocation.getSourceFile(),sourceLocation.getLine(),
		  	sourceLocation.getColumn(),sourceLocation.getOffset());
		  	
		String targetHandle = fieldElem.getHandleIdentifier();
		
        IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
		if (sourceHandle != null && targetHandle != null) {
			IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATES,false,true);
			foreward.addTarget(targetHandle);
				
			IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATED_BY,false,true);
			back.addTarget(sourceHandle);
		}
	}
================= fetch public void testAdvisesRelationshipCoverage() throws Exception { 26a8a86^:ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java
/**
     * Test that all the advises relationships appear in the 
     * Advice Detail and Advice Summary sections and that
     * the links are correct 
     */
public void testAdvisesRelationshipCoverage() throws Exception {
    	File[] files = {file4};
    	runAjdoc("private","1.4",files);
    	
        File htmlFile = new File(getAbsolutePathOutdir() + "/foo/AdvisesRelationshipCoverage.html");
		if (htmlFile == null || !htmlFile.exists()) {
			fail("couldn't find " + htmlFile.getAbsolutePath() + " - were there compilation errors?");
		}
        
		String[] strings = {
				"before(): methodExecutionP..",
				"HREF=\"../foo/Point.html#setX(int)\"",
				"before(): constructorExecutionP..",
				"HREF=\"../foo/Point.html#Point()\"",
				"before(): callMethodP..",
				"HREF=\"../foo/Point.html#changeX(int)\"",
				"before(): callConstructorP..",
				"HREF=\"../foo/Point.html#doIt()\"",
				"before(): getP..",
				"HREF=\"../foo/Point.html#getX()\"",
				"before(): setP..",
				"HREF=\"../foo/Point.html\"><tt>foo.Point</tt></A>, <A HREF=\"../foo/Point.html#Point()\"><tt>foo.Point.Point()</tt></A>, <A HREF=\"../foo/Point.html#setX(int)\"",
				"before(): initializationP..",
				"HREF=\"../foo/Point.html#Point()\"",
				"before(): staticinitializationP..",
				"HREF=\"../foo/Point.html\"",
				"before(): handlerP..",
				"HREF=\"../foo/Point.html#doIt()\""
		};
		
		for (int i = 0; i < strings.length - 1; i = i+2) {
			boolean b = AjdocOutputChecker.detailSectionContainsRel(
					htmlFile,"ADVICE DETAIL SUMMARY",strings[i],
					HtmlDecorator.HtmlRelationshipKind.ADVISES,
					strings[i+1]);
			assertTrue(strings[i] + " should advise " + strings[i+1] + 
					" in the Advice Detail section", b);
		}
		
		for (int i = 0; i < strings.length - 1; i = i+2) {
			boolean b = AjdocOutputChecker.summarySectionContainsRel(
					htmlFile,"ADVICE SUMMARY",strings[i],
					HtmlDecorator.HtmlRelationshipKind.ADVISES,
					strings[i+1]);
			assertTrue(strings[i] + " should advise " + strings[i+1] + 
					" in the Advice Summary section", b);
		}
    }
================= fetch public void testDeclareAnnotationAppearsInStructureModel_pr132130() { 26a8a86^:tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java

public void testDeclareAnnotationAppearsInStructureModel_pr132130() {
	  //AsmManager.setReporting("c:/debug.txt",true,true,true,true);
	  runTest("declare annotation appears in structure model when in same file");
	  IHierarchy top = AsmManager.getDefault().getHierarchy();
	  
  	  // get the IProgramElements corresponding to the different code entries
  	  IProgramElement decam = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.DECLARE_ANNOTATION_AT_METHOD,"declare @method: * debit(..) : @Secured(role = \"supervisor\")");  	   	 
  	  assertNotNull("Couldn't find 'declare @method' element in the tree",decam);
  	  IProgramElement method = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.METHOD,"debit(long,long)");
  	  assertNotNull("Couldn't find the 'debit(long,long)' method element in the tree",method);
  	  IProgramElement decac = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.DECLARE_ANNOTATION_AT_CONSTRUCTOR,"declare @constructor: BankAccount+.new(..) : @Secured(role = \"supervisor\")");  	   	 
  	  assertNotNull("Couldn't find 'declare @constructor' element in the tree",decac);
  	  IProgramElement ctr = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.CONSTRUCTOR,"BankAccount(String,int)");
  	  assertNotNull("Couldn't find the 'BankAccount(String,int)' constructor element in the tree",ctr);

  	  
  	  // check that decam has a annotates relationship with the debit method
  	  List matches = AsmManager.getDefault().getRelationshipMap().get(decam);	
  	  assertNotNull("'declare @method' should have some relationships but does not",matches);
  	  assertTrue("'declare @method' should have one relationships but has " + matches.size(),matches.size()==1);
  	  List matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("'declare @method' should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
  	  IProgramElement target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the 'debit(long,long)' method but is IPE with label "
  			  + target.toLabelString(),method,target);
  	  
  	  // check that the debit method has an annotated by relationship with the declare @method
  	  matches = AsmManager.getDefault().getRelationshipMap().get(method);	
  	  assertNotNull("'debit(long,long)' should have some relationships but does not",matches);
  	  assertTrue("'debit(long,long)' should have one relationships but has " + matches.size(),matches.size()==1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("'debit(long,long)' should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the 'declare @method' ipe but is IPE with label "
  			  + target.toLabelString(),decam,target);

  	  // check that decac has a annotates relationship with the constructor
  	  matches = AsmManager.getDefault().getRelationshipMap().get(decac);	
  	  assertNotNull("'declare @method' should have some relationships but does not",matches);
  	  assertTrue("'declare @method' should have one relationships but has " + matches.size(),matches.size()==1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("'declare @method' should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the 'debit(long, long)' method but is IPE with label "
  			  + target.toLabelString(),ctr,target);
  	  
  	  // check that the constructor has an annotated by relationship with the declare @constructor
  	  matches = AsmManager.getDefault().getRelationshipMap().get(ctr);	
  	  assertNotNull("'debit(long, long)' should have some relationships but does not",matches);
  	  assertTrue("'debit(long, long)' should have one relationships but has " + matches.size(),matches.size()==1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("'debit(long, long)' should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the 'declare @method' ipe but is IPE with label "
  			  + target.toLabelString(),decac,target);


  }
================= fetch public boolean validate() { 69e24e9^:loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java

public boolean validate() {
        if (!(m_world instanceof BcelWorld)) {
            reportError("Internal error: world must be of type BcelWorld");
            return false;
        }

        // name must be undefined so far
        ResolvedType current = m_world.resolve(m_concreteAspect.name, true);
        if (!current.isMissing()) {
            reportError("Attempt to concretize but choosen aspect name already defined: " + stringify());
            return false;
        }

        // it can happen that extends is null, for precedence only declaration
        if (m_concreteAspect.extend == null && m_concreteAspect.precedence != null) {
            if (m_concreteAspect.pointcuts.isEmpty()) {
                m_isValid = true;
                m_perClause = new PerSingleton();
                m_parent = null;
                return true;// no need to checks more in that special case
            } else {
                reportError("Attempt to use nested pointcuts without extends clause: "+stringify());
                return false;
            }
        }

        m_parent = m_world.resolve(m_concreteAspect.extend, true);
        // handle inner classes
        if (m_parent.isMissing()) {
            // fallback on inner class lookup mechanism
            String fixedName = m_concreteAspect.extend;
            int hasDot = fixedName.lastIndexOf('.');
            while (hasDot > 0) {
                char[] fixedNameChars = fixedName.toCharArray();
                fixedNameChars[hasDot] = '$';
                fixedName = new String(fixedNameChars);
                hasDot = fixedName.lastIndexOf('.');
                m_parent = m_world.resolve(UnresolvedType.forName(fixedName), true);
                if (!m_parent.isMissing()) {
                    break;
                }
            }
        }
        if (m_parent.isMissing()) {
            reportError("Cannot find m_parent aspect for: " + stringify());
            return false;
        }

        // extends must be abstract
        if (!m_parent.isAbstract()) {
            reportError("Attempt to concretize a non-abstract aspect: " + stringify());
            return false;
        }

        // m_parent must be aspect
        if (!m_parent.isAspect()) {
            reportError("Attempt to concretize a non aspect: " + stringify());
            return false;
        }

        // must have all abstractions defined
        List elligibleAbstractions = new ArrayList();
        Iterator methods = m_parent.getMethods();
        while (methods.hasNext()) {
            ResolvedMember method = (ResolvedMember) methods.next();
            if (method.isAbstract()) {
                if ("()V".equals(method.getSignature())) {
                	String n = method.getName();
                	if (n.startsWith("ajc$pointcut")) { // Allow for the abstract pointcut being from a code style aspect compiled with -1.5 (see test for 128744)
                		n = n.substring(14);
                		n = n.substring(0,n.indexOf("$"));
                		elligibleAbstractions.add(n);
                	} else {
                		// Only interested in abstract methods that take no parameters and are marked @Pointcut
                		if (hasPointcutAnnotation(method))
                			elligibleAbstractions.add(method.getName());
                	}
                } else {
                    reportError("Abstract method '" + method.getName() + "' cannot be concretized as a pointcut (illegal signature, must have no arguments, must return void): " + stringify());
                    return false;
                }
            }
        }
        List pointcutNames = new ArrayList();
        for (Iterator it = m_concreteAspect.pointcuts.iterator(); it.hasNext();) {
            Definition.Pointcut abstractPc = (Definition.Pointcut) it.next();
            pointcutNames.add(abstractPc.name);
        }
        for (Iterator it = elligibleAbstractions.iterator(); it.hasNext();) {
            String elligiblePc = (String) it.next();
            if (!pointcutNames.contains(elligiblePc)) {
                reportError("Abstract pointcut '" + elligiblePc + "' not configured: " + stringify());
                return false;
            }
        }

        m_perClause = m_parent.getPerClause();
        m_isValid = true;
        return m_isValid;
    }
================= fetch protected Test findResidueInternal(Shadow shadow, ExposedState state) { 6b2d9ae^:weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.Pointcut#findResidue(org.aspectj.weaver.Shadow, org.aspectj.weaver.patterns.ExposedState)
	 */
protected Test findResidueInternal(Shadow shadow, ExposedState state) {
		
		if (annotationTypePattern instanceof BindingAnnotationTypePattern) {
			BindingAnnotationTypePattern btp = (BindingAnnotationTypePattern)annotationTypePattern;
			UnresolvedType annotationType = btp.getAnnotationType();
			Var var = shadow.getKindedAnnotationVar(annotationType);
			
			// This should not happen, we shouldn't have gotten this far 
			// if we weren't going to find the annotation
			if (var == null) throw new BCException("Impossible! annotation=["+annotationType+
					                               "]  shadow=["+shadow+" at "+shadow.getSourceLocation()+
												   "]    pointcut is at ["+getSourceLocation()+"]");//return Literal.FALSE;

			state.set(btp.getFormalIndex(),var);
		}
		if (matchInternal(shadow).alwaysTrue()) 
			return Literal.TRUE;
		else 
			return Literal.FALSE;
	}
================= fetch private void addAndRecurse(Set knowninterfaces,List collector, ResolvedType rtx, 5f6a6b1^:weaver/src/org/aspectj/weaver/ResolvedType.java

public ResolvedType[] getResolvedTypeParameters() {
    	if (resolvedTypeParams == null) {
    		resolvedTypeParams = world.resolve(typeParameters);
    	}
    	return resolvedTypeParams;
    }
================= fetch public void finishTypeMungers() { 5f6a6b1^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

public void finishTypeMungers() {
		// make sure that type mungers are
		Collection ret = new ArrayList();
		Collection baseTypeMungers = getWorld().getCrosscuttingMembersSet().getTypeMungers();
		
		// XXX by Andy: why do we mix up the mungers here? it means later we know about two sets
		// and the late ones are a subset of the complete set? (see pr114436)
        baseTypeMungers.addAll(getWorld().getCrosscuttingMembersSet().getLateTypeMungers());

		for (Iterator i = baseTypeMungers.iterator(); i.hasNext(); ) {
			ConcreteTypeMunger munger = (ConcreteTypeMunger) i.next();
			EclipseTypeMunger etm = makeEclipseTypeMunger(munger);
			if (etm != null) ret.add(etm);
		}
		finishedTypeMungers = ret;
	}
================= fetch public void testPr115251() { 5f6a6b1^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java

public void testPr115251() {
		//AjdeInteractionTestbed.VERBOSE=true;
		initialiseProject("PR115251");
		build("PR115251");
		checkWasFullBuild();
		alter("PR115251","inc1");
		build("PR115251");
		checkWasFullBuild();  // back to the source
	}
================= fetch private boolean addOrReplaceDescendantsOf(ResolvedType aspectType,boolean careAb b166a7e^:weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java

private boolean addOrReplaceDescendantsOf(ResolvedType aspectType,boolean careAboutShadowMungers) {
		//System.err.println("Looking at descendants of "+aspectType.getName());
		Set knownAspects = members.keySet();
		Set toBeReplaced = new HashSet();
		for(Iterator it = knownAspects.iterator(); it.hasNext(); ) {
			ResolvedType candidateDescendant = (ResolvedType)it.next();
			if ((candidateDescendant != aspectType) && (aspectType.isAssignableFrom(candidateDescendant))) {
				toBeReplaced.add(candidateDescendant);
			}
		}
		boolean change = false;
		for (Iterator it = toBeReplaced.iterator(); it.hasNext(); ) {
			ResolvedType next = (ResolvedType)it.next();
			boolean thisChange = addOrReplaceAspect(next,careAboutShadowMungers);
			change = change || thisChange;
		}
		return change;
	}
================= fetch private void checkWeave( b166a7e^:weaver/testsrc/org/aspectj/weaver/bcel/PointcutResidueTestCase.java

private void checkWeave(
        String label,
        String filename,
        String pointcutSource,
        String[] formalTypes,
        String[] formalNames)
        throws IOException 
    {
        final Pointcut sp = Pointcut.fromString(pointcutSource);
        final Pointcut rp =
            sp.resolve(
            	new SimpleScope(
            	world,
                SimpleScope.makeFormalBindings(UnresolvedType.forNames(formalTypes),
                formalNames)
                ));

        ShadowMunger pp =
            new BcelAdvice(
                AdviceKind.Before,
                rp,
                MemberImpl.method(
                    UnresolvedType.forName("Aspect"),
                    Modifier.STATIC,
                    "ajc_before_0",
                    MemberImpl.typesToSignature(
                        ResolvedType.VOID,
                        UnresolvedType.forNames(formalTypes),false)),
            	0, -1, -1, null, null);

		ResolvedType inAspect = world.resolve("Aspect");
		CrosscuttingMembers xcut = new CrosscuttingMembers(inAspect);
		inAspect.crosscuttingMembers = xcut;
		
        ShadowMunger cp = pp.concretize(inAspect, world, null);
        
        xcut.addConcreteShadowMunger(cp);
        
        //System.out.println("extras: " + inAspect.getExtraConcreteShadowMungers());
//        List advice = new ArrayList();
//        advice.add(cp);
//        advice.addAll(inAspect.getExtraConcreteShadowMungers());
        weaveTest(new String[] { filename }, label, xcut.getShadowMungers());

        checkSerialize(rp);
    }
================= fetch public CrosscuttingMembers(ResolvedType inAspect) { b166a7e^:weaver/src/org/aspectj/weaver/CrosscuttingMembers.java

================= fetch public ResolvedPointcutDefinition findPointcut(String name) { b166a7e^:weaver/src/org/aspectj/weaver/ResolvedType.java

ResolvedPointcutDefinition findPointcut(String name) {
        //System.err.println("looking for pointcuts " + this);
        for (Iterator i = getPointcuts(); i.hasNext(); ) {
            ResolvedPointcutDefinition f = (ResolvedPointcutDefinition) i.next();
            //System.err.println(f);
            if (name.equals(f.getName())) {
                return f;
            }
        }
        // pr120521
        if (!getOutermostType().equals(this)) {
        	ResolvedType outerType = getOutermostType().resolve(world);
        	ResolvedPointcutDefinition rpd = outerType.findPointcut(name);
        	return rpd;
        }
        return null; // should we throw an exception here?
    }
================= fetch public boolean addOrReplaceAspect(ResolvedType aspectType) { b166a7e^:weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java

public boolean addOrReplaceAspect(ResolvedType aspectType) {
		return addOrReplaceAspect(aspectType,true);
	}
================= fetch public boolean addOrReplaceAspect(ResolvedType aspectType,boolean careAboutShado b166a7e^:weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java
/**
	 * @return whether or not that was a change to the global signature
	 * 			XXX for efficiency we will need a richer representation than this
	 */
public boolean addOrReplaceAspect(ResolvedType aspectType,boolean careAboutShadowMungers) {
		boolean change = false;
		CrosscuttingMembers xcut = (CrosscuttingMembers)members.get(aspectType);
		if (xcut == null) {
			members.put(aspectType, aspectType.collectCrosscuttingMembers());
			clearCaches();
			CflowPointcut.clearCaches(aspectType);
			change = true;
		} else {
			if (xcut.replaceWith(aspectType.collectCrosscuttingMembers(),careAboutShadowMungers)) {
				clearCaches();

				CflowPointcut.clearCaches(aspectType);
				change = true;
			} else {
				if (!World.compareLocations && careAboutShadowMungers) {
					// bug 134541 - even though we haven't changed we may have updated the 
					// sourcelocation for the shadowMunger which we need to pick up
					shadowMungers = null;
				}
				change = false;
			}
		}
		if (aspectType.isAbstract()) {
			// we might have sub-aspects that need to re-collect their crosscutting members from us
			boolean ancestorChange = addOrReplaceDescendantsOf(aspectType,careAboutShadowMungers); 
			change = change || ancestorChange;
		}
		changedSinceLastReset = changedSinceLastReset || change;
		return change;
	}
================= fetch public boolean replaceWith(CrosscuttingMembers other,boolean careAboutShadowMung b166a7e^:weaver/src/org/aspectj/weaver/CrosscuttingMembers.java
/**
	 * Updates the records if something has changed. This is called at most twice, firstly
	 * whilst collecting ITDs and declares. At this point the CrosscuttingMembers we're 
	 * comparing ourselves with doesn't know about shadowmungers. Therefore a straight comparison
	 * with the existing list of shadowmungers would return that something has changed
	 * even though it might not have, so in this first round we ignore the shadowMungers. 
	 * The second time this is called is whilst we're preparing to weave. At this point 
	 * we know everything in the system and so we're able to compare the shadowMunger list.
	 * (see bug 129163)
	 * 
	 * @param other
	 * @param careAboutShadowMungers
	 * @return true if something has changed since the last time this method was
	 *         called, false otherwise
	 */
public boolean replaceWith(CrosscuttingMembers other,boolean careAboutShadowMungers) {
		boolean changed = false;
		
		if (perClause == null || !perClause.equals(other.perClause)) {
			changed = true;
			perClause = other.perClause;
		}
		
		//XXX all of the below should be set equality rather than list equality
		//System.err.println("old: " + shadowMungers + " new: " + other.shadowMungers);
		
  	    if (careAboutShadowMungers) {
		    // bug 129163: use set equality rather than list equality 
			Set theseShadowMungers = new HashSet();
			theseShadowMungers.addAll(shadowMungers);
			Set otherShadowMungers = new HashSet();
			otherShadowMungers.addAll(other.shadowMungers);
			
			PointcutRewriter pr = new PointcutRewriter();
			for (Iterator iter = otherShadowMungers.iterator(); iter.hasNext();) {
				ShadowMunger munger = (ShadowMunger) iter.next();
				Pointcut p = munger.getPointcut();
				Pointcut newP = pr.rewrite(p);
				munger.setPointcut(newP);
			}
			if (!theseShadowMungers.equals(otherShadowMungers)) {
				changed = true;
			}
			// replace the existing list of shadowmungers with the 
			// new ones in case anything like the sourcelocation has
			// changed, however, don't want this flagged as a change
			// which will force a full build - bug 134541
			shadowMungers = other.shadowMungers;
  	    }
  	    
		// bug 129163: use set equality rather than list equality and
  	    // if we dont care about shadow mungers then ignore those 
  	    // typeMungers which are created to help with the implementation 
  	    // of shadowMungers
		Set theseTypeMungers = new HashSet();
		Set otherTypeMungers = new HashSet();
		if (!careAboutShadowMungers) {
			for (Iterator iter = typeMungers.iterator(); iter.hasNext();) {
				Object o = iter.next();
				if (o instanceof BcelTypeMunger) {
					BcelTypeMunger typeMunger = (BcelTypeMunger) o;
					if (!typeMunger.existsToSupportShadowMunging()) {
						theseTypeMungers.add(typeMunger);
					}				
				} else {
					theseTypeMungers.add(o);
				}
			}
			
			for (Iterator iter = other.typeMungers.iterator(); iter.hasNext();) {
				Object o = iter.next();
				if (o instanceof BcelTypeMunger) {
					BcelTypeMunger typeMunger = (BcelTypeMunger) o;
					if (!typeMunger.existsToSupportShadowMunging()) {
						otherTypeMungers.add(typeMunger);
					}
				} else {
					otherTypeMungers.add(o);
				}
			}
		} else {
			theseTypeMungers.addAll(typeMungers);
			otherTypeMungers.addAll(other.typeMungers);
		}
  	    
  	    // initial go at equivalence logic rather than set compare (see pr133532)
//		if (theseTypeMungers.size()!=otherTypeMungers.size()) {
//			changed = true;
//			typeMungers = other.typeMungers;
//		} else {
//			boolean foundInequality=false;
//			for (Iterator iter = theseTypeMungers.iterator(); iter.hasNext() && !foundInequality;) {
//				Object thisOne = (Object) iter.next();
//				boolean foundInOtherSet = false;
//				for (Iterator iterator = otherTypeMungers.iterator(); iterator.hasNext();) {
//					Object otherOne = (Object) iterator.next();
//					if (thisOne instanceof ConcreteTypeMunger && otherOne instanceof ConcreteTypeMunger) {
//						if (((ConcreteTypeMunger)thisOne).equivalentTo(otherOne)) {
//							foundInOtherSet=true;
//						} else if (thisOne.equals(otherOne)) {
//							foundInOtherSet=true;
//						}
//					} else {
//						if (thisOne.equals(otherOne)) {
//							foundInOtherSet=true;
//						} 
//					}
//				}
//				if (!foundInOtherSet) foundInequality=true;
//			}
//			if (foundInequality) {
//				changed = true;
//				typeMungers = other.typeMungers;
////			} else {
////				typeMungers = other.typeMungers;
//			}
//		}
  	    if (!theseTypeMungers.equals(otherTypeMungers)) {
			changed = true;
			typeMungers = other.typeMungers;
		}

        if (!lateTypeMungers.equals(other.lateTypeMungers)) {
            changed = true;
            lateTypeMungers = other.lateTypeMungers;
        }

		if (!declareDominates.equals(other.declareDominates)) {
			changed = true;
			declareDominates = other.declareDominates;
		}
		
		if (!declareParents.equals(other.declareParents)) {
			changed = true;
			declareParents = other.declareParents;
		}
		
		if (!declareSofts.equals(other.declareSofts)) {
			changed = true;
			declareSofts = other.declareSofts;
		}
		
		// DECAT for when attempting to replace an aspect
		if (!declareAnnotationsOnType.equals(other.declareAnnotationsOnType)) {
			changed = true;
			declareAnnotationsOnType = other.declareAnnotationsOnType;
		}
		
		if (!declareAnnotationsOnField.equals(other.declareAnnotationsOnField)) {
			changed = true;
			declareAnnotationsOnField = other.declareAnnotationsOnField;
		}
		
		if (!declareAnnotationsOnMethods.equals(other.declareAnnotationsOnMethods)) {
			changed = true;
			declareAnnotationsOnMethods = other.declareAnnotationsOnMethods;
		}
		
		return changed;
	}
================= fetch public static void verifyClassSignature(Ajc ajc,String classname,String sig) { b166a7e^:tests/src/org/aspectj/systemtest/ajc150/GenericITDsDesign.java

public List /*BcelTypeMunger*/ getTypeMunger(String classname) {
		ClassPath cp = 
			new ClassPath(ajc.getSandboxDirectory() + File.pathSeparator + 
					      System.getProperty("java.class.path"));
		recentWorld = new BcelWorld(cp.toString());
		ReferenceType resolvedType = (ReferenceType)recentWorld.resolve(classname);
		CrosscuttingMembers cmembers = resolvedType.collectCrosscuttingMembers();
		List tmungers = cmembers.getTypeMungers();
		return tmungers;
	}
================= fetch public void setPerClause(PerClause perClause) { b166a7e^:weaver/src/org/aspectj/weaver/CrosscuttingMembers.java

public void setPerClause(PerClause perClause) {
		this.perClause = perClause.concretize(inAspect);
	}
================= fetch public void testBeforeCflow() throws IOException { b166a7e^:weaver/testsrc/org/aspectj/weaver/bcel/NonstaticWeaveTestCase.java

public void testBeforeCflow() throws IOException {
		String s = "before(): get(* *.*) -> void Aspect.ajc_before()";
		PerClause per = new PatternParser("percflow(execution(void main(..)))").maybeParsePerClause();
		per.resolve(new TestScope(new String[0], new String[0], world));
		
		ResolvedType onAspect = world.resolve("Aspect");
		CrosscuttingMembers xcut = new CrosscuttingMembers(onAspect);
		onAspect.crosscuttingMembers = xcut;
		
		per = per.concretize(onAspect);

        ShadowMunger myMunger = this.makeConcreteAdvice(s, 0, per);
		
		xcut.addConcreteShadowMunger(myMunger);		
		
		
		weaveTest(getStandardTargets(), "CflowNonStaticBefore", xcut.getShadowMungers());
	}
================= fetch public void testBeforePerThis() throws IOException { b166a7e^:weaver/testsrc/org/aspectj/weaver/bcel/NonstaticWeaveTestCase.java

public void testBeforePerThis() throws IOException {
		String s = "before(): call(* println(..)) -> void Aspect.ajc_before()";
		PerClause per = new PatternParser("pertarget(call(* println(..)))").maybeParsePerClause();
		per.resolve(new TestScope(new String[0], new String[0], world));
		
		ResolvedType onAspect = world.resolve("Aspect");
		CrosscuttingMembers xcut = new CrosscuttingMembers(onAspect);
		onAspect.crosscuttingMembers = xcut;
		per = per.concretize(onAspect);

        ShadowMunger myMunger = this.makeConcreteAdvice(s, 0, per);
		xcut.addConcreteShadowMunger(myMunger);
		
//		List mungers = new ArrayList();
//		mungers.add(myMunger);
//		mungers.addAll(onAspect.getExtraConcreteShadowMungers());		
		
		
		weaveTest(getStandardTargets(), "PerThisNonStaticBefore", xcut.getShadowMungers());
	}
================= fetch public void testDominates() { b166a7e^:weaver/testsrc/org/aspectj/weaver/bcel/WeaveOrderTestCase.java

public void testDominates() {
		Declare dom =
			new PatternParser("declare precedence: java.lang.String, java.lang.Throwable").parseDeclare();
		//??? concretize dom
		ResolvedType aType =  world.resolve("Aspect");
		CrosscuttingMembers xcut = new CrosscuttingMembers(aType);
		aType.crosscuttingMembers = xcut;
		xcut.addDeclare(dom);
		world.getCrosscuttingMembersSet().addFixedCrosscuttingMembers(aType);
		
		Advice a1 =
			makeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.OBJECT, 1);
		Advice a2 =
			makeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.THROWABLE, 2);
		Advice a3 =
			makeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.forName("java.lang.String"), 2);
		
		assertEquals(-1, a2.compareTo(a1));
		assertEquals(+1, a1.compareTo(a2));

		assertEquals(-1, a3.compareTo(a1));
		assertEquals(+1, a1.compareTo(a3));
		
		
		assertEquals(+1, a3.compareTo(a2));
		assertEquals(-1, a2.compareTo(a3));
	}
================= fetch public void testDominatesHarder() { b166a7e^:weaver/testsrc/org/aspectj/weaver/bcel/WeaveOrderTestCase.java

public void testDominatesHarder() {
		Declare dom =
			new PatternParser("declare precedence: *, java.lang.String, java.lang.Throwable").parseDeclare();
		//??? concretize dom
		ResolvedType aType =  world.resolve("Aspect");
		CrosscuttingMembers xcut = new CrosscuttingMembers(aType);
		aType.crosscuttingMembers = xcut;
		xcut.addDeclare(dom);
		world.getCrosscuttingMembersSet().addFixedCrosscuttingMembers(aType);
		
		Advice a1 =
			makeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.OBJECT, 2);
		Advice a2 =
			makeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.THROWABLE, 1);
		Advice a3 =
			makeConcreteAdvice(AdviceKind.Before, UnresolvedType.OBJECT, UnresolvedType.forName("java.lang.String"), 1);
		
		assertEquals(-1, a2.compareTo(a1));
		assertEquals(+1, a1.compareTo(a2));

		assertEquals(-1, a3.compareTo(a1));
		assertEquals(+1, a1.compareTo(a3));
		
		
		assertEquals(+1, a3.compareTo(a2));
		assertEquals(-1, a2.compareTo(a3));
	}
Progress : [##################----------------------] 47%================= fetch public static void main (String[] args) { fc7db25^:tests/java5/ataspectj/ataspectj/ltwreweavable/MainReweavableLogging.java

public static void main (String[] args) {
        String ERROR_STRING = "error aspect 'ataspectj.ltwreweavable.AspectReweavableLogging' woven into 'ataspectj.ltwreweavable.MainReweavableLogging' must be declared in an aop.xml file.";
        if(Boolean.getBoolean("aspectDeclared")){
            //if the aspect is declared there should not be an error
            if (MessageHolder.startsAs( Arrays.asList(  new String[]{ ERROR_STRING }  ))
================= fetch private void validateAdvice(MethodDeclaration methodDeclaration) { 9ffc63b^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java
/**
	 * 1) Advice must be public
	 * 2) Advice must have a void return type if not around advice
	 * 3) Advice must not have any other @AspectJ annotations
	 * 4) After throwing advice must declare the thrown formal
	 * 5) After returning advice must declare the returning formal
	 */
private void validateAdvice(MethodDeclaration methodDeclaration) {
		
		if (!insideAspect()) {
			methodDeclaration.scope.problemReporter().signalError(methodDeclaration.sourceStart,
					  methodDeclaration.sourceEnd, 
					  "Advice must be declared inside an aspect type");			
		}
		
		if (!Modifier.isPublic(methodDeclaration.modifiers)) {
			methodDeclaration.scope.problemReporter()
				.signalError(methodDeclaration.sourceStart,methodDeclaration.sourceEnd,"advice must be public");
		}
				
		if (ajAnnotations.hasMultipleAdviceAnnotations) {
			methodDeclaration.scope.problemReporter().disallowedTargetForAnnotation(ajAnnotations.duplicateAdviceAnnotation);
		}
		if (ajAnnotations.hasPointcutAnnotation) {
			methodDeclaration.scope.problemReporter().disallowedTargetForAnnotation(ajAnnotations.pointcutAnnotation);			
		}
		if (ajAnnotations.hasAspectAnnotation) {
			methodDeclaration.scope.problemReporter().disallowedTargetForAnnotation(ajAnnotations.aspectAnnotation);			
		}
		if (ajAnnotations.hasAdviceNameAnnotation) {
			methodDeclaration.scope.problemReporter().disallowedTargetForAnnotation(ajAnnotations.adviceNameAnnotation);			
		}

		if (ajAnnotations.adviceKind != AdviceKind.Around) {
			ensureVoidReturnType(methodDeclaration);
		}	  
		
		if (ajAnnotations.adviceKind == AdviceKind.AfterThrowing) {
			int[] throwingLocation = new int[2];
			String thrownFormal = getStringLiteralFor("throwing",ajAnnotations.adviceAnnotation,throwingLocation);
			if (thrownFormal != null) {
				Argument[] arguments = methodDeclaration.arguments;
				if (!toArgumentNames(methodDeclaration.arguments).contains(thrownFormal)) {
						methodDeclaration.scope.problemReporter()
							.signalError(methodDeclaration.sourceStart,methodDeclaration.sourceEnd,"throwing formal '" + thrownFormal + "' must be declared as a parameter in the advice signature");
				}
			}
		}
		
		if (ajAnnotations.adviceKind == AdviceKind.AfterReturning) {
			int[] throwingLocation = new int[2];
			String returningFormal = getStringLiteralFor("returning",ajAnnotations.adviceAnnotation,throwingLocation);
			if (returningFormal != null) {
				if (!toArgumentNames(methodDeclaration.arguments).contains(returningFormal)) {
						methodDeclaration.scope.problemReporter()
							.signalError(methodDeclaration.sourceStart,methodDeclaration.sourceEnd,"returning formal '" + returningFormal + "' must be declared as a parameter in the advice signature");
				}
			}
		}

		resolveAndSetPointcut(methodDeclaration, ajAnnotations.adviceAnnotation);
		
	}
================= fetch private void validateAspectDeclaration(TypeDeclaration typeDecl) { 9ffc63b^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java
/**
     * aspect must be public
	 * nested aspect must be static
	 * cannot extend a concrete aspect
	 * pointcut in perclause must be good.
	 */
private void validateAspectDeclaration(TypeDeclaration typeDecl) {
		if (typeStack.size() > 1) {
			// it's a nested aspect
			if (!Modifier.isStatic(typeDecl.modifiers)) {
				typeDecl.scope.problemReporter().signalError(typeDecl.sourceStart, typeDecl.sourceEnd, "inner aspects must be static");
				return;
			}
		}
		
		SourceTypeBinding binding = typeDecl.binding;
		if (binding != null) {
			if (binding.isEnum() || binding.isInterface() || binding.isAnnotationType()) {
				typeDecl.scope.problemReporter().signalError(typeDecl.sourceStart,typeDecl.sourceEnd,"only classes can have an @Aspect annotation");
			}
		}

        //FIXME AV - do we really want that
//        if (!Modifier.isPublic(typeDecl.modifiers)) {
//            typeDecl.scope.problemReporter().signalError(typeDecl.sourceStart,typeDecl.sourceEnd,"@Aspect class must be public");
//        }

        TypeReference parentRef = typeDecl.superclass;
		if (parentRef != null) {
			TypeBinding parentBinding = parentRef.resolvedType;
			if (parentBinding instanceof SourceTypeBinding) {
				SourceTypeBinding parentSTB = (SourceTypeBinding) parentBinding;
				if (parentSTB.scope!=null) { // scope is null if its a binarytypebinding (in AJ world, thats a subclass of SourceTypeBinding)
					TypeDeclaration parentDecl = parentSTB.scope.referenceContext; 
					if (isAspect(parentDecl) && !Modifier.isAbstract(parentDecl.modifiers)) {
						typeDecl.scope.problemReporter().signalError(typeDecl.sourceStart,typeDecl.sourceEnd,"cannot extend a concrete aspect");
					}			
				}
			}
		}

		Annotation aspectAnnotation = ajAnnotations.aspectAnnotation;

		int[] pcLoc = new int[2];
		String perClause = getStringLiteralFor("value", aspectAnnotation, pcLoc);
		AspectDeclaration aspectDecl = new AspectDeclaration(typeDecl.compilationResult);

		try {
			if (perClause != null && !perClause.equals("")) {
				ISourceContext context = new EclipseSourceContext(unit.compilationResult,pcLoc[0]);
				Pointcut pc = new PatternParser(perClause,context).maybeParsePerClause();
			    FormalBinding[] bindings = new FormalBinding[0];
				if (pc != null) pc.resolve(new EclipseScope(bindings,typeDecl.scope));
			}
		} catch(ParserException pEx) {
			typeDecl.scope.problemReporter().parseError(
					pcLoc[0] + pEx.getLocation().getStart(),
					pcLoc[0] + pEx.getLocation().getEnd() ,
					-1, 
					perClause.toCharArray(), 
					perClause, 
					new String[] {pEx.getMessage()});
		}
	}
================= fetch public void specializeOn(Shadow shadow) { 3fa4d24^:weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java

public void specializeOn(Shadow shadow) {
	  	if (getKind() == AdviceKind.Around) {
	  		((BcelShadow)shadow).initializeForAroundClosure();
	  	}
    	
    	//XXX this case is just here for supporting lazy test code
    	if (getKind() == null) {
			exposedState = new ExposedState(0);
    		return;
    	}
    	if (getKind().isPerEntry()) {
    		exposedState = new ExposedState(0);
    	} else if (getKind().isCflow()) {
    		exposedState = new ExposedState(nFreeVars);
    	} else if (getSignature() != null) {
			exposedState = new ExposedState(getSignature());
    	} else {
    		exposedState = new ExposedState(0);
    		return;  //XXX this case is just here for supporting lazy test code
    	}
    	
    	World world = shadow.getIWorld();
    	suppressLintWarnings(world);
		pointcutTest = getPointcut().findResidue(shadow, exposedState);
		clearLintSuppressions(world,this.suppressedLintKinds);
		
		// these initializations won't be performed by findResidue, but need to be
		// so that the joinpoint is primed for weaving
		if (getKind() == AdviceKind.PerThisEntry) {
			shadow.getThisVar();
		} else if (getKind() == AdviceKind.PerTargetEntry) {
			shadow.getTargetVar();
		}
		
		
        // make sure thisJoinPoint parameters are initialized
        if ((getExtraParameterFlags() & ThisJoinPointStaticPart) != 0) {
        	((BcelShadow)shadow).getThisJoinPointStaticPartVar();
			((BcelShadow)shadow).getEnclosingClass().warnOnAddedStaticInitializer(shadow,getSourceLocation());
        }

        if ((getExtraParameterFlags() & ThisJoinPoint) != 0) {
    		boolean hasGuardTest = pointcutTest != Literal.TRUE && getKind() != AdviceKind.Around;
    		boolean isAround = getKind() == AdviceKind.Around;
			((BcelShadow)shadow).requireThisJoinPoint(hasGuardTest,isAround);
			((BcelShadow)shadow).getEnclosingClass().warnOnAddedStaticInitializer(shadow,getSourceLocation());
			if (!hasGuardTest && world.getLint().multipleAdviceStoppingLazyTjp.isEnabled()) {
				// collect up the problematic advice
				((BcelShadow)shadow).addAdvicePreventingLazyTjp(this);
			}
			if (!isAround && !hasGuardTest && world.getLint().noGuardForLazyTjp.isEnabled()) {
				// can't build tjp lazily, no suitable test...
				world.getLint().noGuardForLazyTjp.signal(
					    new String[] {shadow.toString()},
					    getSourceLocation(),
					    new ISourceLocation[] { ((BcelShadow)shadow).getSourceLocation() }
					);				
			}
        }
        
        if ((getExtraParameterFlags() & ThisEnclosingJoinPointStaticPart) != 0) {
        	((BcelShadow)shadow).getThisEnclosingJoinPointStaticPartVar();
			((BcelShadow)shadow).getEnclosingClass().warnOnAddedStaticInitializer(shadow,getSourceLocation());
        }
    }
================= fetch public void testPr129163_3() { 3fa4d24^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
// correctly that we don't have to go back to source.
public void testPr129163_3() {
		configureBuildStructureModel(true);
		initialiseProject("PR129163_4");
		build("PR129163_4");
		checkWasFullBuild(); // should be a full build because initializing project
		initialiseProject("PR129163_3");
		configureNewProjectDependency("PR129163_3","PR129163_4");
		build("PR129163_3");
		checkWasFullBuild(); // should be a full build because initializing project
		alter("PR129163_4","inc1");
		build("PR129163_4");
		checkWasntFullBuild(); // should be an incremental build because although
		                       // "inc1" includes the aspect A1.aj, it actually hasn't
							   // changed so we shouldn't go back to source
		alter("PR129163_3","inc1");
		build("PR129163_3");
		checkWasntFullBuild(); // should be an incremental build because nothing has
			                   // changed within the class and no aspects have changed
		                       // within the running of the test
		configureBuildStructureModel(false);
	}
================= fetch public void initializeKindedAnnotationVars() { 3ca976f^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public void initializeKindedAnnotationVars() {
    	if (kindedAnnotationVars != null) return;
    	kindedAnnotationVars = new HashMap();
    	// by determining what "kind" of shadow we are, we can find out the
    	// annotations on the appropriate element (method, field, constructor, type).
    	// Then create one BcelVar entry in the map for each annotation, keyed by
    	// annotation type (UnresolvedType).
    	
    	// FIXME asc Refactor this code, there is duplication
    	ResolvedType[] annotations = null;
    	Member relevantMember = getSignature();
    	ResolvedType  relevantType   = relevantMember.getDeclaringType().resolve(world);
    	
    	if (getKind() == Shadow.StaticInitialization) {
    		annotations  = relevantType.resolve(world).getAnnotationTypes();
    		
    	} else if (getKind() == Shadow.MethodCall  || getKind() == Shadow.ConstructorCall) {
            Member foundMember = findMethod2(relevantType.resolve(world).getDeclaredMethods(),getSignature());            
            annotations = getAnnotations(foundMember, relevantMember, relevantType);
            relevantMember = getRelevantMember(foundMember,relevantMember,relevantType);
            relevantType = relevantMember.getDeclaringType().resolve(world);
    		
    	} else if (getKind() == Shadow.FieldSet || getKind() == Shadow.FieldGet) {
    		relevantMember = findField(relevantType.getDeclaredFields(),getSignature());
    		
			if (relevantMember==null) {
              // check the ITD'd dooberries
				List mungers = relevantType.resolve(world).getInterTypeMungers();
				for (Iterator iter = mungers.iterator(); iter.hasNext();) {
					BcelTypeMunger typeMunger = (BcelTypeMunger) iter.next();
					if (typeMunger.getMunger() instanceof NewFieldTypeMunger) {
					  ResolvedMember fakerm = typeMunger.getSignature();
					  //if (fakerm.hasAnnotations()) 
					  ResolvedMember ajcMethod = AjcMemberMaker.interFieldInitializer(fakerm,typeMunger.getAspectType());
				  	  ResolvedMember rmm       = findMethod(typeMunger.getAspectType(),ajcMethod);
					  if (fakerm.equals(getSignature())) {
						relevantType = typeMunger.getAspectType();
						relevantMember = rmm;
					  }
					}
				}	
			}
    		annotations = relevantMember.getAnnotationTypes();
    		
    	} else if (getKind() == Shadow.MethodExecution || getKind() == Shadow.ConstructorExecution || 
    		        getKind() == Shadow.AdviceExecution) {
    		//ResolvedMember rm[] = relevantType.getDeclaredMethods();
    		Member foundMember = findMethod2(relevantType.getDeclaredMethods(),getSignature());
    		
    		annotations = getAnnotations(foundMember, relevantMember,relevantType);
    		relevantMember = foundMember;
            relevantMember = getRelevantMember(foundMember, relevantMember,relevantType);
            
    	} else if (getKind() == Shadow.ExceptionHandler) {
    		relevantType = getSignature().getParameterTypes()[0].resolve(world);
    		annotations  =  relevantType.getAnnotationTypes();
    		
    	} else if (getKind() == Shadow.PreInitialization || getKind() == Shadow.Initialization) {
    		ResolvedMember found = findMethod2(relevantType.getDeclaredMethods(),getSignature());
    		annotations = found.getAnnotationTypes();
    	}
    	
    	if (annotations == null) {
    		// We can't have recognized the shadow - should blow up now to be on the safe side
    		throw new BCException("Couldn't discover annotations for shadow: "+getKind());
    	}
    	
		for (int i = 0; i < annotations.length; i++) {
			ResolvedType aTX = annotations[i];
			KindedAnnotationAccessVar kaav =  new KindedAnnotationAccessVar(getKind(),aTX.resolve(world),relevantType,relevantMember);
    		kindedAnnotationVars.put(aTX,kaav);
		}
    }
================= fetch public void setPositions(boolean check) { 5d2b5b8^:bcel-builder/src/org/aspectj/apache/bcel/generic/InstructionList.java
/**
   * @return an array of instructions without target information for branch instructions.
   */
public Instruction[] getInstructions() {
    ByteSequence  bytes        = new ByteSequence(getByteCode());
    ArrayList     instructions = new ArrayList();

    try {
      while(bytes.available() > 0) {
	instructions.add(Instruction.readInstruction(bytes));
      }
    } catch(IOException e) { throw new ClassGenException(e.toString()); }

    Instruction[] result = new Instruction[instructions.size()];
    instructions.toArray(result);
    return result;
  }
================= fetch private PointcutParser(Set/*<PointcutPrimitives>*/ supportedPointcutKinds) { b954b26^:weaver/src/org/aspectj/weaver/tools/PointcutParser.java

================= fetch private ResolvedMember createGenericFieldMember(Field forField) { b954b26^:weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java
// for @AspectJ pointcuts compiled by javac only...
private String[] tryToDiscoverParameterNames(Pointcut pcut) {
		Method[] ms = pcut.getDeclaringType().getJavaClass().getDeclaredMethods();
		for(Method m : ms) {
			if (m.getName().equals(pcut.getName())) {
				return argNameFinder.getParameterNames(m);
			}
		}
		return null;
	}
================= fetch public PointcutExpression parsePointcutExpression( b954b26^:weaver/src/org/aspectj/weaver/tools/PointcutParser.java
/**
     * Parse the given pointcut expression.
     * The pointcut is resolved as if it had been declared inside the inScope class
     * (this allows the pointcut to contain unqualified references to other pointcuts
     * declared in the same type for example).
     * The pointcut may contain zero or more formal parameters to be bound at matched
     * join points. 
     * @throws UnsupportedPointcutPrimitiveException if the parser encounters a 
     * primitive pointcut expression of a kind not supported by this PointcutParser.
     * @throws IllegalArgumentException if the expression is not a well-formed 
     * pointcut expression
     */
public PointcutExpression parsePointcutExpression(
    		String expression, 
    		Class inScope,
    		PointcutParameter[] formalParameters) 
    throws UnsupportedPointcutPrimitiveException, IllegalArgumentException {
    	 PointcutExpressionImpl pcExpr = null;
         try {
        	 PatternParser parser = new PatternParser(expression);
        	 parser.setPointcutDesignatorHandlers(pointcutDesignators, world);
             Pointcut pc = parser.parsePointcut();
             validateAgainstSupportedPrimitives(pc,expression);
             IScope resolutionScope = buildResolutionScope((inScope == null ? Object.class : inScope),formalParameters);
             pc = pc.resolve(resolutionScope);
             ResolvedType declaringTypeForResolution = null;
             if (inScope != null) {
            	 declaringTypeForResolution = getWorld().resolve(inScope.getName());
             } else {
            	 declaringTypeForResolution = ResolvedType.OBJECT.resolve(getWorld());
             }
             IntMap arity = new IntMap(formalParameters.length);
             for (int i = 0; i < formalParameters.length; i++) {
            	 arity.put(i, i);
             }             
             pc = pc.concretize(declaringTypeForResolution, declaringTypeForResolution, arity);
             validateAgainstSupportedPrimitives(pc,expression); // again, because we have now followed any ref'd pcuts
             pcExpr = new PointcutExpressionImpl(pc,expression,formalParameters,getWorld());
         } catch (ParserException pEx) {
             throw new IllegalArgumentException(buildUserMessageFromParserException(expression,pEx));
         } catch (ReflectionWorld.ReflectionWorldException rwEx) {
        	 	throw new IllegalArgumentException(rwEx.getMessage());
         }
         return pcExpr;
    }
================= fetch public static PointcutParser getPointcutParserSupportingSpecifiedPrimitivesAndUs b954b26^:weaver/src/org/aspectj/weaver/tools/PointcutParser.java
/**
     * Returns a pointcut parser that can parse pointcut expressions built
     * from a user-defined subset of AspectJ's supported pointcut primitives. 
     * The following restrictions apply:
     * <ul>
     * <li>The <code>if, cflow, and cflowbelow</code> pointcut designators are not supported
     * <li>Pointcut expressions must be self-contained :- they cannot contain references
     * to other named pointcuts
     * <li>The pointcut expression must be anonymous with no formals allowed.
     * </ul>
     * <p>When resolving types in pointcut expressions, the given classloader is used to find types.</p>
     * @param supportedPointcutKinds a set of PointcutPrimitives this parser
     * should support
     * @throws UnsupportedOperationException if the set contains if, cflow, or
     * cflow below
     */
public static PointcutParser getPointcutParserSupportingSpecifiedPrimitivesAndUsingSpecifiedClassLoaderForResolution(Set supportedPointcutKinds, ClassLoader classLoader) {
   		PointcutParser p = new PointcutParser(supportedPointcutKinds);
		p.setClassLoader(classLoader);
		return p;   	
    }
================= fetch public void foo() {} b954b26^:weaver5/java5-testsrc/org/aspectj/weaver/tools/Java15PointcutExpressionTest.java

public void d(A anA, A anotherA) {}
================= fetch public void setWorld(ReflectionWorld aWorld) { b954b26^:weaver/src/org/aspectj/weaver/tools/PointcutParser.java

public void setWorld(ReflectionWorld aWorld) {
    	this.world = aWorld;
    }
================= fetch public void testJavaLangMatching() throws Exception { b954b26^:weaver5/java5-testsrc/org/aspectj/weaver/tools/Java15PointcutExpressionTest.java

public void testJavaLangMatching() throws Exception {
		PointcutExpression ex = parser.parsePointcutExpression("@within(java.lang.Deprecated)");
		Method foo = GoldenOldie.class.getMethod("foo");
		ShadowMatch sm1 = ex.matchesMethodExecution(foo);
		assertTrue("should match",sm1.alwaysMatches());
	}
Progress : [###################---------------------] 48%================= fetch private TypeBinding generatePerObjectInterface( 299c3a4^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java

TypeBinding generatePerObjectInterface(
		ClassFile classFile)
	{
		final EclipseFactory world = EclipseFactory.fromScopeLookupEnvironment(this.scope);
		UnresolvedType interfaceTypeX = 
		    AjcMemberMaker.perObjectInterfaceType(typeX);
		HelperInterfaceBinding interfaceType =
			new HelperInterfaceBinding(this.binding, interfaceTypeX);
		world.addTypeBinding(interfaceType);
		interfaceType.addMethod(world, AjcMemberMaker.perObjectInterfaceGet(typeX));
		interfaceType.addMethod(world, AjcMemberMaker.perObjectInterfaceSet(typeX));
		interfaceType.generateClass(compilationResult, classFile);
		return interfaceType;
	}
================= fetch private void generatePerSupportMembers(ClassFile classFile) { 299c3a4^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java

private void generatePerSupportMembers(ClassFile classFile) {
		if (isAbstract()) return;
		
		//XXX otherwise we need to have this (error handling?)
		if (aspectOfMethod == null) return;
		if (perClause == null) {
			System.err.println("has null perClause: " + this);
			return;
		}
		
		EclipseFactory world = EclipseFactory.fromScopeLookupEnvironment(this.scope);
		
		if (perClause.getKind() == PerClause.SINGLETON) {
			generatePerSingletonAspectOfMethod(classFile);
			generatePerSingletonHasAspectMethod(classFile);
			generatePerSingletonAjcClinitMethod(classFile);
		} else if (perClause.getKind() == PerClause.PERCFLOW) {
			generatePerCflowAspectOfMethod(classFile);
			generatePerCflowHasAspectMethod(classFile);
			generatePerCflowPushMethod(classFile);
			generatePerCflowAjcClinitMethod(classFile);
		} else if (perClause.getKind() == PerClause.PEROBJECT) {
			TypeBinding interfaceType = 
				generatePerObjectInterface(classFile);
			world.addTypeBinding(interfaceType);
			generatePerObjectAspectOfMethod(classFile, interfaceType);
			generatePerObjectHasAspectMethod(classFile, interfaceType);
			generatePerObjectBindMethod(classFile, interfaceType);
		} else if (perClause.getKind() == PerClause.PERTYPEWITHIN) { 
		    //PTWIMPL Generate the methods required *in the aspect*
			generatePerTypeWithinAspectOfMethod(classFile);    //  public static <aspecttype> aspectOf(java.lang.Class)
			generatePerTypeWithinGetInstanceMethod(classFile); // private static <aspecttype> ajc$getInstance(Class c) throws Exception
			generatePerTypeWithinHasAspectMethod(classFile);
			generatePerTypeWithinCreateAspectInstanceMethod(classFile); // generate public static X ajc$createAspectInstance(Class forClass) {
			// PTWIMPL getWithinType() would need this...
			//generatePerTypeWithinGetWithinTypeMethod(classFile); // generate public Class getWithinType() {
		} else {
			throw new RuntimeException("unimplemented");
		}
	}
================= fetch private void recordClassFile(UnwovenClassFile thisTime, File lastTime) { 299c3a4^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java

private void recordClassFile(UnwovenClassFile thisTime, File lastTime) {
		if (simpleStrings == null) {
			// batch build
			// record resolved type for structural comparisions in future increments
			// this records a second reference to a structure already held in memory
			// by the world.
			ResolvedType rType = world.resolve(thisTime.getClassName());
			if (!rType.isMissing()) {
				try {
					ClassFileReader reader = new ClassFileReader(thisTime.getBytes(), null);
					this.resolvedTypeStructuresFromLastBuild.put(thisTime.getClassName(),new CompactStructureRepresentation(reader));
				} catch (ClassFormatException cfe) {
					throw new BCException("Unexpected problem processing class",cfe);
				}
			}
			return;
		}

		CompactStructureRepresentation existingStructure = (CompactStructureRepresentation) this.resolvedTypeStructuresFromLastBuild.get(thisTime.getClassName());
		ReferenceType newResolvedType = (ReferenceType) world.resolve(thisTime.getClassName());
		if (!newResolvedType.isMissing()) {
			try {
				ClassFileReader reader = new ClassFileReader(thisTime.getBytes(), null);
				this.resolvedTypeStructuresFromLastBuild.put(thisTime.getClassName(),new CompactStructureRepresentation(reader));
			} catch (ClassFormatException cfe) {
				throw new BCException("Unexpected problem processing class",cfe);
			}
		}
		
		if (lastTime == null) {
			addDependentsOf(thisTime.getClassName());
			return;
		}

		if (newResolvedType.isMissing()) {
			return;
		}
		world.ensureAdvancedConfigurationProcessed();
		byte[] newBytes = thisTime.getBytes();
		try {
			ClassFileReader reader = new ClassFileReader(newBytes, lastTime.getAbsolutePath().toCharArray());
			// ignore local types since they're only visible inside a single method
			if (!(reader.isLocal() || reader.isAnonymous())) {
				if (hasStructuralChanges(reader,existingStructure)) {
					if (world.forDEBUG_structuralChangesCode) 
						System.err.println("Detected a structural change in "+thisTime.getFilename());
					structuralChangesSinceLastFullBuild.put(thisTime.getFilename(),new Long(currentBuildTime));
					addDependentsOf(new String(reader.getName()).replace('/','.'));
				}
			}
		} catch (ClassFormatException e) {
			addDependentsOf(thisTime.getClassName());
		}							
	}
================= fetch public void addTypeBinding(TypeBinding binding) { 299c3a4^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

public void addTypeBinding(TypeBinding binding) {
		typexToBinding.put(fromBinding(binding), binding);
	}
================= fetch public void testBuildingTwoProjectsMakingSmallChanges() { 299c3a4^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
/**
	 * In order for this next test to run, I had to move the weaver/world pair we keep in the
	 * AjBuildManager instance down into the state object - this makes perfect sense - otherwise
	 * when reusing the state for another project we'd not be switching to the right weaver/world
	 * for that project.
	 */
public void testBuildingTwoProjectsMakingSmallChanges() {
		
		configureBuildStructureModel(true);
		
		initialiseProject("P1");
		initialiseProject("P2");

		build("P1");
		build("P2");
		build("P1");
		checkWasntFullBuild();
		
		build("P2");
		checkWasntFullBuild();
		
		alter("P1","inc1"); // adds a class
		alter("P1","inc2"); // adds an aspect
		build("P1");
		checkWasFullBuild();  // adding an aspect makes us go back to the source
	}
================= fetch String toString (StringMaker sm) { cb5dfe7^:runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java

public final String toLongString() { return toString(StringMaker.longStringMaker); }
================= fetch static boolean getUseCache () { cb5dfe7^:runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java

static boolean getUseCache () {
		return useCache;
	}
================= fetch public Object visit(ThisOrTargetAnnotationPointcut node, Object data) { c667bcb^:weaver/src/org/aspectj/weaver/patterns/PerThisOrTargetPointcutVisitor.java

public Object visit(ThisOrTargetAnnotationPointcut node, Object data) {
        if (m_isTarget && !node.isThis()) {
            return node.getAnnotationTypePattern();
        } else if (!m_isTarget && node.isThis()) {
            return node.getAnnotationTypePattern();
        } else {
            // perthis(@target(Foo))
            return MAYBE;
        }
    }
================= fetch public Object visit(WithinAnnotationPointcut node, Object data) { c667bcb^:weaver/src/org/aspectj/weaver/patterns/PerThisOrTargetPointcutVisitor.java

public Object visit(WithinAnnotationPointcut node, Object data) {
        if (m_isTarget) {
            return MAYBE;
        } else {
            return node.getAnnotationTypePattern();
        }
    }
================= fetch public void setX(String input) { // ajc-only eajc-also docDone 99882cb^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java

================= fetch public boolean equals(Object other) { 1535ee7^:weaver/src/org/aspectj/weaver/PerObjectInterfaceTypeMunger.java

public boolean equals(Object other) {
    	if (!(other instanceof PerObjectInterfaceTypeMunger)) return false;
  		PerObjectInterfaceTypeMunger o = (PerObjectInterfaceTypeMunger)other;
    	return ((o.testPointcut == null) ? (testPointcut == null ) : testPointcut.equals(o.testPointcut))
    			&& ((o.lazyTestTypePattern == null) ? (lazyTestTypePattern == null ) : lazyTestTypePattern.equals(o.lazyTestTypePattern));
    }
================= fetch public void testPr131505() { 1535ee7^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java

public void testPr131505() {
		configureNonStandardCompileOptions("-outxml");
		initialiseProject("PR131505");
		build("PR131505");
		checkWasFullBuild();
		// aop.xml file shouldn't contain any aspects
		checkXMLAspectCount("PR131505","",0);
		// add a new aspect A which should be included in the aop.xml file
		alter("PR131505","inc1");
		build("PR131505");
		checkWasFullBuild();
		checkXMLAspectCount("PR131505","",1);
		checkXMLAspectCount("PR131505","A",1);
		// make changes to the class file which shouldn't affect the contents
		// of the aop.xml file
		alter("PR131505","inc2");
		build("PR131505");
		checkWasntFullBuild();
		checkXMLAspectCount("PR131505","",1);
		checkXMLAspectCount("PR131505","A",1);		
		// add another new aspect A1 which should also be included in the aop.xml file
		// ...there should be no duplicate entries in the file
		alter("PR131505","inc3");
		build("PR131505");
		checkWasFullBuild();
		checkXMLAspectCount("PR131505","",2);
		checkXMLAspectCount("PR131505","A1",1);
		checkXMLAspectCount("PR131505","A",1);
		// delete aspect A1 which meanss that aop.xml file should only contain A
		File a1 = new File(getWorkingDir().getAbsolutePath() 
				+ File.separatorChar + "PR131505" + File.separatorChar + "A1.aj");
		a1.delete();
		build("PR131505");
		checkWasFullBuild();
		checkXMLAspectCount("PR131505","",1);
		checkXMLAspectCount("PR131505","A1",0);
		checkXMLAspectCount("PR131505","A",1);	
		// add another aspect called A which is in a different package, both A
		// and pkg.A should be included in the aop.xml file
		alter("PR131505","inc4");
		build("PR131505");
		checkWasFullBuild();
		checkXMLAspectCount("PR131505","",2);
		checkXMLAspectCount("PR131505","A",1);
		checkXMLAspectCount("PR131505","pkg.A",1);
	}
Progress : [###################---------------------] 49%================= fetch private void ensureOpen() { d1a252e^:weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java

private void ensureOpen() {
			if (zipFile != null && openArchives.contains(zipFile)) {
				if (isReallyOpen()) return;
			}
			try {
				if (openArchives.size()>=maxOpenArchives) {
					closeSomeArchives(openArchives.size()/10); // Close 10% of those open
				}
				zipFile = new ZipFile(file);
				if (!isReallyOpen()) {
					throw new BCException("Can't open archive: "+file.getName()+" (size() check failed)");					
				}
				openArchives.add(zipFile);
			} catch (IOException ioe) {
				throw new BCException("Can't open archive: "+file.getName(),ioe);
			}
		}
================= fetch public ClassFile find(String name) { d1a252e^:weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java

public String getPath() { return file.getPath(); }
================= fetch public ClassFile find(UnresolvedType type) { d1a252e^:weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java

public ClassFile find(UnresolvedType type) {
		String name = type.getName();
		for (Iterator i = entries.iterator(); i.hasNext(); ) {
			Entry entry = (Entry)i.next();
			ClassFile ret = entry.find(name);
			if (ret != null) return ret;
		}
		return null;
	}
================= fetch public List getAllClassFiles() { d1a252e^:weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java
/**
	 * This method is extremely expensive and should only be called rarely
	 */
public List getAllClassFiles() {
		List ret = new ArrayList();
		for (Iterator i = entries.iterator(); i.hasNext(); ) {
			Entry entry = (Entry)i.next();
			ret.addAll(entry.getAllClassFiles());
		}
		return ret;
	}
================= fetch public ZipFile getZipFile() { d1a252e^:weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java

public ZipFile getZipFile() {
			return zipFile;
		}
================= fetch protected ReferenceTypeDelegate resolveDelegate(ReferenceType ty) { 1a6f695^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java

protected ReferenceTypeDelegate resolveDelegate(ReferenceType ty) {
        String name = ty.getName();
        JavaClass jc = null;
    	    ensureAdvancedConfigurationProcessed();
        //UnwovenClassFile classFile = (UnwovenClassFile)sourceJavaClasses.get(name);
        //if (classFile != null) jc = classFile.getJavaClass();
        if (isFastDelegateSupportEnabled() && classPath!=null && !ty.needsModifiableDelegate() && isNotOnPackageRestrictedList(name)) {
	        ClassPathManager.ClassFile cf = classPath.find(ty);
	        if (cf==null) {
	        	return null;
	        } else {
	        	return buildAsmDelegate(ty,cf);
	        }
        } else {
	        if (jc == null) {
	        	jc = lookupJavaClass(classPath, name);
	        }       
	        if (jc == null) {
	        	return null;
	        } else {
	        	return buildBcelDelegate(ty, jc, false);
	        }
	    }
	}
================= fetch public ResolvedType resolve(Type t) { 1a6f695^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java

public ResolvedType resolve(Type t) {
        return resolve(fromBcel(t));
    }
================= fetch public static Test suite() { 1a6f695^:tests/src/org/aspectj/systemtest/AllTests15.java

public static Test suite() {
		TestSuite suite = new TestSuite("AspectJ System Test Suite - JDK 1.5");
		//$JUnit-BEGIN$
		suite.addTest(AllTests14.suite());
		suite.addTest(AllTestsAspectJ150.suite());
		suite.addTest(AllTestsAspectJ151.suite());
		suite.addTest(AtAjAnnotationGenTests.suite());
		//$JUnit-END$
		return suite;
	}
================= fetch public void testLoadingAttributesForMethods() { 1a6f695^:weaver/testsrc/org/aspectj/weaver/bcel/AsmDelegateTests.java

public void testLoadingAttributesForMethods() {
    	boolean debug = false;
    	BcelWorld slowWorld = new BcelWorld(BcweaverTests.TESTDATA_PATH+"/forAsmDelegateTesting/stuff.jar");slowWorld.setFastDelegateSupport(false);
        BcelWorld fastWorld = new BcelWorld(BcweaverTests.TESTDATA_PATH+"/forAsmDelegateTesting/stuff.jar");
        
        ReferenceType bcelT = (ReferenceType)slowWorld.resolve("AspectFromHell");
        ReferenceType asmT  = (ReferenceType)fastWorld.resolve("AspectFromHell");
        
        ResolvedMember[] bcelMethods = bcelT.getDeclaredMethods();
        ResolvedMember[] asmMethods = asmT.getDeclaredMethods(); 
        for (int i = 0; i < bcelMethods.length; i++) {
			BcelMethod bmember = (BcelMethod)bcelMethods[i];
			AsmMethod  amember = (AsmMethod)asmMethods[i];
			assertTrue("Seem to be in a muddle. a="+amember.getName()+" b="+bmember.getName(),
					   amember.getName().equals(bmember.getName()));
			if (debug) System.err.println("Looking at "+bmember);
			String[] bcelMemberAttributes = bmember.getAttributeNames(true);
			String[] asmMemberAttributes  = amember.getAttributeNames(true);
//			System.err.println("BCEL=>\n"+stringifyStringArray(bcelMemberAttributes));
//			System.err.println(" ASM=>\n"+stringifyStringArray(asmMemberAttributes));
			compareAttributeNames(bcelMemberAttributes,asmMemberAttributes);
			
			// Let's check the member ones of interest:
			
			// org.aspectj.weaver.AjSynthetic
			if (bmember.isAjSynthetic()) {
				assertTrue("Why isnt the ASM method ajsynthetic? "+amember.toDebugString(),amember.isAjSynthetic());
			} else {
				assertTrue("Why is the ASM method ajsynthetic? "+amember.toDebugString(),!amember.isAjSynthetic());
			}
			
			// org.aspectj.weaver.EffectiveSignature
			EffectiveSignatureAttribute bcelEsa = bmember.getEffectiveSignature();
			EffectiveSignatureAttribute asmEsa = amember.getEffectiveSignature();
			if (bcelEsa==null) {
				assertTrue("Why isnt the ASM effective signature null? "+asmEsa,asmEsa==null);
			} else {
				if (asmEsa==null) fail("ASM effective signature is null, when BCEL effective signature is "+bcelEsa.toString());
				assertTrue("Should be the same?? b="+bcelEsa.toString()+" a="+asmEsa.toString(),bcelEsa.toString().equals(asmEsa.toString()));
			}
			
			// org.aspectj.weaver.MethodDeclarationLineNumber
			int bLine = bmember.getDeclarationLineNumber();
			int aLine = amember.getDeclarationLineNumber();
			assertTrue("Should be the same number: "+bLine+" "+aLine,bLine==aLine);


			// org.aspectj.weaver.Advice
			ShadowMunger bcelSM = bmember.getAssociatedShadowMunger();
			ShadowMunger asmSM = amember.getAssociatedShadowMunger();
			if (bcelSM==null) {
				assertTrue("Why isnt the ASM effective signature null? "+asmSM,asmSM==null);
			} else {
				if (asmSM==null) fail("ASM effective signature is null, when BCEL effective signature is "+bcelSM.toString());
				assertTrue("Should be the same?? b="+bcelSM.toString()+" a="+asmSM.toString(),bcelSM.toString().equals(asmSM.toString()));
			}
//	          new AjASMAttribute("org.aspectj.weaver.SourceContext"),
		}
        
    }
================= fetch public void testLoadingAttributesForTypes() { 1a6f695^:weaver/testsrc/org/aspectj/weaver/bcel/AsmDelegateTests.java
/**
     * Load up the AspectFromHell and take it apart...
     */
public void testLoadingAttributesForTypes() {
    	BcelWorld slowWorld = new BcelWorld(BcweaverTests.TESTDATA_PATH+"/forAsmDelegateTesting/stuff.jar");slowWorld.setFastDelegateSupport(false);
        BcelWorld fastWorld = new BcelWorld(BcweaverTests.TESTDATA_PATH+"/forAsmDelegateTesting/stuff.jar");
        
        ReferenceType bcelT = (ReferenceType)slowWorld.resolve("AspectFromHell");
        ReferenceType asmT  = (ReferenceType)fastWorld.resolve("AspectFromHell");
        
        AsmDelegate asmD = (AsmDelegate)asmT.getDelegate();
        String [] asmAttributeNames = asmD.getAttributeNames();
        BcelObjectType bcelD = (BcelObjectType)bcelT.getDelegate();
        String [] bcelAttributeNames = bcelD.getAttributeNames();
        
        // Won't be exactly the same number as ASM currently processes some and then discards them - effectively those stored in the delegate
        // are the 'not yet processed' ones
        
        // should be 6 type mungers
        AjAttribute[] asmTypeMungers = asmD.getAttributes("org.aspectj.weaver.TypeMunger");
        AjAttribute[] bcelTypeMungers = bcelD.getAttributes("org.aspectj.weaver.TypeMunger");
        assertTrue("Should be 6 type mungers but asm="+asmTypeMungers.length+" bcel="+bcelTypeMungers.length,asmTypeMungers.length==6 && bcelTypeMungers.length==6);
    }
================= fetch public void weaveAroundInline( 1a6f695^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

void weaveAroundInline(
    	BcelAdvice munger,
    	boolean hasDynamicTest)
	{
		/* Implementation notes:
		 * 
		 * AroundInline still extracts the instructions of the original shadow into 
		 * an extracted method.  This allows inlining of even that advice that doesn't
		 * call proceed or calls proceed more than once. 
		 * 
		 * It extracts the instructions of the original shadow into a method.
		 * 
		 * Then it extracts the instructions of the advice into a new method defined on
		 * this enclosing class.  This new method can then be specialized as below.
		 * 
		 * Then it searches in the instructions of the advice for any call to the
		 * proceed method.
		 * 
		 *   At such a call, there is stuff on the stack representing the arguments to
		 *   proceed.  Pop these into the frame.
		 * 
		 *   Now build the stack for the call to the extracted method, taking values 
		 *   either from the join point state or from the new frame locs from proceed.
		 *   Now call the extracted method.  The right return value should be on the
		 *   stack, so no cast is necessary.
		 *
		 * If only one call to proceed is made, we can re-inline the original shadow.
		 * We are not doing that presently.
		 * 
		 * If the body of the advice can be determined to not alter the stack, or if
		 * this shadow doesn't care about the stack, i.e. method-execution, then the
		 * new method for the advice can also be re-lined.  We are not doing that
		 * presently.
		 */
		 
		// !!! THIS BLOCK OF CODE SHOULD BE IN A METHOD CALLED weaveAround(...);
        Member mungerSig = munger.getSignature();
        //Member originalSig = mungerSig; // If mungerSig is on a parameterized type, originalSig is the member on the generic type
        if (mungerSig instanceof ResolvedMember) {
        	ResolvedMember rm = (ResolvedMember)mungerSig;
        	if (rm.hasBackingGenericMember()) mungerSig = rm.getBackingGenericMember();
        }
        ResolvedType declaringType = world.resolve(mungerSig.getDeclaringType(),true);
        if (declaringType.isMissing()) {
        	world.getLint().cantFindType.signal(
        			new String[] {WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE,declaringType.getClassName())},
        			getSourceLocation(),
        			new ISourceLocation[]{ munger.getSourceLocation()}
        			);
//          IMessage msg = new Message(
//                WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE,declaringType.getClassName()),
//                "",IMessage.ERROR,getSourceLocation(),null,
//                new ISourceLocation[]{ munger.getSourceLocation()});
//          world.getMessageHandler().handleMessage(msg);
        }
        //??? might want some checks here to give better errors
        BcelObjectType ot = BcelWorld.getBcelObjectType((declaringType.isParameterizedType()?declaringType.getGenericType():declaringType)); 
        
		LazyMethodGen adviceMethod = ot.getLazyClassGen().getLazyMethodGen(mungerSig);
		if (!adviceMethod.getCanInline()) {
			weaveAroundClosure(munger, hasDynamicTest);
			return;
		}

        // specific test for @AJ proceedInInners
        if (munger.getConcreteAspect().isAnnotationStyleAspect()) {
            // if we can't find one proceed()
            // we suspect that the call is happening in an inner class
            // so we don't inline it.
            // Note: for code style, this is done at Aspect compilation time.
            boolean canSeeProceedPassedToOther = false;
            InstructionHandle curr = adviceMethod.getBody().getStart();
            InstructionHandle end = adviceMethod.getBody().getEnd();
            ConstantPoolGen cpg = adviceMethod.getEnclosingClass().getConstantPoolGen();
            while (curr != end) {
                InstructionHandle next = curr.getNext();
                Instruction inst = curr.getInstruction();
                if ((inst instanceof InvokeInstruction)
                    && ((InvokeInstruction)inst).getSignature(cpg).indexOf("Lorg/aspectj/lang/ProceedingJoinPoint;") > 0) {
                    // we may want to refine to exclude stuff returning jp ?
                    // does code style skip inline if i write dump(thisJoinPoint) ?
                    canSeeProceedPassedToOther = true;// we see one pjp passed around - dangerous
                    break;
                }
                curr = next;
            }
            if (canSeeProceedPassedToOther) {
                // remember this decision to avoid re-analysis
                adviceMethod.setCanInline(false);
                weaveAroundClosure(munger, hasDynamicTest);
                return;
            }
        }



		// We can't inline around methods if they have around advice on them, this
		// is because the weaving will extract the body and hence the proceed call.
		//??? should consider optimizations to recognize simple cases that don't require body extraction
		enclosingMethod.setCanInline(false);
		
		// start by exposing various useful things into the frame
		final InstructionFactory fact = getFactory();
		
		// now generate the aroundBody method
        LazyMethodGen extractedMethod = 
        	extractMethod(
        		NameMangler.aroundCallbackMethodName(
        			getSignature(),
        			getEnclosingClass()),
				Modifier.PRIVATE,
				munger
            );
        			
        			
        // now extract the advice into its own method
        String adviceMethodName =
			NameMangler.aroundCallbackMethodName(
							getSignature(),
							getEnclosingClass()) + "$advice";
        
		List argVarList = new ArrayList();
		List proceedVarList = new ArrayList();
		int extraParamOffset = 0;
		
		// Create the extra parameters that are needed for passing to proceed
		// This code is very similar to that found in makeCallToCallback and should
		// be rationalized in the future
		if (thisVar != null) {
			argVarList.add(thisVar);
			proceedVarList.add(new BcelVar(thisVar.getType(), extraParamOffset));
			extraParamOffset += thisVar.getType().getSize();
		}
		
		if (targetVar != null && targetVar != thisVar) {
			argVarList.add(targetVar);
			proceedVarList.add(new BcelVar(targetVar.getType(), extraParamOffset));
			extraParamOffset += targetVar.getType().getSize();
		}
		for (int i = 0, len = getArgCount(); i < len; i++) {
			argVarList.add(argVars[i]);
			proceedVarList.add(new BcelVar(argVars[i].getType(), extraParamOffset));
			extraParamOffset += argVars[i].getType().getSize();
		}
		if (thisJoinPointVar != null) {
			argVarList.add(thisJoinPointVar);
			proceedVarList.add(new BcelVar(thisJoinPointVar.getType(), extraParamOffset));
			extraParamOffset += thisJoinPointVar.getType().getSize();
		}
        
        Type[] adviceParameterTypes = adviceMethod.getArgumentTypes();
        Type[] extractedMethodParameterTypes = extractedMethod.getArgumentTypes();
		Type[] parameterTypes =
			new Type[extractedMethodParameterTypes.length
				+ adviceParameterTypes.length
				+ 1];
		int parameterIndex = 0;
		System.arraycopy(
			extractedMethodParameterTypes,
			0,
			parameterTypes,
			parameterIndex,
			extractedMethodParameterTypes.length);
		parameterIndex += extractedMethodParameterTypes.length;

		parameterTypes[parameterIndex++] =
			BcelWorld.makeBcelType(adviceMethod.getEnclosingClass().getType());
		System.arraycopy(
			adviceParameterTypes,
			0,
			parameterTypes,
			parameterIndex,
			adviceParameterTypes.length);

        LazyMethodGen localAdviceMethod =
					new LazyMethodGen(
						Modifier.PRIVATE | Modifier.FINAL | Modifier.STATIC, 
						BcelWorld.makeBcelType(mungerSig.getReturnType()), 
						adviceMethodName,
						parameterTypes,
						new String[0],
						getEnclosingClass());
 
		String donorFileName = adviceMethod.getEnclosingClass().getInternalFileName();
		String recipientFileName = getEnclosingClass().getInternalFileName();
//		System.err.println("donor " + donorFileName);
//		System.err.println("recip " + recipientFileName);
		if (! donorFileName.equals(recipientFileName)) {
			localAdviceMethod.fromFilename = donorFileName;
			getEnclosingClass().addInlinedSourceFileInfo(
				donorFileName,
				adviceMethod.highestLineNumber);
		}
    
		getEnclosingClass().addMethodGen(localAdviceMethod);
		
		// create a map that will move all slots in advice method forward by extraParamOffset
		// in order to make room for the new proceed-required arguments that are added at
		// the beginning of the parameter list
		int nVars = adviceMethod.getMaxLocals() + extraParamOffset;
		IntMap varMap = IntMap.idMap(nVars);
		for (int i=extraParamOffset; i < nVars; i++) {
			varMap.put(i-extraParamOffset, i);
		}

		localAdviceMethod.getBody().insert(
			BcelClassWeaver.genInlineInstructions(adviceMethod,
					localAdviceMethod, varMap, fact, true));


					
		localAdviceMethod.setMaxLocals(nVars);
					
		//System.err.println(localAdviceMethod);
		
    
    	// the shadow is now empty.  First, create a correct call
    	// to the around advice.  This includes both the call (which may involve 
    	// value conversion of the advice arguments) and the return
    	// (which may involve value conversion of the return value).  Right now
    	// we push a null for the unused closure.  It's sad, but there it is.
    	    	
    	InstructionList advice = new InstructionList();
        // InstructionHandle adviceMethodInvocation;
        {
			for (Iterator i = argVarList.iterator(); i.hasNext(); ) {
				BcelVar var = (BcelVar)i.next();
				var.appendLoad(advice, fact);
			}       	
        	// ??? we don't actually need to push NULL for the closure if we take care
			advice.append(
				munger.getAdviceArgSetup(
					this,
					null,
                    (munger.getConcreteAspect().isAnnotationStyleAspect() && munger.getDeclaringAspect()!=null && munger.getDeclaringAspect().resolve(world).isAnnotationStyleAspect())?
                        this.loadThisJoinPoint():
					    new InstructionList(InstructionConstants.ACONST_NULL)));
		    // adviceMethodInvocation =
		        advice.append(
		        	Utility.createInvoke(fact, localAdviceMethod)); //(fact, getWorld(), munger.getSignature()));
			advice.append(
		        Utility.createConversion(
		            getFactory(), 
		            BcelWorld.makeBcelType(mungerSig.getReturnType()), 
		            extractedMethod.getReturnType(),world.isInJava5Mode()));
		    if (! isFallsThrough()) {
		        advice.append(InstructionFactory.createReturn(extractedMethod.getReturnType()));
		    }
        }
        
		// now, situate the call inside the possible dynamic tests,
		// and actually add the whole mess to the shadow
        if (! hasDynamicTest) {
            range.append(advice);
        } else {
        	InstructionList afterThingie = new InstructionList(InstructionConstants.NOP);
            InstructionList callback = makeCallToCallback(extractedMethod);
			if (terminatesWithReturn()) {
				callback.append(
					InstructionFactory.createReturn(extractedMethod.getReturnType()));
			} else {
				//InstructionHandle endNop = range.insert(fact.NOP, Range.InsideAfter);
				advice.append(
					InstructionFactory.createBranchInstruction(
						Constants.GOTO,
						afterThingie.getStart()));
			}
			range.append(
				munger.getTestInstructions(
					this,
					advice.getStart(),
					callback.getStart(),
					advice.getStart()));
            range.append(advice);
            range.append(callback);
            range.append(afterThingie);          
        }        


        // now search through the advice, looking for a call to PROCEED.  
        // Then we replace the call to proceed with some argument setup, and a 
        // call to the extracted method.

        // inlining support for code style aspects
        if (!munger.getConcreteAspect().isAnnotationStyleAspect()) {
            String proceedName =
                NameMangler.proceedMethodName(munger.getSignature().getName());

            InstructionHandle curr = localAdviceMethod.getBody().getStart();
            InstructionHandle end = localAdviceMethod.getBody().getEnd();
            ConstantPoolGen cpg = localAdviceMethod.getEnclosingClass().getConstantPoolGen();
            while (curr != end) {
                InstructionHandle next = curr.getNext();
                Instruction inst = curr.getInstruction();
                if ((inst instanceof INVOKESTATIC)
                    && proceedName.equals(((INVOKESTATIC) inst).getMethodName(cpg))) {

                    localAdviceMethod.getBody().append(
                        curr,
                        getRedoneProceedCall(
                            fact,
                            extractedMethod,
                            munger,
                            localAdviceMethod,
                            proceedVarList));
                    Utility.deleteInstruction(curr, localAdviceMethod);
                }
                curr = next;
            }
            // and that's it.
        } else {
            //ATAJ inlining support for @AJ aspects
            // [TODO document @AJ code rule: don't manipulate 2 jps proceed at the same time.. in an advice body]
            InstructionHandle curr = localAdviceMethod.getBody().getStart();
            InstructionHandle end = localAdviceMethod.getBody().getEnd();
            ConstantPoolGen cpg = localAdviceMethod.getEnclosingClass().getConstantPoolGen();
            while (curr != end) {
                InstructionHandle next = curr.getNext();
                Instruction inst = curr.getInstruction();
                if ((inst instanceof INVOKEINTERFACE)
                    && "proceed".equals(((INVOKEINTERFACE) inst).getMethodName(cpg))) {
                    final boolean isProceedWithArgs;
                    if (((INVOKEINTERFACE) inst).getArgumentTypes(cpg).length == 1) {
                        // proceed with args as a boxed Object[]
                        isProceedWithArgs = true;
                    } else {
                        isProceedWithArgs = false;
                    }
                    InstructionList insteadProceedIl = getRedoneProceedCallForAnnotationStyle(
                            fact,
                            extractedMethod,
                            munger,
                            localAdviceMethod,
                            proceedVarList,
                            isProceedWithArgs
                    );
                    localAdviceMethod.getBody().append(curr, insteadProceedIl);
                    Utility.deleteInstruction(curr, localAdviceMethod);
                }
                curr = next;
            }
        }
	}
================= fetch public boolean addOrReplaceAspect(ResolvedType aspectType,boolean careAboutShado 94d8b82^:weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java
/**
	 * @return whether or not that was a change to the global signature
	 * 			XXX for efficiency we will need a richer representation than this
	 */
public boolean addOrReplaceAspect(ResolvedType aspectType,boolean careAboutShadowMungers) {
		boolean change = false;
		CrosscuttingMembers xcut = (CrosscuttingMembers)members.get(aspectType);
		if (xcut == null) {
			members.put(aspectType, aspectType.collectCrosscuttingMembers());
			clearCaches();
			CflowPointcut.clearCaches(aspectType);
			change = true;
		} else {
			if (xcut.replaceWith(aspectType.collectCrosscuttingMembers(),careAboutShadowMungers)) {
				clearCaches();

				CflowPointcut.clearCaches(aspectType);
				change = true;
			} else {
				change = false;
			}
		}
		if (aspectType.isAbstract()) {
			// we might have sub-aspects that need to re-collect their crosscutting members from us
			boolean ancestorChange = addOrReplaceDescendantsOf(aspectType,careAboutShadowMungers); 
			change = change || ancestorChange;
		}
		changedSinceLastReset = changedSinceLastReset || change;
		return change;
	}
================= fetch public boolean replaceWith(CrosscuttingMembers other,boolean careAboutShadowMung 94d8b82^:weaver/src/org/aspectj/weaver/CrosscuttingMembers.java
/**
	 * Updates the records if something has changed. This is called at most twice, firstly
	 * whilst collecting ITDs and declares. At this point the CrosscuttingMembers we're 
	 * comparing ourselves with doesn't know about shadowmungers. Therefore a straight comparison
	 * with the existing list of shadowmungers would return that something has changed
	 * even though it might not have, so in this first round we ignore the shadowMungers. 
	 * The second time this is called is whilst we're preparing to weave. At this point 
	 * we know everything in the system and so we're able to compare the shadowMunger list.
	 * (see bug 129163)
	 * 
	 * @param other
	 * @param careAboutShadowMungers
	 * @return true if something has changed since the last time this method was
	 *         called, false otherwise
	 */
public boolean replaceWith(CrosscuttingMembers other,boolean careAboutShadowMungers) {
		boolean changed = false;
		
		if (perClause == null || !perClause.equals(other.perClause)) {
			changed = true;
			perClause = other.perClause;
		}
		
		//XXX all of the below should be set equality rather than list equality
		//System.err.println("old: " + shadowMungers + " new: " + other.shadowMungers);
		
  	    if (careAboutShadowMungers) {
		    // bug 129163: use set equality rather than list equality 
			Set theseShadowMungers = new HashSet();
			theseShadowMungers.addAll(shadowMungers);
			Set otherShadowMungers = new HashSet();
			otherShadowMungers.addAll(other.shadowMungers);
			
			PointcutRewriter pr = new PointcutRewriter();
			for (Iterator iter = otherShadowMungers.iterator(); iter.hasNext();) {
				ShadowMunger munger = (ShadowMunger) iter.next();
				Pointcut p = munger.getPointcut();
				Pointcut newP = pr.rewrite(p);
				munger.setPointcut(newP);
			}
			if (!theseShadowMungers.equals(otherShadowMungers)) {
				changed = true;
				shadowMungers = other.shadowMungers;
			}
  	    }
  	    
		// bug 129163: use set equality rather than list equality and
  	    // if we dont care about shadow mungers then ignore those 
  	    // typeMungers which are created to help with the implementation 
  	    // of shadowMungers
		Set theseTypeMungers = new HashSet();
		Set otherTypeMungers = new HashSet();
		if (!careAboutShadowMungers) {
			for (Iterator iter = typeMungers.iterator(); iter.hasNext();) {
				Object o = iter.next();
				if (o instanceof BcelTypeMunger) {
					BcelTypeMunger typeMunger = (BcelTypeMunger) o;
					if (!typeMunger.existsToSupportShadowMunging()) {
						theseTypeMungers.add(typeMunger);
					}				
				} else {
					theseTypeMungers.add(o);
				}
			}
			
			for (Iterator iter = other.typeMungers.iterator(); iter.hasNext();) {
				Object o = iter.next();
				if (o instanceof BcelTypeMunger) {
					BcelTypeMunger typeMunger = (BcelTypeMunger) o;
					if (!typeMunger.existsToSupportShadowMunging()) {
						otherTypeMungers.add(typeMunger);
					}
				} else {
					otherTypeMungers.add(o);
				}
			}
		} else {
			theseTypeMungers.addAll(typeMungers);
			otherTypeMungers.addAll(other.typeMungers);
		}
  	    
  	    // initial go at equivalence logic rather than set compare (see pr133532)
//		if (theseTypeMungers.size()!=otherTypeMungers.size()) {
//			changed = true;
//			typeMungers = other.typeMungers;
//		} else {
//			boolean foundInequality=false;
//			for (Iterator iter = theseTypeMungers.iterator(); iter.hasNext() && !foundInequality;) {
//				Object thisOne = (Object) iter.next();
//				boolean foundInOtherSet = false;
//				for (Iterator iterator = otherTypeMungers.iterator(); iterator.hasNext();) {
//					Object otherOne = (Object) iterator.next();
//					if (thisOne instanceof ConcreteTypeMunger && otherOne instanceof ConcreteTypeMunger) {
//						if (((ConcreteTypeMunger)thisOne).equivalentTo(otherOne)) {
//							foundInOtherSet=true;
//						} else if (thisOne.equals(otherOne)) {
//							foundInOtherSet=true;
//						}
//					} else {
//						if (thisOne.equals(otherOne)) {
//							foundInOtherSet=true;
//						} 
//					}
//				}
//				if (!foundInOtherSet) foundInequality=true;
//			}
//			if (foundInequality) {
//				changed = true;
//				typeMungers = other.typeMungers;
////			} else {
////				typeMungers = other.typeMungers;
//			}
//		}
  	    if (!theseTypeMungers.equals(otherTypeMungers)) {
			changed = true;
			typeMungers = other.typeMungers;
		}

        if (!lateTypeMungers.equals(other.lateTypeMungers)) {
            changed = true;
            lateTypeMungers = other.lateTypeMungers;
        }

		if (!declareDominates.equals(other.declareDominates)) {
			changed = true;
			declareDominates = other.declareDominates;
		}
		
		if (!declareParents.equals(other.declareParents)) {
			changed = true;
			declareParents = other.declareParents;
		}
		
		if (!declareSofts.equals(other.declareSofts)) {
			changed = true;
			declareSofts = other.declareSofts;
		}
		
		// DECAT for when attempting to replace an aspect
		if (!declareAnnotationsOnType.equals(other.declareAnnotationsOnType)) {
			changed = true;
			declareAnnotationsOnType = other.declareAnnotationsOnType;
		}
		
		if (!declareAnnotationsOnField.equals(other.declareAnnotationsOnField)) {
			changed = true;
			declareAnnotationsOnField = other.declareAnnotationsOnField;
		}
		
		if (!declareAnnotationsOnMethods.equals(other.declareAnnotationsOnMethods)) {
			changed = true;
			declareAnnotationsOnMethods = other.declareAnnotationsOnMethods;
		}
		
		return changed;
	}
================= fetch public void testPr133532_2() { 94d8b82^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java

public void testPr133532_2() {
		initialiseProject("pr133532_2");
		build("pr133532_2");
		alter("pr133532_2","inc2");
		build("pr133532_2");
		assertTrue("There should be no errors reported:\n"+MyTaskListManager.getErrorMessages(),
				MyTaskListManager.getErrorMessages().isEmpty());	
		String decisions = AjdeInteractionTestbed.MyStateListener.getDecisions();
		String expect="Need to recompile 'A.aj'";
		assertTrue("Couldn't find build decision: '"+expect+"' in the list of decisions made:\n"+decisions,
				  decisions.indexOf(expect)!=-1);
	}
================= fetch private void ensureVoidReturnType(MethodDeclaration methodDeclaration) { 41f1f3a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java

private FormalBinding[] buildFormalAdviceBindingsFrom(MethodDeclaration mDecl) {
		if (mDecl.arguments == null) return new FormalBinding[0];
		EclipseFactory factory = EclipseFactory.fromScopeLookupEnvironment(mDecl.scope);
		String extraArgName = maybeGetExtraArgName();
		if (extraArgName == null) extraArgName = "";
		FormalBinding[] ret = new FormalBinding[mDecl.arguments.length];
		for (int i = 0; i < mDecl.arguments.length; i++) {
            Argument arg = mDecl.arguments[i];
            String name = new String(arg.name);
			TypeBinding argTypeBinding = mDecl.binding.parameters[i];
            UnresolvedType type = factory.fromBinding(argTypeBinding);
			if  (CharOperation.equals(joinPoint,argTypeBinding.signature()) ||
				 CharOperation.equals(joinPointStaticPart,argTypeBinding.signature()) ||
				 CharOperation.equals(joinPointEnclosingStaticPart,argTypeBinding.signature()) ||
				 CharOperation.equals(proceedingJoinPoint,argTypeBinding.signature()) ||
				 name.equals(extraArgName)) {
				ret[i] = new FormalBinding.ImplicitFormalBinding(type,name,i);
			} else {
	            ret[i] = new FormalBinding(type, name, i, arg.sourceStart, arg.sourceEnd, "unknown");						
			}
		}
		return ret;
	}
================= fetch public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) { fa2ed1b^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java

public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {			
		IProgramElement peNode = null;
		// For intertype decls, use the modifiers from the original signature, not the generated method

		if (methodDeclaration instanceof InterTypeDeclaration) {
			InterTypeDeclaration itd = (InterTypeDeclaration) methodDeclaration;
			ResolvedMember sig = itd.getSignature();
			peNode = new ProgramElement(
						null,
						IProgramElement.Kind.ERROR,
						makeLocation(methodDeclaration),
						(sig!=null?sig.getModifiers():0),null,null);
		
		} else {
			peNode = new ProgramElement(
				null,
				IProgramElement.Kind.ERROR,
				makeLocation(methodDeclaration),
				methodDeclaration.modifiers,null,null); 
		}
		formatter.genLabelAndKind(methodDeclaration, peNode); // will set the name
		genBytecodeInfo(methodDeclaration, peNode);
		List namedPointcuts = genNamedPointcuts(methodDeclaration);
		addUsesPointcutRelationsForNode(peNode, namedPointcuts, methodDeclaration);
		
		if (methodDeclaration.returnType!=null) {
			// if we don't make the distinction between ITD fields and other
			// methods, then we loose the type, for example int, for the field
			// and instead get "void".
			if (peNode.getKind().equals(IProgramElement.Kind.INTER_TYPE_FIELD)) {
				peNode.setCorrespondingType(methodDeclaration.returnType.toString());
			} else {
				peNode.setCorrespondingType(methodDeclaration.returnType.resolvedType.debugName());				
			}
		} else {
		  peNode.setCorrespondingType(null);	
		}
		peNode.setSourceSignature(genSourceSignature(methodDeclaration));
		peNode.setFormalComment(generateJavadocComment(methodDeclaration));
		
		// TODO: add return type test
		if (peNode.getKind().equals(IProgramElement.Kind.METHOD)) {
			if ((peNode.getName().charAt(0)=='m') && 
			       (peNode.toLabelString().equals("main(String[])")
					|| peNode.toLabelString().equals("main(java.lang.String[])"))
				&& peNode.getModifiers().contains(IProgramElement.Modifiers.STATIC)
				&& peNode.getAccessibility().equals(IProgramElement.Accessibility.PUBLIC)) {
				((IProgramElement)stack.peek()).setRunnable(true);
			}	
		}
		
		stack.push(peNode);
		return true;
	}
================= fetch public void genLabelAndKind(MethodDeclaration methodDeclaration, IProgramElement 91473b3^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java

public void genLabelAndKind(MethodDeclaration methodDeclaration, IProgramElement node) {
		
		if (methodDeclaration instanceof AdviceDeclaration) { 
			AdviceDeclaration ad = (AdviceDeclaration)methodDeclaration;
			node.setKind(IProgramElement.Kind.ADVICE);

			if (ad.kind == AdviceKind.Around) {
				node.setCorrespondingType(ad.returnType.toString()); //returnTypeToString(0));
			}
	
			StringBuffer details = new StringBuffer();
			if (ad.pointcutDesignator != null) {	
				if (ad.pointcutDesignator.getPointcut() instanceof ReferencePointcut) {
					ReferencePointcut rp = (ReferencePointcut)ad.pointcutDesignator.getPointcut();
					details.append(rp.name).append("..");
				} else if (ad.pointcutDesignator.getPointcut() instanceof AndPointcut) {
					AndPointcut ap = (AndPointcut)ad.pointcutDesignator.getPointcut();
					if (ap.getLeft() instanceof ReferencePointcut) {
						details.append(ap.getLeft().toString()).append(DOUBLE_DOTS);	
					} else {
						details.append(POINTCUT_ANONYMOUS).append(DOUBLE_DOTS);
					}
				} else if (ad.pointcutDesignator.getPointcut() instanceof OrPointcut) {
					OrPointcut op = (OrPointcut)ad.pointcutDesignator.getPointcut();
					if (op.getLeft() instanceof ReferencePointcut) {
						details.append(op.getLeft().toString()).append(DOUBLE_DOTS);	
					} else {
						details.append(POINTCUT_ANONYMOUS).append(DOUBLE_DOTS);
					}
				} else {
					details.append(POINTCUT_ANONYMOUS);
				}
			} else {
				details.append(POINTCUT_ABSTRACT);
			} 
			node.setName(ad.kind.toString());
			//if (details.length()!=0) 
			node.setDetails(details.toString());
			setParameters(methodDeclaration, node);

		} else if (methodDeclaration instanceof PointcutDeclaration) { 
			PointcutDeclaration pd = (PointcutDeclaration)methodDeclaration;
			node.setKind(IProgramElement.Kind.POINTCUT);
			node.setName(translatePointcutName(new String(methodDeclaration.selector)));
			setParameters(methodDeclaration, node);
			
		} else if (methodDeclaration instanceof DeclareDeclaration) { 
			DeclareDeclaration declare = (DeclareDeclaration)methodDeclaration;
			String name = DEC_LABEL + " ";
			if (declare.declareDecl instanceof DeclareErrorOrWarning) {
				DeclareErrorOrWarning deow = (DeclareErrorOrWarning)declare.declareDecl;
				
				if (deow.isError()) {
					node.setKind( IProgramElement.Kind.DECLARE_ERROR);
					name += DECLARE_ERROR;
				} else {
					node.setKind( IProgramElement.Kind.DECLARE_WARNING);
					name += DECLARE_WARNING;
				}
				node.setName(name) ;
				node.setDetails("\"" + genDeclareMessage(deow.getMessage()) + "\"");
				
			} else if (declare.declareDecl instanceof DeclareParents) {

				node.setKind( IProgramElement.Kind.DECLARE_PARENTS);
				DeclareParents dp = (DeclareParents)declare.declareDecl;
				node.setName(name + DECLARE_PARENTS);
				
				String kindOfDP = null;
				StringBuffer details = new StringBuffer("");
				TypePattern[] newParents = dp.getParents().getTypePatterns();
				for (int i = 0; i < newParents.length; i++) {
					TypePattern tp = newParents[i];
					UnresolvedType tx = tp.getExactType();
					if (kindOfDP == null) {
					  kindOfDP = "implements ";
					  try {
					  	ResolvedType rtx = tx.resolve(((AjLookupEnvironment)declare.scope.environment()).factory.getWorld());
						if (!rtx.isInterface()) kindOfDP = "extends ";
					  } catch (Throwable t) {
					  	// What can go wrong???? who knows!
					  }
					  
					}
					String typename= tp.toString();
					if (typename.lastIndexOf(".")!=-1) {
						typename=typename.substring(typename.lastIndexOf(".")+1);
					}
					details.append(typename);
					if ((i+1)<newParents.length) details.append(",");
				}
				node.setDetails(kindOfDP+details.toString());

			} else if (declare.declareDecl instanceof DeclareSoft) {
				node.setKind( IProgramElement.Kind.DECLARE_SOFT);
				DeclareSoft ds = (DeclareSoft)declare.declareDecl;
				node.setName(name + DECLARE_SOFT);
				node.setDetails(genTypePatternLabel(ds.getException()));
				
			} else if (declare.declareDecl instanceof DeclarePrecedence) {
				node.setKind( IProgramElement.Kind.DECLARE_PRECEDENCE);
				DeclarePrecedence ds = (DeclarePrecedence)declare.declareDecl;
				node.setName(name + DECLARE_PRECEDENCE);
				node.setDetails(genPrecedenceListLabel(ds.getPatterns()));
				
			} else if (declare.declareDecl instanceof DeclareAnnotation) {
			    DeclareAnnotation deca = (DeclareAnnotation)declare.declareDecl;
				String thekind = deca.getKind().toString();
				node.setName(name+"@"+thekind.substring(3));

			    if (deca.getKind()==DeclareAnnotation.AT_CONSTRUCTOR) {
			      node.setKind(IProgramElement.Kind.DECLARE_ANNOTATION_AT_CONSTRUCTOR);
			    } else  if (deca.getKind()==DeclareAnnotation.AT_FIELD) {
			      node.setKind(IProgramElement.Kind.DECLARE_ANNOTATION_AT_FIELD);
			    } else  if (deca.getKind()==DeclareAnnotation.AT_METHOD) {
			      node.setKind(IProgramElement.Kind.DECLARE_ANNOTATION_AT_METHOD);
			    } else  if (deca.getKind()==DeclareAnnotation.AT_TYPE) {
			      node.setKind(IProgramElement.Kind.DECLARE_ANNOTATION_AT_TYPE);
			    }
			    node.setDetails(genDecaLabel(deca));
			    
			} else {
				node.setKind(IProgramElement.Kind.ERROR);
				node.setName(DECLARE_UNKNONWN);
			}
			
		} else if (methodDeclaration instanceof InterTypeDeclaration) {
			InterTypeDeclaration itd = (InterTypeDeclaration)methodDeclaration;
			String name = itd.getOnType().toString() + "." + new String(itd.getDeclaredSelector()); 
			if (methodDeclaration instanceof InterTypeFieldDeclaration) {
				node.setKind(IProgramElement.Kind.INTER_TYPE_FIELD);
				node.setName(name);
			} else if (methodDeclaration instanceof InterTypeMethodDeclaration) {
				node.setKind(IProgramElement.Kind.INTER_TYPE_METHOD);
				node.setName(name);
			} else if (methodDeclaration instanceof InterTypeConstructorDeclaration) {
				node.setKind(IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR);
				
	//			StringBuffer argumentsSignature = new StringBuffer("fubar");
//				argumentsSignature.append("(");
//				if (methodDeclaration.arguments!=null && methodDeclaration.arguments.length>1) {
//		
//				for (int i = 1;i<methodDeclaration.arguments.length;i++) {
//					argumentsSignature.append(methodDeclaration.arguments[i]);
//					if (i+1<methodDeclaration.arguments.length) argumentsSignature.append(",");
//				}
//				}
//				argumentsSignature.append(")");
//				InterTypeConstructorDeclaration itcd = (InterTypeConstructorDeclaration)methodDeclaration;				
				node.setName(itd.getOnType().toString() + "." + itd.getOnType().toString()/*+argumentsSignature.toString()*/);
			} else {
				node.setKind(IProgramElement.Kind.ERROR);
				node.setName(name);
			}
			node.setCorrespondingType(itd.returnType.toString());
			if (node.getKind() != IProgramElement.Kind.INTER_TYPE_FIELD) {
				setParameters(methodDeclaration, node);
			}		
		} else {			
			if (methodDeclaration.isConstructor()) {
				node.setKind(IProgramElement.Kind.CONSTRUCTOR);
			} else {
				node.setKind(IProgramElement.Kind.METHOD);

                //TODO AV - could speed up if we could dig only for @Aspect declaring types (or aspect if mixed style allowed)
                //??? how to : node.getParent().getKind().equals(IProgramElement.Kind.ASPECT)) {
                if (true && methodDeclaration!=null && methodDeclaration.annotations != null) {
                    for (int i = 0; i < methodDeclaration.annotations.length; i++) {
                        //Note: AV: implicit single advice type support here (should be enforced somewhere as well (APT etc))
                        Annotation annotation = methodDeclaration.annotations[i];
                        String annotationSig = new String(annotation.type.getTypeBindingPublic(methodDeclaration.scope).signature());
                        if (annotationSig!=null && annotationSig.charAt(1)=='o') {
	                        if ("Lorg/aspectj/lang/annotation/Pointcut;".equals(annotationSig)) {
	                            node.setKind(IProgramElement.Kind.POINTCUT);
	                            break;
	                        } else if ("Lorg/aspectj/lang/annotation/Before;".equals(annotationSig)
	                                   || "Lorg/aspectj/lang/annotation/After;".equals(annotationSig)
	                                   || "Lorg/aspectj/lang/annotation/AfterReturning;".equals(annotationSig)
	                                   || "Lorg/aspectj/lang/annotation/AfterThrowing;".equals(annotationSig)
	                                   || "Lorg/aspectj/lang/annotation/Around;".equals(annotationSig)) {
	                            node.setKind(IProgramElement.Kind.ADVICE);
	                            //TODO AV - all are considered anonymous - is that ok?
	                            node.setDetails(POINTCUT_ANONYMOUS);
	                            break;
	                        }
                        }
                    }
                }
			}
			node.setName(new String(methodDeclaration.selector));
			setParameters(methodDeclaration, node);
		}
	}
Progress : [####################--------------------] 50%================= fetch private boolean verifyTypeParameters(ResolvedType baseType,IScope scope, boolean c9a60e5^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
/**
	 * When this method is called, we have resolved the base type to an exact type.
	 * We also have a set of type patterns for the parameters.
	 * Time to perform some basic checks:
	 *  - can the base type be parameterized? (is it generic)
	 *  - can the type parameter pattern list match the number of parameters on the base type
	 *  - do all parameter patterns meet the bounds of the respective type variables
	 *  If any of these checks fail, a warning message is issued and we return false.
	 * @return
	 */
private boolean verifyTypeParameters(ResolvedType baseType,IScope scope, boolean requireExactType) {
		ResolvedType genericType = baseType.getGenericType();
		if (genericType == null) {
			// issue message "does not match because baseType.getName() is not generic"
			scope.message(MessageUtil.warn(
					WeaverMessages.format(WeaverMessages.NOT_A_GENERIC_TYPE,baseType.getName()),
					getSourceLocation()));
			return false;
		}
		int minRequiredTypeParameters = typeParameters.size();
		boolean foundEllipsis = false;
		TypePattern[] typeParamPatterns = typeParameters.getTypePatterns();
		for (int i = 0; i < typeParamPatterns.length; i++) {
			if (typeParamPatterns[i] instanceof WildTypePattern) {
				WildTypePattern wtp = (WildTypePattern) typeParamPatterns[i];
				if (wtp.ellipsisCount > 0) {
					foundEllipsis = true;
					minRequiredTypeParameters--;
				}
			}
		}
		TypeVariable[] tvs = genericType.getTypeVariables();
		if ((tvs.length < minRequiredTypeParameters) ||
			(!foundEllipsis && minRequiredTypeParameters != tvs.length))
		{
			// issue message "does not match because wrong no of type params"
			String msg = WeaverMessages.format(WeaverMessages.INCORRECT_NUMBER_OF_TYPE_ARGUMENTS,
					                           genericType.getName(),new Integer(tvs.length));
			if (requireExactType)   scope.message(MessageUtil.error(msg,getSourceLocation()));
			else					scope.message(MessageUtil.warn(msg,getSourceLocation()));
			return false;
		} 
		
		// now check that each typeParameter pattern, if exact, matches the bounds
		// of the type variable.
		return checkBoundsOK(scope,genericType,requireExactType);
		
		// return true;
	}
================= fetch public boolean checkBoundsOK(IScope scope,ResolvedType genericType,boolean requi c9a60e5^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java

public boolean checkBoundsOK(IScope scope,ResolvedType genericType,boolean requireExactType) {
		if (boundscheckingoff) return true;
		TypeVariable[] tvs = genericType.getTypeVariables();
		TypePattern[] typeParamPatterns = typeParameters.getTypePatterns();
		if (typeParameters.areAllExactWithNoSubtypesAllowed()) {
			for (int i = 0; i < tvs.length; i++) {
				UnresolvedType ut = typeParamPatterns[i].getExactType();
				boolean continueCheck = true;
				// FIXME asc dont like this but ok temporary measure.  If the type parameter 
				// is itself a type variable (from the generic aspect) then assume it'll be
				// ok... (see pr112105)  Want to break this? Run GenericAspectK test.
				if (ut.isTypeVariableReference()) {
					continueCheck = false;
				}
				
				if (continueCheck &&	
						!tvs[i].canBeBoundTo(ut.resolve(scope.getWorld()))) {
					// issue message that type parameter does not meet specification
					String parameterName = ut.getName();
					if (ut.isTypeVariableReference()) parameterName = ((TypeVariableReference)ut).getTypeVariable().getDisplayName();
					String msg = 
						WeaverMessages.format(
							WeaverMessages.VIOLATES_TYPE_VARIABLE_BOUNDS,
							parameterName,
							new Integer(i+1),
							tvs[i].getDisplayName(),
							genericType.getName());
					if (requireExactType)  scope.message(MessageUtil.error(msg,getSourceLocation()));	
					else				   scope.message(MessageUtil.warn(msg,getSourceLocation()));	
					return false;
				}
			}
		}
		return true;
	}
================= fetch public boolean hasChangedSinceLastReset() { c9a60e5^:weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java

public boolean hasChangedSinceLastReset() {
		return changedSinceLastReset;
	}
================= fetch public void completeTypeBindings() { c9a60e5^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java
//??? duplicates some of super's code
public void completeTypeBindings() {
		AsmManager.setCompletingTypeBindings(true);
		ContextToken completeTypeBindingsToken = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.COMPLETING_TYPE_BINDINGS, "");
//		builtInterTypesAndPerClauses = false;
		//pendingTypesToWeave = new ArrayList();
		stepCompleted = BUILD_TYPE_HIERARCHY;
		
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.CHECK_AND_SET_IMPORTS, units[i].compilationResult.fileName);
			units[i].scope.checkAndSetImports();
			CompilationAndWeavingContext.leavingPhase(tok);
		}
		stepCompleted = CHECK_AND_SET_IMPORTS;
	
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.CONNECTING_TYPE_HIERARCHY, units[i].compilationResult.fileName);
			units[i].scope.connectTypeHierarchy();
			CompilationAndWeavingContext.leavingPhase(tok);
		}
		stepCompleted = CONNECT_TYPE_HIERARCHY;
	
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.BUILDING_FIELDS_AND_METHODS, units[i].compilationResult.fileName);
			units[i].scope.buildFieldsAndMethods();
			CompilationAndWeavingContext.leavingPhase(tok);
		}
		
		// would like to gather up all TypeDeclarations at this point and put them in the factory
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			SourceTypeBinding[] b = units[i].scope.topLevelTypes;
			for (int j = 0; j < b.length; j++) {
				factory.addSourceTypeBinding(b[j],units[i]);
			}
		}
		
		// We won't find out about anonymous types until later though, so register to be
		// told about them when they turn up.
		AnonymousClassPublisher.aspectOf().setAnonymousClassCreationListener(this);
		
		// need to build inter-type declarations for all AspectDeclarations at this point
		// this MUST be done in order from super-types to subtypes
		List typesToProcess = new ArrayList();
		for (int i=lastCompletedUnitIndex+1; i<=lastUnitIndex; i++) {
			CompilationUnitScope cus = units[i].scope;
			SourceTypeBinding[] stbs = cus.topLevelTypes;
			for (int j=0; j<stbs.length; j++) {
				SourceTypeBinding stb = stbs[j];
				typesToProcess.add(stb);
			}
		}
		factory.getWorld().getCrosscuttingMembersSet().reset();
		while (typesToProcess.size()>0) {
			// removes types from the list as they are processed...
			collectAllITDsAndDeclares((SourceTypeBinding)typesToProcess.get(0),typesToProcess);
		}		
				
		factory.finishTypeMungers();
	
		// now do weaving
		Collection typeMungers = factory.getTypeMungers();
		
		Collection declareParents = factory.getDeclareParents();
		Collection declareAnnotationOnTypes = factory.getDeclareAnnotationOnTypes();

		doPendingWeaves();
		
		// We now have some list of types to process, and we are about to apply the type mungers.
		// There can be situations where the order of types passed to the compiler causes the
		// output from the compiler to vary - THIS IS BAD.  For example, if we have class A
		// and class B extends A.  Also, an aspect that 'declare parents: A+ implements Serializable'
		// then depending on whether we see A first, we may or may not make B serializable.
		
		// The fix is to process them in the right order, ensuring that for a type we process its 
		// supertypes and superinterfaces first.  This algorithm may have problems with:
		// - partial hierarchies (e.g. suppose types A,B,C are in a hierarchy and A and C are to be woven but not B)
		// - weaving that brings new types in for processing (see pendingTypesToWeave.add() calls) after we thought
		//   we had the full list.
		// 
		// but these aren't common cases (he bravely said...)
		boolean typeProcessingOrderIsImportant = declareParents.size()>0 || declareAnnotationOnTypes.size()>0; //DECAT
		
		if (typeProcessingOrderIsImportant) {
			typesToProcess = new ArrayList();
			for (int i=lastCompletedUnitIndex+1; i<=lastUnitIndex; i++) {
				CompilationUnitScope cus = units[i].scope;
				SourceTypeBinding[] stbs = cus.topLevelTypes;
				for (int j=0; j<stbs.length; j++) {
					SourceTypeBinding stb = stbs[j];
					typesToProcess.add(stb);
				}
			}

			while (typesToProcess.size()>0) {
				// A side effect of weaveIntertypes() is that the processed type is removed from the collection
				weaveIntertypes(typesToProcess,(SourceTypeBinding)typesToProcess.get(0),typeMungers,declareParents,declareAnnotationOnTypes);
			}
		
		} else {
			// Order isn't important
			for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
				//System.err.println("Working on "+new String(units[i].getFileName()));
				weaveInterTypeDeclarations(units[i].scope, typeMungers, declareParents,declareAnnotationOnTypes);
			}
		}
		
		for (int i = lastCompletedUnitIndex +1; i<=lastUnitIndex; i++) {
			SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
            	verifyAnyTypeParametersMeetBounds(b[j]);
            }
		}
		
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
            	ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.RESOLVING_POINTCUT_DECLARATIONS, b[j].sourceName);
                resolvePointcutDeclarations(b[j].scope);
                CompilationAndWeavingContext.leavingPhase(tok);
            }
        }
        
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
            	ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.ADDING_DECLARE_WARNINGS_AND_ERRORS, b[j].sourceName);
            	addAdviceLikeDeclares(b[j].scope);
                CompilationAndWeavingContext.leavingPhase(tok);
            }
        }
        
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            units[i] = null; // release unnecessary reference to the parsed unit
        }
                
		stepCompleted = BUILD_FIELDS_AND_METHODS;
		lastCompletedUnitIndex = lastUnitIndex;
		AsmManager.setCompletingTypeBindings(false);
		CompilationAndWeavingContext.leavingPhase(completeTypeBindingsToken);	
	}
================= fetch public void reset() { c9a60e5^:weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java

public void reset() {
		changedSinceLastReset = false;
	}
================= fetch private void ensureAtTargetInitialized() { 2fb86fe^:weaver/src/org/aspectj/weaver/AnnotationX.java
/**
   * Makes sure we have looked for the @target() annotation on this annotation.
   * Calling this method initializes (and caches) the information for later use.
   */
private void ensureAtTargetInitialized() {
	if (!lookedForAtTargetAnnotation) {
  		lookedForAtTargetAnnotation = true;
  		atTargetAnnotation = retrieveAnnotationOnAnnotation(UnresolvedType.AT_TARGET);
  		if (atTargetAnnotation != null) {
  			supportedTargets = new HashSet();
  			List values = atTargetAnnotation.getBcelAnnotation().getValues();
  		  	ElementNameValuePair envp = (ElementNameValuePair)values.get(0);
  		  	ArrayElementValue aev = (ArrayElementValue)envp.getValue();
  		  	ElementValue[] evs = aev.getElementValuesArray();
  		  	for (int i = 0; i < evs.length; i++) {
  				EnumElementValue ev = (EnumElementValue)evs[i];
  				supportedTargets.add(ev.getEnumValueString());
  			}
  		}
  	}
  }
================= fetch public String toSignatureString(boolean getFullyQualifiedArgTypes) { 9dca72e^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public String toSignatureString(boolean getFullyQualifiedArgTypes) {
		StringBuffer sb = new StringBuffer();
		sb.append(name);
		
		List ptypes = getParameterTypes();
		if (ptypes != null) {
			sb.append('('); 
			for (Iterator it = ptypes.iterator(); it.hasNext(); ) {
				String arg = (String)it.next();
				if (getFullyQualifiedArgTypes) {
					sb.append(arg);
				} else {
					int index = arg.lastIndexOf(".");
					if (index != -1) {
						sb.append(arg.substring(index + 1));
					} else {
						sb.append(arg);
					}
				}
				if (it.hasNext()) sb.append(", ");
			}
			sb.append(')');
		}
		
		return sb.toString();		
	}
================= fetch public void testAdvice() { 9dca72e^:ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java

public void testAdvice() {
		IProgramElement node = (IProgramElement)model.getRoot();
		assertNotNull(node);
	
		IProgramElement aspect = AsmManager.getDefault().getHierarchy().findElementForType(null, "AdviceNamingCoverage");
		assertNotNull(aspect);	

		String anon = "before(): <anonymous pointcut>";
		IProgramElement anonNode = model.findElementForLabel(aspect, IProgramElement.Kind.ADVICE, anon);
		assertNotNull(anonNode);		
		assertEquals(anonNode.toLabelString(), anon);			

		String named = "before(): named..";
		IProgramElement namedNode = model.findElementForLabel(aspect, IProgramElement.Kind.ADVICE, named);
		assertNotNull(namedNode);		
		assertEquals(namedNode.toLabelString(), named);		

		String namedWithOneArg = "around(int): namedWithOneArg..";
		IProgramElement namedWithOneArgNode = model.findElementForLabel(aspect, IProgramElement.Kind.ADVICE, namedWithOneArg);
		assertNotNull(namedWithOneArgNode);		
		assertEquals(namedWithOneArgNode.toLabelString(), namedWithOneArg);		

		String afterReturning = "afterReturning(int, int): namedWithArgs..";
		IProgramElement afterReturningNode = model.findElementForLabel(aspect, IProgramElement.Kind.ADVICE, afterReturning);
		assertNotNull(afterReturningNode);		
		assertEquals(afterReturningNode.toLabelString(), afterReturning);

		String around = "around(int): namedWithOneArg..";
		IProgramElement aroundNode = model.findElementForLabel(aspect, IProgramElement.Kind.ADVICE, around);
		assertNotNull(aroundNode);		
		assertEquals(aroundNode.toLabelString(), around);

		String compAnon = "before(int): <anonymous pointcut>..";
		IProgramElement compAnonNode = model.findElementForLabel(aspect, IProgramElement.Kind.ADVICE, compAnon);
		assertNotNull(compAnonNode);		
		assertEquals(compAnonNode.toLabelString(), compAnon);

		String compNamed = "before(int): named()..";
		IProgramElement compNamedNode = model.findElementForLabel(aspect, IProgramElement.Kind.ADVICE, compNamed);
		assertNotNull(compNamedNode);		
		assertEquals(compNamedNode.toLabelString(), compNamed);
	}
================= fetch public void testAdviceNamingCoverage() throws Exception { 9dca72e^:ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java
/**
     * Test that all the different types of advice appear
     * with the named pointcut in it's description 
     */
public void testAdviceNamingCoverage() throws Exception {
    	File[] files = {file4};
    	runAjdoc("private","1.4",files);
    	
        File htmlFile = new File(getAbsolutePathOutdir() + "/foo/AdviceNamingCoverage.html");
		if (htmlFile == null || !htmlFile.exists()) {
			fail("couldn't find " + htmlFile.getAbsolutePath()
					+ " - were there compilation errors?");
		}
        
		String[] strings = { 
				"after(): named..",
				"afterReturning(int, int): namedWithArgs..",
				"afterThrowing(): named..",
				"before(): named..",
				"around(int): namedWithOneArg..",
				"before(int):",
				"before(int): named()..",
				"before():"};
		List missing = AjdocOutputChecker.getMissingStringsInSection(
				htmlFile, strings,"ADVICE DETAIL SUMMARY");
		assertTrue(htmlFile.getName() + " should contain all advice in the Advice Detail section",missing.isEmpty());
		missing = AjdocOutputChecker.getMissingStringsInSection(
				htmlFile,strings,"ADVICE SUMMARY");
		assertTrue(htmlFile.getName() + " should contain all advice in the Advice Summary section",missing.isEmpty());
    }
================= fetch public void testIProgramElementMethods_pr125295() { 9dca72e^:tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java

public void testIProgramElementMethods_pr125295() {
	  runTest("new IProgramElement methods");  
  	  IHierarchy top = AsmManager.getDefault().getHierarchy();

  	  IProgramElement pe = top.findElementForType("pkg","foo");
  	  assertNotNull("Couldn't find 'foo' element in the tree",pe);
  	  // check that the defaults return the fully qualified arg
  	  assertEquals("foo(int, java.lang.Object)",pe.toLabelString());
  	  assertEquals("C.foo(int, java.lang.Object)",pe.toLinkLabelString());
  	  assertEquals("foo(int, java.lang.Object)",pe.toSignatureString());
  	  // check that can get hold of the non qualified args
  	  assertEquals("foo(int, Object)",pe.toLabelString(false));
  	  assertEquals("C.foo(int, Object)",pe.toLinkLabelString(false));
  	  assertEquals("foo(int, Object)",pe.toSignatureString(false));

  	  IProgramElement pe2 = top.findElementForType("pkg","printParameters");
  	  assertNotNull("Couldn't find 'printParameters' element in the tree",pe2);
  	  // the argument is org.aspectj.lang.JoinPoint, check that this is added
  	  assertFalse("printParameters method should have arguments",pe2.getParameterTypes().isEmpty());	  
  }
================= fetch public void testInterTypeDeclarations() { 9dca72e^:ajde/testsrc/org/aspectj/ajde/AsmRelationshipsTest.java

public void testInterTypeDeclarations() {		
		checkInterTypeMapping("InterTypeDecCoverage", "Point", "Point.xxx", "Point", 
			"declared on", "aspect declarations", IProgramElement.Kind.INTER_TYPE_FIELD);	
		checkInterTypeMapping("InterTypeDecCoverage", "Point", "Point.check(int, Line)", 
			"Point", "declared on", "aspect declarations", IProgramElement.Kind.INTER_TYPE_METHOD);	
	}
================= fetch public void testInterTypeMemberDeclares() { 9dca72e^:ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java

public void testInterTypeMemberDeclares() {
		IProgramElement node = (IProgramElement)model.getRoot();
		assertNotNull(node);
	
		IProgramElement aspect = AsmManager.getDefault().getHierarchy().findElementForType(null, "InterTypeDecCoverage");
		assertNotNull(aspect);
		
		String fieldMsg = "Point.xxx";
		IProgramElement fieldNode = model.findElementForLabel(aspect, IProgramElement.Kind.INTER_TYPE_FIELD, fieldMsg);
		assertNotNull(fieldNode);		
		assertEquals(fieldNode.toLabelString(), fieldMsg);

		String methodMsg = "Point.check(int, Line)";
		IProgramElement methodNode = model.findElementForLabel(aspect, IProgramElement.Kind.INTER_TYPE_METHOD, methodMsg);
		assertNotNull(methodNode);		
		assertEquals(methodNode.toLabelString(), methodMsg);

		// TODO: enable
//		String constructorMsg = "Point.new(int, int, int)";
//		ProgramElementNode constructorNode = model.findNode(aspect, ProgramElementNode.Kind.INTER_TYPE_CONSTRUCTOR, constructorMsg);
//		assertNotNull(constructorNode);		
//		assertEquals(constructorNode.toLabelString(), constructorMsg);
	}
================= fetch public void testPointcuts() { 9dca72e^:ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java

public void testPointcuts() {
		IProgramElement node = (IProgramElement)model.getRoot();
		assertNotNull(node);
	
		IProgramElement aspect = AsmManager.getDefault().getHierarchy().findElementForType(null, "AdviceNamingCoverage");
		assertNotNull(aspect);		
	
		String ptct = "named()";
		IProgramElement ptctNode = model.findElementForSignature(aspect, IProgramElement.Kind.POINTCUT, ptct);
		assertNotNull(ptctNode);		
		assertEquals(ptctNode.toLabelString(), ptct);		

		String params = "namedWithArgs(int, int)";
		IProgramElement paramsNode = model.findElementForSignature(aspect, IProgramElement.Kind.POINTCUT, params);
		assertNotNull(paramsNode);		
		assertEquals(paramsNode.toLabelString(), params);	
	}
================= fetch public void testStructureModelForGenericITD_pr131932() { 9dca72e^:tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java

public void testStructureModelForGenericITD_pr131932() {
 	  //AsmManager.setReporting("c:/debug.txt",true,true,true,true);
	  runTest("structure model for generic itd");
	  IHierarchy top = AsmManager.getDefault().getHierarchy();
 	   
  	  // get the IProgramElements corresponding to the ITDs and classes
  	  IProgramElement foo = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.CLASS,"Foo");
  	  assertNotNull("Couldn't find Foo element in the tree",foo);
  	  IProgramElement bar = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.CLASS,"Bar");
  	  assertNotNull("Couldn't find Bar element in the tree",bar);

  	  IProgramElement method = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.INTER_TYPE_METHOD,"Bar.getFirst()");  	   	 
  	  assertNotNull("Couldn't find 'Bar.getFirst()' element in the tree",method);
  	  IProgramElement field = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.INTER_TYPE_FIELD,"Bar.children");  	   	 
  	  assertNotNull("Couldn't find 'Bar.children' element in the tree",field);
  	  IProgramElement constructor = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR,"Foo.Foo(List<T>)");  	   	 
  	  assertNotNull("Couldn't find 'Foo.Foo(List<T>)' element in the tree",constructor);
  	  
  	  // check that the relationship map has 'itd method declared on bar'
  	  List matches = AsmManager.getDefault().getRelationshipMap().get(method);
  	  assertNotNull("itd Bar.getFirst() should have some relationships but does not",matches);
  	  assertTrue("method itd should have one relationship but has " + matches.size(), matches.size() == 1);
  	  List matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("itd Bar.getFirst() should have one target but has " + matchesTargets.size(),matchesTargets.size() == 1);
  	  IProgramElement target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the Bar class but is IPE with label "
  			  + target.toLabelString(),bar,target);

  	  // check that the relationship map has 'itd field declared on bar'
  	  matches = AsmManager.getDefault().getRelationshipMap().get(field);
  	  assertNotNull("itd Bar.children should have some relationships but does not",matches);
  	  assertTrue("field itd should have one relationship but has " + matches.size(), matches.size() == 1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("itd Bar.children should have one target but has " + matchesTargets.size(),matchesTargets.size() == 1);
  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the Bar class but is IPE with label "
  			  + target.toLabelString(),bar,target);

  	  // check that the relationship map has 'itd constructor declared on foo'
  	  matches = AsmManager.getDefault().getRelationshipMap().get(constructor);
  	  assertNotNull("itd Foo.Foo(List<T>) should have some relationships but does not",matches);
  	  assertTrue("constructor itd should have one relationship but has " + matches.size(), matches.size() == 1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("itd Foo.Foo(List<T>) should have one target but has " + matchesTargets.size(),matchesTargets.size() == 1);
  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the Foo class but is IPE with label "
  			  + target.toLabelString(),foo,target);
  	  
  	  // check that the relationship map has 'bar aspect declarations method and field itd'
  	  matches = AsmManager.getDefault().getRelationshipMap().get(bar);
  	  assertNotNull("Bar should have some relationships but does not",matches);
  	  assertTrue("Bar should have one relationship but has " + matches.size(), matches.size() == 1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("Bar should have two targets but has " + matchesTargets.size(),matchesTargets.size() == 2);
  	  for (Iterator iter = matchesTargets.iterator(); iter.hasNext();) {
		  String element = (String) iter.next();
		  target = AsmManager.getDefault().getHierarchy().findElementForHandle(element);
		  if (!target.equals(method) && !target.equals(field)) {
			  fail("Expected rel target to be " + method.toLabelString() + " or " + field.toLabelString() 
					+ ", found " + target.toLabelString());
		  }
	  }

  	  // check that the relationship map has 'foo aspect declarations constructor itd'
 	  matches = AsmManager.getDefault().getRelationshipMap().get(foo);
  	  assertNotNull("Foo should have some relationships but does not",matches);
  	  assertTrue("Foo should have one relationship but has " + matches.size(), matches.size() == 1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("Foo should have one target but has " + matchesTargets.size(),matchesTargets.size() == 1);
 	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the Foo.Foo(List<T>) itd but is IPE with label "
  			  + target.toLabelString(),constructor,target);
  }
================= fetch public ResolvedTypeMunger parameterizedFor(ResolvedType target) { e2703cf^:weaver/src/org/aspectj/weaver/NewConstructorTypeMunger.java
/**
     * see ResolvedTypeMunger.parameterizedFor(ResolvedType)
     */
public ResolvedTypeMunger parameterizedFor(ResolvedType target) {
		ResolvedType genericType = target;
		if (target.isRawType() || target.isParameterizedType()) genericType = genericType.getGenericType();
		ResolvedMember parameterizedSignature = null;
		// If we are parameterizing it for a generic type, we just need to 'swap the letters' from the ones used 
		// in the original ITD declaration to the ones used in the actual target type declaration.
		if (target.isGenericType()) {
			TypeVariable vars[] = target.getTypeVariables();
			UnresolvedTypeVariableReferenceType[] varRefs = new UnresolvedTypeVariableReferenceType[vars.length];
			for (int i = 0; i < vars.length; i++) {
				varRefs[i] = new UnresolvedTypeVariableReferenceType(vars[i]);
			}
			parameterizedSignature = getSignature().parameterizedWith(varRefs,genericType,true,typeVariableAliases);
		} else {
		  // For raw and 'normal' parameterized targets  (e.g. Interface, Interface<String>)
		  parameterizedSignature = getSignature().parameterizedWith(target.getTypeParameters(),genericType,target.isParameterizedType(),typeVariableAliases);
		}
		return new NewConstructorTypeMunger(parameterizedSignature,syntheticConstructor,explicitConstructor,getSuperMethodsCalled(),typeVariableAliases);
	}
================= fetch public ResolvedTypeMunger parameterizedFor(ResolvedType target) { e2703cf^:weaver/src/org/aspectj/weaver/NewFieldTypeMunger.java
/**
     * see ResolvedTypeMunger.parameterizedFor(ResolvedType)
     */
public ResolvedTypeMunger parameterizedFor(ResolvedType target) {
		ResolvedType genericType = target;
		if (target.isRawType() || target.isParameterizedType()) genericType = genericType.getGenericType();
		ResolvedMember parameterizedSignature = null;
		// If we are parameterizing it for a generic type, we just need to 'swap the letters' from the ones used 
		// in the original ITD declaration to the ones used in the actual target type declaration.
		if (target.isGenericType()) {
			TypeVariable vars[] = target.getTypeVariables();
			UnresolvedTypeVariableReferenceType[] varRefs = new UnresolvedTypeVariableReferenceType[vars.length];
			for (int i = 0; i < vars.length; i++) {
				varRefs[i] = new UnresolvedTypeVariableReferenceType(vars[i]);
			}
			parameterizedSignature = getSignature().parameterizedWith(varRefs,genericType,true,typeVariableAliases);
		} else {
		  // For raw and 'normal' parameterized targets  (e.g. Interface, Interface<String>)
		  parameterizedSignature = getSignature().parameterizedWith(target.getTypeParameters(),genericType,target.isParameterizedType(),typeVariableAliases);
		}
		NewFieldTypeMunger nftm = new NewFieldTypeMunger(parameterizedSignature,getSuperMethodsCalled(),typeVariableAliases);
	    nftm.setDeclaredSignature(getSignature());
	    return nftm;
	}
================= fetch public ResolvedTypeMunger parameterizedFor(ResolvedType target) { e2703cf^:weaver/src/org/aspectj/weaver/NewMethodTypeMunger.java
/**
     * see ResolvedTypeMunger.parameterizedFor(ResolvedType)
     */
public ResolvedTypeMunger parameterizedFor(ResolvedType target) {
		ResolvedType genericType = target;
		if (target.isRawType() || target.isParameterizedType()) genericType = genericType.getGenericType();
		ResolvedMember parameterizedSignature = null;
		// If we are parameterizing it for a generic type, we just need to 'swap the letters' from the ones used 
		// in the original ITD declaration to the ones used in the actual target type declaration.
		if (target.isGenericType()) {
			TypeVariable vars[] = target.getTypeVariables();
			UnresolvedTypeVariableReferenceType[] varRefs = new UnresolvedTypeVariableReferenceType[vars.length];
			for (int i = 0; i < vars.length; i++) {
				varRefs[i] = new UnresolvedTypeVariableReferenceType(vars[i]);
			}
			parameterizedSignature = getSignature().parameterizedWith(varRefs,genericType,true,typeVariableAliases);
		} else {
		  // For raw and 'normal' parameterized targets  (e.g. Interface, Interface<String>)
		  parameterizedSignature = getSignature().parameterizedWith(target.getTypeParameters(),genericType,target.isParameterizedType(),typeVariableAliases);
		}
		NewMethodTypeMunger nmtm = new NewMethodTypeMunger(parameterizedSignature,getSuperMethodsCalled(),typeVariableAliases);
		nmtm.setDeclaredSignature(getSignature());
		return nmtm;
	}
================= fetch public void testGenericAspectWithUnknownType_pr131933() { e2703cf^:tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java

public void testGenericAspectWithUnknownType_pr131933() {
	  runTest("no ClassCastException with generic aspect and unknown type");
  }
================= fetch public UnresolvedType resolveExactType(IScope scope, Bindings bindings) { f2cd94f^:weaver/src/org/aspectj/weaver/patterns/TypePattern.java

public UnresolvedType resolveExactType(IScope scope, Bindings bindings) {
		TypePattern p = resolveBindings(scope, bindings, false, true);
		if (p == NO) return ResolvedType.MISSING;
		
		return ((ExactTypePattern)p).getType();
	}
================= fetch public void testSwallowedExceptionIgnored() { f2cd94f^:tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java

public void testSwallowedExceptionIgnored() {
	  runTest("swallowed exceptions with xlint");
  }
================= fetch private static void log(String msg) { b3cd01d^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java

private static void log(String msg) {
		if (VERBOSE) System.out.println(msg);
	}
================= fetch private void addAspectName (String name) { b3cd01d^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void addAspectName (String name) {
				BcelWorld world = getBcelWorld();
				ResolvedType type = world.resolve(name);
//				System.err.println("? writeAspectName() type=" + type);
				if (type.isAspect()) {
					aspectNames.add(name);
				}
			}
================= fetch private void writeOutxmlFile () throws IOException { b3cd01d^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void writeOutxmlFile () throws IOException {
		String filename = buildConfig.getOutxmlName();
//		System.err.println("? AjBuildManager.writeOutxmlFile() outxml=" + filename);
//		System.err.println("? AjBuildManager.writeOutxmlFile() outputDir=" + buildConfig.getOutputDir());
		
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		PrintStream ps = new PrintStream(baos);
		ps.println("<aspectj>");
		ps.println("<aspects>");
		for (Iterator i = aspectNames.iterator(); i.hasNext();) {
			String name = (String)i.next();
			ps.println("<aspect name=\"" + name + "\"/>");
		}
		ps.println("</aspects>");
		ps.println("</aspectj>");
		ps.println();
		ps.close();

		if (zos != null) {
			ZipEntry newEntry = new ZipEntry(filename);
			
			zos.putNextEntry(newEntry);
			zos.write(baos.toByteArray());
			zos.closeEntry();
		} else {
			OutputStream fos = 
				FileUtil.makeOutputStream(new File(buildConfig.getOutputDir(),filename));
			fos.write(baos.toByteArray());
			fos.close();
		}
	}
================= fetch public boolean accept(File f) { b3cd01d^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void copyResourcesFromDirectory(File dir) throws IOException {
		if (!COPY_INPATH_DIR_RESOURCES) return;
		// Get a list of all files (i.e. everything that isnt a directory)
		File[] files = FileUtil.listFiles(dir,new FileFilter() {
			public boolean accept(File f) {
				boolean accept = !(f.isDirectory() || f.getName().endsWith(".class")) ;
				return accept;
			}
		});
		
		// For each file, add it either as a real .class file or as a resource
		for (int i = 0; i < files.length; i++) {
			// ASSERT: files[i].getAbsolutePath().startsWith(inFile.getAbsolutePath()
			// or we are in trouble...
			String filename = files[i].getAbsolutePath().substring(
			                    dir.getAbsolutePath().length()+1);
			copyResourcesFromFile(files[i],filename,dir);
		}		
	}
================= fetch public void testPr129163_3() { b3cd01d^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
// correctly that we don't have to go back to source.
public void testPr129163_3() {
		configureBuildStructureModel(true);
		initialiseProject("PR129163_4");
		build("PR129163_4");
		checkWasFullBuild(); // should be a full build because initializing project
		initialiseProject("PR129163_3");
		configureNewProjectDependency("PR129163_3","PR129163_4");
		build("PR129163_3");
		checkWasFullBuild(); // should be a full build because initializing project
		alter("PR129163_4","inc1");
		build("PR129163_4");
		checkWasntFullBuild(); // should be an incremental build because although
		                       // "inc1" includes the aspect A1.aj, it actually hasn't
							   // changed so we shouldn't go back to source
		alter("PR129163_3","inc1");
		build("PR129163_3");
		checkWasntFullBuild(); // should be an incremental build because nothing has
			                   // changed within the class and no aspects have changed
		                       // within the running of the test
		configureBuildStructureModel(false);
	}
================= fetch public void wipeAllKnowledge() { b3cd01d^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java

public void wipeAllKnowledge() {
		buildManager.state = null;
		buildManager.setStructureModel(null);
	}
Progress : [####################--------------------] 51%================= fetch private void addAjcInitializers() { 6e6658a^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java
//    }
private void addAjcInitializers() {
    	if (tjpFields.size() == 0) return;
    	
    	InstructionList il = initializeAllTjps();

    	getStaticInitializer().getBody().insert(il);
    }
================= fetch private void initBcelWorld(IMessageHandler handler) throws IOException { 6e6658a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/** init only on initial batch compile? no file-specific options */
private void initBcelWorld(IMessageHandler handler) throws IOException {
		List cp = buildConfig.getBootclasspath();
		cp.addAll(buildConfig.getClasspath());
		BcelWorld bcelWorld = new BcelWorld(cp, handler, null);
		bcelWorld.setBehaveInJava5Way(buildConfig.getBehaveInJava5Way());
		bcelWorld.performExtraConfiguration(buildConfig.getXconfigurationInfo());
		bcelWorld.setTargetAspectjRuntimeLevel(buildConfig.getTargetAspectjRuntimeLevel());
		bcelWorld.setOptionalJoinpoints(buildConfig.getXJoinpoints());
		bcelWorld.setXnoInline(buildConfig.isXnoInline());
		bcelWorld.setXlazyTjp(buildConfig.isXlazyTjp());
		bcelWorld.setXHasMemberSupportEnabled(buildConfig.isXHasMemberEnabled());
		bcelWorld.setPinpointMode(buildConfig.isXdevPinpoint());
		BcelWeaver bcelWeaver = new BcelWeaver(bcelWorld);
		state.setWorld(bcelWorld);
		state.setWeaver(bcelWeaver);
		state.clearBinarySourceFiles();
		
		for (Iterator i = buildConfig.getAspectpath().iterator(); i.hasNext();) {
			File f = (File) i.next();
			if (!f.exists()) {
				IMessage message = new Message("invalid aspectpath entry: "+f.getName(),null,true);
				handler.handleMessage(message);
			} else {
				bcelWeaver.addLibraryJarFile(f);
			}
		}
		
//		String lintMode = buildConfig.getLintMode();
		
		if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
			bcelWorld.getLint().loadDefaultProperties();
		} else {
			bcelWorld.getLint().setAll(buildConfig.getLintMode());
		}
		
		if (buildConfig.getLintSpecFile() != null) {
			bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
		}
		
		//??? incremental issues
		for (Iterator i = buildConfig.getInJars().iterator(); i.hasNext(); ) {
			File inJar = (File)i.next();
			List unwovenClasses = bcelWeaver.addJarFile(inJar, buildConfig.getOutputDir(),false);
			state.recordBinarySource(inJar.getPath(), unwovenClasses);
		}
		
		for (Iterator i = buildConfig.getInpath().iterator(); i.hasNext(); ) {
			File inPathElement = (File)i.next();
			if (!inPathElement.isDirectory()) {
				// its a jar file on the inpath
				// the weaver method can actually handle dirs, but we don't call it, see next block
				List unwovenClasses = bcelWeaver.addJarFile(inPathElement,buildConfig.getOutputDir(),true);
				state.recordBinarySource(inPathElement.getPath(),unwovenClasses);
			} else {
				// add each class file in an in-dir individually, this gives us the best error reporting
				// (they are like 'source' files then), and enables a cleaner incremental treatment of
				// class file changes in indirs.
				File[] binSrcs = FileUtil.listFiles(inPathElement, binarySourceFilter);
				for (int j = 0; j < binSrcs.length; j++) {
					UnwovenClassFile ucf = 
						bcelWeaver.addClassFile(binSrcs[j], inPathElement, buildConfig.getOutputDir());
					List ucfl = new ArrayList();
					ucfl.add(ucf);
					state.recordBinarySource(binSrcs[j].getPath(),ucfl);
				}
			}
		}
		
		bcelWeaver.setReweavableMode(buildConfig.isXNotReweavable());

		//check for org.aspectj.runtime.JoinPoint
		ResolvedType joinPoint = bcelWorld.resolve("org.aspectj.lang.JoinPoint");
		if (joinPoint.isMissing()) {
			IMessage message = 
				new Message("classpath error: unable to find org.aspectj.lang.JoinPoint (check that aspectjrt.jar is in your classpath)",
							null,
							true);
				handler.handleMessage(message);
		}
	}
================= fetch public LazyClassGen(BcelObjectType myType) { 6e6658a^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java

================= fetch public boolean isXdevPinpoint() { 6e6658a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java

public boolean isXdevPinpoint() {
		return options.xdevPinpoint;
	}
================= fetch public final boolean isEnum() { 6e6658a^:bcel-builder/src/org/aspectj/apache/bcel/generic/ClassGen.java
/**
   * Returns true if this class represents an enum type
   */
public final boolean isEnum() {
  	return (access_flags & Constants.ACC_ENUM) != 0;
  }
================= fetch public static Test suite() { 6e6658a^:tests/src/org/aspectj/systemtest/ajc151/AllTestsAspectJ151.java

public static Test suite() {
		TestSuite suite = new TestSuite("AspectJ 1.5.1 tests");
		//$JUnit-BEGIN$
		suite.addTest(Ajc151Tests.suite());
		suite.addTest(NewarrayJoinpointTests.suite());
		suite.addTest(AtAroundTests.suite());
        //$JUnit-END$
		return suite;
	}
================= fetch public void forgetTypeVariablesCurrentlyBeingProcessed(Class baseClass) { 6e6658a^:weaver/src/org/aspectj/weaver/World.java

public void forgetTypeVariablesCurrentlyBeingProcessed(Class baseClass) {
		workInProgress1.remove(baseClass);
	}
================= fetch public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r 6e6658a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java
/**
         * Extract AspectJ-specific options (except for argfiles).
         * Caller should warn when sourceroots is empty but in 
         * incremental mode.
         * Signals warnings or errors through handler set in constructor.
         */
public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.remove()
			int nextArgIndex = args.indexOf(arg)+1; // XXX assumes unique
            // trim arg?
			buildConfig.setXlazyTjp(true); // now default - MINOR could be pushed down and made default at a lower level
            if (LangUtil.isEmpty(arg)) {
                showWarning("empty arg found");
            } else if (arg.equals("-inpath")) {;
            	if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_Inpath, CompilerOptions.PRESERVE);
					
					List inPath = buildConfig.getInpath();
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
					while (st.hasMoreTokens()) {
						String filename = st.nextToken();
						File file = makeFile(filename);
						if (file.exists() && FileUtil.hasZipSuffix(filename)) {
							inPath.add(file);    
						} else {
							if (file.isDirectory()) {
								inPath.add(file);
							} else 
		            		
							showError("bad inpath component: " + filename);  
						}
					}
					buildConfig.setInPath(inPath);
					args.remove(args.get(nextArgIndex));            		
            	}
            } else if (arg.equals("-injars")) {;
				if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_InJARs, CompilerOptions.PRESERVE);
					
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
		            	if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
			            	buildConfig.getInJars().add(jarFile);    
		            	} else {
		            		File dirFile = makeFile(filename);
		            		if (dirFile.isDirectory()) {
		            			buildConfig.getInJars().add(dirFile);
		            		} else 
		            		
                            showError("bad injar: " + filename);  
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-aspectpath")) {;
				if (args.size() > nextArgIndex) {
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
                        if (jarFile.exists() && (FileUtil.hasZipSuffix(filename) || jarFile.isDirectory())) {
			            	buildConfig.getAspectpath().add(jarFile);    
		            	} else {
                            showError("bad aspectpath: " + filename);
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-sourceroots")) {
				if (args.size() > nextArgIndex) {
					List sourceRoots = new ArrayList();
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	File f = makeFile(st.nextToken());
		            	if (f.isDirectory() && f.canRead()) {
			                sourceRoots.add(f);
		            	} else {
                            showError("bad sourceroot: " + f);
		            	}		            		
		            }
				    if (0 < sourceRoots.size()) {
						buildConfig.setSourceRoots(sourceRoots);	
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-sourceroots requires list of directories");
				}
			} else if (arg.equals("-outjar")) { 
				if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_OutJAR, CompilerOptions.GENERATE);
					File jarFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
					if (FileUtil.hasZipSuffix(jarFile)) {
						try {
							if (!jarFile.exists()) {
                                jarFile.createNewFile();
                            }
                            buildConfig.setOutputJar(jarFile);  
						} catch (IOException ioe) { 
                            showError("unable to create outjar file: " + jarFile);
						}
					} else {
						showError("invalid -outjar file: " + jarFile);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-outjar requires jar path argument");
				}
			} else if (arg.equals("-outxml")) { 
                buildConfig.setOutxmlName("META-INF/aop.xml");  
			} else if (arg.equals("-outxmlfile")) { 
				if (args.size() > nextArgIndex) {
					String name = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
	                buildConfig.setOutxmlName(name);  
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-outxmlfile requires file name argument");
				}
            } else if (arg.equals("-log")){
				// remove it as it's already been handled in org.aspectj.tools.ajc.Main
				args.remove(args.get(nextArgIndex));
            } else if (arg.equals("-messageHolder")) {
				// remove it as it's already been handled in org.aspectj.tools.ajc.Main
				args.remove(args.get(nextArgIndex));            	            
        	}else if (arg.equals("-incremental")) {
                buildConfig.setIncrementalMode(true);
            } else if (arg.equals("-XincrementalFile")) {
                if (args.size() > nextArgIndex) {
                    File file = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    buildConfig.setIncrementalFile(file);
                    if (!file.canRead()) {
                        showError("bad -XincrementalFile : " + file);
                        // if not created before recompile test, stop after first compile
                    }
                    args.remove(args.get(nextArgIndex));
                } else {
                    showError("-XincrementalFile requires file argument");
                }
			} else if (arg.equals("-crossrefs")) {
				buildConfig.setGenerateCrossRefsMode(true);
				buildConfig.setGenerateModelMode(true);
			} else if (arg.equals("-emacssym")) {
				buildConfig.setEmacsSymMode(true);
				buildConfig.setGenerateModelMode(true);
			} else if (arg.equals("-XjavadocsInModel")) {
				buildConfig.setGenerateModelMode(true);
				buildConfig.setGenerateJavadocsInModelMode(true);
			} else if (arg.equals("-Xdev:NoAtAspectJProcessing")) { 
				buildConfig.setNoAtAspectJAnnotationProcessing(true);
        	} else if (arg.equals("-Xdev:Pinpoint")) { 
				buildConfig.setXdevPinpointMode(true);
        	} else if (arg.equals("-Xjoinpoints:arrayconstruction")) {
        		buildConfig.setXJoinpoints("arrayconstruction");
        	} else if (arg.equals("-noWeave") || arg.equals( "-XnoWeave")) {
				showWarning("the noweave option is no longer required and is being ignored");
        	} else if (arg.equals( "-XterminateAfterCompilation")) {
				buildConfig.setTerminateAfterCompilation(true);
			} else if (arg.equals("-XserializableAspects")) {
				buildConfig.setXserializableAspects(true);
			} else if (arg.equals("-XlazyTjp")) {
				// do nothing as this is now on by default
				showWarning("-XlazyTjp should no longer be used, build tjps lazily is now the default");
            } else if (arg.startsWith("-Xreweavable")) {
            	showWarning("-Xreweavable is on by default");
            	if (arg.endsWith(":compress")) {
            		showWarning("-Xreweavable:compress is no longer available - reweavable is now default");
            	}
			} else if (arg.startsWith("-Xset:")) {
				buildConfig.setXconfigurationInfo(arg.substring(6));
			} else if (arg.startsWith("-XnotReweavable")) {
            	buildConfig.setXnotReweavable(true);
			} else if (arg.equals("-XnoInline")) {
				buildConfig.setXnoInline(true);
            } else if (arg.equals("-XhasMember")) {
            	buildConfig.setXHasMemberSupport(true);
            }	else if (arg.startsWith("-showWeaveInfo")) {            	
            	 buildConfig.setShowWeavingInformation(true);
			} else if (arg.equals("-Xlintfile")) { 
				if (args.size() > nextArgIndex) {
					File lintSpecFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    // XXX relax restriction on props file suffix?
					if (lintSpecFile.canRead() && lintSpecFile.getName().endsWith(".properties")) {
						buildConfig.setLintSpecFile(lintSpecFile);	
					} else {
						showError("bad -Xlintfile file: " + lintSpecFile);
						buildConfig.setLintSpecFile(null);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-Xlintfile requires .properties file argument");
				}
            } else if (arg.equals("-Xlint")) {
//                buildConfig.getAjOptions().put(
//                    AjCompilerOptions.OPTION_Xlint,
//                    CompilerOptions.GENERATE);
                buildConfig.setLintMode(AjBuildConfig.AJLINT_DEFAULT);
            } else if (arg.startsWith("-Xlint:")) {
                if (7 < arg.length()) {
                    buildConfig.setLintMode(arg.substring(7));
                } else {
                    showError("invalid lint option " + arg);
                }
			} else if (arg.equals("-bootclasspath")) {
				if (args.size() > nextArgIndex) {
					String bcpArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer bcp = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(bcpArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    bcp.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        bcp.append(File.pathSeparator);
					    }
					}
					bootclasspath = bcp.toString();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-bootclasspath requires classpath entries");
				}
			} else if (arg.equals("-classpath") || arg.equals("-cp")) {
				if (args.size() > nextArgIndex) {
					String cpArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer cp = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(cpArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    cp.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        cp.append(File.pathSeparator);
					    }
					}
					classpath = cp.toString();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-classpath requires classpath entries");
				}
			} else if (arg.equals("-extdirs")) {
				if (args.size() > nextArgIndex) {
					String extdirsArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer ed = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(extdirsArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    ed.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        ed.append(File.pathSeparator);
					    }
					}					
					extdirs = ed.toString();
					args.remove(args.get(nextArgIndex));
                } else {
                    showError("-extdirs requires list of external directories");
                }
            // error on directory unless -d, -{boot}classpath, or -extdirs
            } else if (arg.equals("-d")) {
                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-classpath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-bootclasspath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-extdirs")) {
//                dirLookahead(arg, args, nextArgIndex);
            } else if (arg.equals("-proceedOnError")) {
            	buildConfig.setProceedOnError(true);
            } else if (new File(arg).isDirectory()) {
                showError("dir arg not permitted: " + arg);
            } else if (arg.startsWith("-Xajruntimetarget")) {
        		if (arg.endsWith(":1.2")) {
            		buildConfig.setTargetAspectjRuntimeLevel(Constants.RUNTIME_LEVEL_12);
        		} else if (arg.endsWith(":1.5")) {
            		buildConfig.setTargetAspectjRuntimeLevel(Constants.RUNTIME_LEVEL_15);
        		} else {
        			showError("-Xajruntimetarget:<level> only supports a target level of 1.2 or 1.5");
        		}
            } else if (arg.equals("-1.5")) {
            	buildConfig.setBehaveInJava5Way(true);
            	unparsedArgs.add("-1.5");
// this would enable the '-source 1.5' to do the same as '-1.5' but doesnt sound quite right as
// as an option right now as it doesnt mean we support 1.5 source code - people will get confused...
            } else if (arg.equals("-source")) {
            	if (args.size() > nextArgIndex) {
            		String level = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
            		if (level.equals("1.5")){
            			buildConfig.setBehaveInJava5Way(true);
            		}
            		unparsedArgs.add("-source");
            		unparsedArgs.add(level);
            		args.remove(args.get(nextArgIndex));
            	}
			} else {
                // argfile, @file parsed by superclass
                // no eclipse options parsed:
                // -d args, -help (handled), 
                // -classpath, -target, -1.3, -1.4, -source [1.3|1.4]
                // -nowarn, -warn:[...], -deprecation, -noImportError,
                // -g:[...], -preserveAllLocals,
                // -referenceInfo, -encoding, -verbose, -log, -time
                // -noExit, -repeat
				// (Actually, -noExit grabbed by Main)
		    	unparsedArgs.add(arg);
			}
        }
================= fetch String next() { b225911^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java

String next() {
                String err = null;
                if (!hasNext()) {
                    err = "need arg for flag " + args[args.length-1];
                } else {
                    String s = args[index++];
                    if (null == s) {
                        err = "null value";                                            
                    } else {
                        s = s.trim();
                        if (0 == s.trim().length()) {
                            err = "no value";                                            
                        } else {
                            return s;
                        }
                    }
                }
                err += " at [" + index + "] of " + Arrays.asList(args);
                throw new BuildException(err);
            }
================= fetch private CRSOptions() { b225911^:testing/src/org/aspectj/testing/harness/bridge/CompilerRun.java

public String toString() {
                return "TestSetup("
                    + (null == compilerName ? "" : compilerName + " ")
                    + (!ignoreWarningsSet
                        ? ""
                        : (ignoreWarnings ? "" : "do not ")
                            + "ignore warnings ")
                    + (result ? "" : "setup failed")
                    + ")";
            }
================= fetch public AjCompilerAdapter(Compiler compiler, b225911^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java

================= fetch public ICompilerAdapter getAdapter(org.aspectj.org.eclipse.jdt.internal.compiler b225911^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/* (non-Javadoc)
	 * @see org.eclipse.jdt.internal.compiler.ICompilerAdapterFactory#getAdapter(org.eclipse.jdt.internal.compiler.Compiler)
	 */
public ICompilerAdapter getAdapter(org.aspectj.org.eclipse.jdt.internal.compiler.Compiler forCompiler) {
		// complete compiler config and return a suitable adapter...
		populateCompilerOptionsFromLintSettings(forCompiler);
		AjProblemReporter pr =
			new AjProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),
								  forCompiler.options, getProblemFactory());
		
		forCompiler.problemReporter = pr;
			
		AjLookupEnvironment le =
			new AjLookupEnvironment(forCompiler, forCompiler.options, pr, environment);
		EclipseFactory factory = new EclipseFactory(le,this);
		le.factory = factory;
		pr.factory = factory;
		
		forCompiler.lookupEnvironment = le;
		
		forCompiler.parser =
			new Parser(
				pr, 
				forCompiler.options.parseLiteralExpressionsAsConstants);
		
		return new AjCompilerAdapter(forCompiler,batchCompile,getBcelWorld(),getWeaver(),
						factory,
						getInterimResultRequestor(),
						progressListener,
						this,  // IOutputFilenameProvider
						this,  // IBinarySourceProvider
						state.getBinarySourceMap(),
						buildConfig.isNoWeave(),
						buildConfig.getProceedOnError(),
						buildConfig.isNoAtAspectJAnnotationProcessing(),
						state);
	}
================= fetch public Map getMap() { b225911^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java
/* (non-Javadoc)
	 * @see org.eclipse.jdt.internal.compiler.impl.CompilerOptions#getMap()
	 */
public Map getMap() {
		Map map = super.getMap();
		// now add AspectJ additional options
		map.put(OPTION_ReportInvalidAbsoluteTypeName,getSeverityString(InvalidAbsoluteTypeName));
		map.put(OPTION_ReportInvalidWildcardTypeName,getSeverityString(InvalidWildCardTypeName));
		map.put(OPTION_ReportUnresolvableMember,getSeverityString(UnresolvableMember));
		map.put(OPTION_ReportTypeNotExposedToWeaver,getSeverityString(TypeNotExposedToWeaver));
		map.put(OPTION_ReportShadowNotInStructure,getSeverityString(ShadowNotInStructure));
		map.put(OPTION_ReportUnmatchedSuperTypeInCall,getSeverityString(UnmatchedSuperTypeInCall));
		map.put(OPTION_ReportCannotImplementLazyTJP,getSeverityString(CannotImplementLazyTJP));
		map.put(OPTION_ReportNeedSerialVersionUIDField,getSeverityString(NeedSerialVersionUIDField));
		map.put(OPTION_ReportIncompatibleSerialVersion,getSeverityString(IncompatibleSerialVersion));
		map.put(CompilerOptions.OPTION_ReportSwallowedExceptionInCatchBlock,getSeverityString(CompilerOptions.SwallowedExceptionInCatchBlock));
		
		map.put(OPTION_NoWeave, this.noWeave ? ENABLED : DISABLED);
		map.put(OPTION_XSerializableAspects,this.xSerializableAspects ? ENABLED : DISABLED);
		map.put(OPTION_XLazyThisJoinPoint,this.xLazyThisJoinPoint ? ENABLED : DISABLED);
		map.put(OPTION_XNoInline,this.xNoInline ? ENABLED : DISABLED);
		map.put(OPTION_XNotReweavable,this.xNotReweavable ? ENABLED : DISABLED);
		map.put(OPTION_XHasMember, this.xHasMember ? ENABLED : DISABLED);
		map.put(OPTION_XdevPinpoint, this.xdevPinpoint ? ENABLED : DISABLED);

		map.put(OPTION_GenerateModel,this.generateModel ? ENABLED : DISABLED);
		map.put(OPTION_GenerateJavaDocsInModel,this.generateJavaDocsInModel ? ENABLED : DISABLED);
		map.put(OPTION_Emacssym,this.generateEmacsSymFiles ? ENABLED : DISABLED);
		map.put(OPTION_XDevNoAtAspectJProcessing,this.noAtAspectJProcessing ? ENABLED : DISABLED);
		
		return map;
	}
================= fetch public String toString() { b225911^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java
/* (non-Javadoc)
	 * @see java.lang.Object#toString()
	 */
public String toString() {
		StringBuffer buf = new StringBuffer( super.toString() );
		// now add AspectJ additional options
		buf.append("\n\tAspectJ Specific Options:");
		buf.append("\n\t- no weave: ").append(this.noWeave ? ENABLED : DISABLED); //$NON-NLS-1$
		buf.append("\n\t- no inline (X option): ").append(this.xNoInline ? ENABLED : DISABLED); //$NON-NLS-1$
		buf.append("\n\t- generate serializable aspects (X option): ").append(this.xSerializableAspects ? ENABLED : DISABLED); //$NON-NLS-1$
		buf.append("\n\t- lazy thisJoinPoint (X option): ").append(this.xLazyThisJoinPoint ? ENABLED : DISABLED); //$NON-NLS-1$
		buf.append("\n\t- generate non-reweavable class files (X option): ").append(this.xNotReweavable ? ENABLED : DISABLED); //$NON-NLS-1$	
		buf.append("\n\t- has member support (X option): ").append(this.xHasMember ? ENABLED : DISABLED); //$NON-NLS-1$

		buf.append("\n\t- generate AJDE model: ").append(this.generateModel ? ENABLED : DISABLED); //$NON-NLS-1$		
		buf.append("\n\t- generate Javadocs in AJDE model: ").append(this.generateJavaDocsInModel ? ENABLED : DISABLED); //$NON-NLS-1$		
		buf.append("\n\t- generate Emacs symbol files: ").append(this.generateEmacsSymFiles ? ENABLED : DISABLED); //$NON-NLS-1$
		buf.append("\n\t- suppress @AspectJ processing: ").append(this.noAtAspectJProcessing ? ENABLED : DISABLED); //$NON-NLS-1$
		
		buf.append("\n\t- invalid absolute type name (XLint): ").append(getSeverityString(InvalidAbsoluteTypeName)); //$NON-NLS-1$
		buf.append("\n\t- invalid wildcard type name (XLint): ").append(getSeverityString(InvalidWildCardTypeName)); //$NON-NLS-1$
		buf.append("\n\t- unresolvable member (XLint): ").append(getSeverityString(UnresolvableMember)); //$NON-NLS-1$
		buf.append("\n\t- type not exposed to weaver (XLint): ").append(getSeverityString(TypeNotExposedToWeaver)); //$NON-NLS-1$
		buf.append("\n\t- shadow not in structure (XLint): ").append(getSeverityString(ShadowNotInStructure)); //$NON-NLS-1$
		buf.append("\n\t- unmatched super type in call (XLint): ").append(getSeverityString(UnmatchedSuperTypeInCall)); //$NON-NLS-1$
		buf.append("\n\t- cannot implement lazy thisJoinPoint (XLint): ").append(getSeverityString(CannotImplementLazyTJP)); //$NON-NLS-1$
		buf.append("\n\t- need serialVersionUID field (XLint): ").append(getSeverityString(NeedSerialVersionUIDField)); //$NON-NLS-1$
		buf.append("\n\t- incompatible serial version (XLint): ").append(getSeverityString(IncompatibleSerialVersion)); //$NON-NLS-1$
		buf.append("\n\t- swallowed exception in catch block (XLint): ").append(getSeverityString(CompilerOptions.SwallowedExceptionInCatchBlock)); //$NON-NLS-1$
		
		return buf.toString();
	}
================= fetch public String toString() { b225911^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java

private static File isAspectjtoolsjar(String path) {
        if (null == path) {
            return null;
        }
        final String prefix = "aspectj";        
        final String infix = "tools";        
        final String altInfix = "-tools";        
        final String suffix = ".jar";
        final int prefixLength = 7; // prefix.length();
        final int minLength = 16;
        // prefixLength + infix.length() + suffix.length();        
        if (!path.endsWith(suffix)) {
            return null;
        }
        int loc = path.lastIndexOf(prefix);
        if ((-1 != loc) && ((loc + minLength) <= path.length())) {
            String rest = path.substring(loc+prefixLength);
            if (-1 != rest.indexOf(File.pathSeparator)) {
                return null;
            }
            if (rest.startsWith(infix)
                || rest.startsWith(altInfix)) {
                File result = new File(path);
                if (result.canRead() && result.isFile()) {
                    return result;
                }
            }
        }        
        return null;
    }
================= fetch public boolean isNoWeave() { b225911^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java

public boolean isNoWeave() {
		return options.noWeave;
	}
================= fetch public static void makeJar1a() throws IOException { b225911^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java

public static void makeJar1a() throws IOException {
		List args = new ArrayList();
		args.add("-outjar");
		args.add("../weaver/testdata/megatraceNoweave.jar");

		args.add("-noweave");

		args.add("-classpath");
        args.add(AjcTests.aspectjrtClasspath());
		
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/trace/MegaTrace.java");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/trace/ExecTrace.java");
		
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
	}
================= fetch public void afterCompiling(CompilationUnitDeclaration[] units) { b225911^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java

public void afterCompiling(CompilationUnitDeclaration[] units) {
		this.eWorld.cleanup();
		try {
			if (isXNoWeave || (reportedErrors && !proceedOnError)) {
				// no point weaving... just tell the requestor we're done
				notifyRequestor();
			} else {
				weave();  // notification happens as weave progresses...
				weaver.getWorld().flush();
			}
		} catch (IOException ex) {
			AbortCompilation ac = new AbortCompilation(null,ex);
			throw ac;
		} catch (RuntimeException rEx) {
			if (rEx instanceof AbortCompilation) throw rEx; // Don't wrap AbortCompilation exceptions!

			// This will be unwrapped in Compiler.handleInternalException() and the nested
			// RuntimeException thrown back to the original caller - which is AspectJ
			// which will then then log it as a compiler problem.
			throw new AbortCompilation(true,rEx);
		}
	}
================= fetch public void afterProcessing(CompilationUnitDeclaration unit, int unitIndex) { b225911^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java

public void afterProcessing(CompilationUnitDeclaration unit, int unitIndex) {
		CompilationAndWeavingContext.leavingPhase(processingToken);
		eWorld.finishedCompilationUnit(unit);
		InterimCompilationResult intRes = new InterimCompilationResult(unit.compilationResult,outputFileNameProvider);
		if (unit.compilationResult.hasErrors()) reportedErrors = true;
		
		if (intermediateResultsRequestor != null) {
			intermediateResultsRequestor.acceptResult(intRes);
		}
		
		if (isXNoWeave) {
			acceptResult(unit.compilationResult);
		} else {
			resultsPendingWeave.add(intRes);
		}
	}
================= fetch public void installGlobals(AjBuildConfig global) { // XXX relies on default valu b225911^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java
/**
     * Install global values into local config
     * unless values conflict:
     * <ul>
     * <li>Collections are unioned</li>
     * <li>values takes local value unless default and global set</li>
     * <li>this only sets one of outputDir and outputJar as needed</li>
     * <ul>
     * This also configures super if javaOptions change.
     * @param global the AjBuildConfig to read globals from
     */
public void installGlobals(AjBuildConfig global) { // XXX relies on default values
    	// don't join the options - they already have defaults taken care of.
//        Map optionsMap = options.getMap();
//        join(optionsMap,global.getOptions().getMap());
//        options.set(optionsMap);
        join(aspectpath, global.aspectpath);
        join(classpath, global.classpath);
        if (null == configFile) {
            configFile = global.configFile; // XXX correct?
        }
        if (!isEmacsSymMode() && global.isEmacsSymMode()) {
            setEmacsSymMode(true);
        }
        join(files, global.files);
        if (!isGenerateModelMode() && global.isGenerateModelMode()) {
            setGenerateModelMode(true);
        }
        if (null == incrementalFile) {
            incrementalFile = global.incrementalFile;
        }
        if (!incrementalMode && global.incrementalMode) {
            incrementalMode = true;
        }
        join(inJars, global.inJars);
        join(inPath, global.inPath);
        if ((null == lintMode) 
            || (AJLINT_DEFAULT.equals(lintMode))) {
            setLintMode(global.lintMode);
        }
        if (null == lintSpecFile) {
            lintSpecFile = global.lintSpecFile;
        }
        if (!isNoWeave() && global.isNoWeave()) {
            setNoWeave(true);
        }
        if ((null == outputDir) && (null == outputJar)) {
            if (null != global.outputDir) {
                outputDir = global.outputDir;
            }
            if (null != global.outputJar) {
                outputJar = global.outputJar;
            }
        }        
        join(sourceRoots, global.sourceRoots);
        if (!isXnoInline() && global.isXnoInline()) {
            setXnoInline(true);
        }
        if (!isXserializableAspects() && global.isXserializableAspects()) {
            setXserializableAspects(true);
        }
        if (!isXlazyTjp() && global.isXlazyTjp()) {
        	setXlazyTjp(true);
        }
        if (!getProceedOnError() && global.getProceedOnError()) {
        	setProceedOnError(true);
        }
       	setTargetAspectjRuntimeLevel(global.getTargetAspectjRuntimeLevel());
       	setXJoinpoints(global.getXJoinpoints());
        if (!isXHasMemberEnabled() && global.isXHasMemberEnabled()) {
        	setXHasMemberSupport(true);
        }
        if (!isXNotReweavable() && global.isXNotReweavable()) {
        	setXnotReweavable(true);
        }
        setXconfigurationInfo(global.getXconfigurationInfo());
    }
================= fetch public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r b225911^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java
/**
         * Extract AspectJ-specific options (except for argfiles).
         * Caller should warn when sourceroots is empty but in 
         * incremental mode.
         * Signals warnings or errors through handler set in constructor.
         */
public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.remove()
			int nextArgIndex = args.indexOf(arg)+1; // XXX assumes unique
            // trim arg?
			buildConfig.setXlazyTjp(true); // now default - MINOR could be pushed down and made default at a lower level
            if (LangUtil.isEmpty(arg)) {
                showWarning("empty arg found");
            } else if (arg.equals("-inpath")) {;
            	if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_Inpath, CompilerOptions.PRESERVE);
					
					List inPath = buildConfig.getInpath();
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
					while (st.hasMoreTokens()) {
						String filename = st.nextToken();
						File file = makeFile(filename);
						if (file.exists() && FileUtil.hasZipSuffix(filename)) {
							inPath.add(file);    
						} else {
							if (file.isDirectory()) {
								inPath.add(file);
							} else 
		            		
							showError("bad inpath component: " + filename);  
						}
					}
					buildConfig.setInPath(inPath);
					args.remove(args.get(nextArgIndex));            		
            	}
            } else if (arg.equals("-injars")) {;
				if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_InJARs, CompilerOptions.PRESERVE);
					
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
		            	if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
			            	buildConfig.getInJars().add(jarFile);    
		            	} else {
		            		File dirFile = makeFile(filename);
		            		if (dirFile.isDirectory()) {
		            			buildConfig.getInJars().add(dirFile);
		            		} else 
		            		
                            showError("bad injar: " + filename);  
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-aspectpath")) {;
				if (args.size() > nextArgIndex) {
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
                        if (jarFile.exists() && (FileUtil.hasZipSuffix(filename) || jarFile.isDirectory())) {
			            	buildConfig.getAspectpath().add(jarFile);    
		            	} else {
                            showError("bad aspectpath: " + filename);
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-sourceroots")) {
				if (args.size() > nextArgIndex) {
					List sourceRoots = new ArrayList();
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	File f = makeFile(st.nextToken());
		            	if (f.isDirectory() && f.canRead()) {
			                sourceRoots.add(f);
		            	} else {
                            showError("bad sourceroot: " + f);
		            	}		            		
		            }
				    if (0 < sourceRoots.size()) {
						buildConfig.setSourceRoots(sourceRoots);	
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-sourceroots requires list of directories");
				}
			} else if (arg.equals("-outjar")) { 
				if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_OutJAR, CompilerOptions.GENERATE);
					File jarFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
					if (FileUtil.hasZipSuffix(jarFile)) {
						try {
							if (!jarFile.exists()) {
                                jarFile.createNewFile();
                            }
                            buildConfig.setOutputJar(jarFile);  
						} catch (IOException ioe) { 
                            showError("unable to create outjar file: " + jarFile);
						}
					} else {
						showError("invalid -outjar file: " + jarFile);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-outjar requires jar path argument");
				}
			} else if (arg.equals("-outxml")) { 
                buildConfig.setOutxmlName("META-INF/aop.xml");  
			} else if (arg.equals("-outxmlfile")) { 
				if (args.size() > nextArgIndex) {
					String name = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
	                buildConfig.setOutxmlName(name);  
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-outxmlfile requires file name argument");
				}
            } else if (arg.equals("-log")){
				// remove it as it's already been handled in org.aspectj.tools.ajc.Main
				args.remove(args.get(nextArgIndex));
            } else if (arg.equals("-messageHolder")) {
				// remove it as it's already been handled in org.aspectj.tools.ajc.Main
				args.remove(args.get(nextArgIndex));            	            
        	}else if (arg.equals("-incremental")) {
                buildConfig.setIncrementalMode(true);
            } else if (arg.equals("-XincrementalFile")) {
                if (args.size() > nextArgIndex) {
                    File file = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    buildConfig.setIncrementalFile(file);
                    if (!file.canRead()) {
                        showError("bad -XincrementalFile : " + file);
                        // if not created before recompile test, stop after first compile
                    }
                    args.remove(args.get(nextArgIndex));
                } else {
                    showError("-XincrementalFile requires file argument");
                }
			} else if (arg.equals("-crossrefs")) {
				buildConfig.setGenerateCrossRefsMode(true);
				buildConfig.setGenerateModelMode(true);
			} else if (arg.equals("-emacssym")) {
				buildConfig.setEmacsSymMode(true);
				buildConfig.setGenerateModelMode(true);
			} else if (arg.equals("-XjavadocsInModel")) {
				buildConfig.setGenerateModelMode(true);
				buildConfig.setGenerateJavadocsInModelMode(true);
			} else if (arg.equals("-Xdev:NoAtAspectJProcessing")) { 
				buildConfig.setNoAtAspectJAnnotationProcessing(true);
        	} else if (arg.equals("-Xdev:Pinpoint")) { 
				buildConfig.setXdevPinpointMode(true);
        	} else if (arg.equals("-Xjoinpoints:arrayconstruction")) {
        		buildConfig.setXJoinpoints("arrayconstruction");
        	} else if (arg.equals("-noweave") || arg.equals( "-XnoWeave")) {
				buildConfig.setNoWeave(true);
			} else if (arg.equals("-XserializableAspects")) {
				buildConfig.setXserializableAspects(true);
			} else if (arg.equals("-XlazyTjp")) {
				// do nothing as this is now on by default
				showWarning("-XlazyTjp should no longer be used, build tjps lazily is now the default");
            } else if (arg.startsWith("-Xreweavable")) {
            	showWarning("-Xreweavable is on by default");
            	if (arg.endsWith(":compress")) {
            		showWarning("-Xreweavable:compress is no longer available - reweavable is now default");
            	}
			} else if (arg.startsWith("-Xset:")) {
				buildConfig.setXconfigurationInfo(arg.substring(6));
			} else if (arg.startsWith("-XnotReweavable")) {
            	buildConfig.setXnotReweavable(true);
			} else if (arg.equals("-XnoInline")) {
				buildConfig.setXnoInline(true);
            } else if (arg.equals("-XhasMember")) {
            	buildConfig.setXHasMemberSupport(true);
            }	else if (arg.startsWith("-showWeaveInfo")) {            	
            	 buildConfig.setShowWeavingInformation(true);
			} else if (arg.equals("-Xlintfile")) { 
				if (args.size() > nextArgIndex) {
					File lintSpecFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    // XXX relax restriction on props file suffix?
					if (lintSpecFile.canRead() && lintSpecFile.getName().endsWith(".properties")) {
						buildConfig.setLintSpecFile(lintSpecFile);	
					} else {
						showError("bad -Xlintfile file: " + lintSpecFile);
						buildConfig.setLintSpecFile(null);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-Xlintfile requires .properties file argument");
				}
            } else if (arg.equals("-Xlint")) {
//                buildConfig.getAjOptions().put(
//                    AjCompilerOptions.OPTION_Xlint,
//                    CompilerOptions.GENERATE);
                buildConfig.setLintMode(AjBuildConfig.AJLINT_DEFAULT);
            } else if (arg.startsWith("-Xlint:")) {
                if (7 < arg.length()) {
                    buildConfig.setLintMode(arg.substring(7));
                } else {
                    showError("invalid lint option " + arg);
                }
			} else if (arg.equals("-bootclasspath")) {
				if (args.size() > nextArgIndex) {
					String bcpArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer bcp = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(bcpArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    bcp.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        bcp.append(File.pathSeparator);
					    }
					}
					bootclasspath = bcp.toString();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-bootclasspath requires classpath entries");
				}
			} else if (arg.equals("-classpath") || arg.equals("-cp")) {
				if (args.size() > nextArgIndex) {
					String cpArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer cp = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(cpArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    cp.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        cp.append(File.pathSeparator);
					    }
					}
					classpath = cp.toString();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-classpath requires classpath entries");
				}
			} else if (arg.equals("-extdirs")) {
				if (args.size() > nextArgIndex) {
					String extdirsArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer ed = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(extdirsArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    ed.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        ed.append(File.pathSeparator);
					    }
					}					
					extdirs = ed.toString();
					args.remove(args.get(nextArgIndex));
                } else {
                    showError("-extdirs requires list of external directories");
                }
            // error on directory unless -d, -{boot}classpath, or -extdirs
            } else if (arg.equals("-d")) {
                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-classpath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-bootclasspath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-extdirs")) {
//                dirLookahead(arg, args, nextArgIndex);
            } else if (arg.equals("-proceedOnError")) {
            	buildConfig.setProceedOnError(true);
            } else if (new File(arg).isDirectory()) {
                showError("dir arg not permitted: " + arg);
            } else if (arg.startsWith("-Xajruntimetarget")) {
        		if (arg.endsWith(":1.2")) {
            		buildConfig.setTargetAspectjRuntimeLevel(Constants.RUNTIME_LEVEL_12);
        		} else if (arg.endsWith(":1.5")) {
            		buildConfig.setTargetAspectjRuntimeLevel(Constants.RUNTIME_LEVEL_15);
        		} else {
        			showError("-Xajruntimetarget:<level> only supports a target level of 1.2 or 1.5");
        		}
            } else if (arg.equals("-1.5")) {
            	buildConfig.setBehaveInJava5Way(true);
            	unparsedArgs.add("-1.5");
// this would enable the '-source 1.5' to do the same as '-1.5' but doesnt sound quite right as
// as an option right now as it doesnt mean we support 1.5 source code - people will get confused...
            } else if (arg.equals("-source")) {
            	if (args.size() > nextArgIndex) {
            		String level = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
            		if (level.equals("1.5")){
            			buildConfig.setBehaveInJava5Way(true);
            		}
            		unparsedArgs.add("-source");
            		unparsedArgs.add(level);
            		args.remove(args.get(nextArgIndex));
            	}
			} else {
                // argfile, @file parsed by superclass
                // no eclipse options parsed:
                // -d args, -help (handled), 
                // -classpath, -target, -1.3, -1.4, -source [1.3|1.4]
                // -nowarn, -warn:[...], -deprecation, -noImportError,
                // -g:[...], -preserveAllLocals,
                // -referenceInfo, -encoding, -verbose, -log, -time
                // -noExit, -repeat
				// (Actually, -noExit grabbed by Main)
		    	unparsedArgs.add(arg);
			}
        }
================= fetch public void set(Map optionsMap) { b225911^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java
/* (non-Javadoc)
	 * @see org.eclipse.jdt.internal.compiler.impl.CompilerOptions#set(java.util.Map)
	 */
public void set(Map optionsMap) {
		super.set(optionsMap);
		Object optionValue;
		if ((optionValue = optionsMap.get(OPTION_ReportInvalidAbsoluteTypeName)) != null) updateSeverity(InvalidAbsoluteTypeName, optionValue);
		if ((optionValue = optionsMap.get(OPTION_ReportInvalidWildcardTypeName)) != null) updateSeverity(InvalidWildCardTypeName, optionValue);
		if ((optionValue = optionsMap.get(OPTION_ReportUnresolvableMember)) != null) updateSeverity(UnresolvableMember, optionValue);
		if ((optionValue = optionsMap.get(OPTION_ReportTypeNotExposedToWeaver)) != null) updateSeverity(TypeNotExposedToWeaver, optionValue);
		if ((optionValue = optionsMap.get(OPTION_ReportShadowNotInStructure)) != null) updateSeverity(ShadowNotInStructure, optionValue);
		if ((optionValue = optionsMap.get(OPTION_ReportUnmatchedSuperTypeInCall)) != null) updateSeverity(UnmatchedSuperTypeInCall, optionValue);
		if ((optionValue = optionsMap.get(OPTION_ReportCannotImplementLazyTJP)) != null) updateSeverity(CannotImplementLazyTJP, optionValue);
		if ((optionValue = optionsMap.get(OPTION_ReportNeedSerialVersionUIDField)) != null) updateSeverity(NeedSerialVersionUIDField, optionValue);
		if ((optionValue = optionsMap.get(OPTION_ReportIncompatibleSerialVersion)) != null) updateSeverity(IncompatibleSerialVersion, optionValue);
		if ((optionValue = optionsMap.get(CompilerOptions.OPTION_ReportSwallowedExceptionInCatchBlock)) != null) updateSeverity(CompilerOptions.SwallowedExceptionInCatchBlock, optionValue);
		
		if ((optionValue = optionsMap.get(OPTION_NoWeave)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.noWeave = true;
			} else if (DISABLED.equals(optionValue)) {
				this.noWeave = false;
			}
		}
		if ((optionValue = optionsMap.get(OPTION_XSerializableAspects)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.xSerializableAspects = true;
			} else if (DISABLED.equals(optionValue)) {
				this.xSerializableAspects = false;
			}
		}
		if ((optionValue = optionsMap.get(OPTION_XLazyThisJoinPoint)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.xLazyThisJoinPoint = true;
			} else if (DISABLED.equals(optionValue)) {
				this.xLazyThisJoinPoint = false;
			}
		}
		if ((optionValue = optionsMap.get(OPTION_XNoInline)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.xNoInline = true;
			} else if (DISABLED.equals(optionValue)) {
				this.xNoInline = false;
			}
		}
		if ((optionValue = optionsMap.get(OPTION_XNotReweavable)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.xNotReweavable = true;
			} else if (DISABLED.equals(optionValue)) {
				this.xNotReweavable = false;
			}
		}
		/*
		if ((optionValue = optionsMap.get(OPTION_XReweavableCompress)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.xReweavableCompress = true;
			} else if (DISABLED.equals(optionValue)) {
				this.xReweavableCompress = false;
			}
		}
*/
		
		
		
		if ((optionValue = optionsMap.get(OPTION_XHasMember)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.xHasMember = true;
			} else if (DISABLED.equals(optionValue)) {
				this.xHasMember = false;
			}
		}

		if ((optionValue = optionsMap.get(OPTION_XdevPinpoint)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.xdevPinpoint = true;
			} else if (DISABLED.equals(optionValue)) {
				this.xdevPinpoint = false;
			}
		}

		if ((optionValue = optionsMap.get(OPTION_GenerateModel)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.generateModel = true;
			} else if (DISABLED.equals(optionValue)) {
				this.generateModel = false;
			}
		}
		if ((optionValue = optionsMap.get(OPTION_GenerateJavaDocsInModel)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.generateJavaDocsInModel = true;
			} else if (DISABLED.equals(optionValue)) {
				this.generateJavaDocsInModel = false;
			}
		}
		if ((optionValue = optionsMap.get(OPTION_Emacssym)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.generateEmacsSymFiles = true;
			} else if (DISABLED.equals(optionValue)) {
				this.generateEmacsSymFiles = false;
			}
		}
		if ((optionValue = optionsMap.get(OPTION_XDevNoAtAspectJProcessing)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.noAtAspectJProcessing = true;
			} else if (DISABLED.equals(optionValue)) {
				this.noAtAspectJProcessing = false;
			}
		}
		
	}
================= fetch public void setLintMode(String lintMode) { b225911^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java
// options...
public void setLintMode(String lintMode) {
		this.lintMode = lintMode;
		String lintValue = null;
		if (AJLINT_IGNORE.equals(lintMode)) {
			lintValue = AjCompilerOptions.IGNORE;
		} else if (AJLINT_WARN.equals(lintMode)) {
			lintValue = AjCompilerOptions.WARNING;
		} else if (AJLINT_ERROR.equals(lintMode)) {
			lintValue = AjCompilerOptions.ERROR;
		}
		
		if (lintValue != null) {
			Map lintOptions = new HashMap();
			lintOptions.put(AjCompilerOptions.OPTION_ReportInvalidAbsoluteTypeName,lintValue);
			lintOptions.put(AjCompilerOptions.OPTION_ReportInvalidWildcardTypeName,lintValue);
			lintOptions.put(AjCompilerOptions.OPTION_ReportUnresolvableMember,lintValue);
			lintOptions.put(AjCompilerOptions.OPTION_ReportTypeNotExposedToWeaver,lintValue);
			lintOptions.put(AjCompilerOptions.OPTION_ReportShadowNotInStructure,lintValue);
			lintOptions.put(AjCompilerOptions.OPTION_ReportUnmatchedSuperTypeInCall,lintValue);
			lintOptions.put(AjCompilerOptions.OPTION_ReportCannotImplementLazyTJP,lintValue);
			lintOptions.put(AjCompilerOptions.OPTION_ReportNeedSerialVersionUIDField,lintValue);
			lintOptions.put(AjCompilerOptions.OPTION_ReportIncompatibleSerialVersion,lintValue);
			options.set(lintOptions);
		}
	}
================= fetch public void setVersion(boolean version) { b225911^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java

public void setVersion(boolean version) {  
    	cmd.addFlag("-version", version);
    }
================= fetch public void setXReweavable(boolean reweavable) { b225911^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java

public void setXReweavable(boolean reweavable) {
    	cmd.addFlag("-Xreweavable",reweavable);
    }
================= fetch public void test003(){ b225911^:tests/src/org/aspectj/systemtest/inpath/InPathTests.java

public void test003(){
    runTest("options -injars checking declare parents interactions");
  }
================= fetch public void testDefaultFileComplete() { b225911^:taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java

public void testDefaultFileComplete() {
		AjcTask task = getTask("default.lst");
		task.setDebugLevel("none");
		task.setDeprecation(true);
		task.setFailonerror(false);
		task.setNoExit(true); // ok to override Ant?
		task.setNoImportError(true);
		task.setNowarn(true);
		task.setXNoweave(true);
		task.setPreserveAllLocals(true);
		task.setProceedOnError(true);
		task.setReferenceInfo(true);
		task.setSource("1.3");
		task.setTarget("1.1");
		task.setTime(true);
		task.setVerbose(true);
		task.setXlint("info");
		runTest(task, NO_EXCEPTION, MessageHolderChecker.INFOS);
	}
================= fetch public void testDefaultValues() { b225911^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java

public void testDefaultValues() {
		assertFalse(options.noWeave);
		assertFalse(options.xSerializableAspects);
		assertFalse(options.xLazyThisJoinPoint);
		assertFalse(options.xNoInline);
		assertFalse(options.xNotReweavable);
		assertFalse(options.generateModel);
		assertFalse(options.generateJavaDocsInModel);
		assertFalse(options.generateEmacsSymFiles);
		assertFalse(options.noAtAspectJProcessing);
		
		Map map = options.getMap();
		assertEquals(CompilerOptions.WARNING,map.get(AjCompilerOptions.OPTION_ReportInvalidAbsoluteTypeName));
		assertEquals(CompilerOptions.IGNORE,map.get(AjCompilerOptions.OPTION_ReportInvalidWildcardTypeName));
		assertEquals(CompilerOptions.WARNING,map.get(AjCompilerOptions.OPTION_ReportUnresolvableMember));
		assertEquals(CompilerOptions.WARNING,map.get(AjCompilerOptions.OPTION_ReportTypeNotExposedToWeaver));
		assertEquals(CompilerOptions.IGNORE,map.get(AjCompilerOptions.OPTION_ReportShadowNotInStructure));
		assertEquals(CompilerOptions.WARNING,map.get(AjCompilerOptions.OPTION_ReportUnmatchedSuperTypeInCall));
		assertEquals(CompilerOptions.WARNING,map.get(AjCompilerOptions.OPTION_ReportCannotImplementLazyTJP));
		assertEquals(CompilerOptions.IGNORE,map.get(AjCompilerOptions.OPTION_ReportNeedSerialVersionUIDField));
		assertEquals(CompilerOptions.IGNORE,map.get(AjCompilerOptions.OPTION_ReportIncompatibleSerialVersion));
	}
================= fetch public void testDirectSet() { b225911^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java

public void testDirectSet() {
		options.noWeave = true;
		options.xSerializableAspects = true;
		options.xLazyThisJoinPoint = true;
		options.xNoInline = true;
		options.xNotReweavable = true;
		options.generateModel = true;
		options.generateJavaDocsInModel = true;
		options.generateEmacsSymFiles = true;
		options.noAtAspectJProcessing = true;

		Map map = options.getMap();
		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_NoWeave));
		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_XSerializableAspects));
		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_XLazyThisJoinPoint));
		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_XNoInline));
		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_XNotReweavable));
		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_GenerateModel));
		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_GenerateJavaDocsInModel));
		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_Emacssym));
		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_XDevNoAtAspectJProcessing));
	}
================= fetch public void testIllegalAccessErrorWithAroundAdviceNotSelf_pr119657() { b225911^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testIllegalAccessErrorWithAroundAdviceNotSelf_pr119657() {
	  runTest("IllegalAccessError with around advice on interface method call not self");
  }
================= fetch public void testJavaCAjcLTWPerClauseTest() { b225911^:tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java

public void testJavaCAjcLTWPerClauseTest() {
        runTest("JavaCAjcLTW PerClauseTest");
    }
================= fetch public void testMapSet() { b225911^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java

public void testMapSet() {
		Map map = new HashMap();
		map.put(AjCompilerOptions.OPTION_ReportInvalidAbsoluteTypeName,CompilerOptions.ERROR);
		map.put(AjCompilerOptions.OPTION_ReportInvalidWildcardTypeName,CompilerOptions.ERROR);
		map.put(AjCompilerOptions.OPTION_ReportUnresolvableMember,CompilerOptions.IGNORE);
		map.put(AjCompilerOptions.OPTION_ReportTypeNotExposedToWeaver,CompilerOptions.ERROR);
		map.put(AjCompilerOptions.OPTION_ReportShadowNotInStructure,CompilerOptions.WARNING);
		map.put(AjCompilerOptions.OPTION_ReportUnmatchedSuperTypeInCall,CompilerOptions.ERROR);
		map.put(AjCompilerOptions.OPTION_ReportCannotImplementLazyTJP,CompilerOptions.ERROR);
		map.put(AjCompilerOptions.OPTION_ReportNeedSerialVersionUIDField,CompilerOptions.WARNING);
		map.put(AjCompilerOptions.OPTION_ReportIncompatibleSerialVersion,CompilerOptions.ERROR);
		
		map.put(AjCompilerOptions.OPTION_NoWeave,CompilerOptions.ENABLED);
		map.put(AjCompilerOptions.OPTION_XSerializableAspects,CompilerOptions.ENABLED);
		map.put(AjCompilerOptions.OPTION_XLazyThisJoinPoint,CompilerOptions.ENABLED);
		map.put(AjCompilerOptions.OPTION_XNoInline,CompilerOptions.ENABLED);
		map.put(AjCompilerOptions.OPTION_XNotReweavable,CompilerOptions.ENABLED);
		map.put(AjCompilerOptions.OPTION_GenerateModel,CompilerOptions.ENABLED);
		map.put(AjCompilerOptions.OPTION_GenerateJavaDocsInModel,CompilerOptions.ENABLED);
		map.put(AjCompilerOptions.OPTION_Emacssym,CompilerOptions.ENABLED);
		map.put(AjCompilerOptions.OPTION_XDevNoAtAspectJProcessing,CompilerOptions.ENABLED);
		
		options.set(map);
		
		assertTrue(options.noWeave);
		assertTrue(options.xSerializableAspects);
		assertTrue(options.xLazyThisJoinPoint);
		assertTrue(options.xNoInline);
		assertTrue(options.xNotReweavable);
		assertTrue(options.generateModel);
		assertTrue(options.generateJavaDocsInModel);
		assertTrue(options.generateEmacsSymFiles);
		assertTrue(options.noAtAspectJProcessing);
		
		Map newMap = options.getMap();
		
		assertEquals(CompilerOptions.ERROR,newMap.get(AjCompilerOptions.OPTION_ReportInvalidAbsoluteTypeName));
		assertEquals(CompilerOptions.ERROR,newMap.get(AjCompilerOptions.OPTION_ReportInvalidWildcardTypeName));
		assertEquals(CompilerOptions.IGNORE,newMap.get(AjCompilerOptions.OPTION_ReportUnresolvableMember));
		assertEquals(CompilerOptions.ERROR,newMap.get(AjCompilerOptions.OPTION_ReportTypeNotExposedToWeaver));
		assertEquals(CompilerOptions.WARNING,newMap.get(AjCompilerOptions.OPTION_ReportShadowNotInStructure));
		assertEquals(CompilerOptions.ERROR,newMap.get(AjCompilerOptions.OPTION_ReportUnmatchedSuperTypeInCall));
		assertEquals(CompilerOptions.ERROR,newMap.get(AjCompilerOptions.OPTION_ReportCannotImplementLazyTJP));
		assertEquals(CompilerOptions.WARNING,newMap.get(AjCompilerOptions.OPTION_ReportNeedSerialVersionUIDField));
		assertEquals(CompilerOptions.ERROR,newMap.get(AjCompilerOptions.OPTION_ReportIncompatibleSerialVersion));
	}
================= fetch public void testNonStandardOptions() { b225911^:ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java

public void testNonStandardOptions() {
		buildOptions.setNonStandardOptions( "-XnoWeave" );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
        assertTrue(configFile + " failed", null != buildConfig);            
		assertTrue( "XnoWeave", buildConfig.isNoWeave() );
		buildOptions.setNonStandardOptions( "-XserializableAspects" );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		assertTrue( "XserializableAspects", buildConfig.isXserializableAspects() );
		buildOptions.setNonStandardOptions( "-XnoInline" );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		assertTrue( "XnoInline", buildConfig.isXnoInline());
		buildOptions.setNonStandardOptions( "-Xlint" );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		assertEquals( "Xlint", AjBuildConfig.AJLINT_DEFAULT, 
		                       buildConfig.getLintMode());
		buildOptions.setNonStandardOptions( "-Xlint:error" );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
		assertEquals( "Xlint", AjBuildConfig.AJLINT_ERROR, 
		                       buildConfig.getLintMode());

		// XXX test for lintfile
//		buildOptions.setNonStandardOptions( "-Xlintfile testdata/AspectJBuildManagerTest/lint.properties" );
//		buildConfig = compilerAdapter.genBuildConfig( configFile );			
//		assertEquals( "Xlintfile", new File( "testdata/AspectJBuildManagerTest/lint.properties" ).getAbsolutePath(), 
//		                       buildConfig.getLintSpecFile().toString());
		// and a few options thrown in at once
		buildOptions.setNonStandardOptions( "-Xlint -XnoInline -XserializableAspects" );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
        assertTrue(configFile + " failed", null != buildConfig);            
		assertEquals( "Xlint", AjBuildConfig.AJLINT_DEFAULT, 
		                       buildConfig.getLintMode());
		assertTrue( "XnoInline", buildConfig.isXnoInline());
		assertTrue( "XserializableAspects", buildConfig.isXserializableAspects() );			                       						
	}
================= fetch public void testRunThemAllWithJavacCompiledAndLTW() { b225911^:tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java

public void testRunThemAllWithJavacCompiledAndLTW() {
		runTest("RunThemAllWithJavacCompiledAndLTW");
	}
================= fetch public MemberImpl( a116142^:weaver/src/org/aspectj/weaver/MemberImpl.java

================= fetch public MemberImpl( a116142^:weaver/src/org/aspectj/weaver/MemberImpl.java

================= fetch public String getSignature() { a116142^:weaver/src/org/aspectj/weaver/JoinPointSignature.java

public String getSignature() {
		return realMember.getSignature();
	}
================= fetch public String toLongString() { a116142^:weaver/src/org/aspectj/weaver/MemberImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.Member#getArity()
	 */
public int getArity() { return parameterTypes.length; }
================= fetch public static Kind read(DataInputStream s) throws IOException { a116142^:weaver/src/org/aspectj/weaver/Member.java

public static Kind read(DataInputStream s) throws IOException {
            int key = s.readByte();
            switch(key) {
                case 1: return METHOD;
                case 2: return FIELD;
                case 3: return CONSTRUCTOR;
                case 4: return STATIC_INITIALIZATION;
                case 5: return POINTCUT;
                case 6: return ADVICE;
                case 7: return HANDLER;
            }
            throw new BCException("weird kind " + key);
        }
================= fetch private ReflectionWorld() { cafdecb^:weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java

================= fetch private static ResolvedType toResolvedType(Class aClass, ReflectionWorld aWorld) cafdecb^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java

private static ResolvedType[] toResolvedTypeArray(Class[] classes, World inWorld) {
		ResolvedType[] ret = new ResolvedType[classes.length];
		for (int i = 0; i < ret.length; i++) {
			ret[i] = ((ReflectionWorld)inWorld).resolve(classes[i]);
		}
		return ret;
	}
================= fetch private void initializeAnnotationFinder(ClassLoader loader) { cafdecb^:weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java

private void initializeAnnotationFinder(ClassLoader loader) {
		try {
			Class java15AnnotationFinder = Class.forName("org.aspectj.weaver.reflect.Java15AnnotationFinder");
			this.annotationFinder = (AnnotationFinder) java15AnnotationFinder.newInstance();
			this.annotationFinder.setClassLoader(loader);
			this.annotationFinder.setWorld(this);
		} catch(ClassNotFoundException ex) {
			// must be on 1.4 or earlier
		} catch(IllegalAccessException ex) {
			// not so good
			throw new BCException("AspectJ internal error",ex);
		} catch(InstantiationException ex) {
			throw new BCException("AspectJ internal error",ex);
		}
	}
================= fetch protected ReferenceTypeDelegate resolveDelegate(ReferenceType ty) { cafdecb^:weaver/src/org/aspectj/weaver/ltw/LTWWorld.java

protected ReferenceTypeDelegate resolveDelegate(ReferenceType ty) {
		// TODO Auto-generated method stub
		return null;
		
	}
================= fetch public Advice createAdviceMunger(AdviceAttribute attribute, Pointcut pointcut, M cafdecb^:weaver/src/org/aspectj/weaver/ltw/LTWWorld.java

public Advice createAdviceMunger(AdviceAttribute attribute, Pointcut pointcut, Member signature) {
		// TODO Auto-generated method stub
		return null;
	}
================= fetch public AnnotationFinder getAnnotationFinder() { cafdecb^:weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java

public AnnotationFinder getAnnotationFinder() {
		return this.annotationFinder;
	}
================= fetch public ConcreteTypeMunger concreteTypeMunger(ResolvedTypeMunger munger, Resolved cafdecb^:weaver/src/org/aspectj/weaver/ltw/LTWWorld.java

public ConcreteTypeMunger concreteTypeMunger(ResolvedTypeMunger munger, ResolvedType aspectType) {
		// TODO Auto-generated method stub
		return null;
	}
================= fetch public ConcreteTypeMunger makeCflowCounterFieldAdder(ResolvedMember cflowField) cafdecb^:weaver/src/org/aspectj/weaver/ltw/LTWWorld.java

public ConcreteTypeMunger makeCflowCounterFieldAdder(ResolvedMember cflowField) {
		// TODO Auto-generated method stub
		return null;
	}
================= fetch public ConcreteTypeMunger makeCflowStackFieldAdder(ResolvedMember cflowField) { cafdecb^:weaver/src/org/aspectj/weaver/ltw/LTWWorld.java

public ConcreteTypeMunger makeCflowStackFieldAdder(ResolvedMember cflowField) {
		// TODO Auto-generated method stub
		return null;
	}
================= fetch public ConcreteTypeMunger makePerClauseAspect(ResolvedType aspect, Kind kind) { cafdecb^:weaver/src/org/aspectj/weaver/ltw/LTWWorld.java

public ConcreteTypeMunger makePerClauseAspect(ResolvedType aspect, Kind kind) {
		// TODO Auto-generated method stub
		return null;
	}
================= fetch public ReflectionShadow(World world, Kind kind, Member signature, Shadow enclosi cafdecb^:weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java

public static Shadow makeFieldSetShadow(World inWorld, Field forField, java.lang.reflect.Member inMember, MatchingContext withContext) {
		Shadow enclosingShadow = makeExecutionShadow(inWorld,inMember,withContext);
		Member signature = ReflectionBasedReferenceTypeDelegateFactory.createResolvedField(forField, inWorld);
		ResolvedMember enclosingMember = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMember(inMember, inWorld);
		ResolvedType enclosingType = enclosingMember.getDeclaringType().resolve(inWorld);
		Kind kind = Shadow.FieldSet;
		return new ReflectionShadow(inWorld,kind,signature,enclosingShadow,enclosingType,enclosingMember,withContext);
	}
================= fetch public ReflectionWorld(ClassLoader aClassLoader) { cafdecb^:weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java

================= fetch public ResolvedType resolve(Class aClass) { cafdecb^:weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java

public ResolvedType resolve(Class aClass) {
		// classes that represent arrays return a class name that is the signature of the array type, ho-hum...
		String className = aClass.getName();
		if (aClass.isArray()) {
			return resolve(UnresolvedType.forSignature(className));
		}
		else{
			return resolve(className);
		} 
	}
================= fetch public static ResolvedMember createHandlerMember(Class exceptionType, Class inTy cafdecb^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java

public static ResolvedMember createHandlerMember(Class exceptionType, Class inType,World inWorld) {
		return new ResolvedMemberImpl(
				org.aspectj.weaver.Member.HANDLER,
				toResolvedType(inType,(ReflectionWorld)inWorld),
				Modifier.STATIC,
				"<catch>",
				"(" + inWorld.resolve(exceptionType.getName()).getSignature() + ")V");
	}
================= fetch public static ResolvedMember createResolvedAdviceMember(Method aMethod, World in cafdecb^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java

public static ResolvedMember createResolvedAdviceMember(Method aMethod, World inWorld) {
		ReflectionBasedResolvedMemberImpl ret =
			new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.ADVICE,
				toResolvedType(aMethod.getDeclaringClass(),(ReflectionWorld)inWorld),
				aMethod.getModifiers(),
				toResolvedType(aMethod.getReturnType(),(ReflectionWorld)inWorld),
				aMethod.getName(),
				toResolvedTypeArray(aMethod.getParameterTypes(),inWorld),
				toResolvedTypeArray(aMethod.getExceptionTypes(),inWorld),
				aMethod
				);
		if (inWorld instanceof ReflectionWorld) {
			ret.setAnnotationFinder(((ReflectionWorld)inWorld).getAnnotationFinder());
		}
		ret.setGenericSignatureInformationProvider(createGenericSignatureProvider(inWorld));
		return ret;
	}
================= fetch public static ResolvedMember createResolvedConstructor(Constructor aConstructor, cafdecb^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java

public static ResolvedMember createResolvedConstructor(Constructor aConstructor, World inWorld) {
		ReflectionBasedResolvedMemberImpl ret =
		   new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.CONSTRUCTOR,
				toResolvedType(aConstructor.getDeclaringClass(),(ReflectionWorld)inWorld),
				aConstructor.getModifiers(),
				// to return what BCEL returns, the return type for ctor is void
				ResolvedType.VOID,//toResolvedType(aConstructor.getDeclaringClass(),(ReflectionWorld)inWorld),
				"<init>",
				toResolvedTypeArray(aConstructor.getParameterTypes(),inWorld),
				toResolvedTypeArray(aConstructor.getExceptionTypes(),inWorld),
				aConstructor
				);
		if (inWorld instanceof ReflectionWorld) {
			ret.setAnnotationFinder(((ReflectionWorld)inWorld).getAnnotationFinder());
		}
		ret.setGenericSignatureInformationProvider(createGenericSignatureProvider(inWorld));
		return ret;
	}
================= fetch public static ResolvedMember createResolvedField(Field aField, World inWorld) { cafdecb^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java

public static ResolvedMember createResolvedField(Field aField, World inWorld) {
		ReflectionBasedResolvedMemberImpl ret =
			new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.FIELD,
				toResolvedType(aField.getDeclaringClass(),(ReflectionWorld)inWorld),
				aField.getModifiers(),
				toResolvedType(aField.getType(),(ReflectionWorld)inWorld),
				aField.getName(),
				new UnresolvedType[0],
				aField);
		if (inWorld instanceof ReflectionWorld) {
			ret.setAnnotationFinder(((ReflectionWorld)inWorld).getAnnotationFinder());
		}
		ret.setGenericSignatureInformationProvider(createGenericSignatureProvider(inWorld));
		return ret;
	}
================= fetch public static ResolvedMember createResolvedMethod(Method aMethod, World inWorld) cafdecb^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java

public static ResolvedMember createResolvedMethod(Method aMethod, World inWorld) {
		ReflectionBasedResolvedMemberImpl ret = new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.METHOD,
				toResolvedType(aMethod.getDeclaringClass(),(ReflectionWorld)inWorld),
				aMethod.getModifiers(),
				toResolvedType(aMethod.getReturnType(),(ReflectionWorld)inWorld),
				aMethod.getName(),
				toResolvedTypeArray(aMethod.getParameterTypes(),inWorld),
				toResolvedTypeArray(aMethod.getExceptionTypes(),inWorld),
				aMethod
				);
		if (inWorld instanceof ReflectionWorld) {
			ret.setAnnotationFinder(((ReflectionWorld)inWorld).getAnnotationFinder());
		}
		ret.setGenericSignatureInformationProvider(createGenericSignatureProvider(inWorld));
		return ret;
	}
================= fetch public static ResolvedMember createStaticInitMember(Class forType, World inWorld cafdecb^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java

public static ResolvedMember createStaticInitMember(Class forType, World inWorld) {
		return new ResolvedMemberImpl(org.aspectj.weaver.Member.STATIC_INITIALIZATION,
				toResolvedType(forType,(ReflectionWorld)inWorld),
				Modifier.STATIC,
				ResolvedType.VOID,
				"<clinit>",
				new UnresolvedType[0],
				new UnresolvedType[0]
				);
	}
================= fetch public static ResolvedType resolveTypeInWorld(Class aClass, World aWorld) { cafdecb^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java

public static ResolvedType resolveTypeInWorld(Class aClass, World aWorld) {
//		 classes that represent arrays return a class name that is the signature of the array type, ho-hum...
		String className = aClass.getName();
		if (aClass.isArray()) {
			return aWorld.resolve(UnresolvedType.forSignature(className.replace('.','/')));
		}
		else{
			return aWorld.resolve(className);
		} 
	}
================= fetch public void testArrayTypes() { cafdecb^:weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.java

public void testArrayTypes() {
		ReflectionWorld world = new ReflectionWorld(getClass().getClassLoader());
		String[] strArray = new String[1];
		ResolvedType rt = world.resolve(strArray.getClass());
		assertTrue(rt.isArray());
	}
================= fetch public void testPrimitiveTypes() { cafdecb^:weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.java

public void testPrimitiveTypes() {
		ReflectionWorld world = new ReflectionWorld(getClass().getClassLoader());
		assertEquals("int",ResolvedType.INT,world.resolve(int.class));
		assertEquals("void",ResolvedType.VOID,world.resolve(void.class));
	}
================= fetch public UnresolvedType getExtraParameterType() { 3fa1bdd^:weaver/src/org/aspectj/weaver/Advice.java

public UnresolvedType getExtraParameterType() {
		if (!hasExtraParameter()) return ResolvedType.MISSING;
		if (signature instanceof ResolvedMember) {
			return ((ResolvedMember)signature).getGenericParameterTypes()[getBaseParameterCount()];
		} else {
			return signature.getParameterTypes()[getBaseParameterCount()];
		}
	}
================= fetch public void testSwallowedException() { 3fa1bdd^:tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java

public void testSwallowedException() {
	  runTest("swallowed exceptions");
  }
================= fetch public boolean handleMessage(IMessage message) throws AbortException { 89d66dc^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java

public boolean handleMessage(IMessage message) throws AbortException {
		if (! (message.isError() || message.isWarning()) ) return sink.handleMessage(message);
		// we only care about warnings and errors here...
		ISourceLocation sLoc = message.getSourceLocation();
		
		// See bug 62073.  We should assert that the caller pass the correct primary source location.
		// But for AJ1.2 final we will simply do less processing of the locations if that is not the
		// case (By calling sink.handleMessage()) - this ensures we don't put out bogus source context info.
		if (sLoc instanceof EclipseSourceLocation) {
			EclipseSourceLocation esLoc = (EclipseSourceLocation)sLoc;
			if (currentlyWeaving!=null && esLoc.getCompilationResult()!=null) {
			  if (!currentlyWeaving.equals(((EclipseSourceLocation)sLoc).getCompilationResult()))
			  return sink.handleMessage(message);
			  //  throw new RuntimeException("Primary source location must match the file we are currently processing!");
			}
		}
		
		CompilationResult problemSource = currentlyWeaving;
		if (problemSource == null) {
			// must be a problem found during completeTypeBindings phase of begin to compile
			if (sLoc instanceof EclipseSourceLocation) {
				problemSource = ((EclipseSourceLocation)sLoc).getCompilationResult();
			}
			if (problemSource == null) {
				// XXX this is ok for ajc, will have to do better for AJDT in time...
				return sink.handleMessage(message);
			}
		}
		int startPos = getStartPos(sLoc,problemSource);
		int endPos = getEndPos(sLoc,problemSource);
		int severity = message.isError() ? ProblemSeverities.Error : ProblemSeverities.Warning;
		char[] filename = problemSource.fileName;
		boolean usedBinarySourceFileName = false;
		if (problemSource.isFromBinarySource()) {
			if (sLoc != null) {
				filename = sLoc.getSourceFile().getPath().toCharArray();
				usedBinarySourceFileName = true;
			}
		}
		ReferenceContext referenceContext = findReferenceContextFor(problemSource);
		IProblem problem = compiler.problemReporter.createProblem(
								filename,
								IProblem.Unclassified,
								new String[0],
								new String[] {message.getMessage()},
								severity,
								startPos,
								endPos,
								sLoc != null ? sLoc.getLine() : 0
								);
		IProblem[] seeAlso = buildSeeAlsoProblems(problem,message.getExtraSourceLocations(),
												  problemSource,	
												  usedBinarySourceFileName);
		problem.setSeeAlsoProblems(seeAlso);
		
		StringBuffer details = new StringBuffer();
		// Stick more info in supplementary message info
		if (message.getDetails() != null) {
			details.append(message.getDetails());
		}
		// Remember if this message was due to a deow
		if (message.getDeclared()) {
			details.append("[deow=true]");
		}
		if (details.length()!=0) { 
			problem.setSupplementaryMessageInfo(details.toString());
		}
		compiler.problemReporter.record(problem, problemSource, referenceContext);
		return true;
	}
================= fetch public void testPr125405() { 89d66dc^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
// parameterization of generic aspects
public void testPr125405() {
		initialiseProject("PR125405");
		build("PR125405");
		checkCompileWeaveCount(1,1);
		alter("PR125405","inc1");
		build("PR125405");
		// "only abstract aspects can have type parameters"
		checkForError("only abstract aspects can have type parameters");
		alter("PR125405","inc2");
		build("PR125405");
		checkCompileWeaveCount(2,1);
		assertTrue("Should be no errors, but got "+MyTaskListManager.getErrorMessages(),MyTaskListManager.getErrorMessages().size()==0);		
	}
Progress : [####################--------------------] 52%================= fetch private void validateOrBranch(OrPointcut pc, Pointcut userPointcut, int numForma ba42a09^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java

private void validateOrBranch(OrPointcut pc, Pointcut userPointcut, int numFormals, 
    		String[] names, Pointcut[] leftBindings, Pointcut[] rightBindings) {
    	Pointcut left = pc.getLeft();
    	Pointcut right = pc.getRight();
    	if (left instanceof OrPointcut) {
    		Pointcut[] newRightBindings = new Pointcut[numFormals];
    		validateOrBranch((OrPointcut)left,userPointcut,numFormals,names,leftBindings,newRightBindings);    		
    	} else {
    		if (left.couldMatchKinds()!=Shadow.NO_SHADOW_KINDS_BITS)
    			validateSingleBranch(left, userPointcut, numFormals, names, leftBindings);
    	}
    	if (right instanceof OrPointcut) {
    		Pointcut[] newLeftBindings = new Pointcut[numFormals];
    		validateOrBranch((OrPointcut)right,userPointcut,numFormals,names,newLeftBindings,rightBindings);
    	} else {
    		if (right.couldMatchKinds()!=Shadow.NO_SHADOW_KINDS_BITS)
    			validateSingleBranch(right, userPointcut, numFormals, names, rightBindings);    		
    	}
		int kindsInCommon = left.couldMatchKinds() & right.couldMatchKinds();
		if (kindsInCommon!=Shadow.NO_SHADOW_KINDS_BITS && couldEverMatchSameJoinPoints(left,right)) {
			// we know that every branch binds every formal, so there is no ambiguity
			// if each branch binds it in exactly the same way...
			List ambiguousNames = new ArrayList();
			for (int i = 0; i < numFormals; i++) {
				if (!leftBindings[i].equals(rightBindings[i])) {
					ambiguousNames.add(names[i]);
				}
			}
			if (!ambiguousNames.isEmpty())
				raiseAmbiguityInDisjunctionError(userPointcut,ambiguousNames);
		}    	
    }
================= fetch public void testAtAspectDeclareParentsRetainsFieldState_pr122370() { ba42a09^:tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java

public void testAtAspectDeclareParentsRetainsFieldState_pr122370() {
	  runTest("@AJ declare parents retains field state");
  }
================= fetch public boolean validate() { 7a2087e^:loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java

public boolean validate() {
        if (!(m_world instanceof BcelWorld)) {
            reportError("Internal error: world must be of type BcelWorld");
            return false;
        }

        // name must be undefined so far
        ResolvedType current = m_world.resolve(m_concreteAspect.name, true);
        if (!current.isMissing()) {
            reportError("Attempt to concretize but choosen aspect name already defined: " + stringify());
            return false;
        }

        // it can happen that extends is null, for precedence only declaration
        if (m_concreteAspect.extend == null && m_concreteAspect.precedence != null) {
            if (m_concreteAspect.pointcuts.isEmpty()) {
                m_isValid = true;
                m_perClause = new PerSingleton();
                m_parent = null;
                return true;// no need to checks more in that special case
            } else {
                reportError("Attempt to use nested pointcuts without extends clause: "+stringify());
                return false;
            }
        }

        m_parent = m_world.resolve(m_concreteAspect.extend, true);
        // handle inner classes
        if (m_parent.isMissing()) {
            // fallback on inner class lookup mechanism
            String fixedName = m_concreteAspect.extend;
            int hasDot = fixedName.lastIndexOf('.');
            while (hasDot > 0) {
                char[] fixedNameChars = fixedName.toCharArray();
                fixedNameChars[hasDot] = '$';
                fixedName = new String(fixedNameChars);
                hasDot = fixedName.lastIndexOf('.');
                m_parent = m_world.resolve(UnresolvedType.forName(fixedName), true);
                if (!m_parent.isMissing()) {
                    break;
                }
            }
        }
        if (m_parent.isMissing()) {
            reportError("Cannot find m_parent aspect for: " + stringify());
            return false;
        }

        // extends must be abstract
        if (!m_parent.isAbstract()) {
            reportError("Attempt to concretize a non-abstract aspect: " + stringify());
            return false;
        }

        // m_parent must be aspect
        if (!m_parent.isAspect()) {
            reportError("Attempt to concretize a non aspect: " + stringify());
            return false;
        }

        // must have all abstractions defined
        List elligibleAbstractions = new ArrayList();
        Iterator methods = m_parent.getMethods();
        while (methods.hasNext()) {
            ResolvedMember method = (ResolvedMember) methods.next();
            if (method.isAbstract()) {
                if ("()V".equals(method.getSignature())) {
                    elligibleAbstractions.add(method.getName());
                } else {
                    reportError("Abstract method '" + method.getName() + "' cannot be concretized as a pointcut (illegal signature, must have no arguments, must return void): " + stringify());
                    return false;
                }
            }
        }
        List pointcutNames = new ArrayList();
        for (Iterator it = m_concreteAspect.pointcuts.iterator(); it.hasNext();) {
            Definition.Pointcut abstractPc = (Definition.Pointcut) it.next();
            pointcutNames.add(abstractPc.name);
        }
        for (Iterator it = elligibleAbstractions.iterator(); it.hasNext();) {
            String elligiblePc = (String) it.next();
            if (!pointcutNames.contains(elligiblePc)) {
                reportError("Abstract pointcut '" + elligiblePc + "' not configured: " + stringify());
                return false;
            }
        }

        m_perClause = m_parent.getPerClause();
        m_isValid = true;
        return m_isValid;
    }
================= fetch public Declare parseDeclare() { f95d2c9^:weaver/src/org/aspectj/weaver/patterns/PatternParser.java

public Declare parseDeclare() {
		int startPos = tokenSource.peek().getStart();
		
		eatIdentifier("declare");
		String kind = parseIdentifier();
		Declare ret;
		if (kind.equals("error")) {
			eat(":");
			ret = parseErrorOrWarning(true);
		} else if (kind.equals("warning")) {
			eat(":");
			ret = parseErrorOrWarning(false);
		} else if (kind.equals("precedence")) {
			eat(":");
			ret = parseDominates();
		} else if (kind.equals("dominates")) {
			throw new ParserException("name changed to declare precedence", tokenSource.peek(-2));
		} else if (kind.equals("parents")) {
			ret = parseParents();
		} else if (kind.equals("soft")) {
			eat(":");
			ret = parseSoft();
		} else {
			throw new ParserException("expected one of error, warning, parents, soft, dominates",
				tokenSource.peek(-1));
		}
	    int endPos = tokenSource.peek(-1).getEnd();
		ret.setLocation(sourceContext, startPos, endPos);
		return ret;
	}
================= fetch private boolean mungeMethodDelegate(BcelClassWeaver weaver, MethodDelegateTypeMu e874581^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java

private boolean mungeMethodDelegate(BcelClassWeaver weaver, MethodDelegateTypeMunger munger) {
        ResolvedMember introduced = munger.getSignature();

        LazyClassGen gen = weaver.getLazyClassGen();

        ResolvedType fromType = weaver.getWorld().resolve(introduced.getDeclaringType(),munger.getSourceLocation());
        if (fromType.isRawType()) fromType = fromType.getGenericType();

        if (gen.getType().isAnnotation() || gen.getType().isEnum()) {
            // don't signal error as it could be a consequence of a wild type pattern
            return false;
        }

        boolean shouldApply = munger.matches(weaver.getLazyClassGen().getType(), aspectType);
        if (shouldApply) {
            LazyMethodGen mg = new LazyMethodGen(
                    introduced.getModifiers() - Modifier.ABSTRACT,
                    BcelWorld.makeBcelType(introduced.getReturnType()),
                    introduced.getName(),
                    BcelWorld.makeBcelTypes(introduced.getParameterTypes()),
                    BcelWorld.makeBcelTypesAsClassNames(introduced.getExceptions()),
                    gen
            );

            //annotation copy from annotation on ITD interface
            if (weaver.getWorld().isInJava5Mode()){
                AnnotationX annotationsOnRealMember[] = null;
                ResolvedType toLookOn = weaver.getWorld().lookupOrCreateName(introduced.getDeclaringType());
                if (fromType.isRawType()) toLookOn = fromType.getGenericType();
                // lookup the method
                ResolvedMember[] ms = toLookOn.getDeclaredJavaMethods();
                for (int i = 0; i < ms.length; i++) {
                    ResolvedMember m = ms[i];
                    if (introduced.getName().equals(m.getName()) && introduced.getSignature().equals(m.getSignature())) {
                        annotationsOnRealMember = m.getAnnotations();
                    }
                }
                if (annotationsOnRealMember!=null) {
                    for (int i = 0; i < annotationsOnRealMember.length; i++) {
                        AnnotationX annotationX = annotationsOnRealMember[i];
                        Annotation a = annotationX.getBcelAnnotation();
                        AnnotationGen ag = new AnnotationGen(a,weaver.getLazyClassGen().getConstantPoolGen(),true);
                        mg.addAnnotation(new AnnotationX(ag.getAnnotation(),weaver.getWorld()));
                    }
                }
            }

            InstructionList body = new InstructionList();
            InstructionFactory fact = gen.getFactory();

            // getfield
            body.append(InstructionConstants.ALOAD_0);
            body.append(Utility.createGet(fact, munger.getDelegate(weaver.getLazyClassGen().getType())));
            BranchInstruction ifNonNull = InstructionFactory.createBranchInstruction(Constants.IFNULL, null);
            body.append(ifNonNull);
            InstructionHandle ifNonNullElse = body.append(InstructionConstants.ALOAD_0);
            body.append(fact.createNew(munger.getImplClassName()));
            body.append(InstructionConstants.DUP);
            body.append(fact.createInvoke(munger.getImplClassName(), "<init>", Type.VOID, Type.NO_ARGS, Constants.INVOKESPECIAL));
            body.append(Utility.createSet(fact, munger.getDelegate(weaver.getLazyClassGen().getType())));
            ifNonNull.setTarget(ifNonNullElse);
            body.append(InstructionConstants.ALOAD_0);
            body.append(Utility.createGet(fact, munger.getDelegate(weaver.getLazyClassGen().getType())));

            //args
            int pos = 0;
    		if (!introduced.isStatic()) { // skip 'this' (?? can this really happen)
    		  //body.append(InstructionFactory.createThis());
    		  pos++;
    		}
            Type[] paramTypes = BcelWorld.makeBcelTypes(introduced.getParameterTypes());
            for (int i = 0, len = paramTypes.length; i < len; i++) {
                Type paramType = paramTypes[i];
                body.append(InstructionFactory.createLoad(paramType, pos));
                pos+=paramType.getSize();
            }
            body.append(Utility.createInvoke(fact, Constants.INVOKEINTERFACE, introduced));
            body.append(
                InstructionFactory.createReturn(
                    BcelWorld.makeBcelType(introduced.getReturnType())
                )
            );

            mg.getBody().append(body);
            // XXX make sure to check that we set exceptions properly on this guy.
            weaver.addLazyMethodGen(mg);
            weaver.getLazyClassGen().warnOnAddedMethod(mg.getMethod(),getSignature().getSourceLocation());
            return true;
        }
        return false;
    }
================= fetch public void testAtAspectWithoutJoinPointImport_pr121616() { e874581^:tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java

public void testAtAspectWithoutJoinPointImport_pr121616() {
	  runTest("@AJ without JoinPoint import");
  }
================= fetch public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) { d4219e1^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java

public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {
		ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.VALIDATING_AT_ASPECTJ_ANNOTATIONS, methodDeclaration.selector);
		ajAnnotations = new AspectJAnnotations(methodDeclaration.annotations);
		if (!methodDeclaration.getClass().equals(AjMethodDeclaration.class)) {
			// simply test for innapropriate use of annotations on code-style members
			if (methodDeclaration instanceof PointcutDeclaration) {
				if (ajAnnotations.hasMultiplePointcutAnnotations ||
				    ajAnnotations.hasAdviceAnnotation ||
				    ajAnnotations.hasAspectAnnotation ||
				    ajAnnotations.hasAdviceNameAnnotation) {
					methodDeclaration.scope.problemReporter().signalError(
							methodDeclaration.sourceStart,
							methodDeclaration.sourceEnd,
							"@AspectJ annotations cannot be declared on this aspect member");
				}
			} else if (methodDeclaration instanceof AdviceDeclaration) {
				if (ajAnnotations.hasMultipleAdviceAnnotations ||
					ajAnnotations.hasAspectAnnotation ||
					ajAnnotations.hasPointcutAnnotation) {
					methodDeclaration.scope.problemReporter().signalError(
										methodDeclaration.sourceStart,
										methodDeclaration.sourceEnd,
										"Only @AdviceName AspectJ annotation allowed on advice");
				}				
			} else {
				if (ajAnnotations.hasAspectJAnnotations()) {
					methodDeclaration.scope.problemReporter().signalError(
							methodDeclaration.sourceStart,
							methodDeclaration.sourceEnd,
							"@AspectJ annotations cannot be declared on this aspect member");					
				}
			}
			CompilationAndWeavingContext.leavingPhase(tok);
			return false;
		}
		
		if (ajAnnotations.hasAdviceAnnotation) {
			validateAdvice(methodDeclaration);
		} else if (ajAnnotations.hasPointcutAnnotation) {
			convertToPointcutDeclaration(methodDeclaration,scope);
		}
		CompilationAndWeavingContext.leavingPhase(tok);
		return false;
	}
================= fetch public void testAtAspectNoNPEWithDEOWWithoutStructureModel_pr120356() { d4219e1^:tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java

public void testAtAspectNoNPEWithDEOWWithoutStructureModel_pr120356() {
	  runTest("@AJ no NPE with deow when structure model isn't generated"); 
  }
Progress : [#####################-------------------] 53%================= fetch public Collection weave(IClassFileProvider input) throws IOException { 0b39aa5^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
// variation of "weave" that sources class files from an external source.
Collection weave(IClassFileProvider input) throws IOException {
    	ContextToken weaveToken = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.WEAVING, "");
    	Collection wovenClassNames = new ArrayList();
    	IWeaveRequestor requestor = input.getRequestor();

        // special case for AtAspectJMungerOnly - see #113587
        if (input.isApplyAtAspectJMungersOnly()) {
            ContextToken atAspectJMungersOnly = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.PROCESSING_ATASPECTJTYPE_MUNGERS_ONLY, "");
            requestor.weavingAspects();
            ContextToken aspectToken = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.WEAVING_ASPECTS, "");
            for (Iterator i = input.getClassFileIterator(); i.hasNext(); ) {
                UnwovenClassFile classFile = (UnwovenClassFile)i.next();
                String className = classFile.getClassName();
                ResolvedType theType = world.resolve(className);
                if (theType.isAnnotationStyleAspect()) {
                    BcelObjectType classType = BcelWorld.getBcelObjectType(theType);
                    if (classType==null) {
                       throw new BCException("Can't find bcel delegate for "+className+" type="+theType.getClass());
                    }
                    LazyClassGen clazz = classType.getLazyClassGen();
                    BcelPerClauseAspectAdder selfMunger = new BcelPerClauseAspectAdder(theType, theType.getPerClause().getKind());
                    selfMunger.forceMunge(clazz, true);
                    classType.finishedWith();
                    UnwovenClassFile[] newClasses = getClassFilesFor(clazz);
                    for (int news = 0; news < newClasses.length; news++) {
                        requestor.acceptResult(newClasses[news]);
                    }
                    wovenClassNames.add(classFile.getClassName());
                }
            }
            requestor.weaveCompleted();
            CompilationAndWeavingContext.leavingPhase(atAspectJMungersOnly);
            return wovenClassNames;
        }

        requestor.processingReweavableState();
    	ContextToken reweaveToken = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.PROCESSING_REWEAVABLE_STATE,"");
		prepareToProcessReweavableState();
		// clear all state from files we'll be reweaving
		for (Iterator i = input.getClassFileIterator(); i.hasNext(); ) {
		    UnwovenClassFile classFile = (UnwovenClassFile)i.next();
			String className = classFile.getClassName();
		    BcelObjectType classType = getClassType(className);
		    
		    // null return from getClassType() means the delegate is an eclipse source type - so
		    // there *cant* be any reweavable state... (he bravely claimed...)
		    if (classType !=null) {
		    	ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.PROCESSING_REWEAVABLE_STATE, className);
		    	processReweavableStateIfPresent(className, classType);
		    	CompilationAndWeavingContext.leavingPhase(tok);
		    }
		}

		CompilationAndWeavingContext.leavingPhase(reweaveToken);
		
		ContextToken typeMungingToken = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.PROCESSING_TYPE_MUNGERS,"");
		requestor.addingTypeMungers();
        
        // We process type mungers in two groups, first mungers that change the type
        // hierarchy, then 'normal' ITD type mungers.
        
        
        // Process the types in a predictable order (rather than the order encountered).
        // For class A, the order is superclasses of A then superinterfaces of A
        // (and this mechanism is applied recursively)
        List typesToProcess = new ArrayList();
        for (Iterator iter = input.getClassFileIterator(); iter.hasNext();) {
			UnwovenClassFile clf = (UnwovenClassFile) iter.next();
            typesToProcess.add(clf.getClassName());
        }
        while (typesToProcess.size()>0) {
            weaveParentsFor(typesToProcess,(String)typesToProcess.get(0));
        }  
        
        for (Iterator i = input.getClassFileIterator(); i.hasNext(); ) {
            UnwovenClassFile classFile = (UnwovenClassFile)i.next();
            String className = classFile.getClassName();
            addNormalTypeMungers(className);
        }

        CompilationAndWeavingContext.leavingPhase(typeMungingToken);
        
		requestor.weavingAspects();
		ContextToken aspectToken = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.WEAVING_ASPECTS, "");
		// first weave into aspects
		for (Iterator i = input.getClassFileIterator(); i.hasNext(); ) {
		    UnwovenClassFile classFile = (UnwovenClassFile)i.next();
			String className = classFile.getClassName();
			ResolvedType theType = world.resolve(className);
			if (theType.isAspect()) {
			   BcelObjectType classType = BcelWorld.getBcelObjectType(theType);
				if (classType==null) {
					
					// Sometimes.. if the Bcel Delegate couldn't be found then a problem occurred at compile time - on
					// a previous compiler run.  In this case I assert the delegate will still be an EclipseSourceType
					// and we can ignore the problem here (the original compile error will be reported again from
					// the eclipse source type) - pr113531
					ReferenceTypeDelegate theDelegate = ((ReferenceType)theType).getDelegate();
					if (theDelegate.getClass().getName().endsWith("EclipseSourceType")) continue;

					throw new BCException("Can't find bcel delegate for "+className+" type="+theType.getClass());
				}
		        weaveAndNotify(classFile, classType,requestor);
		        wovenClassNames.add(className);
		    }
		}
		
		CompilationAndWeavingContext.leavingPhase(aspectToken);

		requestor.weavingClasses();
		ContextToken classToken = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.WEAVING_CLASSES, "");
		// then weave into non-aspects
		for (Iterator i = input.getClassFileIterator(); i.hasNext(); ) {
		    UnwovenClassFile classFile = (UnwovenClassFile)i.next();
			String className = classFile.getClassName();
			ResolvedType theType = world.resolve(className);
			if (!theType.isAspect()) {
				BcelObjectType classType = BcelWorld.getBcelObjectType(theType);
				if (classType==null) {
					throw new BCException("Can't find bcel delegate for "+className+" type="+theType.getClass());
				}
		        weaveAndNotify(classFile, classType, requestor);
		        wovenClassNames.add(className);
		    }
		}
		CompilationAndWeavingContext.leavingPhase(classToken);
		
		addedClasses = new ArrayList();
		deletedTypenames = new ArrayList();
		
        
		warnOnUnmatchedAdvice();

        requestor.weaveCompleted();
        CompilationAndWeavingContext.leavingPhase(weaveToken);
    	return wovenClassNames;
    }
================= fetch public void testPr113531() { 0b39aa5^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
// Stage3: Add a new aspect whilst there is a compile error !
public void testPr113531() {
		initialiseProject("PR113531");
		build("PR113531");
		assertFalse("build should have compiled ok",
				MyTaskListManager.hasErrorMessages());
		alter("PR113531","inc1");
		build("PR113531");
		assertEquals("error message should be 'foo cannot be resolved' ",
				"foo cannot be resolved",
				((IMessage)MyTaskListManager.getErrorMessages().get(0))
					.getMessage());
		alter("PR113531","inc2");
		build("PR113531");
		assertTrue("There should be no exceptions handled:\n"+MyErrorHandler.getErrorMessages(),
				MyErrorHandler.getErrorMessages().isEmpty());		
		assertEquals("error message should be 'foo cannot be resolved' ",
				"foo cannot be resolved",
				((IMessage)MyTaskListManager.getErrorMessages().get(0))
					.getMessage());
	}
================= fetch private static boolean handleDeclareErrorOrWarningAnnotation(RuntimeAnnotations f743fb2^:weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java
/**
     * Read @DeclareError, @DeclareWarning
     *
     * @param runtimeAnnotations
     * @param struct
     * @return true if found
     */
private static boolean handleDeclareErrorOrWarningAnnotation(RuntimeAnnotations runtimeAnnotations, AjAttributeFieldStruct struct) {
        Annotation error = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREERROR_ANNOTATION);
        boolean hasError = false;
        if (error != null) {
            ElementNameValuePair declareError = getAnnotationElement(error, VALUE);
            if (declareError != null) {
                if (!STRING_DESC.equals(struct.field.getSignature()) || struct.field.getConstantValue() == null) {
                    reportError("@DeclareError used on a non String constant field", struct);
                    return false;
                }
                FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
                IScope binding = new BindingScope(
                        struct.enclosingType,
                        struct.context,
                        bindings
                );
                Pointcut pc = parsePointcut(declareError.getValue().stringifyValue(), struct, false);
                if (pc == null) {
                    hasError = false;//cannot parse pointcut
                } else {
                    pc .resolve(binding);
                    DeclareErrorOrWarning deow = new DeclareErrorOrWarning(true, pc, struct.field.getConstantValue().toString());
                    deow.setLocation(struct.context, -1, -1);
                    struct.ajAttributes.add(new AjAttribute.DeclareAttribute(deow));
                    hasError = true;
                }
            }
        }
        Annotation warning = getAnnotation(runtimeAnnotations, AjcMemberMaker.DECLAREWARNING_ANNOTATION);
        boolean hasWarning = false;
        if (warning != null) {
            ElementNameValuePair declareWarning = getAnnotationElement(warning, VALUE);
            if (declareWarning != null) {
                if (!STRING_DESC.equals(struct.field.getSignature()) || struct.field.getConstantValue() == null) {
                    reportError("@DeclareWarning used on a non String constant field", struct);
                    return false;
                }
                FormalBinding[] bindings = new org.aspectj.weaver.patterns.FormalBinding[0];
                IScope binding = new BindingScope(
                        struct.enclosingType,
                        struct.context,
                        bindings
                );
                Pointcut pc = parsePointcut(declareWarning.getValue().stringifyValue(), struct, false);
                if (pc == null) {
                    hasWarning = false;//cannot parse pointcut
                } else {
                    pc.resolve(binding);
                    DeclareErrorOrWarning deow = new DeclareErrorOrWarning(false, pc, struct.field.getConstantValue().toString());
                    deow.setLocation(struct.context, -1, -1);
                    struct.ajAttributes.add(new AjAttribute.DeclareAttribute(deow));
                    return hasWarning = true;
                }
            }
        }
        return hasError || hasWarning;
    }
================= fetch public void testAtAspectInheritsAbstractPointcut_pr125810 () { f743fb2^:tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java
//  }
public void testAtAspectInheritsAbstractPointcut_pr125810 () {
	  runTest("warning when inherited pointcut not made concrete"); 
  }
================= fetch private boolean acceptResource(String resourceName) { d856e4f^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private boolean acceptResource(String resourceName) {
		if (  
				(resourceName.startsWith("CVS/")) ||
				(resourceName.indexOf("/CVS/") != -1) ||
				(resourceName.endsWith("/CVS")) ||
				(resourceName.endsWith(".class")) ||
				(resourceName.toUpperCase().equals(MANIFEST_NAME))
		    )
		{
			return false;
		} else {
			return true;
		}
	}
================= fetch boolean internalGetSetBooleanProperty(SimplePropertyDescriptor property, boolean eec4990^:org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjTypeDeclaration.java
/* (omit javadoc for this method)
	 * Method declared on ASTNode.
	 */
boolean internalGetSetBooleanProperty(SimplePropertyDescriptor property, boolean get, boolean value) {
		if (property == ASPECT_PROPERTY) {
			if (get) {
				return isAspect();
			} else {
				setAspect(value);
				return false;
			}
		}
		// allow default implementation to flag the error
		return super.internalGetSetBooleanProperty(property, get, value);
	}
================= fetch final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property,boole eec4990^:org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AspectDeclaration.java
/*
	 * (omit javadoc for this method) 
	 * Method declared on ASTNode.
	 */
final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property,boolean get, ASTNode child) {
		if (property == PERCLAUSE_PROPERTY) {
			if (get) {
				return getPerClause();
			} else {
				setPerClause((ASTNode) child);
				return null;
			}
		}
		return super.internalGetSetChildProperty(property,get,child);
	}
================= fetch public AjTypeDeclaration(AST ast) { eec4990^:org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjTypeDeclaration.java

================= fetch public void testGetAndSetIsAspect() { eec4990^:org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/AjASTTest.java
/**
	 * AjTypeDeclaration's have an isAspect property - 
	 * test the getting and setting of this property
	 */
public void testGetAndSetIsAspect() {
		AjAST ajast = createAjAST();
		AjTypeDeclaration d = ajast.newAjTypeDeclaration();
		assertFalse("by default an AjTypeDeclaration should be a class",d.isAspect());
		d.setAspect(true);
		assertTrue("AjTypeDeclaration should now be an aspect",d.isAspect());	
		d.setAspect(false);
		assertFalse("AjTypeDeclaration should now be a class",d.isAspect());	
	}
================= fetch public void testPropertyDescriptorsForAspectDeclaration() { eec4990^:org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/AjASTTest.java

public void testPropertyDescriptorsForAspectDeclaration() {
		AjAST ajast = createAjAST();
		AspectDeclaration d = ajast.newAspectDeclaration();
		List props = AspectDeclaration.propertyDescriptors(AST.JLS3);
		boolean foundJavadoc = false;
		boolean foundPerClause = false;
		boolean foundIsPrivileged = false;
		for (Iterator iter = props.iterator(); iter.hasNext();) {
			Object o = iter.next();
			if ((o instanceof ChildPropertyDescriptor)) {
				ChildPropertyDescriptor element = (ChildPropertyDescriptor)o;
				String id = element.getId();
				if (id.equals("javadoc")) {
					foundJavadoc = true;
				} else if (id.equals("perClause")) {
					foundPerClause = true;
				}
			} else if ((o instanceof SimplePropertyDescriptor)
					&& ((SimplePropertyDescriptor)o).getId().equals("privileged")) {
				foundIsPrivileged = true;
			}
		}
		assertTrue("AspectDeclaration should have a javadoc PropertyDescriptor",foundJavadoc);
		assertTrue("AspectDeclaration should have a perClause PropertyDescriptor",foundPerClause);
		assertTrue("AspectDeclaration should have an isPrivileged PropertyDescriptor",foundIsPrivileged);
	}
================= fetch public UnresolvedType ensureTargetTypeIsCorrect(UnresolvedType tx) { 4934132^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
/* PR 72528
     * This method double checks the target type under certain conditions.  The Java 1.4
     * compilers seem to take calls to clone methods on array types and create bytecode that
     * looks like clone is being called on Object.  If we advise a clone call with around
     * advice we extract the call into a helper method which we can then refer to.  Because the
     * type in the bytecode for the call to clone is Object we create a helper method with
     * an Object parameter - this is not correct as we have lost the fact that the actual
     * type is an array type.  If we don't do the check below we will create code that fails
     * java verification.  This method checks for the peculiar set of conditions and if they
     * are true, it has a sneak peek at the code before the call to see what is on the stack.
     */
public UnresolvedType ensureTargetTypeIsCorrect(UnresolvedType tx) {
    	
    	
    	if (tx.equals(ResolvedType.OBJECT) && getKind() == MethodCall && 
    	    getSignature().getReturnType().equals(ResolvedType.OBJECT) && 
			getSignature().getArity()==0 && 
			getSignature().getName().charAt(0) == 'c' &&
			getSignature().getName().equals("clone")) {
    		
    		// Lets go back through the code from the start of the shadow
            InstructionHandle searchPtr = range.getStart().getPrev();
            while (Range.isRangeHandle(searchPtr) || 
            	   searchPtr.getInstruction() instanceof StoreInstruction) { // ignore this instruction - it doesnt give us the info we want
            	searchPtr = searchPtr.getPrev();  
            }
            
            // A load instruction may tell us the real type of what the clone() call is on
            if (searchPtr.getInstruction() instanceof LoadInstruction) {
            	LoadInstruction li = (LoadInstruction)searchPtr.getInstruction();
            	li.getIndex();
            	LocalVariableTag lvt = LazyMethodGen.getLocalVariableTag(searchPtr,li.getIndex());
            	return lvt.getType();
            }
            // A field access instruction may tell us the real type of what the clone() call is on
            if (searchPtr.getInstruction() instanceof FieldInstruction) {
            	FieldInstruction si = (FieldInstruction)searchPtr.getInstruction();
            	Type t = si.getFieldType(getEnclosingClass().getConstantPoolGen());
            	return BcelWorld.fromBcel(t);
            } 
            // A new array instruction obviously tells us it is an array type !
            if (searchPtr.getInstruction() instanceof ANEWARRAY) {
            	//ANEWARRAY ana = (ANEWARRAY)searchPoint.getInstruction();
            	//Type t = ana.getType(getEnclosingClass().getConstantPoolGen());
            	// Just use a standard java.lang.object array - that will work fine
            	return BcelWorld.fromBcel(new ArrayType(Type.OBJECT,1));
            }
            // A multi new array instruction obviously tells us it is an array type !
            if (searchPtr.getInstruction() instanceof MULTIANEWARRAY) {
            	MULTIANEWARRAY ana = (MULTIANEWARRAY)searchPtr.getInstruction();
                // Type t = ana.getType(getEnclosingClass().getConstantPoolGen());
            	// t = new ArrayType(t,ana.getDimensions());
            	// Just use a standard java.lang.object array - that will work fine
            	return BcelWorld.fromBcel(new ArrayType(Type.OBJECT,ana.getDimensions()));
            }
            throw new BCException("Can't determine real target of clone() when processing instruction "+
              searchPtr.getInstruction());
    	}
    	return tx;
    }
================= fetch public void endVisit(QualifiedNameReference ref, BlockScope scope) { 693945f^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java

public void endVisit(QualifiedNameReference ref, BlockScope scope) {
		if (ref.binding instanceof FieldBinding) {
			ref.binding = getAccessibleField((FieldBinding)ref.binding, ref.actualReceiverType);
		}
		if (ref.otherBindings != null && ref.otherBindings.length > 0) {
			TypeBinding receiverType;
			if (ref.binding instanceof FieldBinding) {
				receiverType = ((FieldBinding)ref.binding).type;
			} else if (ref.binding instanceof VariableBinding) {
				receiverType = ((VariableBinding)ref.binding).type;
			} else {
				//!!! understand and fix this case later
				receiverType = ref.otherBindings[0].declaringClass;
			}
			
			for (int i=0, len=ref.otherBindings.length; i < len; i++) {
				FieldBinding binding = ref.otherBindings[i];
				ref.otherBindings[i] = getAccessibleField(binding, receiverType);
				receiverType = binding.type;
			}
		}
	}
Progress : [#####################-------------------] 54%================= fetch private void initBcelWorld(IMessageHandler handler) throws IOException { 551b446^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/** init only on initial batch compile? no file-specific options */
private void initBcelWorld(IMessageHandler handler) throws IOException {
		List cp = buildConfig.getBootclasspath();
		cp.addAll(buildConfig.getClasspath());
		BcelWorld bcelWorld = new BcelWorld(cp, handler, null);
		bcelWorld.setBehaveInJava5Way(buildConfig.getBehaveInJava5Way());
		bcelWorld.setTargetAspectjRuntimeLevel(buildConfig.getTargetAspectjRuntimeLevel());
		bcelWorld.setOptionalJoinpoints(buildConfig.getXJoinpoints());
		bcelWorld.setXnoInline(buildConfig.isXnoInline());
		bcelWorld.setXlazyTjp(buildConfig.isXlazyTjp());
		bcelWorld.setXHasMemberSupportEnabled(buildConfig.isXHasMemberEnabled());
		bcelWorld.setPinpointMode(buildConfig.isXdevPinpoint());
		BcelWeaver bcelWeaver = new BcelWeaver(bcelWorld);
		state.setWorld(bcelWorld);
		state.setWeaver(bcelWeaver);
		state.binarySourceFiles = new HashMap();
		
		for (Iterator i = buildConfig.getAspectpath().iterator(); i.hasNext();) {
			File f = (File) i.next();
			bcelWeaver.addLibraryJarFile(f);
		}
		
//		String lintMode = buildConfig.getLintMode();
		
		if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
			bcelWorld.getLint().loadDefaultProperties();
		} else {
			bcelWorld.getLint().setAll(buildConfig.getLintMode());
		}
		
		if (buildConfig.getLintSpecFile() != null) {
			bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
		}
		
		//??? incremental issues
		for (Iterator i = buildConfig.getInJars().iterator(); i.hasNext(); ) {
			File inJar = (File)i.next();
			List unwovenClasses = bcelWeaver.addJarFile(inJar, buildConfig.getOutputDir(),false);
			state.binarySourceFiles.put(inJar.getPath(), unwovenClasses);
		}
		
		for (Iterator i = buildConfig.getInpath().iterator(); i.hasNext(); ) {
			File inPathElement = (File)i.next();
			if (!inPathElement.isDirectory()) {
				// its a jar file on the inpath
				// the weaver method can actually handle dirs, but we don't call it, see next block
				List unwovenClasses = bcelWeaver.addJarFile(inPathElement,buildConfig.getOutputDir(),true);
				state.binarySourceFiles.put(inPathElement.getPath(),unwovenClasses);
			} else {
				// add each class file in an in-dir individually, this gives us the best error reporting
				// (they are like 'source' files then), and enables a cleaner incremental treatment of
				// class file changes in indirs.
				File[] binSrcs = FileUtil.listFiles(inPathElement, binarySourceFilter);
				for (int j = 0; j < binSrcs.length; j++) {
					UnwovenClassFile ucf = 
						bcelWeaver.addClassFile(binSrcs[j], inPathElement, buildConfig.getOutputDir());
					List ucfl = new ArrayList();
					ucfl.add(ucf);
					state.binarySourceFiles.put(binSrcs[j].getPath(),ucfl);
				}
			}
		}
		
		bcelWeaver.setReweavableMode(buildConfig.isXNotReweavable());

		//check for org.aspectj.runtime.JoinPoint
		ResolvedType joinPoint = bcelWorld.resolve("org.aspectj.lang.JoinPoint");
		if (joinPoint.isMissing()) {
			IMessage message = 
				new Message("classpath error: unable to find org.aspectj.lang.JoinPoint (check that aspectjrt.jar is in your classpath)",
							null,
							true);
				handler.handleMessage(message);
		}
	}
================= fetch protected void setUp() throws Exception { 551b446^:tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java

protected void setUp() throws Exception {
		super.setUp();
		MyStateListener.reset();
		MyBuildProgressMonitor.reset();
		MyTaskListManager.reset();
		
		// Create a sandbox in which to work
		createEmptySandbox();
	}
================= fetch public Set getAspectPath() { 551b446^:tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java

public Set getAspectPath() {
			log("MyProjectProperties.getAspectPath()");
			return null;
		}
================= fetch public static ProjectPropertiesAdapter getInstance() { 551b446^:tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java

public static ProjectPropertiesAdapter getInstance() { 
			return _instance;
		}
================= fetch public static void configureNonStandardCompileOptions(String options) { 551b446^:tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java
// End of methods for configuring the build
protected File getWorkingDir() { return sandboxDir; }
================= fetch public void setClasspath(String path) { 551b446^:tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java

public void setClasspath(String path) {
			this.classPath = path;
		}
================= fetch public void testTheBasics() { 551b446^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
// Compile a single simple project
public void testTheBasics() {
		initialiseProject("P1");
		build("P1"); // This first build will be batch
		build("P1");
		checkWasntFullBuild();
		checkCompileWeaveCount(0,0);
	}
================= fetch private void setParameters(MethodDeclaration md, IProgramElement pe) { 7e40a60^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java
//	}
private void setParameters(MethodDeclaration md, IProgramElement pe) {
		Argument[] argArray = md.arguments;
		List names = new ArrayList();
		List types = new ArrayList();
		pe.setParameterNames(names);
		pe.setParameterTypes(types);
		
		if (argArray == null) return;
		for (int i = 0; i < argArray.length; i++) {
			String argName = new String(argArray[i].name);
			String argType = argArray[i].type.resolvedType.debugName();
			if (acceptArgument(argName, argType)) { 
				names.add(argName);
				types.add(argType);
			}   
		}
	}
================= fetch public String toLabelString() { 7e40a60^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public String toLabelString() {
		String label = toSignatureString();
		if (details != null) {
			label += ": " + details;
		} 
		return label;
	}
================= fetch public String toLinkLabelString() { 7e40a60^:asm/src/org/aspectj/asm/internal/ProgramElement.java
/**
	 * TODO: move the "parent != null"==>injar heuristic to more explicit 
	 */
public String toLinkLabelString() {
		String label;
		if (kind == Kind.CODE || kind == Kind.INITIALIZER) {
			label = parent.getParent().getName() + ": ";
		} else if (kind.isInterTypeMember()) {
			if (shortITDNames) {
				// if (name.indexOf('.')!=-1) return toLabelString().substring(name.indexOf('.')+1);
				label="";
			} else {
			  int dotIndex = name.indexOf('.');  
			  if (dotIndex != -1) {
				return parent.getName() + ": " + toLabelString().substring(dotIndex+1);
			  } else {
				label = parent.getName() + '.';	
			  }
			}
		} else if (kind == Kind.CLASS || kind == Kind.ASPECT || kind == Kind.INTERFACE) {
			label = "";
		} else if (kind.equals(Kind.DECLARE_PARENTS)) {
			label = "";
		} else { 
			if (parent != null) {
				label = parent.getName() + '.';
			} else { 
				label = "injar aspect: ";  
			}
		}
		label += toLabelString();
		return label;
	}
================= fetch public String toSignatureString() { 7e40a60^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public String toSignatureString() {
		StringBuffer sb = new StringBuffer();
		sb.append(name);
		
		if (parameterTypes != null ) {
			sb.append('('); 
			for (Iterator it = parameterTypes.iterator(); it.hasNext(); ) {
				sb.append((String)it.next());
				if (it.hasNext()) sb.append(", ");
			}
			sb.append(')');
		}
		
		return sb.toString();
	}
================= fetch public String toString() { 7e40a60^:asm/src/org/aspectj/asm/IProgramElement.java

public String toString() {
			return "ExtraInformation: ["+extraInfo+"]";
		}
================= fetch public void testMixingNumbersOfTypeParameters_pr125080_2() { 7e40a60^:tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java

public void testMixingNumbersOfTypeParameters_pr125080_2() { 
	  runTest("mixing numbers of type parameters - 2"); 
	  GenericsTests.verifyClassSignature(ajc,"AspectInterface","<T:Ljava/lang/Object;S:Ljava/lang/Number;>Ljava/lang/Object;");
	  GenericsTests.verifyClassSignature(ajc,"AbstractAspect","<T:Ljava/lang/Object;>Ljava/lang/Object;LAspectInterface<TT;Ljava/lang/Integer;>;");
	  GenericsTests.verifyClassSignature(ajc,"ConcreteAspect","LAbstractAspect<LStudent;>;");
  }
================= fetch public BcelObjectType addSourceObjectType(JavaClass jc) { efb20c5^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java

public BcelObjectType addSourceObjectType(JavaClass jc) {
		BcelObjectType ret = null;
		String signature = UnresolvedType.forName(jc.getClassName()).getSignature();
		
		Object fromTheMap = typeMap.get(signature);
		
		if (fromTheMap!=null && !(fromTheMap instanceof ReferenceType)) {
			// what on earth is it then? See pr 112243
			StringBuffer exceptionText = new StringBuffer();
			exceptionText.append("Found invalid (not a ReferenceType) entry in the type map. ");
			exceptionText.append("Signature=["+signature+"] Found=["+fromTheMap+"] Class=["+fromTheMap.getClass()+"]");
			throw new BCException(exceptionText.toString());
		}
		
		ReferenceType nameTypeX = (ReferenceType)fromTheMap;
        
        if (nameTypeX == null) {        	
		    if (jc.isGeneric() && isInJava5Mode()) {
		    	nameTypeX =  ReferenceType.fromTypeX(UnresolvedType.forRawTypeName(jc.getClassName()),this);
		        ret = makeBcelObjectType(nameTypeX, jc, true);
		    	ReferenceType genericRefType = new ReferenceType(
		    			UnresolvedType.forGenericTypeSignature(signature,ret.getDeclaredGenericSignature()),this);
				nameTypeX.setDelegate(ret);
		    	genericRefType.setDelegate(ret);
		    	nameTypeX.setGenericType(genericRefType);
		       	typeMap.put(signature, nameTypeX);
		    } else {
	        	nameTypeX = new ReferenceType(signature, this);
	            ret = makeBcelObjectType(nameTypeX, jc, true);
	           	typeMap.put(signature, nameTypeX);
		    }
        } else {
            ret = makeBcelObjectType(nameTypeX, jc, true);
        }
		return ret;
	}
================= fetch private MethodBinding getAccessibleMethod(MethodBinding binding, TypeBinding rec a4bd19d^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java

private MethodBinding getAccessibleMethod(MethodBinding binding, TypeBinding receiverType) {
		if (!binding.isValidBinding()) return binding;
		
		makePublic(receiverType);  //???
		if (isPublic(binding)) return binding;
		if (binding instanceof InterTypeMethodBinding) return binding;

		ResolvedMember m = null;
		if (binding.isPrivate() &&  binding.declaringClass != inAspect.binding) {
			// does this always mean that the aspect is an inner aspect of the bindings
			// declaring class?  After all, the field is private but we can see it from 
			// where we are.
			binding.modifiers = AstUtil.makePackageVisible(binding.modifiers);
			m = world.makeResolvedMember(binding);
		} else {
			// Sometimes receiverType and binding.declaringClass are *not* the same.
			
			// Sometimes receiverType is a subclass of binding.declaringClass.  In these situations
			// we want the generated inline accessor to call the method on the subclass (at
			// runtime this will be satisfied by the super).
			m = world.makeResolvedMember(binding, receiverType);
		}
		if (inAspect.accessForInline.containsKey(m)) return (MethodBinding)inAspect.accessForInline.get(m);
		MethodBinding ret = world.makeMethodBinding(
			AjcMemberMaker.inlineAccessMethodForMethod(inAspect.typeX, m));
		inAspect.accessForInline.put(m, ret);
		return ret;
	}
================= fetch public void testPr115251() { d916002^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java

public void testPr115251() {
		//AjdeInteractionTestbed.VERBOSE=true;
		initialiseProject("PR115251");
		build("PR115251");
		checkWasFullBuild();
		alter("PR115251","inc1");
		build("PR115251");
		checkWasntFullBuild();
	}
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { 28f8c69^:weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java

public void resolveBindings(IScope scope, Bindings bindings) {
		if (onTypeSymbolic != null) {
			onType = onTypeSymbolic.resolveExactType(scope, bindings);
			// in this case we've already signalled an error
			if (ResolvedType.isMissing(onType)) return;		
		}
		
		ResolvedType searchType;
		if (onType != null) {
			searchType = scope.getWorld().resolve(onType);
		} else {
			searchType = scope.getEnclosingType();
		}
		
		
		arguments.resolveBindings(scope, bindings, true, true);
		//XXX ensure that arguments has no ..'s in it
		
		// check that I refer to a real pointcut declaration and that I match
		
		ResolvedPointcutDefinition pointcutDef = searchType.findPointcut(name);
		// if we're not a static reference, then do a lookup of outers
		if (pointcutDef == null && onType == null) {
			while (true) {
				UnresolvedType declaringType = searchType.getDeclaringType();
				if (declaringType == null) break;
				searchType = declaringType.resolve(scope.getWorld());
				pointcutDef = searchType.findPointcut(name);
				if (pointcutDef != null) {
					// make this a static reference
					onType = searchType;
					break;
				}
			}
		}
		
		if (pointcutDef == null) {
			scope.message(IMessage.ERROR, this, "can't find referenced pointcut " + name);
			return;
		} 
		
		// check visibility
		if (!pointcutDef.isVisible(scope.getEnclosingType())) {
			scope.message(IMessage.ERROR, this, "pointcut declaration " + pointcutDef + " is not accessible");
			return;
		}
		
		if (Modifier.isAbstract(pointcutDef.getModifiers())) {
			if (onType != null) {
				scope.message(IMessage.ERROR, this, 
								"can't make static reference to abstract pointcut");
				return;
			} else if (!searchType.isAbstract()) {
				scope.message(IMessage.ERROR, this,
								"can't use abstract pointcut in concrete context");
				return;
			}
		}
		
		
		ResolvedType[] parameterTypes = 
			scope.getWorld().resolve(pointcutDef.getParameterTypes());
		
		if (parameterTypes.length != arguments.size()) {
			scope.message(IMessage.ERROR, this, "incompatible number of arguments to pointcut, expected " +
						parameterTypes.length + " found " + arguments.size());
			return;
		}
				
		//if (onType == null) onType = pointcutDef.getDeclaringType();
		if (onType != null) {
			if (onType.isParameterizedType()) {
				// build a type map mapping type variable names in the generic type to
				// the type parameters presented
				typeVariableMap = new HashMap();
				ResolvedType underlyingGenericType = ((ResolvedType) onType).getGenericType();
				TypeVariable[] tVars = underlyingGenericType.getTypeVariables();
				ResolvedType[] typeParams = ((ResolvedType)onType).getResolvedTypeParameters();
				for (int i = 0; i < tVars.length; i++) {
					typeVariableMap.put(tVars[i].getName(),typeParams[i]);
				}
			} else if (onType.isGenericType()) {
				scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_REFERENCE_POINTCUT_IN_RAW_TYPE),
						getSourceLocation()));
			}
		}
		
		for (int i=0,len=arguments.size(); i < len; i++) {
			TypePattern p = arguments.get(i);
			//we are allowed to bind to pointcuts which use subtypes as this is type safe
			if (typeVariableMap != null) {
				p = p.parameterizeWith(typeVariableMap);
			}
			if (p == TypePattern.NO) {
				scope.message(IMessage.ERROR, this,
								"bad parameter to pointcut reference");
				return;
			}
			if (!p.matchesSubtypes(parameterTypes[i]) && 
				!p.getExactType().equals(UnresolvedType.OBJECT))
			{
				scope.message(IMessage.ERROR, p, "incompatible type, expected " +
						parameterTypes[i].getName() + " found " + p +".  Check the type specified in your pointcut");
				return;
			}
		}

	}
Progress : [######################------------------] 55%================= fetch private boolean matchesTypeVariable(TypeVariableReferenceType matchType) { 01a8b2e^:weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java

private boolean matchesTypeVariable(TypeVariableReferenceType matchType) {
		return false;
	}
================= fetch protected boolean matchesSubtypes(ResolvedType type) { 01a8b2e^:weaver/src/org/aspectj/weaver/patterns/TypePattern.java
/**
	 * @see org.aspectj.weaver.patterns.TypePattern#matchesSubtypes(IType)
	 */
protected boolean matchesSubtypes(ResolvedType type) {
		return false;
	}
================= fetch public WeaverStateInfo getWeaverState() { 8676df9^:weaver/src/org/aspectj/weaver/ReferenceType.java
/**
	 * It is possible this type has multiple type variables but the interface we are about to parameterize
	 * only uses a subset - this method determines the subset to use by looking at the type variable names
	 * used.  For example:
	 * <code>
	 * class Foo<T extends String,E extends Number> implements SuperInterface<T> {}
	 * </code>
	 * where
	 * <code>
	 * interface SuperInterface<Z> {}
	 * </code>
     * In that example, a use of the 'Foo' raw type should know that it implements
     * the SuperInterface<String>.
	 */
private UnresolvedType[] determineThoseTypesToUse(ResolvedType parameterizedInterface,UnresolvedType[] paramTypes) {
	    // What are the type parameters for the supertype?
		UnresolvedType[] tParms = parameterizedInterface.getTypeParameters();
		UnresolvedType[] retVal = new UnresolvedType[tParms.length];
		
		// Go through the supertypes type parameters, if any of them is a type variable, use the
		// real type variable on the declaring type.
		
		// it is possibly overkill to look up the type variable - ideally the entry in the type parameter list for the
		// interface should be the a ref to the type variable in the current type ... but I'm not 100% confident right now.
		for (int i = 0; i < tParms.length; i++) {
			UnresolvedType tParm = tParms[i];
			if (tParm.isTypeVariableReference()) {
				TypeVariableReference tvrt = (TypeVariableReference)tParm;
				TypeVariable tv = tvrt.getTypeVariable();
				int rank = getRank(tv.getName());
				retVal[i]= paramTypes[rank];
			} else {
				retVal[i] = tParms[i];
			}
			
		}
		return retVal;
	}
================= fetch private String dumpthem(Map m) { 04067a6^:weaver/src/org/aspectj/weaver/World.java

private String dumpthem(Map m) {
	    	StringBuffer sb = new StringBuffer();
	    	Set keys = m.keySet();
	    	for (Iterator iter = keys.iterator(); iter.hasNext();) {
				String k = (String) iter.next();
				sb.append(k+"="+m.get(k)).append("\n");
			}
	    	return sb.toString();
	    }
================= fetch public ResolvedType get(String key) { 04067a6^:weaver/src/org/aspectj/weaver/World.java
/** Lookup a type by its signature */
public ResolvedType get(String key) {
			ResolvedType ret = (ResolvedType) tMap.get(key);
			if (ret == null) ret = (ResolvedType) expendableMap.get(key);
			return ret;
		}
================= fetch public ResolvedType put(String key, ResolvedType type) { 04067a6^:weaver/src/org/aspectj/weaver/World.java

public boolean isTargettingAspectJRuntime12() {
		boolean b = false; // pr116679
		if (!isInJava5Mode()) b=true;
		else b = getTargetAspectjRuntimeLevel().equals(org.aspectj.weaver.Constants.RUNTIME_LEVEL_12);
		//System.err.println("Asked if targetting runtime 1.2 , returning: "+b);
		return b;
	}
================= fetch public ResolvedType remove(String key) { 04067a6^:weaver/src/org/aspectj/weaver/World.java
/** Remove a type from the map */
public ResolvedType remove(String key) {
			ResolvedType ret = (ResolvedType) tMap.remove(key);
			if (ret == null) ret = (ResolvedType) expendableMap.remove(key);
			return ret;
		}
================= fetch public boolean isTargettingAspectJRuntime12() { 04067a6^:weaver/src/org/aspectj/weaver/World.java

public boolean isTargettingAspectJRuntime12() {
		boolean b = false; // pr116679
		if (!isInJava5Mode()) b=true;
		else b = getTargetAspectjRuntimeLevel().equals(org.aspectj.weaver.Constants.RUNTIME_LEVEL_12);
		//System.err.println("Asked if targetting runtime 1.2 , returning: "+b);
		return b;
	}
================= fetch public void tidyUp() { 04067a6^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java

public void tidyUp() {
	    // At end of compile, close any open files so deletion of those archives is possible
		classPath.closeArchives();
	}
================= fetch private void clearCaches() { ab2f89b^:weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java

private void clearCaches() {
		shadowMungers = null;
		typeMungers = null;
        lateTypeMungers = null;
		declareSofts = null;
		declareParents = null;
		declareDominates = null;
	}
================= fetch public void testPr113257() { ab2f89b^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
/**
	 * We have problems with multiple rewrites of a pointcut across incremental builds.
	 */
public void testPr113257() {
		initialiseProject("PR113257");
		build("PR113257");
		alter("PR113257","inc1");
		build("PR113257");
		checkWasntFullBuild();
		alter("PR113257","inc1");
		build("PR113257");
	}
================= fetch public static void clearState() { f4c8bf9^:ajdoc/src/org/aspectj/tools/ajdoc/Main.java

public static void clearState() {
        symbolManager = null;
        options = new Vector();
        ajcOptions = new Vector();
        filenames = new Vector();
        fileList= new Vector();
        packageList = new Vector();
        docModifier = "package";
        sourcepath = new Vector();
        verboseMode = false;
        packageMode = false;
        rootDir       = null;
        declIDTable   = new Hashtable();
        docDir          = ".";
    	aborted = false;
    	deleteTempFilesOnExit = true;
    }
================= fetch public static void main(String[] args) { f4c8bf9^:ajdoc/src/org/aspectj/tools/ajdoc/Main.java

public static void main(String[] args) {
    	clearState();
    	if (!JavadocRunner.has14ToolsAvailable()) {
    		System.err.println("ajdoc requires a JDK 1.4 or later tools jar - exiting");
    		aborted = true;
    		return;
    	}
    	  
        // STEP 1: parse the command line and do other global setup
        sourcepath.addElement("."); // add the current directory to the classapth
        parseCommandLine(args);  
        rootDir = getRootDir();
        symbolManager = SymbolManager.getDefault();
        File[] inputFiles      = new File[filenames.size()];
        File[] signatureFiles  = new File[filenames.size()];
        try {
            // create the workingdir if it doesn't exist
            if ( !(new File( outputWorkingDir ).isDirectory()) ) {
                File dir = new File( outputWorkingDir );
                dir.mkdir();
                if (deleteTempFilesOnExit) dir.deleteOnExit();
            }

            for (int i = 0; i < filenames.size(); i++) {
                inputFiles[i]     = new File((String)filenames.elementAt(i));
                //signatureFiles[i] = createSignatureFile(inputFiles[i]);
            }

            // PHASE 0: call ajc
            ajcOptions.addElement("-noExit");
			ajcOptions.addElement("-XjavadocsInModel");  	// TODO: wrong option to force model gen
            ajcOptions.addElement("-d"); 
            ajcOptions.addElement(rootDir.getAbsolutePath());
			String[] argsToCompiler = new String[ajcOptions.size() + inputFiles.length];
            int i = 0;
            for ( ; i < ajcOptions.size(); i++ ) {
                argsToCompiler[i] = (String)ajcOptions.elementAt(i);
            }
            for ( int j = 0; j < inputFiles.length; j++) {
                argsToCompiler[i] = inputFiles[j].getAbsolutePath();
                //System.out.println(">> file to ajc: " + inputFiles[j].getAbsolutePath());
                i++;
            }

//            System.out.println(Arrays.asList(argsToCompiler));
            System.out.println( "> Calling ajc..." );
            CompilerWrapper.main(argsToCompiler);
            if (CompilerWrapper.hasErrors()) {
            	System.out.println(FAIL_MESSAGE);
            	aborted = true;
            	return;
            }
/*
            for (int ii = 0; ii < inputFiles.length; ii++) {
                String tempFP = inputFiles[ii].getAbsolutePath();
                tempFP = tempFP.substring(0, tempFP.length()-4);
                tempFP += "ajsym";
                System.out.println( ">> checking: " + tempFP);
                File tempF = new File(tempFP);
                if ( !tempF.exists() ) System.out.println( ">>> doesn't exist!" );
            }
*/
            for (int ii = 0; ii < filenames.size(); ii++) {
                signatureFiles[ii] = createSignatureFile(inputFiles[ii]);
            }

            // PHASE 1: generate Signature files (Java with DeclIDs and no bodies).
            System.out.println( "> Building signature files..." );
			try{
            StubFileGenerator.doFiles(declIDTable, symbolManager, inputFiles, signatureFiles);
			} catch (DocException d){
				System.err.println(d.getMessage());
	           // d.printStackTrace();
				return;
			}

            // PHASE 2: let Javadoc generate HTML (with DeclIDs)
            System.out.println( "> Calling javadoc..." );
            String[] javadocargs = null;
            if ( packageMode ) {
                int numExtraArgs = 2;
                if (authorStandardDocletSwitch) numExtraArgs++;
                if (versionStandardDocletSwitch) numExtraArgs++;
                javadocargs = new String[numExtraArgs + options.size() + packageList.size() +
                                         fileList.size() ];
                javadocargs[0] = "-sourcepath";
                javadocargs[1] = outputWorkingDir;
                int argIndex = 2;
                if (authorStandardDocletSwitch) {
                    javadocargs[argIndex] = "-author";
                    argIndex++;
                }
                if (versionStandardDocletSwitch) {
                    javadocargs[argIndex] = "-version";
                }
                //javadocargs[1] = getSourcepathAsString();
                for (int k = 0; k < options.size(); k++) {
                    javadocargs[numExtraArgs+k] = (String)options.elementAt(k);
                }
                for (int k = 0; k < packageList.size(); k++) {
                    javadocargs[numExtraArgs+options.size() + k] = (String)packageList.elementAt(k);
                }
                for (int k = 0; k < fileList.size(); k++) {
                    javadocargs[numExtraArgs+options.size() + packageList.size() + k] = (String)fileList.elementAt(k);
                }
            }
            else {
                javadocargs = new String[options.size() + signatureFiles.length];
                for (int k = 0; k < options.size(); k++) {
                    javadocargs[k] = (String)options.elementAt(k);
                }
                for (int k = 0; k < signatureFiles.length; k++) {
                    javadocargs[options.size() + k] = StructureUtil.translateAjPathName(signatureFiles[k].getCanonicalPath());
                }
            }
         
            JavadocRunner.callJavadoc(javadocargs);
            //for ( int o = 0; o < inputFiles.length; o++ ) {
            //    System.out.println( "file: " + inputFiles[o] );
            //}

            // PHASE 3: add AspectDoc specific stuff to the HTML (and remove the DeclIDS).
            /** We start with the known HTML files (the ones that correspond directly to the
            * input files.)  As we go along, we may learn that Javadoc split one .java file
            * into multiple .html files to handle inner classes or local classes.  The html
            * file decorator picks that up.
            */
            System.out.println( "> Decorating html files..." );
            HtmlDecorator.decorateHTMLFromInputFiles(declIDTable,
                                              rootDir,
                                              symbolManager,
                                              inputFiles,
                                              docModifier); 
            
            System.out.println( "> Removing generated tags (this may take a while)..." );
            removeDeclIDsFromFile("index-all.html", true);
            removeDeclIDsFromFile("serialized-form.html", true);
            if (packageList.size() > 0) {
	            for (int p = 0; p < packageList.size(); p++) {
	                removeDeclIDsFromFile(((String)packageList.elementAt(p)).replace('.','/') +
	                                       Config.DIR_SEP_CHAR +
	                                       "package-summary.html", true);
	            }
            } else {
				File[] files = rootDir.listFiles();
				if (files == null){
					System.err.println("Destination directory is not a directory: " + rootDir.toString());
					return;
				}
            	files = FileUtil.listFiles(rootDir, new FileFilter() {
================= fetch static String addToFormal(String formalComment, String string) { f4c8bf9^:ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java
/**
     * We want to go:
     *   just before the first period
     *   just before the first @
     *   just before the end of the comment
     *
     * Adds a place holder for the period ('#') if one will need to be
     * replaced.
     */
static String addToFormal(String formalComment, String string) {
        boolean appendPeriod = true;
        if ( (formalComment == null) || formalComment.equals("")) {
            //formalComment = "/**\n * . \n */\n";
            formalComment = "/**\n * \n */\n";
            appendPeriod = false;
        }
        formalComment = formalComment.trim();

        int atsignPos = formalComment.indexOf('@');
        int    endPos = formalComment.indexOf("*/");
        int periodPos = formalComment.indexOf("/**")+2;
        int position  = 0;
        String periodPlaceHolder = "";
        if ( periodPos != -1 ) {
            position = periodPos+1;
        }
================= fetch static String generateHREFName(IProgramElement decl) { f4c8bf9^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java

static String generateHREFName(IProgramElement decl) {
        //String hrefLink = decl.toLabelString().replace("\"", "quot;"); // !!!
        StringBuffer hrefLinkBuffer = new StringBuffer();
        char[] declChars =  decl.toLabelString().toCharArray();
        for (int i = 0; i < declChars.length; i++) {
        	if (declChars[i] == '"') {
        		hrefLinkBuffer.append("quot;");
        	} else {
        		hrefLinkBuffer.append(declChars[i]);
        	}
		}
        return hrefLinkBuffer.toString();
    }
================= fetch static String generateIntroductionSignatures(IProgramElement decl, boolean isDet f4c8bf9^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java

static String generateIntroductionSignatures(IProgramElement decl, boolean isDetails) {
    	return "<not implemented>";
    	//        Declaration[] decls = decl.getDeclarations();
//        String entry = "";
//        for ( int j = 0; j < decls.length; j++ ) {
//            Declaration currDecl = decls[j];
//            if ( currDecl != null ) {
//                entry +=
//                        "<TT><B>" +
//                        currDecl.getSignature() +
//                        "</B></TT><BR>";
//            }
//            if (isDetails) {
//                entry += generateDetailsComment(currDecl) + "<P>";
//            }
//            else {
//                entry += generateSummaryComment(currDecl) + "<P>";
//            }
//        }
//        return entry;
    }
================= fetch static String getFormattedComment(IProgramElement decl) { f4c8bf9^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java
/**
     * This formats a comment according to the rules in the Java Langauge Spec:
     * <I>The text of a docuemntation comment consists of the characters between
     * the /** that begins the comment and the 'star-slash' that ends it.  The text is
     * devided into one or more lines.  On each of these lines, the leading *
     * characters are ignored; for lines other than the first, blanks and
     * tabs preceding the initial * characters are also discarded.</I>
     *
     * TODO: implement formatting or linking for tags.
     */
static String getFormattedComment(IProgramElement decl) {

        String comment = decl.getFormalComment();
        if (comment == null) return "";

        String formattedComment = "";
        // strip the comment markers
        
        int startIndex = comment.indexOf("/**");
        int endIndex   = comment.indexOf("*/");
        if ( startIndex == -1 ) {
            startIndex = 0;
        }
        else {
            startIndex += 3;
        }
        if ( endIndex == -1 ) {
            endIndex = comment.length();
        }
        comment = comment.substring( startIndex, endIndex );

        // string the leading whitespace and '*' characters at the beginning of each line
        BufferedReader reader
            = new BufferedReader( new StringReader( comment ) );
        try {
            for (String line = reader.readLine(); line != null; line = reader.readLine()) {
                line = line.trim();
                for (int i = 0; i < line.length(); i++ ) {
                    if ( line.charAt(0) == '*' ) {
                        line = line.substring(1, line.length());
                    }
                    else {
                        break;
                    }
                }
                // !!! remove any @see and @link tags from the line
                //int seeIndex  = line.indexOf("@see");
                //int linkIndex = line.indexOf("@link");
                //if ( seeIndex != -1 ) {
                //    line = line.substring(0, seeIndex) + line.substring(seeIndex);
                //}
                //if ( linkIndex != -1 ) {
                //    line = line.substring(0, linkIndex) + line.substring(linkIndex);
                //}
                formattedComment += line;
            }
        } catch ( IOException ioe ) {
            throw new Error( "Couldn't format comment for declaration: " +
                decl.getName() );
        }
        return formattedComment;
    }
================= fetch static void addAspectDocumentation(IProgramElement node, StringBuffer fileBuffer f4c8bf9^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java

void addAspectDocumentation(IProgramElement node, StringBuffer fileBuffer, int index ) {
    	List pointcuts = new ArrayList();
    	List advice = new ArrayList();
    	List declares = new ArrayList();
    	List methodsDeclaredOn = StructureUtil.getDeclareInterTypeTargets(node, IProgramElement.Kind.INTER_TYPE_METHOD);
    	if (methodsDeclaredOn != null && !methodsDeclaredOn.isEmpty()) {
 			insertDeclarationsSummary(fileBuffer,methodsDeclaredOn,ITD_METHOD_SUMMARY,index);
		}
    	List fieldsDeclaredOn = StructureUtil.getDeclareInterTypeTargets(node, IProgramElement.Kind.INTER_TYPE_FIELD);
    	if (fieldsDeclaredOn != null && !fieldsDeclaredOn.isEmpty()) {
 			insertDeclarationsSummary(fileBuffer,fieldsDeclaredOn,ITD_FIELD_SUMMARY,index);
		}
    	List constDeclaredOn = StructureUtil.getDeclareInterTypeTargets(node, IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR);
    	if (fieldsDeclaredOn != null && !constDeclaredOn.isEmpty()) {
 			insertDeclarationsSummary(fileBuffer,constDeclaredOn,ITD_CONSTRUCTOR_SUMMARY,index);
		}
    	for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
    		IProgramElement member = (IProgramElement)it.next();
    		if (member.getKind().equals(IProgramElement.Kind.POINTCUT)) {
    			pointcuts.add(member);
    		} else if (member.getKind().equals(IProgramElement.Kind.ADVICE)) {
    			advice.add(member);
    		} else if (member.getKind().isDeclare() || member.getKind().isInterTypeMember()) {
    			declares.add(member);
    		}
    	}
    	if (declares.size() > 0) {
    		insertDeclarationsDetails(fileBuffer, declares, DECLARE_DETAIL, index);
    		insertDeclarationsSummary(fileBuffer, declares, DECLARE_SUMMARY, index);
    	}
    	if (pointcuts.size() > 0) {
    		insertDeclarationsSummary(fileBuffer, pointcuts, POINTCUT_SUMMARY, index);
    		insertDeclarationsDetails(fileBuffer, pointcuts, POINTCUT_DETAIL, index);
    	}
    	if (advice.size() > 0) {
    		insertDeclarationsSummary(fileBuffer, advice, ADVICE_SUMMARY, index);
    		insertDeclarationsDetails(fileBuffer, advice, ADVICE_DETAIL, index);
    	}
    	// add the 'aspect declarations' information against the type
    	List parentsDeclaredOn = StructureUtil.getDeclareInterTypeTargets(node, IProgramElement.Kind.DECLARE_PARENTS);
    	if (parentsDeclaredOn != null && parentsDeclaredOn.size() > 0) {
			decorateDocWithRel(node,fileBuffer,index,parentsDeclaredOn,HtmlRelationshipKind.ASPECT_DECLARATIONS);
		}
    	// add the 'annotated by' information against the type
    	List annotatedBy = StructureUtil.getTargets(node,IRelationship.Kind.DECLARE_INTER_TYPE,"annotated by");
    	if (annotatedBy != null && annotatedBy.size() > 0) {
			decorateDocWithRel(node,fileBuffer,index,annotatedBy,HtmlRelationshipKind.ANNOTATED_BY);
		}
    	// add the 'advised by' information against the type
    	List advisedBy = StructureUtil.getTargets(node, IRelationship.Kind.ADVICE);
    	if (advisedBy != null && advisedBy.size() > 0) {
			decorateDocWithRel(node,fileBuffer,index,advisedBy,HtmlRelationshipKind.ADVISED_BY);
		} 	
    }
================= fetch static void decorateDocWithRel( f4c8bf9^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java

static void decorateDocWithRel(
    		IProgramElement node,
    		StringBuffer fileContentsBuffer,
    		int index,
    		List targets,
    		HtmlRelationshipKind relKind) {
        if (targets != null && !targets.isEmpty()) {            
            String adviceDoc = "<TABLE WIDTH=\"100%\" BGCOLOR=#FFFFFF><TR>" +
              "<TD width=\"15%\" bgcolor=\"#FFD8B0\"><B><FONT COLOR=000000>" +
              relKind.toString() +
              "</font></b></td><td>";

			String relativePackagePath =
				getRelativePathFromHere(
					node.getPackageName().replace('.', '/') + Config.DIR_SEP_CHAR);

            List addedNames = new ArrayList();
            for (Iterator it = targets.iterator(); it.hasNext(); ) {
            	Object o = it.next();
            	IProgramElement currDecl = null;
            	if (o instanceof String) {
                	String currHandle = (String)o;
                	currDecl = AsmManager.getDefault().getHierarchy().findElementForHandle(currHandle);					
				} else if (o instanceof IProgramElement){
					currDecl = (IProgramElement)o;
				} else {
					return;
				}
            	
        		String packagePath = "";
        		if (currDecl.getPackageName() != null && !currDecl.getPackageName().equals("")) {
        			packagePath = currDecl.getPackageName().replace('.', '/') + Config.DIR_SEP_CHAR;
        		}
            	
            	String hrefName = "";  
                String hrefLink = "";

				// Start the hRefLink with the relative path based on where
				// *this* type (i.e. the advised) is in the package structure.  
				hrefLink = relativePackagePath + packagePath;

                if (currDecl.getPackageName() != null ) {
                   hrefName = currDecl.getPackageName().replace('.', '/');
//                   hrefLink = "";//+ currDecl.getPackageName() + Config.DIR_SEP_CHAR;
                } 
                
                // in the case of nested classes, in order for the links to work,
                // need to have the correct file name which is something of the 
                // form parentClass.nestedAspect.html
                List names = new ArrayList();
                IProgramElement parent = currDecl;
                while (parent != null
                		&& parent.getParent() != null
                		&& (!parent.getParent().getKind().equals(IProgramElement.Kind.FILE_JAVA) 
                				&& !parent.getParent().getKind().equals(IProgramElement.Kind.FILE_ASPECTJ))) {
					parent = parent.getParent();
					names.add(parent.toLinkLabelString());
				}
                StringBuffer sbuff = new StringBuffer();
                for (int i = names.size() - 1; i >= 0; i--) {
					String element = (String)names.get(i);
					if (i == 0) {
						sbuff.append(element);
					} else {
						sbuff.append(element + ".");
					}
				}
                // use the currDecl.toLabelString rather than currDecl.getName()
                // because two distinct advice blocks can have the same 
                // currDecl.getName() and wouldn't both appear in the ajdoc
                hrefName += Config.DIR_SEP_CHAR +
                				sbuff.toString()
                				+ "." + currDecl.toLabelString();                
                  
                // need to replace " with quot; otherwise the links wont work
                // for 'matches declare' relationship
                StringBuffer sb = new StringBuffer(currDecl.toLabelString());
                int nextQuote = sb.toString().indexOf("\"");
                while (nextQuote != -1) {
					sb.deleteCharAt(nextQuote);
					sb.insert(nextQuote,"quot;");
					nextQuote = sb.toString().indexOf("\"");
				}
                hrefLink += sbuff.toString() + ".html" + "#" + sb.toString(); 

                if (!addedNames.contains(hrefName)) {
	                adviceDoc = adviceDoc +
	                        "<A HREF=\"" + hrefLink + "\"><tt>"
	                        + hrefName.replace('/', '.') + "</tt></A>";  
	                
	                if (it.hasNext()) adviceDoc += ", ";
	                addedNames.add(hrefName);
                }
            }
            adviceDoc += "</TR></TD></TABLE>\n";
            fileContentsBuffer.insert( index, adviceDoc );
        }
    }
================= fetch static void decorateHTMLFromDecls(Declaration[] decls, String base, String docMo f4c8bf9^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java

static void decorateHTMLFromDecls(Declaration[] decls, String base, String docModifier, boolean exceededNestingLevel) throws IOException {
    	if ( decls != null ) {
            for (int i = 0; i < decls.length; i++) {
                Declaration decl = decls[i];
                decorateHTMLFromDecl(decl, base, docModifier, exceededNestingLevel);
            }
        }
    }
================= fetch static void decorateHTMLFromInputFiles(Hashtable table, f4c8bf9^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java

static void decorateHTMLFromInputFiles(Hashtable table,
                                           File newRootDir,
                                           SymbolManager sm,
                                           File[] inputFiles,
                                           String docModifier ) throws IOException {
        rootDir = newRootDir;
        declIDTable = table;
        symbolManager = sm;
        docVisibilityModifier = docModifier;
        for (int i = 0; i < inputFiles.length; i++) {
            decorateHTMLFromDecls(symbolManager.getDeclarations(inputFiles[i].getCanonicalPath()),
                                  rootDir.getCanonicalPath() + Config.DIR_SEP_CHAR,
                                  docModifier,
                                  false);
        }
    }
================= fetch static void doFiles (Hashtable table, f4c8bf9^:ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java

static void doFiles (Hashtable table,
                        SymbolManager symbolManager,
                        File[] inputFiles,
                        File[] signatureFiles) throws DocException {
        declIDTable = table;
        for (int i = 0; i < inputFiles.length; i++) {
            processFile(symbolManager, inputFiles[i], signatureFiles[i]);
        }
    }
================= fetch private void unpackGenericSignature() { 3f77e75^:weaver/src/org/aspectj/weaver/bcel/BcelField.java

private void unpackGenericSignature() {
		if (unpackedGenericSignature)
			return;
		unpackedGenericSignature = true;
		String gSig = field.getGenericSignature();
		if (gSig != null) {
			// get from generic
			Signature.FieldTypeSignature fts = new GenericSignatureParser().parseAsFieldSignature(gSig);
			Signature.ClassSignature genericTypeSig = bcelObjectType.getGenericClassTypeSignature();

			Signature.FormalTypeParameter[] parentFormals = bcelObjectType.getAllFormals();
			Signature.FormalTypeParameter[] typeVars = 
				((genericTypeSig == null) ? new Signature.FormalTypeParameter[0] : genericTypeSig.formalTypeParameters);
			Signature.FormalTypeParameter[] formals = 
				new Signature.FormalTypeParameter[parentFormals.length + typeVars.length];
			// put method formal in front of type formals for overriding in
			// lookup
			System.arraycopy(typeVars, 0, formals, 0, typeVars.length);
			System.arraycopy(parentFormals, 0, formals, typeVars.length,parentFormals.length);

			try {
				genericFieldType = BcelGenericSignatureToTypeXConverter
						.fieldTypeSignature2TypeX(fts, formals, world);
			} catch (GenericSignatureFormatException e) {
				// development bug, fail fast with good info
				throw new IllegalStateException(
						"While determing the generic field type of "
								+ this.toString() + " with generic signature "
								+ gSig + " the following error was detected: "
								+ e.getMessage());
			}
		} else {
			genericFieldType = getReturnType();
		}
	}
================= fetch private void unpackGenericSignature() { 3f77e75^:weaver/src/org/aspectj/weaver/bcel/BcelMethod.java

private void unpackGenericSignature() {
		 if (unpackedGenericSignature) return;
		 unpackedGenericSignature = true;
		 String gSig = method.getGenericSignature();
		 if (gSig != null) {
			 Signature.MethodTypeSignature mSig = new GenericSignatureParser().parseAsMethodSignature(method.getGenericSignature());
 			 if (mSig.formalTypeParameters.length > 0) {
				// generic method declaration
				canBeParameterized = true;
			 }
 			 Signature.FormalTypeParameter[] parentFormals = bcelObjectType.getAllFormals();
 			 Signature.FormalTypeParameter[] formals = new
 			 	Signature.FormalTypeParameter[parentFormals.length + mSig.formalTypeParameters.length];
 			 // put method formal in front of type formals for overriding in lookup
 			 System.arraycopy(mSig.formalTypeParameters,0,formals,0,mSig.formalTypeParameters.length);
 			 System.arraycopy(parentFormals,0,formals,mSig.formalTypeParameters.length,parentFormals.length);
 			 Signature.TypeSignature returnTypeSignature = mSig.returnType;
			 try {
				genericReturnType = BcelGenericSignatureToTypeXConverter.typeSignature2TypeX(
						 returnTypeSignature, formals,
						 world);
			} catch (GenericSignatureFormatException e) {
//				 development bug, fail fast with good info
				throw new IllegalStateException(
						"While determing the generic return type of " + this.toString()
						+ " with generic signature " + gSig + " the following error was detected: "
						+ e.getMessage());
			}
			 Signature.TypeSignature[] paramTypeSigs = mSig.parameters;
			 genericParameterTypes = new UnresolvedType[paramTypeSigs.length];
			 for (int i = 0; i < paramTypeSigs.length; i++) {
				try {
					genericParameterTypes[i] = 
						BcelGenericSignatureToTypeXConverter.typeSignature2TypeX(
								paramTypeSigs[i],formals,world);
				} catch (GenericSignatureFormatException e) {
//					 development bug, fail fast with good info
					throw new IllegalStateException(
							"While determining the generic parameter types of " + this.toString()
							+ " with generic signature " + gSig + " the following error was detected: "
							+ e.getMessage());
				}
				if (paramTypeSigs[i] instanceof TypeVariableSignature) {
					canBeParameterized = true;
				}
			 }
		 } else {
			 genericReturnType = getReturnType();
			 genericParameterTypes = getParameterTypes();
		 }
	 }
================= fetch private void unpackGenericSignature() { 3f77e75^:weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java

public Signature.FormalTypeParameter[] getAllFormals() {
		unpackGenericSignature();
		if (formalsForResolution == null) {
			return new Signature.FormalTypeParameter[0];
		} else {
			return formalsForResolution;
		}
	}
================= fetch public void testCanBeParameterizedGenericMethod() { 3f77e75^:weaver/testsrc/org/aspectj/weaver/MemberTestCase15.java

public void testCanBeParameterizedGenericMethod() {
	    	BcelWorld world = new BcelWorld();
	    	ResolvedType javaLangClass = world.resolve(UnresolvedType.forName("java.lang.Class"));
	    	javaLangClass = javaLangClass.getGenericType();
	    	if (javaLangClass == null) return;  // for < 1.5
	    	ResolvedMember[] methods = javaLangClass.getDeclaredMethods();
	    	ResolvedMember asSubclass = null;
	    	for (int i = 0; i < methods.length; i++) {
				if (methods[i].getName().equals("asSubclass")) {
					asSubclass = methods[i];
					break;
				}
			}
	    	if (asSubclass != null) { // so can run on non-Java 5
//	    		System.out.println("got it");
	    		assertTrue(asSubclass.canBeParameterized());
	    	}    	
	    }
================= fetch public void testCanBeParameterizedMethodInGenericType() { 3f77e75^:weaver/testsrc/org/aspectj/weaver/MemberTestCase15.java

public void testCanBeParameterizedMethodInGenericType() {
	       	BcelWorld world = new BcelWorld();
	    	ResolvedType javaUtilList = world.resolve(UnresolvedType.forName("java.util.List"));
	    	javaUtilList = javaUtilList.getGenericType();
	    	if (javaUtilList == null) return;  // for < 1.5
	    	ResolvedMember[] methods = javaUtilList.getDeclaredMethods();
	    	ResolvedMember add = null;
	    	for (int i = 0; i < methods.length; i++) {
				if (methods[i].getName().equals("add")) {
					add = methods[i];
					break;
				}
			}
	    	if (add != null) { // so can run on non-Java 5
//	    		System.out.println("got it");
	    		assertTrue(add.canBeParameterized());
	    	}    	    	
	    }
Progress : [######################------------------] 56%================= fetch public UnresolvedType getReturnType() { a9ef1b0^:weaver/src/org/aspectj/weaver/Shadow.java

public UnresolvedType getReturnType() {
		if (kind == ConstructorCall) return getSignature().getDeclaringType();
		else if (kind == FieldSet) return ResolvedType.VOID;
		return getResolvedSignature().getGenericReturnType();
	}
================= fetch public static UnresolvedType createTypeFromSignature(String signature) { 24a785f^:weaver/src/org/aspectj/weaver/TypeFactory.java

private static UnresolvedType[] createTypeParams(String typeParameterSpecification) {
		String remainingToProcess = typeParameterSpecification;
		List types = new ArrayList();
		while(!remainingToProcess.equals("")) {
			int endOfSig = 0;
			int anglies = 0;
			boolean sigFound = false;
			for (endOfSig = 0; (endOfSig < remainingToProcess.length()) && !sigFound; endOfSig++) {
				char thisChar = remainingToProcess.charAt(endOfSig);
				switch(thisChar) {
				case '<' : anglies++; break;
				case '>' : anglies--; break;
				case ';' : 
					if (anglies == 0) {
						sigFound = true;
						break;
					}
				}
			}
			types.add(createTypeFromSignature(remainingToProcess.substring(0,endOfSig)));
			remainingToProcess = remainingToProcess.substring(endOfSig);
		}
		UnresolvedType[] typeParams = new UnresolvedType[types.size()];
		types.toArray(typeParams);
		return typeParams;
	}
================= fetch public static Test suite() { 53284da^:tests/src/org/aspectj/systemtest/AllTests15.java

public static Test suite() {
		TestSuite suite = new TestSuite("AspectJ System Test Suite - JDK 1.5");
		//$JUnit-BEGIN$
		suite.addTest(AllTests14.suite());
		suite.addTest(AllTestsAspectJ150.suite());
		suite.addTest(AtAjAnnotationGenTests.suite());
		//$JUnit-END$
		return suite;
	}
================= fetch public static Test suite() { 53284da^:tests/src/org/aspectj/systemtest/ajc150/AllTestsAspectJ150.java

public static Test suite() {
		TestSuite suite = new TestSuite("Java5/AspectJ5 tests");
		//$JUnit-BEGIN$
		suite.addTestSuite(MigrationTests.class);
		suite.addTest(Ajc150Tests.suite());
        suite.addTestSuite(SCCSFixTests.class);
		
		suite.addTest(AccBridgeMethods.suite());
		suite.addTestSuite(CovarianceTests.class);
		suite.addTestSuite(Enums.class);
		suite.addTest(AnnotationsBinaryWeaving.suite());
		suite.addTest(AnnotationPointcutsTests.suite());
		suite.addTestSuite(VarargsTests.class);
		suite.addTestSuite(StaticImports.class);
		suite.addTest(AnnotationRuntimeTests.suite());
		suite.addTestSuite(PerTypeWithinTests.class);
		
		suite.addTest(Autoboxing.suite());		
		suite.addTest(Annotations.suite());
		suite.addTest(AnnotationBinding.suite());
		suite.addTest(RuntimeAnnotations.suite());
		
		suite.addTest(SuppressedWarnings.suite());
		suite.addTest(DeclareAnnotationTests.suite());
		suite.addTest(GenericsTests.suite());
		suite.addTest(GenericITDsDesign.suite());
		suite.addTest(AtAjSyntaxTests.suite());
        suite.addTest(AtAjMisuseTests.suite());
        suite.addTest(AtAjLTWTests.suite());
        suite.addTest(HasMember.suite());

		suite.addTestSuite(LTWTests.class);
        //$JUnit-END$
		return suite;
	}
================= fetch public static UnresolvedType createTypeFromSignature(String signature) { 53284da^:weaver/src/org/aspectj/weaver/TypeFactory.java

private static UnresolvedType[] createTypeParams(String typeParameterSpecification) {
		String remainingToProcess = typeParameterSpecification;
		List types = new ArrayList();
		while(!remainingToProcess.equals("")) {
			int endOfSig = 0;
			int anglies = 0;
			boolean sigFound = false;
			for (endOfSig = 0; (endOfSig < remainingToProcess.length()) && !sigFound; endOfSig++) {
				char thisChar = remainingToProcess.charAt(endOfSig);
				switch(thisChar) {
				case '<' : anglies++; break;
				case '>' : anglies--; break;
				case ';' : 
					if (anglies == 0) {
						sigFound = true;
						break;
					}
				}
			}
			types.add(createTypeFromSignature(remainingToProcess.substring(0,endOfSig)));
			remainingToProcess = remainingToProcess.substring(endOfSig);
		}
		UnresolvedType[] typeParams = new UnresolvedType[types.size()];
		types.toArray(typeParams);
		return typeParams;
	}
================= fetch private static void processMembers(List/*IProgramElement*/ members, PrintWriter d69ce9a^:ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java

private static void processMembers(List/*IProgramElement*/ members, PrintWriter writer, boolean declaringTypeIsInterface) throws DocException {
    	for (Iterator it = members.iterator(); it.hasNext();) {
			IProgramElement member = (IProgramElement) it.next();
		
	    	if (member.getKind().isType()) { 
	    		if (!member.getParent().getKind().equals(IProgramElement.Kind.METHOD)
	    			 && !StructureUtil.isAnonymous(member)) {// don't print anonymous types
//	    			System.err.println(">>>>>>>>>>>>>" + member.getName() + "<<<<" + member.getParent());
	    			processTypeDeclaration(member, writer);
	    		}
			} else {
		    	String formalComment = addDeclID(member, member.getFormalComment());;
		    	writer.println(formalComment);
		    	
		    	String signature = ""; 
		    	if (!member.getKind().equals(IProgramElement.Kind.POINTCUT)
		    	    && !member.getKind().equals(IProgramElement.Kind.ADVICE)) {
					signature = member.getSourceSignature();//StructureUtil.genSignature(member);
					if (member.getKind().equals(IProgramElement.Kind.ENUM_VALUE)){
						if (((IProgramElement)members.get(members.indexOf(member)+1)).getKind().equals(IProgramElement.Kind.ENUM_VALUE)){
							// if the next member is also an ENUM_VALUE:
							signature = signature + ",";
						} else {
							signature = signature + ";";
						}
					}
                } 
		    	
		    	if (member.getKind().isDeclare()) {
//		    		System.err.println("> Skipping declare (ajdoc limitation): " + member.toLabelString());
		    	} else if (signature != null &&
		    		signature != "" && 
		    		!member.getKind().isInterTypeMember() &&
					!member.getKind().equals(IProgramElement.Kind.INITIALIZER) &&
					!StructureUtil.isAnonymous(member)) {   
		    		writer.print(signature);
		    	} else {
//		    		System.err.println(">> skipping: " + member.getKind());
		    	}  
		      
		    	if (member.getKind().equals(IProgramElement.Kind.METHOD) ||
		    		member.getKind().equals(IProgramElement.Kind.CONSTRUCTOR)) {
		    		if (member.getParent().getKind().equals(IProgramElement.Kind.INTERFACE) ||
		    			signature.indexOf("abstract ") != -1) {
		    			writer.println(";");
		    		} else {
		    			writer.println(" { }");
		    		}
		    		
		    	} else if (member.getKind().equals(IProgramElement.Kind.FIELD)) {
//		    		writer.println(";");
		    	}
			}
		}
    }
================= fetch public static Test suite() { d69ce9a^:ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java

public static Test suite() {
        TestSuite suite = new TestSuite(AjdocTests.class.getName());
        //$JUnit-BEGIN$
        suite.addTestSuite(DeclareFormsTest.class);
        suite.addTestSuite(SpacewarTestCase.class);
        suite.addTestSuite(PatternsTestCase.class);
        suite.addTestSuite(CoverageTestCase.class); 
        suite.addTestSuite(ITDTest.class);
        suite.addTestSuite(FullyQualifiedArgumentTest.class);
        suite.addTestSuite(ExecutionTestCase.class);// !!! must be last because it exists
        //$JUnit-END$
        return suite;
    }
================= fetch protected File getSpecFile() { a778ac4^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testDeclareAnnotationOnNonExistentType_pr99191_5() { runTest("declare annotation on non existent type - 5");}
================= fetch public InstructionList getAdviceArgSetup( a778ac4^:weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java

public InstructionList getAdviceArgSetup(
		BcelShadow shadow,
		BcelVar extraVar,
		InstructionList closureInstantiation) 
	{
        InstructionFactory fact = shadow.getFactory();
        BcelWorld world = shadow.getWorld();
        InstructionList il = new InstructionList();

//        if (targetAspectField != null) {
//        	il.append(fact.createFieldAccess(
//        		targetAspectField.getDeclaringType().getName(),
//        		targetAspectField.getName(),
//        		BcelWorld.makeBcelType(targetAspectField.getType()),
//        		Constants.GETSTATIC));
//        }
//        
		//System.err.println("BcelAdvice: " + exposedState);


		if (exposedState.getAspectInstance() != null) {
			il.append(BcelRenderer.renderExpr(fact, world, exposedState.getAspectInstance()));
		}
        final boolean isAnnotationStyleAspect = getConcreteAspect()!=null && getConcreteAspect().isAnnotationStyleAspect();
        boolean previousIsClosure = false;
        for (int i = 0, len = exposedState.size(); i < len; i++) {
        	if (exposedState.isErroneousVar(i)) continue; // Erroneous vars have already had error msgs reported!
            BcelVar v = (BcelVar) exposedState.get(i);

            if (v == null) {
                // if not @AJ aspect, go on with the regular binding handling
            	if (!isAnnotationStyleAspect) {
            		;
            	} else {
                    // ATAJ: for @AJ aspects, handle implicit binding of xxJoinPoint
	                //if (getKind() == AdviceKind.Around) {
                    //    previousIsClosure = true;
	                //    il.append(closureInstantiation);
                    if ("Lorg/aspectj/lang/ProceedingJoinPoint;".equals(getSignature().getParameterTypes()[i].getSignature())) {
                        //make sure we are in an around, since we deal with the closure, not the arg here
                        if (getKind() != AdviceKind.Around) {
                            previousIsClosure = false;
                            getConcreteAspect().getWorld().getMessageHandler().handleMessage(
                                    new Message(
                                            "use of ProceedingJoinPoint is allowed only on around advice ("
                                            + "arg " + i + " in " + toString() + ")",
                                            this.getSourceLocation(),
                                            true
                                    )
                            );
                            // try to avoid verify error and pass in null
                            il.append(InstructionConstants.ACONST_NULL);
                        } else {
                            if (previousIsClosure) {
                                il.append(InstructionConstants.DUP);
                            } else {
                                previousIsClosure = true;
                                il.append(closureInstantiation.copy());
                            }
                        }
	                } else if ("Lorg/aspectj/lang/JoinPoint$StaticPart;".equals(getSignature().getParameterTypes()[i].getSignature())) {
                        previousIsClosure = false;
	                    if ((getExtraParameterFlags() & ThisJoinPointStaticPart) != 0) {
	                        shadow.getThisJoinPointStaticPartBcelVar().appendLoad(il, fact);
	                    }
	                } else if ("Lorg/aspectj/lang/JoinPoint;".equals(getSignature().getParameterTypes()[i].getSignature())) {
                        previousIsClosure = false;
	                    if ((getExtraParameterFlags() & ThisJoinPoint) != 0) {
	                        il.append(shadow.loadThisJoinPoint());
	                    }
	                } else if ("Lorg/aspectj/lang/JoinPoint$EnclosingStaticPart;".equals(getSignature().getParameterTypes()[i].getSignature())) {
                        previousIsClosure = false;
	                    if ((getExtraParameterFlags() & ThisEnclosingJoinPointStaticPart) != 0) {
	                        shadow.getThisEnclosingJoinPointStaticPartBcelVar().appendLoad(il, fact);
	                    }
	                } else if (hasExtraParameter()) {
                        previousIsClosure = false;
                        //extra var can be null here (@Aj aspect extends abstract code style, advice in code style)
                        if (extraVar != null) {
                            extraVar.appendLoadAndConvert(
                                il,
                                fact,
                                getExtraParameterType().resolve(world));
                        }
                    } else {
                        previousIsClosure = false;
                        getConcreteAspect().getWorld().getMessageHandler().handleMessage(
                                new Message(
                                        "use of ProceedingJoinPoint is allowed only on around advice ("
                                        + "arg " + i + " in " + toString() + ")",
                                        this.getSourceLocation(),
                                        true
                                )
                        );
                        // try to avoid verify error and pass in null
                        il.append(InstructionConstants.ACONST_NULL);
	                }
            	}
            } else {
                UnresolvedType desiredTy = getBindingParameterTypes()[i];
                v.appendLoadAndConvert(il, fact, desiredTy.resolve(world));
            }
        }


        // ATAJ: for code style aspect, handles the extraFlag as usual ie not
        // in the middle of the formal bindings but at the end, in a rock solid ordering
        if (!isAnnotationStyleAspect) {
            if (getKind() == AdviceKind.Around) {
                il.append(closureInstantiation);
            } else if (hasExtraParameter()) {
                extraVar.appendLoadAndConvert(
                    il,
                    fact,
                    getExtraParameterType().resolve(world));
            }

            // handle thisJoinPoint parameters
            // these need to be in that same order as parameters in
            // org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration
            if ((getExtraParameterFlags() & ThisJoinPointStaticPart) != 0) {
                shadow.getThisJoinPointStaticPartBcelVar().appendLoad(il, fact);
            }

            if ((getExtraParameterFlags() & ThisJoinPoint) != 0) {
                il.append(shadow.loadThisJoinPoint());
            }

            if ((getExtraParameterFlags() & ThisEnclosingJoinPointStaticPart) != 0) {
                shadow.getThisEnclosingJoinPointStaticPartBcelVar().appendLoad(il, fact);
            }
        }


        return il;
    }
================= fetch public void testAbstractPerThisInAtAspectJ() { a778ac4^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testAbstractPerThisInAtAspectJ() {
	  runTest("abstract perthis in @AspectJ");
  }
================= fetch public void weaveAroundClosure(BcelAdvice munger, boolean hasDynamicTest) { a778ac4^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public void weaveAroundClosure(BcelAdvice munger, boolean hasDynamicTest) {
    	InstructionFactory fact = getFactory();

		enclosingMethod.setCanInline(false);

        // MOVE OUT ALL THE INSTRUCTIONS IN MY SHADOW INTO ANOTHER METHOD!
        LazyMethodGen callbackMethod = 
        	extractMethod(
        		NameMangler.aroundCallbackMethodName(
        			getSignature(),
        			getEnclosingClass()),
        		    0,
        		    munger);
        			    
    	BcelVar[] adviceVars = munger.getExposedStateAsBcelVars(true);
    	
    	String closureClassName = 
    		NameMangler.makeClosureClassName(
    			getEnclosingClass().getType(),
    			getEnclosingClass().getNewGeneratedNameTag());
    			
    	Member constructorSig = new MemberImpl(Member.CONSTRUCTOR, 
    								UnresolvedType.forName(closureClassName), 0, "<init>", 
    								"([Ljava/lang/Object;)V");
    	
    	BcelVar closureHolder = null;
    	
    	// This is not being used currently since getKind() == preinitializaiton
    	// cannot happen in around advice
    	if (getKind() == PreInitialization) {
    		closureHolder = genTempVar(AjcMemberMaker.AROUND_CLOSURE_TYPE);
    	}
    	
        InstructionList closureInstantiation =
            makeClosureInstantiation(constructorSig, closureHolder);

        /*LazyMethodGen constructor = */ 
            makeClosureClassAndReturnConstructor(
            	closureClassName,
                callbackMethod, 
                makeProceedArgumentMap(adviceVars)
                );

        InstructionList returnConversionCode;
		if (getKind() == PreInitialization) {
			returnConversionCode = new InstructionList();
			
			BcelVar stateTempVar = genTempVar(UnresolvedType.OBJECTARRAY);
			closureHolder.appendLoad(returnConversionCode, fact);
			
			returnConversionCode.append(
				Utility.createInvoke(
					fact, 
					world, 
					AjcMemberMaker.aroundClosurePreInitializationGetter()));
			stateTempVar.appendStore(returnConversionCode, fact);
			
			Type[] stateTypes = getSuperConstructorParameterTypes();
			
			returnConversionCode.append(InstructionConstants.ALOAD_0); // put "this" back on the stack
			for (int i = 0, len = stateTypes.length; i < len; i++) {
                UnresolvedType bcelTX = BcelWorld.fromBcel(stateTypes[i]);
                ResolvedType stateRTX = world.resolve(bcelTX,true);
                if (stateRTX.isMissing()) {
                		world.getLint().cantFindType.signal(
                				new String[] {WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE_PREINIT,bcelTX.getClassName())},
                				getSourceLocation(),
                				new ISourceLocation[]{ munger.getSourceLocation()}
                				);
//                    IMessage msg = new Message(
//                             WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE_PREINIT,bcelTX.getClassName()),
//                              "",IMessage.ERROR,getSourceLocation(),null,
//                              new ISourceLocation[]{ munger.getSourceLocation()});
//                    world.getMessageHandler().handleMessage(msg);
                }
				stateTempVar.appendConvertableArrayLoad(
					returnConversionCode, 
					fact, 
					i, 
					stateRTX);
			}
		} else {
	        returnConversionCode = 
	            Utility.createConversion(
	                getFactory(), 
	                BcelWorld.makeBcelType(munger.getSignature().getReturnType()), 
	                callbackMethod.getReturnType(),world.isInJava5Mode());
			if (!isFallsThrough()) {
				returnConversionCode.append(
					InstructionFactory.createReturn(callbackMethod.getReturnType()));
			}
		}

        // ATAJ for @AJ aspect we need to link the closure with the joinpoint instance
        if (munger.getConcreteAspect()!=null && munger.getConcreteAspect().isAnnotationStyleAspect()) {
            closureInstantiation.append(Utility.createInvoke(
                    getFactory(),
                    getWorld(),
                    new MemberImpl(
                            Member.METHOD,
                            UnresolvedType.forName("org.aspectj.runtime.internal.AroundClosure"),
                            Modifier.PUBLIC,
                            "linkClosureAndJoinPoint",
                            "()Lorg/aspectj/lang/ProceedingJoinPoint;"
                            )
            ));
        }

        InstructionList advice = new InstructionList();
        advice.append(munger.getAdviceArgSetup(this, null, closureInstantiation));

        // invoke the advice
        advice.append(munger.getNonTestAdviceInstructions(this));
        advice.append(returnConversionCode);
        
		if (!hasDynamicTest) {
			range.append(advice);
		} else {
			InstructionList callback = makeCallToCallback(callbackMethod);
			InstructionList postCallback = new InstructionList();
			if (terminatesWithReturn()) {
				callback.append(
					InstructionFactory.createReturn(callbackMethod.getReturnType()));
			} else {
				advice.append(
					InstructionFactory.createBranchInstruction(
						Constants.GOTO,
						postCallback.append(InstructionConstants.NOP)));
			}
			range.append(
				munger.getTestInstructions(
					this,
					advice.getStart(),
					callback.getStart(),
					advice.getStart()));
			range.append(advice);
			range.append(callback);
			range.append(postCallback);
		}
    }
================= fetch public void weaveAroundInline( a778ac4^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

void weaveAroundInline(
    	BcelAdvice munger,
    	boolean hasDynamicTest)
	{
		/* Implementation notes:
		 * 
		 * AroundInline still extracts the instructions of the original shadow into 
		 * an extracted method.  This allows inlining of even that advice that doesn't
		 * call proceed or calls proceed more than once. 
		 * 
		 * It extracts the instructions of the original shadow into a method.
		 * 
		 * Then it extracts the instructions of the advice into a new method defined on
		 * this enclosing class.  This new method can then be specialized as below.
		 * 
		 * Then it searches in the instructions of the advice for any call to the
		 * proceed method.
		 * 
		 *   At such a call, there is stuff on the stack representing the arguments to
		 *   proceed.  Pop these into the frame.
		 * 
		 *   Now build the stack for the call to the extracted method, taking values 
		 *   either from the join point state or from the new frame locs from proceed.
		 *   Now call the extracted method.  The right return value should be on the
		 *   stack, so no cast is necessary.
		 *
		 * If only one call to proceed is made, we can re-inline the original shadow.
		 * We are not doing that presently.
		 * 
		 * If the body of the advice can be determined to not alter the stack, or if
		 * this shadow doesn't care about the stack, i.e. method-execution, then the
		 * new method for the advice can also be re-lined.  We are not doing that
		 * presently.
		 */
		 
		// !!! THIS BLOCK OF CODE SHOULD BE IN A METHOD CALLED weaveAround(...);
        Member mungerSig = munger.getSignature();
        //Member originalSig = mungerSig; // If mungerSig is on a parameterized type, originalSig is the member on the generic type
        if (mungerSig instanceof ResolvedMember) {
        	ResolvedMember rm = (ResolvedMember)mungerSig;
        	if (rm.hasBackingGenericMember()) mungerSig = rm.getBackingGenericMember();
        }
        ResolvedType declaringType = world.resolve(mungerSig.getDeclaringType(),true);
        if (declaringType.isMissing()) {
        	world.getLint().cantFindType.signal(
        			new String[] {WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE,declaringType.getClassName())},
        			getSourceLocation(),
        			new ISourceLocation[]{ munger.getSourceLocation()}
        			);
//          IMessage msg = new Message(
//                WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE,declaringType.getClassName()),
//                "",IMessage.ERROR,getSourceLocation(),null,
//                new ISourceLocation[]{ munger.getSourceLocation()});
//          world.getMessageHandler().handleMessage(msg);
        }
        //??? might want some checks here to give better errors
        BcelObjectType ot = BcelWorld.getBcelObjectType((declaringType.isParameterizedType()?declaringType.getGenericType():declaringType)); 
        
		LazyMethodGen adviceMethod = ot.getLazyClassGen().getLazyMethodGen(mungerSig);
		if (!adviceMethod.getCanInline()) {
			weaveAroundClosure(munger, hasDynamicTest);
			return;
		}

        // specific test for @AJ proceedInInners
        if (munger.getConcreteAspect().isAnnotationStyleAspect()) {
            // if we can't find one proceed()
            // we suspect that the call is happening in an inner class
            // so we don't inline it.
            // Note: for code style, this is done at Aspect compilation time.
            boolean canSeeProceedPassedToOther = false;
            InstructionHandle curr = adviceMethod.getBody().getStart();
            InstructionHandle end = adviceMethod.getBody().getEnd();
            ConstantPoolGen cpg = adviceMethod.getEnclosingClass().getConstantPoolGen();
            while (curr != end) {
                InstructionHandle next = curr.getNext();
                Instruction inst = curr.getInstruction();
                if ((inst instanceof InvokeInstruction)
                    && ((InvokeInstruction)inst).getSignature(cpg).indexOf("Lorg/aspectj/lang/ProceedingJoinPoint;") > 0) {
                    // we may want to refine to exclude stuff returning jp ?
                    // does code style skip inline if i write dump(thisJoinPoint) ?
                    canSeeProceedPassedToOther = true;// we see one pjp passed around - dangerous
                    break;
                }
                curr = next;
            }
            if (canSeeProceedPassedToOther) {
                // remember this decision to avoid re-analysis
                adviceMethod.setCanInline(false);
                weaveAroundClosure(munger, hasDynamicTest);
                return;
            }
        }



		// We can't inline around methods if they have around advice on them, this
		// is because the weaving will extract the body and hence the proceed call.
		//??? should consider optimizations to recognize simple cases that don't require body extraction
		enclosingMethod.setCanInline(false);
		
		// start by exposing various useful things into the frame
		final InstructionFactory fact = getFactory();
		
		// now generate the aroundBody method
        LazyMethodGen extractedMethod = 
        	extractMethod(
        		NameMangler.aroundCallbackMethodName(
        			getSignature(),
        			getEnclosingClass()),
				Modifier.PRIVATE,
				munger
            );
        			
        			
        // now extract the advice into its own method
        String adviceMethodName =
			NameMangler.aroundCallbackMethodName(
							getSignature(),
							getEnclosingClass()) + "$advice";
        
		List argVarList = new ArrayList();
		List proceedVarList = new ArrayList();
		int extraParamOffset = 0;
		
		// Create the extra parameters that are needed for passing to proceed
		// This code is very similar to that found in makeCallToCallback and should
		// be rationalized in the future
		if (thisVar != null) {
			argVarList.add(thisVar);
			proceedVarList.add(new BcelVar(thisVar.getType(), extraParamOffset));
			extraParamOffset += thisVar.getType().getSize();
		}
		
		if (targetVar != null && targetVar != thisVar) {
			argVarList.add(targetVar);
			proceedVarList.add(new BcelVar(targetVar.getType(), extraParamOffset));
			extraParamOffset += targetVar.getType().getSize();
		}
		for (int i = 0, len = getArgCount(); i < len; i++) {
			argVarList.add(argVars[i]);
			proceedVarList.add(new BcelVar(argVars[i].getType(), extraParamOffset));
			extraParamOffset += argVars[i].getType().getSize();
		}
		if (thisJoinPointVar != null) {
			argVarList.add(thisJoinPointVar);
			proceedVarList.add(new BcelVar(thisJoinPointVar.getType(), extraParamOffset));
			extraParamOffset += thisJoinPointVar.getType().getSize();
		}
        
        Type[] adviceParameterTypes = adviceMethod.getArgumentTypes();
        Type[] extractedMethodParameterTypes = extractedMethod.getArgumentTypes();
		Type[] parameterTypes =
			new Type[extractedMethodParameterTypes.length
				+ adviceParameterTypes.length
				+ 1];
		int parameterIndex = 0;
		System.arraycopy(
			extractedMethodParameterTypes,
			0,
			parameterTypes,
			parameterIndex,
			extractedMethodParameterTypes.length);
		parameterIndex += extractedMethodParameterTypes.length;

		parameterTypes[parameterIndex++] =
			BcelWorld.makeBcelType(adviceMethod.getEnclosingClass().getType());
		System.arraycopy(
			adviceParameterTypes,
			0,
			parameterTypes,
			parameterIndex,
			adviceParameterTypes.length);

        LazyMethodGen localAdviceMethod =
					new LazyMethodGen(
						Modifier.PRIVATE | Modifier.FINAL | Modifier.STATIC, 
						BcelWorld.makeBcelType(mungerSig.getReturnType()), 
						adviceMethodName,
						parameterTypes,
						new String[0],
						getEnclosingClass());
 
		String donorFileName = adviceMethod.getEnclosingClass().getInternalFileName();
		String recipientFileName = getEnclosingClass().getInternalFileName();
//		System.err.println("donor " + donorFileName);
//		System.err.println("recip " + recipientFileName);
		if (! donorFileName.equals(recipientFileName)) {
			localAdviceMethod.fromFilename = donorFileName;
			getEnclosingClass().addInlinedSourceFileInfo(
				donorFileName,
				adviceMethod.highestLineNumber);
		}
    
		getEnclosingClass().addMethodGen(localAdviceMethod);
		
		// create a map that will move all slots in advice method forward by extraParamOffset
		// in order to make room for the new proceed-required arguments that are added at
		// the beginning of the parameter list
		int nVars = adviceMethod.getMaxLocals() + extraParamOffset;
		IntMap varMap = IntMap.idMap(nVars);
		for (int i=extraParamOffset; i < nVars; i++) {
			varMap.put(i-extraParamOffset, i);
		}

		localAdviceMethod.getBody().insert(
			BcelClassWeaver.genInlineInstructions(adviceMethod,
					localAdviceMethod, varMap, fact, true));


					
		localAdviceMethod.setMaxLocals(nVars);
					
		//System.err.println(localAdviceMethod);
		
    
    	// the shadow is now empty.  First, create a correct call
    	// to the around advice.  This includes both the call (which may involve 
    	// value conversion of the advice arguments) and the return
    	// (which may involve value conversion of the return value).  Right now
    	// we push a null for the unused closure.  It's sad, but there it is.
    	    	
    	InstructionList advice = new InstructionList();
        // InstructionHandle adviceMethodInvocation;
        {
			for (Iterator i = argVarList.iterator(); i.hasNext(); ) {
				BcelVar var = (BcelVar)i.next();
				var.appendLoad(advice, fact);
			}       	
        	// ??? we don't actually need to push NULL for the closure if we take care
			advice.append(
				munger.getAdviceArgSetup(
					this,
					null,
                    (munger.getConcreteAspect().isAnnotationStyleAspect())?
                        this.loadThisJoinPoint():
					    new InstructionList(InstructionConstants.ACONST_NULL)));
		    // adviceMethodInvocation =
		        advice.append(
		        	Utility.createInvoke(fact, localAdviceMethod)); //(fact, getWorld(), munger.getSignature()));
			advice.append(
		        Utility.createConversion(
		            getFactory(), 
		            BcelWorld.makeBcelType(mungerSig.getReturnType()), 
		            extractedMethod.getReturnType(),world.isInJava5Mode()));
		    if (! isFallsThrough()) {
		        advice.append(InstructionFactory.createReturn(extractedMethod.getReturnType()));
		    }
        }
        
		// now, situate the call inside the possible dynamic tests,
		// and actually add the whole mess to the shadow
        if (! hasDynamicTest) {
            range.append(advice);
        } else {
        	InstructionList afterThingie = new InstructionList(InstructionConstants.NOP);
            InstructionList callback = makeCallToCallback(extractedMethod);
			if (terminatesWithReturn()) {
				callback.append(
					InstructionFactory.createReturn(extractedMethod.getReturnType()));
			} else {
				//InstructionHandle endNop = range.insert(fact.NOP, Range.InsideAfter);
				advice.append(
					InstructionFactory.createBranchInstruction(
						Constants.GOTO,
						afterThingie.getStart()));
			}
			range.append(
				munger.getTestInstructions(
					this,
					advice.getStart(),
					callback.getStart(),
					advice.getStart()));
            range.append(advice);
            range.append(callback);
            range.append(afterThingie);          
        }        


        // now search through the advice, looking for a call to PROCEED.  
        // Then we replace the call to proceed with some argument setup, and a 
        // call to the extracted method.

        // inlining support for code style aspects
        if (!munger.getConcreteAspect().isAnnotationStyleAspect()) {
            String proceedName =
                NameMangler.proceedMethodName(munger.getSignature().getName());

            InstructionHandle curr = localAdviceMethod.getBody().getStart();
            InstructionHandle end = localAdviceMethod.getBody().getEnd();
            ConstantPoolGen cpg = localAdviceMethod.getEnclosingClass().getConstantPoolGen();
            while (curr != end) {
                InstructionHandle next = curr.getNext();
                Instruction inst = curr.getInstruction();
                if ((inst instanceof INVOKESTATIC)
                    && proceedName.equals(((INVOKESTATIC) inst).getMethodName(cpg))) {

                    localAdviceMethod.getBody().append(
                        curr,
                        getRedoneProceedCall(
                            fact,
                            extractedMethod,
                            munger,
                            localAdviceMethod,
                            proceedVarList));
                    Utility.deleteInstruction(curr, localAdviceMethod);
                }
                curr = next;
            }
            // and that's it.
        } else {
            //ATAJ inlining support for @AJ aspects
            // [TODO document @AJ code rule: don't manipulate 2 jps proceed at the same time.. in an advice body]
            InstructionHandle curr = localAdviceMethod.getBody().getStart();
            InstructionHandle end = localAdviceMethod.getBody().getEnd();
            ConstantPoolGen cpg = localAdviceMethod.getEnclosingClass().getConstantPoolGen();
            while (curr != end) {
                InstructionHandle next = curr.getNext();
                Instruction inst = curr.getInstruction();
                if ((inst instanceof INVOKEINTERFACE)
                    && "proceed".equals(((INVOKEINTERFACE) inst).getMethodName(cpg))) {
                    final boolean isProceedWithArgs;
                    if (((INVOKEINTERFACE) inst).getArgumentTypes(cpg).length == 1) {
                        // proceed with args as a boxed Object[]
                        isProceedWithArgs = true;
                    } else {
                        isProceedWithArgs = false;
                    }
                    InstructionList insteadProceedIl = getRedoneProceedCallForAnnotationStyle(
                            fact,
                            extractedMethod,
                            munger,
                            localAdviceMethod,
                            proceedVarList,
                            isProceedWithArgs
                    );
                    localAdviceMethod.getBody().append(curr, insteadProceedIl);
                    Utility.deleteInstruction(curr, localAdviceMethod);
                }
                curr = next;
            }
        }
	}
================= fetch private String method2(){ bbdd496^:ajdoc/testdata/pr119453/src/pack/C.java

private String method2(){
		return "";
	}
================= fetch private void setParameters(MethodDeclaration md, IProgramElement pe) { bbdd496^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java
//	}
private void setParameters(MethodDeclaration md, IProgramElement pe) {
		Argument[] argArray = md.arguments;
		List names = new ArrayList();
		List types = new ArrayList();
		pe.setParameterNames(names);
		pe.setParameterTypes(types);
		
		if (argArray == null) return;
		for (int i = 0; i < argArray.length; i++) {
			String argName = new String(argArray[i].name);
			String argType = argArray[i].type.toString();
			if (acceptArgument(argName, argType)) { 
				names.add(argName);
				types.add(argType);
			}   
		}
	}
================= fetch public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) { bbdd496^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java

public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {			
		IProgramElement peNode = null;
		// For intertype decls, use the modifiers from the original signature, not the generated method

		if (methodDeclaration instanceof InterTypeDeclaration) {
			InterTypeDeclaration itd = (InterTypeDeclaration) methodDeclaration;
			ResolvedMember sig = itd.getSignature();
			peNode = new ProgramElement(
						"",
						IProgramElement.Kind.ERROR,
						makeLocation(methodDeclaration),
						(sig!=null?sig.getModifiers():0),
						"",
						new ArrayList());  
		
		} else {
			peNode = new ProgramElement(
				"",
				IProgramElement.Kind.ERROR,
				makeLocation(methodDeclaration),
				methodDeclaration.modifiers, 
				"",
				new ArrayList());  
		}
		formatter.genLabelAndKind(methodDeclaration, peNode);
		genBytecodeInfo(methodDeclaration, peNode);
		List namedPointcuts = genNamedPointcuts(methodDeclaration);
		addUsesPointcutRelationsForNode(peNode, namedPointcuts, methodDeclaration);
		
		if (methodDeclaration.returnType!=null) {
			// if we don't make the distinction between ITD fields and other
			// methods, then we loose the type, for example int, for the field
			// and instead get "void".
			if (peNode.getKind().equals(IProgramElement.Kind.INTER_TYPE_FIELD)) {
				peNode.setCorrespondingType(methodDeclaration.returnType.toString());
			} else {
				peNode.setCorrespondingType(methodDeclaration.returnType.resolvedType.debugName());				
			}
		} else {
		  peNode.setCorrespondingType(null);	
		}
		peNode.setSourceSignature(genSourceSignature(methodDeclaration));
		peNode.setFormalComment(generateJavadocComment(methodDeclaration));
		
		// TODO: add return type test
		if (peNode.getKind().equals(IProgramElement.Kind.METHOD)) {
			if (peNode.toLabelString().equals("main(String[])")
				&& peNode.getModifiers().contains(IProgramElement.Modifiers.STATIC)
				&& peNode.getAccessibility().equals(IProgramElement.Accessibility.PUBLIC)) {
				((IProgramElement)stack.peek()).setRunnable(true);
			}	
		}
		
		stack.push(peNode);
		return true;
	}
================= fetch public static Test suite() { bbdd496^:ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java

public static Test suite() {
        TestSuite suite = new TestSuite(AjdocTests.class.getName());
        //$JUnit-BEGIN$
        suite.addTestSuite(DeclareFormsTest.class);
        suite.addTestSuite(SpacewarTestCase.class);
        suite.addTestSuite(PatternsTestCase.class);
        suite.addTestSuite(CoverageTestCase.class); 
        suite.addTestSuite(ITDTest.class);
        suite.addTestSuite(ExecutionTestCase.class);// !!! must be last because it exists
        //$JUnit-END$
        return suite;
    }
Progress : [######################------------------] 57%================= fetch protected void setUp() throws Exception { 9abfc40^:weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java
// todo: array of int	
protected void setUp() throws Exception {
		world = new ReflectionWorld();
		objectType = world.resolve("java.lang.Object");
	}
================= fetch public void testArrayTypes() { 9abfc40^:weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.java

public void testArrayTypes() {
		ReflectionWorld world = new ReflectionWorld();
		String[] strArray = new String[1];
		ResolvedType rt = world.resolve(strArray.getClass());
		assertTrue(rt.isArray());
	}
================= fetch public void testCompareSubclassDelegates() { 9abfc40^:weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java
// FIXME asc maybe.  The reflection list of methods returned doesn't include <clinit> (the static initializer) ... is that really a problem.
public void testCompareSubclassDelegates() {
    	
    	boolean barfIfClinitMissing = false;
        world.setBehaveInJava5Way(true);
        
        BcelWorld bcelWorld = new BcelWorld();
        bcelWorld.setBehaveInJava5Way(true);
        UnresolvedType javaUtilHashMap = UnresolvedType.forName("java.util.HashMap");
        ReferenceType rawType =(ReferenceType)bcelWorld.resolve(javaUtilHashMap );
        
        ReferenceType rawReflectType =(ReferenceType)world.resolve(javaUtilHashMap );
        ResolvedMember[] rms1 = rawType.getDelegate().getDeclaredMethods();
        ResolvedMember[] rms2 = rawReflectType.getDelegate().getDeclaredMethods();
        StringBuffer errors = new StringBuffer();
        Set one = new HashSet();
        for (int i = 0; i < rms1.length; i++) {
			one.add(rms1[i].toString());
		}
        Set two = new HashSet();
        for (int i = 0; i < rms2.length; i++) {
			two.add(rms2[i].toString());
		}
        for (int i = 0;i<rms2.length;i++) {
        	if (!one.contains(rms2[i].toString())) {
        		errors.append("Couldn't find "+rms2[i].toString()+" in the bcel set\n");
        	}
        }
        for (int i = 0;i<rms1.length;i++) {
        	if (!two.contains(rms1[i].toString())) {
        		if (!barfIfClinitMissing && rms1[i].getName().equals("<clinit>")) continue;
        		errors.append("Couldn't find "+rms1[i].toString()+" in the reflection set\n");
        	}
        }
        assertTrue("Errors:"+errors.toString(),errors.length()==0);
        
        if (barfIfClinitMissing) {
        	// the numbers must be exact
            assertEquals(rms1.length,rms2.length);        	
        } else {
        	// the numbers can be out by one in favour of bcel
        	assertTrue("Should be one extra (clinit) in BCEL case, but bcel="+rms1.length+" reflect="+rms2.length,rms1.length==rms2.length+1);
        }
    }
================= fetch public void testDelegateCreation() { 9abfc40^:weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.java

public void testDelegateCreation() {
		World world = new ReflectionWorld();
		ResolvedType rt = world.resolve("java.lang.Object");
		assertNotNull(rt);
		assertEquals("Ljava/lang/Object;",rt.getSignature());
	}
================= fetch public void testPrimitiveTypes() { 9abfc40^:weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.java

public void testPrimitiveTypes() {
		ReflectionWorld world = new ReflectionWorld();
		assertEquals("int",ResolvedType.INT,world.resolve(int.class));
		assertEquals("void",ResolvedType.VOID,world.resolve(void.class));
	}
================= fetch static WeavingAdaptor getWeaver(ClassLoader loader, IWeavingContext weavingConte 588e7b9^:loadtime/src/org/aspectj/weaver/loadtime/Aj.java
/**
     * Weave
     *
     * @param className
     * @param bytes
     * @param loader
     * @return weaved bytes
     */
public byte[] preProcess(String className, byte[] bytes, ClassLoader loader) {
        //TODO AV needs to doc that
        if (loader == null || className == null) {
            // skip boot loader or null classes (hibernate)
            return bytes;
        }

        try {
            WeavingAdaptor weavingAdaptor = WeaverContainer.getWeaver(loader, weavingContext);
            return weavingAdaptor.weaveClass(className, bytes);
        } catch (Throwable t) {
            //FIXME AV wondering if we should have the option to fail (throw runtime exception) here
            // would make sense at least in test f.e. see TestHelper.handleMessage()
            t.printStackTrace();
            return bytes;
        }
    }
================= fetch protected void suppressLintWarnings(World inWorld) { bdafe31^:weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java

protected void suppressLintWarnings(World inWorld) {
		if (suppressedLintKinds == null) {
    		if (signature instanceof BcelMethod) {
    			this.suppressedLintKinds = Utility.getSuppressedWarnings(signature.getAnnotations(), inWorld.getLint());
    		} else {
    			this.suppressedLintKinds = Collections.EMPTY_LIST;
    		}
    	}
    	inWorld.getLint().suppressKinds(suppressedLintKinds);
	}
================= fetch public ShadowMunger concretize(ResolvedType fromType, World world, PerClause cla bdafe31^:weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java
// ---- implementations of ShadowMunger's methods
public ShadowMunger concretize(ResolvedType fromType, World world, PerClause clause) {
		suppressLintWarnings(world);
		ShadowMunger ret = super.concretize(fromType, world, clause);
		clearLintSuppressions(world);
		return ret;
	}
================= fetch public boolean match(Shadow shadow, World world) { bdafe31^:weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java

public boolean match(Shadow shadow, World world) {
		suppressLintWarnings(world);
		boolean ret = super.match(shadow, world);
		clearLintSuppressions(world);
		return ret;
	}
================= fetch public void clearSuppressions() { bdafe31^:weaver/src/org/aspectj/weaver/Lint.java

private IMessage.Kind getMessageKind(String v) {
		if (v.equals("ignore")) return null;
		else if (v.equals("warning")) return IMessage.WARNING;
		else if (v.equals("error")) return IMessage.ERROR;
		
		MessageUtil.error(world.getMessageHandler(), 
				WeaverMessages.format(WeaverMessages.XLINT_VALUE_ERROR,v));
		return null;
	}
================= fetch public void specializeOn(Shadow shadow) { bdafe31^:weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java

public void specializeOn(Shadow shadow) {
	  	if (getKind() == AdviceKind.Around) {
	  		((BcelShadow)shadow).initializeForAroundClosure();
	  	}
    	
    	//XXX this case is just here for supporting lazy test code
    	if (getKind() == null) {
			exposedState = new ExposedState(0);
    		return;
    	}
    	if (getKind().isPerEntry()) {
    		exposedState = new ExposedState(0);
    	} else if (getKind().isCflow()) {
    		exposedState = new ExposedState(nFreeVars);
    	} else if (getSignature() != null) {
			exposedState = new ExposedState(getSignature());
    	} else {
    		exposedState = new ExposedState(0);
    		return;  //XXX this case is just here for supporting lazy test code
    	}
    	
    	World world = shadow.getIWorld();
    	suppressLintWarnings(world);
		pointcutTest = getPointcut().findResidue(shadow, exposedState);
		clearLintSuppressions(world);
		
		// these initializations won't be performed by findResidue, but need to be
		// so that the joinpoint is primed for weaving
		if (getKind() == AdviceKind.PerThisEntry) {
			shadow.getThisVar();
		} else if (getKind() == AdviceKind.PerTargetEntry) {
			shadow.getTargetVar();
		}
		
		
        // make sure thisJoinPoint parameters are initialized
        if ((getExtraParameterFlags() & ThisJoinPointStaticPart) != 0) {
        	((BcelShadow)shadow).getThisJoinPointStaticPartVar();
			((BcelShadow)shadow).getEnclosingClass().warnOnAddedStaticInitializer(shadow,getSourceLocation());
        }

        if ((getExtraParameterFlags() & ThisJoinPoint) != 0) {
    		boolean hasGuardTest = pointcutTest != Literal.TRUE && getKind() != AdviceKind.Around;
    		boolean isAround = getKind() == AdviceKind.Around;
			((BcelShadow)shadow).requireThisJoinPoint(hasGuardTest,isAround);
			((BcelShadow)shadow).getEnclosingClass().warnOnAddedStaticInitializer(shadow,getSourceLocation());
			if (!hasGuardTest && world.getLint().multipleAdviceStoppingLazyTjp.isEnabled()) {
				// collect up the problematic advice
				((BcelShadow)shadow).addAdvicePreventingLazyTjp(this);
			}
			if (!isAround && !hasGuardTest && world.getLint().noGuardForLazyTjp.isEnabled()) {
				// can't build tjp lazily, no suitable test...
				world.getLint().noGuardForLazyTjp.signal(
					    new String[] {shadow.toString()},
					    getSourceLocation(),
					    new ISourceLocation[] { ((BcelShadow)shadow).getSourceLocation() }
					);				
			}
        }
        
        if ((getExtraParameterFlags() & ThisEnclosingJoinPointStaticPart) != 0) {
        	((BcelShadow)shadow).getThisEnclosingJoinPointStaticPartVar();
			((BcelShadow)shadow).getEnclosingClass().warnOnAddedStaticInitializer(shadow,getSourceLocation());
        }
    }
================= fetch public void suppressKinds(Collection lintKind) { bdafe31^:weaver/src/org/aspectj/weaver/Lint.java
// temporarily suppress the given lint messages
public void suppressKinds(Collection lintKind) {
		for (Iterator iter = lintKind.iterator(); iter.hasNext();) {
			Kind k = (Kind) iter.next();
			k.setSuppressed(true);
		}
	}
================= fetch private void createMessageHandler() { 9d32b76^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java

private void createMessageHandler() {
		messageHandler = new WeavingAdaptorMessageHandler(new PrintWriter(System.err));
		if (verbose) messageHandler.dontIgnore(IMessage.INFO);
		if (Boolean.getBoolean(SHOW_WEAVE_INFO_PROPERTY)) messageHandler.dontIgnore(IMessage.WEAVEINFO);
	}
================= fetch protected File getSpecFile() { ae500c6^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testDeclareAnnotationOnNonExistentType_pr99191_5() { runTest("declare annotation on non existent type - 5");}
================= fetch public UnresolvedType parameterize(Map typeBindings) { 3ac4627^:weaver/src/org/aspectj/weaver/UnresolvedType.java
/**
     * Return a version of this parameterized type in which any type parameters
     * that are type variable references are replaced by their matching type variable
     * binding.
     */
public UnresolvedType parameterize(Map typeBindings) {
    	throw new UnsupportedOperationException("resolve this type first");
    }
Progress : [#######################-----------------] 58%================= fetch protected boolean accept(String className, byte[] bytes) { 9edb4b6^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java

protected boolean accept(String className, byte[] bytes) {
        // avoid ResolvedType if not needed
        if (m_excludeTypePattern.isEmpty() && m_includeTypePattern.isEmpty()) {
            return true;
        }

        // still try to avoid ResolvedType if we have simple patterns
        String fastClassName = className.replace('/', '.').replace('$', '.');
        for (int i = 0; i < m_excludeStartsWith.size(); i++) {
            if (fastClassName.startsWith((String)m_excludeStartsWith.get(i))) {
                return false;
            }
        }
        boolean fastAccept = false;//defaults to false if no fast include
        for (int i = 0; i < m_includeStartsWith.size(); i++) {
            fastAccept = fastClassName.startsWith((String)m_includeStartsWith.get(i));
            if (fastAccept) {
                break;
            }
        }
        if (fastAccept) {
            return true;
        }

        // needs further analysis
        // TODO AV - needs refactoring
        // during LTW this calling resolve at that stage is BAD as we do have the bytecode from the classloader hook
        // but still go thru resolve that will do a getResourcesAsStream on disk
        // this is also problematic for jit stub which are not on disk - as often underlying infra
        // does returns null or some other info for getResourceAsStream (f.e. WLS 9 CR248491)
        // Instead I parse the given bytecode. But this also means it will be parsed again in
        // new WeavingClassFileProvider() from WeavingAdaptor.getWovenBytes()...
        BcelObjectType bct = ((BcelWorld)weaver.getWorld()).addSourceObjectType(Utility.makeJavaClass(null, bytes));
        ResolvedType classInfo = bct.getResolvedTypeX();//BAD: weaver.getWorld().resolve(UnresolvedType.forName(className), true);

        //exclude are "AND"ed
        for (Iterator iterator = m_excludeTypePattern.iterator(); iterator.hasNext();) {
            TypePattern typePattern = (TypePattern) iterator.next();
            if (typePattern.matchesStatically(classInfo)) {
                // exclude match - skip
                return false;
            }
        }
        //include are "OR"ed
        boolean accept = true;//defaults to true if no include
        for (Iterator iterator = m_includeTypePattern.iterator(); iterator.hasNext();) {
            TypePattern typePattern = (TypePattern) iterator.next();
            accept = typePattern.matchesStatically(classInfo);
            if (accept) {
                break;
            }
            // goes on if this include did not match ("OR"ed)
        }
        return accept;
    }
================= fetch public void testLTWDumpBeforeAndAfter() { 9edb4b6^:tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java

public void testLTWDumpBeforeAndAfter() {
        runTest("LTW DumpTest before and after");

        File f = new File("_ajdump/_before/ataspectj/Test$$EnhancerByCGLIB$$12345.class");
        assertTrue(f.exists());
        f = new File("_ajdump/ataspectj/Test$$EnhancerByCGLIB$$12345.class");
        assertTrue(f.exists());
        
        // tidy up...
        f = new File("_ajdump");
        FileUtil.deleteContents(f);
        f.delete();
    }
================= fetch public void testLTWDumpProxy() { 9edb4b6^:tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java

public void testLTWDumpProxy() {
        runTest("LTW DumpTest proxy");

        // The working directory is different because this test must be forked
        File dir = new File("../tests/java5/ataspectj");
        File f = new File(dir,"_ajdump/_before");
        System.out.println("AtAjLTWTests.testLTWDumpProxy() f=" + f.getAbsolutePath());
        CountingFilenameFilter cff = new CountingFilenameFilter();
        f.listFiles(cff);
        assertEquals("Expected dump file in " + f.getAbsolutePath(),1,cff.getCount());
        f = new File(dir,"_ajdump");
        System.out.println("AtAjLTWTests.testLTWDumpProxy() f=" + f.getAbsolutePath());
        cff = new CountingFilenameFilter();
        f.listFiles(cff);
        assertEquals(1,cff.getCount());
        
        // tidy up...
        f = new File(dir,"_ajdump");
        FileUtil.deleteContents(f);
        f.delete();
    }
================= fetch private InstructionList getRedoneProceedCall( 979124d^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

private InstructionList getRedoneProceedCall(
		InstructionFactory fact,
		LazyMethodGen callbackMethod,
		BcelAdvice munger,
		LazyMethodGen localAdviceMethod,
		List argVarList) 
	{
		InstructionList ret = new InstructionList();
		// we have on stack all the arguments for the ADVICE call.
		// we have in frame somewhere all the arguments for the non-advice call.
		
		BcelVar[] adviceVars = munger.getExposedStateAsBcelVars();		
		IntMap proceedMap =  makeProceedArgumentMap(adviceVars);

//		System.out.println(proceedMap + " for " + this);
//		System.out.println(argVarList);
		
		ResolvedType[] proceedParamTypes =
			world.resolve(munger.getSignature().getParameterTypes());
		// remove this*JoinPoint* as arguments to proceed
		if (munger.getBaseParameterCount()+1 < proceedParamTypes.length) {
			int len = munger.getBaseParameterCount()+1;
			ResolvedType[] newTypes = new ResolvedType[len];
			System.arraycopy(proceedParamTypes, 0, newTypes, 0, len);
			proceedParamTypes = newTypes;
		}

		//System.out.println("stateTypes: " + Arrays.asList(stateTypes));
		BcelVar[] proceedVars =
			Utility.pushAndReturnArrayOfVars(proceedParamTypes, ret, fact, localAdviceMethod);

		Type[] stateTypes = callbackMethod.getArgumentTypes();
//		System.out.println("stateTypes: " + Arrays.asList(stateTypes));
		
		for (int i=0, len=stateTypes.length; i < len; i++) {
            Type stateType = stateTypes[i];
            ResolvedType stateTypeX = BcelWorld.fromBcel(stateType).resolve(world);
            if (proceedMap.hasKey(i)) {
            	//throw new RuntimeException("unimplemented");
				proceedVars[proceedMap.get(i)].appendLoadAndConvert(ret, fact, stateTypeX);
            } else {
				((BcelVar) argVarList.get(i)).appendLoad(ret, fact);
            }
		}
				
		ret.append(Utility.createInvoke(fact, callbackMethod));
		ret.append(Utility.createConversion(fact, callbackMethod.getReturnType(), 
				BcelWorld.makeBcelType(munger.getSignature().getReturnType())));
		return ret;
	}
================= fetch public InstructionList getAdviceInstructions( 979124d^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public void weaveCflowEntry(final BcelAdvice munger, final Member cflowField) {
		final boolean isPer = munger.getKind() == AdviceKind.PerCflowBelowEntry || 
								munger.getKind() == AdviceKind.PerCflowEntry;
		
		final Type objectArrayType = new ArrayType(Type.OBJECT, 1);
        final InstructionFactory fact = getFactory();        

		final BcelVar testResult = genTempVar(ResolvedType.BOOLEAN);

		InstructionList entryInstructions = new InstructionList();
		{
			InstructionList entrySuccessInstructions = new InstructionList();
			
			if (munger.hasDynamicTests()) {
				entryInstructions.append(Utility.createConstant(fact, 0));
				testResult.appendStore(entryInstructions, fact);
			
				entrySuccessInstructions.append(Utility.createConstant(fact, 1));
				testResult.appendStore(entrySuccessInstructions, fact);
			}

			if (isPer) {
	      		entrySuccessInstructions.append(
	      			fact.createInvoke(munger.getConcreteAspect().getName(), 
	      						NameMangler.PERCFLOW_PUSH_METHOD, 
	      						Type.VOID, 
	      						new Type[] { }, 
	      						Constants.INVOKESTATIC));
			} else {
				BcelVar[] cflowStateVars = munger.getExposedStateAsBcelVars();
	
				if (cflowStateVars.length == 0) {
					// This should be getting managed by a counter - lets make sure.
					if (!cflowField.getType().getName().endsWith("CFlowCounter")) 
						throw new RuntimeException("Incorrectly attempting counter operation on stacked cflow");
					entrySuccessInstructions.append(
			      			Utility.createGet(fact, cflowField));
					//arrayVar.appendLoad(entrySuccessInstructions, fact);
					entrySuccessInstructions.append(fact.createInvoke(NameMangler.CFLOW_COUNTER_TYPE,"inc",Type.VOID,new Type[] { },Constants.INVOKEVIRTUAL));
				} else {
				    BcelVar arrayVar = genTempVar(UnresolvedType.OBJECTARRAY);
	
				    int alen = cflowStateVars.length;
				    entrySuccessInstructions.append(Utility.createConstant(fact, alen));
				    entrySuccessInstructions.append(
				    		(Instruction) fact.createNewArray(Type.OBJECT, (short) 1));
				    arrayVar.appendStore(entrySuccessInstructions, fact);
		 
				    for (int i = 0; i < alen; i++) {
				    	arrayVar.appendConvertableArrayStore(
				    			entrySuccessInstructions,
								fact,
								i,
								cflowStateVars[i]);
				    }		
	
				    entrySuccessInstructions.append(
				    		Utility.createGet(fact, cflowField));
				    arrayVar.appendLoad(entrySuccessInstructions, fact);

				    entrySuccessInstructions.append(
				    		fact.createInvoke(NameMangler.CFLOW_STACK_TYPE, "push", Type.VOID, 
	      						new Type[] { objectArrayType }, 
	      					Constants.INVOKEVIRTUAL));
				}
			}

			
			InstructionList testInstructions = 
				munger.getTestInstructions(this, entrySuccessInstructions.getStart(), 
									range.getRealStart(), 
									entrySuccessInstructions.getStart());
			entryInstructions.append(testInstructions);
			entryInstructions.append(entrySuccessInstructions);
		}
		
		// this is the same for both per and non-per
		weaveAfter(new BcelAdvice(null, null, null, 0, 0, 0, null, null) {
			public InstructionList getAdviceInstructions(
				BcelShadow s,
				BcelVar extraArgVar,
				InstructionHandle ifNoAdvice) {
				InstructionList exitInstructions = new InstructionList();
				if (munger.hasDynamicTests()) {
					testResult.appendLoad(exitInstructions, fact);
					exitInstructions.append(
						InstructionFactory.createBranchInstruction(
							Constants.IFEQ,
							ifNoAdvice));
				}
				exitInstructions.append(Utility.createGet(fact, cflowField));
				if (munger.getKind() != AdviceKind.PerCflowEntry &&
					munger.getKind() != AdviceKind.PerCflowBelowEntry &&
					munger.getExposedStateAsBcelVars().length==0) {
					exitInstructions
					.append(
						fact
						.createInvoke(
							NameMangler.CFLOW_COUNTER_TYPE,
							"dec",
							Type.VOID,
							new Type[] {
				}, Constants.INVOKEVIRTUAL));
				} else {
				exitInstructions
					.append(
						fact
						.createInvoke(
							NameMangler.CFLOW_STACK_TYPE,
							"pop",
							Type.VOID,
							new Type[] {
				}, Constants.INVOKEVIRTUAL));
				}
				return exitInstructions;
			}
		});
		
		
		range.insert(entryInstructions, Range.InsideBefore);
	}
================= fetch public int compareTo(Object other) { 979124d^:weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java

public BcelVar[] getExposedStateAsBcelVars() {
        // ATAJ aspect
        // the closure instantiation has the same mapping as the extracted method from wich it is called
        if (getConcreteAspect()!= null && getConcreteAspect().isAnnotationStyleAspect()) {
            return BcelVar.NONE;
        }

		//System.out.println("vars: " + Arrays.asList(exposedState.vars));
		if (exposedState == null) return BcelVar.NONE;
		int len = exposedState.vars.length;
		BcelVar[] ret = new BcelVar[len];
		for (int i=0; i < len; i++) {
			ret[i] = (BcelVar)exposedState.vars[i];
		}
		return ret; //(BcelVar[]) exposedState.vars;
	}
================= fetch public void testAppContainer() { 979124d^:tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java

public void testAppContainer() {
        runTest("AppContainer");
    }
================= fetch public void weaveAroundClosure(BcelAdvice munger, boolean hasDynamicTest) { 979124d^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public void weaveAroundClosure(BcelAdvice munger, boolean hasDynamicTest) {
    	InstructionFactory fact = getFactory();

		enclosingMethod.setCanInline(false);

        // MOVE OUT ALL THE INSTRUCTIONS IN MY SHADOW INTO ANOTHER METHOD!
        LazyMethodGen callbackMethod = 
        	extractMethod(
        		NameMangler.aroundCallbackMethodName(
        			getSignature(),
        			getEnclosingClass()),
        		    0,
        		    munger);
        			    
    	BcelVar[] adviceVars = munger.getExposedStateAsBcelVars();
    	
    	String closureClassName = 
    		NameMangler.makeClosureClassName(
    			getEnclosingClass().getType(),
    			getEnclosingClass().getNewGeneratedNameTag());
    			
    	Member constructorSig = new MemberImpl(Member.CONSTRUCTOR, 
    								UnresolvedType.forName(closureClassName), 0, "<init>", 
    								"([Ljava/lang/Object;)V");
    	
    	BcelVar closureHolder = null;
    	
    	// This is not being used currently since getKind() == preinitializaiton
    	// cannot happen in around advice
    	if (getKind() == PreInitialization) {
    		closureHolder = genTempVar(AjcMemberMaker.AROUND_CLOSURE_TYPE);
    	}
    	
        InstructionList closureInstantiation =
            makeClosureInstantiation(constructorSig, closureHolder);

        /*LazyMethodGen constructor = */ 
            makeClosureClassAndReturnConstructor(
            	closureClassName,
                callbackMethod, 
                makeProceedArgumentMap(adviceVars)
                );

        InstructionList returnConversionCode;
		if (getKind() == PreInitialization) {
			returnConversionCode = new InstructionList();
			
			BcelVar stateTempVar = genTempVar(UnresolvedType.OBJECTARRAY);
			closureHolder.appendLoad(returnConversionCode, fact);
			
			returnConversionCode.append(
				Utility.createInvoke(
					fact, 
					world, 
					AjcMemberMaker.aroundClosurePreInitializationGetter()));
			stateTempVar.appendStore(returnConversionCode, fact);
			
			Type[] stateTypes = getSuperConstructorParameterTypes();
			
			returnConversionCode.append(InstructionConstants.ALOAD_0); // put "this" back on the stack
			for (int i = 0, len = stateTypes.length; i < len; i++) {
                UnresolvedType bcelTX = BcelWorld.fromBcel(stateTypes[i]);
                ResolvedType stateRTX = world.resolve(bcelTX,true);
                if (stateRTX.isMissing()) {
                		world.getLint().cantFindType.signal(
                				new String[] {WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE_PREINIT,bcelTX.getClassName())},
                				getSourceLocation(),
                				new ISourceLocation[]{ munger.getSourceLocation()}
                				);
//                    IMessage msg = new Message(
//                             WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE_PREINIT,bcelTX.getClassName()),
//                              "",IMessage.ERROR,getSourceLocation(),null,
//                              new ISourceLocation[]{ munger.getSourceLocation()});
//                    world.getMessageHandler().handleMessage(msg);
                }
				stateTempVar.appendConvertableArrayLoad(
					returnConversionCode, 
					fact, 
					i, 
					stateRTX);
			}
		} else {
	        returnConversionCode = 
	            Utility.createConversion(
	                getFactory(), 
	                BcelWorld.makeBcelType(munger.getSignature().getReturnType()), 
	                callbackMethod.getReturnType(),world.isInJava5Mode());
			if (!isFallsThrough()) {
				returnConversionCode.append(
					InstructionFactory.createReturn(callbackMethod.getReturnType()));
			}
		}

        // ATAJ for @AJ aspect we need to link the closure with the joinpoint instance
        if (munger.getConcreteAspect()!=null && munger.getConcreteAspect().isAnnotationStyleAspect()) {
            closureInstantiation.append(Utility.createInvoke(
                    getFactory(),
                    getWorld(),
                    new MemberImpl(
                            Member.METHOD,
                            UnresolvedType.forName("org.aspectj.runtime.internal.AroundClosure"),
                            Modifier.PUBLIC,
                            "linkClosureAndJoinPoint",
                            "()Lorg/aspectj/lang/ProceedingJoinPoint;"
                            )
            ));
        }

        InstructionList advice = new InstructionList();
        advice.append(munger.getAdviceArgSetup(this, null, closureInstantiation));

        // invoke the advice
        advice.append(munger.getNonTestAdviceInstructions(this));
        advice.append(returnConversionCode);
        
		if (!hasDynamicTest) {
			range.append(advice);
		} else {
			InstructionList callback = makeCallToCallback(callbackMethod);
			InstructionList postCallback = new InstructionList();
			if (terminatesWithReturn()) {
				callback.append(
					InstructionFactory.createReturn(callbackMethod.getReturnType()));
			} else {
				advice.append(
					InstructionFactory.createBranchInstruction(
						Constants.GOTO,
						postCallback.append(InstructionConstants.NOP)));
			}
			range.append(
				munger.getTestInstructions(
					this,
					advice.getStart(),
					callback.getStart(),
					advice.getStart()));
			range.append(advice);
			range.append(callback);
			range.append(postCallback);
		}
    }
================= fetch public void weaveCflowEntry(final BcelAdvice munger, final Member cflowField) { 979124d^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public void weaveCflowEntry(final BcelAdvice munger, final Member cflowField) {
		final boolean isPer = munger.getKind() == AdviceKind.PerCflowBelowEntry || 
								munger.getKind() == AdviceKind.PerCflowEntry;
		
		final Type objectArrayType = new ArrayType(Type.OBJECT, 1);
        final InstructionFactory fact = getFactory();        

		final BcelVar testResult = genTempVar(ResolvedType.BOOLEAN);

		InstructionList entryInstructions = new InstructionList();
		{
			InstructionList entrySuccessInstructions = new InstructionList();
			
			if (munger.hasDynamicTests()) {
				entryInstructions.append(Utility.createConstant(fact, 0));
				testResult.appendStore(entryInstructions, fact);
			
				entrySuccessInstructions.append(Utility.createConstant(fact, 1));
				testResult.appendStore(entrySuccessInstructions, fact);
			}

			if (isPer) {
	      		entrySuccessInstructions.append(
	      			fact.createInvoke(munger.getConcreteAspect().getName(), 
	      						NameMangler.PERCFLOW_PUSH_METHOD, 
	      						Type.VOID, 
	      						new Type[] { }, 
	      						Constants.INVOKESTATIC));
			} else {
				BcelVar[] cflowStateVars = munger.getExposedStateAsBcelVars();
	
				if (cflowStateVars.length == 0) {
					// This should be getting managed by a counter - lets make sure.
					if (!cflowField.getType().getName().endsWith("CFlowCounter")) 
						throw new RuntimeException("Incorrectly attempting counter operation on stacked cflow");
					entrySuccessInstructions.append(
			      			Utility.createGet(fact, cflowField));
					//arrayVar.appendLoad(entrySuccessInstructions, fact);
					entrySuccessInstructions.append(fact.createInvoke(NameMangler.CFLOW_COUNTER_TYPE,"inc",Type.VOID,new Type[] { },Constants.INVOKEVIRTUAL));
				} else {
				    BcelVar arrayVar = genTempVar(UnresolvedType.OBJECTARRAY);
	
				    int alen = cflowStateVars.length;
				    entrySuccessInstructions.append(Utility.createConstant(fact, alen));
				    entrySuccessInstructions.append(
				    		(Instruction) fact.createNewArray(Type.OBJECT, (short) 1));
				    arrayVar.appendStore(entrySuccessInstructions, fact);
		 
				    for (int i = 0; i < alen; i++) {
				    	arrayVar.appendConvertableArrayStore(
				    			entrySuccessInstructions,
								fact,
								i,
								cflowStateVars[i]);
				    }		
	
				    entrySuccessInstructions.append(
				    		Utility.createGet(fact, cflowField));
				    arrayVar.appendLoad(entrySuccessInstructions, fact);

				    entrySuccessInstructions.append(
				    		fact.createInvoke(NameMangler.CFLOW_STACK_TYPE, "push", Type.VOID, 
	      						new Type[] { objectArrayType }, 
	      					Constants.INVOKEVIRTUAL));
				}
			}

			
			InstructionList testInstructions = 
				munger.getTestInstructions(this, entrySuccessInstructions.getStart(), 
									range.getRealStart(), 
									entrySuccessInstructions.getStart());
			entryInstructions.append(testInstructions);
			entryInstructions.append(entrySuccessInstructions);
		}
		
		// this is the same for both per and non-per
		weaveAfter(new BcelAdvice(null, null, null, 0, 0, 0, null, null) {
================= fetch private static String genSourceSignature(IProgramElement classNode) { 5f8d2cd^:ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java
/**
     * Translates "aspect" to "class", as long as its not ".aspect"
     */
private static String genSourceSignature(IProgramElement classNode) {
    	String signature = classNode.getSourceSignature();
		if (signature != null){
			int index = signature.indexOf("aspect");
			if (index != -1 && signature.charAt(index-1) != '.') {
				signature = signature.substring(0, index) +
				"class " +
				signature.substring(index + 6, signature.length());
			}
		}
    	return signature;
	}
================= fetch public StringBuffer printHeader(int indent, StringBuffer output) { 5f8d2cd^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java
//	}
public StringBuffer printHeader(int indent, StringBuffer output) {
		printModifiers(this.modifiers, output);
		output.append("aspect " ); 
		output.append(name);
		if (superclass != null) {
			output.append(" extends ");  //$NON-NLS-1$
			superclass.print(0, output);
		}
		if (superInterfaces != null && superInterfaces.length > 0) {
			output.append((kind() == IGenericType.INTERFACE_DECL) ? " extends " : " implements ");//$NON-NLS-2$ //$NON-NLS-1$
			for (int i = 0; i < superInterfaces.length; i++) {
				if (i > 0) output.append( ", "); //$NON-NLS-1$
				superInterfaces[i].print(0, output);
			}
		}
		return output;		
		//XXX we should append the per-clause
	}
================= fetch public void testAspectAccessibility() { 5f8d2cd^:ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java

public void testAspectAccessibility() {
		IProgramElement packageAspect = AsmManager.getDefault().getHierarchy().findElementForType(null, "AdviceNamingCoverage");
		assertNotNull(packageAspect);
		assertEquals(IProgramElement.Accessibility.PACKAGE, packageAspect.getAccessibility());
	}
================= fetch private ResolvedMember createGenericConstructorMember(Constructor forConstructor b52515f^:weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java

private ResolvedMember createGenericConstructorMember(Constructor forConstructor) {
		ReflectionBasedResolvedMemberImpl ret = 
		new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.METHOD,
			getGenericResolvedType(),
			forConstructor.getModifiers(),
			getGenericResolvedType(),
			"init",
			typeConverter.fromTypes(forConstructor.getParameterTypes()),
			typeConverter.fromTypes(forConstructor.getExceptionTypes()),
			forConstructor
			);
		ret.setAnnotationFinder(this.annotationFinder);
		ret.setGenericSignatureInformationProvider(new Java15GenericSignatureInformationProvider(this.getWorld()));
		return ret;
	}
================= fetch public static ResolvedMember createResolvedConstructor(Constructor aConstructor, b52515f^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java

public static ResolvedMember createResolvedConstructor(Constructor aConstructor, World inWorld) {
		ReflectionBasedResolvedMemberImpl ret =
		   new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.CONSTRUCTOR,
				toResolvedType(aConstructor.getDeclaringClass(),(ReflectionWorld)inWorld),
				aConstructor.getModifiers(),
				toResolvedType(aConstructor.getDeclaringClass(),(ReflectionWorld)inWorld),
				"init",
				toResolvedTypeArray(aConstructor.getParameterTypes(),inWorld),
				toResolvedTypeArray(aConstructor.getExceptionTypes(),inWorld),
				aConstructor
				);
		if (inWorld instanceof ReflectionWorld) {
			ret.setAnnotationFinder(((ReflectionWorld)inWorld).getAnnotationFinder());
		}
		ret.setGenericSignatureInformationProvider(createGenericSignatureProvider(inWorld));
		return ret;
	}
================= fetch public void testGenericInterfaceSuperclass_BcelWorldResolution() { b52515f^:weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java

public void testGenericInterfaceSuperclass_BcelWorldResolution() {
        BcelWorld bcelworld = new BcelWorld();
        bcelworld.setBehaveInJava5Way(true);
        
        UnresolvedType javaUtilMap = UnresolvedType.forName("java.util.Map");
        
        ReferenceType rawType = (ReferenceType) bcelworld.resolve(javaUtilMap);
        assertTrue("Should be the raw type ?!? "+rawType.getTypekind(),rawType.isRawType());
        
        ReferenceType genericType = (ReferenceType)rawType.getGenericType();
        assertTrue("Should be the generic type ?!? "+genericType.getTypekind(),genericType.isGenericType());
        
        ResolvedType rt = rawType.getSuperclass();
        assertTrue("Superclass for Map raw type should be Object but was "+rt,rt.equals(UnresolvedType.OBJECT));         
        
        ResolvedType rt2 = genericType.getSuperclass();
        assertTrue("Superclass for Map generic type should be Object but was "+rt2,rt2.equals(UnresolvedType.OBJECT));         
    }
================= fetch public void testGetDeclaredMethods() { b52515f^:weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java

public void testGetDeclaredMethods() {
		ResolvedMember[] methods = objectType.getDeclaredMethods();
		assertEquals(Object.class.getDeclaredMethods().length + Object.class.getDeclaredConstructors().length, methods.length);
		
		ResolvedType c = world.resolve("reflect.tests.C");
		methods = c.getDeclaredMethods();
		assertEquals(3,methods.length);
		int idx = findMethod("foo", methods);
		assertTrue(idx > -1);
		
		assertEquals(world.resolve("java.lang.String"),methods[idx].getReturnType());
		assertEquals(1, methods[idx].getParameterTypes().length);
		assertEquals(objectType,methods[idx].getParameterTypes()[0]);
		assertEquals(1,methods[idx].getExceptions().length);
		assertEquals(world.resolve("java.lang.Exception"),methods[idx].getExceptions()[0]);
		int baridx = findMethod("bar", methods);
		int initidx = findMethod("init", methods);
		assertTrue(baridx > -1);
		assertTrue(initidx > -1);
		assertTrue(baridx != initidx && baridx != idx && idx <= 2 && initidx <= 2 && baridx <= 2);
		
		ResolvedType d = world.resolve("reflect.tests.D");
		methods = d.getDeclaredMethods();
		assertEquals(2,methods.length);

		classType = world.resolve("java.lang.Class");
		methods = classType.getDeclaredMethods();
		assertEquals(Class.class.getDeclaredMethods().length + Class.class.getDeclaredConstructors().length, methods.length); 
	}
================= fetch private void deleteNewAndDup() { 94159f9^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

private void deleteNewAndDup() {
		final ConstantPoolGen cpg = getEnclosingClass().getConstantPoolGen();
		int depth = 1;
		InstructionHandle ih = range.getStart();

		while (true) {
			Instruction inst = ih.getInstruction();
			if (inst instanceof INVOKESPECIAL
				&& ((INVOKESPECIAL) inst).getName(cpg).equals("<init>")) {
				depth++;
			} else if (inst instanceof NEW) {
				depth--;
				if (depth == 0) break;
			}
			ih = ih.getPrev();
		}
		// now IH points to the NEW.  We're followed by the DUP, and that is followed
		// by the actual instruciton we care about.  
		InstructionHandle newHandle = ih;
		InstructionHandle endHandle = newHandle.getNext();
		InstructionHandle nextHandle;
		if (endHandle.getInstruction() instanceof DUP) {
			nextHandle = endHandle.getNext();			
			retargetFrom(newHandle, nextHandle);
			retargetFrom(endHandle, nextHandle);
		} else if (endHandle.getInstruction() instanceof DUP_X1) {
			InstructionHandle dupHandle = endHandle;
			endHandle = endHandle.getNext();
			nextHandle = endHandle.getNext();
			if (endHandle.getInstruction() instanceof SWAP) {}
			else {
				// XXX see next XXX comment
				throw new RuntimeException("Unhandled kind of new " + endHandle);
			}
			retargetFrom(newHandle, nextHandle);
			retargetFrom(dupHandle, nextHandle);
			retargetFrom(endHandle, nextHandle);
		} else {
			endHandle = newHandle;
			nextHandle = endHandle.getNext();
			retargetFrom(newHandle, nextHandle);
			// add a POP here... we found a NEW w/o a dup or anything else, so
			// we must be in statement context.
			getRange().insert(InstructionConstants.POP, Range.OutsideAfter);
		}
		// assert (dupHandle.getInstruction() instanceof DUP);

		try {
			range.getBody().delete(newHandle, endHandle);
		} catch (TargetLostException e) {
			throw new BCException("shouldn't happen");
		}
	}
================= fetch private void retargetFrom(InstructionHandle old, InstructionHandle fresh) { 94159f9^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

private void retargetFrom(InstructionHandle old, InstructionHandle fresh) {
		InstructionTargeter[] sources = old.getTargeters();
		if (sources != null) {
			for (int i = sources.length - 1; i >= 0; i--) {
				sources[i].updateTarget(old, fresh);
			}
		}
	}
================= fetch protected File getSpecFile() { 94159f9^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testDeclareAnnotationOnNonExistentType_pr99191_5() { runTest("declare annotation on non existent type - 5");}
================= fetch public int getModifiers() { 6e8bf52^:aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/AjTypeImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.lang.reflect.AjType#getSupertype()
	 */
public AjType<? super T> getSupertype() {
		Class<? super T> superclass = clazz.getSuperclass();
		return (AjType<? super T>) new AjTypeImpl(superclass);
	}
================= fetch public void testGetSupertype() { 6e8bf52^:aspectj5rt/java5-testsrc/org/aspectj/internal/lang/reflect/AjTypeTests.java

public void testGetSupertype() {
		Class<?> stringSuper = String.class.getSuperclass();
		AjType ajSuper = stringType.getSupertype();
		assertEquals(AjTypeSystem.getAjType(stringSuper),ajSuper);
	}
Progress : [#######################-----------------] 59%================= fetch private boolean copyLtwFile (File sandboxDirectory) { 1e1bbb3^:testing/newsrc/org/aspectj/testing/RunSpec.java

private boolean copyLtwFile (File sandboxDirectory) {
		boolean useLtw = false;
		
		if (ltwFile != null) {
            // TODO maw use flag rather than empty file name
			if (ltwFile.trim().length() == 0) return true;
			
			File from = new File(baseDir,ltwFile);
			File to = new File(sandboxDirectory,"META-INF" + File.separator + "aop.xml");
//			System.out.println("RunSpec.copyLtwFile() from=" + from.getAbsolutePath() + " to=" + to.getAbsolutePath());
			try {
				FileUtil.copyFile(from,to);
				useLtw = true;
			}
			catch (IOException ex) {
				AjcTestCase.fail(ex.toString());
			}
		}
		
		return useLtw;
	}
================= fetch private void registerOptions(final BcelWeaver weaver, final ClassLoader loader, 1e1bbb3^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
     * Configure the weaver according to the option directives
     * TODO av - don't know if it is that good to reuse, since we only allow a small subset of options in LTW
     *
     * @param weaver
     * @param loader
     * @param definitions
     */
private void registerOptions(final BcelWeaver weaver, final ClassLoader loader, final List definitions) {
        StringBuffer allOptions = new StringBuffer();
        for (Iterator iterator = definitions.iterator(); iterator.hasNext();) {
            Definition definition = (Definition) iterator.next();
            allOptions.append(definition.getWeaverOptions()).append(' ');
        }

        Options.WeaverOption weaverOption = Options.parse(allOptions.toString(), loader, messageHandler);

        // configure the weaver and world
        // AV - code duplicates AspectJBuilder.initWorldAndWeaver()
        World world = weaver.getWorld();
        world.setMessageHandler(weaverOption.messageHandler);
        world.setXlazyTjp(weaverOption.lazyTjp);
        world.setXHasMemberSupportEnabled(weaverOption.hasMember);
        world.setPinpointMode(weaverOption.pinpoint);
        weaver.setReweavableMode(weaverOption.notReWeavable);
        world.setXnoInline(weaverOption.noInline);
        // AMC - autodetect as per line below, needed for AtAjLTWTests.testLTWUnweavable
        world.setBehaveInJava5Way(LangUtil.is15VMOrGreater());
        //-Xlintfile: first so that lint wins
        if (weaverOption.lintFile != null) {
            InputStream resource = null;
            try {
                resource = loader.getResourceAsStream(weaverOption.lintFile);
                Exception failure = null;
                if (resource != null) {
                    try {
                        Properties properties = new Properties();
                        properties.load(resource);
                        world.getLint().setFromProperties(properties);
                    } catch (IOException e) {
                        failure = e;
                    }
                }
                if (failure != null || resource == null) {
                    world.getMessageHandler().handleMessage(new Message(
                            "Cannot access resource for -Xlintfile:"+weaverOption.lintFile,
                            IMessage.WARNING,
                            failure,
                            null));
                }
            } finally {
                try { resource.close(); } catch (Throwable t) {;}
            }
        }
        if (weaverOption.lint == null) {
        		bcelWorld.getLint().loadDefaultProperties();
        		bcelWorld.getLint().adviceDidNotMatch.setKind(IMessage.INFO);
        } else {
            if (weaverOption.lint.equals("default")) {//FIXME should be AjBuildConfig.AJLINT_DEFAULT but yetanother deps..
                bcelWorld.getLint().loadDefaultProperties();
            } else {
                bcelWorld.getLint().setAll(weaverOption.lint);
            }
        }
        //TODO proceedOnError option
    }
================= fetch protected Digester getDigester() { 1e1bbb3^:testing/newsrc/org/aspectj/testing/XMLBasedAjcTestCase.java
/*
	 * The rules for parsing a suite spec file. The Digester using bean properties to match attributes
	 * in the XML document to properties in the associated classes, so this simple implementation should
	 * be very easy to maintain and extend should you ever need to.
	 */
protected Digester getDigester() {
		Digester digester = new Digester();
		digester.push(this);
		digester.addObjectCreate("suite/ajc-test",AjcTest.class);
		digester.addSetProperties("suite/ajc-test");
		digester.addSetNext("suite/ajc-test","addTest","org.aspectj.testing.AjcTest");
		digester.addObjectCreate("suite/ajc-test/compile",CompileSpec.class);
		digester.addSetProperties("suite/ajc-test/compile");
		digester.addSetNext("suite/ajc-test/compile","addTestStep","org.aspectj.testing.ITestStep");
		digester.addObjectCreate("suite/ajc-test/run",RunSpec.class);
		digester.addSetProperties("suite/ajc-test/run","class","classToRun");
		digester.addSetProperties("suite/ajc-test/run","ltw","ltwFile");
		digester.addSetNext("suite/ajc-test/run","addTestStep","org.aspectj.testing.ITestStep");
		digester.addObjectCreate("*/message",ExpectedMessageSpec.class);
		digester.addSetProperties("*/message");
		digester.addSetNext("*/message","addExpectedMessage","org.aspectj.testing.ExpectedMessageSpec");
		digester.addObjectCreate("suite/ajc-test/weave",WeaveSpec.class);
		digester.addSetProperties("suite/ajc-test/weave");
		digester.addSetNext("suite/ajc-test/weave","addTestStep","org.aspectj.testing.ITestStep");

        digester.addObjectCreate("suite/ajc-test/ant",AntSpec.class);
        digester.addSetProperties("suite/ajc-test/ant");
        digester.addSetNext("suite/ajc-test/ant","addTestStep","org.aspectj.testing.ITestStep");
        digester.addObjectCreate("suite/ajc-test/ant/stderr",OutputSpec.class);
        digester.addSetProperties("suite/ajc-test/ant/stderr");
        digester.addSetNext("suite/ajc-test/ant/stderr","addStdErrSpec","org.aspectj.testing.OutputSpec");
        digester.addObjectCreate("suite/ajc-test/ant/stdout",OutputSpec.class);
        digester.addSetProperties("suite/ajc-test/ant/stdout");
        digester.addSetNext("suite/ajc-test/ant/stdout","addStdOutSpec","org.aspectj.testing.OutputSpec");

		digester.addObjectCreate("suite/ajc-test/run/stderr",OutputSpec.class);
		digester.addSetProperties("suite/ajc-test/run/stderr");
		digester.addSetNext("suite/ajc-test/run/stderr","addStdErrSpec","org.aspectj.testing.OutputSpec");
		digester.addObjectCreate("suite/ajc-test/run/stdout",OutputSpec.class);
		digester.addSetProperties("suite/ajc-test/run/stdout");
		digester.addSetNext("suite/ajc-test/run/stdout","addStdOutSpec","org.aspectj.testing.OutputSpec");
		digester.addObjectCreate("*/line",OutputLine.class);
		digester.addSetProperties("*/line");
		digester.addSetNext("*/line","addLine","org.aspectj.testing.OutputLine");
		return digester;
	}
================= fetch protected boolean warn (String message, Throwable th) { 1e1bbb3^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java

protected boolean warn (String message, Throwable th) {
        return messageHandler.handleMessage(new Message("Register definition failed", IMessage.WARNING, th, null));
	}
================= fetch public void execute(AjcTestCase inTestCase) { 1e1bbb3^:testing/newsrc/org/aspectj/testing/RunSpec.java
/* (non-Javadoc)
	 * @see org.aspectj.testing.ITestStep#execute(org.aspectj.tools.ajc.AjcTestCase)
	 */
public void execute(AjcTestCase inTestCase) {
		if (!expected.isEmpty()) {
			System.err.println("Warning, message spec for run command is currently ignored (org.aspectj.testing.RunSpec)");
		}
		String[] args = buildArgs();
//		System.err.println("? execute() inTestCase='" + inTestCase + "', ltwFile=" + ltwFile);
		boolean useLtw = copyLtwFile(inTestCase.getSandboxDirectory());
		AjcTestCase.RunResult rr = inTestCase.run(getClassToRun(),args,getClasspath(),useLtw);
		if (stdErrSpec != null) {
			stdErrSpec.matchAgainst(rr.getStdErr());
		}
		if (stdOutSpec != null) {
			stdOutSpec.matchAgainst(rr.getStdOut());
		}
	}
================= fetch public void matchAgainst(String output) { 1e1bbb3^:testing/newsrc/org/aspectj/testing/OutputSpec.java

public void matchAgainst(String output) {
		boolean matches = false;
		int lineNo = 0;
		StringTokenizer strTok = new StringTokenizer(output,"\n");
		if (strTok.countTokens() == expectedOutputLines.size()) {
			matches = true;
			for (Iterator iter = expectedOutputLines.iterator(); iter.hasNext();) {
				String line = (String) iter.next();
				lineNo++;
				String outputLine = strTok.nextToken().trim();
				if (!line.equals(outputLine)) {
					matches = false;
					break;
				}
			}
		}
		if (!matches) {
			StringBuffer failMessage = new StringBuffer();
			failMessage.append("Expecting output:\n");
			for (Iterator iter = expectedOutputLines.iterator(); iter.hasNext();) {
				String line = (String) iter.next();
				failMessage.append(line);
				failMessage.append("\n");
			}
			failMessage.append("But found output:\n");
			failMessage.append(output);
			failMessage.append("\n");
			failMessage.append("First difference is on line " + lineNo);
			failMessage.append("\n");
			AjcTestCase.fail(failMessage.toString());
		}
	}
================= fetch public void testAspectsIncludeWithLintWarning () { 1e1bbb3^:tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.java

public void testAspectsIncludeWithLintWarning () {
  		runTest("Ensure weaver lint warning issued when an aspect is not used for weaving");
  	}
================= fetch protected Test findResidueInternal(Shadow shadow, ExposedState state) { d43e74b^:weaver/src/org/aspectj/weaver/patterns/IfPointcut.java

public static IfPointcut makeIfTruePointcut(State state) {
		IfPointcut ret = new IfTruePointcut();
		ret.state = state;
		return ret;
	}
================= fetch public void testNoNPEWhenInaccessibleMethodIsCalledWithinITD_pr119019() { d43e74b^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testNoNPEWhenInaccessibleMethodIsCalledWithinITD_pr119019() {
	  runTest("no NPE when inaccessible method is called within itd");
  }
================= fetch protected File getSpecFile() { 6d94d09^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testDeclareAnnotationOnNonExistentType_pr99191_5() { runTest("declare annotation on non existent type - 5");}
================= fetch public boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invocationSi 6d94d09^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeFieldBinding.java

public boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invocationSite, Scope scope) {
		scope.compilationUnitScope().recordTypeReference(declaringClass);
		//System.err.println("canBeSeenBy: " + this + ", " + isPublic());
		if (isPublic()) return true;	
	
		SourceTypeBinding invocationType = scope.invocationType();
		//System.out.println("receiver: " + receiverType + ", " + invocationType);
		ReferenceBinding declaringType = declaringClass;
		
		// FIXME asc what about parameterized types and private ITD generic fields on interfaces?
		
		// Don't work with a raw type, work with the generic type
		if (declaringClass.isRawType()) 
			 declaringType = ((RawTypeBinding)declaringClass).type;
		
		if (invocationType == declaringType) return true;
	
	
	//	if (invocationType.isPrivileged) {
	//		System.out.println("privileged access to: " + this);
	//		return true;
	//	}
		
		if (isProtected()) {
			throw new RuntimeException("unimplemented");
		}
	
		//XXX make sure this walks correctly
		if (isPrivate()) {
			// answer true if the receiverType is the declaringClass
			// AND the invocationType and the declaringClass have a common enclosingType
			if (receiverType != declaringType) return false;
	
			if (invocationType != declaringType) {
				ReferenceBinding outerInvocationType = invocationType;
				ReferenceBinding temp = outerInvocationType.enclosingType();
				while (temp != null) {
					outerInvocationType = temp;
					temp = temp.enclosingType();
				}
	
				ReferenceBinding outerDeclaringClass = declaringType;
				temp = outerDeclaringClass.enclosingType();
				while (temp != null) {
					outerDeclaringClass = temp;
					temp = temp.enclosingType();
				}
				if (outerInvocationType != outerDeclaringClass) return false;
			}
			return true;
		}
	
		// isDefault()
		if (invocationType.fPackage == declaringClass.fPackage) return true;
		return false;
	}
================= fetch protected File getSpecFile() { a75b7fa^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testDeclareAnnotationOnNonExistentType_pr99191_5() { runTest("declare annotation on non existent type - 5");}
================= fetch public ResolvedType put(String key, ResolvedType type) { a75b7fa^:weaver/src/org/aspectj/weaver/World.java

public boolean isTargettingAspectJRuntime12() {
		return getTargetAspectjRuntimeLevel().equals(org.aspectj.weaver.Constants.RUNTIME_LEVEL_12);
	}
================= fetch public ResolvedType resolve(UnresolvedType ty, boolean allowMissing) { a75b7fa^:weaver/src/org/aspectj/weaver/World.java
/**
     * Resolve a type. This the hub of type resolution. The resolved type is added
     * to the type map by signature.
     */
public ResolvedType resolve(UnresolvedType ty, boolean allowMissing) {
    	
    	// special resolution processing for already resolved types.
    	if (ty instanceof ResolvedType) {
    		ResolvedType rty = (ResolvedType) ty;
    		rty = resolve(rty);
    		return rty;
    	}

    	// dispatch back to the type variable reference to resolve its constituent parts
    	// don't do this for other unresolved types otherwise you'll end up in a loop
    	if (ty.isTypeVariableReference()) {
    		return ty.resolve(this);
    	}
    	
    	// if we've already got a resolved type for the signature, just return it
    	// after updating the world
        String signature = ty.getSignature();
        ResolvedType ret = typeMap.get(signature);
        if (ret != null) { 
        	ret.world = this;  // Set the world for the RTX
        	return ret; 
        } else if ( signature.equals("?") || signature.equals("*")) {
        // might be a problem here, not sure '?' should make it to here as a signature, the 
        // proper signature for wildcard '?' is '*'
        	// fault in generic wildcard, can't be done earlier because of init issues
        	ResolvedType something = new BoundedReferenceType("?",this);
        	typeMap.put("?",something);
        	return something;
        }
        
        // no existing resolved type, create one
        if (ty.isArray()) {
        	ResolvedType componentType = resolve(ty.getComponentType(),allowMissing);
        	String brackets = signature.substring(0,signature.lastIndexOf("[")+1);
            ret = new ResolvedType.Array(signature, brackets+componentType.getErasureSignature(),
            		                     this, 
            		                     componentType);
        } else {
            ret = resolveToReferenceType(ty);
            if (!allowMissing && ret == ResolvedType.MISSING) {
                ret = handleRequiredMissingTypeDuringResolution(ty);
            }
        }        
  
		// Pulling in the type may have already put the right entry in the map
		if (typeMap.get(signature)==null && ret != ResolvedType.MISSING) {
	        typeMap.put(signature, ret);
		}
        return ret;
    }
================= fetch private MyBuildOptionsAdapter() {} 551b9ca^:tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java

public static void log(String s) {
			if (VERBOSE) System.out.println(s);
		}
================= fetch private static boolean build(String projectName,String configFile) { 551b9ca^:tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java

public boolean build(String projectName,String configFile) {
		return AjdeManager.build(projectName,configFile);
	}
================= fetch public String getNonStandardOptions() { 551b9ca^:tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java

public String getNonStandardOptions() {
			return null;
		}
================= fetch public static void configureNewProjectDependency(String fromProject, String proj 551b9ca^:tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java
// End of methods for configuring the build
protected File getWorkingDir() { return sandboxDir; }
================= fetch public void installGlobals(AjBuildConfig global) { // XXX relies on default valu 551b9ca^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java
/**
     * Install global values into local config
     * unless values conflict:
     * <ul>
     * <li>Collections are unioned</li>
     * <li>values takes local value unless default and global set</li>
     * <li>this only sets one of outputDir and outputJar as needed</li>
     * <ul>
     * This also configures super if javaOptions change.
     * @param global the AjBuildConfig to read globals from
     */
public void installGlobals(AjBuildConfig global) { // XXX relies on default values
    	// don't join the options - they already have defaults taken care of.
//        Map optionsMap = options.getMap();
//        join(optionsMap,global.getOptions().getMap());
//        options.set(optionsMap);
        join(aspectpath, global.aspectpath);
        join(classpath, global.classpath);
        if (null == configFile) {
            configFile = global.configFile; // XXX correct?
        }
        if (!isEmacsSymMode() && global.isEmacsSymMode()) {
            setEmacsSymMode(true);
        }
        join(files, global.files);
        if (!isGenerateModelMode() && global.isGenerateModelMode()) {
            setGenerateModelMode(true);
        }
        if (null == incrementalFile) {
            incrementalFile = global.incrementalFile;
        }
        if (!incrementalMode && global.incrementalMode) {
            incrementalMode = true;
        }
        join(inJars, global.inJars);
        join(inPath, global.inPath);
        if ((null == lintMode) 
            || (AJLINT_DEFAULT.equals(lintMode))) {
            setLintMode(global.lintMode);
        }
        if (null == lintSpecFile) {
            lintSpecFile = global.lintSpecFile;
        }
        if (!isNoWeave() && global.isNoWeave()) {
            setNoWeave(true);
        }
        if ((null == outputDir) && (null == outputJar)) {
            if (null != global.outputDir) {
                outputDir = global.outputDir;
            }
            if (null != global.outputJar) {
                outputJar = global.outputJar;
            }
        }        
        join(sourceRoots, global.sourceRoots);
        if (!isXnoInline() && global.isXnoInline()) {
            setXnoInline(true);
        }
        if (!isXserializableAspects() && global.isXserializableAspects()) {
            setXserializableAspects(true);
        }
        if (!isXlazyTjp() && global.isXlazyTjp()) {
        	setXlazyTjp(true);
        }
        if (!isXHasMemberEnabled() && global.isXHasMemberEnabled()) {
        	setXHasMemberSupport(true);
        }
        if (!isXNotReweavable() && global.isXNotReweavable()) {
        	setXnotReweavable(true);
        }
    }
================= fetch public void testPr92837() { 551b9ca^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java

public void testPr92837() {
		initialiseProject("PR92837");
		build("PR92837");
		alter("PR92837","inc1");
		build("PR92837");
	}
================= fetch private void sortMungers() { 2c81907^:weaver/src/org/aspectj/weaver/Shadow.java

private void sortMungers() {
		List sorted = PartialOrder.sort(mungers);
		if (sorted == null) {
			// this means that we have circular dependencies
			for (Iterator i = mungers.iterator(); i.hasNext(); ) {
				ShadowMunger m = (ShadowMunger)i.next();
				getIWorld().getMessageHandler().handleMessage(
					MessageUtil.error(
							WeaverMessages.format(WeaverMessages.CIRCULAR_DEPENDENCY,this), m.getSourceLocation()));
			}
		}
		mungers = sorted;
	}
================= fetch protected File getSpecFile() { 2c81907^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testDeclareAnnotationOnNonExistentType_pr99191_5() { runTest("declare annotation on non existent type - 5");}
================= fetch public int compareByPrecedence(ResolvedType aspect1, ResolvedType aspect2) { 2c81907^:weaver/src/org/aspectj/weaver/World.java
/**
	 * Same signature as org.aspectj.util.PartialOrder.PartialComparable.compareTo
	 */
public int compareByPrecedence(ResolvedType aspect1, ResolvedType aspect2) {
		return precedenceCalculator.compareByPrecedence(aspect1, aspect2);
	}
================= fetch public int compareByPrecedence(ResolvedType firstAspect, ResolvedType secondAspe 2c81907^:weaver/src/org/aspectj/weaver/World.java
/**
		 * Ask every declare precedence in the world to order the two aspects.
		 * If more than one declare precedence gives an ordering, and the orderings
		 * conflict, then that's an error. 
		 */
public int compareByPrecedence(ResolvedType firstAspect, ResolvedType secondAspect) {
			PrecedenceCacheKey key = new PrecedenceCacheKey(firstAspect,secondAspect);
			if (cachedResults.containsKey(key)) {
				return ((Integer) cachedResults.get(key)).intValue();
			} else {
				int order = 0;
				DeclarePrecedence orderer = null; // Records the declare precedence statement that gives the first ordering
				for (Iterator i = world.getCrosscuttingMembersSet().getDeclareDominates().iterator(); i.hasNext(); ) {
					DeclarePrecedence d = (DeclarePrecedence)i.next();
					int thisOrder = d.compare(firstAspect, secondAspect);
					if (thisOrder != 0) {
						if (orderer==null) orderer = d;
						if (order != 0 && order != thisOrder) {
							ISourceLocation[] isls = new ISourceLocation[2];
							isls[0]=orderer.getSourceLocation();
							isls[1]=d.getSourceLocation();
							Message m = 
							  new Message("conflicting declare precedence orderings for aspects: "+
							              firstAspect.getName()+" and "+secondAspect.getName(),null,true,isls);
							world.getMessageHandler().handleMessage(m);
						} else {
							order = thisOrder;
						}
					}
				}		
				cachedResults.put(key, new Integer(order));
				return order;
			}
		}
Progress : [########################----------------] 60%================= fetch private static ReflectionBasedReferenceTypeDelegate create15Delegate(ReferenceTy d1a295c^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java

private static ReflectionBasedReferenceTypeDelegate create15Delegate(ReferenceType forReferenceType, Class forClass, ClassLoader usingClassLoader, World inWorld) {
		try {
			Class delegateClass = Class.forName("org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate",false,usingClassLoader);//ReflectionBasedReferenceTypeDelegate.class.getClassLoader()); 
			ReflectionBasedReferenceTypeDelegate ret = (ReflectionBasedReferenceTypeDelegate) delegateClass.newInstance();
			ret.initialize(forReferenceType,forClass,usingClassLoader,inWorld);
			return ret;
		} catch (ClassNotFoundException cnfEx) {
			throw new IllegalStateException("Attempted to create Java 1.5 reflection based delegate but org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate was not found on classpath");
		} catch (InstantiationException insEx) {
			throw new IllegalStateException("Attempted to create Java 1.5 reflection based delegate but InstantiationException: " + insEx + " occured");
		} catch (IllegalAccessException illAccEx) {
			throw new IllegalStateException("Attempted to create Java 1.5 reflection based delegate but IllegalAccessException: " + illAccEx + " occured");
		}
	}
================= fetch private static ReflectionBasedReferenceTypeDelegate create15Delegate(ReferenceTy 508dbcb^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java

private static ReflectionBasedReferenceTypeDelegate create15Delegate(ReferenceType forReferenceType, Class forClass, ClassLoader usingClassLoader, World inWorld) {
		try {
			// important that we use *our own* classloader for the next call...
			Class delegateClass = Class.forName("org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate",false,ReflectionBasedReferenceTypeDelegate.class.getClassLoader()); 
			ReflectionBasedReferenceTypeDelegate ret = (ReflectionBasedReferenceTypeDelegate) delegateClass.newInstance();
			ret.initialize(forReferenceType,forClass,usingClassLoader,inWorld);
			return ret;
		} catch (ClassNotFoundException cnfEx) {
			return null;
		} catch (InstantiationException insEx) {
			return null;
		} catch (IllegalAccessException illAccEx) {
			return null;
		}
	}
================= fetch public void testParameterizedPointcutAndAdvice() { 508dbcb^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testXlintMessageForImproperAnnotationType_pr115252_MoreThanOne() {runTest("xlint message for more than one improper annotated parameter type");}
================= fetch private Collection collectCheckedExceptions(UnresolvedType[] excs) { 6eb77c5^:weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java
// ---- implementations
private Collection collectCheckedExceptions(UnresolvedType[] excs) {
		if (excs == null || excs.length == 0) return Collections.EMPTY_LIST;
		
		Collection ret = new ArrayList();
		World world = concreteAspect.getWorld();
		ResolvedType runtimeException = world.getCoreType(UnresolvedType.RUNTIME_EXCEPTION);
		ResolvedType error = world.getCoreType(UnresolvedType.ERROR);
		
		for (int i=0, len=excs.length; i < len; i++) {
			ResolvedType t = world.resolve(excs[i],true);
            if (t == ResolvedType.MISSING) {
                IMessage msg = new Message(
                  WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_EXCEPTION_TYPE,excs[i].getName()),
                  "",IMessage.ERROR,getSourceLocation(),null,null);
                world.getMessageHandler().handleMessage(msg);
            }
			if (!(runtimeException.isAssignableFrom(t) || error.isAssignableFrom(t))) {
				ret.add(t);
			}
		}
			
		return ret;
	}
================= fetch private Test findResidueNoEllipsis(Shadow shadow, ExposedState state, TypePatter 6eb77c5^:weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java

private Test findResidueNoEllipsis(Shadow shadow, ExposedState state, TypePattern[] patterns) {
		ResolvedType[] argumentsToMatchAgainst = getArgumentsToMatchAgainst(shadow);
		int len = argumentsToMatchAgainst.length;
		//System.err.println("boudn to : " + len + ", " + patterns.length);
		if (patterns.length != len) {
			return Literal.FALSE;
		}
		
		Test ret = Literal.TRUE;
		
		for (int i=0; i < len; i++) {
			UnresolvedType argType = shadow.getGenericArgTypes()[i];
			TypePattern type = patterns[i];
            ResolvedType argRTX = shadow.getIWorld().resolve(argType,true);
			if (!(type instanceof BindingTypePattern)) {
                if (argRTX == ResolvedType.MISSING) {
                  IMessage msg = new Message(
                    WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_ARG_TYPE,argType.getName()),
                    "",IMessage.ERROR,shadow.getSourceLocation(),null,new ISourceLocation[]{getSourceLocation()});
                  shadow.getIWorld().getMessageHandler().handleMessage(msg);
                }
				if (type.matchesInstanceof(argRTX).alwaysTrue()) {
					continue;
				}
			}

			World world = shadow.getIWorld();
			ResolvedType typeToExpose = type.getExactType().resolve(world);
			if (typeToExpose.isParameterizedType()) {
				boolean inDoubt = (type.matchesInstanceof(argRTX) == FuzzyBoolean.MAYBE);				
				if (inDoubt && world.getLint().uncheckedArgument.isEnabled()) {
					String uncheckedMatchWith = typeToExpose.getSimpleBaseName();
					if (argRTX.isParameterizedType() && (argRTX.getRawType() == typeToExpose.getRawType())) {
						uncheckedMatchWith = argRTX.getSimpleName();
					}
					if (!isUncheckedArgumentWarningSuppressed()) {
						world.getLint().uncheckedArgument.signal(
								new String[] {
										typeToExpose.getSimpleName(),
										uncheckedMatchWith,
										typeToExpose.getSimpleBaseName(),
										shadow.toResolvedString(world)},
								getSourceLocation(),
								new ISourceLocation[] {shadow.getSourceLocation()});
						}
				}
			}			
			
			ret = Test.makeAnd(ret,
				exposeStateForVar(shadow.getArgVar(i), type, state,shadow.getIWorld()));
		}
		
		return ret;		
	}
================= fetch private void raiseCantFindType(String key) { 6eb77c5^:weaver/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java

private void raiseCantFindType(String key) {
		if (issuedCantFindTypeError) return;
		String message = WeaverMessages.format(key,getName());
		message += "\n" + CompilationAndWeavingContext.getCurrentContext();
		MessageUtil.error(world.getMessageHandler(),message);
		issuedCantFindTypeError = true;
	}
================= fetch private void raiseCantFindType(String key,String insert) { 6eb77c5^:weaver/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java

private void raiseCantFindType(String key,String insert) {
		if (issuedCantFindTypeError) return;
		String message = WeaverMessages.format(key,getName(),insert);
		message += "\n" + CompilationAndWeavingContext.getCurrentContext();
		MessageUtil.error(world.getMessageHandler(),message);
		issuedCantFindTypeError = true;
	}
================= fetch private void warnOnConfusingSig(Shadow shadow) { 6eb77c5^:weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java
//	}
private void warnOnConfusingSig(Shadow shadow) {
		// Don't do all this processing if we don't need to !
		if (!shadow.getIWorld().getLint().unmatchedSuperTypeInCall.isEnabled()) return;
		
        // no warnings for declare error/warning
        if (munger instanceof Checker) return;
        
        World world = shadow.getIWorld();
        
		// warning never needed if the declaring type is any
		UnresolvedType exactDeclaringType = signature.getDeclaringType().getExactType();
        
		ResolvedType shadowDeclaringType =
			shadow.getSignature().getDeclaringType().resolve(world);
        
		if (signature.getDeclaringType().isStar()
			|| exactDeclaringType == ResolvedType.MISSING
			|| exactDeclaringType.resolve(world).isMissing())
			return;

        // warning not needed if match type couldn't ever be the declaring type
		if (!shadowDeclaringType.isAssignableFrom(exactDeclaringType.resolve(world))) {
            return;
		}

		// if the method in the declaring type is *not* visible to the
		// exact declaring type then warning not needed.
		int shadowModifiers = shadow.getSignature().resolve(world).getModifiers();
		if (!ResolvedType
			.isVisible(
				shadowModifiers,
				shadowDeclaringType,
				exactDeclaringType.resolve(world))) {
			return;
		}
		
		if (!signature.getReturnType().matchesStatically(shadow.getSignature().getReturnType().resolve(world))) {
			// Covariance issue...
			// The reason we didn't match is that the type pattern for the pointcut (Car) doesn't match the
			// return type for the specific declaration at the shadow. (FastCar Sub.getCar())
			// XXX Put out another XLINT in this case?
			return;
		}
		// PR60015 - Don't report the warning if the declaring type is object and 'this' is an interface
		if (exactDeclaringType.resolve(world).isInterface() && shadowDeclaringType.equals(world.resolve("java.lang.Object"))) {
			return;
		}

		SignaturePattern nonConfusingPattern =
			new SignaturePattern(
				signature.getKind(),
				signature.getModifiers(),
				signature.getReturnType(),
				TypePattern.ANY,
				signature.getName(), 
				signature.getParameterTypes(),
				signature.getThrowsPattern(),
				signature.getAnnotationPattern());

		if (nonConfusingPattern
			.matches(shadow.getSignature(), shadow.getIWorld(),true)) {
                shadow.getIWorld().getLint().unmatchedSuperTypeInCall.signal(
                    new String[] {
                        shadow.getSignature().getDeclaringType().toString(),
                        signature.getDeclaringType().toString()
                    },
                    this.getSourceLocation(),
                    new ISourceLocation[] {shadow.getSourceLocation()} );               
		}
	}
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { 6eb77c5^:weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.Pointcut#match(org.aspectj.weaver.Shadow)
	 */
protected FuzzyBoolean matchInternal(Shadow shadow) {
		ResolvedType enclosingType = shadow.getIWorld().resolve(shadow.getEnclosingType(),true);
		if (enclosingType == ResolvedType.MISSING) {
			IMessage msg = new Message(
			    WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_WITHINPCD,
			    		              shadow.getEnclosingType().getName()),
				shadow.getSourceLocation(),true,new ISourceLocation[]{getSourceLocation()});
			shadow.getIWorld().getMessageHandler().handleMessage(msg);
		}
		annotationTypePattern.resolve(shadow.getIWorld());
		return annotationTypePattern.matches(enclosingType);
	}
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { 6eb77c5^:weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java

protected FuzzyBoolean matchInternal(Shadow shadow) {
		ResolvedType enclosingType = shadow.getIWorld().resolve(shadow.getEnclosingType(),true);
		if (enclosingType == ResolvedType.MISSING) {
			IMessage msg = new Message(
			    WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_WITHINPCD,
			    		              shadow.getEnclosingType().getName()),
				shadow.getSourceLocation(),true,new ISourceLocation[]{getSourceLocation()});
			shadow.getIWorld().getMessageHandler().handleMessage(msg);
		}
		typePattern.resolve(shadow.getIWorld());
		return isWithinType(enclosingType);
	}
================= fetch protected Test findResidueInternal(Shadow shadow, ExposedState state) { 6eb77c5^:weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.Pointcut#findResidue(org.aspectj.weaver.Shadow, org.aspectj.weaver.patterns.ExposedState)
	 */
protected Test findResidueInternal(Shadow shadow, ExposedState state) {
		int len = shadow.getArgCount();
	
		// do some quick length tests first
		int numArgsMatchedByEllipsis = (len + arguments.ellipsisCount) - arguments.size();
		if (numArgsMatchedByEllipsis < 0) return Literal.FALSE;  // should never happen
		if ((numArgsMatchedByEllipsis > 0) && (arguments.ellipsisCount == 0)) {
			return Literal.FALSE; // should never happen
		}
		// now work through the args and the patterns, skipping at ellipsis
    	Test ret = Literal.TRUE;
    	int argsIndex = 0;
    	for (int i = 0; i < arguments.size(); i++) {
			if (arguments.get(i) == AnnotationTypePattern.ELLIPSIS) {
				// match ellipsisMatchCount args
				argsIndex += numArgsMatchedByEllipsis;
			} else if (arguments.get(i) == AnnotationTypePattern.ANY) {
				argsIndex++;
			} else {
				// match the argument type at argsIndex with the ExactAnnotationTypePattern
				// we know it is exact because nothing else is allowed in args
				ExactAnnotationTypePattern ap = (ExactAnnotationTypePattern)arguments.get(i);
				UnresolvedType argType = shadow.getArgType(argsIndex);
				ResolvedType rArgType = argType.resolve(shadow.getIWorld());
				if (rArgType == ResolvedType.MISSING) {
	                  IMessage msg = new Message(
	                    WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_ARG_TYPE,argType.getName()),
	                    "",IMessage.ERROR,shadow.getSourceLocation(),null,new ISourceLocation[]{getSourceLocation()});
	            }

				ResolvedType rAnnType = ap.getAnnotationType().resolve(shadow.getIWorld());
				if (ap instanceof BindingAnnotationTypePattern) {
					BindingAnnotationTypePattern btp = (BindingAnnotationTypePattern)ap;
					Var annvar = shadow.getArgAnnotationVar(argsIndex,rAnnType);
					state.set(btp.getFormalIndex(),annvar);
				}
				if (!ap.matches(rArgType).alwaysTrue()) {
					// we need a test...
					ret = Test.makeAnd(ret,
								Test.makeHasAnnotation(
										shadow.getArgVar(argsIndex),
										rAnnType));
				}			
				argsIndex++;
			}
		}   	
    	return ret;
	}
================= fetch public ResolvedType resolve(UnresolvedType ty,ISourceLocation isl) { 6eb77c5^:weaver/src/org/aspectj/weaver/World.java
/**
     * Convenience method for resolving an array of unresolved types
     * in one hit. Useful for e.g. resolving type parameters in signatures.
     */
public ResolvedType[] resolve(UnresolvedType[] types) {
    	if (types == null) return new ResolvedType[0];
    	
        ResolvedType[] ret = new ResolvedType[types.length];
        for (int i=0; i<types.length; i++) {
            ret[i] = resolve(types[i]);
        }
        return ret;
    }
================= fetch public void raiseWarningOnJoinPointSignature(String signature) { 6eb77c5^:weaver/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java

public void raiseWarningOnJoinPointSignature(String signature) {
		if (issuedJoinPointWarning) return;
		String message = WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_JOINPOINT,getName(),signature);
		message += "\n" + CompilationAndWeavingContext.getCurrentContext();
		MessageUtil.warn(world.getMessageHandler(),message); 
		issuedJoinPointWarning = true;		
	}
================= fetch public void raiseWarningOnMissingInterfaceWhilstFindingMethods() { 6eb77c5^:weaver/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java

public void raiseWarningOnMissingInterfaceWhilstFindingMethods() {
		if (issuedMissingInterfaceWarning) return;
		String message = WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_INTERFACE_METHODS,getName(),signature);
		message += "\n" + CompilationAndWeavingContext.getCurrentContext();
		MessageUtil.warn(world.getMessageHandler(),message); 
		issuedMissingInterfaceWarning = true;				
	}
================= fetch public void testDeclareSoftInGenericAspect() { 6eb77c5^:tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java

public void testITDBridgeMethodsPr91381() {runTest("Abstract intertype method and covariant returns");}
================= fetch public void weaveAroundClosure(BcelAdvice munger, boolean hasDynamicTest) { 6eb77c5^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public void weaveAroundClosure(BcelAdvice munger, boolean hasDynamicTest) {
    	InstructionFactory fact = getFactory();

		enclosingMethod.setCanInline(false);

        // MOVE OUT ALL THE INSTRUCTIONS IN MY SHADOW INTO ANOTHER METHOD!
        LazyMethodGen callbackMethod = 
        	extractMethod(
        		NameMangler.aroundCallbackMethodName(
        			getSignature(),
        			getEnclosingClass()),
        		    0,
        		    munger);
        			    
    	BcelVar[] adviceVars = munger.getExposedStateAsBcelVars();
    	
    	String closureClassName = 
    		NameMangler.makeClosureClassName(
    			getEnclosingClass().getType(),
    			getEnclosingClass().getNewGeneratedNameTag());
    			
    	Member constructorSig = new MemberImpl(Member.CONSTRUCTOR, 
    								UnresolvedType.forName(closureClassName), 0, "<init>", 
    								"([Ljava/lang/Object;)V");
    	
    	BcelVar closureHolder = null;
    	
    	// This is not being used currently since getKind() == preinitializaiton
    	// cannot happen in around advice
    	if (getKind() == PreInitialization) {
    		closureHolder = genTempVar(AjcMemberMaker.AROUND_CLOSURE_TYPE);
    	}
    	
        InstructionList closureInstantiation =
            makeClosureInstantiation(constructorSig, closureHolder);

        /*LazyMethodGen constructor = */ 
            makeClosureClassAndReturnConstructor(
            	closureClassName,
                callbackMethod, 
                makeProceedArgumentMap(adviceVars)
                );

        InstructionList returnConversionCode;
		if (getKind() == PreInitialization) {
			returnConversionCode = new InstructionList();
			
			BcelVar stateTempVar = genTempVar(UnresolvedType.OBJECTARRAY);
			closureHolder.appendLoad(returnConversionCode, fact);
			
			returnConversionCode.append(
				Utility.createInvoke(
					fact, 
					world, 
					AjcMemberMaker.aroundClosurePreInitializationGetter()));
			stateTempVar.appendStore(returnConversionCode, fact);
			
			Type[] stateTypes = getSuperConstructorParameterTypes();
			
			returnConversionCode.append(InstructionConstants.ALOAD_0); // put "this" back on the stack
			for (int i = 0, len = stateTypes.length; i < len; i++) {
                UnresolvedType bcelTX = BcelWorld.fromBcel(stateTypes[i]);
                ResolvedType stateRTX = world.resolve(bcelTX,true);
                if (stateRTX == ResolvedType.MISSING) {
                    IMessage msg = new Message(
                             WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE_PREINIT,bcelTX.getClassName()),
                              "",IMessage.ERROR,getSourceLocation(),null,
                              new ISourceLocation[]{ munger.getSourceLocation()});
                    world.getMessageHandler().handleMessage(msg);
                }
				stateTempVar.appendConvertableArrayLoad(
					returnConversionCode, 
					fact, 
					i, 
					stateRTX);
			}
		} else {
	        returnConversionCode = 
	            Utility.createConversion(
	                getFactory(), 
	                BcelWorld.makeBcelType(munger.getSignature().getReturnType()), 
	                callbackMethod.getReturnType());
			if (!isFallsThrough()) {
				returnConversionCode.append(
					InstructionFactory.createReturn(callbackMethod.getReturnType()));
			}
		}

        // ATAJ for @AJ aspect we need to link the closure with the joinpoint instance
        if (munger.getConcreteAspect()!=null && munger.getConcreteAspect().isAnnotationStyleAspect()) {
            closureInstantiation.append(Utility.createInvoke(
                    getFactory(),
                    getWorld(),
                    new MemberImpl(
                            Member.METHOD,
                            UnresolvedType.forName("org.aspectj.runtime.internal.AroundClosure"),
                            Modifier.PUBLIC,
                            "linkClosureAndJoinPoint",
                            "()Lorg/aspectj/lang/ProceedingJoinPoint;"
                            )
            ));
        }

        InstructionList advice = new InstructionList();
        advice.append(munger.getAdviceArgSetup(this, null, closureInstantiation));

        // invoke the advice
        advice.append(munger.getNonTestAdviceInstructions(this));
        advice.append(returnConversionCode);
        
		if (!hasDynamicTest) {
			range.append(advice);
		} else {
			InstructionList callback = makeCallToCallback(callbackMethod);
			InstructionList postCallback = new InstructionList();
			if (terminatesWithReturn()) {
				callback.append(
					InstructionFactory.createReturn(callbackMethod.getReturnType()));
			} else {
				advice.append(
					InstructionFactory.createBranchInstruction(
						Constants.GOTO,
						postCallback.append(InstructionConstants.NOP)));
			}
			range.append(
				munger.getTestInstructions(
					this,
					advice.getStart(),
					callback.getStart(),
					advice.getStart()));
			range.append(advice);
			range.append(callback);
			range.append(postCallback);
		}
    }
================= fetch public void weaveAroundInline( 6eb77c5^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

void weaveAroundInline(
    	BcelAdvice munger,
    	boolean hasDynamicTest)
	{
		/* Implementation notes:
		 * 
		 * AroundInline still extracts the instructions of the original shadow into 
		 * an extracted method.  This allows inlining of even that advice that doesn't
		 * call proceed or calls proceed more than once. 
		 * 
		 * It extracts the instructions of the original shadow into a method.
		 * 
		 * Then it extracts the instructions of the advice into a new method defined on
		 * this enclosing class.  This new method can then be specialized as below.
		 * 
		 * Then it searches in the instructions of the advice for any call to the
		 * proceed method.
		 * 
		 *   At such a call, there is stuff on the stack representing the arguments to
		 *   proceed.  Pop these into the frame.
		 * 
		 *   Now build the stack for the call to the extracted method, taking values 
		 *   either from the join point state or from the new frame locs from proceed.
		 *   Now call the extracted method.  The right return value should be on the
		 *   stack, so no cast is necessary.
		 *
		 * If only one call to proceed is made, we can re-inline the original shadow.
		 * We are not doing that presently.
		 * 
		 * If the body of the advice can be determined to not alter the stack, or if
		 * this shadow doesn't care about the stack, i.e. method-execution, then the
		 * new method for the advice can also be re-lined.  We are not doing that
		 * presently.
		 */
		 
		// !!! THIS BLOCK OF CODE SHOULD BE IN A METHOD CALLED weaveAround(...);
        Member mungerSig = munger.getSignature();
        //Member originalSig = mungerSig; // If mungerSig is on a parameterized type, originalSig is the member on the generic type
        if (mungerSig instanceof ResolvedMember) {
        	ResolvedMember rm = (ResolvedMember)mungerSig;
        	if (rm.hasBackingGenericMember()) mungerSig = rm.getBackingGenericMember();
        }
        ResolvedType declaringType = world.resolve(mungerSig.getDeclaringType(),true);
        if (declaringType == ResolvedType.MISSING) {
          IMessage msg = new Message(
                WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE,declaringType.getClassName()),
                "",IMessage.ERROR,getSourceLocation(),null,
                new ISourceLocation[]{ munger.getSourceLocation()});
          world.getMessageHandler().handleMessage(msg);
        }
        //??? might want some checks here to give better errors
        BcelObjectType ot = BcelWorld.getBcelObjectType((declaringType.isParameterizedType()?declaringType.getGenericType():declaringType)); 
        
		LazyMethodGen adviceMethod = ot.getLazyClassGen().getLazyMethodGen(mungerSig);
		if (!adviceMethod.getCanInline()) {
			weaveAroundClosure(munger, hasDynamicTest);
			return;
		}

        // specific test for @AJ proceedInInners
        if (munger.getConcreteAspect().isAnnotationStyleAspect()) {
            // if we can't find one proceed()
            // we suspect that the call is happening in an inner class
            // so we don't inline it.
            // Note: for code style, this is done at Aspect compilation time.
            boolean canSeeProceedPassedToOther = false;
            InstructionHandle curr = adviceMethod.getBody().getStart();
            InstructionHandle end = adviceMethod.getBody().getEnd();
            ConstantPoolGen cpg = adviceMethod.getEnclosingClass().getConstantPoolGen();
            while (curr != end) {
                InstructionHandle next = curr.getNext();
                Instruction inst = curr.getInstruction();
                if ((inst instanceof InvokeInstruction)
                    && ((InvokeInstruction)inst).getSignature(cpg).indexOf("Lorg/aspectj/lang/ProceedingJoinPoint;") > 0) {
                    // we may want to refine to exclude stuff returning jp ?
                    // does code style skip inline if i write dump(thisJoinPoint) ?
                    canSeeProceedPassedToOther = true;// we see one pjp passed around - dangerous
                    break;
                }
                curr = next;
            }
            if (canSeeProceedPassedToOther) {
                // remember this decision to avoid re-analysis
                adviceMethod.setCanInline(false);
                weaveAroundClosure(munger, hasDynamicTest);
                return;
            }
        }



		// We can't inline around methods if they have around advice on them, this
		// is because the weaving will extract the body and hence the proceed call.
		//??? should consider optimizations to recognize simple cases that don't require body extraction
		enclosingMethod.setCanInline(false);
		
		// start by exposing various useful things into the frame
		final InstructionFactory fact = getFactory();
		
		// now generate the aroundBody method
        LazyMethodGen extractedMethod = 
        	extractMethod(
        		NameMangler.aroundCallbackMethodName(
        			getSignature(),
        			getEnclosingClass()),
				Modifier.PRIVATE,
				munger
            );
        			
        			
        // now extract the advice into its own method
        String adviceMethodName =
			NameMangler.aroundCallbackMethodName(
							getSignature(),
							getEnclosingClass()) + "$advice";
        
		List argVarList = new ArrayList();
		List proceedVarList = new ArrayList();
		int extraParamOffset = 0;
		
		// Create the extra parameters that are needed for passing to proceed
		// This code is very similar to that found in makeCallToCallback and should
		// be rationalized in the future
		if (thisVar != null) {
			argVarList.add(thisVar);
			proceedVarList.add(new BcelVar(thisVar.getType(), extraParamOffset));
			extraParamOffset += thisVar.getType().getSize();
		}
		
		if (targetVar != null && targetVar != thisVar) {
			argVarList.add(targetVar);
			proceedVarList.add(new BcelVar(targetVar.getType(), extraParamOffset));
			extraParamOffset += targetVar.getType().getSize();
		}
		for (int i = 0, len = getArgCount(); i < len; i++) {
			argVarList.add(argVars[i]);
			proceedVarList.add(new BcelVar(argVars[i].getType(), extraParamOffset));
			extraParamOffset += argVars[i].getType().getSize();
		}
		if (thisJoinPointVar != null) {
			argVarList.add(thisJoinPointVar);
			proceedVarList.add(new BcelVar(thisJoinPointVar.getType(), extraParamOffset));
			extraParamOffset += thisJoinPointVar.getType().getSize();
		}
        
        Type[] adviceParameterTypes = adviceMethod.getArgumentTypes();
        Type[] extractedMethodParameterTypes = extractedMethod.getArgumentTypes();
		Type[] parameterTypes =
			new Type[extractedMethodParameterTypes.length
				+ adviceParameterTypes.length
				+ 1];
		int parameterIndex = 0;
		System.arraycopy(
			extractedMethodParameterTypes,
			0,
			parameterTypes,
			parameterIndex,
			extractedMethodParameterTypes.length);
		parameterIndex += extractedMethodParameterTypes.length;

		parameterTypes[parameterIndex++] =
			BcelWorld.makeBcelType(adviceMethod.getEnclosingClass().getType());
		System.arraycopy(
			adviceParameterTypes,
			0,
			parameterTypes,
			parameterIndex,
			adviceParameterTypes.length);

        LazyMethodGen localAdviceMethod =
					new LazyMethodGen(
						Modifier.PRIVATE | Modifier.FINAL | Modifier.STATIC, 
						BcelWorld.makeBcelType(mungerSig.getReturnType()), 
						adviceMethodName,
						parameterTypes,
						new String[0],
						getEnclosingClass());
 
		String donorFileName = adviceMethod.getEnclosingClass().getInternalFileName();
		String recipientFileName = getEnclosingClass().getInternalFileName();
//		System.err.println("donor " + donorFileName);
//		System.err.println("recip " + recipientFileName);
		if (! donorFileName.equals(recipientFileName)) {
			localAdviceMethod.fromFilename = donorFileName;
			getEnclosingClass().addInlinedSourceFileInfo(
				donorFileName,
				adviceMethod.highestLineNumber);
		}
    
		getEnclosingClass().addMethodGen(localAdviceMethod);
		
		// create a map that will move all slots in advice method forward by extraParamOffset
		// in order to make room for the new proceed-required arguments that are added at
		// the beginning of the parameter list
		int nVars = adviceMethod.getMaxLocals() + extraParamOffset;
		IntMap varMap = IntMap.idMap(nVars);
		for (int i=extraParamOffset; i < nVars; i++) {
			varMap.put(i-extraParamOffset, i);
		}

		localAdviceMethod.getBody().insert(
			BcelClassWeaver.genInlineInstructions(adviceMethod,
					localAdviceMethod, varMap, fact, true));


					
		localAdviceMethod.setMaxLocals(nVars);
					
		//System.err.println(localAdviceMethod);
		
    
    	// the shadow is now empty.  First, create a correct call
    	// to the around advice.  This includes both the call (which may involve 
    	// value conversion of the advice arguments) and the return
    	// (which may involve value conversion of the return value).  Right now
    	// we push a null for the unused closure.  It's sad, but there it is.
    	    	
    	InstructionList advice = new InstructionList();
        // InstructionHandle adviceMethodInvocation;
        {
			for (Iterator i = argVarList.iterator(); i.hasNext(); ) {
				BcelVar var = (BcelVar)i.next();
				var.appendLoad(advice, fact);
			}       	
        	// ??? we don't actually need to push NULL for the closure if we take care
			advice.append(
				munger.getAdviceArgSetup(
					this,
					null,
                    (munger.getConcreteAspect().isAnnotationStyleAspect())?
                        this.loadThisJoinPoint():
					    new InstructionList(InstructionConstants.ACONST_NULL)));
		    // adviceMethodInvocation =
		        advice.append(
		        	Utility.createInvoke(fact, localAdviceMethod)); //(fact, getWorld(), munger.getSignature()));
			advice.append(
		        Utility.createConversion(
		            getFactory(), 
		            BcelWorld.makeBcelType(mungerSig.getReturnType()), 
		            extractedMethod.getReturnType()));
		    if (! isFallsThrough()) {
		        advice.append(InstructionFactory.createReturn(extractedMethod.getReturnType()));
		    }
        }
        
		// now, situate the call inside the possible dynamic tests,
		// and actually add the whole mess to the shadow
        if (! hasDynamicTest) {
            range.append(advice);
        } else {
        	InstructionList afterThingie = new InstructionList(InstructionConstants.NOP);
            InstructionList callback = makeCallToCallback(extractedMethod);
			if (terminatesWithReturn()) {
				callback.append(
					InstructionFactory.createReturn(extractedMethod.getReturnType()));
			} else {
				//InstructionHandle endNop = range.insert(fact.NOP, Range.InsideAfter);
				advice.append(
					InstructionFactory.createBranchInstruction(
						Constants.GOTO,
						afterThingie.getStart()));
			}
			range.append(
				munger.getTestInstructions(
					this,
					advice.getStart(),
					callback.getStart(),
					advice.getStart()));
            range.append(advice);
            range.append(callback);
            range.append(afterThingie);          
        }        


        // now search through the advice, looking for a call to PROCEED.  
        // Then we replace the call to proceed with some argument setup, and a 
        // call to the extracted method.

        // inlining support for code style aspects
        if (!munger.getConcreteAspect().isAnnotationStyleAspect()) {
            String proceedName =
                NameMangler.proceedMethodName(munger.getSignature().getName());

            InstructionHandle curr = localAdviceMethod.getBody().getStart();
            InstructionHandle end = localAdviceMethod.getBody().getEnd();
            ConstantPoolGen cpg = localAdviceMethod.getEnclosingClass().getConstantPoolGen();
            while (curr != end) {
                InstructionHandle next = curr.getNext();
                Instruction inst = curr.getInstruction();
                if ((inst instanceof INVOKESTATIC)
                    && proceedName.equals(((INVOKESTATIC) inst).getMethodName(cpg))) {

                    localAdviceMethod.getBody().append(
                        curr,
                        getRedoneProceedCall(
                            fact,
                            extractedMethod,
                            munger,
                            localAdviceMethod,
                            proceedVarList));
                    Utility.deleteInstruction(curr, localAdviceMethod);
                }
                curr = next;
            }
            // and that's it.
        } else {
            //ATAJ inlining support for @AJ aspects
            // [TODO document @AJ code rule: don't manipulate 2 jps proceed at the same time.. in an advice body]
            InstructionHandle curr = localAdviceMethod.getBody().getStart();
            InstructionHandle end = localAdviceMethod.getBody().getEnd();
            ConstantPoolGen cpg = localAdviceMethod.getEnclosingClass().getConstantPoolGen();
            while (curr != end) {
                InstructionHandle next = curr.getNext();
                Instruction inst = curr.getInstruction();
                if ((inst instanceof INVOKEINTERFACE)
                    && "proceed".equals(((INVOKEINTERFACE) inst).getMethodName(cpg))) {
                    final boolean isProceedWithArgs;
                    if (((INVOKEINTERFACE) inst).getArgumentTypes(cpg).length == 1) {
                        // proceed with args as a boxed Object[]
                        isProceedWithArgs = true;
                    } else {
                        isProceedWithArgs = false;
                    }
                    InstructionList insteadProceedIl = getRedoneProceedCallForAnnotationStyle(
                            fact,
                            extractedMethod,
                            munger,
                            localAdviceMethod,
                            proceedVarList,
                            isProceedWithArgs
                    );
                    localAdviceMethod.getBody().append(curr, insteadProceedIl);
                    Utility.deleteInstruction(curr, localAdviceMethod);
                }
                curr = next;
            }
        }
	}
================= fetch public MessageHolder() { 76d7e83^:tests/java5/ataspectj/ataspectj/ltwlog/MessageHolder.java

================= fetch public static WeaverOption parse(String options, ClassLoader laoder, IMessageHan 76d7e83^:loadtime/src/org/aspectj/weaver/loadtime/Options.java

public static WeaverOption parse(String options, ClassLoader laoder, IMessageHandler imh) {
        WeaverOption weaverOption = new WeaverOption(imh);

        if (LangUtil.isEmpty(options)) {
            return weaverOption;
        }
        // the first option wins
        List flags = LangUtil.anySplit(options, " ");
        Collections.reverse(flags);

        // do a first round on the message handler since it will report the options themselves
        for (Iterator iterator = flags.iterator(); iterator.hasNext();) {
            String arg = (String) iterator.next();
            if (arg.startsWith(OPTIONVALUED_messageHandler)) {
                if (arg.length() > OPTIONVALUED_messageHandler.length()) {
                    String handlerClass = arg.substring(OPTIONVALUED_messageHandler.length()).trim();
                    try {
                        Class handler = Class.forName(handlerClass, false, laoder);
                        weaverOption.messageHandler = ((IMessageHandler) handler.newInstance());
                    } catch (Throwable t) {
                        weaverOption.messageHandler.handleMessage(
                                new Message(
                                        "Cannot instantiate message handler " + handlerClass,
                                        IMessage.ERROR,
                                        t,
                                        null
                                )
                        );
                    }
                }
            }
        }

        // configure the other options
        for (Iterator iterator = flags.iterator(); iterator.hasNext();) {
            String arg = (String) iterator.next();
            if (arg.equals(OPTION_15)) {
                weaverOption.java5 = true;
            } else if (arg.equalsIgnoreCase(OPTION_lazyTjp)) {
                weaverOption.lazyTjp = true;
            } else if (arg.equalsIgnoreCase(OPTION_noinline)) {
                weaverOption.noInline = true;
            } else if (arg.equalsIgnoreCase(OPTION_noWarn) || arg.equalsIgnoreCase(OPTION_noWarnNone)) {
                weaverOption.noWarn = true;
            } else if (arg.equalsIgnoreCase(OPTION_proceedOnError)) {
                weaverOption.proceedOnError = true;
            } else if (arg.equalsIgnoreCase(OPTION_reweavable)) {
                weaverOption.notReWeavable = false;
            } else if (arg.equalsIgnoreCase(OPTION_showWeaveInfo)) {
                weaverOption.showWeaveInfo = true;
            } else if (arg.equalsIgnoreCase(OPTION_hasMember)) {
                weaverOption.hasMember = true;
            }  else if (arg.equalsIgnoreCase(OPTION_verbose)) {
                weaverOption.verbose = true;
            } else if (arg.equalsIgnoreCase(OPTION_pinpoint)) {
                weaverOption.pinpoint = true;
            } else if (arg.startsWith(OPTIONVALUED_messageHandler)) {
                ;// handled in first round
            } else if (arg.startsWith(OPTIONVALUED_Xlintfile)) {
                if (arg.length() > OPTIONVALUED_Xlintfile.length()) {
                    weaverOption.lintFile = arg.substring(OPTIONVALUED_Xlintfile.length()).trim();
                }
            } else if (arg.startsWith(OPTIONVALUED_Xlint)) {
                if (arg.length() > OPTIONVALUED_Xlint.length()) {
                    weaverOption.lint = arg.substring(OPTIONVALUED_Xlint.length()).trim();
                }
            } else {
                weaverOption.messageHandler.handleMessage(
                        new Message(
                                "Cannot configure weaver with option '" + arg + "': unknown option",
                                IMessage.WARNING,
                                null,
                                null
                        )
                );
            }
        }

        // refine message handler configuration
        if (weaverOption.noWarn) {
            weaverOption.messageHandler.dontIgnore(IMessage.WARNING);
        }
        if (weaverOption.verbose) {
            weaverOption.messageHandler.dontIgnore(IMessage.DEBUG);
        }
        if (weaverOption.showWeaveInfo) {
            weaverOption.messageHandler.dontIgnore(IMessage.WEAVEINFO);
        }

        return weaverOption;
    }
================= fetch public void testAjcAspect1LTWAspect2_Xreweavable() { 76d7e83^:tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java

public void testAjcAspect1LTWAspect2_Xreweavable() {
        runTest("Ajc Aspect1 LTW Aspect2 -Xreweavable");
    }
================= fetch protected Collection getDeclares() { 86880f7^:weaver/src/org/aspectj/weaver/ReferenceType.java

protected Collection getDeclares() {
		if (parameterizedDeclares != null) return parameterizedDeclares;
		Collection declares = null;
		if (ajMembersNeedParameterization()) {
			Collection genericDeclares = delegate.getDeclares();
			parameterizedDeclares = new ArrayList();
			Map parameterizationMap = getAjMemberParameterizationMap();
			for (Iterator iter = genericDeclares.iterator(); iter.hasNext();) {
				Declare declareStatement = (Declare) iter.next();
				parameterizedDeclares.add(declareStatement.parameterizeWith(parameterizationMap));
			}
			declares = parameterizedDeclares;
		} else {
			declares = delegate.getDeclares();
		}
		for (Iterator iter = declares.iterator(); iter.hasNext();) {
			Declare d = (Declare) iter.next();
			d.setDeclaringType(this);
		}
		return declares;
	}
================= fetch public Collection getDeclaredAdvice() { 86880f7^:weaver/src/org/aspectj/weaver/ResolvedType.java

public Collection getDeclaredAdvice() {
		List l = new ArrayList();
		ResolvedMember[] methods = getDeclaredMethods();
		if (isParameterizedType()) methods = getGenericType().getDeclaredMethods();
		Map typeVariableMap = getMemberParameterizationMap();
		for (int i=0, len = methods.length; i < len; i++) {
			ShadowMunger munger = methods[i].getAssociatedShadowMunger();
			if (munger != null) {
				if (this.isParameterizedType()) {
					//munger.setPointcut(munger.getPointcut().parameterizeWith(typeVariableMap));
					munger = munger.parameterizeWith(this,typeVariableMap);
					if (munger instanceof Advice) {
						Advice advice = (Advice) munger;
						// update to use the parameterized signature...
						UnresolvedType[] ptypes = methods[i].getGenericParameterTypes()	;
						UnresolvedType[] newPTypes = new UnresolvedType[ptypes.length];
						for (int j = 0; j < ptypes.length; j++) {
							if (ptypes[j] instanceof TypeVariableReferenceType) {
								TypeVariableReferenceType tvrt = (TypeVariableReferenceType) ptypes[j];
								if (typeVariableMap.containsKey(tvrt.getTypeVariable().getName())) {
									newPTypes[j] = (UnresolvedType) typeVariableMap.get(tvrt.getTypeVariable().getName());
								} else {
									newPTypes[j] = ptypes[j];
								}
							} else {
								newPTypes[j] = ptypes[j];
							}
						}
						advice.setBindingParameterTypes(newPTypes);
					}
				}
				munger.setDeclaringType(this);
				l.add(munger);
			}
		}
		return l;
	}
================= fetch public ShadowMunger parameterizeWith(ResolvedType declaringType,Map typeVariable 86880f7^:weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java

public ShadowMunger parameterizeWith(ResolvedType declaringType,Map typeVariableMap) {
		Pointcut pc = getPointcut().parameterizeWith(typeVariableMap);
		
		BcelAdvice ret = null;
		Member adviceSignature = signature;		
		// allows for around advice where the return value is a type variable (see pr115250)
		if (signature instanceof ResolvedMember) {
			adviceSignature = ((ResolvedMember)signature).parameterizedWith(declaringType.getTypeParameters(),declaringType,declaringType.isParameterizedType());
		}
		ret = new BcelAdvice(this.attribute,pc,adviceSignature,this.concreteAspect);
		return ret;
	}
================= fetch public boolean isParameterizedWithAMemberTypeVariable() { 86880f7^:weaver/src/org/aspectj/weaver/ResolvedType.java
/**
	 * return true if the parameterization of this type includes a member type variable.  Member
	 * type variables occur in generic methods/ctors.
	 */
public boolean isParameterizedWithAMemberTypeVariable() {
		// MAYBE means we haven't worked it out yet...
		if (parameterizedWithAMemberTypeVariable==FuzzyBoolean.MAYBE) {
			
			// if there are no type parameters then we cant be...
			if (typeParameters==null || typeParameters.length==0) {
				parameterizedWithAMemberTypeVariable = FuzzyBoolean.NO;
				return false;
			}
			
			for (int i = 0; i < typeParameters.length; i++) {
				UnresolvedType aType = (ResolvedType)typeParameters[i];
				if (aType.isTypeVariableReference()  && 
				// assume the worst - if its definetly not a type declared one, it could be anything
						((TypeVariableReference)aType).getTypeVariable().getDeclaringElementKind()!=TypeVariable.TYPE) {
					parameterizedWithAMemberTypeVariable = FuzzyBoolean.YES;
					return true;
				}
				if (aType.isParameterizedType()) {
					boolean b = aType.isParameterizedWithAMemberTypeVariable();
					if (b) {
						parameterizedWithAMemberTypeVariable = FuzzyBoolean.YES;
						return true;
					}
				}
				if (aType.isGenericWildcard()) {
					if (aType.isExtends()) {
						boolean b = false;
						UnresolvedType upperBound = aType.getUpperBound();
						if (upperBound.isParameterizedType()) {
							b = upperBound.isParameterizedWithAMemberTypeVariable();
						} else if (upperBound.isTypeVariableReference() && ((TypeVariableReference)upperBound).getTypeVariable().getDeclaringElementKind()==TypeVariable.METHOD) {
							b = true;
						}
						if (b) {
							parameterizedWithAMemberTypeVariable = FuzzyBoolean.YES;
							return true;
						}
						// FIXME asc need to check additional interface bounds
					}
					if (aType.isSuper()) {
						boolean b = false;
						UnresolvedType lowerBound = aType.getLowerBound();
						if (lowerBound.isParameterizedType()) {
							b = lowerBound.isParameterizedWithAMemberTypeVariable();
						} else if (lowerBound.isTypeVariableReference() && ((TypeVariableReference)lowerBound).getTypeVariable().getDeclaringElementKind()==TypeVariable.METHOD) {
							b = true;
						}
						if (b) {
							parameterizedWithAMemberTypeVariable = FuzzyBoolean.YES;
							return true;
						}
					}
				}
			}
			parameterizedWithAMemberTypeVariable=FuzzyBoolean.NO;
		}
		return parameterizedWithAMemberTypeVariable.alwaysTrue();
	}
================= fetch public void testPerTargetAndNegation() { 86880f7^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testXlintMessageForImproperAnnotationType_pr115252_MoreThanOne() {runTest("xlint message for more than one improper annotated parameter type");}
================= fetch public Object visit(NotPointcut node, Object data) { a4caeb9^:weaver/src/org/aspectj/weaver/patterns/PerThisOrTargetPointcutVisitor.java

public Object visit(NotPointcut node, Object data) {
        TypePattern negated = getPerTypePointcut(node.getNegatedPointcut());
        if (MAYBE.equals(negated)) {
            return MAYBE;
        }
        return new NotTypePattern(negated);
    }
================= fetch public void testReturningObjectBinding() { a4caeb9^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testXlintMessageForImproperAnnotationType_pr115252_MoreThanOne() {runTest("xlint message for more than one improper annotated parameter type");}
Progress : [########################----------------] 61%================= fetch private static Type makeParameterizedType(String typeName, Class classScope) 81e6b60^:aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/StringToType.java

private static Type makeParameterizedType(String typeName, Class classScope) 
	throws ClassNotFoundException {
		int paramStart = typeName.indexOf('<');
		String baseName = typeName.substring(0, paramStart);
		final Class baseClass = Class.forName(baseName);
		int paramEnd = typeName.lastIndexOf('>');
		String params = typeName.substring(paramStart+1,paramEnd);
		final Type[] typeParams = commaSeparatedListToTypeArray(params,classScope);
		return new ParameterizedType() {

			public Type[] getActualTypeArguments() {
				return typeParams;
			}
================= fetch public DeclareSoftImpl(AjType declaringType, String pcut, String exceptionTypeNa 81e6b60^:aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/DeclareSoftImpl.java

================= fetch public static Type stringToType(String typeName, Class classScope) 81e6b60^:aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/StringToType.java

public static Type stringToType(String typeName, Class classScope) 
	throws ClassNotFoundException {
		try {
			if (typeName.indexOf("<") == -1) {
				return AjTypeSystem.getAjType(Class.forName(typeName));
			} else {
				return makeParameterizedType(typeName,classScope);
			}
		} catch (ClassNotFoundException e) {
			// could be a type variable
			TypeVariable[] tVars = classScope.getTypeParameters();
			for (int i = 0; i < tVars.length; i++) {
				if (tVars[i].getName().equals(typeName)) {
					return tVars[i];
				}
			}
			throw new ClassNotFoundException(typeName);
		}
	}
================= fetch protected File getSpecFile() { 11ab99f^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testDeclareAnnotationOnNonExistentType_pr99191_5() { runTest("declare annotation on non existent type - 5");}
================= fetch pointcut j(): 8b294d9^:tests/new/OddConstructors.java

================= fetch private void callEvent(String s, Object o) { 8b294d9^:tests/new/AfterReturningParam.java

public void mVoid() { return; }
================= fetch public boolean hasHighPriorityExceptions() { 8b294d9^:weaver/src/org/aspectj/weaver/Shadow.java
// XXX revisit along with removal of priorities
public boolean hasHighPriorityExceptions() {
			return !isTargetSameAsThis();
		}
================= fetch public boolean match(Shadow shadow, World world) { 8b294d9^:weaver/src/org/aspectj/weaver/Advice.java

public boolean match(Shadow shadow, World world) {
		if (super.match(shadow, world)) {
			if (shadow.getKind() == Shadow.ExceptionHandler) {
				if (kind.isAfter() || kind == AdviceKind.Around) {
					world.showMessage(IMessage.WARNING,
							WeaverMessages.format(WeaverMessages.ONLY_BEFORE_ON_HANDLER),
							getSourceLocation(), shadow.getSourceLocation());
					return false;
				}
			}
			
			
    		if (hasExtraParameter() && kind == AdviceKind.AfterReturning) {
    			ResolvedType resolvedExtraParameterType = getExtraParameterType().resolve(world);
    			ResolvedType shadowReturnType = shadow.getReturnType().resolve(world);
    			boolean matches = resolvedExtraParameterType.isConvertableFrom(shadowReturnType);
    			if (matches && resolvedExtraParameterType.isParameterizedType()) {
    				maybeIssueUncheckedMatchWarning(resolvedExtraParameterType,shadowReturnType,shadow,world);
    			}
    			return matches;
    		} else if (kind == AdviceKind.PerTargetEntry) {
    			return shadow.hasTarget();
    		} else if (kind == AdviceKind.PerThisEntry) {
    			return shadow.hasThis();
    		} else if (kind == AdviceKind.Around) {
    			if (shadow.getKind() == Shadow.PreInitialization) {
	    			world.showMessage(IMessage.ERROR,
	    					WeaverMessages.format(WeaverMessages.AROUND_ON_PREINIT),
							getSourceLocation(), shadow.getSourceLocation());
					return false;
				} else if (shadow.getKind() == Shadow.Initialization) {
					world.showMessage(IMessage.ERROR,
							WeaverMessages.format(WeaverMessages.AROUND_ON_INIT),
							getSourceLocation(), shadow.getSourceLocation());
					return false;
				} else if (shadow.getKind() == Shadow.StaticInitialization && 
							shadow.getEnclosingType().resolve(world).isInterface())
				{
					world.showMessage(IMessage.ERROR,
							WeaverMessages.format(WeaverMessages.AROUND_ON_INTERFACE_STATICINIT,shadow.getEnclosingType().getName()),
							getSourceLocation(), shadow.getSourceLocation());
					return false;
    			} else {
    				//System.err.println(getSignature().getReturnType() + " from " + shadow.getReturnType());
    				if (getSignature().getReturnType() == ResolvedType.VOID) {
    					if (shadow.getReturnType() != ResolvedType.VOID) {
    						world.showMessage(IMessage.ERROR, 
    							WeaverMessages.format(WeaverMessages.NON_VOID_RETURN,shadow),	
    							getSourceLocation(), shadow.getSourceLocation());
    						return false;
    					}
    				} else if (getSignature().getReturnType().equals(UnresolvedType.OBJECT)) {
    					return true;
    				} else {
    					ResolvedType shadowReturnType = shadow.getReturnType().resolve(world);
    					ResolvedType adviceReturnType = getSignature().getGenericReturnType().resolve(world);
    					
    					if (shadowReturnType.isParameterizedType() && adviceReturnType.isRawType()) { // Set<Integer> and Set
    						ResolvedType shadowReturnGenericType = shadowReturnType.getGenericType(); // Set
    						ResolvedType adviceReturnGenericType = adviceReturnType.getGenericType(); // Set
    						if (shadowReturnGenericType.isAssignableFrom(adviceReturnGenericType) && 
    								world.getLint().uncheckedAdviceConversion.isEnabled()) {
    							world.getLint().uncheckedAdviceConversion.signal(
    								new String[]{shadow.toString(),shadowReturnType.getName(),adviceReturnType.getName()},
    								shadow.getSourceLocation(),
    								new ISourceLocation[]{getSourceLocation()});
    						}
    					} else if(!shadowReturnType.isAssignableFrom(adviceReturnType)) {
	    					//System.err.println(this + ", " + sourceContext + ", " + start);
							world.showMessage(IMessage.ERROR,
									WeaverMessages.format(WeaverMessages.INCOMPATIBLE_RETURN_TYPE,shadow),
									getSourceLocation(), shadow.getSourceLocation());
		    				return false;
    					}
    				}
    			}
    		}
    		return true; 
    	} else {
    		return false;
    	}
	}
================= fetch public static void main(String[] args) { 8b294d9^:tests/new/AfterReturningParam.java

public void mVoid() { return; }
================= fetch public static void main(String[] args) { 8b294d9^:tests/new/ConstructorExecInit.java

public static void main(String[] args) {
        new ConstructorExecInit();
        Tester.checkAllEvents();
    }
================= fetch public void testDeclareSoftWithExclusions() { 8b294d9^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testXlintMessageForImproperAnnotationType_pr115252_MoreThanOne() {runTest("xlint message for more than one improper annotated parameter type");}
================= fetch private boolean shouldWeave (String name, byte[] bytes) { a5ac5af^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java
/**
     * @param name
     * @return true if should weave (but maybe we still need to munge it for @AspectJ aspectof support)
     */
private boolean shouldWeave (String name, byte[] bytes) {
		name = name.replace('/','.');
		boolean b = enabled && !generatedClasses.containsKey(name) && shouldWeaveName(name);
        return b && accept(name, bytes);
//        && shouldWeaveAnnotationStyleAspect(name);
//        // we recall shouldWeaveAnnotationStyleAspect as we need to add aspectOf methods for @Aspect anyway
//        //FIXME AV - this is half ok as the aspect will be weaved by others. In theory if the aspect
//        // is excluded from include/exclude config we should only weave late type mungers for aspectof
//        return b && (accept(name) || shouldWeaveAnnotationStyleAspect(name));
	}
================= fetch private void registerDefinitions(final BcelWeaver weaver, final ClassLoader load a5ac5af^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
     * Load and cache the aop.xml/properties according to the classloader visibility rules
     *
     * @param weaver
     * @param loader
     */
void registerDefinitions(final BcelWeaver weaver, final ClassLoader loader) {
        try {
            MessageUtil.info(messageHandler, "register classloader " + getClassLoaderName(loader));
            //TODO av underoptimized: we will parse each XML once per CL that see it
            List definitions = new ArrayList();

            //TODO av dev mode needed ? TBD -Daj5.def=...
            if (ClassLoader.getSystemClassLoader().equals(loader)) {
                String file = System.getProperty("aj5.def", null);
                if (file != null) {
                    MessageUtil.info(messageHandler, "using (-Daj5.def) " + file);
                    definitions.add(DocumentParser.parse((new File(file)).toURL()));
                }
            }

            String resourcePath = System.getProperty("org.aspectj.weaver.loadtime.configuration",AOP_XML);
    		StringTokenizer st = new StringTokenizer(resourcePath,";");

    		while(st.hasMoreTokens()){
    			Enumeration xmls = weavingContext.getResources(st.nextToken());
//    			System.out.println("? registerDefinitions: found-aop.xml=" + xmls.hasMoreElements() + ", loader=" + loader);

    			while (xmls.hasMoreElements()) {
    			    URL xml = (URL) xmls.nextElement();
    			    MessageUtil.info(messageHandler, "using " + xml.getFile());
    			    definitions.add(DocumentParser.parse(xml));
    			}
    		}

            // still go thru if definitions is empty since we will configure
            // the default message handler in there
            registerOptions(weaver, loader, definitions);

            // AV - see #113511
            if (!definitions.isEmpty()) {
                registerAspectExclude(weaver, loader, definitions);
                registerAspectInclude(weaver, loader, definitions);
                registerAspects(weaver, loader, definitions);
                registerIncludeExclude(weaver, loader, definitions);
                registerDump(weaver, loader, definitions);
            } else {
                enabled = false;// will allow very fast skip in shouldWeave()
        		info("no configuration found. Disabling weaver for class loader " + getClassLoaderName(loader));
            }
        } catch (Exception e) {
            enabled = false;// will allow very fast skip in shouldWeave()
            warn("register definition failed",e);
        }
    }
================= fetch public void acceptClass(String name, byte[] bytes) { a5ac5af^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java

void initialize(final ClassLoader loader, IWeavingContext wContext) {
        //super(null);// at this stage we don't have yet a generatedClassHandler to define to the VM the closures
        this.generatedClassHandler = new GeneratedClassHandler() {
            /**
             * Callback when we need to define a Closure in the JVM
             *
             * @param name
             * @param bytes
             */
            public void acceptClass(String name, byte[] bytes) {
                try {
                    if (shouldDump(name.replace('/', '.'))) {
                        Aj.dump(name, bytes);
                    }
                } catch (Throwable throwable) {
                    throwable.printStackTrace();
                }

                Aj.defineClass(loader, name, bytes);// could be done lazily using the hook
            }
        };

        if(wContext==null){
        	weavingContext = new DefaultWeavingContext(loader);
        }else{
        	weavingContext = wContext ;
        }

        bcelWorld = new BcelWorld(
                loader, messageHandler, new ICrossReferenceHandler() {
================= fetch public void addCrossReference(ISourceLocation from, ISourceLocation to, IRelatio a5ac5af^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java

public void acceptClass(String name, byte[] bytes) {
                try {
                    if (shouldDump(name.replace('/', '.'))) {
                        Aj.dump(name, bytes);
                    }
                } catch (Throwable throwable) {
                    throwable.printStackTrace();
                }

                Aj.defineClass(loader, name, bytes);// could be done lazily using the hook
            }
================= fetch public void addURL(URL url) { a5ac5af^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java
/**
	 * Weave a class using aspects previously supplied to the adaptor.
	 * @param name the name of the class
	 * @param bytes the class bytes
	 * @return the woven bytes
     * @exception IOException weave failed
	 */
public byte[] weaveClass (String name, byte[] bytes) throws IOException {
		if (shouldWeave(name, bytes)) {
            //System.out.println("WeavingAdaptor.weaveClass " + name);
			info("weaving '" + name + "'");
			bytes = getWovenBytes(name, bytes);
		} else if (shouldWeaveAnnotationStyleAspect(name, bytes)) {
            // an @AspectJ aspect needs to be at least munged by the aspectOf munger
            info("weaving '" + name + "'");
            bytes = getAtAspectJAspectBytes(name, bytes);
        }

        return bytes;
	}
================= fetch public void flushGeneratedClasses(){ a5ac5af^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
     * Flush the generated classes cache
     */
public void flushGeneratedClasses(){
    	generatedClasses = new HashMap();
    }
================= fetch public ResolvedMember makeResolvedMember(MethodBinding binding) { 554e733^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

public ResolvedMember makeResolvedMember(MethodBinding binding) {
		return makeResolvedMember(binding, binding.declaringClass);
	}
================= fetch public ResolvedMember makeResolvedMember(MethodBinding binding, TypeBinding decl 554e733^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

public ResolvedMember makeResolvedMember(MethodBinding binding, TypeBinding declaringType) {
		//System.err.println("member for: " + binding + ", " + new String(binding.declaringClass.sourceName));

        // Convert the type variables and store them
		UnresolvedType[] ajTypeRefs = null;
		typeVariablesForThisMember.clear();
		// This is the set of type variables available whilst building the resolved member...
		if (binding.typeVariables!=null) {
			ajTypeRefs = new UnresolvedType[binding.typeVariables.length];
			for (int i = 0; i < binding.typeVariables.length; i++) {
				ajTypeRefs[i] = fromBinding(binding.typeVariables[i]);
				typeVariablesForThisMember.put(new String(binding.typeVariables[i].sourceName),/*new Integer(binding.typeVariables[i].rank),*/ajTypeRefs[i]);
			}
		}
		
		// AMC these next two lines shouldn't be needed once we sort out generic types properly in the world map
		ResolvedType realDeclaringType = world.resolve(fromBinding(declaringType));
		if (realDeclaringType.isRawType()) realDeclaringType = realDeclaringType.getGenericType();
		ResolvedMemberImpl ret =  new ResolvedMemberImpl(
			binding.isConstructor() ? Member.CONSTRUCTOR : Member.METHOD,
			realDeclaringType,
			binding.modifiers,
			fromBinding(binding.returnType),
			new String(binding.selector),
			fromBindings(binding.parameters),
			fromBindings(binding.thrownExceptions)
			);
		if (binding.isVarargs()) {
			ret.setVarargsMethod();
		}
		if (ajTypeRefs!=null) {
			TypeVariable[] tVars = new TypeVariable[ajTypeRefs.length];
			for (int i=0;i<ajTypeRefs.length;i++) {
				tVars[i]=((TypeVariableReference)ajTypeRefs[i]).getTypeVariable();
			}
			ret.setTypeVariables(tVars);
		}
		typeVariablesForThisMember.clear();
		ret.resolve(world);
		return ret;
	}
================= fetch public ResolvedMember makeResolvedMemberForITD(MethodBinding binding,TypeBinding 554e733^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java
/**
	 * Construct a resolvedmember from a methodbinding.  The supplied map tells us about any
	 * typevariablebindings that replaced typevariables whilst the compiler was resolving types - 
	 * this only happens if it is a generic itd that shares type variables with its target type.
	 */
public ResolvedMember makeResolvedMemberForITD(MethodBinding binding,TypeBinding declaringType,
			Map /*TypeVariableBinding > original alias name*/ recoveryAliases) {
		ResolvedMember result = null;
		try {
			typeVariablesForAliasRecovery = recoveryAliases;
			result = makeResolvedMember(binding,declaringType);
		} finally {
			typeVariablesForAliasRecovery = null;			
		}
		return result;
	}
================= fetch public static EclipseShadow makeShadow(EclipseFactory world, ASTNode astNode, 554e733^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java
// --- factory methods
public static EclipseShadow makeShadow(EclipseFactory world, ASTNode astNode, 
							ReferenceContext context)
	{
		//XXX make sure we're getting the correct declaring type at call-site
		if (astNode instanceof AllocationExpression) {
			AllocationExpression e = (AllocationExpression)astNode;
			return new EclipseShadow(world, Shadow.ConstructorCall,
					world.makeResolvedMember(e.binding), astNode, context);
		} else if (astNode instanceof MessageSend) {
			MessageSend e = (MessageSend)astNode;
			if (e.isSuperAccess()) return null;  // super calls don't have shadows
			return new EclipseShadow(world, Shadow.MethodCall,
					world.makeResolvedMember(e.binding), astNode, context);
		} else if (astNode instanceof ExplicitConstructorCall) {
			//??? these should be ignored, they don't have shadows
			return null;				
		} else if (astNode instanceof AbstractMethodDeclaration) {
			AbstractMethodDeclaration e = (AbstractMethodDeclaration)astNode;
			Shadow.Kind kind;
			if (e instanceof AdviceDeclaration) {
				kind = Shadow.AdviceExecution;
			} else if (e instanceof InterTypeMethodDeclaration) {
				return new EclipseShadow(world, Shadow.MethodExecution,
					((InterTypeDeclaration)e).getSignature(), astNode, context);
			} else if (e instanceof InterTypeConstructorDeclaration) {
				return new EclipseShadow(world, Shadow.ConstructorExecution,
					((InterTypeDeclaration)e).getSignature(), astNode, context);
			} else if (e instanceof InterTypeFieldDeclaration) {
				return null;
			} else if (e instanceof MethodDeclaration) {
				kind = Shadow.MethodExecution;
			} else if (e instanceof ConstructorDeclaration) {
				kind = Shadow.ConstructorExecution;
			} else if (e instanceof Clinit) {
				kind = Shadow.StaticInitialization; 
			} else {
				return null;
				//throw new RuntimeException("unimplemented: " + e);
			}
			return new EclipseShadow(world, kind,
					world.makeResolvedMember(e.binding), astNode, context);
		} else if (astNode instanceof TypeDeclaration) {
			return new EclipseShadow(world, Shadow.StaticInitialization,
							new MemberImpl(Member.STATIC_INITIALIZATION, 
								world.fromBinding(((TypeDeclaration)astNode).binding), 0, 
								ResolvedType.VOID, "<clinit>", UnresolvedType.NONE),
							astNode, context);
		} else {
			return null;
			//throw new RuntimeException("unimplemented: " + astNode);
		}		
	}
================= fetch public void testReflectionOfAbstractITDs() { 554e733^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testXlintMessageForImproperAnnotationType_pr115252_MoreThanOne() {runTest("xlint message for more than one improper annotated parameter type");}
================= fetch public InterTypeConstructorDeclarationImpl(AjType<?> decType, 735d94f^:aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/InterTypeConstructorDeclarationImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.lang.reflect.InterTypeConstructorDeclaration#getDeclaredExceptionTypes()
	 */
public AjType<?>[] getExceptionTypes() {
		Class<?>[] baseTypes = baseMethod.getExceptionTypes();
		AjType<?>[] ret = new AjType<?>[baseTypes.length];
		for (int i = 0; i < baseTypes.length; i++) {
			ret[i] = AjTypeSystem.getAjType(baseTypes[i]);
		}
		return ret;
	}
================= fetch public InterTypeMethodDeclaration getDeclaredITDMethod(String name, 735d94f^:aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/AjTypeImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.lang.reflect.AjType#getDeclaredITDMethods()
	 */
public InterTypeMethodDeclaration[] getDeclaredITDMethods() {
		if (this.declaredITDMethods == null) {
			List<InterTypeMethodDeclaration> itdms = new ArrayList<InterTypeMethodDeclaration>();
			Method[] baseMethods = clazz.getDeclaredMethods();
			for (Method m : baseMethods) {
				if (!m.getName().contains("ajc$interMethod$")) continue;
				if (m.isAnnotationPresent(ajcITD.class)) {
					ajcITD ann = m.getAnnotation(ajcITD.class);
					InterTypeMethodDeclaration itdm = 
						new InterTypeMethodDeclarationImpl(
								this,ann.targetType(),ann.modifiers(),
								ann.name(),m);
					itdms.add(itdm);
				}				
			}
			addAnnotationStyleITDMethods(itdms,false);
			this.declaredITDMethods = new InterTypeMethodDeclaration[itdms.size()];
			itdms.toArray(this.declaredITDMethods);
		}
		return this.declaredITDMethods;
	}
================= fetch public Type getGenericReturnType() { 735d94f^:aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/InterTypeMethodDeclarationImpl.java

public AjType<?>[] getExceptionTypes() {
		Class<?>[] baseTypes = baseMethod.getExceptionTypes();
		AjType<?>[] ret = new AjType<?>[baseTypes.length];
		for (int i = 0; i < baseTypes.length; i++) {
			ret[i] = AjTypeSystem.getAjType(baseTypes[i]);
		}
		return ret;
	}
================= fetch public Type getGenericType() { 735d94f^:aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/InterTypeFieldDeclarationImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.lang.reflect.InterTypeFieldDeclaration#getGenericType()
	 */
public Type getGenericType() {
		return this.genericType;
	}
================= fetch public void testPointcutParsingOfCompiledPointcuts() { 735d94f^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testXlintMessageForImproperAnnotationType_pr115252_MoreThanOne() {runTest("xlint message for more than one improper annotated parameter type");}
Progress : [########################----------------] 62%================= fetch public int getColumn() { 9ed75a1^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceLocation.java

public int getColumn() {
        if (-1 == column) {
            int lineNumber = getLine();
            // JJH added check that lineNumber is in legal range to avoid exceptions
            if (0 < lineNumber && lineNumber < result.lineSeparatorPositions.length) {
                int lineStart = result.lineSeparatorPositions[lineNumber];
                int col = startPos - lineStart; // 1-based
                if (0 <= col) { 
                    column = col;
                } else {
                    column = 0;
                }
            }
        }
		return column;
	}
================= fetch public void testNoStackOverflowWithCircularPCDInGenericAspect2() { 9ed75a1^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testXlintMessageForImproperAnnotationType_pr115252_MoreThanOne() {runTest("xlint message for more than one improper annotated parameter type");}
================= fetch IMessageHandler setCustomMessageHandler(IMessageHandler aHandler) { 522911e^:weaver/src/org/aspectj/weaver/tools/PointcutParser.java
/* for testing */
IMessageHandler setCustomMessageHandler(IMessageHandler aHandler) {
    	IMessageHandler current = world.getMessageHandler();
    	world.setMessageHandler(aHandler);
    	return current;
    }
================= fetch private IScope buildResolutionScope(Class inScope, PointcutParameter[] formalPar 522911e^:weaver/src/org/aspectj/weaver/tools/PointcutParser.java

private IScope buildResolutionScope(Class inScope, PointcutParameter[] formalParameters) {
    	if (formalParameters == null) formalParameters = new PointcutParameter[0];
    	FormalBinding[] formalBindings = new FormalBinding[formalParameters.length];
    	for (int i = 0; i < formalBindings.length; i++) {
			formalBindings[i] = new FormalBinding(UnresolvedType.forName(formalParameters[i].getType().getName()),formalParameters[i].getName(),i);			
		}
    	if (inScope == null) {
    		return new SimpleScope(world,formalBindings);
    	} else {
    		ResolvedType inType = world.resolve(inScope.getName());
    		ISourceContext sourceContext = new ISourceContext() {
================= fetch private ReflectionVar(ResolvedType type) { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java

public static ReflectionVar createAtAnnotationVar(ResolvedType annType) {
		ReflectionVar ret = new ReflectionVar(annType);
		ret.varType = AT_ANNOTATION_VAR;
		return ret;
	}
================= fetch private ResolvedMember createGenericConstructorMember(Constructor forConstructor 522911e^:weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java

private ResolvedMember createGenericConstructorMember(Constructor forConstructor) {
		ReflectionBasedResolvedMemberImpl ret = 
		new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.METHOD,
			getResolvedTypeX(),
			forConstructor.getModifiers(),
			getResolvedTypeX(),
			"init",
			fromTypes(forConstructor.getGenericParameterTypes()),
			fromTypes(forConstructor.getGenericExceptionTypes()),
			forConstructor
			);
		return ret;
	}
================= fetch private ResolvedMember createGenericFieldMember(Field forField) { 522911e^:weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java

public ResolvedMember[] getDeclaredPointcuts() {
		if (pointcuts == null) {
			Pointcut[] pcs = this.myType.getDeclaredPointcuts();
			pointcuts = new ResolvedMember[pcs.length];
			PointcutParser parser = new PointcutParser();
			for (int i = 0; i < pcs.length; i++) {
				AjType<?>[] ptypes = pcs[i].getParameterTypes();
				String[] pnames = pcs[i].getParameterNames();
				if (pnames.length != ptypes.length) {
					throw new IllegalStateException("Required parameter names not available when parsing pointcut " + pcs[i].getName() + " in type " + getResolvedTypeX().getName());
				}
				PointcutParameter[] parameters = new PointcutParameter[ptypes.length];
				for (int j = 0; j < parameters.length; j++) {
					parameters[j] = parser.createPointcutParameter(pnames[j],ptypes[j].getJavaClass());
				}
				String pcExpr = pcs[i].getPointcutExpression().toString();
				PointcutExpressionImpl pEx = (PointcutExpressionImpl) parser.parsePointcutExpression(pcExpr,getBaseClass(),parameters);
				org.aspectj.weaver.patterns.Pointcut pc = pEx.getUnderlyingPointcut();
				UnresolvedType[] weaverPTypes = new UnresolvedType[ptypes.length];
				for (int j = 0; j < weaverPTypes.length; j++) {
					weaverPTypes[j] = UnresolvedType.forName(ptypes[j].getName());
				}
				pointcuts[i] = new ResolvedPointcutDefinition(getResolvedTypeX(),pcs[i].getModifiers(),pcs[i].getName(),weaverPTypes,pc);
			}
		}
		return pointcuts;
	}
================= fetch private ResolvedMember createGenericMethodMember(Method forMethod) { 522911e^:weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java

private ResolvedMember createGenericMethodMember(Method forMethod) {
		ReflectionBasedResolvedMemberImpl ret = 
		new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.METHOD,
			getResolvedTypeX(),
			forMethod.getModifiers(),
			fromType(forMethod.getGenericReturnType()),
			forMethod.getName(),
			fromTypes(forMethod.getGenericParameterTypes()),
			fromTypes(forMethod.getGenericExceptionTypes()),
			forMethod
			);
		return ret;
	}
================= fetch private static ReflectionBasedReferenceTypeDelegate create15Delegate(ReferenceTy 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java

private static ReflectionBasedReferenceTypeDelegate create15Delegate(ReferenceType forReferenceType, Class forClass, World inWorld) {
		try {
			Class delegateClass = Class.forName("org.aspectj.weaver.reflect.Java15ReflectionBasedReferenceTypeDelegate");
			ReflectionBasedReferenceTypeDelegate ret = (ReflectionBasedReferenceTypeDelegate) delegateClass.newInstance();
			ret.initialize(forReferenceType,forClass,inWorld);
			return ret;
		} catch (ClassNotFoundException cnfEx) {
			return null;
		} catch (InstantiationException insEx) {
			return null;
		} catch (IllegalAccessException illAccEx) {
			return null;
		}
	}
================= fetch protected ReferenceTypeDelegate resolveDelegate(ReferenceType ty) { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.World#resolveDelegate(org.aspectj.weaver.ReferenceType)
	 */
protected ReferenceTypeDelegate resolveDelegate(ReferenceType ty) {
		return ReflectionBasedReferenceTypeDelegateFactory.createDelegate(ty, this);
	}
================= fetch protected World getWorld() { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.java

protected World getWorld() {
		return this.world;
	}
================= fetch public Java15AnnotationFinder() { 522911e^:weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java

================= fetch public Java15ReflectionBasedReferenceTypeDelegate() {} 522911e^:weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java

================= fetch public Object getAnnotation(ResolvedType annotationType, Object onObject) { 522911e^:weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.reflect.AnnotationFinder#getAnnotation(org.aspectj.weaver.ResolvedType, java.lang.Object)
	 */
public Object getAnnotation(ResolvedType annotationType, Object onObject) {
		try {
			Class annotationClass = Class.forName(annotationType.getName());
			if (onObject.getClass().isAnnotationPresent(annotationClass)) {
				return onObject.getClass().getAnnotation(annotationClass);
			}
		} catch (ClassNotFoundException ex) {
			// just return null
		}
		return null;
	}
================= fetch public Object getAnnotationFromClass(ResolvedType annotationType, Class aClass) 522911e^:weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java

public Object getAnnotationFromClass(ResolvedType annotationType, Class aClass) {
		try {
			Class annotationClass = Class.forName(annotationType.getName());
			if (aClass.isAnnotationPresent(annotationClass)) {
				return aClass.getAnnotation(annotationClass);
			}
		} catch (ClassNotFoundException ex) {
			// just return null
		}
		return null;
	}
================= fetch public Object getAnnotationFromMember(ResolvedType annotationType, Member aMembe 522911e^:weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java

public Object getAnnotationFromMember(ResolvedType annotationType, Member aMember) {
		if (!(aMember instanceof AccessibleObject)) return null;
		AccessibleObject ao = (AccessibleObject) aMember;
		try {
			Class annotationClass = Class.forName(annotationType.getName());
			if (ao.isAnnotationPresent(annotationClass)) {
				return ao.getAnnotation(annotationClass);
			}
		} catch (ClassNotFoundException ex) {
			// just return null
		}
		return null;
	}
================= fetch public PointcutExpression parsePointcutExpression( 522911e^:weaver/src/org/aspectj/weaver/tools/PointcutParser.java
/**
     * Parse the given pointcut expression.
     * The pointcut is resolved as if it had been declared inside the inScope class
     * (this allows the pointcut to contain unqualified references to other pointcuts
     * declared in the same type for example).
     * The pointcut may contain zero or more formal parameters to be bound at matched
     * join points. 
     * @throws UnsupportedPointcutPrimitiveException if the parser encounters a 
     * primitive pointcut expression of a kind not supported by this PointcutParser.
     * @throws IllegalArgumentException if the expression is not a well-formed 
     * pointcut expression
     */
public PointcutExpression parsePointcutExpression(
    		String expression, 
    		Class inScope,
    		PointcutParameter[] formalParameters) 
    throws UnsupportedPointcutPrimitiveException, IllegalArgumentException {
    	 PointcutExpressionImpl pcExpr = null;
         try {
             Pointcut pc = new PatternParser(expression).parsePointcut();
             validateAgainstSupportedPrimitives(pc,expression);
             IScope resolutionScope = buildResolutionScope((inScope == null ? Object.class : inScope),formalParameters);
             pc = pc.resolve(resolutionScope);
             ResolvedType declaringTypeForResolution = null;
             if (inScope != null) {
            	 declaringTypeForResolution = world.resolve(inScope.getName());
             } else {
            	 declaringTypeForResolution = ResolvedType.OBJECT.resolve(world);
             }
             IntMap arity = new IntMap(formalParameters.length);
             for (int i = 0; i < formalParameters.length; i++) {
            	 arity.put(i, i);
             }             
        	 pc = pc.concretize(declaringTypeForResolution, declaringTypeForResolution, arity);
             validateAgainstSupportedPrimitives(pc,expression); // again, because we have now followed any ref'd pcuts
             pcExpr = new PointcutExpressionImpl(pc,expression,formalParameters,world);
         } catch (ParserException pEx) {
             throw new IllegalArgumentException(buildUserMessageFromParserException(expression,pEx));
         } catch (ReflectionWorld.ReflectionWorldException rwEx) {
        	 throw new IllegalArgumentException(rwEx.getMessage());
         }
         return pcExpr;
    }
================= fetch public PointcutParser(Set/*<PointcutPrimitives>*/ supportedPointcutKinds) { 522911e^:weaver/src/org/aspectj/weaver/tools/PointcutParser.java

================= fetch public ReflectionBasedReferenceTypeDelegate() {} 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.java

================= fetch public ReflectionBasedResolvedMemberImpl(Kind kind, 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedResolvedMemberImpl.java

================= fetch public ReflectionShadow(World world, Kind kind, Member signature, Shadow enclosi 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java

public static Shadow makeFieldSetShadow(World inWorld, Field forField, java.lang.reflect.Member inMember) {
		Shadow enclosingShadow = makeExecutionShadow(inWorld,inMember);
		Member signature = ReflectionBasedReferenceTypeDelegateFactory.createResolvedField(forField, inWorld);
		ResolvedMember enclosingMember = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMember(inMember, inWorld);
		ResolvedType enclosingType = enclosingMember.getDeclaringType().resolve(inWorld);
		Kind kind = Shadow.FieldSet;
		return new ReflectionShadow(inWorld,kind,signature,enclosingShadow,enclosingType,enclosingMember);
	}
================= fetch public ReflectionWorld() { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java

================= fetch public ResolvedType getSuperclass() { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.ReferenceTypeDelegate#getSuperclass()
	 */
public ResolvedType getSuperclass() {
		if (this.myClass.getSuperclass() == null) return null;
		return getReflectionWorld().resolve(this.myClass.getSuperclass());
	}
================= fetch public Var getArgAnnotationVar(int i, UnresolvedType forAnnotationType) { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.Shadow#getArgAnnotationVar(int, org.aspectj.weaver.UnresolvedType)
	 */
public Var getArgAnnotationVar(int i, UnresolvedType forAnnotationType) {
		ResolvedType annType = forAnnotationType.resolve(world);
		if (atArgsVars.get(annType) == null) {
			Var[] vars = new Var[getArgCount()];
			atArgsVars.put(annType,vars);
		}
		Var[] vars = (Var[]) atArgsVars.get(annType);
		if (i > (vars.length - 1) ) return null;
		if (vars[i] == null) {
			vars[i] = ReflectionVar.createArgsAnnotationVar(annType, i);
		}
		return vars[i];
	}
================= fetch public Var getArgVar(int i) { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.Shadow#getArgVar(int)
	 */
public Var getArgVar(int i) {
		if (argsVars == null) {
			this.argsVars = new Var[this.getArgCount()];
			for (int j = 0; j < this.argsVars.length; j++) {
				this.argsVars[j] = ReflectionVar.createArgsVar(getArgType(j).resolve(world), j);
			}
		}
		if (i < argsVars.length) {
			return argsVars[i];
		} else {
			return null;
		}
	}
================= fetch public Var getKindedAnnotationVar(UnresolvedType forAnnotationType) { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.Shadow#getKindedAnnotationVar(org.aspectj.weaver.UnresolvedType)
	 */
public Var getKindedAnnotationVar(UnresolvedType forAnnotationType) {
		ResolvedType annType = forAnnotationType.resolve(world);
		if (annotationVar.get(annType) == null) {
			Var v = ReflectionVar.createAtAnnotationVar(annType);
			annotationVar.put(annType,v);
		}
		return (Var) annotationVar.get(annType);
	}
================= fetch public Var getTargetAnnotationVar(UnresolvedType forAnnotationType) { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.Shadow#getTargetAnnotationVar(org.aspectj.weaver.UnresolvedType)
	 */
public Var getTargetAnnotationVar(UnresolvedType forAnnotationType) {
		if (atTargetVar == null) {
			atTargetVar = ReflectionVar.createTargetAnnotationVar(forAnnotationType.resolve(world));
		}
		return atTargetVar;
	}
================= fetch public Var getTargetVar() { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.Shadow#getTargetVar()
	 */
public Var getTargetVar() {
		if (targetVar == null && hasTarget()) {
			targetVar = ReflectionVar.createTargetVar(getThisType().resolve(world));
		}
		return targetVar;
	}
================= fetch public Var getThisAnnotationVar(UnresolvedType forAnnotationType) { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.Shadow#getThisAnnotationVar(org.aspectj.weaver.UnresolvedType)
	 */
public Var getThisAnnotationVar(UnresolvedType forAnnotationType) {
		if (atThisVar == null) {
			atThisVar = ReflectionVar.createThisAnnotationVar(forAnnotationType.resolve(world));
		}
		return atThisVar;
	}
================= fetch public Var getThisVar() { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.Shadow#getThisVar()
	 */
public Var getThisVar() {
		if (thisVar == null && hasThis()) {
			thisVar = ReflectionVar.createThisVar(getThisType().resolve(world));
		}
		return thisVar;
	}
================= fetch public Var getWithinAnnotationVar(UnresolvedType forAnnotationType) { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.Shadow#getWithinAnnotationVar(org.aspectj.weaver.UnresolvedType)
	 */
public Var getWithinAnnotationVar(UnresolvedType forAnnotationType) {
		ResolvedType annType = forAnnotationType.resolve(world);
		if (withinAnnotationVar.get(annType) == null) {
			Var v = ReflectionVar.createWithinAnnotationVar(annType);
			withinAnnotationVar.put(annType,v);
		}
		return (Var) withinAnnotationVar.get(annType);
	}
================= fetch public Var getWithinCodeAnnotationVar(UnresolvedType forAnnotationType) { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.Shadow#getWithinCodeAnnotationVar(org.aspectj.weaver.UnresolvedType)
	 */
public Var getWithinCodeAnnotationVar(UnresolvedType forAnnotationType) {
		ResolvedType annType = forAnnotationType.resolve(world);
		if (withinCodeAnnotationVar.get(annType) == null) {
			Var v = ReflectionVar.createWithinCodeAnnotationVar(annType);
			withinCodeAnnotationVar.put(annType,v);
		}
		return (Var) withinCodeAnnotationVar.get(annType);
	}
================= fetch public boolean hasAnnotation(UnresolvedType ofType) { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.ReferenceTypeDelegate#getTypeVariables()
	 */
public TypeVariable[] getTypeVariables() {
		// no type variables in Java 1.4
		return new TypeVariable[0];
	}
================= fetch public boolean isAnnotationStyleAspect(String name, byte[] bytes) { 522911e^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java
/**
     * Checks if given bytecode is an @AspectJ aspect
     *
     * @param name
     * @param bytes
     * @return true if so
     */
public boolean isAnnotationStyleAspect(String name, byte[] bytes) {
        try {
            ClassParser cp = new ClassParser(new ByteArrayInputStream(bytes), null);
            JavaClass jc = cp.parse();
            if (!jc.isClass()) {
                return false;
            }
            Annotation anns[] = jc.getAnnotations();
            if (anns.length == 0) {
                return false;
            }
            for (int i = 0; i < anns.length; i++) {
                Annotation ann = anns[i];
                if ("Lorg/aspectj/lang/annotation/Aspect;".equals(ann.getTypeSignature())) {
                    return true;
                }
            }
            return false;
        } catch (IOException e) {
            // assume it is one as a best effort
            return true;
        }
    }
================= fetch public static ReflectionVar createArgsAnnotationVar(ResolvedType type, int index 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java

public static ReflectionVar createArgsAnnotationVar(ResolvedType type, int index) {
		ReflectionVar ret = new ReflectionVar(type);
		ret.varType = AT_ARGS_VAR;
		ret.argsIndex = index;
		return ret;		
	}
================= fetch public static ReflectionVar createArgsVar(ResolvedType type, int index) { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java

public static ReflectionVar createArgsVar(ResolvedType type, int index) {
		ReflectionVar ret = new ReflectionVar(type);
		ret.varType = ARGS_VAR;
		ret.argsIndex = index;
		return ret;		
	}
================= fetch public static ReflectionVar createAtAnnotationVar(ResolvedType annType) { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java

public static ReflectionVar createAtAnnotationVar(ResolvedType annType) {
		ReflectionVar ret = new ReflectionVar(annType);
		ret.varType = AT_ANNOTATION_VAR;
		return ret;
	}
================= fetch public static ReflectionVar createTargetAnnotationVar(ResolvedType type) { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java

public static ReflectionVar createTargetAnnotationVar(ResolvedType type) {
		ReflectionVar ret = new ReflectionVar(type);
		ret.varType = AT_TARGET_VAR;
		return ret;		
	}
================= fetch public static ReflectionVar createTargetVar(ResolvedType type) { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java

public static ReflectionVar createTargetVar(ResolvedType type) {
		ReflectionVar ret = new ReflectionVar(type);
		ret.varType = TARGET_VAR;
		return ret;		
	}
================= fetch public static ReflectionVar createThisAnnotationVar(ResolvedType type) { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java

public static ReflectionVar createThisAnnotationVar(ResolvedType type) {
		ReflectionVar ret = new ReflectionVar(type);
		ret.varType = AT_THIS_VAR;
		return ret;
	}
================= fetch public static ReflectionVar createThisVar(ResolvedType type) { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java

public static ReflectionVar createThisVar(ResolvedType type) {
		ReflectionVar ret = new ReflectionVar(type);
		ret.varType = THIS_VAR;
		return ret;
	}
================= fetch public static ReflectionVar createWithinAnnotationVar(ResolvedType annType) { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java

public static ReflectionVar createWithinAnnotationVar(ResolvedType annType) {
		ReflectionVar ret = new ReflectionVar(annType);
		ret.varType = AT_WITHIN_VAR;
		return ret;
	}
================= fetch public static ReflectionVar createWithinCodeAnnotationVar(ResolvedType annType) 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java

public static ReflectionVar createWithinCodeAnnotationVar(ResolvedType annType) {
		ReflectionVar ret = new ReflectionVar(annType);
		ret.varType = AT_WITHINCODE_VAR;
		return ret;
	}
================= fetch public static ResolvedMember createHandlerMember(Class exceptionType, Class inTy 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java

public static ResolvedMember createHandlerMember(Class exceptionType, Class inType,World inWorld) {
		return new ResolvedMemberImpl(
				org.aspectj.weaver.Member.HANDLER,
				toResolvedType(inType,(ReflectionWorld)inWorld),
				Modifier.STATIC,
				"<catch>",
				"(" + inWorld.resolve(exceptionType.getName()).getSignature() + ")V");
	}
================= fetch public static ResolvedMember createResolvedAdviceMember(Method aMethod, World in 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java

public static ResolvedMember createResolvedAdviceMember(Method aMethod, World inWorld) {
		return new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.ADVICE,
				toResolvedType(aMethod.getDeclaringClass(),(ReflectionWorld)inWorld),
				aMethod.getModifiers(),
				toResolvedType(aMethod.getReturnType(),(ReflectionWorld)inWorld),
				aMethod.getName(),
				toResolvedTypeArray(aMethod.getParameterTypes(),inWorld),
				toResolvedTypeArray(aMethod.getExceptionTypes(),inWorld),
				aMethod
				);
	}
================= fetch public static ResolvedMember createResolvedConstructor(Constructor aConstructor, 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java

public static ResolvedMember createResolvedConstructor(Constructor aConstructor, World inWorld) {
		return new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.CONSTRUCTOR,
				toResolvedType(aConstructor.getDeclaringClass(),(ReflectionWorld)inWorld),
				aConstructor.getModifiers(),
				toResolvedType(aConstructor.getDeclaringClass(),(ReflectionWorld)inWorld),
				"init",
				toResolvedTypeArray(aConstructor.getParameterTypes(),inWorld),
				toResolvedTypeArray(aConstructor.getExceptionTypes(),inWorld),
				aConstructor
				);
	}
================= fetch public static ResolvedMember createResolvedField(Field aField, World inWorld) { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java

public static ResolvedMember createResolvedField(Field aField, World inWorld) {
		return new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.FIELD,
				toResolvedType(aField.getDeclaringClass(),(ReflectionWorld)inWorld),
				aField.getModifiers(),
				toResolvedType(aField.getType(),(ReflectionWorld)inWorld),
				aField.getName(),
				new UnresolvedType[0],
				aField);
	}
================= fetch public static ResolvedMember createResolvedMethod(Method aMethod, World inWorld) 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java

public static ResolvedMember createResolvedMethod(Method aMethod, World inWorld) {
		ReflectionBasedResolvedMemberImpl ret = new ReflectionBasedResolvedMemberImpl(org.aspectj.weaver.Member.METHOD,
				toResolvedType(aMethod.getDeclaringClass(),(ReflectionWorld)inWorld),
				aMethod.getModifiers(),
				toResolvedType(aMethod.getReturnType(),(ReflectionWorld)inWorld),
				aMethod.getName(),
				toResolvedTypeArray(aMethod.getParameterTypes(),inWorld),
				toResolvedTypeArray(aMethod.getExceptionTypes(),inWorld),
				aMethod
				);
		return ret;
	}
================= fetch public static Test suite() { 522911e^:weaver/testsrc/org/aspectj/weaver/tools/ToolsTests.java

public static Test suite() {
		TestSuite suite = new TestSuite("Test for org.aspectj.weaver.tools");
		//$JUnit-BEGIN$
		suite.addTestSuite(PointcutParserTest.class);
		suite.addTestSuite(PointcutExpressionTest.class);
		//$JUnit-END$
		return suite;
	}
================= fetch public static void main(String[] args) throws Exception { 522911e^:tests/java5/ataspectj/annotationGen/RuntimePointcuts.java

public static void main(String[] args) throws Exception {
		PointcutParser parser = new PointcutParser();
		PointcutExpression pc1 = parser.parsePointcutExpression("PCLib.anyMethodExecution()");
		PointcutParameter param = parser.createPointcutParameter("s",String.class);
		PointcutExpression pc2 = parser.parsePointcutExpression("PCLib.joinPointWithStringArg(s)",RuntimePointcuts.class,new PointcutParameter[] {param});
		Method foo = RuntimePointcuts.class.getDeclaredMethod("foo", new Class[0]);
		Method bar = RuntimePointcuts.class.getDeclaredMethod("bar",new Class[] {String.class});
		ShadowMatch fooMatch1 = pc1.matchesMethodExecution(foo);
		if (!fooMatch1.alwaysMatches()) throw new RuntimeException("fooMatch1 should always match");
		ShadowMatch fooMatch2 = pc2.matchesMethodExecution(foo);
		if (!fooMatch2.neverMatches()) throw new RuntimeException("fooMatch2 should never match");
		ShadowMatch barMatch1 = pc1.matchesMethodExecution(bar);
		if (!barMatch1.alwaysMatches()) throw new RuntimeException("barMatch1 should always match");
		ShadowMatch barMatch2 = pc2.matchesMethodExecution(bar);
		if (!barMatch2.alwaysMatches()) throw new RuntimeException("barMatch2 should always match");
		JoinPointMatch jpm = barMatch2.matchesJoinPoint(new Object(),new Object(),new Object[] {"hello"});
		if (!jpm.matches()) throw new RuntimeException("should match at join point");
		if (!jpm.getParameterBindings()[0].getBinding().toString().equals("hello"))
			throw new RuntimeException("expecting s to be bound to hello");		
	}
================= fetch public void initialize(ReferenceType aType, Class aClass, World aWorld) { 522911e^:weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.java

public void initialize(ReferenceType aType, Class aClass, World aWorld) {
		this.myClass = aClass;
		this.resolvedType = aType;
		this.world = aWorld;
	}
================= fetch public void initialize(ReferenceType aType, Class aClass, World aWorld) { 522911e^:weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java

public void initialize(ReferenceType aType, Class aClass, World aWorld) {
		super.initialize(aType, aClass, aWorld);
		myType = AjTypeSystem.getAjType(aClass);
	}
================= fetch public void testFormals() { 522911e^:weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java

public void testFormals() {
		PointcutParser parser = new PointcutParser();
		PointcutParameter param = parser.createPointcutParameter("x",String.class);
		PointcutExpression pc = parser.parsePointcutExpression("args(x)", null, new PointcutParameter[] {param} );
		assertEquals("args(x)",pc.getPointcutExpression());
		
		try {
			pc = parser.parsePointcutExpression("args(String)", null, new PointcutParameter[] {param} );
			fail("Expecting IllegalArgumentException");
		} catch (IllegalArgumentException ex) {
			assertTrue("formal unbound",ex.getMessage().indexOf("formal unbound") != -1);
		}
		
		try {
			pc = parser.parsePointcutExpression("args(y)");
			fail("Expecting IllegalArgumentException");
		} catch(IllegalArgumentException ex) {
			assertTrue("no match for type name",ex.getMessage().indexOf("warning no match for this type name: y") != -1);
		}
	}
================= fetch public void testNoStackOverflowWithCircularPCDInGenericAspect2() { 522911e^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testXlintMessageForImproperAnnotationType_pr115252_MoreThanOne() {runTest("xlint message for more than one improper annotated parameter type");}
================= fetch public FuzzyBoolean matches(AnnotatedElement annotated) { 557f5b4^:weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.AnnotationTypePattern#matches(org.aspectj.weaver.AnnotatedElement)
	 */
public FuzzyBoolean matches(AnnotatedElement annotated) {
		if (!resolved) {
			throw new IllegalStateException("Can't match on an unresolved annotation type pattern");
		}
		// matches if the type of any of the annotations on the AnnotatedElement is
		// matched by the typePattern.
		ResolvedType[] annTypes = annotated.getAnnotationTypes();
		for (int i = 0; i < annTypes.length; i++) {
			if (typePattern.matches(annTypes[i],TypePattern.STATIC).alwaysTrue()) {
				return FuzzyBoolean.YES;
			}
		}
		return FuzzyBoolean.NO;
	}
================= fetch public static ResolvedMember checkForOverride(ResolvedType typeToCheck,String mn dd9a9b2^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
     * This method recurses up a specified type looking for a method that overrides the one passed in.
     * 
     * @return the method being overridden or null if none is found
     */
public static ResolvedMember checkForOverride(ResolvedType typeToCheck,String mname,String mparams,String mrettype,int mmods,String mpkg,UnresolvedType[] methodParamsArray) {

    	if (typeToCheck==null) return null;
    	if (typeToCheck instanceof MissingResolvedTypeWithKnownSignature) return null; // we just can't tell !
    	
    	if (debug) System.err.println("  Checking for override of "+mname+" in "+typeToCheck);
    	
    	String packageName = typeToCheck.getPackageName();
    	if (packageName==null) packageName="";
    	boolean inSamePackage = packageName.equals(mpkg); // used when looking at visibility rules
    	
    	ResolvedMember [] methods = typeToCheck.getDeclaredMethods();
    	for (int ii=0;ii<methods.length;ii++) {
			ResolvedMember methodThatMightBeGettingOverridden = methods[ii]; // the method we are going to check			
			ResolvedMember isOverriding = isOverriding(typeToCheck,methodThatMightBeGettingOverridden,mname,mrettype,mmods,inSamePackage,methodParamsArray);
			if (isOverriding!=null) return isOverriding;
		}
		List l = typeToCheck.getInterTypeMungers();
		for (Iterator iterator = l.iterator(); iterator.hasNext();) {
			BcelTypeMunger element = (BcelTypeMunger) iterator.next();
			if (element.getMunger() instanceof NewMethodTypeMunger) {
				if (debug) System.err.println("Possible ITD candidate "+element);
				ResolvedMember aMethod = element.getSignature();
				ResolvedMember isOverriding = isOverriding(typeToCheck,aMethod,mname,mrettype,mmods,inSamePackage,methodParamsArray);
				if (isOverriding!=null) return isOverriding;
			}
		}
		
		
		if (typeToCheck.equals(UnresolvedType.OBJECT)) return null; 
		
	    ResolvedType superclass = typeToCheck.getSuperclass();
		ResolvedMember overriddenMethod = checkForOverride(superclass,mname,mparams,mrettype,mmods,mpkg,methodParamsArray);
		if (overriddenMethod!=null) return overriddenMethod;
	    
		ResolvedType[] interfaces = typeToCheck.getDeclaredInterfaces();
		for (int i = 0; i < interfaces.length; i++) {
			ResolvedType anInterface = interfaces[i];
			overriddenMethod = checkForOverride(anInterface,mname,mparams,mrettype,mmods,mpkg,methodParamsArray);
			if (overriddenMethod!=null) return overriddenMethod;
		}
		return null;
    }
================= fetch public WeavingClassFileProvider (String name, byte[] bytes) { c760895^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java

public void dontIgnore (IMessage.Kind kind) {
			if (null != kind) {
				ignoring.remove(kind);
			}
		}
================= fetch public boolean isApplyAtAspectJMungersOnly() { c760895^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java

public byte[] getBytes () {
			return wovenClass.getBytes();
		}
================= fetch public void dontIgnore (IMessage.Kind kind) { c760895^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java
/**
		 * Remove a message kind from the list of those ignored from now on.
		 */
public void dontIgnore (IMessage.Kind kind) {
			if (null != kind) {
				ignoring.remove(kind);
			}
		}
================= fetch public void testNoStackOverflowWithCircularPCDInGenericAspect2() { c760895^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testNoStackOverflowWithCircularPCDInGenericAspect2() {
	  runTest("no StackOverflowError with circular pcd in generic aspect - 2");
  }
================= fetch private DocumentParser() { fabf159^:loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java

================= fetch public static Definition parse(final URL url) throws Exception { fabf159^:loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java

public static Definition parse(final URL url) throws Exception {
        InputStream in = null;
        try {
            DocumentParser parser = new DocumentParser();

            XMLReader xmlReader = SAXParserFactory.newInstance().newSAXParser().getXMLReader();
            xmlReader.setContentHandler(parser);
            xmlReader.setErrorHandler(parser);

            try {
                xmlReader.setFeature("http://xml.org/sax/features/validation", false);
            } catch (SAXException e) {
                ;//fine, the parser don't do validation
            }
            try {
                xmlReader.setFeature("http://xml.org/sax/features/external-general-entities", false);
            } catch (SAXException e) {
                ;//fine, the parser don't do validation
            }
            try {
                xmlReader.setFeature("http://xml.org/sax/features/external-parameter-entities", false);
            } catch (SAXException e) {
                ;//fine, the parser don't do validation
            }


            xmlReader.setEntityResolver(parser);
            in = url.openStream();
            xmlReader.parse(new InputSource(in));
            return parser.m_definition;
        } finally {
            try {
                in.close();
            } catch (Throwable t) {
                ;
            }
        }
    }
Progress : [#########################---------------] 63%================= fetch private void warnOnConfusingSig(Shadow shadow) { 676aa08^:weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java
//	}
private void warnOnConfusingSig(Shadow shadow) {
		// Don't do all this processing if we don't need to !
		if (!shadow.getIWorld().getLint().unmatchedSuperTypeInCall.isEnabled()) return;
		
        // no warnings for declare error/warning
        if (munger instanceof Checker) return;
        
        World world = shadow.getIWorld();
        
		// warning never needed if the declaring type is any
		UnresolvedType exactDeclaringType = signature.getDeclaringType().getExactType();
        
		ResolvedType shadowDeclaringType =
			shadow.getSignature().getDeclaringType().resolve(world);
        
		if (signature.getDeclaringType().isStar()
			|| exactDeclaringType== ResolvedType.MISSING)
			return;

        // warning not needed if match type couldn't ever be the declaring type
		if (!shadowDeclaringType.isAssignableFrom(exactDeclaringType.resolve(world))) {
            return;
		}

		// if the method in the declaring type is *not* visible to the
		// exact declaring type then warning not needed.
		int shadowModifiers = shadow.getSignature().resolve(world).getModifiers();
		if (!ResolvedType
			.isVisible(
				shadowModifiers,
				shadowDeclaringType,
				exactDeclaringType.resolve(world))) {
			return;
		}
		
		if (!signature.getReturnType().matchesStatically(shadow.getSignature().getReturnType().resolve(world))) {
			// Covariance issue...
			// The reason we didn't match is that the type pattern for the pointcut (Car) doesn't match the
			// return type for the specific declaration at the shadow. (FastCar Sub.getCar())
			// XXX Put out another XLINT in this case?
			return;
		}
		// PR60015 - Don't report the warning if the declaring type is object and 'this' is an interface
		if (exactDeclaringType.resolve(world).isInterface() && shadowDeclaringType.equals(world.resolve("java.lang.Object"))) {
			return;
		}

		SignaturePattern nonConfusingPattern =
			new SignaturePattern(
				signature.getKind(),
				signature.getModifiers(),
				signature.getReturnType(),
				TypePattern.ANY,
				signature.getName(), 
				signature.getParameterTypes(),
				signature.getThrowsPattern(),
				signature.getAnnotationPattern());

		if (nonConfusingPattern
			.matches(shadow.getSignature(), shadow.getIWorld(),true)) {
                shadow.getIWorld().getLint().unmatchedSuperTypeInCall.signal(
                    new String[] {
                        shadow.getSignature().getDeclaringType().toString(),
                        signature.getDeclaringType().toString()
                    },
                    this.getSourceLocation(),
                    new ISourceLocation[] {shadow.getSourceLocation()} );               
		}
	}
================= fetch public Pointcut concretize1(ResolvedType searchStart, ResolvedType declaringType 4b8bed7^:weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java
// and not one in a subtype that happens to have the same name.
public Pointcut concretize1(ResolvedType searchStart, ResolvedType declaringType, IntMap bindings) {
		if (concretizing) {
			//Thread.currentThread().dumpStack();
			searchStart.getWorld().getMessageHandler().handleMessage(
				MessageUtil.error(WeaverMessages.format(WeaverMessages.CIRCULAR_POINTCUT,this),
									getSourceLocation()));
			return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
		}
		
		try {
			concretizing = true;
		
			ResolvedPointcutDefinition pointcutDec;
			if (onType != null) {
				searchStart = onType.resolve(searchStart.getWorld());
				if (searchStart == ResolvedType.MISSING) {
					return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
				}
			}
			
			if (declaringType == null) declaringType = searchStart;
			pointcutDec = declaringType.findPointcut(name);
			boolean foundMatchingPointcut = (pointcutDec != null && pointcutDec.isPrivate());
			if (!foundMatchingPointcut) {				
				pointcutDec = searchStart.findPointcut(name);
				if (pointcutDec == null) {
					searchStart.getWorld().getMessageHandler().handleMessage(
						MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_FIND_POINTCUT,name,searchStart.getName()), 
										getSourceLocation())
					);
					return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
				}
			}
			
			if (pointcutDec.isAbstract()) {
				//Thread.currentThread().dumpStack();
				ShadowMunger enclosingAdvice = bindings.getEnclosingAdvice();
				searchStart.getWorld().showMessage(IMessage.ERROR,
						WeaverMessages.format(WeaverMessages.ABSTRACT_POINTCUT,pointcutDec), 
						getSourceLocation(), 
						(null == enclosingAdvice) ? null : enclosingAdvice.getSourceLocation());
				return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
			}
					
			//System.err.println("start: " + searchStart);
			ResolvedType[] parameterTypes = searchStart.getWorld().resolve(pointcutDec.getParameterTypes());
			
			TypePatternList arguments = this.arguments.resolveReferences(bindings);
			
			IntMap newBindings = new IntMap();
			for (int i=0,len=arguments.size(); i < len; i++) {
				TypePattern p = arguments.get(i);
				if (p == TypePattern.NO) continue;
				// we are allowed to bind to pointcuts which use subtypes as this is type safe
				// this will be checked in ReferencePointcut.resolveBindings().  Can't check it here
				// as we don't know about any new parents added via decp.
			    if (p instanceof BindingTypePattern) {
			    	newBindings.put(i, ((BindingTypePattern)p).getFormalIndex());
			    }
			}

			if (searchStart.isParameterizedType()) {
				// build a type map mapping type variable names in the generic type to
				// the type parameters presented
				typeVariableMap = new HashMap();
				ResolvedType underlyingGenericType = searchStart.getGenericType();
				TypeVariable[] tVars = underlyingGenericType.getTypeVariables();
				ResolvedType[] typeParams = searchStart.getResolvedTypeParameters();
				for (int i = 0; i < tVars.length; i++) {
					typeVariableMap.put(tVars[i].getName(),typeParams[i]);
				}
			}
			
			newBindings.copyContext(bindings);
			newBindings.pushEnclosingDefinition(pointcutDec);
			try {
				Pointcut ret = pointcutDec.getPointcut();
				if (typeVariableMap != null) ret = ret.parameterizeWith(typeVariableMap);
				return ret.concretize(searchStart, declaringType, newBindings);
			} finally {
				newBindings.popEnclosingDefinitition();
			}
			
		} finally {
			concretizing = false;
		}
	}
================= fetch public State(String name, int key) { 4b8bed7^:weaver/src/org/aspectj/weaver/patterns/Pointcut.java

================= fetch public void testNoVerifyErrorWithTwoArgsPCDs_pr113447() { 4b8bed7^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testNoVerifyErrorWithTwoArgsPCDs_pr113447() {
	  runTest("no verify error with two args pcds");
  }
================= fetch private void fixupGenericSignatureAttribute () { d7d5947^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java
/**
     * When working with 1.5 generics, a signature attribute is attached to the type which indicates
     * how it was declared.  This routine ensures the signature attribute for what we are about
     * to write out is correct.  Basically its responsibilities are:
     *   1. Checking whether the attribute needs changing (i.e. did weaving change the type hierarchy)
     *   2. If it did, removing the old attribute
     *   3. Check if we need an attribute at all, are we generic? are our supertypes parameterized/generic?
     *   4. Build the new attribute which includes all typevariable, supertype and superinterface information
     */
private void fixupGenericSignatureAttribute () {
		
		if (getWorld() != null && !getWorld().isInJava5Mode()) return;
		
		// TODO asc generics Temporarily assume that types we generate dont need a signature attribute (closure/etc).. will need revisiting no doubt...
		if (myType==null) return;
			
		// 1. Has anything changed that would require us to modify this attribute?
		if (!regenerateGenericSignatureAttribute) return;
		
		// 2. Find the old attribute
		Signature sigAttr = null;
		if (myType!=null) { // if null, this is a type built from scratch, it won't already have a sig attribute
			Attribute[] as = myGen.getAttributes();
			for (int i = 0; i < as.length; i++) {
				Attribute attribute = as[i];
				if (attribute.getName().equals("Signature")) sigAttr = (Signature)attribute;
			}
		}
		
		// 3. Do we need an attribute?
		boolean needAttribute = false;
		if (sigAttr!=null) needAttribute = true; // If we had one before, we definetly still need one as types can't be 'removed' from the hierarchy
		
		// check the interfaces
		if (!needAttribute) {
			if (myType==null) {
				boolean stop = true;
			}
			ResolvedType[] interfaceRTXs = myType.getDeclaredInterfaces();
			for (int i = 0; i < interfaceRTXs.length; i++) {
				ResolvedType typeX = interfaceRTXs[i];
				if (typeX.isGenericType() || typeX.isParameterizedType())  needAttribute = true;
			}
		
			// check the supertype
			ResolvedType superclassRTX = myType.getSuperclass();
			if (superclassRTX.isGenericType() || superclassRTX.isParameterizedType()) needAttribute = true;
		}
		
		if (needAttribute) {
			StringBuffer signature = new StringBuffer();
			// first, the type variables...
			TypeVariable[] tVars = myType.getTypeVariables();
			if (tVars.length>0) {
				signature.append("<");
				for (int i = 0; i < tVars.length; i++) {
					TypeVariable variable = tVars[i];
					if (i!=0) signature.append(",");
					signature.append(variable.getSignature());
				}
				signature.append(">");
			}
			// now the supertype
			signature.append(myType.getSuperclass().getSignature());
			ResolvedType[] interfaceRTXs = myType.getDeclaredInterfaces();
			for (int i = 0; i < interfaceRTXs.length; i++) {
				String s = interfaceRTXs[i].getSignatureForAttribute();
				signature.append(s);
			}
			myGen.addAttribute(createSignatureAttribute(signature.toString()));
		}
		
		// TODO asc generics The 'old' signature is left in the constant pool - I wonder how safe it would be to 
		// remove it since we don't know what else (if anything) is referring to it
	}
================= fetch public void testAdviceExecutionJPToStringForms() { 7a1002a^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testAdviceExecutionJPToStringForms() {
	  runTest("adviceexecution join point toString forms");
  }
================= fetch public String checkRtJar(AjBuildConfig buildConfig) { 1f51499^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/**
	 * This will return null if aspectjrt.jar is present and has the correct version.
	 * Otherwise it will return a string message indicating the problem.
	 */
public String checkRtJar(AjBuildConfig buildConfig) {
        // omitting dev info
		if (Version.text.equals(Version.DEVELOPMENT)) {
			// in the development version we can't do this test usefully
//			MessageUtil.info(holder, "running development version of aspectj compiler");
			return null;
		}
		
		if (buildConfig == null || buildConfig.getFullClasspath() == null) return "no classpath specified";
		for (Iterator it = buildConfig.getFullClasspath().iterator(); it.hasNext(); ) {
			File p = new File( (String)it.next() );
			if (p.isFile() && p.getName().equals("aspectjrt.jar")) {

				try {
                    String version = null;
                    Manifest manifest = new JarFile(p).getManifest();
                    if (manifest == null) {
                    	return "no manifest found in " + p.getAbsolutePath() + 
								", expected " + Version.text;
                    }
                    Attributes attr = manifest.getAttributes("org/aspectj/lang/");
                    if (null != attr) {
                        version = attr.getValue(Attributes.Name.IMPLEMENTATION_VERSION);
                        if (null != version) {
                            version = version.trim();
                        }
                    }
					// assume that users of development aspectjrt.jar know what they're doing
					if (Version.DEVELOPMENT.equals(version)) {
//						MessageUtil.info(holder,
//							"running with development version of aspectjrt.jar in " + 
//							p.getAbsolutePath());
                        return null;
					} else if (!Version.text.equals(version)) {
						return "bad version number found in " + p.getAbsolutePath() + 
								" expected " + Version.text + " found " + version;
					}
				} catch (IOException ioe) {
					return "bad jar file found in " + p.getAbsolutePath() + " error: " + ioe;
				}
				return null;
			} else {
				// might want to catch other classpath errors
			}
		}
		
		return "couldn't find aspectjrt.jar on classpath, checked: " + makeClasspathString(buildConfig);
	}
================= fetch private boolean mungeNewField(BcelClassWeaver weaver, NewFieldTypeMunger munger) d9757d7^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java

private boolean mungeNewField(BcelClassWeaver weaver, NewFieldTypeMunger munger) {
		/*ResolvedMember initMethod = */munger.getInitMethod(aspectType);
		
		LazyClassGen gen = weaver.getLazyClassGen();
		ResolvedMember field = munger.getSignature();
		
		
		ResolvedType onType = weaver.getWorld().resolve(field.getDeclaringType(),munger.getSourceLocation());
		if (onType.isRawType()) onType = onType.getGenericType();

		boolean onInterface = onType.isInterface();
		
		if (onType.isAnnotation()) {
			signalError(WeaverMessages.ITDF_ON_ANNOTATION_NOT_ALLOWED,weaver,onType);
			return false;
		}
		
		if (onType.isEnum()) {
			signalError(WeaverMessages.ITDF_ON_ENUM_NOT_ALLOWED,weaver,onType);
			return false;
		}
		
		
		ResolvedMember interMethodBody = munger.getInitMethod(aspectType);
		
		AnnotationX annotationsOnRealMember[] = null;
		// pr98901
	    // For copying the annotations across, we have to discover the real member in the aspect
	    // which is holding them.
		if (weaver.getWorld().isInJava5Mode()){
				// the below line just gets the method with the same name in aspectType.getDeclaredMethods();
				ResolvedType toLookOn = aspectType;
				if (aspectType.isRawType()) toLookOn = aspectType.getGenericType();
				ResolvedMember realMember = getRealMemberForITDFromAspect(toLookOn,interMethodBody,false);
				if (realMember==null) throw new BCException("Couldn't find ITD init member '"+
						interMethodBody+"' on aspect "+aspectType);
				annotationsOnRealMember = realMember.getAnnotations();
		}
		
		if (onType.equals(gen.getType())) {
			if (onInterface) {
				ResolvedMember itdfieldGetter = AjcMemberMaker.interFieldInterfaceGetter(field, onType, aspectType);
				LazyMethodGen mg = makeMethodGen(gen, itdfieldGetter);
				gen.addMethodGen(mg);
				
				LazyMethodGen mg1 = makeMethodGen(gen, 
					AjcMemberMaker.interFieldInterfaceSetter(field, onType, aspectType));
				gen.addMethodGen(mg1);
			} else {
				weaver.addInitializer(this);
				FieldGen fg = makeFieldGen(gen,
					AjcMemberMaker.interFieldClassField(field, aspectType));
				
				if (annotationsOnRealMember!=null) {
					for (int i = 0; i < annotationsOnRealMember.length; i++) {
						AnnotationX annotationX = annotationsOnRealMember[i];
						Annotation a = annotationX.getBcelAnnotation();
						AnnotationGen ag = new AnnotationGen(a,weaver.getLazyClassGen().getConstantPoolGen(),true);	
						fg.addAnnotation(ag);
					}
				}
				
				gen.addField(fg.getField(),getSourceLocation());
	    		
			}
    		return true;
		} else if (onInterface && gen.getType().isTopmostImplementor(onType)) {
			// wew know that we can't be static since we don't allow statics on interfaces
			if (field.isStatic()) throw new RuntimeException("unimplemented");
			weaver.addInitializer(this);
			//System.err.println("impl body on " + gen.getType() + " for " + munger);
			Type fieldType = 	BcelWorld.makeBcelType(field.getType());

			FieldGen fg = makeFieldGen(gen,AjcMemberMaker.interFieldInterfaceField(field, onType, aspectType));
	    	gen.addField(fg.getField(),getSourceLocation());
			
	    	//this uses a shadow munger to add init method to constructors
	    	//weaver.getShadowMungers().add(makeInitCallShadowMunger(initMethod));
	    	
	    	ResolvedMember itdfieldGetter = AjcMemberMaker.interFieldInterfaceGetter(field, gen.getType()/*onType*/, aspectType);
			LazyMethodGen mg = makeMethodGen(gen, itdfieldGetter);
			InstructionList il = new InstructionList();
			InstructionFactory fact = gen.getFactory();
			if (field.isStatic()) {
				il.append(fact.createFieldAccess(
					gen.getClassName(), 
					fg.getName(),
					fieldType, Constants.GETSTATIC));
			} else {
				il.append(InstructionConstants.ALOAD_0);
				il.append(fact.createFieldAccess(
					gen.getClassName(), 
					fg.getName(),
					fieldType, Constants.GETFIELD));
			}
			il.append(InstructionFactory.createReturn(fieldType));
			mg.getBody().insert(il);
				
			gen.addMethodGen(mg);
						
			// Check if we need bridge methods for the field getter and setter
			if (munger.getDeclaredSignature()!=null) { // is this munger a parameterized form of some original munger?
				ResolvedMember toBridgeTo = munger.getDeclaredSignature().parameterizedWith(null,munger.getSignature().getDeclaringType().resolve(getWorld()),false,munger.getTypeVariableAliases());
				boolean needsbridging = false;
				if (!toBridgeTo.getReturnType().getErasureSignature().equals(munger.getSignature().getReturnType().getErasureSignature())) needsbridging = true;
				if (toBridgeTo!=null && needsbridging) {
				  ResolvedMember bridgingGetter = AjcMemberMaker.interFieldInterfaceGetter(toBridgeTo, gen.getType(), aspectType);				  
				  createBridgeMethodForITDF(weaver,gen,itdfieldGetter,bridgingGetter);
			  }
			}		
			
			ResolvedMember itdfieldSetter = AjcMemberMaker.interFieldInterfaceSetter(field, gen.getType(), aspectType);
			LazyMethodGen mg1 = makeMethodGen(gen, itdfieldSetter);
			InstructionList il1 = new InstructionList();
			if (field.isStatic()) {
				il1.append(InstructionFactory.createLoad(fieldType, 0));
				il1.append(fact.createFieldAccess(
					gen.getClassName(), 
					fg.getName(),
					fieldType, Constants.PUTSTATIC));
			} else {
				il1.append(InstructionConstants.ALOAD_0);
				il1.append(InstructionFactory.createLoad(fieldType, 1));
				il1.append(fact.createFieldAccess(
					gen.getClassName(), 
					fg.getName(), 
					fieldType, Constants.PUTFIELD));
			}
			il1.append(InstructionFactory.createReturn(Type.VOID));
			mg1.getBody().insert(il1);
				
			gen.addMethodGen(mg1);
			
			if (munger.getDeclaredSignature()!=null) {
			  ResolvedMember toBridgeTo = munger.getDeclaredSignature().parameterizedWith(null,munger.getSignature().getDeclaringType().resolve(getWorld()),false,munger.getTypeVariableAliases());
			  boolean needsbridging = false;
			  if (!toBridgeTo.getReturnType().getErasureSignature().equals(munger.getSignature().getReturnType().getErasureSignature())) needsbridging = true;
			  if (toBridgeTo!=null && needsbridging) {
				ResolvedMember bridgingSetter = AjcMemberMaker.interFieldInterfaceSetter(toBridgeTo, gen.getType(), aspectType);
				createBridgeMethodForITDF(weaver, gen, itdfieldSetter, bridgingSetter);
			  }
		    }
			
		    return true;
		} else {
			return false;
		}
	}
================= fetch protected File getSpecFile() { d9757d7^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testDeclareAnnotationOnNonExistentType_pr99191_5() { runTest("declare annotation on non existent type - 5");}
Progress : [#########################---------------] 64%================= fetch private Expression fixReceiver(Expression expression, BlockScope scope) { 21cf37d^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.java

private Expression fixReceiver(Expression expression, BlockScope scope) {
		if (expression instanceof SuperReference) {
			SuperReference superRef = (SuperReference) expression;
			if (superType == null) {
				ISourceLocation location =
					new EclipseSourceLocation(scope.problemReporter().referenceContext.compilationResult(),
										expression.sourceStart, expression.sourceEnd);
				
				world.showMessage(IMessage.ERROR, "multiple supertypes for this interface", location, null);
				dec.ignoreFurtherInvestigation = true;
			}
			//FIXME ??? note error
			expression = new InterSuperReference(superRef, superType);	
		}
		return expression;
	}
================= fetch protected File getSpecFile() { 21cf37d^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testDeclareAnnotationOnNonExistentType_pr99191_5() { runTest("declare annotation on non existent type - 5");}
================= fetch public InterSuperFixerVisitor(InterTypeDeclaration dec, EclipseFactory world, Sc 21cf37d^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.java

================= fetch public void endVisit(MessageSend send, BlockScope scope) { 21cf37d^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.java

public void endVisit(MessageSend send, BlockScope scope) {
		send.receiver = fixReceiver(send.receiver, scope);
	}
================= fetch protected File getSpecFile() { a7e13f1^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testDeclareAnnotationOnNonExistentType_pr99191_5() { runTest("declare annotation on non existent type - 5");}
================= fetch public boolean attemptToModifySuperCalls(BcelClassWeaver weaver,LazyClassGen new a7e13f1^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
/**
     * The main part of implementing declare parents extends.  Modify super ctor calls to target the new type.
     */
public boolean attemptToModifySuperCalls(BcelClassWeaver weaver,LazyClassGen newParentTarget, ResolvedType newParent) {
        String currentParent = newParentTarget.getSuperClassname();
        List mgs = newParentTarget.getMethodGens();
        
        // Look for ctors to modify
        for (Iterator iter = mgs.iterator(); iter.hasNext();) {
        	LazyMethodGen aMethod = (LazyMethodGen) iter.next();     
        
        	if (aMethod.getName().equals("<init>")) { 
        		InstructionList insList = aMethod.getBody();
        		InstructionHandle handle = insList.getStart();
        		while (handle!= null) {
        			if (handle.getInstruction() instanceof INVOKESPECIAL) {
        				ConstantPoolGen cpg = newParentTarget.getConstantPoolGen();
        				INVOKESPECIAL invokeSpecial = (INVOKESPECIAL)handle.getInstruction();
        				if (invokeSpecial.getClassName(cpg).equals(currentParent) && invokeSpecial.getMethodName(cpg).equals("<init>")) {
        					// System.err.println("Transforming super call '<init>"+sp.getSignature(cpg)+"'");
                     
        					// 1. Check there is a ctor in the new parent with the same signature
        					ResolvedMember newCtor = getConstructorWithSignature(newParent,invokeSpecial.getSignature(cpg));
                        
        					if (newCtor == null) {
                                
                                // 2. Check ITDCs to see if the necessary ctor is provided that way
                                boolean satisfiedByITDC = false;
                                for (Iterator ii = newParentTarget.getType().getInterTypeMungersIncludingSupers().iterator(); ii.hasNext() && !satisfiedByITDC; ) {
                                    ConcreteTypeMunger m = (ConcreteTypeMunger)ii.next();
                                    if (m.getMunger() instanceof NewConstructorTypeMunger) {
                                        if (m.getSignature().getSignature().equals(invokeSpecial.getSignature(cpg))) {
                                            satisfiedByITDC = true;
                                        }
                                    }
                                }
                                
                                if (!satisfiedByITDC) {
        						  String csig = createReadableCtorSig(newParent, cpg, invokeSpecial);
        						  weaver.getWorld().getMessageHandler().handleMessage(MessageUtil.error(
        								"Unable to modify hierarchy for "+newParentTarget.getClassName()+" - the constructor "+
										csig+" is missing",this.getSourceLocation()));
        						  return false;
                                }
        					}
                     
        					int idx = cpg.addMethodref(newParent.getClassName(), invokeSpecial.getMethodName(cpg), invokeSpecial.getSignature(cpg));
        					invokeSpecial.setIndex(idx);
        				}
        			}
        			handle = handle.getNext();   
        		}
        	}
        }
        return true;
    }
================= fetch private TypeBinding makeTypeBinding1(UnresolvedType typeX) { ade32bc^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

private TypeBinding makeTypeBinding1(UnresolvedType typeX) {
		if (typeX.isPrimitiveType()) { 
			if (typeX == ResolvedType.BOOLEAN) return BaseTypes.BooleanBinding;
			if (typeX == ResolvedType.BYTE) return BaseTypes.ByteBinding;
			if (typeX == ResolvedType.CHAR) return BaseTypes.CharBinding;
			if (typeX == ResolvedType.DOUBLE) return BaseTypes.DoubleBinding;
			if (typeX == ResolvedType.FLOAT) return BaseTypes.FloatBinding;
			if (typeX == ResolvedType.INT) return BaseTypes.IntBinding;
			if (typeX == ResolvedType.LONG) return BaseTypes.LongBinding;
			if (typeX == ResolvedType.SHORT) return BaseTypes.ShortBinding;
			if (typeX == ResolvedType.VOID) return BaseTypes.VoidBinding;
			throw new RuntimeException("weird primitive type " + typeX);
		} else if (typeX.isArray()) {
			int dim = 0;
			while (typeX.isArray()) {
				dim++;
				typeX = typeX.getComponentType();
			}
			return lookupEnvironment.createArrayType(makeTypeBinding(typeX), dim);
		} else if (typeX.isParameterizedType()) {
		    // Converting back to a binding from a UnresolvedType
		    UnresolvedType[] typeParameters = typeX.getTypeParameters();
			ReferenceBinding baseTypeBinding = lookupBinding(typeX.getBaseName());
			TypeBinding[] argumentBindings = new TypeBinding[typeParameters.length];
			for (int i = 0; i < argumentBindings.length; i++) {
				argumentBindings[i] = makeTypeBinding(typeParameters[i]);
			}
			ParameterizedTypeBinding ptb = 
				lookupEnvironment.createParameterizedType(baseTypeBinding,argumentBindings,baseTypeBinding.enclosingType());
			return ptb;
		} else if (typeX.isTypeVariableReference()) {
//			return makeTypeVariableBinding((TypeVariableReference)typeX);
			return makeTypeVariableBindingFromAJTypeVariable(((TypeVariableReference)typeX).getTypeVariable());
		} else if (typeX.isRawType()) {
			ReferenceBinding baseTypeBinding = lookupBinding(typeX.getBaseName());
			RawTypeBinding rtb = lookupEnvironment.createRawType(baseTypeBinding,baseTypeBinding.enclosingType());
			return rtb;
		} else if (typeX.isGenericWildcard()) {
		    // translate from boundedreferencetype to WildcardBinding
			BoundedReferenceType brt = (BoundedReferenceType)typeX;
			// Work out 'kind' for the WildcardBinding
			int boundkind = Wildcard.UNBOUND;
			TypeBinding bound = null;
			if (brt.isExtends()) {
				boundkind = Wildcard.EXTENDS;
				bound = makeTypeBinding(brt.getUpperBound());
			} else if (brt.isSuper()) {
				boundkind = Wildcard.SUPER;
				bound = makeTypeBinding(brt.getLowerBound());
			}
			TypeBinding[] otherBounds = null;
			if (brt.getAdditionalBounds()!=null && brt.getAdditionalBounds().length!=0) otherBounds = makeTypeBindings(brt.getAdditionalBounds());
			// FIXME asc rank should not always be 0 ... 
			WildcardBinding wb = lookupEnvironment.createWildcard(null,0,bound,otherBounds,boundkind);
			return wb;
		} else {
			return lookupBinding(typeX.getName());
		}
	}
================= fetch protected File getSpecFile() { ade32bc^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testDeclareAnnotationOnNonExistentType_pr99191_5() { runTest("declare annotation on non existent type - 5");}
================= fetch public TypeBinding makeTypeBinding(UnresolvedType typeX) { ade32bc^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

public TypeBinding makeTypeBinding(UnresolvedType typeX) {
		
		TypeBinding ret = null;
		
		// looking up type variables can get us into trouble
		if (!typeX.isTypeVariableReference())
			ret = (TypeBinding)typexToBinding.get(typeX);
			
		if (ret == null) {
			ret = makeTypeBinding1(typeX);
			// FIXME asc keep type variables *out* of the map for now, they go in typeVariableToTypeBinding
			if (!(typeX instanceof BoundedReferenceType) && !(typeX instanceof UnresolvedTypeVariableReferenceType)) 
			  typexToBinding.put(typeX, ret);
		}
		if (ret == null) {
			System.out.println("can't find: " + typeX);
		}
		return ret;
	}
================= fetch private void registerAspects(final BcelWeaver weaver, final ClassLoader loader, 62d16d5^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
     * Register the aspect, following include / exclude rules
     *
     * @param weaver
     * @param loader
     * @param definitions
     */
private void registerAspects(final BcelWeaver weaver, final ClassLoader loader, final List definitions) {
        //TODO: the exclude aspect allow to exclude aspect defined upper in the CL hierarchy - is it what we want ??
        // if not, review the getResource so that we track which resource is defined by which CL

        //iterate aspectClassNames
        //exclude if in any of the exclude list
        for (Iterator iterator = definitions.iterator(); iterator.hasNext();) {
            Definition definition = (Definition) iterator.next();
            for (Iterator aspects = definition.getAspectClassNames().iterator(); aspects.hasNext();) {
                String aspectClassName = (String) aspects.next();
                if (acceptAspect(aspectClassName)) {
                    ResolvedType aspect = weaver.addLibraryAspect(aspectClassName);
                    if (aspect.isAbstract()) {
                        // this is a warning
                        weaver.getWorld().getMessageHandler().handleMessage(
                                new Message("Abstract aspect registered in aop.xml, use a <concrete-aspect> element instead", IMessage.WARNING, null, null)
                        );
                    }
                    //generate key for SC
                	String aspectCode = readAspect(aspectClassName, loader);
                    if(namespace==null){
                    	namespace=new StringBuffer(aspectCode);
                    }else{
                    	namespace = namespace.append(";"+aspectCode);
                    }
                }
            }
        }

        //iterate concreteAspects
        //exclude if in any of the exclude list - note that the user defined name matters for that to happen
        for (Iterator iterator = definitions.iterator(); iterator.hasNext();) {
            Definition definition = (Definition) iterator.next();
            for (Iterator aspects = definition.getConcreteAspects().iterator(); aspects.hasNext();) {
                Definition.ConcreteAspect concreteAspect = (Definition.ConcreteAspect) aspects.next();
                if (acceptAspect(concreteAspect.name)) {
                    ConcreteAspectCodeGen gen = new ConcreteAspectCodeGen(concreteAspect, weaver.getWorld());
                    if (!gen.validate()) {
                        weaver.getWorld().getMessageHandler().handleMessage(
                                new Message("Concrete-aspect '"+concreteAspect.name+"' could not be registered", IMessage.ERROR, null, null)
                        );
                        break;
                    }
                    this.generatedClassHandler.acceptClass(
                            concreteAspect.name,
                            gen.getBytes()
                    );
                    ResolvedType aspect = weaver.addLibraryAspect(concreteAspect.name);
                    //generate key for SC
                	String aspectCode = readAspect(concreteAspect.name, loader);
                    if(namespace==null){
                    	namespace=new StringBuffer(aspectCode);
                    }else{
                    	namespace = namespace.append(";"+aspectCode);
                    }
                }
            }
        }
    }
================= fetch public void flushGeneratedClasses(){ 62d16d5^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
     * Flush the generated classes cache
     */
public void flushGeneratedClasses(){
    	generatedClasses = new HashMap();
    }
================= fetch private void validateAspectDeclaration(TypeDeclaration typeDecl) { 794f9b5^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java
/**
	 * nested aspect must be static
	 * cannot extend a concrete aspect
	 * pointcut in perclause must be good.
	 */
private void validateAspectDeclaration(TypeDeclaration typeDecl) {
		if (typeStack.size() > 1) {
			// it's a nested aspect
			if (!Modifier.isStatic(typeDecl.modifiers)) {
				typeDecl.scope.problemReporter().signalError(typeDecl.sourceStart, typeDecl.sourceEnd, "inner aspects must be static");
				return;
			}
		}
		
		SourceTypeBinding binding = typeDecl.binding;
		if (binding != null) {
			if (binding.isEnum() || binding.isInterface() || binding.isAnnotationType()) {
				typeDecl.scope.problemReporter().signalError(typeDecl.sourceStart,typeDecl.sourceEnd,"only classes can have an @Aspect annotation");
			}
		}
		
		TypeReference parentRef = typeDecl.superclass;
		if (parentRef != null) {
			TypeBinding parentBinding = parentRef.resolvedType;
			if (parentBinding instanceof SourceTypeBinding) {
				SourceTypeBinding parentSTB = (SourceTypeBinding) parentBinding;
				TypeDeclaration parentDecl = parentSTB.scope.referenceContext;
				if (isAspect(parentDecl) && !Modifier.isAbstract(parentDecl.modifiers)) {
					typeDecl.scope.problemReporter().signalError(typeDecl.sourceStart,typeDecl.sourceEnd,"cannot extend a concrete aspect");
				}			
			}
		}

		Annotation aspectAnnotation = ajAnnotations.aspectAnnotation;

		int[] pcLoc = new int[2];
		String perClause = getStringLiteralFor("value", aspectAnnotation, pcLoc);
		AspectDeclaration aspectDecl = new AspectDeclaration(typeDecl.compilationResult);

		try {
			if (perClause != null && !perClause.equals("")) {
				ISourceContext context = new EclipseSourceContext(unit.compilationResult,pcLoc[0]);
				Pointcut pc = new PatternParser(perClause,context).maybeParsePerClause();
			    FormalBinding[] bindings = new FormalBinding[0];
				if (pc != null) pc.resolve(new EclipseScope(bindings,typeDecl.scope));
			}
		} catch(ParserException pEx) {
			typeDecl.scope.problemReporter().parseError(
					pcLoc[0] + pEx.getLocation().getStart(),
					pcLoc[0] + pEx.getLocation().getEnd() ,
					-1, 
					perClause.toCharArray(), 
					perClause, 
					new String[] {pEx.getMessage()});
		}
	}
================= fetch public static List readAj5ClassAttributes(JavaClass javaClass, ReferenceType typ 794f9b5^:weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java
/**
     * Extract class level annotations and turn them into AjAttributes.
     *
     * @param javaClass
     * @param type
     * @param context
     * @param msgHandler
     * @return list of AjAttributes
     */
public static List readAj5ClassAttributes(JavaClass javaClass, ReferenceType type, ISourceContext context, IMessageHandler msgHandler, boolean isCodeStyleAspect) {
        //FIXME AV - 1.5 feature limitation, kick after implemented
        try {
            Constant[] cpool = javaClass.getConstantPool().getConstantPool();
            for (int i = 0; i < cpool.length; i++) {
                Constant constant = cpool[i];
                if (constant != null && constant.getTag() == Constants.CONSTANT_Utf8) {
                    if (!javaClass.getClassName().startsWith("org.aspectj.lang.annotation")) {
                        ConstantUtf8 constantUtf8 = (ConstantUtf8) constant;
                        if ("Lorg/aspectj/lang/annotation/DeclareAnnotation;".equals(constantUtf8.getBytes())) {
                            msgHandler.handleMessage(
                                    new Message(
                                            "Found @DeclareAnnotation while current release does not support it (see '" + type.getName() + "')",
                                            IMessage.WARNING,
                                            null,
                                            type.getSourceLocation()
                                    )
                            );
                        }
                    }
                }
            }
        } catch (Throwable t) {
            ;
        }


        AjAttributeStruct struct = new AjAttributeStruct(type, context, msgHandler);
        Attribute[] attributes = javaClass.getAttributes();
        boolean hasAtAspectAnnotation = false;
        boolean hasAtPrecedenceAnnotation = false;

        for (int i = 0; i < attributes.length; i++) {
            Attribute attribute = attributes[i];
            if (acceptAttribute(attribute)) {
                RuntimeAnnotations rvs = (RuntimeAnnotations) attribute;
                // we don't need to look for several attribute occurence since it cannot happen as per JSR175
                if (!isCodeStyleAspect) {
                    hasAtAspectAnnotation = handleAspectAnnotation(rvs, struct);
                    //TODO AV - if put outside the if isCodeStyleAspect then we would enable mix style
                    hasAtPrecedenceAnnotation = handlePrecedenceAnnotation(rvs, struct);
                }
                // there can only be one RuntimeVisible bytecode attribute
                break;
            }
        }

        // basic semantic check
        if (hasAtPrecedenceAnnotation && !hasAtAspectAnnotation) {
            msgHandler.handleMessage(
                    new Message(
                            "Found @DeclarePrecedence on a non @Aspect type '" + type.getName() + "'",
                            IMessage.WARNING,
                            null,
                            type.getSourceLocation()
                    )
            );
            // bypass what we have read
            return EMPTY_LIST;
        }
        //FIXME turn on when ajcMightHaveAspect
//        if (hasAtAspectAnnotation && type.isInterface()) {
//            msgHandler.handleMessage(
//                    new Message(
//                            "Found @Aspect on an interface type '" + type.getName() + "'",
//                            IMessage.WARNING,
//                            null,
//                            type.getSourceLocation()
//                    )
//            );
//            // bypass what we have read
//            return EMPTY_LIST;
//        }

        // the following block will not detect @Pointcut in non @Aspect types for optimization purpose
        if (!hasAtAspectAnnotation) {
            return EMPTY_LIST;
        }

        // code style pointcuts are class attributes
        // we need to gather the @AJ pointcut right now and not at method level annotation extraction time
        // in order to be able to resolve the pointcut references later on
        // we don't need to look in super class, the pointcut reference in the grammar will do it
        for (int i = 0; i < javaClass.getMethods().length; i++) {
            Method method = javaClass.getMethods()[i];
            if (method.getName().startsWith(NameMangler.PREFIX)) continue;  // already dealt with by ajc...
            //FIXME alex optimize, this method struct will gets recreated for advice extraction
            AjAttributeMethodStruct mstruct = new AjAttributeMethodStruct(method, null, type, context, msgHandler);//FIXME AVASM
            Attribute[] mattributes = method.getAttributes();

            for (int j = 0; j < mattributes.length; j++) {
                Attribute mattribute = mattributes[j];
                if (acceptAttribute(mattribute)) {
                    RuntimeAnnotations mrvs = (RuntimeAnnotations) mattribute;
                    handlePointcutAnnotation(mrvs, mstruct);
                    // there can only be one RuntimeVisible bytecode attribute
                    break;
                }
            }
            // FIXME asc should check we aren't adding multiple versions... will do once I get the tests passing again...
            struct.ajAttributes.add(new AjAttribute.WeaverVersionInfo());
            struct.ajAttributes.addAll(mstruct.ajAttributes);
        }


        // code style declare error / warning / implements / parents are field attributes
        for (int i = 0; i < javaClass.getFields().length; i++) {
            Field field = javaClass.getFields()[i];
            if (field.getName().startsWith(NameMangler.PREFIX)) continue;  // already dealt with by ajc...
            //FIXME alex optimize, this method struct will gets recreated for advice extraction
            AjAttributeFieldStruct fstruct = new AjAttributeFieldStruct(field, null, type, context, msgHandler);
            Attribute[] fattributes = field.getAttributes();

            for (int j = 0; j < fattributes.length; j++) {
                Attribute fattribute = fattributes[j];
                if (acceptAttribute(fattribute)) {
                    RuntimeAnnotations frvs = (RuntimeAnnotations) fattribute;
                    if (handleDeclareErrorOrWarningAnnotation(frvs, fstruct)
                            || handleDeclareImplementsAnnotation(frvs, fstruct)
                            || handleDeclareParentsAnnotation(frvs, fstruct)) {
                        // semantic check - must be in an @Aspect [remove if previous block bypassed in advance]
                        if (!type.isAnnotationStyleAspect()) {
                            msgHandler.handleMessage(
                                    new Message(
                                            "Found @AspectJ annotations in a non @Aspect type '" + type.getName() + "'",
                                            IMessage.WARNING,
                                            null,
                                            type.getSourceLocation()
                                    )
                            );
                            ;// go ahead
                        }
                    }
                    // there can only be one RuntimeVisible bytecode attribute
                    break;
                }
            }
            struct.ajAttributes.addAll(fstruct.ajAttributes);
        }
        return struct.ajAttributes;
    }
================= fetch public void testAspectOfWhenAspectNotInInclude() { 794f9b5^:tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java

public void testAspectOfWhenAspectNotInInclude() {
        runTest("AspectOfWhenAspectNotInInclude");
    }
================= fetch protected File getSpecFile() { 8cea30f^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testDeclareAnnotationOnNonExistentType_pr99191_5() { runTest("declare annotation on non existent type - 5");}
================= fetch public boolean match(Shadow shadow, World world) { 8cea30f^:weaver/src/org/aspectj/weaver/Advice.java

public boolean match(Shadow shadow, World world) {
		if (super.match(shadow, world)) {
			if (shadow.getKind() == Shadow.ExceptionHandler) {
				if (kind.isAfter() || kind == AdviceKind.Around) {
					world.showMessage(IMessage.WARNING,
							WeaverMessages.format(WeaverMessages.ONLY_BEFORE_ON_HANDLER),
							getSourceLocation(), shadow.getSourceLocation());
					return false;
				}
			}
			
			
    		if (hasExtraParameter() && kind == AdviceKind.AfterReturning) {
    			ResolvedType resolvedExtraParameterType = getExtraParameterType().resolve(world);
    			ResolvedType shadowReturnType = shadow.getReturnType().resolve(world);
    			boolean matches = resolvedExtraParameterType.isConvertableFrom(shadowReturnType);
    			if (matches && resolvedExtraParameterType.isParameterizedType()) {
    				maybeIssueUncheckedMatchWarning(resolvedExtraParameterType,shadowReturnType,shadow,world);
    			}
    			return matches;
    		} else if (kind == AdviceKind.PerTargetEntry) {
    			return shadow.hasTarget();
    		} else if (kind == AdviceKind.PerThisEntry) {
    			return shadow.hasThis();
    		} else if (kind == AdviceKind.Around) {
    			if (shadow.getKind() == Shadow.PreInitialization) {
	    			world.showMessage(IMessage.ERROR,
	    					WeaverMessages.format(WeaverMessages.AROUND_ON_PREINIT),
							getSourceLocation(), shadow.getSourceLocation());
					return false;
				} else if (shadow.getKind() == Shadow.Initialization) {
					world.showMessage(IMessage.ERROR,
							WeaverMessages.format(WeaverMessages.AROUND_ON_INIT),
							getSourceLocation(), shadow.getSourceLocation());
					return false;
				} else if (shadow.getKind() == Shadow.StaticInitialization && 
							shadow.getEnclosingType().resolve(world).isInterface())
				{
					world.showMessage(IMessage.ERROR,
							WeaverMessages.format(WeaverMessages.AROUND_ON_INTERFACE_STATICINIT,shadow.getEnclosingType().getName()),
							getSourceLocation(), shadow.getSourceLocation());
					return false;
    			} else {
    				//System.err.println(getSignature().getReturnType() + " from " + shadow.getReturnType());
    				if (getSignature().getReturnType() == ResolvedType.VOID) {
    					if (shadow.getReturnType() != ResolvedType.VOID) {
    						world.showMessage(IMessage.ERROR, 
    							WeaverMessages.format(WeaverMessages.NON_VOID_RETURN,shadow),	
    							getSourceLocation(), shadow.getSourceLocation());
    						return false;
    					}
    				} else if (getSignature().getReturnType().equals(UnresolvedType.OBJECT)) {
    					return true;
    				} else if(!shadow.getReturnType().resolve(world).isAssignableFrom(getSignature().getReturnType().resolve(world))) {
    					//System.err.println(this + ", " + sourceContext + ", " + start);
						world.showMessage(IMessage.ERROR,
								WeaverMessages.format(WeaverMessages.INCOMPATIBLE_RETURN_TYPE,shadow),
								getSourceLocation(), shadow.getSourceLocation());
	    				return false;
    				}
    			}
    		}
    		return true; 
    	} else {
    		return false;
    	}
	}
================= fetch public static Kind read(DataInputStream s) throws IOException { 8cea30f^:weaver/src/org/aspectj/weaver/Member.java

public static Kind read(DataInputStream s) throws IOException {
            int key = s.readByte();
            switch(key) {
                case 1: return METHOD;
                case 2: return FIELD;
                case 3: return CONSTRUCTOR;
                case 4: return STATIC_INITIALIZATION;
                case 5: return POINTCUT;
                case 6: return ADVICE;
                case 7: return HANDLER;
            }
            throw new BCException("weird kind " + key);
        }
Progress : [##########################--------------] 65%================= fetch private boolean weaveDeclareAtField(LazyClassGen clazz) { 2da9b31^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
	 * Weave any declare @field statements into the fields of the supplied class
	 * 
	 * Interesting case relating to public ITDd fields.  The annotations are really stored against
     * the interfieldinit method in the aspect, but the public field is placed in the target
     * type and then is processed in the 2nd pass over fields that occurs.  I think it would be
     * more expensive to avoid putting the annotation on that inserted public field than just to
     * have it put there as well as on the interfieldinit method.
	 */
private boolean weaveDeclareAtField(LazyClassGen clazz) {
	  
        // BUGWARNING not getting enough warnings out on declare @field ?
        // There is a potential problem here with warnings not coming out - this
        // will occur if they are created on the second iteration round this loop.
        // We currently deactivate error reporting for the second time round.
        // A possible solution is to record what annotations were added by what
        // decafs and check that to see if an error needs to be reported - this
        // would be expensive so lets skip it for now

		List reportedProblems = new ArrayList();

		List allDecafs = world.getDeclareAnnotationOnFields();
		if (allDecafs.isEmpty()) return false; // nothing to do
		
		
		boolean isChanged = false;
		List itdFields = getITDSubset(clazz,ResolvedTypeMunger.Field);
		if (itdFields!=null) {
			isChanged = weaveAtFieldRepeatedly(allDecafs,itdFields,reportedProblems);
		}
		
        List decaFs = getMatchingSubset(allDecafs,clazz.getType());
		if (decaFs.isEmpty()) return false; // nothing more to do
		Field[] fields = clazz.getFieldGens();
		if (fields!=null) {
		  
          for (int fieldCounter = 0;fieldCounter<fields.length;fieldCounter++) {
            BcelField aBcelField = new BcelField(clazz.getBcelObjectType(),fields[fieldCounter]);
			if (!aBcelField.getName().startsWith(NameMangler.PREFIX)) {				
            // Single first pass
            List worthRetrying = new ArrayList();
            boolean modificationOccured = false;
            
            Annotation [] dontAddMeTwice = fields[fieldCounter].getAnnotations();
            
            // go through all the declare @field statements
            for (Iterator iter = decaFs.iterator(); iter.hasNext();) {
				DeclareAnnotation decaF = (DeclareAnnotation) iter.next();
				if (decaF.matches(aBcelField,world)) {
					
					if (!dontAddTwice(decaF,dontAddMeTwice)){
						if (doesAlreadyHaveAnnotation(aBcelField,decaF,reportedProblems)){
							continue;
						}
						
						if(decaF.getAnnotationX().isRuntimeVisible()){ // isAnnotationWithRuntimeRetention(clazz.getJavaClass(world))){
						//if(decaF.getAnnotationTypeX().isAnnotationWithRuntimeRetention(world)){						
							// it should be runtime visible, so put it on the Field
							Annotation a = decaF.getAnnotationX().getBcelAnnotation();
							AnnotationGen ag = new AnnotationGen(a,clazz.getConstantPoolGen(),true);
							FieldGen myGen = new FieldGen(fields[fieldCounter],clazz.getConstantPoolGen());
							myGen.addAnnotation(ag);
							Field newField = myGen.getField();
							
							aBcelField.addAnnotation(decaF.getAnnotationX());
							clazz.replaceField(fields[fieldCounter],newField);
							fields[fieldCounter]=newField;
							
						} else{
							aBcelField.addAnnotation(decaF.getAnnotationX());
						}
					}
					
					AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decaF.getSourceLocation(),clazz.getName(),fields[fieldCounter]);
					reportFieldAnnotationWeavingMessage(clazz, fields, fieldCounter, decaF);		
					isChanged = true;
					modificationOccured = true;
				} else {
					if (!decaF.isStarredAnnotationPattern()) 
						worthRetrying.add(decaF); // an annotation is specified that might be put on by a subsequent decaf
				}
			}
			
            // Multiple secondary passes
            while (!worthRetrying.isEmpty() && modificationOccured) {
              modificationOccured = false;
              // lets have another go
              List forRemoval = new ArrayList();
              for (Iterator iter = worthRetrying.iterator(); iter.hasNext();) {
				DeclareAnnotation decaF = (DeclareAnnotation) iter.next();
				if (decaF.matches(aBcelField,world)) {
					// below code is for recursive things
					if (doesAlreadyHaveAnnotation(aBcelField,decaF,reportedProblems)) continue; // skip this one...
					aBcelField.addAnnotation(decaF.getAnnotationX());
					AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decaF.getSourceLocation(),clazz.getName(),fields[fieldCounter]);
					isChanged = true;
					modificationOccured = true;
					forRemoval.add(decaF);
				}
			  }
			  worthRetrying.removeAll(forRemoval);
            }
			}
          }
        }
		return isChanged;
	}
================= fetch private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) { 2da9b31^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
     * Weave any declare @method/@ctor statements into the members of the supplied class
     */
private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {
		List reportedProblems = new ArrayList();
		
		List allDecams = world.getDeclareAnnotationOnMethods();
		if (allDecams.isEmpty()) return false; // nothing to do
		
		boolean isChanged = false;

		// deal with ITDs
		List itdMethodsCtors = getITDSubset(clazz,ResolvedTypeMunger.Method);
		itdMethodsCtors.addAll(getITDSubset(clazz,ResolvedTypeMunger.Constructor));		
		if (!itdMethodsCtors.isEmpty()) {
			// Can't use the subset called 'decaMs' as it won't be right for ITDs...
 	        isChanged = weaveAtMethodOnITDSRepeatedly(allDecams,itdMethodsCtors,reportedProblems);
		}
		
		// deal with all the other methods...
        List members = clazz.getMethodGens();
		List decaMs = getMatchingSubset(allDecams,clazz.getType());		
		if (decaMs.isEmpty()) return false; // nothing to do
		if (!members.isEmpty()) {
          for (int memberCounter = 0;memberCounter<members.size();memberCounter++) {
            LazyMethodGen mg = (LazyMethodGen)members.get(memberCounter);
            if (!mg.getName().startsWith(NameMangler.PREFIX)) {
            	
            	// Single first pass
            	List worthRetrying = new ArrayList();
            	boolean modificationOccured = false;
            	
            	for (Iterator iter = decaMs.iterator(); iter.hasNext();) {
            		DeclareAnnotation decaM = (DeclareAnnotation) iter.next();
            		
            		if (decaM.matches(mg.getMemberView(),world)) {
            			if (doesAlreadyHaveAnnotation(mg.getMemberView(),decaM,reportedProblems)) continue; // skip this one...
            			
            			Annotation a = decaM.getAnnotationX().getBcelAnnotation();
            			AnnotationGen ag = new AnnotationGen(a,clazz.getConstantPoolGen(),true);
            			Method oldMethod = mg.getMethod();
            			MethodGen myGen = new MethodGen(oldMethod,clazz.getClassName(),clazz.getConstantPoolGen());
            			myGen.addAnnotation(ag);
            			Method newMethod = myGen.getMethod();
            			mg.addAnnotation(decaM.getAnnotationX());
            			members.set(memberCounter,new LazyMethodGen(newMethod,clazz));
            			
            			AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decaM.getSourceLocation(),clazz.getName(),mg.getMethod());
            			reportMethodCtorWeavingMessage(clazz, mg.getMemberView(), decaM,mg.getDeclarationLineNumber());
            			isChanged = true;
            			modificationOccured = true;
            		} else {
            			if (!decaM.isStarredAnnotationPattern()) 
            				worthRetrying.add(decaM); // an annotation is specified that might be put on by a subsequent decaf
            		}
            	}
            	
            	// Multiple secondary passes
            	while (!worthRetrying.isEmpty() && modificationOccured) {
            		modificationOccured = false;
            		// lets have another go
            		List forRemoval = new ArrayList();
            		for (Iterator iter = worthRetrying.iterator(); iter.hasNext();) {
            			DeclareAnnotation decaM = (DeclareAnnotation) iter.next();
            			if (decaM.matches(mg.getMemberView(),world)) {
            				if (doesAlreadyHaveAnnotation(mg.getMemberView(),decaM,reportedProblems)) continue; // skip this one...
            				mg.addAnnotation(decaM.getAnnotationX());
            				AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decaM.getSourceLocation(),clazz.getName(),mg.getMethod());
            				isChanged = true;
            				modificationOccured = true;
            				forRemoval.add(decaM);
            			}
            		}
            		worthRetrying.removeAll(forRemoval);
            	}
            }
          }
        }
		return isChanged;
    }
================= fetch protected File getSpecFile() { 2da9b31^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testIncompatibleClassChangeError_pr113630_2() {runTest("IncompatibleClassChangeError - workingscenario");}
================= fetch public void testOutJar() { cc6862f^:ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java

public void testOutJar() {
		String outJar = "mybuild.jar";
		projectProperties.setOutJar( outJar );
		buildConfig = compilerAdapter.genBuildConfig( configFile );			
        assertTrue(configFile + " failed", null != buildConfig);            
		assertNotNull("output jar", buildConfig.getOutputJar());
        assertEquals( "out jar", outJar, buildConfig.getOutputJar().toString() );				
	}
================= fetch private void registerDefinitions(final BcelWeaver weaver, final ClassLoader load 70888dd^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
     * Load and cache the aop.xml/properties according to the classloader visibility rules
     *
     * @param weaver
     * @param loader
     */
void registerDefinitions(final BcelWeaver weaver, final ClassLoader loader) {
        try {
            MessageUtil.info(messageHandler, "register classloader " + ((loader!=null)?loader.getClass().getName()+"@"+loader.hashCode():"null"));
            //TODO av underoptimized: we will parse each XML once per CL that see it
            List definitions = new ArrayList();

            //TODO av dev mode needed ? TBD -Daj5.def=...
            if (ClassLoader.getSystemClassLoader().equals(loader)) {
                String file = System.getProperty("aj5.def", null);
                if (file != null) {
                    MessageUtil.info(messageHandler, "using (-Daj5.def) " + file);
                    definitions.add(DocumentParser.parse((new File(file)).toURL()));
                }
            }
            
            String resourcePath = System.getProperty("org.aspectj.weaver.loadtime.configuration",AOP_XML);
    		StringTokenizer st = new StringTokenizer(resourcePath,";");

    		while(st.hasMoreTokens()){
    			Enumeration xmls = weavingContext.getResources(st.nextToken());
//    			System.out.println("? registerDefinitions: found-aop.xml=" + xmls.hasMoreElements() + ", loader=" + loader);


    			while (xmls.hasMoreElements()) {
    			    URL xml = (URL) xmls.nextElement();
    			    MessageUtil.info(messageHandler, "using " + xml.getFile());
    			    definitions.add(DocumentParser.parse(xml));
    			}
    		}

            // still go thru if definitions is empty since we will configure
            // the default message handler in there
            registerOptions(weaver, loader, definitions);
            registerAspectExclude(weaver, loader, definitions);
            registerAspects(weaver, loader, definitions);
            registerIncludeExclude(weaver, loader, definitions);
            registerDump(weaver, loader, definitions);
        } catch (Exception e) {
            weaver.getWorld().getMessageHandler().handleMessage(
                    new Message("Register definition failed", IMessage.WARNING, e, null)
            );
        }
    }
================= fetch public void addCrossReference(ISourceLocation from, ISourceLocation to, IRelatio 70888dd^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java

public void acceptClass(String name, byte[] bytes) {
                //TODO av make dump configurable
                try {
                    if (shouldDump(name.replace('/', '.'))) {
                        Aj.dump(name, bytes);
                    }
                } catch (Throwable throwable) {
                    throwable.printStackTrace();
                }
                Aj.defineClass(loader, name, bytes);// could be done lazily using the hook
            }
================= fetch static WeavingAdaptor getWeaver(ClassLoader loader, IWeavingContext weavingConte 70888dd^:loadtime/src/org/aspectj/weaver/loadtime/Aj.java
/**
     * Weave
     *
     * @param className
     * @param bytes
     * @param loader
     * @return weaved bytes
     */
public byte[] preProcess(String className, byte[] bytes, ClassLoader loader) {
        //TODO AV needs to doc that
        if (loader == null || className == null) {
            // skip boot loader or null classes (hibernate)
            return bytes;
        }

        try {
            WeavingAdaptor weavingAdaptor = WeaverContainer.getWeaver(loader, weavingContext);
            byte[] weaved = weavingAdaptor.weaveClass(className, bytes);
            if (weavingAdaptor.shouldDump(className.replace('/', '.'))) {
                dump(className, weaved);
            }
            return weaved;
        } catch (Throwable t) {
            //FIXME AV wondering if we should have the option to fail (throw runtime exception) here
            // would make sense at least in test f.e. see TestHelper.handleMessage()
            t.printStackTrace();
            return bytes;
        }
    }
================= fetch public Pointcut concretize1(ResolvedType searchStart, ResolvedType declaringType 3021284^:weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java
// and not one in a subtype that happens to have the same name.
public Pointcut concretize1(ResolvedType searchStart, ResolvedType declaringType, IntMap bindings) {
		if (concretizing) {
			//Thread.currentThread().dumpStack();
			searchStart.getWorld().getMessageHandler().handleMessage(
				MessageUtil.error(WeaverMessages.format(WeaverMessages.CIRCULAR_POINTCUT,this),
									getSourceLocation()));
			return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
		}
		
		try {
			concretizing = true;
		
			ResolvedPointcutDefinition pointcutDec;
			if (onType != null) {
				searchStart = onType.resolve(searchStart.getWorld());
				if (searchStart == ResolvedType.MISSING) {
					return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
				}
			}
			
			if (declaringType == null) declaringType = searchStart;
			pointcutDec = declaringType.findPointcut(name);
			boolean foundMatchingPointcut = (pointcutDec != null && pointcutDec.isPrivate());
			if (!foundMatchingPointcut) {				
				pointcutDec = searchStart.findPointcut(name);
				if (pointcutDec == null) {
					searchStart.getWorld().getMessageHandler().handleMessage(
						MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_FIND_POINTCUT,name,searchStart.getName()), 
										getSourceLocation())
					);
					return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
				}
			}
			
			if (pointcutDec.isAbstract()) {
				//Thread.currentThread().dumpStack();
				ShadowMunger enclosingAdvice = bindings.getEnclosingAdvice();
				searchStart.getWorld().showMessage(IMessage.ERROR,
						WeaverMessages.format(WeaverMessages.ABSTRACT_POINTCUT,pointcutDec), 
						getSourceLocation(), 
						(null == enclosingAdvice) ? null : enclosingAdvice.getSourceLocation());
				return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
			}
					
			//System.err.println("start: " + searchStart);
			ResolvedType[] parameterTypes = searchStart.getWorld().resolve(pointcutDec.getParameterTypes());
			
			TypePatternList arguments = this.arguments.resolveReferences(bindings);
			
			IntMap newBindings = new IntMap();
			for (int i=0,len=arguments.size(); i < len; i++) {
				TypePattern p = arguments.get(i);
				if (p == TypePattern.NO) continue;
				//we are allowed to bind to pointcuts which use subtypes as this is type safe
				if (!p.matchesSubtypes(parameterTypes[i])  && 
					!p.getExactType().equals(UnresolvedType.OBJECT))
				{
					throw new BCException("illegal change to pointcut declaration: " + this);
				}
				
			    if (p instanceof BindingTypePattern) {
			    	newBindings.put(i, ((BindingTypePattern)p).getFormalIndex());
			    }
			}
			
			if (searchStart.isParameterizedType()) {
				// build a type map mapping type variable names in the generic type to
				// the type parameters presented
				typeVariableMap = new HashMap();
				ResolvedType underlyingGenericType = searchStart.getGenericType();
				TypeVariable[] tVars = underlyingGenericType.getTypeVariables();
				ResolvedType[] typeParams = searchStart.getResolvedTypeParameters();
				for (int i = 0; i < tVars.length; i++) {
					typeVariableMap.put(tVars[i].getName(),typeParams[i]);
				}
			}
			
			newBindings.copyContext(bindings);
			newBindings.pushEnclosingDefinition(pointcutDec);
			try {
				Pointcut ret = pointcutDec.getPointcut();
				if (typeVariableMap != null) ret = ret.parameterizeWith(typeVariableMap);
				return ret.concretize(searchStart, declaringType, newBindings);
			} finally {
				newBindings.popEnclosingDefinitition();
			}
			
		} finally {
			concretizing = false;
		}
	}
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { 3021284^:weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java

public void resolveBindings(IScope scope, Bindings bindings) {
		if (onTypeSymbolic != null) {
			onType = onTypeSymbolic.resolveExactType(scope, bindings);
			// in this case we've already signalled an error
			if (onType == ResolvedType.MISSING) return;		
		}
		
		ResolvedType searchType;
		if (onType != null) {
			searchType = scope.getWorld().resolve(onType);
		} else {
			searchType = scope.getEnclosingType();
		}
		
		
		arguments.resolveBindings(scope, bindings, true, true);
		//XXX ensure that arguments has no ..'s in it
		
		// check that I refer to a real pointcut declaration and that I match
		
		ResolvedPointcutDefinition pointcutDef = searchType.findPointcut(name);
		// if we're not a static reference, then do a lookup of outers
		if (pointcutDef == null && onType == null) {
			while (true) {
				UnresolvedType declaringType = searchType.getDeclaringType();
				if (declaringType == null) break;
				searchType = declaringType.resolve(scope.getWorld());
				pointcutDef = searchType.findPointcut(name);
				if (pointcutDef != null) {
					// make this a static reference
					onType = searchType;
					break;
				}
			}
		}
		
		if (pointcutDef == null) {
			scope.message(IMessage.ERROR, this, "can't find referenced pointcut " + name);
			return;
		}
		
		// check visibility
		if (!pointcutDef.isVisible(scope.getEnclosingType())) {
			scope.message(IMessage.ERROR, this, "pointcut declaration " + pointcutDef + " is not accessible");
			return;
		}
		
		if (Modifier.isAbstract(pointcutDef.getModifiers())) {
			if (onType != null) {
				scope.message(IMessage.ERROR, this, 
								"can't make static reference to abstract pointcut");
				return;
			} else if (!searchType.isAbstract()) {
				scope.message(IMessage.ERROR, this,
								"can't use abstract pointcut in concrete context");
				return;
			}
		}
		
		
		ResolvedType[] parameterTypes = 
			scope.getWorld().resolve(pointcutDef.getParameterTypes());
		
		if (parameterTypes.length != arguments.size()) {
			scope.message(IMessage.ERROR, this, "incompatible number of arguments to pointcut, expected " +
						parameterTypes.length + " found " + arguments.size());
			return;
		}
		
		
		
		for (int i=0,len=arguments.size(); i < len; i++) {
			TypePattern p = arguments.get(i);
			//we are allowed to bind to pointcuts which use subtypes as this is type safe
			if (p == TypePattern.NO) {
				scope.message(IMessage.ERROR, this,
								"bad parameter to pointcut reference");
				return;
			}
			if (!p.matchesSubtypes(parameterTypes[i]) && 
				!p.getExactType().equals(UnresolvedType.OBJECT))
			{
				scope.message(IMessage.ERROR, p, "incompatible type, expected " +
						parameterTypes[i].getName() + " found " + p);
				return;
			}
		}
		
		if (onType != null) {
			if (onType.isParameterizedType()) {
				// build a type map mapping type variable names in the generic type to
				// the type parameters presented
				typeVariableMap = new HashMap();
				ResolvedType underlyingGenericType = ((ResolvedType) onType).getGenericType();
				TypeVariable[] tVars = underlyingGenericType.getTypeVariables();
				ResolvedType[] typeParams = ((ResolvedType)onType).getResolvedTypeParameters();
				for (int i = 0; i < tVars.length; i++) {
					typeVariableMap.put(tVars[i].getName(),typeParams[i]);
				}
			} else if (onType.isGenericType()) {
				scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_REFERENCE_POINTCUT_IN_RAW_TYPE),
						getSourceLocation()));
			}
		}
	}
================= fetch public void testParameterizedGenericMethods() { 3021284^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
//public void testCantProvideDefaultImplViaITD_pr110307_6() {runTest("Cant provide default implementation via ITD - 6");}
public void testCantProvideDefaultImplViaITD_pr110307_7() {runTest("Cant provide default implementation via ITD - 7");}
================= fetch private boolean weaveAtMethodOnITDSRepeatedly(List decaMCs, List itdMethodsCtors f06df41^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
     * Applies some set of declare @method/@ctor constructs (List<DeclareAnnotation>) to some bunch 
     * of ITDmembers (List<BcelTypeMunger>.  It will iterate over the fields repeatedly until
     * everything has been applied.
     */
private boolean weaveAtMethodOnITDSRepeatedly(List decaMCs, List itdMethodsCtors,List reportedErrors) {
		boolean isChanged = false;
		for (Iterator iter = itdMethodsCtors.iterator(); iter.hasNext();) {
			BcelTypeMunger methodctorMunger = (BcelTypeMunger) iter.next();
			ResolvedMember unMangledInterMethod = methodctorMunger.getSignature();
			List worthRetrying = new ArrayList();
			boolean modificationOccured = false;
			
			for (Iterator iter2 = decaMCs.iterator(); iter2.hasNext();) {
				DeclareAnnotation decaMC = (DeclareAnnotation) iter2.next();
				if (decaMC.matches(unMangledInterMethod,world)) {
					LazyMethodGen annotationHolder = locateAnnotationHolderForMethodCtorMunger(clazz,methodctorMunger);
					if (annotationHolder == null || doesAlreadyHaveAnnotation(annotationHolder,unMangledInterMethod,decaMC,reportedErrors)){
						continue; // skip this one...
					}
					annotationHolder.addAnnotation(decaMC.getAnnotationX());
					isChanged=true;
					AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decaMC.getSourceLocation(),unMangledInterMethod.getSourceLocation());
					modificationOccured = true;					
				} else {
					if (!decaMC.isStarredAnnotationPattern()) 
						worthRetrying.add(decaMC); // an annotation is specified that might be put on by a subsequent decaf
				}
			}
			
		    while (!worthRetrying.isEmpty() && modificationOccured) {
				modificationOccured = false;
                List forRemoval = new ArrayList();
                for (Iterator iter2 = worthRetrying.iterator(); iter.hasNext();) {
				  DeclareAnnotation decaMC = (DeclareAnnotation) iter2.next();
				  if (decaMC.matches(unMangledInterMethod,world)) {
					LazyMethodGen annotationHolder = locateAnnotationHolderForFieldMunger(clazz,methodctorMunger);
					if (doesAlreadyHaveAnnotation(annotationHolder,unMangledInterMethod,decaMC,reportedErrors)) continue; // skip this one...
					annotationHolder.addAnnotation(decaMC.getAnnotationX());
					unMangledInterMethod.addAnnotation(decaMC.getAnnotationX());
					AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decaMC.getSourceLocation(),unMangledInterMethod.getSourceLocation());
					isChanged = true;
					modificationOccured = true;
					forRemoval.add(decaMC);
				  }
				  worthRetrying.removeAll(forRemoval);
                }
		    }
	      }
	      return isChanged;
	}
================= fetch private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) { f06df41^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
     * Weave any declare @method/@ctor statements into the members of the supplied class
     */
private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {
		List reportedProblems = new ArrayList();
		
		List allDecams = world.getDeclareAnnotationOnMethods();
		if (allDecams.isEmpty()) return false; // nothing to do
		
		boolean isChanged = false;

		// deal with ITDs
		List itdMethodsCtors = getITDSubset(clazz,ResolvedTypeMunger.Method);
		itdMethodsCtors.addAll(getITDSubset(clazz,ResolvedTypeMunger.Constructor));		
		if (!itdMethodsCtors.isEmpty()) {
			// Can't use the subset called 'decaMs' as it won't be right for ITDs...
 	        isChanged = weaveAtMethodOnITDSRepeatedly(allDecams,itdMethodsCtors,reportedProblems);
		}
		
		// deal with all the other methods...
        List members = clazz.getMethodGens();
		List decaMs = getMatchingSubset(allDecams,clazz.getType());		
		if (decaMs.isEmpty()) return false; // nothing to do
		if (!members.isEmpty()) {
          for (int memberCounter = 0;memberCounter<members.size();memberCounter++) {
            LazyMethodGen mg = (LazyMethodGen)members.get(memberCounter);
            if (!mg.getName().startsWith(NameMangler.PREFIX)) {
            	
            	// Single first pass
            	List worthRetrying = new ArrayList();
            	boolean modificationOccured = false;
            	
            	for (Iterator iter = decaMs.iterator(); iter.hasNext();) {
            		DeclareAnnotation decaM = (DeclareAnnotation) iter.next();
            		
            		if (decaM.matches(mg.getMemberView(),world)) {
            			if (doesAlreadyHaveAnnotation(mg.getMemberView(),decaM,reportedProblems)) continue; // skip this one...
            			
            			Annotation a = decaM.getAnnotationX().getBcelAnnotation();
            			AnnotationGen ag = new AnnotationGen(a,clazz.getConstantPoolGen(),true);
            			Method oldMethod = mg.getMethod();
            			MethodGen myGen = new MethodGen(oldMethod,clazz.getClassName(),clazz.getConstantPoolGen());
            			myGen.addAnnotation(ag);
            			Method newMethod = myGen.getMethod();
            			mg.addAnnotation(decaM.getAnnotationX());
            			members.set(memberCounter,new LazyMethodGen(newMethod,clazz));
            			
            			AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decaM.getSourceLocation(),clazz.getName(),mg.getMethod());
            			
            			reportMethodCtorWeavingMessage(clazz, mg, decaM);
            			isChanged = true;
            			modificationOccured = true;
            		} else {
            			if (!decaM.isStarredAnnotationPattern()) 
            				worthRetrying.add(decaM); // an annotation is specified that might be put on by a subsequent decaf
            		}
            	}
            	
            	// Multiple secondary passes
            	while (!worthRetrying.isEmpty() && modificationOccured) {
            		modificationOccured = false;
            		// lets have another go
            		List forRemoval = new ArrayList();
            		for (Iterator iter = worthRetrying.iterator(); iter.hasNext();) {
            			DeclareAnnotation decaM = (DeclareAnnotation) iter.next();
            			if (decaM.matches(mg.getMemberView(),world)) {
            				if (doesAlreadyHaveAnnotation(mg.getMemberView(),decaM,reportedProblems)) continue; // skip this one...
            				mg.addAnnotation(decaM.getAnnotationX());
            				AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decaM.getSourceLocation(),clazz.getName(),mg.getMethod());
            				isChanged = true;
            				modificationOccured = true;
            				forRemoval.add(decaM);
            			}
            		}
            		worthRetrying.removeAll(forRemoval);
            	}
            }
          }
        }
		return isChanged;
    }
================= fetch private void reportMethodCtorWeavingMessage(LazyClassGen clazz, LazyMethodGen mg f06df41^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
// TAG: WeavingMessage
private void reportMethodCtorWeavingMessage(LazyClassGen clazz, LazyMethodGen mg, DeclareAnnotation decaM) {
		if (!getWorld().getMessageHandler().isIgnoring(IMessage.WEAVEINFO)){
			StringBuffer parmString = new StringBuffer("(");
			Type[] args = mg.getMethod().getArgumentTypes();
			for (int i = 0; i < args.length; i++) {
				Type type2 = args[i];
				String s = org.aspectj.apache.bcel.classfile.Utility.signatureToString(type2.getSignature());
				if (s.lastIndexOf(".")!=-1) s =s.substring(s.lastIndexOf(".")+1);
				parmString.append(s);
				if ((i+1)<args.length) parmString.append(",");
			}
			parmString.append(")");
			String methodName = mg.getMethod().getName();
			StringBuffer sig = new StringBuffer();
			sig.append(org.aspectj.apache.bcel.classfile.Utility.accessToString(mg.getMethod().getAccessFlags()) );
			sig.append(" ");
			sig.append(mg.getMethod().getReturnType().toString());
			sig.append(" ");
			sig.append(clazz.getName());
			sig.append(".");
			sig.append(methodName.equals("<init>")?"new":methodName);
			sig.append(parmString);
			
			StringBuffer loc = new StringBuffer();
			if (clazz.getFileName()==null) {
				loc.append("no debug info available");
			} else {
				loc.append(clazz.getFileName());
				if (mg.getDeclarationLineNumber()!=-1) {
					loc.append(":"+mg.getDeclarationLineNumber());
				}
			}
			getWorld().getMessageHandler().handleMessage(
					WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_ANNOTATES,
							new String[]{
							sig.toString(),
							loc.toString(),
							decaM.getAnnotationString(),
							methodName.startsWith("<init>")?"constructor":"method",
							decaM.getAspect().toString(),
							Utility.beautifyLocation(decaM.getSourceLocation())
							}));	
		}
	}
================= fetch public void testVarArgsIITDInConstructor() { f06df41^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testVarArgsIITDInConstructor() {
	  runTest("ITD varargs in constructor");
  }
================= fetch protected File getSpecFile() { ae612d9^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testVarargsITD_pr110906() { runTest("ITD varargs problem");}
================= fetch public int hashCode() { ae612d9^:weaver/src/org/aspectj/weaver/patterns/BindingTypePattern.java

public int hashCode() {
        int result = 17;
        result = 37*result + type.hashCode();
        result = 37*result + formalIndex;
        return result;
    }
Progress : [##########################--------------] 66%================= fetch private File makeFile(File dir, String name) { 332a5df^:util/src/org/aspectj/util/ConfigParser.java

private File makeFile(File dir, String name) {
        name = name.replace('/', File.separatorChar);
        File ret = new File(name);
        if (dir != null && !ret.isAbsolute()) { 
          ret = new File(dir, name);
        }
        try {
        	ret = ret.getCanonicalFile();
        } catch (IOException ioEx) {
        	// proceed without canonicalization
        	// so nothing to do here
        }
        return ret;
    }
================= fetch private final void readConstantPool() throws IOException, ClassFormatException 999d9b0^:bcel-builder/src/org/aspectj/apache/bcel/classfile/ClassParser.java
/**
   * Read constant pool entries.
   * @throws  IOException
   * @throws  ClassFormatException
   */
private final void readConstantPool() throws IOException, ClassFormatException
  {
    constant_pool = new ConstantPool(file);
  }
================= fetch public BcelObjectType addSourceObjectType(JavaClass jc) { 04e8dca^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java

public BcelObjectType addSourceObjectType(JavaClass jc) {
		BcelObjectType ret = null;
		String signature = UnresolvedType.forName(jc.getClassName()).getSignature();
        ReferenceType nameTypeX = (ReferenceType)typeMap.get(signature);

        if (nameTypeX == null) {        	
		    if (jc.isGeneric()) {
		    	nameTypeX =  ReferenceType.fromTypeX(UnresolvedType.forRawTypeName(jc.getClassName()),this);
		        ret = makeBcelObjectType(nameTypeX, jc, true);
		    	ReferenceType genericRefType = new ReferenceType(
		    			UnresolvedType.forGenericTypeSignature(signature,ret.getDeclaredGenericSignature()),this);
				nameTypeX.setDelegate(ret);
		    	genericRefType.setDelegate(ret);
		    	nameTypeX.setGenericType(genericRefType);
		       	typeMap.put(signature, nameTypeX);
		    } else {
	        	nameTypeX = new ReferenceType(signature, this);
	            ret = makeBcelObjectType(nameTypeX, jc, true);
	           	typeMap.put(signature, nameTypeX);
		    }
        } else {
            ret = makeBcelObjectType(nameTypeX, jc, true);
        }
		return ret;
	}
================= fetch public ResolvedType put(String key, ResolvedType type) { 04e8dca^:weaver/src/org/aspectj/weaver/World.java

public boolean isInJava5Mode() {
		return behaveInJava5Way;
	}
================= fetch private static void processMembers(List/*IProgramElement*/ members, PrintWriter ab6c7a5^:ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java

private static void processMembers(List/*IProgramElement*/ members, PrintWriter writer, boolean declaringTypeIsInterface) throws DocException {
    	for (Iterator it = members.iterator(); it.hasNext();) {
			IProgramElement member = (IProgramElement) it.next();
		
	    	if (member.getKind().isType()) { 
	    		if (!member.getParent().getKind().equals(IProgramElement.Kind.METHOD)
	    			 && !StructureUtil.isAnonymous(member)) {// don't print anonymous types
//	    			System.err.println(">>>>>>>>>>>>>" + member.getName() + "<<<<" + member.getParent());
	    			processTypeDeclaration(member, writer);
	    		}
			} else {
		    	String formalComment = addDeclID(member, member.getFormalComment());;
		    	writer.println(formalComment);
		    	
		    	String signature = ""; 
		    	if (!member.getKind().equals(IProgramElement.Kind.POINTCUT)
		    	    && !member.getKind().equals(IProgramElement.Kind.ADVICE)) {
					signature = member.getSourceSignature();//StructureUtil.genSignature(member);
					if (member.getKind().equals(IProgramElement.Kind.ENUM_VALUE)){
						if (((IProgramElement)members.get(members.indexOf(member)+1)).getKind().equals(IProgramElement.Kind.ENUM_VALUE)){
							// if the next member is also an ENUM_VALUE:
							signature = signature + ",";
						} else {
							signature = signature + ";";
						}
					}
                } 
		    	
		    	if (member.getKind().isDeclare()) {
		    		System.err.println("> Skipping declare (ajdoc limitation): " + member.toLabelString());
		    	} else if (signature != null &&
		    		signature != "" && 
		    		!member.getKind().isInterTypeMember() &&
					!member.getKind().equals(IProgramElement.Kind.INITIALIZER) &&
					!StructureUtil.isAnonymous(member)) {   
		    		writer.print(signature);
		    	} else {
//		    		System.err.println(">> skipping: " + member.getKind());
		    	}  
		      
		    	if (member.getKind().equals(IProgramElement.Kind.METHOD) ||
		    		member.getKind().equals(IProgramElement.Kind.CONSTRUCTOR)) {
		    		if (member.getParent().getKind().equals(IProgramElement.Kind.INTERFACE) ||
		    			signature.indexOf("abstract ") != -1) {
		    			writer.println(";");
		    		} else {
		    			writer.println(" { }");
		    		}
		    		
		    	} else if (member.getKind().equals(IProgramElement.Kind.FIELD)) {
//		    		writer.println(";");
		    	}
			}
		}
    }
================= fetch protected void setUp() throws Exception { ab6c7a5^:ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.java

protected void setUp() throws Exception {
		super.setUp();
		new File("testdata/spacewar/docdir").delete();
	}
================= fetch public static Test suite() { ab6c7a5^:ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java

public static Test suite() {
        TestSuite suite = new TestSuite(AjdocTests.class.getName());
        //$JUnit-BEGIN$
        suite.addTestSuite(SpacewarTestCase.class);
        suite.addTestSuite(PatternsTestCase.class);
        suite.addTestSuite(CoverageTestCase.class); 
        suite.addTestSuite(ExecutionTestCase.class);// !!! must be last because it exists
        //$JUnit-END$
        return suite;
    }
================= fetch public void testFailingBuild() { ab6c7a5^:ajdoc/testsrc/org/aspectj/tools/ajdoc/ExecutionTestCase.java

public void testFailingBuild() {
		File file1 = new File("testdata/failing-build/Fail.java");
		String[] args = { file1.getAbsolutePath() };
		
		org.aspectj.tools.ajdoc.Main.main(args);
		assertTrue(Main.hasAborted());
	}
================= fetch public void testPublicModeExample() { ab6c7a5^:ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.java

public void testPublicModeExample() {
		File outdir = new File("testdata/spacewar/docdir");
		File sourcepath = new File("testdata/spacewar");
		
		String[] args = { 
		        "-public",
                "-classpath",
                AjdocTests.ASPECTJRT_PATH.getPath(),
		        "-d", 
				outdir.getAbsolutePath(),
				"-sourcepath",
				sourcepath.getAbsolutePath(),
				"spacewar",
				"coordination" };
		
		org.aspectj.tools.ajdoc.Main.main(args);
		assertTrue(true);
	}
================= fetch public void testSimpleExample() { ab6c7a5^:ajdoc/testsrc/org/aspectj/tools/ajdoc/PatternsTestCase.java

public void testSimpleExample() {
		  
//		System.err.println(new File("testdata.figures-demo").exists());
//		File file1 = new File("testdata/patterns/allPatterns.lst");
		File outdir = new File("testdata/patterns/doc");
		File srcdir = new File("../docs/sandbox/ubc-design-patterns/src");
		
		String[] args = { 
//			"-XajdocDebug", 
                "-classpath",
                AjdocTests.ASPECTJRT_PATH.getPath(),
			"-d", 
			outdir.getAbsolutePath(),
			"-sourcepath", 
			srcdir.getAbsolutePath(),
			"ca.ubc.cs.spl.aspectPatterns.patternLibrary",
			"ca.ubc.cs.spl.aspectPatterns.examples.abstractFactory.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.abstractFactory.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.builder.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.builder.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.factoryMethod.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.factoryMethod.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.prototype.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.prototype.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.singleton.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.singleton.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.adapter.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.adapter.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.bridge.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.bridge.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.composite.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.composite.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.decorator.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.decorator.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.facade.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.facade.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.flyweight.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.flyweight.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.proxy.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.proxy.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.chainOfResponsibility.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.chainOfResponsibility.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.command.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.command.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.interpreter.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.interpreter.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.iterator.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.iterator.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.mediator.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.mediator.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.memento.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.memento.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.observer.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.observer.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.state.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.state.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.strategy.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.strategy.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.templateMethod.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.templateMethod.aspectj",
			"ca.ubc.cs.spl.aspectPatterns.examples.visitor.java",
			"ca.ubc.cs.spl.aspectPatterns.examples.visitor.aspectj"
		};
		
		org.aspectj.tools.ajdoc.Main.main(args);
	}
================= fetch static String generateAffects(IProgramElement decl, boolean isIntroduction) { ab6c7a5^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java
/**
     * TODO: probably want to make this the same for intros and advice.
     */
static String generateAffects(IProgramElement decl, boolean isIntroduction) {

      List targets = StructureUtil.getTargets(decl, IRelationship.Kind.ADVICE);
      if (targets == null) return null;
        List packageList = new ArrayList();
        String entry
        = "<TABLE WIDTH=\"100%\" BGCOLOR=#FFFFFF><TR>" +
          "<TD width=\"10%\" bgcolor=\"#FFD8B0\"><B><FONT COLOR=000000>&nbsp;Advises:</b></font></td><td>";
    
		String relativePackagePath =
			getRelativePathFromHere(
				decl.getPackageName().replace('.', '/') + Config.DIR_SEP_CHAR);    
    
        List addedNames = new ArrayList(); // for ensuring that we don't add duplciates
        for (Iterator it = targets.iterator(); it.hasNext(); ) {
        	String currHandle = (String)it.next();
        	IProgramElement currDecl = AsmManager.getDefault().getHierarchy().findElementForHandle(currHandle);
            if (currDecl.getKind().equals(IProgramElement.Kind.CODE)) {
            	currDecl = currDecl.getParent(); // promote to enclosing
            }
        	if (currDecl != null && !StructureUtil.isAnonymous(currDecl.getParent())) {
        		String packagePath = "";
        		if (currDecl.getPackageName() != null && !currDecl.getPackageName().equals("")) {
        			packagePath = currDecl.getPackageName().replace('.', '/') + Config.DIR_SEP_CHAR;
        		}
        		
				String typeSignature = constructNestedTypeName(currDecl);
        		
        		String hrefName = 
        			packagePath
					+ typeSignature;       		
        		
        		// Start the hRefLink with the relative path based on where
        		// *this* type (i.e. the advisor) is in the package structure.  
        		String hrefLink = 
					relativePackagePath
					+ packagePath 
					+ typeSignature
        			+ ".html";
        		
        		if (!currDecl.getKind().isType()) {
        			hrefName += '.' + currDecl.getName();
					hrefLink += "#" + currDecl.toLabelString();
        		}
        		
        		if (!addedNames.contains(hrefName)) {
	                entry += "<A HREF=\"" + hrefLink +
	                             "\"><tt>" + hrefName.replace('/', '.') + "</tt></A>";  // !!! don't replace
	                if (it.hasNext()) entry += ", ";
	                addedNames.add(hrefName);
        		}
        	}
        }
        entry += "</B></FONT></TD></TR></TABLE>\n</TR></TD>\n";
        return entry;
    }
================= fetch static String generateHREFName(IProgramElement decl) { ab6c7a5^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java

static String generateHREFName(IProgramElement decl) {
        String hrefLink = decl.toLabelString(); // !!!
        return hrefLink;
    }
================= fetch static void addAspectDocumentation(IProgramElement node, StringBuffer fileBuffer ab6c7a5^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java

void addAspectDocumentation(IProgramElement node, StringBuffer fileBuffer, int index ) {
    	List pointcuts = new ArrayList();
    	List advice = new ArrayList();
    	for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
    		IProgramElement member = (IProgramElement)it.next();
    		if (member.getKind().equals(IProgramElement.Kind.POINTCUT)) {
    			pointcuts.add(member);
    		} else if (member.getKind().equals(IProgramElement.Kind.ADVICE)) {
    			advice.add(member);
    		}
    	}
    	if (pointcuts.size() > 0) {
    		insertDeclarationsSummary(fileBuffer, pointcuts, "Pointcut Summary", index);
    		insertDeclarationsDetails(fileBuffer, pointcuts, "Pointcut Detail", index);
    	}
    	if (advice.size() > 0) {
    		insertDeclarationsSummary(fileBuffer, advice, "Advice Summary", index);
    		insertDeclarationsDetails(fileBuffer, advice, "Advice Detail", index);
    	}
    }
================= fetch static void decorateMemberDocumentation(IProgramElement node, ab6c7a5^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java

static void decorateMemberDocumentation(IProgramElement node,
                                             StringBuffer fileContentsBuffer,
                                              int index ) {
    	List targets = StructureUtil.getTargets(node, IRelationship.Kind.ADVICE);
        if (targets != null && !targets.isEmpty()) {
            String prevName = "";
            
            String adviceDoc
            = "<TABLE WIDTH=\"100%\" BGCOLOR=#FFFFFF><TR>" +
              "<TD width=\"15%\" bgcolor=\"#FFD8B0\"><B><FONT COLOR=000000>&nbsp;Advised&nbsp;by:</font></b></td><td>";

			String relativePackagePath =
				getRelativePathFromHere(
					node.getPackageName().replace('.', '/') + Config.DIR_SEP_CHAR);

            List addedNames = new ArrayList();
            for (Iterator it = targets.iterator(); it.hasNext(); ) {
            	String currHandle = (String)it.next();
            	IProgramElement currDecl = AsmManager.getDefault().getHierarchy().findElementForHandle(currHandle);
            	
        		String packagePath = "";
        		if (currDecl.getPackageName() != null && !currDecl.getPackageName().equals("")) {
        			packagePath = currDecl.getPackageName().replace('.', '/') + Config.DIR_SEP_CHAR;
        		}
            	
            	String hrefName = "";  
                String hrefLink = "";

				// Start the hRefLink with the relative path based on where
				// *this* type (i.e. the advised) is in the package structure.  
				hrefLink = relativePackagePath + packagePath;

                if (currDecl.getPackageName() != null ) {
                   hrefName = currDecl.getPackageName().replace('.', '/');
//                   hrefLink = "";//+ currDecl.getPackageName() + Config.DIR_SEP_CHAR;
                } 
                hrefName += Config.DIR_SEP_CHAR +
                              currDecl.getParent().toLinkLabelString()
							  + "." + currDecl.getName();
                  
                hrefLink += currDecl.getParent().toLinkLabelString() + ".html"
					  + "#" + currDecl.toLabelString(); 

                if (!addedNames.contains(hrefName)) {
	                adviceDoc = adviceDoc +
	                        "<A HREF=\"" + hrefLink + "\"><tt>"
	                        + hrefName.replace('/', '.') + "</tt></A>";  
	                
	                if (it.hasNext()) adviceDoc += ", ";
	                addedNames.add(hrefName);
                }
            }
            adviceDoc += "</TR></TD></TABLE>\n";
            fileContentsBuffer.insert( index, adviceDoc );
        }
    }
================= fetch static void insertDeclarationsDetails(StringBuffer fileBuffer, ab6c7a5^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java

================= fetch static void insertDeclarationsSummary(StringBuffer fileBuffer, ab6c7a5^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java

================= fetch public void testBuildingDependantProjects() { 727b0f5^:tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java
/**
	 * Now the most complex test.  Create a dependancy between two projects.  Building
	 * one may affect whether the other does an incremental or full build.  The
	 * structural information recorded in the state object should be getting used
	 * to control whether a full build is necessary...
	 */
public void testBuildingDependantProjects() {
		initialiseProject("P1");
		initialiseProject("P2");
		configureNewProjectDependency("P2","P1");
		
		build("P1");
		build("P2"); // now everything is consistent and compiled
		alter("P1","inc1"); // adds a second class
		build("P1");
		build("P2"); // although a second class was added - P2 can't be using it, so we don't full build here :)
		checkWasntFullBuild();
		alter("P1","inc3"); // structurally changes one of the classes
		build("P1");
		build("P2"); // build notices the structural change
		checkWasFullBuild();
		alter("P1","inc4");
		build("P1");
		build("P2"); // build sees a change but works out its not structural
		checkWasntFullBuild();
	}
================= fetch String next() { 12e6334^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java

String next() {
                String err = null;
                if (!hasNext()) {
                    err = "need arg for flag " + args[args.length-1];
                } else {
                    String s = args[index++];
                    if (null == s) {
                        err = "null value";                                            
                    } else {
                        s = s.trim();
                        if (0 == s.trim().length()) {
                            err = "no value";                                            
                        } else {
                            return s;
                        }
                    }
                }
                err += " at [" + index + "] of " + Arrays.asList(args);
                throw new BuildException(err);
            }
================= fetch private CRSOptions() { 12e6334^:testing/src/org/aspectj/testing/harness/bridge/CompilerRun.java

public String toString() {
                return "TestSetup("
                    + (null == compilerName ? "" : compilerName + " ")
                    + (!ignoreWarningsSet
                        ? ""
                        : (ignoreWarnings ? "" : "do not ")
                            + "ignore warnings ")
                    + (result ? "" : "setup failed")
                    + ")";
            }
================= fetch private Set findAspectsForMungers(LazyMethodGen mg) { 12e6334^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

private Set findAspectsForMungers(LazyMethodGen mg) {
		Set aspectsAffectingType = new HashSet();
		for (Iterator iter = mg.matchedShadows.iterator(); iter.hasNext();) {
			BcelShadow aShadow = (BcelShadow) iter.next();	
			// Mungers in effect on that shadow
			for (Iterator iter2 = aShadow.getMungers().iterator();iter2.hasNext();) {
				ShadowMunger aMunger = (ShadowMunger) iter2.next();
				if (aMunger instanceof BcelAdvice) {
					BcelAdvice bAdvice = (BcelAdvice)aMunger;
					aspectsAffectingType.add(bAdvice.getConcreteAspect().getName());
				} else {
				// It is a 'Checker' - we don't need to remember aspects that only contributed Checkers...
				}		
			}
		}
		return aspectsAffectingType;
	}
================= fetch private WeaverStateInfo(List typeMungers, boolean oldStyle,boolean reweavableMod 12e6334^:weaver/src/org/aspectj/weaver/WeaverStateInfo.java

================= fetch private static void readAnyReweavableData(WeaverStateInfo wsi,DataInputStream s) 12e6334^:weaver/src/org/aspectj/weaver/WeaverStateInfo.java
////
private static void readAnyReweavableData(WeaverStateInfo wsi,DataInputStream s) throws IOException {

		if (wsi.isReweavable()) {		
			// Load list of aspects that need to exist in the world for reweaving to be 'legal'
			int numberAspectsAffectingType = s.readShort();
			for (int i=0; i < numberAspectsAffectingType; i++) {wsi.addAspectAffectingType(s.readUTF());} 
			
			int unwovenClassFileSize = s.readInt();
			byte[] classData = null;					
			// The data might or might not be compressed:
			if (!wsi.reweavableCompressedMode) {
				// Read it straight in
				classData = new byte[unwovenClassFileSize];
				int bytesread = s.read(classData);
				if (bytesread!=unwovenClassFileSize) 
				  throw new IOException("ERROR whilst reading reweavable data, expected "+
				                        unwovenClassFileSize+" bytes, only found "+bytesread);
			} else {
				// Decompress it
				classData = new byte[unwovenClassFileSize];
						
				ZipInputStream zis = new ZipInputStream(s);
				ZipEntry zen = zis.getNextEntry();
				int current = 0; 
				int bytesToGo=unwovenClassFileSize;
				while (bytesToGo>0) {
					int amount = zis.read(classData,current,bytesToGo);
					current+=amount;
					bytesToGo-=amount;
				}
				zis.closeEntry();
				if (bytesToGo!=0) 
				  throw new IOException("ERROR whilst reading compressed reweavable data, expected "+
				                        unwovenClassFileSize+" bytes, only found "+current);
			}
			wsi.setUnwovenClassFileData(classData);
		}
	}
================= fetch private static void writeAnyReweavableData(WeaverStateInfo wsi,DataOutputStream 12e6334^:weaver/src/org/aspectj/weaver/WeaverStateInfo.java

private static void writeAnyReweavableData(WeaverStateInfo wsi,DataOutputStream s) throws IOException {
		if (wsi.isReweavable()) {
			// Write out list of aspects that must exist next time we try and weave this class
			s.writeShort(wsi.aspectsAffectingType.size());
			if (wsi.aspectsAffectingType.size()>0) {
				for (Iterator iter = wsi.aspectsAffectingType.iterator(); iter.hasNext();) {
					String type = (String) iter.next();
					s.writeUTF(type);	
				}
			}
			byte[] data = wsi.unwovenClassFile;
			s.writeInt(data.length);
			// Do we need to compress the data?
			if (!wsi.reweavableCompressedMode) {
				s.write(wsi.unwovenClassFile);
			} else {
				ZipOutputStream zos = new ZipOutputStream(s);
				ZipEntry ze = new ZipEntry("data");
				zos.putNextEntry(ze);
				zos.write(wsi.unwovenClassFile,0,wsi.unwovenClassFile.length);
				zos.closeEntry();
			}
		}
	}
================= fetch private void implement(LazyMethodGen mg) { 12e6334^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
// ----
private void implement(LazyMethodGen mg) {
    	List shadows = mg.matchedShadows;
    	if (shadows == null) return;
        // We depend on a partial order such that inner shadows are earlier on the list
        // than outer shadows.  That's fine.  This order is preserved if:
        
        // A preceeds B iff B.getStart() is LATER THAN A.getStart().
        
        for (Iterator i = shadows.iterator(); i.hasNext(); ) {
            BcelShadow shadow = (BcelShadow)i.next();
            ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.IMPLEMENTING_ON_SHADOW,shadow);
            shadow.implement();
            CompilationAndWeavingContext.leavingPhase(tok);
        }
        mg.matchedShadows = null;
    }
================= fetch private void initBcelWorld(IMessageHandler handler) throws IOException { 12e6334^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/** init only on initial batch compile? no file-specific options */
private void initBcelWorld(IMessageHandler handler) throws IOException {
		List cp = buildConfig.getBootclasspath();
		cp.addAll(buildConfig.getClasspath());
		BcelWorld bcelWorld = new BcelWorld(cp, handler, null);
		bcelWorld.setBehaveInJava5Way(buildConfig.getBehaveInJava5Way());
		bcelWorld.setXnoInline(buildConfig.isXnoInline());
		bcelWorld.setXlazyTjp(buildConfig.isXlazyTjp());
		bcelWorld.setXHasMemberSupportEnabled(buildConfig.isXHasMemberEnabled());
		bcelWorld.setPinpointMode(buildConfig.isXdevPinpoint());
		BcelWeaver bcelWeaver = new BcelWeaver(bcelWorld);
		state.setWorld(bcelWorld);
		state.setWeaver(bcelWeaver);
		state.binarySourceFiles = new HashMap();
		
		for (Iterator i = buildConfig.getAspectpath().iterator(); i.hasNext();) {
			File f = (File) i.next();
			bcelWeaver.addLibraryJarFile(f);
		}
		
//		String lintMode = buildConfig.getLintMode();
		
		if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
			bcelWorld.getLint().loadDefaultProperties();
		} else {
			bcelWorld.getLint().setAll(buildConfig.getLintMode());
		}
		
		if (buildConfig.getLintSpecFile() != null) {
			bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
		}
		
		//??? incremental issues
		for (Iterator i = buildConfig.getInJars().iterator(); i.hasNext(); ) {
			File inJar = (File)i.next();
			List unwovenClasses = bcelWeaver.addJarFile(inJar, buildConfig.getOutputDir(),false);
			state.binarySourceFiles.put(inJar.getPath(), unwovenClasses);
		}
		
		for (Iterator i = buildConfig.getInpath().iterator(); i.hasNext(); ) {
			File inPathElement = (File)i.next();
			if (!inPathElement.isDirectory()) {
				// its a jar file on the inpath
				// the weaver method can actually handle dirs, but we don't call it, see next block
				List unwovenClasses = bcelWeaver.addJarFile(inPathElement,buildConfig.getOutputDir(),true);
				state.binarySourceFiles.put(inPathElement.getPath(),unwovenClasses);
			} else {
				// add each class file in an in-dir individually, this gives us the best error reporting
				// (they are like 'source' files then), and enables a cleaner incremental treatment of
				// class file changes in indirs.
				File[] binSrcs = FileUtil.listFiles(inPathElement, binarySourceFilter);
				for (int j = 0; j < binSrcs.length; j++) {
					UnwovenClassFile ucf = 
						bcelWeaver.addClassFile(binSrcs[j], inPathElement, buildConfig.getOutputDir());
					List ucfl = new ArrayList();
					ucfl.add(ucf);
					state.binarySourceFiles.put(binSrcs[j].getPath(),ucfl);
				}
			}
		}
		
		
		bcelWeaver.setReweavableMode(buildConfig.isXreweavable(),buildConfig.getXreweavableCompressClasses());

		//check for org.aspectj.runtime.JoinPoint
		ResolvedType joinPoint = bcelWorld.resolve("org.aspectj.lang.JoinPoint");
		if (joinPoint.isMissing()) {
			IMessage message = 
				new Message("classpath error: unable to find org.aspectj.lang.JoinPoint (check that aspectjrt.jar is in your classpath)",
							null,
							true);
				handler.handleMessage(message);
		}
	}
================= fetch private void initWorldAndWeaver(AjCompilerOptions options) { 12e6334^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AspectJBuilder.java

private void initWorldAndWeaver(AjCompilerOptions options) {
		cpManager = new EclipseClassPathManager(nameEnvironment);
		myBcelWorld = new BcelWorld(cpManager,new UnhandledMessageHandler(getProject()),null /*(xrefHandler)*/);
		myBcelWorld.setBehaveInJava5Way(options.behaveInJava5Way);
		myBcelWorld.setXnoInline(options.xNoInline);
		myBcelWorld.setXlazyTjp(options.xLazyThisJoinPoint);
		myBcelWorld.setXHasMemberSupportEnabled(options.xHasMember);
		myBcelWorld.setPinpointMode(options.xdevPinpoint);
		setLintProperties(myBcelWorld,options);
		myWeaver = new BcelWeaver(myBcelWorld);
		myWeaver.setReweavableMode(options.xReweavable,options.xReweavableCompress);
		// TODO deal with injars, inpath, and aspectpath here...
	}
================= fetch private void registerOptions(final BcelWeaver weaver, final ClassLoader loader, 12e6334^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
     * Configure the weaver according to the option directives
     * TODO av - don't know if it is that good to reuse, since we only allow a small subset of options in LTW
     *
     * @param weaver
     * @param loader
     * @param definitions
     */
private void registerOptions(final BcelWeaver weaver, final ClassLoader loader, final List definitions) {
        StringBuffer allOptions = new StringBuffer();
        for (Iterator iterator = definitions.iterator(); iterator.hasNext();) {
            Definition definition = (Definition) iterator.next();
            allOptions.append(definition.getWeaverOptions()).append(' ');
        }

        Options.WeaverOption weaverOption = Options.parse(allOptions.toString(), loader);

        // configure the weaver and world
        // AV - code duplicates AspectJBuilder.initWorldAndWeaver()
        World world = weaver.getWorld();
        world.setMessageHandler(weaverOption.messageHandler);
        world.setXlazyTjp(weaverOption.lazyTjp);
        world.setXHasMemberSupportEnabled(weaverOption.hasMember);
        world.setPinpointMode(weaverOption.pinpoint);
        weaver.setReweavableMode(weaverOption.reWeavable, false);
        world.setXnoInline(weaverOption.noInline);
        world.setBehaveInJava5Way(weaverOption.java5);//TODO should be autodetected ?
        //-Xlintfile: first so that lint wins
        if (weaverOption.lintFile != null) {
            InputStream resource = null;
            try {
                resource = loader.getResourceAsStream(weaverOption.lintFile);
                Exception failure = null;
                if (resource != null) {
                    try {
                        Properties properties = new Properties();
                        properties.load(resource);
                        world.getLint().setFromProperties(properties);
                    } catch (IOException e) {
                        failure = e;
                    }
                }
                if (failure != null || resource == null) {
                    world.getMessageHandler().handleMessage(new Message(
                            "Cannot access resource for -Xlintfile:"+weaverOption.lintFile,
                            IMessage.WARNING,
                            failure,
                            null));
                }
            } finally {
                try { resource.close(); } catch (Throwable t) {;}
            }
        }
        if (weaverOption.lint != null) {
            if (weaverOption.lint.equals("default")) {//FIXME should be AjBuildConfig.AJLINT_DEFAULT but yetanother deps..
                bcelWorld.getLint().loadDefaultProperties();
            } else {
                bcelWorld.getLint().setAll(weaverOption.lint);
            }
        }
        //TODO proceedOnError option
    }
================= fetch public BcelWorld getWorld() { 12e6334^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

public BcelWorld getWorld() {
		return world;
	}
================= fetch public JavaClass getJavaClass(BcelWorld world) { 12e6334^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java

public JavaClass getJavaClass(BcelWorld world) {
        writeBack(world);
        return myGen.getJavaClass();
    }
================= fetch public Map getMap() { 12e6334^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java
/* (non-Javadoc)
	 * @see org.eclipse.jdt.internal.compiler.impl.CompilerOptions#getMap()
	 */
public Map getMap() {
		Map map = super.getMap();
		// now add AspectJ additional options
		map.put(OPTION_ReportInvalidAbsoluteTypeName,getSeverityString(InvalidAbsoluteTypeName));
		map.put(OPTION_ReportInvalidWildcardTypeName,getSeverityString(InvalidWildCardTypeName));
		map.put(OPTION_ReportUnresolvableMember,getSeverityString(UnresolvableMember));
		map.put(OPTION_ReportTypeNotExposedToWeaver,getSeverityString(TypeNotExposedToWeaver));
		map.put(OPTION_ReportShadowNotInStructure,getSeverityString(ShadowNotInStructure));
		map.put(OPTION_ReportUnmatchedSuperTypeInCall,getSeverityString(UnmatchedSuperTypeInCall));
		map.put(OPTION_ReportCannotImplementLazyTJP,getSeverityString(CannotImplementLazyTJP));
		map.put(OPTION_ReportNeedSerialVersionUIDField,getSeverityString(NeedSerialVersionUIDField));
		map.put(OPTION_ReportIncompatibleSerialVersion,getSeverityString(IncompatibleSerialVersion));
		
		map.put(OPTION_NoWeave, this.noWeave ? ENABLED : DISABLED);
		map.put(OPTION_XSerializableAspects,this.xSerializableAspects ? ENABLED : DISABLED);
		map.put(OPTION_XLazyThisJoinPoint,this.xLazyThisJoinPoint ? ENABLED : DISABLED);
		map.put(OPTION_XNoInline,this.xNoInline ? ENABLED : DISABLED);
		map.put(OPTION_XReweavable,this.xReweavable ? ENABLED : DISABLED);
		map.put(OPTION_XReweavableCompress,this.xReweavableCompress ? ENABLED : DISABLED);
		map.put(OPTION_XHasMember, this.xHasMember ? ENABLED : DISABLED);
		map.put(OPTION_XdevPinpoint, this.xdevPinpoint ? ENABLED : DISABLED);

		map.put(OPTION_GenerateModel,this.generateModel ? ENABLED : DISABLED);
		map.put(OPTION_GenerateJavaDocsInModel,this.generateJavaDocsInModel ? ENABLED : DISABLED);
		map.put(OPTION_Emacssym,this.generateEmacsSymFiles ? ENABLED : DISABLED);
		map.put(OPTION_XDevNoAtAspectJProcessing,this.noAtAspectJProcessing ? ENABLED : DISABLED);
		
		return map;
	}
================= fetch public Set getAspectsAffectingType() { 12e6334^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java

public Set getAspectsAffectingType() {
		if (myType.getWeaverState()==null) return null;
		return myType.getWeaverState().getAspectsAffectingType();
	}
================= fetch public String toString() { 12e6334^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java
/* (non-Javadoc)
	 * @see java.lang.Object#toString()
	 */
public String toString() {
		StringBuffer buf = new StringBuffer( super.toString() );
		// now add AspectJ additional options
		buf.append("\n\tAspectJ Specific Options:");
		buf.append("\n\t- no weave: ").append(this.noWeave ? ENABLED : DISABLED); //$NON-NLS-1$
		buf.append("\n\t- no inline (X option): ").append(this.xNoInline ? ENABLED : DISABLED); //$NON-NLS-1$
		buf.append("\n\t- generate serializable aspects (X option): ").append(this.xSerializableAspects ? ENABLED : DISABLED); //$NON-NLS-1$
		buf.append("\n\t- lazy thisJoinPoint (X option): ").append(this.xLazyThisJoinPoint ? ENABLED : DISABLED); //$NON-NLS-1$
		buf.append("\n\t- generate reweavable class files (X option): ").append(this.xReweavable ? ENABLED : DISABLED); //$NON-NLS-1$
		buf.append("\n\t- compress reweavable class files (X option): ").append(this.xReweavableCompress ? ENABLED : DISABLED); //$NON-NLS-1$		
		buf.append("\n\t- has member support (X option): ").append(this.xHasMember ? ENABLED : DISABLED); //$NON-NLS-1$

		buf.append("\n\t- generate AJDE model: ").append(this.generateModel ? ENABLED : DISABLED); //$NON-NLS-1$		
		buf.append("\n\t- generate Javadocs in AJDE model: ").append(this.generateJavaDocsInModel ? ENABLED : DISABLED); //$NON-NLS-1$		
		buf.append("\n\t- generate Emacs symbol files: ").append(this.generateEmacsSymFiles ? ENABLED : DISABLED); //$NON-NLS-1$
		buf.append("\n\t- suppress @AspectJ processing: ").append(this.noAtAspectJProcessing ? ENABLED : DISABLED); //$NON-NLS-1$
		
		buf.append("\n\t- invalid absolute type name (XLint): ").append(getSeverityString(InvalidAbsoluteTypeName)); //$NON-NLS-1$
		buf.append("\n\t- invalid wildcard type name (XLint): ").append(getSeverityString(InvalidWildCardTypeName)); //$NON-NLS-1$
		buf.append("\n\t- unresolvable member (XLint): ").append(getSeverityString(UnresolvableMember)); //$NON-NLS-1$
		buf.append("\n\t- type not exposed to weaver (XLint): ").append(getSeverityString(TypeNotExposedToWeaver)); //$NON-NLS-1$
		buf.append("\n\t- shadow not in structure (XLint): ").append(getSeverityString(ShadowNotInStructure)); //$NON-NLS-1$
		buf.append("\n\t- unmatched super type in call (XLint): ").append(getSeverityString(UnmatchedSuperTypeInCall)); //$NON-NLS-1$
		buf.append("\n\t- cannot implement lazy thisJoinPoint (XLint): ").append(getSeverityString(CannotImplementLazyTJP)); //$NON-NLS-1$
		buf.append("\n\t- need serialVersionUID field (XLint): ").append(getSeverityString(NeedSerialVersionUIDField)); //$NON-NLS-1$
		buf.append("\n\t- incompatible serial version (XLint): ").append(getSeverityString(IncompatibleSerialVersion)); //$NON-NLS-1$
		
		return buf.toString();
	}
================= fetch public String toString() { 12e6334^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java

private static File isAspectjtoolsjar(String path) {
        if (null == path) {
            return null;
        }
        final String prefix = "aspectj";        
        final String infix = "tools";        
        final String altInfix = "-tools";        
        final String suffix = ".jar";
        final int prefixLength = 7; // prefix.length();
        final int minLength = 16;
        // prefixLength + infix.length() + suffix.length();        
        if (!path.endsWith(suffix)) {
            return null;
        }
        int loc = path.lastIndexOf(prefix);
        if ((-1 != loc) && ((loc + minLength) <= path.length())) {
            String rest = path.substring(loc+prefixLength);
            if (-1 != rest.indexOf(File.pathSeparator)) {
                return null;
            }
            if (rest.startsWith(infix)
                || rest.startsWith(altInfix)) {
                File result = new File(path);
                if (result.canRead() && result.isFile()) {
                    return result;
                }
            }
        }        
        return null;
    }
================= fetch public String toString() { 12e6334^:weaver/src/org/aspectj/weaver/WeaverStateInfo.java

public String toString() {
		return "WeaverStateInfo(" + typeMungers + ", " + oldStyle + ")";
	}
================= fetch public WeaverStateInfo getOrCreateWeaverStateInfo() { 12e6334^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java

public WeaverStateInfo getOrCreateWeaverStateInfo() {
		WeaverStateInfo ret = myType.getWeaverState();
		if (ret != null) return ret;
		
		ret = new WeaverStateInfo();
		myType.setWeaverState(ret);
		return ret;
	}
================= fetch public WeaverStateInfo() { 12e6334^:weaver/src/org/aspectj/weaver/WeaverStateInfo.java

================= fetch public boolean isOldStyle() { 12e6334^:weaver/src/org/aspectj/weaver/WeaverStateInfo.java

public byte[] getUnwovenClassFileData() {
		return unwovenClassFile;
	}
================= fetch public boolean isReweavable() { 12e6334^:weaver/src/org/aspectj/weaver/WeaverStateInfo.java

public boolean isReweavable() {
		return reweavable;
	}
================= fetch public boolean isReweavable() { 12e6334^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java

public boolean isReweavable() {
		if (myType.getWeaverState()==null) return false;
        return myType.getWeaverState().isReweavable();
	}
================= fetch public boolean isXdevPinpoint() { 12e6334^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java

public boolean isXdevPinpoint() {
		return options.xdevPinpoint;
	}
================= fetch public boolean munge(BcelClassWeaver weaver) { 12e6334^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java

public boolean munge(BcelClassWeaver weaver) {
		ContextToken tok = CompilationAndWeavingContext.enteringPhase(CompilationAndWeavingContext.MUNGING_WITH, this);
		boolean changed = false;
		boolean worthReporting = true;
		
		if (munger.getKind() == ResolvedTypeMunger.Field) {
			changed = mungeNewField(weaver, (NewFieldTypeMunger)munger);
		} else if (munger.getKind() == ResolvedTypeMunger.Method) {
			changed = mungeNewMethod(weaver, (NewMethodTypeMunger)munger);
		} else if (munger.getKind() == ResolvedTypeMunger.PerObjectInterface) {
			changed = mungePerObjectInterface(weaver, (PerObjectInterfaceTypeMunger)munger);
			worthReporting = false;
		} else if (munger.getKind() == ResolvedTypeMunger.PerTypeWithinInterface) {
			// PTWIMPL Transform the target type (add the aspect instance field)
			changed = mungePerTypeWithinTransformer(weaver);
			worthReporting = false;
		} else if (munger.getKind() == ResolvedTypeMunger.PrivilegedAccess) {
			changed = mungePrivilegedAccess(weaver, (PrivilegedAccessMunger)munger);
			worthReporting = false;
		} else if (munger.getKind() == ResolvedTypeMunger.Constructor) {
			changed = mungeNewConstructor(weaver, (NewConstructorTypeMunger)munger);
		} else if (munger.getKind() == ResolvedTypeMunger.Parent) {
			changed = mungeNewParent(weaver, (NewParentTypeMunger)munger);
		} else if (munger.getKind() == ResolvedTypeMunger.AnnotationOnType) {
			changed = mungeNewAnnotationOnType(weaver,(AnnotationOnTypeMunger)munger);
		} else {
			throw new RuntimeException("unimplemented");
		}
		
		if (changed && munger.changesPublicSignature()) {
			WeaverStateInfo info = 
				weaver.getLazyClassGen().getOrCreateWeaverStateInfo();
			info.addConcreteMunger(this);
		}
		// Whilst type mungers aren't persisting their source locations, we add this relationship during
		// compilation time (see other reference to ResolvedTypeMunger.persist)
		if (ResolvedTypeMunger.persistSourceLocation) {
			if (changed && worthReporting) {
				if (munger.getKind().equals(ResolvedTypeMunger.Parent)) {
			  	  AsmRelationshipProvider.getDefault().addRelationship(weaver.getLazyClassGen().getType(), munger,getAspectType());
				} else {
			  	  AsmRelationshipProvider.getDefault().addRelationship(weaver.getLazyClassGen().getType(), munger,getAspectType());	
				}
			}
		}
		
		// TAG: WeavingMessage
		if (changed && worthReporting  && munger!=null && !weaver.getWorld().getMessageHandler().isIgnoring(IMessage.WEAVEINFO)) {
			String tName = weaver.getLazyClassGen().getType().getSourceLocation().getSourceFile().getName();
			if (tName.indexOf("no debug info available")!=-1) tName = "no debug info available";
			else tName = getShortname(weaver.getLazyClassGen().getType().getSourceLocation().getSourceFile().getPath());
			String fName = getShortname(getAspectType().getSourceLocation().getSourceFile().getPath());
        	if (munger.getKind().equals(ResolvedTypeMunger.Parent)) {
        		// This message could come out of AjLookupEnvironment.addParent if doing parents
        		// munging at compile time only...
        		NewParentTypeMunger parentTM = (NewParentTypeMunger)munger;
        		if (parentTM.getNewParent().isInterface()) {
					weaver.getWorld().getMessageHandler().handleMessage(WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_DECLAREPARENTSIMPLEMENTS,
					new String[]{weaver.getLazyClassGen().getType().getName(),
					tName,parentTM.getNewParent().getName(),fName},
					weaver.getLazyClassGen().getClassName(), getAspectType().getName()));
        		} else {
                    weaver.getWorld().getMessageHandler().handleMessage(
                    WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_DECLAREPARENTSEXTENDS,
                        new String[]{weaver.getLazyClassGen().getType().getName(),
                            tName,parentTM.getNewParent().getName(),fName
                                }));
//                  TAG: WeavingMessage    DECLARE PARENTS: EXTENDS
//                  reportDeclareParentsMessage(WeaveMessage.WEAVEMESSAGE_DECLAREPARENTSEXTENDS,sourceType,parent);
                    
        		}
        	} else {
        		weaver.getWorld().getMessageHandler().handleMessage(WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_ITD,
        		new String[]{weaver.getLazyClassGen().getType().getName(),
        			         tName,munger.getKind().toString().toLowerCase(),
        			         getAspectType().getName(),
        					 fName+":'"+munger.getSignature()+"'"},
							 weaver.getLazyClassGen().getClassName(), getAspectType().getName()));
        	}	
		}
		
		CompilationAndWeavingContext.leavingPhase(tok);
		return changed;
	}
================= fetch public boolean weave() { 12e6334^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
// ----
public boolean weave() {
        if (clazz.isWoven() && !clazz.isReweavable()) {
        	world.showMessage(IMessage.ERROR, 
        		  WeaverMessages.format(WeaverMessages.ALREADY_WOVEN,clazz.getType().getName()),
				ty.getSourceLocation(), null);
        	return false;
        }
       

        Set aspectsAffectingType = null;
        if (inReweavableMode || clazz.getType().isAspect()) aspectsAffectingType = new HashSet();
        
        boolean isChanged = false;
        
        // we want to "touch" all aspects
        if (clazz.getType().isAspect()) isChanged = true;

        // start by munging all typeMungers
        for (Iterator i = typeMungers.iterator(); i.hasNext(); ) {
        	Object o = i.next();
        	if ( !(o instanceof BcelTypeMunger) ) {
        		//???System.err.println("surprising: " + o);
        		continue;
        	}
        	BcelTypeMunger munger = (BcelTypeMunger)o;
        	boolean typeMungerAffectedType = munger.munge(this);
        	if (typeMungerAffectedType) {
        		isChanged = true;
        		if (inReweavableMode || clazz.getType().isAspect()) aspectsAffectingType.add(munger.getAspectType().getName());
        	}
        }

        // Weave special half type/half shadow mungers... 
        isChanged = weaveDeclareAtMethodCtor(clazz) || isChanged;
        isChanged = weaveDeclareAtField(clazz)      || isChanged;
        
        // XXX do major sort of stuff
        // sort according to:  Major:  type hierarchy
        //                     within each list:  dominates
        // don't forget to sort addedThisInitialiers according to dominates
        addedSuperInitializersAsList = new ArrayList(addedSuperInitializers.values());
        addedSuperInitializersAsList = PartialOrder.sort(addedSuperInitializersAsList);        
        if (addedSuperInitializersAsList == null) {
        	throw new BCException("circularity in inter-types");
        }
      
        // this will create a static initializer if there isn't one
        // this is in just as bad taste as NOPs
        LazyMethodGen staticInit = clazz.getStaticInitializer();
        staticInit.getBody().insert(genInitInstructions(addedClassInitializers, true));
        
        // now go through each method, and match against each method.  This
        // sets up each method's {@link LazyMethodGen#matchedShadows} field, 
        // and it also possibly adds to {@link #initializationShadows}.
        List methodGens = new ArrayList(clazz.getMethodGens());
        for (Iterator i = methodGens.iterator(); i.hasNext();) {
            LazyMethodGen mg = (LazyMethodGen)i.next();
			if (! mg.hasBody()) continue;
			boolean shadowMungerMatched = match(mg);
			if (shadowMungerMatched) {
				// For matching mungers, add their declaring aspects to the list that affected this type
				if (inReweavableMode || clazz.getType().isAspect()) aspectsAffectingType.addAll(findAspectsForMungers(mg));
              isChanged = true;
			}
        }

        // now we weave all but the initialization shadows
		for (Iterator i = methodGens.iterator(); i.hasNext();) {
			LazyMethodGen mg = (LazyMethodGen)i.next();
			if (! mg.hasBody()) continue;
			implement(mg);
		}
			
        
        // if we matched any initialization shadows, we inline and weave
		if (! initializationShadows.isEmpty()) {
			// Repeat next step until nothing left to inline...cant go on 
			// infinetly as compiler will have detected and reported 
			// "Recursive constructor invocation"
			while (inlineSelfConstructors(methodGens));
			positionAndImplement(initializationShadows);
		}
		
        // now proceed with late type mungers
        if (lateTypeMungers != null) {
            for (Iterator i = lateTypeMungers.iterator(); i.hasNext(); ) {
                BcelTypeMunger munger = (BcelTypeMunger)i.next();
                if (munger.matches(clazz.getType())) {
                    boolean typeMungerAffectedType = munger.munge(this);
                    if (typeMungerAffectedType) {
                        isChanged = true;
                        if (inReweavableMode || clazz.getType().isAspect()) aspectsAffectingType.add(munger.getAspectType().getName());
                    }
                }
            }
        }

        //FIXME AV - see #75442, for now this is not enough to fix the bug, comment that out until we really fix it
//        // flush to save some memory
//        PerObjectInterfaceTypeMunger.unregisterFromAsAdvisedBy(clazz.getType());

		// finally, if we changed, we add in the introduced methods.
        if (isChanged) {
        	clazz.getOrCreateWeaverStateInfo();
			weaveInAddedMethods(); // FIXME asc are these potentially affected by declare annotation?
        }
        
        if (inReweavableMode || clazz.getType().isAspect()) {
        	WeaverStateInfo wsi = clazz.getOrCreateWeaverStateInfo();
        	wsi.addAspectsAffectingType(aspectsAffectingType);
        	wsi.setUnwovenClassFileData(ty.getJavaClass().getBytes());
        	wsi.setReweavable(true,compressReweavableAttributes);
        } else {
        	clazz.getOrCreateWeaverStateInfo().setReweavable(false,false);
        }
        
        return isChanged;
    }
================= fetch public static WeaverOption parse(String options, ClassLoader laoder) { 12e6334^:loadtime/src/org/aspectj/weaver/loadtime/Options.java

public static WeaverOption parse(String options, ClassLoader laoder) {
        if (LangUtil.isEmpty(options)) {
            return new WeaverOption();
        }
        // the first option wins
        List flags = LangUtil.anySplit(options, " ");
        Collections.reverse(flags);

        WeaverOption weaverOption = new WeaverOption();

        // do a first round on the message handler since it will report the options themselves
        for (Iterator iterator = flags.iterator(); iterator.hasNext();) {
            String arg = (String) iterator.next();
            if (arg.startsWith(OPTIONVALUED_messageHandler)) {
                if (arg.length() > OPTIONVALUED_messageHandler.length()) {
                    String handlerClass = arg.substring(OPTIONVALUED_messageHandler.length()).trim();
                    try {
                        Class handler = Class.forName(handlerClass, false, laoder);
                        weaverOption.messageHandler = ((IMessageHandler) handler.newInstance());
                    } catch (Throwable t) {
                        weaverOption.messageHandler.handleMessage(
                                new Message(
                                        "Cannot instantiate message handler " + handlerClass,
                                        IMessage.ERROR,
                                        t,
                                        null
                                )
                        );
                    }
                }
            }
        }

        // configure the other options
        for (Iterator iterator = flags.iterator(); iterator.hasNext();) {
            String arg = (String) iterator.next();
            if (arg.equals(OPTION_15)) {
                weaverOption.java5 = true;
            } else if (arg.equalsIgnoreCase(OPTION_lazyTjp)) {
                weaverOption.lazyTjp = true;
            } else if (arg.equalsIgnoreCase(OPTION_noinline)) {
                weaverOption.noInline = true;
            } else if (arg.equalsIgnoreCase(OPTION_noWarn) || arg.equalsIgnoreCase(OPTION_noWarnNone)) {
                weaverOption.noWarn = true;
            } else if (arg.equalsIgnoreCase(OPTION_proceedOnError)) {
                weaverOption.proceedOnError = true;
            } else if (arg.equalsIgnoreCase(OPTION_reweavable)) {
                weaverOption.reWeavable = true;
            } else if (arg.equalsIgnoreCase(OPTION_showWeaveInfo)) {
                weaverOption.showWeaveInfo = true;
            } else if (arg.equalsIgnoreCase(OPTION_hasMember)) {
                weaverOption.hasMember = true;
            }  else if (arg.equalsIgnoreCase(OPTION_verbose)) {
                weaverOption.verbose = true;
            } else if (arg.equalsIgnoreCase(OPTION_pinpoint)) {
                weaverOption.pinpoint = true;
            } else if (arg.startsWith(OPTIONVALUED_messageHandler)) {
                ;// handled in first round
            } else if (arg.startsWith(OPTIONVALUED_Xlintfile)) {
                if (arg.length() > OPTIONVALUED_Xlintfile.length()) {
                    weaverOption.lintFile = arg.substring(OPTIONVALUED_Xlintfile.length()).trim();
                }
            } else if (arg.startsWith(OPTIONVALUED_Xlint)) {
                if (arg.length() > OPTIONVALUED_Xlint.length()) {
                    weaverOption.lint = arg.substring(OPTIONVALUED_Xlint.length()).trim();
                }
            } else {
                weaverOption.messageHandler.handleMessage(
                        new Message(
                                "Cannot configure weaver with option '" + arg + "': unknown option",
                                IMessage.WARNING,
                                null,
                                null
                        )
                );
            }
        }

        // refine message handler configuration
        if (weaverOption.noWarn) {
            weaverOption.messageHandler.dontIgnore(IMessage.WARNING);
        }
        if (weaverOption.verbose) {
            weaverOption.messageHandler.dontIgnore(IMessage.DEBUG);
        }
        if (weaverOption.showWeaveInfo) {
            weaverOption.messageHandler.dontIgnore(IMessage.WEAVEINFO);
        }

        return weaverOption;
    }
================= fetch public static boolean weave( 12e6334^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

public static boolean weave(
		BcelWorld world,
		LazyClassGen clazz,
		List shadowMungers,
		List typeMungers,
        List lateTypeMungers)
	{
		boolean b =  new BcelClassWeaver(world, clazz, shadowMungers, typeMungers, lateTypeMungers).weave();
		//System.out.println(clazz.getClassName() + ", " + clazz.getType().getWeaverState());
		//clazz.print();
		return b;
	}
================= fetch public static final WeaverStateInfo read(VersionedDataInputStream s, ISourceCont 12e6334^:weaver/src/org/aspectj/weaver/WeaverStateInfo.java

public static final WeaverStateInfo read(VersionedDataInputStream s, ISourceContext context) throws IOException {
		byte b = s.readByte();
		
		boolean isReweavable = ((b&REWEAVABLE_BIT)!=0);
		if (isReweavable) b=(byte) (b-REWEAVABLE_BIT);

		boolean isReweavableCompressed = ((b&REWEAVABLE_COMPRESSION_BIT)!=0);
		if (isReweavableCompressed) b=(byte) (b-REWEAVABLE_COMPRESSION_BIT);

		switch(b) {
			case UNTOUCHED:
				throw new RuntimeException("unexpected UNWOVEN");
			case WOVEN: 
				return new WeaverStateInfo(Collections.EMPTY_LIST, true,isReweavable,isReweavableCompressed);
			case EXTENDED:
				int n = s.readShort();
				List l = new ArrayList();
				for (int i=0; i < n; i++) {
					UnresolvedType aspectType = UnresolvedType.read(s);
					ResolvedTypeMunger typeMunger = 
						ResolvedTypeMunger.read(s, context);
					l.add(new Entry(aspectType, typeMunger));
				}
			    WeaverStateInfo wsi = new WeaverStateInfo(l,false,isReweavable,isReweavableCompressed);
			    readAnyReweavableData(wsi,s);
				return wsi;
		} 
		throw new RuntimeException("bad WeaverState.Kind: " + b);
	}
================= fetch public static void main(String args[]) throws Throwable { 12e6334^:tests/java5/ataspectj/ataspectj/ltwlog/MainVerboseAndShow.java

public static void main(String args[]) throws Throwable {
        new MainVerboseAndShow().target();
        if (!MessageHolder.startsAs(Arrays.asList(new String[]{
                "info weaving 'ataspectj/ltwlog/MainVerboseAndShow'",
                "weaveinfo Join point 'method-execution(void ataspectj.ltwlog.MainVerboseAndShow.target())' in Type 'ataspectj.ltwlog.MainVerboseAndShow' (MainVerboseAndShow.java:22) advised by before advice from 'ataspectj.ltwlog.Aspect1' (Aspect1.java)",
                "info weaving 'ataspectj/ltwlog/Aspect1'"})
================= fetch public static void setReweavableMode(boolean mode,boolean compress) { 12e6334^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
// Called by the BcelWeaver to let us know all BcelClassWeavers need to collect reweavable info
public static void setReweavableMode(boolean mode,boolean compress) {
		inReweavableMode = mode;
		compressReweavableAttributes = compress;
	}
================= fetch public static void setReweavableModeDefaults(boolean mode, boolean compress) { 12e6334^:weaver/src/org/aspectj/weaver/WeaverStateInfo.java

public static void setReweavableModeDefaults(boolean mode, boolean compress) {
		reweavableDefault = mode;
		reweavableCompressedModeDefault = compress;
	}
================= fetch public void addAspectAffectingType(String aspectType) { 12e6334^:weaver/src/org/aspectj/weaver/WeaverStateInfo.java

public Set /*String*/ getAspectsAffectingType() {
		return this.aspectsAffectingType;
	}
================= fetch public void addNormalTypeMungers(String typeName) { 12e6334^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java

public UnwovenClassFile[] getClassFilesFor(LazyClassGen clazz) {
    	List childClasses = clazz.getChildClasses(world);
    	UnwovenClassFile[] ret = new UnwovenClassFile[1 + childClasses.size()];    	
    	ret[0] = new UnwovenClassFile(clazz.getFileName(),clazz.getJavaClass(world).getBytes());
    	int index = 1;
    	for (Iterator iter = childClasses.iterator(); iter.hasNext();) {
			UnwovenClassFile.ChildClass element = (UnwovenClassFile.ChildClass) iter.next();
			UnwovenClassFile childClass = new UnwovenClassFile(clazz.getFileName() + "$" + element.name, element.bytes);
			ret[index++] = childClass;
		}
    	return ret;
    }
================= fetch public void execute(AjcTestCase inTestCase) { 12e6334^:testing/newsrc/org/aspectj/testing/WeaveSpec.java

public void execute(AjcTestCase inTestCase) {
		String failMessage = "test \"" + getTest().getTitle() + "\" failed";
		try {
			File base = new File(getBaseDir());
			classFilesFromClasses = new ArrayList();
			setFiles(classesFiles);
			String[] args = buildArgs();
			CompilationResult result = inTestCase.ajc(base,args);
			inTestCase.assertNoMessages(result,failMessage);
			File sandbox = inTestCase.getSandboxDirectory();
			createJar(sandbox,"classes.jar",true);
			
			inTestCase.setShouldEmptySandbox(false); 
			setFiles(aspectsFiles);
			String options = getOptions();
			if (options == null) {
				setOptions("-Xreweavable");
			} else if (options.indexOf("-Xreweavable") == -1) {
				setOptions(options + ",-Xreweavable");
			}
			setClasspath("classes.jar");
			args = buildArgs();
			result = inTestCase.ajc(base,args);
			inTestCase.assertNoMessages(result,failMessage);
			createJar(sandbox,"aspects.jar",false);
			
			args = buildWeaveArgs();
			inTestCase.setShouldEmptySandbox(false); 
			result = inTestCase.ajc(base,args);
			AjcTestCase.MessageSpec messageSpec = buildMessageSpec();
			inTestCase.assertMessages(result,failMessage,messageSpec);
			inTestCase.setShouldEmptySandbox(false); // so subsequent steps in same test see my results
		} catch (IOException e) {
			AjcTestCase.fail(failMessage + " " + e);
		}
	}
================= fetch public void installGlobals(AjBuildConfig global) { // XXX relies on default valu 12e6334^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java
/**
     * Install global values into local config
     * unless values conflict:
     * <ul>
     * <li>Collections are unioned</li>
     * <li>values takes local value unless default and global set</li>
     * <li>this only sets one of outputDir and outputJar as needed</li>
     * <ul>
     * This also configures super if javaOptions change.
     * @param global the AjBuildConfig to read globals from
     */
public void installGlobals(AjBuildConfig global) { // XXX relies on default values
    	// don't join the options - they already have defaults taken care of.
//        Map optionsMap = options.getMap();
//        join(optionsMap,global.getOptions().getMap());
//        options.set(optionsMap);
        join(aspectpath, global.aspectpath);
        join(classpath, global.classpath);
        if (null == configFile) {
            configFile = global.configFile; // XXX correct?
        }
        if (!isEmacsSymMode() && global.isEmacsSymMode()) {
            setEmacsSymMode(true);
        }
        join(files, global.files);
        if (!isGenerateModelMode() && global.isGenerateModelMode()) {
            setGenerateModelMode(true);
        }
        if (null == incrementalFile) {
            incrementalFile = global.incrementalFile;
        }
        if (!incrementalMode && global.incrementalMode) {
            incrementalMode = true;
        }
        join(inJars, global.inJars);
        join(inPath, global.inPath);
        if ((null == lintMode) 
            || (AJLINT_DEFAULT.equals(lintMode))) {
            setLintMode(global.lintMode);
        }
        if (null == lintSpecFile) {
            lintSpecFile = global.lintSpecFile;
        }
        if (!isNoWeave() && global.isNoWeave()) {
            setNoWeave(true);
        }
        if ((null == outputDir) && (null == outputJar)) {
            if (null != global.outputDir) {
                outputDir = global.outputDir;
            }
            if (null != global.outputJar) {
                outputJar = global.outputJar;
            }
        }        
        join(sourceRoots, global.sourceRoots);
        if (!isXnoInline() && global.isXnoInline()) {
            setXnoInline(true);
        }
        if (!isXserializableAspects() && global.isXserializableAspects()) {
            setXserializableAspects(true);
        }
        if (!isXlazyTjp() && global.isXlazyTjp()) {
        	setXlazyTjp(true);
        }
        if (!isXreweavable() && global.isXreweavable()) {
        	setXreweavable(true);
        }
        if (!getXreweavableCompressClasses() && global.getXreweavableCompressClasses()) {
        	setXreweavableCompressClasses(true);
        }
    }
================= fetch public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r 12e6334^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java
/**
         * Extract AspectJ-specific options (except for argfiles).
         * Caller should warn when sourceroots is empty but in 
         * incremental mode.
         * Signals warnings or errors through handler set in constructor.
         */
public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.remove()
			int nextArgIndex = args.indexOf(arg)+1; // XXX assumes unique
            // trim arg?
            if (LangUtil.isEmpty(arg)) {
                showWarning("empty arg found");
            } else if (arg.equals("-inpath")) {;
            	if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_Inpath, CompilerOptions.PRESERVE);
					
					List inPath = buildConfig.getInpath();
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
					while (st.hasMoreTokens()) {
						String filename = st.nextToken();
						File file = makeFile(filename);
						if (file.exists() && FileUtil.hasZipSuffix(filename)) {
							inPath.add(file);    
						} else {
							if (file.isDirectory()) {
								inPath.add(file);
							} else 
		            		
							showError("bad inpath component: " + filename);  
						}
					}
					buildConfig.setInPath(inPath);
					args.remove(args.get(nextArgIndex));            		
            	}
            } else if (arg.equals("-injars")) {;
				if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_InJARs, CompilerOptions.PRESERVE);
					
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
		            	if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
			            	buildConfig.getInJars().add(jarFile);    
		            	} else {
		            		File dirFile = makeFile(filename);
		            		if (dirFile.isDirectory()) {
		            			buildConfig.getInJars().add(dirFile);
		            		} else 
		            		
                            showError("bad injar: " + filename);  
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-aspectpath")) {;
				if (args.size() > nextArgIndex) {
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
                        if (jarFile.exists() && (FileUtil.hasZipSuffix(filename) || jarFile.isDirectory())) {
			            	buildConfig.getAspectpath().add(jarFile);    
		            	} else {
                            showError("bad aspectpath: " + filename);
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-sourceroots")) {
				if (args.size() > nextArgIndex) {
					List sourceRoots = new ArrayList();
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	File f = makeFile(st.nextToken());
		            	if (f.isDirectory() && f.canRead()) {
			                sourceRoots.add(f);
		            	} else {
                            showError("bad sourceroot: " + f);
		            	}		            		
		            }
				    if (0 < sourceRoots.size()) {
						buildConfig.setSourceRoots(sourceRoots);	
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-sourceroots requires list of directories");
				}
			} else if (arg.equals("-outjar")) { 
				if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_OutJAR, CompilerOptions.GENERATE);
					File jarFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
					if (FileUtil.hasZipSuffix(jarFile)) {
						try {
							if (!jarFile.exists()) {
                                jarFile.createNewFile();
                            }
                            buildConfig.setOutputJar(jarFile);  
						} catch (IOException ioe) { 
                            showError("unable to create outjar file: " + jarFile);
						}
					} else {
						showError("invalid -outjar file: " + jarFile);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-outjar requires jar path argument");
				}
            } else if (arg.equals("-log")){
				// remove it as it's already been handled in org.aspectj.tools.ajc.Main
				args.remove(args.get(nextArgIndex));
            } else if (arg.equals("-incremental")) {
                buildConfig.setIncrementalMode(true);
            } else if (arg.equals("-XincrementalFile")) {
                if (args.size() > nextArgIndex) {
                    File file = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    buildConfig.setIncrementalFile(file);
                    if (!file.canRead()) {
                        showError("bad -XincrementalFile : " + file);
                        // if not created before recompile test, stop after first compile
                    }
                    args.remove(args.get(nextArgIndex));
                } else {
                    showError("-XincrementalFile requires file argument");
                }
			} else if (arg.equals("-emacssym")) {
				buildConfig.setEmacsSymMode(true);
				buildConfig.setGenerateModelMode(true);
			} else if (arg.equals("-XjavadocsInModel")) {
				buildConfig.setGenerateModelMode(true);
				buildConfig.setGenerateJavadocsInModelMode(true);
			} else if (arg.equals("-Xdev:NoAtAspectJProcessing")) { 
				buildConfig.setNoAtAspectJAnnotationProcessing(true);
        	} else if (arg.equals("-Xdev:Pinpoint")) { 
				buildConfig.setXdevPinpointMode(true);
        	} else if (arg.equals("-noweave") || arg.equals( "-XnoWeave")) {
				buildConfig.setNoWeave(true);
			} else if (arg.equals("-XserializableAspects")) {
				buildConfig.setXserializableAspects(true);
			} else if (arg.equals("-XlazyTjp")) {
				buildConfig.setXlazyTjp(true);
            } else if (arg.startsWith("-Xreweavable")) {
            	buildConfig.setXreweavable(true);
            	if (arg.endsWith(":compress")) {
            		buildConfig.setXreweavableCompressClasses(true);
            	}
			} else if (arg.equals("-XnoInline")) {
				buildConfig.setXnoInline(true);
            } else if (arg.equals("-XhasMember")) {
            	buildConfig.setXHasMemberSupport(true);
            }	else if (arg.startsWith("-showWeaveInfo")) {            	
            	 buildConfig.setShowWeavingInformation(true);
			} else if (arg.equals("-Xlintfile")) { 
				if (args.size() > nextArgIndex) {
					File lintSpecFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    // XXX relax restriction on props file suffix?
					if (lintSpecFile.canRead() && lintSpecFile.getName().endsWith(".properties")) {
						buildConfig.setLintSpecFile(lintSpecFile);	
					} else {
						showError("bad -Xlintfile file: " + lintSpecFile);
						buildConfig.setLintSpecFile(null);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-Xlintfile requires .properties file argument");
				}
            } else if (arg.equals("-Xlint")) {
//                buildConfig.getAjOptions().put(
//                    AjCompilerOptions.OPTION_Xlint,
//                    CompilerOptions.GENERATE);
                buildConfig.setLintMode(AjBuildConfig.AJLINT_DEFAULT);
            } else if (arg.startsWith("-Xlint:")) {
                if (7 < arg.length()) {
                    buildConfig.setLintMode(arg.substring(7));
                } else {
                    showError("invalid lint option " + arg);
                }
			} else if (arg.equals("-bootclasspath")) {
				if (args.size() > nextArgIndex) {
					String bcpArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer bcp = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(bcpArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    bcp.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        bcp.append(File.pathSeparator);
					    }
					}
					bootclasspath = bcp.toString();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-bootclasspath requires classpath entries");
				}
			} else if (arg.equals("-classpath") || arg.equals("-cp")) {
				if (args.size() > nextArgIndex) {
					String cpArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer cp = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(cpArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    cp.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        cp.append(File.pathSeparator);
					    }
					}
					classpath = cp.toString();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-classpath requires classpath entries");
				}
			} else if (arg.equals("-extdirs")) {
				if (args.size() > nextArgIndex) {
					String extdirsArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer ed = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(extdirsArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    ed.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        ed.append(File.pathSeparator);
					    }
					}					
					extdirs = ed.toString();
					args.remove(args.get(nextArgIndex));
                } else {
                    showError("-extdirs requires list of external directories");
                }
            // error on directory unless -d, -{boot}classpath, or -extdirs
            } else if (arg.equals("-d")) {
                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-classpath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-bootclasspath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-extdirs")) {
//                dirLookahead(arg, args, nextArgIndex);
            } else if (arg.equals("-proceedOnError")) {
            	buildConfig.setProceedOnError(true);
            } else if (new File(arg).isDirectory()) {
                showError("dir arg not permitted: " + arg);
            } else if (arg.equals("-1.5")) {
            	buildConfig.setBehaveInJava5Way(true);
            	unparsedArgs.add("-1.5");
// this would enable the '-source 1.5' to do the same as '-1.5' but doesnt sound quite right as
// as an option right now as it doesnt mean we support 1.5 source code - people will get confused...
            } else if (arg.equals("-source")) {
            	if (args.size() > nextArgIndex) {
            		String level = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
            		if (level.equals("1.5")){
            			buildConfig.setBehaveInJava5Way(true);
            		}
            		unparsedArgs.add("-source");
            		unparsedArgs.add(level);
            		args.remove(args.get(nextArgIndex));
            	}
			} else {
                // argfile, @file parsed by superclass
                // no eclipse options parsed:
                // -d args, -help (handled), 
                // -classpath, -target, -1.3, -1.4, -source [1.3|1.4]
                // -nowarn, -warn:[...], -deprecation, -noImportError,
                // -g:[...], -preserveAllLocals,
                // -referenceInfo, -encoding, -verbose, -log, -time
                // -noExit, -repeat
				// (Actually, -noExit grabbed by Main)
		    	unparsedArgs.add(arg);
			}
        }
================= fetch public void processReweavableStateIfPresent(String className, BcelObjectType cla 12e6334^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java

public void processReweavableStateIfPresent(String className, BcelObjectType classType) {
		// If the class is marked reweavable, check any aspects around when it was built are in this world
		WeaverStateInfo wsi = classType.getWeaverState();		
		if (wsi!=null && wsi.isReweavable()) { // Check all necessary types are around!
			world.showMessage(IMessage.INFO,
					WeaverMessages.format(WeaverMessages.PROCESSING_REWEAVABLE,className,classType.getSourceLocation().getSourceFile()),
					null,null);
			Set aspectsPreviouslyInWorld = wsi.getAspectsAffectingType();
			if (aspectsPreviouslyInWorld!=null) {
                // keep track of them just to ensure unique missing aspect error reporting
                Set alreadyConfirmedReweavableState = new HashSet();
				for (Iterator iter = aspectsPreviouslyInWorld.iterator(); iter.hasNext();) {
					String requiredTypeName = (String) iter.next();
					if (!alreadyConfirmedReweavableState.contains(requiredTypeName)) {
						ResolvedType rtx = world.resolve(UnresolvedType.forName(requiredTypeName),true);
						boolean exists = rtx!=ResolvedType.MISSING;
						if (!exists) {
							world.showMessage(IMessage.ERROR, 
									WeaverMessages.format(WeaverMessages.MISSING_REWEAVABLE_TYPE,requiredTypeName,className),
								    classType.getSourceLocation(), null);
						} else {
							if (!world.getMessageHandler().isIgnoring(IMessage.INFO))
							  world.showMessage(IMessage.INFO,
							  		WeaverMessages.format(WeaverMessages.VERIFIED_REWEAVABLE_TYPE,requiredTypeName,rtx.getSourceLocation().getSourceFile()),
									null,null);
							alreadyConfirmedReweavableState.add(requiredTypeName);
						}
					}		
				}
			}
			classType.setJavaClass(Utility.makeJavaClass(classType.getJavaClass().getFileName(), wsi.getUnwovenClassFileData()));
		} else {
			classType.resetState();
		}
	}
================= fetch public void set(Map optionsMap) { 12e6334^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java
/* (non-Javadoc)
	 * @see org.eclipse.jdt.internal.compiler.impl.CompilerOptions#set(java.util.Map)
	 */
public void set(Map optionsMap) {
		super.set(optionsMap);
		Object optionValue;
		if ((optionValue = optionsMap.get(OPTION_ReportInvalidAbsoluteTypeName)) != null) updateSeverity(InvalidAbsoluteTypeName, optionValue);
		if ((optionValue = optionsMap.get(OPTION_ReportInvalidWildcardTypeName)) != null) updateSeverity(InvalidWildCardTypeName, optionValue);
		if ((optionValue = optionsMap.get(OPTION_ReportUnresolvableMember)) != null) updateSeverity(UnresolvableMember, optionValue);
		if ((optionValue = optionsMap.get(OPTION_ReportTypeNotExposedToWeaver)) != null) updateSeverity(TypeNotExposedToWeaver, optionValue);
		if ((optionValue = optionsMap.get(OPTION_ReportShadowNotInStructure)) != null) updateSeverity(ShadowNotInStructure, optionValue);
		if ((optionValue = optionsMap.get(OPTION_ReportUnmatchedSuperTypeInCall)) != null) updateSeverity(UnmatchedSuperTypeInCall, optionValue);
		if ((optionValue = optionsMap.get(OPTION_ReportCannotImplementLazyTJP)) != null) updateSeverity(CannotImplementLazyTJP, optionValue);
		if ((optionValue = optionsMap.get(OPTION_ReportNeedSerialVersionUIDField)) != null) updateSeverity(NeedSerialVersionUIDField, optionValue);
		if ((optionValue = optionsMap.get(OPTION_ReportIncompatibleSerialVersion)) != null) updateSeverity(IncompatibleSerialVersion, optionValue);
		
		if ((optionValue = optionsMap.get(OPTION_NoWeave)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.noWeave = true;
			} else if (DISABLED.equals(optionValue)) {
				this.noWeave = false;
			}
		}
		if ((optionValue = optionsMap.get(OPTION_XSerializableAspects)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.xSerializableAspects = true;
			} else if (DISABLED.equals(optionValue)) {
				this.xSerializableAspects = false;
			}
		}
		if ((optionValue = optionsMap.get(OPTION_XLazyThisJoinPoint)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.xLazyThisJoinPoint = true;
			} else if (DISABLED.equals(optionValue)) {
				this.xLazyThisJoinPoint = false;
			}
		}
		if ((optionValue = optionsMap.get(OPTION_XNoInline)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.xNoInline = true;
			} else if (DISABLED.equals(optionValue)) {
				this.xNoInline = false;
			}
		}
		if ((optionValue = optionsMap.get(OPTION_XReweavable)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.xReweavable = true;
			} else if (DISABLED.equals(optionValue)) {
				this.xReweavable = false;
			}
		}
		if ((optionValue = optionsMap.get(OPTION_XReweavableCompress)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.xReweavableCompress = true;
			} else if (DISABLED.equals(optionValue)) {
				this.xReweavableCompress = false;
			}
		}
		if ((optionValue = optionsMap.get(OPTION_XHasMember)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.xHasMember = true;
			} else if (DISABLED.equals(optionValue)) {
				this.xHasMember = false;
			}
		}

		if ((optionValue = optionsMap.get(OPTION_XdevPinpoint)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.xdevPinpoint = true;
			} else if (DISABLED.equals(optionValue)) {
				this.xdevPinpoint = false;
			}
		}

		if ((optionValue = optionsMap.get(OPTION_GenerateModel)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.generateModel = true;
			} else if (DISABLED.equals(optionValue)) {
				this.generateModel = false;
			}
		}
		if ((optionValue = optionsMap.get(OPTION_GenerateJavaDocsInModel)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.generateJavaDocsInModel = true;
			} else if (DISABLED.equals(optionValue)) {
				this.generateJavaDocsInModel = false;
			}
		}
		if ((optionValue = optionsMap.get(OPTION_Emacssym)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.generateEmacsSymFiles = true;
			} else if (DISABLED.equals(optionValue)) {
				this.generateEmacsSymFiles = false;
			}
		}
		if ((optionValue = optionsMap.get(OPTION_XDevNoAtAspectJProcessing)) != null) {
			if (ENABLED.equals(optionValue)) {
				this.noAtAspectJProcessing = true;
			} else if (DISABLED.equals(optionValue)) {
				this.noAtAspectJProcessing = false;
			}
		}
		
	}
================= fetch public void setProgressListener(IProgressListener listener, double previousProgr 12e6334^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java

public void setProgressListener(IProgressListener listener, double previousProgress, double progressPerClassFile) {
		progressListener = listener;
		this.progressMade = previousProgress;
		this.progressPerClassFile = progressPerClassFile;
	}
================= fetch public void setReweavable(boolean rw,boolean compressData) { 12e6334^:weaver/src/org/aspectj/weaver/WeaverStateInfo.java

public void setReweavable(boolean rw,boolean compressData) {
		reweavable = rw;
		reweavableCompressedMode = compressData;
	}
================= fetch public void setXReweavable(boolean reweavable) { 12e6334^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java

public void setXReweavable(boolean reweavable) {
    	cmd.addFlag("-Xreweavable",reweavable);
    }
================= fetch public void setXlazyTjp(boolean b) { 12e6334^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java

public void setXlazyTjp(boolean b) {
		options.xLazyThisJoinPoint = b;
	}
================= fetch public void testAjcLTWAroundInlineMungerTest_Xreweavable() { 12e6334^:tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java

public void testAjcLTWAroundInlineMungerTest_Xreweavable() {
        runTest("AjcLTW AroundInlineMungerTest -Xreweavable");
    }
================= fetch public void testDefaultValues() { 12e6334^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java

public void testDefaultValues() {
		assertFalse(options.noWeave);
		assertFalse(options.xSerializableAspects);
		assertFalse(options.xLazyThisJoinPoint);
		assertFalse(options.xNoInline);
		assertFalse(options.xReweavable);
		assertFalse(options.xReweavableCompress);
		assertFalse(options.generateModel);
		assertFalse(options.generateJavaDocsInModel);
		assertFalse(options.generateEmacsSymFiles);
		assertFalse(options.noAtAspectJProcessing);
		
		Map map = options.getMap();
		assertEquals(CompilerOptions.WARNING,map.get(AjCompilerOptions.OPTION_ReportInvalidAbsoluteTypeName));
		assertEquals(CompilerOptions.IGNORE,map.get(AjCompilerOptions.OPTION_ReportInvalidWildcardTypeName));
		assertEquals(CompilerOptions.WARNING,map.get(AjCompilerOptions.OPTION_ReportUnresolvableMember));
		assertEquals(CompilerOptions.WARNING,map.get(AjCompilerOptions.OPTION_ReportTypeNotExposedToWeaver));
		assertEquals(CompilerOptions.IGNORE,map.get(AjCompilerOptions.OPTION_ReportShadowNotInStructure));
		assertEquals(CompilerOptions.WARNING,map.get(AjCompilerOptions.OPTION_ReportUnmatchedSuperTypeInCall));
		assertEquals(CompilerOptions.WARNING,map.get(AjCompilerOptions.OPTION_ReportCannotImplementLazyTJP));
		assertEquals(CompilerOptions.IGNORE,map.get(AjCompilerOptions.OPTION_ReportNeedSerialVersionUIDField));
		assertEquals(CompilerOptions.IGNORE,map.get(AjCompilerOptions.OPTION_ReportIncompatibleSerialVersion));
	}
================= fetch public void testDirectSet() { 12e6334^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java

public void testDirectSet() {
		options.noWeave = true;
		options.xSerializableAspects = true;
		options.xLazyThisJoinPoint = true;
		options.xNoInline = true;
		options.xReweavable = true;
		options.xReweavableCompress = true;
		options.generateModel = true;
		options.generateJavaDocsInModel = true;
		options.generateEmacsSymFiles = true;
		options.noAtAspectJProcessing = true;

		Map map = options.getMap();
		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_NoWeave));
		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_XSerializableAspects));
		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_XLazyThisJoinPoint));
		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_XNoInline));
		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_XReweavable));
		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_XReweavableCompress));
		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_GenerateModel));
		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_GenerateJavaDocsInModel));
		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_Emacssym));
		assertEquals(CompilerOptions.ENABLED,map.get(AjCompilerOptions.OPTION_XDevNoAtAspectJProcessing));
	}
================= fetch public void testJar1() throws IOException { 12e6334^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BinaryFormsTestCase.java

public void testJar1() throws IOException {
		List args = new ArrayList();
		args.add("-outjar");
		args.add("out/lib.jar");

		args.add("-classpath");
        args.add(AjcTests.aspectjrtClasspath());
		
		args.add("-d");
		args.add("out");
		
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/binary/lib/ConcreteA.aj");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/binary/lib/AbstractA.aj");
		
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
		
		args = new ArrayList();
		args.add("-aspectpath");
		args.add("out/lib.jar");

		args.add("-classpath");
        args.add(AjcTests.aspectjrtClasspath());
		
		args.add("-d");
		args.add("out");
		
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/binary/client/Client.java");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/binary/client/Client1.java");
		
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
		
		TestUtil.runMain("out" + File.pathSeparator + "out/lib.jar", "client.Client");
		TestUtil.runMain("out" + File.pathSeparator + "out/lib.jar", "client.Client1");
		
		args = new ArrayList();
		args.add("-aspectpath");
		args.add("out/lib.jar");

		args.add("-classpath");
        args.add(AjcTests.aspectjrtClasspath());
		
		args.add("-d");
		args.add("out");
		
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/binary/client/MyAspect.aj");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/binary/client/Client1.java");
		
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
		
		TestUtil.runMain("out" + File.pathSeparator + "out/lib.jar", "client.Client1");

		args = new ArrayList();
		args.add("-aspectpath");
		args.add("out/lib.jar");

		args.add("-classpath");
        args.add(AjcTests.aspectjrtClasspath());
		
		args.add("-d");
		args.add("out");
		
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/binary/client/MyAspect1.aj");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/binary/client/Client1.java");
		
		CommandTestCase.runCompiler(args, new int[] {24, 30});

		args = new ArrayList();
		args.add("-classpath");
        args.add("out/lib.jar" + File.pathSeparator + AjcTests.aspectjrtClasspath());
		
		args.add("-d");
		args.add("out");
		
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/binary/client/Client1.java");
		
		CommandTestCase.runCompiler(args, new int[] {15, 17, 22});
		
		args = new ArrayList();
		args.add("-classpath");
        args.add(AjcTests.aspectjrtClasspath() + File.pathSeparator + "out/lib.jar");
		args.add("-Xlint:error");
		
		args.add("-d");
		args.add("out");
		
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/binary/client/MyAspect.aj");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/binary/client/Client1.java");
		
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
	}
================= fetch public void testMapSet() { 12e6334^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java

public void testMapSet() {
		Map map = new HashMap();
		map.put(AjCompilerOptions.OPTION_ReportInvalidAbsoluteTypeName,CompilerOptions.ERROR);
		map.put(AjCompilerOptions.OPTION_ReportInvalidWildcardTypeName,CompilerOptions.ERROR);
		map.put(AjCompilerOptions.OPTION_ReportUnresolvableMember,CompilerOptions.IGNORE);
		map.put(AjCompilerOptions.OPTION_ReportTypeNotExposedToWeaver,CompilerOptions.ERROR);
		map.put(AjCompilerOptions.OPTION_ReportShadowNotInStructure,CompilerOptions.WARNING);
		map.put(AjCompilerOptions.OPTION_ReportUnmatchedSuperTypeInCall,CompilerOptions.ERROR);
		map.put(AjCompilerOptions.OPTION_ReportCannotImplementLazyTJP,CompilerOptions.ERROR);
		map.put(AjCompilerOptions.OPTION_ReportNeedSerialVersionUIDField,CompilerOptions.WARNING);
		map.put(AjCompilerOptions.OPTION_ReportIncompatibleSerialVersion,CompilerOptions.ERROR);
		
		map.put(AjCompilerOptions.OPTION_NoWeave,CompilerOptions.ENABLED);
		map.put(AjCompilerOptions.OPTION_XSerializableAspects,CompilerOptions.ENABLED);
		map.put(AjCompilerOptions.OPTION_XLazyThisJoinPoint,CompilerOptions.ENABLED);
		map.put(AjCompilerOptions.OPTION_XNoInline,CompilerOptions.ENABLED);
		map.put(AjCompilerOptions.OPTION_XReweavable,CompilerOptions.ENABLED);
		map.put(AjCompilerOptions.OPTION_XReweavableCompress,CompilerOptions.ENABLED);
		map.put(AjCompilerOptions.OPTION_GenerateModel,CompilerOptions.ENABLED);
		map.put(AjCompilerOptions.OPTION_GenerateJavaDocsInModel,CompilerOptions.ENABLED);
		map.put(AjCompilerOptions.OPTION_Emacssym,CompilerOptions.ENABLED);
		map.put(AjCompilerOptions.OPTION_XDevNoAtAspectJProcessing,CompilerOptions.ENABLED);
		
		options.set(map);
		
		assertTrue(options.noWeave);
		assertTrue(options.xSerializableAspects);
		assertTrue(options.xLazyThisJoinPoint);
		assertTrue(options.xNoInline);
		assertTrue(options.xReweavable);
		assertTrue(options.xReweavableCompress);
		assertTrue(options.generateModel);
		assertTrue(options.generateJavaDocsInModel);
		assertTrue(options.generateEmacsSymFiles);
		assertTrue(options.noAtAspectJProcessing);
		
		Map newMap = options.getMap();
		
		assertEquals(CompilerOptions.ERROR,newMap.get(AjCompilerOptions.OPTION_ReportInvalidAbsoluteTypeName));
		assertEquals(CompilerOptions.ERROR,newMap.get(AjCompilerOptions.OPTION_ReportInvalidWildcardTypeName));
		assertEquals(CompilerOptions.IGNORE,newMap.get(AjCompilerOptions.OPTION_ReportUnresolvableMember));
		assertEquals(CompilerOptions.ERROR,newMap.get(AjCompilerOptions.OPTION_ReportTypeNotExposedToWeaver));
		assertEquals(CompilerOptions.WARNING,newMap.get(AjCompilerOptions.OPTION_ReportShadowNotInStructure));
		assertEquals(CompilerOptions.ERROR,newMap.get(AjCompilerOptions.OPTION_ReportUnmatchedSuperTypeInCall));
		assertEquals(CompilerOptions.ERROR,newMap.get(AjCompilerOptions.OPTION_ReportCannotImplementLazyTJP));
		assertEquals(CompilerOptions.WARNING,newMap.get(AjCompilerOptions.OPTION_ReportNeedSerialVersionUIDField));
		assertEquals(CompilerOptions.ERROR,newMap.get(AjCompilerOptions.OPTION_ReportIncompatibleSerialVersion));
	}
================= fetch public void write(DataOutputStream s) throws IOException { 12e6334^:weaver/src/org/aspectj/weaver/WeaverStateInfo.java

void write(DataOutputStream s) throws IOException {
		if (oldStyle) throw new RuntimeException("shouldn't be writing this");
		
		byte weaverStateInfoKind = EXTENDED;
		if (reweavable) weaverStateInfoKind |= REWEAVABLE_BIT;
		if (reweavableCompressedMode) weaverStateInfoKind |= REWEAVABLE_COMPRESSION_BIT;
		s.writeByte(weaverStateInfoKind);
		int n = typeMungers.size();
		s.writeShort(n);
		for (int i=0; i < n; i++) {
			Entry e = (Entry)typeMungers.get(i);
			e.aspectType.write(s);
			e.typeMunger.write(s);
		}
		writeAnyReweavableData(this,s);
	}
Progress : [##########################--------------] 67%================= fetch private Test findResidueNoEllipsis(Shadow shadow, ExposedState state, TypePatter 451fea8^:weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java

private Test findResidueNoEllipsis(Shadow shadow, ExposedState state, TypePattern[] patterns) {
		ResolvedType[] argumentsToMatchAgainst = getArgumentsToMatchAgainst(shadow);
		int len = argumentsToMatchAgainst.length;
		//System.err.println("boudn to : " + len + ", " + patterns.length);
		if (patterns.length != len) {
			return Literal.FALSE;
		}
		
		Test ret = Literal.TRUE;
		
		for (int i=0; i < len; i++) {
			UnresolvedType argType = shadow.getGenericArgTypes()[i];
			TypePattern type = patterns[i];
            ResolvedType argRTX = shadow.getIWorld().resolve(argType,true);
			if (!(type instanceof BindingTypePattern)) {
                if (argRTX == ResolvedType.MISSING) {
                  IMessage msg = new Message(
                    WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_ARG_TYPE,argType.getName()),
                    "",IMessage.ERROR,shadow.getSourceLocation(),null,new ISourceLocation[]{getSourceLocation()});
                }
				if (type.matchesInstanceof(argRTX).alwaysTrue()) {
					continue;
				}
			} else {
			  BindingTypePattern btp = (BindingTypePattern)type;
			  // Check if we have already bound something to this formal
			  if ((state.get(btp.getFormalIndex())!=null) &&(lastMatchedShadowId != shadow.shadowId)) {
//			  	ISourceLocation isl = getSourceLocation();
//				Message errorMessage = new Message(
//                    "Ambiguous binding of type "+type.getExactType().toString()+
//                    " using args(..) at this line - formal is already bound"+
//                    ".  See secondary source location for location of args(..)",
//					shadow.getSourceLocation(),true,new ISourceLocation[]{getSourceLocation()});
//				shadow.getIWorld().getMessageHandler().handleMessage(errorMessage);
				state.setErroneousVar(btp.getFormalIndex());
			  }
			}

			World world = shadow.getIWorld();
			ResolvedType typeToExpose = type.getExactType().resolve(world);
			if (typeToExpose.isParameterizedType()) {
				boolean inDoubt = (type.matchesInstanceof(argRTX) == FuzzyBoolean.MAYBE);				
				if (inDoubt && world.getLint().uncheckedArgument.isEnabled()) {
					String uncheckedMatchWith = typeToExpose.getSimpleBaseName();
					if (argRTX.isParameterizedType() && (argRTX.getRawType() == typeToExpose.getRawType())) {
						uncheckedMatchWith = argRTX.getSimpleName();
					}
					if (!isUncheckedArgumentWarningSuppressed()) {
						world.getLint().uncheckedArgument.signal(
								new String[] {
										typeToExpose.getSimpleName(),
										uncheckedMatchWith,
										typeToExpose.getSimpleBaseName(),
										shadow.toResolvedString(world)},
								getSourceLocation(),
								new ISourceLocation[] {shadow.getSourceLocation()});
						}
				}
			}			
			
			ret = Test.makeAnd(ret,
				exposeStateForVar(shadow.getArgVar(i), type, state,shadow.getIWorld()));
		}
		
		return ret;		
	}
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { 451fea8^:weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java

private ResolvedType[] getArgumentsToMatchAgainst(Shadow shadow) {
		ResolvedType[] argumentsToMatchAgainst = shadow.getIWorld().resolve(shadow.getGenericArgTypes());

		// special treatment for adviceexecution which may have synthetic arguments we
		// want to ignore.
		if (shadow.getKind() == Shadow.AdviceExecution) {
			int numExtraArgs = 0;
			for (int i = 0; i < argumentsToMatchAgainst.length; i++) {
				String argumentSignature = argumentsToMatchAgainst[i].getSignature();
				if (argumentSignature.startsWith(ASPECTJ_JP_SIGNATURE_PREFIX) || argumentSignature.startsWith(ASPECTJ_SYNTHETIC_SIGNATURE_PREFIX)) {
					numExtraArgs++;
				} else {
					// normal arg after AJ type means earlier arg was NOT synthetic
					numExtraArgs = 0;
				}
			}
			if (numExtraArgs > 0) {
				int newArgLength = argumentsToMatchAgainst.length - numExtraArgs;
				ResolvedType[] argsSubset = new ResolvedType[newArgLength];
				System.arraycopy(argumentsToMatchAgainst, 0, argsSubset, 0, newArgLength);
				argumentsToMatchAgainst = argsSubset;
			}
		} else if (shadow.getKind() == Shadow.ConstructorExecution) {		
			if (shadow.getMatchingSignature().getParameterTypes().length < argumentsToMatchAgainst.length) {
				// there are one or more synthetic args on the end, caused by non-public itd constructor 
				int newArgLength = shadow.getMatchingSignature().getParameterTypes().length;
				ResolvedType[] argsSubset = new ResolvedType[newArgLength];
				System.arraycopy(argumentsToMatchAgainst, 0, argsSubset, 0, newArgLength);
				argumentsToMatchAgainst = argsSubset;				
			}
		}
		
		return argumentsToMatchAgainst;
	}
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { 451fea8^:weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java

protected FuzzyBoolean matchInternal(Shadow shadow) {
		if (shadow.getKind() != Shadow.ExceptionHandler) return FuzzyBoolean.NO;
		
		exceptionType.resolve(shadow.getIWorld());
		
		// we know we have exactly one parameter since we're checking an exception handler
		return exceptionType.matches(
				shadow.getSignature().getParameterTypes()[0].resolve(shadow.getIWorld()), 
				TypePattern.STATIC);
	}
================= fetch public AnnotationPatternList(List l) { 451fea8^:weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.java

protected AnnotationTypePattern[] getAnnotationPatterns() {
		return typePatterns;
	}
================= fetch public Declare parameterizeWith(Map typeVariableBindingMap) { 451fea8^:weaver/src/org/aspectj/weaver/patterns/DeclareAnnotation.java

public Declare parameterizeWith(Map typeVariableBindingMap) {
		// TODO Auto-generated method stub
		return this;
	}
================= fetch public Declare parameterizeWith(Map typeVariableBindingMap) { 451fea8^:weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java

public Declare parameterizeWith(Map typeVariableBindingMap) {
		// TODO Auto-generated method stub
		return this;
	}
================= fetch public PerClause concretize(ResolvedType inAspect) { 451fea8^:weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java

public PerClause concretize(ResolvedType inAspect) {
		PerClause p = lookupConcretePerClause(inAspect.getSuperclass());
		if (p == null) {
			inAspect.getWorld().getMessageHandler().handleMessage(
			  MessageUtil.error(WeaverMessages.format(WeaverMessages.MISSING_PER_CLAUSE,inAspect.getSuperclass()), getSourceLocation())
			);
            return new PerSingleton().concretize(inAspect);// AV: fallback on something else NPE in AJDT
		} else {
            if (p.getKind() != kind) {
                inAspect.getWorld().getMessageHandler().handleMessage(
                  MessageUtil.error(WeaverMessages.format(WeaverMessages.WRONG_PER_CLAUSE,kind,p.getKind()),
                                    getSourceLocation())
                );
            }
            return p.concretize(inAspect);
        }
	}
================= fetch public Set couldMatchKinds() { 451fea8^:weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java

public Set couldMatchKinds() {
		return Shadow.ALL_SHADOW_KINDS;
	}
================= fetch public Set couldMatchKinds() { 451fea8^:weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java

public Set couldMatchKinds() {
		return Shadow.ALL_SHADOW_KINDS;  // empty args() matches jps with no args
	}
================= fetch public Set couldMatchKinds() { 451fea8^:weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java

public Set couldMatchKinds() {
		return kindSet;
	}
================= fetch public Set couldMatchKinds() { 451fea8^:weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java

public Set couldMatchKinds() {
		return isThis ? thisKindSet : targetKindSet;
	}
================= fetch public Set couldMatchKinds() { 451fea8^:weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java

public Set couldMatchKinds() {
		return Shadow.ALL_SHADOW_KINDS;
	}
================= fetch public Set couldMatchKinds() { 451fea8^:weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java

public Set couldMatchKinds() {
		return matchedShadowKinds;
	}
================= fetch public Set couldMatchKinds() { 451fea8^:weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java

public Set couldMatchKinds() {
		return Shadow.ALL_SHADOW_KINDS;
	}
================= fetch public Set couldMatchKinds() { 451fea8^:weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java

public Set couldMatchKinds() {
		return matchedShadowKinds;
	}
================= fetch public TypePattern getType() { 451fea8^:weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java

public boolean isThis() { return isThis; }
================= fetch public TypePattern parameterizeWith(Map typeVariableMap) { 451fea8^:weaver/src/org/aspectj/weaver/patterns/TypePattern.java

public TypePattern parameterizeWith(Map typeVariableMap) {
		return this;
	}
================= fetch public TypePatternList getArguments() { 451fea8^:weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java

public TypePatternList getArguments() {
        return arguments;
    }
================= fetch public static Pointcut read(VersionedDataInputStream s, ISourceContext context) 451fea8^:weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java

public static Pointcut read(VersionedDataInputStream s, ISourceContext context) throws IOException {

		CflowPointcut ret = new CflowPointcut(Pointcut.read(s, context), s.readBoolean(), FileUtil.readIntArray(s));
		ret.readLocation(context, s);
		return ret;
	}
================= fetch public void assertState(State state) { 451fea8^:weaver/src/org/aspectj/weaver/patterns/Pointcut.java

public void assertState(State state) {
		if (this.state != state) {
			throw new BCException("expected state: " + state + " got: " + this.state);
		}
	}
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { 451fea8^:weaver/src/org/aspectj/weaver/patterns/ConcreteCflowPointcut.java

public void resolveBindings(IScope scope, Bindings bindings) {
		throw new RuntimeException("unimplemented");
	}
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { 451fea8^:weaver/src/org/aspectj/weaver/patterns/PerCflow.java

public void resolveBindings(IScope scope, Bindings bindings) {
    	// assert bindings == null;
    	entry.resolve(scope);  
    }
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { 451fea8^:weaver/src/org/aspectj/weaver/patterns/PerObject.java

public void resolveBindings(IScope scope, Bindings bindings) {
    	// assert bindings == null;
    	entry.resolve(scope);  
    }
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { 451fea8^:weaver/src/org/aspectj/weaver/patterns/PerSingleton.java

public void resolveBindings(IScope scope, Bindings bindings) {
    	// this method intentionally left blank
    }
================= fetch public EclipseTypeMunger build(ClassScope classScope) { 2b0e675^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeConstructorDeclaration.java

public EclipseTypeMunger build(ClassScope classScope) {
		EclipseFactory world = EclipseFactory.fromScopeLookupEnvironment(classScope);
		
		resolveOnType(classScope);
		if (ignoreFurtherInvestigation) return null;
		
		binding = classScope.referenceContext.binding.resolveTypesFor(binding);
				
		if (isTargetAnnotation(classScope,"constructor")) return null; // Error message output in isTargetAnnotation
		if (isTargetEnum(classScope,"constructor")) return null;       // Error message output in isTargetEnum
		
		if (onTypeBinding.isInterface()) {
			classScope.problemReporter().signalError(sourceStart, sourceEnd,
							"can't define constructors on interfaces");
			ignoreFurtherInvestigation = true;
			return null;
		}
		
		if (onTypeBinding.isNestedType()) {
			classScope.problemReporter().signalError(sourceStart, sourceEnd,
				"can't define constructors on nested types (compiler limitation)");
			ignoreFurtherInvestigation = true;
			return null;
		}	
		
		ResolvedType declaringTypeX = world.fromEclipse(onTypeBinding);
		ResolvedType aspectType = world.fromEclipse(classScope.referenceContext.binding);
		
		

		// This signature represents what we want consumers of the targetted type to 'see'
		ResolvedMember signature = world.makeResolvedMember(binding,onTypeBinding);
		signature.resetKind(Member.CONSTRUCTOR);
		signature.resetName("<init>");
		signature.resetModifiers(declaredModifiers);
		
		ResolvedMember syntheticInterMember =
			AjcMemberMaker.interConstructor(declaringTypeX,  signature, aspectType);
		
		NewConstructorTypeMunger myMunger = 
			new NewConstructorTypeMunger(signature, syntheticInterMember, null, null);
		setMunger(myMunger);
		myMunger.check(world.getWorld());
		
		this.selector = binding.selector =
			NameMangler.postIntroducedConstructor(
				world.fromBinding(binding.declaringClass),
				declaringTypeX).toCharArray();
		
		return new EclipseTypeMunger(world, myMunger, aspectType, this);
	}
================= fetch public void testDWInStructureModelWithAnonymousInnerClass_pr77269() { 2b0e675^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testDWInStructureModelWithAnonymousInnerClass_pr77269() {
      // AsmManager.setReporting("c:/debug.txt",true,true,true,true);
	  runTest("declare warning in structure model with anonymous inner class");  
  	  IHierarchy top = AsmManager.getDefault().getHierarchy();
  	  IProgramElement pe = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.CODE,"method-call(void pack.Test.someMethod())");  	 	 
  	  assertNotNull("Couldn't find 'method-call(void pack.Test.someMethod())' element in the tree",pe);
  }
================= fetch private IProgramElement findClassInNodes(Collection nodes, String name) { 4573068^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java

private IProgramElement findClassInNodes(Collection nodes, String name) {
		String baseName;
		String innerName;
		int dollar = name.indexOf('$');
		if (dollar == -1) {
			baseName = name;
			innerName = null;
		} else {
			baseName = name.substring(0, dollar);
			innerName = name.substring(dollar+1);
		}
		
		for (Iterator j = nodes.iterator(); j.hasNext(); ) {
			IProgramElement classNode = (IProgramElement)j.next();
			if (baseName.equals(classNode.getName())) {
				if (innerName == null) return classNode;
				else return findClassInNodes(classNode.getChildren(), innerName);
			} else if (name.equals(classNode.getName())) {
				return classNode;
			}
		}
		return null;
	}
================= fetch public IProgramElement findElementForType(String packageName, String typeName) { 4573068^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java
/**
	 * @param packageName	if null default package is searched
	 * @param className 	can't be null
	 */
public IProgramElement findElementForType(String packageName, String typeName) {
		StringBuffer keyb = (packageName == null) ? new StringBuffer() : 
		                                            new StringBuffer(packageName);
		keyb.append(".");
		keyb.append(typeName);
		String key = keyb.toString();
		IProgramElement ret = (IProgramElement) typeMap.get(key);
		if (ret == null) {
			IProgramElement packageNode = null;
			if (packageName == null) {
				packageNode = root;
			} else {
				if (root == null) return null;
				List kids = root.getChildren();
				if (kids == null) return null;
				for (Iterator it = kids.iterator(); it.hasNext(); ) {
					IProgramElement node = (IProgramElement)it.next();
					if (packageName.equals(node.getName())) {
						packageNode = node;
					} 
				}
				if (packageNode == null) return null;
			}
			
			// this searches each file for a class
			for (Iterator it = packageNode.getChildren().iterator(); it.hasNext(); ) {
				IProgramElement fileNode = (IProgramElement)it.next();
				IProgramElement cNode = findClassInNodes(fileNode.getChildren(), typeName);
				if (cNode != null) {
					ret = cNode;
					typeMap.put(key,ret);
				} 
			}			
		}
		return ret;
	}
================= fetch public boolean visit(TypeDeclaration memberTypeDeclaration, BlockScope scope) { 4573068^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java

public boolean visit(TypeDeclaration memberTypeDeclaration, BlockScope scope) {		
		String fullName = "<undefined>";
		if (memberTypeDeclaration.allocation != null
			&& memberTypeDeclaration.allocation.type != null) {
			// Create a name something like 'new Runnable() {..}'
			fullName = "new "+memberTypeDeclaration.allocation.type.toString()+"() {..}";
		} else if (memberTypeDeclaration.binding != null
			&& memberTypeDeclaration.binding.constantPoolName() != null) {
			// If we couldn't find a nice name like 'new Runnable() {..}' then use the number after the $
			fullName = new String(memberTypeDeclaration.binding.constantPoolName());
			 
			int dollar = fullName.indexOf('$');
			fullName = fullName.substring(dollar+1);
		}

		IProgramElement.Kind kind = IProgramElement.Kind.CLASS;
		if (memberTypeDeclaration.kind() == IGenericType.INTERFACE_DECL) kind = IProgramElement.Kind.INTERFACE;
		else if (memberTypeDeclaration.kind() == IGenericType.ENUM_DECL) kind = IProgramElement.Kind.ENUM;
		else if (memberTypeDeclaration.kind() == IGenericType.ANNOTATION_TYPE_DECL) kind = IProgramElement.Kind.ANNOTATION;

        //@AJ support
        if (memberTypeDeclaration.annotations != null) {
            for (int i = 0; i < memberTypeDeclaration.annotations.length; i++) {
                Annotation annotation = memberTypeDeclaration.annotations[i];
                if (Arrays.equals(annotation.type.getTypeBindingPublic(scope).signature(),
                                  "Lorg/aspectj/lang/annotation/Aspect;".toCharArray())) {
                    kind = IProgramElement.Kind.ASPECT;
                    break;
                }
            }
        }
        
		IProgramElement peNode = new ProgramElement(
			fullName,
			kind,
			makeLocation(memberTypeDeclaration),
			memberTypeDeclaration.modifiers,
			"",
			new ArrayList());
		peNode.setSourceSignature(genSourceSignature(memberTypeDeclaration));
		peNode.setFormalComment(generateJavadocComment(memberTypeDeclaration));
		

		((IProgramElement)stack.peek()).addChild(peNode);
		stack.push(peNode);
		return true;
	}
================= fetch public void testDebugInfoForAroundAdvice() { 4573068^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testDebugInfoForAroundAdvice() {
	  runTest("debug info in around advice inlining");
  }
================= fetch public BcelAdvice(AdviceKind kind, Pointcut pointcut, Member signature, 81a0790^:weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java

================= fetch public boolean hasMatchedSomething() { 81a0790^:weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java

public boolean hasMatchedSomething() {
		return hasMatchedAtLeastOnce;
	}
================= fetch public static boolean isSuppressing(AnnotationX[] anns,String lintkey) { 81a0790^:weaver/src/org/aspectj/weaver/bcel/Utility.java

public static List/*Lint.Kind*/ getSuppressedWarnings(AnnotationX[] anns, Lint lint) {
      	if (anns == null) return Collections.EMPTY_LIST;
        // Go through the annotation types
      	List suppressedWarnings = new ArrayList();
      	boolean found = false;
        for (int i = 0;!found && i<anns.length;i++) {
          // Check for the SuppressAjWarnings annotation
          if (UnresolvedType.SUPPRESS_AJ_WARNINGS.getSignature().equals(anns[i].getBcelAnnotation().getTypeSignature())) {
        	found = true;
            // Two possibilities:
            // 1. there are no values specified (i.e. @SuppressAjWarnings)
            // 2. there are values specified (i.e. @SuppressAjWarnings("A") or @SuppressAjWarnings({"A","B"})
            List vals = anns[i].getBcelAnnotation().getValues();
            if (vals == null || vals.size()==0) { // (1)
               suppressedWarnings.addAll(lint.allKinds());
            } else { // (2)
            	// We know the value is an array value
            	ArrayElementValue array = (ArrayElementValue)((ElementNameValuePair)vals.get(0)).getValue();
            	ElementValue[] values = array.getElementValuesArray();
            	for (int j = 0; j < values.length; j++) {
            		// We know values in the array are strings
					SimpleElementValue value = (SimpleElementValue)values[j];
					suppressedWarnings.add(lint.getLintKind(value.getValueString()));
				}
            }
          }
        }
        return suppressedWarnings;
     }
================= fetch public void specializeOn(Shadow shadow) { 81a0790^:weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java
// ---- implementations of ShadowMunger's methods
public void specializeOn(Shadow shadow) {
	  	if (getKind() == AdviceKind.Around) {
	  		((BcelShadow)shadow).initializeForAroundClosure();
	  	}
    	
    	//XXX this case is just here for supporting lazy test code
    	if (getKind() == null) {
			exposedState = new ExposedState(0);
    		return;
    	}
    	if (getKind().isPerEntry()) {
    		exposedState = new ExposedState(0);
    	} else if (getKind().isCflow()) {
    		exposedState = new ExposedState(nFreeVars);
    	} else if (getSignature() != null) {
			exposedState = new ExposedState(getSignature());
    	} else {
    		exposedState = new ExposedState(0);
    		return;  //XXX this case is just here for supporting lazy test code
    	}
    	
    	World world = shadow.getIWorld();
    	if (suppressedLintKinds == null) {
    		if (signature instanceof BcelMethod) {
    			this.suppressedLintKinds = Utility.getSuppressedWarnings(signature.getAnnotations(), world.getLint());
    		} else {
    			this.suppressedLintKinds = Collections.EMPTY_LIST;
    		}
    	}
    	world.getLint().suppressKinds(suppressedLintKinds);
		pointcutTest = getPointcut().findResidue(shadow, exposedState);
		world.getLint().clearSuppressions();
		
		// these initializations won't be performed by findResidue, but need to be
		// so that the joinpoint is primed for weaving
		if (getKind() == AdviceKind.PerThisEntry) {
			shadow.getThisVar();
		} else if (getKind() == AdviceKind.PerTargetEntry) {
			shadow.getTargetVar();
		}
		
		
        // make sure thisJoinPoint parameters are initialized
        if ((getExtraParameterFlags() & ThisJoinPointStaticPart) != 0) {
        	((BcelShadow)shadow).getThisJoinPointStaticPartVar();
			((BcelShadow)shadow).getEnclosingClass().warnOnAddedStaticInitializer(shadow,getSourceLocation());
        }

        if ((getExtraParameterFlags() & ThisJoinPoint) != 0) {
			((BcelShadow)shadow).requireThisJoinPoint(pointcutTest != Literal.TRUE && getKind() != AdviceKind.Around);
			((BcelShadow)shadow).getEnclosingClass().warnOnAddedStaticInitializer(shadow,getSourceLocation());
        }
        
        if ((getExtraParameterFlags() & ThisEnclosingJoinPointStaticPart) != 0) {
        	((BcelShadow)shadow).getThisEnclosingJoinPointStaticPartVar();
			((BcelShadow)shadow).getEnclosingClass().warnOnAddedStaticInitializer(shadow,getSourceLocation());
        }
    }
================= fetch public void testSuppressionWithCflow_pr93345() { 81a0790^:tests/src/org/aspectj/systemtest/ajc150/SuppressedWarnings.java

public void testSuppressionWithCflow_pr93345() {
    runTest("XLint warning for advice not applied with cflow(execution)");
  }
================= fetch public MethodGen(Method m, String class_name, ConstantPoolGen cp) { 85a4b0a^:bcel-builder/src/org/aspectj/apache/bcel/generic/MethodGen.java

================= fetch private void unpackLocals(MethodGen gen) { 97520cf^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

private void unpackLocals(MethodGen gen) {
        Set locals = new HashSet();
        for (InstructionHandle ih = body.getStart(); ih != null; ih = ih.getNext()) {
            InstructionTargeter[] targeters = ih.getTargeters();
            List ends = new ArrayList(0);
            if (targeters != null) {
                for (int i = targeters.length - 1; i >= 0; i--) {
                    InstructionTargeter targeter = targeters[i];
                    if (targeter instanceof LocalVariableGen) {
                        LocalVariableGen lng = (LocalVariableGen) targeter;
                        LocalVariableTag lr = new LocalVariableTag(BcelWorld.fromBcel(lng.getType()), lng.getName(), lng.getIndex());
                        if (lng.getStart() == ih) {
                            locals.add(lr);
                        } else {
                            ends.add(lr);
                        }
                    }
                }
            }
            for (Iterator i = locals.iterator(); i.hasNext(); ) {
                ih.addTargeter((LocalVariableTag) i.next());
            }
            locals.removeAll(ends);
        }
        gen.removeLocalVariables();
    }
================= fetch public LocalVariable getLocalVariable(ConstantPoolGen cp) { 97520cf^:bcel-builder/src/org/aspectj/apache/bcel/generic/LocalVariableGen.java

public InstructionHandle getEnd()                    { return end; }
================= fetch public boolean equals(Object other) { 97520cf^:weaver/src/org/aspectj/weaver/bcel/LocalVariableTag.java

public boolean equals(Object other) {
        if (!(other instanceof LocalVariableTag)) return false;
        LocalVariableTag o = (LocalVariableTag)other;
        return o.type.equals(type) && o.name.equals(name) && o.slot == slot;
    }
================= fetch public void packBody(MethodGen gen) { 97520cf^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
/** fill the newly created method gen with our body, 
     * inspired by InstructionList.copy()
     */
public void packBody(MethodGen gen) {
        HashMap map = new HashMap();
        InstructionList fresh = gen.getInstructionList();
        
        /* Make copies of all instructions, append them to the new list
         * and associate old instruction references with the new ones, i.e.,
         * a 1:1 mapping.
         */
        for (InstructionHandle ih = getBody().getStart(); ih != null; ih = ih.getNext()) {
            if (Range.isRangeHandle(ih)) {
                continue;
            }
            Instruction i = ih.getInstruction();
            Instruction c = Utility.copyInstruction(i);

            if (c instanceof BranchInstruction)
                map.put(ih, fresh.append((BranchInstruction) c));
            else
                map.put(ih, fresh.append(c));
        }
        // at this point, no rangeHandles are in fresh.  Let's use that...

        /* Update branch targets and insert various attributes.  
         * Insert our exceptionHandlers
         * into a sorted list, so they can be added in order later.
         */
        InstructionHandle ih = getBody().getStart();
        InstructionHandle jh = fresh.getStart();

        LinkedList exnList = new LinkedList();   

		// map from localvariabletag to instruction handle
        Map localVariableStarts = new HashMap();
        Map localVariableEnds = new HashMap();

        int currLine = -1;
        
        while (ih != null) {
            if (map.get(ih) == null) {
                // we're a range instruction
                Range r = Range.getRange(ih);
                if (r instanceof ExceptionRange) {
                    ExceptionRange er = (ExceptionRange) r;
                    if (er.getStart() == ih) {
                    	//System.err.println("er " + er);
                    	if (!er.isEmpty()){
                        	// order is important, insert handlers in order of start
                        	insertHandler(er, exnList);
                    	}
                    }
                } else {
                    // we must be a shadow range or something equally useless, 
                    // so forget about doing anything
                }
                // just increment ih. 
                ih = ih.getNext();
            } else {
                // assert map.get(ih) == jh
                Instruction i = ih.getInstruction();
                Instruction j = jh.getInstruction();
    
                if (i instanceof BranchInstruction) {
                    BranchInstruction bi = (BranchInstruction) i;
                    BranchInstruction bj = (BranchInstruction) j;
                    InstructionHandle itarget = bi.getTarget(); // old target
    
//    				try {
                    // New target is in hash map
                    bj.setTarget(remap(itarget, map));
//    				} catch (NullPointerException e) {
//    					print();
//    					System.out.println("Was trying to remap " + bi);
//    					System.out.println("who's target was supposedly " + itarget);
//    					throw e;
//    				}
    
                    if (bi instanceof Select) { 
                        // Either LOOKUPSWITCH or TABLESWITCH
                        InstructionHandle[] itargets = ((Select) bi).getTargets();
                        InstructionHandle[] jtargets = ((Select) bj).getTargets();
    
                        for (int k = itargets.length - 1; k >= 0; k--) { 
                            // Update all targets
                            jtargets[k] = remap(itargets[k], map);
                            jtargets[k].addTargeter(bj);
                        }
                    }
                }
                
                // now deal with line numbers 
                // and store up info for local variables
                InstructionTargeter[] targeters = ih.getTargeters();
				int lineNumberOffset =
					(fromFilename == null)
						? 0
						: getEnclosingClass().getSourceDebugExtensionOffset(fromFilename);
                if (targeters != null) {
                    for (int k = targeters.length - 1; k >= 0; k--) {
                        InstructionTargeter targeter = targeters[k];
                        if (targeter instanceof LineNumberTag) {
                            int line = ((LineNumberTag)targeter).getLineNumber();
                            if (line != currLine) {
                                gen.addLineNumber(jh, line + lineNumberOffset);
                                currLine = line;
                            }
                        } else if (targeter instanceof LocalVariableTag) {
                            LocalVariableTag lvt = (LocalVariableTag) targeter;
			    if (localVariableStarts.get(lvt) == null) {
				localVariableStarts.put(lvt, jh);
			    }
			    localVariableEnds.put(lvt, jh);
                        }
                    }
                }
                // now continue
                ih = ih.getNext();
                jh = jh.getNext();
            }
        }
	
        // now add exception handlers
        for (Iterator iter = exnList.iterator(); iter.hasNext();) {
            ExceptionRange r = (ExceptionRange) iter.next();
            if (r.isEmpty()) continue;
            gen.addExceptionHandler(
                remap(r.getRealStart(), map), 
                remap(r.getRealEnd(), map),
                remap(r.getHandler(), map),
                (r.getCatchType() == null)
                ? null 
                : (ObjectType) BcelWorld.makeBcelType(r.getCatchType()));
        }
        // now add local variables
        gen.removeLocalVariables();

		// this next iteration _might_ be overkill, but we had problems with
		// bcel before with duplicate local variables.  Now that we're patching
		// bcel we should be able to do without it if we're paranoid enough
		// through the rest of the compiler.
        
        Map duplicatedLocalMap = new HashMap();
		List keys = new ArrayList(); 
        keys.addAll(localVariableStarts.keySet());
        for (Iterator iter = keys.iterator(); iter.hasNext(); ) {
            LocalVariableTag tag = (LocalVariableTag) iter.next();
        	// have we already added one with the same slot number and start location?  
        	// if so, just continue.
        	InstructionHandle start = (InstructionHandle) localVariableStarts.get(tag);
        	Set slots = (Set) duplicatedLocalMap.get(start);
	       	if (slots == null) {
	       		slots = new HashSet();
	       		duplicatedLocalMap.put(start, slots);	
	       	}
	       	if (slots.contains(new Integer(tag.getSlot()))) {
	       		// we already have a var starting at this tag with this slot
	       		continue;
	       	}
	       	slots.add(new Integer(tag.getSlot()));

            gen.addLocalVariable(
                tag.getName(), 
                BcelWorld.makeBcelType(tag.getType()),
                tag.getSlot(),
                (InstructionHandle) localVariableStarts.get(tag),
                (InstructionHandle) localVariableEnds.get(tag));
        }
        
        // JAVAC adds line number tables (with just one entry) to generated accessor methods - this
        // keeps some tools that rely on finding at least some form of linenumbertable happy.
        // Let's check if we have one - if we don't then let's add one.
        // TODO Could be made conditional on whether line debug info is being produced
        if (gen.getLineNumbers().length==0) { 
        	gen.addLineNumber(gen.getInstructionList().getStart(),1);
        }
    }
Progress : [###########################-------------] 68%================= fetch public void testNoRequirementForUnwovenTypesToBeExposedToWeaver() { fb428d0^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testNoRequirementForUnwovenTypesToBeExposedToWeaver() {
	  runTest("default impl of Runnable");
  }
================= fetch public boolean matches(ResolvedType matchType, ResolvedType aspectType) { e76b370^:weaver/src/org/aspectj/weaver/ResolvedTypeMunger.java

public boolean matches(ResolvedType matchType, ResolvedType aspectType) {
    	ResolvedType onType = matchType.getWorld().resolve(signature.getDeclaringType());
    	if (onType.isRawType()) onType = onType.getGenericType();
    	//System.err.println("matching: " + this + " to " + matchType + " onType = " + onType);
   		if (matchType.equals(onType)) { 
   			if (!onType.isExposedToWeaver()) {
   				if (onType.getWeaverState() == null) {
	   				if (matchType.getWorld().getLint().typeNotExposedToWeaver.isEnabled()) {
	   					matchType.getWorld().getLint().typeNotExposedToWeaver.signal(
	   						matchType.getName(), signature.getSourceLocation());
	   				}
   				}
   			}
   			return true;
   		}
   		//System.err.println("NO MATCH DIRECT");
   		
    	if (onType.isInterface()) {
    		return matchType.isTopmostImplementor(onType);
    	} else {
    		return false;
    	}
    }
================= fetch public void testParameterizedGenericMethods() { e76b370^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testParameterizedGenericMethods() {
	  runTest("parameterized generic methods");
  }
================= fetch private ResolvedMember lookupMember(Member m, ResolvedMember[] a) { a4a9090^:weaver/src/org/aspectj/weaver/ResolvedType.java
/** return null if not found */
private ResolvedMember lookupMember(Member m, ResolvedMember[] a) {
		for (int i = 0; i < a.length; i++) {
			ResolvedMember f = a[i];
            if (matches(f, m)) return f;	
		}
		return null;
    }
================= fetch private TypePattern resolveBindingsFromFullyQualifiedTypeName(String fullyQualif a4a9090^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java

private TypePattern resolveBindingsFromFullyQualifiedTypeName(String fullyQualifiedName, IScope scope, Bindings bindings, 
			boolean allowBinding, boolean requireExactType) {
		String originalName = fullyQualifiedName;
		ResolvedType resolvedTypeInTheWorld = null;
		UnresolvedType type;
		
		//System.out.println("resolve: " + cleanName);
		//??? this loop has too many inefficiencies to count
		resolvedTypeInTheWorld = lookupTypeInWorld(scope.getWorld(), fullyQualifiedName);
		if (resolvedTypeInTheWorld.isGenericWildcard()) {
			type = resolvedTypeInTheWorld;
		} else {
			type = lookupTypeInScope(scope, fullyQualifiedName, this);
		}
		if (type == ResolvedType.MISSING) {
			return resolveBindingsForMissingType(resolvedTypeInTheWorld, originalName, scope, bindings, allowBinding, requireExactType);
		} else {
			return resolveBindingsForExactType(scope,type,fullyQualifiedName,requireExactType);
		}
	}
================= fetch private boolean enforceDecpRule1_abstractMethodsImplemented(BcelClassWeaver weav a4a9090^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
/**
     * Rule 1: For the declare parents to be allowed, the target type must override and implement 
     *         inherited abstract methods (if the type is not declared abstract)
     */
private boolean enforceDecpRule1_abstractMethodsImplemented(BcelClassWeaver weaver, ISourceLocation mungerLoc,LazyClassGen newParentTarget, ResolvedType newParent) {
        boolean ruleCheckingSucceeded = true;
        if (!(newParentTarget.isAbstract() || newParentTarget.isInterface())) { // Ignore abstract classes or interfaces
            List methods = newParent.getMethodsWithoutIterator(false);
            for (Iterator i = methods.iterator(); i.hasNext();) {
                ResolvedMember o = (ResolvedMember)i.next();
                if (o.isAbstract() && !o.getName().startsWith("ajc$interField")) { // Ignore abstract methods of ajc$interField prefixed methods
                    ResolvedMember discoveredImpl = null;
                    List newParentTargetMethods = newParentTarget.getType().getMethodsWithoutIterator(false);
                    for (Iterator ii = newParentTargetMethods.iterator(); ii.hasNext() && discoveredImpl==null;) {
                        ResolvedMember gen2 = (ResolvedMember) ii.next();
                        if (gen2.getName().equals(o.getName()) && 
                            gen2.getParameterSignature().equals(o.getParameterSignature()) && !gen2.isAbstract()) {
                            discoveredImpl = gen2; // Found a valid implementation !
                        }
                    }     
                    if (discoveredImpl == null) {
                        // didnt find a valid implementation, lets check the ITDs on this type to see if they satisfy it
                        boolean satisfiedByITD = false;
                        for (Iterator ii = newParentTarget.getType().getInterTypeMungersIncludingSupers().iterator(); ii.hasNext(); ) {
                            ConcreteTypeMunger m = (ConcreteTypeMunger)ii.next();
                            if (m.getMunger() instanceof NewMethodTypeMunger) {
                            ResolvedMember sig = m.getSignature();
                            if (!Modifier.isAbstract(sig.getModifiers())) {
                                if (ResolvedType
                                    .matches(
                                        AjcMemberMaker.interMethod(
                                            sig,m.getAspectType(),sig.getDeclaringType().resolve(weaver.getWorld()).isInterface()),o)) {
                                    satisfiedByITD = true;
                                }
                            }
                            }
                        }
                        if (!satisfiedByITD) {
                          error(weaver,
                                "The type " + newParentTarget.getName() + " must implement the inherited abstract method "+o.getDeclaringType()+"."+o.getName()+o.getParameterSignature(),
                                newParentTarget.getType().getSourceLocation(),new ISourceLocation[]{o.getSourceLocation(),mungerLoc});
                          ruleCheckingSucceeded=false;
                        }
                    }
                }
            }
        }
        return ruleCheckingSucceeded;
    }
================= fetch private boolean matchesAnnotations(ResolvedMember member,World world) { a4a9090^:weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java

private boolean matchesAnnotations(ResolvedMember member,World world) {
	  if (member == null) {
	        if (member.getName().startsWith(NameMangler.PREFIX)) {
				return false;
			}
			world.getLint().unresolvableMember.signal(member.toString(), getSourceLocation());
			return false;
	  }
	  annotationPattern.resolve(world);
	 
	  // optimization before we go digging around for annotations on ITDs
	  if (annotationPattern instanceof AnyAnnotationTypePattern) return true;
	  
	  // fake members represent ITD'd fields - for their annotations we should go and look up the
	  // relevant member in the original aspect
	  if (member.isAnnotatedElsewhere() && member.getKind()==Member.FIELD) {
	    // FIXME asc duplicate of code in AnnotationPattern.matchInternal()?  same fixmes apply here.
	    ResolvedMember [] mems = member.getDeclaringType().resolve(world).getDeclaredFields(); // FIXME asc should include supers with getInterTypeMungersIncludingSupers?
	    List mungers = member.getDeclaringType().resolve(world).getInterTypeMungers(); 
		for (Iterator iter = mungers.iterator(); iter.hasNext();) {
	        BcelTypeMunger typeMunger = (BcelTypeMunger) iter.next();
			if (typeMunger.getMunger() instanceof NewFieldTypeMunger) {
			  ResolvedMember fakerm = typeMunger.getSignature();
			  ResolvedMember ajcMethod = AjcMemberMaker.interFieldInitializer(fakerm,typeMunger.getAspectType());
		  	  ResolvedMember rmm       = findMethod(typeMunger.getAspectType(),ajcMethod);
			  if (fakerm.equals(member)) {
				member = rmm;
			  }
			}
		}
	  }
	  
	  return annotationPattern.matches(member).alwaysTrue();
	}
================= fetch private boolean matchesExactly(JoinPointSignature aMember, World inAWorld, boole a4a9090^:weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java
// or chasing up the hierarchy)
private boolean matchesExactly(JoinPointSignature aMember, World inAWorld, boolean allowBridgeMethods) {
		// Java5 introduces bridge methods, we match a call to them but nothing else...
		if (aMember.isBridgeMethod() && !allowBridgeMethods) {
			return false;
		}
			
		if (!modifiers.matches(aMember.getModifiers())) return false;
		
		boolean matchesIgnoringAnnotations = true;
		if (kind == Member.STATIC_INITIALIZATION) {
			matchesIgnoringAnnotations = matchesExactlyStaticInitialization(aMember, inAWorld);
		} else if (kind == Member.FIELD) {
			matchesIgnoringAnnotations = matchesExactlyField(aMember,inAWorld);
		} else if (kind == Member.METHOD) {
			matchesIgnoringAnnotations = matchesExactlyMethod(aMember,inAWorld);
		} else if (kind == Member.CONSTRUCTOR) {
			matchesIgnoringAnnotations = matchesExactlyConstructor(aMember, inAWorld);
		}
		if (!matchesIgnoringAnnotations) return false;
		
		return matchesAnnotations(aMember, inAWorld);
	}
================= fetch private boolean matchesExactlyConstructor(JoinPointSignature aConstructor, World a4a9090^:weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java
/**
	 * match on declaring type, parameter types, throws types
	 */
private boolean matchesExactlyConstructor(JoinPointSignature aConstructor, World world) {
		if (!declaringType.matchesStatically(aConstructor.getDeclaringType().resolve(world))) return false;

		ResolvedType[] resolvedParameters = world.resolve(aConstructor.getParameterTypes());
		if (!parameterTypes.matches(resolvedParameters, TypePattern.STATIC).alwaysTrue()) {
			// It could still be a match based on the generic sig parameter types of a parameterized type
			if (!parameterTypes.matches(world.resolve(aConstructor.getGenericParameterTypes()),TypePattern.STATIC).alwaysTrue()) {
				return false;
				// It could STILL be a match based on the erasure of the parameter types??
				// to be determined via test cases...
			}
		}
		
		// check that varargs specifications match
		if (!matchesVarArgs(aConstructor,world)) return false;
		
		// Check the throws pattern
		if (!throwsPattern.matches(aConstructor.getExceptions(), world)) return false;
		
		// passed all the guards..
		return true;		
	}
================= fetch private boolean matchesExactlyField(JoinPointSignature aField, World world) { a4a9090^:weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java
/**
	 * Matches on name, declaring type, field type
	 */
private boolean matchesExactlyField(JoinPointSignature aField, World world) {
		if (!name.matches(aField.getName())) return false;
		if (!declaringType.matchesStatically(aField.getDeclaringType().resolve(world))) return false;
		if (!returnType.matchesStatically(aField.getReturnType().resolve(world))) {
			// looking bad, but there might be parameterization to consider...
			if (!returnType.matchesStatically(aField.getGenericReturnType().resolve(world))) {
				// ok, it's bad.
				return false;
			}
		}
		// passed all the guards...
		return true;
	}
================= fetch private boolean matchesExactlyMethod(JoinPointSignature aMethod, World world) { a4a9090^:weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java
/**
	 * Matches on name, declaring type, return type, parameter types, throws types
	 */
private boolean matchesExactlyMethod(JoinPointSignature aMethod, World world) {
		if (!name.matches(aMethod.getName())) return false;
		if (!declaringType.matchesStatically(aMethod.getDeclaringType().resolve(world))) return false;
		if (!returnType.matchesStatically(aMethod.getReturnType().resolve(world))) {
			// looking bad, but there might be parameterization to consider...
			if (!returnType.matchesStatically(aMethod.getGenericReturnType().resolve(world))) {
				// ok, it's bad.
				return false;
			}
		}
		ResolvedType[] resolvedParameters = world.resolve(aMethod.getParameterTypes());
		if (!parameterTypes.matches(resolvedParameters, TypePattern.STATIC).alwaysTrue()) {
			// It could still be a match based on the generic sig parameter types of a parameterized type
			if (!parameterTypes.matches(world.resolve(aMethod.getGenericParameterTypes()),TypePattern.STATIC).alwaysTrue()) {
				return false;
				// It could STILL be a match based on the erasure of the parameter types??
				// to be determined via test cases...
			}
		}
		
		// check that varargs specifications match
		if (!matchesVarArgs(aMethod,world)) return false;
		
		// Check the throws pattern
		if (!throwsPattern.matches(aMethod.getExceptions(), world)) return false;
		
		// passed all the guards..
		return true;
	}
================= fetch private boolean matchesExactlyStaticInitialization(JoinPointSignature aMember,Wo a4a9090^:weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java
/**
	 * Matches on declaring type
	 */
private boolean matchesExactlyStaticInitialization(JoinPointSignature aMember,World world) {
		return declaringType.matchesStatically(aMember.getDeclaringType().resolve(world));
	}
================= fetch private boolean matchesVarArgs(JoinPointSignature aMethodOrConstructor, World in a4a9090^:weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java
/**
	 * We've matched against this method or constructor so far, but without considering
	 * varargs (which has been matched as a simple array thus far). Now we do the additional
	 * checks to see if the parties agree on whether the last parameter is varargs or a 
	 * straight array. 
	 */
private boolean matchesVarArgs(JoinPointSignature aMethodOrConstructor, World inAWorld) {
		if (parameterTypes.size() == 0) return true;
		
		TypePattern lastPattern = parameterTypes.get(parameterTypes.size()-1);
		boolean canMatchVarArgsSignature = lastPattern.isStar() || 
		                                    lastPattern.isVarArgs() ||
		                                    (lastPattern == TypePattern.ELLIPSIS);
		
		if (aMethodOrConstructor.isVarargsMethod()) {
			// we have at least one parameter in the pattern list, and the method has a varargs signature
			if (!canMatchVarArgsSignature) {
				// XXX - Ideally the shadow would be included in the msg but we don't know it...
				inAWorld.getLint().cantMatchArrayTypeOnVarargs.signal(aMethodOrConstructor.toString(),getSourceLocation());
				return false;
			}
		} else {
			// the method ends with an array type, check that we don't *require* a varargs
			if (lastPattern.isVarArgs()) return false;
		}

		return true;
	}
================= fetch private boolean mungeNewParent(BcelClassWeaver weaver, NewParentTypeMunger munge a4a9090^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java
/** 
     * For a long time, AspectJ did not allow binary weaving of declare parents.  This restriction is now lifted
     * but could do with more testing!
	 */
private boolean mungeNewParent(BcelClassWeaver weaver, NewParentTypeMunger munger) {
		LazyClassGen  newParentTarget = weaver.getLazyClassGen();
		ResolvedType newParent       = munger.getNewParent();
        
        boolean cont = true; // Set to false when we error, so we don't actually *do* the munge           
        cont = enforceDecpRule1_abstractMethodsImplemented(weaver, munger.getSourceLocation(),newParentTarget, newParent);
        cont = enforceDecpRule2_cantExtendFinalClass(weaver,munger.getSourceLocation(),newParentTarget,newParent) && cont;
                
        List methods = newParent.getMethodsWithoutIterator(false);
        for (Iterator iter = methods.iterator(); iter.hasNext();) {
		  ResolvedMember    superMethod = (ResolvedMember) iter.next();
          if (!superMethod.getName().equals("<init>")) {
		    LazyMethodGen   subMethod = findMatchingMethod(newParentTarget, superMethod);
            if (subMethod!=null) {
              cont = enforceDecpRule3_visibilityChanges(weaver, newParent, superMethod, subMethod) && cont;
              cont = enforceDecpRule4_compatibleReturnTypes(weaver, superMethod, subMethod)        && cont;
              cont = enforceDecpRule5_cantChangeFromStaticToNonstatic(weaver,munger.getSourceLocation(),superMethod,subMethod) && cont;
            }                
          }
        }
        if (!cont) return false; // A rule was violated and an error message already reported
             
        if (newParent.isClass()) { // Changing the supertype
             if (!attemptToModifySuperCalls(weaver,newParentTarget,newParent)) return false;
             newParentTarget.setSuperClass(newParent);
		} else { // Adding a new interface
			newParentTarget.addInterface(newParent,getSourceLocation());
		}
		return true;
	}
================= fetch private final boolean isCoerceableFromParameterizedType(ResolvedType other) { a4a9090^:weaver/src/org/aspectj/weaver/ReferenceType.java

private final boolean isCoerceableFromParameterizedType(ResolvedType other) {
    	if (!other.isParameterizedType()) return false;
   		ResolvedType myRawType = (ResolvedType) getRawType();
   		ResolvedType theirRawType = (ResolvedType) other.getRawType();
   		if (myRawType == theirRawType) {  
   			if (getTypeParameters().length == other.getTypeParameters().length) {
   				// there's a chance it can be done
   				ResolvedType[] myTypeParameters = getResolvedTypeParameters();
   				ResolvedType[] theirTypeParameters = other.getResolvedTypeParameters();
   				for (int i = 0; i < myTypeParameters.length; i++) {
					if (myTypeParameters[i] != theirTypeParameters[i]) {
						// thin ice now... but List<String> may still be coerceable from e.g. List<T>
						if (myTypeParameters[i].isGenericWildcard()) {
							BoundedReferenceType wildcard = (BoundedReferenceType) myTypeParameters[i];
							if (!wildcard.canBeCoercedTo(theirTypeParameters[i])) return false;
						} else if (myTypeParameters[i].isTypeVariableReference()) {
							TypeVariableReferenceType tvrt = (TypeVariableReferenceType) myTypeParameters[i];
							TypeVariable tv = tvrt.getTypeVariable();
							tv.resolve(world);
							if (!tv.canBeBoundTo(theirTypeParameters[i])) return false;
						} else if (theirTypeParameters[i].isTypeVariableReference()) {
							TypeVariableReferenceType tvrt = (TypeVariableReferenceType) theirTypeParameters[i];
							TypeVariable tv = tvrt.getTypeVariable();
							tv.resolve(world);
							if (!tv.canBeBoundTo(myTypeParameters[i])) return false;							
						} else {
							return false;
						}
					}
				}
   				return true;
   			}
   		} else {
   			// we do this walk for situations like the following:
   			// Base<T>, Sub<S,T> extends Base<S>
   			// is Sub<Y,Z> coerceable from Base<X> ???
   	        for(Iterator i = getDirectSupertypes(); i.hasNext(); ) {
   	        	ReferenceType parent = (ReferenceType) i.next();
   	            if (parent.isCoerceableFromParameterizedType(other)) return true;
   	        }          			
   		}
    	return false;
    }
================= fetch private static void accumulateMembersMatching( a4a9090^:weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java
/**
     * We have a resolved member, possibly with type parameter references as parameters or return
     * type. We need to find all its ancestor members. When doing this, a type parameter matches
     * regardless of bounds (bounds can be narrowed down the hierarchy).
     */
private static void accumulateMembersMatching(
    		ResolvedMemberImpl memberToMatch,
    		Iterator typesToLookIn,
    		List typesAlreadyVisited,
    		Set foundMembers) {
    	while(typesToLookIn.hasNext()) {
    		ResolvedType toLookIn = (ResolvedType) typesToLookIn.next();
			if (!typesAlreadyVisited.contains(toLookIn)) {
				typesAlreadyVisited.add(toLookIn);
				ResolvedMemberImpl foundMember = (ResolvedMemberImpl) toLookIn.lookupResolvedMember(memberToMatch);
				if (foundMember != null && isVisibleTo(memberToMatch,foundMember)) {
					List declaringTypes = new ArrayList();
					// declaring type can be unresolved if the member can from an ITD...
					ResolvedType resolvedDeclaringType = foundMember.getDeclaringType().resolve(toLookIn.getWorld());
					accumulateTypesInBetween(toLookIn, resolvedDeclaringType, declaringTypes);
				   	for (Iterator iter = declaringTypes.iterator(); iter.hasNext();) {
						ResolvedType declaringType = (ResolvedType) iter.next();
//						typesAlreadyVisited.add(declaringType);
						ResolvedMember member = foundMember.withSubstituteDeclaringType(declaringType);
						foundMembers.add(member);
					}				   	
					if (toLookIn.isParameterizedType() && (foundMember.backingGenericMember != null)) {
						foundMembers.add(new JoinPointSignature(foundMember.backingGenericMember,foundMember.declaringType.resolve(toLookIn.getWorld())));
					}
					accumulateMembersMatching(foundMember,toLookIn.getDirectSupertypes(),typesAlreadyVisited,foundMembers);
					// if this was a parameterized type, look in the generic type that backs it too
				}	
			}
		}
    }
================= fetch private void addAndRecurse(Set knowninterfaces,List collector, ResolvedType rtx, a4a9090^:weaver/src/org/aspectj/weaver/ResolvedType.java

public ResolvedType[] getResolvedTypeParameters() {
    	if (resolvedTypeParams == null) {
    		resolvedTypeParams = world.resolve(typeParameters);
    	}
    	return resolvedTypeParams;
    }
================= fetch private void collectInterTypeParentMungers(List collector) { a4a9090^:weaver/src/org/aspectj/weaver/ResolvedType.java

private void collectInterTypeParentMungers(List collector) {
        for (Iterator iter = getDirectSupertypes(); iter.hasNext();) {
            ResolvedType superType = (ResolvedType) iter.next();
            superType.collectInterTypeParentMungers(collector);
        }
        collector.addAll(getInterTypeParentMungers());
    }
================= fetch private void handleRequiredMissingTypeDuringResolution(UnresolvedType ty) { a4a9090^:weaver/src/org/aspectj/weaver/World.java
/**
     * We tried to resolve a type and couldn't find it...
     */
private void handleRequiredMissingTypeDuringResolution(UnresolvedType ty) {
		MessageUtil.error(messageHandler, 
				WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE,ty.getName()));
		if (dumpState_cantFindTypeExceptions==null) {
		  dumpState_cantFindTypeExceptions = new ArrayList();   
		}
		dumpState_cantFindTypeExceptions.add(new RuntimeException("Can't find type "+ty.getName()));
	}
================= fetch private void initBcelWorld(IMessageHandler handler) throws IOException { a4a9090^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/** init only on initial batch compile? no file-specific options */
private void initBcelWorld(IMessageHandler handler) throws IOException {
		List cp = buildConfig.getBootclasspath();
		cp.addAll(buildConfig.getClasspath());
		BcelWorld bcelWorld = new BcelWorld(cp, handler, null);
		bcelWorld.setBehaveInJava5Way(buildConfig.getBehaveInJava5Way());
		bcelWorld.setXnoInline(buildConfig.isXnoInline());
		bcelWorld.setXlazyTjp(buildConfig.isXlazyTjp());
		bcelWorld.setXHasMemberSupportEnabled(buildConfig.isXHasMemberEnabled());
		BcelWeaver bcelWeaver = new BcelWeaver(bcelWorld);
		state.setWorld(bcelWorld);
		state.setWeaver(bcelWeaver);
		state.binarySourceFiles = new HashMap();
		
		for (Iterator i = buildConfig.getAspectpath().iterator(); i.hasNext();) {
			File f = (File) i.next();
			bcelWeaver.addLibraryJarFile(f);
		}
		
//		String lintMode = buildConfig.getLintMode();
		
		if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
			bcelWorld.getLint().loadDefaultProperties();
		} else {
			bcelWorld.getLint().setAll(buildConfig.getLintMode());
		}
		
		if (buildConfig.getLintSpecFile() != null) {
			bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
		}
		
		//??? incremental issues
		for (Iterator i = buildConfig.getInJars().iterator(); i.hasNext(); ) {
			File inJar = (File)i.next();
			List unwovenClasses = bcelWeaver.addJarFile(inJar, buildConfig.getOutputDir(),false);
			state.binarySourceFiles.put(inJar.getPath(), unwovenClasses);
		}
		
		for (Iterator i = buildConfig.getInpath().iterator(); i.hasNext(); ) {
			File inPathElement = (File)i.next();
			if (!inPathElement.isDirectory()) {
				// its a jar file on the inpath
				// the weaver method can actually handle dirs, but we don't call it, see next block
				List unwovenClasses = bcelWeaver.addJarFile(inPathElement,buildConfig.getOutputDir(),true);
				state.binarySourceFiles.put(inPathElement.getPath(),unwovenClasses);
			} else {
				// add each class file in an in-dir individually, this gives us the best error reporting
				// (they are like 'source' files then), and enables a cleaner incremental treatment of
				// class file changes in indirs.
				File[] binSrcs = FileUtil.listFiles(inPathElement, binarySourceFilter);
				for (int j = 0; j < binSrcs.length; j++) {
					UnwovenClassFile ucf = 
						bcelWeaver.addClassFile(binSrcs[j], inPathElement, buildConfig.getOutputDir());
					List ucfl = new ArrayList();
					ucfl.add(ucf);
					state.binarySourceFiles.put(binSrcs[j].getPath(),ucfl);
				}
			}
		}
		
		
		bcelWeaver.setReweavableMode(buildConfig.isXreweavable(),buildConfig.getXreweavableCompressClasses());

		//check for org.aspectj.runtime.JoinPoint
		bcelWorld.resolve("org.aspectj.lang.JoinPoint");
	}
================= fetch private void openAroundAdvice(LazyMethodGen aroundAdvice) { a4a9090^:weaver/src/org/aspectj/weaver/bcel/BcelAccessForInlineMunger.java
/**
     * Prepare the around advice, flag it as cannot be inlined if it can't be
     *
     * @param aroundAdvice
     */
private void openAroundAdvice(LazyMethodGen aroundAdvice) {
        InstructionHandle curr = aroundAdvice.getBody().getStart();
        InstructionHandle end = aroundAdvice.getBody().getEnd();
        ConstantPoolGen cpg = aroundAdvice.getEnclosingClass().getConstantPoolGen();
        InstructionFactory factory = aroundAdvice.getEnclosingClass().getFactory();

        boolean realizedCannotInline = false;
        while (curr != end) {
            if (realizedCannotInline) {
                // we know we cannot inline this advice so no need for futher handling
                break;
            }
            InstructionHandle next = curr.getNext();
            Instruction inst = curr.getInstruction();

            // open-up method call
            if ((inst instanceof InvokeInstruction)) {
                InvokeInstruction invoke = (InvokeInstruction) inst;
                ResolvedType callee = m_aspectGen.getWorld().resolve(UnresolvedType.forName(invoke.getClassName(cpg)));

                // look in the whole method list and not just declared for super calls and alike
                List methods = callee.getMethodsWithoutIterator(false);
                for (Iterator iter = methods.iterator(); iter.hasNext();) {
                    ResolvedMember resolvedMember = (ResolvedMember) iter.next();
                    if (invoke.getName(cpg).equals(resolvedMember.getName())
                            && invoke.getSignature(cpg).equals(resolvedMember.getSignature())
                            && !resolvedMember.isPublic()) {
                        if ("<init>".equals(invoke.getName(cpg))) {
                            // skipping open up for private constructor
                            // can occur when aspect new a private inner type
                            // too complex to handle new + dup + .. + invokespecial here.
                            aroundAdvice.setCanInline(false);
                            realizedCannotInline = true;
                        } else {
                            // specific handling for super.foo() calls, where foo is non public
                            if (aspectType.getSuperclass() != null
                                    && aspectType.getSuperclass().getName().equals(callee.getName())) {
                                ResolvedMember accessor = createOrGetInlineAccessorForSuperDispatch(resolvedMember);
                                InvokeInstruction newInst = factory.createInvoke(
                                        aspectType.getName(),
                                        accessor.getName(),
                                        BcelWorld.makeBcelType(accessor.getReturnType()),
                                        BcelWorld.makeBcelTypes(accessor.getParameterTypes()),
                                        Constants.INVOKEVIRTUAL
                                );
                                curr.setInstruction(newInst);
                            } else {
                                ResolvedMember accessor = createOrGetInlineAccessorForMethod(resolvedMember);
                                InvokeInstruction newInst = factory.createInvoke(
                                        aspectType.getName(),
                                        accessor.getName(),
                                        BcelWorld.makeBcelType(accessor.getReturnType()),
                                        BcelWorld.makeBcelTypes(accessor.getParameterTypes()),
                                        Constants.INVOKESTATIC
                                );
                                curr.setInstruction(newInst);
                            }
                        }

                        break;//ok we found a matching callee member and swapped the instruction with the accessor
                    }
                }
            } else if (inst instanceof FieldInstruction) {
                FieldInstruction invoke = (FieldInstruction) inst;
                ResolvedType callee = m_aspectGen.getWorld().resolve(UnresolvedType.forName(invoke.getClassName(cpg)));
                for (int i = 0; i < callee.getDeclaredJavaFields().length; i++) {
                    ResolvedMember resolvedMember = callee.getDeclaredJavaFields()[i];
                    if (invoke.getName(cpg).equals(resolvedMember.getName())
                            && invoke.getSignature(cpg).equals(resolvedMember.getSignature())
                            && !resolvedMember.isPublic()) {
                        final ResolvedMember accessor;
                        if ((inst instanceof GETFIELD) || (inst instanceof GETSTATIC)) {
                            accessor = createOrGetInlineAccessorForFieldGet(resolvedMember);
                        } else {
                            accessor = createOrGetInlineAccessorForFieldSet(resolvedMember);
                        }
                        InvokeInstruction newInst = factory.createInvoke(
                                aspectType.getName(),
                                accessor.getName(),
                                BcelWorld.makeBcelType(accessor.getReturnType()),
                                BcelWorld.makeBcelTypes(accessor.getParameterTypes()),
                                Constants.INVOKESTATIC
                        );
                        curr.setInstruction(newInst);

                        break;//ok we found a matching callee member and swapped the instruction with the accessor
                    }
                }
            }

            curr = next;
        }

        // no reason for not inlining this advice
        // since it is used for @AJ advice that cannot be inlined by defauilt
        // make sure we set inline to true since we have done this analysis
        if (!realizedCannotInline) {
            aroundAdvice.setCanInline(true);
        }
    }
================= fetch protected String makeString(String[] names) { a4a9090^:weaver/src/org/aspectj/weaver/MemberImpl.java
/**
     * All the signatures that a join point with this member as its signature has.
     */
public JoinPointSignature[] getJoinPointSignatures(World inAWorld) {
		if (joinPointSignatures == null) {
			joinPointSignatures = ResolvedMemberImpl.getJoinPointSignatures(this, inAWorld);
		}
		return joinPointSignatures;
	}
================= fetch public LazyClassGen(BcelObjectType myType) { a4a9090^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java

================= fetch public List getMethodsWithoutIterator(boolean includeITDs) { a4a9090^:weaver/src/org/aspectj/weaver/ResolvedType.java
/**
     * Return a list of methods, first those declared on this class, then those declared on the superclass (recurse) and then those declared
     * on the superinterfaces.  The getMethods() call above doesn't quite work the same as it will (through the iterator) return methods
     * declared on *this* class twice, once at the start and once at the end - I couldn't debug that problem, so created this alternative.
     */
List getMethodsWithoutIterator(boolean includeITDs) {
        List methods = new ArrayList();
        Set knowninterfaces = new HashSet();
        addAndRecurse(knowninterfaces,methods,this,includeITDs);
        return methods;
    }
================= fetch public ResolvedMember lookupResolvedMember(ResolvedMember aMember) { a4a9090^:weaver/src/org/aspectj/weaver/ResolvedType.java
/**
     * Looks for the first member in the hierarchy matching aMember. This method
     * differs from lookupMember(Member) in that it takes into account parameters
     * which are type variables - which clearly an unresolved Member cannot do since
     * it does not know anything about type variables. 
     */
public ResolvedMember lookupResolvedMember(ResolvedMember aMember) {
    	Iterator toSearch = null;
    	ResolvedMember found = null;
    	if ((aMember.getKind() == Member.METHOD) || (aMember.getKind() == Member.CONSTRUCTOR)) {
    		toSearch = getMethodsWithoutIterator(true).iterator();
    	} else {
    		if (aMember.getKind() != Member.FIELD) 
    			throw new IllegalStateException("I didn't know you would look for members of kind " + aMember.getKind());
    		toSearch = getFields();
    	}
    	while(toSearch.hasNext()) {
			ResolvedMemberImpl candidate = (ResolvedMemberImpl) toSearch.next();			
			if (candidate.matches(aMember)) {
				found = candidate;
				break;
			} 
		}
    	
    	return found;
    }
================= fetch public ResolvedType resolve(UnresolvedType ty, boolean allowMissing) { a4a9090^:weaver/src/org/aspectj/weaver/World.java
/**
     * Resolve a type. This the hub of type resolution. The resolved type is added
     * to the type map by signature.
     */
public ResolvedType resolve(UnresolvedType ty, boolean allowMissing) {
    	
    	// special resolution processing for already resolved types.
    	if (ty instanceof ResolvedType) {
    		ResolvedType rty = (ResolvedType) ty;
    		rty = resolve(rty);
    		return rty;
    	}

    	// dispatch back to the type variable reference to resolve its constituent parts
    	// don't do this for other unresolved types otherwise you'll end up in a loop
    	if (ty.isTypeVariableReference()) {
    		return ty.resolve(this);
    	}
    	
    	// if we've already got a resolved type for the signature, just return it
    	// after updating the world
        String signature = ty.getSignature();
        ResolvedType ret = typeMap.get(signature);
        if (ret != null) { 
        	ret.world = this;  // Set the world for the RTX
        	return ret; 
        } else if ( signature.equals("?") || signature.equals("*")) {
        // might be a problem here, not sure '?' should make it to here as a signature, the 
        // proper signature for wildcard '?' is '*'
        	// fault in generic wildcard, can't be done earlier because of init issues
        	ResolvedType something = new BoundedReferenceType("?",this);
        	typeMap.put("?",something);
        	return something;
        }
        
        // no existing resolved type, create one
        if (ty.isArray()) {
            ret = new ResolvedType.Array(signature, 
            		                     this, 
            		                     resolve(ty.getComponentType(), 
            		                     allowMissing));
        } else {
            ret = resolveToReferenceType(ty);
            if (!allowMissing && ret == ResolvedType.MISSING) {
                handleRequiredMissingTypeDuringResolution(ty);
            }
        }        
  
		// Pulling in the type may have already put the right entry in the map
		if (typeMap.get(signature)==null && ret != ResolvedType.MISSING) {
	        typeMap.put(signature, ret);
		}
        return ret;
    }
================= fetch public String getSignatureString(World world) { a4a9090^:weaver/src/org/aspectj/weaver/JoinPointSignature.java

public JoinPointSignature[] getJoinPointSignatures(World world) {
		return realMember.getJoinPointSignatures(world);
	}
================= fetch public String toString() { a4a9090^:weaver/src/org/aspectj/weaver/patterns/TypePatternList.java

public String toString() {
    	StringBuffer buf = new StringBuffer();
    	buf.append("(");
    	for (int i=0, len=typePatterns.length; i < len; i++) {
    		TypePattern type = typePatterns[i];
    		if (i > 0) buf.append(", ");
    		if (type == TypePattern.ELLIPSIS) {
    			buf.append("..");
    		} else {
    			buf.append(type.toString());
    		}
    	}
    	buf.append(")");
    	return buf.toString();
    }
================= fetch public boolean isTopmostImplementor(ResolvedType interfaceType) { a4a9090^:weaver/src/org/aspectj/weaver/ResolvedType.java

public boolean isTopmostImplementor(ResolvedType interfaceType) {
		if (isInterface()) return false;
		if (!interfaceType.isAssignableFrom(this)) return false;
		// check that I'm truly the topmost implementor
		if (interfaceType.isAssignableFrom(this.getSuperclass())) {
			return false;
		}
		return true;
	}
================= fetch public boolean matches(Member joinPointSignature, World world, boolean allowBrid a4a9090^:weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java

public boolean matches(Member joinPointSignature, World world, boolean allowBridgeMethods) {
		// fail (or succeed!) fast tests...
		if (joinPointSignature == null) return false;
		if (kind != joinPointSignature.getKind()) return false;
		if (kind == Member.ADVICE) return true;
		
		// do the hard work then...
		JoinPointSignature[] candidateMatches = joinPointSignature.getJoinPointSignatures(world);
		for (int i = 0; i < candidateMatches.length; i++) {
			if (matchesExactly(candidateMatches[i],world,allowBridgeMethods)) return true;
		}
		return false;
	}
================= fetch public final boolean isAssignableFrom(ResolvedType o) { a4a9090^:weaver/src/org/aspectj/weaver/ResolvedType.java

public final boolean isAssignableFrom(ResolvedType o) {
            if (! o.isArray()) return false;
            if (o.getComponentType().isPrimitiveType()) {
                return o.equals(this);
            } else {
                return getComponentType().resolve(world).isAssignableFrom(o.getComponentType().resolve(world));
            }
        }
================= fetch public final boolean isAssignableFrom(ResolvedType other) { a4a9090^:weaver/src/org/aspectj/weaver/ReferenceType.java
// true iff the statement "this = other" would compile.
public final boolean isAssignableFrom(ResolvedType other) {
       	if (other.isPrimitiveType()) {
    		if (!world.isInJava5Mode()) return false;
    		if (ResolvedType.validBoxing.contains(this.getSignature()+other.getSignature())) return true;
    	}      
       	if (this == other) return true;

       	if ((this.isRawType() || this.isGenericType()) && other.isParameterizedType()) {
       		if (isAssignableFrom((ResolvedType)other.getRawType())) return true;
       	}
       	if (this.isRawType() && other.isGenericType()) {
       		if (isAssignableFrom((ResolvedType)other.getRawType())) return true;
       	}
       	if (this.isGenericType() && other.isRawType()) {
       		if (isAssignableFrom((ResolvedType)other.getGenericType())) return true;
       	}
       	
       	if (this.isParameterizedType()) {
       		// look at wildcards...
       		if (((ReferenceType)this.getRawType()).isAssignableFrom(other)) {
       			boolean wildcardsAllTheWay = true;
       			ResolvedType[] myParameters = this.getResolvedTypeParameters();
       			for (int i = 0; i < myParameters.length; i++) {
					if (!myParameters[i].isGenericWildcard()) {
						wildcardsAllTheWay = false;
					} else if (myParameters[i].isExtends() || myParameters[i].isSuper()) {
						wildcardsAllTheWay = false;
					}
				}
       			if (wildcardsAllTheWay && !other.isParameterizedType()) return true;
       			// we have to match by parameters one at a time
       			ResolvedType[] theirParameters = other.getResolvedTypeParameters();
       			boolean parametersAssignable = true;
       			if (myParameters.length == theirParameters.length) {
       				for (int i = 0; i < myParameters.length; i++) {
						if (myParameters[i] == theirParameters[i]) continue;
						if (!myParameters[i].isGenericWildcard()) {
							parametersAssignable = false;
							break;
						} else {
							BoundedReferenceType wildcardType = (BoundedReferenceType) myParameters[i];
							if (!wildcardType.alwaysMatches(theirParameters[i])) {
								parametersAssignable = false;
								break;
							}
						}
					}
       			} else {
       				parametersAssignable = false;
       			}
       			if (parametersAssignable) return true;
       		}
       	}

       	if (other.isTypeVariableReference()) {
       		TypeVariableReferenceType otherType = (TypeVariableReferenceType) other;
       		return this.isAssignableFrom(otherType.getUpperBound().resolve(world));
       	}
       	
        for(Iterator i = other.getDirectSupertypes(); i.hasNext(); ) {
            if (this.isAssignableFrom((ResolvedType) i.next())) return true;
        }       
        return false;
    }
================= fetch public final boolean isConvertableFrom(ResolvedType other) { a4a9090^:weaver/src/org/aspectj/weaver/ResolvedType.java
/**
	 * Determines if variables of this type could be assigned values of another
	 * with lots of help.  
	 * java.lang.Object is convertable from all types.
	 * A primitive type is convertable from X iff it's assignable from X.
	 * A reference type is convertable from X iff it's coerceable from X.
	 * In other words, X isConvertableFrom Y iff the compiler thinks that _some_ value of Y
	 * could be assignable to a variable of type X without loss of precision. 
	 * 
	 * @param other the other type
	 * @param world the {@link World} in which the possible assignment should be checked.
	 * @return true iff variables of this type could be assigned values of other with possible conversion
	 */
public final boolean isConvertableFrom(ResolvedType other) {

//    	 // version from TypeX
//    	 if (this.equals(OBJECT)) return true;
//    	 if (this.isPrimitiveType() || other.isPrimitiveType()) return this.isAssignableFrom(other);
//    	 return this.isCoerceableFrom(other);
//    	 
    	 
    	 // version from ResolvedTypeX
    	 if (this.equals(OBJECT)) return true;
    	 if (world.isInJava5Mode()) {
        	if (this.isPrimitiveType()^other.isPrimitiveType()) { // If one is primitive and the other isnt
        		if (validBoxing.contains(this.getSignature()+other.getSignature())) return true;
        	}
    	 }
    	 if (this.isPrimitiveType() || other.isPrimitiveType()) return this.isAssignableFrom(other);
    	 return this.isCoerceableFrom(other);
	 }
================= fetch public static Kind read(DataInputStream s) throws IOException { a4a9090^:weaver/src/org/aspectj/weaver/Member.java

public static Kind read(DataInputStream s) throws IOException {
            int key = s.readByte();
            switch(key) {
                case 1: return METHOD;
                case 2: return FIELD;
                case 3: return CONSTRUCTOR;
                case 4: return STATIC_INITIALIZATION;
                case 5: return POINTCUT;
                case 6: return ADVICE;
                case 7: return HANDLER;
            }
            throw new BCException("weird kind " + key);
        }
================= fetch public void addAnnotation(Annotation a) { a4a9090^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java

public void addAnnotation(Annotation a) {
		if (!hasAnnotation(UnresolvedType.forSignature(a.getTypeSignature()))) {
		  annotations.add(new AnnotationGen(a,getConstantPoolGen(),true));
		}
	}
================= fetch public void addInterTypeMunger(ConcreteTypeMunger munger) { a4a9090^:weaver/src/org/aspectj/weaver/ResolvedType.java

public void addInterTypeMunger(ConcreteTypeMunger munger) {
		ResolvedMember sig = munger.getSignature();
		if (sig == null || munger.getMunger() == null || 
				munger.getMunger().getKind() == ResolvedTypeMunger.PrivilegedAccess)
		{
			interTypeMungers.add(munger);
			return;
		}
		
		//System.err.println("add: " + munger + " to " + this.getClassName() + " with " + interTypeMungers);
		if (sig.getKind() == Member.METHOD) {
			if (!compareToExistingMembers(munger, getMethodsWithoutIterator(false) /*getMethods()*/)) return;
			if (this.isInterface()) {
				if (!compareToExistingMembers(munger, 
						Arrays.asList(world.getCoreType(OBJECT).getDeclaredMethods()).iterator())) return;
			}
		} else if (sig.getKind() == Member.FIELD) {
			if (!compareToExistingMembers(munger, Arrays.asList(getDeclaredFields()).iterator())) return;
		} else {
			if (!compareToExistingMembers(munger, Arrays.asList(getDeclaredMethods()).iterator())) return;
		}

		
		// now compare to existingMungers
		for (Iterator i = interTypeMungers.iterator(); i.hasNext(); ) {
			ConcreteTypeMunger existingMunger = (ConcreteTypeMunger)i.next();
			if (conflictingSignature(existingMunger.getSignature(), munger.getSignature())) {
				//System.err.println("match " + munger + " with " + existingMunger);
				if (isVisible(munger.getSignature().getModifiers(),
							munger.getAspectType(), existingMunger.getAspectType()))
				{
					//System.err.println("    is visible");
					int c = compareMemberPrecedence(sig, existingMunger.getSignature());
					if (c == 0) {
						c = getWorld().compareByPrecedenceAndHierarchy(munger.getAspectType(), existingMunger.getAspectType());
					}
					//System.err.println("       compare: " + c);
					if (c < 0) {
						// the existing munger dominates the new munger
						checkLegalOverride(munger.getSignature(), existingMunger.getSignature());
						return;
					} else if (c > 0) {
						// the new munger dominates the existing one
						checkLegalOverride(existingMunger.getSignature(), munger.getSignature());
						i.remove();
						break;
					} else {
						interTypeConflictError(munger, existingMunger);
						interTypeConflictError(existingMunger, munger);
						return;
					}					
				}
			}
		}
		//System.err.println("adding: " + munger + " to " + this);
		interTypeMungers.add(munger);
	}
================= fetch public void remove() { a4a9090^:weaver/src/org/aspectj/weaver/ResolvedType.java

public void remove() {
                            throw new UnsupportedOperationException();
                        }
================= fetch public void resetReturnTypeToObjectArray() { a4a9090^:weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java

public void resetReturnTypeToObjectArray() {
		returnType = UnresolvedType.OBJECTARRAY;
	}
================= fetch public void testOutjarDeletedOnError () { a4a9090^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/OutjarTest.java
/**
	 * Aim: Check that -outjar is not present when compile fails.
	 * 
	 * Inputs to the compiler:
	 *   -injar
	 *   -aspectpath
	 *   -outjar 
	 * 
	 * Expected result = Compile fails with error message.
	 */
public void testOutjarDeletedOnError () {
		String[] args = new String[] {"-aspectpath", aspectjarName, "-injars", injarName, "-outjar", outjarName};
		Message error = new Message(WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE,"jar1.Parent"));
		MessageSpec spec = new MessageSpec(null,newMessageList(error));
		CompilationResult result = ajc(baseDir,args);
//		System.out.println(result);
		assertMessages(result,spec);
		File outjar = new File(ajc.getSandboxDirectory(),outjarName);
		assertFalse("-outjar " + outjar.getPath() + " should be deleted",outjar.exists());
	}
================= fetch private void registerAspects(final BcelWeaver weaver, final ClassLoader loader, 03b20bc^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
     * Register the aspect, following include / exclude rules
     *
     * @param weaver
     * @param loader
     * @param definitions
     */
private void registerAspects(final BcelWeaver weaver, final ClassLoader loader, final List definitions) {
        //TODO: the exclude aspect allow to exclude aspect defined upper in the CL hierarchy - is it what we want ??
        // if not, review the getResource so that we track which resource is defined by which CL

        //it aspectClassNames
        //exclude if in any of the exclude list
        for (Iterator iterator = definitions.iterator(); iterator.hasNext();) {
            Definition definition = (Definition) iterator.next();
            for (Iterator aspects = definition.getAspectClassNames().iterator(); aspects.hasNext();) {
                String aspectClassName = (String) aspects.next();
                if (acceptAspect(aspectClassName)) {
                    weaver.addLibraryAspect(aspectClassName);
                }
            }
        }

        //it concreteAspects
        //exclude if in any of the exclude list
        //TODO
    }
================= fetch private void registerDefinitions(final BcelWeaver weaver, final ClassLoader load 03b20bc^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
     * Load and cache the aop.xml/properties according to the classloader visibility rules
     *
     * @param weaver
     * @param loader
     */
void registerDefinitions(final BcelWeaver weaver, final ClassLoader loader) {
        try {
            MessageUtil.info(messageHandler, "register classloader " + ((loader!=null)?loader.getClass().getName()+"@"+loader.hashCode():"null"));
            //TODO av underoptimized: we will parse each XML once per CL that see it
            Enumeration xmls = loader.getResources(AOP_XML);
            List definitions = new ArrayList();

            //TODO av dev mode needed ? TBD -Daj5.def=...
            if (ClassLoader.getSystemClassLoader().equals(loader)) {
                String file = System.getProperty("aj5.def", null);
                if (file != null) {
                    MessageUtil.info(messageHandler, "using (-Daj5.def) " + file);
                    definitions.add(DocumentParser.parse((new File(file)).toURL()));
                }
            }

            while (xmls.hasMoreElements()) {
                URL xml = (URL) xmls.nextElement();
                MessageUtil.info(messageHandler, "using " + xml.getFile());
                definitions.add(DocumentParser.parse(xml));
            }

            // still go thru if definitions is empty since we will configure
            // the default message handler in there
            registerOptions(weaver, loader, definitions);
            registerAspectExclude(weaver, loader, definitions);
            registerAspects(weaver, loader, definitions);
            registerIncludeExclude(weaver, loader, definitions);
            registerDump(weaver, loader, definitions);
        } catch (Exception e) {
            weaver.getWorld().getMessageHandler().handleMessage(
                    new Message("Register definition failed", IMessage.WARNING, e, null)
            );
        }
    }
================= fetch public boolean shouldDump(String className) { 03b20bc^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java

public boolean shouldDump(String className) {
        // avoid ResolvedType if not needed
        if (m_dumpTypePattern.isEmpty()) {
            return false;
        }
        //TODO AV - optimize for className.startWith only
        ResolvedType classInfo = weaver.getWorld().resolve(UnresolvedType.forName(className), true);
        //dump
        for (Iterator iterator = m_dumpTypePattern.iterator(); iterator.hasNext();) {
            TypePattern typePattern = (TypePattern) iterator.next();
            if (typePattern.matchesStatically(classInfo)) {
                // dump match
                return true;
            }
        }
        return false;
    }
================= fetch public void acceptClass(String name, byte[] bytes) { 03b20bc^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java

================= fetch public void initialize() { 03b20bc^:loadtime/src/org/aspectj/weaver/loadtime/Aj.java
/**
     * Weave
     *
     * @param className
     * @param bytes
     * @param loader
     * @return
     */
public byte[] preProcess(String className, byte[] bytes, ClassLoader loader) {
        //TODO AV needs to doc that
        if (loader == null || className == null) {
            // skip boot loader or null classes (hibernate)
            return bytes;
        }

        try {
            WeavingAdaptor weavingAdaptor = WeaverContainer.getWeaver(loader);
            byte[] weaved = weavingAdaptor.weaveClass(className, bytes);
            if (weavingAdaptor.shouldDump(className.replace('/', '.'))) {
                dump(className, weaved);
            }
            return weaved;
        } catch (Throwable t) {
            //FIXME AV wondering if we should have the option to fail (throw runtime exception) here
            // would make sense at least in test f.e. see TestHelper.handleMessage()
            t.printStackTrace();
            return bytes;
        }
    }
================= fetch static WeavingAdaptor getWeaver(ClassLoader loader) { 03b20bc^:loadtime/src/org/aspectj/weaver/loadtime/Aj.java
/**
     * Weave
     *
     * @param className
     * @param bytes
     * @param loader
     * @return
     */
public byte[] preProcess(String className, byte[] bytes, ClassLoader loader) {
        //TODO AV needs to doc that
        if (loader == null || className == null) {
            // skip boot loader or null classes (hibernate)
            return bytes;
        }

        try {
            WeavingAdaptor weavingAdaptor = WeaverContainer.getWeaver(loader);
            byte[] weaved = weavingAdaptor.weaveClass(className, bytes);
            if (weavingAdaptor.shouldDump(className.replace('/', '.'))) {
                dump(className, weaved);
            }
            return weaved;
        } catch (Throwable t) {
            //FIXME AV wondering if we should have the option to fail (throw runtime exception) here
            // would make sense at least in test f.e. see TestHelper.handleMessage()
            t.printStackTrace();
            return bytes;
        }
    }
================= fetch static void dump(String name, byte[] b) throws Throwable { 03b20bc^:loadtime/src/org/aspectj/weaver/loadtime/Aj.java
/**
     * Dump the given bytcode in _dump/... (dev mode)
     *
     * @param name
     * @param b
     * @throws Throwable
     */
static void dump(String name, byte[] b) throws Throwable {
        String className = name.replace('.', '/');
        final File dir;
        if (className.indexOf('/') > 0) {
            dir = new File("_ajdump" + File.separator + className.substring(0, className.lastIndexOf('/')));
        } else {
            dir = new File("_ajdump");
        }
        dir.mkdirs();
        String fileName = "_ajdump" + File.separator + className + ".class";
        FileOutputStream os = new FileOutputStream(fileName);
        os.write(b);
        os.close();
    }
================= fetch private ReferenceBinding lookupBinding(String sname) { 8a0f59a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java
// just like the code above except it returns an array of ReferenceBindings
private ReferenceBinding[] makeReferenceBindings(UnresolvedType[] types) {
		int len = types.length;
		ReferenceBinding[] ret = new ReferenceBinding[len];
		
		for (int i = 0; i < len; i++) {
			ret[i] = (ReferenceBinding)makeTypeBinding(types[i]);
		}
		return ret;
	}
================= fetch private void buildPerClause(ClassScope scope) { 8a0f59a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java

private void buildPerClause(ClassScope scope) {
		EclipseFactory world = EclipseFactory.fromScopeLookupEnvironment(scope);
		
		if (perClause == null) {
			PerClause.Kind kind = lookupPerClauseKind(binding.superclass);
			if (kind == null) {
				perClause = new PerSingleton();
			} else {
				perClause = new PerFromSuper(kind);
			}
		}
		
		aspectAttribute = new AjAttribute.Aspect(perClause);
		
		if (ignoreFurtherInvestigation) return; //???
		
		
		if (!isAbstract()) {
			if (perClause.getKind() == PerClause.SINGLETON) {
				aspectOfMethod = AjcMemberMaker.perSingletonAspectOfMethod(typeX);
				hasAspectMethod = AjcMemberMaker.perSingletonHasAspectMethod(typeX);		
			} else if (perClause.getKind() == PerClause.PERCFLOW) {
				aspectOfMethod = AjcMemberMaker.perCflowAspectOfMethod(typeX);
				hasAspectMethod = AjcMemberMaker.perCflowHasAspectMethod(typeX);		
			} else if (perClause.getKind() == PerClause.PEROBJECT) {
				aspectOfMethod = AjcMemberMaker.perObjectAspectOfMethod(typeX);
				hasAspectMethod = AjcMemberMaker.perObjectHasAspectMethod(typeX);
			} else if (perClause.getKind() == PerClause.PERTYPEWITHIN) {
			    // PTWIMPL Use these variants of aspectOf()/hasAspect()
				aspectOfMethod  = AjcMemberMaker.perTypeWithinAspectOfMethod(typeX);
				hasAspectMethod = AjcMemberMaker.perTypeWithinHasAspectMethod(typeX);
			} else {
				throw new RuntimeException("bad per clause: " + perClause);	
			}
			
			binding.addMethod(world.makeMethodBinding(aspectOfMethod));
			binding.addMethod(world.makeMethodBinding(hasAspectMethod));
		}
		resolvePerClause(); //XXX might be too soon for some error checking
	}
================= fetch private void generatePerTWAspectOfMethod(LazyClassGen classGen) { 8a0f59a^:weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.java

private void generatePerTWAspectOfMethod(LazyClassGen classGen) {
        InstructionFactory factory = classGen.getFactory();
        LazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perTypeWithinAspectOfMethod(aspectType));
        flagAsSynthetic(method, false);
        classGen.addMethodGen(method);

        InstructionList il = method.getBody();
        InstructionHandle tryStart = il.append(InstructionConstants.ALOAD_0);

        il.append(Utility.createInvoke(
                factory,
                Constants.INVOKESTATIC,
                AjcMemberMaker.perTypeWithinGetInstance(aspectType)
        ));
        il.append(InstructionConstants.ASTORE_1);
        il.append(InstructionConstants.ALOAD_1);
        BranchInstruction ifNonNull = InstructionFactory.createBranchInstruction(Constants.IFNONNULL, null);
        il.append(ifNonNull);
        il.append(factory.createNew(AjcMemberMaker.NO_ASPECT_BOUND_EXCEPTION.getName()));
        il.append(InstructionConstants.DUP);
        il.append(new PUSH(classGen.getConstantPoolGen(), aspectType.getName()));
        il.append(InstructionConstants.ACONST_NULL);
        il.append(factory.createInvoke(AjcMemberMaker.NO_ASPECT_BOUND_EXCEPTION.getName(), "<init>", Type.VOID, new Type[] { Type.STRING, new ObjectType("java.lang.Throwable") }, Constants.INVOKESPECIAL));
        il.append(InstructionConstants.ATHROW);
        InstructionHandle ifElse = il.append(InstructionConstants.ALOAD_1);
        ifNonNull.setTarget(ifElse);
        il.append(InstructionFactory.createReturn(Type.OBJECT));

        InstructionHandle handler = il.append(InstructionConstants.ASTORE_1);
        il.append(factory.createNew(AjcMemberMaker.NO_ASPECT_BOUND_EXCEPTION.getName()));
        il.append(InstructionConstants.DUP);
        il.append(factory.createInvoke(AjcMemberMaker.NO_ASPECT_BOUND_EXCEPTION.getName(), "<init>", Type.VOID, Type.NO_ARGS, Constants.INVOKESPECIAL));
        il.append(InstructionConstants.ATHROW);

        method.addExceptionHandler(
            tryStart, handler.getPrev(), handler, new ObjectType("java.lang.Exception"), false
        );
    }
================= fetch private void generatePerTWHasAspectMethod(LazyClassGen classGen) { 8a0f59a^:weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.java

private void generatePerTWHasAspectMethod(LazyClassGen classGen) {
        InstructionFactory factory = classGen.getFactory();
        LazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perTypeWithinHasAspectMethod(aspectType));
        flagAsSynthetic(method, false);
        classGen.addMethodGen(method);

        InstructionList il = method.getBody();
        InstructionHandle tryStart = il.append(InstructionConstants.ALOAD_0);
        il.append(Utility.createInvoke(
                factory,
                Constants.INVOKESTATIC,
                AjcMemberMaker.perTypeWithinGetInstance(aspectType)
        ));
        BranchInstruction ifNull = InstructionFactory.createBranchInstruction(Constants.IFNULL, null);
        il.append(ifNull);
        il.append(InstructionConstants.ICONST_1);
        il.append(InstructionConstants.IRETURN);
        InstructionHandle ifElse = il.append(InstructionConstants.ICONST_0);
        ifNull.setTarget(ifElse);
        il.append(InstructionConstants.IRETURN);

        InstructionHandle handler = il.append(InstructionConstants.ASTORE_1);
        il.append(InstructionConstants.ICONST_0);
        il.append(InstructionConstants.IRETURN);

        method.addExceptionHandler(
            tryStart, handler.getPrev(), handler, new ObjectType("java.lang.Exception"), false
        );
    }
================= fetch public static ResolvedMember perObjectHasAspectMethod(UnresolvedType declaringTy 8a0f59a^:weaver/src/org/aspectj/weaver/AjcMemberMaker.java

public static ResolvedMember perObjectHasAspectMethod(UnresolvedType declaringType) {
		return new ResolvedMemberImpl(Member.METHOD,
			declaringType, PUBLIC_STATIC, "hasAspect", 
			"(Ljava/lang/Object;)Z");		
	}
================= fetch public static ResolvedMember perTypeWithinAspectOfMethod(UnresolvedType declarin 8a0f59a^:weaver/src/org/aspectj/weaver/AjcMemberMaker.java
// PTWIMPL ResolvedMember for aspectOf(), declared in aspect
public static ResolvedMember perTypeWithinAspectOfMethod(UnresolvedType declaringType) {
		return new ResolvedMemberImpl(Member.METHOD,
				declaringType, PUBLIC_STATIC, "aspectOf", 
				"(Ljava/lang/Class;)" + declaringType.getSignature());		
	}
================= fetch public void testMessageOnMissingTypeInDecP() { 8a0f59a^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testMessageOnMissingTypeInDecP() {
	  runTest("declare parents on a missing type");
  }
================= fetch public void testAtAnnotationBindingWithAround() { ca9c1f7^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testUnableToBuildShadows_pr109728() { runTest("Unable to build shadows");}
Progress : [###########################-------------] 69%================= fetch public boolean equals(Instruction i1, Instruction i2) { 0e1bb19^:bcel-builder/src/org/aspectj/apache/bcel/generic/InstructionComparator.java

public boolean equals(Instruction i1, Instruction i2) {
	  if(i1.opcode == i2.opcode) {
	    if(i1 instanceof Select) {
	      InstructionHandle[] t1 = ((Select)i1).getTargets();
	      InstructionHandle[] t2 = ((Select)i2).getTargets();

	      if(t1.length == t2.length) {
		for(int i = 0; i < t1.length; i++) {
		  if(t1[i] != t2[i]) {
		    return false;
		  }
		}
		
		return true;
	      }
	    } else if(i1 instanceof BranchInstruction) {
	      return ((BranchInstruction)i1).target == 
		((BranchInstruction)i2).target;
	    } else if(i1 instanceof ConstantPushInstruction) {
	      return ((ConstantPushInstruction)i1).getValue().
		equals(((ConstantPushInstruction)i2).getValue());
	    } else if(i1 instanceof IndexedInstruction) {
	      return ((IndexedInstruction)i1).getIndex() == 
		((IndexedInstruction)i2).getIndex();
	    } else if(i1 instanceof NEWARRAY) {
	      return ((NEWARRAY)i1).getTypecode() == ((NEWARRAY)i2).getTypecode();
	    } else {
	      return true;
	    }
	  }

	  return false;
	}
================= fetch Set getSupportedPrimitives() { a39f595^:weaver/src/org/aspectj/weaver/tools/PointcutParser.java
/* for testing */
Set getSupportedPrimitives() {
    	return supportedPrimitives;
    }
================= fetch private FuzzyBoolean checkSignatureMatch(Class[] pTypes) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java
/**
	 * @param ret
	 * @param pTypes
	 * @return
	 */
private FuzzyBoolean checkSignatureMatch(Class[] pTypes) {
		Collection tps = arguments.getExactTypes();
		int sigIndex = 0;
		for (Iterator iter = tps.iterator(); iter.hasNext();) {
			UnresolvedType tp = (UnresolvedType) iter.next();
			Class lookForClass = getPossiblyBoxed(tp);
			if (lookForClass != null) {
				boolean foundMatchInSig = false;
				while (sigIndex < pTypes.length && !foundMatchInSig) {
					if (pTypes[sigIndex++] == lookForClass) foundMatchInSig = true;
				}
				if (!foundMatchInSig) {
					return FuzzyBoolean.NO;
				}
			}
		}
		return FuzzyBoolean.YES;
	}
================= fetch private Pointcut asPointcut(Method method) { a39f595^:aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/AjTypeImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.lang.reflect.AjType#getDeclaredAdvice(org.aspectj.lang.reflect.AdviceType)
	 */
private Advice[] getDeclaredAdvice(Set ofAdviceTypes) {
		if (declaredAdvice == null) initDeclaredAdvice();
		List<Advice> adviceList = new ArrayList<Advice>();
		for (Advice a : declaredAdvice) {
			if (ofAdviceTypes.contains(a.getKind())) adviceList.add(a);
		}
		Advice[] ret = new Advice[adviceList.size()];
		adviceList.toArray(ret);
		return ret;
	}
================= fetch private boolean matchesAny( a39f595^:weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java

private boolean matchesAny(TypePattern typePattern, Class[] types) {
		for (int i = types.length - 1; i >= 0; i--) {
			if (typePattern.matchesStatically(types[i])) return true;	
		}
		return false;
	}
================= fetch private boolean verifyTypeParameters(ResolvedType baseType,IScope scope, boolean a39f595^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
/**
	 * When this method is called, we have resolved the base type to an exact type.
	 * We also have a set of type patterns for the parameters.
	 * Time to perform some basic checks:
	 *  - can the base type be parameterized? (is it generic)
	 *  - can the type parameter pattern list match the number of parameters on the base type
	 *  - do all parameter patterns meet the bounds of the respective type variables
	 *  If any of these checks fail, a warning message is issued and we return false.
	 * @return
	 */
private boolean verifyTypeParameters(ResolvedType baseType,IScope scope, boolean requireExactType) {
		ResolvedType genericType = baseType.getGenericType();
		if (genericType == null) {
			// issue message "does not match because baseType.getName() is not generic"
			scope.message(MessageUtil.warn(
					WeaverMessages.format(WeaverMessages.NOT_A_GENERIC_TYPE,baseType.getName()),
					getSourceLocation()));
			return false;
		}
		int minRequiredTypeParameters = typeParameters.size();
		boolean foundEllipsis = false;
		TypePattern[] typeParamPatterns = typeParameters.getTypePatterns();
		for (int i = 0; i < typeParamPatterns.length; i++) {
			if (typeParamPatterns[i] instanceof WildTypePattern) {
				WildTypePattern wtp = (WildTypePattern) typeParamPatterns[i];
				if (wtp.ellipsisCount > 0) {
					foundEllipsis = true;
					minRequiredTypeParameters--;
				}
			}
		}
		TypeVariable[] tvs = genericType.getTypeVariables();
		if ((tvs.length < minRequiredTypeParameters) ||
			(!foundEllipsis && minRequiredTypeParameters != tvs.length))
		{
			// issue message "does not match because wrong no of type params"
			String msg = WeaverMessages.format(WeaverMessages.INCORRECT_NUMBER_OF_TYPE_ARGUMENTS,
					                           genericType.getName(),new Integer(tvs.length));
			if (requireExactType)   scope.message(MessageUtil.error(msg,getSourceLocation()));
			else					scope.message(MessageUtil.warn(msg,getSourceLocation()));
			return false;
		} 
		
		// now check that each typeParameter pattern, if exact, matches the bounds
		// of the type variable.
		if (typeParameters.areAllExactWithNoSubtypesAllowed()) {
			for (int i = 0; i < tvs.length; i++) {
				UnresolvedType ut = typeParamPatterns[i].getExactType();
				if (!tvs[i].canBeBoundTo(ut.resolve(scope.getWorld()))) {
					// issue message that type parameter does not meet specification
					String parameterName = ut.getName();
					if (ut.isTypeVariableReference()) parameterName = ((TypeVariableReference)ut).getTypeVariable().getDisplayName();
					String msg = 
						WeaverMessages.format(
							WeaverMessages.VIOLATES_TYPE_VARIABLE_BOUNDS,
							parameterName,
							new Integer(i+1),
							tvs[i].getDisplayName(),
							genericType.getName());
					if (requireExactType)  scope.message(MessageUtil.error(msg,getSourceLocation()));	
					else				   scope.message(MessageUtil.warn(msg,getSourceLocation()));	
					return false;
				}
			}
		}
		return true;
	}
================= fetch private final ResolvedType resolveToReferenceType(UnresolvedType ty) { a39f595^:weaver/src/org/aspectj/weaver/World.java
/**
	 * Resolve to a ReferenceType - simple, raw, parameterized, or generic.
     * Raw, parameterized, and generic versions of a type share a delegate.
     */
private final ResolvedType resolveToReferenceType(UnresolvedType ty) {
		if (ty.isParameterizedType()) {
			// ======= parameterized types ================
			ReferenceType genericType = (ReferenceType)resolveGenericTypeFor(ty,false);
			ReferenceType parameterizedType = 
				TypeFactory.createParameterizedType(genericType, ty.typeParameters, this);
			return parameterizedType;
			
		} else if (ty.isGenericType()) {
			// ======= generic types ======================
			ReferenceType genericType = (ReferenceType)resolveGenericTypeFor(ty,false);
			return genericType;
			
		} else if (ty.isGenericWildcard()) {
			// ======= generic wildcard types =============
			return resolveGenericWildcardFor(ty);
    	} else {
			// ======= simple and raw types ===============
			String erasedSignature = ty.getErasureSignature();
    		ReferenceType simpleOrRawType = new ReferenceType(erasedSignature, this);
	    	ReferenceTypeDelegate delegate = resolveDelegate(simpleOrRawType);
	    	if (delegate == null) return ResolvedType.MISSING;
	    	
	    	if (delegate.isGeneric() && behaveInJava5Way) {
	    		// ======== raw type ===========
	    		simpleOrRawType.typeKind = TypeKind.RAW;
	        	ReferenceType genericType = new ReferenceType(
	        			UnresolvedType.forGenericTypeSignature(erasedSignature,delegate.getDeclaredGenericSignature()),this);
	    		// name =  ReferenceType.fromTypeX(UnresolvedType.forRawTypeNames(ty.getName()),this);
		    	simpleOrRawType.setDelegate(delegate);
		    	genericType.setDelegate(delegate);
		    	simpleOrRawType.setGenericType(genericType);
		    	return simpleOrRawType;
		    	
	    	} else {
	    		// ======== simple type =========
		    	simpleOrRawType.setDelegate(delegate);
		    	return simpleOrRawType;
	    	}
		}
    }
================= fetch private static FuzzyBoolean inStar(final TypePattern[] pattern, final ResolvedTy a39f595^:weaver/src/org/aspectj/weaver/patterns/TypePatternList.java

private static FuzzyBoolean inStar(final TypePattern[] pattern, final ResolvedType[] target, 
                                               int           pi,             int    ti, 
                                         final int           pLeft,         int    tLeft,
                                               int    starsLeft,     TypePattern.MatchKind kind) {
        // invariant: pLeft > 0, so we know we'll run out of stars and find a real char in pattern
        TypePattern patternChar = pattern[pi];
        while (patternChar == TypePattern.ELLIPSIS) {
            starsLeft--;
            patternChar = pattern[++pi];
        }
        while (true) {
            // invariant: if (tLeft > 0) then (ti < target.length)
            if (pLeft > tLeft) return FuzzyBoolean.NO;
            FuzzyBoolean ff = patternChar.matches(target[ti], kind);
            if (ff.maybeTrue()) {
                FuzzyBoolean xx = outOfStar(pattern, target, pi+1, ti+1, pLeft-1, tLeft-1, starsLeft, kind);
                if (xx.maybeTrue()) return ff.and(xx);
            } 
            ti++; tLeft--;
        }
    }
================= fetch private void checkEquals(String pattern, Pointcut p) throws IOException { a39f595^:weaver/testsrc/org/aspectj/weaver/patterns/AndOrNotTestCase.java

private void checkEquals(String pattern, Pointcut p) throws IOException {
		assertEquals(pattern, p, makePointcut(pattern));
		checkSerialization(pattern);
	}
================= fetch private void checkMatches(Pointcut p, JoinPoint jp, JoinPoint.StaticPart jpsp, F a39f595^:weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java

private void checkMatches(Pointcut p, JoinPoint jp, JoinPoint.StaticPart jpsp, FuzzyBoolean expected) {
		assertEquals(expected,p.match(jp,jpsp));
	}
================= fetch private void checkMatches(Pointcut p, JoinPoint jp, JoinPoint.StaticPart jpsp, F a39f595^:weaver/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java

private void checkMatches(Pointcut p, JoinPoint jp, JoinPoint.StaticPart jpsp, FuzzyBoolean expected) {
		assertEquals(expected,p.match(jp,jpsp));
	}
================= fetch private void validateAgainstSupportedPrimitives(Pointcut pc, String expression) a39f595^:weaver/src/org/aspectj/weaver/tools/PointcutParser.java

private void validateAgainstSupportedPrimitives(Pointcut pc, String expression) {
        switch(pc.getPointcutKind()) {
        	case Pointcut.AND:
        	   validateAgainstSupportedPrimitives(((AndPointcut)pc).getLeft(),expression);
        	   validateAgainstSupportedPrimitives(((AndPointcut)pc).getRight(),expression);
        	   break;
        	case Pointcut.ARGS:
        	    if (!supportedPrimitives.contains(PointcutPrimitive.ARGS))
        	        throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.ARGS);
        	    break;
        	case Pointcut.CFLOW:
					CflowPointcut cfp = (CflowPointcut) pc;
					if (cfp.isCflowBelow()) {
	        	        throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.CFLOW_BELOW);												
					} else {
	        	        throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.CFLOW);						
					}
        	case Pointcut.HANDLER:
        	    if (!supportedPrimitives.contains(PointcutPrimitive.HANDLER))
        	        throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.HANDLER);
        	    break;
        	case Pointcut.IF:
        	case Pointcut.IF_FALSE:
        	case Pointcut.IF_TRUE:
        	    throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.IF);       	    
        	case Pointcut.KINDED:
        		validateKindedPointcut(((KindedPointcut)pc),expression);
        	    break;
        	case Pointcut.NOT:
        	    validateAgainstSupportedPrimitives(((NotPointcut)pc).getNegatedPointcut(),expression);
        	    break;
        	case Pointcut.OR:
         	    validateAgainstSupportedPrimitives(((OrPointcut)pc).getLeft(),expression);
        		validateAgainstSupportedPrimitives(((OrPointcut)pc).getRight(),expression);
        	    break;
        	case Pointcut.REFERENCE:
        	    throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.REFERENCE);
        	case Pointcut.THIS_OR_TARGET:
        	    boolean isThis = ((ThisOrTargetPointcut)pc).isThis();
        		if (isThis && !supportedPrimitives.contains(PointcutPrimitive.THIS)) {
        		    throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.THIS);
        		} else if (!supportedPrimitives.contains(PointcutPrimitive.TARGET)) {
        		    throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.TARGET);
        		}
        	    break;
        	case Pointcut.WITHIN:
        	    if (!supportedPrimitives.contains(PointcutPrimitive.WITHIN))
        	        throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.WITHIN);
        	    break;
        	case Pointcut.WITHINCODE:
        	    if (!supportedPrimitives.contains(PointcutPrimitive.WITHIN_CODE))
        	        throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.WITHIN_CODE);
        	    break;
        	case Pointcut.NONE:  // deliberate fall-through
        	default:
        	    throw new IllegalArgumentException("Unknown pointcut kind: " + pc.getPointcutKind());
        }
    }
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { a39f595^:weaver/src/org/aspectj/weaver/patterns/AndPointcut.java

protected FuzzyBoolean matchInternal(Shadow shadow) {
		FuzzyBoolean leftMatch = left.match(shadow);
		if (leftMatch.alwaysFalse()) return leftMatch;
		return leftMatch.and(right.match(shadow));
	}
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java

private ResolvedType[] getArgumentsToMatchAgainst(Shadow shadow) {
		ResolvedType[] argumentsToMatchAgainst = shadow.getIWorld().resolve(shadow.getGenericArgTypes());

		// special treatment for adviceexecution which may have synthetic arguments we
		// want to ignore.
		if (shadow.getKind() == Shadow.AdviceExecution) {
			int numExtraArgs = 0;
			for (int i = 0; i < argumentsToMatchAgainst.length; i++) {
				String argumentSignature = argumentsToMatchAgainst[i].getSignature();
				if (argumentSignature.startsWith(ASPECTJ_JP_SIGNATURE_PREFIX) || argumentSignature.startsWith(ASPECTJ_SYNTHETIC_SIGNATURE_PREFIX)) {
					numExtraArgs++;
				} else {
					// normal arg after AJ type means earlier arg was NOT synthetic
					numExtraArgs = 0;
				}
			}
			if (numExtraArgs > 0) {
				int newArgLength = argumentsToMatchAgainst.length - numExtraArgs;
				ResolvedType[] argsSubset = new ResolvedType[newArgLength];
				System.arraycopy(argumentsToMatchAgainst, 0, argsSubset, 0, newArgLength);
				argumentsToMatchAgainst = argsSubset;
			}
		} else if (shadow.getKind() == Shadow.ConstructorExecution) {		
			if (shadow.getMatchingSignature().getParameterTypes().length < argumentsToMatchAgainst.length) {
				// there are one or more synthetic args on the end, caused by non-public itd constructor 
				int newArgLength = shadow.getMatchingSignature().getParameterTypes().length;
				ResolvedType[] argsSubset = new ResolvedType[newArgLength];
				System.arraycopy(argumentsToMatchAgainst, 0, argsSubset, 0, newArgLength);
				argumentsToMatchAgainst = argsSubset;				
			}
		}
		
		return argumentsToMatchAgainst;
	}
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { a39f595^:weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java

protected FuzzyBoolean matchInternal(Shadow shadow) {
		//??? this is not maximally efficient
		return FuzzyBoolean.MAYBE;
	}
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ConcreteCflowPointcut.java

protected FuzzyBoolean matchInternal(Shadow shadow) {
		//??? this is not maximally efficient
		return FuzzyBoolean.MAYBE;
	}
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { a39f595^:weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java

protected FuzzyBoolean matchInternal(Shadow shadow) {
		if (shadow.getKind() != Shadow.ExceptionHandler) return FuzzyBoolean.NO;
		
		exceptionType.resolve(shadow.getIWorld());
		
		// we know we have exactly one parameter since we're checking an exception handler
		return exceptionType.matches(
				shadow.getSignature().getParameterTypes()[0].resolve(shadow.getIWorld()), 
				TypePattern.STATIC);
	}
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { a39f595^:weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java

protected FuzzyBoolean matchInternal(Shadow shadow) {
		if (shadow.getKind() != kind) return FuzzyBoolean.NO;

		if (!signature.matches(shadow.getMatchingSignature(), shadow.getIWorld(),this.kind == Shadow.MethodCall)){

            if(kind == Shadow.MethodCall) {
                warnOnConfusingSig(shadow);
                //warnOnBridgeMethod(shadow);
            }
            return FuzzyBoolean.NO; 
        }

		return FuzzyBoolean.YES;
	}
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { a39f595^:weaver/src/org/aspectj/weaver/patterns/NotPointcut.java

protected FuzzyBoolean matchInternal(Shadow shadow) {
		return body.match(shadow).not();
	}
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { a39f595^:weaver/src/org/aspectj/weaver/patterns/OrPointcut.java

protected FuzzyBoolean matchInternal(Shadow shadow) {
		FuzzyBoolean leftMatch = left.match(shadow);
		if (leftMatch.alwaysTrue()) return leftMatch;
		return leftMatch.or(right.match(shadow));
	}
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { a39f595^:weaver/src/org/aspectj/weaver/patterns/Pointcut.java

protected FuzzyBoolean matchInternal(Shadow shadow) {
			return FuzzyBoolean.NO;
		}
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java

protected FuzzyBoolean matchInternal(Shadow shadow) {
		if (!couldMatch(shadow)) return FuzzyBoolean.NO;
		UnresolvedType typeToMatch = isThis ? shadow.getThisType() : shadow.getTargetType(); 
		//if (typeToMatch == ResolvedType.MISSING) return FuzzyBoolean.NO;
		
		return type.matches(typeToMatch.resolve(shadow.getIWorld()), TypePattern.DYNAMIC);
	}
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { a39f595^:weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java

protected FuzzyBoolean matchInternal(Shadow shadow) {
		ResolvedType enclosingType = shadow.getIWorld().resolve(shadow.getEnclosingType(),true);
		if (enclosingType == ResolvedType.MISSING) {
			IMessage msg = new Message(
			    WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_WITHINPCD,
			    		              shadow.getEnclosingType().getName()),
				shadow.getSourceLocation(),true,new ISourceLocation[]{getSourceLocation()});
			shadow.getIWorld().getMessageHandler().handleMessage(msg);
		}
		typePattern.resolve(shadow.getIWorld());
		return isWithinType(enclosingType);
	}
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { a39f595^:weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java

protected FuzzyBoolean matchInternal(Shadow shadow) {
		//This will not match code in local or anonymous classes as if
		//they were withincode of the outer signature
		return FuzzyBoolean.fromBoolean(
			signature.matches(shadow.getEnclosingCodeSignature(), shadow.getIWorld(), false));
	}
================= fetch protected PointcutImpl(String name, String pc, Method method, AjType declaringTy a39f595^:aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/PointcutImpl.java

================= fetch protected Test findResidueInternal(Shadow shadow, ExposedState state) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.Pointcut#findResidue(org.aspectj.weaver.Shadow, org.aspectj.weaver.patterns.ExposedState)
	 */
protected Test findResidueInternal(Shadow shadow, ExposedState state) {
		int len = shadow.getArgCount();
	
		// do some quick length tests first
		int numArgsMatchedByEllipsis = (len + arguments.ellipsisCount) - arguments.size();
		if (numArgsMatchedByEllipsis < 0) return Literal.FALSE;  // should never happen
		if ((numArgsMatchedByEllipsis > 0) && (arguments.ellipsisCount == 0)) {
			return Literal.FALSE; // should never happen
		}
		// now work through the args and the patterns, skipping at ellipsis
    	Test ret = Literal.TRUE;
    	int argsIndex = 0;
    	for (int i = 0; i < arguments.size(); i++) {
			if (arguments.get(i) == AnnotationTypePattern.ELLIPSIS) {
				// match ellipsisMatchCount args
				argsIndex += numArgsMatchedByEllipsis;
			} else if (arguments.get(i) == AnnotationTypePattern.ANY) {
				argsIndex++;
			} else {
				// match the argument type at argsIndex with the ExactAnnotationTypePattern
				// we know it is exact because nothing else is allowed in args
				ExactAnnotationTypePattern ap = (ExactAnnotationTypePattern)arguments.get(i);
				UnresolvedType argType = shadow.getArgType(argsIndex);
				ResolvedType rArgType = argType.resolve(shadow.getIWorld());
				if (rArgType == ResolvedType.MISSING) {
	                  IMessage msg = new Message(
	                    WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_ARG_TYPE,argType.getName()),
	                    "",IMessage.ERROR,shadow.getSourceLocation(),null,new ISourceLocation[]{getSourceLocation()});
	            }

				ResolvedType rAnnType = ap.getAnnotationType().resolve(shadow.getIWorld());
				if (ap instanceof BindingAnnotationTypePattern) {
					BindingAnnotationTypePattern btp = (BindingAnnotationTypePattern)ap;
					Var annvar = shadow.getArgAnnotationVar(argsIndex,rAnnType);
					state.set(btp.getFormalIndex(),annvar);
				}
				if (!ap.matches(rArgType).alwaysTrue()) {
					// we need a test...
					ret = Test.makeAnd(ret,Test.makeHasAnnotation(shadow.getArgVar(argsIndex),rAnnType));
				}			
				argsIndex++;
			}
		}   	
    	return ret;
	}
================= fetch protected boolean matchesExactly(ResolvedType type, ResolvedType annotatedType) a39f595^:weaver/src/org/aspectj/weaver/patterns/AndTypePattern.java

protected boolean matchesExactly(ResolvedType type, ResolvedType annotatedType) {
		return left.matchesExactly(type,annotatedType) && right.matchesExactly(type,annotatedType);		
	}
================= fetch protected boolean matchesExactly(ResolvedType type, ResolvedType annotatedType) a39f595^:weaver/src/org/aspectj/weaver/patterns/NotTypePattern.java

protected boolean matchesExactly(ResolvedType type, ResolvedType annotatedType) {
		return (!negatedPattern.matchesExactly(type,annotatedType) && annotationPattern.matches(annotatedType).alwaysTrue());
	}
================= fetch protected void resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.Pointcut#resolveBindings(org.aspectj.weaver.patterns.IScope, org.aspectj.weaver.patterns.Bindings)
	 */
protected void resolveBindings(IScope scope, Bindings bindings) {
		annotationTypePattern = (ExactAnnotationTypePattern) annotationTypePattern.resolveBindings(scope,bindings,true);
		// must be either a Var, or an annotation type pattern
	}
================= fetch protected void resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.Pointcut#resolveBindings(org.aspectj.weaver.patterns.IScope, org.aspectj.weaver.patterns.Bindings)
	 */
protected void resolveBindings(IScope scope, Bindings bindings) {
		arguments.resolveBindings(scope, bindings, true);
		if (arguments.ellipsisCount > 1) {
			scope.message(IMessage.ERROR, this,
					"uses more than one .. in args (compiler limitation)");
		}
	}
================= fetch protected void resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.Pointcut#resolveBindings(org.aspectj.weaver.patterns.IScope, org.aspectj.weaver.patterns.Bindings)
	 */
protected void resolveBindings(IScope scope, Bindings bindings) {
		annotationTypePattern = (ExactAnnotationTypePattern) annotationTypePattern.resolveBindings(scope,bindings,true);
		// must be either a Var, or an annotation type pattern
		// if annotationType does not have runtime retention, this is an error
		if (annotationTypePattern.annotationType == null) {
			// it's a formal with a binding error
			return;
		}
		ResolvedType rAnnotationType = (ResolvedType) annotationTypePattern.annotationType;
		if (!(rAnnotationType.isAnnotationWithRuntimeRetention())) {
		    IMessage m = MessageUtil.error(
					WeaverMessages.format(WeaverMessages.BINDING_NON_RUNTIME_RETENTION_ANNOTATION,rAnnotationType.getName()),
					getSourceLocation());
			scope.getMessageHandler().handleMessage(m);
		}
		
	}
================= fetch protected void resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.Pointcut#resolveBindings(org.aspectj.weaver.patterns.IScope, org.aspectj.weaver.patterns.Bindings)
	 */
protected void resolveBindings(IScope scope, Bindings bindings) {
		annotationTypePattern = (ExactAnnotationTypePattern) annotationTypePattern.resolveBindings(scope,bindings,true);
		// must be either a Var, or an annotation type pattern
	}
================= fetch protected void resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.Pointcut#resolveBindings(org.aspectj.weaver.patterns.IScope, org.aspectj.weaver.patterns.Bindings)
	 */
protected void resolveBindings(IScope scope, Bindings bindings) {
		annotationTypePattern = (ExactAnnotationTypePattern) annotationTypePattern.resolveBindings(scope,bindings,true);
		// must be either a Var, or an annotation type pattern
	}
================= fetch protected void setUp() throws Exception { a39f595^:weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java
/* (non-Javadoc)
	 * @see junit.framework.TestCase#setUp()
	 */
protected void setUp() throws Exception {
		super.setUp();
		wildcardArgs = new PatternParser("args(..)").parsePointcut().resolve();
		oneA = new PatternParser("args(org.aspectj.weaver.patterns.ArgsTestCase.A)").parsePointcut().resolve();
		oneAandaC = new PatternParser("args(org.aspectj.weaver.patterns.ArgsTestCase.A,org.aspectj.weaver.patterns.ArgsTestCase.C)").parsePointcut().resolve();
		BthenAnything = new PatternParser("args(org.aspectj.weaver.patterns.ArgsTestCase.B,..)").parsePointcut().resolve();
		singleArg = new PatternParser("args(*)").parsePointcut().resolve();
	}
================= fetch protected void setUp() throws Exception { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java

protected void setUp() throws Exception {
		super.setUp();
		p = new PointcutParser();
		asCons = A.class.getConstructor(new Class[]{String.class});
		bsCons = B.class.getConstructor(new Class[0]);
		bsStringCons = B.class.getConstructor(new Class[]{String.class});
		a = A.class.getMethod("a",new Class[0]);
		aa = A.class.getMethod("aa",new Class[]{int.class});
		aaa = A.class.getMethod("aaa",new Class[]{String.class,int.class});
		x = A.class.getDeclaredField("x");
		y = B.class.getDeclaredField("y");
		b = B.class.getMethod("b",new Class[0]);
		bsaa = B.class.getMethod("aa",new Class[]{int.class});
		n = Client.class.getDeclaredField("n");
		foo = Client.class.getDeclaredMethod("foo",new Class[]{String.class,int.class,Number.class});
		bar = Client.class.getDeclaredMethod("bar",new Class[]{String.class,int.class,Integer.class,Number.class});
	}
================= fetch public AjType getDeclaringType() { a39f595^:aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/PointcutImpl.java

public AjType getDeclaringType() {
		return declaringType;
	}
================= fetch public ArgsAnnotationPointcut(AnnotationPatternList arguments) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java

================= fetch public FuzzyBoolean fastMatch(FastMatchInfo info) { a39f595^:weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.Pointcut#fastMatch(org.aspectj.weaver.patterns.FastMatchInfo)
	 */
public FuzzyBoolean fastMatch(FastMatchInfo info) {
		if (info.getKind() == Shadow.StaticInitialization) {
			return annotationTypePattern.fastMatches(info.getType());
		} else {
			return FuzzyBoolean.MAYBE;
		}
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo info) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.Pointcut#fastMatch(org.aspectj.weaver.patterns.FastMatchInfo)
	 */
public FuzzyBoolean fastMatch(FastMatchInfo info) {
		return FuzzyBoolean.MAYBE;
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo info) { a39f595^:weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java

public FuzzyBoolean fastMatch(FastMatchInfo info) {
    	if (info.getKind() != null) {
			if (info.getKind() != kind) return FuzzyBoolean.NO;
    	}

		return FuzzyBoolean.MAYBE;
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo info) { a39f595^:weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java
// -----
public FuzzyBoolean fastMatch(FastMatchInfo info) {
		if (typePattern.annotationPattern instanceof AnyAnnotationTypePattern) {
			return isWithinType(info.getType());
		}
		return FuzzyBoolean.MAYBE;
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo info) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.Pointcut#fastMatch(org.aspectj.weaver.patterns.FastMatchInfo)
	 */
public FuzzyBoolean fastMatch(FastMatchInfo info) {
		return FuzzyBoolean.MAYBE;
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo info) { a39f595^:weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.Pointcut#fastMatch(org.aspectj.weaver.patterns.FastMatchInfo)
	 */
public FuzzyBoolean fastMatch(FastMatchInfo info) {
	    return annotationTypePattern.fastMatches(info.getType());
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo info) { a39f595^:weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.Pointcut#fastMatch(org.aspectj.weaver.patterns.FastMatchInfo)
	 */
public FuzzyBoolean fastMatch(FastMatchInfo info) {
		return FuzzyBoolean.MAYBE;
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo info) { a39f595^:weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java

public FuzzyBoolean fastMatch(FastMatchInfo info) {
	    if (typePattern.annotationPattern instanceof AnyAnnotationTypePattern) {
	        return isWithinType(info.getType());
	    }
	    return FuzzyBoolean.MAYBE;
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/AndPointcut.java

public FuzzyBoolean fastMatch(FastMatchInfo type) {
		return left.fastMatch(type).and(right.fastMatch(type));
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java

public FuzzyBoolean fastMatch(FastMatchInfo type) {
		return FuzzyBoolean.MAYBE;
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java

public FuzzyBoolean fastMatch(FastMatchInfo type) {
		return FuzzyBoolean.MAYBE;
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ConcreteCflowPointcut.java

public FuzzyBoolean fastMatch(FastMatchInfo type) {
		return FuzzyBoolean.MAYBE;
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java

public FuzzyBoolean fastMatch(FastMatchInfo type) {
    	//??? should be able to do better by finding all referenced types in type
		return FuzzyBoolean.MAYBE;
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/IfPointcut.java

public static IfPointcut makeIfTruePointcut(State state) {
		IfPointcut ret = new IfTruePointcut();
		ret.state = state;
		return ret;
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/NotPointcut.java

public FuzzyBoolean fastMatch(FastMatchInfo type) {
		return body.fastMatch(type).not();
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/OrPointcut.java

public FuzzyBoolean fastMatch(FastMatchInfo type) {
		return left.fastMatch(type).or(right.fastMatch(type));
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/PerCflow.java

public FuzzyBoolean fastMatch(FastMatchInfo type) {
		return FuzzyBoolean.MAYBE;
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java

public FuzzyBoolean fastMatch(FastMatchInfo type) {
		throw new RuntimeException("unimplemented");
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/PerObject.java
// -----
public FuzzyBoolean fastMatch(FastMatchInfo type) {
		return FuzzyBoolean.MAYBE;
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/PerSingleton.java

public FuzzyBoolean fastMatch(FastMatchInfo type) {
		return FuzzyBoolean.YES;
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/Pointcut.java

public FuzzyBoolean fastMatch(FastMatchInfo type) {
			return FuzzyBoolean.NO;
		}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java
//??? do either of these match methods make any sense???
public FuzzyBoolean fastMatch(FastMatchInfo type) {
		return FuzzyBoolean.MAYBE;
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java

public FuzzyBoolean fastMatch(FastMatchInfo type) {
		return FuzzyBoolean.MAYBE;
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java

public FuzzyBoolean fastMatch(FastMatchInfo type) {
		return FuzzyBoolean.MAYBE;
	}
================= fetch public FuzzyBoolean matches(ResolvedType[] types, TypePattern.MatchKind kind) { a39f595^:weaver/src/org/aspectj/weaver/patterns/TypePatternList.java
/**
     * When called with TypePattern.STATIC this will always return either
     * FuzzyBoolean.YES or FuzzyBoolean.NO.
     * 
     * When called with TypePattern.DYNAMIC this could return MAYBE if
     * at runtime it would be possible for arguments of the given static
     * types to dynamically match this, but it is not known for certain.
     * 
     * This method will never return FuzzyBoolean.NEVER
     */
public FuzzyBoolean matches(ResolvedType[] types, TypePattern.MatchKind kind) {
    	int nameLength = types.length;
		int patternLength = typePatterns.length;
		
		int nameIndex = 0;
		int patternIndex = 0;
		
		if (ellipsisCount == 0) {
			if (nameLength != patternLength) return FuzzyBoolean.NO;
			FuzzyBoolean finalReturn = FuzzyBoolean.YES;
			while (patternIndex < patternLength) {
				FuzzyBoolean ret = typePatterns[patternIndex++].matches(types[nameIndex++], kind);
				if (ret == FuzzyBoolean.NO) return ret;
				if (ret == FuzzyBoolean.MAYBE) finalReturn = ret;
			}
			return finalReturn;
		} else if (ellipsisCount == 1) {
			if (nameLength < patternLength-1) return FuzzyBoolean.NO;
			FuzzyBoolean finalReturn = FuzzyBoolean.YES;
			while (patternIndex < patternLength) {
				TypePattern p = typePatterns[patternIndex++];
				if (p == TypePattern.ELLIPSIS) {
					nameIndex = nameLength - (patternLength-patternIndex);
				} else {
					FuzzyBoolean ret = p.matches(types[nameIndex++], kind);
				    if (ret == FuzzyBoolean.NO) return ret;
				    if (ret == FuzzyBoolean.MAYBE) finalReturn = ret;
				}
			}
			return finalReturn;
		} else {
//            System.err.print("match(" + arguments + ", " + types + ") -> ");
            FuzzyBoolean b =  outOfStar(typePatterns, types, 0, 0, patternLength - ellipsisCount, nameLength, ellipsisCount, kind);
//            System.err.println(b);
            return b;
    	}
    }
================= fetch public FuzzyBoolean matchesAdviceExecution(Method anAdviceMethod, a39f595^:weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.tools.PointcutExpression#matchesAdviceExecution(java.lang.reflect.Method, java.lang.Class)
	 */
public FuzzyBoolean matchesAdviceExecution(Method anAdviceMethod,
			Class thisClass) {
		return fuzzyMatch(pointcut.matchesStatically(
				JoinPoint.ADVICE_EXECUTION,
				anAdviceMethod,
				thisClass,
				thisClass,
				null));
	}
================= fetch public FuzzyBoolean matchesConstructorCall(Constructor aConstructor, a39f595^:weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.tools.PointcutExpression#matchesConstructorCall(java.lang.reflect.Constructor, java.lang.Class, java.lang.reflect.Member)
	 */
public FuzzyBoolean matchesConstructorCall(Constructor aConstructor,
			Class thisClass, Member withinCode) {
		return fuzzyMatch(pointcut.matchesStatically(
				JoinPoint.CONSTRUCTOR_CALL,
				aConstructor,
				thisClass,
				aConstructor.getDeclaringClass(),
				withinCode));
	}
================= fetch public FuzzyBoolean matchesConstructorExecution(Constructor aConstructor, Class a39f595^:weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.tools.PointcutExpression#matchesConstructorExecution(java.lang.reflect.Constructor)
	 */
public FuzzyBoolean matchesConstructorExecution(Constructor aConstructor, Class thisClass) {
		return fuzzyMatch(pointcut.matchesStatically(
				JoinPoint.CONSTRUCTOR_EXECUTION,
				aConstructor,
				thisClass,
				thisClass,
				null));
	}
================= fetch public FuzzyBoolean matchesFieldGet(Field aField, Class thisClass, a39f595^:weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.tools.PointcutExpression#matchesFieldGet(java.lang.reflect.Field, java.lang.Class, java.lang.Class, java.lang.reflect.Member)
	 */
public FuzzyBoolean matchesFieldGet(Field aField, Class thisClass,
			Class targetClass, Member withinCode) {
		return fuzzyMatch(pointcut.matchesStatically(
				JoinPoint.FIELD_GET,
				aField,
				thisClass,
				targetClass,
				withinCode));
	}
================= fetch public FuzzyBoolean matchesFieldSet(Field aField, Class thisClass, a39f595^:weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.tools.PointcutExpression#matchesFieldSet(java.lang.reflect.Field, java.lang.Class, java.lang.Class, java.lang.reflect.Member)
	 */
public FuzzyBoolean matchesFieldSet(Field aField, Class thisClass,
			Class targetClass, Member withinCode) {
		return fuzzyMatch(pointcut.matchesStatically(
				JoinPoint.FIELD_SET,
				aField,
				thisClass,
				targetClass,
				withinCode));
	}
================= fetch public FuzzyBoolean matchesHandler(Class exceptionType, Class inClass, a39f595^:weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.tools.PointcutExpression#matchesHandler(java.lang.Class, java.lang.Class, java.lang.reflect.Member)
	 */
public FuzzyBoolean matchesHandler(Class exceptionType, Class inClass,
			Member withinCode) {
		return fuzzyMatch(pointcut.matchesStatically(
				JoinPoint.EXCEPTION_HANDLER,
				new Handler(inClass,exceptionType),
				inClass,
				inClass,
				withinCode));
	}
================= fetch public FuzzyBoolean matchesInitialization(Constructor aConstructor) { a39f595^:weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.tools.PointcutExpression#matchesInitialization(java.lang.reflect.Constructor)
	 */
public FuzzyBoolean matchesInitialization(Constructor aConstructor) {
		return fuzzyMatch(pointcut.matchesStatically(
				JoinPoint.INITIALIZATION,
				aConstructor,
				aConstructor.getDeclaringClass(),
				aConstructor.getDeclaringClass(),
				null));
	}
================= fetch public FuzzyBoolean matchesInstanceof(ResolvedType matchType) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java
// true if (matchType instanceof this.type)
public FuzzyBoolean matchesInstanceof(ResolvedType matchType) {
		// in our world, Object is assignable from anything
		if (type.equals(ResolvedType.OBJECT)) 
		    return FuzzyBoolean.YES.and(annotationPattern.matches(matchType));
		
		if (type.resolve(matchType.getWorld()).isAssignableFrom(matchType)) {
			return FuzzyBoolean.YES.and(annotationPattern.matches(matchType));
		}
		
		// fix for PR 64262 - shouldn't try to coerce primitives
		if (type.isPrimitiveType()) {
			return FuzzyBoolean.NO;
		} else {
		    return matchType.isCoerceableFrom(type.resolve(matchType.getWorld())) ? FuzzyBoolean.MAYBE : FuzzyBoolean.NO;
		}
	}
================= fetch public FuzzyBoolean matchesInstanceof(ResolvedType type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/HasMemberTypePattern.java

public FuzzyBoolean matchesInstanceof(ResolvedType type) {
		throw new UnsupportedOperationException("hasmethod/field do not support instanceof matching");
	}
================= fetch public FuzzyBoolean matchesInstanceof(ResolvedType type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/TypePattern.java
/**
	 * @see org.aspectj.weaver.patterns.TypePattern#matchesInstanceof(IType)
	 */
public FuzzyBoolean matchesInstanceof(ResolvedType type) {
		return FuzzyBoolean.NO;
	}
================= fetch public FuzzyBoolean matchesMethodCall(Method aMethod, Class thisClass, a39f595^:weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.tools.PointcutExpression#matchesMethodCall(java.lang.reflect.Method, java.lang.Class, java.lang.Class, java.lang.reflect.Member)
	 */
public FuzzyBoolean matchesMethodCall(Method aMethod, Class thisClass,
			Class targetClass, Member withinCode) {
		return fuzzyMatch(pointcut.matchesStatically(
				JoinPoint.METHOD_CALL,
				aMethod,
				thisClass,
				targetClass,
				withinCode));
	}
================= fetch public FuzzyBoolean matchesMethodExecution(Method aMethod, Class thisClass) { a39f595^:weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.tools.PointcutExpression#matchesMethodExecution(java.lang.reflect.Method, java.lang.Class)
	 */
public FuzzyBoolean matchesMethodExecution(Method aMethod, Class thisClass) {
		return fuzzyMatch(pointcut.matchesStatically(
				JoinPoint.METHOD_EXECUTION,
				aMethod,
				thisClass,
				thisClass,
				null));
	}
================= fetch public FuzzyBoolean matchesPreInitialization(Constructor aConstructor) { a39f595^:weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.tools.PointcutExpression#matchesPreInitialization(java.lang.reflect.Constructor)
	 */
public FuzzyBoolean matchesPreInitialization(Constructor aConstructor) {
		return fuzzyMatch(pointcut.matchesStatically(
				JoinPoint.PREINTIALIZATION,
				aConstructor,
				aConstructor.getDeclaringClass(),
				aConstructor.getDeclaringClass(),
				null));
	}
================= fetch public FuzzyBoolean matchesStaticInitialization(Class aClass) { a39f595^:weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.tools.PointcutExpression#matchesStaticInitialization(java.lang.Class)
	 */
public FuzzyBoolean matchesStaticInitialization(Class aClass) {
		return fuzzyMatch(pointcut.matchesStatically(
				JoinPoint.STATICINITIALIZATION,
				null,
				aClass,
				aClass,
				null
				));
	}
================= fetch public FuzzyBoolean matchesStatically( a39f595^:weaver/src/org/aspectj/weaver/patterns/Pointcut.java
// ---- test method
public static Pointcut fromString(String str) {
        PatternParser parser = new PatternParser(str);
        return parser.parsePointcut();
    }
================= fetch public FuzzyBoolean willMatchDynamically(Class staticType) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java
/**
	 * Return YES if any subtype of the static type would match,
	 *        MAYBE if some subtypes could match
	 *        NO if there could never be a match
	 * @param staticType
	 * @return
	 */
public FuzzyBoolean willMatchDynamically(Class staticType) {
		if (matchesExactly(staticType)) return FuzzyBoolean.YES;
		if (matchesInstanceof(staticType) == FuzzyBoolean.YES) return FuzzyBoolean.YES;
		
		try {
			String typeName = type.getName();
			Class toMatchAgainst = getClassFor(typeName);
			if (toMatchAgainst.isInterface()) return FuzzyBoolean.MAYBE;
			if (staticType.isAssignableFrom(toMatchAgainst)) return FuzzyBoolean.MAYBE;
			return FuzzyBoolean.NO;
		} catch (ClassNotFoundException cnfEx) {
			return FuzzyBoolean.NO;			
		}
	}
================= fetch public Method getMethod(java.lang.reflect.Method m) { a39f595^:bcel-builder/src/org/aspectj/apache/bcel/classfile/JavaClass.java
/**
   * @return Class name index.
   */
public int getSuperclassNameIndex() { return superclass_name_index; }
================= fetch public Object visit(ThisOrTargetPointcut node, Object data) { a39f595^:weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java

public Object visit(ThisOrTargetPointcut node, Object data) {
			hasDynamicContent = true;
			return null;
		}
================= fetch public Pointcut getPointcut() { a39f595^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDesignator.java

public Pointcut getPointcut() {
        return pointcut;
    }
================= fetch public Pointcut getResidueSource() { a39f595^:weaver/src/org/aspectj/weaver/patterns/IfPointcut.java
// enh 76055
public Pointcut getResidueSource() {
		return residueSource;
	}
================= fetch public Pointcut() { a39f595^:weaver/src/org/aspectj/weaver/patterns/Pointcut.java

public String[] getTypeVariablesInScope() {
		return typeVariablesInScope;
	}
================= fetch public PointcutExpression parsePointcutExpression(String expression) a39f595^:weaver/src/org/aspectj/weaver/tools/PointcutParser.java
/**
     * Parse the given pointcut expression.
     * @throws UnsupportedPointcutPrimitiveException if the parser encounters a 
     * primitive pointcut expression of a kind not supported by this PointcutParser.
     * @throws IllegalArgumentException if the expression is not a well-formed 
     * pointcut expression
     */
public PointcutExpression parsePointcutExpression(String expression)
    throws UnsupportedPointcutPrimitiveException, IllegalArgumentException {
        PointcutExpressionImpl pcExpr = null;
        try {
            Pointcut pc = new PatternParser(expression).parsePointcut();
            validateAgainstSupportedPrimitives(pc,expression);
            pc.resolve();
            pcExpr = new PointcutExpressionImpl(pc,expression);
        } catch (ParserException pEx) {
            throw new IllegalArgumentException(buildUserMessageFromParserException(expression,pEx));
        }
        return pcExpr;
    }
================= fetch public PointcutExpressionImpl(Pointcut pointcut, String expression) { a39f595^:weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java

================= fetch public ResolvedType resolveGenericTypeFor(UnresolvedType anUnresolvedType, boole a39f595^:weaver/src/org/aspectj/weaver/World.java
/**
     * Attempt to resolve a type that should be a generic type.  
     */
public ResolvedType resolveGenericTypeFor(UnresolvedType anUnresolvedType, boolean allowMissing) {
        // Look up the raw type by signature
    	String rawSignature = anUnresolvedType.getRawType().getSignature();
    	ResolvedType rawType = (ResolvedType) typeMap.get(rawSignature);
    	if (rawType==null) {
    		rawType = resolve(UnresolvedType.forSignature(rawSignature),false);
        	typeMap.put(rawSignature,rawType);
    	}
    	
    	// Does the raw type know its generic form? (It will if we created the
    	// raw type from a source type, it won't if its been created just through
    	// being referenced, e.g. java.util.List
    	ResolvedType genericType = rawType.getGenericType();
    	
    	// There is a special case to consider here (testGenericsBang_pr95993 highlights it)
    	// You may have an unresolvedType for a parameterized type but it
    	// is backed by a simple type rather than a generic type.  This occurs for
    	// inner types of generic types that inherit their enclosing types
    	// type variables.
    	if (rawType.isSimpleType() && anUnresolvedType.typeParameters.length==0) {
    		rawType.world = this;
    		return rawType; 
    	}
    	
    	if (genericType != null) { 
    		genericType.world = this;
    		return genericType; 
    	} else {
	    	// Fault in the generic that underpins the raw type ;)
	    	ReferenceTypeDelegate delegate = resolveDelegate((ReferenceType)rawType);
	    	ReferenceType genericRefType = new ReferenceType(
	    			UnresolvedType.forGenericTypeSignature(rawType.getSignature(),delegate.getDeclaredGenericSignature()),this);
	    	((ReferenceType)rawType).setGenericType(genericRefType);
	    	genericRefType.setDelegate(delegate);
	    	((ReferenceType)rawType).setDelegate(delegate);
	    	return genericRefType;
    	}
    }
================= fetch public SignaturePattern resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java

public SignaturePattern resolveBindings(IScope scope, Bindings bindings) { 
		if (returnType != null) {
			returnType = returnType.resolveBindings(scope, bindings, false, false);
		} 
		if (declaringType != null) {
			declaringType = declaringType.resolveBindings(scope, bindings, false, false);
		}
		if (parameterTypes != null) {
			parameterTypes = parameterTypes.resolveBindings(scope, bindings, false, false);
		}
		if (throwsPattern != null) {
			throwsPattern = throwsPattern.resolveBindings(scope, bindings);
		}
		if (annotationPattern != null) {
			annotationPattern = annotationPattern.resolveBindings(scope,bindings,false);
		}
		
    	return this;
    }
================= fetch public State(String name, int key) { a39f595^:weaver/src/org/aspectj/weaver/patterns/Pointcut.java

================= fetch public String getPointcutExpression() { a39f595^:weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.tools.PointcutExpression#getPointcutExpression()
	 */
public String getPointcutExpression() {
		return expression;
	}
================= fetch public String toString() { a39f595^:weaver/src/org/aspectj/weaver/patterns/TypePatternList.java

public String toString() {
    	StringBuffer buf = new StringBuffer();
    	buf.append("(");
    	for (int i=0, len=typePatterns.length; i < len; i++) {
    		TypePattern type = typePatterns[i];
    		if (i > 0) buf.append(", ");
    		if (type == TypePattern.ELLIPSIS) {
    			buf.append("..");
    		} else {
    			buf.append(type.toString());
    		}
    	}
    	buf.append(")");
    	return buf.toString();
    }
================= fetch public ThisOrTargetAnnotationPointcut(boolean isThis, ExactAnnotationTypePattern a39f595^:weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java

================= fetch public ThrowsPattern resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java

public ThrowsPattern resolveBindings(IScope scope, Bindings bindings) {
    	if (this == ANY) return this;
    	required = required.resolveBindings(scope, bindings, false, false);
    	forbidden = forbidden.resolveBindings(scope, bindings, false, false);
    	return this;
    }
================= fetch public TypePattern parameterizeWith(Map typeVariableMap) { a39f595^:weaver/src/org/aspectj/weaver/patterns/AndTypePattern.java

public TypePattern parameterizeWith(Map typeVariableMap) {
		TypePattern newLeft = left.parameterizeWith(typeVariableMap);
		TypePattern newRight = right.parameterizeWith(typeVariableMap);
		AndTypePattern ret = new AndTypePattern(newLeft,newRight);
		ret.copyLocationFrom(this);
		return ret;
	}
================= fetch public TypePattern parameterizeWith(Map typeVariableMap) { a39f595^:weaver/src/org/aspectj/weaver/patterns/NotTypePattern.java

public TypePattern parameterizeWith(Map typeVariableMap) {
		TypePattern newNegatedPattern = negatedPattern.parameterizeWith(typeVariableMap);
		NotTypePattern ret = new NotTypePattern(newNegatedPattern);
		ret.copyLocationFrom(this);
		return ret;
	}
================= fetch public TypePattern parameterizeWith(Map typeVariableMap) { a39f595^:weaver/src/org/aspectj/weaver/patterns/OrTypePattern.java

public TypePattern parameterizeWith(Map typeVariableMap) {
		TypePattern newLeft = left.parameterizeWith(typeVariableMap);
		TypePattern newRight = right.parameterizeWith(typeVariableMap);
		OrTypePattern ret = new OrTypePattern(newLeft,newRight);
		ret.copyLocationFrom(this);
		return ret;
	}
================= fetch public TypePattern resolveBindings(IScope scope, Bindings bindings, a39f595^:weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java

public TypePattern resolveBindings(IScope scope, Bindings bindings, 
    								boolean allowBinding, boolean requireExactType)
    { 
		throw new BCException("trying to re-resolve");
		
	}
================= fetch public TypePattern resolveBindings(IScope scope, Bindings bindings, a39f595^:weaver/src/org/aspectj/weaver/patterns/TypePattern.java
/**
	 * This can modify in place, or return a new TypePattern if the type changes.
	 */
public TypePattern resolveBindings(IScope scope, Bindings bindings, 
    								boolean allowBinding, boolean requireExactType)
    { 
    	annotationPattern = annotationPattern.resolveBindings(scope,bindings,allowBinding);
    	return this;
    }
================= fetch public TypePatternList resolveBindings(IScope scope, Bindings bindings, boolean a39f595^:weaver/src/org/aspectj/weaver/patterns/TypePatternList.java

public TypePatternList resolveBindings(IScope scope, Bindings bindings, boolean allowBinding, boolean requireExactType) {
		for (int i=0; i<typePatterns.length; i++) {
			TypePattern p = typePatterns[i];
			if (p != null) {
				typePatterns[i] = typePatterns[i].resolveBindings(scope, bindings, allowBinding, requireExactType);
			}
		}
		return this;
	}
================= fetch public UnresolvedType getReturnType() { a39f595^:weaver/src/org/aspectj/weaver/Shadow.java

public UnresolvedType getReturnType() {
		if (kind == ConstructorCall) return getSignature().getDeclaringType();
		else if (kind == FieldSet) return ResolvedType.VOID;
		return getResolvedSignature().getGenericReturnType();
	}
================= fetch public WithinAnnotationPointcut(AnnotationTypePattern type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java

================= fetch public WithinAnnotationPointcut(AnnotationTypePattern type, ShadowMunger munger) a39f595^:weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java

================= fetch public WithinCodeAnnotationPointcut(ExactAnnotationTypePattern type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java

================= fetch public WithinCodeAnnotationPointcut(ExactAnnotationTypePattern type, ShadowMunge a39f595^:weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java

================= fetch public boolean couldMatchJoinPointsInType(Class aClass) { a39f595^:weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java

public boolean couldMatchJoinPointsInType(Class aClass) {
		return pointcut.fastMatch(aClass).maybeTrue();
	}
================= fetch public boolean declaringTypeMatchAllowingForCovariance(Member member, Unresolved a39f595^:weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java

public boolean declaringTypeMatchAllowingForCovariance(Member member, UnresolvedType shadowDeclaringType, World world,TypePattern returnTypePattern,ResolvedType sigReturn) {
		
		ResolvedType onType = shadowDeclaringType.resolve(world);
			
		// fastmatch
		if (declaringType.matchesStatically(onType) && returnTypePattern.matchesStatically(sigReturn)) 
			return true;
			
		Collection declaringTypes = member.getDeclaringTypes(world);
		
		boolean checkReturnType = true;
		// XXX Possible enhancement?  Doesn't seem to speed things up
		//	if (returnTypePattern.isStar()) {
		//		if (returnTypePattern instanceof WildTypePattern) {
		//			if (((WildTypePattern)returnTypePattern).getDimensions()==0) checkReturnType = false;
		//		}
		//	}
			
		// Sometimes that list includes types that don't explicitly declare the member we are after -
		// they are on the list because their supertype is on the list, that's why we use
		// lookupMethod rather than lookupMemberNoSupers()
		for (Iterator i = declaringTypes.iterator(); i.hasNext(); ) {
			ResolvedType type = (ResolvedType)i.next();
			if (declaringType.matchesStatically(type)) {
			  if (!checkReturnType) return true;
			  ResolvedMember rm = type.lookupMethod(member);
			  if (rm==null)  rm = type.lookupMethodInITDs(member); // It must be in here, or we have *real* problems
			  if (rm==null) continue; // might be currently looking at the generic type and we need to continue searching in case we hit a parameterized version of this same type...
			  UnresolvedType returnTypeX = rm.getReturnType();
			  ResolvedType returnType = returnTypeX.resolve(world);
			  if (returnTypePattern.matchesStatically(returnType)) return true;
			}
		}
		return false;
	}
================= fetch public boolean matches(UnresolvedType[] tys, World world) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java

public boolean matches(UnresolvedType[] tys, World world) {
		if (this == ANY) return true;
		
		//System.out.println("matching: " + this + " with " + Arrays.asList(tys));
		
		ResolvedType[] types = world.resolve(tys);
		// int len = types.length;
		for (int j=0, lenj = required.size(); j < lenj; j++) {
			if (! matchesAny(required.get(j), types)) {
				return false;
			}
		}
		for (int j=0, lenj = forbidden.size(); j < lenj; j++) {
			if (matchesAny(forbidden.get(j), types)) {
				return false;
			}
		}
		return true;
	}
================= fetch public boolean matchesStatically(ResolvedType type) { a39f595^:weaver/src/org/aspectj/weaver/patterns/OrTypePattern.java

public boolean matchesStatically(ResolvedType type) {
		return left.matchesStatically(type) || right.matchesStatically(type);
	}
================= fetch public boolean mayNeedDynamicTest() { a39f595^:weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java

public boolean mayNeedDynamicTest() {
		HasPossibleDynamicContentVisitor visitor = new HasPossibleDynamicContentVisitor();
		pointcut.traverse(visitor, null);
		return visitor.hasDynamicContent();
	}
================= fetch public final FuzzyBoolean match(Shadow shadow) { a39f595^:weaver/src/org/aspectj/weaver/patterns/Pointcut.java
/**
	 * Do I really match this shadow?
	 * XXX implementors need to handle state
	 */
public final FuzzyBoolean match(Shadow shadow) {
		if (shadow.shadowId == lastMatchedShadowId) return lastMatchedShadowResult;
		FuzzyBoolean ret;
		// this next test will prevent a lot of un-needed matching going on....
		if (couldMatchKinds().contains(shadow.getKind())) {
			ret = matchInternal(shadow);
		} else {
			ret = FuzzyBoolean.NO;
		}
		lastMatchedShadowId = shadow.shadowId;
		lastMatchedShadowResult = ret;
		return ret;
	}
================= fetch public final FuzzyBoolean matches(Class toMatch, MatchKind kind) { a39f595^:weaver/src/org/aspectj/weaver/patterns/TypePattern.java
// methods for dynamic pc matching...
public final FuzzyBoolean matches(Class toMatch, MatchKind kind) {
		if (kind == STATIC) {
			return FuzzyBoolean.fromBoolean(matchesStatically(toMatch));
		} else if (kind == DYNAMIC) {
			//System.err.println("matching: " + this + " with " + type);
			FuzzyBoolean ret = matchesInstanceof(toMatch);
			//System.err.println("    got: " + ret);
			return ret;
		} else {
			throw new IllegalArgumentException("kind must be DYNAMIC or STATIC");
		}
	}
================= fetch public final FuzzyBoolean matches(ResolvedType type, MatchKind kind) { a39f595^:weaver/src/org/aspectj/weaver/patterns/TypePattern.java

public final FuzzyBoolean matches(ResolvedType type, MatchKind kind) {
		FuzzyBoolean typeMatch = null;
		//??? This is part of gracefully handling missing references
		if (type == ResolvedType.MISSING) return FuzzyBoolean.NO;
		
		if (kind == STATIC) {
//			typeMatch = FuzzyBoolean.fromBoolean(matchesStatically(type));
//			return typeMatch.and(annotationPattern.matches(type));
		    return FuzzyBoolean.fromBoolean(matchesStatically(type));
		} else if (kind == DYNAMIC) {
			//System.err.println("matching: " + this + " with " + type);
//			typeMatch = matchesInstanceof(type);
			//System.err.println("    got: " + ret);
//			return typeMatch.and(annotationPattern.matches(type));
		    return matchesInstanceof(type);
		} else {
			throw new IllegalArgumentException("kind must be DYNAMIC or STATIC");
		}
	}
================= fetch public final Pointcut resolve(IScope scope) { a39f595^:weaver/src/org/aspectj/weaver/patterns/Pointcut.java
/**
     * Returns this pointcut mutated
     */
public final Pointcut resolve(IScope scope) {
    	assertState(SYMBOLIC);
    	Bindings bindingTable = new Bindings(scope.getFormalCount());
    	IScope bindingResolutionScope = scope;
    	if (typeVariablesInScope.length > 0) {
    		bindingResolutionScope = new ScopeWithTypeVariables(typeVariablesInScope,scope);
    	}
        this.resolveBindings(bindingResolutionScope, bindingTable);
        bindingTable.checkAllBound(bindingResolutionScope);
        this.state = RESOLVED;
        return this;  	
    }
================= fetch public int hashCode() { a39f595^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java

public int hashCode() {
        int result = 17;
        for (int i = 0, len = namePatterns.length; i < len; i++) {
            result = 37*result + namePatterns[i].hashCode();
        }
        result = 37*result + annotationPattern.hashCode();
        if (upperBound != null) result = 37*result + upperBound.hashCode();
        if (lowerBound != null) result = 37*result + lowerBound.hashCode();
        return result;
    }
================= fetch public static Annotation createAroundAnnotation(String pointcutExpression, int p a39f595^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AtAspectJAnnotationFactory.java

public static Annotation createAroundAnnotation(String pointcutExpression, int pos) {
		char[][] typeName = new char[][] {org,aspectj,lang,annotation,around};
		return makeSingleStringMemberAnnotation(typeName, pos, pointcutExpression);
	}
================= fetch public static Annotation createPointcutAnnotation(String pointcutExpression, int a39f595^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AtAspectJAnnotationFactory.java

public static Annotation createPointcutAnnotation(String pointcutExpression, int pos) {
		char[][] typeName = new char[][] {org,aspectj,lang,annotation,pointcut};
		return makeSingleStringMemberAnnotation(typeName, pos, pointcutExpression);
	}
================= fetch public static Kind read(VersionedDataInputStream s) throws IOException { a39f595^:weaver/src/org/aspectj/weaver/patterns/PerClause.java

public final Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, IntMap bindings) {
    	throw new RuntimeException("unimplemented: wrong concretize");
    }
================= fetch public static Set getAllSupportedPointcutPrimitives() { a39f595^:weaver/src/org/aspectj/weaver/tools/PointcutParser.java

public static Set getAllSupportedPointcutPrimitives() {
        Set primitives = new HashSet();
        primitives.add(PointcutPrimitive.ADVICE_EXECUTION);
        primitives.add(PointcutPrimitive.ARGS);
        primitives.add(PointcutPrimitive.CALL);
        primitives.add(PointcutPrimitive.EXECUTION);
        primitives.add(PointcutPrimitive.GET);
        primitives.add(PointcutPrimitive.HANDLER);
        primitives.add(PointcutPrimitive.INITIALIZATION);
        primitives.add(PointcutPrimitive.PRE_INITIALIZATION);
        primitives.add(PointcutPrimitive.SET);
        primitives.add(PointcutPrimitive.STATIC_INITIALIZATION);
        primitives.add(PointcutPrimitive.TARGET);
        primitives.add(PointcutPrimitive.THIS);
        primitives.add(PointcutPrimitive.WITHIN);
        primitives.add(PointcutPrimitive.WITHIN_CODE);
        return primitives;
    }
================= fetch public static String getSignature(java.lang.reflect.Method meth) { a39f595^:bcel-builder/src/org/aspectj/apache/bcel/generic/Type.java

public static String getSignature(java.lang.reflect.Method meth) {
    StringBuffer sb = new StringBuffer("(");
    Class[] params = meth.getParameterTypes(); // avoid clone

    for(int j = 0; j < params.length; j++) {
      sb.append(getType(params[j]).getSignature());
    }

    sb.append(")");
    sb.append(getType(meth.getReturnType()).getSignature());
    return sb.toString();
  }
================= fetch public static Test suite() { a39f595^:weaver/testsrc/BcweaverModuleTests15.java

public static Test suite() { 
	        TestSuite suite = new TestSuite(BcweaverModuleTests15.class.getName());
	        suite.addTestSuite(TypeVariableTestCase.class);
	        suite.addTestSuite(ReferenceTypeTestCase.class);
	        suite.addTestSuite(BoundedReferenceTypeTestCase.class);
	        suite.addTestSuite(TypeVariableReferenceTypeTestCase.class);
	        suite.addTestSuite(MemberTestCase15.class);
	        suite.addTestSuite(BcelGenericSignatureToTypeXTestCase.class);
	        suite.addTestSuite(WildTypePatternResolutionTestCase.class);
	        return suite;
	    }
================= fetch public static Test suite() { a39f595^:weaver/testsrc/org/aspectj/weaver/patterns/PatternsTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(PatternsTests.class.getName());
        //$JUnit-BEGIN$
        suite.addTestSuite(AndOrNotTestCase.class); 
        suite.addTestSuite(BindingTestCase.class); 
        suite.addTestSuite(DeclareErrorOrWarningTestCase.class); 
        suite.addTestSuite(ModifiersPatternTestCase.class); 
        suite.addTestSuite(NamePatternParserTestCase.class); 
        suite.addTestSuite(NamePatternTestCase.class); 
        suite.addTestSuite(ParserTestCase.class); 
        suite.addTestSuite(SignaturePatternTestCase.class); 
        suite.addTestSuite(ThisOrTargetTestCase.class); 
        suite.addTestSuite(TypePatternListTestCase.class); 
        suite.addTestSuite(TypePatternTestCase.class); 
        suite.addTestSuite(WithinTestCase.class); 
        suite.addTestSuite(PointcutTestCase.class);
        suite.addTestSuite(ArgsTestCase.class);
        suite.addTestSuite(HandlerTestCase.class);
        suite.addTestSuite(KindedTestCase.class);
        suite.addTestSuite(WithinCodeTestCase.class);
        suite.addTestSuite(AnnotationPatternTestCase.class);
        suite.addTestSuite(AnnotationPatternMatchingTestCase.class);
        suite.addTestSuite(PointcutRewriterTest.class);

        suite.addTestSuite(VisitorTestCase.class);
        //$JUnit-END$
        return suite;
    }
================= fetch public static UnresolvedType forGenericTypeSignature(String sig,String declaredG a39f595^:weaver/src/org/aspectj/weaver/UnresolvedType.java

public static UnresolvedType forGenericTypeSignature(String sig,String declaredGenericSig) {
    	UnresolvedType ret = UnresolvedType.forSignature(sig);
    	ret.typeKind=TypeKind.GENERIC;
    	
    	ClassSignature csig = new GenericSignatureParser().parseAsClassSignature(declaredGenericSig);
    	
    	Signature.FormalTypeParameter[] ftps = csig.formalTypeParameters;
    	ret.typeVariables = new TypeVariable[ftps.length];
    	for (int i = 0; i < ftps.length; i++) {
			Signature.FormalTypeParameter parameter = ftps[i];
			Signature.ClassTypeSignature cts = (Signature.ClassTypeSignature)parameter.classBound;
			ret.typeVariables[i]=new TypeVariable(ftps[i].identifier,UnresolvedType.forSignature(cts.outerType.identifier+";"));
		}
    	ret.signatureErasure = sig;
    	ret.signature = ret.signatureErasure;
    	return ret;
    }
================= fetch public void aa(int i) {} a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java

public void aaa(String s, int i) {}
================= fetch public void addAtAspectJAnnotations() { a39f595^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java
/**
	 * Called from the AtAspectJVisitor to create the @Pointcut annotation
	 * (and corresponding method) for this pointcut
	 *
	 */
public void addAtAspectJAnnotations() {
		Annotation pcutAnnotation = AtAspectJAnnotationFactory.createPointcutAnnotation(getPointcut().toString(),declarationSourceStart);;
		if (annotations == null) {
			annotations = new Annotation[] { pcutAnnotation };
		} else {
			Annotation[] old = annotations;
			annotations = new Annotation[old.length +1];
			System.arraycopy(old,0,annotations,0,old.length);
			annotations[old.length] = pcutAnnotation;
		}		
		generateSyntheticPointcutMethod = true;
	}
================= fetch public void bar(String s, int i, Integer i2, Number n) {} a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java

public void bar(String s, int i, Integer i2, Number n) {}
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/AndPointcut.java

public void resolveBindings(IScope scope, Bindings bindings) {
		left.resolveBindings(scope, bindings);
		right.resolveBindings(scope, bindings);
	}
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java

public void resolveBindings(IScope scope, Bindings bindings) {
		arguments.resolveBindings(scope, bindings, true, true);
		if (arguments.ellipsisCount > 1) {
			scope.message(IMessage.ERROR, this,
					"uses more than one .. in args (compiler limitation)");
		}
	}
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java

public void resolveBindings(IScope scope, Bindings bindings) {
		if (bindings == null) {
			entry.resolveBindings(scope, null);
			entry.state = RESOLVED;
			freeVars = new int[0];
		} else {
			//??? for if's sake we might need to be more careful here
			Bindings entryBindings = new Bindings(bindings.size());
			
			entry.resolveBindings(scope, entryBindings);
			entry.state = RESOLVED;
			
			freeVars = entryBindings.getUsedFormals();
			
			bindings.mergeIn(entryBindings, scope);
		}
	}
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ConcreteCflowPointcut.java

public void resolveBindings(IScope scope, Bindings bindings) {
		throw new RuntimeException("unimplemented");
	}
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java
// list in capturing type identifiers.
public void resolveBindings(IScope scope, Bindings bindings) {
		exceptionType = exceptionType.resolveBindings(scope, bindings, false, false);
		boolean invalidParameterization = false;
		if (exceptionType.getTypeParameters().size() > 0) invalidParameterization = true ;
		UnresolvedType exactType = exceptionType.getExactType();
		if (exactType != null && exactType.isParameterizedType()) invalidParameterization = true;
		if (invalidParameterization) {
			// no parameterized or generic types for handler
			scope.message(
					MessageUtil.error(WeaverMessages.format(WeaverMessages.HANDLER_PCD_DOESNT_SUPPORT_PARAMETERS),
									getSourceLocation()));
		}
		//XXX add error if exact binding and not an exception
	}
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/IfPointcut.java

public static IfPointcut makeIfTruePointcut(State state) {
		IfPointcut ret = new IfTruePointcut();
		ret.state = state;
		return ret;
	}
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java
// list in capturing type identifiers.
public void resolveBindings(IScope scope, Bindings bindings) {
		if (kind == Shadow.Initialization) {
//			scope.getMessageHandler().handleMessage(
//				MessageUtil.error(
//					"initialization unimplemented in 1.1beta1",
//					this.getSourceLocation()));
		}
		signature = signature.resolveBindings(scope, bindings);
		
		
		if (kind == Shadow.ConstructorExecution) { 		// Bug fix 60936
		  if (signature.getDeclaringType() != null) {
			World world = scope.getWorld();
			UnresolvedType exactType = signature.getDeclaringType().getExactType();
			if (signature.getKind() == Member.CONSTRUCTOR &&
				!exactType.equals(ResolvedType.MISSING) &&
				exactType.resolve(world).isInterface() &&
				!signature.getDeclaringType().isIncludeSubtypes()) {
					world.getLint().noInterfaceCtorJoinpoint.signal(exactType.toString(), getSourceLocation());
				}
		  }
		}
		
		// no parameterized types
		if (kind == Shadow.StaticInitialization) {
			HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor 
				visitor = new HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor();
			signature.getDeclaringType().traverse(visitor, null);
			if (visitor.wellHasItThen/*?*/()) {
				scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.NO_STATIC_INIT_JPS_FOR_PARAMETERIZED_TYPES),
						getSourceLocation()));
			}
		}
		
		// no parameterized types in declaring type position
		if ((kind == Shadow.FieldGet) || (kind == Shadow.FieldSet)) {
			HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor 
				visitor = new HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor();
			signature.getDeclaringType().traverse(visitor, null);
			if (visitor.wellHasItThen/*?*/()) {
				scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.GET_AND_SET_DONT_SUPPORT_DEC_TYPE_PARAMETERS),
						getSourceLocation()));
			}	
			
			// fields can't have a void type!
			UnresolvedType returnType = signature.getReturnType().getExactType();
			if (returnType == ResolvedType.VOID) {
				scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.FIELDS_CANT_HAVE_VOID_TYPE),
						getSourceLocation()));				
			}
		}
		
		// no join points for initialization and preinitialization of parameterized types
		// no throwable parameterized types
		if ((kind == Shadow.Initialization) || (kind == Shadow.PreInitialization)) {
			HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor 
			visitor = new HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor();
			signature.getDeclaringType().traverse(visitor, null);
			if (visitor.wellHasItThen/*?*/()) {
				scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.NO_INIT_JPS_FOR_PARAMETERIZED_TYPES),
						getSourceLocation()));
			}						
			
			visitor = new HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor();
			signature.getThrowsPattern().traverse(visitor, null);
			if (visitor.wellHasItThen/*?*/()) {
				scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.NO_GENERIC_THROWABLES),
						getSourceLocation()));
			}									
		}
		
		// no parameterized types in declaring type position
		// no throwable parameterized types
		if ((kind == Shadow.MethodExecution) || (kind == Shadow.ConstructorExecution)) {
			HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor 
			visitor = new HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor();
			signature.getDeclaringType().traverse(visitor, null);
			if (visitor.wellHasItThen/*?*/()) {
				scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.EXECUTION_DOESNT_SUPPORT_PARAMETERIZED_DECLARING_TYPES),
						getSourceLocation()));
			}						
			
			visitor = new HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor();
			signature.getThrowsPattern().traverse(visitor, null);
			if (visitor.wellHasItThen/*?*/()) {
				scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.NO_GENERIC_THROWABLES),
						getSourceLocation()));
			}									
		}
		
		// no parameterized types in declaring type position
		// no throwable parameterized types
		if ((kind == Shadow.MethodCall) || (kind == Shadow.ConstructorCall)) {
			HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor 
			visitor = new HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor();
			signature.getDeclaringType().traverse(visitor, null);
			if (visitor.wellHasItThen/*?*/()) {
				scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.CALL_DOESNT_SUPPORT_PARAMETERIZED_DECLARING_TYPES),
						getSourceLocation()));
			}						
			
			visitor = new HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor();
			signature.getThrowsPattern().traverse(visitor, null);
			if (visitor.wellHasItThen/*?*/()) {
				scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.NO_GENERIC_THROWABLES),
						getSourceLocation()));
			}									
		}
	}
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/NotPointcut.java

public void resolveBindings(IScope scope, Bindings bindings) {
		//Bindings old = bindings.copy();
		
		//Bindings newBindings = new Bindings(bindings.size());
		
		
		body.resolveBindings(scope, null);
		
		//newBindings.checkEmpty(scope, "negation does not allow binding");
		//bindings.checkEquals(old, scope);
		
	}
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/OrPointcut.java
/**
	 * @see org.aspectj.weaver.patterns.Pointcut#resolveBindings(IScope, Bindings)
	 */
public void resolveBindings(IScope scope, Bindings bindings) {
		Bindings old = bindings == null ? null : bindings.copy();
		
		left.resolveBindings(scope, bindings);
		right.resolveBindings(scope, old);
		if (bindings != null) bindings.checkEquals(old, scope);
		
	}
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/Pointcut.java

public void resolveBindings(IScope scope, Bindings bindings) {
		}
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java

public void resolveBindings(IScope scope, Bindings bindings) {
		if (onTypeSymbolic != null) {
			onType = onTypeSymbolic.resolveExactType(scope, bindings);
			// in this case we've already signalled an error
			if (onType == ResolvedType.MISSING) return;		
		}
		
		ResolvedType searchType;
		if (onType != null) {
			searchType = scope.getWorld().resolve(onType);
		} else {
			searchType = scope.getEnclosingType();
		}
		
		
		arguments.resolveBindings(scope, bindings, true, true);
		//XXX ensure that arguments has no ..'s in it
		
		// check that I refer to a real pointcut declaration and that I match
		
		ResolvedPointcutDefinition pointcutDef = searchType.findPointcut(name);
		// if we're not a static reference, then do a lookup of outers
		if (pointcutDef == null && onType == null) {
			while (true) {
				UnresolvedType declaringType = searchType.getDeclaringType();
				if (declaringType == null) break;
				searchType = declaringType.resolve(scope.getWorld());
				pointcutDef = searchType.findPointcut(name);
				if (pointcutDef != null) {
					// make this a static reference
					onType = searchType;
					break;
				}
			}
		}
		
		if (pointcutDef == null) {
			scope.message(IMessage.ERROR, this, "can't find referenced pointcut " + name);
			return;
		}
		
		// check visibility
		if (!pointcutDef.isVisible(scope.getEnclosingType())) {
			scope.message(IMessage.ERROR, this, "pointcut declaration " + pointcutDef + " is not accessible");
			return;
		}
		
		if (Modifier.isAbstract(pointcutDef.getModifiers())) {
			if (onType != null) {
				scope.message(IMessage.ERROR, this, 
								"can't make static reference to abstract pointcut");
				return;
			} else if (!searchType.isAbstract()) {
				scope.message(IMessage.ERROR, this,
								"can't use abstract pointcut in concrete context");
				return;
			}
		}
		
		
		ResolvedType[] parameterTypes = 
			scope.getWorld().resolve(pointcutDef.getParameterTypes());
		
		if (parameterTypes.length != arguments.size()) {
			scope.message(IMessage.ERROR, this, "incompatible number of arguments to pointcut, expected " +
						parameterTypes.length + " found " + arguments.size());
			return;
		}
		
		
		
		for (int i=0,len=arguments.size(); i < len; i++) {
			TypePattern p = arguments.get(i);
			//we are allowed to bind to pointcuts which use subtypes as this is type safe
			if (p == TypePattern.NO) {
				scope.message(IMessage.ERROR, this,
								"bad parameter to pointcut reference");
				return;
			}
			if (!p.matchesSubtypes(parameterTypes[i]) && 
				!p.getExactType().equals(UnresolvedType.OBJECT))
			{
				scope.message(IMessage.ERROR, p, "incompatible type, expected " +
						parameterTypes[i].getName() + " found " + p);
				return;
			}
		}
		
		if (onType != null) {
			if (onType.isParameterizedType()) {
				// build a type map mapping type variable names in the generic type to
				// the type parameters presented
				typeVariableMap = new HashMap();
				ResolvedType underlyingGenericType = ((ResolvedType) onType).getGenericType();
				TypeVariable[] tVars = underlyingGenericType.getTypeVariables();
				ResolvedType[] typeParams = ((ResolvedType)onType).getResolvedTypeParameters();
				for (int i = 0; i < tVars.length; i++) {
					typeVariableMap.put(tVars[i].getName(),typeParams[i]);
				}
			} else if (onType.isGenericType()) {
				scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_REFERENCE_POINTCUT_IN_RAW_TYPE),
						getSourceLocation()));
			}
		}
	}
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java

public void resolveBindings(IScope scope, Bindings bindings) {
		type = type.resolveBindings(scope, bindings, true, true);
		
		// look for parameterized type patterns which are not supported...
		HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor 
			visitor = new HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor();
		type.traverse(visitor, null);
		if (visitor.wellHasItThen/*?*/()) {
			scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.THIS_AND_TARGET_DONT_SUPPORT_PARAMETERS),
				getSourceLocation()));
		}		
		// ??? handle non-formal
	}
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java

public void resolveBindings(IScope scope, Bindings bindings) {
		typePattern = typePattern.resolveBindings(scope, bindings, false, false);
		
		// look for parameterized type patterns which are not supported...
		HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor 
			visitor = new HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor();
		typePattern.traverse(visitor, null);
		if (visitor.wellHasItThen/*?*/()) {
			scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.WITHIN_PCD_DOESNT_SUPPORT_PARAMETERS),
				getSourceLocation()));
		}		
	}
================= fetch public void resolveBindings(IScope scope, Bindings bindings) { a39f595^:weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java

public void resolveBindings(IScope scope, Bindings bindings) {
		signature = signature.resolveBindings(scope, bindings);
		
		// look for inappropriate use of parameterized types and tell user...
		HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor 
			visitor = new HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor();
		signature.getDeclaringType().traverse(visitor, null);
		if (visitor.wellHasItThen/*?*/()) {
			scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.WITHINCODE_DOESNT_SUPPORT_PARAMETERIZED_DECLARING_TYPES),
					getSourceLocation()));
		}						
		
		visitor = new HasThisTypePatternTriedToSneakInSomeGenericOrParameterizedTypePatternMatchingStuffAnywhereVisitor();
		signature.getThrowsPattern().traverse(visitor, null);
		if (visitor.wellHasItThen/*?*/()) {
			scope.message(MessageUtil.error(WeaverMessages.format(WeaverMessages.NO_GENERIC_THROWABLES),
					getSourceLocation()));
		}					
	}
================= fetch public void testArgsMatching() { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java

public void testArgsMatching() {
		// too few args
		PointcutExpression ex = p.parsePointcutExpression("args(*,*,*,*)");
		assertEquals("Too few args",FuzzyBoolean.NO,ex.matchesMethodExecution(foo,Client.class));
		assertEquals("Matching #args",FuzzyBoolean.YES,ex.matchesMethodExecution(bar,Client.class));
		// one too few + ellipsis
		ex = p.parsePointcutExpression("args(*,*,*,..)");
		assertEquals("Matches with ellipsis",FuzzyBoolean.YES,ex.matchesMethodExecution(foo,Client.class));
		// exact number + ellipsis
		assertEquals("Matches with ellipsis",FuzzyBoolean.YES,ex.matchesMethodExecution(bar,Client.class));
		assertEquals("Does not match with ellipsis",FuzzyBoolean.NO,ex.matchesMethodExecution(a,A.class));		
		// too many + ellipsis
		ex = p.parsePointcutExpression("args(*,..,*)");
		assertEquals("Matches with ellipsis",FuzzyBoolean.YES,ex.matchesMethodExecution(bar,Client.class));
		assertEquals("Does not match with ellipsis",FuzzyBoolean.NO,ex.matchesMethodExecution(a,A.class));		
		assertEquals("Matches with ellipsis",FuzzyBoolean.YES,ex.matchesMethodExecution(aaa,A.class));
		// exact match
		ex = p.parsePointcutExpression("args(String,int,Number)");
		assertEquals("Matches exactly",FuzzyBoolean.YES,ex.matchesMethodExecution(foo,Client.class));
		// maybe match
		ex = p.parsePointcutExpression("args(String,int,Double)");
		assertEquals("Matches maybe",FuzzyBoolean.MAYBE,ex.matchesMethodExecution(foo,Client.class));
		// never match
		ex = p.parsePointcutExpression("args(String,Integer,Number)");
		assertEquals("Does not match",FuzzyBoolean.NO,ex.matchesMethodExecution(foo,Client.class));
	}
================= fetch public void testCouldMatchJoinPointsInType() { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java

public void testCouldMatchJoinPointsInType() {
		PointcutExpression ex = p.parsePointcutExpression("execution(* org.aspectj.weaver.tools.PointcutExpressionTest.B.*(..))");
		assertFalse("Could never match String",ex.couldMatchJoinPointsInType(String.class));
		assertTrue("Will always match B",ex.couldMatchJoinPointsInType(B.class));
		assertFalse("Does not match A",ex.couldMatchJoinPointsInType(A.class));
	}
================= fetch public void testDeows() { a39f595^:tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjAnnotationGenTests.java

public void testDeows() {
		runTest("ann gen for deows");
	}
================= fetch public void testEmptyConstructor() { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java

public void testEmptyConstructor() {
		PointcutParser parser = new PointcutParser();
		Set s = parser.getSupportedPrimitives();
		assertEquals("Should be 14 elements in the set",14,s.size());
		assertFalse("Should not contain if pcd",s.contains(PointcutPrimitive.IF));
		assertFalse("Should not contain cflow pcd",s.contains(PointcutPrimitive.CFLOW));
		assertFalse("Should not contain cflowbelow pcd",s.contains(PointcutPrimitive.CFLOW_BELOW));
	}
================= fetch public void testGetAllSupportedPointcutPrimitives() { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java

public void testGetAllSupportedPointcutPrimitives() {
		Set s = PointcutParser.getAllSupportedPointcutPrimitives();
		assertEquals("Should be 14 elements in the set",14,s.size());
		assertFalse("Should not contain if pcd",s.contains(PointcutPrimitive.IF));
		assertFalse("Should not contain cflow pcd",s.contains(PointcutPrimitive.CFLOW));
		assertFalse("Should not contain cflowbelow pcd",s.contains(PointcutPrimitive.CFLOW_BELOW));
	}
================= fetch public void testMatch() throws IOException { a39f595^:weaver/testsrc/org/aspectj/weaver/patterns/AndOrNotTestCase.java

public void testMatch() throws IOException {
		world = new BcelWorld();
		
		Pointcut foo = makePointcut("this(Foo)");
		Pointcut bar = makePointcut("this(Bar)");
		Pointcut c = makePointcut("this(C)");
		
		checkEquals("this(Foo) && this(Bar)", new AndPointcut(foo, bar));
		checkEquals("this(Foo) && this(Bar) && this(C)", new AndPointcut(foo, new AndPointcut(bar, c)));


		checkEquals("this(Foo) || this(Bar)", new OrPointcut(foo, bar));
		checkEquals("this(Foo) || this(Bar) || this(C)", new OrPointcut(foo, new OrPointcut(bar, c)));
		
		checkEquals("this(Foo) && this(Bar) || this(C)", new OrPointcut(new AndPointcut(foo, bar), c));
		checkEquals("this(Foo) || this(Bar) && this(C)", new OrPointcut(foo, new AndPointcut(bar, c)));
		checkEquals("(this(Foo) || this(Bar)) && this(C)", new AndPointcut(new OrPointcut(foo, bar), c));
		checkEquals("this(Foo) || (this(Bar) && this(C))", new OrPointcut(foo, new AndPointcut(bar, c)));
	
		checkEquals("!this(Foo)", new NotPointcut(foo));
		checkEquals("!this(Foo) && this(Bar)", new AndPointcut(new NotPointcut(foo), bar));
		checkEquals("!(this(Foo) && this(Bar)) || this(C)", new OrPointcut(new NotPointcut(new AndPointcut(foo, bar)), c));
		checkEquals("!!this(Foo)", new NotPointcut(new NotPointcut(foo)));
		
	}
================= fetch public void testMatch() throws IOException { a39f595^:weaver/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java

public void testMatch() throws IOException {
		world = new BcelWorld();
		

		
	}
================= fetch public void testMatch() throws IOException { a39f595^:weaver/testsrc/org/aspectj/weaver/patterns/WithinTestCase.java

public void testMatch() throws IOException {
		Shadow getOutFromArrayList = new TestShadow(
			Shadow.FieldGet, 
			MemberImpl.fieldFromString("java.io.PrintStream java.lang.System.out"),
			UnresolvedType.forName("java.util.ArrayList"),
			world);

		checkMatch(makePointcut("within(*)"), getOutFromArrayList, FuzzyBoolean.YES);
		checkMatch(makePointcut("within(java.util.*)"), getOutFromArrayList, FuzzyBoolean.YES);
		checkMatch(makePointcut("within(java.lang.*)"), getOutFromArrayList, FuzzyBoolean.NO);
		checkMatch(makePointcut("within(java.util.List+)"), getOutFromArrayList, FuzzyBoolean.YES);
		checkMatch(makePointcut("within(java.uti*.List+)"), getOutFromArrayList, FuzzyBoolean.YES);
		checkMatch(makePointcut("within(java.uti*..*)"), getOutFromArrayList, FuzzyBoolean.YES);
		checkMatch(makePointcut("within(java.util.*List)"), getOutFromArrayList, FuzzyBoolean.YES);
		checkMatch(makePointcut("within(java.util.List*)"), getOutFromArrayList, FuzzyBoolean.NO);
		
		
		Shadow getOutFromEntry = new TestShadow(
			Shadow.FieldGet, 
			MemberImpl.fieldFromString("java.io.PrintStream java.lang.System.out"),
			UnresolvedType.forName("java.util.Map$Entry"),
			world);
			
		checkMatch(makePointcut("within(*)"), getOutFromEntry, FuzzyBoolean.YES);
		checkMatch(makePointcut("within(java.util.*)"), getOutFromEntry, FuzzyBoolean.YES);
		checkMatch(makePointcut("within(java.util.Map.*)"), getOutFromEntry, FuzzyBoolean.YES);
		checkMatch(makePointcut("within(java.util..*)"), getOutFromEntry, FuzzyBoolean.YES);
		checkMatch(makePointcut("within(java.util.Map..*)"), getOutFromEntry, FuzzyBoolean.YES);
		checkMatch(makePointcut("within(java.lang.*)"), getOutFromEntry, FuzzyBoolean.NO);
		checkMatch(makePointcut("within(java.util.List+)"), getOutFromEntry, FuzzyBoolean.NO);
		checkMatch(makePointcut("within(java.util.Map+)"), getOutFromEntry, FuzzyBoolean.YES);
		checkMatch(makePointcut("within(java.lang.Object+)"), getOutFromEntry, FuzzyBoolean.YES);
		
		//this is something we should in type patterns tests
		//checkMatch(makePointcut("within(*List)"), getOut, FuzzyBoolean.NO);

	}
================= fetch public void testMatchJP() { a39f595^:weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java

public void testMatchJP() {
		Factory f = new Factory("ArgsTestCase.java",ArgsTestCase.A.class);
		
		JoinPoint.StaticPart jpsp1 = f.makeSJP(JoinPoint.METHOD_EXECUTION,f.makeMethodSig(0,"aMethod",A.class,new Class[] {A.class},new String[] {"a"},new Class[] {},null) ,1);
		JoinPoint.StaticPart jpsp2 = f.makeSJP(JoinPoint.METHOD_EXECUTION,f.makeMethodSig(0,"aMethod",A.class,new Class[] {B.class},new String[] {"b"},new Class[] {},null),1);
		JoinPoint.StaticPart jpsp3 = f.makeSJP(JoinPoint.METHOD_EXECUTION,f.makeMethodSig(0,"aMethod",A.class,new Class[] {A.class,C.class},new String[] {"a","c"},new Class[] {},null),1);
		JoinPoint.StaticPart jpsp4 = f.makeSJP(JoinPoint.METHOD_EXECUTION,f.makeMethodSig(0,"aMethod",A.class,new Class[] {A.class,A.class},new String[] {"a","a2"},new Class[] {},null),1);
		JoinPoint oneAArg = Factory.makeJP(jpsp1,new A(),new A(),new A());
		JoinPoint oneBArg = Factory.makeJP(jpsp2,new A(), new A(), new B());
		JoinPoint acArgs = Factory.makeJP(jpsp3,new A(), new A(), new A(), new C());
		JoinPoint baArgs = Factory.makeJP(jpsp4,new A(), new A(), new B(), new A());
		
		checkMatches(wildcardArgs,oneAArg,null,FuzzyBoolean.YES);
		checkMatches(wildcardArgs,oneBArg,null,FuzzyBoolean.YES);
		checkMatches(wildcardArgs,acArgs,null,FuzzyBoolean.YES);
		checkMatches(wildcardArgs,baArgs,null,FuzzyBoolean.YES);
		
		checkMatches(oneA,oneAArg,null,FuzzyBoolean.YES);
		checkMatches(oneA,oneBArg,null,FuzzyBoolean.YES);
		checkMatches(oneA,acArgs,null,FuzzyBoolean.NO);
		checkMatches(oneA,baArgs,null,FuzzyBoolean.NO);

		checkMatches(oneAandaC,oneAArg,null,FuzzyBoolean.NO);
		checkMatches(oneAandaC,oneBArg,null,FuzzyBoolean.NO);
		checkMatches(oneAandaC,acArgs,null,FuzzyBoolean.YES);
		checkMatches(oneAandaC,baArgs,null,FuzzyBoolean.NO);
		
		checkMatches(BthenAnything,oneAArg,null,FuzzyBoolean.NO);
		checkMatches(BthenAnything,oneBArg,null,FuzzyBoolean.YES);
		checkMatches(BthenAnything,acArgs,null,FuzzyBoolean.NO);
		checkMatches(BthenAnything,baArgs,null,FuzzyBoolean.YES);

		checkMatches(singleArg,oneAArg,null,FuzzyBoolean.YES);
		checkMatches(singleArg,oneBArg,null,FuzzyBoolean.YES);
		checkMatches(singleArg,acArgs,null,FuzzyBoolean.NO);
		checkMatches(singleArg,baArgs,null,FuzzyBoolean.NO);

	}
================= fetch public void testMatchJP() { a39f595^:weaver/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java

public void testMatchJP() {
		Factory f = new Factory("ThisOrTargetTestCase.java",ThisOrTargetTestCase.class);
		
		Pointcut thisEx = new PatternParser("this(Exception)").parsePointcut().resolve();
		Pointcut thisIOEx = new PatternParser("this(java.io.IOException)").parsePointcut().resolve();

		Pointcut targetEx = new PatternParser("target(Exception)").parsePointcut().resolve();
		Pointcut targetIOEx = new PatternParser("target(java.io.IOException)").parsePointcut().resolve();

		JoinPoint.StaticPart jpsp1 = f.makeSJP(JoinPoint.EXCEPTION_HANDLER,f.makeCatchClauseSig(HandlerTestCase.class,Exception.class,"ex"),1);
		JoinPoint thisExJP = Factory.makeJP(jpsp1,new Exception(),this);
		JoinPoint thisIOExJP = Factory.makeJP(jpsp1,new IOException(),this);
		JoinPoint targetExJP = Factory.makeJP(jpsp1,this,new Exception());
		JoinPoint targetIOExJP = Factory.makeJP(jpsp1,this,new IOException());
		
		checkMatches(thisEx,thisExJP,null,FuzzyBoolean.YES);
		checkMatches(thisIOEx,thisExJP,null,FuzzyBoolean.NO);
		checkMatches(targetEx,thisExJP,null,FuzzyBoolean.NO);
		checkMatches(targetIOEx,thisExJP,null,FuzzyBoolean.NO);

		checkMatches(thisEx,thisIOExJP,null,FuzzyBoolean.YES);
		checkMatches(thisIOEx,thisIOExJP,null,FuzzyBoolean.YES);
		checkMatches(targetEx,thisIOExJP,null,FuzzyBoolean.NO);
		checkMatches(targetIOEx,thisIOExJP,null,FuzzyBoolean.NO);

		checkMatches(thisEx,targetExJP,null,FuzzyBoolean.NO);
		checkMatches(thisIOEx,targetExJP,null,FuzzyBoolean.NO);
		checkMatches(targetEx,targetExJP,null,FuzzyBoolean.YES);
		checkMatches(targetIOEx,targetExJP,null,FuzzyBoolean.NO);

		checkMatches(thisEx,targetIOExJP,null,FuzzyBoolean.NO);
		checkMatches(thisIOEx,targetIOExJP,null,FuzzyBoolean.NO);
		checkMatches(targetEx,targetIOExJP,null,FuzzyBoolean.YES);
		checkMatches(targetIOEx,targetIOExJP,null,FuzzyBoolean.YES);
	}
================= fetch public void testMatchJPWithPrimitiveTypes() { a39f595^:weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java

public void testMatchJPWithPrimitiveTypes() {
		try {
			Factory f = new Factory("ArgsTestCase.java",ArgsTestCase.A.class);
			
			Pointcut oneInt = new PatternParser("args(int)").parsePointcut().resolve();
			Pointcut oneInteger = new PatternParser("args(Integer)").parsePointcut().resolve();

			JoinPoint.StaticPart oneIntjp = f.makeSJP(JoinPoint.METHOD_EXECUTION,f.makeMethodSig(0,"aMethod",A.class,new Class[] {int.class},new String[] {"i"},new Class[] {},null) ,1);
			JoinPoint.StaticPart oneIntegerjp = f.makeSJP(JoinPoint.METHOD_EXECUTION,f.makeMethodSig(0,"aMethod",A.class,new Class[] {Integer.class},new String[] {"i"},new Class[] {},null),1);

			JoinPoint oneIntArg = Factory.makeJP(oneIntjp,new A(),new A(),new Integer(3));
			JoinPoint oneIntegerArg = Factory.makeJP(oneIntegerjp,new A(), new A(), new Integer(7));
			
			checkMatches(oneInt,oneIntArg,null,FuzzyBoolean.YES);
			checkMatches(oneInt,oneIntegerArg,null,FuzzyBoolean.NO);
			checkMatches(oneInteger,oneIntArg,null,FuzzyBoolean.NO);
			checkMatches(oneInteger,oneIntegerArg,null,FuzzyBoolean.YES);
			
		} catch( Exception ex) {
			fail("Unexpected exception " + ex);
		}
		
	}
================= fetch public void testMatchesAdviceExecution() { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java

public void testMatchesAdviceExecution() {
		PointcutExpression ex = p.parsePointcutExpression("adviceexecution()");
		assertEquals("Should match (advice) A.a",FuzzyBoolean.YES,ex.matchesAdviceExecution(a,A.class));
		// test this
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.Client)");
		assertEquals("Should match Client",FuzzyBoolean.YES,ex.matchesAdviceExecution(a,Client.class));
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("Maybe matches B",FuzzyBoolean.MAYBE,ex.matchesAdviceExecution(a,A.class));
		assertEquals("Does not match client",FuzzyBoolean.NO,ex.matchesAdviceExecution(a,Client.class));
		// test target
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.Client)");
		assertEquals("Should match Client",FuzzyBoolean.YES,ex.matchesAdviceExecution(a,Client.class));
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("Maybe matches B",FuzzyBoolean.MAYBE,ex.matchesAdviceExecution(a,A.class));
		assertEquals("Does not match client",FuzzyBoolean.NO,ex.matchesAdviceExecution(a,Client.class));
		// test within
		ex = p.parsePointcutExpression("within(*..A)");
		assertEquals("Matches in class A",FuzzyBoolean.YES,ex.matchesAdviceExecution(a,A.class));
		assertEquals("Does not match in class B",FuzzyBoolean.NO,ex.matchesAdviceExecution(b,B.class));		
		// withincode
		ex = p.parsePointcutExpression("withincode(* a*(..))");
		assertEquals("Does not match",FuzzyBoolean.NO,ex.matchesAdviceExecution(a,A.class));
		// test args
		ex = p.parsePointcutExpression("args(..,int)");
		assertEquals("Should match A.aa",FuzzyBoolean.YES,ex.matchesAdviceExecution(aa,A.class));
		assertEquals("Should match A.aaa",FuzzyBoolean.YES,ex.matchesAdviceExecution(aaa,A.class));
		assertEquals("Should not match A.a",FuzzyBoolean.NO,ex.matchesAdviceExecution(a,A.class));
	}
================= fetch public void testMatchesConstructorCall() { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java

public void testMatchesConstructorCall() {
		PointcutExpression ex = p.parsePointcutExpression("call(new(String))");
		assertEquals("Should match A(String)",FuzzyBoolean.YES, ex.matchesConstructorCall(asCons,A.class,null));
		assertEquals("Should match B(String)", FuzzyBoolean.YES, ex.matchesConstructorCall(bsStringCons,Client.class,null));
		assertEquals("Should not match B()", FuzzyBoolean.NO,ex.matchesConstructorCall(bsCons,Client.class,null));
		ex = p.parsePointcutExpression("call(*..A.new(String))");
		assertEquals("Should match A(String)",FuzzyBoolean.YES, ex.matchesConstructorCall(asCons,A.class,null));
		assertEquals("Should not match B(String)", FuzzyBoolean.NO, ex.matchesConstructorCall(bsStringCons,Client.class,null));
		// this
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.Client)");
		assertEquals("Should match Client",FuzzyBoolean.YES,ex.matchesConstructorCall(asCons,Client.class,null));
		assertEquals("Should not match A",FuzzyBoolean.NO,ex.matchesConstructorCall(asCons,A.class,null));
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("Should maybe match B",FuzzyBoolean.MAYBE,ex.matchesConstructorCall(asCons,A.class,null));
		// target
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.Client)");
		assertEquals("Should not match Client",FuzzyBoolean.NO,ex.matchesConstructorCall(asCons,Client.class,null));
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.A)");
		assertEquals("Should match A",FuzzyBoolean.YES,ex.matchesConstructorCall(asCons,A.class,null));
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("Should maybe match A",FuzzyBoolean.MAYBE,ex.matchesConstructorCall(asCons,A.class,null));		
		// args
		ex = p.parsePointcutExpression("args(String)");
		assertEquals("Should match A(String)",FuzzyBoolean.YES, ex.matchesConstructorCall(asCons,A.class,null));
		assertEquals("Should match B(String)", FuzzyBoolean.YES, ex.matchesConstructorCall(bsStringCons,Client.class,null));
		assertEquals("Should not match B()", FuzzyBoolean.NO,ex.matchesConstructorCall(bsCons,Client.class,null));
		// within
		ex = p.parsePointcutExpression("within(*..A)");
		assertEquals("Matches in class A",FuzzyBoolean.YES,ex.matchesConstructorCall(asCons,A.class,null));
		assertEquals("Does not match in class B",FuzzyBoolean.NO,ex.matchesConstructorCall(asCons,B.class,null));
		// withincode
		ex = p.parsePointcutExpression("withincode(* a*(..))");
		assertEquals("Should match",FuzzyBoolean.YES,ex.matchesConstructorCall(bsCons,B.class,aa));
		assertEquals("Should not match",FuzzyBoolean.NO,ex.matchesConstructorCall(bsCons,B.class,b));
	}
================= fetch public void testMatchesConstructorExecution() { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java

public void testMatchesConstructorExecution() {
		PointcutExpression ex = p.parsePointcutExpression("execution(new(String))");
		assertEquals("Should match A(String)",FuzzyBoolean.YES, ex.matchesConstructorExecution(asCons,A.class));
		assertEquals("Should match B(String)", FuzzyBoolean.YES, ex.matchesConstructorExecution(bsStringCons,Client.class));
		assertEquals("Should not match B()", FuzzyBoolean.NO,ex.matchesConstructorExecution(bsCons,Client.class));
		ex = p.parsePointcutExpression("execution(*..A.new(String))");
		assertEquals("Should match A(String)",FuzzyBoolean.YES, ex.matchesConstructorExecution(asCons,A.class));
		assertEquals("Should not match B(String)", FuzzyBoolean.NO, ex.matchesConstructorExecution(bsStringCons,Client.class));
		// test this
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.A)");
		assertEquals("Should match A",FuzzyBoolean.YES,ex.matchesConstructorExecution(asCons,A.class));
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("Maybe matches B",FuzzyBoolean.MAYBE,ex.matchesConstructorExecution(asCons,A.class));
		assertEquals("Should match B",FuzzyBoolean.YES,ex.matchesConstructorExecution(asCons,B.class));
		assertEquals("Does not match client",FuzzyBoolean.NO,ex.matchesConstructorExecution(asCons,Client.class));
		// test target
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.A)");
		assertEquals("Should match A",FuzzyBoolean.YES,ex.matchesConstructorExecution(asCons,A.class));
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("Maybe matches B",FuzzyBoolean.MAYBE,ex.matchesConstructorExecution(asCons,A.class));
		assertEquals("Should match B",FuzzyBoolean.YES,ex.matchesConstructorExecution(asCons,B.class));
		assertEquals("Does not match client",FuzzyBoolean.NO,ex.matchesConstructorExecution(asCons,Client.class));
		// within
		ex = p.parsePointcutExpression("within(*..A)");
		assertEquals("Matches in class A",FuzzyBoolean.YES,ex.matchesConstructorExecution(asCons,B.class));
		assertEquals("Does not match in class B",FuzzyBoolean.NO,ex.matchesConstructorExecution(bsCons,B.class));
		// withincode
		ex = p.parsePointcutExpression("withincode(* a*(..))");
		assertEquals("Does not match",FuzzyBoolean.NO,ex.matchesConstructorExecution(bsCons,B.class));
		// args
		ex = p.parsePointcutExpression("args(String)");
		assertEquals("Should match A(String)",FuzzyBoolean.YES, ex.matchesConstructorExecution(asCons,A.class));
		assertEquals("Should match B(String)", FuzzyBoolean.YES, ex.matchesConstructorExecution(bsStringCons,Client.class));
		assertEquals("Should not match B()", FuzzyBoolean.NO,ex.matchesConstructorExecution(bsCons,Client.class));
	}
================= fetch public void testMatchesFieldGet() { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java

public void testMatchesFieldGet() {
		PointcutExpression ex = p.parsePointcutExpression("get(* *..A+.*)");
		assertEquals("matches x",FuzzyBoolean.YES,ex.matchesFieldGet(x,Client.class,A.class,null));
		assertEquals("matches y",FuzzyBoolean.YES,ex.matchesFieldGet(y,Client.class,B.class,null));
		assertEquals("does not match n",FuzzyBoolean.NO,ex.matchesFieldGet(n,A.class,Client.class,null));
		// this
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.Client)");
		assertEquals("matches Client",FuzzyBoolean.YES,ex.matchesFieldGet(x,Client.class,A.class,null));
		assertEquals("does not match A",FuzzyBoolean.NO,ex.matchesFieldGet(n,A.class,Client.class,null));
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("maybe matches A",FuzzyBoolean.MAYBE,ex.matchesFieldGet(x,A.class,A.class,null));
		// target
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("matches B",FuzzyBoolean.YES,ex.matchesFieldGet(y,Client.class,B.class,null));
		assertEquals("maybe matches A",FuzzyBoolean.MAYBE,ex.matchesFieldGet(x,Client.class,A.class,null));		
		// args
		ex = p.parsePointcutExpression("args(int)");
		assertEquals("matches x",FuzzyBoolean.NO,ex.matchesFieldGet(x,Client.class,A.class,null));
		assertEquals("matches y",FuzzyBoolean.NO,ex.matchesFieldGet(y,Client.class,B.class,null));
		assertEquals("does not match n",FuzzyBoolean.NO,ex.matchesFieldGet(n,A.class,Client.class,null));
		// within
		ex = p.parsePointcutExpression("within(*..A)");
		assertEquals("Matches in class A",FuzzyBoolean.YES,ex.matchesFieldGet(x,A.class,A.class,null));
		assertEquals("Does not match in class B",FuzzyBoolean.NO,ex.matchesFieldGet(x,B.class,A.class,null));
		// withincode
		ex = p.parsePointcutExpression("withincode(* a*(..))");
		assertEquals("Should match",FuzzyBoolean.YES,ex.matchesFieldGet(x,A.class,A.class,aa));
		assertEquals("Should not match",FuzzyBoolean.NO,ex.matchesFieldGet(x,A.class,A.class,b));
	}
================= fetch public void testMatchesFieldSet() { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java

public void testMatchesFieldSet() {
		PointcutExpression ex = p.parsePointcutExpression("set(* *..A+.*)");
		assertEquals("matches x",FuzzyBoolean.YES,ex.matchesFieldSet(x,Client.class,A.class,null));
		assertEquals("matches y",FuzzyBoolean.YES,ex.matchesFieldSet(y,Client.class,B.class,null));
		assertEquals("does not match n",FuzzyBoolean.NO,ex.matchesFieldSet(n,A.class,Client.class,null));
		// this
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.Client)");
		assertEquals("matches Client",FuzzyBoolean.YES,ex.matchesFieldSet(x,Client.class,A.class,null));
		assertEquals("does not match A",FuzzyBoolean.NO,ex.matchesFieldSet(n,A.class,Client.class,null));
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("maybe matches A",FuzzyBoolean.MAYBE,ex.matchesFieldSet(x,A.class,A.class,null));
		// target
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("matches B",FuzzyBoolean.YES,ex.matchesFieldSet(y,Client.class,B.class,null));
		assertEquals("maybe matches A",FuzzyBoolean.MAYBE,ex.matchesFieldSet(x,Client.class,A.class,null));		
		// args
		ex = p.parsePointcutExpression("args(int)");
		assertEquals("matches x",FuzzyBoolean.YES,ex.matchesFieldSet(x,Client.class,A.class,null));
		assertEquals("matches y",FuzzyBoolean.YES,ex.matchesFieldSet(y,Client.class,B.class,null));
		assertEquals("does not match n",FuzzyBoolean.NO,ex.matchesFieldSet(n,A.class,Client.class,null));
		// within
		ex = p.parsePointcutExpression("within(*..A)");
		assertEquals("Matches in class A",FuzzyBoolean.YES,ex.matchesFieldSet(x,A.class,A.class,null));
		assertEquals("Does not match in class B",FuzzyBoolean.NO,ex.matchesFieldSet(x,B.class,A.class,null));
		// withincode
		ex = p.parsePointcutExpression("withincode(* a*(..))");
		assertEquals("Should match",FuzzyBoolean.YES,ex.matchesFieldSet(x,A.class,A.class,aa));
		assertEquals("Should not match",FuzzyBoolean.NO,ex.matchesFieldSet(x,A.class,A.class,b));
	}
================= fetch public void testMatchesHandler() { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java

public void testMatchesHandler() {
		PointcutExpression ex = p.parsePointcutExpression("handler(Exception)");
		assertEquals("Should match catch(Exception)",FuzzyBoolean.YES,ex.matchesHandler(Exception.class,Client.class,null));
		assertEquals("Should not match catch(Throwable)",FuzzyBoolean.NO,ex.matchesHandler(Throwable.class,Client.class,null));
		// test this
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.Client)");
		assertEquals("Should match Client",FuzzyBoolean.YES,ex.matchesHandler(Exception.class,Client.class,null));
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("Maybe matches B",FuzzyBoolean.MAYBE,ex.matchesHandler(Exception.class,A.class,null));
		assertEquals("Does not match client",FuzzyBoolean.NO,ex.matchesHandler(Exception.class,Client.class,null));
		// target
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.Client)");
		assertEquals("Should match Client",FuzzyBoolean.YES,ex.matchesHandler(Exception.class,Client.class,null));
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("Maybe matches B",FuzzyBoolean.MAYBE,ex.matchesHandler(Exception.class,A.class,null));
		assertEquals("Does not match client",FuzzyBoolean.NO,ex.matchesHandler(Exception.class,Client.class,null));
		// args
		ex = p.parsePointcutExpression("args(Exception)");
		assertEquals("Should match Exception",FuzzyBoolean.YES, ex.matchesHandler(Exception.class,Client.class,null));
		assertEquals("Should match RuntimeException",FuzzyBoolean.YES, ex.matchesHandler(RuntimeException.class,Client.class,null));
		assertEquals("Should not match String",FuzzyBoolean.NO,ex.matchesHandler(String.class,Client.class,null));
		assertEquals("Maybe matches Throwable",FuzzyBoolean.MAYBE,ex.matchesHandler(Throwable.class,Client.class,null));
		// within
		ex = p.parsePointcutExpression("within(*..Client)");
		assertEquals("Matches in class Client",FuzzyBoolean.YES,ex.matchesHandler(Exception.class,Client.class,null));
		assertEquals("Does not match in class B",FuzzyBoolean.NO,ex.matchesHandler(Exception.class,B.class,null));
		// withincode
		ex = p.parsePointcutExpression("withincode(* a*(..))");
		assertEquals("Matches within aa",FuzzyBoolean.YES,ex.matchesHandler(Exception.class,Client.class,aa));
		assertEquals("Does not match within b",FuzzyBoolean.NO,ex.matchesHandler(Exception.class,Client.class,b));
	}
================= fetch public void testMatchesInitialization() { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java

public void testMatchesInitialization() {
		PointcutExpression ex = p.parsePointcutExpression("initialization(new(String))");
		assertEquals("Should match A(String)",FuzzyBoolean.YES, ex.matchesInitialization(asCons));
		assertEquals("Should match B(String)", FuzzyBoolean.YES, ex.matchesInitialization(bsStringCons));
		assertEquals("Should not match B()", FuzzyBoolean.NO,ex.matchesInitialization(bsCons));
		ex = p.parsePointcutExpression("initialization(*..A.new(String))");
		assertEquals("Should match A(String)",FuzzyBoolean.YES, ex.matchesInitialization(asCons));
		assertEquals("Should not match B(String)", FuzzyBoolean.NO, ex.matchesInitialization(bsStringCons));
		// test this
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.A)");
		assertEquals("Should match A",FuzzyBoolean.YES,ex.matchesInitialization(asCons));
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("Maybe matches B",FuzzyBoolean.MAYBE,ex.matchesInitialization(asCons));
		// test target
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.A)");
		assertEquals("Should match A",FuzzyBoolean.YES,ex.matchesInitialization(asCons));
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("Maybe matches B",FuzzyBoolean.MAYBE,ex.matchesInitialization(asCons));
		// within
		ex = p.parsePointcutExpression("within(*..A)");
		assertEquals("Matches in class A",FuzzyBoolean.YES,ex.matchesInitialization(asCons));
		assertEquals("Does not match in class B",FuzzyBoolean.NO,ex.matchesInitialization(bsCons));
		// withincode
		ex = p.parsePointcutExpression("withincode(* a*(..))");
		assertEquals("Does not match",FuzzyBoolean.NO,ex.matchesInitialization(bsCons));
		// args
		ex = p.parsePointcutExpression("args(String)");
		assertEquals("Should match A(String)",FuzzyBoolean.YES, ex.matchesInitialization(asCons));
		assertEquals("Should match B(String)", FuzzyBoolean.YES, ex.matchesInitialization(bsStringCons));
		assertEquals("Should not match B()", FuzzyBoolean.NO,ex.matchesInitialization(bsCons));
	}
================= fetch public void testMatchesMethodCall() { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java

public void testMatchesMethodCall() {
		PointcutExpression ex = p.parsePointcutExpression("call(* *..A.a*(..))");
		assertEquals("Should match call to A.a()",FuzzyBoolean.YES,ex.matchesMethodCall(a,Client.class,A.class,null));
		assertEquals("Should match call to A.aaa()",FuzzyBoolean.YES,ex.matchesMethodCall(aaa,Client.class,A.class,null));
		assertEquals("Should match call to B.aa()",FuzzyBoolean.YES,ex.matchesMethodCall(bsaa,Client.class,A.class,null));
		assertEquals("Should not match call to B.b()",FuzzyBoolean.NO,ex.matchesMethodCall(b,Client.class,A.class,null));
		ex = p.parsePointcutExpression("call(* *..A.a*(int))");
		assertEquals("Should match call to A.aa()",FuzzyBoolean.YES,ex.matchesMethodCall(aa,Client.class,A.class,null));
		assertEquals("Should not match call to A.a()",FuzzyBoolean.NO,ex.matchesMethodCall(a,Client.class,A.class,null));
		ex = p.parsePointcutExpression("call(void aaa(..)) && this(org.aspectj.weaver.tools.PointcutExpressionTest.Client)");
		assertEquals("Should match call to A.aaa() from Client",FuzzyBoolean.YES,ex.matchesMethodCall(aaa,Client.class,A.class,null));
		ex = p.parsePointcutExpression("call(void aaa(..)) && this(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("Should match call to A.aaa() from B",FuzzyBoolean.YES,ex.matchesMethodCall(aaa,B.class,A.class,null));
		assertEquals("May match call to A.aaa() from A",FuzzyBoolean.MAYBE,ex.matchesMethodCall(aaa,A.class,A.class,null));
		ex = p.parsePointcutExpression("execution(* *.*(..))");
		assertEquals("Should not match call to A.aa",FuzzyBoolean.NO,ex.matchesMethodCall(aa,A.class,A.class,null));
		// this
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.Client)");
		assertEquals("Should match Client",FuzzyBoolean.YES,ex.matchesMethodCall(a,Client.class,A.class,null));
		assertEquals("Should not match A",FuzzyBoolean.NO,ex.matchesMethodCall(a,A.class,A.class,null));
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("Should maybe match B",FuzzyBoolean.MAYBE,ex.matchesMethodCall(bsaa,A.class,B.class,null));
		// target
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.Client)");
		assertEquals("Should not match Client",FuzzyBoolean.NO,ex.matchesMethodCall(a,Client.class,A.class,null));
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.A)");
		assertEquals("Should match A",FuzzyBoolean.YES,ex.matchesMethodCall(a,Client.class,A.class,null));
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("Should maybe match A",FuzzyBoolean.MAYBE,ex.matchesMethodCall(aa,A.class,A.class,null));		
		// test args
		ex = p.parsePointcutExpression("args(..,int)");
		assertEquals("Should match A.aa",FuzzyBoolean.YES,ex.matchesMethodCall(aa,A.class,A.class,null));
		assertEquals("Should match A.aaa",FuzzyBoolean.YES,ex.matchesMethodCall(aaa,A.class,A.class,null));
		assertEquals("Should not match A.a",FuzzyBoolean.NO,ex.matchesMethodCall(a,A.class,A.class,null));
		// within
		ex = p.parsePointcutExpression("within(*..A)");
		assertEquals("Matches in class A",FuzzyBoolean.YES,ex.matchesMethodCall(a,A.class,A.class,null));
		assertEquals("Does not match in class B",FuzzyBoolean.NO,ex.matchesMethodCall(a,B.class,A.class,null));
		// withincode
		ex = p.parsePointcutExpression("withincode(* a*(..))");
		assertEquals("Should match",FuzzyBoolean.YES,ex.matchesMethodCall(b,B.class,B.class,bsaa));
		assertEquals("Should not match",FuzzyBoolean.NO,ex.matchesMethodCall(b,B.class,B.class,b));
	}
================= fetch public void testMatchesMethodExecution() { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java

public void testMatchesMethodExecution() {
		PointcutExpression ex = p.parsePointcutExpression("execution(* *..A.aa(..))");
		assertEquals("Should match execution of A.aa",FuzzyBoolean.YES,ex.matchesMethodExecution(aa,A.class));
		assertEquals("Should match execution of B.aa",FuzzyBoolean.YES,ex.matchesMethodExecution(bsaa,B.class));
		assertEquals("Should not match execution of A.a",FuzzyBoolean.NO,ex.matchesMethodExecution(a,B.class));
		ex = p.parsePointcutExpression("call(* *..A.a*(int))");
		assertEquals("Should not match execution of A.a",FuzzyBoolean.NO,ex.matchesMethodExecution(a,B.class));
		// test this
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.A)");
		assertEquals("Should match A",FuzzyBoolean.YES,ex.matchesMethodExecution(a,A.class));
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("Maybe matches B",FuzzyBoolean.MAYBE,ex.matchesMethodExecution(a,A.class));
		assertEquals("Should match B",FuzzyBoolean.YES,ex.matchesMethodExecution(a,B.class));
		assertEquals("Does not match client",FuzzyBoolean.NO,ex.matchesMethodExecution(a,Client.class));
		// test target
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.A)");
		assertEquals("Should match A",FuzzyBoolean.YES,ex.matchesMethodExecution(a,A.class));
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("Maybe matches B",FuzzyBoolean.MAYBE,ex.matchesMethodExecution(a,A.class));
		assertEquals("Should match B",FuzzyBoolean.YES,ex.matchesMethodExecution(a,B.class));
		assertEquals("Does not match client",FuzzyBoolean.NO,ex.matchesMethodExecution(a,Client.class));
		// test args
		ex = p.parsePointcutExpression("args(..,int)");
		assertEquals("Should match A.aa",FuzzyBoolean.YES,ex.matchesMethodExecution(aa,A.class));
		assertEquals("Should match A.aaa",FuzzyBoolean.YES,ex.matchesMethodExecution(aaa,A.class));
		assertEquals("Should not match A.a",FuzzyBoolean.NO,ex.matchesMethodExecution(a,A.class));
		// within
		ex = p.parsePointcutExpression("within(*..A)");
		assertEquals("Matches in class A",FuzzyBoolean.YES,ex.matchesMethodExecution(a,A.class));
		assertEquals("Does not match in class B",FuzzyBoolean.NO,ex.matchesMethodExecution(bsaa,B.class));
		// withincode
		ex = p.parsePointcutExpression("withincode(* a*(..))");
		assertEquals("Should not match",FuzzyBoolean.NO,ex.matchesMethodExecution(a,A.class));
	}
================= fetch public void testMatchesPreInitialization() { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java

public void testMatchesPreInitialization() {
		PointcutExpression ex = p.parsePointcutExpression("preinitialization(new(String))");
		assertEquals("Should match A(String)",FuzzyBoolean.YES, ex.matchesPreInitialization(asCons));
		assertEquals("Should match B(String)", FuzzyBoolean.YES, ex.matchesPreInitialization(bsStringCons));
		assertEquals("Should not match B()", FuzzyBoolean.NO,ex.matchesPreInitialization(bsCons));
		ex = p.parsePointcutExpression("preinitialization(*..A.new(String))");
		assertEquals("Should match A(String)",FuzzyBoolean.YES, ex.matchesPreInitialization(asCons));
		assertEquals("Should not match B(String)", FuzzyBoolean.NO, ex.matchesPreInitialization(bsStringCons));
		// test this
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.A)");
		assertEquals("Should match A",FuzzyBoolean.YES,ex.matchesPreInitialization(asCons));
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("Maybe matches B",FuzzyBoolean.MAYBE,ex.matchesPreInitialization(asCons));
		// test target
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.A)");
		assertEquals("Should match A",FuzzyBoolean.YES,ex.matchesPreInitialization(asCons));
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.B)");
		assertEquals("Maybe matches B",FuzzyBoolean.MAYBE,ex.matchesPreInitialization(asCons));
		// within
		ex = p.parsePointcutExpression("within(*..A)");
		assertEquals("Matches in class A",FuzzyBoolean.YES,ex.matchesPreInitialization(asCons));
		assertEquals("Does not match in class B",FuzzyBoolean.NO,ex.matchesPreInitialization(bsCons));
		// withincode
		ex = p.parsePointcutExpression("withincode(* a*(..))");
		assertEquals("Does not match",FuzzyBoolean.NO,ex.matchesPreInitialization(bsCons));
		// args
		ex = p.parsePointcutExpression("args(String)");
		assertEquals("Should match A(String)",FuzzyBoolean.YES, ex.matchesPreInitialization(asCons));
		assertEquals("Should match B(String)", FuzzyBoolean.YES, ex.matchesPreInitialization(bsStringCons));
		assertEquals("Should not match B()", FuzzyBoolean.NO,ex.matchesPreInitialization(bsCons));	}
================= fetch public void testMatchesStaticInitialization() { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java

public void testMatchesStaticInitialization() {
		// staticinit
		PointcutExpression ex = p.parsePointcutExpression("staticinitialization(*..A+)");
		assertEquals("Matches A",FuzzyBoolean.YES,ex.matchesStaticInitialization(A.class));
		assertEquals("Matches B",FuzzyBoolean.YES,ex.matchesStaticInitialization(B.class));
		assertEquals("Doesn't match Client",FuzzyBoolean.NO,ex.matchesStaticInitialization(Client.class));
		// this
		ex = p.parsePointcutExpression("this(org.aspectj.weaver.tools.PointcutExpressionTest.A)");
		assertEquals("No this",FuzzyBoolean.NO,ex.matchesStaticInitialization(A.class));
		// target
		ex = p.parsePointcutExpression("target(org.aspectj.weaver.tools.PointcutExpressionTest.A)");
		assertEquals("No target",FuzzyBoolean.NO,ex.matchesStaticInitialization(A.class));		
		// args
		ex = p.parsePointcutExpression("args()");
		assertEquals("No args",FuzzyBoolean.NO,ex.matchesStaticInitialization(A.class));
		// within
		ex = p.parsePointcutExpression("within(*..A)");
		assertEquals("Matches in class A",FuzzyBoolean.YES,ex.matchesStaticInitialization(A.class));
		assertEquals("Does not match in class B",FuzzyBoolean.NO,ex.matchesStaticInitialization(B.class));		
		// withincode
		ex = p.parsePointcutExpression("withincode(* a*(..))");
		assertEquals("Does not match",FuzzyBoolean.NO,ex.matchesStaticInitialization(A.class));
	}
================= fetch public void testMayNeedDynamicTest() { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java

public void testMayNeedDynamicTest() {
		PointcutExpression ex = p.parsePointcutExpression("execution(* org.aspectj.weaver.tools.PointcutExpressionTest.B.*(..))");
		assertFalse("No dynamic test needed",ex.mayNeedDynamicTest());
		ex = p.parsePointcutExpression("execution(* org.aspectj.weaver.tools.PointcutExpressionTest.B.*(..)) && args(X)");
		assertTrue("Dynamic test needed",ex.mayNeedDynamicTest());
	}
================= fetch public void testParseExceptionErrorMessages() { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java

public void testParseExceptionErrorMessages() {
		PointcutParser p = new PointcutParser();
		try {
			PointcutExpression pEx = p.parsePointcutExpression("execution(int Foo.*(..) && args(Double)");
			fail("Expected IllegalArgumentException");
		} catch (IllegalArgumentException ex) {
			assertTrue("Pointcut is not well-formed message",ex.getMessage().startsWith("Pointcut is not well-formed: expecting ')' at character position 24"));
		}		
	}
================= fetch public void testParsePointcutExpression() { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java

public void testParsePointcutExpression() {
		PointcutParser p = new PointcutParser();
		PointcutExpression pEx = p.parsePointcutExpression(
				"(adviceexecution() || execution(* *.*(..)) || handler(Exception) || " +
				"call(Foo Bar+.*(Goo)) || get(* foo) || set(Foo+ (Goo||Moo).s*) || " +
				"initialization(Foo.new(..)) || preinitialization(*.new(Foo,..)) || " +
				"staticinitialization(org.xzy.abc..*)) && (this(Foo) || target(Boo) ||" +
				"args(A,B,C)) && !handler(X)");
		try {
			pEx = p.parsePointcutExpression("gobble-de-gook()");
			fail("Expected IllegalArgumentException");
		} catch (IllegalArgumentException ex) {}
	}
================= fetch public void testParseReferencePCDs() { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java

public void testParseReferencePCDs() {
		PointcutParser p = new PointcutParser();
		try {
			p.parsePointcutExpression("bananas(x)");
			fail("Expected UnsupportedPointcutPrimitiveException");
		} catch(UnsupportedPointcutPrimitiveException ex) {
			assertTrue(ex.getUnsupportedPrimitive() == PointcutPrimitive.REFERENCE);
		}	
	}
================= fetch public void testParseUnsupportedPCDs() { a39f595^:weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java

public void testParseUnsupportedPCDs() {
		Set s = new HashSet();
		PointcutParser p = new PointcutParser(s);
		try {
			p.parsePointcutExpression("args(x)");
			fail("Expected UnsupportedPointcutPrimitiveException");
		} catch(UnsupportedPointcutPrimitiveException ex) {
			assertEquals("Args",PointcutPrimitive.ARGS,ex.getUnsupportedPrimitive());
		}	
		try {
			p.parsePointcutExpression("within(x)");
			fail("Expected UnsupportedPointcutPrimitiveException");
		} catch(UnsupportedPointcutPrimitiveException ex) {
			assertEquals("Within",PointcutPrimitive.WITHIN,ex.getUnsupportedPrimitive());
		}	
		try {
			p.parsePointcutExpression("withincode(new(..))");
			fail("Expected UnsupportedPointcutPrimitiveException");
		} catch(UnsupportedPointcutPrimitiveException ex) {
			assertEquals("Withincode",PointcutPrimitive.WITHIN_CODE,ex.getUnsupportedPrimitive());
		}	
		try {
			p.parsePointcutExpression("handler(Exception)");
			fail("Expected UnsupportedPointcutPrimitiveException");
		} catch(UnsupportedPointcutPrimitiveException ex) {
			assertEquals("handler",PointcutPrimitive.HANDLER,ex.getUnsupportedPrimitive());
		}	
		try {
			p.parsePointcutExpression("this(X)");
			fail("Expected UnsupportedPointcutPrimitiveException");
		} catch(UnsupportedPointcutPrimitiveException ex) {
			assertEquals("this",PointcutPrimitive.THIS,ex.getUnsupportedPrimitive());
		}	
		try {
			p.parsePointcutExpression("target(X)");
			fail("Expected UnsupportedPointcutPrimitiveException");
		} catch(UnsupportedPointcutPrimitiveException ex) {
			assertEquals("target",PointcutPrimitive.TARGET,ex.getUnsupportedPrimitive());
		}	
		try {
			p.parsePointcutExpression("this(X) && target(Y)");
			fail("Expected UnsupportedPointcutPrimitiveException");
		} catch(UnsupportedPointcutPrimitiveException ex) {
			assertEquals("This",PointcutPrimitive.THIS,ex.getUnsupportedPrimitive());
		}	
		try {
			p.parsePointcutExpression("this(X) || target(Y)");
			fail("Expected UnsupportedPointcutPrimitiveException");
		} catch(UnsupportedPointcutPrimitiveException ex) {
			assertEquals("This",PointcutPrimitive.THIS,ex.getUnsupportedPrimitive());
		}	
		try {
			p.parsePointcutExpression("!this(X)");
			fail("Expected UnsupportedPointcutPrimitiveException");
		} catch(UnsupportedPointcutPrimitiveException ex) {
			assertEquals("This",PointcutPrimitive.THIS,ex.getUnsupportedPrimitive());
		}	
		try {
			p.parsePointcutExpression("call(* *.*(..))");
			fail("Expected UnsupportedPointcutPrimitiveException");
		} catch(UnsupportedPointcutPrimitiveException ex) {
			assertEquals("Call",PointcutPrimitive.CALL,ex.getUnsupportedPrimitive());
		}	
		try {
			p.parsePointcutExpression("execution(* *.*(..))");
			fail("Expected UnsupportedPointcutPrimitiveException");
		} catch(UnsupportedPointcutPrimitiveException ex) {
			assertEquals("Execution",PointcutPrimitive.EXECUTION,ex.getUnsupportedPrimitive());
		}	
		try {
			p.parsePointcutExpression("get(* *)");
			fail("Expected UnsupportedPointcutPrimitiveException");
		} catch(UnsupportedPointcutPrimitiveException ex) {
			assertEquals("Get",PointcutPrimitive.GET,ex.getUnsupportedPrimitive());
		}	
		try {
			p.parsePointcutExpression("set(* *)");
			fail("Expected UnsupportedPointcutPrimitiveException");
		} catch(UnsupportedPointcutPrimitiveException ex) {
			assertEquals("Set",PointcutPrimitive.SET,ex.getUnsupportedPrimitive());
		}	
		try {
			p.parsePointcutExpression("initialization(new(..))");
			fail("Expected UnsupportedPointcutPrimitiveException");
		} catch(UnsupportedPointcutPrimitiveException ex) {
			assertEquals("Initialization",PointcutPrimitive.INITIALIZATION,ex.getUnsupportedPrimitive());
		}	
		try {
			p.parsePointcutExpression("preinitialization(new(..))");
			fail("Expected UnsupportedPointcutPrimitiveException");
		} catch(UnsupportedPointcutPrimitiveException ex) {
			assertEquals("Prc-init",PointcutPrimitive.PRE_INITIALIZATION,ex.getUnsupportedPrimitive());
		}	
		try {
			p.parsePointcutExpression("staticinitialization(T)");
			fail("Expected UnsupportedPointcutPrimitiveException");
		} catch(UnsupportedPointcutPrimitiveException ex) {
			assertEquals("Staticinit",PointcutPrimitive.STATIC_INITIALIZATION,ex.getUnsupportedPrimitive());
		}	
	}
================= fetch public void testRawAndGenericTypeConversionITDCons() { a39f595^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testUnableToBuildShadows_pr109728() { runTest("Unable to build shadows");}
================= fetch private final void readClassInfo() throws IOException, ClassFormatException 87e5c2e^:bcel-builder/src/org/aspectj/apache/bcel/classfile/ClassParser.java
/**
   * Read information about the class and its super class.
   * @throws  IOException
   * @throws  ClassFormatException
   */
private final void readClassInfo() throws IOException, ClassFormatException
  {
    access_flags = file.readUnsignedShort();

    /* Interfaces are implicitely abstract, the flag should be set
     * according to the JVM specification.
     */
    if((access_flags & Constants.ACC_INTERFACE) != 0)
      access_flags |= Constants.ACC_ABSTRACT;

    if(((access_flags & Constants.ACC_ABSTRACT) != 0) && 
       ((access_flags & Constants.ACC_FINAL)    != 0 ))
      throw new ClassFormatException("Class can't be both final and abstract");

    class_name_index      = file.readUnsignedShort();
    superclass_name_index = file.readUnsignedShort();
  }
================= fetch public void testIfEvaluationExplosion_pr94086() { 87e5c2e^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testSyntaxErrorNPE_pr103266() {runTest("NPE on syntax error");}
================= fetch protected Test findResidueInternal(Shadow shadow, ExposedState state) { 2ae4f53^:weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.Pointcut#findResidue(org.aspectj.weaver.Shadow, org.aspectj.weaver.patterns.ExposedState)
	 */
protected Test findResidueInternal(Shadow shadow, ExposedState state) {



		
		if (annotationTypePattern instanceof BindingAnnotationTypePattern) {
			BindingAnnotationTypePattern btp = (BindingAnnotationTypePattern)annotationTypePattern;
			UnresolvedType annotationType = btp.getAnnotationType();
			Var var = shadow.getKindedAnnotationVar(annotationType);
			
			// This should not happen, we shouldn't have gotten this far 
			// if we weren't going to find the annotation
			if (var == null) throw new BCException("Impossible! annotation=["+annotationType+
					                               "]  shadow=["+shadow+" at "+shadow.getSourceLocation()+
												   "]    pointcut is at ["+getSourceLocation()+"]");//return Literal.FALSE;
			// Check if we have already bound something to this formal
			if ((state.get(btp.getFormalIndex())!=null) &&(lastMatchedShadowId == shadow.shadowId)) {
//				ISourceLocation pcdSloc = getSourceLocation(); 
//				ISourceLocation shadowSloc = shadow.getSourceLocation();
//				Message errorMessage = new Message(
//					"Cannot use @pointcut to match at this location and bind a formal to type '"+var.getType()+
//					"' - the formal is already bound to type '"+state.get(btp.getFormalIndex()).getType()+"'"+
//					".  The secondary source location points to the problematic binding.",
//					shadowSloc,true,new ISourceLocation[]{pcdSloc}); 
//				shadow.getIWorld().getMessageHandler().handleMessage(errorMessage);
				state.setErroneousVar(btp.getFormalIndex());
			}
			state.set(btp.getFormalIndex(),var);
		} 
		return Literal.TRUE;
	}
================= fetch public void testSuperCallInITD() { 2ae4f53^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testSuperCallInITD() {
	  runTest("super call in ITD");
  }
================= fetch public void testSuperCallInITDPart2() { 2ae4f53^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testSuperCallInITDPart2() {
	  runTest("super call in ITD - part 2");
  }
================= fetch public UnresolvedType fromBinding(TypeBinding binding) { 2942ca0^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java
//??? going back and forth between strings and bindings is a waste of cycles
public UnresolvedType fromBinding(TypeBinding binding) {
		if (binding instanceof HelperInterfaceBinding) {
			return ((HelperInterfaceBinding) binding).getTypeX();
		}
		if (binding == null || binding.qualifiedSourceName() == null) {
			return ResolvedType.MISSING;
		}
		// first piece of generics support!
		if (binding instanceof TypeVariableBinding) {
			return fromTypeVariableBinding((TypeVariableBinding)binding);
		}
		
		
		if (binding instanceof WildcardBinding) {
			WildcardBinding eWB = (WildcardBinding) binding;
			UnresolvedType ut =  TypeFactory.createTypeFromSignature(CharOperation.charToString(eWB.genericTypeSignature()));
			// If the bound for the wildcard is a typevariable, e.g. '? extends E' then
			// the type variable in the unresolvedtype will be correct only in name.  In that
			// case let's set it correctly based on the one in the eclipse WildcardBinding
			if (eWB.bound instanceof TypeVariableBinding) {
				UnresolvedType tVar = fromTypeVariableBinding((TypeVariableBinding)eWB.bound);
				if (ut.isGenericWildcard() && ut.isSuper()) ut.setLowerBound(tVar);
				if (ut.isGenericWildcard() && ut.isExtends()) ut.setUpperBound(tVar);
			}
			return ut;
		}
		
		if (binding instanceof ParameterizedTypeBinding) {
			if (binding instanceof RawTypeBinding) {
				// special case where no parameters are specified!
				return UnresolvedType.forRawTypeName(getName(binding));
			}
			ParameterizedTypeBinding ptb = (ParameterizedTypeBinding) binding;
			
			UnresolvedType[] arguments = null;
			
			if (ptb.arguments!=null) { // null can mean this is an inner type of a Parameterized Type with no bounds of its own (pr100227)
				arguments = new UnresolvedType[ptb.arguments.length];
				for (int i = 0; i < arguments.length; i++) {
					arguments[i] = fromBinding(ptb.arguments[i]);
				}
			}
			
			String baseTypeSignature = null;
			
			ResolvedType baseType = getWorld().resolve(UnresolvedType.forName(getName(binding)),true);
			if (baseType != ResolvedType.MISSING) {
				// can legitimately be missing if a bound refers to a type we haven't added to the world yet...
				if (!baseType.isGenericType() && arguments!=null) baseType = baseType.getGenericType();
				baseTypeSignature = baseType.getErasureSignature();
			} else {
				baseTypeSignature = UnresolvedType.forName(getName(binding)).getSignature();
			}
			
			// Create an unresolved parameterized type.  We can't create a resolved one as the 
			// act of resolution here may cause recursion problems since the parameters may
			// be type variables that we haven't fixed up yet.
			if (arguments==null) arguments=new UnresolvedType[0];
			String parameterizedSig = ResolvedType.PARAMETERIZED_TYPE_IDENTIFIER+CharOperation.charToString(binding.genericTypeSignature()).substring(1);
			return TypeFactory.createUnresolvedParameterizedType(parameterizedSig,baseTypeSignature,arguments);
		}
		
		// Convert the source type binding for a generic type into a generic UnresolvedType
		// notice we can easily determine the type variables from the eclipse object
		// and we can recover the generic signature from it too - so we pass those
		// to the forGenericType() method.
		if (binding.isGenericType() && 
		    !binding.isParameterizedType() && 
		    !binding.isRawType()) {
			TypeVariableBinding[] tvbs = binding.typeVariables();
			TypeVariable[] tVars = new TypeVariable[tvbs.length];
			for (int i = 0; i < tvbs.length; i++) {
				TypeVariableBinding eclipseV = tvbs[i];
				String name = CharOperation.charToString(eclipseV.sourceName); 
				tVars[i] = new TypeVariable(name,fromBinding(eclipseV.superclass()),fromBindings(eclipseV.superInterfaces()));
			}
			//TODO asc generics - temporary guard....
			if (!(binding instanceof SourceTypeBinding))
				throw new RuntimeException("Cant get the generic sig for "+binding.debugName());
			return UnresolvedType.forGenericType(getName(binding),tVars,
					CharOperation.charToString(((SourceTypeBinding)binding).genericSignature()));
		} 
		
		// LocalTypeBinding have a name $Local$, we can get the real name by using the signature.... 
		if (binding instanceof LocalTypeBinding) {
			LocalTypeBinding ltb = (LocalTypeBinding) binding;
			if (ltb.constantPoolName() != null && ltb.constantPoolName().length > 0) {
				return UnresolvedType.forSignature(new String(binding.signature()));
			} else {			
				// we're reporting a problem and don't have a resolved name for an 
				// anonymous local type yet, report the issue on the enclosing type
				return UnresolvedType.forSignature(new String(ltb.enclosingType.signature()));
			}
		}
		
		return UnresolvedType.forName(getName(binding));
	}
================= fetch public void testNoVerifyErrorWithSetOnInnerType() { 2942ca0^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testNoVerifyErrorWithSetOnInnerType() {
	  runTest("no verify error with set on inner type");
  }
================= fetch private void unpackAttributes(World world) { a9ca915^:weaver/src/org/aspectj/weaver/bcel/BcelField.java

private void unpackAttributes(World world) {
		Attribute[] attrs = field.getAttributes();
        List as = BcelAttributes.readAjAttributes(getDeclaringType().getClassName(),attrs, getSourceContext(world),world.getMessageHandler(),bcelObjectType.getWeaverVersionAttribute());
        as.addAll(AtAjAttributes.readAj5FieldAttributes(field, world.resolve(getDeclaringType()), getSourceContext(world), world.getMessageHandler()));

		for (Iterator iter = as.iterator(); iter.hasNext();) {
			AjAttribute a = (AjAttribute) iter.next();
			if (a instanceof AjAttribute.AjSynthetic) {
				isAjSynthetic = true;
			} else {
				throw new BCException("weird field attribute " + a);
			}
		}
		isAjSynthetic = false;
		
		
		for (int i = attrs.length - 1; i >= 0; i--) {
			if (attrs[i] instanceof Synthetic) isSynthetic = true;
		}
	}
================= fetch public void testNoUnusedParameterWarningsForSyntheticAdviceArgs() { a9ca915^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testNoUnusedParameterWarningsForSyntheticAdviceArgs() {
	  runTest("no unused parameter warnings for synthetic advice args");
  }
Progress : [############################------------] 70%================= fetch private static boolean configureBuildOptions( AjBuildConfig config, BuildOptions 5187437^:ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java
/**
	 * Populate options in a build configuration, using the Ajde BuildOptionsAdapter.
	 * Added by AMC 01.20.2003, bugzilla #29769
	 */
private static boolean configureBuildOptions( AjBuildConfig config, BuildOptionsAdapter options, IMessageHandler handler) {
        LangUtil.throwIaxIfNull(options, "options");
        LangUtil.throwIaxIfNull(config, "config");
		Map optionsToSet = new HashMap();
        LangUtil.throwIaxIfNull(optionsToSet, "javaOptions");

        if (options.getSourceCompatibilityLevel() != null && options.getSourceCompatibilityLevel().equals(CompilerOptions.VERSION_1_5)) {
		    optionsToSet.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_5);
		    optionsToSet.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_5); 
		} else if (options.getSourceOnePointFourMode() 
		        || options.getSourceCompatibilityLevel() != null && options.getSourceCompatibilityLevel().equals(CompilerOptions.VERSION_1_4)) {
		    optionsToSet.put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_4);	 
			optionsToSet.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_4);
		} 
		
		String enc = options.getCharacterEncoding();
		if (!LangUtil.isEmpty(enc)) {
			optionsToSet.put(CompilerOptions.OPTION_Encoding, enc );
		}

		String compliance = options.getComplianceLevel();
		if (!LangUtil.isEmpty(compliance)) {
			String version = CompilerOptions.VERSION_1_4;
			if ( compliance.equals( BuildOptionsAdapter.VERSION_13 ) ) {
				version = CompilerOptions.VERSION_1_3;
			}
			optionsToSet.put(CompilerOptions.OPTION_Compliance, version );	
			optionsToSet.put(CompilerOptions.OPTION_Source, version );
		}
				
		String sourceLevel = options.getSourceCompatibilityLevel();
		if (!LangUtil.isEmpty(sourceLevel)) {
			String slVersion = CompilerOptions.VERSION_1_4;
			if ( sourceLevel.equals( BuildOptionsAdapter.VERSION_13 ) ) {
				slVersion = CompilerOptions.VERSION_1_3;
			}
			// never set a lower source level than compliance level
			// Mik: prepended with 1.5 check
			if (sourceLevel.equals(CompilerOptions.VERSION_1_5)) {
			    optionsToSet.put(CompilerOptions.OPTION_Source, CompilerOptions.VERSION_1_5);	
			} else {
				String setCompliance = (String) optionsToSet.get( CompilerOptions.OPTION_Compliance);
				if ( ! (setCompliance.equals(CompilerOptions.VERSION_1_4 )
			         && slVersion.equals(CompilerOptions.VERSION_1_3)) ) {
				    optionsToSet.put(CompilerOptions.OPTION_Source, slVersion);		
				} 
			}
		}
	
		Set warnings = options.getWarnings();
		if (!LangUtil.isEmpty(warnings)) {
			// turn off all warnings	
			disableWarnings( optionsToSet );
			// then selectively enable those in the set
			enableWarnings( optionsToSet, warnings );
		} else if (warnings == null) {
			// set default warnings on...
			enableWarnings( optionsToSet, DEFAULT__AJDE_WARNINGS);
		}

		Set debugOptions = options.getDebugLevel();
		if (!LangUtil.isEmpty(debugOptions)) {
			// default is all options on, so just need to selectively
			// disable
			boolean sourceLine = false;
			boolean varAttr = false;
			boolean lineNo = false;
			Iterator it = debugOptions.iterator();
			while (it.hasNext()){
				String debug = (String) it.next();
				if ( debug.equals( BuildOptionsAdapter.DEBUG_ALL )) {
					sourceLine = true;
					varAttr = true;
					lineNo = true;
				} else if ( debug.equals( BuildOptionsAdapter.DEBUG_LINES )) {
					lineNo = true;
				}  else if ( debug.equals( BuildOptionsAdapter.DEBUG_SOURCE )) {
					sourceLine = true;
				}  else if ( debug.equals( BuildOptionsAdapter.DEBUG_VARS)) {
					varAttr = true;
				}
			}
			if (sourceLine) optionsToSet.put(CompilerOptions.OPTION_SourceFileAttribute,
											CompilerOptions.GENERATE);
			if (varAttr) optionsToSet.put(CompilerOptions.OPTION_LocalVariableAttribute,
											CompilerOptions.GENERATE);		
			if (lineNo)  optionsToSet.put(CompilerOptions.OPTION_LineNumberAttribute,
											CompilerOptions.GENERATE);
		}
		//XXX we can't turn off import errors in 3.0 stream
//		if ( options.getNoImportError() ) {
//			javaOptions.put( CompilerOptions.OPTION_ReportInvalidImport,
//				CompilerOptions.WARNING);	
//		}
				
		if ( options.getPreserveAllLocals() ) {
			optionsToSet.put( CompilerOptions.OPTION_PreserveUnusedLocal,
				CompilerOptions.PRESERVE);		
		}
        if ( !config.isIncrementalMode()
            && options.getIncrementalMode() ) {
                config.setIncrementalMode(true);
        }
        				
		Map jom = options.getJavaOptionsMap();
		if (jom!=null) {
			String version = (String)jom.get(CompilerOptions.OPTION_Compliance);
			if (version!=null && version.equals(CompilerOptions.VERSION_1_5)) {
				config.setBehaveInJava5Way(true);
			}
		}
		
		config.getOptions().set(optionsToSet);
		String toAdd = options.getNonStandardOptions();
        return LangUtil.isEmpty(toAdd) 
            ? true
            : configureNonStandardOptions( config, toAdd, handler );
        // ignored: lenient, porting, preprocess, strict, usejavac, workingdir
	}
================= fetch protected void fillDeclaredMembers() { 2d21db0^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java

protected void fillDeclaredMembers() {
		List declaredPointcuts = new ArrayList();
		List declaredMethods = new ArrayList();
		List declaredFields = new ArrayList();
		
		binding.methods();  // the important side-effect of this call is to make sure bindings are completed
		AbstractMethodDeclaration[] methods = declaration.methods;
		if (methods != null) {
			for (int i=0, len=methods.length; i < len; i++) {
				AbstractMethodDeclaration amd = methods[i];
				if (amd == null || amd.ignoreFurtherInvestigation) continue;
				if (amd instanceof PointcutDeclaration) {
					PointcutDeclaration d = (PointcutDeclaration)amd;
					ResolvedPointcutDefinition df = d.makeResolvedPointcutDefinition(factory);
					declaredPointcuts.add(df);
				} else if (amd instanceof InterTypeDeclaration) {				
					// these are handled in a separate pass
					continue;
				} else if (amd instanceof DeclareDeclaration && 
				           !(amd instanceof DeclareAnnotationDeclaration)) { // surfaces the annotated ajc$ method
					// these are handled in a separate pass
					continue;
				} else if (amd instanceof AdviceDeclaration) {
					// these are ignored during compilation and only used during weaving
					continue;
				}  else if ((amd.annotations != null) && isAnnotationStylePointcut(amd.annotations)) {
					// consider pointcuts defined via annotations
					ResolvedPointcutDefinition df = makeResolvedPointcutDefinition(amd);
					declaredPointcuts.add(df);
				} else {
					if (amd.binding == null || !amd.binding.isValidBinding()) continue;
					declaredMethods.add(factory.makeResolvedMember(amd.binding));
				}
			}
		}

		FieldBinding[] fields = binding.fields();
		for (int i=0, len=fields.length; i < len; i++) {
			FieldBinding f = fields[i];
			declaredFields.add(factory.makeResolvedMember(f));
		}
			
		this.declaredPointcuts = (ResolvedPointcutDefinition[])
			declaredPointcuts.toArray(new ResolvedPointcutDefinition[declaredPointcuts.size()]);
		this.declaredMethods = (ResolvedMember[])
			declaredMethods.toArray(new ResolvedMember[declaredMethods.size()]);
		this.declaredFields = (ResolvedMember[])
			declaredFields.toArray(new ResolvedMember[declaredFields.size()]);
	}
================= fetch public EclipseSourceType(ReferenceType resolvedTypeX, EclipseFactory factory, 2d21db0^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java

protected EclipseFactory eclipseWorld() {
		return factory;
	}
================= fetch public ResolvedMemberImpl parameterizedWith(UnresolvedType[] typeParameters,Reso 2d21db0^:weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java
// but if !isParameterized List<T> will turn into List.
public ResolvedMemberImpl parameterizedWith(UnresolvedType[] typeParameters,ResolvedType newDeclaringType, boolean isParameterized) {
		if (!this.getDeclaringType().isGenericType()) {
			throw new IllegalStateException("Can't ask to parameterize a member of a non-generic type");
		}
		TypeVariable[] typeVariables = getDeclaringType().getTypeVariables();
		if (typeVariables.length != typeParameters.length) {
			throw new IllegalStateException("Wrong number of type parameters supplied");
		}
		Map typeMap = new HashMap();
		for (int i = 0; i < typeVariables.length; i++) {
			typeMap.put(typeVariables[i].getName(), typeParameters[i]);
		}
		UnresolvedType parameterizedReturnType = parameterize(getGenericReturnType(),typeMap,isParameterized);
		UnresolvedType[] parameterizedParameterTypes = new UnresolvedType[getGenericParameterTypes().length];
		for (int i = 0; i < parameterizedParameterTypes.length; i++) {
			parameterizedParameterTypes[i] = 
				parameterize(getGenericParameterTypes()[i], typeMap,isParameterized);
		}
		return new ResolvedMemberImpl(
					getKind(),
					newDeclaringType,
					getModifiers(),
					parameterizedReturnType,
					getName(),
					parameterizedParameterTypes,
					getExceptions(),
					this
				);
	}
================= fetch public Shadow makeShadow(ReferenceContext context) { 2d21db0^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

public Shadow makeShadow(ReferenceContext context) {
		return EclipseShadow.makeShadow(this, (ASTNode) context, context);
	}
================= fetch public boolean checkLegalOverride(ResolvedMember parent, ResolvedMember child) { 2d21db0^:weaver/src/org/aspectj/weaver/ResolvedType.java
/**
	 * @return true if the override is legal
	 * note: calling showMessage with two locations issues TWO messages, not ONE message
	 * with an additional source location.
	 */
public boolean checkLegalOverride(ResolvedMember parent, ResolvedMember child) {
		//System.err.println("check: " + child.getDeclaringType() + " overrides " + parent.getDeclaringType());
		if (Modifier.isFinal(parent.getModifiers())) {
			// XXX horrible test, if we're in eclipes, child.getSourceLocation will be
			// null, and this message will have already been issued.
			if (child.getSourceLocation() == null) return false;
			world.showMessage(Message.ERROR,
					WeaverMessages.format(WeaverMessages.CANT_OVERRIDE_FINAL_MEMBER,parent),
					child.getSourceLocation(),null);
			return false;
		}
		
		boolean incompatibleReturnTypes = false;
		
		// In 1.5 mode, allow for covariance on return type
		if (world.isInJava5Mode() && parent.getKind()==Member.METHOD) {
	      ResolvedType rtParentReturnType = parent.getReturnType().resolve(world);
		  ResolvedType rtChildReturnType  = child.getReturnType().resolve(world);
		  incompatibleReturnTypes = !rtParentReturnType.isAssignableFrom(rtChildReturnType);
		} else {
		  incompatibleReturnTypes =!parent.getReturnType().equals(child.getReturnType());
		}
		
		if (incompatibleReturnTypes) {
			world.showMessage(IMessage.ERROR,
					WeaverMessages.format(WeaverMessages.ITD_RETURN_TYPE_MISMATCH,parent,child),
					child.getSourceLocation(), parent.getSourceLocation());
			return false;
		}		
		if (parent.getKind() == Member.POINTCUT) {
			UnresolvedType[] pTypes = parent.getParameterTypes();
			UnresolvedType[] cTypes = child.getParameterTypes();
			if (!Arrays.equals(pTypes, cTypes)) {
				world.showMessage(IMessage.ERROR,
						WeaverMessages.format(WeaverMessages.ITD_PARAM_TYPE_MISMATCH,parent,child),
						child.getSourceLocation(), parent.getSourceLocation());
				return false;
			}
		}		
		//System.err.println("check: " + child.getModifiers() + " more visible " + parent.getModifiers());
		if (isMoreVisible(parent.getModifiers(), child.getModifiers())) {
			world.showMessage(IMessage.ERROR,
					WeaverMessages.format(WeaverMessages.ITD_VISIBILITY_REDUCTION,parent,child),
					child.getSourceLocation(), parent.getSourceLocation());
			return false;
		}
		
		// check declared exceptions
		ResolvedType[] childExceptions = world.resolve(child.getExceptions());
		ResolvedType[] parentExceptions = world.resolve(parent.getExceptions());
		ResolvedType runtimeException = world.resolve("java.lang.RuntimeException");
		ResolvedType error = world.resolve("java.lang.Error");
		
		outer: for (int i=0, leni = childExceptions.length; i < leni; i++) {
			//System.err.println("checking: " + childExceptions[i]);
			if (runtimeException.isAssignableFrom(childExceptions[i])) continue;
			if (error.isAssignableFrom(childExceptions[i])) continue;
			
			for (int j = 0, lenj = parentExceptions.length; j < lenj; j++) {
				if (parentExceptions[j].isAssignableFrom(childExceptions[i])) continue outer;
			}
			
			// this message is now better handled my MethodVerifier in JDT core.
//			world.showMessage(IMessage.ERROR,
//					WeaverMessages.format(WeaverMessages.ITD_DOESNT_THROW,childExceptions[i].getName()),
//					child.getSourceLocation(), null);
						
			return false;
		}
		if (parent.isStatic() && !child.isStatic()) {
			world.showMessage(IMessage.ERROR,
					WeaverMessages.format(WeaverMessages.ITD_OVERRIDDEN_STATIC,child,parent),
					child.getSourceLocation(),null);
			return false;
		} else if (child.isStatic() && !parent.isStatic()) {
			world.showMessage(IMessage.ERROR,
					WeaverMessages.format(WeaverMessages.ITD_OVERIDDING_STATIC,child,parent),
					child.getSourceLocation(),null);
			return false;
		}
		return true;
		
	}
================= fetch public void addSourceTypeBinding(SourceTypeBinding binding) { 2d21db0^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

public void addSourceTypeBinding(SourceTypeBinding binding) {
		TypeDeclaration decl = binding.scope.referenceContext;
		
		// Deal with the raw/basic type to give us an entry in the world type map
		UnresolvedType simpleTx = null;
		if (binding.isGenericType()) {
		    simpleTx  = UnresolvedType.forRawTypeName(getName(binding)); 
		} else if (binding.isLocalType()) { 
			LocalTypeBinding ltb = (LocalTypeBinding) binding;
			if (ltb.constantPoolName() != null && ltb.constantPoolName().length > 0) {
				simpleTx = UnresolvedType.forSignature(new String(binding.signature()));
			} else {
				simpleTx = UnresolvedType.forName(getName(binding));
			}
		}else {
			simpleTx  = UnresolvedType.forName(getName(binding)); 
		}
		ReferenceType name  = getWorld().lookupOrCreateName(simpleTx);
		EclipseSourceType t = new EclipseSourceType(name, this, binding, decl);
		
		// For generics, go a bit further - build a typex for the generic type
		// give it the same delegate and link it to the raw type
		if (binding.isGenericType()) {
			UnresolvedType complexTx = fromBinding(binding); // fully aware of any generics info
			ReferenceType complexName = new ReferenceType(complexTx,world);//getWorld().lookupOrCreateName(complexTx);
			name.setGenericType(complexName);
			complexName.setDelegate(t);
			complexName.setSourceContext(t.getResolvedTypeX().getSourceContext());
		}
				
		name.setDelegate(t);
		if (decl instanceof AspectDeclaration) {
			((AspectDeclaration)decl).typeX = name;
			((AspectDeclaration)decl).concreteName = t;
		}
		
		ReferenceBinding[] memberTypes = binding.memberTypes;
		for (int i = 0, length = memberTypes.length; i < length; i++) {
			addSourceTypeBinding((SourceTypeBinding) memberTypes[i]);
		}
	}
================= fetch public void anonymousTypeBindingCreated(LocalTypeBinding aBinding) { 2d21db0^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java
/**
	 * Callback driven when the compiler detects an anonymous type during block resolution.
	 * We need to add it to the weaver so that we don't trip up later.
	 * @param aBinding
	 */
public void anonymousTypeBindingCreated(LocalTypeBinding aBinding) {
		factory.addSourceTypeBinding(aBinding);
	}
================= fetch public void completeTypeBindings() { 2d21db0^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java
//??? duplicates some of super's code
public void completeTypeBindings() {
//		builtInterTypesAndPerClauses = false;
		//pendingTypesToWeave = new ArrayList();
		stepCompleted = BUILD_TYPE_HIERARCHY;
		
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			units[i].scope.checkAndSetImports();
		}
		stepCompleted = CHECK_AND_SET_IMPORTS;
	
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			units[i].scope.connectTypeHierarchy();
		}
		stepCompleted = CONNECT_TYPE_HIERARCHY;
	
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			units[i].scope.buildFieldsAndMethods();
		}
		
		// would like to gather up all TypeDeclarations at this point and put them in the factory
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			SourceTypeBinding[] b = units[i].scope.topLevelTypes;
			for (int j = 0; j < b.length; j++) {
				factory.addSourceTypeBinding(b[j]);
			}
		}
		
		// We won't find out about anonymous types until later though, so register to be
		// told about them when they turn up.
		AnonymousClassPublisher.aspectOf().setAnonymousClassCreationListener(this);
		
		// need to build inter-type declarations for all AspectDeclarations at this point
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
                buildInterTypeAndPerClause(b[j].scope);
                addCrosscuttingStructures(b[j].scope);
            }
        }        

		factory.finishTypeMungers();
	
		// now do weaving
		Collection typeMungers = factory.getTypeMungers();
		
		Collection declareParents = factory.getDeclareParents();
		Collection declareAnnotationOnTypes = factory.getDeclareAnnotationOnTypes();

		doPendingWeaves();
		
		// We now have some list of types to process, and we are about to apply the type mungers.
		// There can be situations where the order of types passed to the compiler causes the
		// output from the compiler to vary - THIS IS BAD.  For example, if we have class A
		// and class B extends A.  Also, an aspect that 'declare parents: A+ implements Serializable'
		// then depending on whether we see A first, we may or may not make B serializable.
		
		// The fix is to process them in the right order, ensuring that for a type we process its 
		// supertypes and superinterfaces first.  This algorithm may have problems with:
		// - partial hierarchies (e.g. suppose types A,B,C are in a hierarchy and A and C are to be woven but not B)
		// - weaving that brings new types in for processing (see pendingTypesToWeave.add() calls) after we thought
		//   we had the full list.
		// 
		// but these aren't common cases (he bravely said...)
		boolean typeProcessingOrderIsImportant = declareParents.size()>0 || declareAnnotationOnTypes.size()>0; //DECAT
		
		if (typeProcessingOrderIsImportant) {
			List typesToProcess = new ArrayList();
			for (int i=lastCompletedUnitIndex+1; i<=lastUnitIndex; i++) {
				CompilationUnitScope cus = units[i].scope;
				SourceTypeBinding[] stbs = cus.topLevelTypes;
				for (int j=0; j<stbs.length; j++) {
					SourceTypeBinding stb = stbs[j];
					typesToProcess.add(stb);
				}
			}

			while (typesToProcess.size()>0) {
				// A side effect of weaveIntertypes() is that the processed type is removed from the collection
				weaveIntertypes(typesToProcess,(SourceTypeBinding)typesToProcess.get(0),typeMungers,declareParents,declareAnnotationOnTypes);
			}
		
		} else {
			// Order isn't important
			for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
				//System.err.println("Working on "+new String(units[i].getFileName()));
				weaveInterTypeDeclarations(units[i].scope, typeMungers, declareParents,declareAnnotationOnTypes);
			}
		}
		
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
                resolvePointcutDeclarations(b[j].scope);
            }
        }
        
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
            	addAdviceLikeDeclares(b[j].scope);
            }
        }
        
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            units[i] = null; // release unnecessary reference to the parsed unit
        }
                
		stepCompleted = BUILD_FIELDS_AND_METHODS;
		lastCompletedUnitIndex = lastUnitIndex;
	}
================= fetch public void testSuperCallInITD() { 08d6a5d^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testSuperCallInITD() {
	  runTest("super call in ITD");
  }
================= fetch public void unusedPrivateMethod(AbstractMethodDeclaration methodDecl) { 08d6a5d^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java

public void unusedPrivateMethod(AbstractMethodDeclaration methodDecl) {
    	// don't output unused warnings for pointcuts...
    	if (!(methodDecl instanceof PointcutDeclaration))
    			super.unusedPrivateMethod(methodDecl);
    }
================= fetch public void resolveStatements() { 2505485^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java

public void resolveStatements() {
		checkAndSetModifiersForMethod();
        if ((modifiers & AccSemicolonBody) != 0) {
            if ((declaredModifiers & AccAbstract) == 0)
                scope.problemReporter().methodNeedBody(this);
        } else {
            // the method HAS a body --> abstract native modifiers are forbiden
            if (((declaredModifiers & AccAbstract) != 0))
                scope.problemReporter().methodNeedingNoBody(this);
        }        
        
        // check @Override annotation - based on MethodDeclaration.resolveStatements() @Override processing
		checkOverride: {
			if (this.binding == null) break checkOverride;
			if (this.scope.compilerOptions().sourceLevel < JDK1_5) break checkOverride;
			int bindingModifiers = this.binding.modifiers;
			boolean hasOverrideAnnotation = (this.binding.tagBits & TagBits.AnnotationOverride) != 0;
			
			// Need to verify
			if (hasOverrideAnnotation) {
				
				// Work out the real method binding that we can use for comparison
				EclipseFactory world = EclipseFactory.fromScopeLookupEnvironment(scope);
				MethodBinding realthing = world.makeMethodBinding(munger.getSignature());
				
				boolean reportError = true;				
				// Go up the hierarchy, looking for something we override
				ReferenceBinding supertype = onTypeBinding.superclass();
				while (supertype!=null && reportError) {
					MethodBinding[] possibles = supertype.getMethods(declaredSelector);
					for (int i = 0; i < possibles.length; i++) {
						MethodBinding mb = possibles[i];

						boolean couldBeMatch = true;
						if (mb.parameters.length!=realthing.parameters.length) couldBeMatch=false;
						else {
							for (int j = 0; j < mb.parameters.length && couldBeMatch; j++) {
								if (!mb.parameters[j].equals(realthing.parameters[j])) couldBeMatch=false;
							}
						}
						// return types compatible? (allow for covariance)
						if (couldBeMatch && !returnType.resolvedType.isCompatibleWith(mb.returnType)) couldBeMatch=false;
						if (couldBeMatch) reportError = false;
					}
					supertype = supertype.superclass(); // superclass of object is null
				}
				// If we couldn't find something we override, report the error
				if (reportError) ((AjProblemReporter)this.scope.problemReporter()).itdMethodMustOverride(this,realthing);			
			}
		}
        
		if (!Modifier.isAbstract(declaredModifiers)) super.resolveStatements();
		if (Modifier.isStatic(declaredModifiers)) {
			// Check the target for ITD is not an interface
			if (onTypeBinding.isInterface()) {
				scope.problemReporter().signalError(sourceStart, sourceEnd,
					"methods in interfaces cannot be declared static");
			}
		}
	}
================= fetch public void testAdviceOnCflow() { 2505485^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testAdviceOnCflow() {
	  runTest("advising cflow advice execution");
  }
================= fetch protected Test findResidueInternal(Shadow shadow, ExposedState state) { 71771ab^:weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java

protected Test findResidueInternal(Shadow shadow, ExposedState state) {
		if (arguments.matches(getArgumentsToMatchAgainst(shadow), TypePattern.DYNAMIC).alwaysFalse()) {
			return Literal.FALSE;
		}
		int ellipsisCount = arguments.ellipsisCount;
		if (ellipsisCount == 0) {
			return findResidueNoEllipsis(shadow, state, arguments.getTypePatterns());		
		} else if (ellipsisCount == 1) {
			TypePattern[] patternsWithEllipsis = arguments.getTypePatterns();
			TypePattern[] patternsWithoutEllipsis = new TypePattern[shadow.getArgCount()];
			int lenWithEllipsis = patternsWithEllipsis.length;
			int lenWithoutEllipsis = patternsWithoutEllipsis.length;
			// l1+1 >= l0
			int indexWithEllipsis = 0;
			int indexWithoutEllipsis = 0;
			while (indexWithoutEllipsis < lenWithoutEllipsis) {
				TypePattern p = patternsWithEllipsis[indexWithEllipsis++];
				if (p == TypePattern.ELLIPSIS) {
					int newLenWithoutEllipsis =
						lenWithoutEllipsis - (lenWithEllipsis-indexWithEllipsis);
					while (indexWithoutEllipsis < newLenWithoutEllipsis) {
						patternsWithoutEllipsis[indexWithoutEllipsis++] = TypePattern.ANY;
					}
				} else {
					patternsWithoutEllipsis[indexWithoutEllipsis++] = p;
				}
			}
			return findResidueNoEllipsis(shadow, state, patternsWithoutEllipsis);
		} else {
			throw new BetaException("unimplemented");
		}
	}
================= fetch public void testPrivatePointcutOverriding() { 71771ab^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testPrivatePointcutOverriding() {
	  runTest("can't override private pointcut in abstract aspect");
  }
================= fetch private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge df46c6f^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java

private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munger) {
		ResolvedMember unMangledInterMethod = munger.getSignature();
		// do matching on the unMangled one, but actually add them to the mangled method
		ResolvedMember interMethodBody = munger.getInterMethodBody(aspectType);
		ResolvedMember interMethodDispatcher = munger.getInterMethodDispatcher(aspectType);
		
		LazyClassGen gen = weaver.getLazyClassGen();
		boolean mungingInterface = gen.isInterface();
		
		ResolvedType onType = weaver.getWorld().resolve(unMangledInterMethod.getDeclaringType(),munger.getSourceLocation());
		if (onType.isRawType()) onType = onType.getGenericType();

		boolean onInterface = onType.isInterface();
		
		if (onType.isAnnotation()) {
			signalError(WeaverMessages.ITDM_ON_ANNOTATION_NOT_ALLOWED,weaver,onType);
			return false;		
		}
		
		if (onType.isEnum()) {
			signalError(WeaverMessages.ITDM_ON_ENUM_NOT_ALLOWED,weaver,onType);
			return false;
		}
		
		if (onType.equals(gen.getType())) {
			ResolvedMember mangledInterMethod =
					AjcMemberMaker.interMethod(unMangledInterMethod, aspectType, onInterface);
            
			
			LazyMethodGen mg = makeMethodGen(gen, mangledInterMethod);
			if (mungingInterface) {
				// we want the modifiers of the ITD to be used for all *implementors* of the
				// interface, but the method itself we add to the interface must be public abstract
				mg.setAccessFlags(Modifier.PUBLIC | Modifier.ABSTRACT);
			}
			
			// pr98901
		    // For copying the annotations across, we have to discover the real member in the aspect
		    // which is holding them.
			if (weaver.getWorld().isInJava5Mode()){
				AnnotationX annotationsOnRealMember[] = null;
				ResolvedType toLookOn = aspectType;
				if (aspectType.isRawType()) toLookOn = aspectType.getGenericType();
				ResolvedMember realMember = getRealMemberForITDFromAspect(toLookOn,interMethodDispatcher);
				if (realMember==null) throw new BCException("Couldn't find ITD holder member '"+
						interMethodDispatcher+"' on aspect "+aspectType);
				annotationsOnRealMember = realMember.getAnnotations();
				
				if (annotationsOnRealMember!=null) {
					for (int i = 0; i < annotationsOnRealMember.length; i++) {
						AnnotationX annotationX = annotationsOnRealMember[i];
						Annotation a = annotationX.getBcelAnnotation();
						AnnotationGen ag = new AnnotationGen(a,weaver.getLazyClassGen().getConstantPoolGen(),true);
						mg.addAnnotation(new AnnotationX(ag.getAnnotation(),weaver.getWorld()));
					}
				}
				// the below loop fixes the very special (and very stupid)
				// case where an aspect declares an annotation
				// on an ITD it declared on itself.
				List allDecams = weaver.getWorld().getDeclareAnnotationOnMethods();
				for (Iterator i = allDecams.iterator(); i.hasNext();){
					DeclareAnnotation decaMC = (DeclareAnnotation) i.next();	
					if (decaMC.matches(unMangledInterMethod,weaver.getWorld())
							&& mg.getEnclosingClass().getType() == aspectType) {
						mg.addAnnotation(decaMC.getAnnotationX());
					}
				}
			}

			if (!onInterface && !Modifier.isAbstract(mangledInterMethod.getModifiers())) {
				InstructionList body = mg.getBody();
				InstructionFactory fact = gen.getFactory();
				int pos = 0;
	
				if (!unMangledInterMethod.isStatic()) {
					body.append(InstructionFactory.createThis());
					pos++;
				}
				Type[] paramTypes = BcelWorld.makeBcelTypes(mangledInterMethod.getParameterTypes());
				for (int i = 0, len = paramTypes.length; i < len; i++) {
					Type paramType = paramTypes[i];
					body.append(InstructionFactory.createLoad(paramType, pos));
					pos+=paramType.getSize();
				}
				body.append(Utility.createInvoke(fact, weaver.getWorld(), interMethodBody));
				body.append(
					InstructionFactory.createReturn(
						BcelWorld.makeBcelType(mangledInterMethod.getReturnType())));
			} else {
				//??? this is okay
				//if (!(mg.getBody() == null)) throw new RuntimeException("bas");
			}
			

			// XXX make sure to check that we set exceptions properly on this guy.
			weaver.addLazyMethodGen(mg);
			weaver.getLazyClassGen().warnOnAddedMethod(mg.getMethod(),getSignature().getSourceLocation());
			
			addNeededSuperCallMethods(weaver, onType, munger.getSuperMethodsCalled());
			
    		return true;
    		
		} else if (onInterface && !Modifier.isAbstract(unMangledInterMethod.getModifiers())) {
			
			// This means the 'gen' should be the top most implementor
			// - if it is *not* then something went wrong after we worked
			// out that it was the top most implementor (see pr49657)
    		if (!gen.getType().isTopmostImplementor(onType)) {
    			ResolvedType rtx = gen.getType().getTopmostImplementor(onType);
    			if (!rtx.isExposedToWeaver()) {
    				ISourceLocation sLoc = munger.getSourceLocation();
    			    weaver.getWorld().getMessageHandler().handleMessage(MessageUtil.error(
    			    		WeaverMessages.format(WeaverMessages.ITD_NON_EXPOSED_IMPLEMENTOR,rtx,getAspectType().getName()),
							(sLoc==null?getAspectType().getSourceLocation():sLoc)));
    			} else {
    				// XXX what does this state mean?
    				// We have incorrectly identified what is the top most implementor and its not because
    				// a type wasn't exposed to the weaver
    			}
				return false;
    		} else {
		
			  ResolvedMember mangledInterMethod =
					AjcMemberMaker.interMethod(unMangledInterMethod, aspectType, false);
			
			  LazyMethodGen mg = makeMethodGen(gen, mangledInterMethod);
			  if (mungingInterface) {
				// we want the modifiers of the ITD to be used for all *implementors* of the
				// interface, but the method itself we add to the interface must be public abstract
				mg.setAccessFlags(Modifier.PUBLIC | Modifier.ABSTRACT);
			  }
						
			  Type[] paramTypes = BcelWorld.makeBcelTypes(mangledInterMethod.getParameterTypes());
			  Type returnType = BcelWorld.makeBcelType(mangledInterMethod.getReturnType());
			
			  InstructionList body = mg.getBody();
			  InstructionFactory fact = gen.getFactory();
			  int pos = 0;

			  if (!mangledInterMethod.isStatic()) {
				body.append(InstructionFactory.createThis());
				pos++;
			  }
			  for (int i = 0, len = paramTypes.length; i < len; i++) {
				Type paramType = paramTypes[i];
				body.append(InstructionFactory.createLoad(paramType, pos));
				pos+=paramType.getSize();
			  }
			  body.append(Utility.createInvoke(fact, weaver.getWorld(), interMethodBody));
			  body.append(InstructionFactory.createReturn(returnType));
			  mg.definingType = onType;
			
			  weaver.addOrReplaceLazyMethodGen(mg);
			
			  addNeededSuperCallMethods(weaver, onType, munger.getSuperMethodsCalled());
			
			  return true;
    		}
		} else {
			return false;
		}
	}
================= fetch public LazyMethodGen getLazyMethodGen(Member m) { df46c6f^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java

public LazyMethodGen getLazyMethodGen(Member m) {
		return getLazyMethodGen(m.getName(), m.getSignature());
	}
================= fetch public LazyMethodGen getLazyMethodGen(String name, String signature) { df46c6f^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java

public LazyMethodGen getLazyMethodGen(String name, String signature) {
		for (Iterator i = methodGens.iterator(); i.hasNext();) {
			LazyMethodGen gen = (LazyMethodGen) i.next();
			if (gen.getName().equals(name) && gen.getSignature().equals(signature))
				return gen;
		}
		
		throw new BCException("Class " + this.getName() + " does not have a method " 	
			+ name + " with signature " + signature);
	}
================= fetch public void testNoWarningOnUnusedPointcut() { df46c6f^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testNoWarningOnUnusedPointcut() {
	  runTest("unused private pointcuts");
  }
Progress : [############################------------] 71%================= fetch public void testSynchronizedITDInterfaceMethods() { 2c88c59^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testSynchronizedITDInterfaceMethods() {
	  runTest("synchronized itd interface methods");
  }
================= fetch public void unusedPrivateType(TypeDeclaration typeDecl) { 2c88c59^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java

public void unusedPrivateType(TypeDeclaration typeDecl) {
    	// don't output unused type warnings for aspects!
    	if (!(typeDecl instanceof AspectDeclaration))
    		super.unusedPrivateType(typeDecl);
    }
================= fetch private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge b17ff4e^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java

private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munger) {
		ResolvedMember unMangledInterMethod = munger.getSignature();
		// do matching on the unMangled one, but actually add them to the mangled method
		ResolvedMember interMethodBody = munger.getInterMethodBody(aspectType);
		ResolvedMember interMethodDispatcher = munger.getInterMethodDispatcher(aspectType);
		
		LazyClassGen gen = weaver.getLazyClassGen();
		
		ResolvedType onType = weaver.getWorld().resolve(unMangledInterMethod.getDeclaringType(),munger.getSourceLocation());
		if (onType.isRawType()) onType = onType.getGenericType();

		boolean onInterface = onType.isInterface();
		
		if (onType.isAnnotation()) {
			signalError(WeaverMessages.ITDM_ON_ANNOTATION_NOT_ALLOWED,weaver,onType);
			return false;		
		}
		
		if (onType.isEnum()) {
			signalError(WeaverMessages.ITDM_ON_ENUM_NOT_ALLOWED,weaver,onType);
			return false;
		}
		
		if (onType.equals(gen.getType())) {
			ResolvedMember mangledInterMethod =
					AjcMemberMaker.interMethod(unMangledInterMethod, aspectType, onInterface);
            
			
			LazyMethodGen mg = makeMethodGen(gen, mangledInterMethod);
			
			// pr98901
		    // For copying the annotations across, we have to discover the real member in the aspect
		    // which is holding them.
			if (weaver.getWorld().isInJava5Mode()){
				AnnotationX annotationsOnRealMember[] = null;
				ResolvedType toLookOn = aspectType;
				if (aspectType.isRawType()) toLookOn = aspectType.getGenericType();
				ResolvedMember realMember = getRealMemberForITDFromAspect(toLookOn,interMethodDispatcher);
				if (realMember==null) throw new BCException("Couldn't find ITD holder member '"+
						interMethodDispatcher+"' on aspect "+aspectType);
				annotationsOnRealMember = realMember.getAnnotations();
				
				if (annotationsOnRealMember!=null) {
					for (int i = 0; i < annotationsOnRealMember.length; i++) {
						AnnotationX annotationX = annotationsOnRealMember[i];
						Annotation a = annotationX.getBcelAnnotation();
						AnnotationGen ag = new AnnotationGen(a,weaver.getLazyClassGen().getConstantPoolGen(),true);
						mg.addAnnotation(new AnnotationX(ag.getAnnotation(),weaver.getWorld()));
					}
				}
				// the below loop fixes the very special (and very stupid)
				// case where an aspect declares an annotation
				// on an ITD it declared on itself.
				List allDecams = weaver.getWorld().getDeclareAnnotationOnMethods();
				for (Iterator i = allDecams.iterator(); i.hasNext();){
					DeclareAnnotation decaMC = (DeclareAnnotation) i.next();	
					if (decaMC.matches(unMangledInterMethod,weaver.getWorld())
							&& mg.getEnclosingClass().getType() == aspectType) {
						mg.addAnnotation(decaMC.getAnnotationX());
					}
				}
			}

			if (!onInterface && !Modifier.isAbstract(mangledInterMethod.getModifiers())) {
				InstructionList body = mg.getBody();
				InstructionFactory fact = gen.getFactory();
				int pos = 0;
	
				if (!unMangledInterMethod.isStatic()) {
					body.append(InstructionFactory.createThis());
					pos++;
				}
				Type[] paramTypes = BcelWorld.makeBcelTypes(mangledInterMethod.getParameterTypes());
				for (int i = 0, len = paramTypes.length; i < len; i++) {
					Type paramType = paramTypes[i];
					body.append(InstructionFactory.createLoad(paramType, pos));
					pos+=paramType.getSize();
				}
				body.append(Utility.createInvoke(fact, weaver.getWorld(), interMethodBody));
				body.append(
					InstructionFactory.createReturn(
						BcelWorld.makeBcelType(mangledInterMethod.getReturnType())));
			} else {
				//??? this is okay
				//if (!(mg.getBody() == null)) throw new RuntimeException("bas");
			}
			

			// XXX make sure to check that we set exceptions properly on this guy.
			weaver.addLazyMethodGen(mg);
			weaver.getLazyClassGen().warnOnAddedMethod(mg.getMethod(),getSignature().getSourceLocation());
			
			addNeededSuperCallMethods(weaver, onType, munger.getSuperMethodsCalled());
			
    		return true;
    		
		} else if (onInterface && !Modifier.isAbstract(unMangledInterMethod.getModifiers())) {
			
			// This means the 'gen' should be the top most implementor
			// - if it is *not* then something went wrong after we worked
			// out that it was the top most implementor (see pr49657)
    		if (!gen.getType().isTopmostImplementor(onType)) {
    			ResolvedType rtx = gen.getType().getTopmostImplementor(onType);
    			if (!rtx.isExposedToWeaver()) {
    				ISourceLocation sLoc = munger.getSourceLocation();
    			    weaver.getWorld().getMessageHandler().handleMessage(MessageUtil.error(
    			    		WeaverMessages.format(WeaverMessages.ITD_NON_EXPOSED_IMPLEMENTOR,rtx,getAspectType().getName()),
							(sLoc==null?getAspectType().getSourceLocation():sLoc)));
    			} else {
    				// XXX what does this state mean?
    				// We have incorrectly identified what is the top most implementor and its not because
    				// a type wasn't exposed to the weaver
    			}
				return false;
    		} else {
		
			  ResolvedMember mangledInterMethod =
					AjcMemberMaker.interMethod(unMangledInterMethod, aspectType, false);
			
			  LazyMethodGen mg = makeMethodGen(gen, mangledInterMethod);
						
			  Type[] paramTypes = BcelWorld.makeBcelTypes(mangledInterMethod.getParameterTypes());
			  Type returnType = BcelWorld.makeBcelType(mangledInterMethod.getReturnType());
			
			  InstructionList body = mg.getBody();
			  InstructionFactory fact = gen.getFactory();
			  int pos = 0;

			  if (!mangledInterMethod.isStatic()) {
				body.append(InstructionFactory.createThis());
				pos++;
			  }
			  for (int i = 0, len = paramTypes.length; i < len; i++) {
				Type paramType = paramTypes[i];
				body.append(InstructionFactory.createLoad(paramType, pos));
				pos+=paramType.getSize();
			  }
			  body.append(Utility.createInvoke(fact, weaver.getWorld(), interMethodBody));
			  body.append(InstructionFactory.createReturn(returnType));
			  mg.definingType = onType;
			
			  weaver.addOrReplaceLazyMethodGen(mg);
			
			  addNeededSuperCallMethods(weaver, onType, munger.getSuperMethodsCalled());
			
			  return true;
    		}
		} else {
			return false;
		}
	}
================= fetch public void testAbstractSynchronizedITDMethods() { b17ff4e^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testAbstractSynchronizedITDMethods() {
	  runTest("abstract synchronized itdms not detected");
  }
================= fetch public Collection weave(IClassFileProvider input) throws IOException { 047173e^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
// variation of "weave" that sources class files from an external source.
Collection weave(IClassFileProvider input) throws IOException {
    	Collection wovenClassNames = new ArrayList();
    	IWeaveRequestor requestor = input.getRequestor();

    	requestor.processingReweavableState();
		prepareToProcessReweavableState();
		// clear all state from files we'll be reweaving
		for (Iterator i = input.getClassFileIterator(); i.hasNext(); ) {
		    UnwovenClassFile classFile = (UnwovenClassFile)i.next();
			String className = classFile.getClassName();
		    BcelObjectType classType = getClassType(className);
		    
		    // null return from getClassType() means the delegate is an eclipse source type - so
		    // there *cant* be any reweavable state... (he bravely claimed...)
		    if (classType !=null)
		    	processReweavableStateIfPresent(className, classType);
		}

		requestor.addingTypeMungers();
        
        // We process type mungers in two groups, first mungers that change the type
        // hierarchy, then 'normal' ITD type mungers.
        
        
        // Process the types in a predictable order (rather than the order encountered).
        // For class A, the order is superclasses of A then superinterfaces of A
        // (and this mechanism is applied recursively)
        List typesToProcess = new ArrayList();
        for (Iterator iter = input.getClassFileIterator(); iter.hasNext();) {
			UnwovenClassFile clf = (UnwovenClassFile) iter.next();
            typesToProcess.add(clf.getClassName());
        }
        while (typesToProcess.size()>0) {
            weaveParentsFor(typesToProcess,(String)typesToProcess.get(0));
        }  
        
        for (Iterator i = input.getClassFileIterator(); i.hasNext(); ) {
            UnwovenClassFile classFile = (UnwovenClassFile)i.next();
            String className = classFile.getClassName();
            addNormalTypeMungers(className);
        }

		requestor.weavingAspects();
		// first weave into aspects
		for (Iterator i = input.getClassFileIterator(); i.hasNext(); ) {
		    UnwovenClassFile classFile = (UnwovenClassFile)i.next();
			String className = classFile.getClassName();
		    BcelObjectType classType = BcelWorld.getBcelObjectType(world.resolve(className));
		    if (classType.isAspect()) {
		        weaveAndNotify(classFile, classType,requestor);
		        wovenClassNames.add(className);
		    }
		}

		requestor.weavingClasses();
		// then weave into non-aspects
		for (Iterator i = input.getClassFileIterator(); i.hasNext(); ) {
		    UnwovenClassFile classFile = (UnwovenClassFile)i.next();
			String className = classFile.getClassName();
		    BcelObjectType classType = BcelWorld.getBcelObjectType(world.resolve(className));
		    if (! classType.isAspect()) {
		        weaveAndNotify(classFile, classType, requestor);
		        wovenClassNames.add(className);
		    }
		}
		
		addedClasses = new ArrayList();
		deletedTypenames = new ArrayList();
		
        
		// FIXME asc Should be factored out into Xlint code and done automatically for all xlint messages, ideally.
        // if a piece of advice hasn't matched anywhere and we are in -1.5 mode, put out a warning
        if (world.isInJava5Mode() && 
            world.getLint().adviceDidNotMatch.isEnabled()) {
        	List l = world.getCrosscuttingMembersSet().getShadowMungers();
        	for (Iterator iter = l.iterator(); iter.hasNext();) {
        		ShadowMunger element = (ShadowMunger) iter.next();
        		if (element instanceof BcelAdvice) { // This will stop us incorrectly reporting deow Checkers
                  BcelAdvice ba = (BcelAdvice)element;
                  if (!ba.hasMatchedSomething()) {
					 // Because we implement some features of AJ itself by creating our own kind of mungers, you sometimes
 				     // find that ba.getSignature() is not a BcelMethod - for example it might be a cflow entry munger.
	                 if (ba.getSignature()!=null) {
					   if (!(ba.getSignature() instanceof BcelMethod)
					       || !Utility.isSuppressing((AnnotationX[])ba.getSignature().getAnnotations(),"adviceDidNotMatch")) {
					        world.getLint().adviceDidNotMatch.signal(ba.getDeclaringAspect().toString(),element.getSourceLocation());
					   }							  
                     }
                  }
        		}
        	}
        }

        requestor.weaveCompleted();
    	return wovenClassNames;
    }
================= fetch public void test019(){ 047173e^:tests/src/org/aspectj/systemtest/xlint/XLintTests.java

public void test019(){
    runTest("XLint warning for call PCD's using subtype of defining type (-1.3 -Xlint:ignore)");
  }
================= fetch public void testParsingOfGenericTypeSignature() { 047173e^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testParsingOfGenericTypeSignature() {
	  runTest("parse generic type signature with parameterized type in interface");
  }
================= fetch private String eatIdentifier() { ad753aa^:bcel-builder/src/org/aspectj/apache/bcel/classfile/GenericSignatureParser.java
/**
	 * non-private for test visibility
	 * Splits a string containing a generic signature into tokens for consumption
	 * by the parser.
	 */
public String[] tokenize(String signatureString) {
		  char[] chars = signatureString.toCharArray();
		  int index = 0;
		  List tokens = new ArrayList();
		  StringBuffer identifier = new StringBuffer();
		  boolean inParens = false;
		  boolean inArray = false;
		  boolean couldSeePrimitive = false;
		  do {
			switch (chars[index]) {
				case '<' :
					if (identifier.length() > 0) tokens.add(identifier.toString());
					identifier = new StringBuffer();
					tokens.add("<");
					break;
				case '>' :
					if (identifier.length() > 0) tokens.add(identifier.toString());
					identifier = new StringBuffer();
					tokens.add(">");
					break;
				case ':' :
					if (identifier.length() > 0) tokens.add(identifier.toString());
					identifier = new StringBuffer();
					tokens.add(":");
					break;
				case '/' :
					if (identifier.length() > 0) tokens.add(identifier.toString());
					identifier = new StringBuffer();
					tokens.add("/");
					couldSeePrimitive = false;
					break;
				case ';' :
					if (identifier.length() > 0) tokens.add(identifier.toString());
					identifier = new StringBuffer();
					tokens.add(";");
					couldSeePrimitive = true;
					inArray = false;
					break;
				case '^':
					if (identifier.length() > 0) tokens.add(identifier.toString());
					identifier = new StringBuffer();
					tokens.add("^");
					break;
				case '+':
					tokens.add("+");
					break;
				case '-':
					tokens.add("-");
					break;
				case '*':
					tokens.add("*");
					break;
				case '.' :
					if (identifier.length() > 0) tokens.add(identifier.toString());
					identifier = new StringBuffer();
					tokens.add(".");
					break;
				case '(' :
					tokens.add("(");
					inParens = true;
					couldSeePrimitive = true;
					break;
				case ')' :
					tokens.add(")");
					inParens = false;
					break;
				case '[' :
					tokens.add("[");
					couldSeePrimitive = true;
					inArray = true;
					break;
				case 'B' :
				case 'C' :
				case 'D' :
				case 'F' :
				case 'I' :
				case 'J' :
				case 'S' :
				case 'V' :
				case 'Z' :
					if ((inParens || inArray) && couldSeePrimitive && identifier.length() == 0) {
						tokens.add(new String("" + chars[index]));
					} else {
						identifier.append(chars[index]);
					}
					couldSeePrimitive = false;
					inArray = false;
					break;
				default : 
					identifier.append(chars[index]);
			}
		  } while((++index) < chars.length);
		  if (identifier.length() > 0) tokens.add(identifier.toString());
		  String [] tokenArray = new String[tokens.size()];
		  tokens.toArray(tokenArray);
		  return tokenArray;
	  }
================= fetch public void testSyntheticArgumentsOnITDConstructorsNotUsedInMatching() { ad753aa^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testSyntheticArgumentsOnITDConstructorsNotUsedInMatching() {
	  runTest("synthetic arguments on itd cons are not used in matching");
  }
================= fetch public ISourceLocation getSourceLocation() { 619f8bc^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public ISourceLocation getSourceLocation() {
		int sourceLine = getSourceLine();
		if (sourceLine == 0 || sourceLine == -1) {
//			Thread.currentThread().dumpStack();
//			System.err.println(this + ": " + range);
			return getEnclosingClass().getType().getSourceLocation();
		} else {
		    // For staticinitialization, if we have a nice offset, don't build a new source loc
			if (getKind()==Shadow.StaticInitialization && getEnclosingClass().getType().getSourceLocation().getOffset()!=0)
				return getEnclosingClass().getType().getSourceLocation();
			else 
			    return getEnclosingClass().getType().getSourceContext().makeSourceLocation(sourceLine, 0);
		}
	}
================= fetch public int getDeclarationLineNumber() { 619f8bc^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

public int getDeclarationLineNumber() {
    	if (hasDeclaredLineNumberInfo()) {
    		return memberView.getDeclarationLineNumber();
    	} else {
    		return -1;
    	}
    }
================= fetch public void addAttribute(Attribute attr) { 619f8bc^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
/**
     * Adds an attribute to the method
     * @param attr
     */
public void addAttribute(Attribute attr) {
        Attribute[] newAttributes = new Attribute[attributes.length + 1];
        System.arraycopy(attributes, 0, newAttributes, 0, attributes.length);
        newAttributes[attributes.length] = attr;
        attributes = newAttributes;
    }
================= fetch private void reportWeavingMessage(ShadowMunger munger) { c6bc7a2^:weaver/src/org/aspectj/weaver/Shadow.java

public IRelationship.Kind determineRelKind(ShadowMunger munger) {
		AdviceKind ak = ((Advice)munger).getKind();
		if (ak.getKey()==AdviceKind.Before.getKey())
				return IRelationship.Kind.ADVICE_BEFORE;
================= fetch public static void main(String args[]) throws Throwable { c6bc7a2^:tests/java5/ataspectj/ataspectj/ltwlog/MainVerboseAndShow.java

public static void main(String args[]) throws Throwable {
        new MainVerboseAndShow().target();
        if (!MessageHolder.startsAs(Arrays.asList(new String[]{
                "info weaving 'ataspectj/ltwlog/MainVerboseAndShow'",
                "weaveinfo Type 'ataspectj.ltwlog.MainVerboseAndShow' (MainVerboseAndShow.java:22) advised by before advice from 'ataspectj.ltwlog.Aspect1' (Aspect1.java)",
                "info weaving 'ataspectj/ltwlog/Aspect1'"})
Progress : [############################------------] 72%================= fetch Class extractType(int n) { a5e645f^:runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java

Class extractType(int n) {
        String s = extractString(n);
        return makeClass(s);
    }
================= fetch Class makeClass(String s) { a5e645f^:runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java

Class[] extractTypes(int n) {
        String s = extractString(n);
        StringTokenizer st = new StringTokenizer(s, INNER_SEP);
        final int N = st.countTokens();
        Class[] ret = new Class[N];
        for (int i = 0; i < N; i++) ret[i]= makeClass(st.nextToken());
        return ret;
    }
================= fetch private void initializeTjp(InstructionFactory fact, InstructionList list, a5e645f^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java

void initializeTjp(InstructionFactory fact, InstructionList list,
    							 Field field, BcelShadow shadow)
    {
    	Member sig = shadow.getSignature();
    	//ResolvedMember mem = shadow.getSignature().resolve(shadow.getWorld());
    	
    	// load the factory
    	list.append(InstructionFactory.createLoad(factoryType, 0));
    	
    	// load the kind
    	list.append(new PUSH(getConstantPoolGen(), shadow.getKind().getName()));
    	
    	// create the signature
    	list.append(InstructionFactory.createLoad(factoryType, 0));
    	list.append(new PUSH(getConstantPoolGen(), sig.getSignatureString(shadow.getWorld())));
    	list.append(fact.createInvoke(factoryType.getClassName(), 
    					sig.getSignatureMakerName(),
    					new ObjectType(sig.getSignatureType()),
    					new Type[] { Type.STRING },
    					Constants.INVOKEVIRTUAL));
    	
    	//XXX should load source location from shadow
    	list.append(Utility.createConstant(fact, shadow.getSourceLine()));

        final String factoryMethod;
        if (staticTjpType.equals(field.getType())) {
            factoryMethod = "makeSJP";
        } else if (enclosingStaticTjpType.equals(field.getType())) {
            factoryMethod = "makeESJP";
        } else {
            throw new Error("should not happen");
        }
    	list.append(fact.createInvoke(factoryType.getClassName(),
    			factoryMethod, field.getType(),
    			new Type[] { Type.STRING, sigType, Type.INT},
    			Constants.INVOKEVIRTUAL));
    	
    	// put it in the field	
    	list.append(fact.createFieldAccess(getClassName(), field.getName(),
    		field.getType(), Constants.PUTSTATIC));
    }
================= fetch public AdviceSignature makeAdviceSig(String stringRep) { a5e645f^:runtime/src/org/aspectj/runtime/reflect/Factory.java

public AdviceSignature makeAdviceSig(String stringRep) {
        AdviceSignatureImpl ret = new AdviceSignatureImpl(stringRep);
        ret.setLookupClassLoader(lookupClassLoader);
        return ret;
    }
================= fetch public CatchClauseSignature makeCatchClauseSig(String stringRep) { a5e645f^:runtime/src/org/aspectj/runtime/reflect/Factory.java

public CatchClauseSignature makeCatchClauseSig(String stringRep) {
        CatchClauseSignatureImpl ret = new CatchClauseSignatureImpl(stringRep);
        ret.setLookupClassLoader(lookupClassLoader);
        return ret;
    }
================= fetch public ConstructorSignature makeConstructorSig(String stringRep) { a5e645f^:runtime/src/org/aspectj/runtime/reflect/Factory.java

public ConstructorSignature makeConstructorSig(String stringRep) {
        ConstructorSignatureImpl ret = new ConstructorSignatureImpl(stringRep);
        ret.setLookupClassLoader(lookupClassLoader);
        return ret;
    }
================= fetch public FieldSignature makeFieldSig(String stringRep) { a5e645f^:runtime/src/org/aspectj/runtime/reflect/Factory.java

public FieldSignature makeFieldSig(String stringRep) {
        FieldSignatureImpl ret = new FieldSignatureImpl(stringRep);
        ret.setLookupClassLoader(lookupClassLoader);
        return ret;
    }
================= fetch public InitializerSignature makeInitializerSig(String stringRep) { a5e645f^:runtime/src/org/aspectj/runtime/reflect/Factory.java

public InitializerSignature makeInitializerSig(String stringRep) {
        InitializerSignatureImpl ret = new InitializerSignatureImpl(stringRep);
        ret.setLookupClassLoader(lookupClassLoader);
        return ret;
    }
================= fetch public MethodSignature makeMethodSig(String stringRep) { a5e645f^:runtime/src/org/aspectj/runtime/reflect/Factory.java

public MethodSignature makeMethodSig(String stringRep) {
        MethodSignatureImpl ret = new MethodSignatureImpl(stringRep);
        ret.setLookupClassLoader(lookupClassLoader);
        return ret;
    }
================= fetch public void testArgsGeneratedCorrectlyForAdviceExecution() { 16512b2^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testArgsGeneratedCorrectlyForAdviceExecution() {
	  runTest("args generated correctly for advice execution join point");
  }
================= fetch public void visibilityConflict(MethodBinding currentMethod, MethodBinding inheri 16512b2^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java

public void visibilityConflict(MethodBinding currentMethod, MethodBinding inheritedMethod) {
    	// Not quite sure if the conditions on this test are right - basically I'm saying
    	// DONT WORRY if its ITDs since the error will be reported another way...
    	if (isIntertypeDeclaration(currentMethod) && 
    		isIntertypeDeclaration(inheritedMethod) && 
    		Modifier.isPrivate(currentMethod.modifiers) && 
    		Modifier.isPrivate(inheritedMethod.modifiers)) {
    		return;
    	}
    	super.visibilityConflict(currentMethod,inheritedMethod);
    }
================= fetch private Test findResidueNoEllipsis(Shadow shadow, ExposedState state, TypePatter a66e0a2^:weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java

private Test findResidueNoEllipsis(Shadow shadow, ExposedState state, TypePattern[] patterns) {
		int len = shadow.getArgCount();
		//System.err.println("boudn to : " + len + ", " + patterns.length);
		if (patterns.length != len) {
			return Literal.FALSE;
		}
		
		Test ret = Literal.TRUE;
		
		for (int i=0; i < len; i++) {
			UnresolvedType argType = shadow.getGenericArgTypes()[i];
			TypePattern type = patterns[i];
            ResolvedType argRTX = shadow.getIWorld().resolve(argType,true);
			if (!(type instanceof BindingTypePattern)) {
                if (argRTX == ResolvedType.MISSING) {
                  IMessage msg = new Message(
                    WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_ARG_TYPE,argType.getName()),
                    "",IMessage.ERROR,shadow.getSourceLocation(),null,new ISourceLocation[]{getSourceLocation()});
                }
				if (type.matchesInstanceof(argRTX).alwaysTrue()) {
					continue;
				}
			} else {
			  BindingTypePattern btp = (BindingTypePattern)type;
			  // Check if we have already bound something to this formal
			  if ((state.get(btp.getFormalIndex())!=null) &&(lastMatchedShadowId != shadow.shadowId)) {
//			  	ISourceLocation isl = getSourceLocation();
//				Message errorMessage = new Message(
//                    "Ambiguous binding of type "+type.getExactType().toString()+
//                    " using args(..) at this line - formal is already bound"+
//                    ".  See secondary source location for location of args(..)",
//					shadow.getSourceLocation(),true,new ISourceLocation[]{getSourceLocation()});
//				shadow.getIWorld().getMessageHandler().handleMessage(errorMessage);
				state.setErroneousVar(btp.getFormalIndex());
			  }
			}

			World world = shadow.getIWorld();
			ResolvedType typeToExpose = type.getExactType().resolve(world);
			if (typeToExpose.isParameterizedType()) {
				boolean inDoubt = (type.matchesInstanceof(argRTX) == FuzzyBoolean.MAYBE);				
				if (inDoubt && world.getLint().uncheckedArgument.isEnabled()) {
					String uncheckedMatchWith = typeToExpose.getSimpleBaseName();
					if (argRTX.isParameterizedType() && (argRTX.getRawType() == typeToExpose.getRawType())) {
						uncheckedMatchWith = argRTX.getSimpleName();
					}
					if (!isUncheckedArgumentWarningSuppressed()) {
						world.getLint().uncheckedArgument.signal(
								new String[] {
										typeToExpose.getSimpleName(),
										uncheckedMatchWith,
										typeToExpose.getSimpleBaseName(),
										shadow.toResolvedString(world)},
								getSourceLocation(),
								new ISourceLocation[] {shadow.getSourceLocation()});
						}
				}
			}			
			
			ret = Test.makeAnd(ret,
				exposeStateForVar(shadow.getArgVar(i), type, state,shadow.getIWorld()));
		}
		
		return ret;		
	}
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { a66e0a2^:weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java

protected FuzzyBoolean matchInternal(Shadow shadow) {
		FuzzyBoolean ret =
			arguments.matches(shadow.getIWorld().resolve(shadow.getGenericArgTypes()), TypePattern.DYNAMIC);
		return ret;
	}
================= fetch protected Test findResidueInternal(Shadow shadow, ExposedState state) { a66e0a2^:weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java

protected Test findResidueInternal(Shadow shadow, ExposedState state) {
		if (arguments.matches(shadow.getIWorld().resolve(shadow.getGenericArgTypes()), TypePattern.DYNAMIC).alwaysFalse()) {
			return Literal.FALSE;
		}
		int ellipsisCount = arguments.ellipsisCount;
		if (ellipsisCount == 0) {
			return findResidueNoEllipsis(shadow, state, arguments.getTypePatterns());		
		} else if (ellipsisCount == 1) {
			TypePattern[] patternsWithEllipsis = arguments.getTypePatterns();
			TypePattern[] patternsWithoutEllipsis = new TypePattern[shadow.getArgCount()];
			int lenWithEllipsis = patternsWithEllipsis.length;
			int lenWithoutEllipsis = patternsWithoutEllipsis.length;
			// l1+1 >= l0
			int indexWithEllipsis = 0;
			int indexWithoutEllipsis = 0;
			while (indexWithoutEllipsis < lenWithoutEllipsis) {
				TypePattern p = patternsWithEllipsis[indexWithEllipsis++];
				if (p == TypePattern.ELLIPSIS) {
					int newLenWithoutEllipsis =
						lenWithoutEllipsis - (lenWithEllipsis-indexWithEllipsis);
					while (indexWithoutEllipsis < newLenWithoutEllipsis) {
						patternsWithoutEllipsis[indexWithoutEllipsis++] = TypePattern.ANY;
					}
				} else {
					patternsWithoutEllipsis[indexWithoutEllipsis++] = p;
				}
			}
			return findResidueNoEllipsis(shadow, state, patternsWithoutEllipsis);
		} else {
			throw new BetaException("unimplemented");
		}
	}
================= fetch public void testVisibiltyInSignatureMatchingWithOverridesPart3() { a66e0a2^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testVisibiltyInSignatureMatchingWithOverridesPart3() {
	  runTest("visibility in signature matching with overrides - 3");
  }
================= fetch private static void accumulateMembersMatching( 7e0c3cd^:weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java
/**
     * We have a resolved member, possibly with type parameter references as parameters or return
     * type. We need to find all its ancestor members. When doing this, a type parameter matches
     * regardless of bounds (bounds can be narrowed down the hierarchy).
     */
private static void accumulateMembersMatching(
    		ResolvedMemberImpl memberToMatch,
    		Iterator typesToLookIn,
    		List typesAlreadyVisited,
    		Set foundMembers) {
    	while(typesToLookIn.hasNext()) {
    		ResolvedType toLookIn = (ResolvedType) typesToLookIn.next();
			if (!typesAlreadyVisited.contains(toLookIn)) {
				typesAlreadyVisited.add(toLookIn);
				ResolvedMemberImpl foundMember = (ResolvedMemberImpl) toLookIn.lookupResolvedMember(memberToMatch);
				if (foundMember != null) {
					List declaringTypes = new ArrayList();
					// declaring type can be unresolved if the member can from an ITD...
					ResolvedType resolvedDeclaringType = foundMember.getDeclaringType().resolve(toLookIn.getWorld());
					accumulateTypesInBetween(toLookIn, resolvedDeclaringType, declaringTypes);
				   	for (Iterator iter = declaringTypes.iterator(); iter.hasNext();) {
						ResolvedType declaringType = (ResolvedType) iter.next();
//						typesAlreadyVisited.add(declaringType);
						ResolvedMember member = foundMember.withSubstituteDeclaringType(declaringType);
						foundMembers.add(member);
					}				   	
					if (toLookIn.isParameterizedType() && (foundMember.backingGenericMember != null)) {
						foundMembers.add(new JoinPointSignature(foundMember.backingGenericMember,foundMember.declaringType.resolve(toLookIn.getWorld())));
					}
					accumulateMembersMatching(foundMember,toLookIn.getDirectSupertypes(),typesAlreadyVisited,foundMembers);
					// if this was a parameterized type, look in the generic type that backs it too
				}	
			}
		}
    }
================= fetch public void testInlinedFieldAccessInProceedCall() { 7e0c3cd^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testInlinedFieldAccessInProceedCall() {
	  runTest("inlined field access in proceed call");
  }
================= fetch private FieldBinding getAccessibleField(FieldBinding binding, TypeBinding receiv 6c8747b^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java

private FieldBinding getAccessibleField(FieldBinding binding, TypeBinding receiverType) {
		//System.err.println("checking field: " + binding);
		if (!binding.isValidBinding()) return binding;
		
		makePublic(receiverType);
		if (isPublic(binding)) return binding;
		if (binding instanceof PrivilegedFieldBinding) return binding;
		if (binding instanceof InterTypeFieldBinding) return binding;

		if (binding.isPrivate() &&  binding.declaringClass != inAspect.binding) {
			binding.modifiers = AstUtil.makePackageVisible(binding.modifiers);
		}
		
		ResolvedMember m = world.makeResolvedMember(binding, receiverType);
		if (inAspect.accessForInline.containsKey(m)) return (FieldBinding)inAspect.accessForInline.get(m);
		FieldBinding ret = new InlineAccessFieldBinding(inAspect, binding, m);
		
		//System.err.println("   made accessor: " + ret);
		
		inAspect.accessForInline.put(m, ret);
		return ret;
	}
================= fetch public void testInnerClassPassedToVarargs() { 6c8747b^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testInnerClassPassedToVarargs() {
	  runTest("inner class passed as argument to varargs method");
  }
================= fetch public void testDeclareParentsIntroducingCovariantReturnType() { f2af562^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testDeclareParentsIntroducingCovariantReturnType() {
	  runTest("declare parents introducing override with covariance");
  }
Progress : [#############################-----------] 73%================= fetch public void testEnumSwitchInITD() { b953c03^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testEnumSwitchInITD() {
	  runTest("switch on enum inside ITD method");
  }
================= fetch private ReferenceType getOuterClass() { 2c9ea11^:weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java

private void ensureGenericInfoProcessed() { getDeclaredGenericSignature();}
================= fetch private static ResolvedType classTypeSignature2TypeX( 2c9ea11^:weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java

private static ResolvedType classTypeSignature2TypeX(
			Signature.ClassTypeSignature aClassTypeSignature,
			Signature.FormalTypeParameter[] typeParams,
			World world,
			Map inProgressTypeVariableResolutions) {
		// class type sig consists of an outer type, and zero or more nested types
		// the fully qualified name is outer-type.nested-type1.nested-type2....
		// each type in the hierarchy may have type arguments
		
		// first build the 'raw type' signature
		StringBuffer sig = new StringBuffer();
		sig.append(aClassTypeSignature.outerType.identifier.replace(';',' ').trim());
		for (int i = 0; i < aClassTypeSignature.nestedTypes.length; i++) {
			sig.append("$"); 
			sig.append(aClassTypeSignature.nestedTypes[i].identifier.replace(';',' ').trim());
		}
		sig.append(";");
		
		// now look for any type parameters.
		// I *think* we only need to worry about the 'right-most' type...
		SimpleClassTypeSignature innerType = aClassTypeSignature.outerType;
		if (aClassTypeSignature.nestedTypes.length > 0) {
			innerType = aClassTypeSignature.nestedTypes[aClassTypeSignature.nestedTypes.length-1];
		}
		if (innerType.typeArguments.length > 0) {
			// we have to create a parameterized type
			// type arguments may be array types, class types, or typevariable types
			ResolvedType theBaseType = UnresolvedType.forSignature(sig.toString()).resolve(world);
			ResolvedType[] typeArgumentTypes = new ResolvedType[innerType.typeArguments.length];
			for (int i = 0; i < typeArgumentTypes.length; i++) {
				typeArgumentTypes[i] = typeArgument2TypeX(innerType.typeArguments[i],typeParams,world,inProgressTypeVariableResolutions);
			}
			return 
				TypeFactory.createParameterizedType(
									theBaseType,
									typeArgumentTypes,
									world);
				
			
//				world.resolve(UnresolvedType.forParameterizedTypes(
//						UnresolvedType.forSignature(sig.toString()).resolve(world), 
//						typeArgumentTypes));
		} else {
			// we have a non-parameterized type
			return world.resolve(UnresolvedType.forSignature(sig.toString()));
		}
	}
================= fetch private static ResolvedType fieldTypeSignature2TypeX( 2c9ea11^:weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java

private static ResolvedType fieldTypeSignature2TypeX(
			Signature.FieldTypeSignature aFieldTypeSignature,
			Signature.FormalTypeParameter[] typeParams,
			World world,
			Map inProgressTypeVariableResolutions) {
		if (aFieldTypeSignature.isClassTypeSignature()) {
			return classTypeSignature2TypeX((Signature.ClassTypeSignature)aFieldTypeSignature,typeParams,world,inProgressTypeVariableResolutions);
		} else if (aFieldTypeSignature.isArrayTypeSignature()) {
			int dims = 0;
			Signature.TypeSignature ats =  aFieldTypeSignature;
			while(ats instanceof Signature.ArrayTypeSignature) {
				dims++;
				ats = ((Signature.ArrayTypeSignature)ats).typeSig;
			}
			return world.resolve(UnresolvedType.makeArray(typeSignature2TypeX(ats,typeParams,world,inProgressTypeVariableResolutions), dims));
		} else if (aFieldTypeSignature.isTypeVariableSignature()) {
			ResolvedType rtx = typeVariableSignature2TypeX((Signature.TypeVariableSignature)aFieldTypeSignature,typeParams,world,inProgressTypeVariableResolutions);
			return rtx;
		} else {
			throw new IllegalStateException("Cant understand field type signature: "  + aFieldTypeSignature);
		}
	}
================= fetch private static ResolvedType typeArgument2TypeX( 2c9ea11^:weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java

private static ResolvedType typeArgument2TypeX(
			Signature.TypeArgument aTypeArgument,
			Signature.FormalTypeParameter[] typeParams,
			World world,
			Map inProgressTypeVariableResolutions) {
		if (aTypeArgument.isWildcard) return UnresolvedType.SOMETHING.resolve(world);
		if (aTypeArgument.isMinus) {
			UnresolvedType bound = fieldTypeSignature2TypeX(aTypeArgument.signature, typeParams,world,inProgressTypeVariableResolutions);
			ReferenceType rBound = (ReferenceType) world.resolve(bound);
			return new BoundedReferenceType(rBound,false,world);
		} else if (aTypeArgument.isPlus) {
			UnresolvedType bound = fieldTypeSignature2TypeX(aTypeArgument.signature, typeParams,world,inProgressTypeVariableResolutions);
			ReferenceType rBound = (ReferenceType) world.resolve(bound);
			return new BoundedReferenceType(rBound,true,world);
		} else {
			return fieldTypeSignature2TypeX(aTypeArgument.signature,typeParams,world,inProgressTypeVariableResolutions);
		}
	}
================= fetch private static ResolvedType typeSignature2TypeX( 2c9ea11^:weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java

private static ResolvedType typeSignature2TypeX(
			Signature.TypeSignature aTypeSig,
			Signature.FormalTypeParameter[] typeParams,
			World world,
			Map inProgressTypeVariableResolutions) {
		if (aTypeSig.isBaseType()) {
			return world.resolve(UnresolvedType.forSignature(((Signature.BaseTypeSignature)aTypeSig).toString()));
		} else {
			return fieldTypeSignature2TypeX((Signature.FieldTypeSignature)aTypeSig,typeParams,world,inProgressTypeVariableResolutions);
		}
	}
================= fetch private static ResolvedType typeVariableSignature2TypeX( 2c9ea11^:weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java

private static ResolvedType typeVariableSignature2TypeX(
			Signature.TypeVariableSignature aTypeVarSig,
			Signature.FormalTypeParameter[] typeParams,
			World world,
			Map inProgressTypeVariableResolutions) {
		Signature.FormalTypeParameter typeVarBounds = null;
		for (int i = 0; i < typeParams.length; i++) {
			if (typeParams[i].identifier.equals(aTypeVarSig.typeVariableName)) {
				typeVarBounds = typeParams[i];
				break;
			}
		}
		if (typeVarBounds == null) {
			throw new IllegalStateException("Undeclared type variable in signature: " + aTypeVarSig.typeVariableName);
		}
		if (inProgressTypeVariableResolutions.containsKey(typeVarBounds)) {
			return (ResolvedType) inProgressTypeVariableResolutions.get(typeVarBounds);
		}
		inProgressTypeVariableResolutions.put(typeVarBounds,new FTPHolder(typeVarBounds,world));
		ResolvedType ret = new TypeVariableReferenceType(
				formalTypeParameter2TypeVariable(typeVarBounds,typeParams,world,inProgressTypeVariableResolutions),
				world);
		inProgressTypeVariableResolutions.put(typeVarBounds,ret);
		return ret;
	}
================= fetch private static TypeVariable formalTypeParameter2TypeVariable( 2c9ea11^:weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java

private static TypeVariable formalTypeParameter2TypeVariable(
			Signature.FormalTypeParameter aFormalTypeParameter,
			Signature.FormalTypeParameter[] typeParams,
			World world,
			Map inProgressTypeVariableResolutions) {
			UnresolvedType upperBound = fieldTypeSignature2TypeX(aFormalTypeParameter.classBound,typeParams,world,inProgressTypeVariableResolutions);
			UnresolvedType[] ifBounds = new UnresolvedType[aFormalTypeParameter.interfaceBounds.length];
			for (int i = 0; i < ifBounds.length; i++) {
				ifBounds[i] = fieldTypeSignature2TypeX(aFormalTypeParameter.interfaceBounds[i], typeParams,world,inProgressTypeVariableResolutions);
			}
			return new TypeVariable(aFormalTypeParameter.identifier,upperBound,ifBounds);
	}
================= fetch private void unpackGenericSignature() { 2c9ea11^:weaver/src/org/aspectj/weaver/bcel/BcelField.java

private void unpackGenericSignature() {
		if (unpackedGenericSignature) return;
		unpackedGenericSignature = true;
		String gSig = field.getGenericSignature();
		if (gSig != null) {
		  // get from generic
		  Signature.FieldTypeSignature fts = new GenericSignatureParser().parseAsFieldSignature(gSig);
		  Signature.ClassSignature genericTypeSig = bcelObjectType.getGenericClassTypeSignature();
		  Signature.FormalTypeParameter[] typeVars = ((genericTypeSig == null) ? new Signature.FormalTypeParameter[0] : genericTypeSig.formalTypeParameters);
		  genericFieldType = BcelGenericSignatureToTypeXConverter.fieldTypeSignature2TypeX(fts, typeVars, world);
		} else {
		  genericFieldType = getReturnType();
		}	
	}
================= fetch private void unpackGenericSignature() { 2c9ea11^:weaver/src/org/aspectj/weaver/bcel/BcelMethod.java

private void unpackGenericSignature() {
		 if (unpackedGenericSignature) return;
		 unpackedGenericSignature = true;
		 String gSig = method.getGenericSignature();
		 if (gSig != null) {
			 Signature.MethodTypeSignature mSig = new GenericSignatureParser().parseAsMethodSignature(method.getGenericSignature());
 			 if (mSig.formalTypeParameters.length > 0) {
				// generic method declaration
				canBeParameterized = true;
			 }
 			 Signature.FormalTypeParameter[] parentFormals = bcelObjectType.getAllFormals();
 			 Signature.FormalTypeParameter[] formals = new
 			 	Signature.FormalTypeParameter[parentFormals.length + mSig.formalTypeParameters.length];
 			 // put method formal in front of type formals for overriding in lookup
 			 System.arraycopy(mSig.formalTypeParameters,0,formals,0,mSig.formalTypeParameters.length);
 			 System.arraycopy(parentFormals,0,formals,mSig.formalTypeParameters.length,parentFormals.length);
 			 Signature.TypeSignature returnTypeSignature = mSig.returnType;
			 genericReturnType = BcelGenericSignatureToTypeXConverter.typeSignature2TypeX(
					 returnTypeSignature, formals,
					 world);
			 Signature.TypeSignature[] paramTypeSigs = mSig.parameters;
			 genericParameterTypes = new UnresolvedType[paramTypeSigs.length];
			 for (int i = 0; i < paramTypeSigs.length; i++) {
				genericParameterTypes[i] = 
					BcelGenericSignatureToTypeXConverter.typeSignature2TypeX(
							paramTypeSigs[i],formals,world);
				if (paramTypeSigs[i] instanceof TypeVariableSignature) {
					canBeParameterized = true;
				}
			 }
		 } else {
			 genericReturnType = getReturnType();
			 genericParameterTypes = getParameterTypes();
		 }
	 }
================= fetch private void unpackGenericSignature() { 2c9ea11^:weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java

public Signature.FormalTypeParameter[] getAllFormals() {
		unpackGenericSignature();
		if (formalsForResolution == null) {
			return new Signature.FormalTypeParameter[0];
		} else {
			return formalsForResolution;
		}
	}
================= fetch public ResolvedType resolve(World world) { 2c9ea11^:weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java

public ResolvedType resolve(World world) {
			return this;
		}
================= fetch public static ResolvedType classTypeSignature2TypeX( 2c9ea11^:weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java

public static ResolvedType classTypeSignature2TypeX(
			Signature.ClassTypeSignature aClassTypeSignature,
			Signature.FormalTypeParameter[] typeParams,
			World world) {
		Map typeMap = new HashMap();
		ResolvedType ret = classTypeSignature2TypeX(aClassTypeSignature,typeParams,world,typeMap);
		fixUpCircularDependencies(ret, typeMap);
		return ret;
	}
================= fetch public static ResolvedType fieldTypeSignature2TypeX( 2c9ea11^:weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java

public static ResolvedType fieldTypeSignature2TypeX(
			Signature.FieldTypeSignature aFieldTypeSignature,
			Signature.FormalTypeParameter[] typeParams,
			World world) {
		Map typeMap = new HashMap();
		ResolvedType ret = fieldTypeSignature2TypeX(aFieldTypeSignature,typeParams,world,typeMap);
		fixUpCircularDependencies(ret, typeMap);
		return ret;
	}
================= fetch public static ResolvedType typeSignature2TypeX( 2c9ea11^:weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java

public static ResolvedType typeSignature2TypeX(
			Signature.TypeSignature aTypeSig,
			Signature.FormalTypeParameter[] typeParams,
			World world) {
		Map typeMap = new HashMap();
		ResolvedType ret = typeSignature2TypeX(aTypeSig,typeParams,world,typeMap);
		fixUpCircularDependencies(ret, typeMap);
		return ret;
	}
================= fetch public static TypeVariable formalTypeParameter2TypeVariable( 2c9ea11^:weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java

public static TypeVariable formalTypeParameter2TypeVariable(
			Signature.FormalTypeParameter aFormalTypeParameter,
			Signature.FormalTypeParameter[] typeParams,
			World world) {
		Map typeMap = new HashMap();
		return formalTypeParameter2TypeVariable(aFormalTypeParameter,typeParams,world,typeMap);
	}
================= fetch public void setJavaClass(JavaClass newclass) { 2c9ea11^:weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java

public TypeVariable[] getTypeVariables() {
    	if (!isGeneric()) return new TypeVariable[0];
    	
    	if (typeVars == null) {
	    	Signature.ClassSignature classSig = javaClass.getGenericClassTypeSignature();
	    	typeVars = new TypeVariable[classSig.formalTypeParameters.length];
	    	for (int i = 0; i < typeVars.length; i++) {
				Signature.FormalTypeParameter ftp = classSig.formalTypeParameters[i];
				typeVars[i] = BcelGenericSignatureToTypeXConverter.formalTypeParameter2TypeVariable(
						ftp, 
						classSig.formalTypeParameters,
						getResolvedTypeX().getWorld());
			}
    	}
    	return typeVars;
    }
================= fetch public void testEnumFromHell() { 2c9ea11^:weaver/testsrc/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXTestCase.java

public void testEnumFromHell() {
		BcelWorld world = new BcelWorld();
		JavaClass javaLangEnum = Repository.lookupClass("java/lang/Enum");
		Signature.ClassSignature cSig = javaLangEnum.getGenericClassTypeSignature();
		UnresolvedType superclass = 
			BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(
					cSig.superclassSignature,
					cSig.formalTypeParameters,
					world
					);
		assertEquals("Ljava/lang/Object;",superclass.getSignature());
		assertEquals("2 superinterfaces",2,cSig.superInterfaceSignatures.length);
		UnresolvedType comparable = 
			BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(
					cSig.superInterfaceSignatures[0],
					cSig.formalTypeParameters,
					world
					);		
		assertEquals("Pjava/lang/Comparable<TE;>;",comparable.getSignature());
		UnresolvedType serializable = 
			BcelGenericSignatureToTypeXConverter.classTypeSignature2TypeX(
					cSig.superInterfaceSignatures[1],
					cSig.formalTypeParameters,
					world
					);
		assertEquals("Ljava/io/Serializable;",serializable.getSignature());
	}
================= fetch public void testParameterizedVarArgsMatch() { be750d5^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testParameterizedVarArgsMatch() {
	  runTest("varargs with type variable");
  }
================= fetch private static void accumulateMembersMatching( 27e68f3^:weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java
/**
     * We have a resolved member, possibly with type parameter references as parameters or return
     * type. We need to find all its ancestor members. When doing this, a type parameter matches
     * regardless of bounds (bounds can be narrowed down the hierarchy).
     */
private static void accumulateMembersMatching(
    		ResolvedMemberImpl memberToMatch,
    		Iterator typesToLookIn,
    		List typesAlreadyVisited,
    		List foundMembers) {
    	while(typesToLookIn.hasNext()) {
    		ResolvedType toLookIn = (ResolvedType) typesToLookIn.next();
			if (!typesAlreadyVisited.contains(toLookIn)) {
				typesAlreadyVisited.add(toLookIn);
				ResolvedMemberImpl foundMember = (ResolvedMemberImpl) toLookIn.lookupResolvedMember(memberToMatch);
				if (foundMember != null) {
					List declaringTypes = new ArrayList();
					// declaring type can be unresolved if the member can from an ITD...
					ResolvedType resolvedDeclaringType = foundMember.getDeclaringType().resolve(toLookIn.getWorld());
					accumulateTypesInBetween(toLookIn, resolvedDeclaringType, declaringTypes);
				   	for (Iterator iter = declaringTypes.iterator(); iter.hasNext();) {
						ResolvedType declaringType = (ResolvedType) iter.next();
						typesAlreadyVisited.add(declaringType);
						ResolvedMember member = foundMember.withSubstituteDeclaringType(declaringType);
						foundMembers.add(member);
					}				   	
					if (toLookIn.isParameterizedType() && (foundMember.backingGenericMember != null)) {
						foundMembers.add(new JoinPointSignature(foundMember.backingGenericMember,foundMember.declaringType.resolve(toLookIn.getWorld())));
					}
					accumulateMembersMatching(foundMember,toLookIn.getDirectSupertypes(),typesAlreadyVisited,foundMembers);
					// if this was a parameterized type, look in the generic type that backs it too
				}	
			}
		}
    }
================= fetch public ResolvedMemberImpl( 27e68f3^:weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java
/**
     * Compute the full set of signatures for a member. This walks up the hierarchy
     * giving the ResolvedMember in each defining type in the hierarchy. A shadowMember
     * can be created with a target type (declaring type) that does not actually define
     * the member. This is ok as long as the member is inherited in the declaring type.
     * Each declaring type in the line to the actual declaring type is added as an additional
     * signature. For example:
     * 
     * class A { void foo(); }
     * class B extends A {}
     * 
     * shadowMember : void B.foo()
     * 
     * gives  { void B.foo(), void A.foo() }
     * @param joinPointSignature
     * @param inAWorld
     */
public static JoinPointSignature[] getJoinPointSignatures(Member joinPointSignature, World inAWorld) {
    	
    	// Walk up hierarchy creating one member for each type up to and including the
    	// first defining type
    	ResolvedType originalDeclaringType = joinPointSignature.getDeclaringType().resolve(inAWorld);
    	ResolvedMemberImpl firstDefiningMember = (ResolvedMemberImpl) joinPointSignature.resolve(inAWorld);
    	if (firstDefiningMember == null) {
    		return new JoinPointSignature[0];
    	} 
    	// declaringType can be unresolved if we matched a synthetic member generated by Aj...
    	// should be fixed elsewhere but add this resolve call on the end for now so that we can
    	// focus on one problem at a time...
    	ResolvedType firstDefiningType = firstDefiningMember.getDeclaringType().resolve(inAWorld);
    	if (firstDefiningType != originalDeclaringType) {
    		if (joinPointSignature.getKind() == Member.CONSTRUCTOR) {
    			return new JoinPointSignature[0];
    		} 
//    		else if (shadowMember.isStatic()) {
//    			return new ResolvedMember[] {firstDefiningMember};
//    		}
    	}

    	List declaringTypes = new ArrayList();
    	accumulateTypesInBetween(originalDeclaringType, 
    							 firstDefiningType,
    							 declaringTypes);
    	List memberSignatures = new ArrayList();
    	for (Iterator iter = declaringTypes.iterator(); iter.hasNext();) {
			ResolvedType declaringType = (ResolvedType) iter.next();
			ResolvedMember member = firstDefiningMember.withSubstituteDeclaringType(declaringType);
			memberSignatures.add(member);
		}

    	if (shouldWalkUpHierarchyFor(firstDefiningMember)) {
	       	// now walk up the hierarchy from the firstDefiningMember and include the signature for
	    	// every type between the firstDefiningMember and the root defining member.
	    	Iterator superTypeIterator = firstDefiningType.getDirectSupertypes();
	    	List typesAlreadyVisited = new ArrayList();
	    	accumulateMembersMatching(firstDefiningMember,superTypeIterator,typesAlreadyVisited,memberSignatures);
    	}
    	
    	JoinPointSignature[] ret = new JoinPointSignature[memberSignatures.size()];
    	memberSignatures.toArray(ret);
    	return ret;
    }
================= fetch public void resetReturnTypeToObjectArray() { 27e68f3^:weaver/src/org/aspectj/weaver/JoinPointSignature.java

public void resetReturnTypeToObjectArray() {
		realMember.resetReturnTypeToObjectArray();
	}
================= fetch public void testMultipleAnonymousInnerClasses_pr108104() { 27e68f3^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testMultipleAnonymousInnerClasses_pr108104() {
	  runTest("multiple anonymous inner classes 2");
  }
================= fetch private void weaveAndNotify(UnwovenClassFile classFile, BcelObjectType classType 100d9e0^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java

private void weaveAndNotify(UnwovenClassFile classFile, BcelObjectType classType,
    		                    IWeaveRequestor requestor) throws IOException {
    	LazyClassGen clazz = weaveWithoutDump(classFile,classType);
    	classType.finishedWith();
		//clazz is null if the classfile was unchanged by weaving...
		if (clazz != null) {
			UnwovenClassFile[] newClasses = getClassFilesFor(clazz);
			for (int i = 0; i < newClasses.length; i++) {
				requestor.acceptResult(newClasses[i]);
			}
		} else {
			requestor.acceptResult(classFile);
		}
    }
================= fetch public Collection weave(IClassFileProvider input) throws IOException { 100d9e0^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
// variation of "weave" that sources class files from an external source.
Collection weave(IClassFileProvider input) throws IOException {
    	Collection wovenClassNames = new ArrayList();
    	IWeaveRequestor requestor = input.getRequestor();

    	requestor.processingReweavableState();
		prepareToProcessReweavableState();
		// clear all state from files we'll be reweaving
		for (Iterator i = input.getClassFileIterator(); i.hasNext(); ) {
		    UnwovenClassFile classFile = (UnwovenClassFile)i.next();
			String className = classFile.getClassName();
		    BcelObjectType classType = getClassType(className);			            
			processReweavableStateIfPresent(className, classType);
		}

		requestor.addingTypeMungers();
        
        // We process type mungers in two groups, first mungers that change the type
        // hierarchy, then 'normal' ITD type mungers.
        
        
        // Process the types in a predictable order (rather than the order encountered).
        // For class A, the order is superclasses of A then superinterfaces of A
        // (and this mechanism is applied recursively)
        List typesToProcess = new ArrayList();
        for (Iterator iter = input.getClassFileIterator(); iter.hasNext();) {
			UnwovenClassFile clf = (UnwovenClassFile) iter.next();
            typesToProcess.add(clf.getClassName());
        }
        while (typesToProcess.size()>0) {
            weaveParentsFor(typesToProcess,(String)typesToProcess.get(0));
        }  
        
        for (Iterator i = input.getClassFileIterator(); i.hasNext(); ) {
            UnwovenClassFile classFile = (UnwovenClassFile)i.next();
            String className = classFile.getClassName();
            addNormalTypeMungers(className);
        }

		requestor.weavingAspects();
		// first weave into aspects
		for (Iterator i = input.getClassFileIterator(); i.hasNext(); ) {
		    UnwovenClassFile classFile = (UnwovenClassFile)i.next();
			String className = classFile.getClassName();
		    BcelObjectType classType = BcelWorld.getBcelObjectType(world.resolve(className));
		    if (classType.isAspect()) {
		        weaveAndNotify(classFile, classType,requestor);
		        wovenClassNames.add(className);
		    }
		}

		requestor.weavingClasses();
		// then weave into non-aspects
		for (Iterator i = input.getClassFileIterator(); i.hasNext(); ) {
		    UnwovenClassFile classFile = (UnwovenClassFile)i.next();
			String className = classFile.getClassName();
		    BcelObjectType classType = BcelWorld.getBcelObjectType(world.resolve(className));
		    if (! classType.isAspect()) {
		        weaveAndNotify(classFile, classType, requestor);
		        wovenClassNames.add(className);
		    }
		}
		
		addedClasses = new ArrayList();
		deletedTypenames = new ArrayList();
		
        
		// FIXME asc Should be factored out into Xlint code and done automatically for all xlint messages, ideally.
        // if a piece of advice hasn't matched anywhere and we are in -1.5 mode, put out a warning
        if (world.isInJava5Mode() && 
            world.getLint().adviceDidNotMatch.isEnabled()) {
        	List l = world.getCrosscuttingMembersSet().getShadowMungers();
        	for (Iterator iter = l.iterator(); iter.hasNext();) {
        		ShadowMunger element = (ShadowMunger) iter.next();
        		if (element instanceof BcelAdvice) { // This will stop us incorrectly reporting deow Checkers
                  BcelAdvice ba = (BcelAdvice)element;
                  if (!ba.hasMatchedSomething()) {
					 // Because we implement some features of AJ itself by creating our own kind of mungers, you sometimes
 				     // find that ba.getSignature() is not a BcelMethod - for example it might be a cflow entry munger.
	                 if (ba.getSignature()!=null) {
					   if (!(ba.getSignature() instanceof BcelMethod)
					       || !Utility.isSuppressing((AnnotationX[])ba.getSignature().getAnnotations(),"adviceDidNotMatch")) {
					        world.getLint().adviceDidNotMatch.signal(ba.getDeclaringAspect().toString(),element.getSourceLocation());
					   }							  
                     }
                  }
        		}
        	}
        }

        requestor.weaveCompleted();
    	return wovenClassNames;
    }
================= fetch public ConcreteTypeMunger makePerClauseAspect(ResolvedType aspect, PerClause.Kin 100d9e0^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java
/**
     * Register a munger for perclause @AJ aspect so that we add aspectOf(..) to them as needed
     *
     * @param aspect
     * @param kind
     * @return
     */
public ConcreteTypeMunger makePerClauseAspect(ResolvedType aspect, PerClause.Kind kind) {
        return new BcelPerClauseAspectAdder(aspect, kind);
    }
================= fetch public static BcelObjectType getBcelObjectType(ResolvedType concreteAspect) { 100d9e0^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java

public static BcelObjectType getBcelObjectType(ResolvedType concreteAspect) {
		//XXX need error checking
		return (BcelObjectType) ((ReferenceType)concreteAspect).getDelegate();
	}
================= fetch public SWITCH(int[] match, InstructionHandle[] targets, bf767a9^:bcel-builder/src/org/aspectj/apache/bcel/generic/SWITCH.java

================= fetch public TABLESWITCH(int[] match, InstructionHandle[] targets, bf767a9^:bcel-builder/src/org/aspectj/apache/bcel/generic/TABLESWITCH.java

================= fetch public void dump(DataOutputStream out) throws IOException { bf767a9^:bcel-builder/src/org/aspectj/apache/bcel/generic/TABLESWITCH.java
/**
   * Dump instruction as byte code to stream out.
   * @param out Output stream
   */
public void dump(DataOutputStream out) throws IOException {
    super.dump(out);

    int low = (match_length > 0)? match[0] : 0;
    out.writeInt(low);

    int high = (match_length > 0)? match[match_length - 1] : 0;
    out.writeInt(high);

    for(int i=0; i < match_length; i++)     // jump offsets
      out.writeInt(indices[i] = getTargetOffset(targets[i]));
  }
Progress : [#############################-----------] 74%================= fetch public static ResolvedMember privilegedAccessMethodForMethod(UnresolvedType aspe cc6e681^:weaver/src/org/aspectj/weaver/AjcMemberMaker.java
// -- privileged accessors
public static ResolvedMember privilegedAccessMethodForMethod(UnresolvedType aspectType, ResolvedMember method) {
		String sig = method.getDeclaredSignature();
		return new ResolvedMemberImpl(Member.METHOD,
			method.getDeclaringType(),
			Modifier.PUBLIC | (method.isStatic() ? Modifier.STATIC : 0),
			NameMangler.privilegedAccessMethodForMethod(method.getName(),
												method.getDeclaringType(), aspectType),
			sig);
			//XXX needs thrown exceptions to be correct
	}
================= fetch public void testDeclareSoftInGenericAspect() { cc6e681^:tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java
//	public void testGenericITDsBridgeMethods3binary()  {runTest("bridge methods -3binary");}
public void testGenericITDsBridgeMethodsPR91381()  {runTest("abstract intertype methods and covariant returns");}
================= fetch public void testMultipleAnonymousInnerClasses() { cc6e681^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testMultipleAnonymousInnerClasses() {
	  runTest("multiple anonymous inner classes");
  }
================= fetch public Pointcut concretize1(ResolvedType searchStart, IntMap bindings) { 93fdce1^:weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java

public Pointcut concretize1(ResolvedType searchStart, IntMap bindings) {
		if (concretizing) {
			//Thread.currentThread().dumpStack();
			searchStart.getWorld().getMessageHandler().handleMessage(
				MessageUtil.error(WeaverMessages.format(WeaverMessages.CIRCULAR_POINTCUT,this),
									getSourceLocation()));
			return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
		}
		
		try {
			concretizing = true;
		
			ResolvedPointcutDefinition pointcutDec;
			if (onType != null) {
				searchStart = onType.resolve(searchStart.getWorld());
				if (searchStart == ResolvedType.MISSING) {
					return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
				}
			}
			pointcutDec = searchStart.findPointcut(name);
			if (pointcutDec == null) {
				searchStart.getWorld().getMessageHandler().handleMessage(
					MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_FIND_POINTCUT,name,searchStart.getName()), 
									getSourceLocation())
				);
				return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
			}
			
			if (pointcutDec.isAbstract()) {
				//Thread.currentThread().dumpStack();
				ShadowMunger enclosingAdvice = bindings.getEnclosingAdvice();
				searchStart.getWorld().showMessage(IMessage.ERROR,
						WeaverMessages.format(WeaverMessages.ABSTRACT_POINTCUT,pointcutDec), 
						getSourceLocation(), 
						(null == enclosingAdvice) ? null : enclosingAdvice.getSourceLocation());
				return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
			}
					
			//System.err.println("start: " + searchStart);
			ResolvedType[] parameterTypes = searchStart.getWorld().resolve(pointcutDec.getParameterTypes());
			
			TypePatternList arguments = this.arguments.resolveReferences(bindings);
			
			IntMap newBindings = new IntMap();
			for (int i=0,len=arguments.size(); i < len; i++) {
				TypePattern p = arguments.get(i);
				//we are allowed to bind to pointcuts which use subtypes as this is type safe
				if (!p.matchesSubtypes(parameterTypes[i])  && 
					!p.getExactType().equals(UnresolvedType.OBJECT))
				{
					throw new BCException("illegal change to pointcut declaration: " + this);
				}
				
			    if (p instanceof BindingTypePattern) {
			    	newBindings.put(i, ((BindingTypePattern)p).getFormalIndex());
			    }
			}
			
			if (searchStart.isParameterizedType()) {
				// build a type map mapping type variable names in the generic type to
				// the type parameters presented
				typeVariableMap = new HashMap();
				ResolvedType underlyingGenericType = searchStart.getGenericType();
				TypeVariable[] tVars = underlyingGenericType.getTypeVariables();
				ResolvedType[] typeParams = searchStart.getResolvedTypeParameters();
				for (int i = 0; i < tVars.length; i++) {
					typeVariableMap.put(tVars[i].getName(),typeParams[i]);
				}
			}
			
			newBindings.copyContext(bindings);
			newBindings.pushEnclosingDefinition(pointcutDec);
			try {
				Pointcut ret = pointcutDec.getPointcut();
				if (typeVariableMap != null) ret = ret.parameterizeWith(typeVariableMap);
				return ret.concretize(searchStart, newBindings);
			} finally {
				newBindings.popEnclosingDefinitition();
			}
			
		} finally {
			concretizing = false;
		}
	}
================= fetch public void testAtSuppressWarnings() { 93fdce1^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testAtSuppressWarnings() {
	  runTest("@SuppressWarnings should suppress");
  }
================= fetch public void testPointcutOverriding() { 7b32570^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testPointcutOverriding() {
	  runTest("overriding final pointcut from super-aspect");
  }
================= fetch private boolean isDuplicateMemberWithinTargetType(ResolvedMember existingMember, 86ce1f7^:weaver/src/org/aspectj/weaver/ResolvedType.java
// signature AND more than one of them is concrete AND they are both visible within the target type.
private boolean isDuplicateMemberWithinTargetType(ResolvedMember existingMember, ResolvedType targetType,ResolvedMember itdMember) {
	    if ( (existingMember.isAbstract() || itdMember.isAbstract())) return false;
	    UnresolvedType declaringType = existingMember.getDeclaringType();
	    if (!targetType.equals(declaringType)) return false;
	    // now have to test that itdMember is visible from targetType
	    if (itdMember.isPrivate()) return false;
	    if (itdMember.isPublic()) return true;
	    // must be in same package to be visible then...
	    if (!targetType.getPackageName().equals(itdMember.getDeclaringType().getPackageName())) return false;
	    
	    // trying to put two members with the same signature into the exact same type..., and both visible in that type.
	    return true;
	}
================= fetch public boolean checkLegalOverride(ResolvedMember parent, ResolvedMember child) { 86ce1f7^:weaver/src/org/aspectj/weaver/ResolvedType.java
/**
	 * @return true if the override is legal
	 */
public boolean checkLegalOverride(ResolvedMember parent, ResolvedMember child) {
		//System.err.println("check: " + child.getDeclaringType() + " overrides " + parent.getDeclaringType());
		if (!parent.getReturnType().equals(child.getReturnType())) {
			world.showMessage(IMessage.ERROR,
					WeaverMessages.format(WeaverMessages.ITD_RETURN_TYPE_MISMATCH,parent,child),
					child.getSourceLocation(), parent.getSourceLocation());
			return false;
		}		
		if (parent.getKind() == Member.POINTCUT) {
			UnresolvedType[] pTypes = parent.getParameterTypes();
			UnresolvedType[] cTypes = child.getParameterTypes();
			if (!Arrays.equals(pTypes, cTypes)) {
				world.showMessage(IMessage.ERROR,
						WeaverMessages.format(WeaverMessages.ITD_PARAM_TYPE_MISMATCH,parent,child),
						child.getSourceLocation(), parent.getSourceLocation());
				return false;
			}
		}		
		//System.err.println("check: " + child.getModifiers() + " more visible " + parent.getModifiers());
		if (isMoreVisible(parent.getModifiers(), child.getModifiers())) {
			world.showMessage(IMessage.ERROR,
					WeaverMessages.format(WeaverMessages.ITD_VISIBILITY_REDUCTION,parent,child),
					child.getSourceLocation(), parent.getSourceLocation());
			return false;
		}
		
		// check declared exceptions
		ResolvedType[] childExceptions = world.resolve(child.getExceptions());
		ResolvedType[] parentExceptions = world.resolve(parent.getExceptions());
		ResolvedType runtimeException = world.resolve("java.lang.RuntimeException");
		ResolvedType error = world.resolve("java.lang.Error");
		
		outer: for (int i=0, leni = childExceptions.length; i < leni; i++) {
			//System.err.println("checking: " + childExceptions[i]);
			if (runtimeException.isAssignableFrom(childExceptions[i])) continue;
			if (error.isAssignableFrom(childExceptions[i])) continue;
			
			for (int j = 0, lenj = parentExceptions.length; j < lenj; j++) {
				if (parentExceptions[j].isAssignableFrom(childExceptions[i])) continue outer;
			}
			
			world.showMessage(IMessage.ERROR,
					WeaverMessages.format(WeaverMessages.ITD_DOESNT_THROW,childExceptions[i].getName()),
					child.getSourceLocation(), null);
						
			return false;
		}
		if (parent.isStatic() && !child.isStatic()) {
			world.showMessage(IMessage.ERROR,
					WeaverMessages.format(WeaverMessages.ITD_OVERRIDDEN_STATIC,child,parent),
					child.getSourceLocation(),null);
		} else if (child.isStatic() && !parent.isStatic()) {
			world.showMessage(IMessage.ERROR,
					WeaverMessages.format(WeaverMessages.ITD_OVERIDDING_STATIC,child,parent),
					child.getSourceLocation(),null);
		}
		return true;
		
	}
================= fetch public void testDetectVoidFieldType() { 86ce1f7^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testDetectVoidFieldType() {
	  runTest("void field type in pointcut expression");
  }
================= fetch public void testNoBeforeReturningAdvice() { 2b23e91^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testNoBeforeReturningAdvice() {
	  runTest("before returning advice not allowed!");
  }
================= fetch public void testAjKeywordsAsIdentifiers() { 169a488^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testAjKeywordsAsIdentifiers() {
	  runTest("before and after are valid identifiers in classes");
  }
Progress : [##############################----------] 75%================= fetch public void testBadRuntimeTestGeneration() { 5e9aca9^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testBadRuntimeTestGeneration() {
	  runTest("target(@Foo *)");
  }
================= fetch public void testIfEvaluationExplosion_pr94086() { 477c575^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testMissingNamePattern_pr106461() { runTest("missing name pattern"); }
================= fetch public NamePattern extractName() { 5735e96^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java

public NamePattern extractName() {
		//System.err.println("extract from : " + Arrays.asList(namePatterns));
		int len = namePatterns.length;
		NamePattern ret = namePatterns[len-1];
		NamePattern[] newNames = new NamePattern[len-1];
		System.arraycopy(namePatterns, 0, newNames, 0, len-1);
		namePatterns = newNames;
		//System.err.println("    left : " + Arrays.asList(namePatterns));
		return ret;
	}
================= fetch public SignaturePattern parseFieldSignaturePattern() { 5735e96^:weaver/src/org/aspectj/weaver/patterns/PatternParser.java

public SignaturePattern parseFieldSignaturePattern() {
		int startPos = tokenSource.peek().getStart();
		
	//	TypePatternList followMe = TypePatternList.ANY;
		
		AnnotationTypePattern annotationPattern = maybeParseAnnotationPattern();
		ModifiersPattern modifiers = parseModifiersPattern();
		TypePattern returnType = parseTypePattern();
		TypePattern declaringType = parseTypePattern();
		NamePattern name;
		//System.err.println("parsed field: " + declaringType.toString());
		if (maybeEat(".")) {
		    name = parseNamePattern();
	    } else {
	    	name = tryToExtractName(declaringType);
	    	if (declaringType.toString().equals("")) {
	    		declaringType = TypePattern.ANY;
	    	}
		}
		SignaturePattern ret = new SignaturePattern(Member.FIELD, modifiers, returnType,
					declaringType, name, TypePatternList.ANY, ThrowsPattern.ANY,annotationPattern);
					
		int endPos = tokenSource.peek(-1).getEnd();
	    ret.setLocation(sourceContext, startPos, endPos);
		return ret;
	}
================= fetch public void testIfEvaluationExplosion_pr94086() { 5735e96^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testSyntaxErrorNPE_pr103266() {runTest("NPE on syntax error");}
================= fetch private void matchInvokeInstruction(LazyMethodGen mg, 619a6ad^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

private void matchInvokeInstruction(LazyMethodGen mg,
		InstructionHandle ih,
		InvokeInstruction invoke,
		BcelShadow enclosingShadow,
		List shadowAccumulator) 
	{
		String methodName = invoke.getName(cpg);
		if (methodName.startsWith(NameMangler.PREFIX)) {
			Member method =
				BcelWorld.makeMethodSignature(clazz, invoke);
			ResolvedMember declaredSig = method.resolve(world);
			//System.err.println(method + ", declaredSig: "  +declaredSig);
			if (declaredSig == null) return;
			
			if (declaredSig.getKind() == Member.FIELD) {
				Shadow.Kind kind;
				if (method.getReturnType().equals(ResolvedType.VOID)) {
					kind = Shadow.FieldSet;
				} else {
					kind = Shadow.FieldGet;
				}
				
				if (canMatch(Shadow.FieldGet) || canMatch(Shadow.FieldSet))
					match(BcelShadow.makeShadowForMethodCall(world, mg, ih, enclosingShadow,
							kind, declaredSig),
							shadowAccumulator);
			} else {
				AjAttribute.EffectiveSignatureAttribute effectiveSig =
					declaredSig.getEffectiveSignature();
				if (effectiveSig == null) return;
				//System.err.println("call to inter-type member: " + effectiveSig);
				if (effectiveSig.isWeaveBody()) return;

				
			    ResolvedMember rm = effectiveSig.getEffectiveSignature();
				
				fixAnnotationsForResolvedMember(rm,declaredSig); // abracadabra
			  
				if (canMatch(effectiveSig.getShadowKind())) 
					match(BcelShadow.makeShadowForMethodCall(world, mg, ih, enclosingShadow,
							effectiveSig.getShadowKind(), rm), shadowAccumulator);
			}
		} else {
			if (canMatch(Shadow.MethodCall))
				match(
						BcelShadow.makeMethodCall(world, mg, ih, enclosingShadow),
						shadowAccumulator);
		}
	}
================= fetch public Member makeMethodSignature(LazyMethodGen mg, Member.Kind kind) { 619a6ad^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java

public Member makeMethodSignature(LazyMethodGen mg, Member.Kind kind) {
		ResolvedMember ret = mg.getMemberView();
		if (ret == null) {
	        int mods = mg.getAccessFlags();
	        if (mg.getEnclosingClass().isInterface()) {
	            mods |= Modifier.INTERFACE;
	        }
	        if (kind == null) {
		        if (mg.getName().equals("<init>")) {
		        	kind = Member.CONSTRUCTOR;
		        } else if (mg.getName().equals("<clinit>")) {
		        	kind = Member.STATIC_INITIALIZATION;
		        } else {
		        	kind = Member.METHOD;
		        }
	        }
	        return new ResolvedMember(kind,
	                UnresolvedType.forName(mg.getClassName()), 
	                mods,
	                fromBcel(mg.getReturnType()),
	                mg.getName(),
	                fromBcel(mg.getArgumentTypes())
	                );
		} else {
			return ret;
		}
        
    }
================= fetch public static BcelShadow makeConstructorCall( 619a6ad^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
// all the arguments in temps.
public static BcelShadow makeConstructorCall(
        BcelWorld world,
        LazyMethodGen enclosingMethod,
        InstructionHandle callHandle, 
        BcelShadow enclosingShadow) 
    {
        final InstructionList body = enclosingMethod.getBody();
        
        Member sig = BcelWorld.makeMethodSignature(
                    	enclosingMethod.getEnclosingClass(),
                    	(InvokeInstruction) callHandle.getInstruction());
                    
		BcelShadow s = 
			new BcelShadow(
				world,
				ConstructorCall,
				sig,
                enclosingMethod, 
                enclosingShadow);
        ShadowRange r = new ShadowRange(body);
        r.associateWithShadow(s);
        r.associateWithTargets(
        	Range.genStart(body, callHandle),
            Range.genEnd(body, callHandle));
        retargetAllBranches(callHandle, r.getStart());                
        return s;
    }
================= fetch public static BcelShadow makeMethodCall( 619a6ad^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public static BcelShadow makeMethodCall(
            BcelWorld world,
            LazyMethodGen enclosingMethod,
            InstructionHandle callHandle,
            BcelShadow enclosingShadow) 
    {
        final InstructionList body = enclosingMethod.getBody();
        BcelShadow s =
            new BcelShadow(
                world,
                MethodCall,
                BcelWorld.makeMethodSignature(
                    enclosingMethod.getEnclosingClass(),
                    (InvokeInstruction) callHandle.getInstruction()),
                enclosingMethod,
                enclosingShadow);
        ShadowRange r = new ShadowRange(body);
        r.associateWithShadow(s);
        r.associateWithTargets(
        	Range.genStart(body, callHandle),
            Range.genEnd(body, callHandle));                
        retargetAllBranches(callHandle, r.getStart());
        return s;
    }
================= fetch public static Member makeMethodSignature(LazyClassGen cg, InvokeInstruction ii) 619a6ad^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java

public static Member makeMethodSignature(LazyClassGen cg, InvokeInstruction ii) {
    	ConstantPoolGen cpg = cg.getConstantPoolGen();
        String declaring = ii.getClassName(cpg);
        String name = ii.getName(cpg);
        String signature = ii.getSignature(cpg);
        
        int modifier = 
            (ii instanceof INVOKEINTERFACE)
            ? Modifier.INTERFACE
            : (ii instanceof INVOKESTATIC)
              ? Modifier.STATIC
              : (ii instanceof INVOKESPECIAL && ! name.equals("<init>"))
                ? Modifier.PRIVATE
                : 0;
        return Member.method(UnresolvedType.forName(declaring), modifier, name, signature);
    }
================= fetch public void testMultipleBinding() { 619a6ad^:tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjSyntaxTests.java

public void testMultipleBinding() {
        runTest("MultipleBinding");
    }
================= fetch public void endVisit(ConstructorDeclaration decl, ClassScope scope) { bba9c50^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/MakeDeclsPublicVisitor.java

public void endVisit(ConstructorDeclaration decl, ClassScope scope) {
		decl.binding.modifiers = AstUtil.makePublic(decl.binding.modifiers);
	}
================= fetch public void endVisit(FieldDeclaration decl, MethodScope scope) { bba9c50^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/MakeDeclsPublicVisitor.java

public void endVisit(FieldDeclaration decl, MethodScope scope) {
		decl.binding.modifiers = AstUtil.makePublic(decl.binding.modifiers);
	}
================= fetch public void endVisit(MethodDeclaration decl, ClassScope scope) { bba9c50^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/MakeDeclsPublicVisitor.java

public void endVisit(MethodDeclaration decl, ClassScope scope) {
		decl.binding.modifiers = AstUtil.makePublic(decl.binding.modifiers);
	}
================= fetch public void endVisit( bba9c50^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/MakeDeclsPublicVisitor.java
/* (non-Javadoc)
	 * @see org.eclipse.jdt.internal.compiler.ASTVisitor#endVisit(org.eclipse.jdt.internal.compiler.ast.TypeDeclaration, org.eclipse.jdt.internal.compiler.lookup.ClassScope)
	 */
public void endVisit(
		TypeDeclaration memberTypeDeclaration,
		ClassScope scope) {
		memberTypeDeclaration.binding.modifiers = AstUtil.makePublic(memberTypeDeclaration.binding.modifiers);
	}
================= fetch public void testIfEvaluationExplosion_pr94086() { bba9c50^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testItdGenerics_pr100260() {runTest("methods inherited from a generic parent");}
================= fetch public InstructionList getAdviceArgSetup( 639b4fd^:weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java

public InstructionList getAdviceArgSetup(
		BcelShadow shadow,
		BcelVar extraVar,
		InstructionList closureInstantiation) 
	{
        InstructionFactory fact = shadow.getFactory();
        BcelWorld world = shadow.getWorld();
        InstructionList il = new InstructionList();

//        if (targetAspectField != null) {
//        	il.append(fact.createFieldAccess(
//        		targetAspectField.getDeclaringType().getName(),
//        		targetAspectField.getName(),
//        		BcelWorld.makeBcelType(targetAspectField.getType()),
//        		Constants.GETSTATIC));
//        }
//        
		//System.err.println("BcelAdvice: " + exposedState);


		if (exposedState.getAspectInstance() != null) {
			il.append(
				BcelRenderer.renderExpr(fact, world, exposedState.getAspectInstance()));
		}
        for (int i = 0, len = exposedState.size(); i < len; i++) {
        	if (exposedState.isErroneousVar(i)) continue; // Erroneous vars have already had error msgs reported!
            BcelVar v = (BcelVar) exposedState.get(i);

            if (v == null) {
                // if not @AJ aspect, go on with the regular binding handling
            	if (getConcreteAspect()==null || !getConcreteAspect().isAnnotationStyleAspect()) {
            		;
            	} else {
                    // ATAJ: for @AJ aspects, handle implicit binding of xxJoinPoint
	                if (getKind() == AdviceKind.Around) {
	                    il.append(closureInstantiation);
	                } else if ("Lorg/aspectj/lang/JoinPoint$StaticPart;".equals(getSignature().getParameterTypes()[i].getSignature())) {
	                    if ((getExtraParameterFlags() & ThisJoinPointStaticPart) != 0) {
	                        shadow.getThisJoinPointStaticPartBcelVar().appendLoad(il, fact);
	                    }
	                } else if ("Lorg/aspectj/lang/JoinPoint;".equals(getSignature().getParameterTypes()[i].getSignature())) {
	                    if ((getExtraParameterFlags() & ThisJoinPoint) != 0) {
	                        il.append(shadow.loadThisJoinPoint());
	                    }
	                } else if ("Lorg/aspectj/lang/JoinPoint$EnclosingStaticPart;".equals(getSignature().getParameterTypes()[i].getSignature())) {
	                    if ((getExtraParameterFlags() & ThisEnclosingJoinPointStaticPart) != 0) {
	                        shadow.getThisEnclosingJoinPointStaticPartBcelVar().appendLoad(il, fact);
	                    }
	                } else if (hasExtraParameter()) {
	                    extraVar.appendLoadAndConvert(
	                        il,
	                        fact,
	                        getExtraParameterType().resolve(world));
	                } else {
                        getConcreteAspect().getWorld().getMessageHandler().handleMessage(
                                new Message(
                                        "use of ProceedingJoinPoint is allowed only on around advice ("
                                        + "arg " + i + " in " + toString() + ")",
                                        this.getSourceLocation(),
                                        true
                                )
                        );
                        // try to avoid verify error and pass in null
                        il.append(InstructionConstants.ACONST_NULL);
	                }
            	}
            } else {
                TypeX desiredTy = getSignature().getParameterTypes()[i];
                v.appendLoadAndConvert(il, fact, desiredTy.resolve(world));
            }
        }

        
        // ATAJ: for code style aspect, handles the extraFlag as usual ie not
        // in the middle of the formal bindings but at the end, in a rock solid ordering
        if (getConcreteAspect()==null || !getConcreteAspect().isAnnotationStyleAspect()) {
            if (getKind() == AdviceKind.Around) {
                il.append(closureInstantiation);
            } else if (hasExtraParameter()) {
                extraVar.appendLoadAndConvert(
                    il,
                    fact,
                    getExtraParameterType().resolve(world));
            }

            // handle thisJoinPoint parameters
            // these need to be in that same order as parameters in
            // org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration
            if ((getExtraParameterFlags() & ThisJoinPointStaticPart) != 0) {
                shadow.getThisJoinPointStaticPartBcelVar().appendLoad(il, fact);
            }

            if ((getExtraParameterFlags() & ThisJoinPoint) != 0) {
                il.append(shadow.loadThisJoinPoint());
            }

            if ((getExtraParameterFlags() & ThisEnclosingJoinPointStaticPart) != 0) {
                shadow.getThisEnclosingJoinPointStaticPartBcelVar().appendLoad(il, fact);
            }
        }


        return il;
    }
================= fetch public void before(String s, JoinPoint.StaticPart sjp) { 639b4fd^:tests/java5/ataspectj/ataspectj/SingletonAspectBindingsTest.java
// 2/ the advice is register thru its Bcel Method mirror
@Before("execution(* ataspectj.SingletonAspectBindingsTest.hello(String)) && args(s)")
        public void before(String s, JoinPoint.StaticPart sjp) {
            log("before-");
            log(s);
            assertEquals("hello", sjp.getSignature().getName());
        }
================= fetch public void testIfPointcut2() { 639b4fd^:tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjSyntaxTests.java

public void testIfPointcut2() {
        runTest("IfPointcut2Test");
    }
================= fetch public void testSingletonAspectBindings() { 639b4fd^:tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjSyntaxTests.java

public void testSingletonAspectBindings() {
        //Note AV: uncomment setReporting to get it in modules/tests folder
        org.aspectj.asm.AsmManager.setReporting("debug.txt",true,true,true,true);
        runTest("singletonAspectBindings");
        // same stuff with AJ
        //org.aspectj.asm.AsmManager.setReporting("debug-aj.txt",true,true,true,true);
        //runTest("singletonAspectBindings2");

    }
Progress : [##############################----------] 76%================= fetch public void testIfEvaluationExplosion_pr94086() { b54831f^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testItdGenerics_pr100227() {runTest("inner class with generic enclosing class");}
================= fetch public String getBaseName() { 7d5002a^:weaver/src/org/aspectj/weaver/TypeX.java
/**
     * Returns an array of strings representing the java langauge names of 
     * an array of types.
     *
     * @param types an array of TypeX objects
     * @return an array of Strings fo the java language names of types.
     * @see #getName()
     */
public static String[] getNames(TypeX[] types) {
        String[] ret = new String[types.length];
        for (int i = 0, len = types.length; i < len; i++) {
            ret[i] = types[i].getName();
        }
        return ret;
    }
================= fetch public final boolean isArray() { 7d5002a^:weaver/src/org/aspectj/weaver/TypeX.java
/**
     * Determins if this represents an array type.
     *
     * @return  true iff this represents an array type.
     */
public final boolean isArray() {
        return signature.startsWith("[");
    }
================= fetch public final boolean isParameterized() { 7d5002a^:weaver/src/org/aspectj/weaver/TypeX.java
/**
	 * Determines if this represents a parameterized type.
	 */
public final boolean isParameterized() {
		return isParameterized;
//		return signature.indexOf("<") != -1; 
//		//(typeParameters != null) && (typeParameters.length > 0);
	}
================= fetch public final boolean isRawType() { 7d5002a^:weaver/src/org/aspectj/weaver/TypeX.java

public final boolean isRawType() { 
	    return isParameterized && typeParameters==null;
	}
================= fetch public static TypeX forParameterizedTypeNames(String name, String[] paramTypeNam 7d5002a^:weaver/src/org/aspectj/weaver/TypeX.java
/**
	 * Makes a parameterized type with the given name
	 * and parameterized type names.
	 */
public static TypeX forParameterizedTypeNames(String name, String[] paramTypeNames) {
		TypeX ret = TypeX.forName(name);
		ret.setParameterized(true);
		ret.typeParameters = new TypeX[paramTypeNames.length];
		for (int i = 0; i < paramTypeNames.length; i++) {
			ret.typeParameters[i] = TypeX.forName(paramTypeNames[i]);
		}
		ret.rawTypeSignature = ret.signature;
		// sig for e.g. List<String> is Ljava/util/List<Ljava/lang/String;>;
		StringBuffer sigAddition = new StringBuffer();
		sigAddition.append("<");
		for (int i = 0; i < ret.typeParameters.length; i++) {
			sigAddition.append(ret.typeParameters[i].signature);			
		}
		sigAddition.append(">");
		sigAddition.append(";");
		ret.signature = ret.signature.substring(0,ret.signature.length()-1) + sigAddition.toString();
		return ret;
    }
================= fetch public static TypeX forRawTypeNames(String name) { 7d5002a^:weaver/src/org/aspectj/weaver/TypeX.java
/**
	 * Creates a new type array with a fresh type inserted at the beginning.
	 * 
	 * 
	 * @param start the left hand side of the new array
	 * @param types the right hand side of the new array
	 */
public static TypeX[] insert(TypeX start, TypeX[] types) {
		int len = types.length;
		TypeX[] ret = new TypeX[len + 1];
		ret[0] = start;
		System.arraycopy(types, 0, ret, 1, len);
		return ret;
    }
================= fetch public static TypeX fromBinding(TypeBinding binding) { 7d5002a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

public static TypeX[] fromBindings(TypeBinding[] bindings) {
		if (bindings == null) return TypeX.NONE;
		int len = bindings.length;
		TypeX[] ret = new TypeX[len];
		for (int i=0; i<len; i++) {
			ret[i] = fromBinding(bindings[i]);
		}
		return ret;
	}
================= fetch public void testIfEvaluationExplosion_pr94086() { 7d5002a^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testItdGenerics_pr98320() {runTest("intertype with nested generic type");}
================= fetch private SourceTypeBinding makeSourceTypeBinding(ReferenceBinding onType) { 588023e^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeScope.java
// this method depends on the fact that BinaryTypeBinding extends SourceTypeBinding
private SourceTypeBinding makeSourceTypeBinding(ReferenceBinding onType) {
		if (onType instanceof SourceTypeBinding) return (SourceTypeBinding)onType;
		else throw new RuntimeException("can't handle: " + onType);
	}
================= fetch public void testReflectNPE_pr94167() { f747b82^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testReflectNPE_pr94167() {
	  runTest("NPE in reflect implementation");
  }
================= fetch public List parseDottedNamePattern() { 743566f^:weaver/src/org/aspectj/weaver/patterns/PatternParser.java

public List parseDottedNamePattern() {
		List names = new ArrayList();
		StringBuffer buf = new StringBuffer();
		IToken previous = null;
		boolean justProcessedEllipsis = false; // Remember if we just dealt with an ellipsis (PR61536)
		boolean justProcessedDot = false; 
		boolean onADot = false;

		while (true) {
			IToken tok = null;
			int startPos = tokenSource.peek().getStart();
			String afterDot = null;
			while (true) {
				if (previous !=null && previous.getString().equals(".")) justProcessedDot = true;
				tok = tokenSource.peek();
				onADot = (tok.getString().equals("."));
				if (previous != null) {
					if (!isAdjacent(previous, tok)) break;
				}
				if (tok.getString() == "*" || tok.isIdentifier()) {
					buf.append(tok.getString());
				} else if (tok.getLiteralKind() != null) {
					//System.err.println("literal kind: " + tok.getString());
					String s = tok.getString();
					int dot = s.indexOf('.');
					if (dot != -1) {
						buf.append(s.substring(0, dot));
						afterDot = s.substring(dot+1);
						previous = tokenSource.next();
						break;
					}
					buf.append(s);  // ??? so-so
				} else {
					break;
				}
				previous = tokenSource.next();
				//XXX need to handle floats and other fun stuff
			}
			int endPos = tokenSource.peek(-1).getEnd();
			if (buf.length() == 0 && names.isEmpty()) {
				throw new ParserException("name pattern", tok);
			} 
			
			if (buf.length() == 0 && justProcessedEllipsis) {
				throw new ParserException("name pattern cannot finish with ..", tok);
			}
			if (buf.length() == 0 && justProcessedDot && !onADot) {
					throw new ParserException("name pattern cannot finish with .", tok);
			}
			
			if (buf.length() == 0) {
				names.add(NamePattern.ELLIPSIS);
				justProcessedEllipsis = true;
			} else {
				checkLegalName(buf.toString(), previous);
				NamePattern ret = new NamePattern(buf.toString());
				ret.setLocation(sourceContext, startPos, endPos);
				names.add(ret);
				justProcessedEllipsis = false;
			}
			
			if (afterDot == null) {
				buf.setLength(0);
//                //FIXME AV for Adrian - the following does not works in the general case
//                //varargs lookahead
//                IToken next_1 = tokenSource.peek();
//                if (!IToken.EOF.equals(next_1) && next_1.getString().equals(".")) {
//                    IToken next_2 = tokenSource.peek(1);
//                    if (!IToken.EOF.equals(next_2) && next_2.getString().equals(".")) {
//                        IToken next_3 = tokenSource.peek(2);
//                        if (!IToken.EOF.equals(next_3) && next_3.getString().equals(".")) {
//                            // happens to be a varargs
//                            break;
//                        }
//                    }
//                }
				// no elipsis or dotted name part
                if (!maybeEat(".")) break;
                // go on
				else previous = tokenSource.peek(-1);
			} else {
				buf.setLength(0);
				buf.append(afterDot);
				afterDot = null;
			}
		}
		//System.err.println("parsed: " + names);
		return names;
	}
================= fetch public TypePattern parseSingleTypePattern() { 743566f^:weaver/src/org/aspectj/weaver/patterns/PatternParser.java

public TypePattern parseSingleTypePattern() {
		List names = parseDottedNamePattern(); 
//		new ArrayList();
//		NamePattern p1 = parseNamePattern();
//		names.add(p1);
//		while (maybeEat(".")) {
//			if (maybeEat(".")) {
//				names.add(NamePattern.ELLIPSIS);
//			}
//			NamePattern p2 = parseNamePattern();
//			names.add(p2);
//		}
		int dim = 0;
		while (maybeEat("[")) {
			eat("]");
			dim++;
		}

        // FIXME AV for Adrian - varargs need special handling since Token are 3x"." and not "..."
        // the following works for 'call(* *(int, Integer...))' but not in the general case (see testAJDKExamples test f.e.)
        // and the current code does not work for 'call(* *(int, Integer...))'
//        int varargDot = 0;
//        while (maybeEat(".")) {
//            varargDot++;
//        }
//        boolean isVarArgs = false;
//        if (varargDot > 0) {
//            if (varargDot == 3) {
//                isVarArgs = true;
//            } else {
//                throw new ParserException("Invalid varargs", tokenSource.peek());
//            }
//        }
        boolean isVarArgs = maybeEat("...");

		boolean includeSubtypes = maybeEat("+");
		int endPos = tokenSource.peek(-1).getEnd();
		
		//??? what about the source location of any's????
		if (names.size() == 1 && ((NamePattern)names.get(0)).isAny() && dim == 0 && !isVarArgs) return TypePattern.ANY;
		
		// Notice we increase the dimensions if varargs is set.  this is to allow type matching to
		// succeed later: The actual signature at runtime of a method declared varargs is an array type of
		// the original declared type (so Integer... becomes Integer[] in the bytecode).  So, here for the
		// pattern 'Integer...' we create a WildTypePattern 'Integer[]' with varargs set.  If this matches
		// during shadow matching, we confirm that the varargs flags match up before calling it a successful
		// match.
		return new WildTypePattern(names, includeSubtypes, dim+(isVarArgs?1:0), endPos,isVarArgs);
	}
================= fetch public void testMock() { 743566f^:weaver/testsrc/org/aspectj/weaver/patterns/VisitorTestCase.java

public void testMock() {
        //empty so that JUnit does not complain about no test cases in there - this one beeing already in the suite
    }
================= fetch static ITokenSource makeTokenSource(String input, ISourceContext context) { 743566f^:weaver/src/org/aspectj/weaver/patterns/BasicTokenSource.java
// Convenience, maybe just for testing
static ITokenSource makeTokenSource(String input, ISourceContext context) {
		char[] chars = input.toCharArray();
		
		int i = 0;
		List tokens = new ArrayList();
		
		while (i < chars.length) {
			char ch = chars[i++];			
			switch(ch) {
				case ' ':
				case '\t':
				case '\n':
				case '\r':
					continue;
				case '*':
				case '.':
				case '(':
				case ')':
				case '+':
				case '[':
				case ']':
				case ',':
				case '!':
				case ':':
				case '@':
				    tokens.add(BasicToken.makeOperator(makeString(ch), i-1, i-1));
				    continue;
				case '&':
				case '|':
				    if (i == chars.length) {
				    	throw new BCException("bad " + ch);
				    }
				    char nextChar = chars[i++];
				    if (nextChar == ch) {
				    	tokens.add(BasicToken.makeOperator(makeString(ch, 2), i-2, i-1));
				    } else {
				    	throw new RuntimeException("bad " + ch);
				    }
				    continue;
				    
				case '\"':
				    int start0 = i-1;
				    while (i < chars.length && !(chars[i]=='\"')) i++;
				    i += 1;
				    tokens.add(BasicToken.makeLiteral(new String(chars, start0+1, i-start0-2), "string", start0, i-1));
				    continue;
				default:
				    int start = i-1;
				    while (i < chars.length && Character.isJavaIdentifierPart(chars[i])) { i++; }
				    tokens.add(BasicToken.makeIdentifier(new String(chars, start, i-start), start, i-1));
				
			}
		}

		//System.out.println(tokens);
		
		return new BasicTokenSource((IToken[])tokens.toArray(new IToken[tokens.size()]), context);
	}
================= fetch public Method getAdvice() { 3824b1c^:runtime/src/org/aspectj/runtime/reflect/AdviceSignatureImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.runtime.reflect.MemberSignatureImpl#createAccessibleObject()
	 */
public Method getAdvice() {
		if (adviceMethod == null) {
			try {
				adviceMethod = declaringType.getDeclaredMethod(getName(),getParameterTypes());
			} catch (Exception ex) {
				; // nothing we can do, caller will see null
			}
		}
		return adviceMethod;
	}
================= fetch public Method getMethod() { 3824b1c^:runtime/src/org/aspectj/runtime/reflect/MethodSignatureImpl.java
/* (non-Javadoc)
	 * @see org.aspectj.lang.reflect.MemberSignature#getAccessibleObject()
	 */
public Method getMethod() {
		if (method == null) {
			try {
				method = declaringType.getDeclaredMethod(getName(),getParameterTypes());
			} catch (NoSuchMethodException nsmEx) {
				; // nothing we can do, user will see null return
			}
		}
		return method;
	}
================= fetch public void testIfEvaluationExplosiion_PR94086() { 3824b1c^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java
/**
   * IfPointcut.findResidueInternal() was modified to make this test complete in a short amount
   * of time - if you see it hanging, someone has messed with the optimization.
   */
public void testIfEvaluationExplosiion_PR94086() {
	  runTest("Exploding compile time with if() statements in pointcut");
  }
================= fetch public void testInternalCompilerError_pr86832() { 3824b1c^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testInternalCompilerError_pr86832() {
	  runTest("Internal compiler error");
  }
Progress : [##############################----------] 77%================= fetch public static String makeLocationContext(ICompilationUnit compilationUnit, IProb a675b65^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java

public static String makeLocationContext(ICompilationUnit compilationUnit, IProblem problem) {
        //extra from the source the innacurate     token
        //and "highlight" it using some underneath ^^^^^
        //put some context around too.

        //this code assumes that the font used in the console is fixed size

        //sanity .....
        int startPosition = problem.getSourceStart();
        int endPosition = problem.getSourceEnd();
        
        if ((startPosition > endPosition)
            || ((startPosition <= 0) && (endPosition <= 0))
            || compilationUnit==null)
            //return Util.bind("problem.noSourceInformation"); //$NON-NLS-1$
        	return "(no source information available)";

        final char SPACE = '\u0020';
        final char MARK = '^';
        final char TAB = '\t';
        char[] source = compilationUnit.getContents();
        //the next code tries to underline the token.....
        //it assumes (for a good display) that token source does not
        //contain any \r \n. This is false on statements ! 
        //(the code still works but the display is not optimal !)

        //compute the how-much-char we are displaying around the inaccurate token
        int begin = startPosition >= source.length ? source.length - 1 : startPosition;
        int relativeStart = 0;
        int end = endPosition >= source.length ? source.length - 1 : endPosition;
        int relativeEnd = 0;
        label : for (relativeStart = 0;; relativeStart++) {
            if (begin == 0)
                break label;
            if ((source[begin - 1] == '\n') || (source[begin - 1] == '\r'))
                break label;
            begin--;
        }
        label : for (relativeEnd = 0;; relativeEnd++) {
            if ((end + 1) >= source.length)
                break label;
            if ((source[end + 1] == '\r') || (source[end + 1] == '\n')) {
                break label;
            }
            end++;
        }
        //extract the message form the source
        char[] extract = new char[end - begin + 1];
        System.arraycopy(source, begin, extract, 0, extract.length);
        char c;
        //remove all SPACE and TAB that begin the error message...
        int trimLeftIndex = 0;
        while (((c = extract[trimLeftIndex++]) == TAB) || (c == SPACE)) {
        };
        System.arraycopy(
            extract,
            trimLeftIndex - 1,
            extract = new char[extract.length - trimLeftIndex + 1],
            0,
            extract.length);
        relativeStart -= trimLeftIndex;
        //buffer spaces and tabs in order to reach the error position
        int pos = 0;
        char[] underneath = new char[extract.length]; // can't be bigger
        for (int i = 0; i <= relativeStart; i++) {
            if (extract[i] == TAB) {
                underneath[pos++] = TAB;
            } else {
                underneath[pos++] = SPACE;
            }
        }
        //mark the error position
        for (int i = startPosition + trimLeftIndex;  // AMC if we took stuff off the start, take it into account!
            i <= (endPosition >= source.length ? source.length - 1 : endPosition);
            i++)
            underneath[pos++] = MARK;
        //resize underneathto remove 'null' chars
        System.arraycopy(underneath, 0, underneath = new char[pos], 0, pos);

        return new String(extract) + "\n" + new String(underneath); //$NON-NLS-2$ //$NON-NLS-1$
    }
================= fetch private void registerDefinitions(final BcelWeaver weaver, final ClassLoader load f14646f^:loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java
/**
     * Load and cache the aop.xml/properties according to the classloader visibility rules
     *
     * @param weaver
     * @param loader
     */
void registerDefinitions(final BcelWeaver weaver, final ClassLoader loader) {
        try {
            //TODO av underoptimized: we will parse each XML once per CL that see it
            Enumeration xmls = loader.getResources("/META-INF/aop.xml");
            List definitions = new ArrayList();

            //TODO av dev mode needed ? TBD -Daj5.def=...
            if (loader != null && loader != ClassLoader.getSystemClassLoader().getParent()) {
                String file = System.getProperty("aj5.def", null);
                if (file != null) {
                    definitions.add(DocumentParser.parse((new File(file)).toURL()));
                }
            }

            while (xmls.hasMoreElements()) {
                URL xml = (URL) xmls.nextElement();
                definitions.add(DocumentParser.parse(xml));
            }
            
            // still go thru if definitions is empty since we will configure
            // the default message handler in there
            registerOptions(weaver, loader, definitions);
            registerAspectExclude(weaver, loader, definitions);
            registerAspects(weaver, loader, definitions);
            registerIncludeExclude(weaver, loader, definitions);
        } catch (Exception e) {
            weaver.getWorld().getMessageHandler().handleMessage(
                    new Message("Register definition failed", IMessage.WARNING, e, null)
            );
        }
    }
================= fetch protected Test findResidueInternal(Shadow shadow, ExposedState state) { 88d477d^:weaver/src/org/aspectj/weaver/patterns/IfPointcut.java

public static IfPointcut makeIfTruePointcut(State state) {
		IfPointcut ret = new IfTruePointcut();
		ret.state = state;
		return ret;
	}
================= fetch public String toString() { 88d477d^:weaver/src/org/aspectj/weaver/patterns/IfPointcut.java

public static IfPointcut makeIfTruePointcut(State state) {
		IfPointcut ret = new IfTruePointcut();
		ret.state = state;
		return ret;
	}
================= fetch public void testInternalCompilerError_pr86832() { 88d477d^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testInternalCompilerError_pr86832() {
	  runTest("Internal compiler error");
  }
================= fetch public boolean isAnnotationWithRuntimeRetention() { f9eebd4^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java

public boolean isAnnotationWithRuntimeRetention() {
	    if (!isAnnotation()) {
	        return false;
	    } else {
	    	return (binding.getAnnotationTagBits() & TagBits.AnnotationRuntimeRetention)!=0;        
	    }
	}
================= fetch public void resolveBinding(World world) { f9eebd4^:weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.java

public void resolveBinding(World world) {
	    
		if (resolved) return;
		resolved = true;
		annotationType = annotationType.resolve(world);
		if (!annotationType.isAnnotation(world)) {
			IMessage m = MessageUtil.error(
					WeaverMessages.format(WeaverMessages.REFERENCE_TO_NON_ANNOTATION_TYPE,annotationType.getName()),
					getSourceLocation());
			world.getMessageHandler().handleMessage(m);
			resolved = false;
		}
		if (!annotationType.hasAnnotation(TypeX.AT_RETENTION)) {
		    // default is class visibility
			IMessage m = MessageUtil.error(
					WeaverMessages.format(WeaverMessages.BINDING_NON_RUNTIME_RETENTION_ANNOTATION,annotationType.getName()),
					getSourceLocation());
			world.getMessageHandler().handleMessage(m);
			resolved = false;		    
		} else {
		    // Get the retention policy annotation, and check the value is RetentionPolicy.RUNTIME;
			// FIXME asc invention required, implement this !
//			if (!annotationType.hasRuntimeRetention()) {
//			ResolvedTypeX[] allAs = annotationType.getAnnotationTypes();
//			for (int i = 0; i < allAs.length; i++) {
//				ResolvedTypeX  ann = allAs[i];
//				if ()
//			}
		}
	}
================= fetch public void testEnumCalledEnumEtc() { 0cb826c^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testEnumCalledEnumEtc() {
	  runTest("enum called Enum, annotation called Annotation, etc");
  }
================= fetch private static void processMembers(List/*IProgramElement*/ members, PrintWriter 7b7c7b2^:ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java

private static void processMembers(List/*IProgramElement*/ members, PrintWriter writer, boolean declaringTypeIsInterface) throws IOException {
    	for (Iterator it = members.iterator(); it.hasNext();) {
			IProgramElement member = (IProgramElement) it.next();
		
	    	if (member.getKind().isType()) { 
	    		if (!member.getParent().getKind().equals(IProgramElement.Kind.METHOD)
	    			 && !StructureUtil.isAnonymous(member)) {// don't print anonymous types
//	    			System.err.println(">>>>>>>>>>>>>" + member.getName() + "<<<<" + member.getParent());
	    			processTypeDeclaration(member, writer);
	    		}
			} else {
		    	String formalComment = addDeclID(member, member.getFormalComment());;
		    	writer.println(formalComment);
		    	
		    	String signature = ""; 
		    	if (!member.getKind().equals(IProgramElement.Kind.POINTCUT)
		    	    && !member.getKind().equals(IProgramElement.Kind.ADVICE)) {
		    		signature = member.getSourceSignature();//StructureUtil.genSignature(member);
                } 
		    	
		    	if (member.getKind().isDeclare()) {
		    		System.err.println("> Skipping declare (ajdoc limitation): " + member.toLabelString());
		    	} else if (signature != null &&
		    		signature != "" && 
		    		!member.getKind().isInterTypeMember() &&
					!member.getKind().equals(IProgramElement.Kind.INITIALIZER) &&
					!StructureUtil.isAnonymous(member)) {   
		    		writer.print(signature);
		    	} else {
//		    		System.err.println(">> skipping: " + member.getKind());
		    	}  
		      
		    	if (member.getKind().equals(IProgramElement.Kind.METHOD) ||
		    		member.getKind().equals(IProgramElement.Kind.CONSTRUCTOR)) {
		    		if (member.getParent().getKind().equals(IProgramElement.Kind.INTERFACE) ||
		    			signature.indexOf("abstract ") != -1) {
		    			writer.println(";");
		    		} else {
		    			writer.println(" { }");
		    		}
		    		
		    	} else if (member.getKind().equals(IProgramElement.Kind.FIELD)) {
//		    		writer.println(";");
		    	}
			}
		}
    }
================= fetch protected String genSourceSignature(FieldDeclaration fieldDeclaration) { 7b7c7b2^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java
/**
	 * Doesn't print qualified allocation expressions.
	 */
protected String genSourceSignature(FieldDeclaration fieldDeclaration) {
		StringBuffer output = new StringBuffer();
		FieldDeclaration.printModifiers(fieldDeclaration.modifiers, output);
		if (fieldDeclaration.type == null) { // This is an enum value
			output.append(fieldDeclaration.binding.type.debugName()).append(" ").append(fieldDeclaration.name);
		} else {
			fieldDeclaration.type.print(0, output).append(' ').append(fieldDeclaration.name);
		}
		
		if (fieldDeclaration.initialization != null
			&& !(fieldDeclaration.initialization instanceof QualifiedAllocationExpression)) {
			output.append(" = "); //$NON-NLS-1$
			if (fieldDeclaration.initialization instanceof ExtendedStringLiteral) {
				output.append("\"<extended string literal>\"");
			} else {
				fieldDeclaration.initialization.printExpression(0, output);
			}
		}
		
		output.append(';');
		return output.toString();
	}
================= fetch protected String generateJavadocComment(ASTNode astNode) { 7b7c7b2^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java
/**
	 * Checks if comments should be added to the model before generating.
	 */
protected String generateJavadocComment(ASTNode astNode) {
		if (buildConfig != null && !buildConfig.isGenerateJavadocsInModelMode()) return null;
		
		StringBuffer sb = new StringBuffer(); // !!! specify length?
		boolean completed = false;
		int startIndex = -1;
		if (astNode instanceof MethodDeclaration) {
			startIndex = ((MethodDeclaration)astNode).declarationSourceStart;
		} else if (astNode instanceof FieldDeclaration) {
			startIndex = ((FieldDeclaration)astNode).declarationSourceStart;
		} else if (astNode instanceof TypeDeclaration) {
			startIndex = ((TypeDeclaration)astNode).declarationSourceStart;
		} 
		
		if (startIndex == -1) {
			return null;
		} else if (currCompilationResult.compilationUnit.getContents()[startIndex] == '/'  // look for /**
			&& currCompilationResult.compilationUnit.getContents()[startIndex+1] == '*'
			&& currCompilationResult.compilationUnit.getContents()[startIndex+2] == '*') {
			
			for (int i = startIndex; i < astNode.sourceStart && !completed; i++) {
				char curr = currCompilationResult.compilationUnit.getContents()[i];
				if (curr == '/' && sb.length() > 2 && sb.charAt(sb.length()-1) == '*') completed = true; // found */
				sb.append(currCompilationResult.compilationUnit.getContents()[i]);
			} 
			return sb.toString();
		} else {
			return null;
		}
		
	}
================= fetch public boolean isType() { 7b7c7b2^:ajdoc/src/org/aspectj/tools/ajdoc/Declaration.java

public boolean isType() {
        return getKind().equals("interface") || getKind().equals("class") || getKind().equals("aspect");
    }
Progress : [###############################---------] 78%================= fetch public Collection weave(IClassFileProvider input) throws IOException { f603458^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
// variation of "weave" that sources class files from an external source.
Collection weave(IClassFileProvider input) throws IOException {
    	Collection wovenClassNames = new ArrayList();
    	IWeaveRequestor requestor = input.getRequestor();

    	requestor.processingReweavableState();
		prepareToProcessReweavableState();
		// clear all state from files we'll be reweaving
		for (Iterator i = input.getClassFileIterator(); i.hasNext(); ) {
		    UnwovenClassFile classFile = (UnwovenClassFile)i.next();
			String className = classFile.getClassName();
		    BcelObjectType classType = getClassType(className);			            
			processReweavableStateIfPresent(className, classType);
		}
								
		requestor.addingTypeMungers();
        
        // We process type mungers in two groups, first mungers that change the type
        // hierarchy, then 'normal' ITD type mungers.
        
        
        // Process the types in a predictable order (rather than the order encountered).
        // For class A, the order is superclasses of A then superinterfaces of A
        // (and this mechanism is applied recursively)
        List typesToProcess = new ArrayList();
        for (Iterator iter = input.getClassFileIterator(); iter.hasNext();) {
			UnwovenClassFile clf = (UnwovenClassFile) iter.next();
            typesToProcess.add(clf.getClassName());
        }
        while (typesToProcess.size()>0) {
            weaveParentsFor(typesToProcess,(String)typesToProcess.get(0));
        }  
        
        for (Iterator i = input.getClassFileIterator(); i.hasNext(); ) {
            UnwovenClassFile classFile = (UnwovenClassFile)i.next();
            String className = classFile.getClassName();
            addNormalTypeMungers(className);
        }

		requestor.weavingAspects();
		// first weave into aspects
		for (Iterator i = input.getClassFileIterator(); i.hasNext(); ) {
		    UnwovenClassFile classFile = (UnwovenClassFile)i.next();
			String className = classFile.getClassName();
		    BcelObjectType classType = BcelWorld.getBcelObjectType(world.resolve(className));
		    if (classType.isAspect()) {
		        weaveAndNotify(classFile, classType,requestor);
		        wovenClassNames.add(className);
		    }
		}

		requestor.weavingClasses();
		// then weave into non-aspects
		for (Iterator i = input.getClassFileIterator(); i.hasNext(); ) {
		    UnwovenClassFile classFile = (UnwovenClassFile)i.next();
			String className = classFile.getClassName();
		    BcelObjectType classType = BcelWorld.getBcelObjectType(world.resolve(className));
		    if (! classType.isAspect()) {
		        weaveAndNotify(classFile, classType, requestor);
		        wovenClassNames.add(className);
		    }
		}
		
		addedClasses = new ArrayList();
		deletedTypenames = new ArrayList();
		
        
        // if a piece of advice hasn't matched anywhere and we are in -1.5 mode, put out a warning
        if (world.behaveInJava5Way && 
            world.getLint().adviceDidNotMatch.isEnabled()) {
        	List l = world.getCrosscuttingMembersSet().getShadowMungers();
        	for (Iterator iter = l.iterator(); iter.hasNext();) {
        		ShadowMunger element = (ShadowMunger) iter.next();
        		if (element instanceof BcelAdvice) { // This will stop us incorrectly reporting deow Checkers
                  BcelAdvice ba = (BcelAdvice)element;
                  if (!ba.hasMatchedSomething()) {
                    BcelMethod meth = (BcelMethod)ba.getSignature();
                    if (meth!=null) {
                      AnnotationX[] anns = (AnnotationX[])meth.getAnnotations();
                      // Check if they want to suppress the warning on this piece of advice
               	      if (!Utility.isSuppressing(anns,"adviceDidNotMatch")) {
                        world.getLint().adviceDidNotMatch.signal(ba.getDeclaringAspect().toString(),element.getSourceLocation());
                      }
                    }
                  }
        		}
        	}
        }

        requestor.weaveCompleted();
    	return wovenClassNames;
    }
================= fetch public static Test suite() { f603458^:tests/src/org/aspectj/systemtest/ajc150/AllTestsAspectJ150.java

public static Test suite() {
		TestSuite suite = new TestSuite("Java5/AspectJ5 tests");
		//$JUnit-BEGIN$
		suite.addTestSuite(MigrationTests.class);
		suite.addTest(Ajc150Tests.suite());
        suite.addTestSuite(SCCSFixTests.class);
		
		suite.addTest(AccBridgeMethods.suite());
		suite.addTestSuite(CovarianceTests.class);
		suite.addTestSuite(Enums.class);
		suite.addTest(AnnotationsBinaryWeaving.suite());
		suite.addTest(AnnotationPointcutsTests.suite());
		suite.addTestSuite(VarargsTests.class);
		suite.addTest(AnnotationRuntimeTests.suite());
		suite.addTestSuite(PerTypeWithinTests.class);
		
		suite.addTest(Autoboxing.suite());		
		suite.addTest(Annotations.suite());
		suite.addTest(AnnotationBinding.suite());
		
		suite.addTest(SuppressedWarnings.suite());
		suite.addTest(DeclareAnnotationTests.suite());
		suite.addTest(GenericsTests.suite());
		suite.addTest(AtAjSyntaxTests.suite());
        suite.addTest(AtAjMisuseTests.suite());
		//$JUnit-END$
		return suite;
	}
================= fetch public void testSuppression2() { f603458^:tests/src/org/aspectj/systemtest/ajc150/SuppressedWarnings.java
// (see bug 62073 reference in WeaverMessageHandler.handleMessage())
public void testSuppression2() {
  	runTest("suppressing non-matching advice warnings when multiple source files involved");
  }
================= fetch public void testPR91053() { 51c018d^:tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java

public void testPR91053() {
		runTest("Generics problem with Set");
	}
================= fetch private TypeBinding makeTypeBinding1(TypeX typeX) { 952dda9^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

private TypeBinding makeTypeBinding1(TypeX typeX) {
		if (typeX.isPrimitive()) {
			if (typeX == ResolvedTypeX.BOOLEAN) return BaseTypes.BooleanBinding;
			if (typeX == ResolvedTypeX.BYTE) return BaseTypes.ByteBinding;
			if (typeX == ResolvedTypeX.CHAR) return BaseTypes.CharBinding;
			if (typeX == ResolvedTypeX.DOUBLE) return BaseTypes.DoubleBinding;
			if (typeX == ResolvedTypeX.FLOAT) return BaseTypes.FloatBinding;
			if (typeX == ResolvedTypeX.INT) return BaseTypes.IntBinding;
			if (typeX == ResolvedTypeX.LONG) return BaseTypes.LongBinding;
			if (typeX == ResolvedTypeX.SHORT) return BaseTypes.ShortBinding;
			if (typeX == ResolvedTypeX.VOID) return BaseTypes.VoidBinding;
			throw new RuntimeException("weird primitive type " + typeX);
		} else if (typeX.isArray()) {
			int dim = 0;
			while (typeX.isArray()) {
				dim++;
				typeX = typeX.getComponentType();
			}
			return lookupEnvironment.createArrayType(makeTypeBinding(typeX), dim);
		} else if (typeX.isParameterized()){
			TypeX[] typeParameters = typeX.getTypeParameters();
			ReferenceBinding baseTypeBinding = lookupBinding(typeX.getBaseName());
			ReferenceBinding[] argumentBindings = new ReferenceBinding[typeParameters.length];
			for (int i = 0; i < argumentBindings.length; i++) {
				argumentBindings[i] = lookupBinding(typeParameters[i].getName());
			}
			ParameterizedTypeBinding ptb = 
				lookupEnvironment.createParameterizedType(baseTypeBinding,argumentBindings,baseTypeBinding.enclosingType());
			return ptb;
		} else {
			return lookupBinding(typeX.getName());
		}
	}
================= fetch public ResolvedTypeX resolve(TypeX ty, boolean allowMissing) { 952dda9^:weaver/src/org/aspectj/weaver/World.java

public ResolvedTypeX resolve(TypeX ty, boolean allowMissing) {
    	//System.out.println("resolve: " + ty + " world " + typeMap.keySet());
        String signature = ty.getSignature();
        ResolvedTypeX ret = typeMap.get(signature);
        if (ret != null) { ret.world = this; return ret; } // Set the world for the RTX
        
        if (ty.isArray()) {
            ret = new ResolvedTypeX.Array(signature, this, resolve(ty.getComponentType(), allowMissing));
        } else {
            ret = resolveObjectType(ty);
            if (!allowMissing && ret == ResolvedTypeX.MISSING) {
                MessageUtil.error(messageHandler, 
                		WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE,ty.getName()));
                if (dumpState_cantFindTypeExceptions==null) {
                  dumpState_cantFindTypeExceptions = new ArrayList();   
                }
                dumpState_cantFindTypeExceptions.add(new RuntimeException("Can't find type "+ty.getName()));
            }
        }
		if (ty.isParameterized()) {
			for (int i = 0; i < ty.typeParameters.length; i++) {
				ty.typeParameters[i] = resolve(ty.typeParameters[i],allowMissing);
			}
		}
        //System.out.println("ret: " + ret);
        typeMap.put(signature, ret);
        return ret;
    }
================= fetch public String getBaseName() { 952dda9^:weaver/src/org/aspectj/weaver/TypeX.java
/**
     * Returns an array of strings representing the java langauge names of 
     * an array of types.
     *
     * @param types an array of TypeX objects
     * @return an array of Strings fo the java language names of types.
     * @see #getName()
     */
public static String[] getNames(TypeX[] types) {
        String[] ret = new String[types.length];
        for (int i = 0, len = types.length; i < len; i++) {
            ret[i] = types[i].getName();
        }
        return ret;
    }
================= fetch public final boolean isParameterized() { 952dda9^:weaver/src/org/aspectj/weaver/TypeX.java
/**
	 * Determines if this represents a parameterized type.
	 */
public final boolean isParameterized() {
		return signature.indexOf("<") != -1; 
		//(typeParameters != null) && (typeParameters.length > 0);
	}
================= fetch public static TypeX forParameterizedTypeNames(String name, String[] paramTypeNam 952dda9^:weaver/src/org/aspectj/weaver/TypeX.java
/**
	 * Creates a new type array with a fresh type inserted at the beginning.
	 * 
	 * 
	 * @param start the left hand side of the new array
	 * @param types the right hand side of the new array
	 */
public static TypeX[] insert(TypeX start, TypeX[] types) {
		int len = types.length;
		TypeX[] ret = new TypeX[len + 1];
		ret[0] = start;
		System.arraycopy(types, 0, ret, 1, len);
		return ret;
    }
================= fetch public static TypeX fromBinding(TypeBinding binding) { 952dda9^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

public static TypeX[] fromBindings(TypeBinding[] bindings) {
		if (bindings == null) return TypeX.NONE;
		int len = bindings.length;
		TypeX[] ret = new TypeX[len];
		for (int i=0; i<len; i++) {
			ret[i] = fromBinding(bindings[i]);
		}
		return ret;
	}
================= fetch public void testPR91267_2() { 952dda9^:tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java

public void testPR91267_2() {
		runTest("NPE using generic methods in aspects 2");
	}
================= fetch private static String getName(TypeBinding binding) { 7389d9f^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

private static String getName(TypeBinding binding) {
		if (binding instanceof ReferenceBinding) {
			return new String(
				CharOperation.concatWith(((ReferenceBinding)binding).compoundName, '.'));
		}
		
		String packageName = new String(binding.qualifiedPackageName());
		String className = new String(binding.qualifiedSourceName()).replace('.', '$');
		if (packageName.length() > 0) {
			className = packageName + "." + className;
		}
		//XXX doesn't handle arrays correctly (or primitives?)
		return new String(className);
	}
================= fetch public ResolvedTypeX fromTypeBindingToRTX(TypeBinding tb) { 7389d9f^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

public ResolvedTypeX[] fromEclipse(ReferenceBinding[] bindings) {
		if (bindings == null) {
			return ResolvedTypeX.NONE;
		}
		int len = bindings.length;
		ResolvedTypeX[] ret = new ResolvedTypeX[len];
		for (int i=0; i < len; i++) {
			ret[i] = fromEclipse(bindings[i]);
		}
		return ret;
	}
================= fetch public static TypeX forName(String name) { 7389d9f^:weaver/src/org/aspectj/weaver/TypeX.java
/** Constructs a TypeX for each java language type name in an incoming array.
     * 
     * @param names an array of java language type names.
     * @return an array of TypeX objects.
     * @see #forName(String)
     */
public static TypeX[] forNames(String[] names) {
        TypeX[] ret = new TypeX[names.length];
        for (int i = 0, len = names.length; i < len; i++) {
            ret[i] = TypeX.forName(names[i]);
        }
        return ret;
    }
================= fetch public static TypeX forParameterizedTypeNames(String name, String[] paramTypeNam 7389d9f^:weaver/src/org/aspectj/weaver/TypeX.java
/**
	 * Creates a new type array with a fresh type inserted at the beginning.
	 * 
	 * 
	 * @param start the left hand side of the new array
	 * @param types the right hand side of the new array
	 */
public static TypeX[] insert(TypeX start, TypeX[] types) {
		int len = types.length;
		TypeX[] ret = new TypeX[len + 1];
		ret[0] = start;
		System.arraycopy(types, 0, ret, 1, len);
		return ret;
    }
================= fetch public static TypeX fromBinding(TypeBinding binding) { 7389d9f^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

public static TypeX[] fromBindings(TypeBinding[] bindings) {
		if (bindings == null) return TypeX.NONE;
		int len = bindings.length;
		TypeX[] ret = new TypeX[len];
		for (int i=0; i<len; i++) {
			ret[i] = fromBinding(bindings[i]);
		}
		return ret;
	}
================= fetch public void testITDReturningParameterizedType() { 7389d9f^:tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java

public void testITDReturningParameterizedType() {
		runTest("ITD with parameterized type");
	}
================= fetch public void test019(){ 70b9ffd^:tests/src/org/aspectj/systemtest/xlint/XLintTests.java

public void test019(){
    runTest("XLint warning for call PCD's using subtype of defining type (-1.3 -Xlint:ignore)");
  }
================= fetch private Utility() { abc9a58^:weaver/src/org/aspectj/weaver/bcel/Utility.java

================= fetch private boolean applyDeclareAtType(DeclareAnnotation decA, ResolvedTypeX onType, abc9a58^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
/**
	 * Apply a declare @type - return true if we change the type
	 */
private boolean applyDeclareAtType(DeclareAnnotation decA, ResolvedTypeX onType,boolean reportProblems) {
		boolean didSomething = false;
		if (decA.matches(onType)) {
			
			//FIXME asc important this should be guarded by the 'already has annotation' check below but isn't since the compiler is producing classfiles with deca affected things in...
			AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decA.getSourceLocation(),onType.getSourceLocation());
			
		    if (onType.hasAnnotation(decA.getAnnotationX().getSignature())) {
// FIXME asc Could put out a lint here for an already annotated type - the problem is that it may have
// picked up the annotation during 'source weaving' in which case the message is misleading.  Leaving it
// off for now...
//		      if (reportProblems) {
//		      	world.getLint().elementAlreadyAnnotated.signal(
//      		      new String[]{onType.toString(),decA.getAnnotationTypeX().toString()},
//      		      onType.getSourceLocation(),new ISourceLocation[]{decA.getSourceLocation()});
//		      }
		      return false;
		    }
			
			AnnotationX annoX = decA.getAnnotationX();
			
			// check the annotation is suitable for the target
			boolean problemReported = verifyTargetIsOK(decA, onType, annoX,reportProblems);
			
			if (!problemReported) {
				didSomething = true;
				ResolvedTypeMunger newAnnotationTM = new AnnotationOnTypeMunger(annoX);
				newAnnotationTM.setSourceLocation(decA.getSourceLocation());
				onType.addInterTypeMunger(new BcelTypeMunger(newAnnotationTM,decA.getAspect().resolve(world)));
				decA.copyAnnotationTo(onType);
			}
		}
		return didSomething;
	}
================= fetch private boolean weaveDeclareAtField(LazyClassGen clazz) { abc9a58^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
	 * Weave any declare @field statements into the fields of the supplied class
	 * 
	 * Interesting case relating to public ITDd fields.  The annotations are really stored against
     * the interfieldinit method in the aspect, but the public field is placed in the target
     * type and then is processed in the 2nd pass over fields that occurs.  I think it would be
     * more expensive to avoid putting the annotation on that inserted public field than just to
     * have it put there as well as on the interfieldinit method.
	 */
private boolean weaveDeclareAtField(LazyClassGen clazz) {
	  
        // BUGWARNING not getting enough warnings out on declare @field ?
        // There is a potential problem here with warnings not coming out - this
        // will occur if they are created on the second iteration round this loop.
        // We currently deactivate error reporting for the second time round.
        // A possible solution is to record what annotations were added by what
        // decafs and check that to see if an error needs to be reported - this
        // would be expensive so lets skip it for now

		List reportedProblems = new ArrayList();

		List allDecafs = world.getDeclareAnnotationOnFields();
		if (allDecafs.isEmpty()) return false; // nothing to do
		
		
		boolean isChanged = false;
		List itdFields = getITDSubset(clazz,ResolvedTypeMunger.Field);
		if (itdFields!=null) {
			isChanged = weaveAtFieldRepeatedly(allDecafs,itdFields,reportedProblems);
		}
		
        List decaFs = getMatchingSubset(allDecafs,clazz.getType());
		if (decaFs.isEmpty()) return false; // nothing more to do
		Field[] fields = clazz.getFieldGens();
		if (fields!=null) {
		  
          for (int fieldCounter = 0;fieldCounter<fields.length;fieldCounter++) {
            BcelField aBcelField = new BcelField(clazz.getBcelObjectType(),fields[fieldCounter]);
			if (!aBcelField.getName().startsWith(NameMangler.PREFIX)) {				
            // Single first pass
            List worthRetrying = new ArrayList();
            boolean modificationOccured = false;
            // go through all the declare @field statements
            for (Iterator iter = decaFs.iterator(); iter.hasNext();) {
				DeclareAnnotation decaF = (DeclareAnnotation) iter.next();
				if (decaF.matches(aBcelField,world)) {
					if (doesAlreadyHaveAnnotation(aBcelField,decaF,reportedProblems)) continue; // skip this one...
					aBcelField.addAnnotation(decaF.getAnnotationX());
					AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decaF.getSourceLocation(),clazz.getName(),fields[fieldCounter]);
					isChanged = true;
					modificationOccured = true;
				} else {
					if (!decaF.isStarredAnnotationPattern()) 
						worthRetrying.add(decaF); // an annotation is specified that might be put on by a subsequent decaf
				}
			}
			
            // Multiple secondary passes
            while (!worthRetrying.isEmpty() && modificationOccured) {
              modificationOccured = false;
              // lets have another go
              List forRemoval = new ArrayList();
              for (Iterator iter = worthRetrying.iterator(); iter.hasNext();) {
				DeclareAnnotation decaF = (DeclareAnnotation) iter.next();
				if (decaF.matches(aBcelField,world)) {
					if (doesAlreadyHaveAnnotation(aBcelField,decaF,reportedProblems)) continue; // skip this one...
					aBcelField.addAnnotation(decaF.getAnnotationX());
					AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decaF.getSourceLocation(),clazz.getName(),fields[fieldCounter]);
					isChanged = true;
					modificationOccured = true;
					forRemoval.add(decaF);
				}
			  }
			  worthRetrying.removeAll(forRemoval);
            }
			}
          }
        }
		return isChanged;
	}
================= fetch private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) { abc9a58^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
     * Weave any declare @method/@ctor statements into the members of the supplied class
     */
private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {
		List reportedProblems = new ArrayList();
		
		List allDecams = world.getDeclareAnnotationOnMethods();
		if (allDecams.isEmpty()) return false; // nothing to do
		
		boolean isChanged = false;

		// deal with ITDs
		List itdMethodsCtors = getITDSubset(clazz,ResolvedTypeMunger.Method);
		itdMethodsCtors.addAll(getITDSubset(clazz,ResolvedTypeMunger.Constructor));		
		if (!itdMethodsCtors.isEmpty()) {
			// Can't use the subset called 'decaMs' as it won't be right for ITDs...
 	        isChanged = weaveAtMethodOnITDSRepeatedly(allDecams,itdMethodsCtors,reportedProblems);
		}
		
		// deal with all the other methods...
        List members = clazz.getMethodGens();
		List decaMs = getMatchingSubset(allDecams,clazz.getType());		
		if (decaMs.isEmpty()) return false; // nothing to do
		if (!members.isEmpty()) {
          for (int memberCounter = 0;memberCounter<members.size();memberCounter++) {
            LazyMethodGen mg = (LazyMethodGen)members.get(memberCounter);
            if (!mg.getName().startsWith(NameMangler.PREFIX)) {

            // Single first pass
            List worthRetrying = new ArrayList();
            boolean modificationOccured = false;
            
            for (Iterator iter = decaMs.iterator(); iter.hasNext();) {
				DeclareAnnotation decaM = (DeclareAnnotation) iter.next();
				
				if (decaM.matches(mg.getMemberView(),world)) {
	  				if (doesAlreadyHaveAnnotation(mg.getMemberView(),decaM,reportedProblems)) continue; // skip this one...
					mg.addAnnotation(decaM.getAnnotationX());
					AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decaM.getSourceLocation(),clazz.getName(),mg.getMethod());
					isChanged = true;
					modificationOccured = true;
				} else {
					if (!decaM.isStarredAnnotationPattern()) 
						worthRetrying.add(decaM); // an annotation is specified that might be put on by a subsequent decaf
				}
			}
			
            // Multiple secondary passes
            while (!worthRetrying.isEmpty() && modificationOccured) {
              modificationOccured = false;
              // lets have another go
              List forRemoval = new ArrayList();
              for (Iterator iter = worthRetrying.iterator(); iter.hasNext();) {
				DeclareAnnotation decaM = (DeclareAnnotation) iter.next();
				if (decaM.matches(mg.getMemberView(),world)) {
					if (doesAlreadyHaveAnnotation(mg.getMemberView(),decaM,reportedProblems)) continue; // skip this one...
					mg.addAnnotation(decaM.getAnnotationX());
					AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decaM.getSourceLocation(),clazz.getName(),mg.getMethod());
					isChanged = true;
					modificationOccured = true;
					forRemoval.add(decaM);
				}
			  }
			  worthRetrying.removeAll(forRemoval);
            }
            }
          }
        }
		return isChanged;
    }
================= fetch private void compareWeaveMessages(File f) { abc9a58^:ajde/testsrc/org/aspectj/ajde/ShowWeaveMessagesTestCase.java
/**
	 * Compare weaving messages with what is in the file
	 */
private void compareWeaveMessages(File f) {
		List fileContents = new ArrayList();
		BufferedReader fr;
		try {
			// Load the file in
			fr = new BufferedReader(new FileReader(f));
			String line = null;
			while ((line=fr.readLine())!=null) fileContents.add(line);
			
			// See if the messages match
			int msgCount = 0;
			List l = ideManager.getCompilationSourceLineTasks();
			for (Iterator iter = l.iterator(); iter.hasNext();) {
				IMessage msg = ((NullIdeTaskListManager.SourceLineTask) iter.next()).message;
				if (msg.getKind().equals(IMessage.WEAVEINFO)) {
					if (!fileContents.contains(msg.getMessage())) {
						fail("Could not find message '"+msg.getMessage()+"' in the expected results\n"+
						stringify(fileContents));
					} else {
						fileContents.remove(msg.getMessage());
					}
					msgCount++;
				}
			}
			assertTrue("Didn't get these expected messages: "+fileContents,fileContents.size()==0);
			if (debugTests) System.out.println("Successfully verified "+msgCount+" weaving messages");
		} catch (Exception e) {
			fail("Unexpected exception saving weaving messages:"+e);
		}
	}
================= fetch protected void tearDown() throws Exception { abc9a58^:ajde/testsrc/org/aspectj/ajde/ShowWeaveMessagesTestCase.java

protected void tearDown() throws Exception {
		super.tearDown();
		FileUtil.deleteContents(openFile(binDir));
		File rogueSymFile = new File(currTestDataPath + File.separatorChar + "Empty.ajsym");
		if (rogueSymFile.exists()) rogueSymFile.delete();
	}
================= fetch public void testWeaveMessagesDeclareSoft() { abc9a58^:ajde/testsrc/org/aspectj/ajde/ShowWeaveMessagesTestCase.java
/**
	 * Weave "declare soft: type: pointcut" and check the weave messages that come out.
	 */
public void testWeaveMessagesDeclareSoft() {
		if (debugTests) System.out.println("\ntestWeaveMessagesDeclareSoft: Building with Five.lst");
		compilerAdapter = new CompilerAdapter();
		compilerAdapter.showInfoMessages(true);
		compilerAdapter.compile((String) openFile("Five.lst").getAbsolutePath(),new BPM(),false);
		verifyWeavingMessages("declare.soft",true);		
	}
================= fetch public void weaveParentTypeMungers(ResolvedTypeX onType) { abc9a58^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
/**
     * Weaves new parents and annotations onto a type ("declare parents" and "declare @type")
     * 
     * Algorithm:
     *   1. First pass, do parents then do annotations.  During this pass record:
     *      - any parent mungers that don't match but have a non-wild annotation type pattern
     *      - any annotation mungers that don't match
     *   2. Multiple subsequent passes which go over the munger lists constructed in the first
     *      pass, repeatedly applying them until nothing changes.
     * FIXME asc confirm that algorithm is optimal ??
     */
public void weaveParentTypeMungers(ResolvedTypeX onType) {
		onType.clearInterTypeMungers();
		
		List decpToRepeat = new ArrayList();
		List decaToRepeat = new ArrayList();
		
		boolean aParentChangeOccurred      = false;
		boolean anAnnotationChangeOccurred = false;
		// First pass - apply all decp mungers
		for (Iterator i = declareParentsList.iterator(); i.hasNext(); ) {
			DeclareParents decp = (DeclareParents)i.next();
			boolean typeChanged = applyDeclareParents(decp,onType);
			if (typeChanged) {
				aParentChangeOccurred = true;
			} else { // Perhaps it would have matched if a 'dec @type' had modified the type
				if (!decp.getChild().isStarAnnotation()) decpToRepeat.add(decp);
			}
		}

		// Still first pass - apply all dec @type mungers
		for (Iterator i = xcutSet.getDeclareAnnotationOnTypes().iterator();i.hasNext();) {
			DeclareAnnotation decA = (DeclareAnnotation)i.next();
			boolean typeChanged = applyDeclareAtType(decA,onType,true);
			if (typeChanged) {
				anAnnotationChangeOccurred = true;
			}
		}
		
		while ((aParentChangeOccurred || anAnnotationChangeOccurred) && !decpToRepeat.isEmpty()) {
			anAnnotationChangeOccurred = aParentChangeOccurred = false;
			List decpToRepeatNextTime = new ArrayList();
			for (Iterator iter = decpToRepeat.iterator(); iter.hasNext();) {
				DeclareParents decp = (DeclareParents) iter.next();
				boolean typeChanged = applyDeclareParents(decp,onType);
				if (typeChanged) {
					aParentChangeOccurred = true;
				} else {
					decpToRepeatNextTime.add(decp);
				}
			}
			
			for (Iterator iter = xcutSet.getDeclareAnnotationOnTypes().iterator(); iter.hasNext();) {
				DeclareAnnotation decA = (DeclareAnnotation) iter.next();
				boolean typeChanged = applyDeclareAtType(decA,onType,false);
				if (typeChanged) {
					anAnnotationChangeOccurred = true;
				}
			}
			decpToRepeat = decpToRepeatNextTime;
		}
    }
Progress : [###############################---------] 79%================= fetch public boolean accept(File dir, String name) { 02f75ba^:weaver/src/org/aspectj/weaver/bcel/UnwovenClassFile.java

public void deleteRealFile() throws IOException {
		File victim = new File(filename);
		String namePrefix = victim.getName();
		namePrefix = namePrefix.substring(0,namePrefix.lastIndexOf('.'));
		final String targetPrefix = namePrefix + "$Ajc";
		File dir = victim.getParentFile();
		if (dir != null) {
			File[] weaverGenerated = dir.listFiles(new FilenameFilter() {
				public boolean accept(File dir, String name) {
					return name.startsWith(targetPrefix);
				}});
			for (int i = 0; i < weaverGenerated.length; i++) {
				weaverGenerated[i].delete();
			}
		}
		victim.delete();
	}
================= fetch public void adviceMunger(IHierarchy model, Shadow shadow, ShadowMunger munger) { 7a61380^:weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java

public void adviceMunger(IHierarchy model, Shadow shadow, ShadowMunger munger) {
	  if (!AsmManager.isCreatingModel()) return;
		if (munger instanceof Advice) {
			Advice advice = (Advice)munger;
			
			if (advice.getKind().isPerEntry() || advice.getKind().isCflow()) {
				// TODO: might want to show these in the future
				return;
			}
			

			IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
			IProgramElement targetNode = getNode(AsmManager.getDefault().getHierarchy(), shadow);
			boolean runtimeTest = ((BcelAdvice)munger).hasDynamicTests();
			
			// Work out extra info to inform interested UIs !
			IProgramElement.ExtraInformation ai = new IProgramElement.ExtraInformation();

			String adviceHandle = advice.getHandle(); 
			
			// What kind of advice is it?
			// TODO: Prob a better way to do this but I just want to
			// get it into CVS !!!
			AdviceKind ak = ((Advice)munger).getKind();
			ai.setExtraAdviceInformation(ak.getName());
			IProgramElement adviceElement = AsmManager.getDefault().getHierarchy().findElementForHandle(adviceHandle);
			adviceElement.setExtraInfo(ai);		
			
			if (adviceHandle != null && targetNode != null) {
		
				if (targetNode != null) {
					String targetHandle = targetNode.getHandleIdentifier();	
				
					IRelationship foreward = mapper.get(adviceHandle, IRelationship.Kind.ADVICE, ADVISES,runtimeTest,true);
					if (foreward != null) foreward.addTarget(targetHandle);//foreward.getTargets().add(targetHandle);
					
					IRelationship back = mapper.get(targetHandle, IRelationship.Kind.ADVICE, ADVISED_BY,runtimeTest,true);
					if (back != null)     back.addTarget(adviceHandle);//back.getTargets().add(adviceHandle);
				}
			}

		}
	}
================= fetch protected Test findResidueInternal(Shadow shadow, ExposedState state) { 3f942a4^:weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.Pointcut#findResidue(org.aspectj.weaver.Shadow, org.aspectj.weaver.patterns.ExposedState)
	 */
protected Test findResidueInternal(Shadow shadow, ExposedState state) {
		int len = shadow.getArgCount();
	
		// do some quick length tests first
		int numArgsMatchedByEllipsis = (len + arguments.ellipsisCount) - arguments.size();
		if (numArgsMatchedByEllipsis < 0) return Literal.FALSE;  // should never happen
		if ((numArgsMatchedByEllipsis > 0) && (arguments.ellipsisCount == 0)) {
			return Literal.FALSE; // should never happen
		}
		// now work through the args and the patterns, skipping at ellipsis
    	Test ret = Literal.TRUE;
    	int argsIndex = 0;
    	for (int i = 0; i < arguments.size(); i++) {
			if (arguments.get(i) == AnnotationTypePattern.ELLIPSIS) {
				// match ellipsisMatchCount args
				argsIndex += numArgsMatchedByEllipsis;
			} else if (arguments.get(i) == AnnotationTypePattern.ANY) {
				argsIndex++;
			} else {
				// match the argument type at argsIndex with the ExactAnnotationTypePattern
				// we know it is exact because nothing else is allowed in args
				ExactAnnotationTypePattern ap = (ExactAnnotationTypePattern)arguments.get(i);
				TypeX argType = shadow.getArgType(argsIndex);
				ResolvedTypeX rArgType = argType.resolve(shadow.getIWorld());
				if (rArgType == ResolvedTypeX.MISSING) {
	                  IMessage msg = new Message(
	                    WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_ARG_TYPE,argType.getName()),
	                    "",IMessage.ERROR,shadow.getSourceLocation(),null,new ISourceLocation[]{getSourceLocation()});
	            }
				if (ap.matches(rArgType).alwaysTrue()) { // !!! ASC Can we ever take this branch?
					                                     // !!! AMC - Yes, if annotation is @Inherited
					argsIndex++;
					continue;
				} else {
					// we need a test...
					ResolvedTypeX rAnnType = ap.annotationType.resolve(shadow.getIWorld());
					if (ap instanceof BindingAnnotationTypePattern) {
						BindingAnnotationTypePattern btp = (BindingAnnotationTypePattern)ap;
						Var annvar = shadow.getArgAnnotationVar(argsIndex,rAnnType);
						state.set(btp.getFormalIndex(),annvar);
						ret = Test.makeAnd(ret,Test.makeHasAnnotation(shadow.getArgVar(argsIndex),rAnnType));
						argsIndex++;
					} else {
						ret = Test.makeAnd(ret,Test.makeHasAnnotation(shadow.getArgVar(argsIndex),rAnnType));
						argsIndex++;
					}
				}				
			}
		}   	
    	return ret;
	}
================= fetch public void testAnnotationBindingAndITDs7_asmtest() { 3f942a4^:tests/src/org/aspectj/systemtest/ajc150/AnnotationBinding.java

public void testAnnotationBindingAndITDs7_asmtest() {
	 // AsmManager.setReporting("c:/debug.txt",true,true,true,true);
	  runTest("simple binding annotation values where itd ctor is annotated via declare");  
		
	  	if (getCurrentTest().canRunOnThisVM()) {
		  	IHierarchy top = AsmManager.getDefault().getHierarchy();
		  	
		  	IProgramElement ipe = top.findElementForLabel(top.getRoot(),
		  		IProgramElement.Kind.DECLARE_ANNOTATION_AT_CONSTRUCTOR,
		  		"declare @constructor: A.new(java.lang.String) : @Fruit(\"pear\")");
		  	assertTrue("Couldn't find 'declare @constructor' element in the tree",ipe!=null);

		    List l = AsmManager.getDefault().getRelationshipMap().get(ipe);
		  	assertTrue("Should have a relationship but does not ",l.size()>0);
		  	
		  	ipe = top.findElementForLabel(top.getRoot(),
		  		IProgramElement.Kind.DECLARE_ANNOTATION_AT_CONSTRUCTOR,
		  		"declare @constructor: A.new(int) : @Fruit(\"orange\")");
		  	assertTrue("Couldn't find 'declare @constructor element in the tree",ipe!=null);
		  	
		    l = AsmManager.getDefault().getRelationshipMap().get(ipe);
		  	assertTrue("Should have a relationship but does not ",l.size()>0);

			Relationship rel = (Relationship)l.get(0);
			assertTrue("Should have 1 target but has "+rel.getTargets().size(),rel.getTargets().size()==1);
			String tgt = (String)rel.getTargets().get(0);
			assertTrue("Should point to line 10 but doesnt: "+tgt,tgt.indexOf("|10|")!=-1);
	  	}
  }
================= fetch public Declare parseDeclareAnnotation() { 78abc76^:weaver/src/org/aspectj/weaver/patterns/PatternParser.java

public Declare parseDeclareAnnotation() {
		int startPos = tokenSource.peek().getStart();
		
		eatIdentifier("declare");
		eat("@");
		String kind = parseIdentifier();
		eat(":");
		Declare ret;
		if (kind.equals("type")) {
			ret = parseDeclareAtType();
		} else if (kind.equals("method")) {
			ret = parseDeclareAtMethod(true);
		} else if (kind.equals("field")) {
			ret = parseDeclareAtField();			
		} else if (kind.equals("constructor")) {
			ret = parseDeclareAtMethod(false);			
		} else {
			throw new ParserException("expected one of type, method, field, constructor",
				tokenSource.peek(-1));
		}
		eat(";");
	    int endPos = tokenSource.peek(-1).getEnd();
		ret.setLocation(sourceContext, startPos, endPos);
		return ret;
		
	}
================= fetch public void postParse(TypeDeclaration typeDec) { 78abc76^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/DeclareAnnotationDeclaration.java

public void postParse(TypeDeclaration typeDec) {
		super.postParse(typeDec);
	    ((DeclareAnnotation)declareDecl).setAnnotationMethod(new String(selector));
	}
================= fetch public void testStructureModel() { 78abc76^:tests/src/org/aspectj/systemtest/ajc150/DeclareAnnotationTests.java
// dump of the structure model in c:/debug.txt 
public void testStructureModel() {
    // AsmManager.setReporting("c:/debug.txt",true,true,true,true);
  	runTest("declare all annotations on one class - source weaving");
  	
  	if (getCurrentTest().canRunOnThisVM()) {
	  	IHierarchy top = AsmManager.getDefault().getHierarchy();
	  	
	  	IProgramElement ipe = top.findElementForLabel(top.getRoot(),
	  		IProgramElement.Kind.DECLARE_ANNOTATION_AT_TYPE,
	  		"declare @type: p.q.DeathByAnnotations : @Colored(\"red\")");
	  	assertTrue("Couldn't find 'declare @type' element in the tree",ipe!=null);
	  	
	    List l = AsmManager.getDefault().getRelationshipMap().get(ipe);
	  	assertTrue("Should have a relationship but does not ",l.size()>0);
	  	
	  	ipe = top.findElementForLabel(top.getRoot(),
	  		IProgramElement.Kind.DECLARE_ANNOTATION_AT_METHOD,
	  		"declare @method: * m*(..) : @Fruit(\"tomato\")");
	  	assertTrue("Couldn't find 'declare @method element in the tree",ipe!=null);
	  	
	    l = AsmManager.getDefault().getRelationshipMap().get(ipe);
	  	assertTrue("Should have a relationship but does not ",l.size()>0);
	  	
	  	ipe = top.findElementForLabel(top.getRoot(),
	  		IProgramElement.Kind.DECLARE_ANNOTATION_AT_CONSTRUCTOR,
	  		"declare @constructor: p.q.DeathByAnnotations.new(..) : @Fruit(\"tomato\")");
	  	assertTrue("Couldn't find 'declare @constructor element in the tree",ipe!=null);
	    l = AsmManager.getDefault().getRelationshipMap().get(ipe);
	  	assertTrue("Should have a relationship but does not ",l.size()>0);
	  	
	  	ipe = top.findElementForLabel(top.getRoot(),
	  		IProgramElement.Kind.DECLARE_ANNOTATION_AT_FIELD,
	  		"declare @field: * p.q.DeathByAnnotations.* : @Material(\"wood\")");
	  	assertTrue("Couldn't find 'declare @field element in the tree",ipe!=null);
	    l = AsmManager.getDefault().getRelationshipMap().get(ipe);
	  	assertTrue("Should have a relationship but does not ",l.size()>0);
  	}
  }
================= fetch private void addUsesPointcutRelationsForNode(IProgramElement peNode, List namedP df7fff4^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java

private void addUsesPointcutRelationsForNode(IProgramElement peNode, List namedPointcuts, MethodDeclaration declaration) {
        for (Iterator it = namedPointcuts.iterator(); it.hasNext();) {
            ReferencePointcut rp = (ReferencePointcut) it.next();
            ResolvedMember member = getPointcutDeclaration(rp, declaration);
            if (member != null) {
                IRelationship foreward = AsmManager.getDefault().getRelationshipMap().get(peNode.getHandleIdentifier(), IRelationship.Kind.USES_POINTCUT, "uses pointcut", false, true);
                foreward.addTarget(ProgramElement.genHandleIdentifier(member.getSourceLocation()));            
                
                IRelationship back = AsmManager.getDefault().getRelationshipMap().get(ProgramElement.genHandleIdentifier(member.getSourceLocation()), IRelationship.Kind.USES_POINTCUT, "pointcut used by", false, true);
                back.addTarget(peNode.getHandleIdentifier());             
            } 
        }        
    }
================= fetch private void notifyListeners() { df7fff4^:asm/src/org/aspectj/asm/AsmManager.java

private void notifyListeners() {
        for (Iterator it = structureListeners.iterator(); it.hasNext(); ) {
            ((IHierarchyListener)it.next()).elementsUpdated(hierarchy);
        }
    }
================= fetch public IProgramElement findElementForHandle(String handle) { df7fff4^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java
// TODO: optimize this lookup
public IProgramElement findElementForHandle(String handle) {
		// try the cache first...
		IProgramElement ret = (IProgramElement) handleMap.get(handle);
		if (ret != null) return ret;
		
		StringTokenizer st = new StringTokenizer(handle, ProgramElement.ID_DELIM);
		String file = st.nextToken();
		int line = new Integer(st.nextToken()).intValue();
//		int col = new Integer(st.nextToken()).intValue();
		// TODO: use column number when available
		ret = findElementForSourceLine(file, line);
		if (ret != null) { 
			cache(handle,(ProgramElement)ret);
		}
		return ret;
		
//		IProgramElement parent = findElementForType(packageName, typeName);
//		if (parent == null) return null;
//		if (kind == IProgramElement.Kind.CLASS ||
//			kind == IProgramElement.Kind.ASPECT) {
//				return parent;
//		} else {
//			return findElementForSignature(parent, kind, name);	
//		}	
	}
================= fetch public IProgramElement getElement(String handle) { df7fff4^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java

public IProgramElement getElement(String handle) {
		IProgramElement cachedEntry = (IProgramElement)handleMap.get(handle);
		if (cachedEntry!=null) return cachedEntry;
		
		StringTokenizer st = new StringTokenizer(handle, ProgramElement.ID_DELIM);
		String file = st.nextToken();
		int line = new Integer(st.nextToken()).intValue();
		// int col = new Integer(st.nextToken()).intValue(); TODO: use column number when available
		String canonicalSFP = AsmManager.getDefault().getCanonicalFilePath(new File(file));
		IProgramElement ret = findNodeForSourceLineHelper(root,canonicalSFP, line);
		if (ret!=null) {
			handleMap.put(handle,ret);
		}
		return ret;
	}
================= fetch public String getHandle() { df7fff4^:weaver/src/org/aspectj/weaver/ShadowMunger.java

public String getHandle() {
		if (null == handle) {
			ISourceLocation sl = getSourceLocation();
			if (sl != null) {
				handle = ProgramElement.createHandleIdentifier(
				            sl.getSourceFile(),
				            sl.getLine(),
				            sl.getColumn(),
							sl.getOffset());
			}
		}
		return handle;
	}
================= fetch public String getHandleIdentifier() { df7fff4^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public String getHandleIdentifier() {
	    if (null == handle) {
			if (sourceLocation != null) {
			    return genHandleIdentifier(sourceLocation);
			}
	    }
	    return handle;
	}
================= fetch public String toLabelString() { df7fff4^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public String toLabelString() {
		String label = toSignatureString();
		if (details != null) {
			label += ": " + details;
		} 
		return label;
	}
================= fetch public static ModelInfo summarizeModel() { df7fff4^:asm/src/org/aspectj/asm/AsmManager.java

public static ModelInfo summarizeModel() {
			return new ModelInfo(AsmManager.getDefault().getHierarchy(),
								 AsmManager.getDefault().getRelationshipMap());
		}
================= fetch public void addDeclareAnnotationRelationship(ISourceLocation declareAnnotationLo df7fff4^:weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java
/**
	 * Adds a declare annotation relationship, sometimes entities don't have source locs (methods/fields) so use other
	 * variants of this method if that is the case as they will look the entities up in the structure model.
	 */
public void addDeclareAnnotationRelationship(ISourceLocation declareAnnotationLocation,ISourceLocation annotatedLocation) {
	    if (!AsmManager.isCreatingModel()) return;
		String sourceHandle = ProgramElement.createHandleIdentifier(declareAnnotationLocation.getSourceFile(),declareAnnotationLocation.getLine(),
																	declareAnnotationLocation.getColumn(),declareAnnotationLocation.getOffset());
		IProgramElement declareAnnotationPE = AsmManager.getDefault().getHierarchy().findElementForHandle(sourceHandle);
		
		String targetHandle = ProgramElement.createHandleIdentifier(
				annotatedLocation.getSourceFile(),
				annotatedLocation.getLine(),
				annotatedLocation.getColumn(),
				annotatedLocation.getOffset());
				
		IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
		if (sourceHandle != null && targetHandle != null) {
			IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATES,false,true);
			foreward.addTarget(targetHandle);
				
			IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATED_BY,false,true);
			back.addTarget(sourceHandle);
		}
	}
================= fetch public void addDeclareAnnotationRelationship(ISourceLocation sourceLocation, Str df7fff4^:weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java
/**
     * Add a relationship to the known set for a declare @field construct.  Locating the field is trickier than
     * it might seem since we have no line number info for it, we have to dig through the structure model under
     * the fields' type in order to locate it.  Currently just fails silently if any of the lookup code
     * doesn't find anything...
     */
public void addDeclareAnnotationRelationship(ISourceLocation sourceLocation, String typename,Field field) {
	    if (!AsmManager.isCreatingModel()) return;
	    
  	    String pkg  = null;
	    String type = typename;
	    int packageSeparator = typename.lastIndexOf(".");
	    if (packageSeparator!=-1) {
	  	  pkg  = typename.substring(0,packageSeparator);
	  	  type = typename.substring(packageSeparator+1);
	    }
	    
        IProgramElement typeElem = AsmManager.getDefault().getHierarchy().findElementForType(pkg,type);
        if (typeElem == null) return;
        
        IProgramElement fieldElem = AsmManager.getDefault().getHierarchy().findElementForSignature(typeElem,IProgramElement.Kind.FIELD,field.getName());
        if (fieldElem== null) return;

		String sourceHandle = 
		  ProgramElement.createHandleIdentifier(sourceLocation.getSourceFile(),sourceLocation.getLine(),
		  	sourceLocation.getColumn(),sourceLocation.getOffset());
		  	
		String targetHandle = fieldElem.getHandleIdentifier();
		
        IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
		if (sourceHandle != null && targetHandle != null) {
			IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATES,false,true);
			foreward.addTarget(targetHandle);
				
			IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE_INTER_TYPE, ANNOTATED_BY,false,true);
			back.addTarget(sourceHandle);
		}
	}
================= fetch public void addDeclareParentsRelationship(ISourceLocation decp,ResolvedTypeX tar df7fff4^:weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java

public void addDeclareParentsRelationship(ISourceLocation decp,ResolvedTypeX targetType, List newParents) {
	    if (!AsmManager.isCreatingModel()) return;

		String sourceHandle = ProgramElement.createHandleIdentifier(decp.getSourceFile(),decp.getLine(),decp.getColumn(),decp.getOffset());
		
		IProgramElement ipe = AsmManager.getDefault().getHierarchy().findElementForHandle(sourceHandle);
		
	
		String targetHandle = ProgramElement.createHandleIdentifier(
				targetType.getSourceLocation().getSourceFile(),
				targetType.getSourceLocation().getLine(),
				targetType.getSourceLocation().getColumn(),
				targetType.getSourceLocation().getOffset());
				
		IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
		if (sourceHandle != null && targetHandle != null) {
			IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE_INTER_TYPE, INTER_TYPE_DECLARES,false,true);
			foreward.addTarget(targetHandle);
				
			IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE_INTER_TYPE, INTER_TYPE_DECLARED_BY,false,true);
			back.addTarget(sourceHandle);
		}
		
	}
================= fetch public void addDeclareParentsRelationship(ISourceLocation decp, df7fff4^:docs/sandbox/api-clients/org/aspectj/samples/AsmRelationshipMapExtensionTest.java

protected void setUp() throws Exception {
        AsmRelationshipProvider.setDefault(new DeclareInfoProvider());
        super.setUp("examples");
 
        assertTrue("build success",
                doSynchronousBuild("../examples/coverage/coverage.lst"));
    }
================= fetch public void addRelationship( df7fff4^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AsmInterTypeRelationshipProvider.java

public void addRelationship(
		ResolvedTypeX onType,
		EclipseTypeMunger munger) {
			
//		IProgramElement.Kind kind = IProgramElement.Kind.ERROR;
//		if (munger.getMunger().getKind() == ResolvedTypeMunger.Field) {
//			kind = IProgramElement.Kind.INTER_TYPE_FIELD;
//		} else if (munger.getMunger().getKind() == ResolvedTypeMunger.Constructor) {
//			kind = IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR;
//		} else if (munger.getMunger().getKind() == ResolvedTypeMunger.Method) {
//			kind = IProgramElement.Kind.INTER_TYPE_METHOD;
//		} else if (munger.getMunger().getKind() == ResolvedTypeMunger.Parent) {
//			kind = IProgramElement.Kind.INTER_TYPE_PARENT;
//		}  	 
	
		if (munger.getSourceLocation() != null
			&& munger.getSourceLocation() != null) {
			String sourceHandle = ProgramElement.createHandleIdentifier(
				munger.getSourceLocation().getSourceFile(),
				munger.getSourceLocation().getLine(),
				munger.getSourceLocation().getColumn(),
				munger.getSourceLocation().getOffset());
				
			String targetHandle = ProgramElement.createHandleIdentifier(
				onType.getSourceLocation().getSourceFile(),
				onType.getSourceLocation().getLine(),
				onType.getSourceLocation().getColumn(),
				onType.getSourceLocation().getOffset());
				
			IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
			if (sourceHandle != null && targetHandle != null) {
				IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE_INTER_TYPE, INTER_TYPE_DECLARES,false,true);
				foreward.addTarget(targetHandle);
				
				IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE_INTER_TYPE, INTER_TYPE_DECLARED_BY,false,true);
				back.addTarget(sourceHandle);
			}
		}
	}
================= fetch public void addRelationship( df7fff4^:weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java
// For ITDs
public void addRelationship(
		ResolvedTypeX onType,
		ResolvedTypeMunger munger,
		ResolvedTypeX originatingAspect) {

	  if (!AsmManager.isCreatingModel()) return;
		String sourceHandle = "";
		if (munger.getSourceLocation()!=null) {
			sourceHandle = ProgramElement.createHandleIdentifier(
										munger.getSourceLocation().getSourceFile(),
										munger.getSourceLocation().getLine(),
										munger.getSourceLocation().getColumn(),
										munger.getSourceLocation().getOffset());
		} else {
			sourceHandle = ProgramElement.createHandleIdentifier(
							originatingAspect.getSourceLocation().getSourceFile(),
							originatingAspect.getSourceLocation().getLine(),
							originatingAspect.getSourceLocation().getColumn(),
							originatingAspect.getSourceLocation().getOffset());
		}
		if (originatingAspect.getSourceLocation() != null) {
				
			String targetHandle = ProgramElement.createHandleIdentifier(
				onType.getSourceLocation().getSourceFile(),
				onType.getSourceLocation().getLine(),
				onType.getSourceLocation().getColumn(),
				onType.getSourceLocation().getOffset());
				
			IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
			if (sourceHandle != null && targetHandle != null) {
				IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE_INTER_TYPE, INTER_TYPE_DECLARES,false,true);
				foreward.addTarget(targetHandle);
//				foreward.getTargets().add(targetHandle);
				
				IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE_INTER_TYPE, INTER_TYPE_DECLARED_BY,false,true);
				back.addTarget(sourceHandle);
//				back.getTargets().add(sourceHandle);  
			}
		}
	}
================= fetch public void checkerMunger(IHierarchy model, Shadow shadow, Checker checker) { df7fff4^:weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java

public void checkerMunger(IHierarchy model, Shadow shadow, Checker checker) {
	  if (!AsmManager.isCreatingModel()) return;
		if (shadow.getSourceLocation() == null || checker.getSourceLocation() == null) return;
		
		// Ensure a node for the target exists
		IProgramElement targetNode = getNode(AsmManager.getDefault().getHierarchy(), shadow);

		String sourceHandle = ProgramElement.createHandleIdentifier(
			checker.getSourceLocation().getSourceFile(),
			checker.getSourceLocation().getLine(),
			checker.getSourceLocation().getColumn(),
			checker.getSourceLocation().getOffset());
			
		String targetHandle = ProgramElement.createHandleIdentifier(
			shadow.getSourceLocation().getSourceFile(),
			shadow.getSourceLocation().getLine(),
			shadow.getSourceLocation().getColumn(),
			shadow.getSourceLocation().getOffset());

		IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
		if (sourceHandle != null && targetHandle != null) {
			IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE, MATCHED_BY,false,true);
			foreward.addTarget(targetHandle);
//			foreward.getTargets().add(targetHandle);
				
			IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE, MATCHES_DECLARE,false,true);
			if (back != null && back.getTargets() != null) {
				back.addTarget(sourceHandle);
				//back.getTargets().add(sourceHandle);   
			}
		}
	}
Progress : [################################--------] 80%================= fetch boolean prepareForNextBuild(AjBuildConfig newBuildConfig) { e460b1e^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
/**
	 * Returns false if a batch build is needed.
	 */
boolean prepareForNextBuild(AjBuildConfig newBuildConfig) {
		currentBuildTime = System.currentTimeMillis();
		
		addedClassFiles = new ArrayList();
		
		if (lastSuccessfulBuildTime == -1 || buildConfig == null) {
			return false;
		}
		
		// we don't support incremental with an outjar yet
		if (newBuildConfig.getOutputJar() != null) return false;
		
		// we can't do an incremental build if one of our paths
		// has changed, or a jar on a path has been modified
		if (pathChange(buildConfig,newBuildConfig)) {
		    // last time we built, .class files and resource files from jars on the
		    // inpath will have been copied to the output directory.
		    // these all need to be deleted in preparation for the clean build that is
		    // coming - otherwise a file that has been deleted from an inpath jar 
		    // since the last build will not be deleted from the output directory.
		    removeAllResultsOfLastBuild();
		    return false;
		}
		
		simpleStrings = new ArrayList();
		qualifiedStrings = new ArrayList();
		
		Set oldFiles = new HashSet(buildConfig.getFiles());
		Set newFiles = new HashSet(newBuildConfig.getFiles());
		
		addedFiles = new HashSet(newFiles);
		addedFiles.removeAll(oldFiles);
		deletedFiles = new HashSet(oldFiles);
		deletedFiles.removeAll(newFiles);
		
		Set oldBinaryFiles = new HashSet(buildConfig.getBinaryFiles());
		Set newBinaryFiles = new HashSet(newBuildConfig.getBinaryFiles());
		
		addedBinaryFiles = new HashSet(newBinaryFiles);
		addedBinaryFiles.removeAll(oldBinaryFiles);
		deletedBinaryFiles = new HashSet(oldBinaryFiles);
		deletedBinaryFiles.removeAll(newBinaryFiles);
		
		this.newBuildConfig = newBuildConfig;
		
		return true;
	}
================= fetch private boolean changed(List oldPath, List newPath, boolean checkClassFiles) { e460b1e^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java

private boolean changed(List oldPath, List newPath, boolean checkClassFiles) {
		if (oldPath == null) oldPath = new ArrayList();
		if (newPath == null) newPath = new ArrayList();
		if (oldPath.size() != newPath.size()) {
			return true;
		}
		for (int i = 0; i < oldPath.size(); i++) {
			if (!oldPath.get(i).equals(newPath.get(i))) {
				return true;
			}
			Object o = oldPath.get(i);  // String on classpath, File on other paths
			File f = null;
			if (o instanceof String) {
				f = new File((String)o);
			} else {
				f = (File) o;
			}
			if (f.exists() && !f.isDirectory() && (f.lastModified() >= lastSuccessfulBuildTime)) {
				return true;
			}
			if (f.exists() && f.isDirectory() && checkClassFiles) {
				return classFileChangedInDirSinceLastBuild(f);
			}
		}
		return false;
	}
================= fetch private boolean pathChange(AjBuildConfig oldConfig, AjBuildConfig newConfig) { e460b1e^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java

boolean pathChange(AjBuildConfig oldConfig, AjBuildConfig newConfig) {
		boolean changed = false;
		List oldClasspath = oldConfig.getClasspath();
		List newClasspath = newConfig.getClasspath();
		if (changed(oldClasspath,newClasspath,true)) return true;
		List oldAspectpath = oldConfig.getAspectpath();
		List newAspectpath = newConfig.getAspectpath();
		if (changed(oldAspectpath,newAspectpath,true)) return true;
		List oldInJars = oldConfig.getInJars();
		List newInJars = newConfig.getInJars();
		if (changed(oldInJars,newInJars,false)) return true;
		List oldInPath = oldConfig.getInpath();
		List newInPath = newConfig.getInpath();
		if (changed(oldInPath, newInPath,false)) return true;
		return changed;
	}
================= fetch protected void addDependentsOf(File sourceFile) { e460b1e^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java

protected void addDependentsOf(File sourceFile) {
		InterimCompilationResult intRes = (InterimCompilationResult)resultsFromFile.get(sourceFile);
		if (intRes == null) return;
		
		for (int i = 0; i < intRes.unwovenClassFiles().length; i++) {
			addDependentsOf(intRes.unwovenClassFiles()[i].getClassName());
		}
	}
================= fetch public boolean accept(File pathname) { e460b1e^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java

private boolean classFileChangedInDirSinceLastBuild(File dir) {
		File[] classFiles = FileUtil.listFiles(dir, new FileFilter(){
		
			public boolean accept(File pathname) {
				return pathname.getName().endsWith(".class");
			}
		
		});
		for (int i = 0; i < classFiles.length; i++) {
			long modTime = classFiles[i].lastModified();
			if (modTime + 1000 >= lastSuccessfulBuildTime) return true;
		}
		return false;
	}
================= fetch private List getMatchingSubset(List declareAnnotations, ResolvedTypeX type) { 0d14ccf^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
	 * Looks through a list of declare annotation statements and only returns
	 * those that could possibly match on a field/method/ctor in type.
	 */
private List getMatchingSubset(List declareAnnotations, ResolvedTypeX type) {
	    List subset = new ArrayList();
	    //System.err.println("For type="+type+"\nPrior set: "+declareAnnotations);
	    for (Iterator iter = declareAnnotations.iterator(); iter.hasNext();) {
			DeclareAnnotation da = (DeclareAnnotation) iter.next();
			if (da.couldEverMatch(type)) {
				subset.add(da);
			}
		}
		//System.err.println("After set: "+subset);
		return subset;
	}
================= fetch private boolean applyDeclareAtType(DeclareAnnotation decA, ResolvedTypeX onType, 0d14ccf^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
/**
	 * Apply a declare @type - return true if we change the type
	 */
private boolean applyDeclareAtType(DeclareAnnotation decA, ResolvedTypeX onType,boolean reportProblems) {
		boolean didSomething = false;
		if (decA.matches(onType)) {
			
			//FIXME asc CRITICAL this should be guarded by the 'already has annotation' check below but isn't since the compiler is producing classfiles with deca affected things in...
			AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decA.getSourceLocation(),onType.getSourceLocation());
			
		    if (onType.hasAnnotation(decA.getAnnotationX().getSignature())) {
// FIXME asc Could put out a lint here for an already annotated type - the problem is that it may have
// picked up the annotation during 'source weaving' in which case the message is misleading.  Leaving it
// off for now...
//		      if (reportProblems) {
//		      	world.getLint().elementAlreadyAnnotated.signal(
//      		      new String[]{onType.toString(),decA.getAnnotationTypeX().toString()},
//      		      onType.getSourceLocation(),new ISourceLocation[]{decA.getSourceLocation()});
//		      }
		      return false;
		    }
			
			AnnotationX annoX = decA.getAnnotationX();
			
			// check the annotation is suitable for the target
			boolean problemReported = verifyTargetIsOK(decA, onType, annoX,reportProblems);
			
			if (!problemReported) {
				didSomething = true;
				ResolvedTypeMunger newAnnotationTM = new AnnotationOnTypeMunger(annoX);
				newAnnotationTM.setSourceLocation(decA.getSourceLocation());
				onType.addInterTypeMunger(new BcelTypeMunger(newAnnotationTM,decA.getAspect().resolve(world)));
				decA.copyAnnotationTo(onType);
			}
		}
		return didSomething;
	}
================= fetch private boolean doesAlreadyHaveAnnotation(ResolvedMember rm,DeclareAnnotation de 0d14ccf^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
     * Check if a resolved member (field/method/ctor) already has an annotation, if it
     * does then put out a warning and return true
     */
private boolean doesAlreadyHaveAnnotation(ResolvedMember rm,DeclareAnnotation deca,boolean reportProblems) {
	  if (rm.hasAnnotation(deca.getAnnotationTypeX())) {
	    if (reportProblems) {
        world.getLint().elementAlreadyAnnotated.signal(
      		new String[]{rm.toString(),deca.getAnnotationTypeX().toString()},
      		rm.getSourceLocation(),new ISourceLocation[]{deca.getSourceLocation()});
	    }
      	return true;
	  }
	  return false;
	}
================= fetch private boolean match(LazyMethodGen mg) { 0d14ccf^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
// ----
private boolean match(LazyMethodGen mg) {
		BcelShadow enclosingShadow;

		List shadowAccumulator = new ArrayList();
		// we want to match ajsynthetic constructors...
		if (mg.getName().equals("<init>")) {
			return matchInit(mg, shadowAccumulator);
		} else if (!shouldWeaveBody(mg)) { //.isAjSynthetic()) {
			return false;			
		} else {
			if (mg.getName().equals("<clinit>")) {
				clinitShadow = enclosingShadow = BcelShadow.makeStaticInitialization(world, mg);
				//System.err.println(enclosingShadow);
			} else if (mg.isAdviceMethod()) {
				enclosingShadow = BcelShadow.makeAdviceExecution(world, mg);
			} else {
				AjAttribute.EffectiveSignatureAttribute effective = mg.getEffectiveSignature();
				if (effective == null) {
					enclosingShadow = BcelShadow.makeMethodExecution(world, mg, !canMatchBodyShadows);
				} else if (effective.isWeaveBody()) {
					enclosingShadow =
						BcelShadow.makeShadowForMethod(
							world,
							mg,
							effective.getShadowKind(),
							effective.getEffectiveSignature());
				} else {
					return false;
				}
			}

			if (canMatchBodyShadows) {
				for (InstructionHandle h = mg.getBody().getStart();
					h != null;
					h = h.getNext()) {
					match(mg, h, enclosingShadow, shadowAccumulator);
				}
			}
			if (canMatch(enclosingShadow.getKind())) {
				if (match(enclosingShadow, shadowAccumulator)) {
					enclosingShadow.init();
				}
			}
			mg.matchedShadows = shadowAccumulator;
			return !shadowAccumulator.isEmpty();
		}
	}
================= fetch private boolean weaveDeclareAtField(LazyClassGen clazz) { 0d14ccf^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
	 * Weave any declare @field statements into the fields of the supplied class
	 */
private boolean weaveDeclareAtField(LazyClassGen clazz) {
	  
        // BUGWARNING not getting enough warnings out on declare @field ?
        // There is a potential problem here with warnings not coming out - this
        // will occur if they are created on the second iteration round this loop.
        // We currently deactivate error reporting for the second time round.
        // A possible solution is to record what annotations were added by what
        // decafs and check that to see if an error needs to be reported - this
        // would be expensive so lets skip it for now

        List decaFs = getMatchingSubset(world.getDeclareAnnotationOnFields(),clazz.getType());
		boolean isChanged = false;
		Field[] fields = clazz.getFieldGens();
		if (fields!=null && !decaFs.isEmpty()) {
          // go through all the fields
          for (int fieldCounter = 0;fieldCounter<fields.length;fieldCounter++) {
            BcelField aBcelField = new BcelField(clazz.getBcelObjectType(),fields[fieldCounter]);
			if (!aBcelField.getName().startsWith(NameMangler.PREFIX)) {
            // Single first pass
            List worthRetrying = new ArrayList();
            boolean modificationOccured = false;
            // go through all the declare @field statements
            for (Iterator iter = decaFs.iterator(); iter.hasNext();) {
				DeclareAnnotation decaF = (DeclareAnnotation) iter.next();
				if (decaF.matches(aBcelField,world)) {
					if (doesAlreadyHaveAnnotation(aBcelField,decaF,true)) continue; // skip this one...
					aBcelField.addAnnotation(decaF.getAnnotationX());
					AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decaF.getSourceLocation(),clazz.getName(),fields[fieldCounter]);
					isChanged = true;
					modificationOccured = true;
				} else {
					if (!decaF.isStarredAnnotationPattern()) 
						worthRetrying.add(decaF); // an annotation is specified that might be put on by a subsequent decaf
				}
			}
			
            // Multiple secondary passes
            while (!worthRetrying.isEmpty() && modificationOccured) {
              modificationOccured = false;
              // lets have another go
              List forRemoval = new ArrayList();
              for (Iterator iter = worthRetrying.iterator(); iter.hasNext();) {
				DeclareAnnotation decaF = (DeclareAnnotation) iter.next();
				if (decaF.matches(aBcelField,world)) {
					if (doesAlreadyHaveAnnotation(aBcelField,decaF,false)) continue; // skip this one...
					aBcelField.addAnnotation(decaF.getAnnotationX());
					AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decaF.getSourceLocation(),clazz.getName(),fields[fieldCounter]);
					isChanged = true;
					modificationOccured = true;
					forRemoval.add(decaF);
				}
			  }
			  worthRetrying.removeAll(forRemoval);
            }
			}
          }
        }
		return isChanged;
	}
================= fetch private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) { 0d14ccf^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
/**
     * Weave any declare @method/@ctor statements into the members of the supplied class
     */
private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {
		
		boolean isChanged = false;
        List decaMs = getMatchingSubset(world.getDeclareAnnotationOnMethods(),clazz.getType());
        List members = clazz.getMethodGens();
		if (!members.isEmpty() && !decaMs.isEmpty()) {
          // go through all the fields
          for (int memberCounter = 0;memberCounter<members.size();memberCounter++) {
            LazyMethodGen mg = (LazyMethodGen)members.get(memberCounter);
            if (!mg.getName().startsWith(NameMangler.PREFIX)) {
            // Single first pass
            List worthRetrying = new ArrayList();
            boolean modificationOccured = false;
            // go through all the declare @field statements
            for (Iterator iter = decaMs.iterator(); iter.hasNext();) {
				DeclareAnnotation decaM = (DeclareAnnotation) iter.next();
				
				if (decaM.matches(mg.getMemberView(),world)) {
	  				if (doesAlreadyHaveAnnotation(mg.getMemberView(),decaM,true)) continue; // skip this one...
					mg.addAnnotation(decaM.getAnnotationX());
					//System.err.println("Mloc ("+mg+") ="+mg.getSourceLocation());
					AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decaM.getSourceLocation(),clazz.getName(),mg.getMethod());
					isChanged = true;
					modificationOccured = true;
				} else {
					if (!decaM.isStarredAnnotationPattern()) 
						worthRetrying.add(decaM); // an annotation is specified that might be put on by a subsequent decaf
				}
			}
			
            // Multiple secondary passes
            while (!worthRetrying.isEmpty() && modificationOccured) {
              modificationOccured = false;
              // lets have another go
              List forRemoval = new ArrayList();
              for (Iterator iter = worthRetrying.iterator(); iter.hasNext();) {
				DeclareAnnotation decaM = (DeclareAnnotation) iter.next();
				if (decaM.matches(mg.getMemberView(),world)) {
					if (doesAlreadyHaveAnnotation(mg.getMemberView(),decaM,false)) continue; // skip this one...
					mg.addAnnotation(decaM.getAnnotationX());
					AsmRelationshipProvider.getDefault().addDeclareAnnotationRelationship(decaM.getSourceLocation(),clazz.getName(),mg.getMethod());
					isChanged = true;
					modificationOccured = true;
					forRemoval.add(decaM);
				}
			  }
			  worthRetrying.removeAll(forRemoval);
            }
            }
          }
        }
		return isChanged;
    }
================= fetch private void initialize() { 0d14ccf^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

private void initialize() {
    	if (returnType != null) return;
    	
    	//System.err.println("initializing: " + getName() + ", " + enclosingClass.getName() + ", " + returnType + ", " + savedMethod);
    	
		MethodGen gen = new MethodGen(savedMethod, enclosingClass.getName(), enclosingClass.getConstantPoolGen());
        
		this.returnType = gen.getReturnType();
		this.argumentTypes = gen.getArgumentTypes();

		this.declaredExceptions = gen.getExceptions();
		this.attributes = gen.getAttributes();
		this.annotations = gen.getAnnotations();
		this.maxLocals = gen.getMaxLocals();
        
//		this.returnType = BcelWorld.makeBcelType(memberView.getReturnType());
//		this.argumentTypes = BcelWorld.makeBcelTypes(memberView.getParameterTypes());
//
//		this.declaredExceptions = TypeX.getNames(memberView.getExceptions()); //gen.getExceptions();
//		this.attributes = new Attribute[0]; //gen.getAttributes();
//		this.maxLocals = savedMethod.getCode().getMaxLocals();
        
        
        if (gen.isAbstract() || gen.isNative()) {
            body = null;
        } else {
        	//body = new InstructionList(savedMethod.getCode().getCode());
            body = gen.getInstructionList();
            
            unpackHandlers(gen);
            unpackLineNumbers(gen);
            unpackLocals(gen);
        }
        assertGoodBody();
        
		//System.err.println("initialized: " + this.getClassName() + "." + this.getName());
    }
================= fetch private void matchGetInstruction(LazyMethodGen mg, InstructionHandle ih, BcelSha 0d14ccf^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

private void matchGetInstruction(LazyMethodGen mg, InstructionHandle ih, BcelShadow enclosingShadow, List shadowAccumulator) {
		FieldInstruction fi = (FieldInstruction) ih.getInstruction();
		Member field = BcelWorld.makeFieldSignature(clazz, fi);
		
		// synthetic fields are never join points
		if (field.getName().startsWith(NameMangler.PREFIX)) return;
		
		ResolvedMember resolvedField = field.resolve(world);
		if (resolvedField == null) {
			// we can't find the field, so it's not a join point.
			return;
		} else if (resolvedField.isSynthetic()) {
			// sets of synthetics aren't join points in 1.1
			return;
		} else {
			match(BcelShadow.makeFieldGet(world, mg, ih, enclosingShadow), shadowAccumulator);
		}
	}
================= fetch private void matchInvokeInstruction(LazyMethodGen mg, 0d14ccf^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

private void matchInvokeInstruction(LazyMethodGen mg,
		InstructionHandle ih,
		InvokeInstruction invoke,
		BcelShadow enclosingShadow,
		List shadowAccumulator) 
	{
		String methodName = invoke.getName(cpg);
		if (methodName.startsWith(NameMangler.PREFIX)) {
			Member method =
				BcelWorld.makeMethodSignature(clazz, invoke);
			ResolvedMember declaredSig = method.resolve(world);
			//System.err.println(method + ", declaredSig: "  +declaredSig);
			if (declaredSig == null) return;
			
			if (declaredSig.getKind() == Member.FIELD) {
				Shadow.Kind kind;
				if (method.getReturnType().equals(ResolvedTypeX.VOID)) {
					kind = Shadow.FieldSet;
				} else {
					kind = Shadow.FieldGet;
				}
				
				if (canMatch(Shadow.FieldGet) || canMatch(Shadow.FieldSet))
					match(BcelShadow.makeShadowForMethodCall(world, mg, ih, enclosingShadow,
							kind, declaredSig),
							shadowAccumulator);
			} else {
				AjAttribute.EffectiveSignatureAttribute effectiveSig =
					declaredSig.getEffectiveSignature();
				if (effectiveSig == null) return;
				//System.err.println("call to inter-type member: " + effectiveSig);
				if (effectiveSig.isWeaveBody()) return;
				if (canMatch(effectiveSig.getShadowKind()))
					match(BcelShadow.makeShadowForMethodCall(world, mg, ih, enclosingShadow,
							effectiveSig.getShadowKind(), effectiveSig.getEffectiveSignature()),
							shadowAccumulator);
			}
		} else {
			if (canMatch(Shadow.MethodCall))
				match(
						BcelShadow.makeMethodCall(world, mg, ih, enclosingShadow),
						shadowAccumulator);
		}
	}
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { 0d14ccf^:weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.Pointcut#match(org.aspectj.weaver.Shadow)
	 */
protected FuzzyBoolean matchInternal(Shadow shadow) {
		AnnotatedElement toMatchAgainst = null;
		Member member = shadow.getSignature();
		ResolvedMember rMember = member.resolve(shadow.getIWorld());

		if (rMember == null) {
		    if (member.getName().startsWith(NameMangler.PREFIX)) {
		    	return FuzzyBoolean.NO;
			}
			shadow.getIWorld().getLint().unresolvableMember.signal(member.toString(), getSourceLocation());
			return FuzzyBoolean.NO;
		}

		Shadow.Kind kind = shadow.getKind();
		if (kind == Shadow.StaticInitialization) {
			toMatchAgainst = rMember.getDeclaringType().resolve(shadow.getIWorld());
		} else if ( (kind == Shadow.ExceptionHandler)) {
			toMatchAgainst = rMember.getParameterTypes()[0].resolve(shadow.getIWorld());
		} else {
			toMatchAgainst = rMember;
		}
		
		annotationTypePattern.resolve(shadow.getIWorld());
		return annotationTypePattern.matches(toMatchAgainst);
	}
================= fetch protected Test findResidueInternal(Shadow shadow, ExposedState state) { 0d14ccf^:weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.Pointcut#findResidue(org.aspectj.weaver.Shadow, org.aspectj.weaver.patterns.ExposedState)
	 */
protected Test findResidueInternal(Shadow shadow, ExposedState state) {

		if (shadow.getKind()!=Shadow.MethodCall &&
			shadow.getKind()!=Shadow.ConstructorCall &&
			shadow.getKind()!=Shadow.ConstructorExecution &&
			shadow.getKind()!=Shadow.MethodExecution &&
			shadow.getKind()!=Shadow.FieldSet &&
			shadow.getKind()!=Shadow.FieldGet &&
			shadow.getKind()!=Shadow.StaticInitialization &&
			shadow.getKind()!=Shadow.PreInitialization &&
			shadow.getKind()!=Shadow.AdviceExecution &&
			shadow.getKind()!=Shadow.Initialization &&
			shadow.getKind()!=Shadow.ExceptionHandler
			) {
			IMessage lim = MessageUtil.error("Binding not supported in @pcds (1.5.0 M2 limitation) for "+shadow.getKind()+" join points, see: " +
						getSourceLocation());
			shadow.getIWorld().getMessageHandler().handleMessage(lim);
			throw new BCException("Binding not supported in @pcds (1.5.0 M2 limitation) for "+shadow.getKind()+" join points, see: " +
			getSourceLocation());
		}

		
		if (annotationTypePattern instanceof BindingAnnotationTypePattern) {
			BindingAnnotationTypePattern btp = (BindingAnnotationTypePattern)annotationTypePattern;
			TypeX annotationType = btp.annotationType;
			Var var = shadow.getKindedAnnotationVar(annotationType);
			
			// This should not happen, we shouldn't have gotten this far 
			// if we weren't going to find the annotation
			if (var == null) throw new BCException("Impossible! annotation=["+annotationType+
					                               "]  shadow=["+shadow+" at "+shadow.getSourceLocation()+
												   "]    pointcut is at ["+getSourceLocation()+"]");//return Literal.FALSE;
			// Check if we have already bound something to this formal
			if ((state.get(btp.getFormalIndex())!=null) &&(lastMatchedShadowId == shadow.shadowId)) {
//				ISourceLocation pcdSloc = getSourceLocation(); 
//				ISourceLocation shadowSloc = shadow.getSourceLocation();
//				Message errorMessage = new Message(
//					"Cannot use @pointcut to match at this location and bind a formal to type '"+var.getType()+
//					"' - the formal is already bound to type '"+state.get(btp.getFormalIndex()).getType()+"'"+
//					".  The secondary source location points to the problematic binding.",
//					shadowSloc,true,new ISourceLocation[]{pcdSloc}); 
//				shadow.getIWorld().getMessageHandler().handleMessage(errorMessage);
				state.setErroneousVar(btp.getFormalIndex());
			}
			state.set(btp.getFormalIndex(),var);
		} 
		return Literal.TRUE;
	}
================= fetch public MethodGen pack() { 0d14ccf^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
// ---- packing!
public MethodGen pack() {
    	//killNops();
        MethodGen gen =
            new MethodGen(
                getAccessFlags(),
                getReturnType(),
                getArgumentTypes(),
                null, //getArgumentNames(),
                getName(),
                getEnclosingClass().getName(),
                new InstructionList(),
                getEnclosingClass().getConstantPoolGen());
        for (int i = 0, len = declaredExceptions.length; i < len; i++) {
            gen.addException(declaredExceptions[i]);
        }
        
        for (int i = 0, len = attributes.length; i < len; i++) {
            gen.addAttribute(attributes[i]);
        }
        
        if (annotations!=null) { 
          for (int i = 0, len = annotations.length; i < len; i++) {
            gen.addAnnotation(annotations[i]);
          }
        }
        
        if (isSynthetic) {
			ConstantPoolGen cpg = gen.getConstantPool();
			int index = cpg.addUtf8("Synthetic");
			gen.addAttribute(new Synthetic(index, 0, new byte[0], cpg.getConstantPool()));
        }
        
        if (hasBody()) {
            packBody(gen);
            gen.setMaxLocals();
            gen.setMaxStack();
        } else {
        	gen.setInstructionList(null);
        }
        return gen;
    }
================= fetch public NewFieldTypeMunger(ResolvedMember signature, Set superMethodsCalled) { 0d14ccf^:weaver/src/org/aspectj/weaver/NewFieldTypeMunger.java

================= fetch public ResolvedMember resolve(World world) { 0d14ccf^:weaver/src/org/aspectj/weaver/ResolvedMember.java

public ResolvedMember resolve(World world) {
		return this;
	}
================= fetch public boolean hasAnnotation(TypeX ofType) { 0d14ccf^:weaver/src/org/aspectj/weaver/ResolvedMember.java

public ResolvedTypeX[] getAnnotationTypes() {
    	// The ctors don't allow annotations to be specified ... yet - but
    	// that doesn't mean it is an error to call this method.
    	// Normally the weaver will be working with subtypes of
    	// this type - BcelField/BcelMethod
    	return null;
    }
================= fetch public boolean isAjSynthetic() { 0d14ccf^:weaver/src/org/aspectj/weaver/ResolvedMember.java
// ??? true or false?
public boolean isAjSynthetic() {
    	return true;
    }
================= fetch public boolean matchesAnnotations(Member member,World world) { 0d14ccf^:weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java

public boolean matchesAnnotations(Member member,World world) {
	  ResolvedMember rMember = member.resolve(world);
	  if (rMember == null) {
	        if (member.getName().startsWith(NameMangler.PREFIX)) {
				return false;
			}
			world.getLint().unresolvableMember.signal(member.toString(), getSourceLocation());
			return false;
	  }
	  annotationPattern.resolve(world);
	  return annotationPattern.matches(rMember).alwaysTrue();
	}
================= fetch public boolean matchesIgnoringAnnotations(Member member, World world) { 0d14ccf^:weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java

public boolean matchesIgnoringAnnotations(Member member, World world) {
		//XXX performance gains would come from matching on name before resolving
		//    to fail fast.  ASC 30th Nov 04 => Not necessarily, it didn't make it faster for me.
		//    Here is the code I used:
		//		String n1 = member.getName();
		//		String n2 = this.getName().maybeGetSimpleName();
		//		if (n2!=null && !n1.equals(n2)) return false;

		// FIXME ASC : 
		if (member == null) return false;
		ResolvedMember sig = member.resolve(world);
		
		if (sig == null) {
			//XXX
			if (member.getName().startsWith(NameMangler.PREFIX)) {
				return false;
			}
			world.getLint().unresolvableMember.signal(member.toString(), getSourceLocation());
			return false;
		}
		
		// Java5 introduces bridge methods, we don't want to match on them at all...
		if (sig.isBridgeMethod()) {
			return false;
		}
		
		// This check should only matter when used from WithincodePointcut as KindedPointcut
		// has already effectively checked this with the shadows kind.
		if (kind != member.getKind()) {
			return false;
		}
		
		if (kind == Member.ADVICE) return true;
		
		if (!modifiers.matches(sig.getModifiers())) return false;
		
		if (kind == Member.STATIC_INITIALIZATION) {
			//System.err.println("match static init: " + sig.getDeclaringType() + " with " + this);
			return declaringType.matchesStatically(sig.getDeclaringType().resolve(world));
		} else if (kind == Member.FIELD) {
			
			if (!returnType.matchesStatically(sig.getReturnType().resolve(world))) return false;
			if (!name.matches(sig.getName())) return false;
			boolean ret = declaringTypeMatch(member.getDeclaringType(), member, world);
			//System.out.println("   ret: " + ret);
			return ret;
		} else if (kind == Member.METHOD) {
			// Change all this in the face of covariance...
			
			// Check the name
			if (!name.matches(sig.getName())) return false;
			
			// Check the parameters
			if (!parameterTypes.matches(world.resolve(sig.getParameterTypes()), TypePattern.STATIC).alwaysTrue()) {
				return false;
			}
			
			// If we have matched on parameters, let's just check it isn't because the last parameter in the pattern
			// is an array type and the method is declared with varargs
			// XXX - Ideally the shadow would be included in the msg but we don't know it...
			if (isNotMatchBecauseOfVarargsIssue(parameterTypes,sig.getModifiers())) { 
				world.getLint().cantMatchArrayTypeOnVarargs.signal(sig.toString(),getSourceLocation());
				return false;
			}

			if (parameterTypes.size()>0 && (sig.isVarargsMethod()^parameterTypes.get(parameterTypes.size()-1).isVarArgs)) 
				return false;
			
			// Check the throws pattern
			if (!throwsPattern.matches(sig.getExceptions(), world)) return false;

			return declaringTypeMatchAllowingForCovariance(member,world,returnType,sig.getReturnType().resolve(world));
		} else if (kind == Member.CONSTRUCTOR) {
			if (!parameterTypes.matches(world.resolve(sig.getParameterTypes()), TypePattern.STATIC).alwaysTrue()) {
				return false;
			}
			
			// If we have matched on parameters, let's just check it isn't because the last parameter in the pattern
			// is an array type and the method is declared with varargs
			// XXX - Ideally the shadow would be included in the msg but we don't know it...
			if (isNotMatchBecauseOfVarargsIssue(parameterTypes,sig.getModifiers())) { 
				world.getLint().cantMatchArrayTypeOnVarargs.signal(sig.toString(),getSourceLocation());
				return false;
			}
			
			if (!throwsPattern.matches(sig.getExceptions(), world)) return false;
			return declaringType.matchesStatically(member.getDeclaringType().resolve(world));
			//return declaringTypeMatch(member.getDeclaringType(), member, world);			
		}
		
		return false;
	}
================= fetch public static boolean weave( 0d14ccf^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

public static boolean weave(
		BcelWorld world,
		LazyClassGen clazz,
		List shadowMungers,
		List typeMungers) 
	{
		boolean b =  new BcelClassWeaver(world, clazz, shadowMungers, typeMungers).weave();
		//System.out.println(clazz.getClassName() + ", " + clazz.getType().getWeaverState());
		//clazz.print();
		return b;
	}
================= fetch public void addAnnotation(AnnotationX ax) { 0d14ccf^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

public void addAnnotation(AnnotationX ax) {
    	initialize();
//		if (!hasAnnotation(TypeX.forSignature(a.getTypeSignature()))) {
    	AnnotationGen ag = new AnnotationGen(ax.getBcelAnnotation(),enclosingClass.getConstantPoolGen(),true);
    	AnnotationGen[] newAnnotations = new AnnotationGen[annotations.length+1];
    	System.arraycopy(annotations,0,newAnnotations,0,annotations.length);
    	newAnnotations[annotations.length]=ag;
    	annotations = newAnnotations;
    	// FIXME asc does this mean we are managing two levels of annotations again?
    	// one here and one in the memberView??!?
    	memberView.addAnnotation(ax);
    }
================= fetch public void initializeArgAnnotationVars() { 0d14ccf^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public void initializeArgAnnotationVars() {
    	if (argAnnotationVars != null) return;
    	int numArgs = getArgCount();
    	argAnnotationVars = new Map[numArgs];
    	for (int i = 0; i < argAnnotationVars.length; i++) {
			argAnnotationVars[i] = new HashMap();
			//FIXME asc just delete this logic - we always build the Var on demand, as we don't know at weave time
			// what the full set of annotations could be (due to static/dynamic type differences...)
		}
    }
================= fetch public void initializeKindedAnnotationVars() { 0d14ccf^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public void initializeKindedAnnotationVars() {
    	if (kindedAnnotationVars != null) return;
    	kindedAnnotationVars = new HashMap();
    	// by determining what "kind" of shadow we are, we can find out the
    	// annotations on the appropriate element (method, field, constructor, type).
    	// Then create one BcelVar entry in the map for each annotation, keyed by
    	// annotation type (TypeX).
    	
    	// FIXME asc Refactor these once all shadow kinds added - there is lots of commonality
    	ResolvedTypeX[] annotations = null;
    	TypeX relevantType = null;
    	
    	if (getKind() == Shadow.StaticInitialization) {
    		relevantType = getSignature().getDeclaringType();
    		annotations  = relevantType.resolve(world).getAnnotationTypes();
    	}
    	if (getKind() == Shadow.ExceptionHandler) {
    		relevantType = getSignature().getParameterTypes()[0];
    		annotations  =  relevantType.resolve(world).getAnnotationTypes();
    	}
    	if (getKind() == Shadow.MethodCall  || getKind() == Shadow.ConstructorCall) {
    		relevantType = getSignature().getDeclaringType();
    		ResolvedMember rm[] = relevantType.getDeclaredMethods(world);
    		ResolvedMember found = null;
    		String searchString = getSignature().getName()+getSignature().getParameterSignature();
    		for (int i = 0; i < rm.length && found==null; i++) {
				ResolvedMember member = rm[i];
				if ((member.getName()+member.getParameterSignature()).equals(searchString)) {
					found = member;
				}
			}
    		annotations = found.getAnnotationTypes();
    	}
    	if (getKind() == Shadow.MethodExecution || getKind() == Shadow.ConstructorExecution || 
    		getKind() == Shadow.AdviceExecution) {
    		relevantType = getSignature().getDeclaringType();
    		ResolvedMember rm[] = relevantType.getDeclaredMethods(world);
    		ResolvedMember found = null;
    		String searchString = getSignature().getName()+getSignature().getParameterSignature();
    		for (int i = 0; i < rm.length && found==null; i++) {
				ResolvedMember member = rm[i];
				if ((member.getName()+member.getParameterSignature()).equals(searchString)) {
					found = member;
				}
			}
    		annotations = found.getAnnotationTypes();
    	}
    	if (getKind() == Shadow.PreInitialization || getKind() == Shadow.Initialization) {
    		relevantType = getSignature().getDeclaringType();
    		ResolvedMember rm[] = relevantType.getDeclaredMethods(world);
    		ResolvedMember found = null;
    		String searchString = getSignature().getName()+getSignature().getParameterSignature();
    		for (int i = 0; i < rm.length && found==null; i++) {
				ResolvedMember member = rm[i];
				if ((member.getName()+member.getParameterSignature()).equals(searchString)) {
					found = member;
				}
			}
    		annotations = found.getAnnotationTypes();
    	}
    	if (getKind() == Shadow.FieldSet) {
    		relevantType = getSignature().getDeclaringType();
    		ResolvedMember rm[] = relevantType.getDeclaredFields(world);
    		ResolvedMember found = null;
    		for (int i = 0; i < rm.length && found==null; i++) {
				ResolvedMember member = rm[i];
				if ( member.getName().equals(getSignature().getName()) &&
				     member.getType().equals(getSignature().getType()))  {
					found = member;
				}
			}
    		annotations = found.getAnnotationTypes();
    	}
    	if (getKind() == Shadow.FieldGet) {
    		relevantType = getSignature().getDeclaringType();
    		ResolvedMember rm[] = relevantType.getDeclaredFields(world);
    		ResolvedMember found = null;
    		for (int i = 0; i < rm.length && found==null; i++) {
				ResolvedMember member = rm[i];
				if ( member.getName().equals(getSignature().getName()) &&
				     member.getType().equals(getSignature().getType()))  {
					found = member;
				}
			}
    		annotations = found.getAnnotationTypes();
    	}
    	
    	if (annotations == null) {
    		// We can't have recognized the shadow - should blow up now to be on the safe side
    		throw new BCException("Didn't recognize shadow: "+getKind());
    	}
    	
		for (int i = 0; i < annotations.length; i++) {
			ResolvedTypeX aTX = annotations[i];
    		kindedAnnotationVars.put(aTX,
    				new KindedAnnotationAccessVar(getKind(),aTX.resolve(world),relevantType,getSignature()));
		}

    	
    	
    }
================= fetch public void initializeThisAnnotationVars() { 0d14ccf^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public void initializeThisAnnotationVars() {
    	if (thisAnnotationVars != null) return;
    	thisAnnotationVars = new HashMap();
    	// populate..
    }
================= fetch public void setCheckedExceptions(TypeX[] checkedExceptions) { 0d14ccf^:weaver/src/org/aspectj/weaver/ResolvedMember.java

public void setCheckedExceptions(TypeX[] checkedExceptions) {
		this.checkedExceptions = checkedExceptions;
	}
================= fetch public void testAnnotatedITDs() { 0d14ccf^:tests/src/org/aspectj/systemtest/ajc150/Annotations.java
// more implementation work needed before this test passes
public void testAnnotatedITDs() {
  	runTest("annotated itds");
  }
================= fetch public void testCallsAndExecutionsOfStaticMethods() { 0d14ccf^:tests/src/org/aspectj/systemtest/ajc150/AnnotationBinding.java
// Binding with calls/executions of static methods
public void testCallsAndExecutionsOfStaticMethods() {
  	runTest("binding with static methods");
  }
================= fetch public static TypeX fromBinding(TypeBinding binding) { fb01cad^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

public static TypeX[] fromBindings(TypeBinding[] bindings) {
		if (bindings == null) return TypeX.NONE;
		int len = bindings.length;
		TypeX[] ret = new TypeX[len];
		for (int i=0; i<len; i++) {
			ret[i] = fromBinding(bindings[i]);
		}
		return ret;
	}
================= fetch public void testAspectpathdirs() { fb01cad^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testAspectpathdirs() {
	  runTest("dirs on aspectpath");
  }
================= fetch Collection getModifiedBinaryFiles(long lastBuildTime) { 68f6350^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java

Collection getModifiedBinaryFiles(long lastBuildTime) {
		List ret = new ArrayList();
		//not our job to account for new and deleted files
		for (Iterator i = buildConfig.getBinaryFiles().iterator(); i.hasNext(); ) {
			AjBuildConfig.BinarySourceFile bsfile = (AjBuildConfig.BinarySourceFile)i.next();
			File file = bsfile.binSrc;
			if (!file.exists()) continue;
			
			long modTime = file.lastModified();
			//System.out.println("check: " + file + " mod " + modTime + " build " + lastBuildTime);			
			// need to add 1000 since lastModTime is only accurate to a second on some (all?) platforms
			if (modTime + 1000 >= lastBuildTime) {
				ret.add(bsfile);
			} 
		}
		return ret;
	}
================= fetch private boolean changed(List oldPath, List newPath) { 68f6350^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java

private boolean changed(List oldPath, List newPath) {
		if (oldPath == null) oldPath = new ArrayList();
		if (newPath == null) newPath = new ArrayList();
		if (oldPath.size() != newPath.size()) {
			return true;
		}
		for (int i = 0; i < oldPath.size(); i++) {
			if (!oldPath.get(i).equals(newPath.get(i))) {
				return true;
			}
			Object o = oldPath.get(i);  // String on classpath, File on other paths
			File f = null;
			if (o instanceof String) {
				f = new File((String)o);
			} else {
				f = (File) o;
			}
			if (f.exists() && !f.isDirectory() && (f.lastModified() >= lastSuccessfulBuildTime)) {
				return true;
			}
		}
		return false;
	}
================= fetch private boolean pathChange(AjBuildConfig oldConfig, AjBuildConfig newConfig) { 68f6350^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java

private boolean pathChange(AjBuildConfig oldConfig, AjBuildConfig newConfig) {
		boolean changed = false;
		List oldClasspath = oldConfig.getClasspath();
		List newClasspath = newConfig.getClasspath();
		if (changed(oldClasspath,newClasspath)) return true;
		List oldAspectpath = oldConfig.getAspectpath();
		List newAspectpath = newConfig.getAspectpath();
		if (changed(oldAspectpath,newAspectpath)) return true;
		List oldInJars = oldConfig.getInJars();
		List newInJars = newConfig.getInJars();
		if (changed(oldInJars,newInJars)) return true;
		List oldInPath = oldConfig.getInpath();
		List newInPath = newConfig.getInpath();
		if (changed(oldInPath, newInPath)) return true;
		return changed;
	}
================= fetch public void addLibraryJarFile(File inFile) throws IOException { 68f6350^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java

================= fetch public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r 68f6350^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java
/**
         * Extract AspectJ-specific options (except for argfiles).
         * Caller should warn when sourceroots is empty but in 
         * incremental mode.
         * Signals warnings or errors through handler set in constructor.
         */
public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.remove()
			int nextArgIndex = args.indexOf(arg)+1; // XXX assumes unique
            // trim arg?
            if (LangUtil.isEmpty(arg)) {
                showWarning("empty arg found");
            } else if (arg.equals("-inpath")) {;
            	if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_Inpath, CompilerOptions.PRESERVE);
					
					List inPath = buildConfig.getInpath();
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
					while (st.hasMoreTokens()) {
						String filename = st.nextToken();
						File file = makeFile(filename);
						if (file.exists() && FileUtil.hasZipSuffix(filename)) {
							inPath.add(file);    
						} else {
							if (file.isDirectory()) {
								inPath.add(file);
							} else 
		            		
							showError("bad inpath component: " + filename);  
						}
					}
					buildConfig.setInPath(inPath);
					args.remove(args.get(nextArgIndex));            		
            	}
            } else if (arg.equals("-injars")) {;
				if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_InJARs, CompilerOptions.PRESERVE);
					
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
		            	if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
			            	buildConfig.getInJars().add(jarFile);    
		            	} else {
		            		File dirFile = makeFile(filename);
		            		if (dirFile.isDirectory()) {
		            			buildConfig.getInJars().add(dirFile);
		            		} else 
		            		
                            showError("bad injar: " + filename);  
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-aspectpath")) {;
				if (args.size() > nextArgIndex) {
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
                        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
			            	buildConfig.getAspectpath().add(jarFile);    
		            	} else {
                            showError("bad aspectpath: " + filename);
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-sourceroots")) {
				if (args.size() > nextArgIndex) {
					List sourceRoots = new ArrayList();
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	File f = makeFile(st.nextToken());
		            	if (f.isDirectory() && f.canRead()) {
			                sourceRoots.add(f);
		            	} else {
                            showError("bad sourceroot: " + f);
		            	}		            		
		            }
				    if (0 < sourceRoots.size()) {
						buildConfig.setSourceRoots(sourceRoots);	
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-sourceroots requires list of directories");
				}
			} else if (arg.equals("-outjar")) { 
				if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_OutJAR, CompilerOptions.GENERATE);
					File jarFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
					if (FileUtil.hasZipSuffix(jarFile)) {
						try {
							if (!jarFile.exists()) {
                                jarFile.createNewFile();
                            }
                            buildConfig.setOutputJar(jarFile);  
						} catch (IOException ioe) { 
                            showError("unable to create outjar file: " + jarFile);
						}
					} else {
						showError("invalid -outjar file: " + jarFile);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-outjar requires jar path argument");
				}
            } else if (arg.equals("-incremental")) {
                buildConfig.setIncrementalMode(true);
            } else if (arg.equals("-XincrementalFile")) {
                if (args.size() > nextArgIndex) {
                    File file = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    buildConfig.setIncrementalFile(file);
                    if (!file.canRead()) {
                        showError("bad -XincrementalFile : " + file);
                        // if not created before recompile test, stop after first compile
                    }
                    args.remove(args.get(nextArgIndex));
                } else {
                    showError("-XincrementalFile requires file argument");
                }
			} else if (arg.equals("-emacssym")) {
				buildConfig.setEmacsSymMode(true);
				buildConfig.setGenerateModelMode(true);
			} else if (arg.equals("-XjavadocsInModel")) {
				buildConfig.setGenerateModelMode(true);
				buildConfig.setGenerateJavadocsInModelMode(true);
			} else if (arg.equals("-noweave") || arg.equals( "-XnoWeave")) {
				buildConfig.setNoWeave(true);
			} else if (arg.equals("-XserializableAspects")) {
				buildConfig.setXserializableAspects(true);
			} else if (arg.equals("-XlazyTjp")) {
				buildConfig.setXlazyTjp(true);
            } else if (arg.startsWith("-Xreweavable")) {
            	buildConfig.setXreweavable(true);
            	if (arg.endsWith(":compress")) {
            		buildConfig.setXreweavableCompressClasses(true);
            	}
			} else if (arg.equals("-XnoInline")) {
				buildConfig.setXnoInline(true);
            } else if (arg.startsWith("-showWeaveInfo")) {
            	 buildConfig.setShowWeavingInformation(true);
			} else if (arg.equals("-Xlintfile")) { 
				if (args.size() > nextArgIndex) {
					File lintSpecFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    // XXX relax restriction on props file suffix?
					if (lintSpecFile.canRead() && lintSpecFile.getName().endsWith(".properties")) {
						buildConfig.setLintSpecFile(lintSpecFile);	
					} else {
						showError("bad -Xlintfile file: " + lintSpecFile);
						buildConfig.setLintSpecFile(null);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-Xlintfile requires .properties file argument");
				}
            } else if (arg.equals("-Xlint")) {
//                buildConfig.getAjOptions().put(
//                    AjCompilerOptions.OPTION_Xlint,
//                    CompilerOptions.GENERATE);
                buildConfig.setLintMode(AjBuildConfig.AJLINT_DEFAULT);
            } else if (arg.startsWith("-Xlint:")) {
                if (7 < arg.length()) {
                    buildConfig.setLintMode(arg.substring(7));
                } else {
                    showError("invalid lint option " + arg);
                }
			} else if (arg.equals("-bootclasspath")) {
				if (args.size() > nextArgIndex) {
					String bcpArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer bcp = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(bcpArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    bcp.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        bcp.append(File.pathSeparator);
					    }
					}
					bootclasspath = bcp.toString();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-bootclasspath requires classpath entries");
				}
			} else if (arg.equals("-classpath") || arg.equals("-cp")) {
				if (args.size() > nextArgIndex) {
					String cpArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer cp = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(cpArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    cp.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        cp.append(File.pathSeparator);
					    }
					}
					classpath = cp.toString();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-classpath requires classpath entries");
				}
			} else if (arg.equals("-extdirs")) {
				if (args.size() > nextArgIndex) {
					String extdirsArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer ed = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(extdirsArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    ed.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        ed.append(File.pathSeparator);
					    }
					}					
					extdirs = ed.toString();
					args.remove(args.get(nextArgIndex));
                } else {
                    showError("-extdirs requires list of external directories");
                }
            // error on directory unless -d, -{boot}classpath, or -extdirs
            } else if (arg.equals("-d")) {
                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-classpath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-bootclasspath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-extdirs")) {
//                dirLookahead(arg, args, nextArgIndex);
            } else if (arg.equals("-proceedOnError")) {
            	buildConfig.setProceedOnError(true);
            } else if (new File(arg).isDirectory()) {
                showError("dir arg not permitted: " + arg);
            } else if (arg.equals("-1.5")) {
            	buildConfig.setBehaveInJava5Way(true);
            	unparsedArgs.add("-1.5");
// this would enable the '-source 1.5' to do the same as '-1.5' but doesnt sound quite right as
// as an option right now as it doesnt mean we support 1.5 source code - people will get confused...
            } else if (arg.equals("-source")) {
            	if (args.size() > nextArgIndex) {
            		String level = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
            		if (level.equals("1.5")){
            			buildConfig.setBehaveInJava5Way(true);
            		}
            		unparsedArgs.add("-source");
            		unparsedArgs.add(level);
            		args.remove(args.get(nextArgIndex));
            	}
			} else {
                // argfile, @file parsed by superclass
                // no eclipse options parsed:
                // -d args, -help (handled), 
                // -classpath, -target, -1.3, -1.4, -source [1.3|1.4]
                // -nowarn, -warn:[...], -deprecation, -noImportError,
                // -g:[...], -preserveAllLocals,
                // -referenceInfo, -encoding, -verbose, -log, -time
                // -noExit, -repeat
				// (Actually, -noExit grabbed by Main)
		    	unparsedArgs.add(arg);
			}
        }
================= fetch public void testVarargsInConsBug() { 68f6350^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testVarargsInConsBug() {
	  runTest("varargs in constructor sig");
  }
================= fetch public Set couldMatchKinds() { b0f270e^:weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java

public Set couldMatchKinds() {
		return Shadow.ALL_SHADOW_KINDS;
	}
================= fetch public boolean alwaysTrue() { b0f270e^:weaver/src/org/aspectj/weaver/patterns/IfPointcut.java

public static IfPointcut makeIfTruePointcut(State state) {
		IfPointcut ret = new IfTruePointcut();
		ret.state = state;
		return ret;
	}
================= fetch private boolean isNotMatchBecauseOfVarargsIssue(TypePatternList params,int modif b5f4d09^:weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java
/**
	 * return true if last argument in params is an Object[] but the modifiers say this method
	 * was declared with varargs (Object...).  We shouldn't be matching if this is the case.
	 */
private boolean isNotMatchBecauseOfVarargsIssue(TypePatternList params,int modifiers) {
		if (params.size()>0 && (modifiers & Constants.ACC_VARARGS)!=0 &&  // XXX Promote this to an isVarargs() on MethodSignature?
			!params.get(params.size()-1).isVarArgs) {
			return true;
		}
		return false;
	}
================= fetch public ExactTypePattern(TypeX type, boolean includeSubtypes,boolean isVarArgs) { b5f4d09^:weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java

================= fetch public boolean isStarAnnotation() { b5f4d09^:weaver/src/org/aspectj/weaver/patterns/TypePattern.java

public boolean isStarAnnotation() {
		return annotationPattern == AnnotationTypePattern.ANY;
	}
================= fetch public int getDimensions() { b5f4d09^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
/**
	 * Used in conjunction with checks on 'isStar()' to tell you if this pattern represents '*' or '*[]' which are 
	 * different !
	 */
public int getDimensions() {
		return dim;
	}
================= fetch public void testSyntaxError() { b5f4d09^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testSyntaxError() {
	  runTest("invalid cons syntax");
  }
Progress : [################################--------] 81%================= fetch private ResolvedMember getPointcutDeclaration(ReferencePointcut rp, MethodDeclar 85aa152^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java

private ResolvedMember getPointcutDeclaration(ReferencePointcut rp, MethodDeclaration declaration) {
		World world = ((AjLookupEnvironment)declaration.scope.environment()).factory.getWorld();
		TypeX onType = rp.onType;
		if (onType == null) {
		    Member member = EclipseFactory.makeResolvedMember(declaration.binding);
			onType = member.getDeclaringType();
		}
		ResolvedMember[] members = onType.getDeclaredPointcuts(world);
		if (members != null) {
			for (int i = 0; i < members.length; i++) {
			    if (members[i].getName().equals(rp.name)) {
			        return members[i];
			    }
			}
		}
		return null;
    }
================= fetch public void testBadASMforEnums() throws IOException { 85aa152^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

public void testBadASMforEnums() throws IOException {
  	runTest("bad asm for enums");
  	
  	if (System.getProperty("java.vm.version").startsWith("1.5")) {
	  	ByteArrayOutputStream baos = new ByteArrayOutputStream();
	  	PrintWriter pw = new PrintWriter(baos);
	  	AsmManager.dumptree(pw,AsmManager.getDefault().getHierarchy().getRoot(),0);
	  	pw.flush();
	  	String tree = baos.toString();
	  	assertTrue("Expected 'Red [enumvalue]' somewhere in here:"+tree,tree.indexOf("Red  [enumvalue]")!=-1);
  	}
  }
================= fetch private boolean matchesExactlyByName(String targetTypeName) { f90186c^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
/**
	 * @param targetTypeName
	 * @return
	 */
private boolean matchesExactlyByName(String targetTypeName) {
		//XXX hack
		if (knownMatches == null && importedPrefixes == null) {
			return innerMatchesExactly(targetTypeName);
		}
		
		if (isStar()) {
			// we match if the dimensions match
			int numDimensionsInTargetType = 0;
			if (dim > 0) {
				int index;
				while((index = targetTypeName.indexOf('[')) != -1) {
					numDimensionsInTargetType++;
					targetTypeName = targetTypeName.substring(index+1);
				}
				if (numDimensionsInTargetType == dim) {
					return true;
				} else {
					return false;
				}
			}
		}
		
		// if our pattern is length 1, then known matches are exact matches
		// if it's longer than that, then known matches are prefixes of a sort
		if (namePatterns.length == 1) {
			for (int i=0, len=knownMatches.length; i < len; i++) {
				if (knownMatches[i].equals(targetTypeName)) return true;
			}
		} else {
			for (int i=0, len=knownMatches.length; i < len; i++) {
				String knownPrefix = knownMatches[i] + "$";
				if (targetTypeName.startsWith(knownPrefix)) {
					int pos = lastIndexOfDotOrDollar(knownMatches[i]);
					if (innerMatchesExactly(targetTypeName.substring(pos+1))) {
						return true;
					}
				}
			}
		}


		// if any prefixes match, strip the prefix and check that the rest matches
		// assumes that prefixes have a dot at the end
		for (int i=0, len=importedPrefixes.length; i < len; i++) {
			String prefix = importedPrefixes[i];
			//System.err.println("prefix match? " + prefix + " to " + targetTypeName);
			if (targetTypeName.startsWith(prefix)) {
				
				if (innerMatchesExactly(targetTypeName.substring(prefix.length()))) {
					return true;
				}
			}
		}
		
		return innerMatchesExactly(targetTypeName);
	}
================= fetch public TypePattern resolveBindings(IScope scope, Bindings bindings, f90186c^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
/**
	 * Need to determine if I'm really a pattern or a reference to a formal
	 * 
	 * We may wish to further optimize the case of pattern vs. non-pattern
	 * 
	 * We will be replaced by what we return
	 */
public TypePattern resolveBindings(IScope scope, Bindings bindings, 
    								boolean allowBinding, boolean requireExactType)
    { 		
    	if (isStar()) {
    	    // If there is an annotation specified we have to
    	    // use a special variant of Any TypePattern called
    	    // AnyWithAnnotation
    		if (annotationPattern == AnnotationTypePattern.ANY) {
    		  if (dim == 0) { // pr72531
    			return TypePattern.ANY;  //??? loses source location
    		  } 
    		} else {
    	    	annotationPattern = annotationPattern.resolveBindings(scope,bindings,allowBinding);
    			AnyWithAnnotationTypePattern ret = new AnyWithAnnotationTypePattern(annotationPattern); 			
    			ret.setLocation(sourceContext,start,end);
    			return ret;
    		}
		}

    	annotationPattern = annotationPattern.resolveBindings(scope,bindings,allowBinding);
    	
		String simpleName = maybeGetSimpleName();
		if (simpleName != null) {
			FormalBinding formalBinding = scope.lookupFormal(simpleName);
			if (formalBinding != null) {
				if (bindings == null) {
					scope.message(IMessage.ERROR, this, "negation doesn't allow binding");
					return this;
				}
				if (!allowBinding) {
					scope.message(IMessage.ERROR, this, 
						"name binding only allowed in target, this, and args pcds");
					return this;
				}
				
				BindingTypePattern binding = new BindingTypePattern(formalBinding,isVarArgs);
				binding.copyLocationFrom(this);
				bindings.register(binding, scope);
				
				return binding;
			}
		}
		
		String cleanName = maybeGetCleanName();
		String originalName = cleanName;
		// if we discover it is 'MISSING' when searching via the scope, this next local var will
		// tell us if it is really missing or if it does exist in the world and we just can't
		// see it from the current scope.
		ResolvedTypeX resolvedTypeInTheWorld = null;
		if (cleanName != null) {
			TypeX type;
			
			//System.out.println("resolve: " + cleanName);
			//??? this loop has too many inefficiencies to count
			resolvedTypeInTheWorld = scope.getWorld().resolve(TypeX.forName(cleanName),true);
			while ((type = scope.lookupType(cleanName, this)) == ResolvedTypeX.MISSING) {
				int lastDot = cleanName.lastIndexOf('.');
				if (lastDot == -1) break;
				cleanName = cleanName.substring(0, lastDot) + '$' + cleanName.substring(lastDot+1);
				if (resolvedTypeInTheWorld == ResolvedTypeX.MISSING)
					resolvedTypeInTheWorld = scope.getWorld().resolve(TypeX.forName(cleanName),true);					
			}
			if (type == ResolvedTypeX.MISSING) {
				if (requireExactType) {
					if (!allowBinding) {
						scope.getWorld().getMessageHandler().handleMessage(
							MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_BIND_TYPE,originalName),
											getSourceLocation()));
					} else if (scope.getWorld().getLint().invalidAbsoluteTypeName.isEnabled()) {
						scope.getWorld().getLint().invalidAbsoluteTypeName.signal(originalName, getSourceLocation());
					}
					return NO;
				} else if (scope.getWorld().getLint().invalidAbsoluteTypeName.isEnabled()) {
					// Only put the lint warning out if we can't find it in the world
					if (resolvedTypeInTheWorld == ResolvedTypeX.MISSING)
					  scope.getWorld().getLint().invalidAbsoluteTypeName.signal(originalName, getSourceLocation());
				}
			} else {
				if (dim != 0) type = TypeX.makeArray(type, dim);
				TypePattern ret = new ExactTypePattern(type, includeSubtypes,isVarArgs);
				ret.copyLocationFrom(this);
				return ret;
			}
		} else {
			if (requireExactType) {
				scope.getWorld().getMessageHandler().handleMessage(
					MessageUtil.error(WeaverMessages.format(WeaverMessages.WILDCARD_NOT_ALLOWED),
										getSourceLocation()));
				return NO;
			}
			//XXX need to implement behavior for Lint.invalidWildcardTypeName
		}
		
		importedPrefixes = scope.getImportedPrefixes();
		knownMatches = preMatch(scope.getImportedNames());
		
		return this;
	}
================= fetch public boolean isStar() { f90186c^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
/**
	 * returns those possible matches which I match exactly the last element of
	 */
private String[] preMatch(String[] possibleMatches) {
		//if (namePatterns.length != 1) return CollectionUtil.NO_STRINGS;
		
		List ret = new ArrayList();
		for (int i=0, len=possibleMatches.length; i < len; i++) {
			char[][] names = splitNames(possibleMatches[i]); //??? not most efficient
			if (namePatterns[0].matches(names[names.length-1])) {
				ret.add(possibleMatches[i]);
			}
		}
		return (String[])ret.toArray(new String[ret.size()]);
	}
================= fetch protected void genBytecodeInfo(MethodDeclaration methodDeclaration, IProgramElem 5765d53^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java

protected void genBytecodeInfo(MethodDeclaration methodDeclaration, IProgramElement peNode) {
		if (methodDeclaration.binding != null) {
			String memberName = "";
			String memberBytecodeSignature = "";
			try {
				Member member = EclipseFactory.makeResolvedMember(methodDeclaration.binding);
				memberName = member.getName();
				memberBytecodeSignature = member.getSignature();
			} catch (NullPointerException npe) {
				memberName = "<undefined>";
			} 
			
			peNode.setBytecodeName(memberName);
			peNode.setBytecodeSignature(memberBytecodeSignature);
		}
		((IProgramElement)stack.peek()).addChild(peNode);
	}
================= fetch public boolean visit(ConstructorDeclaration constructorDeclaration, ClassScope s 5765d53^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java
//	}
public boolean visit(ConstructorDeclaration constructorDeclaration, ClassScope scope) {
		if (constructorDeclaration.isDefaultConstructor) {
			stack.push(null); // a little wierd but does the job
			return true;	
		}
		StringBuffer argumentsSignature = new StringBuffer();
		argumentsSignature.append("(");
		if (constructorDeclaration.arguments!=null) {
		  for (int i = 0;i<constructorDeclaration.arguments.length;i++) {
			argumentsSignature.append(constructorDeclaration.arguments[i]);
			if (i+1<constructorDeclaration.arguments.length) argumentsSignature.append(",");
		  }
		}
		argumentsSignature.append(")");
		IProgramElement peNode = new ProgramElement(
			new String(constructorDeclaration.selector)+argumentsSignature,
			IProgramElement.Kind.CONSTRUCTOR,	
			makeLocation(constructorDeclaration),
			constructorDeclaration.modifiers,
			"",
			new ArrayList());  
		
		peNode.setModifiers(constructorDeclaration.modifiers);
		peNode.setSourceSignature(genSourceSignature(constructorDeclaration));
		
		// Fix to enable us to anchor things from ctor nodes
		if (constructorDeclaration.binding != null) {
			String memberName = "";
			String memberBytecodeSignature = "";
			try {
				Member member = EclipseFactory.makeResolvedMember(constructorDeclaration.binding);
				memberName = member.getName();
				memberBytecodeSignature = member.getSignature();
			} catch (NullPointerException npe) {
				memberName = "<undefined>";
			} 
			peNode.setBytecodeName(memberName);
			peNode.setBytecodeSignature(memberBytecodeSignature);
		}
		
		
		((IProgramElement)stack.peek()).addChild(peNode);
		stack.push(peNode);
		return true;	
	}
================= fetch public static Test suite() { 5765d53^:ajde/testsrc/org/aspectj/ajde/AjdeTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(AjdeTests.class.getName());
        //$JUnit-BEGIN$
		suite.addTestSuite(ShowWeaveMessagesTestCase.class);
		suite.addTestSuite(DuplicateManifestTest.class);
		suite.addTestSuite(BuildOptionsTest.class); 
        suite.addTestSuite(BuildConfigurationTests.class);
        suite.addTestSuite(StructureModelRegressionTest.class); 
        suite.addTestSuite(StructureModelTest.class); 
        suite.addTestSuite(VersionTest.class); 
		suite.addTestSuite(CompilerMessagesTest.class);
		suite.addTestSuite(AsmDeclarationsTest.class);
		suite.addTestSuite(AsmRelationshipsTest.class);
		suite.addTestSuite(InpathTestcase.class);
		suite.addTestSuite(ReweavableTestCase.class);
		suite.addTestSuite(ResourceCopyTestCase.class);
		suite.addTestSuite(ModelPerformanceTest.class);
		suite.addTestSuite(SavedModelConsistencyTest. class);
		suite.addTestSuite(BuildCancellingTest.class);
		suite.addTestSuite(JarManifestTest.class);
		suite.addTestSuite(ExtensionTests.class);
		
        //$JUnit-END$
        return suite;
    }
================= fetch public void removeNOPs() { 7b4c7d7^:bcel-builder/src/org/aspectj/apache/bcel/generic/MethodGen.java

public void            setInstructionList(InstructionList il)  { this.il = il; }
================= fetch public PerClause concretize(ResolvedTypeX inAspect) { 1b01255^:weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java

public PerClause concretize(ResolvedTypeX inAspect) {
		PerTypeWithin ret = new PerTypeWithin(typePattern);
		ret.copyLocationFrom(this);
		ret.inAspect = inAspect;
		if (inAspect.isAbstract()) return ret;
		
		
		World world = inAspect.getWorld();
		
		SignaturePattern sigpat = new SignaturePattern(
				Member.STATIC_INITIALIZATION,
				ModifiersPattern.ANY,
				TypePattern.ANY,
				typePattern,
				NamePattern.ANY,
				TypePatternList.ANY,
				ThrowsPattern.ANY,
				AnnotationTypePattern.ANY
				);
		Pointcut testPc = new KindedPointcut(Shadow.StaticInitialization,sigpat);
		Pointcut testPc2= new WithinPointcut(typePattern);
		// This munger will initialize the aspect instance field in the matched type
		inAspect.crosscuttingMembers.addConcreteShadowMunger(Advice.makePerTypeWithinEntry(world, testPc, inAspect));
		
		ResolvedTypeMunger munger = new PerTypeWithinTargetTypeMunger(inAspect, ret);
		inAspect.crosscuttingMembers.addTypeMunger(world.concreteTypeMunger(munger, inAspect));
		return ret;
		
	}
================= fetch public Pointcut getTestPointcut() { 1b01255^:weaver/src/org/aspectj/weaver/PerTypeWithinTargetTypeMunger.java

public Pointcut getTestPointcut() {
		return testPointcut;
	}
================= fetch public boolean matches(ResolvedTypeX matchType, ResolvedTypeX aspectType) { 1b01255^:weaver/src/org/aspectj/weaver/PerTypeWithinTargetTypeMunger.java

public boolean matches(ResolvedTypeX matchType, ResolvedTypeX aspectType) {
		return testPointcut.getTypePattern().matches(matchType,TypePattern.STATIC).alwaysTrue();
	}
================= fetch public void testCanOverrideProtectedMethodsViaITDandDecp_pr83303() { 1b01255^:tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.java

public void testCanOverrideProtectedMethodsViaITDandDecp_pr83303() {
  	CompilationResult cR = ajc(baseDir,new String[]{"PR83303.java"});
  	assertTrue("Should be no errors:"+cR,!cR.hasErrorMessages());
  }
================= fetch public void abstractMethodCannotBeOverridden( 5d281fd^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java

public void abstractMethodCannotBeOverridden(
		SourceTypeBinding type,
		MethodBinding concreteMethod)
	{
		if (isPointcutDeclaration(concreteMethod)) {
			return;
		}
		super.abstractMethodCannotBeOverridden(type, concreteMethod);
	}
Progress : [################################--------] 82%================= fetch private static void processMembers(List/*IProgramElement*/ members, PrintWriter b460597^:ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java

private static void processMembers(List/*IProgramElement*/ members, PrintWriter writer, boolean declaringTypeIsInterface) throws IOException {
    	for (Iterator it = members.iterator(); it.hasNext();) {
			IProgramElement member = (IProgramElement) it.next();
		
	    	if (member.getKind().isType()) { 
	    		if (!member.getParent().getKind().equals(IProgramElement.Kind.METHOD)
	    			 && !StructureUtil.isAnonymous(member)) {// don't print anonymous types
//	    			System.err.println(">>>>>>>>>>>>>" + member.getName() + "<<<<" + member.getParent());
	    			processTypeDeclaration(member, writer);
	    		}
			} else {
		    	String formalComment = addDeclID(member, member.getFormalComment());;
		    	writer.println(formalComment);
		    	
		    	String signature = ""; 
		    	if (!member.getKind().equals(IProgramElement.Kind.POINTCUT)
		    	    && !member.getKind().equals(IProgramElement.Kind.ADVICE)) {
		    		signature = member.getSourceSignature();//StructureUtil.genSignature(member);
		    	} 
		    	
		    	if (member.getKind().isDeclare()) {
		    		System.err.println("> Skipping declare (ajdoc limitation): " + member.toLabelString());
		    	} else if (signature != null &&
		    		signature != "" && 
		    		!member.getKind().isInterTypeMember() &&
					!member.getKind().equals(IProgramElement.Kind.INITIALIZER) &&
					!StructureUtil.isAnonymous(member)) {   
		    		writer.print(signature);
		    	} else {
//		    		System.err.println(">> skipping: " + member.getKind());
		    	}  
		      
		    	if (member.getKind().equals(IProgramElement.Kind.METHOD) ||
		    		member.getKind().equals(IProgramElement.Kind.CONSTRUCTOR)) {
		    		if (member.getParent().getKind().equals(IProgramElement.Kind.INTERFACE) ||
		    			signature.indexOf("abstract ") != -1) {
		    			writer.println(";");
		    		} else {
		    			writer.println(" { }");
		    		}
		    		
		    	} else if (member.getKind().equals(IProgramElement.Kind.FIELD)) {
//		    		writer.println(";");
		    	}
			}
		}
    }
================= fetch static void addAspectDocumentation(IProgramElement node, StringBuffer fileBuffer b460597^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java

void addAspectDocumentation(IProgramElement node, StringBuffer fileBuffer, int index ) {
//        List relations = AsmManager.getDefault().getRelationshipMap().get(node);
//        System.err.println("> node: " + node + ", " + "relations: " + relations);
        

    	List pointcuts = new ArrayList();
    	List advice = new ArrayList();
    	for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
    		IProgramElement member = (IProgramElement)it.next();
    		if (member.getKind().equals(IProgramElement.Kind.POINTCUT)) {
    			pointcuts.add(member);
    		} else if (member.getKind().equals(IProgramElement.Kind.ADVICE)) {
    			advice.add(member);
    		}
    	}
    	if (pointcuts.size() > 0) {
    		insertDeclarationsSummary(fileBuffer, pointcuts, "Pointcut Summary", index);
    		insertDeclarationsDetails(fileBuffer, pointcuts, "Pointcut Detail", index);
    	}
    	if (advice.size() > 0) {
    		insertDeclarationsSummary(fileBuffer, advice, "Advice Summary", index);
    		insertDeclarationsDetails(fileBuffer, advice, "Advice Detail", index);
    	}
    }
================= fetch static void decorateHTMLFromDecl(Declaration decl, b460597^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java
/**
     * Before attempting to decorate the HTML file we have to verify that it exists,
     * which depends on the documentation visibility specified to c.
     *
     * Depending on docModifier, can document
     *   - public: only public
     *   - protected: protected and public (default)
     *   - package: package protected and public
     *   - private: everything
     */
static void decorateHTMLFromDecl(Declaration decl,
                                     String base,
                                     String docModifier,
                                     boolean exceededNestingLevel ) throws IOException {
        boolean nestedClass = false;
        if ( decl.isType() ) {
            boolean decorateFile = true;
            if ( (docModifier.equals("private")) || // everything
                 (docModifier.equals("package") && decl.getModifiers().indexOf( "private" ) == -1) || // package
                 (docModifier.equals("protected") && (decl.getModifiers().indexOf( "protected" ) != -1 ||
                                                        decl.getModifiers().indexOf( "public" ) != -1 )) ||
                 (docModifier.equals("public") && decl.getModifiers().indexOf( "public" ) != -1) ) {
                visibleFileList.add(decl.getSignature());
                String packageName = decl.getPackageName();
                String filename    = "";
                if ( packageName != null ) {
                   
                   int index1 = base.lastIndexOf(Config.DIR_SEP_CHAR);
                   int index2 = base.lastIndexOf(".");
                   String currFileClass = "";
                   if (index1 > -1 && index2 > 0 && index1 < index2) {
                      currFileClass = base.substring(index1+1, index2);
                   }
                   
                   // XXX only one level of nexting
                   if (currFileClass.equals(decl.getDeclaringType())) {
                   	  nestedClass = true;
                      packageName = packageName.replace( '.','/' );
                      String newBase = "";
                      if ( base.lastIndexOf(Config.DIR_SEP_CHAR) > 0 ) {
                         newBase = base.substring(0, base.lastIndexOf(Config.DIR_SEP_CHAR));
                      }
                      String signature = constructNestedTypeName(decl.getNode());
                     
                      filename = newBase + Config.DIR_SEP_CHAR + packageName +
                                 Config.DIR_SEP_CHAR + currFileClass + //"." +
                                 signature + ".html"; 
                   } else {
                       packageName = packageName.replace( '.','/' ); 
                       filename = base + packageName + Config.DIR_SEP_CHAR + decl.getSignature() + ".html";
                   }
                }
                else {
                    filename = base + decl.getSignature() + ".html";
                }
                if (!exceededNestingLevel) {
                    
                   decorateHTMLFile(new File(filename));
                   
                   decorateHTMLFromDecls(decl.getDeclarations(),
                                         base + decl.getSignature() + ".",
                                         docModifier,
                                         nestedClass);
                }
                else {
                   System.out.println("Warning: can not generate documentation for nested " +
                                      "inner class: " + decl.getSignature() );
                }
            }
        }
    }
================= fetch static void insertDeclarationsDetails(StringBuffer fileBuffer, b460597^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java

================= fetch static void insertDeclarationsSummary(StringBuffer fileBuffer, b460597^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java

================= fetch public void testCoverage() { f70b383^:ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java

public void testCoverage() {
		outdir.delete();
		String[] args = { 
//			"-XajdocDebug",
			"-source", 
			"1.4",
			"-private",
			"-d", 
			outdir.getAbsolutePath(),
			aspect1.getAbsolutePath(), 
			file0.getAbsolutePath(), 
			file1.getAbsolutePath(), 
			file2.getAbsolutePath(),
			file3.getAbsolutePath(),
			file4.getAbsolutePath(),
			file5.getAbsolutePath(),
			file6.getAbsolutePath(),
			file7.getAbsolutePath(),
			file8.getAbsolutePath(),
			file9.getAbsolutePath()
		};
		org.aspectj.tools.ajdoc.Main.main(args);
	}
================= fetch public void testOptions() { f70b383^:ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java

public void testOptions() {
		outdir.delete();
		String[] args = { 
			"-private",
			"-encoding",
			"EUCJIS",
			"-docencoding",
			"EUCJIS",
			"-charset",
			"UTF-8",
			"-d", 
			outdir.getAbsolutePath(),
			file0.getAbsolutePath(), 
		};
		org.aspectj.tools.ajdoc.Main.main(args);
	    assertTrue(true);
	}
================= fetch static int findDetailsIndex(StringBuffer fileBuffer, int index) { f70b383^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java

static int findDetailsIndex(StringBuffer fileBuffer, int index) {
        String fbs = fileBuffer.toString();
        String MARKER_1 = "<!-- ========= CONSTRUCTOR DETAIL ======== -->";
        String MARKER_2 = "<!-- ============ FIELD DETAIL =========== -->";
        String MARKER_3 = "<!-- ============ METHOD DETAIL ========== -->";
        int index1 = fbs.indexOf(MARKER_1, index);
        int index2 = fbs.indexOf(MARKER_2, index);
        int index3 = fbs.indexOf(MARKER_3, index);
        if (index1 < index2 && index1 < index3) {
            return index1;
        }
================= fetch static int findSummaryIndex(StringBuffer fileBuffer, int index) { f70b383^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java
/**
     * TODO: don't place the summary first.
     */
static int findSummaryIndex(StringBuffer fileBuffer, int index) {
        String fbs = fileBuffer.toString();
        String MARKER_1 = "<!-- =========== FIELD SUMMARY =========== -->";
        String MARKER_2 = "<!-- ======== CONSTRUCTOR SUMMARY ======== -->";
        int index1 = fbs.indexOf(MARKER_1, index);
        int index2 = fbs.indexOf(MARKER_2, index);
        if (index1 < index2) {
            return index1;
        }
        else {
            return index2;
        }
    }
================= fetch void doIt() { f70b383^:ajdoc/testdata/coverage/foo/ModelCoverage.java

void doIt() { 
		try {
			File f = new File(".");
			f.getCanonicalPath();
		} catch (IOException ioe) {
			System.err.println("!");	
		}	
//		setX(10);
		new Point();
	}
================= fetch private static InstructionHandle remap(InstructionHandle ih, Map map) { 603b063^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
/* private */
static void insertHandler(ExceptionRange fresh, LinkedList l) {
//        for (ListIterator iter = l.listIterator(); iter.hasNext();) {
//            ExceptionRange r = (ExceptionRange) iter.next();
//            if (fresh.getPriority() >= r.getPriority()) {
//                iter.previous();
//                iter.add(fresh);
//                return;
//            }            
//        }
        l.add(0, fresh);        
    }
================= fetch public static Test suite() { 603b063^:tests/src/org/aspectj/systemtest/AllTests.java

public static Test suite() {
		TestSuite suite = new TestSuite("AspectJ System Test Suite - JDK 1.3");
		//$JUnit-BEGIN$
		suite.addTest(AllTestsJava5_binaryWeaving.suite());
		suite.addTest(Ajc121Tests.suite());
		suite.addTest(Ajc120Tests.suite());
		suite.addTest(Ajc11Tests.suite());
		suite.addTest(Ajc10xTests.suite());
		suite.addTest(AspectPathTests.suite());
		suite.addTest(InPathTests.suite());
		suite.addTest(BaseTests.suite());
		suite.addTest(DesignTests.suite());
		suite.addTest(IncrementalTests.suite());
		suite.addTest(IncrementalModelTests.suite());
		//suite.addTest(KnownLimitationsTests.class);
		suite.addTest(OptionsTests.suite());
		suite.addTest(AjcPre10xTests.suite());
		//suite.addTest(PureJavaTests.class);
		suite.addTest(SUIDTests.suite());
		suite.addTest(XLintTests.suite());
		//$JUnit-END$
		return suite;
	}
================= fetch public void packBody(MethodGen gen) { 603b063^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
/** fill the newly created method gen with our body, 
     * inspired by InstructionList.copy()
     */
public void packBody(MethodGen gen) {
        HashMap map = new HashMap();
        InstructionList fresh = gen.getInstructionList();
        
        /* Make copies of all instructions, append them to the new list
         * and associate old instruction references with the new ones, i.e.,
         * a 1:1 mapping.
         */
        for (InstructionHandle ih = getBody().getStart(); ih != null; ih = ih.getNext()) {
            if (Range.isRangeHandle(ih)) {
                continue;
            }
            Instruction i = ih.getInstruction();
            Instruction c = Utility.copyInstruction(i);

            if (c instanceof BranchInstruction)
                map.put(ih, fresh.append((BranchInstruction) c));
            else
                map.put(ih, fresh.append(c));
        }
        // at this point, no rangeHandles are in fresh.  Let's use that...

        /* Update branch targets and insert various attributes.  
         * Insert our exceptionHandlers
         * into a sorted list, so they can be added in order later.
         */
        InstructionHandle ih = getBody().getStart();
        InstructionHandle jh = fresh.getStart();

        LinkedList exnList = new LinkedList();   

		// map from localvariabletag to instruction handle
        Map localVariableStarts = new HashMap();
        Map localVariableEnds = new HashMap();

        int currLine = -1;
        
        while (ih != null) {
            if (map.get(ih) == null) {
                // we're a range instruction
                Range r = Range.getRange(ih);
                if (r instanceof ExceptionRange) {
                    ExceptionRange er = (ExceptionRange) r;
                    if (er.getStart() == ih) {
                    	//System.err.println("er " + er);
                    	if (!er.isEmpty()){
                        	// order is important, insert handlers in order of start
                        	insertHandler(er, exnList);
                    	}
                    }
                } else {
                    // we must be a shadow range or something equally useless, 
                    // so forget about doing anything
                }
                // just increment ih. 
                ih = ih.getNext();
            } else {
                // assert map.get(ih) == jh
                Instruction i = ih.getInstruction();
                Instruction j = jh.getInstruction();
    
                if (i instanceof BranchInstruction) {
                    BranchInstruction bi = (BranchInstruction) i;
                    BranchInstruction bj = (BranchInstruction) j;
                    InstructionHandle itarget = bi.getTarget(); // old target
    
//    				try {
                    // New target is in hash map
                    bj.setTarget(remap(itarget, map));
//    				} catch (NullPointerException e) {
//    					print();
//    					System.out.println("Was trying to remap " + bi);
//    					System.out.println("who's target was supposedly " + itarget);
//    					throw e;
//    				}
    
                    if (bi instanceof Select) { 
                        // Either LOOKUPSWITCH or TABLESWITCH
                        InstructionHandle[] itargets = ((Select) bi).getTargets();
                        InstructionHandle[] jtargets = ((Select) bj).getTargets();
    
                        for (int k = itargets.length - 1; k >= 0; k--) { 
                            // Update all targets
                            jtargets[k] = remap(itargets[k], map);
                            jtargets[k].addTargeter(bj);
                        }
                    }
                }
                
                // now deal with line numbers 
                // and store up info for local variables
                InstructionTargeter[] targeters = ih.getTargeters();
				int lineNumberOffset =
					(fromFilename == null)
						? 0
						: getEnclosingClass().getSourceDebugExtensionOffset(fromFilename);
                if (targeters != null) {
                    for (int k = targeters.length - 1; k >= 0; k--) {
                        InstructionTargeter targeter = targeters[k];
                        if (targeter instanceof LineNumberTag) {
                            int line = ((LineNumberTag)targeter).getLineNumber();
                            if (line != currLine) {
                                gen.addLineNumber(jh, line + lineNumberOffset);
                                currLine = line;
                            }
                        } else if (targeter instanceof LocalVariableTag) {
                            LocalVariableTag lvt = (LocalVariableTag) targeter;
			    if (localVariableStarts.get(lvt) == null) {
				localVariableStarts.put(lvt, jh);
			    }
			    localVariableEnds.put(lvt, jh);
                        }
                    }
                }
                // now continue
                ih = ih.getNext();
                jh = jh.getNext();
            }
        }
	
        // now add exception handlers
        for (Iterator iter = exnList.iterator(); iter.hasNext();) {
            ExceptionRange r = (ExceptionRange) iter.next();
            if (r.isEmpty()) continue;
            gen.addExceptionHandler(
                remap(r.getRealStart(), map), 
                remap(r.getRealEnd(), map),
                remap(r.getHandler(), map),
                (r.getCatchType() == null)
                ? null 
                : (ObjectType) BcelWorld.makeBcelType(r.getCatchType()));
        }
        // now add local variables
        gen.removeLocalVariables();

		// this next iteration _might_ be overkill, but we had problems with
		// bcel before with duplicate local variables.  Now that we're patching
		// bcel we should be able to do without it if we're paranoid enough
		// through the rest of the compiler.
        
        Map duplicatedLocalMap = new HashMap();
		List keys = new ArrayList(); 
        keys.addAll(localVariableStarts.keySet());
        for (Iterator iter = keys.iterator(); iter.hasNext(); ) {
            LocalVariableTag tag = (LocalVariableTag) iter.next();
        	// have we already added one with the same slot number and start location?  
        	// if so, just continue.
        	InstructionHandle start = (InstructionHandle) localVariableStarts.get(tag);
        	Set slots = (Set) duplicatedLocalMap.get(start);
	       	if (slots == null) {
	       		slots = new HashSet();
	       		duplicatedLocalMap.put(start, slots);	
	       	}
	       	if (slots.contains(new Integer(tag.getSlot()))) {
	       		// we already have a var starting at this tag with this slot
	       		continue;
	       	}
	       	slots.add(new Integer(tag.getSlot()));

            gen.addLocalVariable(
                tag.getName(), 
                BcelWorld.makeBcelType(tag.getType()),
                tag.getSlot(),
                (InstructionHandle) localVariableStarts.get(tag),
                (InstructionHandle) localVariableEnds.get(tag));
        }

    }
================= fetch private boolean matchesAny(TypePattern typePattern, Class[] types) { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java

private boolean matchesAny(TypePattern typePattern, Class[] types) {
		for (int i = types.length - 1; i >= 0; i--) {
			if (typePattern.matchesStatically(types[i])) return true;	
		}
		return false;
	}
================= fetch private void checkSerialization(Declare declare) throws IOException { 797b6a6^:weaver/testsrc/org/aspectj/weaver/patterns/DeclareErrorOrWarningTestCase.java

private void checkSerialization(Declare declare) throws IOException {
		ByteArrayOutputStream bo = new ByteArrayOutputStream();
		DataOutputStream out = new DataOutputStream(bo);
		declare.write(out);
		out.close();
		
		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
		DataInputStream in = new DataInputStream(bi);
		Declare newDeclare = Declare.read(in, null);
		
		assertEquals("write/read", declare, newDeclare);	
	}
================= fetch private void checkSerialization(NamePattern p) throws IOException { 797b6a6^:weaver/testsrc/org/aspectj/weaver/patterns/NamePatternTestCase.java

private void checkSerialization(NamePattern p) throws IOException {
		ByteArrayOutputStream bo = new ByteArrayOutputStream();
		DataOutputStream out = new DataOutputStream(bo);
		p.write(out);
		out.close();
		
		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
		DataInputStream in = new DataInputStream(bi);
		NamePattern newP = NamePattern.read(in);
		
		assertEquals("write/read", p, newP);	
	}
================= fetch private void checkSerialization(Pointcut p) throws IOException { 797b6a6^:weaver/testsrc/org/aspectj/weaver/patterns/WithinTestCase.java

private void checkSerialization(Pointcut p) throws IOException {
		ByteArrayOutputStream bo = new ByteArrayOutputStream();
		DataOutputStream out = new DataOutputStream(bo);
		p.write(out);
		out.close();
		
		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
		DataInputStream in = new DataInputStream(bi);
		Pointcut newP = Pointcut.read(in, null);
		
		assertEquals("write/read", p, newP);	
	}
================= fetch private void checkSerialization(SignaturePattern p) throws IOException { 797b6a6^:weaver/testsrc/org/aspectj/weaver/patterns/SignaturePatternTestCase.java

private void checkSerialization(SignaturePattern p) throws IOException {
		ByteArrayOutputStream bo = new ByteArrayOutputStream();
		DataOutputStream out = new DataOutputStream(bo);
		p.write(out);
		out.close();
		
		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
		DataInputStream in = new DataInputStream(bi);
		SignaturePattern newP = SignaturePattern.read(in, null);
		
		assertEquals("write/read", p, newP);	
	}
================= fetch private void checkSerialization(String string) throws IOException { 797b6a6^:weaver/testsrc/org/aspectj/weaver/patterns/AndOrNotTestCase.java
/**
	 * Method checkSerialization.
	 * @param string
	 */
private void checkSerialization(String string) throws IOException {
		Pointcut p = makePointcut(string);
		ByteArrayOutputStream bo = new ByteArrayOutputStream();
		DataOutputStream out = new DataOutputStream(bo);
		p.write(out);
		out.close();
		
		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
		DataInputStream in = new DataInputStream(bi);
		Pointcut newP = Pointcut.read(in, null);
		
		assertEquals("write/read", p, newP);	
	}
================= fetch private void checkSerialization(String string) throws IOException { 797b6a6^:weaver/testsrc/org/aspectj/weaver/patterns/ModifiersPatternTestCase.java
/**
	 * Method checkSerialization.
	 * @param string
	 */
private void checkSerialization(String string) throws IOException {
		ModifiersPattern p = makeModifiersPattern(string);
		ByteArrayOutputStream bo = new ByteArrayOutputStream();
		DataOutputStream out = new DataOutputStream(bo);
		p.write(out);
		out.close();
		
		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
		DataInputStream in = new DataInputStream(bi);
		ModifiersPattern newP = ModifiersPattern.read(in);
		
		assertEquals("write/read", p, newP);	
	}
================= fetch private void checkSerialization(String string) throws IOException { 797b6a6^:weaver/testsrc/org/aspectj/weaver/patterns/TypePatternListTestCase.java
/**
	 * Method checkSerialization.
	 * @param string
	 */
private void checkSerialization(String string) throws IOException {
		TypePatternList p = makeArgumentsPattern(string);
		ByteArrayOutputStream bo = new ByteArrayOutputStream();
		DataOutputStream out = new DataOutputStream(bo);
		p.write(out);
		out.close();
		
		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
		DataInputStream in = new DataInputStream(bi);
		TypePatternList newP = TypePatternList.read(in, null);
		
		assertEquals("write/read", p, newP);	
	}
================= fetch private void checkSerialization(String string) throws IOException { 797b6a6^:weaver/testsrc/org/aspectj/weaver/patterns/TypePatternTestCase.java
/**
	 * Method checkSerialization.
	 * @param string
	 */
private void checkSerialization(String string) throws IOException {
		TypePattern p = makeTypePattern(string);
		ByteArrayOutputStream bo = new ByteArrayOutputStream();
		DataOutputStream out = new DataOutputStream(bo);
		p.write(out);
		out.close();
		
		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
		DataInputStream in = new DataInputStream(bi);
		TypePattern newP = TypePattern.read(in, null);
		
		assertEquals("write/read", p, newP);	
	}
================= fetch private void printAspectAttributes(PrintStream out) { 797b6a6^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

private void printAspectAttributes(PrintStream out) {
		ISourceContext context = null;
		if (enclosingClass != null && enclosingClass.getType() != null) {
			context = enclosingClass.getType().getSourceContext();
		}
		List as = BcelAttributes.readAjAttributes(attributes, context,null);
		if (! as.isEmpty()) {
			out.println("    " + as.get(0)); // XXX assuming exactly one attribute, munger...
		}
	}
================= fetch private void unpackAjAttributes(World world) { 797b6a6^:weaver/src/org/aspectj/weaver/bcel/BcelMethod.java

private void unpackAjAttributes(World world) {
		List as = BcelAttributes.readAjAttributes(method.getAttributes(), getSourceContext(world),world.getMessageHandler());
		//System.out.println("unpack: " + this + ", " + as);
		for (Iterator iter = as.iterator(); iter.hasNext();) {
			AjAttribute a = (AjAttribute) iter.next();
			if (a instanceof AjAttribute.MethodDeclarationLineNumberAttribute) {
				declarationLineNumber = (AjAttribute.MethodDeclarationLineNumberAttribute)a;
			} else if (a instanceof AjAttribute.AdviceAttribute) {
				associatedShadowMunger = ((AjAttribute.AdviceAttribute)a).reify(this, world);
				return;
			} else if (a instanceof AjAttribute.AjSynthetic) {
				isAjSynthetic = true;
			} else if (a instanceof AjAttribute.EffectiveSignatureAttribute) {
				//System.out.println("found effective: " + this);
				effectiveSignature = (AjAttribute.EffectiveSignatureAttribute)a;
			} else {
				throw new BCException("weird method attribute " + a);
			}
		}
		associatedShadowMunger = null;
	}
================= fetch private void unpackAspectAttributes() { 797b6a6^:weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java

private void unpackAspectAttributes() {
		List pointcuts = new ArrayList();
		typeMungers = new ArrayList();
		declares = new ArrayList();
		List l = BcelAttributes.readAjAttributes(javaClass.getAttributes(), getResolvedTypeX().getSourceContext(),getResolvedTypeX().getWorld().getMessageHandler());
		for (Iterator iter = l.iterator(); iter.hasNext();) {
			AjAttribute a = (AjAttribute) iter.next();
			//System.err.println("unpacking: " + this + " and " + a);
			if (a instanceof AjAttribute.Aspect) {
				perClause = ((AjAttribute.Aspect)a).reify(this.getResolvedTypeX());
			} else if (a instanceof AjAttribute.PointcutDeclarationAttribute) {
				pointcuts.add(((AjAttribute.PointcutDeclarationAttribute)a).reify());
			} else if (a instanceof AjAttribute.WeaverState) {
				weaverState = ((AjAttribute.WeaverState)a).reify();
			} else if (a instanceof AjAttribute.TypeMunger) {
				typeMungers.add(((AjAttribute.TypeMunger)a).reify(getResolvedTypeX().getWorld(), getResolvedTypeX()));
			} else if (a instanceof AjAttribute.DeclareAttribute) {
				declares.add(((AjAttribute.DeclareAttribute)a).getDeclare());
			} else if (a instanceof AjAttribute.PrivilegedAttribute) {
				privilegedAccess = ((AjAttribute.PrivilegedAttribute)a).getAccessedMembers();
			} else if (a instanceof AjAttribute.SourceContextAttribute) {
				if (getResolvedTypeX().getSourceContext() instanceof BcelSourceContext) {
					((BcelSourceContext)getResolvedTypeX().getSourceContext()).addAttributeInfo((AjAttribute.SourceContextAttribute)a);
				}
			} else if (a instanceof AjAttribute.WeaverVersionInfo) {
				wvInfo = (AjAttribute.WeaverVersionInfo)a;
				if (wvInfo.getMajorVersion() > WeaverVersionInfo.getCurrentWeaverMajorVersion()) {
					// The class file containing this attribute was created by a version of AspectJ that
					// added some behavior that 'this' version of AspectJ doesn't understand.  And the
					// class file contains changes that mean 'this' version of AspectJ cannot continue.
					throw new BCException("Unable to continue, this version of AspectJ supports classes built with weaver version "+
							WeaverVersionInfo.toCurrentVersionString()+" but the class "+ javaClass.getClassName()+" is version "+wvInfo.toString());
				}
			} else {
				throw new BCException("bad attribute " + a);
			}
		}
		this.pointcuts = (ResolvedPointcutDefinition[]) 
			pointcuts.toArray(new ResolvedPointcutDefinition[pointcuts.size()]);
//		this.typeMungers = (BcelTypeMunger[]) 
//			typeMungers.toArray(new BcelTypeMunger[typeMungers.size()]);
//		this.declares = (Declare[])
//			declares.toArray(new Declare[declares.size()]);	
	}
================= fetch private void unpackAttributes(World world) { 797b6a6^:weaver/src/org/aspectj/weaver/bcel/BcelField.java

private void unpackAttributes(World world) {
		Attribute[] attrs = field.getAttributes();
		List as = BcelAttributes.readAjAttributes(attrs, getSourceContext(world),world.getMessageHandler());
		for (Iterator iter = as.iterator(); iter.hasNext();) {
			AjAttribute a = (AjAttribute) iter.next();
			if (a instanceof AjAttribute.AjSynthetic) {
				isAjSynthetic = true;
			} else {
				throw new BCException("weird field attribute " + a);
			}
		}
		isAjSynthetic = false;
		
		
		for (int i = attrs.length - 1; i >= 0; i--) {
			if (attrs[i] instanceof Synthetic) isSynthetic = true;
		}
	}
================= fetch public AdviceAttribute(AdviceKind kind, Pointcut pointcut, int extraArgumentFlag 797b6a6^:weaver/src/org/aspectj/weaver/AjAttribute.java

public String getNameString() {
			return AttributeName;
		}
================= fetch public AdviceKind(String name, int key, int precedence, boolean isAfter, boolean 797b6a6^:weaver/src/org/aspectj/weaver/AdviceKind.java

================= fetch public AnnotationTypePattern resolveBindings(IScope scope, Bindings bindings, 797b6a6^:weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java
/**
	 * This can modify in place, or return a new TypePattern if the type changes.
	 */
public AnnotationTypePattern resolveBindings(IScope scope, Bindings bindings, 
    								             boolean allowBinding)
    { 
    	return this;
    }
================= fetch public AnnotationTypePattern resolveBindings(IScope scope, 797b6a6^:weaver/src/org/aspectj/weaver/patterns/AndAnnotationTypePattern.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.AnnotationTypePattern#resolveBindings(org.aspectj.weaver.patterns.IScope, org.aspectj.weaver.patterns.Bindings, boolean)
	 */
public AnnotationTypePattern resolveBindings(IScope scope,
			Bindings bindings, boolean allowBinding) {
		left = left.resolveBindings(scope,bindings,allowBinding);
		right =right.resolveBindings(scope,bindings,allowBinding);
		return this;
	}
================= fetch public AnnotationTypePattern resolveBindings(IScope scope, 797b6a6^:weaver/src/org/aspectj/weaver/patterns/OrAnnotationTypePattern.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.AnnotationTypePattern#resolveBindings(org.aspectj.weaver.patterns.IScope, org.aspectj.weaver.patterns.Bindings, boolean)
	 */
public AnnotationTypePattern resolveBindings(IScope scope,
			Bindings bindings, boolean allowBinding) {
		left = left.resolveBindings(scope,bindings,allowBinding);
		right =right.resolveBindings(scope,bindings,allowBinding);
		return this;
	}
================= fetch public TypePattern remapAdviceFormals(IntMap bindings) { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/TypePattern.java
/**
     * This is called during concretization of pointcuts, it is used by BindingTypePattern
     * to return a new BindingTypePattern with a formal index appropiate for the advice,
     * rather than for the lexical declaration, i.e. this handles transforamtions through
     * named pointcuts.
     * <pre>
     * pointcut foo(String name): args(name);
     * --&gt; This makes a BindingTypePattern(0) pointing to the 0th formal
     * 
     * before(Foo f, String n): this(f) && foo(n) { ... }
     * --&gt; when resolveReferences is called on the args from the above, it
     *     will return a BindingTypePattern(1)
     * 
     * before(Foo f): this(f) && foo(*) { ... }
     * --&gt; when resolveReferences is called on the args from the above, it
     *     will return an ExactTypePattern(String)
     * </pre>
     */
public TypePattern remapAdviceFormals(IntMap bindings) {
		return this;
	}
================= fetch public WeaverStateInfo reify() { 797b6a6^:weaver/src/org/aspectj/weaver/AjAttribute.java

public WeaverStateInfo reify() {
			return kind;
		}
================= fetch public boolean matches(int modifiers) { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/ModifiersPattern.java

public boolean matches(int modifiers) {
		return ((modifiers & requiredModifiers) == requiredModifiers) &&
		        ((modifiers & forbiddenModifiers) == 0);
	}
================= fetch public final Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/PerClause.java

public final Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {
    	throw new RuntimeException("unimplemented: wrong concretize");
    }
================= fetch public int hashCode() { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.java

public int hashCode() {
        int result = 41;
        for (int i = 0, len = typePatterns.length; i < len; i++) {
            result = 37*result + typePatterns[i].hashCode();
        }
        return result;
    }
================= fetch public int hashCode() { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/TypePatternList.java

public int hashCode() {
        int result = 41;
        for (int i = 0, len = typePatterns.length; i < len; i++) {
            result = 37*result + typePatterns[i].hashCode();
        }
        return result;
    }
================= fetch public static AjAttribute read(String name, byte[] bytes, ISourceContext context 797b6a6^:weaver/src/org/aspectj/weaver/AjAttribute.java

public static AjAttribute read(String name, byte[] bytes, ISourceContext context,IMessageHandler msgHandler) {
		try {
			if (bytes == null) bytes = new byte[0];
			DataInputStream s = new DataInputStream(new ByteArrayInputStream(bytes));
			if (name.equals(Aspect.AttributeName)) {
				return new Aspect(PerClause.readPerClause(s, context));
			} else if (name.equals(MethodDeclarationLineNumberAttribute.AttributeName)) {
			   return MethodDeclarationLineNumberAttribute.read(s);
			} else if (name.equals(WeaverState.AttributeName)) {
				return new WeaverState(WeaverStateInfo.read(s, context));
			} else if (name.equals(WeaverVersionInfo.AttributeName)) {
				return WeaverVersionInfo.read(s);
			} else if (name.equals(AdviceAttribute.AttributeName)) {
				return AdviceAttribute.read(s, context);
			} else if (name.equals(PointcutDeclarationAttribute.AttributeName)) {
				return new PointcutDeclarationAttribute(ResolvedPointcutDefinition.read(s, context));
			} else if (name.equals(TypeMunger.AttributeName)) {
				return new TypeMunger(ResolvedTypeMunger.read(s, context));
			} else if (name.equals(AjSynthetic.AttributeName)) {
				return new AjSynthetic();
			} else if (name.equals(DeclareAttribute.AttributeName)) {
				return new DeclareAttribute(Declare.read(s, context));
			} else if (name.equals(PrivilegedAttribute.AttributeName)) {
				return PrivilegedAttribute.read(s, context);
			} else if (name.equals(SourceContextAttribute.AttributeName)) {
				return SourceContextAttribute.read(s);
			} else if (name.equals(EffectiveSignatureAttribute.AttributeName)) {
				return EffectiveSignatureAttribute.read(s, context);
			} else {
				// We have to tell the user about this...
				if (msgHandler == null) throw new BCException("unknown attribute" + name);
				msgHandler.handleMessage(MessageUtil.warn("unknown attribute encountered "+name));
				return null;
			}
		} catch (IOException e) {
			throw new BCException("malformed " + name + " attribute " + e);
		}
	}
================= fetch public static List readAjAttributes(Attribute[] as, ISourceContext context,IMess 797b6a6^:weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java

public static List readAjAttributes(Attribute[] as, ISourceContext context,IMessageHandler msgHandler) {
		List l = new ArrayList();
		for (int i = as.length - 1; i >= 0; i--) {
			Attribute a = as[i];
			if (a instanceof Unknown) {
				Unknown u = (Unknown) a;
				String name = u.getName();
				if (name.startsWith(AjAttribute.AttributePrefix)) {
					AjAttribute attr = AjAttribute.read(name, u.getBytes(), context,msgHandler);
					if (attr!=null) l.add(attr);
				}
			}
		}
		return l;
	}
================= fetch public static SignaturePattern read(DataInputStream s, ISourceContext context) t 797b6a6^:weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java

public static SignaturePattern read(DataInputStream s, ISourceContext context) throws IOException {
		Member.Kind kind = Member.Kind.read(s);
		ModifiersPattern modifiers = ModifiersPattern.read(s);
		TypePattern returnType = TypePattern.read(s, context);
		TypePattern declaringType = TypePattern.read(s, context);
		NamePattern name = NamePattern.read(s);
		TypePatternList parameterTypes = TypePatternList.read(s, context);
		ThrowsPattern throwsPattern = ThrowsPattern.read(s, context);
		AnnotationTypePattern annotationPattern = AnnotationTypePattern.read(s,context);
		SignaturePattern ret = new SignaturePattern(kind, modifiers, returnType, declaringType,
					name, parameterTypes, throwsPattern,annotationPattern);
		ret.readLocation(context, s);
		return ret;
	}
================= fetch public static Test suite() { 797b6a6^:tests/src/org/aspectj/systemtest/ajc150/AllTestsJava5_binaryWeaving.java

public static Test suite() {
		TestSuite suite = new TestSuite("Java5 - binary weaving");
		//$JUnit-BEGIN$
		suite.addTest(Ajc150Tests.suite());
		suite.addTest(AccBridgeMethods.suite());
		suite.addTestSuite(CovarianceTests.class);
		suite.addTestSuite(Enums.class);
		suite.addTestSuite(Annotations.class);
		suite.addTestSuite(AnnotationPointcutsTests.class);
		suite.addTestSuite(VarargsTests.class);
		suite.addTestSuite(AnnotationRuntimeTests.class);
		//$JUnit-END$
		return suite;
	}
================= fetch public static TypePattern read(DataInputStream s, ISourceContext context) throws 797b6a6^:weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java

public static TypePattern read(DataInputStream s, ISourceContext context) throws IOException {
		byte version = s.readByte();
		if (version > EXACT_VERSION) throw new BCException("ExactTypePattern was written by a more recent version of AspectJ");
		TypePattern ret = new ExactTypePattern(TypeX.read(s), s.readBoolean(), s.readBoolean());
		ret.setAnnotationTypePattern(AnnotationTypePattern.read(s,context));
		ret.readLocation(context, s);
		return ret;
	}
================= fetch public static TypePattern read(DataInputStream s, ISourceContext context) throws 797b6a6^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java

public static TypePattern read(DataInputStream s, ISourceContext context) throws IOException {
		byte version = s.readByte();
		if (version > VERSION) {
			throw new BCException("WildTypePattern was written by a more recent version of AspectJ, cannot read");
		}
		int len = s.readShort();
		NamePattern[] namePatterns = new NamePattern[len];
		for (int i=0; i < len; i++) {
			namePatterns[i] = NamePattern.read(s);
		}
		boolean includeSubtypes = s.readBoolean();
		int dim = s.readInt();
		boolean varArg = s.readBoolean();
		WildTypePattern ret = new WildTypePattern(namePatterns, includeSubtypes, dim,varArg);
		ret.knownMatches = FileUtil.readStringArray(s);
		ret.importedPrefixes = FileUtil.readStringArray(s);
		ret.readLocation(context, s);
		ret.setAnnotationTypePattern(AnnotationTypePattern.read(s,context));
		return ret;
	}
================= fetch public static WeaverVersionInfo read(DataInputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/AjAttribute.java

public static WeaverVersionInfo read(DataInputStream s) throws IOException {
			short major = s.readShort();
			short minor = s.readShort();
			return new WeaverVersionInfo(major,minor);
		}
================= fetch public static void setReweavableModeDefaults(boolean mode, boolean compress) { 797b6a6^:weaver/src/org/aspectj/weaver/WeaverStateInfo.java

public static void setReweavableModeDefaults(boolean mode, boolean compress) {
		reweavableDefault = mode;
		reweavableCompressedModeDefault = compress;
	}
================= fetch public void checkSerialize(Pointcut p) throws IOException { 797b6a6^:weaver/testsrc/org/aspectj/weaver/bcel/PatternWeaveTestCase.java

void checkSerialize(Pointcut p) throws IOException {
		ByteArrayOutputStream bo = new ByteArrayOutputStream();
		DataOutputStream out = new DataOutputStream(bo);
		p.write(out);
		out.close();
		
		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
		DataInputStream in = new DataInputStream(bi);
		Pointcut newP = Pointcut.read(in, null);
		
		assertEquals("write/read", p, newP);	
	}
================= fetch public void checkSerialize(Pointcut p) throws IOException { 797b6a6^:weaver/testsrc/org/aspectj/weaver/bcel/PointcutResidueTestCase.java

public void checkSerialize(Pointcut p) throws IOException {
		ByteArrayOutputStream bo = new ByteArrayOutputStream();
		DataOutputStream out = new DataOutputStream(bo);
		p.write(out);
		out.close();
		
		ByteArrayInputStream bi = new ByteArrayInputStream(bo.toByteArray());
		DataInputStream in = new DataInputStream(bi);
		Pointcut newP = Pointcut.read(in, null);
		
		assertEquals("write/read", p, newP);	
	}
================= fetch public void postRead(ResolvedTypeX enclosingType) {} 797b6a6^:weaver/src/org/aspectj/weaver/patterns/Pointcut.java
//XXX currently it's unused  we're keeping it around as a stub
public void postRead(ResolvedTypeX enclosingType) {}
================= fetch public void write(DataOutputStream out) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/BindingTypePattern.java

public void write(DataOutputStream out) throws IOException {
		out.writeByte(TypePattern.BINDING);
		type.write(out);
		out.writeShort((short)formalIndex);
		out.writeBoolean(isVarArgs);
		writeLocation(out);
	}
================= fetch public void write(DataOutputStream out) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java
// rev if changed
public void write(DataOutputStream out) throws IOException {
		out.writeByte(TypePattern.EXACT);
		out.writeByte(EXACT_VERSION);
		type.write(out);
		out.writeBoolean(includeSubtypes);
		out.writeBoolean(isVarArgs);
		annotationPattern.write(out);
		writeLocation(out);
	}
================= fetch public void write(DataOutputStream out) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/NamePattern.java

public void write(DataOutputStream out) throws IOException {
		out.writeUTF(new String(pattern));
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/AjAttribute.java

public void write(DataOutputStream s) throws IOException {}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.java
// ----
public void write(DataOutputStream s) throws IOException {
		getDeclaringType().write(s);
		s.writeInt(getModifiers());
		s.writeUTF(getName());
		TypeX.writeArray(getParameterTypes(), s);
		pointcut.write(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/AndPointcut.java

public void write(DataOutputStream s) throws IOException {
		s.writeByte(Pointcut.AND);
		left.write(s);
		right.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/AndTypePattern.java

public void write(DataOutputStream s) throws IOException {
		s.writeByte(TypePattern.AND);
		left.write(s);
		right.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.PatternNode#write(java.io.DataOutputStream)
	 */
public void write(DataOutputStream s) throws IOException {
		s.writeByte(Pointcut.ANNOTATION);
		annotationTypePattern.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.PatternNode#write(java.io.DataOutputStream)
	 */
public void write(DataOutputStream s) throws IOException {
		s.writeByte(Pointcut.ATARGS);
		arguments.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java

public void write(DataOutputStream s) throws IOException {
		s.writeByte(Pointcut.ARGS);
		arguments.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.ExactAnnotationTypePattern#write(java.io.DataOutputStream)
	 */
public void write(DataOutputStream s) throws IOException {
		s.writeByte(AnnotationTypePattern.BINDING);
		s.writeByte(VERSION);
		annotationType.write(s);
		s.writeShort((short)formalIndex);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java

public void write(DataOutputStream s) throws IOException {
		s.writeByte(Pointcut.CFLOW);
		entry.write(s);
		s.writeBoolean(isBelow);
		FileUtil.writeIntArray(freeVars, s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java

public void write(DataOutputStream s) throws IOException {
		s.writeByte(Declare.ERROR_OR_WARNING);
		s.writeBoolean(isError);
		pointcut.write(s);
		s.writeUTF(message);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/DeclareParents.java

public void write(DataOutputStream s) throws IOException {
		s.writeByte(Declare.PARENTS);
		child.write(s);
		parents.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java

public void write(DataOutputStream s) throws IOException {
		s.writeByte(Declare.DOMINATES);
		patterns.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java

public void write(DataOutputStream s) throws IOException {
		s.writeByte(Declare.SOFT);
		exception.write(s);
		pointcut.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.PatternNode#write(java.io.DataOutputStream)
	 */
public void write(DataOutputStream s) throws IOException {
		s.writeByte(AnnotationTypePattern.EXACT);
		s.writeByte(VERSION);
		s.writeBoolean(bindingPattern);
		if (bindingPattern) {
			s.writeUTF(formalName);
		} else {
			annotationType.write(s);
		}
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java

public void write(DataOutputStream s) throws IOException {
		s.writeByte(Pointcut.HANDLER);
		exceptionType.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/IfPointcut.java

public static IfPointcut makeIfTruePointcut(State state) {
		IfPointcut ret = new IfTruePointcut();
		ret.state = state;
		return ret;
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java

public void write(DataOutputStream s) throws IOException {
		s.writeByte(Pointcut.KINDED);
		kind.write(s);
		signature.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/NotAnnotationTypePattern.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.PatternNode#write(java.io.DataOutputStream)
	 */
public void write(DataOutputStream s) throws IOException {
		s.writeByte(AnnotationTypePattern.NOT);
		negatedPattern.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/NotPointcut.java

public void write(DataOutputStream s) throws IOException {
		s.writeByte(Pointcut.NOT);
		body.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/NotTypePattern.java

public void write(DataOutputStream s) throws IOException {
		s.writeByte(TypePattern.NOT);
		pattern.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/OrPointcut.java

public void write(DataOutputStream s) throws IOException {
		s.writeByte(Pointcut.OR);
		left.write(s);
		right.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/OrTypePattern.java

public void write(DataOutputStream s) throws IOException {
		s.writeByte(TypePattern.OR);
		left.write(s);
		right.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/PerCflow.java

public void write(DataOutputStream s) throws IOException {
    	PERCFLOW.write(s);
    	entry.write(s);
    	s.writeBoolean(isBelow);
    	writeLocation(s);
    }
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java

public void write(DataOutputStream s) throws IOException {
    	FROMSUPER.write(s);
    	kind.write(s);
    	writeLocation(s);
    }
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/PerObject.java

public void write(DataOutputStream s) throws IOException {
    	PEROBJECT.write(s);
    	entry.write(s);
    	s.writeBoolean(isThis);
    	writeLocation(s);
    }
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/PerSingleton.java

public void write(DataOutputStream s) throws IOException {
    	SINGLETON.write(s);
    	writeLocation(s);
    }
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java

public void write(DataOutputStream s) throws IOException {
		//XXX ignores onType
		s.writeByte(Pointcut.REFERENCE);
		if (onType != null) {
			s.writeBoolean(true);
			onType.write(s);
		} else {
			s.writeBoolean(false);
		}
		
		s.writeUTF(name);
		arguments.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java

public void write(DataOutputStream s) throws IOException {
		kind.write(s);
		modifiers.write(s);
		returnType.write(s);
		declaringType.write(s);
		name.write(s);
		parameterTypes.write(s);
		throwsPattern.write(s);
		annotationPattern.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.PatternNode#write(java.io.DataOutputStream)
	 */
public void write(DataOutputStream s) throws IOException {
	    s.writeByte(Pointcut.ATTHIS_OR_TARGET);
	    s.writeBoolean(isThis);
		annotationTypePattern.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java

public void write(DataOutputStream s) throws IOException {
		s.writeByte(Pointcut.THIS_OR_TARGET);
		s.writeBoolean(isThis);
		type.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.PatternNode#write(java.io.DataOutputStream)
	 */
public void write(DataOutputStream s) throws IOException {
		s.writeByte(AnnotationTypePattern.WILD);
		s.writeByte(VERSION);
		typePattern.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
/**
	 * @see org.aspectj.weaver.patterns.PatternNode#write(DataOutputStream)
	 */
public void write(DataOutputStream s) throws IOException {
		s.writeByte(TypePattern.WILD);
		s.writeByte(VERSION);
		s.writeShort(namePatterns.length);
		for (int i = 0; i < namePatterns.length; i++) {
			namePatterns[i].write(s);
		}
		s.writeBoolean(includeSubtypes);
		s.writeInt(dim);
		s.writeBoolean(isVarArgs);
		//??? storing this information with every type pattern is wasteful of .class
		//    file size. Storing it on enclosing types would be more efficient
		FileUtil.writeStringArray(knownMatches, s);
		FileUtil.writeStringArray(importedPrefixes, s);
		writeLocation(s);
		annotationPattern.write(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.PatternNode#write(java.io.DataOutputStream)
	 */
public void write(DataOutputStream s) throws IOException {
		s.writeByte(Pointcut.ATWITHIN);
		annotationTypePattern.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.patterns.PatternNode#write(java.io.DataOutputStream)
	 */
public void write(DataOutputStream s) throws IOException {
		s.writeByte(Pointcut.ATWITHINCODE);
		annotationTypePattern.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java

public void write(DataOutputStream s) throws IOException {
		s.writeByte(Pointcut.WITHIN);
		typePattern.write(s);
		writeLocation(s);
	}
================= fetch public void write(DataOutputStream s) throws IOException { 797b6a6^:weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java

public void write(DataOutputStream s) throws IOException {
		s.writeByte(Pointcut.WITHINCODE);
		signature.write(s);
		writeLocation(s);
	}
================= fetch private FuzzyBoolean isWithinType(ResolvedTypeX type) { 8a8930f^:weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java

private FuzzyBoolean isWithinType(ResolvedTypeX type) {
		while (type != null) {
			if (typePattern.matchesStatically(type)) {
				return FuzzyBoolean.YES;
			}
			type = type.getDeclaringType();
		}
		return FuzzyBoolean.NO;
	}
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { 8a8930f^:weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java

protected FuzzyBoolean matchInternal(Shadow shadow) {
		if (shadow.getKind() != Shadow.ExceptionHandler) return FuzzyBoolean.NO;
		
		// we know we have exactly one parameter since we're checking an exception handler
		return exceptionType.matches(
				shadow.getSignature().getParameterTypes()[0].resolve(shadow.getIWorld()), 
				TypePattern.STATIC);
	}
================= fetch protected FuzzyBoolean matchInternal(Shadow shadow) { 8a8930f^:weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java

protected FuzzyBoolean matchInternal(Shadow shadow) {
		ResolvedTypeX enclosingType = shadow.getIWorld().resolve(shadow.getEnclosingType(),true);
		if (enclosingType == ResolvedTypeX.MISSING) {
			IMessage msg = new Message(
			    WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_WITHINPCD,
			    		              shadow.getEnclosingType().getName()),
				shadow.getSourceLocation(),true,new ISourceLocation[]{getSourceLocation()});
			shadow.getIWorld().getMessageHandler().handleMessage(msg);
		}
		return isWithinType(enclosingType);
	}
================= fetch protected boolean matchesExactly(ResolvedTypeX matchType) { 8a8930f^:weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java

public TypeX getType() { return type; }
================= fetch protected boolean matchesExactly(ResolvedTypeX type) { 8a8930f^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
/**
	 * @see org.aspectj.weaver.TypePattern#matchesExactly(IType)
	 */
protected boolean matchesExactly(ResolvedTypeX type) {
		String targetTypeName = type.getName();
		
		//System.err.println("match: " + targetTypeName + ", " + knownMatches); //Arrays.asList(importedPrefixes));
		
		return matchesExactlyByName(targetTypeName);
	}
================= fetch public FuzzyBoolean fastMatch(FastMatchInfo info) { 8a8930f^:weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java

public FuzzyBoolean fastMatch(FastMatchInfo info) {
		return isWithinType(info.getType());
	}
================= fetch public FuzzyBoolean matchesInstanceof(ResolvedTypeX matchType) { 8a8930f^:weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java

public FuzzyBoolean matchesInstanceof(ResolvedTypeX matchType) {
		// in our world, Object is assignable from anything
		if (type.equals(ResolvedTypeX.OBJECT)) return FuzzyBoolean.YES;
		
		if (type.isAssignableFrom(matchType, matchType.getWorld())) {
			return FuzzyBoolean.YES;
		}
		
		// fix for PR 64262 - shouldn't try to coerce primitives
		if (type.isPrimitive()) {
			return FuzzyBoolean.NO;
		} else {
		    return matchType.isCoerceableFrom(type) ? FuzzyBoolean.MAYBE : FuzzyBoolean.NO;
		}
	}
================= fetch public TypePattern resolveBindingsFromRTTI(boolean allowBindng, boolean requireE 8a8930f^:weaver/src/org/aspectj/weaver/patterns/TypePattern.java

public TypePattern resolveBindingsFromRTTI(boolean allowBindng, boolean requireExactType) {
    	return this;
    }
================= fetch public final FuzzyBoolean matches(ResolvedTypeX type, MatchKind kind) { 8a8930f^:weaver/src/org/aspectj/weaver/patterns/TypePattern.java

public final FuzzyBoolean matches(ResolvedTypeX type, MatchKind kind) {
		FuzzyBoolean typeMatch = null;
		//??? This is part of gracefully handling missing references
		if (type == ResolvedTypeX.MISSING) return FuzzyBoolean.NO;
		
		if (kind == STATIC) {
			typeMatch = FuzzyBoolean.fromBoolean(matchesStatically(type));
			return typeMatch.and(annotationPattern.matches(type));
		} else if (kind == DYNAMIC) {
			//System.err.println("matching: " + this + " with " + type);
			typeMatch = matchesInstanceof(type);
			//System.err.println("    got: " + ret);
			return typeMatch.and(annotationPattern.matches(type));
		} else {
			throw new IllegalArgumentException("kind must be DYNAMIC or STATIC");
		}
	}
================= fetch public static AnnotationTypePattern read(DataInputStream s, ISourceContext conte 8a8930f^:weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java

public static AnnotationTypePattern read(DataInputStream s, ISourceContext context) throws IOException {
		byte key = s.readByte();
		switch(key) {
			case EXACT: return ExactAnnotationTypePattern.read(s, context);
			case BINDING: return BindingAnnotationTypePattern.read(s, context);
			case NOT: return NotAnnotationTypePattern.read(s, context);
			case OR: return OrAnnotationTypePattern.read(s, context);
			case AND: return AndAnnotationTypePattern.read(s, context);
			case WILD: return WildAnnotationTypePattern.read(s,context);
			case ELLIPSIS_KEY: return ELLIPSIS;
			case ANY_KEY: return ANY;
		}
		throw new BCException("unknown TypePattern kind: " + key);
	}
================= fetch public void resolve(World world) { 8a8930f^:weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java

public void resolve(World world) {
		annotationType = annotationType.resolve(world);
	}
================= fetch public void test002_AtAnnotationMatching() { 8a8930f^:tests/src/org/aspectj/systemtest/ajc150/AnnotationPointcutsTests.java

public void test002_AtAnnotationMatching() {
      CompilationResult cR = binaryWeave("testcode.jar","AnnotationAspect03.aj",0,1);
      List expectedWarnings = new ArrayList();
      expectedWarnings.add(new Message("@annotation matched here"));  // L 8
      assertMessages(cR, new MessageSpec(expectedWarnings, new ArrayList()));
  }
================= fetch public void test006_CantUseinDecEoW() { 8a8930f^:tests/src/org/aspectj/systemtest/ajc150/AnnotationRuntimeTests.java

public void test006_CantUseinDecEoW() {
    	baseDir = new File("../tests/java5/annotations/args");
        CompilationResult cR = binaryWeave("TestingArgsAnnotations.jar","DeclareEoW.java",2,0);
        List errors = new ArrayList();
        errors.add(new Message(3,"args() pointcut designator cannot be used in declare statement"));
        MessageSpec messageSpec = new MessageSpec(new ArrayList(), errors);
        assertMessages(cR, messageSpec);
    }
================= fetch private WeaveMessage(String message) { 9897659^:bridge/src/org/aspectj/bridge/WeaveMessage.java

================= fetch private boolean mungeNewField(BcelClassWeaver weaver, NewFieldTypeMunger munger) 9897659^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java

private boolean mungeNewField(BcelClassWeaver weaver, NewFieldTypeMunger munger) {
		/*ResolvedMember initMethod = */munger.getInitMethod(aspectType);
		
		LazyClassGen gen = weaver.getLazyClassGen();
		ResolvedMember field = munger.getSignature();
		
		
		ResolvedTypeX onType = weaver.getWorld().resolve(field.getDeclaringType(),munger.getSourceLocation());
		boolean onInterface = onType.isInterface();
		
		if (onType.isAnnotation(weaver.getWorld())) {
			signalError(WeaverMessages.ITDF_ON_ANNOTATION_NOT_ALLOWED,weaver,onType);
			return false;
		}
		
		if (onType.isEnum(weaver.getWorld())) {
			signalError(WeaverMessages.ITDF_ON_ENUM_NOT_ALLOWED,weaver,onType);
			return false;
		}
		
		if (onType.equals(gen.getType())) {
			if (onInterface) {
				LazyMethodGen mg = makeMethodGen(gen, 
					AjcMemberMaker.interFieldInterfaceGetter(field, onType, aspectType));
				gen.addMethodGen(mg);
				
				LazyMethodGen mg1 = makeMethodGen(gen, 
					AjcMemberMaker.interFieldInterfaceSetter(field, onType, aspectType));
				gen.addMethodGen(mg1);
			} else {
				weaver.addInitializer(this);
				FieldGen fg = makeFieldGen(gen,
					AjcMemberMaker.interFieldClassField(field, aspectType));
	    		gen.addField(fg.getField(),getSourceLocation());
			}
    		return true;
		} else if (onInterface && gen.getType().isTopmostImplementor(onType)) {
			// wew know that we can't be static since we don't allow statics on interfaces
			if (field.isStatic()) throw new RuntimeException("unimplemented");
			weaver.addInitializer(this);
			//System.err.println("impl body on " + gen.getType() + " for " + munger);
			Type fieldType = 	BcelWorld.makeBcelType(field.getType());
			
			FieldGen fg = makeFieldGen(gen,
					AjcMemberMaker.interFieldInterfaceField(field, onType, aspectType));
	    	gen.addField(fg.getField(),getSourceLocation());
			
	    	//this uses a shadow munger to add init method to constructors
	    	//weaver.getShadowMungers().add(makeInitCallShadowMunger(initMethod));
	    	
			LazyMethodGen mg = makeMethodGen(gen, 
					AjcMemberMaker.interFieldInterfaceGetter(field, gen.getType(), aspectType));
			InstructionList il = new InstructionList();
			InstructionFactory fact = gen.getFactory();
			if (field.isStatic()) {
				il.append(fact.createFieldAccess(
					gen.getClassName(), 
					fg.getName(),
					fieldType, Constants.GETSTATIC));
			} else {
				il.append(InstructionConstants.ALOAD_0);
				il.append(fact.createFieldAccess(
					gen.getClassName(), 
					fg.getName(),
					fieldType, Constants.GETFIELD));
			}
			il.append(InstructionFactory.createReturn(fieldType));
			mg.getBody().insert(il);
				
			gen.addMethodGen(mg);
			
			LazyMethodGen mg1 = makeMethodGen(gen, 
					AjcMemberMaker.interFieldInterfaceSetter(field, gen.getType(), aspectType));
			InstructionList il1 = new InstructionList();
			if (field.isStatic()) {
				il1.append(InstructionFactory.createLoad(fieldType, 0));
				il1.append(fact.createFieldAccess(
					gen.getClassName(), 
					fg.getName(),
					fieldType, Constants.PUTSTATIC));
			} else {
				il1.append(InstructionConstants.ALOAD_0);
				il1.append(InstructionFactory.createLoad(fieldType, 1));
				il1.append(fact.createFieldAccess(
					gen.getClassName(), 
					fg.getName(), 
					fieldType, Constants.PUTFIELD));
			}
			il1.append(InstructionFactory.createReturn(Type.VOID));
			mg1.getBody().insert(il1);
				
			gen.addMethodGen(mg1);

			return true;
		} else {
			return false;
		}
	}
================= fetch private void reportWeavingMessage(ShadowMunger munger) { 9897659^:weaver/src/org/aspectj/weaver/Shadow.java

public IRelationship.Kind determineRelKind(ShadowMunger munger) {
		AdviceKind ak = ((Advice)munger).getKind();
		if (ak.getKey()==AdviceKind.Before.getKey()) 
				return IRelationship.Kind.ADVICE_BEFORE;
================= fetch public ResolvedTypeX resolve(Type t) { 9897659^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java

protected ResolvedTypeX.ConcreteName resolveObjectType(ResolvedTypeX.Name ty) {
        String name = ty.getName();
        JavaClass jc = null;
        //UnwovenClassFile classFile = (UnwovenClassFile)sourceJavaClasses.get(name);
        //if (classFile != null) jc = classFile.getJavaClass();
//		if (jc == null) {
//		    jc = lookupJavaClass(aspectPath, name);
//		}
        if (jc == null) {
        	jc = lookupJavaClass(classPath, name);
        }       
        if (jc == null) {
        	return null;
        } else {
        	return makeBcelObjectType(ty, jc, false);
        }
	}
================= fetch public boolean munge(BcelClassWeaver weaver) { 9897659^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java

public boolean munge(BcelClassWeaver weaver) {
		boolean changed = false;
		boolean worthReporting = true;
		
		if (munger.getKind() == ResolvedTypeMunger.Field) {
			changed = mungeNewField(weaver, (NewFieldTypeMunger)munger);
		} else if (munger.getKind() == ResolvedTypeMunger.Method) {
			changed = mungeNewMethod(weaver, (NewMethodTypeMunger)munger);
		} else if (munger.getKind() == ResolvedTypeMunger.PerObjectInterface) {
			changed = mungePerObjectInterface(weaver, (PerObjectInterfaceTypeMunger)munger);
			worthReporting = false;
		} else if (munger.getKind() == ResolvedTypeMunger.PrivilegedAccess) {
			changed = mungePrivilegedAccess(weaver, (PrivilegedAccessMunger)munger);
			worthReporting = false;
		} else if (munger.getKind() == ResolvedTypeMunger.Constructor) {
			changed = mungeNewConstructor(weaver, (NewConstructorTypeMunger)munger);
		} else if (munger.getKind() == ResolvedTypeMunger.Parent) {
			changed = mungeNewParent(weaver, (NewParentTypeMunger)munger);
		} else {
			throw new RuntimeException("unimplemented");
		}
		
		if (changed && munger.changesPublicSignature()) {
			WeaverStateInfo info = 
				weaver.getLazyClassGen().getOrCreateWeaverStateInfo();
			info.addConcreteMunger(this);
		}
		// Whilst type mungers aren't persisting their source locations, we add this relationship during
		// compilation time (see other reference to ResolvedTypeMunger.persist)
		if (ResolvedTypeMunger.persistSourceLocation) {
			if (changed) {
				if (munger.getKind().equals(ResolvedTypeMunger.Parent)) {
			  	  AsmRelationshipProvider.getDefault().addRelationship(weaver.getLazyClassGen().getType(), munger,getAspectType());
				} else {
			  	  AsmRelationshipProvider.getDefault().addRelationship(weaver.getLazyClassGen().getType(), munger,getAspectType());	
				}
			}
		}
		
		// TAG: WeavingMessage
		if (changed && worthReporting  && munger!=null && !weaver.getWorld().getMessageHandler().isIgnoring(IMessage.WEAVEINFO)) {
			String tName = weaver.getLazyClassGen().getType().getSourceLocation().getSourceFile().getName();
			if (tName.indexOf("no debug info available")!=-1) tName = "no debug info available";
			else tName = getShortname(weaver.getLazyClassGen().getType().getSourceLocation().getSourceFile().getPath());
			String fName = getShortname(getAspectType().getSourceLocation().getSourceFile().getPath());
        	if (munger.getKind().equals(ResolvedTypeMunger.Parent)) {
        		// This message will come out of AjLookupEnvironment.addParent if doing a source
        		// compilation.
        		NewParentTypeMunger parentTM = (NewParentTypeMunger)munger;
        		if (parentTM.getNewParent().isInterface()) {
					weaver.getWorld().getMessageHandler().handleMessage(WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_DECLAREPARENTSIMPLEMENTS,
					new String[]{weaver.getLazyClassGen().getType().getName(),
					tName,parentTM.getNewParent().getName(),fName}));
        		} else {
        			System.err.println("BANG, you need to fix this.  BcelTypeMunger");
        		}
        	} else {
        		weaver.getWorld().getMessageHandler().handleMessage(WeaveMessage.constructWeavingMessage(WeaveMessage.WEAVEMESSAGE_ITD,
        		new String[]{weaver.getLazyClassGen().getType().getName(),
        			         tName,munger.getKind().toString().toLowerCase(),
        			         getAspectType().getName(),
        					 fName+":'"+munger.getSignature()+"'"}));
				// ??? If only type mungers knew their originating line numbers ...
        	}	
		}
		
		return changed;
	}
================= fetch public static WeaveMessage constructWeavingMessage( 9897659^:bridge/src/org/aspectj/bridge/WeaveMessage.java
/**
     * Static helper method for constructing weaving messages.
     * @param kind what kind of message (e.g. declare parents)
     * @param inserts inserts for the message (inserts are marked %n in the message)
     * @param affectedtypename the type which is being advised/declaredUpon
     * @param aspectname the aspect that defined the advice or declares
     * @return new weaving message
     */
public static WeaveMessage constructWeavingMessage(
	  WeaveMessageKind kind,
	  String[] inserts) {
		StringBuffer str = new StringBuffer(kind.getMessage());
		int pos = -1;
		while ((pos=new String(str).indexOf("%"))!=-1) {
			int n = Character.getNumericValue(str.charAt(pos+1));
			str.replace(pos,pos+2,inserts[n-1]);
		}
		return new WeaveMessage(str.toString());
	}
Progress : [#################################-------] 83%================= fetch public void checkerMunger(IHierarchy model, Shadow shadow, Checker checker) { 427c0d3^:weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java

public void checkerMunger(IHierarchy model, Shadow shadow, Checker checker) {
		if (shadow.getSourceLocation() == null || checker.getSourceLocation() == null) return;
		
		String sourceHandle = ProgramElement.createHandleIdentifier(
			checker.getSourceLocation().getSourceFile(),
			checker.getSourceLocation().getLine(),
			checker.getSourceLocation().getColumn(),
			checker.getSourceLocation().getOffset());
			
		String targetHandle = ProgramElement.createHandleIdentifier(
			shadow.getSourceLocation().getSourceFile(),
			shadow.getSourceLocation().getLine(),
			shadow.getSourceLocation().getColumn(),
			shadow.getSourceLocation().getOffset());

		IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
		if (sourceHandle != null && targetHandle != null) {
			IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE, MATCHED_BY,false,true);
			foreward.addTarget(targetHandle);
//			foreward.getTargets().add(targetHandle);
				
			IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE, MATCHES_DECLARE,false,true);
			if (back != null && back.getTargets() != null) {
				back.addTarget(sourceHandle);
				//back.getTargets().add(sourceHandle);   
			}
		}
	}
================= fetch private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, Collection 9052d5d^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java

private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, Collection typeMungers, Collection declareParents, boolean skipInners) {
		ResolvedTypeX onType = factory.fromEclipse(sourceType);
		WeaverStateInfo info = onType.getWeaverState();

		if (info != null && !info.isOldStyle()) {		
			Collection mungers = 
				onType.getWeaverState().getTypeMungers(onType);
				
			//System.out.println(onType + " mungers: " + mungers);
			for (Iterator i = mungers.iterator(); i.hasNext(); ) {
				ConcreteTypeMunger m = (ConcreteTypeMunger)i.next();
				EclipseTypeMunger munger = factory.makeEclipseTypeMunger(m);
				if (munger.munge(sourceType)) {
					if (onType.isInterface() &&
						munger.getMunger().needsAccessToTopmostImplementor())
					{
						if (!onType.getWorld().getCrosscuttingMembersSet().containsAspect(munger.getAspectType())) {
							dangerousInterfaces.put(onType, 
								"implementors of " + onType + " must be woven by " +
								munger.getAspectType());
						}
					}
				}
				
			}
			
			return;
		}
		
		//System.out.println("dangerousInterfaces: " + dangerousInterfaces);
		
		for (Iterator i = dangerousInterfaces.entrySet().iterator(); i.hasNext();) {
			Map.Entry entry = (Map.Entry) i.next();
			ResolvedTypeX interfaceType = (ResolvedTypeX)entry.getKey();
			if (onType.isTopmostImplementor(interfaceType)) {
				factory.showMessage(IMessage.ERROR, 
					onType + ": " + entry.getValue(),
					onType.getSourceLocation(), null);
			}
		}
		
		boolean needOldStyleWarning = (info != null && info.isOldStyle());
		
		onType.clearInterTypeMungers();
		
		for (Iterator i = declareParents.iterator(); i.hasNext();) {
			doDeclareParents((DeclareParents)i.next(), sourceType);
		}
		
		for (Iterator i = typeMungers.iterator(); i.hasNext();) {
			EclipseTypeMunger munger = (EclipseTypeMunger) i.next();
			if (munger.matches(onType)) {
				if (needOldStyleWarning) {
					factory.showMessage(IMessage.WARNING, 
						"The class for " + onType + " should be recompiled with ajc-1.1.1 for best results",
						onType.getSourceLocation(), null);
					needOldStyleWarning = false;
				}
				onType.addInterTypeMunger(munger);
				//TODO: Andy Should be done at weave time.
				// Unfortunately we can't do it at weave time unless the type mungers remember where
				// they came from.  Thats why we do it here during complation because at this time
				// they do know their source location.  I've put a flag in ResolvedTypeMunger that
				// records whether type mungers are currently set to remember their source location.
				// The flag is currently set to false, it should be set to true when we do the
				// work to version all AspectJ attributes.
				// (When done at weave time, it is done by invoking addRelationship() on 
				// AsmRelationshipProvider (see BCELTypeMunger)
				if (!ResolvedTypeMunger.persistSourceLocation) // Do it up front if we bloody have to
				 AsmInterTypeRelationshipProvider.getDefault().addRelationship(onType, munger);
			}
		}
		
        //???onType.checkInterTypeMungers();
        onType.checkInterTypeMungers();
		for (Iterator i = onType.getInterTypeMungers().iterator(); i.hasNext();) {
			EclipseTypeMunger munger = (EclipseTypeMunger) i.next();
			//System.out.println("applying: " + munger + " to " + new String(sourceType.sourceName));
			munger.munge(sourceType);
		}
		
		if (skipInners) return;

		ReferenceBinding[] memberTypes = sourceType.memberTypes;
		for (int i = 0, length = memberTypes.length; i < length; i++) {
			if (memberTypes[i] instanceof SourceTypeBinding) {
				weaveInterTypeDeclarations((SourceTypeBinding) memberTypes[i], typeMungers, declareParents, false);
			}
		}
	}
================= fetch protected File getSpecFile() { 9052d5d^:tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java

protected File getSpecFile() {
    return new File("../tests/src/org/aspectj/systemtest/ajc150/ajc150.xml");
  }
================= fetch public void completeTypeBindings() { 9052d5d^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java
//??? duplicates some of super's code
public void completeTypeBindings() {
//		builtInterTypesAndPerClauses = false;
		//pendingTypesToWeave = new ArrayList();
		stepCompleted = BUILD_TYPE_HIERARCHY;
		
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			units[i].scope.checkAndSetImports();
		}
		stepCompleted = CHECK_AND_SET_IMPORTS;
	
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			units[i].scope.connectTypeHierarchy();
		}
		stepCompleted = CONNECT_TYPE_HIERARCHY;
	
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			units[i].scope.buildFieldsAndMethods();
		}
		
		// would like to gather up all TypeDeclarations at this point and put them in the factory
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			SourceTypeBinding[] b = units[i].scope.topLevelTypes;
			for (int j = 0; j < b.length; j++) {
				factory.addSourceTypeBinding(b[j]);
			}
		}
		
		// need to build inter-type declarations for all AspectDeclarations at this point
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
                buildInterTypeAndPerClause(b[j].scope);
                addCrosscuttingStructures(b[j].scope);
            }
        }        

		factory.finishTypeMungers();
	
		// now do weaving
		Collection typeMungers = factory.getTypeMungers();
		
		Collection declareParents = factory.getDeclareParents();

		doPendingWeaves();

		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			weaveInterTypeDeclarations(units[i].scope, typeMungers, declareParents);
		}
        
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
                resolvePointcutDeclarations(b[j].scope);
            }
        }
        
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
            	addAdviceLikeDeclares(b[j].scope);
            }
        }
        
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            units[i] = null; // release unnecessary reference to the parsed unit
        }
                
		stepCompleted = BUILD_FIELDS_AND_METHODS;
		lastCompletedUnitIndex = lastUnitIndex;
	}
================= fetch private List getFullClassPath (ClassLoader loader) { edd6539^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java

private List getFullClassPath (ClassLoader loader) {
		List list = new LinkedList();
		for (; loader != null; loader = loader.getParent()) {
			if (loader instanceof URLClassLoader) {
				URL[] urls = ((URLClassLoader)loader).getURLs();
				list.addAll(0,FileUtil.makeClasspath(urls));
			}
			else {
				if (verbose) System.err.println("WeavingAdaptor: Warning - could not determine classpath for " + loader); 
			}
		}

		list.addAll(0,makeClasspath(System.getProperty("sun.boot.class.path")));

		return list;
	}
================= fetch private boolean shouldWeave (String name) { edd6539^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java

private boolean shouldWeave (String name) {
		name = name.replace('/','.');
		boolean b = (enabled && !generatedClasses.containsKey(name) && shouldWeaveName(name) && shouldWeaveAspect(name));
		if (verbose) System.out.println("WeavingAdaptor: shouldWeave('" + name + "') " + b);
		return b;
	}
================= fetch private static List makeClasspath(String cp) { edd6539^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java

private static List makeClasspath(String cp) {
		List ret = new ArrayList();
		if (cp != null) {
			StringTokenizer tok = new StringTokenizer(cp,File.pathSeparator);
			while (tok.hasMoreTokens()) {
				ret.add(tok.nextToken());
			}
		}
		return ret;
	}
================= fetch private void init(List classPath, List aspectPath) { edd6539^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java

private void init(List classPath, List aspectPath) {
		if (verbose) System.out.println("WeavingAdaptor: classPath='" + classPath + "'");
		
		// make sure the weaver can find all types...
		messageHandler = new MessageHandler();
		bcelWorld = new BcelWorld(classPath,messageHandler,null);
		bcelWorld.setXnoInline(false);
		bcelWorld.getLint().loadDefaultProperties();

		weaver = new BcelWeaver(bcelWorld);
		registerAspectLibraries(aspectPath);
	}
================= fetch private void registerAspectLibraries(List aspectPath) { edd6539^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java

private void registerAspectLibraries(List aspectPath) {
//		System.err.println("? WeavingAdaptor.registerAspectLibraries(" + aspectPath + ")");
		for (Iterator i = aspectPath.iterator(); i.hasNext();) {
			String lib = (String)i.next();
			File libFile = new File(lib);
			if (libFile.isFile() && lib.endsWith(".jar")) {
				try {
					if (verbose) System.out.println("WeavingAdaptor: adding aspect '" + lib + "' to weaver");
					addAspectLibrary(new File(lib));
				} catch (IOException ioEx) {
					if (verbose) System.err.println(
						"WeavingAdaptor: Warning - could not load aspect path entry " 
						+ lib + " : " + ioEx);
				}
			} else {
				if (verbose) System.err.println(
					"WeavingAdaptor: Warning - ignoring aspect path entry: " + lib);
			}
		}
		
		weaver.prepareForWeave();
	}
================= fetch public WeavingURLClassLoaderTest(String name) { edd6539^:weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java

================= fetch public boolean handleMessage(IMessage message) throws AbortException { edd6539^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java

private static List makeClasspath(String cp) {
		List ret = new ArrayList();
		if (cp != null) {
			StringTokenizer tok = new StringTokenizer(cp,File.pathSeparator);
			while (tok.hasMoreTokens()) {
				ret.add(tok.nextToken());
			}
		}
		return ret;
	}
================= fetch public static void invokeMain (Class clazz, String[] args) edd6539^:weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java

public static void invokeMain (Class clazz, String[] args)
	{
		Class[] paramTypes = new Class[1];
		paramTypes[0] = args.getClass();
	
		try {
			Method method = clazz.getDeclaredMethod("main",paramTypes);
			Object[] params = new Object[1];
			params[0] = args;
			method.invoke(null,params);
		}
		catch (InvocationTargetException ex) {
			throw new RuntimeException(ex.getTargetException().toString());
		}
		catch (Exception ex) {
			throw new RuntimeException(ex.toString());
		}
	}
================= fetch public void addURL(URL url) { edd6539^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java
/**
	 * Weave a class using aspects previously supplied to the adaptor.
	 * @param name the name of the class
	 * @param bytes the class bytes
	 * @return the woven bytes
     * @exception IOException weave failed
	 */
public byte[] weaveClass (String name, byte[] bytes) throws IOException {
		if (shouldWeave(name)) {
			bytes = getWovenBytes(name, bytes);
		}
		return bytes;
	}
================= fetch public void testIncompletePath () { edd6539^:weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java
/*
	 * Aspects on ASPECTPATH but missing from CLASSPATH
	 */
public void testIncompletePath () {
		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,ADVICE_ASPECTS);
		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,CLASSES_JAR);
		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			invokeMain(clazz,new String[] { "LTWAspect" }); 
			fail("Expecting java.lang.NoClassDefFoundError");
		}
		catch (Exception ex) {
		}
	}
================= fetch public void testJunkJar () { edd6539^:weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java

public void testJunkJar () {		
		File junkJar = new File(JUNK_JAR);
		assertFalse(junkJar + " should not exist",junkJar.exists());
		
		URL classes = FileUtil.getFileURL(junkJar);
		URL[] classURLs = new URL[] { classes };
		URL[] aspectURLs = new URL[] { };
		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			fail("Expecting java.lang.ClassNotFoundException");
		}
		catch (Exception ex) {
			assertTrue("Expecting java.lang.ClassNotFoundException caught " + ex,(ex instanceof ClassNotFoundException));
		}
	}
================= fetch public void testLoadClass () { edd6539^:weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java

public void testLoadClass () {
		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,"");
		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,CLASSES_JAR);
		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			invokeMain(clazz,new String[] {}); 
		}
		catch (Exception ex) {
			fail(ex.toString());
		}
	}
================= fetch public void testLoadWovenClass () { edd6539^:weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java

public void testLoadWovenClass () {
		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,"");
		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,WOVEN_JAR);
		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			invokeMain(clazz,new String[] { "LTWAspect" }); 
		}
		catch (Exception ex) {
			fail(ex.toString());
		}
	}
================= fetch public void testPackage () { edd6539^:weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java
/*
	 * Ensure package object is correct
	 */
public void testPackage () {
		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,"");
		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,CLASSES_JAR);
		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("ltw.LTWPackageTest");
			invokeMain(clazz,new String[] { }); 
			Package pakkage = clazz.getPackage();
			assertTrue("Expected 'ltw' got " + pakkage,(pakkage != null));
		}
		catch (Exception ex) {
			fail(ex.toString());
		}
	}
================= fetch public void testWeaveAdvice () { edd6539^:weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java

public void testWeaveAdvice () {
		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,ADVICE_ASPECTS);
		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR);
		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			invokeMain(clazz,new String[] { "LTWAspect" }); 
		}
		catch (Exception ex) {
			fail(ex.toString());
		}
	}
================= fetch public void testWeaveAroundClosure () { edd6539^:weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java

public void testWeaveAroundClosure () {
		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,AROUNDCLOSURE_ASPECTS);
		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,AROUNDCLOSURE_ASPECTS + File.pathSeparator + CLASSES_JAR);
		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			invokeMain(clazz,new String[] { "LTWAroundClosure" }); 
		}
		catch (Exception ex) {
			fail(ex.toString());
		}
	}
================= fetch public void testWeaveDeclareErrorAdvice () { edd6539^:weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java

public void testWeaveDeclareErrorAdvice () {
		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,DE_ADVICE_ASPECTS);
		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,DE_ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR);
		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			invokeMain(clazz,new String[] {} ); 
			fail("Expecting org.aspectj.bridge.AbortException");
		}
		catch (Exception ex) {
			assertTrue("Expecting org.aspectj.bridge.AbortException caught " + ex,(ex instanceof AbortException));
		}
	}
================= fetch public void testWeaveDeclareWarningAdvice () { edd6539^:weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java

public void testWeaveDeclareWarningAdvice () {
		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,DW_ADVICE_ASPECTS);
		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,DW_ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR);
		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			invokeMain(clazz,new String[] {} ); 
		}
		catch (Exception ex) {
			fail(ex.toString());
		}
	}
================= fetch public void testWeaveWovenClass () { edd6539^:weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java

public void testWeaveWovenClass () {
		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,ADVICE_ASPECTS);
		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,ADVICE_ASPECTS + File.pathSeparator + WOVEN_JAR);
		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			fail("Expecting org.aspectj.bridge.AbortException");
		}
		catch (Exception ex) {
			assertTrue("Expecting org.aspectj.bridge.AbortException caught " + ex,(ex instanceof AbortException));
		}
	}
================= fetch private List findMatchesHelper( aab9c2c^:ajde/src/org/aspectj/ajde/ui/StructureSearchManager.java

private List findMatchesHelper(
		IProgramElement node, 
		String pattern, 
		IProgramElement.Kind kind,
		List matches) {
			
		if (node != null && node.getName().indexOf(pattern) != -1) {
			if (kind == null || node.getKind().equals(kind)) {
				matches.add(node);	
			} 
		}
		if (node.getChildren() != null) {
			for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
				IProgramElement nextNode = (IProgramElement)it.next();
				if (nextNode instanceof IProgramElement) {
					findMatchesHelper(
							(IProgramElement)nextNode, 
							pattern, 
							kind,
							matches);
				}
			}
		}
		 
		return matches;		
	}
================= fetch private void printAspectAttributes(PrintStream out) { 6aa7516^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

private void printAspectAttributes(PrintStream out) {
		ISourceContext context = null;
		if (enclosingClass != null && enclosingClass.getType() != null) {
			context = enclosingClass.getType().getSourceContext();
		}
		List as = BcelAttributes.readAjAttributes(attributes, context);
		if (! as.isEmpty()) {
			out.println("    " + as.get(0)); // XXX assuming exactly one attribute, munger...
		}
	}
================= fetch private void unpackAjAttributes(World world) { 6aa7516^:weaver/src/org/aspectj/weaver/bcel/BcelMethod.java

private void unpackAjAttributes(World world) {
		List as = BcelAttributes.readAjAttributes(method.getAttributes(), getSourceContext(world));
		//System.out.println("unpack: " + this + ", " + as);
		for (Iterator iter = as.iterator(); iter.hasNext();) {
			AjAttribute a = (AjAttribute) iter.next();
			if (a instanceof AjAttribute.MethodDeclarationLineNumberAttribute) {
				declarationLineNumber = (AjAttribute.MethodDeclarationLineNumberAttribute)a;
			} else if (a instanceof AjAttribute.AdviceAttribute) {
				associatedShadowMunger = ((AjAttribute.AdviceAttribute)a).reify(this, world);
				return;
			} else if (a instanceof AjAttribute.AjSynthetic) {
				isAjSynthetic = true;
			} else if (a instanceof AjAttribute.EffectiveSignatureAttribute) {
				//System.out.println("found effective: " + this);
				effectiveSignature = (AjAttribute.EffectiveSignatureAttribute)a;
			} else {
				throw new BCException("weird method attribute " + a);
			}
		}
		associatedShadowMunger = null;
	}
================= fetch private void unpackAspectAttributes() { 6aa7516^:weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java

private void unpackAspectAttributes() {
		List pointcuts = new ArrayList();
		typeMungers = new ArrayList();
		declares = new ArrayList();
		List l = BcelAttributes.readAjAttributes(javaClass.getAttributes(), getResolvedTypeX().getSourceContext());
		for (Iterator iter = l.iterator(); iter.hasNext();) {
			AjAttribute a = (AjAttribute) iter.next();
			//System.err.println("unpacking: " + this + " and " + a);
			if (a instanceof AjAttribute.Aspect) {
				perClause = ((AjAttribute.Aspect)a).reify(this.getResolvedTypeX());
			} else if (a instanceof AjAttribute.PointcutDeclarationAttribute) {
				pointcuts.add(((AjAttribute.PointcutDeclarationAttribute)a).reify());
			} else if (a instanceof AjAttribute.WeaverState) {
				weaverState = ((AjAttribute.WeaverState)a).reify();
			} else if (a instanceof AjAttribute.TypeMunger) {
				typeMungers.add(((AjAttribute.TypeMunger)a).reify(getResolvedTypeX().getWorld(), getResolvedTypeX()));
			} else if (a instanceof AjAttribute.DeclareAttribute) {
				declares.add(((AjAttribute.DeclareAttribute)a).getDeclare());
			} else if (a instanceof AjAttribute.PrivilegedAttribute) {
				privilegedAccess = ((AjAttribute.PrivilegedAttribute)a).getAccessedMembers();
			} else if (a instanceof AjAttribute.SourceContextAttribute) {
				if (getResolvedTypeX().getSourceContext() instanceof BcelSourceContext) {
					((BcelSourceContext)getResolvedTypeX().getSourceContext()).addAttributeInfo((AjAttribute.SourceContextAttribute)a);
				}
			} else {
				throw new BCException("bad attribute " + a);
			}
		}
		this.pointcuts = (ResolvedPointcutDefinition[]) 
			pointcuts.toArray(new ResolvedPointcutDefinition[pointcuts.size()]);
//		this.typeMungers = (BcelTypeMunger[]) 
//			typeMungers.toArray(new BcelTypeMunger[typeMungers.size()]);
//		this.declares = (Declare[])
//			declares.toArray(new Declare[declares.size()]);	
	}
================= fetch private void unpackAttributes(World world) { 6aa7516^:weaver/src/org/aspectj/weaver/bcel/BcelField.java

private void unpackAttributes(World world) {
		Attribute[] attrs = field.getAttributes();
		List as = BcelAttributes.readAjAttributes(attrs, getSourceContext(world));
		for (Iterator iter = as.iterator(); iter.hasNext();) {
			AjAttribute a = (AjAttribute) iter.next();
			if (a instanceof AjAttribute.AjSynthetic) {
				isAjSynthetic = true;
			} else {
				throw new BCException("weird field attribute " + a);
			}
		}
		isAjSynthetic = false;
		
		
		for (int i = attrs.length - 1; i >= 0; i--) {
			if (attrs[i] instanceof Synthetic) isSynthetic = true;
		}
	}
================= fetch private void writeBack(BcelWorld world) { 6aa7516^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java

private void writeBack(BcelWorld world) {
        if (getConstantPoolGen().getSize() > Short.MAX_VALUE) {
            // PR 59208
            // we've generated a class that is just toooooooooo big (you've been generating programs
            // again haven't you? come on, admit it, no-one writes classes this big by hand).
            // create an empty myGen so that we can give back a return value that doesn't upset the
            // rest of the process.
            myGen = new ClassGen(myGen.getClassName(), myGen.getSuperclassName(), 
                    myGen.getFileName(), myGen.getAccessFlags(), myGen.getInterfaceNames());
            // raise an error against this compilation unit.
       		getWorld().showMessage(
        			IMessage.ERROR, 
    				WeaverMessages.format(WeaverMessages.CLASS_TOO_BIG,
    						              this.getClassName()),
    			    new SourceLocation(new File(myGen.getFileName()),0), null
    			    );
        	return;
        }
    	if (myType != null && myType.getWeaverState() != null) {
			myGen.addAttribute(BcelAttributes.bcelAttribute(
				new AjAttribute.WeaverState(myType.getWeaverState()), 
				getConstantPoolGen()));
    	}
    	
    	addAjcInitializers();
    	
        int len = methodGens.size();
        myGen.setMethods(new Method[0]);
        
        calculateSourceDebugExtensionOffsets();
        for (int i = 0; i < len; i++) {
            LazyMethodGen gen = (LazyMethodGen) methodGens.get(i);
            // we skip empty clinits
            if (isEmptyClinit(gen)) continue;
            myGen.addMethod(gen.getMethod());
        }
		if (inlinedFiles.size() != 0) {
			if (hasSourceDebugExtensionAttribute(myGen)) {
				world.showMessage(
					IMessage.WARNING,
					WeaverMessages.format(WeaverMessages.OVERWRITE_JSR45,getFileName()),
					null,
					null);
			}
			myGen.addAttribute(getSourceDebugExtensionAttribute());
		}
    }
================= fetch public ISourceLocation getSourceLocation() { 6aa7516^:weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java

public ISourceLocation getSourceLocation() {
		return getResolvedTypeX().getSourceContext().makeSourceLocation(0); //FIXME, we can do better than this
	}
================= fetch public WeaverStateInfo reify() { 6aa7516^:weaver/src/org/aspectj/weaver/AjAttribute.java

public WeaverStateInfo reify() {
			return kind;
		}
================= fetch public static AjAttribute read(String name, byte[] bytes, ISourceContext context 6aa7516^:weaver/src/org/aspectj/weaver/AjAttribute.java

public static AjAttribute read(String name, byte[] bytes, ISourceContext context) {
		try {
			if (bytes == null) bytes = new byte[0];
			DataInputStream s = new DataInputStream(new ByteArrayInputStream(bytes));
			if (name.equals(Aspect.AttributeName)) {
				return new Aspect(PerClause.readPerClause(s, context));
			} else if (name.equals(MethodDeclarationLineNumberAttribute.AttributeName)) {
			   return MethodDeclarationLineNumberAttribute.read(s);
			} else if (name.equals(WeaverState.AttributeName)) {
				return new WeaverState(WeaverStateInfo.read(s, context));
			} else if (name.equals(AdviceAttribute.AttributeName)) {
				return AdviceAttribute.read(s, context);
			} else if (name.equals(PointcutDeclarationAttribute.AttributeName)) {
				return new PointcutDeclarationAttribute(ResolvedPointcutDefinition.read(s, context));
			} else if (name.equals(TypeMunger.AttributeName)) {
				return new TypeMunger(ResolvedTypeMunger.read(s, context));
			} else if (name.equals(AjSynthetic.AttributeName)) {
				return new AjSynthetic();
			} else if (name.equals(DeclareAttribute.AttributeName)) {
				return new DeclareAttribute(Declare.read(s, context));
			} else if (name.equals(PrivilegedAttribute.AttributeName)) {
				return PrivilegedAttribute.read(s, context);
			} else if (name.equals(SourceContextAttribute.AttributeName)) {
				return SourceContextAttribute.read(s);
			} else if (name.equals(EffectiveSignatureAttribute.AttributeName)) {
				return EffectiveSignatureAttribute.read(s, context);
			} else {
				throw new BCException("unknown attribute" + name);
			}
		} catch (IOException e) {
			throw new BCException("malformed " + name + " attribute " + e);
		}
	}
================= fetch public static List readAjAttributes(Attribute[] as, ISourceContext context) { 6aa7516^:weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java

public static List readAjAttributes(Attribute[] as, ISourceContext context) {
		List l = new ArrayList();
		for (int i = as.length - 1; i >= 0; i--) {
			Attribute a = as[i];
			if (a instanceof Unknown) {
				Unknown u = (Unknown) a;
				String name = u.getName();
				if (name.startsWith(AjAttribute.AttributePrefix)) {
					l.add(AjAttribute.read(name, u.getBytes(), context));
				}
			}
		}
		return l;
	}
================= fetch public final boolean isCoerceableFrom(TypeX o) { 8a64fa2^:weaver/src/org/aspectj/weaver/ResolvedTypeX.java

public boolean doesNotExposeShadowMungers() {
			return delegate.doesNotExposeShadowMungers();
		}
Progress : [#################################-------] 84%================= fetch protected void prepareForMungers() { a303a09^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

protected void prepareForMungers() {
		// if we're a constructor call, we need to remove the new:dup or the new:dup_x1:swap, 
		// and store all our
		// arguments on the frame.
 		
		// ??? This is a bit of a hack (for the Java langauge).  We do this because
		// we sometime add code "outsideBefore" when dealing with weaving join points.  We only
		// do this for exposing state that is on the stack.  It turns out to just work for 
		// everything except for constructor calls and exception handlers.  If we were to clean
		// this up, every ShadowRange would have three instructionHandle points, the start of 
		// the arg-setup code, the start of the running code, and the end of the running code.
		if (getKind() == ConstructorCall) {
			deleteNewAndDup();
			initializeArgVars();
		} else if (getKind() == ExceptionHandler) {
			
			ShadowRange range = getRange();
			InstructionList body = range.getBody();
			InstructionHandle start = range.getStart();		
			
			// Create a store instruction to put the value from the top of the 
			// stack into a local variable slot.  This is a trimmed version of
			// what is in initializeArgVars() (since there is only one argument
			// at a handler jp and only before advice is supported) (pr46298)
	        argVars = new BcelVar[1];
			int positionOffset = (hasTarget() ? 1 : 0) + ((hasThis() && !getKind().isTargetSameAsThis()) ? 1 : 0);
            TypeX tx = getArgType(0);
            argVars[0] = genTempVar(tx, "ajc$arg0");
            InstructionHandle insertedInstruction = 
            	range.insert(argVars[0].createStore(getFactory()), Range.OutsideBefore);

            // Now the exception range starts just after our new instruction.
            // The next bit of code changes the exception range to point at
            // the store instruction
			InstructionTargeter[] targeters = start.getTargeters();
			for (int i = 0; i < targeters.length; i++) {
				InstructionTargeter t = targeters[i];
				if (t instanceof ExceptionRange) {
					ExceptionRange er = (ExceptionRange) t;
					er.updateTarget(start, insertedInstruction, body);
				}
			}
		}

		// now we ask each munger to request our state
		isThisJoinPointLazy = world.isXlazyTjp();
		
		for (Iterator iter = mungers.iterator(); iter.hasNext();) {
			ShadowMunger munger = (ShadowMunger) iter.next();
			munger.specializeOn(this);
		}
		
		initializeThisJoinPoint();

	    // If we are an expression kind, we require our target/arguments on the stack
	    // before we do our actual thing.  However, they may have been removed
	    // from the stack as the shadowMungers have requested state.  
	    // if any of our shadowMungers requested either the arguments or target, 
	    // the munger will have added code
	    // to pop the target/arguments into temporary variables, represented by 
	    // targetVar and argVars.  In such a case, we must make sure to re-push the 
	    // values.  
	
	    // If we are nonExpressionKind, we don't expect arguments on the stack
	    // so this is moot.  If our argVars happen to be null, then we know that
	    // no ShadowMunger has squirrelled away our arguments, so they're still
	    // on the stack.		
		InstructionFactory fact = getFactory();
		if (getKind().argsOnStack() && argVars != null) {
			
			// Special case first (pr46298).  If we are an exception handler and the instruction
			// just after the shadow is a POP then we should remove the pop.  The code 
			// above which generated the store instruction has already cleared the stack.
			// We also don't generate any code for the arguments in this case as it would be
			// an incorrect aload.
			if (getKind() == ExceptionHandler 
				&& range.getEnd().getNext().getInstruction().equals(InstructionConstants.POP)) {
				// easier than deleting it ...
				range.getEnd().getNext().setInstruction(InstructionConstants.NOP);
			} else {
			  range.insert(
				BcelRenderer.renderExprs(fact, world, argVars),
				Range.InsideBefore);
			  if (targetVar != null) {
				range.insert(
					BcelRenderer.renderExpr(fact, world, targetVar),
					Range.InsideBefore);
			  }
			  if (getKind() == ConstructorCall) {
				range.insert((Instruction) InstructionFactory.createDup(1), Range.InsideBefore);
				range.insert(
					fact.createNew(
						(ObjectType) BcelWorld.makeBcelType(
							getSignature().getDeclaringType())),
					Range.InsideBefore);
			  }
			}
		}
 	}
================= fetch public void test064() { a303a09^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test064() {
  	runTest("Anonymous classes unaware of introductions into abstract classes");
  }
================= fetch public void weaveAfterReturning(BcelAdvice munger) { a303a09^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
/**
	 * We guarantee that the return value is on the top of the stack when
	 * munger.getAdviceInstructions() will be run
	 * (Unless we have a void return type in which case there's nothing)
	 */
public void weaveAfterReturning(BcelAdvice munger) {
        // InstructionFactory fact = getFactory();
        List returns = new ArrayList();
        Instruction ret = null;
        for (InstructionHandle ih = range.getStart(); ih != range.getEnd(); ih = ih.getNext()) {
            if (ih.getInstruction() instanceof ReturnInstruction) {
                returns.add(ih);
                ret = Utility.copyInstruction(ih.getInstruction());
            }
        }
        InstructionList retList;
        InstructionHandle afterAdvice;
        if (ret != null) {
            retList = new InstructionList(ret);
            afterAdvice = retList.getStart();
        } else /* if (munger.hasDynamicTests()) */ {
            retList = new InstructionList(InstructionConstants.NOP);            
            afterAdvice = retList.getStart();
//        } else {
//        	retList = new InstructionList();
//        	afterAdvice = null;
        }

        InstructionList advice = new InstructionList();
        BcelVar tempVar = null;
        if (munger.hasExtraParameter()) {
            TypeX tempVarType = getReturnType();
            if (tempVarType.equals(ResolvedTypeX.VOID)) {
            	tempVar = genTempVar(TypeX.OBJECT);
            	advice.append(InstructionConstants.ACONST_NULL);
            	tempVar.appendStore(advice, getFactory());
            } else {
	            tempVar = genTempVar(tempVarType);
	            advice.append(InstructionFactory.createDup(tempVarType.getSize()));
	            tempVar.appendStore(advice, getFactory());
            }
        }
        advice.append(munger.getAdviceInstructions(this, tempVar, afterAdvice));            

        if (ret != null) {
            InstructionHandle gotoTarget = advice.getStart();           
			for (Iterator i = returns.iterator(); i.hasNext();) {
				InstructionHandle ih = (InstructionHandle) i.next();
				Utility.replaceInstruction(
					ih,
					InstructionFactory.createBranchInstruction(
						Constants.GOTO,
						gotoTarget),
					enclosingMethod);
			}
            range.append(advice);
            range.append(retList);
        } else {
            range.append(advice);
            range.append(retList);
        }
    }
================= fetch public void weaveCflowEntry(final BcelAdvice munger, final Member cflowField) { a303a09^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public void weaveCflowEntry(final BcelAdvice munger, final Member cflowField) {
		final boolean isPer = munger.getKind() == AdviceKind.PerCflowBelowEntry || 
								munger.getKind() == AdviceKind.PerCflowEntry;
		
		final Type objectArrayType = new ArrayType(Type.OBJECT, 1);
        final InstructionFactory fact = getFactory();        

		final BcelVar testResult = genTempVar(ResolvedTypeX.BOOLEAN);

		InstructionList entryInstructions = new InstructionList();
		{
			InstructionList entrySuccessInstructions = new InstructionList();
			
			if (munger.hasDynamicTests()) {
				entryInstructions.append(Utility.createConstant(fact, 0));
				testResult.appendStore(entryInstructions, fact);
			
				entrySuccessInstructions.append(Utility.createConstant(fact, 1));
				testResult.appendStore(entrySuccessInstructions, fact);
			}

			if (isPer) {
	      		entrySuccessInstructions.append(
	      			fact.createInvoke(munger.getConcreteAspect().getName(), 
	      						NameMangler.PERCFLOW_PUSH_METHOD, 
	      						Type.VOID, 
	      						new Type[] { }, 
	      						Constants.INVOKESTATIC));
			} else {
				BcelVar[] cflowStateVars = munger.getExposedStateAsBcelVars();
	
				if (cflowStateVars.length == 0) {
					// This should be getting managed by a counter - lets make sure.
					if (!cflowField.getType().getName().endsWith("CFlowCounter")) 
						throw new RuntimeException("Oncorrectly attempting counter operation on stacked cflow");
					entrySuccessInstructions.append(
			      			Utility.createGet(fact, cflowField));
					//arrayVar.appendLoad(entrySuccessInstructions, fact);
					entrySuccessInstructions.append(fact.createInvoke(NameMangler.CFLOW_COUNTER_TYPE,"inc",Type.VOID,new Type[] { },Constants.INVOKEVIRTUAL));
				} else {
				    BcelVar arrayVar = genTempVar(TypeX.OBJECTARRAY);
	
				    int alen = cflowStateVars.length;
				    entrySuccessInstructions.append(Utility.createConstant(fact, alen));
				    entrySuccessInstructions.append(
				    		(Instruction) fact.createNewArray(Type.OBJECT, (short) 1));
				    arrayVar.appendStore(entrySuccessInstructions, fact);
		 
				    for (int i = 0; i < alen; i++) {
				    	arrayVar.appendConvertableArrayStore(
				    			entrySuccessInstructions,
								fact,
								i,
								cflowStateVars[i]);
				    }		
	
				    entrySuccessInstructions.append(
				    		Utility.createGet(fact, cflowField));
				    arrayVar.appendLoad(entrySuccessInstructions, fact);

				    entrySuccessInstructions.append(
				    		fact.createInvoke(NameMangler.CFLOW_STACK_TYPE, "push", Type.VOID, 
	      						new Type[] { objectArrayType }, 
	      					Constants.INVOKEVIRTUAL));
				}
			}

			
			InstructionList testInstructions = 
				munger.getTestInstructions(this, entrySuccessInstructions.getStart(), 
									range.getRealStart(), 
									entrySuccessInstructions.getStart());
						
			entryInstructions.append(testInstructions);
			entryInstructions.append(entrySuccessInstructions);
		}
		
		// this is the same for both per and non-per
		weaveAfter(new BcelAdvice(null, null, null, 0, 0, 0, null, null) {
================= fetch public void abstractMethodMustBeImplemented( 6beb43f^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java

public void abstractMethodMustBeImplemented(
		SourceTypeBinding type,
		MethodBinding abstractMethod)
	{
		// if this is a PointcutDeclaration then there is no error
		if (isPointcutDeclaration(abstractMethod)) {
			return;
		}
		
		if (CharOperation.prefixEquals("ajc$interField".toCharArray(), abstractMethod.selector)) {
			//??? think through how this could go wrong
			return;
		}
		
		// if we implemented this method by an inter-type declaration, then there is no error
		//??? be sure this is always right
		ResolvedTypeX onTypeX = factory.fromEclipse(type); //abstractMethod.declaringClass);
		for (Iterator i = onTypeX.getInterTypeMungersIncludingSupers().iterator(); i.hasNext(); ) {
			ConcreteTypeMunger m = (ConcreteTypeMunger)i.next();
			ResolvedMember sig = m.getSignature();
            if (!Modifier.isAbstract(sig.getModifiers())) {
				if (ResolvedTypeX
					.matches(
						AjcMemberMaker.interMethod(
							sig,
							m.getAspectType(),
							sig.getDeclaringType().isInterface(
								factory.getWorld())),
						EclipseFactory.makeResolvedMember(abstractMethod))) {
					return;
				}
			}
		}

		super.abstractMethodMustBeImplemented(type, abstractMethod);
	}
================= fetch public void test063_cflowOptimization_countersWithAbstractPcuts() { 6beb43f^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test063_cflowOptimization_countersWithAbstractPcuts() {
  	runTest("Optimization of cflow - counters with abstract pointcuts (5)");
  }
================= fetch protected boolean proceedOnError() { 0a77939^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

boolean proceedOnError() {
		return true;  //???
	}
================= fetch public AjCompilerAdapter(Compiler compiler, 0a77939^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java

================= fetch public ICompilerAdapter getAdapter(Compiler forCompiler) { 0a77939^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AspectJBuilder.java
/* (non-Javadoc)
	 * @see org.eclipse.jdt.internal.compiler.ICompilerAdapterFactory#getAdapter(org.eclipse.jdt.internal.compiler.Compiler)
	 */
public ICompilerAdapter getAdapter(Compiler forCompiler) {
		Map javaOptions = forCompiler.options.getMap();
		// TODO get aspectj options from project and add into map before...
		AjCompilerOptions ajOptions = new AjCompilerOptions(javaOptions);
		forCompiler.options = ajOptions;
		
		if (isBatchBuild || myBcelWorld == null || myWeaver == null) {
			initWorldAndWeaver(ajOptions);
		} else {
			// update the nameEnvironment each time we compile...
			cpManager.setNameEnvironment(nameEnvironment);
		}
		
		// * an eclipse factory  -- create from AjLookupEnvironment, need to hide AjBuildManager field
		AjProblemReporter pr =
			new AjProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),
								  forCompiler.options, new DefaultProblemFactory(Locale.getDefault()));		
		forCompiler.problemReporter = pr;			
		AjLookupEnvironment le =
			new AjLookupEnvironment(forCompiler, forCompiler.options, pr,nameEnvironment);		
		EclipseFactory eFactory = new EclipseFactory(le,myBcelWorld,ajOptions.xSerializableAspects);
		le.factory = eFactory;
		forCompiler.lookupEnvironment = le;
		
		AjBuildNotifier ajNotifier = (AjBuildNotifier) notifier;
		if (fileNameProvider == null ) fileNameProvider = new OutputFileNameProvider(getProject());
		
		// * the set of binary source entries for this compile  -- from analyzing deltas, or everything if batch
		// * the full set of binary source entries for the project -- from IAspectJProject
		// TODO deal with inpath, injars here...
		IBinarySourceProvider bsProvider = new NullBinarySourceProvider();
		Map fullBinarySourceEntries = new HashMap();

		// * the intermediate result set from the last batch compile
		if (isBatchBuild) {
			unwovenResultCollector = new UnwovenResultCollector();
		}
		Collection resultSetForFullWeave = unwovenResultCollector.getIntermediateResults();
		
		return new AjCompilerAdapter(forCompiler,isBatchBuild,myBcelWorld,
				     myWeaver,eFactory,unwovenResultCollector,ajNotifier,fileNameProvider,bsProvider,
					 fullBinarySourceEntries,resultSetForFullWeave,
					 ajOptions.noWeave);
	}
================= fetch public ICompilerAdapter getAdapter(org.aspectj.org.eclipse.jdt.internal.compiler 0a77939^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/* (non-Javadoc)
	 * @see org.eclipse.jdt.internal.compiler.ICompilerAdapterFactory#getAdapter(org.eclipse.jdt.internal.compiler.Compiler)
	 */
public ICompilerAdapter getAdapter(org.aspectj.org.eclipse.jdt.internal.compiler.Compiler forCompiler) {
		// complete compiler config and return a suitable adapter...
		AjProblemReporter pr =
			new AjProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),
								  forCompiler.options, getProblemFactory());
		
		forCompiler.problemReporter = pr;
			
		AjLookupEnvironment le =
			new AjLookupEnvironment(forCompiler, forCompiler.options, pr, environment);
		EclipseFactory factory = new EclipseFactory(le,this);
		le.factory = factory;
		pr.factory = factory;
		
		forCompiler.lookupEnvironment = le;
		
		forCompiler.parser =
			new Parser(
				pr, 
				forCompiler.options.parseLiteralExpressionsAsConstants);
		
		return new AjCompilerAdapter(forCompiler,batchCompile,bcelWorld,bcelWeaver,
						factory,
						getInterimResultRequestor(),
						progressListener,
						this,  // IOutputFilenameProvider
						this,  // IBinarySourceProvider
						state.binarySourceFiles,
						state.resultsFromFile.values(),
						buildConfig.isNoWeave());
	}
================= fetch public boolean getShowWeavingInformation() { 0a77939^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java

public boolean getShowWeavingInformation() { 
		return options.showWeavingInformation;
	}
================= fetch public static Test suite() { 0a77939^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(AjdtBatchTests.class.getName());
        // Abstract superclass
        //suite.addTestSuite(CommandTestCase.class); 
        //$JUnit-BEGIN$
        suite.addTestSuite(BasicCommandTestCase.class); 
        suite.addTestSuite(BinaryFormsTestCase.class); 
		suite.addTestSuite(CompileAndRunTestCase.class); 
		suite.addTestSuite(PerformanceTestCase.class); 
        suite.addTestSuite(ImageTestCase.class); 
        suite.addTestSuite(MultipleCompileTestCase.class); 
        suite.addTestSuite(JavadocTest.class);
        suite.addTestSuite(PartiallyExposedHierarchyTestCase.class);
        suite.addTestSuite(CompilerDumpTestCase.class); 
        // XXX suite.addTestSuite(VerifyWeaveTestCase.class); 
        //suite.addTestSuite(WorkingCommandTestCase.class); 
        //$JUnit-END$
        return suite;
    }
================= fetch public void afterCompiling() { 0a77939^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java

public void afterCompiling() {
		try {
			if (isXNoWeave || reportedErrors) {
				// no point weaving... just tell the requestor we're done
				notifyRequestor();
			} else {
				weave();  // notification happens as weave progresses...
			}
		} catch (IOException ex) {
			AbortCompilation ac = new AbortCompilation(null,ex);
			throw ac;
		} catch (RuntimeException rEx) {
			if (rEx instanceof AbortCompilation) throw rEx; // Don't wrap AbortCompilation exceptions!

			// This will be unwrapped in Compiler.handleInternalException() and the nested
			// RuntimeException thrown back to the original caller - which is AspectJ
			// which will then then log it as a compiler problem.
			throw new AbortCompilation(true,rEx);
		}
	}
================= fetch public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r 0a77939^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java
/**
         * Extract AspectJ-specific options (except for argfiles).
         * Caller should warn when sourceroots is empty but in 
         * incremental mode.
         * Signals warnings or errors through handler set in constructor.
         */
public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.remove()
			int nextArgIndex = args.indexOf(arg)+1; // XXX assumes unique
            // trim arg?
            if (LangUtil.isEmpty(arg)) {
                showWarning("empty arg found");
            } else if (arg.equals("-inpath")) {;
            	if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_Inpath, CompilerOptions.PRESERVE);
					
					List inPath = buildConfig.getInpath();
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
					while (st.hasMoreTokens()) {
						String filename = st.nextToken();
						File file = makeFile(filename);
						if (file.exists() && FileUtil.hasZipSuffix(filename)) {
							inPath.add(file);    
						} else {
							if (file.isDirectory()) {
								inPath.add(file);
							} else 
		            		
							showError("bad inpath component: " + filename);  
						}
					}
					buildConfig.setInPath(inPath);
					args.remove(args.get(nextArgIndex));            		
            	}
            } else if (arg.equals("-injars")) {;
				if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_InJARs, CompilerOptions.PRESERVE);
					
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
		            	if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
			            	buildConfig.getInJars().add(jarFile);    
		            	} else {
		            		File dirFile = makeFile(filename);
		            		if (dirFile.isDirectory()) {
		            			buildConfig.getInJars().add(dirFile);
		            		} else 
		            		
                            showError("bad injar: " + filename);  
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-aspectpath")) {;
				if (args.size() > nextArgIndex) {
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
                        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
			            	buildConfig.getAspectpath().add(jarFile);    
		            	} else {
                            showError("bad aspectpath: " + filename);
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-sourceroots")) {
				if (args.size() > nextArgIndex) {
					List sourceRoots = new ArrayList();
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	File f = makeFile(st.nextToken());
		            	if (f.isDirectory() && f.canRead()) {
			                sourceRoots.add(f);
		            	} else {
                            showError("bad sourceroot: " + f);
		            	}		            		
		            }
				    if (0 < sourceRoots.size()) {
						buildConfig.setSourceRoots(sourceRoots);	
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-sourceroots requires list of directories");
				}
			} else if (arg.equals("-outjar")) { 
				if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_OutJAR, CompilerOptions.GENERATE);
					File jarFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
					if (FileUtil.hasZipSuffix(jarFile)) {
						try {
							if (!jarFile.exists()) {
                                jarFile.createNewFile();
                            }
                            buildConfig.setOutputJar(jarFile);  
						} catch (IOException ioe) { 
                            showError("unable to create outjar file: " + jarFile);
						}
					} else {
						showError("invalid -outjar file: " + jarFile);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-outjar requires jar path argument");
				}
            } else if (arg.equals("-incremental")) {
                buildConfig.setIncrementalMode(true);
            } else if (arg.equals("-XincrementalFile")) {
                if (args.size() > nextArgIndex) {
                    File file = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    buildConfig.setIncrementalFile(file);
                    if (!file.canRead()) {
                        showError("bad -XincrementalFile : " + file);
                        // if not created before recompile test, stop after first compile
                    }
                    args.remove(args.get(nextArgIndex));
                } else {
                    showError("-XincrementalFile requires file argument");
                }
			} else if (arg.equals("-emacssym")) {
				buildConfig.setEmacsSymMode(true);
				buildConfig.setGenerateModelMode(true);
			} else if (arg.equals("-XjavadocsInModel")) {
				buildConfig.setGenerateModelMode(true);
				buildConfig.setGenerateJavadocsInModelMode(true);
			} else if (arg.equals("-noweave") || arg.equals( "-XnoWeave")) {
				buildConfig.setNoWeave(true);
			} else if (arg.equals("-XserializableAspects")) {
				buildConfig.setXserializableAspects(true);
			} else if (arg.equals("-XlazyTjp")) {
				buildConfig.setXlazyTjp(true);
            } else if (arg.startsWith("-Xreweavable")) {
            	buildConfig.setXreweavable(true);
            	if (arg.endsWith(":compress")) {
            		buildConfig.setXreweavableCompressClasses(true);
            	}
			} else if (arg.equals("-XnoInline")) {
				buildConfig.setXnoInline(true);
            } else if (arg.startsWith("-showWeaveInfo")) {
            	 buildConfig.setShowWeavingInformation(true);
			} else if (arg.equals("-Xlintfile")) { 
				if (args.size() > nextArgIndex) {
					File lintSpecFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    // XXX relax restriction on props file suffix?
					if (lintSpecFile.canRead() && lintSpecFile.getName().endsWith(".properties")) {
						buildConfig.setLintSpecFile(lintSpecFile);	
					} else {
						showError("bad -Xlintfile file: " + lintSpecFile);
						buildConfig.setLintSpecFile(null);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-Xlintfile requires .properties file argument");
				}
            } else if (arg.equals("-Xlint")) {
//                buildConfig.getAjOptions().put(
//                    AjCompilerOptions.OPTION_Xlint,
//                    CompilerOptions.GENERATE);
                buildConfig.setLintMode(AjBuildConfig.AJLINT_DEFAULT);
            } else if (arg.startsWith("-Xlint:")) {
                if (7 < arg.length()) {
                    buildConfig.setLintMode(arg.substring(7));
                } else {
                    showError("invalid lint option " + arg);
                }
			} else if (arg.equals("-bootclasspath")) {
				if (args.size() > nextArgIndex) {
					String bcpArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer bcp = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(bcpArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    bcp.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        bcp.append(File.pathSeparator);
					    }
					}
					bootclasspath = bcp.toString();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-bootclasspath requires classpath entries");
				}
			} else if (arg.equals("-classpath") || arg.equals("-cp")) {
				if (args.size() > nextArgIndex) {
					String cpArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer cp = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(cpArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    cp.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        cp.append(File.pathSeparator);
					    }
					}
					classpath = cp.toString();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-classpath requires classpath entries");
				}
			} else if (arg.equals("-extdirs")) {
				if (args.size() > nextArgIndex) {
					String extdirsArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer ed = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(extdirsArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    ed.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        ed.append(File.pathSeparator);
					    }
					}					
					extdirs = ed.toString();
					args.remove(args.get(nextArgIndex));
                } else {
                    showError("-extdirs requires list of external directories");
                }
            // error on directory unless -d, -{boot}classpath, or -extdirs
            } else if (arg.equals("-d")) {
                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-classpath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-bootclasspath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-extdirs")) {
//                dirLookahead(arg, args, nextArgIndex);
            } else if (new File(arg).isDirectory()) {
                showError("dir arg not permitted: " + arg);
			} else {
                // argfile, @file parsed by superclass
                // no eclipse options parsed:
                // -d args, -help (handled), 
                // -classpath, -target, -1.3, -1.4, -source [1.3|1.4]
                // -nowarn, -warn:[...], -deprecation, -noImportError,
                // -proceedOnError, -g:[...], -preserveAllLocals,
                // -referenceInfo, -encoding, -verbose, -log, -time
                // -noExit, -repeat
		    	unparsedArgs.add(arg);
			}
        }
================= fetch private static void selectFactoryForVMVersion() { 6e155a6^:runtime/src/org/aspectj/runtime/internal/CFlowCounter.java

private static void selectFactoryForVMVersion() {
		String override = System.getProperty("aspectj.runtime.cflowstack.usethreadlocal","unspecified");
		boolean useThreadLocalImplementation = false;
		if (override.equals("unspecified")) {
			String v = System.getProperty("java.class.version","0.0");
			// Java 1.2 is version 46.0 and above
			useThreadLocalImplementation = (v.compareTo("46.0") >= 0);
		} else {
			useThreadLocalImplementation = override.equals("yes") || override.equals("true");
		}
		// System.err.println("Trying to use thread local implementation? "+useThreadLocalImplementation);
		if (useThreadLocalImplementation) {
			tsFactory = getThreadLocalStackFactory();
		} else {
			tsFactory = getThreadLocalStackFactoryFor11();
		}
	}
================= fetch private static void selectFactoryForVMVersion() { 6e155a6^:runtime/src/org/aspectj/runtime/internal/CFlowStack.java

private static void selectFactoryForVMVersion() {
		String override = System.getProperty("aspectj.runtime.cflowstack.usethreadlocal","unspecified");
		boolean useThreadLocalImplementation = false;
		if (override.equals("unspecified")) {
			String v = System.getProperty("java.class.version","0.0");
			// Java 1.2 is version 46.0 and above
			useThreadLocalImplementation = (v.compareTo("46.0") >= 0);
		} else {
			useThreadLocalImplementation = override.equals("yes") || override.equals("true");
		}
		// System.err.println("Trying to use thread local implementation? "+useThreadLocalImplementation);
		if (useThreadLocalImplementation) {
			tsFactory = getThreadLocalStackFactory();
		} else {
			tsFactory = getThreadLocalStackFactoryFor11();
		}
	}
================= fetch public PersistenceException(Throwable cause) { eca1429^:tests/bugs/ConvertToUnchecked.java

public static void main(String[] args) {
		try {
			Foo foo = new Foo("hello");
			Tester.check(false, "shouldn't get here");
		} catch (PersistenceException pe) {
		}
	}
================= fetch public void test056_arrayCloning() { eca1429^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test056_arrayCloning() {
    runTest("around advice throws java.lang.VerifyError at runtime");
  }
================= fetch public void unhandledException( eca1429^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java

public void unhandledException(
		TypeBinding exceptionType,
		ASTNode location)
	{
		if (!factory.getWorld().getDeclareSoft().isEmpty()) {
			Shadow callSite = factory.makeShadow(location, referenceContext);
			Shadow enclosingExec = factory.makeShadow(referenceContext);
//			System.err.println("about to show error for unhandled exception: "  + new String(exceptionType.sourceName()) + 
//					" at " + location + " in " + referenceContext);		
			
			for (Iterator i = factory.getWorld().getDeclareSoft().iterator(); i.hasNext(); ) {
				DeclareSoft d = (DeclareSoft)i.next();
				// We need the exceptionType to match the type in the declare soft statement
				// This means it must either be the same type or a subtype
				ResolvedTypeX throwException = factory.fromEclipse((ReferenceBinding)exceptionType);
				FuzzyBoolean isExceptionTypeOrSubtype = 
					d.getException().matchesInstanceof(throwException);
				if (!isExceptionTypeOrSubtype.alwaysTrue() ) continue;

				if (callSite != null) {
					FuzzyBoolean match = d.getPointcut().match(callSite);
					if (match.alwaysTrue()) {
						//System.err.println("matched callSite: "  + callSite + " with " + d);
						return;
					} else if (!match.alwaysFalse()) {
						//!!! need this check to happen much sooner
						//throw new RuntimeException("unimplemented, shouldn't have fuzzy match here");
					}
				}
				if (enclosingExec != null) {
					FuzzyBoolean match = d.getPointcut().match(enclosingExec);
					if (match.alwaysTrue()) {
						//System.err.println("matched enclosingExec: "  + enclosingExec + " with " + d);
						return;
					} else if (!match.alwaysFalse()) {
						//!!! need this check to happen much sooner
						//throw new RuntimeException("unimplemented, shouldn't have fuzzy match here");
					}
				}
			}
		}
		
		//??? is this always correct
		if (location instanceof Proceed) {
			return;
		}

		super.unhandledException(exceptionType, location);
	}
================= fetch public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r 8e4d898^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java
/**
         * Extract AspectJ-specific options (except for argfiles).
         * Caller should warn when sourceroots is empty but in 
         * incremental mode.
         * Signals warnings or errors through handler set in constructor.
         */
public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.remove()
			int nextArgIndex = args.indexOf(arg)+1; // XXX assumes unique
            // trim arg?
            if (LangUtil.isEmpty(arg)) {
                showWarning("empty arg found");
            } else if (arg.equals("-inpath")) {;
            	if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_Inpath, CompilerOptions.PRESERVE);
					
					List inPath = buildConfig.getInpath();
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
					while (st.hasMoreTokens()) {
						String filename = st.nextToken();
						File file = makeFile(filename);
						if (file.exists() && FileUtil.hasZipSuffix(filename)) {
							inPath.add(file);    
						} else {
							if (file.isDirectory()) {
								inPath.add(file);
							} else 
		            		
							showError("bad inpath component: " + filename);  
						}
					}
					buildConfig.setInPath(inPath);
					args.remove(args.get(nextArgIndex));            		
            	}
            } else if (arg.equals("-injars")) {;
				if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_InJARs, CompilerOptions.PRESERVE);
					
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
		            	if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
			            	buildConfig.getInJars().add(jarFile);    
		            	} else {
		            		File dirFile = makeFile(filename);
		            		if (dirFile.isDirectory()) {
		            			buildConfig.getInJars().add(dirFile);
		            		} else 
		            		
                            showError("bad injar: " + filename);  
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-aspectpath")) {;
				if (args.size() > nextArgIndex) {
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
                        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
			            	buildConfig.getAspectpath().add(jarFile);    
		            	} else {
                            showError("bad aspectpath: " + filename);
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-sourceroots")) {
				if (args.size() > nextArgIndex) {
					List sourceRoots = new ArrayList();
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	File f = makeFile(st.nextToken());
		            	if (f.isDirectory() && f.canRead()) {
			                sourceRoots.add(f);
		            	} else {
                            showError("bad sourceroot: " + f);
		            	}		            		
		            }
				    if (0 < sourceRoots.size()) {
						buildConfig.setSourceRoots(sourceRoots);	
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-sourceroots requires list of directories");
				}
			} else if (arg.equals("-outjar")) { 
				if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_OutJAR, CompilerOptions.GENERATE);
					File jarFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
					if (FileUtil.hasZipSuffix(jarFile)) {
						try {
							if (!jarFile.exists()) {
                                jarFile.createNewFile();
                            }
                            buildConfig.setOutputJar(jarFile);  
						} catch (IOException ioe) { 
                            showError("unable to create outjar file: " + jarFile);
						}
					} else {
						showError("invalid -outjar file: " + jarFile);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-outjar requires jar path argument");
				}
            } else if (arg.equals("-incremental")) {
                buildConfig.setIncrementalMode(true);
            } else if (arg.equals("-XincrementalFile")) {
                if (args.size() > nextArgIndex) {
                    File file = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    buildConfig.setIncrementalFile(file);
                    if (!file.canRead()) {
                        showError("bad -XincrementalFile : " + file);
                        // if not created before recompile test, stop after first compile
                    }
                    args.remove(args.get(nextArgIndex));
                } else {
                    showError("-XincrementalFile requires file argument");
                }
			} else if (arg.equals("-emacssym")) {
				buildConfig.setEmacsSymMode(true);
				buildConfig.setGenerateModelMode(true);
			} else if (arg.equals("-XjavadocsInModel")) {
				buildConfig.setGenerateModelMode(true);
				buildConfig.setGenerateJavadocsInModelMode(true);
			} else if (arg.equals("-noweave") || arg.equals( "-XnoWeave")) {
				buildConfig.setNoWeave(true);
			} else if (arg.equals("-XserializableAspects")) {
				buildConfig.setXserializableAspects(true);
			} else if (arg.equals("-XlazyTjp")) {
				buildConfig.setXlazyTjp(true);
            } else if (arg.startsWith("-Xreweavable")) {
            	buildConfig.setXreweavable(true);
            	if (arg.endsWith(":compress")) {
            		buildConfig.setXreweavableCompressClasses(true);
            	}
			} else if (arg.equals("-XnoInline")) {
				buildConfig.setXnoInline(true);
            } else if (arg.startsWith("-showWeaveInfo")) {
            	 buildConfig.setShowWeavingInformation(true);
			} else if (arg.equals("-Xlintfile")) { 
				if (args.size() > nextArgIndex) {
					File lintSpecFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    // XXX relax restriction on props file suffix?
					if (lintSpecFile.canRead() && lintSpecFile.getName().endsWith(".properties")) {
						buildConfig.setLintSpecFile(lintSpecFile);	
					} else {
						showError("bad -Xlintfile file: " + lintSpecFile);
						buildConfig.setLintSpecFile(null);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-Xlintfile requires .properties file argument");
				}
            } else if (arg.equals("-Xlint")) {
//                buildConfig.getAjOptions().put(
//                    AjCompilerOptions.OPTION_Xlint,
//                    CompilerOptions.GENERATE);
                buildConfig.setLintMode(AjBuildConfig.AJLINT_DEFAULT);
            } else if (arg.startsWith("-Xlint:")) {
                if (7 < arg.length()) {
                    buildConfig.setLintMode(arg.substring(7));
                } else {
                    showError("invalid lint option " + arg);
                }
			} else if (arg.equals("-bootclasspath")) {
				if (args.size() > nextArgIndex) {
					String bcpArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer bcp = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(bcpArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    bcp.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        bcp.append(File.pathSeparator);
					    }
					}
					bootclasspath = bcp.toString();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-bootclasspath requires classpath entries");
				}
			} else if (arg.equals("-classpath")) {
				if (args.size() > nextArgIndex) {
					String cpArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer cp = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(cpArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    cp.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        cp.append(File.pathSeparator);
					    }
					}
					classpath = cp.toString();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-classpath requires classpath entries");
				}
			} else if (arg.equals("-extdirs")) {
				if (args.size() > nextArgIndex) {
					String extdirsArg = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					StringBuffer ed = new StringBuffer();
					StringTokenizer strTok = new StringTokenizer(extdirsArg,File.pathSeparator);
					while (strTok.hasMoreTokens()) {
					    ed.append(makeFile(strTok.nextToken()));
					    if (strTok.hasMoreTokens()) {
					        ed.append(File.pathSeparator);
					    }
					}					
					extdirs = ed.toString();
					args.remove(args.get(nextArgIndex));
                } else {
                    showError("-extdirs requires list of external directories");
                }
            // error on directory unless -d, -{boot}classpath, or -extdirs
            } else if (arg.equals("-d")) {
                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-classpath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-bootclasspath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-extdirs")) {
//                dirLookahead(arg, args, nextArgIndex);
            } else if (new File(arg).isDirectory()) {
                showError("dir arg not permitted: " + arg);
			} else {
                // argfile, @file parsed by superclass
                // no eclipse options parsed:
                // -d args, -help (handled), 
                // -classpath, -target, -1.3, -1.4, -source [1.3|1.4]
                // -nowarn, -warn:[...], -deprecation, -noImportError,
                // -proceedOnError, -g:[...], -preserveAllLocals,
                // -referenceInfo, -encoding, -verbose, -log, -time
                // -noExit, -repeat
		    	unparsedArgs.add(arg);
			}
        }
Progress : [##################################------] 85%================= fetch private static long performCompile() throws IOException { b133299^:org.aspectj.ajdt.core/testsrc/WeaveTests.java

private static long performCompile() throws IOException {
		
		String ajcargs = 
			"-noExit -outjar " + OUTPUT_PACKAGE + File.separatorChar + "classes.jar " + 
			"-argfile " + OUTPUT_PACKAGE + File.separatorChar + "build.lst";

		// split method creates a String array delimited on a space
		String[] parsedArgs = RunWeaveTests.split(ajcargs); 

		
		long start = System.currentTimeMillis();
		
		org.aspectj.tools.ajc.Main.main(parsedArgs);
		
		long stop = System.currentTimeMillis();
		
		return stop - start;
	}
================= fetch private void configureProjectOptions( AjBuildConfig config, ProjectPropertiesAda b133299^:ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java
/**
	 * Add new options from the ProjectPropertiesAdapter to the configuration.
     * <ul>
     * <li>New list entries are added if not duplicates in,
     *     for classpath, aspectpath, injars, inpath and sourceroots</li>
     * <li>Set only one new entry for output dir or output jar
     *     only if there is no output dir/jar entry in the config</li>
     * </ul>
     * Subsequent changes to the ProjectPropertiesAdapter will not affect
     * the configuration.
	 * <p>Added by AMC 01.20.2003, bugzilla #29769
	 */
private void configureProjectOptions( AjBuildConfig config, ProjectPropertiesAdapter properties ) {
        // XXX no error handling in copying project properties
		// Handle regular classpath
        String propcp = properties.getClasspath();
        if (!LangUtil.isEmpty(propcp)) {
            StringTokenizer st = new StringTokenizer(propcp, File.pathSeparator);
            List configClasspath = config.getClasspath();
            ArrayList toAdd = new ArrayList();
            while (st.hasMoreTokens()) {
                String entry = st.nextToken();
                if (!configClasspath.contains(entry)) {
                    toAdd.add(entry);
                }
            }
            if (0 < toAdd.size()) {
                ArrayList both = new ArrayList(configClasspath.size() + toAdd.size());
                both.addAll(configClasspath);
                both.addAll(toAdd);
                config.setClasspath(both);
                Ajde.getDefault().logEvent("building with classpath: " + both);
            }
        }
       
        // Handle boot classpath
        propcp = properties.getBootClasspath();
        if (!LangUtil.isEmpty(propcp)) {
            StringTokenizer st = new StringTokenizer(propcp, File.pathSeparator);
            List configClasspath = config.getBootclasspath();
            ArrayList toAdd = new ArrayList();
            while (st.hasMoreTokens()) {
                String entry = st.nextToken();
                if (!configClasspath.contains(entry)) {
                    toAdd.add(entry);
                }
            }
            if (0 < toAdd.size()) {
                ArrayList both = new ArrayList(configClasspath.size() + toAdd.size());
                both.addAll(configClasspath);
                both.addAll(toAdd);
                config.setBootclasspath(both);
                Ajde.getDefault().logEvent("building with boot classpath: " + both);
            }
        }
       
        
        
        // set outputdir and outputjar only if both not set
        if ((null == config.getOutputDir() && (null == config.getOutputJar()))) {
            String outPath = properties.getOutputPath();
            if (!LangUtil.isEmpty(outPath)) {
                config.setOutputDir(new File(outPath));
            } 
            String outJar = properties.getOutJar();
            if (!LangUtil.isEmpty(outJar)) {
                config.setOutputJar(new File( outJar ) );  
            }
        }

        join(config.getSourceRoots(), properties.getSourceRoots());
        join(config.getInJars(), properties.getInJars());
        join(config.getInpath(),properties.getInpath());
		config.setSourcePathResources(properties.getSourcePathResources());
        join(config.getAspectpath(), properties.getAspectPath());
	}
================= fetch public String getOutputClassFileName(char[] eclipseClassFileName, CompilationRes b133299^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/* (non-Javadoc)
	 * @see org.aspectj.ajdt.internal.compiler.AjCompiler.IOutputClassFileNameProvider#getOutputClassFileName(char[])
	 */
public String getOutputClassFileName(char[] eclipseClassFileName, CompilationResult result) {
		String filename = new String(eclipseClassFileName);
		filename = filename.replace('/', File.separatorChar) + ".class";
		File destinationPath = buildConfig.getOutputDir();
		String outFile;
		if (destinationPath == null) {
			outFile = new File(filename).getName();
			outFile = new File(extractDestinationPathFromSourceFile(result), outFile).getPath();
		} else {
			outFile = new File(destinationPath, filename).getPath();
		}
		return outFile;		
	}
================= fetch public void performCompilation(List files) { b133299^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

public void performCompilation(List files) {
		if (progressListener != null) {
			compiledCount = 0;
			sourceFileCount = files.size();
			progressListener.setText("compiling source files");
		}
		//System.err.println("got files: " + files);
		String[] filenames = new String[files.size()];
		String[] encodings = new String[files.size()];
		//System.err.println("filename: " + this.filenames);
		for (int i=0; i < files.size(); i++) {
			filenames[i] = ((File)files.get(i)).getPath();
		}
		
		List cps = buildConfig.getFullClasspath();
		Dump.saveFullClasspath(cps);
		String[] classpaths = new String[cps.size()];
		for (int i=0; i < cps.size(); i++) {
			classpaths[i] = (String)cps.get(i);
		}
		
		//System.out.println("compiling");
		environment = getLibraryAccess(classpaths, filenames);
		
		if (!state.classesFromName.isEmpty()) {
			environment = new StatefulNameEnvironment(environment, state.classesFromName);
		}
		
		org.eclipse.jdt.internal.compiler.Compiler.setCompilerAdapterFactory(this);
		org.eclipse.jdt.internal.compiler.Compiler compiler = 
			new org.eclipse.jdt.internal.compiler.Compiler(environment,
					DefaultErrorHandlingPolicies.proceedWithAllProblems(),
				    buildConfig.getOptions().getMap(),
					getBatchRequestor(),
					getProblemFactory());
		
		CompilerOptions options = compiler.options;

		options.produceReferenceInfo = true; //TODO turn off when not needed
		
		try {
		 	compiler.compile(getCompilationUnits(filenames, encodings));
		} catch (OperationCanceledException oce) {
			handler.handleMessage(new Message("build cancelled:"+oce.getMessage(),IMessage.WARNING,null,null));
		}
		// cleanup
		environment.cleanup();
		environment = null;
	}
================= fetch String makeClasspathString() { d1551bd^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

String makeClasspathString() {
		if (buildConfig == null || buildConfig.getClasspath() == null) return "";
		StringBuffer buf = new StringBuffer();
		boolean first = true;
		for (Iterator it = buildConfig.getClasspath().iterator(); it.hasNext(); ) {
			if (first) { first = false; }
			else { buf.append(File.pathSeparator); }
			buf.append(it.next().toString());
		}
		return buf.toString();
	}
================= fetch private Collection collectSourceRootFiles(File dir) { d1551bd^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java

private Collection collectSourceRootFiles(File dir) {
		return Arrays.asList(FileUtil.listFiles(dir, FileUtil.aspectjSourceFileFilter));
	}
================= fetch private static boolean configureNonStandardOptions( d1551bd^:ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java
/**
	 * Helper method for configure build options.
     * This reads all command-line options specified
     * in the non-standard options text entry and
     * sets any corresponding unset values in config.
     * @return false if config failed
	 */
private static boolean configureNonStandardOptions(
        AjBuildConfig config, 
        String nonStdOptions,
        IMessageHandler messageHandler ) {

        if (LangUtil.isEmpty(nonStdOptions)) {
            return true;
        }
		
		// Break a string into a string array of non-standard options.
		// Allows for one option to include a ' '.   i.e. assuming it has been quoted, it
		// won't accidentally get treated as a pair of options (can be needed for xlint props file option)
		List tokens = new ArrayList();
		int ind = nonStdOptions.indexOf('\"');
		int ind2 = nonStdOptions.indexOf('\"',ind+1);
		if ((ind > -1) && (ind2 > -1)) { // dont tokenize within double quotes
			String pre = nonStdOptions.substring(0,ind);
			String quoted = nonStdOptions.substring(ind+1,ind2);
			String post = nonStdOptions.substring(ind2+1,nonStdOptions.length());
			tokens.addAll(tokenizeString(pre));
			tokens.add(quoted);
			tokens.addAll(tokenizeString(post));
		} else {
			tokens.addAll(tokenizeString(nonStdOptions));
		}
		String[] args = (String[])tokens.toArray(new String[]{});
		
		
		// set the non-standard options in an alternate build config
		// (we don't want to lose the settings we already have)
        CountingMessageHandler counter 
            = CountingMessageHandler.makeCountingMessageHandler(messageHandler);
		AjBuildConfig altConfig = AjdtCommand.genBuildConfig(args, counter);
		if (counter.hasErrors()) {
            return false;
        }
        // copy globals where local is not set
        config.installGlobals(altConfig);
        return true;
    }
================= fetch private void configureProjectOptions( AjBuildConfig config, ProjectPropertiesAda d1551bd^:ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java
/**
	 * Add new options from the ProjectPropertiesAdapter to the configuration.
     * <ul>
     * <li>New list entries are added if not duplicates in,
     *     for classpath, aspectpath, injars, inpath and sourceroots</li>
     * <li>New bootclasspath entries are ignored XXX</li>
     * <li>Set only one new entry for output dir or output jar
     *     only if there is no output dir/jar entry in the config</li>
     * </ul>
     * Subsequent changes to the ProjectPropertiesAdapter will not affect
     * the configuration.
	 * <p>Added by AMC 01.20.2003, bugzilla #29769
	 */
private void configureProjectOptions( AjBuildConfig config, ProjectPropertiesAdapter properties ) {
        // XXX no error handling in copying project properties
        String propcp = properties.getClasspath(); // XXX omitting bootclasspath...
        if (!LangUtil.isEmpty(propcp)) {
            StringTokenizer st = new StringTokenizer(propcp, File.pathSeparator);
            List configClasspath = config.getClasspath();
            ArrayList toAdd = new ArrayList();
            while (st.hasMoreTokens()) {
                String entry = st.nextToken();
                if (!configClasspath.contains(entry)) {
                    toAdd.add(entry);
                }
            }
            if (0 < toAdd.size()) {
                ArrayList both = new ArrayList(configClasspath.size() + toAdd.size());
                both.addAll(configClasspath);
                both.addAll(toAdd);
                config.setClasspath(both);
                Ajde.getDefault().logEvent("building with classpath: " + both);
            }
        }

        // set outputdir and outputjar only if both not set
        if ((null == config.getOutputDir() && (null == config.getOutputJar()))) {
            String outPath = properties.getOutputPath();
            if (!LangUtil.isEmpty(outPath)) {
                config.setOutputDir(new File(outPath));
            } 
            String outJar = properties.getOutJar();
            if (!LangUtil.isEmpty(outJar)) {
                config.setOutputJar(new File( outJar ) );  
            }
        }

        join(config.getSourceRoots(), properties.getSourceRoots());
        join(config.getInJars(), properties.getInJars());
        join(config.getInpath(),properties.getInpath());
		config.setSourcePathResources(properties.getSourcePathResources());
        join(config.getAspectpath(), properties.getAspectPath());
	}
================= fetch private void initBcelWorld(IMessageHandler handler) throws IOException { d1551bd^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/** init only on initial batch compile? no file-specific options */
private void initBcelWorld(IMessageHandler handler) throws IOException {
		bcelWorld = new BcelWorld(buildConfig.getClasspath(), handler, null);
		bcelWorld.setXnoInline(buildConfig.isXnoInline());
		bcelWorld.setXlazyTjp(buildConfig.isXlazyTjp());
		bcelWeaver = new BcelWeaver(bcelWorld);
		state.binarySourceFiles = new HashMap();
		
		for (Iterator i = buildConfig.getAspectpath().iterator(); i.hasNext();) {
			File f = (File) i.next();
			bcelWeaver.addLibraryJarFile(f);
		}
		
//		String lintMode = buildConfig.getLintMode();
		
		if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
			bcelWorld.getLint().loadDefaultProperties();
		} else {
			bcelWorld.getLint().setAll(buildConfig.getLintMode());
		}
		
		if (buildConfig.getLintSpecFile() != null) {
			bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
		}
		
		//??? incremental issues
		for (Iterator i = buildConfig.getInJars().iterator(); i.hasNext(); ) {
			File inJar = (File)i.next();
			List unwovenClasses = bcelWeaver.addJarFile(inJar, buildConfig.getOutputDir(),false);
			state.binarySourceFiles.put(inJar.getPath(), unwovenClasses);
		}
		
		for (Iterator i = buildConfig.getInpath().iterator(); i.hasNext(); ) {
			File inPathElement = (File)i.next();
			if (!inPathElement.isDirectory()) {
				// its a jar file on the inpath
				// the weaver method can actually handle dirs, but we don't call it, see next block
				List unwovenClasses = bcelWeaver.addJarFile(inPathElement,buildConfig.getOutputDir(),true);
				state.binarySourceFiles.put(inPathElement.getPath(),unwovenClasses);
			} else {
				// add each class file in an in-dir individually, this gives us the best error reporting
				// (they are like 'source' files then), and enables a cleaner incremental treatment of
				// class file changes in indirs.
				File[] binSrcs = FileUtil.listFiles(inPathElement, binarySourceFilter);
				for (int j = 0; j < binSrcs.length; j++) {
					UnwovenClassFile ucf = 
						bcelWeaver.addClassFile(binSrcs[j], inPathElement, buildConfig.getOutputDir());
					List ucfl = new ArrayList();
					ucfl.add(ucf);
					state.binarySourceFiles.put(binSrcs[j].getPath(),ucfl);
				}
			}
		}
		
		
		bcelWeaver.setReweavableMode(buildConfig.isXreweavable(),buildConfig.getXreweavableCompressClasses());

		//check for org.aspectj.runtime.JoinPoint
		bcelWorld.resolve("org.aspectj.lang.JoinPoint");
	}
================= fetch public AjBuildConfig populateBuildConfig(AjBuildConfig buildConfig, String[] arg d1551bd^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java
/**
     * Generate build configuration for the input args,
     * passing to handler any error messages.
     * @param args the String[] arguments for the build configuration
     * @param setClasspath	determines if the classpath should be parsed and set on the build configuration
     * @param configFile	can be null
     * @return AjBuildConfig per args, 
     *         which will be invalid unless there are no handler errors.
     */
public AjBuildConfig populateBuildConfig(AjBuildConfig buildConfig, String[] args, boolean setClasspath, File configFile) {
		Dump.saveCommandLine(args);	
		buildConfig.setConfigFile(configFile);
		try {
			// sets filenames to be non-null in order to make sure that file paramters are ignored
			super.filenames = new String[] { "" }; 
			
			AjcConfigParser parser = new AjcConfigParser(buildConfig, handler);
			parser.parseCommandLine(args);
			
			boolean swi = buildConfig.getShowWeavingInformation();
			// Now jump through firey hoops to turn them on/off
			if (handler instanceof CountingMessageHandler) {
				IMessageHandler delegate = ((CountingMessageHandler)handler).delegate;
				// Without dontIgnore() on the IMessageHandler interface, we have to do this *blurgh*
				if (delegate instanceof MessageHandler) {
					if (swi) 
					  ((MessageHandler)delegate).dontIgnore(IMessage.WEAVEINFO);
					else 
					  ((MessageHandler)delegate).ignore(IMessage.WEAVEINFO);
				}
			}
			
            
            boolean incrementalMode = buildConfig.isIncrementalMode()
            	|| buildConfig.isIncrementalFileMode();
			
			List fileList = new ArrayList();
            List files = parser.getFiles();
            if (!LangUtil.isEmpty(files)) {
                if (incrementalMode) {
                    MessageUtil.error(handler, "incremental mode only handles source files using -sourceroots"); 
                } else {
                    fileList.addAll(files);
                }
            }
				
			List javaArgList = new ArrayList();
			//	disable all special eclipse warnings by default - why???
			//??? might want to instead override getDefaultOptions()
			javaArgList.add("-warn:none");
			// these next four lines are some nonsense to fool the eclipse batch compiler
			// without these it will go searching for reasonable values from properties
			//TODO fix org.eclipse.jdt.internal.compiler.batch.Main so this hack isn't needed
			javaArgList.add("-classpath");
			javaArgList.add(System.getProperty("user.dir"));
			javaArgList.add("-bootclasspath");
			javaArgList.add(System.getProperty("user.dir"));
			javaArgList.addAll(parser.getUnparsedArgs());
			super.configure((String[])javaArgList.toArray(new String[javaArgList.size()]));
			
			if (!proceed) {
				buildConfig.doNotProceed();
				return buildConfig;
			} 
			
			if (buildConfig.getSourceRoots() != null) {
				for (Iterator i = buildConfig.getSourceRoots().iterator(); i.hasNext(); ) {
					fileList.addAll(collectSourceRootFiles((File)i.next()));
				}
			}
			
			buildConfig.setFiles(fileList);
			if (destinationPath != null) { // XXX ?? unparsed but set?
				buildConfig.setOutputDir(new File(destinationPath));
			}
			
			if (setClasspath) {
				buildConfig.setClasspath(getClasspath(parser));
			}
			
			if (incrementalMode 
                && (0 == buildConfig.getSourceRoots().size())) {
                    MessageUtil.error(handler, "specify a source root when in incremental mode");
			}

			/*
			 * Ensure we don't overwrite injars, inpath or aspectpath with outjar
			 * bug-71339 
			 */
			File outjar = buildConfig.getOutputJar();
			if (outjar != null) {
				
				/* Search injars */
				for (Iterator i = buildConfig.getInJars().iterator(); i.hasNext(); ) {
					File injar = (File)i.next();
					if (injar.equals(outjar)) {
						String message = WeaverMessages.format(WeaverMessages.OUTJAR_IN_INPUT_PATH);
						MessageUtil.error(handler,message);
					}
				}

				/* Search inpath */
				for (Iterator i = buildConfig.getInpath().iterator(); i.hasNext(); ) {
					File inPathElement = (File)i.next();
					if (!inPathElement.isDirectory() && inPathElement.equals(outjar)) {				
						String message = WeaverMessages.format(WeaverMessages.OUTJAR_IN_INPUT_PATH);
						MessageUtil.error(handler,message);
					}
				}

				/* Search aspectpath */
				for (Iterator i = buildConfig.getAspectpath().iterator(); i.hasNext(); ) {
					File pathElement = (File)i.next();
					if (!pathElement.isDirectory() && pathElement.equals(outjar)) {				
						String message = WeaverMessages.format(WeaverMessages.OUTJAR_IN_INPUT_PATH);
						MessageUtil.error(handler,message);
					}
				}

			}
			
			setDebugOptions();
			buildConfig.getOptions().set(options);
		} catch (InvalidInputException iie) {
			ISourceLocation location = null;
			if (buildConfig.getConfigFile() != null) {
				location = new SourceLocation(buildConfig.getConfigFile(), 0); 
			}
			IMessage m = new Message(iie.getMessage(), IMessage.ERROR, null, location);            
			handler.handleMessage(m);
		}
		return buildConfig;
	}
================= fetch public AjCompilerOptions getOptions() { d1551bd^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java

public AjCompilerOptions getOptions() {
		return options;
	}
================= fetch public List getClasspath(AjcConfigParser parser) { d1551bd^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java
/**
     * If the classpath is not set, we use the environment's java.class.path, but remove
     * the aspectjtools.jar entry from that list in order to prevent wierd bootstrap issues
     * (refer to bug#39959).
     */
public List getClasspath(AjcConfigParser parser) {
    	List ret = new ArrayList();
    	
    	if (parser.bootclasspath == null) {
    		addClasspath(System.getProperty("sun.boot.class.path", ""), ret);
    	} else {  
    		addClasspath(parser.bootclasspath, ret);
    	}

		String extdirs = parser.extdirs;
		if (extdirs == null) {
            extdirs = System.getProperty("java.ext.dirs", "");
        }  
        addExtDirs(extdirs, ret);
		
		if (parser.classpath == null) {			
			addClasspath(System.getProperty("java.class.path", ""), ret);
			List fixedList = new ArrayList();
			for (Iterator it = ret.iterator(); it.hasNext(); ) {
				String entry = (String)it.next();
				if (!entry.endsWith("aspectjtools.jar")) {
					fixedList.add(entry);
				}
			}  
			ret = fixedList;
		} else {
	    	addClasspath(parser.classpath, ret);
		}	
		//??? eclipse seems to put outdir on the classpath
		//??? we're brave and believe we don't need it	    
	    return ret;
    }
================= fetch public List getFullClasspath() { d1551bd^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java
/**
     * @return List (String) classpath of injars, inpath, aspectpath 
     *   entries, specified classpath (bootclasspath, extdirs, and 
     *   classpath), and output dir or jar
     */
public List getFullClasspath() {
        List full = new ArrayList();
        for (Iterator i = inJars.iterator(); i.hasNext(); ) {
            full.add(((File)i.next()).getAbsolutePath());
        }
        for (Iterator i = inPath.iterator();i.hasNext();) {
        	full.add(((File)i.next()).getAbsolutePath());
        }
        for (Iterator i = aspectpath.iterator(); i.hasNext(); ) {
            full.add(((File)i.next()).getAbsolutePath());
        }
        full.addAll(getClasspath());
//        if (null != outputDir) {
//            full.add(outputDir.getAbsolutePath());
//        } else if (null != outputJar) {
//            full.add(outputJar.getAbsolutePath());
//        }
        return full;
    }
================= fetch public String checkRtJar(AjBuildConfig buildConfig) { d1551bd^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/**
	 * This will return null if aspectjrt.jar is present and has the correct version.
	 * Otherwise it will return a string message indicating the problem.
	 */
public String checkRtJar(AjBuildConfig buildConfig) {
        // omitting dev info
		if (Version.text.equals(Version.DEVELOPMENT)) {
			// in the development version we can't do this test usefully
//			MessageUtil.info(holder, "running development version of aspectj compiler");
			return null;
		}
		
		if (buildConfig == null || buildConfig.getClasspath() == null) return "no classpath specified";
		for (Iterator it = buildConfig.getClasspath().iterator(); it.hasNext(); ) {
			File p = new File( (String)it.next() );
			if (p.isFile() && p.getName().equals("aspectjrt.jar")) {

				try {
                    String version = null;
                    Manifest manifest = new JarFile(p).getManifest();
                    if (manifest == null) {
                    	return "no manifest found in " + p.getAbsolutePath() + 
								", expected " + Version.text;
                    }
                    Attributes attr = manifest.getAttributes("org/aspectj/lang/");
                    if (null != attr) {
                        version = attr.getValue(Attributes.Name.IMPLEMENTATION_VERSION);
                        if (null != version) {
                            version = version.trim();
                        }
                    }
					// assume that users of development aspectjrt.jar know what they're doing
					if (Version.DEVELOPMENT.equals(version)) {
//						MessageUtil.info(holder,
//							"running with development version of aspectjrt.jar in " + 
//							p.getAbsolutePath());
                        return null;
					} else if (!Version.text.equals(version)) {
						return "bad version number found in " + p.getAbsolutePath() + 
								" expected " + Version.text + " found " + version;
					}
				} catch (IOException ioe) {
					return "bad jar file found in " + p.getAbsolutePath() + " error: " + ioe;
				}
				return null;
			} else {
				// might want to catch other classpath errors
			}
		}
		
		return "couldn't find aspectjrt.jar on classpath, checked: " + makeClasspathString();
	}
================= fetch public boolean isIncrementalFileMode() { d1551bd^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java

public boolean isIncrementalFileMode() {
        return (null != incrementalFile);
    }
================= fetch public void setClasspath(List classpath) { d1551bd^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java

public void setClasspath(List classpath) {
		this.classpath = classpath;
	}
================= fetch public void testBootclasspath() throws InvalidInputException { d1551bd^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java

public void testBootclasspath() throws InvalidInputException {
		final String PATH = "mumble" + File.separator + "rt.jar";
		AjBuildConfig config = genBuildConfig(new String[] { 
			"-bootclasspath", PATH }, 
			messageWriter);		
		assertTrue("Should find '" + PATH + "' contained in the first entry of '" + config.getClasspath().toString(),
				((String)config.getClasspath().get(0)).indexOf(PATH) != -1); 

		config = genBuildConfig(new String[] { 
			}, 
			messageWriter);		
		assertTrue(config.getClasspath().toString(), !config.getClasspath().get(0).equals(PATH)); 
	}
================= fetch public void testPathResolutionFromConfigArgs() { d1551bd^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java

public void testPathResolutionFromConfigArgs() {
		String FILE_PATH =   "@" + TEST_DIR + "configWithClasspathExtdirsBootCPArgs.lst";
		AjBuildConfig config = genBuildConfig(new String[] { FILE_PATH }, messageWriter);
		List classpath = config.getClasspath();
		// should have three entries, resolved relative to location of .lst file
		assertEquals("Three entries in classpath",3,classpath.size());
		Iterator cpIter = classpath.iterator();
		try {
		    assertEquals("Should be relative to TESTDIR",new File(TEST_DIR+File.separator+"xyz").getCanonicalPath(),cpIter.next());
		    assertEquals("Should be relative to TESTDIR",new File(TEST_DIR+File.separator+"myextdir" + File.separator + "dummy.jar").getCanonicalPath(),cpIter.next());
		    assertEquals("Should be relative to TESTDIR",new File(TEST_DIR+File.separator+"abc.jar").getCanonicalPath(),cpIter.next());
			List files = config.getFiles();
			assertEquals("Two source files",2,files.size());
			Iterator fIter = files.iterator();
			assertEquals("Should be relative to TESTDIR",new File(TEST_DIR+File.separator+"Abc.java").getCanonicalFile(),fIter.next());
			assertEquals("Should be relative to TESTDIR",new File(TEST_DIR+File.separator+"xyz"+File.separator+"Def.aj").getCanonicalFile(),fIter.next());
		    
		} catch (IOException ex) {
		    fail("Test case failure attempting to create canonical path: " + ex);
		}
		
	}
================= fetch private LazyMethodGen createMethodGen(String newMethodName, int visibilityModifi 27d204c^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
/**
     * The new method always static.
     * It may take some extra arguments:  this, target.
     * If it's argsOnStack, then it must take both this/target
     * If it's argsOnFrame, it shares this and target.
     * ??? rewrite this to do less array munging, please
     */
private LazyMethodGen createMethodGen(String newMethodName, int visibilityModifier) {
        Type[] parameterTypes = BcelWorld.makeBcelTypes(getArgTypes()); 
        int modifiers = Modifier.FINAL | visibilityModifier;

        // XXX some bug
//        if (! isExpressionKind() && getSignature().isStrict(world)) {
//            modifiers |= Modifier.STRICT;
//        }
        modifiers |= Modifier.STATIC;
        if (targetVar != null && targetVar != thisVar) {
            TypeX targetType = getTargetType();
            ResolvedMember resolvedMember = getSignature().resolve(world);
            if (resolvedMember != null && Modifier.isProtected(resolvedMember.getModifiers()) && 
            	!samePackage(targetType.getPackageName(), getEnclosingType().getPackageName()))
            {
            	if (!targetType.isAssignableFrom(getThisType(), world)) {
            		throw new BCException("bad bytecode");
            	}
            	targetType = getThisType();
            }
            parameterTypes = addType(BcelWorld.makeBcelType(targetType), parameterTypes);
        }
        if (thisVar != null) {
        	TypeX thisType = getThisType();
        	parameterTypes = addType(BcelWorld.makeBcelType(thisType), parameterTypes);
        }
        
        // We always want to pass down thisJoinPoint in case we have already woven
        // some advice in here.  If we only have a single piece of around advice on a
        // join point, it is unnecessary to accept (and pass) tjp.
        if (thisJoinPointVar != null) {
        	parameterTypes = addTypeToEnd(LazyClassGen.tjpType, parameterTypes);
        }
        
        TypeX returnType;
        if (getKind() == PreInitialization) {
        	returnType = TypeX.OBJECTARRAY;
        } else {
        	returnType = getReturnType();
        }
        return
            new LazyMethodGen(
                modifiers, 
                BcelWorld.makeBcelType(returnType), 
                newMethodName,
                parameterTypes,
                new String[0],
    // XXX again, we need to look up methods!
//                TypeX.getNames(getSignature().getExceptions(world)),
                getEnclosingClass());
    }
================= fetch public boolean isExposedToWeaver() { 27d204c^:weaver/src/org/aspectj/weaver/ResolvedTypeX.java

public boolean isExposedToWeaver() { return false; }
================= fetch public void initializeTargetVar() { 27d204c^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public void initializeTargetVar() {
    	InstructionFactory fact = getFactory();    	
        if (targetVar != null) return;
        if (getKind().isTargetSameAsThis()) {
            if (hasThis()) initializeThisVar();
            targetVar = thisVar;
        } else {
            initializeArgVars(); // gotta pop off the args before we find the target
            TypeX type = getTargetType();
            targetVar = genTempVar(type, "ajc$target");
            range.insert(targetVar.createStore(fact), Range.OutsideBefore); 
	        targetVar.setPositionInAroundState(hasThis() ? 1 : 0);            
        }
    }
================= fetch public void test055_cnfe() { 27d204c^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test055_cnfe() {
    runTest("passing null to array arguments confuzes static join point signature. (2)");
  }
================= fetch protected void prepareForMungers() { 4921f0c^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

protected void prepareForMungers() {
		// if we're a constructor call, we need to remove the new:dup or the new:dup_x1:swap, 
		// and store all our
		// arguments on the frame.
		
		// ??? This is a bit of a hack (for the Java langauge).  We do this because
		// we sometime add code "outsideBefore" when dealing with weaving join points.  We only
		// do this for exposing state that is on the stack.  It turns out to just work for 
		// everything except for constructor calls and exception handlers.  If we were to clean
		// this up, every ShadowRange would have three instructionHandle points, the start of 
		// the arg-setup code, the start of the running code, and the end of the running code.
		if (getKind() == ConstructorCall) {
			deleteNewAndDup();
			initializeArgVars();
		} else if (getKind() == ExceptionHandler) {
			ShadowRange range = getRange();
			InstructionList body = range.getBody();
			InstructionHandle start = range.getStart();
			InstructionHandle freshIh = body.insert(start, InstructionConstants.NOP);
			InstructionTargeter[] targeters = start.getTargeters();
			for (int i = 0; i < targeters.length; i++) {
				InstructionTargeter t = targeters[i];
				if (t instanceof ExceptionRange) {
					ExceptionRange er = (ExceptionRange) t;
					er.updateTarget(start, freshIh, body);
				}
			}
		}

		// now we ask each munger to request our state
		isThisJoinPointLazy = world.isXlazyTjp();
		
		for (Iterator iter = mungers.iterator(); iter.hasNext();) {
			ShadowMunger munger = (ShadowMunger) iter.next();
			munger.specializeOn(this);
		}
		
		initializeThisJoinPoint();

	    // If we are an expression kind, we require our target/arguments on the stack
	    // before we do our actual thing.  However, they may have been removed
	    // from the stack as the shadowMungers have requested state.  
	    // if any of our shadowMungers requested either the arguments or target, 
	    // the munger will have added code
	    // to pop the target/arguments into temporary variables, represented by 
	    // targetVar and argVars.  In such a case, we must make sure to re-push the 
	    // values.  
	
	    // If we are nonExpressionKind, we don't expect arguments on the stack
	    // so this is moot.  If our argVars happen to be null, then we know that
	    // no ShadowMunger has squirrelled away our arguments, so they're still
	    // on the stack.		
		InstructionFactory fact = getFactory();
		if (getKind().argsOnStack() && argVars != null) {
			range.insert(
				BcelRenderer.renderExprs(fact, world, argVars),
				Range.InsideBefore);
			if (targetVar != null) {
				range.insert(
					BcelRenderer.renderExpr(fact, world, targetVar),
					Range.InsideBefore);
			}
			if (getKind() == ConstructorCall) {
				range.insert((Instruction) InstructionFactory.createDup(1), Range.InsideBefore);
				range.insert(
					fact.createNew(
						(ObjectType) BcelWorld.makeBcelType(
							getSignature().getDeclaringType())),
					Range.InsideBefore);
			}
		}
 	}
================= fetch Class makeClass(String s) { 438e61c^:runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java

Class[] extractTypes(int n) {
        String s = extractString(n);
        StringTokenizer st = new StringTokenizer(s, INNER_SEP);
        final int N = st.countTokens();
        Class[] ret = new Class[N];
        for (int i = 0; i < N; i++) ret[i]= makeClass(st.nextToken());
        return ret;
    }
================= fetch public Class getFieldType() { 438e61c^:runtime/src/org/aspectj/runtime/reflect/FieldSignatureImpl.java

public Class getFieldType() {
        if (fieldType == null) fieldType = extractType(3);
        return fieldType;
    }
================= fetch public Class getReturnType() { 438e61c^:runtime/src/org/aspectj/runtime/reflect/AdviceSignatureImpl.java

public Class getReturnType() {
        if (returnType == null) returnType = extractType(6);
        return returnType;
    }
================= fetch public Class getReturnType() { 438e61c^:runtime/src/org/aspectj/runtime/reflect/MethodSignatureImpl.java

public Class getReturnType() {
        if (returnType == null) returnType = extractType(6);
        return returnType;
    }
================= fetch public SourceLocation makeSourceLoc(int line, int col) 438e61c^:runtime/src/org/aspectj/runtime/reflect/Factory.java

public SourceLocation makeSourceLoc(int line, int col)
    {
        return new SourceLocationImpl(lexicalClass, this.filename, line, col);
    }
================= fetch public String getName() { 438e61c^:runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.java

public String getName() {
    	return Modifier.isStatic(getModifiers()) ? "<clinit>": "<init>";
    }
================= fetch public String getParameterName() { 438e61c^:runtime/src/org/aspectj/runtime/reflect/CatchClauseSignatureImpl.java

public String getParameterName() {
        if (parameterName == null) parameterName = extractString(4);
        return parameterName;
    }
================= fetch public String toString() { 438e61c^:runtime/src/org/aspectj/runtime/reflect/SourceLocationImpl.java

public String toString() {
    	return getFileName() + ":" + getLine() +
    		((getColumn() == -1) ? ""  : ":" + getColumn());
    }
================= fetch public static TestSuite suite() { 438e61c^:runtime/testsrc/RuntimeModuleTests.java

public static TestSuite suite() { 
        TestSuite suite = new TestSuite(RuntimeModuleTests.class.getName());
        suite.addTestSuite(RuntimeModuleTests.class); // minimum 1 test (testNothing)
        suite.addTestSuite(SignatureTest.class);
        suite.addTestSuite(JoinPointImplTest.class);
        return suite;
    }
================= fetch public void testGetDeclaringTypeName() { 438e61c^:runtime/testsrc/org/aspectj/runtime/reflect/SignatureTest.java

public void testGetDeclaringTypeName() {
		FieldSignatureImpl fsi = new FieldSignatureImpl(0,"x",SignatureTest.class,String.class);
		assertEquals(SignatureTest.class.getName(),fsi.getDeclaringTypeName());
		assertSame(fsi.getDeclaringTypeName(),fsi.getDeclaringTypeName()); // should be cached.
	}
================= fetch void addTypeArray(StringBuffer buf, Class[] types) { 438e61c^:runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java

void addTypeArray(StringBuffer buf, Class[] types) {
        addFullTypeNames(buf, types);
    }
================= fetch public void javadocMissingParamTag(Argument arg, int modifiers) { 5e08765^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java
// PR71076
public void javadocMissingParamTag(Argument arg, int modifiers) {
        boolean reportIt = true;
        if (arg.binding!=null && (arg.binding.declaringScope instanceof MethodScope) ) {
            MethodScope ms = (MethodScope) arg.binding.declaringScope;
            if (ms.referenceContext!=null && (ms.referenceContext instanceof AdviceDeclaration)) {
                AdviceDeclaration adviceDecl = (AdviceDeclaration)ms.referenceContext;
                if (arg.name!=null) {
                  if (adviceDecl.selector.length>4 &&
                    adviceDecl.selector[0] == 'a' &&
                    adviceDecl.selector[1] == 'j' &&
                    adviceDecl.selector[2] == 'c' &&
                    adviceDecl.selector[3] == '$') {
                  
                    String stringArgName = new String(arg.name);
                    if (stringArgName.equals("thisJoinPoint")) reportIt = false;
                    if (stringArgName.equals("thisJoinPointStaticPart")) reportIt = false;
                    if (stringArgName.equals("thisEnclosingJoinPointStaticPart")) reportIt = false;
                    if (arg.type.toString().indexOf("AroundClosure")!=-1) reportIt = false;
                  }
              }
            }
        }
        if (arg.name!=null && new String(arg.name).startsWith("ajc$")) reportIt = false;
        if (reportIt) 
        	super.javadocMissingParamTag(arg, modifiers);
    }
================= fetch public void postParse(TypeDeclaration typeDec) { 5e08765^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java

public void postParse(TypeDeclaration typeDec) {
		if (arguments == null) arguments = new Argument[0];
		this.declaredModifiers = modifiers;
		this.declaredName = new String(selector);
		selector = CharOperation.concat(mangledPrefix, '$', selector, '$',
				Integer.toHexString(sourceStart).toCharArray());
				
		if (Modifier.isAbstract(this.declaredModifiers) && 
			!(typeDec instanceof AspectDeclaration))
		{
			typeDec.scope.problemReporter().signalError(sourceStart, sourceEnd, 
				"The abstract pointcut " + new String(declaredName) +
				" can only be defined in an aspect");
			ignoreFurtherInvestigation = true;
			return;
		}
		
		if (pointcutDesignator != null) {
			pointcutDesignator.postParse(typeDec, this);
		}
	}
================= fetch public void test051_arrayCloningInJava5() { 5e08765^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test051_arrayCloningInJava5() {
    runTest("AJC possible bug with static nested classes");
  }
Progress : [##################################------] 86%================= fetch private static String nameToSignature(String name) { b5e6307^:weaver/src/org/aspectj/weaver/TypeX.java

private static String nameToSignature(String name) {
        if (name.equals("byte")) return "B";
        if (name.equals("char")) return "C";
        if (name.equals("double")) return "D";
        if (name.equals("float")) return "F";
        if (name.equals("int")) return "I";
        if (name.equals("long")) return "J";
        if (name.equals("short")) return "S";
        if (name.equals("boolean")) return "Z";
        if (name.equals("void")) return "V";
        if (name.endsWith("[]")) 
            return "[" + nameToSignature(name.substring(0, name.length() - 2));
        if (name.length() != 0)  // lots more tests could be made here...
            return "L" + name.replace('.', '/') + ";";
        else 
            throw new BCException("Bad type name: " + name);
    }
================= fetch public void test050_typePatternMatchingWithArrays() { b5e6307^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test050_typePatternMatchingWithArrays() {
  	runTest("declare warning warns at wrong points");
  }
================= fetch private boolean matchesExactlyByName(String targetTypeName) { 82eae55^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
/**
	 * @param targetTypeName
	 * @return
	 */
private boolean matchesExactlyByName(String targetTypeName) {
		//XXX hack
		if (knownMatches == null && importedPrefixes == null) {
			return innerMatchesExactly(targetTypeName);
		}
		
		// if our pattern is length 1, then known matches are exact matches
		// if it's longer than that, then known matches are prefixes of a sort
		if (namePatterns.length == 1) {
			for (int i=0, len=knownMatches.length; i < len; i++) {
				if (knownMatches[i].equals(targetTypeName)) return true;
			}
		} else {
			for (int i=0, len=knownMatches.length; i < len; i++) {
				String knownPrefix = knownMatches[i] + "$";
				if (targetTypeName.startsWith(knownPrefix)) {
					int pos = lastIndexOfDotOrDollar(knownMatches[i]);
					if (innerMatchesExactly(targetTypeName.substring(pos+1))) {
						return true;
					}
				}
			}
		}


		// if any prefixes match, strip the prefix and check that the rest matches
		// assumes that prefixes have a dot at the end
		for (int i=0, len=importedPrefixes.length; i < len; i++) {
			String prefix = importedPrefixes[i];
			//System.err.println("prefix match? " + prefix + " to " + targetTypeName);
			if (targetTypeName.startsWith(prefix)) {
				
				if (innerMatchesExactly(targetTypeName.substring(prefix.length()))) {
					return true;
				}
			}
		}
		
		return innerMatchesExactly(targetTypeName);
	}
================= fetch public TypePattern resolveBindings(IScope scope, Bindings bindings, 82eae55^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
/**
	 * Need to determine if I'm really a pattern or a reference to a formal
	 * 
	 * We may wish to further optimize the case of pattern vs. non-pattern
	 * 
	 * We will be replaced by what we return
	 */
public TypePattern resolveBindings(IScope scope, Bindings bindings, 
    								boolean allowBinding, boolean requireExactType)
    { 		
    	if (isStar()) {
			return TypePattern.ANY;  //??? loses source location
		}

		String simpleName = maybeGetSimpleName();
		if (simpleName != null) {
			FormalBinding formalBinding = scope.lookupFormal(simpleName);
			if (formalBinding != null) {
				if (bindings == null) {
					scope.message(IMessage.ERROR, this, "negation doesn't allow binding");
					return this;
				}
				if (!allowBinding) {
					scope.message(IMessage.ERROR, this, 
						"name binding only allowed in target, this, and args pcds");
					return this;
				}
				
				BindingTypePattern binding = new BindingTypePattern(formalBinding);
				binding.copyLocationFrom(this);
				bindings.register(binding, scope);
				
				return binding;
			}
		}
		
		String cleanName = maybeGetCleanName();
		String originalName = cleanName;
		// if we discover it is 'MISSING' when searching via the scope, this next local var will
		// tell us if it is really missing or if it does exist in the world and we just can't
		// see it from the current scope.
		ResolvedTypeX resolvedTypeInTheWorld = null;
		if (cleanName != null) {
			TypeX type;
			
			//System.out.println("resolve: " + cleanName);
			//??? this loop has too many inefficiencies to count
			resolvedTypeInTheWorld = scope.getWorld().resolve(TypeX.forName(cleanName),true);
			while ((type = scope.lookupType(cleanName, this)) == ResolvedTypeX.MISSING) {
				int lastDot = cleanName.lastIndexOf('.');
				if (lastDot == -1) break;
				cleanName = cleanName.substring(0, lastDot) + '$' + cleanName.substring(lastDot+1);
				if (resolvedTypeInTheWorld == ResolvedTypeX.MISSING)
					resolvedTypeInTheWorld = scope.getWorld().resolve(TypeX.forName(cleanName),true);					
			}
			if (type == ResolvedTypeX.MISSING) {
				if (requireExactType) {
					if (!allowBinding) {
						scope.getWorld().getMessageHandler().handleMessage(
							MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_BIND_TYPE,originalName),
											getSourceLocation()));
					} else if (scope.getWorld().getLint().invalidAbsoluteTypeName.isEnabled()) {
						scope.getWorld().getLint().invalidAbsoluteTypeName.signal(originalName, getSourceLocation());
					}
					return NO;
				} else if (scope.getWorld().getLint().invalidAbsoluteTypeName.isEnabled()) {
					// Only put the lint warning out if we can't find it in the world
					if (resolvedTypeInTheWorld == ResolvedTypeX.MISSING)
					  scope.getWorld().getLint().invalidAbsoluteTypeName.signal(originalName, getSourceLocation());
				}
			} else {
				if (dim != 0) type = TypeX.makeArray(type, dim);
				TypePattern ret = new ExactTypePattern(type, includeSubtypes);
				ret.copyLocationFrom(this);
				return ret;
			}
		} else {
			if (requireExactType) {
				scope.getWorld().getMessageHandler().handleMessage(
					MessageUtil.error(WeaverMessages.format(WeaverMessages.WILDCARD_NOT_ALLOWED),
										getSourceLocation()));
				return NO;
			}
			//XXX need to implement behavior for Lint.invalidWildcardTypeName
		}
		
		importedPrefixes = scope.getImportedPrefixes();
		knownMatches = preMatch(scope.getImportedNames());
		
		return this;
	}
================= fetch public void test049_interfaceITD_pr70794_4() { 82eae55^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test049_interfaceITD_pr70794_4() {
    runTest("The introduction on interface causes the interface implementation class error (4)");
  }
================= fetch protected World() { f503523^:weaver/src/org/aspectj/weaver/World.java

public ResolvedTypeX[] resolve(TypeX[] types) {
        int len = types.length;
        ResolvedTypeX[] ret = new ResolvedTypeX[len];
        for (int i=0; i<len; i++) {
            ret[i] = resolve(types[i]);
        }
        return ret;
    }
================= fetch protected boolean doCommand(IMessageHandler handler, boolean repeat) { f503523^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java
/** 
     * Delegate of both runCommand and repeatCommand.
     * This invokes the argument parser each time
     * (even when repeating).
     * If the parser detects errors, this signals an 
     * abort with the usage message and returns false.
     * @param handler the IMessageHandler sink for any messages
     * @param repeat if true, do incremental build, else do batch build
     * @return false if handler has any errors or command failed
     */
protected boolean doCommand(IMessageHandler handler, boolean repeat) {
        try {
			//buildManager.setMessageHandler(handler);
            CountingMessageHandler counter = new CountingMessageHandler(handler);
            if (counter.hasErrors()) {
                return false;
            }
            // regenerate configuration b/c world might have changed (?)
            AjBuildConfig config = genBuildConfig(savedArgs, counter);
            if (!config.shouldProceed()) {
            	return true;
            }
            if (!config.hasSources()) {
                MessageUtil.error(counter, "no sources specified");
            }
            if (counter.hasErrors())  { // print usage for config errors
                String usage = BuildArgParser.getUsage();
                MessageUtil.abort(handler, usage);
                return false;
            }
            //System.err.println("errs: " + counter.hasErrors());          
            return ((repeat 
                        ? buildManager.incrementalBuild(config, handler)
                        : buildManager.batchBuild(config, handler))
                    && !counter.hasErrors());
        } catch (AbortException ae) {
            if (ae.isSilent()) {
                throw ae;
            } else {
                MessageUtil.abort(handler, ABORT_MESSAGE, ae);
            }
        } catch (MissingSourceFileException t) { 
            MessageUtil.error(handler, t.getMessage());
        } catch (Throwable t) {
            MessageUtil.abort(handler, ABORT_MESSAGE, t);
        } 
        return false;
    }
================= fetch public AjBuildConfig genBuildConfig(String[] args) { f503523^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java
/**
	 * Generate build configuration for the input args,
	 * passing to handler any error messages.
	 * @param args the String[] arguments for the build configuration
	 * @return AjBuildConfig per args, 
	 *         which will be invalid unless there are no handler errors.
	 */
public AjBuildConfig genBuildConfig(String[] args) {
		AjBuildConfig config = new AjBuildConfig();
		populateBuildConfig(config, args,  true, null);
		return config;
	}
================= fetch public ResolvedPointcutDefinition findPointcut(TypeX typeX, String name) { f503523^:weaver/src/org/aspectj/weaver/World.java
// ---- pointcuts
public ResolvedPointcutDefinition findPointcut(TypeX typeX, String name) {
        throw new RuntimeException("not implemented yet");
    }
================= fetch public ResolvedTypeX resolve(TypeX ty, boolean allowMissing) { f503523^:weaver/src/org/aspectj/weaver/World.java

public ResolvedTypeX resolve(TypeX ty, boolean allowMissing) {
    	//System.out.println("resolve: " + ty + " world " + typeMap.keySet());
        String signature = ty.getSignature();
        ResolvedTypeX ret = typeMap.get(signature);
        if (ret != null) return ret;
        
        if (ty.isArray()) {
            ret = new ResolvedTypeX.Array(signature, this, resolve(ty.getComponentType(), allowMissing));
        } else {
            ret = resolveObjectType(ty);
            if (!allowMissing && ret == ResolvedTypeX.MISSING) {
            	//Thread.currentThread().dumpStack();
                MessageUtil.error(messageHandler, 
                		WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE,ty.getName()));
                // + " on classpath " + classPath);
            }
        }
        //System.out.println("ret: " + ret);
        typeMap.put(signature, ret);
        return ret;
    }
================= fetch public static Test suite() { f503523^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(AjdtBatchTests.class.getName());
        // Abstract superclass
        //suite.addTestSuite(CommandTestCase.class); 
        //$JUnit-BEGIN$
        suite.addTestSuite(BasicCommandTestCase.class); 
        suite.addTestSuite(BinaryFormsTestCase.class); 
		suite.addTestSuite(CompileAndRunTestCase.class); 
		suite.addTestSuite(PerformanceTestCase.class); 
        suite.addTestSuite(ImageTestCase.class); 
        suite.addTestSuite(MultipleCompileTestCase.class); 
        suite.addTestSuite(JavadocTest.class);
        suite.addTestSuite(PartiallyExposedHierarchyTestCase.class);
        // XXX suite.addTestSuite(VerifyWeaveTestCase.class); 
        //suite.addTestSuite(WorkingCommandTestCase.class); 
        //$JUnit-END$
        return suite;
    }
================= fetch public static Test suite() { f503523^:weaver/testsrc/org/aspectj/weaver/BcweaverTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(BcweaverTests.class.getName());
        // abstract
        //suite.addTestSuite(AbstractWorldTestCase.class); 
        //$JUnit-BEGIN$
        suite.addTestSuite(MemberTestCase.class); 
		suite.addTestSuite(TypeXTestCase.class); 
		suite.addTestSuite(WeavingURLClassLoaderTest.class); 
		suite.addTestSuite(WeaverMessagesTestCase.class);
        //$JUnit-END$
        return suite;
    }
================= fetch public void performCompilation(List files) { f503523^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

public void performCompilation(List files) {
		if (progressListener != null) {
			compiledCount = 0;
			sourceFileCount = files.size();
			progressListener.setText("compiling source files");
		}
		//System.err.println("got files: " + files);
		String[] filenames = new String[files.size()];
		String[] encodings = new String[files.size()];
		//System.err.println("filename: " + this.filenames);
		for (int i=0; i < files.size(); i++) {
			filenames[i] = ((File)files.get(i)).getPath();
		}
		
		List cps = buildConfig.getFullClasspath();
		String[] classpaths = new String[cps.size()];
		for (int i=0; i < cps.size(); i++) {
			classpaths[i] = (String)cps.get(i);
		}
		
		//System.out.println("compiling");
		environment = getLibraryAccess(classpaths, filenames);
		
		if (!state.classesFromName.isEmpty()) {
			environment = new StatefulNameEnvironment(environment, state.classesFromName);
		}
		
		org.eclipse.jdt.internal.compiler.Compiler.setCompilerAdapterFactory(this);
		org.eclipse.jdt.internal.compiler.Compiler compiler = 
			new org.eclipse.jdt.internal.compiler.Compiler(environment,
					DefaultErrorHandlingPolicies.proceedWithAllProblems(),
				    buildConfig.getOptions().getMap(),
					getBatchRequestor(),
					getProblemFactory());
		
		CompilerOptions options = compiler.options;

		options.produceReferenceInfo = true; //TODO turn off when not needed
		
		try {
		 	compiler.compile(getCompilationUnits(filenames, encodings));
		} catch (OperationCanceledException oce) {
			handler.handleMessage(new Message("build cancelled:"+oce.getMessage(),IMessage.WARNING,null,null));
		}
		// cleanup
		environment.cleanup();
		environment = null;
	}
================= fetch public void run(String[] args, IMessageHolder holder) { f503523^:org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java
/**
     * Run without using System.exit(..), putting all messages in holder:
     * <ul>
     * <li>ERROR: compiler error</li>
     * <li>WARNING: compiler warning</li>
     * <li>FAIL: command error (bad arguments, exception thrown)</li>
     * </ul>
     * This handles incremental behavior:
     * <ul>
     * <li>If args include "-incremental", repeat for every input char
     *     until 'q' is entered.<li>
     * <li>If args include "-incrementalTagFile {file}", repeat every time
     *     we detect that {file} modification time has changed. </li>
     * <li>Either way, list files recompiled each time if args includes "-verbose".</li>
     * <li>Exit when the commmand/compiler throws any Throwable.</li>
     * </ul>
     * When complete, this contains all the messages of the final
     * run of the command and/or any FAIL messages produced in running
     * the command, including any Throwable thrown by the command itself.
     * 
     * @param args the String[] command line for the compiler
     * @param holder the MessageHandler sink for messages.
     */
public void run(String[] args, IMessageHolder holder) {
        if (LangUtil.isEmpty(args)) {
            args = new String[] { "-?" };
        }  else if (controller.running()) {
            fail(holder, "already running with controller: " + controller, null);
            return;
        } 
        args = controller.init(args, holder);
        if (0 < holder.numMessages(IMessage.ERROR, true)) {
            return;
        }      
        ICommand command = ReflectionFactory.makeCommand(commandName, holder);
        if (0 < holder.numMessages(IMessage.ERROR, true)) {
            return;
        }      
        try {
//            boolean verbose = (-1 != ("" + Arrays.asList(args)).indexOf("-verbose"));
            outer:
            while (true) {
                boolean passed = command.runCommand(args, holder);
                if (report(passed, holder) && controller.incremental()) {
//                    final boolean onCommandLine = controller.commandLineIncremental();
                    while (controller.doRepeatCommand(command)) {
                        holder.clearMessages();
                        if (controller.buildFresh()) {
                            continue outer;
                        } else {
                            passed = command.repeatCommand(holder);
                        }
                        if (!report(passed, holder)) {
                            break;
                        }
                    }
                }
                break;
            }
        } catch (AbortException ae) {
        	if (ae.isSilent()) { 
        		quit();
        	} else {
                IMessage message = ae.getIMessage();
                Throwable thrown = ae.getThrown();
                if (null == thrown) { // toss AbortException wrapper
                    if (null != message) {
                        holder.handleMessage(message);
                    } else {
                        fail(holder, "abort without message", ae);
                    }
                } else if (null == message) {
                    fail(holder, "aborted", thrown);
                } else {
                    String mssg = MessageUtil.MESSAGE_MOST.renderToString(message);
                    fail(holder, mssg, thrown);
                }
        	}
    	} catch (Throwable t) {
            fail(holder, "unexpected exception", t);
        }
    }
================= fetch public void testCoverage() { 5f80c8c^:ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java

public void testCoverage() {
		outdir.delete();
		String[] args = { 
//			"-XajdocDebug",
			"-source", 
			"1.4",
			"-private",
			"-d", 
			outdir.getAbsolutePath(),
			aspect1.getAbsolutePath(), 
			file0.getAbsolutePath(), 
			file1.getAbsolutePath(), 
			file2.getAbsolutePath(),
			file3.getAbsolutePath(),
			file4.getAbsolutePath(),
			file5.getAbsolutePath(),
			file6.getAbsolutePath(),
			file7.getAbsolutePath(),
			file8.getAbsolutePath(),
			file9.getAbsolutePath()
		};
		org.aspectj.tools.ajdoc.Main.main(args);
	}
================= fetch private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge dbe1024^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java

private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munger) {
		ResolvedMember signature = munger.getSignature();
		ResolvedMember dispatchMethod = munger.getDispatchMethod(aspectType);
		
		LazyClassGen gen = weaver.getLazyClassGen();
		
		ResolvedTypeX onType = weaver.getWorld().resolve(signature.getDeclaringType());
		boolean onInterface = onType.isInterface();
		
		if (onType.equals(gen.getType())) {
			ResolvedMember introMethod = 
					AjcMemberMaker.interMethod(signature, aspectType, onInterface);
            
			LazyMethodGen mg = makeMethodGen(gen, introMethod);

			if (!onInterface && !Modifier.isAbstract(introMethod.getModifiers())) {
				InstructionList body = mg.getBody();
				InstructionFactory fact = gen.getFactory();
				int pos = 0;
	
				if (!signature.isStatic()) {
					body.append(InstructionFactory.createThis());
					pos++;
				}
				Type[] paramTypes = BcelWorld.makeBcelTypes(introMethod.getParameterTypes());
				for (int i = 0, len = paramTypes.length; i < len; i++) {
					Type paramType = paramTypes[i];
					body.append(InstructionFactory.createLoad(paramType, pos));
					pos+=paramType.getSize();
				}
				body.append(Utility.createInvoke(fact, weaver.getWorld(), dispatchMethod));
				body.append(
					InstructionFactory.createReturn(
						BcelWorld.makeBcelType(introMethod.getReturnType())));
			} else {
				//??? this is okay
				//if (!(mg.getBody() == null)) throw new RuntimeException("bas");
			}
			

			// XXX make sure to check that we set exceptions properly on this guy.
			weaver.addLazyMethodGen(mg);
			weaver.getLazyClassGen().warnOnAddedMethod(mg.getMethod(),getSignature().getSourceLocation());
			
			addNeededSuperCallMethods(weaver, onType, munger.getSuperMethodsCalled());
			
    		return true;
		} else if (onInterface && gen.getType().isTopmostImplementor(onType) && 
						!Modifier.isAbstract(signature.getModifiers()))
		{
			ResolvedMember introMethod = 
					AjcMemberMaker.interMethod(signature, aspectType, false);
			
			LazyMethodGen mg = makeMethodGen(gen, introMethod);
						
			Type[] paramTypes = BcelWorld.makeBcelTypes(introMethod.getParameterTypes());
			Type returnType = BcelWorld.makeBcelType(introMethod.getReturnType());
			
			InstructionList body = mg.getBody();
			InstructionFactory fact = gen.getFactory();
			int pos = 0;

			if (!introMethod.isStatic()) {
				body.append(InstructionFactory.createThis());
				pos++;
			}
			for (int i = 0, len = paramTypes.length; i < len; i++) {
				Type paramType = paramTypes[i];
				body.append(InstructionFactory.createLoad(paramType, pos));
				pos+=paramType.getSize();
			}
			body.append(Utility.createInvoke(fact, weaver.getWorld(), dispatchMethod));
			body.append(InstructionFactory.createReturn(returnType));
			mg.definingType = onType;
			
			weaver.addOrReplaceLazyMethodGen(mg);
			
			addNeededSuperCallMethods(weaver, onType, munger.getSuperMethodsCalled());
			
			return true;
		} else {
			return false;
		}
	}
================= fetch public boolean isTopmostImplementor(ResolvedTypeX interfaceType) { dbe1024^:weaver/src/org/aspectj/weaver/ResolvedTypeX.java

public boolean isTopmostImplementor(ResolvedTypeX interfaceType) {
		if (isInterface()) return false;
		if (!interfaceType.isAssignableFrom(this)) return false;
		// check that I'm truly the topmost implementor
		if (interfaceType.isAssignableFrom(this.getSuperclass())) {
			return false;
		}
		return true;
	}
================= fetch public static Test suite() { dbe1024^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(AjdtBatchTests.class.getName());
        // Abstract superclass
        //suite.addTestSuite(CommandTestCase.class); 
        //$JUnit-BEGIN$
        suite.addTestSuite(BasicCommandTestCase.class); 
        suite.addTestSuite(BinaryFormsTestCase.class); 
		suite.addTestSuite(CompileAndRunTestCase.class); 
		suite.addTestSuite(PerformanceTestCase.class); 
        suite.addTestSuite(ImageTestCase.class); 
        suite.addTestSuite(MultipleCompileTestCase.class); 
        suite.addTestSuite(JavadocTest.class);
        // XXX suite.addTestSuite(VerifyWeaveTestCase.class); 
        //suite.addTestSuite(WorkingCommandTestCase.class); 
        //$JUnit-END$
        return suite;
    }
================= fetch public void test043_pr62642_ExceptionInInitializerError() { dfb15c1^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test043_pr62642_ExceptionInInitializerError() {
    runTest("proper handling of ExceptionInIntializer inside clinit in presence of after throwing advice");
    String s = getLastRunResult().getStdErr();
    assertTrue("Output should contain java.lang.ExceptionInInitializerError but is '"+s+"'",
            s.indexOf("java.lang.ExceptionInInitializerError")!=-1);
    // No getCause on 1.3 JVMs
//    assertTrue("Output should contain 'CAUSE=org.aspectj.lang.NoAspectBoundException' but is '"+s+"'",
//            s.indexOf("CAUSE=org.aspectj.lang.NoAspectBoundException")!=-1);
  }
================= fetch public void test044_ITDnameClashes() { dfb15c1^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test044_ITDnameClashes() {
    	runTest("ITD name clashes with private members");
  }
Progress : [##################################------] 87%================= fetch public static Test suite() { 5b90224^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(AjdtBatchTests.class.getName());
        // Abstract superclass
        //suite.addTestSuite(CommandTestCase.class); 
        //$JUnit-BEGIN$
        suite.addTestSuite(BasicCommandTestCase.class); 
        suite.addTestSuite(BinaryFormsTestCase.class); 
		suite.addTestSuite(CompileAndRunTestCase.class); 
		suite.addTestSuite(PerformanceTestCase.class); 
        suite.addTestSuite(ImageTestCase.class); 
        suite.addTestSuite(MultipleCompileTestCase.class); 
        // XXX suite.addTestSuite(VerifyWeaveTestCase.class); 
        //suite.addTestSuite(WorkingCommandTestCase.class); 
        //$JUnit-END$
        return suite;
    }
================= fetch public void test042_ITDaccessingPrivateMethod_pr67578_2() { 84e4e53^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test042_ITDaccessingPrivateMethod_pr67578_2() {
  	runTest("Privileged Aspect Access Problem Across Packages (2)");
  }
================= fetch public boolean visit(TypeDeclaration memberTypeDeclaration, BlockScope scope) { a2469c7^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java

public boolean visit(TypeDeclaration memberTypeDeclaration, BlockScope scope) {
//		String name = new String(memberTypeDeclaration.name);
		
		String fullName = "<undefined>";
		if (memberTypeDeclaration.binding != null
			&& memberTypeDeclaration.binding.constantPoolName() != null) {
			fullName = new String(memberTypeDeclaration.binding.constantPoolName());
		}
		 
		int dollar = fullName.indexOf('$');
		fullName = fullName.substring(dollar+1);

		IProgramElement.Kind kind = IProgramElement.Kind.CLASS;
		if (memberTypeDeclaration.isInterface()) kind = IProgramElement.Kind.INTERFACE;

		IProgramElement peNode = new ProgramElement(
			fullName,
			kind,
			makeLocation(memberTypeDeclaration),
			memberTypeDeclaration.modifiers,
			"",
			new ArrayList());
		peNode.setSourceSignature(genSourceSignature(memberTypeDeclaration));
		peNode.setFormalComment(generateJavadocComment(memberTypeDeclaration));
		
		//??? we add this to the compilation unit
		findEnclosingClass(stack).addChild(peNode);
		stack.push(peNode);
		return true;
	}
================= fetch public void testOutjarInInjars () { a2469c7^:ajde/testsrc/org/aspectj/ajde/ExtensionTests.java
/**
	 * Aim: Check that the ID of certain message kinds are correct
	 * 
	 *   ajc -warn:unusedImport UnusedImport.java
	 * 
	 * Expected result = id 
	 */
public void testOutjarInInjars () {
		String[] args = new String[] {"UnusedImport.java","-warn:unusedImport"};
		CompilationResult result = ajc(baseDir,args);
		List l = result.getWarningMessages();
		IMessage m = ((IMessage)l.get(0));
		assertTrue("Expected ID of message to be "+IProblem.UnusedImport+" (UnusedImport) but found an ID of "+m.getID(),
			m.getID()==IProblem.UnusedImport);
	}
================= fetch public void test038_innerAspectCallsPrivateMethod_pr71372_4() { 6b1ef0f^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test038_innerAspectCallsPrivateMethod_pr71372_4() {
    runTest("NoSuchMethodError calling private method from around advice in inner aspect (4)");
    String s = getLastRunResult().getStdErr();
    assertTrue("Expected ':before:around' but got "+s,
    		   s.equals(":before:around"));
  }
================= fetch private IProgramElement createFileStructureNode(String sourceFilePath) { 2dfc738^:asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java

private IProgramElement createFileStructureNode(String sourceFilePath) {
		String fileName = new File(sourceFilePath).getName();
		IProgramElement fileNode = new ProgramElement(fileName, IProgramElement.Kind.FILE_JAVA, null);
		fileNode.setSourceLocation(new SourceLocation(new File(sourceFilePath), 1, 1));
		fileNode.addChild(NO_STRUCTURE);
		return fileNode;
	}
================= fetch private void printOne(PrintStream out) { 228fc8d^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java

private void printOne(PrintStream out) {
        out.print(toShortString());
        out.print(" extends ");
        out.print(
            org.apache.bcel.classfile.Utility.compactClassName(
                myGen.getSuperclassName(),
                false));

        int size = myGen.getInterfaces().length;

        if (size > 0) {
            out.print(" implements ");
            for (int i = 0; i < size; i++) {
                out.print(myGen.getInterfaceNames()[i]);
                if (i < size - 1)
                    out.print(", ");
            }
        }
        out.print(":");
        out.println();
        // XXX make sure to pass types correctly around, so this doesn't happen.
        if (myType != null) {
        	myType.printWackyStuff(out);
        }
        Field[] fields = myGen.getFields();
        for (int i = 0, len = fields.length; i < len; i++) {
            out.print("  ");
            out.println(fields[i]);
        }
        List methodGens = getMethodGens();
        for (Iterator iter = methodGens.iterator(); iter.hasNext();) {
            LazyMethodGen gen = (LazyMethodGen) iter.next();
            // we skip empty clinits
            if (isEmptyClinit(gen)) continue;
            gen.print(out);
            if (iter.hasNext()) out.println();
        }
//        out.println("  ATTRIBS: " + Arrays.asList(myGen.getAttributes()));
        
        out.println("end " + toShortString());
    }
================= fetch public String toShortString() { 228fc8d^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java

public String toShortString() {
        String s =
            org.apache.bcel.classfile.Utility.accessToString(myGen.getAccessFlags(), true);
        if (s != "")
            s += " ";
        s += org.apache.bcel.classfile.Utility.classOrInterface(myGen.getAccessFlags());
        s += " ";
        s += myGen.getClassName();
        return s;
    }
================= fetch public String toShortString() { 228fc8d^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

public String toShortString() {
        String access = org.apache.bcel.classfile.Utility.accessToString(getAccessFlags());
        
        StringBuffer buf = new StringBuffer();
        
        if (!access.equals("")) {
            buf.append(access);
            buf.append(" ");
        }
		buf.append(
			org.apache.bcel.classfile.Utility.signatureToString(
				getReturnType().getSignature(),
				true));
        buf.append(" ");
        buf.append(getName());
        buf.append("(");
		{
			int len = argumentTypes.length;
			if (len > 0) {
				buf.append(
					org.apache.bcel.classfile.Utility.signatureToString(
						argumentTypes[0].getSignature(),
						true));
				for (int i = 1; i < argumentTypes.length; i++) {
					buf.append(", ");
					buf.append(
						org.apache.bcel.classfile.Utility.signatureToString(
							argumentTypes[i].getSignature(),
							true));
				}
			}
		}
        buf.append(")");
        
        {
            int len = declaredExceptions != null ? declaredExceptions.length : 0;
            if (len > 0) {
                buf.append(" throws ");
                buf.append(declaredExceptions[0]);
                for (int i = 1; i < declaredExceptions.length; i++) {
                    buf.append(", ");
                    buf.append(declaredExceptions[i]);
                }  
            }
        }      
        return buf.toString();
    }
Progress : [###################################-----] 88%================= fetch public void test027_itdsOnInnerClassesAsStatic() { 8c5d743^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test027_itdsOnInnerClassesAsStatic() {
      runTest("ITDs on inner classes should be static context");
  }
================= fetch public void test029_falseInvalidAbsoluteTypeName() { 8c5d743^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java
//  }
public void test029_falseInvalidAbsoluteTypeName() {
    runTest("Valid but inaccessible type names should not be flagged by XLint:invalidAbsoluteTypeName");
  }
================= fetch public void test033_stringConcatForDEOWErrorCase() { 8c5d743^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test033_stringConcatForDEOWErrorCase() {
    runTest("Compile time declarations (warning and error) do not accept string concatenation (with +) (2)");
  }
================= fetch private Declare parseErrorOrWarning(boolean isError) { d43a391^:weaver/src/org/aspectj/weaver/patterns/PatternParser.java

private Declare parseErrorOrWarning(boolean isError) {
		Pointcut pointcut = parsePointcut();
		eat(":");
		String message = parseStringLiteral();
		return new DeclareErrorOrWarning(isError, pointcut, message);
	}
================= fetch private NamePattern tryToExtractName(TypePattern nextType) { d43a391^:weaver/src/org/aspectj/weaver/patterns/PatternParser.java

private NamePattern tryToExtractName(TypePattern nextType) {
		if (nextType == TypePattern.ANY) {
			return NamePattern.ANY;
		} else if (nextType instanceof WildTypePattern) {
			WildTypePattern p = (WildTypePattern)nextType;
			return p.extractName();
		} else {
		    return null;
		}
	}
================= fetch public void test025_proceedInAround3() { d43a391^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test025_proceedInAround3() {
      runTest("proceed used as method name in around advice (3)");
  }
================= fetch public void test029_falseInvalidAbsoluteTypeName() { d43a391^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java
//  }
public void test029_falseInvalidAbsoluteTypeName() {
    runTest("Valid but inaccessible type names should not be flagged by XLint:invalidAbsoluteTypeName");
  }
================= fetch public void test031_privateITDinitialisersBeingMatched_OxfordTest() { d43a391^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test031_privateITDinitialisersBeingMatched_OxfordTest() {
    runTest("intertype initialisers should match field set pointcuts (oxford testcase)");
    //System.err.println(">"+getLastRunResult().getStdErr());
    String exp = ":set field set(int C.n):set field set(int C.m):get field get(int C.n):set field set(int C.n)";
    assertTrue("Expected output '"+exp+"' but got "+getLastRunResult().getStdErr(),
    		getLastRunResult().getStdErr().equals(exp));
  }
================= fetch public void resolve(ClassScope upperScope) { 64183c3^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeFieldDeclaration.java

public void resolve(ClassScope upperScope) {
		if (munger == null) ignoreFurtherInvestigation = true;
		if (ignoreFurtherInvestigation) return;
		
		EclipseFactory world = EclipseFactory.fromScopeLookupEnvironment(upperScope);
		ResolvedMember sig = munger.getSignature();
		TypeX aspectType = EclipseFactory.fromBinding(upperScope.referenceContext.binding);
		
		if (sig.getReturnType() == ResolvedTypeX.VOID || 
				(sig.getReturnType().isArray() && (sig.getReturnType().getComponentType() == ResolvedTypeX.VOID)))
		{
			upperScope.problemReporter().signalError(sourceStart, sourceEnd,
				"field type can not be void");
		}
		
//
//		System.err.println("sig: " + sig);
//		System.err.println("field: " + world.makeFieldBinding(
//				AjcMemberMaker.interFieldClassField(sig, aspectType)));
		

		if (initialization != null && initialization instanceof ArrayInitializer) {
			//System.err.println("got initializer: " + initialization);
			ArrayAllocationExpression aae = new ArrayAllocationExpression();
			aae.initializer = (ArrayInitializer)initialization;
			ArrayBinding arrayType = (ArrayBinding)world.makeTypeBinding(sig.getReturnType());
			aae.type = AstUtil.makeTypeReference(arrayType.leafComponentType());
			aae.sourceStart = initialization.sourceStart;
			aae.sourceEnd = initialization.sourceEnd;
			aae.dimensions = new Expression[arrayType.dimensions];
			initialization = aae;
		}

		
		if (initialization == null) {
			this.statements = new Statement[] {
				new ReturnStatement(null, 0, 0),
			};
		} else if (!onTypeBinding.isInterface()) {
			FieldBinding interField = world.makeFieldBinding(
				AjcMemberMaker.interFieldClassField(sig, aspectType));
			Reference ref = new KnownFieldReference(interField, 0);
			this.statements = new Statement[] {
				new Assignment(ref, initialization, initialization.sourceEnd),
			};
		} else {
			//XXX something is broken about this logic.  Can we write to static interface fields?
			MethodBinding writeMethod = world.makeMethodBinding(
				AjcMemberMaker.interFieldInterfaceSetter(sig, sig.getDeclaringType().resolve(world.getWorld()), aspectType));
			if (Modifier.isStatic(declaredModifiers)) {
				this.statements = new Statement[] {
					new KnownMessageSend(writeMethod, 
							AstUtil.makeNameReference(writeMethod.declaringClass),
							new Expression[] {initialization}),
				};
			} else {				
				this.statements = new Statement[] {
					new KnownMessageSend(writeMethod, 
							AstUtil.makeLocalVariableReference(arguments[0].binding),
							new Expression[] {initialization}),
				};
			}
		}
		
		super.resolve(upperScope);
	}
================= fetch public void test025_proceedInAround3() { 64183c3^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test025_proceedInAround3() {
      runTest("proceed used as method name in around advice (3)");
  }
================= fetch public void test029_falseInvalidAbsoluteTypeName() { 64183c3^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java
//  }
public void test029_falseInvalidAbsoluteTypeName() {
    runTest("Valid but inaccessible type names should not be flagged by XLint:invalidAbsoluteTypeName");
  }
================= fetch private Test findResidueNoEllipsis(Shadow shadow, ExposedState state, TypePatter b75cd93^:weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java

private Test findResidueNoEllipsis(Shadow shadow, ExposedState state, TypePattern[] patterns) {
		int len = shadow.getArgCount();
		//System.err.println("boudn to : " + len + ", " + patterns.length);
		if (patterns.length != len) {
			return Literal.FALSE;
		}
		
		Test ret = Literal.TRUE;
		
		for (int i=0; i < len; i++) {
			TypeX argType = shadow.getArgType(i);
			TypePattern type = patterns[i];
			if (!(type instanceof BindingTypePattern)) {
				if (type.matchesInstanceof(shadow.getIWorld().resolve(argType)).alwaysTrue()) {
					continue;
				}
			} else {
			  BindingTypePattern btp = (BindingTypePattern)type;
			  // Check if we have already bound something to this formal
			  if (state.get(btp.getFormalIndex())!=null) {
			  	ISourceLocation isl = getSourceLocation();
				Message errorMessage = new Message(
                    "Ambiguous binding of type "+type.getExactType().toString()+
                    " using args(..) at this line.  Use one args(..) per matched join point,"+"" +
                    " see secondary source location for location of extraneous args(..)",					shadow.getSourceLocation(),true,new ISourceLocation[]{getSourceLocation()});
				shadow.getIWorld().getMessageHandler().handleMessage(errorMessage);
			  }
			}
			ret = Test.makeAnd(ret,
				exposeStateForVar(shadow.getArgVar(i), type, state,shadow.getIWorld()));
		}
		
		return ret;		
	}
================= fetch public ExposedState(int size) { b75cd93^:weaver/src/org/aspectj/weaver/patterns/ExposedState.java

================= fetch public InstructionList getAdviceArgSetup( b75cd93^:weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java

public InstructionList getAdviceArgSetup(
		BcelShadow shadow,
		BcelVar extraVar,
		InstructionList closureInstantiation) 
	{
        InstructionFactory fact = shadow.getFactory();
        BcelWorld world = shadow.getWorld();
        InstructionList il = new InstructionList();

//        if (targetAspectField != null) {
//        	il.append(fact.createFieldAccess(
//        		targetAspectField.getDeclaringType().getName(),
//        		targetAspectField.getName(),
//        		BcelWorld.makeBcelType(targetAspectField.getType()),
//        		Constants.GETSTATIC));
//        }
//        
		//System.err.println("BcelAdvice: " + exposedState);


		if (exposedState.getAspectInstance() != null) {
			il.append(
				BcelRenderer.renderExpr(fact, world, exposedState.getAspectInstance()));
		}
        for (int i = 0, len = exposedState.size(); i < len; i++) {
            BcelVar v = (BcelVar) exposedState.get(i);
            if (v == null) continue;
            TypeX desiredTy = getSignature().getParameterTypes()[i];
            v.appendLoadAndConvert(il, fact, desiredTy.resolve(world));
        }

        
		if (getKind() == AdviceKind.Around) {
			il.append(closureInstantiation);
		} else if (hasExtraParameter()) {
			extraVar.appendLoadAndConvert(
				il,
				fact,
				getExtraParameterType().resolve(world));
		}
        
        // handle thisJoinPoint parameters
        // these need to be in that same order as parameters in 
        // org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration
        if ((getExtraParameterFlags() & ThisJoinPointStaticPart) != 0) {
        	shadow.getThisJoinPointStaticPartBcelVar().appendLoad(il, fact);
        }
        
        if ((getExtraParameterFlags() & ThisJoinPoint) != 0) {
        	il.append(shadow.loadThisJoinPoint());
        }
        

        if ((getExtraParameterFlags() & ThisEnclosingJoinPointStaticPart) != 0) {
        	shadow.getThisEnclosingJoinPointStaticPartBcelVar().appendLoad(il, fact);
        }
        
        
        return il;
    }
================= fetch public String toString() { b75cd93^:weaver/src/org/aspectj/weaver/patterns/ExposedState.java

public String toString() {
		return "ExposedState(" + Arrays.asList(vars) + ", " + aspectInstance + ")";
	}
================= fetch public Test findResidue(Shadow shadow, ExposedState state) { b75cd93^:weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java

public Test findResidue(Shadow shadow, ExposedState state) {
		if (!couldMatch(shadow)) return Literal.FALSE;
		
		if (type == TypePattern.ANY) return Literal.TRUE;
		
		Var var = isThis ? shadow.getThisVar() : shadow.getTargetVar();
		return exposeStateForVar(var, type, state, shadow.getIWorld());
	}
================= fetch public void set(int i, Var var) { b75cd93^:weaver/src/org/aspectj/weaver/patterns/ExposedState.java

public void set(int i, Var var) {
		//XXX add sanity checks
		// Check (1) added to call of set(), verifies we aren't binding twice to the same formal
		vars[i] = var;
	}
================= fetch public void test025_proceedInAround3() { b75cd93^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test025_proceedInAround3() {
      runTest("proceed used as method name in around advice (3)");
  }
================= fetch private AdviceDeclaration findEnclosingAround(Scope scope) { 05dabd1^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/Proceed.java

private AdviceDeclaration findEnclosingAround(Scope scope) {
		if (scope == null) return null;
		
		if (scope instanceof MethodScope) {
			MethodScope methodScope = (MethodScope)scope;
			ReferenceContext context = methodScope.referenceContext;
			if (context instanceof AdviceDeclaration) {
				AdviceDeclaration adviceDecl = (AdviceDeclaration)context;
				if (adviceDecl.kind == AdviceKind.Around) {
					adviceDecl.proceedCalls.add(this);
					return adviceDecl;
				} else {
					return null;
				}
			}
		} else if (scope instanceof ClassScope) {
			inInner = true;
		}
		
		return findEnclosingAround(scope.parent);
	}
================= fetch public void test019_PrivateFieldGetsInAroundAdvice() { 05dabd1^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test019_PrivateFieldGetsInAroundAdvice() {
    runTest("Cannot advise private field gets in around advice");
    System.err.println(getLastRunResult().getStdErr());
  }
================= fetch private void writeBack(BcelWorld world) { 44a92e1^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java

private void writeBack(BcelWorld world) {
    	if (myType != null && myType.getWeaverState() != null) {
			myGen.addAttribute(BcelAttributes.bcelAttribute(
				new AjAttribute.WeaverState(myType.getWeaverState()), 
				getConstantPoolGen()));
    	}
    	
    	addAjcInitializers();
    	
        int len = methodGens.size();
        myGen.setMethods(new Method[0]);
        
        calculateSourceDebugExtensionOffsets();
        for (int i = 0; i < len; i++) {
            LazyMethodGen gen = (LazyMethodGen) methodGens.get(i);
            // we skip empty clinits
            if (isEmptyClinit(gen)) continue;
            myGen.addMethod(gen.getMethod());
        }
		if (inlinedFiles.size() != 0) {
			if (hasSourceDebugExtensionAttribute(myGen)) {
				world.showMessage(
					IMessage.WARNING,
					WeaverMessages.format(WeaverMessages.OVERWRITE_JSR45,getFileName()),
					null,
					null);
			}
			myGen.addAttribute(getSourceDebugExtensionAttribute());
		}
    }
================= fetch public void test019_PrivateFieldGetsInAroundAdvice() { 44a92e1^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test019_PrivateFieldGetsInAroundAdvice() {
    runTest("Cannot advise private field gets in around advice");
    System.err.println(getLastRunResult().getStdErr());
  }
Progress : [###################################-----] 89%================= fetch public JoinPointImpl(org.aspectj.lang.JoinPoint.StaticPart staticPart, Object _t f6436e3^:runtime/src/org/aspectj/runtime/reflect/JoinPointImpl.java

public final String toLongString() { return staticPart.toLongString(); }
================= fetch public static TestSuite suite() { f6436e3^:runtime/testsrc/RuntimeModuleTests.java

public static TestSuite suite() { 
        TestSuite suite = new TestSuite(RuntimeModuleTests.class.getName());
        suite.addTestSuite(RuntimeModuleTests.class); // minimum 1 test (testNothing)
        suite.addTestSuite(SignatureTest.class);
        return suite;
    }
================= fetch private void generateInlineAccessMethod(ClassFile classFile, final MethodBinding 851da68^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java

void generateInlineAccessMethod(ClassFile classFile, final MethodBinding accessMethod, final ResolvedMember method) {
		generateMethod(classFile, accessMethod, 
		new BodyGenerator() {
================= fetch private void generateInlineAccessors(ClassFile classFile, final InlineAccessFiel 851da68^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java

private void generateInlineAccessors(ClassFile classFile, final InlineAccessFieldBinding accessField, final ResolvedMember field) {
		final FieldBinding fieldBinding = factory.makeFieldBinding(field);
		generateMethod(classFile, accessField.reader, 
		new BodyGenerator() {
================= fetch private void generateMethod(ClassFile classFile, MethodBinding methodBinding, Bo 851da68^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java

private void generateMethod(ClassFile classFile, MethodBinding methodBinding, BodyGenerator gen) {
//		EclipseFactory world = EclipseFactory.fromScopeLookupEnvironment(this.scope);
		classFile.generateMethodInfoHeader(methodBinding);
		int methodAttributeOffset = classFile.contentsOffset;
		int attributeNumber = classFile.generateMethodInfoAttribute(methodBinding, AstUtil.getAjSyntheticAttribute());
		int codeAttributeOffset = classFile.contentsOffset;
		classFile.generateCodeAttributeHeader();
		CodeStream codeStream = classFile.codeStream;
		
		// Use reset() rather than init()
		// XXX We need a scope to keep reset happy, initializerScope is *not* the right one, but it works !
//		 codeStream.init(classFile);
//		 codeStream.initializeMaxLocals(methodBinding);
		MethodDeclaration md = AstUtil.makeMethodDeclaration(methodBinding);
		md.scope = initializerScope;
		codeStream.reset(md,classFile);
		
		// body starts here
		gen.generate(codeStream);
		// body ends here
		classFile.completeCodeAttribute(codeAttributeOffset);
		attributeNumber++;
		classFile.completeMethodInfo(methodAttributeOffset, attributeNumber);
	}
================= fetch public Field getTjpField(BcelShadow shadow) { 851da68^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java

public Field getTjpField(BcelShadow shadow) {
    	Field ret = (Field)tjpFields.get(shadow);
    	if (ret != null) return ret;
    	
		int modifiers = Modifier.STATIC | Modifier.FINAL;
		if (getType().isInterface()) {
			modifiers |= Modifier.PUBLIC;
		}
		else {
			modifiers |= Modifier.PRIVATE;
		}
		ret = new FieldGen(modifiers,
    		staticTjpType,
    		"ajc$tjp_" + tjpFields.size(),
    		getConstantPoolGen()).getField();
    	addField(ret);
    	tjpFields.put(shadow, ret);
    	return ret;
    }
================= fetch public void generate(CodeStream codeStream) { 851da68^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java

private PerClause.Kind lookupPerClauseKind(ReferenceBinding binding) {
        PerClause perClause;
        if (binding instanceof BinaryTypeBinding) {
            ResolvedTypeX superTypeX = factory.fromEclipse(binding);
            perClause = superTypeX.getPerClause();
        } else if (binding instanceof SourceTypeBinding ) {
			SourceTypeBinding sourceSc = (SourceTypeBinding)binding;
			if (sourceSc.scope.referenceContext instanceof AspectDeclaration) {
				perClause = ((AspectDeclaration)sourceSc.scope.referenceContext).perClause;
			} else {
				return null;
			}
		} else {
			//XXX need to handle this too
			return null;
		}
        if (perClause == null) {
            return lookupPerClauseKind(binding.superclass()); 
        } else {
            return perClause.getKind();
	    }
    }
================= fetch public void test001(){ 851da68^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test001(){
    runTest("false ambigous binding error (introduced in 1.2rc2)");
  }
================= fetch public void test016_ByteConversionInstructions() { 851da68^:tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java

public void test016_ByteConversionInstructions() {
  	runTest("RuntimeException thrown: Could not find instruction: org.apache.bcel.generic.B2I");
  	String output = getLastRunResult().getStdErr();
  	assertTrue("Expected to find [b2] in this output but didn't:"+output,output.indexOf("[b2]")!=-1);
  	assertTrue("Expected to find [b127] in this output but didn't:"+output,output.indexOf("[b127]")!=-1);
  	assertTrue("Expected to find [b0] in this output but didn't:"+output,output.indexOf("[b0]")!=-1);

  	assertTrue("Expected to find [c65] in this output but didn't:"+output,output.indexOf("[c65]")!=-1);
  	assertTrue("Expected to find [c66] in this output but didn't:"+output,output.indexOf("[c66]")!=-1);
  	assertTrue("Expected to find [c67] in this output but didn't:"+output,output.indexOf("[c67]")!=-1);

  	assertTrue("Expected to find [s1] in this output but didn't:"+output,output.indexOf("[s1]")!=-1);
  	assertTrue("Expected to find [s32767] in this output but didn't:"+output,output.indexOf("[s32767]")!=-1);
  	assertTrue("Expected to find [b0] in this output but didn't:"+output,output.indexOf("[b0]")!=-1);
  }
================= fetch InstructionList createThisJoinPoint() { 061395c^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

InstructionList createThisJoinPoint() {
		InstructionFactory fact = getFactory();
		InstructionList il = new InstructionList();
		
		BcelVar staticPart = getThisJoinPointStaticPartBcelVar();
		staticPart.appendLoad(il, fact);
		if (hasThis()) {
			((BcelVar)getThisVar()).appendLoad(il, fact);
		} else {
			il.append(new ACONST_NULL());
		}
		if (hasTarget()) {
			((BcelVar)getTargetVar()).appendLoad(il, fact);
		} else {
			il.append(new ACONST_NULL());
		}
		
		switch(getArgCount()) {
			case 0:
				il.append(fact.createInvoke("org.aspectj.runtime.reflect.Factory", 
									"makeJP", LazyClassGen.tjpType,
									new Type[] { LazyClassGen.staticTjpType,
											Type.OBJECT, Type.OBJECT},
									Constants.INVOKESTATIC));
				break;
			case 1:
				((BcelVar)getArgVar(0)).appendLoadAndConvert(il, fact, world.resolve(ResolvedTypeX.OBJECT));
				il.append(fact.createInvoke("org.aspectj.runtime.reflect.Factory", 
									"makeJP", LazyClassGen.tjpType,
									new Type[] { LazyClassGen.staticTjpType,
											Type.OBJECT, Type.OBJECT, Type.OBJECT},
									Constants.INVOKESTATIC));
				break;
			case 2:
				((BcelVar)getArgVar(0)).appendLoadAndConvert(il, fact, world.resolve(ResolvedTypeX.OBJECT));
				((BcelVar)getArgVar(1)).appendLoadAndConvert(il, fact, world.resolve(ResolvedTypeX.OBJECT));
				il.append(fact.createInvoke("org.aspectj.runtime.reflect.Factory", 
									"makeJP", LazyClassGen.tjpType,
									new Type[] { LazyClassGen.staticTjpType,
											Type.OBJECT, Type.OBJECT, Type.OBJECT, Type.OBJECT},
									Constants.INVOKESTATIC));
				break;
			default:
				il.append(makeArgsObjectArray());
				il.append(fact.createInvoke("org.aspectj.runtime.reflect.Factory", 
									"makeJP", LazyClassGen.tjpType,
									new Type[] { LazyClassGen.staticTjpType,
											Type.OBJECT, Type.OBJECT, new ArrayType(Type.OBJECT, 1)},
									Constants.INVOKESTATIC));
				break;
		}
		
		return il;
	}
================= fetch private Collection collectCheckedExceptions(TypeX[] excs) { 061395c^:weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java
// ---- implementations
private Collection collectCheckedExceptions(TypeX[] excs) {
		if (excs == null || excs.length == 0) return Collections.EMPTY_LIST;
		
		Collection ret = new ArrayList();
		World world = concreteAspect.getWorld();
		ResolvedTypeX runtimeException = world.resolve(TypeX.RUNTIME_EXCEPTION);
		ResolvedTypeX error = world.resolve(TypeX.ERROR);
		
		for (int i=0, len=excs.length; i < len; i++) {
			ResolvedTypeX t = world.resolve(excs[i]);
			if (!(runtimeException.isAssignableFrom(t) || error.isAssignableFrom(t))) {
				ret.add(t);
			}
		}
			
		return ret;
	}
================= fetch private ResolvedTypeX maybeGetNewParent(ResolvedTypeX targetType, TypePattern ty 061395c^:weaver/src/org/aspectj/weaver/patterns/DeclareParents.java

public List/*<ResolvedTypeX>*/ findMatchingNewParents(ResolvedTypeX onType) {
		if (!match(onType)) return Collections.EMPTY_LIST;
		
		List ret = new ArrayList();
		for (int i=0; i < parents.size(); i++) {
			ResolvedTypeX t = maybeGetNewParent(onType, parents.get(i), onType.getWorld());
			if (t != null) ret.add(t);
		}
		
		return ret;
	}
================= fetch private void addPreInitializationReturnCode( 061395c^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

private Type[] getSuperConstructorParameterTypes() {
		// assert getKind() == PreInitialization	
		InstructionHandle superCallHandle = getRange().getEnd().getNext();
		InvokeInstruction superCallInstruction = 
			(InvokeInstruction) superCallHandle.getInstruction();
		return superCallInstruction.getArgumentTypes(
			getEnclosingClass().getConstantPoolGen());
	}
================= fetch public BcelVar getThisJoinPointStaticPartBcelVar() { 061395c^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public BcelVar getThisJoinPointStaticPartBcelVar() {
    	if (thisJoinPointStaticPartVar == null) {
    		Field field = getEnclosingClass().getTjpField(this);
    		thisJoinPointStaticPartVar =
    			new BcelFieldRef(
    				world.resolve(TypeX.forName("org.aspectj.lang.JoinPoint$StaticPart")),
    				getEnclosingClass().getClassName(),
    				field.getName());
//    		getEnclosingClass().warnOnAddedStaticInitializer(this,munger.getSourceLocation());
    	}
    	return thisJoinPointStaticPartVar;
    }
================= fetch public ResolvedTypeX getSuperclass() { 061395c^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java

public ResolvedTypeX[] getDeclaredInterfaces() {
		return eclipseWorld().fromEclipse(binding.superInterfaces());
	}
================= fetch public boolean canBeSeenBy( 061395c^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java

public void checkSpec(ClassScope scope) {
		if (ignoreFurtherInvestigation) return;
		if (dominatesPattern != null) {
			scope.problemReporter().signalError(
					dominatesPattern.getStart(), dominatesPattern.getEnd(), 
					"dominates has changed for 1.1, use 'declare precedence: " +
					new String(this.name) + ", " + dominatesPattern.toString() + ";' " +
					"in the body of the aspect instead");
		}
		
		if (!isAbstract()) {
			MethodBinding[] methods = binding.methods();
			for (int i=0, len = methods.length; i < len; i++) {
				MethodBinding m = methods[i];
				if (m.isConstructor()) {
					// this make all constructors in aspects invisible and thus uncallable
					//XXX this only works for aspects that come from source
					methods[i] = new MethodBinding(m, binding) {
						public boolean canBeSeenBy(
							InvocationSite invocationSite,
							Scope scope) {
							return false;
						}
					};
					
					if (m.parameters != null && m.parameters.length != 0) {
						scope.problemReporter().signalError(m.sourceStart(), m.sourceEnd(),
								"only zero-argument constructors allowed in concrete aspect");
					}
				}
			}
		}
		
		if (this.enclosingType != null) {
			if (!Modifier.isStatic(modifiers)) {
				scope.problemReporter().signalError(sourceStart, sourceEnd,
								"inner aspects must be static");
				ignoreFurtherInvestigation = true;
			    return;
			}
		}
		
		
		EclipseFactory world = EclipseFactory.fromScopeLookupEnvironment(scope);
		ResolvedTypeX myType = typeX;
		//if (myType == null) System.err.println("bad myType for: " + this);
		ResolvedTypeX superType = myType.getSuperclass();		
		
		// can't be Serializable/Cloneable unless -XserializableAspects
		if (!world.isXSerializableAspects()) {
			if (world.getWorld().resolve(TypeX.SERIALIZABLE).isAssignableFrom(myType)) {
				scope.problemReporter().signalError(sourceStart, sourceEnd,
								"aspects may not implement Serializable");
				ignoreFurtherInvestigation = true;
			    return;
			}
			if (world.getWorld().resolve(TypeX.CLONEABLE).isAssignableFrom(myType)) {
				scope.problemReporter().signalError(sourceStart, sourceEnd,
								"aspects may not implement Cloneable");
				ignoreFurtherInvestigation = true;
			    return;
			}

		}

		if (superType.isAspect()) {
			if (!superType.isAbstract()) {
				scope.problemReporter().signalError(sourceStart, sourceEnd,
								"can not extend a concrete aspect");
				ignoreFurtherInvestigation = true;
				return;
			}
		}
	}
================= fetch public boolean isExposedToWeaver() { 061395c^:weaver/src/org/aspectj/weaver/ResolvedTypeX.java

public boolean isExposedToWeaver() { return false; }
================= fetch public final ResolvedTypeX getSuperclass() { 061395c^:weaver/src/org/aspectj/weaver/ResolvedTypeX.java

public ResolvedTypeX.Name getResolvedTypeX() {
			return resolvedTypeX;
		}
================= fetch public void addInterTypeMunger(ConcreteTypeMunger munger) { 061395c^:weaver/src/org/aspectj/weaver/ResolvedTypeX.java

public void addInterTypeMunger(ConcreteTypeMunger munger) {
		ResolvedMember sig = munger.getSignature();
		if (sig == null || munger.getMunger() == null || 
				munger.getMunger().getKind() == ResolvedTypeMunger.PrivilegedAccess)
		{
			interTypeMungers.add(munger);
			return;
		}
		
		//System.err.println("add: " + munger + " to " + this.getClassName() + " with " + interTypeMungers);
		if (sig.getKind() == Member.METHOD) {
			if (!compareToExistingMembers(munger, getMethods())) return;
			if (this.isInterface()) {
				if (!compareToExistingMembers(munger, 
						Arrays.asList(world.resolve(OBJECT).getDeclaredMethods()).iterator())) return;
			}
		} else if (sig.getKind() == Member.FIELD) {
			if (!compareToExistingMembers(munger, Arrays.asList(getDeclaredFields()).iterator())) return;
		} else {
			if (!compareToExistingMembers(munger, Arrays.asList(getDeclaredMethods()).iterator())) return;
		}

		
		// now compare to existingMungers
		for (Iterator i = interTypeMungers.iterator(); i.hasNext(); ) {
			ConcreteTypeMunger existingMunger = (ConcreteTypeMunger)i.next();
			if (conflictingSignature(existingMunger.getSignature(), munger.getSignature())) {
				//System.err.println("match " + munger + " with " + existingMunger);
				if (isVisible(munger.getSignature().getModifiers(),
							munger.getAspectType(), existingMunger.getAspectType()))
				{
					//System.err.println("    is visible");
					int c = compareMemberPrecedence(sig, existingMunger.getSignature());
					if (c == 0) {
						c = getWorld().comparePrecedence(munger.getAspectType(), existingMunger.getAspectType());
					}
					//System.err.println("       compare: " + c);
					if (c < 0) {
						// the existing munger dominates the new munger
						checkLegalOverride(munger.getSignature(), existingMunger.getSignature());
						return;
					} else if (c > 0) {
						// the new munger dominates the existing one
						checkLegalOverride(existingMunger.getSignature(), munger.getSignature());
						i.remove();
						break;
					} else {
						interTypeConflictError(munger, existingMunger);
						interTypeConflictError(existingMunger, munger);
						return;
					}					
				}
			}
		}
		//System.err.println("adding: " + munger + " to " + this);
		interTypeMungers.add(munger);
	}
================= fetch public void resolve(IScope scope) { 061395c^:weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java

public void resolve(IScope scope) {
    	exception = exception.resolveBindings(scope, null, false, true);
    	TypeX excType = exception.getExactType();
    	if (excType != ResolvedTypeX.MISSING) {
    		if (!scope.getWorld().resolve(TypeX.THROWABLE).isAssignableFrom(excType)) {
    			scope.getWorld().showMessage(IMessage.ERROR,
    					WeaverMessages.format(WeaverMessages.NOT_THROWABLE,excType.getName()),
    					exception.getSourceLocation(), null);
    			pointcut = Pointcut.makeMatchesNothing(Pointcut.RESOLVED);
    			return;
    		}
    	}
    	
    	pointcut = pointcut.resolve(scope); 	
    }
================= fetch private AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler) { 648c0f4^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java

private AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler) {
		return new BuildArgParser(handler).genBuildConfig(args);
	}
================= fetch public File makeFile(String name) { 648c0f4^:util/src/org/aspectj/util/ConfigParser.java

public File makeFile(String name) {
        return makeFile(getCurrentDir(), name);
    }
================= fetch public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r 648c0f4^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java
/**
         * Extract AspectJ-specific options (except for argfiles).
         * Caller should warn when sourceroots is empty but in 
         * incremental mode.
         * Signals warnings or errors through handler set in constructor.
         */
public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.remove()
			int nextArgIndex = args.indexOf(arg)+1; // XXX assumes unique
            // trim arg?
            if (LangUtil.isEmpty(arg)) {
                showWarning("empty arg found");
            } else if (arg.equals("-inpath")) {;
            	if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_Inpath, CompilerOptions.PRESERVE);
					
					List inPath = buildConfig.getInpath();
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
					while (st.hasMoreTokens()) {
						String filename = st.nextToken();
						File file = makeFile(filename);
						if (file.exists() && FileUtil.hasZipSuffix(filename)) {
							inPath.add(file);    
						} else {
							if (file.isDirectory()) {
								inPath.add(file);
							} else 
		            		
							showError("bad inpath component: " + filename);  
						}
					}
					buildConfig.setInPath(inPath);
					args.remove(args.get(nextArgIndex));            		
            	}
            } else if (arg.equals("-injars")) {;
				if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_InJARs, CompilerOptions.PRESERVE);
					
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
		            	if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
			            	buildConfig.getInJars().add(jarFile);    
		            	} else {
		            		File dirFile = makeFile(filename);
		            		if (dirFile.isDirectory()) {
		            			buildConfig.getInJars().add(dirFile);
		            		} else 
		            		
                            showError("bad injar: " + filename);  
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-aspectpath")) {;
				if (args.size() > nextArgIndex) {
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
                        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
			            	buildConfig.getAspectpath().add(jarFile);    
		            	} else {
                            showError("bad aspectpath: " + filename);
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-sourceroots")) {
				if (args.size() > nextArgIndex) {
					List sourceRoots = new ArrayList();
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	File f = makeFile(st.nextToken());
		            	if (f.isDirectory() && f.canRead()) {
			                sourceRoots.add(f);
		            	} else {
                            showError("bad sourceroot: " + f);
		            	}		            		
		            }
				    if (0 < sourceRoots.size()) {
						buildConfig.setSourceRoots(sourceRoots);	
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-sourceroots requires list of directories");
				}
			} else if (arg.equals("-outjar")) { 
				if (args.size() > nextArgIndex) {
//					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_OutJAR, CompilerOptions.GENERATE);
					File jarFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
					if (FileUtil.hasZipSuffix(jarFile)) {
						try {
							if (!jarFile.exists()) {
                                jarFile.createNewFile();
                            }
                            buildConfig.setOutputJar(jarFile);  
						} catch (IOException ioe) { 
                            showError("unable to create outjar file: " + jarFile);
						}
					} else {
						showError("invalid -outjar file: " + jarFile);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-outjar requires jar path argument");
				}
            } else if (arg.equals("-incremental")) {
                buildConfig.setIncrementalMode(true);
            } else if (arg.equals("-XincrementalFile")) {
                if (args.size() > nextArgIndex) {
                    File file = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    buildConfig.setIncrementalFile(file);
                    if (!file.canRead()) {
                        showError("bad -XincrementalFile : " + file);
                        // if not created before recompile test, stop after first compile
                    }
                    args.remove(args.get(nextArgIndex));
                } else {
                    showError("-XincrementalFile requires file argument");
                }
			} else if (arg.equals("-emacssym")) {
				buildConfig.setEmacsSymMode(true);
				buildConfig.setGenerateModelMode(true);
			} else if (arg.equals("-XjavadocsInModel")) {
				buildConfig.setGenerateModelMode(true);
				buildConfig.setGenerateJavadocsInModelMode(true);
			} else if (arg.equals("-noweave") || arg.equals( "-XnoWeave")) {
				buildConfig.setNoWeave(true);
			} else if (arg.equals("-XserializableAspects")) {
				buildConfig.setXserializableAspects(true);
			} else if (arg.equals("-XlazyTjp")) {
				buildConfig.setXlazyTjp(true);
            } else if (arg.startsWith("-Xreweavable")) {
            	buildConfig.setXreweavable(true);
            	if (arg.endsWith(":compress")) {
            		buildConfig.setXreweavableCompressClasses(true);
            	}
			} else if (arg.equals("-XnoInline")) {
				buildConfig.setXnoInline(true);
            } else if (arg.startsWith("-showWeaveInfo")) {
            	 buildConfig.setShowWeavingInformation(true);
			} else if (arg.equals("-Xlintfile")) { 
				if (args.size() > nextArgIndex) {
					File lintSpecFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    // XXX relax restriction on props file suffix?
					if (lintSpecFile.canRead() && lintSpecFile.getName().endsWith(".properties")) {
						buildConfig.setLintSpecFile(lintSpecFile);	
					} else {
						showError("bad -Xlintfile file: " + lintSpecFile);
						buildConfig.setLintSpecFile(null);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-Xlintfile requires .properties file argument");
				}
            } else if (arg.equals("-Xlint")) {
//                buildConfig.getAjOptions().put(
//                    AjCompilerOptions.OPTION_Xlint,
//                    CompilerOptions.GENERATE);
                buildConfig.setLintMode(AjBuildConfig.AJLINT_DEFAULT);
            } else if (arg.startsWith("-Xlint:")) {
                if (7 < arg.length()) {
                    buildConfig.setLintMode(arg.substring(7));
                } else {
                    showError("invalid lint option " + arg);
                }
			} else if (arg.equals("-bootclasspath")) {
				if (args.size() > nextArgIndex) {
					bootclasspath = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-bootclasspath requires classpath entries");
				}
			} else if (arg.equals("-classpath")) {
				if (args.size() > nextArgIndex) {
					classpath = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-classpath requires classpath entries");
				}
			} else if (arg.equals("-extdirs")) {
				if (args.size() > nextArgIndex) {
					extdirs = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					args.remove(args.get(nextArgIndex));
                } else {
                    showError("-extdirs requires list of external directories");
                }
            // error on directory unless -d, -{boot}classpath, or -extdirs
            } else if (arg.equals("-d")) {
                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-classpath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-bootclasspath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-extdirs")) {
//                dirLookahead(arg, args, nextArgIndex);
            } else if (new File(arg).isDirectory()) {
                showError("dir arg not permitted: " + arg);
			} else {
                // argfile, @file parsed by superclass
                // no eclipse options parsed:
                // -d args, -help (handled), 
                // -classpath, -target, -1.3, -1.4, -source [1.3|1.4]
                // -nowarn, -warn:[...], -deprecation, -noImportError,
                // -proceedOnError, -g:[...], -preserveAllLocals,
                // -referenceInfo, -encoding, -verbose, -log, -time
                // -noExit, -repeat
		    	unparsedArgs.add(arg);
			}
        }
================= fetch public void testBootclasspath() throws InvalidInputException { 648c0f4^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java

public void testBootclasspath() throws InvalidInputException {
		final String PATH = "mumble/rt.jar";
		AjBuildConfig config = genBuildConfig(new String[] { 
			"-bootclasspath", PATH }, 
			messageWriter);		
		assertTrue(config.getClasspath().toString(), config.getClasspath().get(0).equals(PATH)); 

		config = genBuildConfig(new String[] { 
			}, 
			messageWriter);		
		assertTrue(config.getClasspath().toString(), !config.getClasspath().get(0).equals(PATH)); 
	}
================= fetch public void testClasspathSetting() throws InvalidInputException { 648c0f4^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java

public void testClasspathSetting() throws InvalidInputException {
		String ENTRY = "1.jar" + File.pathSeparator + "2.jar";
		AjBuildConfig config = genBuildConfig(new String[] {  "-classpath", ENTRY }, messageWriter);
		
		assertTrue(
			config.getClasspath().toString(),
			config.getClasspath().contains("1.jar"));

		assertTrue(
			config.getClasspath().toString(),
			config.getClasspath().contains("2.jar"));
	}
================= fetch public void testDefaultClasspathAndTargetCombo() throws InvalidInputException { 648c0f4^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java

public void testDefaultClasspathAndTargetCombo() throws InvalidInputException {
		String ENTRY = "1.jar" + File.pathSeparator + "2.jar";
		final String classpath = System.getProperty("java.class.path");
		try {
            System.setProperty("java.class.path", ENTRY); // see finally below
            BuildArgParser parser = new BuildArgParser(messageWriter);
    		AjBuildConfig config = parser.genBuildConfig(new String[] { });
            /*String err = */parser.getOtherMessages(true);       
            //!!!assertTrue(err, null == err);
            assertTrue(
    			config.getClasspath().toString(),
    			config.getClasspath().contains("1.jar"));
    		assertTrue(
    			config.getClasspath().toString(),
    			config.getClasspath().contains("2.jar"));
    
    		config = genBuildConfig(new String[] { "-1.3" }, messageWriter);
    		// these errors are deffered to the compiler now
            //err = parser.getOtherMessages(true);       
            //!!!assertTrue(err, null == err);
    		assertTrue(
    			config.getClasspath().toString(),
    			config.getClasspath().contains("1.jar"));
    		assertTrue(
    			config.getClasspath().toString(),
    			config.getClasspath().contains("2.jar"));
    
			parser = new BuildArgParser(messageWriter);
    		config = parser.genBuildConfig(new String[] { "-1.3" });
            /*err = */parser.getOtherMessages(true);       
            //!!!assertTrue(err, null == err);
    		assertTrue(
    			config.getClasspath().toString(),
    			config.getClasspath().contains("1.jar"));
    		assertTrue(
    			config.getClasspath().toString(),
    			config.getClasspath().contains("2.jar"));
    			
    		config = genBuildConfig(new String[] { 
    			"-classpath", ENTRY, "-1.4" }, messageWriter);
			//			these errors are deffered to the compiler now
            //err = parser.getOtherMessages(true);       
            //assertTrue("expected errors for missing jars", null != err);
    		assertTrue(
    			config.getClasspath().toString(),
    			config.getClasspath().contains("1.jar"));
    		assertTrue(
    			config.getClasspath().toString(),
    			config.getClasspath().contains("2.jar"));
    			
        } finally {
            // do finally to avoid messing up classpath for other tests
            System.setProperty("java.class.path", classpath);
            String setPath = System.getProperty("java.class.path");
            String m = "other tests will fail - classpath not reset";
            assertEquals(m, classpath, setPath); 
        }
	}
================= fetch public void testExtDirs() throws InvalidInputException { 648c0f4^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java

public void testExtDirs() throws InvalidInputException {
		final String DIR = AjdtAjcTests.TESTDATA_PATH;
		AjBuildConfig config = genBuildConfig(new String[] { 
			"-extdirs", DIR }, 
			messageWriter);
		assertTrue(config.getClasspath().toString(), config.getClasspath().contains(
			new File(DIR + File.separator + "testclasses.jar").getAbsolutePath()
		));
	}
================= fetch public void testSourceRootDirWithFiles() throws InvalidInputException, IOExcepti 648c0f4^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java
//??? we've decided not to make this an error
public void testSourceRootDirWithFiles() throws InvalidInputException, IOException {
		final String SRCROOT = AjdtAjcTests.TESTDATA_PATH + "/ajc/pkg";
		AjBuildConfig config = genBuildConfig(new String[] { 
			"-sourceroots", SRCROOT,  AjdtAjcTests.TESTDATA_PATH + "/src1/A.java"}, 
			messageWriter);

		assertEquals(getCanonicalPath(new File(SRCROOT)), ((File)config.getSourceRoots().get(0)).getAbsolutePath());
		
		Collection expectedFiles = Arrays.asList(new File[] {
			new File(SRCROOT+File.separator+"Hello.java").getCanonicalFile(),
			new File(AjdtAjcTests.TESTDATA_PATH +File.separator+"src1"+File.separator+"A.java").getCanonicalFile(),
		});

		TestUtil.assertSetEquals(expectedFiles, config.getFiles());
		
	}
================= fetch private void warnOnConfusingSig(Shadow shadow) { ef7885f^:weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java

private void warnOnConfusingSig(Shadow shadow) {
        // no warnings for declare error/warning
        if (munger instanceof Checker) return;
        
        World world = shadow.getIWorld();
        
		// warning never needed if the declaring type is any
		TypeX exactDeclaringType = signature.getDeclaringType().getExactType();
        
		ResolvedTypeX shadowDeclaringType =
			shadow.getSignature().getDeclaringType().resolve(world);
        
		if (signature.getDeclaringType().isStar()
			|| exactDeclaringType== ResolvedTypeX.MISSING)
			return;

        // warning not needed if match type couldn't ever be the declaring type
		if (!shadowDeclaringType.isAssignableFrom(exactDeclaringType)) {
            return;
		}

		// if the method in the declaring type is *not* visible to the
		// exact declaring type then warning not needed.
		int shadowModifiers = shadow.getSignature().getModifiers(world);
		if (!ResolvedTypeX
			.isVisible(
				shadowModifiers,
				shadowDeclaringType,
				exactDeclaringType.resolve(world))) {
			return;
		}

		SignaturePattern nonConfusingPattern =
			new SignaturePattern(
				signature.getKind(),
				signature.getModifiers(),
				signature.getReturnType(),
				TypePattern.ANY,
				signature.getName(), 
				signature.getParameterTypes(),
				signature.getThrowsPattern());

		if (nonConfusingPattern
			.matches(shadow.getSignature(), shadow.getIWorld())) {
                shadow.getIWorld().getLint().unmatchedSuperTypeInCall.signal(
                    new String[] {
                        shadow.getSignature().getDeclaringType().toString(),
                        signature.getDeclaringType().toString()
                    },
                    this.getSourceLocation(),
                    new ISourceLocation[] {shadow.getSourceLocation()} );               
		}
	}
================= fetch private boolean acceptResource(String resourceName) { 2b8fa31^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private boolean acceptResource(String resourceName) {
		if (  
				(resourceName.startsWith("CVS/")) ||
				(resourceName.indexOf("/CVS/") != -1) ||
				(resourceName.endsWith("/CVS")) ||
				(resourceName.endsWith(".class")) 
		    )
		{
			return false;
		} else {
			return true;
		}
	}
================= fetch private void copyResourcesFromJarFile(File jarFile) throws IOException { 2b8fa31^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void copyResourcesFromJarFile(File jarFile) throws IOException {
		JarInputStream inStream = null;
		try {
			inStream = new JarInputStream(new FileInputStream(jarFile));
			while (true) {
				ZipEntry entry = inStream.getNextEntry();
				if (entry == null) break;
			
				String filename = entry.getName();
	
				if (!entry.isDirectory() && acceptResource(filename)) {
					byte[] bytes = FileUtil.readAsByteArray(inStream);
					writeResource(filename,bytes,jarFile);
				}
	
				inStream.closeEntry();
			}
		} finally {
			if (inStream != null) inStream.close();
		}
	}
================= fetch public List addJarFile(File inFile, File outDir, boolean canBeDirectory){ 2b8fa31^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
/** Adds all class files in the jar
	 */
List addJarFile(File inFile, File outDir, boolean canBeDirectory){
//		System.err.println("? addJarFile(" + inFile + ", " + outDir + ")");
		List addedClassFiles = new ArrayList();
		needToReweaveWorld = true;
		JarInputStream inStream = null;
		
		try {
			// Is this a directory we are looking at?
			if (inFile.isDirectory() && canBeDirectory) {
				addedClassFiles.addAll(addDirectoryContents(inFile,outDir));
			} else {
			
				inStream = new JarInputStream(new FileInputStream(inFile)); //??? buffered
				addManifest(inStream.getManifest());
			
				while (true) {
					ZipEntry entry = inStream.getNextEntry();
					if (entry == null) break;
				
					byte[] bytes = FileUtil.readAsByteArray(inStream);
					String filename = entry.getName();
					UnwovenClassFile classFile = new UnwovenClassFile(new File(outDir, filename).getAbsolutePath(), bytes);

					if (filename.endsWith(".class")) {
						this.addClassFile(classFile);
						addedClassFiles.add(classFile);
					}
//					else if (!entry.isDirectory()) {
//
//						/* bug-44190 Copy meta-data */
//						addResource(filename,classFile);
//					}

					inStream.closeEntry();
				}
				inStream.close();
			}
		} catch (FileNotFoundException ex) {
			IMessage message = new Message(
					"Could not find input jar file " + inFile.getPath() + ", ignoring",
					new SourceLocation(inFile,0),
					false);
			world.getMessageHandler().handleMessage(message);
		} catch (IOException ex) {
			IMessage message = new Message(
					"Could not read input jar file " + inFile.getPath() + "(" + ex.getMessage() + ")",
					new SourceLocation(inFile,0),
					true);
			world.getMessageHandler().handleMessage(message);
		} finally {
			if (inStream != null) {
				try {inStream.close();}
				catch (IOException ex) {
					IMessage message = new Message(
							"Could not close input jar file " + inFile.getPath() + "(" + ex.getMessage() + ")",
							new SourceLocation(inFile,0),
							true);					
					world.getMessageHandler().handleMessage(message);					
				}
			}
		}
		
		return addedClassFiles;
	}
================= fetch public static Test suite() { 2b8fa31^:ajde/testsrc/org/aspectj/ajde/AjdeTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(AjdeTests.class.getName());
        //$JUnit-BEGIN$
        suite.addTestSuite(BuildOptionsTest.class); 
        suite.addTestSuite(BuildConfigurationTests.class);
        suite.addTestSuite(StructureModelRegressionTest.class); 
        suite.addTestSuite(StructureModelTest.class); 
        suite.addTestSuite(VersionTest.class); 
		suite.addTestSuite(CompilerMessagesTest.class);
		suite.addTestSuite(AsmDeclarationsTest.class);
		suite.addTestSuite(AsmRelationshipsTest.class);
		suite.addTestSuite(InpathTestcase.class);
		suite.addTestSuite(ReweavableTestCase.class);
		suite.addTestSuite(ResourceCopyTestCase.class);
		suite.addTestSuite(ModelPerformanceTest.class);
		suite.addTestSuite(SavedModelConsistencyTest. class);
		suite.addTestSuite(BuildCancellingTest.class);
		suite.addTestSuite(JarManifestTest.class);
		
        //$JUnit-END$
        return suite;
    }
================= fetch public static void main(String[] args) throws IOException { 2b8fa31^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java

public static void main(String[] args) throws IOException {
		makeJar0();
		makeJar1();
		makeJar1a();
		makeJar2();
		
		makeJarObviousNothing();
		makeJarHardNothing();
		
		
		makeTestJars();

		makeURLWeavingClassLoaderJars();
	}
================= fetch public static void makeURLWeavingClassLoaderJars() throws IOException { 2b8fa31^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java

public static void makeURLWeavingClassLoaderJars() throws IOException {
		List args = new ArrayList();

		/*
		 * Vanilla classes
		 */
		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../weaver/testdata/ltw-classes.jar");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWHelloWorld.java");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/ltw/LTWPackageTest.java");
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);

		/* 
		 * Woven classes
		 */
		args = new ArrayList();
		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../weaver/testdata/ltw-woven.jar");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWHelloWorld.java");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWAspect.aj");
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);

		/*
		 * Advice
		 */
		args = new ArrayList();
		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../weaver/testdata/ltw-aspects.jar");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWAspect.aj");
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);

		/*
		 * Declare warning advice
		 */
		args = new ArrayList();
		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../weaver/testdata/ltw-dwaspects.jar");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWDeclareWarning.aj");
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);

		/*
		 * Declare error advice
		 */
		args = new ArrayList();
		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../weaver/testdata/ltw-deaspects.jar");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWDeclareError.aj");
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);

		/*
		 * Around closure advice
		 */
		args = new ArrayList();
		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../weaver/testdata/ltw-acaspects.jar");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWAroundClosure.aj");
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);

		/*
		 * ITD
		 */
		args = new ArrayList();
		args.add("-Xlint:ignore"); 
		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../weaver/testdata/ltw-itdaspects.jar");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWInterfaceITD.aj");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWFieldITD.aj");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWMethodITD.aj");
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);

		/*
		 * perXXX()
		 */
		args = new ArrayList();
		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../weaver/testdata/ltw-peraspects.jar");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWPerthis.aj");
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
	}
================= fetch public void addManifest (Manifest newManifest) { 2b8fa31^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
//    }
void addManifest (Manifest newManifest) {
		if (manifest == null) {
			manifest = newManifest;
		}
	}
Progress : [####################################----] 90%================= fetch public BinaryTypeBinding createBinaryTypeFrom( 9aed31d^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java

public BinaryTypeBinding createBinaryTypeFrom(
		IBinaryType binaryType,
		PackageBinding packageBinding,
		boolean needFieldsAndMethods)
	{
		if (inBinaryTypeCreation) {
			BinaryTypeBinding ret = super.createBinaryTypeFrom(
				binaryType,
				packageBinding,
				needFieldsAndMethods);
			pendingTypesToFinish.add(ret);
			return ret;
		}
		
		
		inBinaryTypeCreation = true;
		try {
			BinaryTypeBinding ret = super.createBinaryTypeFrom(
				binaryType,
				packageBinding,
				needFieldsAndMethods);
			weaveInterTypeDeclarations(ret);
			
			return ret;
		} finally {
			inBinaryTypeCreation = false;
			if (!pendingTypesToFinish.isEmpty()) {
				for (Iterator i = pendingTypesToFinish.iterator(); i.hasNext(); ) {
					weaveInterTypeDeclarations((BinaryTypeBinding)i.next());
				}
				pendingTypesToFinish.clear();
			}
		}		
	}
================= fetch public void warnOnAddedInterface (ResolvedTypeX type, ResolvedTypeX parent) { 9aed31d^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java

public void warnOnAddedInterface (ResolvedTypeX type, ResolvedTypeX parent) {
		World world = factory.getWorld();
		ResolvedTypeX serializable = world.resolve(TypeX.SERIALIZABLE);
		if (serializable.isAssignableFrom(type)
			&& !serializable.isAssignableFrom(parent)
			&& !LazyClassGen.hasSerialVersionUIDField(type)) {
			world.getLint().needsSerialVersionUIDField.signal(
				new String[] {
					type.getName().toString(),
					"added interface " + parent.getName().toString()
				},
				null,
				null);               
		}
	}
================= fetch private ResolvedTypeX maybeGetNewParent(ResolvedTypeX targetType, TypePattern ty 4feb835^:weaver/src/org/aspectj/weaver/patterns/DeclareParents.java

public List/*<ResolvedTypeX>*/ findMatchingNewParents(ResolvedTypeX onType) {
		if (!match(onType)) return Collections.EMPTY_LIST;
		
		List ret = new ArrayList();
		for (int i=0; i < parents.size(); i++) {
			ResolvedTypeX t = maybeGetNewParent(onType, parents.get(i), onType.getWorld());
			if (t != null) ret.add(t);
		}
		
		return ret;
	}
================= fetch private boolean compareToExistingMembers(ConcreteTypeMunger munger, Iterator exi 4feb835^:weaver/src/org/aspectj/weaver/ResolvedTypeX.java
//??? returning too soon
private boolean compareToExistingMembers(ConcreteTypeMunger munger, Iterator existingMembers) {
		ResolvedMember sig = munger.getSignature();
		while (existingMembers.hasNext()) {
			ResolvedMember existingMember = (ResolvedMember)existingMembers.next();
			//System.err.println("Comparing munger: "+sig+" with member "+existingMember);
			if (conflictingSignature(existingMember, munger.getSignature())) {
				//System.err.println("conflict: existingMember=" + existingMember + "   typeMunger=" + munger);
				//System.err.println(munger.getSourceLocation() + ", " + munger.getSignature() + ", " + munger.getSignature().getSourceLocation());
				
				if (isVisible(existingMember.getModifiers(), this, munger.getAspectType())) {
					int c = compareMemberPrecedence(sig, existingMember);
					//System.err.println("   c: " + c);
					if (c < 0) {
						// existingMember dominates munger
						checkLegalOverride(munger.getSignature(), existingMember);
						return false;
					} else if (c > 0) {
						// munger dominates existingMember
						checkLegalOverride(existingMember, munger.getSignature());
						//interTypeMungers.add(munger);  
						//??? might need list of these overridden abstracts
						continue;
					} else {
						//XXX dual errors possible if (this instanceof BcelObjectType) return false;  //XXX ignores separate comp
						getWorld().getMessageHandler().handleMessage(
							MessageUtil.error("inter-type declaration from " + munger.getAspectType().getName() +
											" conflicts with existing member: " + existingMember,
											munger.getSourceLocation())
						);
					}
				} else {
					//interTypeMungers.add(munger);
				}
				//return;
			}
		}
		return true;
	}
================= fetch private int matchingIndex(ResolvedTypeX a) { 4feb835^:weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java

private int matchingIndex(ResolvedTypeX a) {
		int knownMatch = -1;
		int starMatch = -1;
		for (int i=0, len=patterns.size(); i < len; i++) {
			TypePattern p = patterns.get(i);
			if (p.isStar()) {
				starMatch = i;
			} else if (p.matchesStatically(a)) {
				if (knownMatch != -1) {
					a.getWorld().showMessage(IMessage.ERROR, "multiple matches for " + a + 
							", matches both " + patterns.get(knownMatch) + " and " + p,
							patterns.get(knownMatch).getSourceLocation(), p.getSourceLocation());
					return -1;
				} else {
					knownMatch = i;
				}
			}
		}
		if (knownMatch == -1) return starMatch;
		else return knownMatch;
	}
================= fetch private void addPointcutsResolvingConflicts(List acc, List added, boolean isOver 4feb835^:weaver/src/org/aspectj/weaver/ResolvedTypeX.java

public boolean isExposedToWeaver() { return false; }
================= fetch private void interTypeConflictError( 4feb835^:weaver/src/org/aspectj/weaver/ResolvedTypeX.java

private void interTypeConflictError(
		ConcreteTypeMunger m1,
		ConcreteTypeMunger m2)
	{
		//XXX this works only if we ignore separate compilation issues
		//XXX dual errors possible if (this instanceof BcelObjectType) return;
		
		//System.err.println("conflict at " + m2.getSourceLocation());
		getWorld().showMessage(IMessage.ERROR,
			"intertype declaration from "
				+ m1.getAspectType().getName()
				+ " conflicts with intertype declaration: "
				+ m2.getSignature()
				+ " from "
				+ m2.getAspectType().getName(),
			m2.getSourceLocation(), getSourceLocation());
	}
================= fetch private void sortMungers() { 4feb835^:weaver/src/org/aspectj/weaver/Shadow.java

private void sortMungers() {
		List sorted = PartialOrder.sort(mungers);
		if (sorted == null) {
			// this means that we have circular dependencies
			for (Iterator i = mungers.iterator(); i.hasNext(); ) {
				ShadowMunger m = (ShadowMunger)i.next();
				getIWorld().getMessageHandler().handleMessage(
					MessageUtil.error("circular advice dependency at " + this, m.getSourceLocation()));
			}
		}
		mungers = sorted;
	}
================= fetch private void writeBack(BcelWorld world) { 4feb835^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java

private void writeBack(BcelWorld world) {
    	if (myType != null && myType.getWeaverState() != null) {
			myGen.addAttribute(BcelAttributes.bcelAttribute(
				new AjAttribute.WeaverState(myType.getWeaverState()), 
				getConstantPoolGen()));
    	}
    	
    	addAjcInitializers();
    	
        int len = methodGens.size();
        myGen.setMethods(new Method[0]);
        
        calculateSourceDebugExtensionOffsets();
        for (int i = 0; i < len; i++) {
            LazyMethodGen gen = (LazyMethodGen) methodGens.get(i);
            // we skip empty clinits
            if (isEmptyClinit(gen)) continue;
            myGen.addMethod(gen.getMethod());
        }
		if (inlinedFiles.size() != 0) {
			if (hasSourceDebugExtensionAttribute(myGen)) {
				world.showMessage(
					IMessage.WARNING,
					"overwriting JSR45 information for "
						+ getFileName()
						+ " (compiler limitation)",
					null,
					null);
			}
			myGen.addAttribute(getSourceDebugExtensionAttribute());
		}
    }
================= fetch protected TypePattern notExactType(IScope s) { 4feb835^:weaver/src/org/aspectj/weaver/patterns/TypePattern.java

protected TypePattern notExactType(IScope s) {
		s.getMessageHandler().handleMessage(MessageUtil.error("exact type pattern required", getSourceLocation()));
		return NO;
	}
================= fetch protected boolean checkCanThrow(ShadowMunger munger, ResolvedTypeX resolvedTypeX 4feb835^:weaver/src/org/aspectj/weaver/Shadow.java

protected boolean checkCanThrow(ShadowMunger munger, ResolvedTypeX resolvedTypeX) {
		if (getKind() == ExceptionHandler) {
			//XXX much too lenient rules here, need to walk up exception handlers
			return true;
		}
		
		if (!isDeclaredException(resolvedTypeX, getSignature())) {
			getIWorld().showMessage(IMessage.ERROR, "can't throw checked exception \'" + resolvedTypeX +
							"\' at this join point \'" + this +"\'", // from advice in \'" + munger. + "\'",
							getSourceLocation(), munger.getSourceLocation());
		}
		
		return true;
	}
================= fetch public List getExposedPointcuts() { 4feb835^:weaver/src/org/aspectj/weaver/ResolvedTypeX.java

public List getExposedPointcuts() {
		List ret = new ArrayList();
		if (getSuperclass() != null) ret.addAll(getSuperclass().getExposedPointcuts());
		
		for (Iterator i = Arrays.asList(getDeclaredInterfaces()).iterator(); i.hasNext(); ) {
			ResolvedTypeX t = (ResolvedTypeX)i.next();
			addPointcutsResolvingConflicts(ret, Arrays.asList(t.getDeclaredPointcuts()), false);
		}
		addPointcutsResolvingConflicts(ret, Arrays.asList(getDeclaredPointcuts()), true);
		for (Iterator i = ret.iterator(); i.hasNext(); ) {
			ResolvedPointcutDefinition inherited = (ResolvedPointcutDefinition)i.next();
//			System.err.println("looking at: " + inherited + " in " + this);
//			System.err.println("            " + inherited.isAbstract() + " in " + this.isAbstract());
			if (inherited.isAbstract()) {
				if (!this.isAbstract()) {
					getWorld().showMessage(IMessage.ERROR,
						"inherited abstract " + inherited + 
						" is not made concrete in " + this.getName(),
						inherited.getSourceLocation(), this.getSourceLocation());
				}
			}
		}		
		
		
		return ret;
	}
================= fetch public List getTypeMungers(ResolvedTypeX onType) { 4feb835^:weaver/src/org/aspectj/weaver/WeaverStateInfo.java

public List getTypeMungers(ResolvedTypeX onType) {
		World world = onType.getWorld();
		List ret = new ArrayList();
		for (Iterator i = typeMungers.iterator(); i.hasNext();) {
			Entry entry = (Entry) i.next();
			ResolvedTypeX aspectType = world.resolve(entry.aspectType, true);
			if (aspectType == ResolvedTypeX.MISSING) {
				world.showMessage(IMessage.ERROR, "aspect " + entry.aspectType + 
					" is needed when using type " + onType,
					onType.getSourceLocation(), null);
				continue;
			}
			
			ret.add(new BcelTypeMunger(entry.typeMunger, aspectType));
		}
		return ret;
	}
================= fetch public Method getMethod() { 4feb835^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

public Method getMethod() {
    	if (savedMethod != null) return savedMethod;  //??? this relies on gentle treatment of constant pool
    	
    	try {
			MethodGen gen = pack();
			return gen.getMethod();
    	} catch (ClassGenException e) {
    		enclosingClass.getBcelObjectType().getResolvedTypeX().getWorld().showMessage(
    			IMessage.ERROR, "problem generating method " + 
    			this.getClassName() + "." + this.getName() + ": " + e.getMessage(),
    			this.getMemberView() == null ? null : this.getMemberView().getSourceLocation(), null);
    		throw e;
    	}
    }
================= fetch public PerClause concretize(ResolvedTypeX inAspect) { 4feb835^:weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java

public PerClause concretize(ResolvedTypeX inAspect) {
		PerClause p = lookupConcretePerClause(inAspect.getSuperclass());
		if (p == null) {
			inAspect.getWorld().getMessageHandler().handleMessage(
			  MessageUtil.error("expected per clause on super aspect not found on " + 
			  					inAspect.getSuperclass(), getSourceLocation())
			);
		}
		if (p.getKind() != kind) {
			inAspect.getWorld().getMessageHandler().handleMessage(
			  MessageUtil.error("wrong kind of per clause on super, expected " + 
			  					kind + " but found " + p.getKind(),
			  					getSourceLocation())
			);
		}
		return p.concretize(inAspect);
	}
================= fetch public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) { 4feb835^:weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java

public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {
		if (isDeclare(bindings.getEnclosingAdvice())) {
		  // Enforce rule about which designators are supported in declare
		  inAspect.getWorld().showMessage(IMessage.ERROR,
			"args() pointcut designator cannot be used in declare statement",
			bindings.getEnclosingAdvice().getSourceLocation(), null);
		  return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
		}
		TypePatternList args = arguments.resolveReferences(bindings);
		if (inAspect.crosscuttingMembers != null) {
			inAspect.crosscuttingMembers.exposeTypes(args.getExactTypes());
		}
		return new ArgsPointcut(args);
	}
================= fetch public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) { 4feb835^:weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java

public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {
		if (isDeclare(bindings.getEnclosingAdvice())) {
			// Enforce rule about which designators are supported in declare
			inAspect.getWorld().showMessage(IMessage.ERROR,
			  "cflow"+(isBelow?"below":"")+"() pointcut designator cannot be used in declare statement",
			  bindings.getEnclosingAdvice().getSourceLocation(), null);
			return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
		}
		//make this remap from formal positions to arrayIndices
		IntMap entryBindings = new IntMap();
		for (int i=0, len=freeVars.length; i < len; i++) {
			int freeVar = freeVars[i];
			//int formalIndex = bindings.get(freeVar);
			entryBindings.put(freeVar, i);
		}
		entryBindings.copyContext(bindings);
		//System.out.println(this + " bindings: " + entryBindings);
		
		World world = inAspect.getWorld();
		
		Pointcut concreteEntry;
		
		ResolvedTypeX concreteAspect = bindings.getConcreteAspect();
		
		CrosscuttingMembers xcut = concreteAspect.crosscuttingMembers;		
		Collection previousCflowEntries = xcut.getCflowEntries();
		
		entryBindings.pushEnclosingDefinition(CFLOW_MARKER);
		try {
			concreteEntry = entry.concretize(inAspect, entryBindings);
		} finally {
			entryBindings.popEnclosingDefinitition();
		}

		List innerCflowEntries = new ArrayList(xcut.getCflowEntries());
		innerCflowEntries.removeAll(previousCflowEntries);

		
		ResolvedMember cflowField = new ResolvedMember(
			Member.FIELD, concreteAspect, Modifier.STATIC | Modifier.PUBLIC | Modifier.FINAL,
					NameMangler.cflowStack(xcut), 
					TypeX.forName(NameMangler.CFLOW_STACK_TYPE).getSignature());
		//System.out.println("adding field to: " + inAspect + " field " + cflowField);
					
		// add field and initializer to inAspect
		//XXX and then that info above needs to be mapped down here to help with
		//XXX getting the exposed state right
		concreteAspect.crosscuttingMembers.addConcreteShadowMunger(
				Advice.makeCflowEntry(world, concreteEntry, isBelow, cflowField, freeVars.length, innerCflowEntries,inAspect));
		
		concreteAspect.crosscuttingMembers.addTypeMunger(
			world.makeCflowStackFieldAdder(cflowField));
			
			
		List slots = new ArrayList();
		for (int i=0, len=freeVars.length; i < len; i++) {
			int freeVar = freeVars[i];
			
			// we don't need to keep state that isn't actually exposed to advice
			//??? this means that we will store some state that we won't actually use, optimize this later
			if (!bindings.hasKey(freeVar)) continue; 
			
			int formalIndex = bindings.get(freeVar);
			ResolvedTypeX formalType =
				bindings.getAdviceSignature().getParameterTypes()[formalIndex].resolve(world);
			
			ConcreteCflowPointcut.Slot slot = 
				new ConcreteCflowPointcut.Slot(formalIndex, formalType, i);
			slots.add(slot);
		}
		
		return new ConcreteCflowPointcut(cflowField, slots);
	}
================= fetch public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) { 4feb835^:weaver/src/org/aspectj/weaver/patterns/IfPointcut.java

public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {
		//System.err.println("concretize: " + this + " already: " + partiallyConcretized);
		
		if (isDeclare(bindings.getEnclosingAdvice())) {
			// Enforce rule about which designators are supported in declare
			inAspect.getWorld().showMessage(IMessage.ERROR,
			  "if() pointcut designator cannot be used in declare statement",
			  bindings.getEnclosingAdvice().getSourceLocation(),
			  null);
			return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
		}
		
		if (partiallyConcretized != null) {
			return partiallyConcretized;
		}
		IfPointcut ret = new IfPointcut(testMethod, extraParameterFlags);
		partiallyConcretized = ret;
		
		// It is possible to directly code your pointcut expression in a per clause
		// rather than defining a pointcut declaration and referencing it in your
		// per clause.  If you do this, we have problems (bug #62458).  For now,
		// let's police that you are trying to code a pointcut in a per clause and
		// put out a compiler error.
		if (bindings.directlyInAdvice() && bindings.getEnclosingAdvice()==null) {
			// Assumption: if() is in a per clause if we say we are directly in advice
			// but we have no enclosing advice.
			inAspect.getWorld().showMessage(IMessage.ERROR,
				"if() pointcut designator cannot be used directly in a per clause (compiler limitation).  Create a named pointcut containing the if() and refer to it",
				this.getSourceLocation(),null);
			return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
		}
		
		if (bindings.directlyInAdvice()) {
			ShadowMunger advice = bindings.getEnclosingAdvice();
			if (advice instanceof Advice) {
				ret.baseArgsCount = ((Advice)advice).getBaseParameterCount();
			} else {
				ret.baseArgsCount = 0;
			}
			ret.residueSource = advice.getPointcut().concretize(inAspect, ret.baseArgsCount, advice);
		} else {
			ResolvedPointcutDefinition def = bindings.peekEnclosingDefinitition();
			if (def == CflowPointcut.CFLOW_MARKER) {
				inAspect.getWorld().showMessage(IMessage.ERROR,
					"if not supported lexically within cflow (compiler limitation)",
					getSourceLocation(), null);
				return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
			}
			ret.baseArgsCount = def.getParameterTypes().length;
			
			IntMap newBindings = IntMap.idMap(ret.baseArgsCount);
			newBindings.copyContext(bindings);
			ret.residueSource = def.getPointcut().concretize(inAspect, newBindings);
		}
		
		return ret;
	}
================= fetch public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) { 4feb835^:weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java

public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {
		if (isDeclare(bindings.getEnclosingAdvice())) {
		  // Enforce rule about which designators are supported in declare
		  inAspect.getWorld().showMessage(IMessage.ERROR,
		    (isThis?"this":"target")+"() pointcut designator cannot be used in declare statement",
		    bindings.getEnclosingAdvice().getSourceLocation(), null);
		  return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
		}
		
		TypePattern newType = type.remapAdviceFormals(bindings);
		if (inAspect.crosscuttingMembers != null) {
			inAspect.crosscuttingMembers.exposeType(newType.getExactType());
		}
		
		return new ThisOrTargetPointcut(isThis, newType);
	}
================= fetch public Pointcut concretize1(ResolvedTypeX searchStart, IntMap bindings) { 4feb835^:weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java

public Pointcut concretize1(ResolvedTypeX searchStart, IntMap bindings) {
		if (concretizing) {
			//Thread.currentThread().dumpStack();
			searchStart.getWorld().getMessageHandler().handleMessage(
				MessageUtil.error("circular pointcut declaration involving: " + this,
									getSourceLocation()));
			return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
		}
		
		try {
			concretizing = true;
		
			ResolvedPointcutDefinition pointcutDec;
			if (onType != null) {
				searchStart = onType.resolve(searchStart.getWorld());
				if (searchStart == ResolvedTypeX.MISSING) {
					return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
				}
			}
			pointcutDec = searchStart.findPointcut(name);
			if (pointcutDec == null) {
				searchStart.getWorld().getMessageHandler().handleMessage(
					MessageUtil.error("can't find pointcut \'" + name + "\' on " + searchStart.getName(), 
									getSourceLocation())
				);
				return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
			}
			
			if (pointcutDec.isAbstract()) {
				//Thread.currentThread().dumpStack();
				ShadowMunger enclosingAdvice = bindings.getEnclosingAdvice();
				searchStart.getWorld().showMessage(IMessage.ERROR,
					pointcutDec + " is abstract", 
					getSourceLocation(), 
					(null == enclosingAdvice) ? null : enclosingAdvice.getSourceLocation());
				return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
			}
					
			//System.err.println("start: " + searchStart);
			ResolvedTypeX[] parameterTypes = searchStart.getWorld().resolve(pointcutDec.getParameterTypes());
			
			TypePatternList arguments = this.arguments.resolveReferences(bindings);
			
			IntMap newBindings = new IntMap();
			for (int i=0,len=arguments.size(); i < len; i++) {
				TypePattern p = arguments.get(i);
				//we are allowed to bind to pointcuts which use subtypes as this is type safe
				if (!p.matchesSubtypes(parameterTypes[i])  && 
					!p.getExactType().equals(TypeX.OBJECT))
				{
					throw new BCException("illegal change to pointcut declaration: " + this);
				}
				
			    if (p instanceof BindingTypePattern) {
			    	newBindings.put(i, ((BindingTypePattern)p).getFormalIndex());
			    }
			}
			
			newBindings.copyContext(bindings);
			newBindings.pushEnclosingDefinition(pointcutDec);
			try {
				return pointcutDec.getPointcut().concretize(searchStart, newBindings);
			} finally {
				newBindings.popEnclosingDefinitition();
			}
			
		} finally {
			concretizing = false;
		}
	}
================= fetch public Pointcut concretize1( 4feb835^:weaver/src/org/aspectj/weaver/patterns/IfPointcut.java

public static IfPointcut makeIfTruePointcut(State state) {
		IfPointcut ret = new IfTruePointcut();
		ret.state = state;
		return ret;
	}
================= fetch public ResolvedTypeX resolve(TypeX ty, boolean allowMissing) { 4feb835^:weaver/src/org/aspectj/weaver/World.java

public ResolvedTypeX resolve(TypeX ty, boolean allowMissing) {
    	//System.out.println("resolve: " + ty + " world " + typeMap.keySet());
        String signature = ty.getSignature();
        ResolvedTypeX ret = typeMap.get(signature);
        if (ret != null) return ret;
        
        if (ty.isArray()) {
            ret = new ResolvedTypeX.Array(signature, this, resolve(ty.getComponentType(), allowMissing));
        } else {
            ret = resolveObjectType(ty);
            if (!allowMissing && ret == ResolvedTypeX.MISSING) {
            	//Thread.currentThread().dumpStack();
                MessageUtil.error(messageHandler, "can't find type " + ty.getName());
                // + " on classpath " + classPath);
            }
        }
        //System.out.println("ret: " + ret);
        typeMap.put(signature, ret);
        return ret;
    }
================= fetch public TypePattern resolveBindings(IScope scope, Bindings bindings, 4feb835^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
/**
	 * Need to determine if I'm really a pattern or a reference to a formal
	 * 
	 * We may wish to further optimize the case of pattern vs. non-pattern
	 * 
	 * We will be replaced by what we return
	 */
public TypePattern resolveBindings(IScope scope, Bindings bindings, 
    								boolean allowBinding, boolean requireExactType)
    { 		
    	if (isStar()) {
			return TypePattern.ANY;  //??? loses source location
		}

		String simpleName = maybeGetSimpleName();
		if (simpleName != null) {
			FormalBinding formalBinding = scope.lookupFormal(simpleName);
			if (formalBinding != null) {
				if (bindings == null) {
					scope.message(IMessage.ERROR, this, "negation doesn't allow binding");
					return this;
				}
				if (!allowBinding) {
					scope.message(IMessage.ERROR, this, 
						"name binding only allowed in target, this, and args pcds");
					return this;
				}
				
				BindingTypePattern binding = new BindingTypePattern(formalBinding);
				binding.copyLocationFrom(this);
				bindings.register(binding, scope);
				
				return binding;
			}
		}
		
		String cleanName = maybeGetCleanName();
		String originalName = cleanName;
		if (cleanName != null) {
			TypeX type;
			
			//System.out.println("resolve: " + cleanName);
			//??? this loop has too many inefficiencies to count
			while ((type = scope.lookupType(cleanName, this)) == ResolvedTypeX.MISSING) {
				int lastDot = cleanName.lastIndexOf('.');
				if (lastDot == -1) break;
				cleanName = cleanName.substring(0, lastDot) + '$' + cleanName.substring(lastDot+1);
			}
			if (type == ResolvedTypeX.MISSING) {
				if (requireExactType) {
					if (!allowBinding) {
						scope.getWorld().getMessageHandler().handleMessage(
							MessageUtil.error("can't bind type name '" + originalName + "'",
											getSourceLocation()));
					} else if (scope.getWorld().getLint().invalidAbsoluteTypeName.isEnabled()) {
						scope.getWorld().getLint().invalidAbsoluteTypeName.signal(originalName, getSourceLocation());
					}
					return NO;
				} else if (scope.getWorld().getLint().invalidAbsoluteTypeName.isEnabled()) {
					scope.getWorld().getLint().invalidAbsoluteTypeName.signal(originalName, getSourceLocation());
				}
			} else {
				if (dim != 0) type = TypeX.makeArray(type, dim);
				TypePattern ret = new ExactTypePattern(type, includeSubtypes);
				ret.copyLocationFrom(this);
				return ret;
			}
		} else {
			if (requireExactType) {
				scope.getWorld().getMessageHandler().handleMessage(
					MessageUtil.error("wildcard type pattern not allowed, must use type name",
										getSourceLocation()));
				return NO;
			}
			//XXX need to implement behavior for Lint.invalidWildcardTypeName
		}
		
		importedPrefixes = scope.getImportedPrefixes();
		knownMatches = preMatch(scope.getImportedNames());
		
		return this;
	}
================= fetch public boolean checkLegalOverride(ResolvedMember parent, ResolvedMember child) { 4feb835^:weaver/src/org/aspectj/weaver/ResolvedTypeX.java

public boolean checkLegalOverride(ResolvedMember parent, ResolvedMember child) {
		//System.err.println("check: " + child.getDeclaringType() + " overrides " + parent.getDeclaringType());
		if (!parent.getReturnType().equals(child.getReturnType())) {
			world.showMessage(IMessage.ERROR,
				"can't override " + parent +
				" with " + child + " return types don't match",
				child.getSourceLocation(), parent.getSourceLocation());
			return false;
		}		
		if (parent.getKind() == Member.POINTCUT) {
			TypeX[] pTypes = parent.getParameterTypes();
			TypeX[] cTypes = child.getParameterTypes();
			if (!Arrays.equals(pTypes, cTypes)) {
				world.showMessage(IMessage.ERROR,
					"can't override " + parent +
					" with " + child + " parameter types don't match",
					child.getSourceLocation(), parent.getSourceLocation());
				return false;
			}
		}		
		//System.err.println("check: " + child.getModifiers() + " more visible " + parent.getModifiers());
		if (isMoreVisible(parent.getModifiers(), child.getModifiers())) {
			world.showMessage(IMessage.ERROR,
				"can't override " + parent +
				" with " + child + " visibility is reduced",
				child.getSourceLocation(), parent.getSourceLocation());
			return false;
		}
		
		// check declared exceptions
		ResolvedTypeX[] childExceptions = world.resolve(child.getExceptions());
		ResolvedTypeX[] parentExceptions = world.resolve(parent.getExceptions());
		ResolvedTypeX runtimeException = world.resolve("java.lang.RuntimeException");
		ResolvedTypeX error = world.resolve("java.lang.Error");
		
		outer: for (int i=0, leni = childExceptions.length; i < leni; i++) {
			//System.err.println("checking: " + childExceptions[i]);
			if (runtimeException.isAssignableFrom(childExceptions[i])) continue;
			if (error.isAssignableFrom(childExceptions[i])) continue;
			
			for (int j = 0, lenj = parentExceptions.length; j < lenj; j++) {
				if (parentExceptions[j].isAssignableFrom(childExceptions[i])) continue outer;
			}
			
			world.showMessage(IMessage.ERROR, "overriden method doesn't throw " 
					+ childExceptions[i].getName(), child.getSourceLocation(), null);
						
			return false;
		}
		if (parent.isStatic() && !child.isStatic()) {
			world.showMessage(IMessage.ERROR,
			  child.toString()+" cannot override "+parent.toString()+"; overridden method is static",
			  child.getSourceLocation(),null);
		} else if (child.isStatic() && !parent.isStatic()) {
			world.showMessage(IMessage.ERROR,
			  child.toString()+" cannot override "+parent.toString()+"; overriding method is static",
			  child.getSourceLocation(),null);
		}
		return true;
		
	}
================= fetch public boolean match(Shadow shadow, World world) { 4feb835^:weaver/src/org/aspectj/weaver/Advice.java

public boolean match(Shadow shadow, World world) {
		if (super.match(shadow, world)) {
			if (shadow.getKind() == Shadow.ExceptionHandler) {
				if (kind.isAfter() || kind == AdviceKind.Around) {
					world.showMessage(IMessage.WARNING,
	    				"Only before advice is supported on handler join points (compiler limitation)", 
	    				getSourceLocation(), shadow.getSourceLocation());
					return false;
				}
			}
			
			
    		if (hasExtraParameter() && kind == AdviceKind.AfterReturning) {
    			return getExtraParameterType().isConvertableFrom(shadow.getReturnType(), world);
    		} else if (kind == AdviceKind.PerTargetEntry) {
    			return shadow.hasTarget();
    		} else if (kind == AdviceKind.PerThisEntry) {
    			return shadow.hasThis();
    		} else if (kind == AdviceKind.Around) {
    			if (shadow.getKind() == Shadow.PreInitialization) {
	    			world.showMessage(IMessage.ERROR,
	    				"around on pre-initialization not supported (compiler limitation)", 
	    				getSourceLocation(), shadow.getSourceLocation());
					return false;
				} else if (shadow.getKind() == Shadow.Initialization) {
					world.showMessage(IMessage.ERROR,
						"around on initialization not supported (compiler limitation)", 
						getSourceLocation(), shadow.getSourceLocation());
					return false;
				} else if (shadow.getKind() == Shadow.StaticInitialization && 
							shadow.getEnclosingType().isInterface(world))
				{
					world.showMessage(IMessage.ERROR,
						"around on staticinitialization of interface \'" + 
						shadow.getEnclosingType().getName() +
						"\' not supported (compiler limitation)", 
						getSourceLocation(), shadow.getSourceLocation());
					return false;
    			} else {
    				//System.err.println(getSignature().getReturnType() + " from " + shadow.getReturnType());
    				if (getSignature().getReturnType() == ResolvedTypeX.VOID) {
    					if (shadow.getReturnType() != ResolvedTypeX.VOID) {
    						world.showMessage(IMessage.ERROR, 
    							"applying to join point that doesn't return void: " + shadow,
    							getSourceLocation(), shadow.getSourceLocation());
    						return false;
    					}
    				} else if (getSignature().getReturnType().equals(TypeX.OBJECT)) {
    					return true;
    				} else if(!shadow.getReturnType().isAssignableFrom(getSignature().getReturnType(), world)) {
    					//System.err.println(this + ", " + sourceContext + ", " + start);
						world.showMessage(IMessage.ERROR, 
								"incompatible return type applying to " + shadow,
								getSourceLocation(), shadow.getSourceLocation());
	    				return false;
    				}
    			}
    		}
    		return true; 
    	} else {
    		return false;
    	}
	}
================= fetch public boolean weave() { 4feb835^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
// ----
public boolean weave() {

        if (clazz.isWoven() && !clazz.isReweavable()) {
        	world.showMessage(IMessage.ERROR, 
				"class \'" + clazz.getType().getName() + "\' is already woven and has not been built with -Xreweavable",
				ty.getSourceLocation(), null);
        	return false;
        }
       

        Set aspectsAffectingType = null;
        if (inReweavableMode) aspectsAffectingType = new HashSet();
        
        boolean isChanged = false;
        
        // we want to "touch" all aspects
        if (clazz.getType().isAspect()) isChanged = true;
                
        // start by munging all typeMungers
        for (Iterator i = typeMungers.iterator(); i.hasNext(); ) {
        	Object o = i.next();
        	if ( !(o instanceof BcelTypeMunger) ) {
        		//???System.err.println("surprising: " + o);
        		continue;
        	}
        	BcelTypeMunger munger = (BcelTypeMunger)o;
        	boolean typeMungerAffectedType = munger.munge(this);
        	if (typeMungerAffectedType) {
        		isChanged = true;
        		if (inReweavableMode) aspectsAffectingType.add(munger.getAspectType().getName());
        	}
        }
        
        // XXX do major sort of stuff
        // sort according to:  Major:  type hierarchy
        //                     within each list:  dominates
        // don't forget to sort addedThisInitialiers according to dominates
        addedSuperInitializersAsList = new ArrayList(addedSuperInitializers.values());
        addedSuperInitializersAsList = PartialOrder.sort(addedSuperInitializersAsList);        
        if (addedSuperInitializersAsList == null) {
        	throw new BCException("circularity in inter-types");
        }
      
        // this will create a static initializer if there isn't one
        // this is in just as bad taste as NOPs
        LazyMethodGen staticInit = clazz.getStaticInitializer();
        staticInit.getBody().insert(genInitInstructions(addedClassInitializers, true));
        
        // now go through each method, and match against each method.  This
        // sets up each method's {@link LazyMethodGen#matchedShadows} field, 
        // and it also possibly adds to {@link #initializationShadows}.
        List methodGens = new ArrayList(clazz.getMethodGens());
        for (Iterator i = methodGens.iterator(); i.hasNext();) {
            LazyMethodGen mg = (LazyMethodGen)i.next();
            //mg.getBody();
			if (! mg.hasBody()) continue;
			boolean shadowMungerMatched = match(mg);
			if (shadowMungerMatched) {
				// For matching mungers, add their declaring aspects to the list that affected this type
				if (inReweavableMode) aspectsAffectingType.addAll(findAspectsForMungers(mg));
              isChanged = true;
			}
        }
        if (! isChanged) return false;
        
        
        // now we weave all but the initialization shadows
		for (Iterator i = methodGens.iterator(); i.hasNext();) {
			LazyMethodGen mg = (LazyMethodGen)i.next();
			if (! mg.hasBody()) continue;
			implement(mg);
		}
			
        
        // if we matched any initialization shadows, we inline and weave
		if (! initializationShadows.isEmpty()) {
			// Repeat next step until nothing left to inline...cant go on 
			// infinetly as compiler will have detected and reported 
			// "Recursive constructor invocation"
			while (inlineSelfConstructors(methodGens));
			positionAndImplement(initializationShadows);
		}
		
		
		// finally, if we changed, we add in the introduced methods.
        if (isChanged) {
        	clazz.getOrCreateWeaverStateInfo();
			weaveInAddedMethods();
        }
        
        if (inReweavableMode) {
        	WeaverStateInfo wsi = clazz.getOrCreateWeaverStateInfo();
        	wsi.addAspectsAffectingType(aspectsAffectingType);
        	wsi.setUnwovenClassFileData(ty.getJavaClass().getBytes());
        	wsi.setReweavable(true,compressReweavableAttributes);
        } else {
        	clazz.getOrCreateWeaverStateInfo().setReweavable(false,false);
        }
        
        return isChanged;
    }
================= fetch public static Test suite() { 4feb835^:weaver/testsrc/org/aspectj/weaver/BcweaverTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(BcweaverTests.class.getName());
        // abstract
        //suite.addTestSuite(AbstractWorldTestCase.class); 
        //$JUnit-BEGIN$
        suite.addTestSuite(MemberTestCase.class); 
		suite.addTestSuite(TypeXTestCase.class); 
		suite.addTestSuite(WeavingURLClassLoaderTest.class); 
        //$JUnit-END$
        return suite;
    }
================= fetch public void addPath (String name, IMessageHandler handler) { 4feb835^:weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java

public void addPath (String name, IMessageHandler handler) {
		File f = new File(name);
		String lc = name.toLowerCase();
		if (lc.endsWith(".jar") || lc.endsWith(".zip")) {
			if (!f.isFile()) {
			MessageUtil.info(handler, "zipfile classpath entry does not exist: " + name);
			return;
			}
			try {
				entries.add(new ZipFileEntry(f));
			} catch (IOException ioe) {
			MessageUtil.warn(handler, "zipfile classpath entry is invalid: " + name + "<" + ioe.getMessage() + ">");
			return;
			}
		} else {
			if (!f.isDirectory()) {
			MessageUtil.info(handler, "directory classpath entry does not exist: " + name);
			return;
			}
			entries.add(new DirEntry(f));
		}
	}
================= fetch public void check(World world) { 4feb835^:weaver/src/org/aspectj/weaver/NewConstructorTypeMunger.java

public void check(World world) {
		if (getSignature().getDeclaringType().isAspect(world)) {
			world.showMessage(IMessage.ERROR, "can't declare constructor on an aspect",
						getSignature().getSourceLocation(), null);
		}
	}
================= fetch public void loadDefaultProperties() { 4feb835^:weaver/src/org/aspectj/weaver/Lint.java

public void loadDefaultProperties() {
		InputStream s = getClass().getResourceAsStream("XlintDefault.properties");
		if (s == null) {
			MessageUtil.warn(world.getMessageHandler(), "couldn't load XlintDefault.properties");
			return;
		}
		try {
			setFromProperties(s);
		} catch (IOException ioe) {
			MessageUtil.error(world.getMessageHandler(), "problem loading XlintDefault.properties, " +
					ioe.getMessage());
		}

	}
================= fetch public void prepareToProcessReweavableState() { 4feb835^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java

public void prepareToProcessReweavableState() {
		if (inReweavableMode)
			world.showMessage(IMessage.INFO, "weaver operating in reweavable mode.  Need to verify any required types exist.", null, null);
    	 	    	
    	alreadyConfirmedReweavableState = new HashSet();
    }
================= fetch public void processReweavableStateIfPresent(String className, BcelObjectType cla 4feb835^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java

public void processReweavableStateIfPresent(String className, BcelObjectType classType) {
		// If the class is marked reweavable, check any aspects around when it was built are in this world
		WeaverStateInfo wsi = classType.getWeaverState();		
		if (wsi!=null && wsi.isReweavable()) { // Check all necessary types are around!
			world.showMessage(IMessage.INFO,"processing reweavable type "+className+": "+classType.getSourceLocation().getSourceFile(),null,null);
			Set aspectsPreviouslyInWorld = wsi.getAspectsAffectingType();
			if (aspectsPreviouslyInWorld!=null) {
				for (Iterator iter = aspectsPreviouslyInWorld.iterator(); iter.hasNext();) {
					String requiredTypeName = (String) iter.next();
					if (!alreadyConfirmedReweavableState.contains(requiredTypeName)) {
						ResolvedTypeX rtx = world.resolve(TypeX.forName(requiredTypeName),true);
						boolean exists = rtx!=ResolvedTypeX.MISSING;
						if (!exists) {
							world.showMessage(IMessage.ERROR, "type " + requiredTypeName + 
								" is needed by reweavable type " + className,
								classType.getSourceLocation(), null);
						} else {
							if (!world.getMessageHandler().isIgnoring(IMessage.INFO))
							  world.showMessage(IMessage.INFO,"successfully verified type "+requiredTypeName+
		                        " exists.  Originates from "+rtx.getSourceLocation().getSourceFile(),null,null);
							alreadyConfirmedReweavableState.add(requiredTypeName);
						}
					}		
				}
			}
			classType.setJavaClass(Utility.makeJavaClass(classType.getJavaClass().getFileName(), wsi.getUnwovenClassFileData()));
		} else {
			classType.resetState();
		}
	}
================= fetch public void resolve(IScope scope) { 4feb835^:weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java

public void resolve(IScope scope) {
    	patterns = patterns.resolveBindings(scope, Bindings.NONE, false, false); 
    	boolean seenStar = false;
    	
    	for (int i=0; i < patterns.size(); i++) {
    		TypePattern pi = patterns.get(i);
    		if (pi.isStar()) {
    			if (seenStar) {
    				scope.getWorld().showMessage(IMessage.ERROR,
    					"circularity in declare precedence, '*' occurs more than once",
    					pi.getSourceLocation(), null);    				
    			}
    			seenStar = true;
    			continue;
    		}
    		ResolvedTypeX exactType = pi.getExactType().resolve(scope.getWorld());
    		if (exactType == ResolvedTypeX.MISSING) continue;
    		
    		// Cannot do a dec prec specifying a non-aspect types unless suffixed with a '+'
    		if (!exactType.isAspect() && !pi.isIncludeSubtypes()) {
    			scope.getWorld().showMessage(IMessage.ERROR,
    				"Non-aspect types can only be specified in a declare precedence statement when subtypes are included.  Non-aspect type is : "+exactType.getName(),
    				pi.getSourceLocation(),null);
    		}
    		
    		for (int j=0; j < patterns.size(); j++) {
    			if (j == i) continue;
    			TypePattern pj = patterns.get(j);
    			if (pj.isStar()) continue;
    			if (pj.matchesStatically(exactType)) {
    				scope.getWorld().showMessage(IMessage.ERROR,
    					"circularity in declare precedence, '" + exactType.getName() + 
    						"' matches two patterns", pi.getSourceLocation(), pj.getSourceLocation());
    			}
    		}
    	}    	
    }
================= fetch public void resolve(IScope scope) { 4feb835^:weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java

public void resolve(IScope scope) {
    	exception = exception.resolveBindings(scope, null, false, true);
    	TypeX excType = exception.getExactType();
    	if (excType != ResolvedTypeX.MISSING) {
    		if (!scope.getWorld().resolve(TypeX.THROWABLE).isAssignableFrom(excType)) {
    			scope.getWorld().showMessage(IMessage.ERROR,
    					excType.getName() + " is not a subtype of Throwable",
    					exception.getSourceLocation(), null);
    			pointcut = Pointcut.makeMatchesNothing(Pointcut.RESOLVED);
    			return;
    		}
    	}
    	
    	pointcut = pointcut.resolve(scope); 	
    }
================= fetch public void setFromProperties(File file) { 4feb835^:weaver/src/org/aspectj/weaver/Lint.java

public void setFromProperties(File file) {
		try {
			InputStream s = new FileInputStream(file);
			setFromProperties(s);
		} catch (IOException ioe) {
			MessageUtil.error(world.getMessageHandler(), "problem loading Xlint properties file: " + 
					file.getPath() + ", " + ioe.getMessage());
		}
	}
================= fetch public void setFromProperties(Properties properties) { 4feb835^:weaver/src/org/aspectj/weaver/Lint.java

private IMessage.Kind getMessageKind(String v) {
		if (v.equals("ignore")) return null;
		else if (v.equals("warning")) return IMessage.WARNING;
		else if (v.equals("error")) return IMessage.ERROR;
		
		MessageUtil.error(world.getMessageHandler(), 
			"invalid Xlint message kind (must be one of ignore, warning, error): " + v);
		return null;
	}
================= fetch public void weave(ResolvedTypeX onType) { 4feb835^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java

public void weave(ResolvedTypeX onType) {
		onType.clearInterTypeMungers();
		
		// need to do any declare parents before the matching below
		for (Iterator i = declareParentsList.iterator(); i.hasNext(); ) {
			DeclareParents p = (DeclareParents)i.next();
			List newParents = p.findMatchingNewParents(onType);
			if (!newParents.isEmpty()) {
				BcelObjectType classType = BcelWorld.getBcelObjectType(onType);
				//System.err.println("need to do declare parents for: " + onType);
				for (Iterator j = newParents.iterator(); j.hasNext(); ) {
					ResolvedTypeX newParent = (ResolvedTypeX)j.next();
					if (newParent.isClass()) {
						world.showMessage(IMessage.ERROR,
							"can't use declare parents to change superclass of binary form \'" +
							onType.getName() + "\' (implementation limitation)",
							p.getSourceLocation(), null);
						continue;
					}
					
					classType.addParent(newParent);
					ResolvedTypeMunger newParentMunger = new NewParentTypeMunger(newParent);
					onType.addInterTypeMunger(new BcelTypeMunger(newParentMunger, xcutSet.findAspectDeclaringParents(p)));
				}
			}
		}
		
		for (Iterator i = typeMungerList.iterator(); i.hasNext(); ) {
			ConcreteTypeMunger m = (ConcreteTypeMunger)i.next();
			if (m.matches(onType)) {
				onType.addInterTypeMunger(m);
			}
		}
	}
================= fetch public List parseDottedNamePattern() { 45bce91^:weaver/src/org/aspectj/weaver/patterns/PatternParser.java

public List parseDottedNamePattern() {
		List names = new ArrayList();
		StringBuffer buf = new StringBuffer();
		IToken previous = null;
		while (true) {
			IToken tok;
			int startPos = tokenSource.peek().getStart();
			String afterDot = null;
			while (true) {
				tok = tokenSource.peek();
				if (previous != null) {
					if (!isAdjacent(previous, tok)) break;
				}
				if (tok.getString() == "*" || tok.isIdentifier()) {
					buf.append(tok.getString());
				} else if (tok.getLiteralKind() != null) {
					//System.err.println("literal kind: " + tok.getString());
					String s = tok.getString();
					int dot = s.indexOf('.');
					if (dot != -1) {
						buf.append(s.substring(0, dot));
						afterDot = s.substring(dot+1);
						previous = tokenSource.next();
						break;
					}
					buf.append(s);  // ??? so-so
				} else {
					break;
				}
				previous = tokenSource.next();
				//XXX need to handle floats and other fun stuff
			}
			int endPos = tokenSource.peek(-1).getEnd();
			if (buf.length() == 0 && names.isEmpty()) {
				throw new ParserException("expected name pattern", tok);
			} 
			
			if (buf.length() == 0) {
				names.add(NamePattern.ELLIPSIS);
			} else {
				checkLegalName(buf.toString(), previous);
				NamePattern ret = new NamePattern(buf.toString());
				ret.setLocation(sourceContext, startPos, endPos);
				names.add(ret);
			}
			
			if (afterDot == null) {
				buf.setLength(0);
				if (!maybeEat(".")) break;
				else previous = tokenSource.peek(-1);
			} else {
				buf.setLength(0);
				buf.append(afterDot);
				afterDot = null;
			}
		}
		//System.err.println("parsed: " + names);
		return names;
	}
================= fetch public FuzzyBoolean match(JoinPoint.StaticPart jpsp) { 10c6de6^:weaver/src/org/aspectj/weaver/patterns/Pointcut.java
// ---- test method
public static Pointcut fromString(String str) {
        PatternParser parser = new PatternParser(str);
        return parser.parsePointcut();
    }
================= fetch public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) { 10c6de6^:weaver/src/org/aspectj/weaver/patterns/IfPointcut.java

public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {
		//System.err.println("concretize: " + this + " already: " + partiallyConcretized);
		
		if (isDeclare(bindings.getEnclosingAdvice())) {
			// Enforce rule about which designators are supported in declare
			inAspect.getWorld().showMessage(IMessage.ERROR,
			  "if() pointcut designator cannot be used in declare statement",
			  bindings.getEnclosingAdvice().getSourceLocation(),
			  null);
			return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
		}
		
		if (partiallyConcretized != null) {
			return partiallyConcretized;
		}
		IfPointcut ret = new IfPointcut(testMethod, extraParameterFlags);
		partiallyConcretized = ret;
		
		// It is possible to directly code your pointcut expression in a per clause
		// rather than defining a pointcut declaration and referencing it in your
		// per clause.  If you do this, we have problems (bug #62458).  For now,
		// let's police that you are trying to code a pointcut in a per clause and
		// put out a compiler error.
		if (bindings.directlyInAdvice() && bindings.getEnclosingAdvice()==null) {
			// Assumption: if() is in a per clause if we say we are directly in advice
			// but we have no enclosing advice.
			inAspect.getWorld().showMessage(IMessage.ERROR,
				"if() pointcut designator cannot be used directly in a per clause (compiler limitation).  Create a named pointcut containing the if() and refer to it",
				this.getSourceLocation(),null);
			return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
		}
		
		if (bindings.directlyInAdvice()) {
			ShadowMunger advice = bindings.getEnclosingAdvice();
			if (advice instanceof Advice) {
				ret.baseArgsCount = ((Advice)advice).getBaseParameterCount();
			} else {
				ret.baseArgsCount = 0;
			}
			ret.residueSource = advice.getPointcut().concretize(inAspect, ret.baseArgsCount, advice);
		} else {
			ResolvedPointcutDefinition def = bindings.peekEnclosingDefinitition();
			if (def == CflowPointcut.CFLOW_MARKER) {
				inAspect.getWorld().showMessage(IMessage.ERROR,
					"if not supported lexically within cflow (compiler limitation)",
					getSourceLocation(), null);
				return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
			}
			ret.baseArgsCount = def.getParameterTypes().length;
			
			IntMap newBindings = IntMap.idMap(ret.baseArgsCount);
			newBindings.copyContext(bindings);
			ret.residueSource = def.getPointcut().concretize(inAspect, newBindings);
		}
		
		return ret;
	}
================= fetch public Pointcut maybeGetParsedPointcut() { 10c6de6^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/IfPseudoToken.java

public Pointcut maybeGetParsedPointcut() {
		pointcut = new IfPointcut(new ResolvedMember(Member.METHOD, TypeX.OBJECT, 0, "if_", "()V"), 0);
		return pointcut;
	}
================= fetch public static Pointcut makeMatchesNothing(State state) { 10c6de6^:weaver/src/org/aspectj/weaver/patterns/Pointcut.java
//??? there could possibly be some good optimizations to be done at this point
static Pointcut makeMatchesNothing(State state) {
    	Pointcut ret = new MatchesNothingPointcut();
    	ret.state = state;
    	return ret;
    }
================= fetch public static Pointcut read(DataInputStream s, ISourceContext context) throws IO 10c6de6^:weaver/src/org/aspectj/weaver/patterns/Pointcut.java

public static Pointcut read(DataInputStream s, ISourceContext context) throws IOException {
		byte kind = s.readByte();
		Pointcut ret;
		
		switch(kind) {
			case KINDED: ret = KindedPointcut.read(s, context); break;
			case WITHIN: ret = WithinPointcut.read(s, context); break;
			case THIS_OR_TARGET: ret = ThisOrTargetPointcut.read(s, context); break;
			case ARGS: ret = ArgsPointcut.read(s, context); break;
			case AND: ret = AndPointcut.read(s, context); break;
			case OR: ret = OrPointcut.read(s, context); break;
			case NOT: ret = NotPointcut.read(s, context); break;
			case REFERENCE: ret = ReferencePointcut.read(s, context); break;
			case IF: ret = IfPointcut.read(s, context); break;
			case CFLOW: ret = CflowPointcut.read(s, context); break;
			case WITHINCODE: ret = WithincodePointcut.read(s, context); break;
			case HANDLER: ret = HandlerPointcut.read(s, context); break;
			
			case NONE: ret = makeMatchesNothing(RESOLVED); break;
			default:
				throw new BCException("unknown kind: " + kind);
		}
		ret.state = RESOLVED;
		return ret;
	}
================= fetch private ReferenceContext findReferenceContextFor(CompilationResult result) { 573741c^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java

private IProblem[] buildSeeAlsoProblems(List sourceLocations,
											CompilationResult problemSource,
											boolean usedBinarySourceFileName) {
		int probLength = sourceLocations.size();
		if (usedBinarySourceFileName) probLength++;
		IProblem[] ret = new IProblem[probLength];
		for (int i = 0; i < sourceLocations.size(); i++) {
			ISourceLocation loc = (ISourceLocation) sourceLocations.get(i);
			ret[i] = new DefaultProblem(loc.getSourceFile().getPath().toCharArray(),
										"see also",
										0,
										new String[] {},
										ProblemSeverities.Ignore,
										getStartPos(loc,null),
										getEndPos(loc,null),
										loc.getLine());
		}
		if (usedBinarySourceFileName) {
			ret[ret.length -1] = new DefaultProblem(problemSource.fileName,"see also",0,new String[] {},
													ProblemSeverities.Ignore,0,
													0,0);
		}
		return ret;
	}
================= fetch public void checkInterTypeMungers() { 573741c^:weaver/src/org/aspectj/weaver/ResolvedTypeX.java
/**
     * Check that we don't have any abstract type mungers unless this
     * type is abstract.
     */
public void checkInterTypeMungers() {
        if (isAbstract()) return;
        
        for (Iterator iter = getInterTypeMungersIncludingSupers().iterator(); iter.hasNext();) {
			ConcreteTypeMunger element = (ConcreteTypeMunger) iter.next();
            if (element.getSignature() != null && element.getSignature().isAbstract()) {
                world.getMessageHandler().handleMessage(
                    new Message("must implement abstract inter-type declaration: " + element.getSignature(),
                        "", IMessage.ERROR, getSourceLocation(), null, 
                        new ISourceLocation[] { element.getSourceLocation() }));
            }
		}
    }
Progress : [####################################----] 91%================= fetch protected void showWarning(String message) { 6ea8300^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java

protected void showWarning(String message) {
			ISourceLocation location = null;
			if (buildConfig.getConfigFile() != null) {
				location = new SourceLocation(buildConfig.getConfigFile(), 0); 
			} 
			IMessage errorMessage = new Message(CONFIG_MSG + message, IMessage.WARNING, null, location);
			handler.handleMessage(errorMessage);
//            MessageUtil.warn(handler, message);
        }
================= fetch public boolean runCommand(String[] args, IMessageHandler handler) { 6ea8300^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java

public boolean runCommand(String[] args, IMessageHandler handler) {
		buildManager = new AjBuildManager(handler); 
		savedArgs = new String[args.length];
        System.arraycopy(args, 0, savedArgs, 0, savedArgs.length);
        for (int i = 0; i < args.length; i++) {
            if ("-help".equals(args[i])) {
                // should be info, but handler usually suppresses
                MessageUtil.abort(handler, BuildArgParser.getUsage());
                return true;
            }
        }
        return doCommand(handler, false);
    }
================= fetch public static String getUsage() { 6ea8300^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java

public static String getUsage() {   
        return Main.bind("misc.usage");
    }
================= fetch public static Test suite() { 6ea8300^:org.aspectj.ajdt.core/testsrc/EajcModuleTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(EajcModuleTests.class.getName());
        suite.addTest(org.aspectj.ajdt.ajc.AjdtAjcTests.suite()); 
        suite.addTest(org.aspectj.ajdt.internal.compiler.batch.AjdtBatchTests.suite()); 
        suite.addTest(org.aspectj.ajdt.internal.core.builder.AjdtBuilderTests.suite()); 
        return suite;
    }
================= fetch public void run(String[] args, IMessageHolder holder) { 6ea8300^:org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java
/**
     * Run without using System.exit(..), putting all messages in holder:
     * <ul>
     * <li>ERROR: compiler error</li>
     * <li>WARNING: compiler warning</li>
     * <li>FAIL: command error (bad arguments, exception thrown)</li>
     * </ul>
     * This handles incremental behavior:
     * <ul>
     * <li>If args include "-incremental", repeat for every input char
     *     until 'q' is entered.<li>
     * <li>If args include "-incrementalTagFile {file}", repeat every time
     *     we detect that {file} modification time has changed. </li>
     * <li>Either way, list files recompiled each time if args includes "-verbose".</li>
     * <li>Exit when the commmand/compiler throws any Throwable.</li>
     * </ul>
     * When complete, this contains all the messages of the final
     * run of the command and/or any FAIL messages produced in running
     * the command, including any Throwable thrown by the command itself.
     * 
     * @param args the String[] command line for the compiler
     * @param holder the MessageHandler sink for messages.
     */
public void run(String[] args, IMessageHolder holder) {
        if (LangUtil.isEmpty(args)) {
            args = new String[] { "-help" };
        }  else if (controller.running()) {
            fail(holder, "already running with controller: " + controller, null);
            return;
        } 
        args = controller.init(args, holder);
        if (0 < holder.numMessages(IMessage.ERROR, true)) {
            return;
        }      
        ICommand command = ReflectionFactory.makeCommand(commandName, holder);
        if (0 < holder.numMessages(IMessage.ERROR, true)) {
            return;
        }      
        try {
//            boolean verbose = (-1 != ("" + Arrays.asList(args)).indexOf("-verbose"));
            outer:
            while (true) {
                boolean passed = command.runCommand(args, holder);
                if (report(passed, holder) && controller.incremental()) {
//                    final boolean onCommandLine = controller.commandLineIncremental();
                    while (controller.doRepeatCommand()) {
                        holder.clearMessages();
                        if (controller.buildFresh()) {
                            continue outer;
                        } else {
                            passed = command.repeatCommand(holder);
                        }
                        if (!report(passed, holder)) {
                            break;
                        }
                    }
                }
                break;
            }
        } catch (AbortException ae) {
        	if (ae.isSilent()) { 
        		quit();
        	} else {
                IMessage message = ae.getIMessage();
                Throwable thrown = ae.getThrown();
                if (null == thrown) { // toss AbortException wrapper
                    if (null != message) {
                        holder.handleMessage(message);
                    } else {
                        fail(holder, "abort without message", ae);
                    }
                } else if (null == message) {
                    fail(holder, "aborted", thrown);
                } else {
                    String mssg = MessageUtil.MESSAGE_MOST.renderToString(message);
                    fail(holder, mssg, thrown);
                }
        	}
    	} catch (Throwable t) {
            fail(holder, "unexpected exception", t);
        }
    }
================= fetch public void testMainbare() { 6ea8300^:org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/MainTest.java

public void testMainbare() {
        ArrayList list = new ArrayList();
        Main.bareMain(new String[] {"-help"}, false, list, null, null, null);
        assertTrue(1 == list.size());
        Object o = list.get(0);
        assertTrue(o instanceof String);
        assertTrue(-1 != ((String)o).indexOf("-aspectpath"));
        assertTrue(-1 != ((String)o).indexOf("-incremental"));
    }
================= fetch private boolean compareToExistingMembers(ConcreteTypeMunger munger, Iterator exi b184363^:weaver/src/org/aspectj/weaver/ResolvedTypeX.java
//??? returning too soon
private boolean compareToExistingMembers(ConcreteTypeMunger munger, Iterator existingMembers) {
		ResolvedMember sig = munger.getSignature();
		while (existingMembers.hasNext()) {
			ResolvedMember existingMember = (ResolvedMember)existingMembers.next();
			
			if (conflictingSignature(existingMember, munger.getSignature())) {
				//System.err.println("conflict: " + existingMember + " with " + munger);
				//System.err.println(munger.getSourceLocation() + ", " + munger.getSignature() + ", " + munger.getSignature().getSourceLocation());
				
				if (isVisible(existingMember.getModifiers(), this, munger.getAspectType())) {
					int c = compareMemberPrecedence(sig, existingMember);
					//System.err.println("   c: " + c);
					if (c < 0) {
						// existingMember dominates munger
						checkLegalOverride(munger.getSignature(), existingMember);
						return false;
					} else if (c > 0) {
						// munger dominates existingMember
						checkLegalOverride(existingMember, munger.getSignature());
						//interTypeMungers.add(munger);  
						//??? might need list of these overridden abstracts
						continue;
					} else {
						//XXX dual errors possible if (this instanceof BcelObjectType) return false;  //XXX ignores separate comp
						getWorld().getMessageHandler().handleMessage(
							MessageUtil.error("inter-type declaration from " + munger.getAspectType().getName() +
											" conflicts with existing member: " + existingMember,
											munger.getSourceLocation())
						);
					}
				} else {
					//interTypeMungers.add(munger);
				}
				//return;
			}
		}
		return true;
	}
================= fetch public boolean checkLegalOverride(ResolvedMember parent, ResolvedMember child) { b184363^:weaver/src/org/aspectj/weaver/ResolvedTypeX.java

public boolean checkLegalOverride(ResolvedMember parent, ResolvedMember child) {
		//System.err.println("check: " + child.getDeclaringType() + " overrides " + parent.getDeclaringType());
		if (!parent.getReturnType().equals(child.getReturnType())) {
			world.showMessage(IMessage.ERROR,
				"can't override " + parent +
				" with " + child + " return types don't match",
				child.getSourceLocation(), parent.getSourceLocation());
			return false;
		}		
		if (parent.getKind() == Member.POINTCUT) {
			TypeX[] pTypes = parent.getParameterTypes();
			TypeX[] cTypes = child.getParameterTypes();
			if (!Arrays.equals(pTypes, cTypes)) {
				world.showMessage(IMessage.ERROR,
					"can't override " + parent +
					" with " + child + " parameter types don't match",
					child.getSourceLocation(), parent.getSourceLocation());
				return false;
			}
		}		
		//System.err.println("check: " + child.getModifiers() + " more visible " + parent.getModifiers());
		if (isMoreVisible(parent.getModifiers(), child.getModifiers())) {
			world.showMessage(IMessage.ERROR,
				"can't override " + parent +
				" with " + child + " visibility is reduced",
				child.getSourceLocation(), parent.getSourceLocation());
			return false;
		}
		
		// check declared exceptions
		ResolvedTypeX[] childExceptions = world.resolve(child.getExceptions());
		ResolvedTypeX[] parentExceptions = world.resolve(parent.getExceptions());
		ResolvedTypeX runtimeException = world.resolve("java.lang.RuntimeException");
		ResolvedTypeX error = world.resolve("java.lang.Error");
		
		outer: for (int i=0, leni = childExceptions.length; i < leni; i++) {
			//System.err.println("checking: " + childExceptions[i]);
			if (runtimeException.isAssignableFrom(childExceptions[i])) continue;
			if (error.isAssignableFrom(childExceptions[i])) continue;
			
			for (int j = 0, lenj = parentExceptions.length; j < lenj; j++) {
				if (parentExceptions[j].isAssignableFrom(childExceptions[i])) continue outer;
			}
			
			world.showMessage(IMessage.ERROR, "overriden method doesn't throw " 
					+ childExceptions[i].getName(), child.getSourceLocation(), null);
						
			return false;
		}
		
		return true;
		
	}
================= fetch public TypePattern resolveBindings(IScope scope, Bindings bindings, 936459c^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
/**
	 * Need to determine if I'm really a pattern or a reference to a formal
	 * 
	 * We may wish to further optimize the case of pattern vs. non-pattern
	 * 
	 * We will be replaced by what we return
	 */
public TypePattern resolveBindings(IScope scope, Bindings bindings, 
    								boolean allowBinding, boolean requireExactType)
    { 		
    	if (isStar()) {
			return TypePattern.ANY;  //??? loses source location
		}

		String simpleName = maybeGetSimpleName();
		if (simpleName != null) {
			FormalBinding formalBinding = scope.lookupFormal(simpleName);
			if (formalBinding != null) {
				if (bindings == null) {
					scope.message(IMessage.ERROR, this, "negation doesn't allow binding");
					return this;
				}
				if (!allowBinding) {
					scope.message(IMessage.ERROR, this, 
						"name binding only allowed in target, this, and args pcds");
					return this;
				}
				
				BindingTypePattern binding = new BindingTypePattern(formalBinding);
				binding.copyLocationFrom(this);
				bindings.register(binding, scope);
				
				return binding;
			}
		}
		
		String cleanName = maybeGetCleanName();
		if (cleanName != null) {
			TypeX type;
			
			//System.out.println("resolve: " + cleanName);
			//??? this loop has too many inefficiencies to count
			while ((type = scope.lookupType(cleanName, this)) == ResolvedTypeX.MISSING) {
				int lastDot = cleanName.lastIndexOf('.');
				if (lastDot == -1) break;
				cleanName = cleanName.substring(0, lastDot) + '$' + cleanName.substring(lastDot+1);
			}
			if (type == ResolvedTypeX.MISSING) {
				if (requireExactType) {
					if (!allowBinding) {
						scope.getWorld().getMessageHandler().handleMessage(
							MessageUtil.error("can't bind type name '" + cleanName + "'",
											getSourceLocation()));
					} else if (scope.getWorld().getLint().invalidAbsoluteTypeName.isEnabled()) {
						scope.getWorld().getLint().invalidAbsoluteTypeName.signal(cleanName, getSourceLocation());
					}
					return NO;
				} else if (scope.getWorld().getLint().invalidAbsoluteTypeName.isEnabled()) {
					scope.getWorld().getLint().invalidAbsoluteTypeName.signal(cleanName, getSourceLocation());
				}
			} else {
				if (dim != 0) type = TypeX.makeArray(type, dim);
				TypePattern ret = new ExactTypePattern(type, includeSubtypes);
				ret.copyLocationFrom(this);
				return ret;
			}
		} else {
			if (requireExactType) {
				scope.getWorld().getMessageHandler().handleMessage(
					MessageUtil.error("wildcard type pattern not allowed, must use type name",
										getSourceLocation()));
				return NO;
			}
			//XXX need to implement behavior for Lint.invalidWildcardTypeName
		}
		
		importedPrefixes = scope.getImportedPrefixes();
		knownMatches = preMatch(scope.getImportedNames());
		
		return this;
	}
================= fetch public int compareByDominates(ResolvedTypeX aspect1, ResolvedTypeX aspect2) { 75852d7^:weaver/src/org/aspectj/weaver/World.java
/**
	 * Same signature as org.aspectj.util.PartialOrder.PartialComparable.compareTo
	 */
public int compareByDominates(ResolvedTypeX aspect1, ResolvedTypeX aspect2) {
		//System.out.println("dom compare: " + aspect1 + " with " + aspect2);
		//System.out.println(crosscuttingMembersSet.getDeclareDominates());
		
		//??? We probably want to cache this result.  This is order N where N is the
		//??? number of dominates declares in the whole system.
		//??? This method can be called a large number of times.
		int order = 0;
		for (Iterator i = crosscuttingMembersSet.getDeclareDominates().iterator(); i.hasNext(); ) {
			DeclarePrecedence d = (DeclarePrecedence)i.next();
			int thisOrder = d.compare(aspect1, aspect2);
			//System.out.println("comparing: " + thisOrder + ": " + d);
			if (thisOrder != 0) {
				if (order != 0 && order != thisOrder) {
					throw new BCException("conflicting dominates orders");
				} else {
					order = thisOrder;
				}
			}
		}
		
		
		return order; 
	}
================= fetch private static String constructNestedTypeName(IProgramElement node) { 8dc0845^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java

private static String constructNestedTypeName(IProgramElement node) {
    	if (node.getParent().getKind().isSourceFile()) {
    		return node.getName();
    	} else {
			String nodeName = "";
			if (node.getKind().isType()) nodeName += '.' + node.getName();
			return constructNestedTypeName(node.getParent()) + nodeName;
    	}
	}
================= fetch public void testCoverage() { 8dc0845^:ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java

public void testCoverage() {
		  
//		System.err.println(new File("testdata/figures-demo").exists());
		File file0 = new File("testdata/coverage/InDefaultPackage.java");
		File file1 = new File("testdata/coverage/foo/ClassA.java");
		File aspect1 = new File("testdata/coverage/foo/UseThisAspectForLinkCheck.aj");
		File file2 = new File("testdata/coverage/foo/InterfaceI.java");
		File file3 = new File("testdata/coverage/foo/PlainJava.java");
		File file4 = new File("testdata/coverage/foo/ModelCoverage.java");
		File file5 = new File("testdata/coverage/fluffy/Fluffy.java");
		File file6 = new File("testdata/coverage/fluffy/bunny/Bunny.java");
		File file7 = new File("testdata/coverage/fluffy/bunny/rocks/Rocks.java");
		File file8 = new File("testdata/coverage/fluffy/bunny/rocks/UseThisAspectForLinkCheckToo.java");
		File outdir = new File("testdata/coverage/doc");
		    
		String[] args = { 
//			"-XajdocDebug",
			"-source", 
			"1.4",
			"-private",
			"-d", 
			outdir.getAbsolutePath(),
			aspect1.getAbsolutePath(), 
			file0.getAbsolutePath(), 
			file1.getAbsolutePath(), 
			file2.getAbsolutePath(),
			file3.getAbsolutePath(),
			file4.getAbsolutePath(),
			file5.getAbsolutePath(),
			file6.getAbsolutePath(),
			file7.getAbsolutePath(),
			file8.getAbsolutePath()
		};
		
		org.aspectj.tools.ajdoc.Main.main(args);
	}
================= fetch public void testSimpleExample() { 8dc0845^:ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.java

public void testSimpleExample() {
		
//		System.err.println(new File("testdata/figures-demo").exists());
		File outdir = new File("testdata/spacewar/docdir");
		File sourcepath = new File("testdata/spacewar");
		
		String[] args = { "-d", 
				outdir.getAbsolutePath(),
				"-sourcepath",
				sourcepath.getAbsolutePath(),
				"spacewar",
				"coordination" };
		
		org.aspectj.tools.ajdoc.Main.main(args);
		
		assertTrue(true);
	}
================= fetch static void decorateHTMLFile(File file) throws IOException { 8dc0845^:ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java

static void decorateHTMLFile(File file) throws IOException {
        System.out.println( "> Decorating " + file.getCanonicalPath() + "..." );
        BufferedReader reader = new BufferedReader(new FileReader(file));
        StringBuffer fileContents = new StringBuffer();
        String line = reader.readLine();
        while( line != null ) {
            fileContents.append(line + "\n");
            line = reader.readLine();
        }

        boolean isSecond = false;
        int index = 0;
        IProgramElement decl;
        while ( true ) {

            //---this next part is an inlined procedure that returns two values---
            //---the next declaration and the index at which that declaration's---
            //---DeclID sits in the .html file                                 ---
            String contents = fileContents.toString();
            int start = contents.indexOf( Config.DECL_ID_STRING, index);
            int end   = contents.indexOf( Config.DECL_ID_TERMINATOR, index );
            if ( start == -1 )
                decl = null;
================= fetch public void testCoverage() { 2cc4826^:ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java

public void testCoverage() {
		  
//		System.err.println(new File("testdata/figures-demo").exists());
		File file1 = new File("testdata/coverage/foo/ClassA.java");
		File aspect1 = new File("testdata/coverage/foo/UseThisAspectForLinkCheck.aj");
		File file2 = new File("testdata/coverage/foo/InterfaceI.java");
		File file3 = new File("testdata/coverage/foo/PlainJava.java");
		File file4 = new File("testdata/coverage/foo/ModelCoverage.java");
		File file5 = new File("testdata/coverage/fluffy/Fluffy.java");
		File file6 = new File("testdata/coverage/fluffy/bunny/Bunny.java");
		File file7 = new File("testdata/coverage/fluffy/bunny/rocks/Rocks.java");
		File file8 = new File("testdata/coverage/fluffy/bunny/rocks/UseThisAspectForLinkCheckToo.java");
		File outdir = new File("testdata/coverage/doc");
		    
		String[] args = { 
//			"-XajdocDebug",
			"-source", 
			"1.4",
			"-private",
			"-d", 
			outdir.getAbsolutePath(),
			aspect1.getAbsolutePath(),  
			file1.getAbsolutePath(), 
			file2.getAbsolutePath(),
			file3.getAbsolutePath(),
			file4.getAbsolutePath(),
			file5.getAbsolutePath(),
			file6.getAbsolutePath(),
			file7.getAbsolutePath(),
			file8.getAbsolutePath()
		};
		
		org.aspectj.tools.ajdoc.Main.main(args);
	}
================= fetch static void processFile(SymbolManager symbolManager, File inputFile, File signat 2cc4826^:ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java

static void processFile(SymbolManager symbolManager, File inputFile, File signatureFile) {
        try {
        	String path = StructureUtil.translateAjPathName(signatureFile.getCanonicalPath());
            PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(path)));
             
            String packageName = StructureUtil.getPackageDeclarationFromFile(inputFile);
            
            if (packageName != null ) {
                writer.println( "package " + packageName + ";" );
            }

           	IProgramElement fileNode = (IProgramElement)AsmManager.getDefault().getHierarchy().findElementForSourceFile(inputFile.getAbsolutePath());
        	for (Iterator it = fileNode.getChildren().iterator(); it.hasNext(); ) {
        		IProgramElement node = (IProgramElement)it.next();
        		if (node.getKind().equals(IProgramElement.Kind.IMPORT_REFERENCE)) {
        			processImportDeclaration(node, writer);
        		} else {
        			processTypeDeclaration(node, writer);
        		}
        	}
           	
            // if we got an error we don't want the contents of the file
            writer.close(); 
        } catch (IOException e) {
            System.err.println(e.getMessage());
            e.printStackTrace();
        } 
    }
Progress : [####################################----] 92%================= fetch private static void removeDeclIDsFromFile(String filename, boolean relativePath) 3707411^:ajdoc/src/org/aspectj/tools/ajdoc/Main.java

static void removeDeclIDsFromFile(String filename, boolean relativePath) {
        // Remove the decl ids from "index-all.html"
        File indexFile;
        if (relativePath) {
        	indexFile = new File(docDir + Config.DIR_SEP_CHAR + filename);
        } else {
        	indexFile = new File(filename);
        }
        try {
        if ( indexFile.exists() ) {
            BufferedReader indexFileReader = new BufferedReader( new FileReader( indexFile ) );
            String indexFileBuffer = "";
            String line = indexFileReader.readLine();
            while ( line != null ) {
              int indexStart = line.indexOf( Config.DECL_ID_STRING );
              int indexEnd   = line.indexOf( Config.DECL_ID_TERMINATOR );
              if ( indexStart != -1 && indexEnd != -1 ) {
                line = line.substring( 0, indexStart ) +
                       line.substring( indexEnd+Config.DECL_ID_TERMINATOR.length() );
              }
              indexFileBuffer += line;
              line = indexFileReader.readLine();
            }
            FileOutputStream fos = new FileOutputStream( indexFile );
            fos.write( indexFileBuffer.getBytes() );
        }
        }
        catch (IOException ioe) {
              // be siltent
        }
    }
================= fetch public boolean accept( File dir, String name ) { 3707411^:ajdoc/src/org/aspectj/tools/ajdoc/Main.java

================= fetch public static boolean isAnonymous(IProgramElement node) { 3707411^:ajdoc/src/org/aspectj/tools/ajdoc/StructureUtil.java

public static boolean isAnonymous(IProgramElement node) {
		boolean isIntName = true;
		try {
			Integer.valueOf(node.getName());
		} catch (NumberFormatException nfe) {
			// !!! using exceptions for logic, fix
			isIntName = false;
		}
//		System.err.println(">>>>>>>> " + node.getName());
		return isIntName || node.getName().startsWith("new ");
//		return isIntName;
//		if (!isIntName) {
//			 
//			return node.getName().startsWith("new ");
//		} else {
//			return false; 
//		}
	}
================= fetch public static void main(String[] args) { 3707411^:ajdoc/src/org/aspectj/tools/ajdoc/Main.java

public static void main(String[] args) {
    	clearState();
//    	if (!JavadocRunner.has14ToolsAvailable()) {
//    		System.err.println("ajdoc requires a JDK 1.4 or later tools jar - exiting");
//    		aborted = true;
//    		return;
//    	}
    	  
        // STEP 1: parse the command line and do other global setup
        sourcepath.addElement("."); // add the current directory to the classapth
        parseCommandLine(args);  
        rootDir = getRootDir();
        symbolManager = SymbolManager.getDefault();
        File[] inputFiles      = new File[filenames.size()];
        File[] signatureFiles  = new File[filenames.size()];
        try {
            // create the workingdir if it doesn't exist
            if ( !(new File( Config.WORKING_DIR ).isDirectory()) ) {
                File dir = new File( Config.WORKING_DIR );
                dir.mkdir();
                if (deleteTempFilesOnExit) dir.deleteOnExit();
            }

            for (int i = 0; i < filenames.size(); i++) {
                inputFiles[i]     = findFile((String)filenames.elementAt(i));
                //signatureFiles[i] = createSignatureFile(inputFiles[i]);
            }

            // PHASE 0: call ajc
            ajcOptions.addElement("-noExit");
			ajcOptions.addElement("-XjavadocsInModel");  	// TODO: wrong option to force model gen
            ajcOptions.addElement("-d"); 
            ajcOptions.addElement(rootDir.getAbsolutePath());
			String[] argsToCompiler = new String[ajcOptions.size() + inputFiles.length];
            int i = 0;
            for ( ; i < ajcOptions.size(); i++ ) {
                argsToCompiler[i] = (String)ajcOptions.elementAt(i);
            }
            for ( int j = 0; j < inputFiles.length; j++) {
                argsToCompiler[i] = inputFiles[j].getAbsolutePath();
                //System.out.println(">> file to ajc: " + inputFiles[j].getAbsolutePath());
                i++;
            }

//            System.out.println(Arrays.asList(argsToCompiler));
            System.out.println( "> Calling ajc..." );
            CompilerWrapper.main(argsToCompiler);
            if (CompilerWrapper.hasErrors()) {
            	System.out.println(FAIL_MESSAGE);
            	aborted = true;
            	return;
            }
/*
            for (int ii = 0; ii < inputFiles.length; ii++) {
                String tempFP = inputFiles[ii].getAbsolutePath();
                tempFP = tempFP.substring(0, tempFP.length()-4);
                tempFP += "ajsym";
                System.out.println( ">> checking: " + tempFP);
                File tempF = new File(tempFP);
                if ( !tempF.exists() ) System.out.println( ">>> doesn't exist!" );
            }
*/
            for (int ii = 0; ii < filenames.size(); ii++) {
                signatureFiles[ii] = createSignatureFile(inputFiles[ii]);
            }

            // PHASE 1: generate Signature files (Java with DeclIDs and no bodies).
            System.out.println( "> Building signature files..." );
            StubFileGenerator.doFiles(declIDTable, symbolManager, inputFiles, signatureFiles);

            // PHASE 2: let Javadoc generate HTML (with DeclIDs)
            System.out.println( "> Calling javadoc..." );
            String[] javadocargs = null;
            if ( packageMode ) {
                int numExtraArgs = 2;
                if (authorStandardDocletSwitch) numExtraArgs++;
                if (versionStandardDocletSwitch) numExtraArgs++;
                javadocargs = new String[numExtraArgs + options.size() + packageList.size() +
                                         fileList.size() ];
                javadocargs[0] = "-sourcepath";
                javadocargs[1] = Config.WORKING_DIR;
                int argIndex = 2;
                if (authorStandardDocletSwitch) {
                    javadocargs[argIndex] = "-author";
                    argIndex++;
                }
                if (versionStandardDocletSwitch) {
                    javadocargs[argIndex] = "-version";
                }
                //javadocargs[1] = getSourcepathAsString();
                for (int k = 0; k < options.size(); k++) {
                    javadocargs[numExtraArgs+k] = (String)options.elementAt(k);
                }
                for (int k = 0; k < packageList.size(); k++) {
                    javadocargs[numExtraArgs+options.size() + k] = (String)packageList.elementAt(k);
                }
                for (int k = 0; k < fileList.size(); k++) {
                    javadocargs[numExtraArgs+options.size() + packageList.size() + k] = (String)fileList.elementAt(k);
                }
            }
            else {
                javadocargs = new String[options.size() + signatureFiles.length];
                for (int k = 0; k < options.size(); k++) {
                    javadocargs[k] = (String)options.elementAt(k);
                }
                for (int k = 0; k < signatureFiles.length; k++) {
                    javadocargs[options.size() + k] = signatureFiles[k].getCanonicalPath();
                }
            }
         
            JavadocRunner.callJavadoc(javadocargs);
            //for ( int o = 0; o < inputFiles.length; o++ ) {
            //    System.out.println( "file: " + inputFiles[o] );
            //}

            // PHASE 3: add AspectDoc specific stuff to the HTML (and remove the DeclIDS).
            /** We start with the known HTML files (the ones that correspond directly to the
            * input files.)  As we go along, we may learn that Javadoc split one .java file
            * into multiple .html files to handle inner classes or local classes.  The html
            * file decorator picks that up.
            */
            System.out.println( "> Decorating html files..." );
            HtmlDecorator.decorateHTMLFromInputFiles(declIDTable,
                                              rootDir,
                                              symbolManager,
                                              inputFiles,
                                              docModifier); 
            
            System.out.println( "> Removing generated tags (this may take a while)..." );
            removeDeclIDsFromFile("index-all.html", true);
            removeDeclIDsFromFile("serialized-form.html", true);
            if (packageList.size() > 0) {
	            for (int p = 0; p < packageList.size(); p++) {
	                removeDeclIDsFromFile(((String)packageList.elementAt(p)).replace('.','/') +
	                                       Config.DIR_SEP_CHAR +
	                                       "package-summary.html", true);
	            }
            } else {
            	File[] files = FileUtil.listFiles(rootDir, new FileFilter() {
================= fetch public void testCoverage() { 3707411^:ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java

public void testCoverage() {
		  
//		System.err.println(new File("testdata/figures-demo").exists());
		File file1 = new File("testdata/coverage/foo/ClassA.java");
		File aspect1 = new File("testdata/coverage/foo/UseThisAspectForLinkCheck.java");
		File file2 = new File("testdata/coverage/foo/InterfaceI.java");
		File file3 = new File("testdata/coverage/foo/PlainJava.java");
		File file4 = new File("testdata/coverage/foo/ModelCoverage.java");
		File file5 = new File("testdata/coverage/fluffy/Fluffy.java");
		File file6 = new File("testdata/coverage/fluffy/bunny/Bunny.java");
		File file7 = new File("testdata/coverage/fluffy/bunny/rocks/Rocks.java");
		File file8 = new File("testdata/coverage/fluffy/bunny/rocks/UseThisAspectForLinkCheckToo.java");
		File outdir = new File("testdata/coverage/doc");
		
		String[] args = { 
//			"-XajdocDebug",
			"-source", 
			"1.4",
			"-private",
			"-d", 
			outdir.getAbsolutePath(),
			aspect1.getAbsolutePath(),
			file1.getAbsolutePath(), 
			file2.getAbsolutePath(),
			file3.getAbsolutePath(),
			file4.getAbsolutePath(),
			file5.getAbsolutePath(),
			file6.getAbsolutePath(),
			file7.getAbsolutePath(),
			file8.getAbsolutePath()
		};
		
		org.aspectj.tools.ajdoc.Main.main(args);
	}
================= fetch static void parseArgs(List vargs, File currentWorkingDir) { 3707411^:ajdoc/src/org/aspectj/tools/ajdoc/Main.java

static void parseArgs(List vargs, File currentWorkingDir) {
        boolean addNextAsOption     = false;
        boolean addNextAsArgFile    = false;
        boolean addNextToAJCOptions = false;
        boolean addNextAsDocDir     = false;
        boolean addNextAsClasspath  = false;
        boolean ignoreArg           = false;  // used for discrepancy betwen class/sourcepath in ajc/javadoc
        boolean addNextAsSourcePath = false;
        if ( vargs.size() == 0 ) {
            displayHelpAndExit( null );
        }
        for (int i = 0; i < vargs.size() ; i++) {
            String arg = (String)vargs.get(i);
            ignoreArg = false;
            if ( addNextToAJCOptions ) {
                ajcOptions.addElement( arg );
                addNextToAJCOptions = false;
            }
            if ( addNextAsDocDir ) {
                docDir = arg;
                addNextAsDocDir = false;
            }
            if ( addNextAsClasspath ) {
                addNextAsClasspath = false;
            }
            if ( addNextAsSourcePath ) {
                setSourcepath( arg );
                addNextAsSourcePath = false;
                ignoreArg = true;
            }
            if ( arg.startsWith("@") ) {
                expandAtSignFile(arg.substring(1), currentWorkingDir);
            }
================= fetch static void parseCommandLine(String[] args) { 3707411^:ajdoc/src/org/aspectj/tools/ajdoc/Main.java
/**
     * Can read Eclipse-generated single-line arg
     */
static void parseCommandLine(String[] args) {
        if (args.length == 0) {
            displayHelpAndExit( null );
        } else if (args.length == 1 && args[0].startsWith("@")) {
        	String argFile = args[0].substring(1);
        	System.out.println("> Using arg file: " + argFile);  
        	BufferedReader br;
			try {
				br = new BufferedReader(new FileReader(argFile));
				String line = "";
	        	line = br.readLine();
	        	StringTokenizer st = new StringTokenizer(line, " ");
	        	List argList = new ArrayList();
	        	while(st.hasMoreElements()) {
	        		argList.add((String)st.nextElement());
	        	}
	        	//System.err.println(argList);
	        	args = new String[argList.size()];
	        	int counter = 0;
	        	for (Iterator it = argList.iterator(); it.hasNext(); ) {
	        		args[counter] = (String)it.next();
	        		counter++;
	        	}
			} catch (FileNotFoundException e) {
				System.err.println("> could not read arg file: " + argFile);
				e.printStackTrace();
			} catch (IOException ioe) {
				System.err.println("> could not read arg file: " + argFile);
				ioe.printStackTrace();
			}

        	
        }
        List vargs = new LinkedList(Arrays.asList(args));

        parseArgs(vargs, new File( "." ));  // !!!

        if (filenames.size() == 0) {
            displayHelpAndExit( "ajdoc: No packages or classes specified" );
        }
    }
================= fetch static void processFile(SymbolManager symbolManager, File inputFile, File signat 3707411^:ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java

static void processFile(SymbolManager symbolManager, File inputFile, File signatureFile) {
        try {
            PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(signatureFile.getCanonicalPath())));
            
            String packageName = StructureUtil.getPackageDeclarationFromFile(inputFile);
            
            if (packageName != null ) {
                writer.println( "package " + packageName + ";" );
            }

           	IProgramElement fileNode = (IProgramElement)AsmManager.getDefault().getHierarchy().findElementForSourceFile(inputFile.getAbsolutePath());
        	for (Iterator it = fileNode.getChildren().iterator(); it.hasNext(); ) {
        		IProgramElement node = (IProgramElement)it.next();
        		if (node.getKind().equals(IProgramElement.Kind.IMPORT_REFERENCE)) {
        			processImportDeclaration(node, writer);
        		} else {
        			processTypeDeclaration(node, writer);
        		}
        	}
           	
            // if we got an error we don't want the contents of the file
            writer.close(); 
        } catch (IOException e) {
            System.err.println(e.getMessage());
            e.printStackTrace();
        } 
    }
================= fetch public boolean onWindowsPro() { 39c3a3b^:build/src/$/org/aspectj/Main.java

================= fetch public boolean handleMessage(IMessage message) throws AbortException { 9ebfc84^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java

private static List makeClasspath(String cp) {
		List ret = new ArrayList();
		if (cp != null) {
			StringTokenizer tok = new StringTokenizer(cp,File.pathSeparator);
			while (tok.hasMoreTokens()) {
				ret.add(tok.nextToken());
			}
		}
		return ret;
	}
================= fetch public boolean isIgnoring(Kind kind) { 9ebfc84^:weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java

public boolean isIgnoring(Kind kind) {
			return ((kind == IMessage.INFO) || (kind == IMessage.DEBUG));
		}
================= fetch public static void makeURLWeavingClassLoaderJars() throws IOException { 9ebfc84^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java

public static void makeURLWeavingClassLoaderJars() throws IOException {
		List args = new ArrayList();

		/*
		 * Vanilla classes
		 */
		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../weaver/testdata/ltw-classes.jar");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWHelloWorld.java");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/ltw/LTWPackageTest.java");
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);

		/* 
		 * Woven classes
		 */
		args = new ArrayList();
		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../weaver/testdata/ltw-woven.jar");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWHelloWorld.java");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWAspect.aj");
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);

		/*
		 * Advice
		 */
		args = new ArrayList();
		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../weaver/testdata/ltw-aspects.jar");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWAspect.aj");
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);

		/*
		 * Around closure advice
		 */
		args = new ArrayList();
		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../weaver/testdata/ltw-acaspects.jar");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWAroundClosure.aj");
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);

		/*
		 * ITD
		 */
		args = new ArrayList();
		args.add("-Xlint:ignore"); 
		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../weaver/testdata/ltw-itdaspects.jar");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWInterfaceITD.aj");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWFieldITD.aj");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWMethodITD.aj");
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);

		/*
		 * perXXX()
		 */
		args = new ArrayList();
		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../weaver/testdata/ltw-peraspects.jar");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWPerthis.aj");
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
	}
================= fetch public void testWeaveAdvice () { 9ebfc84^:weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java

public void testWeaveAdvice () {
		System.setProperty(WeavingURLClassLoader.WEAVING_ASPECT_PATH,ADVICE_ASPECTS);
		System.setProperty(WeavingURLClassLoader.WEAVING_CLASS_PATH,ADVICE_ASPECTS + File.pathSeparator + CLASSES_JAR);
		WeavingURLClassLoader loader = new WeavingURLClassLoader(getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			invokeMain(clazz,new String[] { "LTWAspect" }); 
		}
		catch (Exception ex) {
			fail(ex.toString());
		}
	}
================= fetch public boolean isValid() { 5f6b18b^:runtime/src/org/aspectj/runtime/internal/CFlowStack.java

public boolean isValid() {
        return !getThreadStack().isEmpty();
    }
================= fetch public void showSourceLine(ISourceLocation sourceLocation, boolean highlight) { a17b51b^:ajbrowser/src/org/aspectj/tools/ajbrowser/BasicEditor.java

public void showSourceLine(ISourceLocation sourceLocation, boolean highlight) {
		showSourceLine(sourceLocation.getSourceFile().getAbsolutePath(), sourceLocation.getLine(), highlight);
	}
Progress : [#####################################---] 93%================= fetch public static String makeLocationContext(ICompilationUnit compilationUnit, IProb a97f3b6^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java

public static String makeLocationContext(ICompilationUnit compilationUnit, IProblem problem) {
        //extra from the source the innacurate     token
        //and "highlight" it using some underneath ^^^^^
        //put some context around too.

        //this code assumes that the font used in the console is fixed size

        //sanity .....
        int startPosition = problem.getSourceStart();
        int endPosition = problem.getSourceEnd();
        
        if ((startPosition > endPosition)
            || ((startPosition <= 0) && (endPosition <= 0)))
            //return Util.bind("problem.noSourceInformation"); //$NON-NLS-1$
        	return "(no source information available)";

        final char SPACE = '\u0020';
        final char MARK = '^';
        final char TAB = '\t';
        char[] source = compilationUnit.getContents();
        //the next code tries to underline the token.....
        //it assumes (for a good display) that token source does not
        //contain any \r \n. This is false on statements ! 
        //(the code still works but the display is not optimal !)

        //compute the how-much-char we are displaying around the inaccurate token
        int begin = startPosition >= source.length ? source.length - 1 : startPosition;
        int relativeStart = 0;
        int end = endPosition >= source.length ? source.length - 1 : endPosition;
        int relativeEnd = 0;
        label : for (relativeStart = 0;; relativeStart++) {
            if (begin == 0)
                break label;
            if ((source[begin - 1] == '\n') || (source[begin - 1] == '\r'))
                break label;
            begin--;
        }
        label : for (relativeEnd = 0;; relativeEnd++) {
            if ((end + 1) >= source.length)
                break label;
            if ((source[end + 1] == '\r') || (source[end + 1] == '\n')) {
                break label;
            }
            end++;
        }
        //extract the message form the source
        char[] extract = new char[end - begin + 1];
        System.arraycopy(source, begin, extract, 0, extract.length);
        char c;
        //remove all SPACE and TAB that begin the error message...
        int trimLeftIndex = 0;
        while (((c = extract[trimLeftIndex++]) == TAB) || (c == SPACE)) {
        };
        System.arraycopy(
            extract,
            trimLeftIndex - 1,
            extract = new char[extract.length - trimLeftIndex + 1],
            0,
            extract.length);
        relativeStart -= trimLeftIndex;
        //buffer spaces and tabs in order to reach the error position
        int pos = 0;
        char[] underneath = new char[extract.length]; // can't be bigger
        for (int i = 0; i <= relativeStart; i++) {
            if (extract[i] == TAB) {
                underneath[pos++] = TAB;
            } else {
                underneath[pos++] = SPACE;
            }
        }
        //mark the error position
        for (int i = startPosition + trimLeftIndex;  // AMC if we took stuff off the start, take it into account!
            i <= (endPosition >= source.length ? source.length - 1 : endPosition);
            i++)
            underneath[pos++] = MARK;
        //resize underneathto remove 'null' chars
        System.arraycopy(underneath, 0, underneath = new char[pos], 0, pos);

        return new String(extract) + "\n" + new String(underneath); //$NON-NLS-2$ //$NON-NLS-1$
    }
================= fetch private void generateMethod(ClassFile classFile, MethodBinding methodBinding, Bo b0d32ca^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java

private void generateMethod(ClassFile classFile, MethodBinding methodBinding, BodyGenerator gen) {
//		EclipseFactory world = EclipseFactory.fromScopeLookupEnvironment(this.scope);
		classFile.generateMethodInfoHeader(methodBinding);
		int methodAttributeOffset = classFile.contentsOffset;
		int attributeNumber = classFile.generateMethodInfoAttribute(methodBinding, AstUtil.getAjSyntheticAttribute());
		int codeAttributeOffset = classFile.contentsOffset;
		classFile.generateCodeAttributeHeader();
		CodeStream codeStream = classFile.codeStream;
		codeStream.init(classFile);
		codeStream.initializeMaxLocals(methodBinding);
		// body starts here
		gen.generate(codeStream);
		// body ends here
		classFile.completeCodeAttribute(codeAttributeOffset);
		attributeNumber++;
		classFile.completeMethodInfo(methodAttributeOffset, attributeNumber);
	}
================= fetch public void afterCompiling() { e7ac54f^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java

public void afterCompiling() {
		try {
			if (isXNoWeave || reportedErrors) {
				// no point weaving... just tell the requestor we're done
				notifyRequestor();
			} else {
				weave();  // notification happens as weave progresses...
			}
		} catch (IOException ex) {
			AbortCompilation ac = new AbortCompilation(null,ex);
			throw ac;
		} 
	}
================= fetch public FieldBinding getField( 0521e79^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.java

public FieldBinding getField(
		SourceTypeBinding sourceTypeBinding,
		char[] fieldName,
		InvocationSite site,
		Scope scope)
	{
		FieldBinding retField = sourceTypeBinding.getFieldBase(fieldName, false);  // XXX may need to get the correct value for second parameter in the future
		if (interTypeFields.isEmpty()) return retField;
		int fieldLength = fieldName.length;
		
		for (int i=0, len=interTypeFields.size(); i < len; i++) {
			FieldBinding field = (FieldBinding)interTypeFields.get(i);
			if (field.name.length == fieldLength && CharOperation.prefixEquals(field.name, fieldName)) {
				retField = resolveConflicts(sourceTypeBinding, retField, field, site, scope);
			}
		}
		
		return retField;
	}
================= fetch public static void makeTestJars() throws IOException { 0521e79^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java

public static void makeTestJars() throws IOException {
		List args = new ArrayList();

		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar" +
			File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../tests/new/options11/aspectlib1.jar");		
		args.add("../tests/new/options11/library1/*.java");
		
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
		
		args = new ArrayList();

		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../tests/new/options11/aspectlib2.jar");		
		args.add("../tests/new/options11/library2/*.java");
		
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
		
		args = new ArrayList();

		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar"  +
			File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../tests/new/options11/injar.jar");		
		args.add("../tests/new/options11/injar/*.java");
		
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
		
		args = new ArrayList();

		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar"  +
			File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../tests/bugs/serialVersionUID/injar.jar");		
		args.add("../tests/bugs/serialVersionUID/Test.java");
		args.add("../tests/bugs/serialVersionUID/Util.java");
		
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
	}
================= fetch public static void makeURLWeavingClassLoaderJars() throws IOException { 0521e79^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java

public static void makeURLWeavingClassLoaderJars() throws IOException {
		List args = new ArrayList();

		/*
		 * Vanilla classes
		 */
		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../weaver/testdata/ltw-classes.jar");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWHelloWorld.java");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/ltw/LTWPackageTest.java");
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);

		/* 
		 * Woven classes
		 */
		args = new ArrayList();
		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../weaver/testdata/ltw-woven.jar");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWHelloWorld.java");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWAspect.aj");
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);

		/*
		 * Advice
		 */
		args = new ArrayList();
		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../weaver/testdata/ltw-aspects.jar");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWAspect.aj");
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);

		/*
		 * Around closure advice
		 */
		args = new ArrayList();
		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../weaver/testdata/ltw-acaspects.jar");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWAroundClosure.aj");
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);

		/*
		 * ITD
		 */
		args = new ArrayList();
		args.add("-Xlint:ignore"); 
		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../weaver/testdata/ltw-itdaspects.jar");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWInterfaceITD.aj");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWFieldITD.aj");
		/* Uncomment when bug #55341 fixed */
//		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWMethodITD.aj");
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);

		/*
		 * perXXX()
		 */
		args = new ArrayList();
		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar;../weaver/testdata/ltw-classes.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../weaver/testdata/ltw-peraspects.jar");
		args.add(AjdtAjcTests.TESTDATA_PATH + "/src1/LTWPerthis.aj");
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
	}
================= fetch public void testWeavingAspects () { 0521e79^:weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java

public void testWeavingAspects () {
		URL classes = FileUtil.getFileURL(new File(CLASSES_JAR));
		URL aspects1 = FileUtil.getFileURL(new File(ADVICE_ASPECTS));
		URL aspects2 = FileUtil.getFileURL(new File(AROUNDCLOSURE_ASPECTS));
		URL aspects3 = FileUtil.getFileURL(new File(ITD_ASPECTS));
		URL aspects4 = FileUtil.getFileURL(new File(PER_ASPECTS));
		URL[] classURLs = new URL[] {  aspects1, aspects2, aspects3, aspects4, classes };
		URL[] aspectURLs = new URL[] { aspects1, aspects2, aspects3, aspects4 };
		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			/* Uncomment when bug #55341 fixed */
//			invokeMain(clazz,new String[] { "LTWAspect", "LTWAroundClosure", "LTWPerthis", "LTWInterfaceITD", "LTWFieldITD", "LTWMethodITD", "LTWPerthis"}); 
			invokeMain(clazz,new String[] { "LTWAspect", "LTWAroundClosure", "LTWPerthis", "LTWInterfaceITD", "LTWFieldITD", "LTWPerthis"}); 
		}
		catch (Exception ex) {
			fail(ex.toString());
		}
	}
================= fetch public void testWeavingITD () { 0521e79^:weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java

public void testWeavingITD () {
		URL classes = FileUtil.getFileURL(new File(CLASSES_JAR));
		URL aspects = FileUtil.getFileURL(new File(ITD_ASPECTS));
		URL[] classURLs = new URL[] { aspects, classes };
		URL[] aspectURLs = new URL[] { aspects };
		WeavingURLClassLoader loader = new WeavingURLClassLoader(classURLs,aspectURLs,getClass().getClassLoader());

		try {
			Class clazz = loader.loadClass("LTWHelloWorld");
			/* Uncomment when bug #55341 fixed */
//			invokeMain(clazz,new String[] { "LTWInterfaceITD", "LTWFieldITD", "LTWMethodITD" }); 
			invokeMain(clazz,new String[] { "LTWInterfaceITD", "LTWFieldITD" }); 
		}
		catch (Exception ex) {
			fail(ex.toString());
		}
	}
================= fetch private static void listFiles(final File baseDir, String dir, ArrayList result) 33d8ee9^:util/src/org/aspectj/util/FileUtil.java

private static void listFiles(final File baseDir, String dir, ArrayList result)  {
        final String dirPrefix = (null == dir ? "" : dir + "/");
        final File dirFile = (null == dir ? baseDir : new File(baseDir.getPath() + "/" + dir));
        final String[] files = dirFile.list();
        for (int i = 0; i < files.length; i++) {
            File f = new File(dirFile, files[i]);
            String path = dirPrefix + files[i];
            if (f.isDirectory()) {
                listFiles(baseDir, path, result);
            } else {
                result.add(path);
            }
        }
    }
================= fetch public static Test suite() { 33d8ee9^:weaver/testsrc/BcweaverModuleTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(BcweaverModuleTests.class.getName());
        suite.addTest(org.aspectj.weaver.bcel.BcelTests.suite()); 
        suite.addTest(org.aspectj.weaver.BcweaverTests.suite()); 
        suite.addTest(org.aspectj.weaver.patterns.PatternsTests.suite()); 
        suite.addTestSuite(LocaleTest.class);
        return suite;
    }
================= fetch public static Test suite() { 33d8ee9^:weaver/testsrc/org/aspectj/weaver/BcweaverTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(BcweaverTests.class.getName());
        // abstract
        //suite.addTestSuite(AbstractWorldTestCase.class); 
        //$JUnit-BEGIN$
        suite.addTestSuite(MemberTestCase.class); 
        suite.addTestSuite(TypeXTestCase.class); 
        //$JUnit-END$
        return suite;
    }
================= fetch public static void main(String[] args) throws IOException { 33d8ee9^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java

public static void main(String[] args) throws IOException {
		makeJar0();
		makeJar1();
		makeJar1a();
		makeJar2();
		
		makeJarObviousNothing();
		makeJarHardNothing();
		
		
		makeTestJars();
	}
================= fetch public static void makeTestJars() throws IOException { 33d8ee9^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java

public static void makeTestJars() throws IOException {
		List args = new ArrayList();

		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar" +
			File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../tests/new/options11/aspectlib1.jar");		
		args.add("../tests/new/options11/library1/*.java");
		
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
		
		args = new ArrayList();

		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar" +
		   File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../tests/new/options11/aspectlib2.jar");		
		args.add("../tests/new/options11/library2/*.java");
		
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
		
		args = new ArrayList();

		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar"  +
			File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../tests/new/options11/injar.jar");		
		args.add("../tests/new/options11/injar/*.java");
		
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
		
		args = new ArrayList();

		args.add("-classpath"); 
		args.add("../lib/test/aspectjrt.jar;../lib/test/testing-client.jar"  +
			File.pathSeparator + System.getProperty("aspectjrt.path"));
		args.add("-outjar");
		args.add("../tests/bugs/serialVersionUID/injar.jar");		
		args.add("../tests/bugs/serialVersionUID/Test.java");
		args.add("../tests/bugs/serialVersionUID/Util.java");
		
		CommandTestCase.runCompiler(args, CommandTestCase.NO_ERRORS);
	}
Progress : [#####################################---] 94%================= fetch public String toString() { 7d6b500^:weaver/src/org/aspectj/weaver/bcel/UnwovenClassFile.java

public void deleteRealFile() throws IOException {
		new File(filename).delete();
	}
================= fetch public void deleteRealFile() throws IOException { 7d6b500^:weaver/src/org/aspectj/weaver/bcel/UnwovenClassFile.java

public void deleteRealFile() throws IOException {
		new File(filename).delete();
	}
================= fetch private void removeFromHashtable(Hashtable table, char[] key) { 183fc23^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java

private void removeFromHashtable(Hashtable table, char[] key) {
		// jdt uses char[] as a key in the hashtable, which is not very useful as equality is based on being
		// the same array, not having the same content.
		String skey = new String(key);
		char[] victim = null;
		for (Enumeration iter = table.keys(); iter.hasMoreElements();) {
			char[] thisKey = (char[]) iter.nextElement();
			if (skey.equals(new String(thisKey))) {
				victim = thisKey;
				break;
			}
		}
		if (victim != null) {
			table.remove(victim);
		}
	}
================= fetch private void weave() throws IOException { 183fc23^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java

private void weave() throws IOException {
		// ensure weaver state is set up correctly
		for (Iterator iter = resultsPendingWeave.iterator(); iter.hasNext();) {
			InterimCompilationResult iresult = (InterimCompilationResult) iter.next();
			for (int i = 0; i < iresult.unwovenClassFiles().length; i++) {
				weaver.addClassFile(iresult.unwovenClassFiles()[i]);
			}			
		}

		weaver.prepareForWeave();

		if (isBatchCompile) {
			resultsPendingWeave.addAll(binarySources);  
			// passed into the compiler, the set of classes in injars and inpath...
		} else if (weaver.needToReweaveWorld()) {
			addAllKnownClassesToWeaveList();
		}

		weaver.weave(new WeaverAdapter(this,weaverMessageHandler));
	}
================= fetch protected boolean doBuild( 183fc23^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/** @throws AbortException if check for runtime fails */
protected boolean doBuild(
        AjBuildConfig buildConfig, 
        IMessageHandler baseHandler, 
        boolean batch) throws IOException, AbortException {
        boolean ret = true;
    	batchCompile = batch;
    	
        try {
        	if (batch) {
        		this.state = new AjState(this);
        	}
        	
            boolean canIncremental = state.prepareForNextBuild(buildConfig);
            if (!canIncremental && !batch) { // retry as batch?
                return doBuild(buildConfig, baseHandler, true);
            }
            this.handler = 
                CountingMessageHandler.makeCountingMessageHandler(baseHandler);
            // XXX duplicate, no? remove?
            String check = checkRtJar(buildConfig);
            if (check != null) {
                if (FAIL_IF_RUNTIME_NOT_FOUND) {
                    MessageUtil.error(handler, check);
                    return false;
                } else {
                    MessageUtil.warn(handler, check);
                }
            }
            // if (batch) {
                setBuildConfig(buildConfig);
            //}
//            if (batch) {
//                if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) {  
                	setupModel();
//                }
//            }
            if (batch) {
                initBcelWorld(handler);
            }
            if (handler.hasErrors()) {
                return false;
            }
            
            if (buildConfig.getOutputJar() != null) {
            	if (!openOutputStream(buildConfig.getOutputJar())) return false;
            }
            
            if (batch) {
                // System.err.println("XXXX batch: " + buildConfig.getFiles());
                if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) {  
                    bcelWorld.setModel(AsmManager.getDefault().getHierarchy());
                    // in incremental build, only get updated model?
                }
                performCompilation(buildConfig.getFiles());
                if (handler.hasErrors()) {
                    return false;
                }
            } else {
// done already?
//                if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) {  
//                    bcelWorld.setModel(StructureModelManager.INSTANCE.getStructureModel());
//                }
                // System.err.println("XXXX start inc ");
                List files = state.getFilesToCompile(true);
                for (int i = 0; (i < 5) && !files.isEmpty(); i++) {
                    // System.err.println("XXXX inc: " + files);
                    performCompilation(files);
                    if (handler.hasErrors()) {
                        return false;
                    } 
                    files = state.getFilesToCompile(false);
                }
                if (!files.isEmpty()) {
                    return batchBuild(buildConfig, baseHandler);
                }
            }

            // XXX not in Mik's incremental
            if (buildConfig.isEmacsSymMode()) {
                new org.aspectj.ajdt.internal.core.builder.EmacsStructureModelManager().externalizeModel();
            }
            // have to tell state we succeeded or next is not incremental
            state.successfulCompile(buildConfig);

            copyResourcesToDestination();
            /*boolean weaved = *///weaveAndGenerateClassFiles();
            // if not weaved, then no-op build, no model changes
            // but always returns true
            // XXX weaved not in Mik's incremental
            if (buildConfig.isGenerateModelMode()) {
                AsmManager.getDefault().fireModelUpdated();  
            }
        } finally {
        	if (zos != null) {
        		closeOutputStream();
        	}
            ret = !handler.hasErrors();
            handler = null;
        }
        return ret;
    }
================= fetch public AjCompilerAdapter(Compiler compiler, 183fc23^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java

================= fetch public ICompilerAdapter getAdapter(org.eclipse.jdt.internal.compiler.Compiler fo 183fc23^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/* (non-Javadoc)
	 * @see org.eclipse.jdt.internal.compiler.ICompilerAdapterFactory#getAdapter(org.eclipse.jdt.internal.compiler.Compiler)
	 */
public ICompilerAdapter getAdapter(org.eclipse.jdt.internal.compiler.Compiler forCompiler) {
		// complete compiler config and return a suitable adapter...
		AjProblemReporter pr =
			new AjProblemReporter(DefaultErrorHandlingPolicies.proceedWithAllProblems(),
								  forCompiler.options, getProblemFactory());
		
		forCompiler.problemReporter = pr;
			
		AjLookupEnvironment le =
			new AjLookupEnvironment(forCompiler, forCompiler.options, pr, environment);
		EclipseFactory factory = new EclipseFactory(le);
		le.factory = factory;
		pr.factory = factory;
		le.factory.buildManager = this;
		
		forCompiler.lookupEnvironment = le;
		
		forCompiler.parser =
			new Parser(
				pr, 
				forCompiler.options.parseLiteralExpressionsAsConstants);
		
		return new AjCompilerAdapter(forCompiler,batchCompile,bcelWorld,bcelWeaver,
						factory,
						getInterimResultRequestor(),this,
						state.binarySourceFiles,
						state.resultsFromFile.values(),
						buildConfig.isNoWeave());
	}
================= fetch public Iterator getClassFileIterator() { 183fc23^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.IClassFileProvider#getClassFileIterator()
	 */
public Iterator getClassFileIterator() {
		classFileIndex = 0;
		nowProcessing = null;
		lastReturnedResult = null;
		resultIterator = compilerAdapter.resultsPendingWeave.iterator();
		return this;
	}
================= fetch public Object next() { 183fc23^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java
/* (non-Javadoc)
	 * @see java.util.Iterator#next()
	 */
public Object next() {
		if (!hasNext()) return null;  // sets up indices correctly
		if (finalPhase) {
			if ((lastReturnedResult != null) && (lastReturnedResult != nowProcessing)) {
				// we're done with the lastReturnedResult
				finishedWith(lastReturnedResult);
			}
		}
		lastReturnedResult = nowProcessing;
		weaverMessageHandler.setCurrentResult(nowProcessing.result());
		return nowProcessing.unwovenClassFiles()[classFileIndex++];
	}
================= fetch public WeaverAdapter(AjCompilerAdapter forCompiler, 183fc23^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java

================= fetch public static Test suite() { 183fc23^:ajde/testsrc/org/aspectj/ajde/AjdeTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(AjdeTests.class.getName());
        //$JUnit-BEGIN$
        suite.addTestSuite(BuildOptionsTest.class); 
        suite.addTestSuite(BuildConfigurationTests.class);
        suite.addTestSuite(StructureModelRegressionTest.class); 
        suite.addTestSuite(StructureModelTest.class); 
        suite.addTestSuite(VersionTest.class); 
		suite.addTestSuite(CompilerMessagesTest.class);
		suite.addTestSuite(AsmDeclarationsTest.class);
		suite.addTestSuite(AsmRelationshipsTest.class);
		suite.addTestSuite(InpathTestcase.class);
		suite.addTestSuite(ReweavableTestCase.class);
		suite.addTestSuite(ResourceCopyTestCase.class);
		suite.addTestSuite(ModelPerformanceTest.class);
		suite.addTestSuite(SavedModelConsistencyTest. class);
		suite.addTestSuite(JarManifestTest.class);
		
        //$JUnit-END$
        return suite;
    }
================= fetch public void acceptResult(InterimCompilationResult result) { 183fc23^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

public IIntermediateResultsRequestor getInterimResultRequestor() {
		return new IIntermediateResultsRequestor() {
			int lineDelta = 0;
			public void acceptResult(InterimCompilationResult result) {
				if (progressListener != null) {
					compiledCount++;
					progressListener.setProgress((compiledCount/2.0)/sourceFileCount);
					progressListener.setText("compiled: " + result.fileName());
				}
				state.noteResult(result);
			}
		};
	}
================= fetch public void acceptResult(UnwovenClassFile result) { 183fc23^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java
/* (non-Javadoc)
	 * @see org.aspectj.weaver.IWeaveRequestor#acceptResult(org.aspectj.weaver.bcel.UnwovenClassFile)
	 */
public void acceptResult(UnwovenClassFile result) {
		char[] key = result.getClassName().replace('.','/').toCharArray();
		removeFromHashtable(lastReturnedResult.result().compiledTypes,key);
		String className = result.getClassName().replace('.', '/');
		AjClassFile ajcf = new AjClassFile(className.toCharArray(),
										   result.getBytes());
		lastReturnedResult.result().record(ajcf.fileName(),ajcf);
	}
================= fetch public void afterProcessing(CompilationUnitDeclaration unit, int unitIndex) { 183fc23^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java

public void afterProcessing(CompilationUnitDeclaration unit, int unitIndex) {
		eWorld.finishedCompilationUnit(unit);
		InterimCompilationResult intRes = new InterimCompilationResult(unit.compilationResult,outputFileNameProvider);
		if (unit.compilationResult.hasErrors()) reportedErrors = true;
		
		if (intermediateResultsRequestor != null) {
			intermediateResultsRequestor.acceptResult(intRes);
		}
		
		if (isXNoWeave) {
			acceptResult(unit.compilationResult);
		} else {
			resultsPendingWeave.add(intRes);
		}
	}
================= fetch public void performCompilation(List files) { 183fc23^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

public void performCompilation(List files) {
		if (progressListener != null) {
			compiledCount = 0;
			sourceFileCount = files.size();
			progressListener.setText("compiling source files");
		}
		//System.err.println("got files: " + files);
		String[] filenames = new String[files.size()];
		String[] encodings = new String[files.size()];
		//System.err.println("filename: " + this.filenames);
		for (int i=0; i < files.size(); i++) {
			filenames[i] = ((File)files.get(i)).getPath();
		}
		
		List cps = buildConfig.getFullClasspath();
		String[] classpaths = new String[cps.size()];
		for (int i=0; i < cps.size(); i++) {
			classpaths[i] = (String)cps.get(i);
		}
		
		//System.out.println("compiling");
		environment = getLibraryAccess(classpaths, filenames);
		
		if (!state.classesFromName.isEmpty()) {
			environment = new StatefulNameEnvironment(environment, state.classesFromName);
		}
		
		org.eclipse.jdt.internal.compiler.Compiler.setCompilerAdapterFactory(this);
		org.eclipse.jdt.internal.compiler.Compiler compiler = 
			new org.eclipse.jdt.internal.compiler.Compiler(environment,
					DefaultErrorHandlingPolicies.proceedWithAllProblems(),
				    buildConfig.getJavaOptions(),
					getBatchRequestor(),
					getProblemFactory());
		
		CompilerOptions options = compiler.options;

		options.produceReferenceInfo(true); //TODO turn off when not needed
		
		compiler.compile(getCompilationUnits(filenames, encodings));
		
		// cleanup
		environment.cleanup();
		environment = null;
	}
================= fetch public void remove() { 183fc23^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java
/* (non-Javadoc)
	 * @see java.util.Iterator#remove()
	 */
public void remove() {
		throw new UnsupportedOperationException();
	}
================= fetch public void setText(String text) { 183fc23^:ajde/src/org/aspectj/ajde/internal/BuildNotifierAdapter.java

public void setText(String text) {
		progressMonitor.setProgressText(text);
	}
================= fetch public void weaveCompleted() { 183fc23^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java

public void weaveCompleted() {
		if ((lastReturnedResult != null) && (!lastReturnedResult.result().hasBeenAccepted)) {
			finishedWith(lastReturnedResult);
		}
	}
================= fetch private boolean openOutputStream(File outJar) { 34dbb0c^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

================= fetch private void copyResourcesFromJarFile(File jarFile) throws IOException { 34dbb0c^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void copyResourcesFromJarFile(File jarFile) throws IOException {
		ZipInputStream inStream = null;
		try {
			inStream = new ZipInputStream(new FileInputStream(jarFile));
			while (true) {
				ZipEntry entry = inStream.getNextEntry();
				if (entry == null) break;
			
				String filename = entry.getName();
	
				if (!entry.isDirectory() && acceptResource(filename)) {
					byte[] bytes = FileUtil.readAsByteArray(inStream);
					writeResource(filename,bytes,jarFile);
				}
	
				inStream.closeEntry();
			}
		} finally {
			if (inStream != null) inStream.close();
		}
	}
================= fetch private void copyResourcesToDestination() throws IOException { 34dbb0c^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void copyResourcesToDestination() throws IOException {
		// resources that we need to copy are contained in the injars and inpath only
		for (Iterator i = buildConfig.getInJars().iterator(); i.hasNext(); ) {
			File inJar = (File)i.next();
			copyResourcesFromJarFile(inJar);
		}
		
		for (Iterator i = buildConfig.getInpath().iterator(); i.hasNext(); ) {
			File inPathElement = (File)i.next();
			if (inPathElement.isDirectory()) {				
				copyResourcesFromDirectory(inPathElement);
			} else {
				copyResourcesFromJarFile(inPathElement);
			}
		}	
		
		if (buildConfig.getSourcePathResources() != null) {
			for (Iterator i = buildConfig.getSourcePathResources().keySet().iterator(); i.hasNext(); ) {
				String resource = (String)i.next();
				File from = (File)buildConfig.getSourcePathResources().get(resource);
				copyResourcesFromFile(from,resource,from);
			}
		}
    }
================= fetch private void writeResource(String filename, byte[] content, File srcLocation) th 34dbb0c^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void writeResource(String filename, byte[] content, File srcLocation) throws IOException {
		if (state.resources.contains(filename)) {
			IMessage msg = new Message("duplicate resource: '" + filename + "'",
									   IMessage.WARNING,
									   null,
									   new SourceLocation(srcLocation,0));
			handler.handleMessage(msg);
			return;
		}
		if (zos != null) {
			ZipEntry newEntry = new ZipEntry(filename);  //??? get compression scheme right
			
			zos.putNextEntry(newEntry);
			zos.write(content);
			zos.closeEntry();
		} else {
			OutputStream fos = 
				FileUtil.makeOutputStream(new File(buildConfig.getOutputDir(),filename));
			fos.write(content);
			fos.close();
		}
		state.resources.add(filename);
	}
================= fetch public BcelWeaver() { 34dbb0c^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java

================= fetch public List addJarFile(File inFile, File outDir, boolean canBeDirectory){ 34dbb0c^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
/** Adds all class files in the jar
	 */
List addJarFile(File inFile, File outDir, boolean canBeDirectory){
//		System.err.println("? addJarFile(" + inFile + ", " + outDir + ")");
		List addedClassFiles = new ArrayList();
		needToReweaveWorld = true;
		ZipInputStream inStream = null;
		
		try {
			// Is this a directory we are looking at?
			if (inFile.isDirectory() && canBeDirectory) {
				addedClassFiles.addAll(addDirectoryContents(inFile,outDir));
			} else {
			
				inStream = new ZipInputStream(new FileInputStream(inFile)); //??? buffered
			
				while (true) {
					ZipEntry entry = inStream.getNextEntry();
					if (entry == null) break;
				
					byte[] bytes = FileUtil.readAsByteArray(inStream);
					String filename = entry.getName();
					UnwovenClassFile classFile = new UnwovenClassFile(new File(outDir, filename).getAbsolutePath(), bytes);

					if (filename.endsWith(".class")) {
						this.addClassFile(classFile);
						addedClassFiles.add(classFile);
					}
//					else if (!entry.isDirectory()) {
//
//						/* bug-44190 Copy meta-data */
//						addResource(filename,classFile);
//					}

					inStream.closeEntry();
				}
				inStream.close();
			}
		} catch (FileNotFoundException ex) {
			IMessage message = new Message(
					"Could not find input jar file " + inFile.getPath() + ", ignoring",
					new SourceLocation(inFile,0),
					false);
			world.getMessageHandler().handleMessage(message);
		} catch (IOException ex) {
			IMessage message = new Message(
					"Could not read input jar file " + inFile.getPath() + "(" + ex.getMessage() + ")",
					new SourceLocation(inFile,0),
					true);
			world.getMessageHandler().handleMessage(message);
		} finally {
			if (inStream != null) {
				try {inStream.close();}
				catch (IOException ex) {
					IMessage message = new Message(
							"Could not close input jar file " + inFile.getPath() + "(" + ex.getMessage() + ")",
							new SourceLocation(inFile,0),
							true);					
					world.getMessageHandler().handleMessage(message);					
				}
			}
		}
		
		return addedClassFiles;
	}
================= fetch public int compare(Object o1, Object o2) { 34dbb0c^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java

public void prepareForWeave() {
    	needToReweaveWorld = false;

    	
    	// update mungers
    	for (Iterator i = addedClasses.iterator(); i.hasNext(); ) { 
    		UnwovenClassFile jc = (UnwovenClassFile)i.next();
    		String name = jc.getClassName();
    		ResolvedTypeX type = world.resolve(name);
    		//System.err.println("added: " + type + " aspect? " + type.isAspect());
    		if (type.isAspect()) {
    			needToReweaveWorld |= xcutSet.addOrReplaceAspect(type);
    		}
    	}

    	for (Iterator i = deletedTypenames.iterator(); i.hasNext(); ) { 
    		String name = (String)i.next();
    		if (xcutSet.deleteAspect(TypeX.forName(name))) needToReweaveWorld = true;
    	}

		shadowMungerList = xcutSet.getShadowMungers();
		typeMungerList = xcutSet.getTypeMungers();
		declareParentsList = xcutSet.getDeclareParents();
    	
		//XXX this gets us a stable (but completely meaningless) order
		Collections.sort(
			shadowMungerList, 
			new Comparator() {
				public int compare(Object o1, Object o2) {
					return o1.toString().compareTo(o2.toString());
				}
			});
    }
================= fetch public int fetchFromJar(File outjarFile, String filename) { 34dbb0c^:ajde/testsrc/org/aspectj/ajde/InpathTestcase.java
// Return the size of specified entry from the output jar file
public int fetchFromJar(File outjarFile, String filename) {
		int ret = -1;
		try {
			ZipInputStream outjar;

			outjar =
				new ZipInputStream(new java.io.FileInputStream(outjarFile));

			ZipEntry entry;
			while (null != (entry = outjar.getNextEntry())) {
				String zipentryname = entry.getName();
				if (zipentryname.equals(filename)) {
						byte[] filedata = FileUtil.readAsByteArray(outjar);
						ret = filedata.length;
						outjar.closeEntry();
						break;
				}
				outjar.closeEntry();
			}
			outjar.close();
		} catch (FileNotFoundException e) {
			e.printStackTrace();
		} catch (IOException e) {
			e.printStackTrace();
		}
		return ret;
	}
================= fetch public static Test suite() { 34dbb0c^:ajde/testsrc/org/aspectj/ajde/AjdeTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(AjdeTests.class.getName());
        //$JUnit-BEGIN$
        suite.addTestSuite(BuildOptionsTest.class); 
        suite.addTestSuite(BuildConfigurationTests.class);
        suite.addTestSuite(StructureModelRegressionTest.class); 
        suite.addTestSuite(StructureModelTest.class); 
        suite.addTestSuite(VersionTest.class); 
		suite.addTestSuite(CompilerMessagesTest.class);
		suite.addTestSuite(AsmDeclarationsTest.class);
		suite.addTestSuite(AsmRelationshipsTest.class);
		suite.addTestSuite(InpathTestcase.class);
		suite.addTestSuite(ReweavableTestCase.class);
		suite.addTestSuite(ResourceCopyTestCase.class);
		suite.addTestSuite(ModelPerformanceTest.class);
		suite.addTestSuite(SavedModelConsistencyTest. class);
		
        //$JUnit-END$
        return suite;
    }
================= fetch public void addLibraryJarFile(File inFile) throws IOException { 34dbb0c^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java

================= fetch public void compareJars( 34dbb0c^:ajde/testsrc/org/aspectj/ajde/InpathTestcase.java
/*
	 * Ensure -outjar contains all non-Java resouces from injars
	 */
public void compareJars(
		File dirFile,
		String sourceDir,
		File outjarFile,
		Set expectedOutputJarContents) {

		try {
			assertTrue(
				"outjar older than injar",
				(outjarFile.lastModified() > dirFile.lastModified()));

			// Go through the output jar file, for each element, remove it from
			// the expectedOutputJarContents - when we finish, the expectedOutputJarContents
			// set should be empty!
			ZipInputStream outjar =
				new ZipInputStream(new java.io.FileInputStream(outjarFile));
			ZipEntry entry;
			while (null != (entry = outjar.getNextEntry())) {
				String fileName = entry.getName();
				fileName = fileName.replace('\\', '/');
				if (fileName.indexOf("CVS") == -1) {
					boolean b = expectedOutputJarContents.remove(fileName);
					assertTrue(
							"Unexpectedly found : " + fileName + " in outjar",
							b);
				}
				outjar.closeEntry();
			}
			outjar.close();

			assertTrue(
				"Didnt make it into the output jar: "
					+ expectedOutputJarContents.toString(),
				expectedOutputJarContents.isEmpty());
		} catch (IOException ex) {
			fail(ex.toString());
		}
	}
================= fetch public void compareSourceToOutjar (String indirName, File outjarFile) { 34dbb0c^:ajde/testsrc/org/aspectj/ajde/ResourceCopyTestCase.java
/*
	 * Ensure -outjar conatins all non-Java resouces from source and injars
	 */
public void compareSourceToOutjar (String indirName, File outjarFile) {
		HashSet resources = new HashSet();		
		listSourceResources(indirName,resources);		
	
		try {	

			ZipInputStream outjar = new ZipInputStream(new java.io.FileInputStream(outjarFile));
			ZipEntry entry;
			while (null != (entry = outjar.getNextEntry())) {
				String fileName = entry.getName();
				if (!fileName.endsWith(".class")) {
					boolean b = resources.remove(fileName);
					assertTrue(fileName,b);
				}
				outjar.closeEntry();
			}
			outjar.close();

			assertTrue("Missing resources: " + resources.toString(), resources.isEmpty());
		}
		catch (IOException ex) {
			fail(ex.toString());
		}
	}
================= fetch public void compareSourceToOutjar(String indirName, File outjarFile) { 34dbb0c^:ajde/testsrc/org/aspectj/ajde/InpathTestcase.java
/*
	 * Ensure -outjar contains all non-Java resouces from source and injars
	 */
public void compareSourceToOutjar(String indirName, File outjarFile) {
		HashSet resources = new HashSet();
		listSourceResources(indirName, resources);

		try {

			ZipInputStream outjar =
				new ZipInputStream(new java.io.FileInputStream(outjarFile));
			ZipEntry entry;
			while (null != (entry = outjar.getNextEntry())) {
				String fileName = entry.getName();

				if (!fileName.endsWith(".class")) {
					boolean b = resources.remove(fileName);
					assertTrue(fileName, b);
				}
				outjar.closeEntry();
			}
			outjar.close();

			assertTrue(
				"Missing resources: " + resources.toString(),
				resources.isEmpty());
		} catch (IOException ex) {
			fail(ex.toString());
		}
	}
================= fetch boolean prepareForNextBuild(AjBuildConfig newBuildConfig) { 1a4c02c^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
/**
	 * Returns false if a batch build is needed.
	 */
boolean prepareForNextBuild(AjBuildConfig newBuildConfig) {
		currentBuildTime = System.currentTimeMillis();
		
		addedClassFiles = new ArrayList();
		
		if (lastSuccessfulBuildTime == -1 || buildConfig == null) {
			return false;
		}
		
//		if (newBuildConfig.getOutputJar() != null) return false;
		
		simpleStrings = new ArrayList();
		qualifiedStrings = new ArrayList();
		
		Set oldFiles = new HashSet(buildConfig.getFiles());
		Set newFiles = new HashSet(newBuildConfig.getFiles());
		
		addedFiles = new HashSet(newFiles);
		addedFiles.removeAll(oldFiles);
		deletedFiles = new HashSet(oldFiles);
		deletedFiles.removeAll(newFiles);
		
		this.newBuildConfig = newBuildConfig;
		
		return true;
	}
================= fetch boolean prepareForNextBuild(AjBuildConfig newBuildConfig) { 41c6f6d^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
/**
	 * Returns false if a batch build is needed.
	 */
boolean prepareForNextBuild(AjBuildConfig newBuildConfig) {
		currentBuildTime = System.currentTimeMillis();
		
		addedClassFiles = new ArrayList();
		
		if (lastSuccessfulBuildTime == -1 || buildConfig == null) {
			return false;
		}
		
		simpleStrings = new ArrayList();
		qualifiedStrings = new ArrayList();
		
		Set oldFiles = new HashSet(buildConfig.getFiles());
		Set newFiles = new HashSet(newBuildConfig.getFiles());
		
		addedFiles = new HashSet(newFiles);
		addedFiles.removeAll(oldFiles);
		deletedFiles = new HashSet(oldFiles);
		deletedFiles.removeAll(newFiles);
		
		this.newBuildConfig = newBuildConfig;
		
		return true;
	}
================= fetch private static StringSet makeStringSet(List strings) { 41c6f6d^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java
//	}
private static StringSet makeStringSet(List strings) {
		StringSet ret = new StringSet(strings.size());
		for (Iterator iter = strings.iterator(); iter.hasNext();) {
			String element = (String) iter.next();
			ret.add(element);
		}
		return ret;
	}
================= fetch protected void addAffectedSourceFiles(List sourceFiles) { 41c6f6d^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java

protected void addAffectedSourceFiles(List sourceFiles) {
		if (qualifiedStrings.isEmpty() && simpleStrings.isEmpty()) return;

		// the qualifiedStrings are of the form 'p1/p2' & the simpleStrings are just 'X'
		char[][][] qualifiedNames = ReferenceCollection.internQualifiedNames(makeStringSet(qualifiedStrings));
		// if a well known qualified name was found then we can skip over these
		if (qualifiedNames.length < qualifiedStrings.size())
			qualifiedNames = null;
		char[][] simpleNames = ReferenceCollection.internSimpleNames(makeStringSet(simpleStrings));
		// if a well known name was found then we can skip over these
		if (simpleNames.length < simpleStrings.size())
			simpleNames = null;

		//System.err.println("simple: " + simpleStrings);
		//System.err.println("qualif: " + qualifiedStrings);

		for (Iterator i = references.entrySet().iterator(); i.hasNext();) {
			Map.Entry entry = (Map.Entry) i.next();
			ReferenceCollection refs = (ReferenceCollection)entry.getValue();
			if (refs != null && refs.includes(qualifiedNames, simpleNames)) {
				File file = (File)entry.getKey();
				if (file.exists()) {
					if (!sourceFiles.contains(file)) {  //??? O(n**2)
						sourceFiles.add(file);
					}
				}
			}
		}
		
		qualifiedStrings.clear();
		simpleStrings.clear();
	}
================= fetch public List getFilesToCompile(boolean firstPass) { 41c6f6d^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java

public List getFilesToCompile(boolean firstPass) {
		List sourceFiles = new ArrayList();
		if (firstPass) {
			Collection modifiedFiles = getModifiedFiles();
			//System.out.println("modified: " + modifiedFiles);
			sourceFiles.addAll(modifiedFiles);
			//??? eclipse IncrementalImageBuilder appears to do this
	//		for (Iterator i = modifiedFiles.iterator(); i.hasNext();) {
	//			File file = (File) i.next();
	//			addDependentsOf(file);
	//		}
			
			sourceFiles.addAll(addedFiles);	
			
			deleteClassFiles();
			
			addAffectedSourceFiles(sourceFiles);
		} else {
			
			addAffectedSourceFiles(sourceFiles);
		}
		return sourceFiles;
	}
Progress : [######################################--] 95%================= fetch public EclipseTypeMunger build(ClassScope classScope) { 5c67166^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java

public EclipseTypeMunger build(ClassScope classScope) {
		EclipseFactory world = EclipseFactory.fromScopeLookupEnvironment(classScope);
		
		resolveOnType(classScope);
		if (ignoreFurtherInvestigation) return null;
		
		binding = classScope.referenceContext.binding.resolveTypesFor(binding);
		ResolvedMember sig = new ResolvedMember(Member.METHOD, EclipseFactory.fromBinding(onTypeBinding),
			declaredModifiers, EclipseFactory.fromBinding(binding.returnType), new String(declaredSelector),
			EclipseFactory.fromBindings(binding.parameters),
			world.fromEclipse(binding.thrownExceptions));
		
		NewMethodTypeMunger myMunger = new NewMethodTypeMunger(sig, null);
		setMunger(myMunger);
		ResolvedTypeX aspectType = world.fromEclipse(classScope.referenceContext.binding);
		ResolvedMember me =
			myMunger.getDispatchMethod(aspectType);
		this.selector = binding.selector = me.getName().toCharArray();
		
		return new EclipseTypeMunger(world, myMunger, aspectType, this);
	}
================= fetch private void sortMungers() { 0109534^:weaver/src/org/aspectj/weaver/Shadow.java

private void sortMungers() {
		List sorted = PartialOrder.sort(mungers);
		if (sorted == null) {
			// this means that we have circular dependencies
			for (Iterator i = mungers.iterator(); i.hasNext(); ) {
				ShadowMunger m = (ShadowMunger)i.next();
				getIWorld().getMessageHandler().handleMessage(
					MessageUtil.error("circular dependency at " + this, m.getSourceLocation()));
			}
		}
		mungers = sorted;
	}
================= fetch public void resolve(IScope scope) { 0109534^:weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java

public void resolve(IScope scope) {
    	patterns = patterns.resolveBindings(scope, Bindings.NONE, false, false); 
    	boolean seenStar = false;
    	
    	for (int i=0; i < patterns.size(); i++) {
    		TypePattern pi = patterns.get(i);
    		if (pi.isStar()) {
    			if (seenStar) {
    				scope.getWorld().showMessage(IMessage.ERROR,
    					"circularity in declare dominates, '*' occurs more than once",
    					pi.getSourceLocation(), null);    				
    			}
    			seenStar = true;
    			continue;
    		}
    		ResolvedTypeX exactType = pi.getExactType().resolve(scope.getWorld());
    		if (exactType == ResolvedTypeX.MISSING) continue;
    		for (int j=0; j < patterns.size(); j++) {
    			if (j == i) continue;
    			TypePattern pj = patterns.get(j);
    			if (pj.isStar()) continue;
    			if (pj.matchesStatically(exactType)) {
    				scope.getWorld().showMessage(IMessage.ERROR,
    					"circularity in declare dominates, '" + exactType.getName() + 
    						"' matches two patterns", pi.getSourceLocation(), pj.getSourceLocation());
    			}
    		}
    	}    	
    }
================= fetch public MethodBinding getExactMethod( c798923^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.java

public MethodBinding getExactMethod(
		SourceTypeBinding sourceTypeBinding,
		char[] selector,
		TypeBinding[] argumentTypes)
	{
		MethodBinding ret = sourceTypeBinding.getExactMethodBase(selector, argumentTypes);
		if (ret != null) return ret;
		
		for (int i=0, len=interTypeMethods.size(); i < len; i++) {
			MethodBinding im =
				(MethodBinding)interTypeMethods.get(i);
			if (matches(im, selector, argumentTypes)) {
				return im;
			}
		}
		return null;
	}
================= fetch private boolean isInitFailureHandler(InstructionHandle ih) { 5d73494^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

private boolean isInitFailureHandler(InstructionHandle ih) {
		if (ih.getInstruction() instanceof PUTSTATIC) {
			String name = ((PUTSTATIC)ih.getInstruction()).getFieldName(cpg);
			if (name.equals(NameMangler.INITFAILURECAUSE_FIELD_NAME)) return true;
		}
		return false;
	}
================= fetch protected void generatePostSyntheticCode( 5d73494^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java

protected void generatePostSyntheticCode(
		ClassScope classScope,
		CodeStream codeStream)
	{
		super.generatePostSyntheticCode(classScope, codeStream);
		if (hasPost) {
			final EclipseFactory world = EclipseFactory.fromScopeLookupEnvironment(classScope);

			codeStream.invokestatic(world.makeMethodBindingForCall(
				AjcMemberMaker.ajcPostClinitMethod(
					EclipseFactory.fromBinding(classScope.referenceContext.binding)
				)));
		}
		
		if (initFailureField != null) {
			handlerLabel.placeEnd();
			Label endLabel = new Label(codeStream);
			codeStream.goto_(endLabel);
			
			handlerLabel.place();
			codeStream.putstatic(initFailureField);
			endLabel.place();
		}
		
	}
================= fetch public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) { fbc0aa3^:weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java

public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {
		TypePatternList args = arguments.resolveReferences(bindings);
		if (inAspect.crosscuttingMembers != null) {
			inAspect.crosscuttingMembers.exposeTypes(args.getExactTypes());
		}
		return new ArgsPointcut(args);
	}
================= fetch public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) { fbc0aa3^:weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java

public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {
		//make this remap from formal positions to arrayIndices
		IntMap entryBindings = new IntMap();
		for (int i=0, len=freeVars.length; i < len; i++) {
			int freeVar = freeVars[i];
			//int formalIndex = bindings.get(freeVar);
			entryBindings.put(freeVar, i);
		}
		entryBindings.copyContext(bindings);
		//System.out.println(this + " bindings: " + entryBindings);
		
		World world = inAspect.getWorld();
		
		Pointcut concreteEntry;
		
		ResolvedTypeX concreteAspect = bindings.getConcreteAspect();
		
		CrosscuttingMembers xcut = concreteAspect.crosscuttingMembers;		
		Collection previousCflowEntries = xcut.getCflowEntries();
		
		entryBindings.pushEnclosingDefinition(CFLOW_MARKER);
		try {
			concreteEntry = entry.concretize(inAspect, entryBindings);
		} finally {
			entryBindings.popEnclosingDefinitition();
		}

		List innerCflowEntries = new ArrayList(xcut.getCflowEntries());
		innerCflowEntries.removeAll(previousCflowEntries);

		
		ResolvedMember cflowField = new ResolvedMember(
			Member.FIELD, concreteAspect, Modifier.STATIC | Modifier.PUBLIC | Modifier.FINAL,
					NameMangler.cflowStack(xcut), 
					TypeX.forName(NameMangler.CFLOW_STACK_TYPE).getSignature());
		//System.out.println("adding field to: " + inAspect + " field " + cflowField);
					
		// add field and initializer to inAspect
		//XXX and then that info above needs to be mapped down here to help with
		//XXX getting the exposed state right
		concreteAspect.crosscuttingMembers.addConcreteShadowMunger(
				Advice.makeCflowEntry(world, concreteEntry, isBelow, cflowField, freeVars.length, innerCflowEntries,inAspect));
		
		concreteAspect.crosscuttingMembers.addTypeMunger(
			world.makeCflowStackFieldAdder(cflowField));
			
			
		List slots = new ArrayList();
		for (int i=0, len=freeVars.length; i < len; i++) {
			int freeVar = freeVars[i];
			
			// we don't need to keep state that isn't actually exposed to advice
			//??? this means that we will store some state that we won't actually use, optimize this later
			if (!bindings.hasKey(freeVar)) continue; 
			
			int formalIndex = bindings.get(freeVar);
			ResolvedTypeX formalType =
				bindings.getAdviceSignature().getParameterTypes()[formalIndex].resolve(world);
			
			ConcreteCflowPointcut.Slot slot = 
				new ConcreteCflowPointcut.Slot(formalIndex, formalType, i);
			slots.add(slot);
		}
		
		return new ConcreteCflowPointcut(cflowField, slots);
	}
================= fetch public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) { fbc0aa3^:weaver/src/org/aspectj/weaver/patterns/IfPointcut.java

public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {
		//System.err.println("concretize: " + this + " already: " + partiallyConcretized);
		if (partiallyConcretized != null) {
			return partiallyConcretized;
		}
		IfPointcut ret = new IfPointcut(testMethod, extraParameterFlags);
		partiallyConcretized = ret;
		if (bindings.directlyInAdvice()) {
			ShadowMunger advice = bindings.getEnclosingAdvice();
			ret.baseArgsCount = ((Advice)advice).getBaseParameterCount();
			ret.residueSource = advice.getPointcut().concretize(inAspect, ret.baseArgsCount, advice);
		} else {
			ResolvedPointcutDefinition def = bindings.peekEnclosingDefinitition();
			if (def == CflowPointcut.CFLOW_MARKER) {
				inAspect.getWorld().showMessage(IMessage.ERROR,
					"if not supported lexically within cflow (compiler limitation)",
					getSourceLocation(), null);
				return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
			}
			ret.baseArgsCount = def.getParameterTypes().length;
			
			IntMap newBindings = IntMap.idMap(ret.baseArgsCount);
			newBindings.copyContext(bindings);
			ret.residueSource = def.getPointcut().concretize(inAspect, newBindings);
		}
		
		return ret;
	}
================= fetch public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) { fbc0aa3^:weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java

public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {
		TypePattern newType = type.remapAdviceFormals(bindings);
		if (inAspect.crosscuttingMembers != null) {
			inAspect.crosscuttingMembers.exposeType(newType.getExactType());
		}
		
		return new ThisOrTargetPointcut(isThis, newType);
	}
================= fetch LazyClassGen weave(UnwovenClassFile classFile, BcelObjectType classType) throws 16a0abd^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
// non-private for testing
LazyClassGen weave(UnwovenClassFile classFile, BcelObjectType classType) throws IOException {
		LazyClassGen ret = weave(classFile, classType, true);
		
		if (progressListener != null) {
			progressMade += progressPerClassFile;
			progressListener.setProgress(progressMade);
			progressListener.setText("woven: " + classFile.getFilename());
		}
		
		return ret;
	}
================= fetch String next() { 16a0abd^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java

String next() {
                String err = null;
                if (!hasNext()) {
                    err = "need arg for flag " + args[args.length-1];
                } else {
                    String s = args[index++];
                    if (null == s) {
                        err = "null value";                                            
                    } else {
                        s = s.trim();
                        if (0 == s.trim().length()) {
                            err = "no value";                                            
                        } else {
                            return s;
                        }
                    }
                }
                err += " at [" + index + "] of " + Arrays.asList(args);
                throw new BuildException(err);
            }
================= fetch private CRSOptions() { 16a0abd^:testing/src/org/aspectj/testing/harness/bridge/CompilerRun.java

public String toString() {
                return "TestSetup("
                    + (null == compilerName ? "" : compilerName + " ")
                    + (!ignoreWarningsSet
                        ? ""
                        : (ignoreWarnings ? "" : "do not ")
                            + "ignore warnings ")
                    + (result ? "" : "setup failed")
                    + ")";
            }
================= fetch private WeaverStateInfo(List typeMungers, boolean oldStyle) { 16a0abd^:weaver/src/org/aspectj/weaver/WeaverStateInfo.java

================= fetch private void initBcelWorld(IMessageHandler handler) throws IOException { 16a0abd^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/** init only on initial batch compile? no file-specific options */
private void initBcelWorld(IMessageHandler handler) throws IOException {
		bcelWorld = new BcelWorld(buildConfig.getClasspath(), handler, null);
		bcelWorld.setXnoInline(buildConfig.isXnoInline());
		bcelWorld.setXlazyTjp(buildConfig.isXlazyTjp());
		bcelWeaver = new BcelWeaver(bcelWorld);
		
		for (Iterator i = buildConfig.getAspectpath().iterator(); i.hasNext();) {
			File f = (File) i.next();
			bcelWeaver.addLibraryJarFile(f);
		}
		
//		String lintMode = buildConfig.getLintMode();
		
		if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
			bcelWorld.getLint().loadDefaultProperties();
		} else {
			bcelWorld.getLint().setAll(buildConfig.getLintMode());
		}
		
		if (buildConfig.getLintSpecFile() != null) {
			bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
		}
		
		//??? incremental issues
		for (Iterator i = buildConfig.getInJars().iterator(); i.hasNext(); ) {
			File inJar = (File)i.next();
			bcelWeaver.addJarFile(inJar, buildConfig.getOutputDir(),false);
		}
		
		for (Iterator i = buildConfig.getInpath().iterator(); i.hasNext(); ) {
			File inPathElement = (File)i.next();
			bcelWeaver.addJarFile(inPathElement,buildConfig.getOutputDir(),true);
		}
		
		if (buildConfig.getSourcePathResources() != null) {
			for (Iterator i = buildConfig.getSourcePathResources().keySet().iterator(); i.hasNext(); ) {
	//			File resource = (File)i.next();
				String resource = (String)i.next();
				bcelWeaver.addResource(resource, (File)buildConfig.getSourcePathResources().get(resource), buildConfig.getOutputDir());
	//			bcelWeaver.addResource(resource, buildConfig.getOutputDir());
			}
		}
		//check for org.aspectj.runtime.JoinPoint
		bcelWorld.resolve("org.aspectj.lang.JoinPoint");
	}
================= fetch protected Shadow(Kind kind, Member signature, Shadow enclosingShadow) { 16a0abd^:weaver/src/org/aspectj/weaver/Shadow.java

================= fetch public BcelCflowStackFieldAdder(ResolvedMember cflowStackField) { 16a0abd^:weaver/src/org/aspectj/weaver/bcel/BcelCflowStackFieldAdder.java

================= fetch public BcelWorld getWorld() { 16a0abd^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

public BcelWorld getWorld() {
		return world;
	}
================= fetch public Collection getPrivilegedAccesses() { 16a0abd^:weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java

public Collection getPrivilegedAccesses() {
		if (privilegedAccess == null) return Collections.EMPTY_LIST;
		return Arrays.asList(privilegedAccess);
	}
================= fetch public Collection weave() throws IOException { 16a0abd^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java

public Collection weave() throws IOException {
    	prepareForWeave();
    	Collection filesToWeave;
    	
    	if (needToReweaveWorld) {
    		filesToWeave = sourceJavaClasses.values();
    	} else {
    		filesToWeave = addedClasses;
    	}
    	
    	Collection wovenClassNames = new ArrayList();
    	world.showMessage(IMessage.INFO, "might need to weave " + filesToWeave + 
    					"(world=" + needToReweaveWorld + ")", null, null);
    	
    	
    	//System.err.println("typeMungers: " + typeMungerList);
    	
		// clear all state from files we'll be reweaving
        for (Iterator i = filesToWeave.iterator(); i.hasNext(); ) {
            UnwovenClassFile classFile = (UnwovenClassFile)i.next();
	    	String className = classFile.getClassName();
            BcelObjectType classType = BcelWorld.getBcelObjectType(world.resolve(className));
            classType.resetState();
        }
    	
    	
    	
    	//XXX this isn't quite the right place for this...
    	for (Iterator i = filesToWeave.iterator(); i.hasNext(); ) {
            UnwovenClassFile classFile = (UnwovenClassFile)i.next();
            String className = classFile.getClassName();
            ResolvedTypeX onType = world.resolve(className);
            weave(onType);
        }
    	
		// first weave into aspects
        for (Iterator i = filesToWeave.iterator(); i.hasNext(); ) {
            UnwovenClassFile classFile = (UnwovenClassFile)i.next();
	    	String className = classFile.getClassName();
            BcelObjectType classType = BcelWorld.getBcelObjectType(world.resolve(className));
            if (classType.isAspect()) {
	            weave(classFile, classType);
	            wovenClassNames.add(className);
            }
        }

		// then weave into non-aspects
		for (Iterator i = filesToWeave.iterator(); i.hasNext(); ) {
            UnwovenClassFile classFile = (UnwovenClassFile)i.next();
	    	String className = classFile.getClassName();
            BcelObjectType classType = BcelWorld.getBcelObjectType(world.resolve(className));
            if (! classType.isAspect()) {
	            weave(classFile, classType);
	            wovenClassNames.add(className);
            }
        }
        
        if (zipOutputStream != null && !needToReweaveWorld) {
        	Collection filesToDump = new HashSet(sourceJavaClasses.values());
        	filesToDump.removeAll(filesToWeave);
        	for (Iterator i = filesToDump.iterator(); i.hasNext(); ) {
                UnwovenClassFile classFile = (UnwovenClassFile)i.next();
                dumpUnchanged(classFile);
        	}
        }
        
        addedClasses = new ArrayList();
    	deletedTypenames = new ArrayList();
		
        return wovenClassNames;
    }
================= fetch public List getDeclareDominates() { 16a0abd^:weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java

public List getDeclareDominates() {
		if (declareDominates == null) {
			ArrayList ret = new ArrayList();
			for (Iterator i = members.values().iterator(); i.hasNext(); ) {
				ret.addAll(((CrosscuttingMembers)i.next()).getDeclareDominates());
			}
			declareDominates = ret;
		}
		return declareDominates;
	}
================= fetch public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) { 16a0abd^:weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java

public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {
		//make this remap from formal positions to arrayIndices
		IntMap entryBindings = new IntMap();
		for (int i=0, len=freeVars.length; i < len; i++) {
			int freeVar = freeVars[i];
			//int formalIndex = bindings.get(freeVar);
			entryBindings.put(freeVar, i);
		}
		entryBindings.copyContext(bindings);
		//System.out.println(this + " bindings: " + entryBindings);
		
		World world = inAspect.getWorld();
		
		Pointcut concreteEntry;
		
		ResolvedTypeX concreteAspect = bindings.getConcreteAspect();
		
		CrosscuttingMembers xcut = concreteAspect.crosscuttingMembers;		
		Collection previousCflowEntries = xcut.getCflowEntries();
		
		entryBindings.pushEnclosingDefinition(CFLOW_MARKER);
		try {
			concreteEntry = entry.concretize(inAspect, entryBindings);
		} finally {
			entryBindings.popEnclosingDefinitition();
		}

		List innerCflowEntries = new ArrayList(xcut.getCflowEntries());
		innerCflowEntries.removeAll(previousCflowEntries);

		
		ResolvedMember cflowField = new ResolvedMember(
			Member.FIELD, concreteAspect, Modifier.STATIC | Modifier.PUBLIC | Modifier.FINAL,
					NameMangler.cflowStack(xcut), 
					TypeX.forName(NameMangler.CFLOW_STACK_TYPE).getSignature());
		//System.out.println("adding field to: " + inAspect + " field " + cflowField);
					
		// add field and initializer to inAspect
		//XXX and then that info above needs to be mapped down here to help with
		//XXX getting the exposed state right
		concreteAspect.crosscuttingMembers.addConcreteShadowMunger(
				Advice.makeCflowEntry(world, concreteEntry, isBelow, cflowField, freeVars.length, innerCflowEntries));
		
		concreteAspect.crosscuttingMembers.addTypeMunger(
			world.makeCflowStackFieldAdder(cflowField));
			
			
		List slots = new ArrayList();
		for (int i=0, len=freeVars.length; i < len; i++) {
			int freeVar = freeVars[i];
			
			// we don't need to keep state that isn't actually exposed to advice
			//??? this means that we will store some state that we won't actually use, optimize this later
			if (!bindings.hasKey(freeVar)) continue; 
			
			int formalIndex = bindings.get(freeVar);
			ResolvedTypeX formalType =
				bindings.getAdviceSignature().getParameterTypes()[formalIndex].resolve(world);
			
			ConcreteCflowPointcut.Slot slot = 
				new ConcreteCflowPointcut.Slot(formalIndex, formalType, i);
			slots.add(slot);
		}
		
		return new ConcreteCflowPointcut(cflowField, slots);
	}
================= fetch public WeaverStateInfo() { 16a0abd^:weaver/src/org/aspectj/weaver/WeaverStateInfo.java

================= fetch public boolean isOldStyle() { 16a0abd^:weaver/src/org/aspectj/weaver/WeaverStateInfo.java

public boolean isOldStyle() {
		return oldStyle;
	}
================= fetch public boolean isWoven() { 16a0abd^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java

public boolean isWoven() {
		return myType.getWeaverState() != null;
	}
================= fetch public boolean weave() { 16a0abd^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
// ----
public boolean weave() {
        if (clazz.isWoven()) {
        	world.showMessage(IMessage.ERROR, 
				"class \'" + clazz.getType().getName() + "\' is already woven",
				ty.getSourceLocation(), null);
        	return false;
        }
        
        boolean isChanged = false;
        
        // we want to "touch" all aspects
        if (clazz.getType().isAspect()) isChanged = true;
        
        
        // start by munging all typeMungers
        for (Iterator i = typeMungers.iterator(); i.hasNext(); ) {
        	Object o = i.next();
        	if ( !(o instanceof BcelTypeMunger) ) {
        		//???System.err.println("surprising: " + o);
        		continue;
        	}
        	BcelTypeMunger munger = (BcelTypeMunger)o;
        	isChanged |= munger.munge(this);
        }
        
        // XXX do major sort of stuff
        // sort according to:  Major:  type hierarchy
        //                     within each list:  dominates
        // don't forget to sort addedThisInitialiers according to dominates
        addedSuperInitializersAsList = new ArrayList(addedSuperInitializers.values());
        addedSuperInitializersAsList = PartialOrder.sort(addedSuperInitializersAsList);        
        if (addedSuperInitializersAsList == null) {
        	throw new BCException("circularity in inter-types");
        }
        
        // this will create a static initializer if there isn't one
        // this is in just as bad taste as NOPs
        LazyMethodGen staticInit = clazz.getStaticInitializer();
        staticInit.getBody().insert(genInitInstructions(addedClassInitializers, true));
        
        
        // now go through each method, and match against each method.  This
        // sets up each method's {@link LazyMethodGen#matchedShadows} field, 
        // and it also possibly adds to {@link #initializationShadows}.
        List methodGens = new ArrayList(clazz.getMethodGens());
        for (Iterator i = methodGens.iterator(); i.hasNext();) {
            LazyMethodGen mg = (LazyMethodGen)i.next();
            //mg.getBody();
			if (! mg.hasBody()) continue;
            isChanged |= match(mg);
        }
        if (! isChanged) return false;
        
        // now we weave all but the initialization shadows
		for (Iterator i = methodGens.iterator(); i.hasNext();) {
			LazyMethodGen mg = (LazyMethodGen)i.next();
			if (! mg.hasBody()) continue;
			implement(mg);
		}
			
        
        // if we matched any initialization shadows, we inline and weave
		if (! initializationShadows.isEmpty()) {
			inlineSelfConstructors(methodGens);
			positionAndImplement(initializationShadows);
		}
		
		
		// finally, if we changed, we add in the introduced methods.
        if (isChanged) {
        	clazz.getOrCreateWeaverStateInfo();
			weaveInAddedMethods();
        }
        
        return isChanged;
    }
================= fetch public static Advice makePerObjectEntry(World world, Pointcut entry, boolean isT 16a0abd^:weaver/src/org/aspectj/weaver/Advice.java

public static Advice makePerObjectEntry(World world, Pointcut entry, boolean isThis, 
    								ResolvedTypeX inAspect)
    {
    	Advice ret = world.concreteAdvice(isThis ? AdviceKind.PerThisEntry : AdviceKind.PerTargetEntry,
    	      entry, null, 0, entry);
  
    	ret.concreteAspect = inAspect;
    	return ret;
    }
================= fetch public static Advice makeSoftener(World world, Pointcut entry, TypePattern excep 16a0abd^:weaver/src/org/aspectj/weaver/Advice.java

public static Advice makeSoftener(World world, Pointcut entry, TypePattern exceptionType) {
    	Advice ret = world.concreteAdvice(AdviceKind.Softener,
    	      entry, null, 0, entry);  
  
    	ret.exceptionType = exceptionType;
    	//System.out.println("made ret: " + ret + " with " + exceptionType);
    	return ret;
    }
================= fetch public static Test suite() { 16a0abd^:ajde/testsrc/org/aspectj/ajde/AjdeTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(AjdeTests.class.getName());
        //$JUnit-BEGIN$
        suite.addTestSuite(BuildOptionsTest.class); 
        suite.addTestSuite(BuildConfigurationTests.class);
        suite.addTestSuite(StructureModelRegressionTest.class); 
        suite.addTestSuite(StructureModelTest.class); 
        suite.addTestSuite(VersionTest.class); 
		suite.addTestSuite(CompilerMessagesTest.class);
		suite.addTestSuite(AsmDeclarationsTest.class);
		suite.addTestSuite(AsmRelationshipsTest.class);
		suite.addTestSuite(InpathTestcase.class);
		suite.addTestSuite(ResourceCopyTestCase.class);
		suite.addTestSuite(ModelPerformanceTest.class);
		suite.addTestSuite(SavedModelConsistencyTest. class);
		
        //$JUnit-END$
        return suite;
    }
================= fetch public static boolean weave( 16a0abd^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

public static boolean weave(
		BcelWorld world,
		LazyClassGen clazz,
		List shadowMungers,
		List typeMungers) 
	{
		boolean b =  new BcelClassWeaver(world, clazz, shadowMungers, typeMungers).weave();
		//System.out.println(clazz.getClassName() + ", " + clazz.getType().getWeaverState());
		//clazz.print();
		return b;
	}
================= fetch public static final WeaverStateInfo read(DataInputStream s, ISourceContext conte 16a0abd^:weaver/src/org/aspectj/weaver/WeaverStateInfo.java

public static final WeaverStateInfo read(DataInputStream s, ISourceContext context) throws IOException {
		byte b = s.readByte();
		
		switch(b) {
			case UNTOUCHED:
				throw new RuntimeException("unexpected UNWOVEN");
			case WOVEN: 
				return new WeaverStateInfo(Collections.EMPTY_LIST, true);
			case EXTENDED:
				int n = s.readShort();
				List l = new ArrayList();
				for (int i=0; i < n; i++) {
					TypeX aspectType = TypeX.read(s);
					ResolvedTypeMunger typeMunger = 
						ResolvedTypeMunger.read(s, context);
					l.add(new Entry(aspectType, typeMunger));
				}
				return new WeaverStateInfo(l, false);
		} 
		throw new RuntimeException("bad WeaverState.Kind: " + b);
	}
================= fetch public void addDeclare(Declare declare) { 16a0abd^:weaver/src/org/aspectj/weaver/CrosscuttingMembers.java

public void addDeclare(Declare declare) {
		// this is not extensible, oh well
		if (declare instanceof DeclareErrorOrWarning) {
			ShadowMunger m = new Checker((DeclareErrorOrWarning)declare);
			addShadowMunger(m);
		} else if (declare instanceof DeclarePrecedence) {
			declareDominates.add(declare);
		} else if (declare instanceof DeclareParents) {
			DeclareParents dp = (DeclareParents)declare;
			exposeTypes(dp.getParents().getExactTypes());
			declareParents.add(dp);
		} else if (declare instanceof DeclareSoft) {
			DeclareSoft d = (DeclareSoft)declare;
			Pointcut concretePointcut = d.getPointcut().concretize(inAspect, 0);
			declareSofts.add(new DeclareSoft(d.getException(), concretePointcut));
			ShadowMunger m = Advice.makeSoftener(world, concretePointcut, d.getException());
			addConcreteShadowMunger(m);
		} else {
			throw new RuntimeException("unimplemented");
		}
	}
================= fetch public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r 16a0abd^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java
/**
         * Extract AspectJ-specific options (except for argfiles).
         * Caller should warn when sourceroots is empty but in 
         * incremental mode.
         * Signals warnings or errors through handler set in constructor.
         */
public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.remove()
			int nextArgIndex = args.indexOf(arg)+1; // XXX assumes unique
            // trim arg?
            if (LangUtil.isEmpty(arg)) {
                showWarning("empty arg found");
            } else if (arg.equals("-inpath")) {;
            	if (args.size() > nextArgIndex) {
					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_Inpath, CompilerOptions.PRESERVE);
					
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
					while (st.hasMoreTokens()) {
						String filename = st.nextToken();
						File file = makeFile(filename);
						if (file.exists() && FileUtil.hasZipSuffix(filename)) {
							buildConfig.getInpath().add(file);    
						} else {
							if (file.isDirectory()) {
								buildConfig.getInpath().add(file);
							} else 
		            		
							showError("bad inpath component: " + filename);  
						}
					}
					
					args.remove(args.get(nextArgIndex));            		
            	}
            } else if (arg.equals("-injars")) {;
				if (args.size() > nextArgIndex) {
					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_InJARs, CompilerOptions.PRESERVE);
					
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
		            	if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
			            	buildConfig.getInJars().add(jarFile);    
		            	} else {
		            		File dirFile = makeFile(filename);
		            		if (dirFile.isDirectory()) {
		            			buildConfig.getInJars().add(dirFile);
		            		} else 
		            		
                            showError("bad injar: " + filename);  
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-aspectpath")) {;
				if (args.size() > nextArgIndex) {
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
                        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
			            	buildConfig.getAspectpath().add(jarFile);    
		            	} else {
                            showError("bad aspectpath: " + filename);
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-sourceroots")) {
				if (args.size() > nextArgIndex) {
					List sourceRoots = new ArrayList();
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	File f = makeFile(st.nextToken());
		            	if (f.isDirectory() && f.canRead()) {
			                sourceRoots.add(f);
		            	} else {
                            showError("bad sourceroot: " + f);
		            	}		            		
		            }
				    if (0 < sourceRoots.size()) {
						buildConfig.setSourceRoots(sourceRoots);	
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-sourceroots requires list of directories");
				}
			} else if (arg.equals("-outjar")) { 
				if (args.size() > nextArgIndex) {
					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_OutJAR, CompilerOptions.GENERATE);
					File jarFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
					if (FileUtil.hasZipSuffix(jarFile)) {
						try {
							if (!jarFile.exists()) {
                                jarFile.createNewFile();
                            }
                            buildConfig.setOutputJar(jarFile);  
						} catch (IOException ioe) { 
                            showError("unable to create outjar file: " + jarFile);
						}
					} else {
						showError("invalid -outjar file: " + jarFile);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-outjar requires jar path argument");
				}
            } else if (arg.equals("-incremental")) {
                buildConfig.setIncrementalMode(true);
            } else if (arg.equals("-XincrementalFile")) {
                if (args.size() > nextArgIndex) {
                    File file = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    buildConfig.setIncrementalFile(file);
                    if (!file.canRead()) {
                        showError("bad -XincrementalFile : " + file);
                        // if not created before recompile test, stop after first compile
                    }
                    args.remove(args.get(nextArgIndex));
                } else {
                    showError("-XincrementalFile requires file argument");
                }
			} else if (arg.equals("-emacssym")) {
				buildConfig.setEmacsSymMode(true);
				buildConfig.setGenerateModelMode(true);
			} else if (arg.equals("-noweave") || arg.equals( "-XnoWeave")) {
				buildConfig.setNoWeave(true);
			} else if (arg.equals("-XserializableAspects")) {
				buildConfig.setXserializableAspects(true);
			} else if (arg.equals("-XlazyTjp")) {
				buildConfig.setXlazyTjp(true);
			} else if (arg.equals("-XnoInline")) {
				buildConfig.setXnoInline(true);
			} else if (arg.equals("-Xlintfile")) { 
				if (args.size() > nextArgIndex) {
					File lintSpecFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    // XXX relax restriction on props file suffix?
					if (lintSpecFile.canRead() && lintSpecFile.getName().endsWith(".properties")) {
						buildConfig.setLintSpecFile(lintSpecFile);	
					} else {
						showError("bad -Xlintfile file: " + lintSpecFile);
						buildConfig.setLintSpecFile(null);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-Xlintfile requires .properties file argument");
				}
            } else if (arg.equals("-Xlint")) {
                buildConfig.getAjOptions().put(
                    AjCompilerOptions.OPTION_Xlint,
                    CompilerOptions.GENERATE);
                buildConfig.setLintMode(AjBuildConfig.AJLINT_DEFAULT);
            } else if (arg.startsWith("-Xlint:")) {
                if (7 < arg.length()) {
                    buildConfig.setLintMode(arg.substring(7));
                } else {
                    showError("invalid lint option " + arg);
                }
			} else if (arg.equals("-bootclasspath")) {
				if (args.size() > nextArgIndex) {
					bootclasspath = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-bootclasspath requires classpath entries");
				}
			} else if (arg.equals("-classpath")) {
				if (args.size() > nextArgIndex) {
					classpath = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-classpath requires classpath entries");
				}
			} else if (arg.equals("-extdirs")) {
				if (args.size() > nextArgIndex) {
					extdirs = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					args.remove(args.get(nextArgIndex));
                } else {
                    showError("-extdirs requires list of external directories");
                }
            // error on directory unless -d, -{boot}classpath, or -extdirs
            } else if (arg.equals("-d")) {
                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-classpath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-bootclasspath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-extdirs")) {
//                dirLookahead(arg, args, nextArgIndex);
            } else if (new File(arg).isDirectory()) {
                showError("dir arg not permitted: " + arg);
			} else {
                // argfile, @file parsed by superclass
                // no eclipse options parsed:
                // -d args, -help (handled), 
                // -classpath, -target, -1.3, -1.4, -source [1.3|1.4]
                // -nowarn, -warn:[...], -deprecation, -noImportError,
                // -proceedOnError, -g:[...], -preserveAllLocals,
                // -referenceInfo, -encoding, -verbose, -log, -time
                // -noExit, -repeat
		    	unparsedArgs.add(arg);
			}
        }
================= fetch public void setInJars(List sourceJars) { 16a0abd^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java

public void setInJars(List sourceJars) {
		this.inJars = sourceJars;
	}
================= fetch public void setProgressListener(IProgressListener listener, double previousProgr 16a0abd^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java

public void setProgressListener(IProgressListener listener, double previousProgress, double progressPerClassFile) {
		progressListener = listener;
		this.progressMade = previousProgress;
		this.progressPerClassFile = progressPerClassFile;
	}
================= fetch public void setXNoweave(boolean noweave) { 16a0abd^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java

public void setXNoweave(boolean noweave) {  
        cmd.addFlag("-XnoWeave", noweave);
    }
================= fetch public void setXlazyTjp(boolean b) { 16a0abd^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java

public void setXlazyTjp(boolean b) {
		XlazyTjp = b;
	}
================= fetch public void weave(ResolvedTypeX onType) { 16a0abd^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java

public void weave(ResolvedTypeX onType) {
		onType.clearInterTypeMungers();
		
		// need to do any declare parents before the matching below
		for (Iterator i = declareParentsList.iterator(); i.hasNext(); ) {
			DeclareParents p = (DeclareParents)i.next();
			List newParents = p.findMatchingNewParents(onType);
			if (!newParents.isEmpty()) {
				BcelObjectType classType = BcelWorld.getBcelObjectType(onType);
				//System.err.println("need to do declare parents for: " + onType);
				for (Iterator j = newParents.iterator(); j.hasNext(); ) {
					ResolvedTypeX newParent = (ResolvedTypeX)j.next();
					if (newParent.isClass()) {
						world.showMessage(IMessage.ERROR,
							"can't use declare parents to change superclass of binary form \'" +
							onType.getName() + "\' (implementation limitation)",
							p.getSourceLocation(), null);
						continue;
					}
					
					classType.addParent(newParent);
					ResolvedTypeMunger newParentMunger = new NewParentTypeMunger(newParent);
					onType.addInterTypeMunger(new BcelTypeMunger(newParentMunger, null));
				}
			}
		}
		
		for (Iterator i = typeMungerList.iterator(); i.hasNext(); ) {
			ConcreteTypeMunger m = (ConcreteTypeMunger)i.next();
			if (m.matches(onType)) {
				onType.addInterTypeMunger(m);
			}
		}
	}
================= fetch public void write(DataOutputStream s) throws IOException { 16a0abd^:weaver/src/org/aspectj/weaver/WeaverStateInfo.java

void write(DataOutputStream s) throws IOException {
		if (oldStyle) throw new RuntimeException("shouldn't be writing this");
		
		s.writeByte(EXTENDED);
		int n = typeMungers.size();
		s.writeShort(n);
		for (int i=0; i < n; i++) {
			Entry e = (Entry)typeMungers.get(i);
			e.aspectType.write(s);
			e.typeMunger.write(s);
		}
	}
Progress : [######################################--] 96%================= fetch private FieldBinding getAccessibleField(FieldBinding binding) { 6ddae42^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java

private FieldBinding getAccessibleField(FieldBinding binding) {
		//System.err.println("checking field: " + binding);
		if (!binding.isValidBinding()) return binding;
		
		makePublic(binding.declaringClass);
		if (isPublic(binding)) return binding;
		if (binding instanceof PrivilegedFieldBinding) return binding;
		if (binding instanceof InterTypeFieldBinding) return binding;

		if (binding.isPrivate() &&  binding.declaringClass != inAspect.binding) {
			binding.modifiers = AstUtil.makePackageVisible(binding.modifiers);
		}
		
		ResolvedMember m = EclipseFactory.makeResolvedMember(binding);
		if (inAspect.accessForInline.containsKey(m)) return (FieldBinding)inAspect.accessForInline.get(m);
		FieldBinding ret = new InlineAccessFieldBinding(inAspect, binding);
		
		//System.err.println("   made accessor: " + ret);
		
		inAspect.accessForInline.put(m, ret);
		return ret;
	}
================= fetch private MethodBinding getAccessibleMethod(MethodBinding binding) { 6ddae42^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java

private MethodBinding getAccessibleMethod(MethodBinding binding) {
		if (!binding.isValidBinding()) return binding;
		
		makePublic(binding.declaringClass);  //???
		if (isPublic(binding)) return binding;
		if (binding instanceof InterTypeMethodBinding) return binding;

		if (binding.isPrivate() &&  binding.declaringClass != inAspect.binding) {
			binding.modifiers = AstUtil.makePackageVisible(binding.modifiers);
		}

		
		ResolvedMember m = EclipseFactory.makeResolvedMember(binding);
		if (inAspect.accessForInline.containsKey(m)) return (MethodBinding)inAspect.accessForInline.get(m);
		MethodBinding ret = world.makeMethodBinding(
			AjcMemberMaker.inlineAccessMethodForMethod(inAspect.typeX, m)
			);
		inAspect.accessForInline.put(m, ret);
		return ret;
	}
================= fetch private void doOtherStuff() { 6ddae42^:tests/bugs/protectedvf/main/Driver.java

private void doOtherStuff() {
		System.out.println("doing other stuff");
	}
================= fetch private void doStuff() { 6ddae42^:tests/bugs/protectedvf/main/Driver.java

private void doStuff() {
		System.out.println("doing stuff");
	}
================= fetch public InlineAccessFieldBinding(AspectDeclaration inAspect, FieldBinding baseFie 6ddae42^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InlineAccessFieldBinding.java

================= fetch public static ResolvedMember makeResolvedMember(FieldBinding binding) { 6ddae42^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

public static ResolvedMember makeResolvedMember(FieldBinding binding) {
		return new ResolvedMember(
			Member.FIELD,
			fromBinding(binding.declaringClass),
			binding.modifiers,
			fromBinding(binding.type),
			new String(binding.name),
			TypeX.NONE);
	}
================= fetch public static ResolvedMember makeResolvedMember(MethodBinding binding) { 6ddae42^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

public static ResolvedMember makeResolvedMember(MethodBinding binding) {
		//System.err.println("member for: " + binding + ", " + new String(binding.declaringClass.sourceName));
		ResolvedMember ret =  new ResolvedMember(
			binding.isConstructor() ? Member.CONSTRUCTOR : Member.METHOD,
			fromBinding(binding.declaringClass),
			binding.modifiers,
			fromBinding(binding.returnType),
			new String(binding.selector),
			fromBindings(binding.parameters),
			fromBindings(binding.thrownExceptions));
		return ret;
	}
================= fetch public void endVisit(ClassLiteralAccess classLiteral, BlockScope scope) { 6ddae42^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java

public void endVisit(ClassLiteralAccess classLiteral, BlockScope scope) {
		isInlinable = false;
	}
================= fetch public void endVisit(FieldReference ref, BlockScope scope) { 6ddae42^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java

public void endVisit(FieldReference ref, BlockScope scope) {
		if (ref.binding instanceof FieldBinding) {
			ref.binding = getAccessibleField((FieldBinding)ref.binding);
		}
	}
================= fetch public void endVisit(MessageSend send, BlockScope scope) { 6ddae42^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java

public void endVisit(MessageSend send, BlockScope scope) {
		if (send instanceof Proceed) return;
		if (send.binding == null || !send.binding.isValidBinding()) return;
		
		if (send.isSuperAccess() && !send.binding.isStatic()) {
			send.receiver = new ThisReference(send.sourceStart, send.sourceEnd);
			MethodBinding superAccessBinding = getSuperAccessMethod((MethodBinding)send.binding);
			AstUtil.replaceMethodBinding(send, superAccessBinding);
		} else if (!isPublic(send.binding)) {
			send.syntheticAccessor = getAccessibleMethod((MethodBinding)send.binding);
		}
	}
================= fetch public void endVisit(QualifiedNameReference ref, BlockScope scope) { 6ddae42^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java

public void endVisit(QualifiedNameReference ref, BlockScope scope) {
		//System.err.println("qref: " + ref + ", " + ref.binding.getClass().getName() + ", " + ref.codegenBinding.getClass().getName());
		//System.err.println("   others: " + Arrays.asList(ref.otherBindings));
		if (ref.binding instanceof FieldBinding) {
			ref.binding = getAccessibleField((FieldBinding)ref.binding);
		}
		if (ref.otherBindings != null) {
			for (int i=0, len=ref.otherBindings.length; i < len; i++) {
				if (ref.otherBindings[i] instanceof FieldBinding) {
					ref.otherBindings[i] = getAccessibleField((FieldBinding)ref.otherBindings[i]);
				}
			}
		}
	}
================= fetch public void endVisit(SingleNameReference ref, BlockScope scope) { 6ddae42^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java

public void endVisit(SingleNameReference ref, BlockScope scope) {
		if (ref.binding instanceof FieldBinding) {
			ref.binding = getAccessibleField((FieldBinding)ref.binding);
		}
	}
================= fetch public void endVisit( 6ddae42^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java

public void endVisit(ClassLiteralAccess classLiteral, BlockScope scope) {
		isInlinable = false;
	}
================= fetch private Object readResolve() throws ObjectStreamException { 669cd7c^:asm/src/org/aspectj/asm/IProgramElement.java

private Object readResolve() throws ObjectStreamException {
			return ALL[ordinal];
		}
================= fetch public static Test suite() { 669cd7c^:ajde/testsrc/org/aspectj/ajde/AjdeTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(AjdeTests.class.getName());
        //$JUnit-BEGIN$
        suite.addTestSuite(BuildOptionsTest.class); 
        suite.addTestSuite(BuildConfigurationTests.class);
        suite.addTestSuite(StructureModelRegressionTest.class); 
        suite.addTestSuite(StructureModelTest.class); 
        suite.addTestSuite(VersionTest.class); 
		suite.addTestSuite(CompilerMessagesTest.class);
		suite.addTestSuite(AsmDeclarationsTest.class);
		suite.addTestSuite(AsmRelationshipsTest.class);
		suite.addTestSuite(InpathTestcase.class);
		suite.addTestSuite(ResourceCopyTestCase.class);
		suite.addTestSuite(ModelPerformanceTest.class);
		
        //$JUnit-END$
        return suite;
    }
================= fetch private String getHandlerSignatureString(World world) { 19bac86^:weaver/src/org/aspectj/weaver/Member.java

private String getHandlerSignatureString(World world) {
        StringBuffer buf = new StringBuffer();
        buf.append(makeString(0));
        buf.append('-');
        //buf.append(getName());
        buf.append('-');
        buf.append(makeString(getDeclaringType()));
        buf.append('-');
        buf.append(makeString(getParameterTypes()[0]));
        buf.append('-');
        //XXX we don't actually try to find the handler parameter name
        //XXX it probably wouldn't be too hard
        String pName = "<missing>";
        //String[] pNames = getParameterNames(world);
        //if (pNames != null) pName = pNames[0];
        buf.append(pName);
        buf.append('-');
        return buf.toString();
	}
================= fetch private static Member pointcut(TypeX declTy, int mods, TypeX rTy, String name, T 19bac86^:weaver/src/org/aspectj/weaver/Member.java

private static Member pointcut(TypeX declTy, int mods, TypeX rTy, String name, TypeX[] paramTys) {
        return new Member(
            POINTCUT,
            declTy,
            mods,
            rTy,
            name,
            paramTys);
    }
================= fetch public static BcelShadow makeExceptionHandler( 19bac86^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java
/** Make the shadow for an exception handler.  Currently makes an empty shadow that
	 * only allows before advice to be woven into it.
	 */
public static BcelShadow makeExceptionHandler(
		BcelWorld world,
		ExceptionRange exceptionRange,
		LazyMethodGen enclosingMethod,
		InstructionHandle startOfHandler,
		BcelShadow enclosingShadow) 
	{
		InstructionList body = enclosingMethod.getBody();
		TypeX catchType = exceptionRange.getCatchType();
		TypeX inType = enclosingMethod.getEnclosingClass().getType();
        BcelShadow s =
            new BcelShadow(
                world,
                ExceptionHandler,
                Member.makeExceptionHandlerSignature(inType, catchType),
                enclosingMethod,
                enclosingShadow);
        ShadowRange r = new ShadowRange(body);
        r.associateWithShadow(s);
        InstructionHandle start = Range.genStart(body, startOfHandler);
        InstructionHandle end = Range.genEnd(body, start);
        
        r.associateWithTargets(start, end);
        exceptionRange.updateTarget(startOfHandler, start, body);
        return s;
	}
================= fetch private void initBcelWorld(IMessageHandler handler) throws IOException { 0c83343^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/** init only on initial batch compile? no file-specific options */
private void initBcelWorld(IMessageHandler handler) throws IOException {
		bcelWorld = new BcelWorld(buildConfig.getClasspath(), handler, null);
		bcelWorld.setXnoInline(buildConfig.isXnoInline());
		bcelWeaver = new BcelWeaver(bcelWorld);
		
		for (Iterator i = buildConfig.getAspectpath().iterator(); i.hasNext();) {
			File f = (File) i.next();
			bcelWeaver.addLibraryJarFile(f);
		}
		
//		String lintMode = buildConfig.getLintMode();
		
		if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
			bcelWorld.getLint().loadDefaultProperties();
		} else {
			bcelWorld.getLint().setAll(buildConfig.getLintMode());
		}
		
		if (buildConfig.getLintSpecFile() != null) {
			bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
		}
		
		//??? incremental issues
		for (Iterator i = buildConfig.getInJars().iterator(); i.hasNext(); ) {
			File inJar = (File)i.next();
			bcelWeaver.addJarFile(inJar, buildConfig.getOutputDir(),false);
		}
		
		for (Iterator i = buildConfig.getInpath().iterator(); i.hasNext(); ) {
			File inPathElement = (File)i.next();
			bcelWeaver.addJarFile(inPathElement,buildConfig.getOutputDir(),true);
		}
		
		if (buildConfig.getSourcePathResources() != null) {
			for (Iterator i = buildConfig.getSourcePathResources().keySet().iterator(); i.hasNext(); ) {
	//			File resource = (File)i.next();
				String resource = (String)i.next();
				bcelWeaver.addResource(resource, (File)buildConfig.getSourcePathResources().get(resource), buildConfig.getOutputDir());
	//			bcelWeaver.addResource(resource, buildConfig.getOutputDir());
			}
		}
		//check for org.aspectj.runtime.JoinPoint
		bcelWorld.resolve("org.aspectj.lang.JoinPoint");
	}
================= fetch protected void prepareForMungers() { 0c83343^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

protected void prepareForMungers() {
		// if we're a constructor call, we need to remove the new:dup or the new:dup_x1:swap, 
		// and store all our
		// arguments on the frame.
		
		// ??? This is a bit of a hack (for the Java langauge).  We do this because
		// we sometime add code "outsideBefore" when dealing with weaving join points.  We only
		// do this for exposing state that is on the stack.  It turns out to just work for 
		// everything except for constructor calls and exception handlers.  If we were to clean
		// this up, every ShadowRange would have three instructionHandle points, the start of 
		// the arg-setup code, the start of the running code, and the end of the running code.
		if (getKind() == ConstructorCall) {
			deleteNewAndDup();
			initializeArgVars();
		} else if (getKind() == ExceptionHandler) {
			ShadowRange range = getRange();
			InstructionList body = range.getBody();
			InstructionHandle start = range.getStart();
			InstructionHandle freshIh = body.insert(start, InstructionConstants.NOP);
			InstructionTargeter[] targeters = start.getTargeters();
			for (int i = 0; i < targeters.length; i++) {
				InstructionTargeter t = targeters[i];
				if (t instanceof ExceptionRange) {
					ExceptionRange er = (ExceptionRange) t;
					er.updateTarget(start, freshIh, body);
				}
			}
		}

		// now we ask each munger to request our state
		for (Iterator iter = mungers.iterator(); iter.hasNext();) {
			ShadowMunger munger = (ShadowMunger) iter.next();
			munger.specializeOn(this);
		}
		
	    // If we are an expression kind, we require our target/arguments on the stack
	    // before we do our actual thing.  However, they may have been removed
	    // from the stack as the shadowMungers have requested state.  
	    // if any of our shadowMungers requested either the arguments or target, 
	    // the munger will have added code
	    // to pop the target/arguments into temporary variables, represented by 
	    // targetVar and argVars.  In such a case, we must make sure to re-push the 
	    // values.  
	
	    // If we are nonExpressionKind, we don't expect arguments on the stack
	    // so this is moot.  If our argVars happen to be null, then we know that
	    // no ShadowMunger has squirrelled away our arguments, so they're still
	    // on the stack.		
		InstructionFactory fact = getFactory();
		if (getKind().argsOnStack() && argVars != null) {
			range.insert(
				BcelRenderer.renderExprs(fact, world, argVars),
				Range.InsideBefore);
			if (targetVar != null) {
				range.insert(
					BcelRenderer.renderExpr(fact, world, targetVar),
					Range.InsideBefore);
			}
			if (getKind() == ConstructorCall) {
				range.insert((Instruction) InstructionFactory.createDup(1), Range.InsideBefore);
				range.insert(
					fact.createNew(
						(ObjectType) BcelWorld.makeBcelType(
							getSignature().getDeclaringType())),
					Range.InsideBefore);
			}
		}
 	}
================= fetch public BcelVar getThisJoinPointBcelVar() { 0c83343^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public BcelVar getThisJoinPointBcelVar() {
    	if (thisJoinPointVar == null) {
    		thisJoinPointVar = genTempVar(TypeX.forName("org.aspectj.lang.JoinPoint"));
    		InstructionFactory fact = getFactory();
    		InstructionList il = new InstructionList();
    		BcelVar staticPart = getThisJoinPointStaticPartBcelVar();
    		staticPart.appendLoad(il, fact);
    		if (hasThis()) {
    			((BcelVar)getThisVar()).appendLoad(il, fact);
    		} else {
    			il.append(new ACONST_NULL());
    		}
    		if (hasTarget()) {
    			((BcelVar)getTargetVar()).appendLoad(il, fact);
    		} else {
    			il.append(new ACONST_NULL());
    		}
			il.append(makeArgsObjectArray());
    		
    		il.append(fact.createInvoke("org.aspectj.runtime.reflect.Factory", 
    							"makeJP", LazyClassGen.tjpType,
    							new Type[] { LazyClassGen.staticTjpType,
    									Type.OBJECT, Type.OBJECT, new ArrayType(Type.OBJECT, 1)},
    							Constants.INVOKESTATIC));
    		il.append(thisJoinPointVar.createStore(fact));
    		range.insert(il, Range.OutsideBefore);
    	}
    	return thisJoinPointVar;
    }
================= fetch public Factory(String filename, Class lexicalClass) { 0c83343^:runtime/src/org/aspectj/runtime/reflect/Factory.java

public JoinPoint.StaticPart makeSJP(String kind, Signature sig, int l) {
        return new JoinPointImpl.StaticPartImpl(kind, sig, makeSourceLoc(l, -1));
    }
================= fetch public InstructionList getAdviceArgSetup( 0c83343^:weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java

public InstructionList getAdviceArgSetup(
		BcelShadow shadow,
		BcelVar extraVar,
		InstructionList closureInstantiation) 
	{
        InstructionFactory fact = shadow.getFactory();
        BcelWorld world = shadow.getWorld();
        InstructionList il = new InstructionList();

//        if (targetAspectField != null) {
//        	il.append(fact.createFieldAccess(
//        		targetAspectField.getDeclaringType().getName(),
//        		targetAspectField.getName(),
//        		BcelWorld.makeBcelType(targetAspectField.getType()),
//        		Constants.GETSTATIC));
//        }
//        
		//System.err.println("BcelAdvice: " + exposedState);


		if (exposedState.getAspectInstance() != null) {
			il.append(
				BcelRenderer.renderExpr(fact, world, exposedState.getAspectInstance()));
		}
        for (int i = 0, len = exposedState.size(); i < len; i++) {
            BcelVar v = (BcelVar) exposedState.get(i);
            if (v == null) continue;
            TypeX desiredTy = getSignature().getParameterTypes()[i];
            v.appendLoadAndConvert(il, fact, desiredTy.resolve(world));
        }

        
		if (getKind() == AdviceKind.Around) {
			il.append(closureInstantiation);
		} else if (hasExtraParameter()) {
			extraVar.appendLoadAndConvert(
				il,
				fact,
				getExtraParameterType().resolve(world));
		}
        
        // handle thisJoinPoint parameters
        // these need to be in that same order as parameters in 
        // org.aspectj.ajdt.internal.compiler.ast.AdviceDeclaration
        if ((getExtraParameterFlags() & ThisJoinPointStaticPart) != 0) {
        	shadow.getThisJoinPointStaticPartBcelVar().appendLoad(il, fact);
        }
        
        if ((getExtraParameterFlags() & ThisJoinPoint) != 0) {
        	shadow.getThisJoinPointBcelVar().appendLoad(il, fact);
        }
        

        if ((getExtraParameterFlags() & ThisEnclosingJoinPointStaticPart) != 0) {
        	shadow.getThisEnclosingJoinPointStaticPartBcelVar().appendLoad(il, fact);
        }
        
        
        return il;
    }
================= fetch public Var getArgVar(int i) { 0c83343^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public Var getArgVar(int i) {
        initializeArgVars();
        return argVars[i];
    }
================= fetch public final Var getThisEnclosingJoinPointStaticPartVar() { 0c83343^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public final Var getThisEnclosingJoinPointStaticPartVar() {
		return getThisEnclosingJoinPointStaticPartBcelVar();
	}
================= fetch public static Test suite() { 0c83343^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(AjdtBatchTests.class.getName());
        // Abstract superclass
        //suite.addTestSuite(CommandTestCase.class); 
        //$JUnit-BEGIN$
        suite.addTestSuite(BasicCommandTestCase.class); 
        suite.addTestSuite(BinaryFormsTestCase.class); 
        suite.addTestSuite(CompileAndRunTestCase.class); 
        suite.addTestSuite(ImageTestCase.class); 
        suite.addTestSuite(MultipleCompileTestCase.class); 
        // XXX suite.addTestSuite(VerifyWeaveTestCase.class); 
        //suite.addTestSuite(WorkingCommandTestCase.class); 
        //$JUnit-END$
        return suite;
    }
================= fetch public static void checkCompile(String source, int[] expectedErrors) { 0c83343^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CommandTestCase.java

public static void checkCompile(String source, int[] expectedErrors) {
		List args = new ArrayList();
		args.add("-verbose");
		
		args.add("-d");
		args.add("out");
		
		args.add("-classpath");		

		args.add(getRuntimeClasspath() + File.pathSeparator + 
			"../lib/junit/junit.jar");
		
		args.add("-g");  //XXX need this to get sourcefile and line numbers, shouldn't
		
		args.add(AjdtAjcTests.TESTDATA_PATH + "/" + source);
		
		runCompiler(args, expectedErrors);
	}
================= fetch public void doNotProceed() { 0c83343^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java

public void doNotProceed() {
		shouldProceed = false;
	}
================= fetch public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r 0c83343^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java
/**
         * Extract AspectJ-specific options (except for argfiles).
         * Caller should warn when sourceroots is empty but in 
         * incremental mode.
         * Signals warnings or errors through handler set in constructor.
         */
public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.remove()
			int nextArgIndex = args.indexOf(arg)+1; // XXX assumes unique
            // trim arg?
            if (LangUtil.isEmpty(arg)) {
                showWarning("empty arg found");
            } else if (arg.equals("-inpath")) {;
            	if (args.size() > nextArgIndex) {
					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_Inpath, CompilerOptions.PRESERVE);
					
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
					while (st.hasMoreTokens()) {
						String filename = st.nextToken();
						File file = makeFile(filename);
						if (file.exists() && FileUtil.hasZipSuffix(filename)) {
							buildConfig.getInpath().add(file);    
						} else {
							if (file.isDirectory()) {
								buildConfig.getInpath().add(file);
							} else 
		            		
							showError("bad inpath component: " + filename);  
						}
					}
					
					args.remove(args.get(nextArgIndex));            		
            	}
            } else if (arg.equals("-injars")) {;
				if (args.size() > nextArgIndex) {
					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_InJARs, CompilerOptions.PRESERVE);
					
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
		            	if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
			            	buildConfig.getInJars().add(jarFile);    
		            	} else {
		            		File dirFile = makeFile(filename);
		            		if (dirFile.isDirectory()) {
		            			buildConfig.getInJars().add(dirFile);
		            		} else 
		            		
                            showError("bad injar: " + filename);  
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-aspectpath")) {;
				if (args.size() > nextArgIndex) {
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
                        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
			            	buildConfig.getAspectpath().add(jarFile);    
		            	} else {
                            showError("bad aspectpath: " + filename);
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-sourceroots")) {
				if (args.size() > nextArgIndex) {
					List sourceRoots = new ArrayList();
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	File f = makeFile(st.nextToken());
		            	if (f.isDirectory() && f.canRead()) {
			                sourceRoots.add(f);
		            	} else {
                            showError("bad sourceroot: " + f);
		            	}		            		
		            }
				    if (0 < sourceRoots.size()) {
						buildConfig.setSourceRoots(sourceRoots);	
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-sourceroots requires list of directories");
				}
			} else if (arg.equals("-outjar")) { 
				if (args.size() > nextArgIndex) {
					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_OutJAR, CompilerOptions.GENERATE);
					File jarFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
					if (FileUtil.hasZipSuffix(jarFile)) {
						try {
							if (!jarFile.exists()) {
                                jarFile.createNewFile();
                            }
                            buildConfig.setOutputJar(jarFile);  
						} catch (IOException ioe) { 
                            showError("unable to create outjar file: " + jarFile);
						}
					} else {
						showError("invalid -outjar file: " + jarFile);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-outjar requires jar path argument");
				}
            } else if (arg.equals("-incremental")) {
                buildConfig.setIncrementalMode(true);
            } else if (arg.equals("-XincrementalFile")) {
                if (args.size() > nextArgIndex) {
                    File file = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    buildConfig.setIncrementalFile(file);
                    if (!file.canRead()) {
                        showError("bad -XincrementalFile : " + file);
                        // if not created before recompile test, stop after first compile
                    }
                    args.remove(args.get(nextArgIndex));
                } else {
                    showError("-XincrementalFile requires file argument");
                }
			} else if (arg.equals("-emacssym")) {
				buildConfig.setEmacsSymMode(true);
				buildConfig.setGenerateModelMode(true);
			} else if (arg.equals("-noweave") || arg.equals( "-XnoWeave")) {
				buildConfig.setNoWeave(true);
			} else if (arg.equals("-XserializableAspects")) {
				buildConfig.setXserializableAspects(true);
			} else if (arg.equals("-XnoInline")) {
				buildConfig.setXnoInline(true);
			} else if (arg.equals("-Xlintfile")) { 
				if (args.size() > nextArgIndex) {
					File lintSpecFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    // XXX relax restriction on props file suffix?
					if (lintSpecFile.canRead() && lintSpecFile.getName().endsWith(".properties")) {
						buildConfig.setLintSpecFile(lintSpecFile);	
					} else {
						showError("bad -Xlintfile file: " + lintSpecFile);
						buildConfig.setLintSpecFile(null);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-Xlintfile requires .properties file argument");
				}
            } else if (arg.equals("-Xlint")) {
                buildConfig.getAjOptions().put(
                    AjCompilerOptions.OPTION_Xlint,
                    CompilerOptions.GENERATE);
                buildConfig.setLintMode(AjBuildConfig.AJLINT_DEFAULT);
            } else if (arg.startsWith("-Xlint:")) {
                if (7 < arg.length()) {
                    buildConfig.setLintMode(arg.substring(7));
                } else {
                    showError("invalid lint option " + arg);
                }
			} else if (arg.equals("-bootclasspath")) {
				if (args.size() > nextArgIndex) {
					bootclasspath = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-bootclasspath requires classpath entries");
				}
			} else if (arg.equals("-classpath")) {
				if (args.size() > nextArgIndex) {
					classpath = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-classpath requires classpath entries");
				}
			} else if (arg.equals("-extdirs")) {
				if (args.size() > nextArgIndex) {
					extdirs = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					args.remove(args.get(nextArgIndex));
                } else {
                    showError("-extdirs requires list of external directories");
                }
            // error on directory unless -d, -{boot}classpath, or -extdirs
            } else if (arg.equals("-d")) {
                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-classpath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-bootclasspath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-extdirs")) {
//                dirLookahead(arg, args, nextArgIndex);
            } else if (new File(arg).isDirectory()) {
                showError("dir arg not permitted: " + arg);
			} else {
                // argfile, @file parsed by superclass
                // no eclipse options parsed:
                // -d args, -help (handled), 
                // -classpath, -target, -1.3, -1.4, -source [1.3|1.4]
                // -nowarn, -warn:[...], -deprecation, -noImportError,
                // -proceedOnError, -g:[...], -preserveAllLocals,
                // -referenceInfo, -encoding, -verbose, -log, -time
                // -noExit, -repeat
		    	unparsedArgs.add(arg);
			}
        }
================= fetch public void setXnoInline(boolean xnoInline) { 0c83343^:weaver/src/org/aspectj/weaver/World.java

public ResolvedTypeX.Name lookupOrCreateName(TypeX ty) {
		String signature = ty.getSignature();
        ResolvedTypeX.Name ret = (ResolvedTypeX.Name)typeMap.get(signature);
        if (ret == null) {
        	ret = new ResolvedTypeX.Name(signature, this);
        	typeMap.put(signature, ret);
        }
        
		return ret;
	}
================= fetch public void specializeOn(Shadow shadow) { 0c83343^:weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java
// ---- implementations of ShadowMunger's methods
public void specializeOn(Shadow shadow) {
	  	if (getKind() == AdviceKind.Around) {
	  		((BcelShadow)shadow).initializeForAroundClosure();
	  	}
    	
    	//XXX this case is just here for supporting lazy test code
    	if (getKind() == null) {
			exposedState = new ExposedState(0);
    		return;
    	}
    	if (getKind().isPerEntry()) {
    		exposedState = new ExposedState(0);
    	} else if (getKind().isCflow()) {
    		exposedState = new ExposedState(nFreeVars);
    	} else if (getSignature() != null) {
			exposedState = new ExposedState(getSignature());
    	} else {
    		exposedState = new ExposedState(0);
    		return;  //XXX this case is just here for supporting lazy test code
    	}
		pointcutTest = getPointcut().findResidue(shadow, exposedState);
		
		// these initializations won't be performed by findResidue, but need to be
		// so that the joinpoint is primed for weaving
		if (getKind() == AdviceKind.PerThisEntry) {
			shadow.getThisVar();
		} else if (getKind() == AdviceKind.PerTargetEntry) {
			shadow.getTargetVar();
		}
		
		
        // make sure thisJoinPoint parameters are initialized
        if ((getExtraParameterFlags() & ThisJoinPointStaticPart) != 0) {
        	((BcelShadow)shadow).getThisJoinPointStaticPartVar();
        }

        if ((getExtraParameterFlags() & ThisJoinPoint) != 0) {
        	((BcelShadow)shadow).getThisJoinPointVar();
        }
        
        if ((getExtraParameterFlags() & ThisEnclosingJoinPointStaticPart) != 0) {
        	((BcelShadow)shadow).getThisEnclosingJoinPointStaticPartVar();
        }
    }
================= fetch private static List getPathEntries(String s) { f24286d^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java

private static List getPathEntries(String s) {
		List ret = new ArrayList();
		StringTokenizer tok = new StringTokenizer(s, File.pathSeparator);

      	while(tok.hasMoreTokens()) ret.add(tok.nextToken());
      	
      	return ret;
	}
================= fetch private void implementMungers() { f24286d^:weaver/src/org/aspectj/weaver/Shadow.java
/** Actually implement the (non-empty) mungers associated with this shadow */
private void implementMungers() {
		World world = getIWorld();
		for (Iterator iter = mungers.iterator(); iter.hasNext();) {
			ShadowMunger munger = (ShadowMunger) iter.next();
			munger.implementOn(this);
			if (world.getModel() != null) {
				//System.err.println("munger: " + munger + " on " + this);
				AsmRelationshipProvider.adviceMunger(world.getModel(), this, munger);
			}
		}
	}
================= fetch private void initBcelWorld(IMessageHandler handler) throws IOException { f24286d^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
/** init only on initial batch compile? no file-specific options */
private void initBcelWorld(IMessageHandler handler) throws IOException {
		bcelWorld = new BcelWorld(buildConfig.getClasspath(), handler);
		bcelWorld.setXnoInline(buildConfig.isXnoInline());
		bcelWeaver = new BcelWeaver(bcelWorld);
		
		for (Iterator i = buildConfig.getAspectpath().iterator(); i.hasNext();) {
			File f = (File) i.next();
			bcelWeaver.addLibraryJarFile(f);
		}
		
		String lintMode = buildConfig.getLintMode();
		
		if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
			bcelWorld.getLint().loadDefaultProperties();
		} else {
			bcelWorld.getLint().setAll(buildConfig.getLintMode());
		}
		
		if (buildConfig.getLintSpecFile() != null) {
			bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
		}
		
		//??? incremental issues
		for (Iterator i = buildConfig.getInJars().iterator(); i.hasNext(); ) {
			File inJar = (File)i.next();
			bcelWeaver.addJarFile(inJar, buildConfig.getOutputDir(),false);
		}
		
		for (Iterator i = buildConfig.getInpath().iterator(); i.hasNext(); ) {
			File inPathElement = (File)i.next();
			bcelWeaver.addJarFile(inPathElement,buildConfig.getOutputDir(),true);
		}
		
		if (buildConfig.getSourcePathResources() != null) {
			for (Iterator i = buildConfig.getSourcePathResources().keySet().iterator(); i.hasNext(); ) {
	//			File resource = (File)i.next();
				String resource = (String)i.next();
				bcelWeaver.addResource(resource, (File)buildConfig.getSourcePathResources().get(resource), buildConfig.getOutputDir());
	//			bcelWeaver.addResource(resource, buildConfig.getOutputDir());
			}
		}
		//check for org.aspectj.runtime.JoinPoint
		bcelWorld.resolve("org.aspectj.lang.JoinPoint");
	}
================= fetch public BcelWorld(List classPath, IMessageHandler handler) { f24286d^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java

private static List getPathEntries(String s) {
		List ret = new ArrayList();
		StringTokenizer tok = new StringTokenizer(s, File.pathSeparator);

      	while(tok.hasMoreTokens()) ret.add(tok.nextToken());
      	
      	return ret;
	}
================= fetch public BcelWorld(String cp) { f24286d^:weaver/src/org/aspectj/weaver/bcel/BcelWorld.java

================= fetch public boolean match(Shadow shadow, World world) { f24286d^:weaver/src/org/aspectj/weaver/Checker.java

public boolean match(Shadow shadow, World world) {
		if (super.match(shadow, world)) {
			IMessage message = new Message(
				msg,
				shadow.toString(),
				isError ? IMessage.ERROR : IMessage.WARNING,
				shadow.getSourceLocation(),
                null,
                new ISourceLocation[]{this.getSourceLocation()});
			world.getMessageHandler().handleMessage(message);
			
			AsmRelationshipProvider.checkerMunger(world.getModel(), shadow, this);
		}
		return false;
	}
================= fetch public void setMessageHandler(IMessageHandler messageHandler) { f24286d^:weaver/src/org/aspectj/weaver/World.java

public void setMessageHandler(IMessageHandler messageHandler) {
		this.messageHandler = messageHandler;
	}
================= fetch protected boolean assemble(Module module, File classesDir, List errors) { 6f099df^:build/src/org/aspectj/internal/tools/ant/taskdefs/AntBuilder.java
/**
	 * @see org.aspectj.internal.tools.build.Builder#buildAntecedants(Module)
	 */
protected String[] getAntecedantModuleNames(Module module, boolean rebuild) {
        Hashtable targets = new Hashtable();
        makeTargetsForModule(module, targets, rebuild);   
        // XXX bug: doc says topoSort returns String, but returns Target 
        Collection result = project.topoSort(module.name, targets);
        // XXX is it topoSort that should detect cycles?
        int size = result.size();
        if (0 == result.size()) {
            return new String[0];
        }
        ArrayList toReturn = new ArrayList();
        for (Iterator iter = result.iterator(); iter.hasNext();) {
            Target target = (Target) iter.next();
            String name = target.getName();
            if (null == name) {
                throw new Error("null name?");
            } else {
                toReturn.add(name);
            }
        }
        // topoSort always returns module.name    
        if ((1 == size) 
            && module.name.equals(toReturn.get(0))
            && !module.outOfDate(false)) {
            return new String[0];
        }
        return (String[]) toReturn.toArray(new String[0]);
    }
Progress : [######################################--] 97%================= fetch public void runMain(String[] args, boolean useSystemExit) { b3b1eec^:org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java
/**
     * Run without throwing exceptions but optionally using System.exit(..).
     * This sets up a message handler which emits messages immediately,
     * so report(boolean, IMessageHandler) only reports total number
     * of errors or warnings.
     * @param args the String[] command line for the compiler
     * @param useSystemExit if true, use System.exit(int) to complete
     *         unless one of the args is -noExit. 
     * and signal result (0 no exceptions/error, <0 exceptions, >0 compiler errors).
     */
public void runMain(String[] args, boolean useSystemExit) {
        boolean verbose = (-1 != ("" + LangUtil.arrayAsList(args)).indexOf("-verbose"));
        IMessageHolder holder = clientHolder;
        if (null == holder) {
            holder = ourHandler;
            if (verbose) {
                ourHandler.setInterceptor(MessagePrinter.VERBOSE);
            } else {
                ourHandler.ignore(IMessage.INFO);
                ourHandler.setInterceptor(MessagePrinter.TERSE);
            }
        }
        run(args, holder);

        boolean skipExit = false;
        if (useSystemExit && !LangUtil.isEmpty(args)) {  // sigh - pluck -noExit
            for (int i = 0; i < args.length; i++) {
				if ("-noExit".equals(args[i])) {
                    skipExit = true;
                    break;
                }
			}
        }
        if (useSystemExit && !skipExit) {
            systemExit(holder);
        }
    }
================= fetch public SoftException(Throwable inner) { ad2fb7a^:runtime/src/org/aspectj/lang/SoftException.java

public Throwable getCause() { return inner; }
================= fetch public static TestSuite suite() { ad2fb7a^:runtime/testsrc/RuntimeModuleTests.java

public static TestSuite suite() { 
        TestSuite suite = new TestSuite(RuntimeModuleTests.class.getName());
        suite.addTestSuite(RuntimeModuleTests.class); // minimum 1 test (testNothing)
        return suite;
    }
================= fetch public void testNoAspectBoundException() { ad2fb7a^:runtime/testsrc/RuntimeModuleTests.java

public void testNoAspectBoundException() {
    	RuntimeException fun = new RuntimeException("fun");
    	NoAspectBoundException nab = new NoAspectBoundException("Foo", fun);
    	assertEquals(fun,nab.getCause());
    }
================= fetch private List getInterTypeMungersIncludingSupers() { 0071cb4^:weaver/src/org/aspectj/weaver/ResolvedTypeX.java

private List getInterTypeMungersIncludingSupers() {
        ArrayList ret = new ArrayList();
        collectInterTypeMungers(ret);
        return ret;
    }
================= fetch public List getInterTypeMungers() { 0071cb4^:weaver/src/org/aspectj/weaver/ResolvedTypeX.java

public List getInterTypeMungers() {
		return interTypeMungers;
	}
================= fetch public void abstractMethodMustBeImplemented( 0071cb4^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java

public void abstractMethodMustBeImplemented(
		SourceTypeBinding type,
		MethodBinding abstractMethod)
	{
		// if this is a PointcutDeclaration then there is no error
		if (isPointcutDeclaration(abstractMethod)) {
			return;
		}
		
		if (CharOperation.prefixEquals("ajc$interField".toCharArray(), abstractMethod.selector)) {
			//??? think through how this could go wrong
			return;
		}
		
		// if we implemented this method by an inter-type declaration, then there is no error
		//??? be sure this is always right
		ResolvedTypeX onTypeX = factory.fromEclipse(type); //abstractMethod.declaringClass);
		for (Iterator i = onTypeX.getInterTypeMungers().iterator(); i.hasNext(); ) {
			ConcreteTypeMunger m = (ConcreteTypeMunger)i.next();
			if (m.matches(onTypeX)) {
				ResolvedMember sig = m.getSignature();
                if (!Modifier.isAbstract(sig.getModifiers())) {
					if (ResolvedTypeX
						.matches(
							AjcMemberMaker.interMethod(
								sig,
								m.getAspectType(),
								sig.getDeclaringType().isInterface(
									factory.getWorld())),
							EclipseFactory.makeResolvedMember(abstractMethod))) {
						return;
					}
				}
			}
		}

		super.abstractMethodMustBeImplemented(type, abstractMethod);
	}
================= fetch private NameMangler() { 5834de9^:weaver/src/org/aspectj/weaver/NameMangler.java

================= fetch private void match( 5834de9^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

private void match(
		LazyMethodGen mg,
		InstructionHandle ih,
		BcelShadow enclosingShadow,
		List shadowAccumulator) 
	{
		Instruction i = ih.getInstruction();
		if (i instanceof FieldInstruction) {
			FieldInstruction fi = (FieldInstruction) i;
						
			if (fi instanceof PUTFIELD || fi instanceof PUTSTATIC) {
				// check for sets of constant fields.  We first check the previous 
				// instruction.  If the previous instruction is a LD_WHATEVER (push
				// constant on the stack) then we must resolve the field to determine
				// if it's final.  If it is final, then we don't generate a shadow.
				InstructionHandle prevHandle = ih.getPrev();
				Instruction prevI = prevHandle.getInstruction();
				if (Utility.isConstantPushInstruction(prevI)) {
					Member field = BcelWorld.makeFieldSignature(clazz, (FieldInstruction) i);
					ResolvedMember resolvedField = field.resolve(world);
					if (resolvedField == null) {
						// we can't find the field, so it's not a join point.
					} else if (Modifier.isFinal(resolvedField.getModifiers())) {
						// it's final, so it's the set of a final constant, so it's
						// not a join point according to 1.0.6 and 1.1.
					} else {
						matchSetInstruction(mg, ih, enclosingShadow, shadowAccumulator);
					}						
				} else {
					matchSetInstruction(mg, ih, enclosingShadow, shadowAccumulator);
				}
			} else {
				matchGetInstruction(mg, ih, enclosingShadow, shadowAccumulator);
			}
		} else if (i instanceof InvokeInstruction) {
			InvokeInstruction ii = (InvokeInstruction) i;
			if (ii.getMethodName(clazz.getConstantPoolGen()).equals("<init>")) {
				match(
					BcelShadow.makeConstructorCall(world, mg, ih, enclosingShadow),
					shadowAccumulator);
			} else if (ii instanceof INVOKESPECIAL) {
				String onTypeName = ii.getClassName(cpg);
				if (onTypeName.equals(mg.getEnclosingClass().getName())) {
					// we are private
					matchInvokeInstruction(mg, ih, ii, enclosingShadow, shadowAccumulator);
				} else {
					// we are a super call, and this is not a join point in AspectJ-1.{0,1}
				}
			} else {
					matchInvokeInstruction(mg, ih, ii, enclosingShadow, shadowAccumulator);
			}
		} 
		// performance optimization... we only actually care about ASTORE instructions, 
		// since that's what every javac type thing ever uses to start a handler, but for
		// now we'll do this for everybody.
		if (Range.isRangeHandle(ih)) return;
		InstructionTargeter[] targeters = ih.getTargeters();
		if (targeters != null) {
			for (int j = 0; j < targeters.length; j++) {
				InstructionTargeter t = targeters[j];
				if (t instanceof ExceptionRange) {
					// assert t.getHandler() == ih
					ExceptionRange er = (ExceptionRange) t;
					if (er.getCatchType() == null) continue;
					match(
						BcelShadow.makeExceptionHandler(
							world, 
							er,
							mg, ih, enclosingShadow),
						shadowAccumulator);
				}
			}
		}
	}
================= fetch private void matchGetInstruction(LazyMethodGen mg, InstructionHandle ih, BcelSha 5834de9^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

private void matchGetInstruction(LazyMethodGen mg, InstructionHandle ih, BcelShadow enclosingShadow, List shadowAccumulator) {
		FieldInstruction fi = (FieldInstruction) ih.getInstruction();
		Member field = BcelWorld.makeFieldSignature(clazz, fi);
		ResolvedMember resolvedField = field.resolve(world);
		if (resolvedField == null) {
			// we can't find the field, so it's not a join point.
			return;
		} else if (resolvedField.isSynthetic()) {
			// sets of synthetics aren't join points in 1.1
			return;
		} else {
			match(BcelShadow.makeFieldGet(world, mg, ih, enclosingShadow), shadowAccumulator);
		}
	}
================= fetch private void matchSetInstruction( 5834de9^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

private void matchSetInstruction(
		LazyMethodGen mg,
		InstructionHandle ih,
		BcelShadow enclosingShadow,
		List shadowAccumulator) {
		FieldInstruction fi = (FieldInstruction) ih.getInstruction();
		Member field = BcelWorld.makeFieldSignature(clazz, fi);
		ResolvedMember resolvedField = field.resolve(world);
		if (resolvedField == null) {
			// we can't find the field, so it's not a join point.
			return;
		} else if (
			Modifier.isFinal(resolvedField.getModifiers())
				&& Utility.isConstantPushInstruction(ih.getPrev().getInstruction())) {
			// it's the set of a final constant, so it's
			// not a join point according to 1.0.6 and 1.1.
			return;
		} else if (resolvedField.isSynthetic()) {
			// sets of synthetics aren't join points in 1.1
			return;
		} else {
			match(
				BcelShadow.makeFieldSet(world, mg, ih, enclosingShadow),
				shadowAccumulator);
		}
	}
================= fetch protected void generatePostSyntheticCode( 5834de9^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java

protected void generatePostSyntheticCode(
		ClassScope classScope,
		CodeStream codeStream)
	{
		super.generatePostSyntheticCode(classScope, codeStream);
		if (hasPost) {
			final EclipseFactory world = EclipseFactory.fromScopeLookupEnvironment(classScope);

			codeStream.invokestatic(world.makeMethodBindingForCall(
				AjcMemberMaker.ajcPostClinitMethod(
					world.fromBinding(classScope.referenceContext.binding)
				)));
		}
		
	}
================= fetch protected void generateSyntheticCode( 5834de9^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java

protected void generateSyntheticCode(
		ClassScope classScope,
		CodeStream codeStream) 
	{
		if (hasPre) {
			final EclipseFactory world = EclipseFactory.fromScopeLookupEnvironment(classScope);

			codeStream.invokestatic(world.makeMethodBindingForCall(
				AjcMemberMaker.ajcPreClinitMethod(
					world.fromBinding(classScope.referenceContext.binding)
				)));
		}
		super.generateSyntheticCode(classScope, codeStream);
	}
================= fetch public AspectClinit(Clinit old, CompilationResult compilationResult, boolean has 5834de9^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java

================= fetch public boolean canBeSeenBy( 5834de9^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java

public void checkSpec(ClassScope scope) {
		if (ignoreFurtherInvestigation) return;
		if (dominatesPattern != null) {
			scope.problemReporter().signalError(
					dominatesPattern.getStart(), dominatesPattern.getEnd(), 
					"dominates has changed for 1.1, use 'declare precedence: " +
					new String(this.name) + ", " + dominatesPattern.toString() + ";' " +
					"in the body of the aspect instead");
		}
		
		if (!isAbstract()) {
			MethodBinding[] methods = binding.methods();
			for (int i=0, len = methods.length; i < len; i++) {
				MethodBinding m = methods[i];
				if (m.isConstructor()) {
					// this make all constructors in aspects invisible and thus uncallable
					//XXX this only works for aspects that come from source
					methods[i] = new MethodBinding(m, binding) {
						public boolean canBeSeenBy(
							InvocationSite invocationSite,
							Scope scope) {
							return false;
						}
					};
					
					if (m.parameters != null && m.parameters.length != 0) {
						scope.problemReporter().signalError(m.sourceStart(), m.sourceEnd(),
								"only zero-argument constructors allowed in concrete aspect");
					}
				}
			}
		}
		
		if (this.enclosingType != null) {
			if (!Modifier.isStatic(modifiers)) {
				scope.problemReporter().signalError(sourceStart, sourceEnd,
								"inner aspects must be static");
				ignoreFurtherInvestigation = true;
			    return;
			}
		}
		
		
		EclipseFactory world = EclipseFactory.fromScopeLookupEnvironment(scope);
		ResolvedTypeX myType = typeX;
		//if (myType == null) System.err.println("bad myType for: " + this);
		ResolvedTypeX superType = myType.getSuperclass();		
		
		// can't be Serializable/Cloneable unless -XserializableAspects
		if (!world.buildManager.buildConfig.isXserializableAspects()) {
			if (world.getWorld().resolve(TypeX.SERIALIZABLE).isAssignableFrom(myType)) {
				scope.problemReporter().signalError(sourceStart, sourceEnd,
								"aspects may not implement Serializable");
				ignoreFurtherInvestigation = true;
			    return;
			}
			if (world.getWorld().resolve(TypeX.CLONEABLE).isAssignableFrom(myType)) {
				scope.problemReporter().signalError(sourceStart, sourceEnd,
								"aspects may not implement Cloneable");
				ignoreFurtherInvestigation = true;
			    return;
			}

		}

		if (superType.isAspect()) {
			if (!superType.isAbstract()) {
				scope.problemReporter().signalError(sourceStart, sourceEnd,
								"can not extend a concrete aspect");
				ignoreFurtherInvestigation = true;
				return;
			}
		}
	}
================= fetch public static Member noAspectBoundExceptionInit() { 5834de9^:weaver/src/org/aspectj/weaver/AjcMemberMaker.java

public static Member noAspectBoundExceptionInit() {
		return new ResolvedMember(
			Member.METHOD,
			NO_ASPECT_BOUND_EXCEPTION,
			Modifier.PUBLIC,
			"<init>",
			"()V");
	}
================= fetch public static ResolvedMember perSingletonField(TypeX declaringType) { 5834de9^:weaver/src/org/aspectj/weaver/AjcMemberMaker.java

public static ResolvedMember perSingletonField(TypeX declaringType) {
		return new ResolvedMember(
			Member.FIELD, 
			declaringType,
			PUBLIC_STATIC_FINAL,
			NameMangler.PERSINGLETON_FIELD_NAME,
			declaringType.getSignature());
	}
================= fetch public static void main(String[] args) { 5834de9^:tests/new/ConstructorExecInitFails.java

public static void main(String[] args) {
    	try {
        	new ConstructorExecInitFails();
    	} catch (ExceptionInInitializerError e) {
    		return;
    	}
        Tester.checkFailed("shouldn't be able to run");
    }
================= fetch public void generate(CodeStream codeStream) { 5834de9^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java

private PerClause.Kind lookupPerClauseKind(ReferenceBinding binding) {
        PerClause perClause;
        if (binding instanceof BinaryTypeBinding) {
            ResolvedTypeX superTypeX = factory.fromEclipse(binding);
            perClause = superTypeX.getPerClause();
        } else if (binding instanceof SourceTypeBinding ) {
			SourceTypeBinding sourceSc = (SourceTypeBinding)binding;
			if (sourceSc.scope.referenceContext instanceof AspectDeclaration) {
				perClause = ((AspectDeclaration)sourceSc.scope.referenceContext).perClause;
			} else {
				return null;
			}
		} else {
			//XXX need to handle this too
			return null;
		}
        if (perClause == null) {
            return lookupPerClauseKind(binding.superclass()); 
        } else {
            return perClause.getKind();
	    }
    }
================= fetch public void generateCode(ClassFile enclosingClassFile) { 5834de9^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java

void generateCode(ClassFile enclosingClassFile) {
		if (ignoreFurtherInvestigation) {
			if (binding == null)
				return;
			ClassFile.createProblemType(
				this,
				scope.referenceCompilationUnit().compilationResult);
			return;
		}
		
		
		// make me and my binding public
		this.modifiers = AstUtil.makePublic(this.modifiers);
		this.binding.modifiers = AstUtil.makePublic(this.binding.modifiers);
		
		
		if (!isAbstract()) {
			if (perClause == null) {
				// we've already produced an error for this
			} else if (perClause.getKind() == PerClause.SINGLETON) {
				binding.addField(factory.makeFieldBinding(AjcMemberMaker.perSingletonField(
						typeX)));
				methods[0] = new AspectClinit((Clinit)methods[0], compilationResult, false, true);
			} else if (perClause.getKind() == PerClause.PERCFLOW) {
				binding.addField(
					factory.makeFieldBinding(
						AjcMemberMaker.perCflowField(
							typeX)));
				methods[0] = new AspectClinit((Clinit)methods[0], compilationResult, true, false);
			} else if (perClause.getKind() == PerClause.PEROBJECT) {
//				binding.addField(
//					world.makeFieldBinding(
//						AjcMemberMaker.perCflowField(
//							typeX)));
			} else {
				throw new RuntimeException("unimplemented");
			}
		}

		if (EclipseFactory.DEBUG) System.out.println(toString());
		
		super.generateCode(enclosingClassFile);
	}
================= fetch public void testNothing() {} 5834de9^:runtime/testsrc/RuntimeModuleTests.java

public void testNothing() {}
================= fetch protected void consumeAspectHeaderName(boolean isPrivileged) { 7bbd1f4^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/parser/AjParser.java

protected void consumeAspectHeaderName(boolean isPrivileged) {
		// (isPrivileged == false) -> AspectHeaderName ::= Modifiersopt 'aspect' 'Identifier'
		// (isPrivileged == true) -> AspectHeaderName ::= Modifiersopt 'privileged' Modifiersopt 'aspect' 'Identifier'
		AspectDeclaration aspectDecl =
			new AspectDeclaration(this.compilationUnit.compilationResult);

		println("aspect header name: ");
		this.display();

		//highlight the name of the type
		long pos = identifierPositionStack[identifierPtr];
		aspectDecl.sourceEnd = (int) pos;
		aspectDecl.sourceStart = (int) (pos >>> 32);
		aspectDecl.name = identifierStack[identifierPtr--];
		identifierLengthPtr--;

		// pop the aspect pseudo-token
		eatIdentifier();


		// handle modifiers, only without privileged for now
		if (isPrivileged) {
			pos = eatIdentifier(); // eat the privileged
			int end = (int) pos;
		    int start = (int) (pos >>> 32);
		    aspectDecl.isPrivileged = true;
			//problemReporter().signalError(start, end, "privileged is unimplemented in 1.1alpha1");
		}
		aspectDecl.modifiersSourceStart = intStack[intPtr--];
		aspectDecl.modifiers = intStack[intPtr--];
		if (aspectDecl.modifiersSourceStart >= 0) {
			aspectDecl.declarationSourceStart = aspectDecl.modifiersSourceStart;
		}

		println("modifiers: " + aspectDecl.modifiers);

		aspectDecl.bodyStart = aspectDecl.sourceEnd + 1;
		pushOnAstStack(aspectDecl);

		listLength = 0; // will be updated when reading super-interfaces
		// recovery
		if (currentElement != null) {
			lastCheckPoint = aspectDecl.bodyStart;
			currentElement = currentElement.add(aspectDecl, 0);
			lastIgnoredToken = -1;
		}

		this.display();
	}
Progress : [#######################################-] 98%================= fetch public void testBadInJars() throws InvalidInputException { a4a1234^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java

public void testBadInJars() throws InvalidInputException {
		final String SOURCE_JARS = AjdtAjcTests.TESTDATA_PATH + "/testclasses.jar" + File.pathSeparator + "b.far" + File.pathSeparator + "c.jar";
		AjBuildConfig config = parser.genBuildConfig(new String[] { 
			"-injars", SOURCE_JARS }, 
			messageWriter);
		assertTrue("size: " + config.getInJars().size(), config.getInJars().size() == 1);
	}
================= fetch void addFiles(File dir, FileFilter filter) { a4a1234^:util/src/org/aspectj/util/ConfigParser.java

public boolean accept(File f) {
                        return f != null && f.getName().endsWith(".aj");
                    }
================= fetch protected void consumeExtraParameterNoFormal() { 7b081f2^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/parser/AjParser.java

protected void consumeExtraParameterNoFormal() {
		
		
	    long pos = identifierPositionStack[identifierPtr];
	    int end = (int) pos;
		int start = (int) (pos >>> 32);
	    char[] name = identifierStack[identifierPtr--];
	    identifierLengthPtr--;
	    
	    //System.out.println("extra parameter: " + new String(name));
	    
	    AdviceDeclaration adviceDecl = (AdviceDeclaration)astStack[astPtr];
	    if (adviceDecl.kind != AdviceKind.After) {
	    	//XXX error, extra param makes no sense here
	    }
	    
	    if (CharOperation.equals(name, "throwing".toCharArray())) {
	    	adviceDecl.kind = AdviceKind.AfterThrowing;
	    } else if (CharOperation.equals(name, "returning".toCharArray())) {
	    	adviceDecl.kind = AdviceKind.AfterReturning;
	    } else {
	    	//XXX illegal name here
	    }
	}
================= fetch private final static Collection sort(String str) { 97ab1e9^:tests/new/CallTypesI.java

private final static Collection sort(String str) {
        SortedSet sort = new TreeSet();
        for (StringTokenizer t = new StringTokenizer(str, ",", false);
             t.hasMoreTokens();) {
            String s = t.nextToken().trim();
            if (s.length() > 0) sort.add(s);
        }
        return sort;
    }
================= fetch protected String render(IMessage message) { 97ab1e9^:org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java
/**
         * Render message differently.
         * If abort, then prefix stack trace with feedback request.
         * If the actual message is empty, then use toString on the whole.
         * Prefix message part with file:line;
         * If it has context, suffix message with context.
         * @param message the IMessage to render
         * @return String rendering IMessage (never null)
         */
protected String render(IMessage message) {
            IMessage.Kind kind = message.getKind();
            
            StringBuffer sb = new StringBuffer();
            String text = message.getMessage();
            if (text.equals(AbortException.NO_MESSAGE_TEXT)) {
                text = null;
            }
            boolean toString = (LangUtil.isEmpty(text));
            if (toString) {
                text = message.toString();
            }
            ISourceLocation loc = message.getSourceLocation();
            String context = null;
            if (null != loc) {
                File file = loc.getSourceFile();
                if (null != file) {
                    String name = file.getName();
                    if (!toString || (-1 == text.indexOf(name))) {                        
                        sb.append(FileUtil.getBestPath(file));
                        sb.append(":" + loc.getLine());
                        int col = loc.getColumn();
                        if (0 < col) {
                            sb.append(":" + col);
                        }
                        sb.append(" ");
                    }
                }
                context = loc.getContext();
            }
            sb.append(text);
            if (null != context) {
                sb.append(LangUtil.EOL);
                sb.append(context);
            }
            Throwable thrown = message.getThrown();
            if (null != thrown) {
                sb.append(LangUtil.EOL);
                sb.append(Main.renderExceptionForUser(thrown));
            }
            
            return sb.toString();
        }
================= fetch public FuzzyBoolean match(Shadow shadow) { 97ab1e9^:weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java

public FuzzyBoolean match(Shadow shadow) {
		if (shadow.getKind() != kind) return FuzzyBoolean.NO;
		
		if (!signature.matches(shadow.getSignature(), shadow.getIWorld())) return  FuzzyBoolean.NO;

		return  FuzzyBoolean.YES;
	}
================= fetch public Message(String message, IMessage.Kind kind, Throwable thrown, 97ab1e9^:bridge/src/org/aspectj/bridge/Message.java
/** @return the kind of this message */
public IMessage.Kind getKind() {
        return kind;
    }
================= fetch public Message(String message, String details, IMessage.Kind kind, 97ab1e9^:bridge/src/org/aspectj/bridge/Message.java

================= fetch public Pointcut concretize(ResolvedTypeX inAspect, IntMap bindings) { 97ab1e9^:weaver/src/org/aspectj/weaver/patterns/Pointcut.java

public Pointcut concretize(ResolvedTypeX inAspect, IntMap bindings) {
		assertState(RESOLVED);
		Pointcut ret = this.concretize1(inAspect, bindings);
		ret.state = CONCRETE;
		return ret;
	}
================= fetch public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) { 97ab1e9^:weaver/src/org/aspectj/weaver/patterns/AndPointcut.java

public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {
		return new AndPointcut(left.concretize1(inAspect, bindings),
								right.concretize1(inAspect, bindings));
	}
================= fetch public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) { 97ab1e9^:weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java

public Shadow.Kind getKind() {
		return kind;
	}
================= fetch public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) { 97ab1e9^:weaver/src/org/aspectj/weaver/patterns/NotPointcut.java

public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {
		return new NotPointcut(body.concretize1(inAspect, bindings));
	}
================= fetch public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) { 97ab1e9^:weaver/src/org/aspectj/weaver/patterns/OrPointcut.java

public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {
		return new OrPointcut(left.concretize1(inAspect, bindings),
								right.concretize1(inAspect, bindings));
	}
================= fetch public Pointcut concretize1(ResolvedTypeX searchStart, IntMap bindings) { 97ab1e9^:weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java

public Pointcut concretize1(ResolvedTypeX searchStart, IntMap bindings) {
		if (concretizing) {
			//Thread.currentThread().dumpStack();
			searchStart.getWorld().getMessageHandler().handleMessage(
				MessageUtil.error("circular pointcut declaration involving: " + this,
									getSourceLocation()));
			return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
		}
		
		try {
			concretizing = true;
		
			ResolvedPointcutDefinition pointcutDec;
			if (onType != null) {
				searchStart = onType.resolve(searchStart.getWorld());
				if (searchStart == ResolvedTypeX.MISSING) {
					return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
				}
			}
			pointcutDec = searchStart.findPointcut(name);
			if (pointcutDec == null) {
				searchStart.getWorld().getMessageHandler().handleMessage(
					MessageUtil.error("can't find pointcut \'" + name + "\' on " + searchStart.getName(), 
									getSourceLocation())
				);
				return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
			}
			
			if (pointcutDec.isAbstract()) {
				//Thread.currentThread().dumpStack();
				ShadowMunger enclosingAdvice = bindings.getEnclosingAdvice();
				searchStart.getWorld().showMessage(IMessage.ERROR,
					pointcutDec + " is abstract", 
					getSourceLocation(), 
					(null == enclosingAdvice) ? null : enclosingAdvice.getSourceLocation());
				return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
			}
					
			//System.err.println("start: " + searchStart);
			ResolvedTypeX[] parameterTypes = searchStart.getWorld().resolve(pointcutDec.getParameterTypes());
			
			TypePatternList arguments = this.arguments.resolveReferences(bindings);
			
			IntMap newBindings = new IntMap();
			for (int i=0,len=arguments.size(); i < len; i++) {
				TypePattern p = arguments.get(i);
				//we are allowed to bind to pointcuts which use subtypes as this is type safe
				if (!p.matchesSubtypes(parameterTypes[i])  && 
					!p.getExactType().equals(TypeX.OBJECT))
				{
					throw new BCException("illegal change to pointcut declaration: " + this);
				}
				
			    if (p instanceof BindingTypePattern) {
			    	newBindings.put(i, ((BindingTypePattern)p).getFormalIndex());
			    }
			}
			
			newBindings.copyContext(bindings);
			newBindings.pushEnclosingDefinition(pointcutDec);
			try {
				return pointcutDec.getPointcut().concretize1(searchStart, newBindings);
			} finally {
				newBindings.popEnclosingDefinitition();
			}
			
		} finally {
			concretizing = false;
		}
	}
================= fetch public String getDetails() { 97ab1e9^:bridge/src/org/aspectj/bridge/Message.java

public String getDetails() {
		return details;
	}
================= fetch public String toString() { 97ab1e9^:bridge/src/org/aspectj/bridge/IMessage.java

public String toString() {
			return name;
		}
================= fetch public String toString() { 97ab1e9^:bridge/src/org/aspectj/bridge/Message.java

public String toString() {
        return Message.renderToString(this);
    }
================= fetch public String toString() { 97ab1e9^:bridge/src/org/aspectj/bridge/SourceLocation.java
/** @return String {context\n}{file:}line{:column} */
public String toString() {
        StringBuffer sb = new StringBuffer();
        if (null != context) {
            sb.append(context);
            sb.append(LangUtil.EOL);
        }
        if (sourceFile != ISourceLocation.NO_FILE) {
            sb.append(sourceFile.getPath());
            sb.append(":");
        }
        sb.append("" + startLine + "-" + endLine);
        if (!noColumn) {
            sb.append(":" + column);
        }
        return sb.toString();
    }
================= fetch public String toString() { 97ab1e9^:weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java

public String toString() {
    	//Thread.currentThread().dumpStack();
    	return "ExactTypePattern(" + type.toString() + (includeSubtypes ? "+" : "") + ")";
    }
================= fetch public boolean match(Shadow shadow, World world) { 97ab1e9^:weaver/src/org/aspectj/weaver/Checker.java

public boolean match(Shadow shadow, World world) {
		if (super.match(shadow, world)) {
			IMessage message = new Message(
				msg,
				shadow.toString(),
				isError ? IMessage.ERROR : IMessage.WARNING,
				shadow.getSourceLocation());
			world.getMessageHandler().handleMessage(message);
			
			AsmRelationshipProvider.checkerMunger(world.getModel(), shadow, this);
		}
		return false;
	}
================= fetch public static SignaturePattern read(DataInputStream s, ISourceContext context) t 97ab1e9^:weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java

public static SignaturePattern read(DataInputStream s, ISourceContext context) throws IOException {
		Member.Kind kind = Member.Kind.read(s);
		ModifiersPattern modifiers = ModifiersPattern.read(s);
		TypePattern returnType = TypePattern.read(s, context);
		TypePattern declaringType = TypePattern.read(s, context);
		NamePattern name = NamePattern.read(s);
		TypePatternList parameterTypes = TypePatternList.read(s, context);
		ThrowsPattern throwsPattern = ThrowsPattern.read(s, context);
		SignaturePattern ret = new SignaturePattern(kind, modifiers, returnType, declaringType,
					name, parameterTypes, throwsPattern);
		ret.readLocation(context, s);
		return ret;
	}
================= fetch public static String renderMessage(IMessage message, boolean elide) { 97ab1e9^:bridge/src/org/aspectj/bridge/MessageUtil.java
/** 
     * This renders IMessage as String, ignoring empty elements
     * and eliding any thrown.
     * @return "((IMessage) null)" if null or String rendering otherwise,
     *           including everything (esp. throwable stack trace)
     * @see renderSourceLocation(ISourceLocation loc)
     */
public static String renderMessage(IMessage message, boolean elide) {
        if (null == message) {
            return "((IMessage) null)";
        }
        StringBuffer result = new StringBuffer();
        
        result.append(message.getKind().toString());
        result.append(" ");
        
        String messageString = message.getMessage();
        if (!LangUtil.isEmpty(messageString)) {
            result.append(messageString);
            result.append(" ");
        }

        ISourceLocation loc = message.getSourceLocation();
        if ((null != loc) && (loc != ISourceLocation.EMPTY)) {
            result.append("at " + renderSourceLocation(loc));
        }
        Throwable thrown = message.getThrown(); 
        if (null != thrown) {
            result.append(" -- " + LangUtil.renderExceptionShort(thrown));
            result.append("\n" + LangUtil.renderException(thrown, elide));            
        }
        return result.toString();
    }
================= fetch public void mI() { } 97ab1e9^:tests/new/CallTypesI.java

public void mC() { }
================= fetch public void setDetails(String string) { 97ab1e9^:testing/src/org/aspectj/testing/xml/SoftMessage.java

public void setDetails(String string) {
		details = string;
	}
================= fetch public void signal(String info, ISourceLocation location) { 97ab1e9^:weaver/src/org/aspectj/weaver/Lint.java

public void signal(String info, ISourceLocation location) {
			if (kind == null) return;
			
			String text = MessageFormat.format(message, new Object[] {info} );
			text += " [Xlint:" + name + "]";
			world.getMessageHandler().handleMessage(new Message(text, kind, null, location));
		}
================= fetch void check(String pc, JoinPoint jp) { 97ab1e9^:tests/new/IndeterminateArg.java

void check(String pc, JoinPoint jp) {
        Class[] types = ((CodeSignature) jp.getSignature()).getParameterTypes();
        String name = jp.toLongString() + " " + actualTypes(jp) + ": " + pc;
        T.e(name);
    }
================= fetch void check(String pc, JoinPoint jp) { 97ab1e9^:tests/new/IndeterminateArgType.java

void check(String pc, JoinPoint jp) {
        Class[] types = ((CodeSignature) jp.getSignature()).getParameterTypes();
        String name = jp.toLongString() + " " + actualTypes(jp) + ": " + pc;
        T.e(name);
    }
================= fetch public void resolveStatements() { 7322131^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java

public void resolveStatements() {
		if (!Modifier.isAbstract(declaredModifiers)) super.resolveStatements();
	}
================= fetch public SoftException(Throwable inner) { eac16ae^:runtime/src/org/aspectj/lang/SoftException.java

public Throwable getWrappedThrowable() { return inner; }
Progress : [#######################################-] 99%================= fetch private void resolvePointcutDeclarations(ClassScope s) { c517e85^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java

private void resolvePointcutDeclarations(ClassScope s) {
        TypeDeclaration dec = s.referenceContext;
        SourceTypeBinding sourceType = s.referenceContext.binding;
        
        AbstractMethodDeclaration[] methods = dec.methods;
        boolean initializedMethods = false;
        if (methods != null) {
            for (int i=0; i < methods.length; i++) {
                if (methods[i] instanceof PointcutDeclaration) {
                    if (!initializedMethods) {
                        sourceType.methods(); //force initialization
                        initializedMethods = true;
                    }
                    ((PointcutDeclaration)methods[i]).resolvePointcut(s);
                }
            }
        }
        
        ReferenceBinding[] memberTypes = sourceType.memberTypes;
        for (int i = 0, length = memberTypes.length; i < length; i++) {
            resolvePointcutDeclarations(((SourceTypeBinding) memberTypes[i]).scope);
        }
    }
================= fetch public void resolve() { c517e85^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java

public void resolve() {
		if (binding == null) {
			ignoreFurtherInvestigation = true;
			return;
		}
		
		if (concreteName != null) concreteName.checkPointcutDeclarations();
		
		super.resolve();
	}
================= fetch public AjBuildConfig genBuildConfig(String configFilePath) { 3e4b59a^:ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java
/**
     * Generate AjBuildConfig from the local configFile parameter
     * plus global project and build options.
     * Errors signalled using signal... methods.
     * @param configFile
     * @return null if invalid configuration, 
     *   corresponding AjBuildConfig otherwise
     */
public AjBuildConfig genBuildConfig(String configFilePath) {
        init();
	    File configFile = new File(configFilePath);
        if (!configFile.exists()) {
            signalError("Config file \"" + configFile + "\" does not exist."); 
            return null;
        }
        String[] args = new String[] { "@" + configFile.getAbsolutePath() };
        CountingMessageHandler handler 
            = CountingMessageHandler.makeCountingMessageHandler(messageHandler);
		BuildArgParser parser = new BuildArgParser();
		
        AjBuildConfig config = parser.genBuildConfig(args, handler, false, configFile);  
		configureProjectOptions(config, Ajde.getDefault().getProjectProperties());  // !!! not what the API intended

		// -- get globals, treat as defaults used if no local values
		AjBuildConfig global = new AjBuildConfig();
		// AMC refactored into two methods to populate buildConfig from buildOptions and
		// project properties - bugzilla 29769.
		BuildOptionsAdapter buildOptions 
			= Ajde.getDefault().getBuildManager().getBuildOptions();
		if (!configureBuildOptions(global, buildOptions, handler)) {
			return null;
		}
		ProjectPropertiesAdapter projectOptions =
			Ajde.getDefault().getProjectProperties();
		configureProjectOptions(global, projectOptions);
		config.installGlobals(global);

		ISourceLocation location = null;
		if (config.getConfigFile() != null) {
			location = new SourceLocation(config.getConfigFile(), 0); 
		}
        
		String message = parser.getOtherMessages(true);
		if (null != message) {  
			IMessage m = new Message(message, IMessage.ERROR, null, location);            
			handler.handleMessage(m);
		}
        
        // always force model generation in AJDE
        config.setGenerateModelMode(true);       
		if (Ajde.getDefault().getBuildManager().getBuildOptions().getJavaOptionsMap() != null) {
			config.getJavaOptions().putAll(Ajde.getDefault().getBuildManager().getBuildOptions().getJavaOptionsMap());
		}
		return config;
//        return fixupBuildConfig(config);
	}
================= fetch public boolean compile(String configFile, BuildProgressMonitor progressMonitor, 3e4b59a^:ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java

public boolean compile(String configFile, BuildProgressMonitor progressMonitor, boolean buildModel) {
		init();
		try { 
			AjBuildConfig buildConfig = genBuildConfig(configFile);
			buildConfig.setGenerateModelMode(buildModel);
			if (null == buildConfig) {
                return false;
			}
			currNotifier = new BuildNotifierAdapter(progressMonitor);		
			buildManager.setProgressListener(currNotifier);
			messageHandler.setBuildNotifierAdapter(currNotifier);
			
			String rtInfo = buildManager.checkRtJar(buildConfig); // !!! will get called twice
			if (rtInfo != null) {
				signalWarning(
                	  "AspectJ Runtime error: " + rtInfo
		            + "  Please place a valid aspectjrt.jar on the classpath.");
	            return false;
			}
			boolean incrementalEnabled = 
                buildConfig.isIncrementalMode()
                || buildConfig.isIncrementalFileMode();
            if (incrementalEnabled && nextBuild) {
                return buildManager.incrementalBuild(buildConfig, messageHandler);
            } else {
                if (incrementalEnabled) {
                    nextBuild = incrementalEnabled;
                } 
                return buildManager.batchBuild(buildConfig, messageHandler); 
            }
        } catch (OperationCanceledException ce) {
            signalWarning("build cancelled by user");
            return false;
		} catch (AbortException e) {
            final IMessage message = e.getIMessage();
            if (null == message) {
                signalThrown(e);
            } else if (null != message.getMessage()) {
                signalWarning(message.getMessage());
            } else if (null != message.getThrown()) {
                signalThrown(message.getThrown());
            } else {
                signalThrown(e);
            }
			return false;
		} catch (Throwable t) {
            signalThrown(t);
			return false; 
		} 
	}
================= fetch public static void checkerMunger(IHierarchy model, Shadow shadow, Checker checke 3117255^:weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java

public static void checkerMunger(IHierarchy model, Shadow shadow, Checker checker) {
		if (shadow.getSourceLocation() == null || checker.getSourceLocation() == null) return;
		
		String sourceHandle = ProgramElement.createHandleIdentifier(
			checker.getSourceLocation().getSourceFile(),
			checker.getSourceLocation().getLine(),
			checker.getSourceLocation().getColumn());
			
		String targetHandle = ProgramElement.createHandleIdentifier(
			shadow.getSourceLocation().getSourceFile(),
			shadow.getSourceLocation().getLine(),
			shadow.getSourceLocation().getColumn());

		IRelationshipMap mapper = AsmManager.getDefault().getRelationshipMap();
		if (sourceHandle != null && targetHandle != null) {
			IRelationship foreward = mapper.get(sourceHandle, IRelationship.Kind.DECLARE, MATCHED_BY);
			foreward.getTargets().add(targetHandle);
				
			IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE, MATCHES_DECLARE);
			back.getTargets().add(sourceHandle);  
		}
	}
================= fetch public String toLinkLabelString() { 426d89b^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public String toLinkLabelString() {
		String label;
		if (kind == Kind.CODE || kind == Kind.INITIALIZER) {
			label = parent.getParent().getName() + ": ";
		} else if (kind.isInterTypeMemberKind()) {
			int dotIndex = name.indexOf('.');  
			if (dotIndex != -1) {
				return parent.getName() + ": " + toLabelString().substring(dotIndex+1);
			} else {
				label = parent.getName() + '.';	
			}
		} else if (kind == Kind.CLASS || kind == Kind.ASPECT) {
			label = "";
		} else {
			label = parent.getName() + '.';
		}
		label += toLabelString();
		return label;
	}
================= fetch public String toSignatureString() { 426d89b^:asm/src/org/aspectj/asm/internal/ProgramElement.java

public String toSignatureString() {
		StringBuffer sb = new StringBuffer();
		sb.append(name);
		
		if (parameterTypes != null ) {
			sb.append('('); 
			for (Iterator it = parameterTypes.iterator(); it.hasNext(); ) {
				sb.append((String)it.next());
				if (it.hasNext()) sb.append(", ");
			}
			sb.append(')');
		}
		
		return sb.toString();
	}
================= fetch public Pointcut concretize1(ResolvedTypeX searchStart, IntMap bindings) { 5357086^:weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java

public Pointcut concretize1(ResolvedTypeX searchStart, IntMap bindings) {
		if (concretizing) {
			//Thread.currentThread().dumpStack();
			searchStart.getWorld().getMessageHandler().handleMessage(
				MessageUtil.error("circular pointcut declaration involving: " + this,
									getSourceLocation()));
			return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
		}
		
		try {
			concretizing = true;
		
			ResolvedPointcutDefinition pointcutDec;
			if (onType != null) {
				searchStart = onType.resolve(searchStart.getWorld());
				if (searchStart == ResolvedTypeX.MISSING) {
					return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
				}
			}
			pointcutDec = searchStart.findPointcut(name);
			if (pointcutDec == null) {
				searchStart.getWorld().getMessageHandler().handleMessage(
					MessageUtil.error("can't find pointcut \'" + name + "\' on " + searchStart.getName(), 
									getSourceLocation())
				);
				return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
			}
			
			if (pointcutDec.isAbstract()) {
				//Thread.currentThread().dumpStack();
				searchStart.getWorld().showMessage(IMessage.ERROR,
					pointcutDec + " is abstract", 
					getSourceLocation(), bindings.getEnclosingAdvice().getSourceLocation());
				return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
			}
					
			//System.err.println("start: " + searchStart);
			ResolvedTypeX[] parameterTypes = searchStart.getWorld().resolve(pointcutDec.getParameterTypes());
			
			TypePatternList arguments = this.arguments.resolveReferences(bindings);
			
			IntMap newBindings = new IntMap();
			for (int i=0,len=arguments.size(); i < len; i++) {
				TypePattern p = arguments.get(i);
				//we are allowed to bind to pointcuts which use subtypes as this is type safe
				if (!p.matchesSubtypes(parameterTypes[i])  && 
					!p.getExactType().equals(TypeX.OBJECT))
				{
					throw new BCException("illegal change to pointcut declaration: " + this);
				}
				
			    if (p instanceof BindingTypePattern) {
			    	newBindings.put(i, ((BindingTypePattern)p).getFormalIndex());
			    }
			}
			
			newBindings.copyContext(bindings);
			newBindings.pushEnclosingDefinition(pointcutDec);
			try {
				return pointcutDec.getPointcut().concretize1(searchStart, newBindings);
			} finally {
				newBindings.popEnclosingDefinitition();
			}
			
		} finally {
			concretizing = false;
		}
	}
Progress : [########################################] 100%================= fetch public Pointcut concretize1(ResolvedTypeX searchStart, IntMap bindings) { fc0d2af^:weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java

public Pointcut concretize1(ResolvedTypeX searchStart, IntMap bindings) {
		if (concretizing) {
			//Thread.currentThread().dumpStack();
			searchStart.getWorld().getMessageHandler().handleMessage(
				MessageUtil.error("circular pointcut declaration involving: " + this,
									getSourceLocation()));
			return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
		}
		
		try {
			concretizing = true;
		
			ResolvedPointcutDefinition pointcutDec;
			if (onType != null) {
				searchStart = onType.resolve(searchStart.getWorld());
				if (searchStart == ResolvedTypeX.MISSING) {
					return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
				}
			}
			pointcutDec = searchStart.findPointcut(name);
			if (pointcutDec == null) {
				searchStart.getWorld().getMessageHandler().handleMessage(
					MessageUtil.error("can't find pointcut \'" + name + "\' on " + searchStart.getName(), 
									getSourceLocation())
				);
				return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
			}
			
			if (pointcutDec.isAbstract()) {
				//Thread.currentThread().dumpStack();
				searchStart.getWorld().showMessage(IMessage.ERROR,
					pointcutDec + " is abstract", 
					getSourceLocation(), bindings.getEnclosingAdvice().getSourceLocation());
				return Pointcut.makeMatchesNothing(Pointcut.CONCRETE);
			}
					
			//System.err.println("start: " + searchStart);
			ResolvedTypeX[] parameterTypes = searchStart.getWorld().resolve(pointcutDec.getParameterTypes());
			
			arguments = arguments.resolveReferences(bindings);
			
			IntMap newBindings = new IntMap();
			for (int i=0,len=arguments.size(); i < len; i++) {
				TypePattern p = arguments.get(i);
				//we are allowed to bind to pointcuts which use subtypes as this is type safe
				if (!p.matchesSubtypes(parameterTypes[i])  && 
					!p.getExactType().equals(TypeX.OBJECT))
				{
					throw new BCException("illegal change to pointcut declaration: " + this);
				}
				
			    if (p instanceof BindingTypePattern) {
			    	newBindings.put(i, ((BindingTypePattern)p).getFormalIndex());
			    }
			}
			
			newBindings.copyContext(bindings);
			newBindings.pushEnclosingDefinition(pointcutDec);
			try {
				return pointcutDec.getPointcut().concretize1(searchStart, newBindings);
			} finally {
				newBindings.popEnclosingDefinitition();
			}
			
		} finally {
			concretizing = false;
		}
	}
================= fetch private void doPendingWeaves() { b512738^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java

private void doPendingWeaves() {
		for (Iterator i = pendingTypesToWeave.iterator(); i.hasNext(); ) {
			SourceTypeBinding t = (SourceTypeBinding)i.next();
			weaveInterTypeDeclarations(t);
		}
		pendingTypesToWeave.clear();
	}
================= fetch public CrosscuttingMembers collectCrosscuttingMembers() { b512738^:weaver/src/org/aspectj/weaver/ResolvedTypeX.java

public CrosscuttingMembers collectCrosscuttingMembers() {
		crosscuttingMembers = new CrosscuttingMembers(this);
		crosscuttingMembers.setPerClause(getPerClause());
		crosscuttingMembers.addShadowMungers(collectShadowMungers());
		crosscuttingMembers.addTypeMungers(getTypeMungers());
		crosscuttingMembers.addDeclares(collectDeclares());
		crosscuttingMembers.addPrivilegedAccesses(getPrivilegedAccesses());
		
		//System.err.println("collected cc members: " + this + ", " + collectDeclares());
		return crosscuttingMembers;
	}
================= fetch public List getDeclareDominates() { b512738^:weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java

public List getDeclareDominates() {
		if (declareDominates == null) {
			ArrayList ret = new ArrayList();
			for (Iterator i = members.values().iterator(); i.hasNext(); ) {
				ret.addAll(((CrosscuttingMembers)i.next()).getDeclareDominates());
			}
			declareDominates = ret;
		}
		return declareDominates;
	}
================= fetch public boolean addOrReplaceAspect(ResolvedTypeX aspectType) { b512738^:weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java
/**
	 * @return whether or not that was a change to the global signature
	 * 			XXX for efficiency we will need a richer representation than this
	 */
public boolean addOrReplaceAspect(ResolvedTypeX aspectType) {
		CrosscuttingMembers xcut = (CrosscuttingMembers)members.get(aspectType);
		if (xcut == null) {
			members.put(aspectType, aspectType.collectCrosscuttingMembers());
			clearCaches();
			return true;
		} else {
			if (xcut.replaceWith(aspectType.collectCrosscuttingMembers())) {
				clearCaches();
				return true;
			} else {
				return false;
			}
		}
	}
================= fetch public boolean containsAspect(TypeX aspectType) { b512738^:weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java

public boolean containsAspect(TypeX aspectType) {
		return members.containsKey(aspectType);
	}
================= fetch public void completeTypeBindings() { b512738^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java
//??? duplicates some of super's code
public void completeTypeBindings() {
//		builtInterTypesAndPerClauses = false;
		//pendingTypesToWeave = new ArrayList();
		stepCompleted = BUILD_TYPE_HIERARCHY;
		
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			units[i].scope.checkAndSetImports();
		}
		stepCompleted = CHECK_AND_SET_IMPORTS;
	
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			units[i].scope.connectTypeHierarchy();
		}
		stepCompleted = CONNECT_TYPE_HIERARCHY;
	
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			units[i].scope.buildFieldsAndMethods();
		}
		
		// would like to gather up all TypeDeclarations at this point and put them in the factory
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			SourceTypeBinding[] b = units[i].scope.topLevelTypes;
			for (int j = 0; j < b.length; j++) {
				factory.addSourceTypeBinding(b[j]);
			}
		}
		
		// need to build inter-type declarations for all AspectDeclarations at this point
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
                buildInterTypeAndPerClause(b[j].scope);
            }
        }
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
                resolvePointcutDeclarations(b[j].scope);
            }
        }
        
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
                addCrosscuttingStructures(b[j].scope);
            }
        }
		factory.finishTypeMungers();
	
		// now do weaving
		Collection typeMungers = factory.getTypeMungers();
		
		Collection declareParents = factory.getDeclareParents();

		doPendingWeaves();

		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			weaveInterTypeDeclarations(units[i].scope, typeMungers, declareParents);
            units[i] = null; // release unnecessary reference to the parsed unit
		}
                
		stepCompleted = BUILD_FIELDS_AND_METHODS;
		lastCompletedUnitIndex = lastUnitIndex;
	}
================= fetch private void doPendingWeaves() { d78d9ed^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java

private void doPendingWeaves() {
		for (Iterator i = pendingTypesToWeave.iterator(); i.hasNext(); ) {
			SourceTypeBinding t = (SourceTypeBinding)i.next();
			weaveInterTypeDeclarations(t);
		}
		pendingTypesToWeave.clear();
	}
================= fetch public ResolvedPointcutDefinition makeResolvedPointcutDefinition() { d78d9ed^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java

public ResolvedPointcutDefinition makeResolvedPointcutDefinition() {
		//System.out.println("pc: " + getPointcut());
		ResolvedPointcutDefinition ret = new ResolvedPointcutDefinition(
            EclipseFactory.fromBinding(this.binding.declaringClass), 
            declaredModifiers, 
            declaredName,
			EclipseFactory.fromBindings(this.binding.parameters),
			getPointcut());
			
		ret.setPosition(sourceStart, sourceEnd);
		ret.setSourceContext(new EclipseSourceContext(compilationResult));
		return ret;
	}
================= fetch public boolean isAjSynthetic() { d78d9ed^:weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.java

public boolean isAjSynthetic() {
		return true;
	}
================= fetch public void buildInterTypeAndPerClause(ClassScope classScope) { d78d9ed^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java

public void buildInterTypeAndPerClause(ClassScope classScope) {
		factory = EclipseFactory.fromScopeLookupEnvironment(scope);
		if (isPrivileged) {
			binding.privilegedHandler = new PrivilegedHandler(this);
		}
		
		checkSpec(classScope);
		if (ignoreFurtherInvestigation) return;
		
		buildPerClause(scope);
		
		if (methods != null) {
			for (int i = 0; i < methods.length; i++) {
				if (methods[i] instanceof InterTypeDeclaration) {
					EclipseTypeMunger m = ((InterTypeDeclaration)methods[i]).build(classScope);
					if (m != null) concreteName.typeMungers.add(m);
				} else if (methods[i] instanceof DeclareDeclaration) {
					Declare d = ((DeclareDeclaration)methods[i]).build(classScope);
					if (d != null) concreteName.declares.add(d);
				}
			}
		}

		//??? timing is weird
		factory.getWorld().getCrosscuttingMembersSet().addOrReplaceAspect(typeX);
		
		if (typeX.getSuperclass().isAspect() && !typeX.getSuperclass().isExposedToWeaver()) {
			factory.getWorld().getCrosscuttingMembersSet().addOrReplaceAspect(typeX.getSuperclass());
		}
	}
================= fetch public void completeTypeBindings() { d78d9ed^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java
//??? duplicates some of super's code
public void completeTypeBindings() {
//		builtInterTypesAndPerClauses = false;
		//pendingTypesToWeave = new ArrayList();
		stepCompleted = BUILD_TYPE_HIERARCHY;
		
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			units[i].scope.checkAndSetImports();
		}
		stepCompleted = CHECK_AND_SET_IMPORTS;
	
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			units[i].scope.connectTypeHierarchy();
		}
		stepCompleted = CONNECT_TYPE_HIERARCHY;
	
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			units[i].scope.buildFieldsAndMethods();
		}
		
		// would like to gather up all TypeDeclarations at this point and put them in the factory
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			SourceTypeBinding[] b = units[i].scope.topLevelTypes;
			for (int j = 0; j < b.length; j++) {
				factory.addSourceTypeBinding(b[j]);
			}
		}
		
		// need to build inter-type declarations for all AspectDeclarations at this point
		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			SourceTypeBinding[] b = units[i].scope.topLevelTypes;
			for (int j = 0; j < b.length; j++) {
				buildInterTypeAndPerClause(b[j].scope);
			}
		}
		factory.finishTypeMungers();
	
		// now do weaving
		Collection typeMungers = factory.getTypeMungers();
		
		Collection declareParents = factory.getDeclareParents();

		doPendingWeaves();

		for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
			weaveInterTypeDeclarations(units[i].scope, typeMungers, declareParents);
			units[i] = null; // release unnecessary reference to the parsed unit
		}
		
		stepCompleted = BUILD_FIELDS_AND_METHODS;
		lastCompletedUnitIndex = lastUnitIndex;
	}
================= fetch public void postParse(TypeDeclaration typeDec) { d78d9ed^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java

public void postParse(TypeDeclaration typeDec) {
		if (arguments == null) arguments = new Argument[0];
		this.declaredModifiers = modifiers;
		this.declaredName = new String(selector);
		selector = CharOperation.concat(mangledPrefix, '$', selector, '$',
				Integer.toHexString(sourceStart).toCharArray());
				
		if (Modifier.isAbstract(this.declaredModifiers) && 
			!(typeDec instanceof AspectDeclaration))
		{
			typeDec.scope.problemReporter().signalError(sourceStart, sourceEnd, 
				"The abstract pointcut " + new String(declaredName) +
				" can only be defined in an aspect");
			ignoreFurtherInvestigation = true;
			return;
		}
		
		if (pointcutDesignator != null) {
			pointcutDesignator.postParse(typeDec, this);
		}
	}
================= fetch public void resolveStatements() { d78d9ed^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java

public void resolveStatements() {
		if (isAbstract()) {
			this.modifiers |= AccSemicolonBody;
		}

		
		if (binding == null || ignoreFurtherInvestigation) return;

		if (Modifier.isAbstract(this.declaredModifiers)&& (pointcutDesignator != null)) {
			scope.problemReporter().signalError(sourceStart, sourceEnd, "abstract pointcut can't have body");
			ignoreFurtherInvestigation = true;
			return;
		}
		
		if (pointcutDesignator != null) {
			pointcutDesignator.finishResolveTypes(this, this.binding, arguments.length, 
					scope.enclosingSourceType());
		}
		
		super.resolveStatements();
	}
================= fetch private boolean matchesAny( 8660cc1^:weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java

private boolean matchesAny(
		TypePattern typePattern,
		ResolvedTypeX[] types) 
	{
		for (int i = types.length - 1; i >= 0; i--) {
			if (typePattern.matchesExactly(types[i])) return true;	
		}
		return false;
	}
================= fetch public void generate(CodeStream codeStream) { 5a07dce^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java

private PerClause.Kind lookupPerClauseKind(ReferenceBinding binding) {
		if (binding instanceof SourceTypeBinding && !(binding instanceof BinaryTypeBinding)) {
			SourceTypeBinding sourceSc = (SourceTypeBinding)binding;
			if (sourceSc.scope.referenceContext instanceof AspectDeclaration) {
				PerClause perClause = ((AspectDeclaration)sourceSc.scope.referenceContext).perClause;
				if (perClause == null) return lookupPerClauseKind(binding.superclass());
				else return perClause.getKind();
			} else {
				return null;
			}
		} else {
			//XXX need to handle this too
			return null;
		}
	}
Progress : [########################################] 101%================= fetch private void unpackLocals(MethodGen gen) { d90acdc^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

private void unpackLocals(MethodGen gen) {
        Set locals = new HashSet();
        for (InstructionHandle ih = body.getStart(); ih != null; ih = ih.getNext()) {
            InstructionTargeter[] targeters = ih.getTargeters();
            List ends = new ArrayList(0);
            if (targeters != null) {
                for (int i = targeters.length - 1; i >= 0; i--) {
                    InstructionTargeter targeter = targeters[i];
                    if (targeter instanceof LocalVariableGen) {
                        LocalVariableGen lng = (LocalVariableGen) targeter;
                        LocalVariableTag lr = new LocalVariableTag(BcelWorld.fromBcel(lng.getType()), lng.getName(), lng.getIndex());
                        if (lng.getStart() == ih) {
                            lng.setStart(null);
                            locals.add(lr);
                        } else {
                            lng.setEnd(null);
                            ends.add(lr);
                        }
                    }
                }
            }
            for (Iterator i = locals.iterator(); i.hasNext(); ) {
                ih.addTargeter((LocalVariableTag) i.next());
            }
            locals.removeAll(ends);
        }
        gen.removeLocalVariables();
    }
================= fetch public void packBody(MethodGen gen) { d90acdc^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
/** fill the newly created method gen with our body, 
     * inspired by InstructionList.copy()
     */
public void packBody(MethodGen gen) {
        HashMap map = new HashMap();
        InstructionList fresh = gen.getInstructionList();
        
        /* Make copies of all instructions, append them to the new list
         * and associate old instruction references with the new ones, i.e.,
         * a 1:1 mapping.
         */
        for (InstructionHandle ih = getBody().getStart(); ih != null; ih = ih.getNext()) {
            if (Range.isRangeHandle(ih)) {
                continue;
            }
            Instruction i = ih.getInstruction();
            Instruction c = Utility.copyInstruction(i);

            if (c instanceof BranchInstruction)
                map.put(ih, fresh.append((BranchInstruction) c));
            else
                map.put(ih, fresh.append(c));
        }
        // at this point, no rangeHandles are in fresh.  Let's use that...

        /* Update branch targets and insert various attributes.  
         * Insert our exceptionHandlers
         * into a sorted list, so they can be added in order later.
         */
        InstructionHandle ih = getBody().getStart();
        InstructionHandle jh = fresh.getStart();

        LinkedList exnList = new LinkedList();   

		// map from localvariabletag to instruction handle
        Map localVariableStarts = new HashMap();
        Map localVariableEnds = new HashMap();

        int currLine = -1;
        
        while (ih != null) {
            if (map.get(ih) == null) {
                // we're a range instruction
                Range r = Range.getRange(ih);
                if (r instanceof ExceptionRange) {
                    ExceptionRange er = (ExceptionRange) r;
                    if (er.getStart() == ih) {
                    	//System.err.println("er " + er);
                    	if (!er.isEmpty()){
                        	// order is important, insert handlers in order of start
                        	insertHandler(er, exnList);
                    	}
                    }
                } else {
                    // we must be a shadow range or something equally useless, 
                    // so forget about doing anything
                }
                // just increment ih. 
                ih = ih.getNext();
            } else {
                // assert map.get(ih) == jh
                Instruction i = ih.getInstruction();
                Instruction j = jh.getInstruction();
    
                if (i instanceof BranchInstruction) {
                    BranchInstruction bi = (BranchInstruction) i;
                    BranchInstruction bj = (BranchInstruction) j;
                    InstructionHandle itarget = bi.getTarget(); // old target
    
//    				try {
                    // New target is in hash map
                    bj.setTarget(remap(itarget, map));
//    				} catch (NullPointerException e) {
//    					print();
//    					System.out.println("Was trying to remap " + bi);
//    					System.out.println("who's target was supposedly " + itarget);
//    					throw e;
//    				}
    
                    if (bi instanceof Select) { 
                        // Either LOOKUPSWITCH or TABLESWITCH
                        InstructionHandle[] itargets = ((Select) bi).getTargets();
                        InstructionHandle[] jtargets = ((Select) bj).getTargets();
    
                        for (int k = itargets.length - 1; k >= 0; k--) { 
                            // Update all targets
                            jtargets[k] = remap(itargets[k], map);
                            jtargets[k].addTargeter(bj);
                        }
                    }
                }
                
                // now deal with line numbers 
                // and store up info for local variables
                InstructionTargeter[] targeters = ih.getTargeters();
                if (targeters != null) {
                    for (int k = targeters.length - 1; k >= 0; k--) {
                        InstructionTargeter targeter = targeters[k];
                        if (targeter instanceof LineNumberTag) {
                            int line = ((LineNumberTag)targeter).getLineNumber();
                            if (line != currLine) {
                                gen.addLineNumber(jh, line);
                                currLine = line;
                            }
                        } else if (targeter instanceof LocalVariableTag) {
                            LocalVariableTag lvt = (LocalVariableTag) targeter;
                            if (i instanceof LocalVariableInstruction) {
                                int index = ((LocalVariableInstruction)i).getIndex();
                                if (lvt.getSlot() == index) {
                                    if (localVariableStarts.get(lvt) == null) {
                                        localVariableStarts.put(lvt, jh);
                                    }
                                    localVariableEnds.put(lvt, jh);
                                }
                            }
                        }
                    }
                }
                // now continue
                ih = ih.getNext();
                jh = jh.getNext();
            }
        }

        // now add exception handlers
        for (Iterator iter = exnList.iterator(); iter.hasNext();) {
            ExceptionRange r = (ExceptionRange) iter.next();
            if (r.isEmpty()) continue;
            gen.addExceptionHandler(
                remap(r.getRealStart(), map), 
                remap(r.getRealEnd(), map),
                remap(r.getHandler(), map),
                (r.getCatchType() == null)
                ? null 
                : (ObjectType) BcelWorld.makeBcelType(r.getCatchType()));
        }
        // now add local variables
        gen.removeLocalVariables();
        
        // BCEL sometimes creates extra local variables with the same name.  We now
        // remove them and add back to the gen.
        
        Map duplicatedLocalMap = new HashMap();
        
	List keys = new ArrayList(); 
	keys.addAll(localVariableStarts.keySet()); 
	Collections.sort(keys,new Comparator() {
================= fetch private JPopupMenu createFilterMenu() { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java

private JPopupMenu createFilterMenu() {
		JPopupMenu filterMenu = new JPopupMenu();
		ProgramElementNode.Accessibility[] accessibility = ProgramElementNode.Accessibility.ALL;
		for (int i = 0; i < accessibility.length; i++) {
			CheckBoxSelectionMenuButton menuItem = new CheckBoxSelectionMenuButton(accessibility[i]);
			menuItem.setIcon(AjdeUIManager.getDefault().getIconRegistry().getAccessibilitySwingIcon(accessibility[i]));
			filterMenu.add(menuItem);
		}
		filterMenu.add(new JSeparator());

		ProgramElementNode.Kind[] kinds = ProgramElementNode.Kind.ALL;
		for (int i = 0; i < kinds.length; i++) {
			if (kinds[i].isMemberKind()) {
				CheckBoxSelectionMenuButton menuItem = new CheckBoxSelectionMenuButton(kinds[i]);
				menuItem.setIcon((Icon)AjdeUIManager.getDefault().getIconRegistry().getStructureIcon(kinds[i]).getIconResource());
				filterMenu.add(menuItem);
			}
		}
		filterMenu.add(new JSeparator());

		ProgramElementNode.Modifiers[] modifiers = ProgramElementNode.Modifiers.ALL;
		for (int i = 0; i < modifiers.length; i++) {
			CheckBoxSelectionMenuButton menuItem = new CheckBoxSelectionMenuButton(modifiers[i]);
			filterMenu.add(menuItem);
		}
		return filterMenu;
	}
================= fetch private JPopupMenu createRelationsMenu() { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java

private JPopupMenu createRelationsMenu() {
		JPopupMenu relationsMenu = new JPopupMenu();

		java.util.List relations = Ajde.getDefault().getStructureViewManager().getAvailableRelations();
		for (Iterator it = relations.iterator(); it.hasNext(); ) {
			Relation relation = (Relation)it.next();
			CheckBoxSelectionMenuButton menuItem = new CheckBoxSelectionMenuButton(relation);
			menuItem.setIcon((Icon)AjdeUIManager.getDefault().getIconRegistry().getRelationIcon(relation).getIconResource());
			relationsMenu.add(menuItem);
		}

		return relationsMenu;
	}
================= fetch private List findMatchesHelper( f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureSearchManager.java

private List findMatchesHelper(
		ProgramElementNode node, 
		String pattern, 
		ProgramElementNode.Kind kind,
		List matches) {
			
		if (node != null && node.getName().indexOf(pattern) != -1) {
			if (kind == null || node.getProgramElementKind().equals(kind)) {
				matches.add(node);	
			} 
		}
		
		for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
			StructureNode nextNode = (StructureNode)it.next();
			if (nextNode instanceof ProgramElementNode) {
				findMatchesHelper(
					(ProgramElementNode)nextNode, 
					pattern, 
					kind,
					matches); 		
			}
		}
		 
		return matches;		
	}
================= fetch private Map getViewProperties() { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/PointcutWizard.java

private Map getViewProperties() {
        Map views = new HashMap();
        GlobalViewProperties INHERITANCE_VIEW = new GlobalViewProperties(StructureViewProperties.Hierarchy.INHERITANCE);
        INHERITANCE_VIEW.addRelation(InheritanceAssociation.INHERITS_RELATION);
        views.put(INHERITANCE_VIEW.toString(), INHERITANCE_VIEW);
        return views;
    }
================= fetch private ProgramElementNode findClassInNodes(Collection nodes, String name) { f1deb9c^:asm/src/org/aspectj/asm/StructureModel.java

private ProgramElementNode findClassInNodes(Collection nodes, String name) {
		String baseName;
		String innerName;
		int dollar = name.indexOf('$');
		if (dollar == -1) {
			baseName = name;
			innerName = null;
		} else {
			baseName = name.substring(0, dollar);
			innerName = name.substring(dollar+1);
		}
		
		
		for (Iterator j = nodes.iterator(); j.hasNext(); ) {
			ProgramElementNode classNode = (ProgramElementNode)j.next();
//			System.err.println("checking: " + classNode + " for " + baseName);	
//			System.err.println("children: " + classNode.getChildren());
			if (baseName.equals(classNode.getName())) {
				if (innerName == null) return classNode;
				else return findClassInNodes(classNode.getChildren(), innerName);
			} else if (name.equals(classNode.getName())) {
				return classNode;
			}
		}
		return null;
	}
================= fetch private StructureNode createFileStructureNode(String sourceFilePath) { f1deb9c^:asm/src/org/aspectj/asm/StructureModel.java

private StructureNode createFileStructureNode(String sourceFilePath) {
		String fileName = new File(sourceFilePath).getName();
		ProgramElementNode fileNode = new ProgramElementNode(fileName, ProgramElementNode.Kind.FILE_JAVA, null);
		fileNode.setSourceLocation(new SourceLocation(new File(sourceFilePath), 1, 1));
		fileNode.addChild(NO_STRUCTURE);
		return fileNode;
	}
================= fetch private StructureNode findNodeForSourceLineHelper(StructureNode node, String sou f1deb9c^:asm/src/org/aspectj/asm/StructureModel.java

private StructureNode findNodeForSourceLineHelper(StructureNode node, String sourceFilePath, int lineNumber) {
		if (matches(node, sourceFilePath, lineNumber) 
			&& !hasMoreSpecificChild(node, sourceFilePath, lineNumber)) {
			return node;	
		} 
		
		if (node != null && node.getChildren() != null) {
			for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
				StructureNode foundNode = findNodeForSourceLineHelper(
					(StructureNode)it.next(), 
					sourceFilePath, 
					lineNumber); 		
				if (foundNode != null) return foundNode;
			}
		}
		
		return null;		
	}
================= fetch private StructureViewNode buildCustomTree(GlobalStructureView view, StructureMod f1deb9c^:ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java

private StructureViewNode buildCustomTree(GlobalStructureView view, StructureModel model) {
        StructureNode rootNode = model.getRoot();
        StructureViewNode treeNode = nodeFactory.createNode(rootNode);

        List rootNodes = new ArrayList();
        getRoots(rootNode, rootNodes, view.getGlobalViewProperties().getHierarchy());
		
        for (Iterator it = rootNodes.iterator(); it.hasNext(); ) {
            if (view.getGlobalViewProperties().getHierarchy().equals(StructureViewProperties.Hierarchy.CROSSCUTTING)) {
                treeNode.add(getCrosscuttingChildren((StructureNode)it.next()));
            } else if (view.getGlobalViewProperties().getHierarchy().equals(StructureViewProperties.Hierarchy.INHERITANCE)) {
                treeNode.add(getInheritanceChildren(
                	(StructureNode)it.next(),
                	view.getViewProperties().getRelations())	
                );
            }
        }
        return treeNode;
    }
================= fetch private StructureViewNode buildTree(StructureNode node, List associations) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java

private StructureViewNode buildTree(StructureNode node, List associations) {
        //StructureViewNode treeNode = new StructureViewNodeAdapter(node);
        StructureViewNode treeNode = nodeFactory.createNode(node);
        if (node instanceof ProgramElementNode) {
            List relations = ((ProgramElementNode)node).getRelations();
            if (relations != null) {
                for (Iterator it = relations.iterator(); it.hasNext(); ) {
                    RelationNode relationNode = (RelationNode)it.next();
                    if (associations.contains(relationNode.getRelation().toString())) {
                        treeNode.add(buildTree(relationNode, associations));
                    }
                }
            }
        }
        if (node != null) {
            List children = null;
            children = node.getChildren();
            if (children != null) {
                List childList = new ArrayList();
                for (Iterator itt = children.iterator(); itt.hasNext(); ) {
                    StructureNode child = (StructureNode)itt.next();
                    if (child instanceof ProgramElementNode) {
                        ProgramElementNode progNode = (ProgramElementNode)child;
                        if (!progNode.isCode()) {
                            childList.add(buildTree(child, associations));
                        }
                    } else {
                        childList.add(buildTree(child, associations));
                    }
                }
                //sortNodes(childList);
                for (Iterator it = childList.iterator(); it.hasNext(); ) {
                    treeNode.add((StructureViewNode)it.next());
                }
            }

        }
        return treeNode;
    }
================= fetch private StructureViewNode createViewNode(StructureNode node, StructureViewProper f1deb9c^:ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java

private StructureViewNode createViewNode(StructureNode node, StructureViewProperties properties) {
		if (node == null) return null;
		List children = new ArrayList();
		if (node instanceof ProgramElementNode) {
			ProgramElementNode pNode = (ProgramElementNode)node;
			if (pNode.getRelations() != null) {
				for (Iterator it = pNode.getRelations().iterator(); it.hasNext(); ) {
					StructureNode structureNode = (StructureNode)it.next();
					if (acceptNode(structureNode, properties)) {
						children.add(createViewNode(structureNode, properties));
					}
				}	
			}
			if (pNode.isRunnable() && pNode.getParent() != null) {
				ProgramElementNode parent = (ProgramElementNode)pNode.getParent();
				if (parent.getProgramElementKind().equals(ProgramElementNode.Kind.CLASS)
					|| parent.getProgramElementKind().equals(ProgramElementNode.Kind.ASPECT)) {
					parent.setRunnable(true);	
					pNode.setRunnable(false);
				}
			}
		}
		if (node.getChildren() != null) {
			for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
				StructureNode structureNode = (StructureNode)it.next();
				if (acceptNode(structureNode, properties)) {
					children.add(createViewNode(structureNode, properties));
				}
			}	
		}
		StructureViewNode viewNode = nodeFactory.createNode(node, children);//new TreeViewNode(root, null, children);
		return viewNode;	
	}
================= fetch private StructureViewNode getCrosscuttingChildren(StructureNode node) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java

private StructureViewNode getCrosscuttingChildren(StructureNode node) {
        //StructureViewNodeAdapter treeNode = new StructureViewNodeAdapter(node);
        StructureViewNode treeNode = nodeFactory.createNode(node);
        List relations = ((ProgramElementNode)node).getRelations();
        if (relations != null) {
            for (Iterator it = relations.iterator(); it.hasNext(); ) {
                RelationNode relation = (RelationNode)it.next();
                if (relation.getName().equals("pointcut used by")) {
                    for (Iterator it2 = relation.getChildren().iterator(); it2.hasNext(); ) {
                        ProgramElementNode pNode = ((LinkNode)it2.next()).getProgramElementNode();
                        StructureViewNode newNode = getCrosscuttingChildren(pNode);
                        for (Iterator it3 = pNode.getRelations().iterator(); it3.hasNext(); ) {
                            RelationNode relationNode = (RelationNode)it3.next();
                            if (relationNode.getName().indexOf("pointcut") == -1) {
                                newNode.add(getRelations(relationNode));
                            }
                        }
                        treeNode.add(newNode);
                    }
                } else if (relations.toString().indexOf("uses pointcut") == -1) {
                    for (Iterator it4 = relations.iterator(); it4.hasNext(); ) {
                        RelationNode relationNode = (RelationNode)it4.next();
                        if (relationNode.getName().indexOf("pointcut") == -1) {
                            treeNode.add(getRelations(relationNode));
                        }
                    }
                }
            }
        }
        return treeNode;
    }
================= fetch private StructureViewNode getInheritanceChildren(StructureNode node, List associ f1deb9c^:ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java

private StructureViewNode getInheritanceChildren(StructureNode node, List associations) {
    	StructureViewNode treeNode = nodeFactory.createNode(node);
        //StructureViewNode treeNode = new StructureViewNodeAdapter(node);
        List relations = ((ProgramElementNode)node).getRelations();
        if (relations != null) {
            for (Iterator it = relations.iterator(); it.hasNext(); ) {
                RelationNode relation = (RelationNode)it.next();
                if (relation.getName().equals("is inherited by")) {
                    for (Iterator it2 = relation.getChildren().iterator(); it2.hasNext(); ) {
                        ProgramElementNode pNode = ((LinkNode)it2.next()).getProgramElementNode();
                        StructureViewNode newNode = getInheritanceChildren(pNode, associations);
                        StructureViewNode typeChildren = buildTree(newNode.getStructureNode(), associations);
                        for (int i = 0; i < typeChildren.getChildren().size(); i++) {
                            newNode.add((StructureViewNode)typeChildren.getChildren().get(i));
                        }
						treeNode.add(newNode);
                    }
                }
            }
        }
        return treeNode;
    }
================= fetch private StructureViewNode getRelations(RelationNode node) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java

private StructureViewNode getRelations(RelationNode node) {
        //StructureViewNode treeNode = new StructureViewNode(node);
        StructureViewNode treeNode = nodeFactory.createNode(node);
        for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
            treeNode.add(
            	nodeFactory.createNode((StructureNode)it.next())
            );
        }
        return treeNode;
    }
================= fetch private boolean acceptGranularity(ProgramElementNode.Kind kind, StructureViewPro f1deb9c^:ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java

private boolean acceptGranularity(ProgramElementNode.Kind kind, StructureViewProperties.Granularity granularity) {
		
		if (granularity == StructureViewProperties.Granularity.DECLARED_ELEMENTS) {
			return true;
		} else if (granularity == StructureViewProperties.Granularity.MEMBER && 
			(kind != ProgramElementNode.Kind.CODE)) {
			return true;
		} else if (granularity == StructureViewProperties.Granularity.TYPE
			&& (kind == ProgramElementNode.Kind.PROJECT
				|| kind == ProgramElementNode.Kind.PACKAGE
				|| kind.isSourceFileKind()
				|| kind.isTypeKind())) {
			return true;			
		} else if (granularity == StructureViewProperties.Granularity.FILE
			&& (kind == ProgramElementNode.Kind.PROJECT
				|| kind == ProgramElementNode.Kind.PACKAGE
				|| kind.isSourceFileKind())) {
			return true;			
		} else if (granularity == StructureViewProperties.Granularity.PACKAGE
			&& (kind == ProgramElementNode.Kind.PROJECT
				|| kind == ProgramElementNode.Kind.PACKAGE)) {
			return true;			
		} else {
			return false;
		}
	}
================= fetch private boolean acceptNode(StructureNode node, StructureViewProperties propertie f1deb9c^:ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java

private boolean acceptNode(StructureNode node, StructureViewProperties properties) {
		if (node instanceof ProgramElementNode) {
			ProgramElementNode pNode = (ProgramElementNode)node;
			if (!acceptGranularity(pNode.getProgramElementKind(), properties.getGranularity())) {
				return false;
			} else if (pNode.isMemberKind()) {
				if (properties.getFilteredMemberAccessibility().contains(pNode.getAccessibility())) {
					return false;	
				}
				if (properties.getFilteredMemberKinds().contains(pNode.getProgramElementKind())) {
					return false;	
				}
				for (Iterator it = pNode.getModifiers().iterator(); it.hasNext(); ) {
					if (properties.getFilteredMemberModifiers().contains(it.next())) {
						return false;	
					}	
				}
			}
		} else if (node instanceof RelationNode) {
			Relation relation = ((RelationNode)node).getRelation();
			return properties.getRelations().contains(relation);
		} else {
			return true;
		}
		return true;
	}
================= fetch private boolean hasMoreSpecificChild(StructureNode node, String sourceFilePath, f1deb9c^:asm/src/org/aspectj/asm/StructureModel.java

private boolean hasMoreSpecificChild(StructureNode node, String sourceFilePath, int lineNumber) {
		for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
			ProgramElementNode child = (ProgramElementNode)it.next();
			if (matches(child, sourceFilePath, lineNumber)) return true;
		}
		return false;
	}
================= fetch private boolean isFileView(StructureView view) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java
/**
	 * @todo	get rid of this test, fix polymorphism
	 */
private boolean isFileView(StructureView view) {
		return view instanceof FileStructureView
			&& !(view instanceof GlobalStructureView);
	}
================= fetch private boolean matches(StructureNode node, String sourceFilePath, int lineNumbe f1deb9c^:asm/src/org/aspectj/asm/StructureModel.java

private boolean matches(StructureNode node, String sourceFilePath, int lineNumber) {
		try {			
//			if (node != null && node.getSourceLocation() != null)
//				System.err.println("====\n1: " + 
//					sourceFilePath + "\n2: " +
//					node.getSourceLocation().getSourceFile().getCanonicalPath().equals(sourceFilePath)
//				);	
			
			return node != null 
				&& node.getSourceLocation() != null
				&& node.getSourceLocation().getSourceFile().getCanonicalPath().equals(sourceFilePath)
				&& ((node.getSourceLocation().getLine() <= lineNumber
					&& node.getSourceLocation().getEndLine() >= lineNumber)
				    ||
					(lineNumber <= 1
					 && node instanceof ProgramElementNode 
					 && ((ProgramElementNode)node).getProgramElementKind().isSourceFileKind())	
				);
		} catch (IOException ioe) { 
			return false;
		} 
	}
================= fetch private boolean pruneEmptyDirs(BuildConfigNode node) { f1deb9c^:ajde/src/org/aspectj/ajde/internal/LstBuildConfigManager.java

private boolean pruneEmptyDirs(BuildConfigNode node) {
		List nodesToRemove = new ArrayList();
		for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
			BuildConfigNode currNode = (BuildConfigNode)it.next();
			boolean hasValidChildren = pruneEmptyDirs(currNode);
			if (!currNode.isValidResource() && !hasValidChildren) {
				nodesToRemove.add(currNode);
			} 
		}
		
		for (Iterator it = nodesToRemove.iterator(); it.hasNext(); ) {
			StructureNode currNode = (StructureNode)it.next();
			node.removeChild(currNode);	
		}
		return node.getChildren().size() > 0;
	}
================= fetch private boolean structureNodesEqual( StructureNode s1, StructureNode s2 ) { f1deb9c^:ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java

private boolean structureNodesEqual( StructureNode s1, StructureNode s2 ) {
	  final boolean equal = true;
	  	if ( s1 == s2 ) return equal;
	  	if ( null == s1 || null == s2 ) return !equal;

		if (!s1.getName( ).equals(s2.getName())) return !equal;
		if (!s1.getKind( ).equals(s2.getKind())) return !equal;
		
		// check child nodes
		List s1Kids = s1.getChildren();
		List s2Kids = s2.getChildren();
		
		if ( s1Kids != null && s2Kids != null ) {
			if (s1Kids == null || s2Kids == null) return !equal;			
			if (s1Kids.size() != s2Kids.size() ) return !equal;
			for ( int k=0; k<s1Kids.size(); k++ ) {
				StructureNode k1 = (StructureNode) s1Kids.get(k);
				StructureNode k2 = (StructureNode) s2Kids.get(k);	
				if (!structureNodesEqual( k1, k2 )) return !equal;
			}
		}
	  return equal;		
	}
================= fetch private static List getPackagesHelper( f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java

private static List getPackagesHelper(
		ProgramElementNode node,
		ProgramElementNode.Kind kind,
		String prename,
		List matches) {

		if (kind == null || node.getProgramElementKind().equals(kind)) {
			if (prename == null) {
				prename = new String(node.toString());
			} else {
				prename = new String(prename + "." + node);
			}
			Object[] o = new Object[2];
			o[0] = node;
			o[1] = prename;

			matches.add(o);
		}

		for (Iterator it = node.getChildren().iterator(); it.hasNext();) {
			StructureNode nextNode = (StructureNode) it.next();
			if (nextNode instanceof ProgramElementNode) {
				getPackagesHelper(
					(ProgramElementNode) nextNode,
					kind,
					prename,
					matches);
			}
		}

		return matches;
	}
================= fetch private static ProgramElementNode findMemberInClass( f1deb9c^:weaver/src/org/aspectj/weaver/AsmAdaptor.java

private static ProgramElementNode findMemberInClass(
		ProgramElementNode classNode,
		Member member)
	{
		if (classNode == null) return null; // XXX remove this check
		for (Iterator it = classNode.getChildren().iterator(); it.hasNext(); ) {
			ProgramElementNode node = (ProgramElementNode)it.next();
			//System.err.println("checking: " + member.getName() + " with " + node.getBytecodeName() + ", " + node.getBytecodeSignature());
			if (member.getName().equals(node.getBytecodeName()) &&
				member.getSignature().equals(node.getBytecodeSignature()))
			{
				return node;
			}
		}
	 	// if we can't find the member, we'll just put it in the class
		return classNode;
	}
================= fetch private static ProgramElementNode findOrCreateBodyNode( f1deb9c^:weaver/src/org/aspectj/weaver/AsmAdaptor.java

private static ProgramElementNode findOrCreateBodyNode(
		ProgramElementNode enclosingNode,
		Member shadowSig, Shadow shadow)
	{
		for (Iterator it = enclosingNode.getChildren().iterator(); it.hasNext(); ) {
			ProgramElementNode node = (ProgramElementNode)it.next();
			if (shadowSig.getName().equals(node.getBytecodeName()) &&
				shadowSig.getSignature().equals(node.getBytecodeSignature()))
			{
				return node;
			}
		}
		
		ISourceLocation sl = shadow.getSourceLocation();
		
		ProgramElementNode peNode = new ProgramElementNode(
			shadow.toString(),
			ProgramElementNode.Kind.CODE,
//XXX why not use shadow file? new SourceLocation(sl.getSourceFile(), sl.getLine()),
        new SourceLocation(enclosingNode.getSourceLocation().getSourceFile(), sl.getLine()),
//			enclosingNode.getSourceLocation(),
			0,
			"",
			new ArrayList());
			
		//System.err.println(peNode.getSourceLocation());
		peNode.setBytecodeName(shadowSig.getName());
		peNode.setBytecodeSignature(shadowSig.getSignature());
		enclosingNode.addChild(peNode);
		return peNode;
	}
================= fetch private static ProgramElementNode getNode(StructureModel model, Advice a) { f1deb9c^:weaver/src/org/aspectj/weaver/AsmAdaptor.java

private static ProgramElementNode getNode(StructureModel model, Advice a) {
		//ResolvedTypeX inAspect = a.getConcreteAspect();
		Member member = a.getSignature();
		if (a.getSignature() == null) return null;
		return lookupMember(model, member);
	}
================= fetch private static ProgramElementNode getNode(StructureModel model, Shadow shadow) { f1deb9c^:weaver/src/org/aspectj/weaver/AsmAdaptor.java

private static ProgramElementNode getNode(StructureModel model, Shadow shadow) {
		Member enclosingMember = shadow.getEnclosingCodeSignature();
		
		ProgramElementNode enclosingNode = lookupMember(model, enclosingMember);
		if (enclosingNode == null) {
			Lint.Kind err = shadow.getIWorld().getLint().shadowNotInStructure;
			if (err.isEnabled()) {
				err.signal(shadow.toString(), shadow.getSourceLocation());
			}
			return null;
		}
		
		Member shadowSig = shadow.getSignature();
		if (!shadowSig.equals(enclosingMember)) {
			ProgramElementNode bodyNode = findOrCreateBodyNode(enclosingNode, shadowSig, shadow);
			return bodyNode;
		} else {
			return enclosingNode;
		}
	}
================= fetch private static void addLink( f1deb9c^:weaver/src/org/aspectj/weaver/AsmAdaptor.java

private static void addLink(
		ProgramElementNode onNode,
		LinkNode linkNode,
		Relation relation,
		boolean isBack)
	{
		RelationNode node = null;
		String relationName = isBack ? relation.getBackNavigationName() : relation.getForwardNavigationName();
		
		//System.err.println("on: " + onNode + " relationName: " + relationName + " existin: " + onNode.getRelations());
		
		for (Iterator i = onNode.getRelations().iterator(); i.hasNext();) {
			RelationNode relationNode = (RelationNode) i.next();
			if (relationName.equals(relationNode.getName())) {
				node = relationNode;
				break;
			}
		}	
		if (node == null) {
			node = new RelationNode(relation,  relationName, new ArrayList());
			onNode.getRelations().add(node);
		}
		node.getChildren().add(linkNode);
		
	}
================= fetch private static void createAppropriateLinks( f1deb9c^:weaver/src/org/aspectj/weaver/AsmAdaptor.java

private static void createAppropriateLinks(
		ProgramElementNode target,
		ProgramElementNode advice,
		Relation relation)
	{
		if (target == null || advice == null) return;
		
		
		addLink(target, new LinkNode(advice),  relation, true);
		addLink(advice, new LinkNode(target),  relation, false);
		
//		System.out.println(">> added target: " + target.getProgramElementKind() + ", advice: " + advice);
//		System.out.println(">> target: " + target + ", advice: " + target.getSourceLocation());
	}
================= fetch private void addPackageNode(StructureView view, StructureViewNode viewRoot) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java

private void addPackageNode(StructureView view, StructureViewNode viewRoot) {
		if (isFileView(view)) {
			ProgramElementNode fileNode = (ProgramElementNode)viewRoot.getStructureNode();
			
			StructureNode parentNode = fileNode.getParent();
			if (parentNode instanceof ProgramElementNode 
				&& ((ProgramElementNode)parentNode).getProgramElementKind().equals(ProgramElementNode.Kind.PACKAGE)) {
				String name = ((ProgramElementNode)parentNode).getName();
				ProgramElementNode packageNode = new ProgramElementNode(name, ProgramElementNode.Kind.PACKAGE, null);
				packageNode.setSourceLocation(fileNode.getSourceLocation());
				StructureViewNode packageViewNode = createViewNode(
					packageNode, 
					view.getViewProperties()
				);
				viewRoot.getChildren().add(0, packageViewNode);
			};
		}
	}
================= fetch private void expandTree(int depth) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java

private void expandTree(int depth) {
        for (int i = 0; i < structureTree.getRowCount(); i++) {
            TreePath path = structureTree.getPathForRow(i);
            SwingTreeViewNode node = (SwingTreeViewNode)path.getLastPathComponent();
            if (path.getPath().length-1 > depth || node.getUserObject() instanceof RelationNode) {
                structureTree.collapsePath(path);
            } else {
                structureTree.expandPath(path);
            }
        }
        structureTree.expandPath(structureTree.getPathForRow(0));
    }
================= fetch private void expandTreeToFiles() { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java

private void expandTreeToFiles() {
        for (int i = 0; i < structureTree.getRowCount(); i++) {
            TreePath path = structureTree.getPathForRow(i);
            SwingTreeViewNode node = (SwingTreeViewNode)path.getLastPathComponent();
            if (node.getUserObject() instanceof ProgramElementNode) {
	            ProgramElementNode pNode = (ProgramElementNode)node.getUserObject();
	            ProgramElementNode.Kind kind = pNode.getProgramElementKind();
	            if (kind == ProgramElementNode.Kind.PROJECT
					|| kind == ProgramElementNode.Kind.PACKAGE) {
	                structureTree.expandPath(path);
	            } else {
	                structureTree.collapsePath(path);
	            }
            } else {
            	structureTree.collapsePath(path);
            }
        }
        structureTree.expandPath(structureTree.getPathForRow(0));
    }
================= fetch private void getAllStructureChildren(ProgramElementNode node, List result, boole f1deb9c^:asm/src/org/aspectj/asm/StructureModelManager.java

private void getAllStructureChildren(ProgramElementNode node, List result, boolean showSubMember, boolean showMemberAndType) {
        List children = node.getChildren();
        for (Iterator it = children.iterator(); it.hasNext(); ) {
            StructureNode next = (StructureNode)it.next();
            if (next instanceof ProgramElementNode) {
                ProgramElementNode pNode = (ProgramElementNode)next;
                if (pNode != null
                	&& ((pNode.isCode() && showSubMember) || (!pNode.isCode() && showMemberAndType))
                	&& pNode.getRelations() != null 
                	&& pNode.getRelations().size() > 0) {
                    result.add(next);
                }
                getAllStructureChildren((ProgramElementNode)next, result, showSubMember, showMemberAndType);
            }
        }
    }
================= fetch private void getRoots(StructureNode rootNode, List roots, StructureViewPropertie f1deb9c^:ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java

private void getRoots(StructureNode rootNode, List roots, StructureViewProperties.Hierarchy hierarchy) {
        if (rootNode != null && rootNode.getChildren() != null) {
            for (Iterator it = rootNode.getChildren().iterator(); it.hasNext(); ) {
                StructureNode node = (StructureNode)it.next();
                if (node instanceof ProgramElementNode) {
                    if (acceptNodeAsRoot((ProgramElementNode)node, hierarchy)) {
                        ProgramElementNode pNode = (ProgramElementNode)node;
                        List relations = pNode.getRelations();
                        String delimiter = "";
                        if (hierarchy.equals(StructureViewProperties.Hierarchy.CROSSCUTTING)) {
                            delimiter = "uses pointcut";
                        } else if (hierarchy.equals(StructureViewProperties.Hierarchy.INHERITANCE)) {
                            delimiter = "inherits";
                        } 
                        if (relations != null && relations.toString().indexOf(delimiter) == -1) {
                            boolean found = false;
                            for (Iterator it2 = roots.iterator(); it2.hasNext(); ) {
                                if (((ProgramElementNode)it2.next()).equals(pNode)) found = true;
                            }
                            if (!found) roots.add(pNode);
                        } 
                    } 
                }
                getRoots(node, roots, hierarchy);
            }
        }
    }
================= fetch private void hideNonAJ_button_actionPerformed(ActionEvent e) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/SimpleStructureViewToolPanel.java

private void hideNonAJ_button_actionPerformed(ActionEvent e) {
		if (hideNonAJEnabled) {
			hideNonAJ_button.setBorder(AjdeWidgetStyles.DEFAULT_BORDER);
			hideNonAJEnabled = false;
			currentView.getViewProperties().setFilteredMemberKinds(new ArrayList());
		} else {
			hideNonAJ_button.setBorder(AjdeWidgetStyles.LOWERED_BEVEL_BORDER);
			hideNonAJEnabled = true;
			currentView.getViewProperties().setFilteredMemberKinds(
				ProgramElementNode.Kind.getNonAJMemberKinds()
			);
		}
		Ajde.getDefault().getStructureViewManager().refreshView(currentView);
    }
================= fetch private void highlightNode(SwingTreeViewNode parent, ProgramElementNode node) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java

private void highlightNode(SwingTreeViewNode parent, ProgramElementNode node) {
        for (int i = 0; i < parent.getChildCount(); i++) {
            SwingTreeViewNode currNode = (SwingTreeViewNode)parent.getChildAt(i);
            StructureNode sNode = (StructureNode)currNode.getUserObject();
            if (sNode instanceof ProgramElementNode &&
                ((ProgramElementNode)sNode).equals(node)) {
                TreePath path = new TreePath(currNode.getPath());
                structureTree.setSelectionPath(path);
                int currRow = structureTree.getRowForPath(path);
                structureTree.expandRow(currRow);
                structureTree.scrollRowToVisible(currRow);
            } else {
                highlightNode(currNode, node);
            }
        }
    }
================= fetch private void maybeShowPopup(MouseEvent e) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java
/**
     * @todo    this should probably use <CODE>e.isPopupTrigger()</CODE> but that
     * doesn't work for some reason, so we just check if the right mouse button
     * has been clicked.
     */
private void maybeShowPopup(MouseEvent e) {
        if (e.getModifiers() == InputEvent.BUTTON3_MASK && tree.getSelectionCount() > 0) {
            TreePath[] selectionPaths = tree.getSelectionPaths();
            final List signatures = new ArrayList();
            for (int i = 0; i < selectionPaths.length; i++) {
                StructureNode currNode = (StructureNode)((SwingTreeViewNode)selectionPaths[i].getLastPathComponent()).getUserObject();
                if (currNode instanceof LinkNode || currNode instanceof ProgramElementNode) {
                    signatures.add(currNode);
                }
            }

            JPopupMenu popup = new JPopupMenu();
            JMenuItem showSourcesItem = new JMenuItem("Display sources", AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(ProgramElementNode.Kind.CODE));
            showSourcesItem.setFont(new java.awt.Font("Dialog", 0, 11));
            showSourcesItem.addActionListener(new AbstractAction() {
================= fetch private void navigationAction(ProgramElementNode node, boolean recordHistory) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureViewManager.java
/**
	 * Highlights the given node in all structure views.  If the node represents code
	 * and as such is below the granularity visible in the view the parent is highlighted,
	 * along with the corresponding sourceline.
	 */
private void navigationAction(ProgramElementNode node, boolean recordHistory) { 
		if (node == null 
			|| node == StructureModel.NO_STRUCTURE) {
			Ajde.getDefault().getIdeUIAdapter().displayStatusInformation("Source not available for node: " + node.getName());
			return;    	
		}
		Ajde.getDefault().logEvent("navigating to node: " + node + ", recordHistory: " + recordHistory);
		if (recordHistory) historyModel.navigateToNode(node); 
    	if (defaultFileView != null && node.getSourceLocation() != null) {
    		String newFilePath = node.getSourceLocation().getSourceFile().getAbsolutePath();
			if (defaultFileView.getSourceFile() != null
				&& !defaultFileView.getSourceFile().equals(newFilePath)) {
				defaultFileView.setSourceFile(newFilePath);
				treeViewBuilder.buildView(defaultFileView, StructureModelManager.getDefault().getStructureModel());
			}
		}
		   
	    for (Iterator it = structureViews.iterator(); it.hasNext(); ) {
    		StructureView view = (StructureView)it.next();
    		if (!(view instanceof GlobalStructureView) || !recordHistory || defaultFileView == null) {
	    		if (node.getProgramElementKind().equals(ProgramElementNode.Kind.CODE)) {
	    			ProgramElementNode parentNode = (ProgramElementNode)node.getParent();
	    			if (parentNode != null) {
		    			StructureViewNode currNode = view.findCorrespondingViewNode(parentNode);
		    			int lineOffset = node.getSourceLocation().getLine() - parentNode.getSourceLocation().getLine();
		    			if (currNode != null) view.setActiveNode(currNode, lineOffset);
	    			}
	    		} else {
	    			StructureViewNode currNode = view.findCorrespondingViewNode(node);
	    			if (currNode != null) view.setActiveNode(currNode);	
	    		}	
    		}
    	}
	}
================= fetch private void notifyListeners() { f1deb9c^:asm/src/org/aspectj/asm/StructureModelManager.java

private void notifyListeners() {
        for (Iterator it = structureListeners.iterator(); it.hasNext(); ) {
            ((StructureModelListener)it.next()).modelUpdated(model);
        }
    }
================= fetch private void printDecl(ProgramElementNode node, boolean recurse) { f1deb9c^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java
/**
         * @param   structureNode   can be a ProgramElementNode or a LinkNode
         */
private void printDecl(ProgramElementNode node, boolean recurse) {
        	if (node == null || node.getSourceLocation() == null) return;
            String kind = node.getKind().toLowerCase();
            print("(");
            print("(" + node.getSourceLocation().getLine() + " . " + node.getSourceLocation().getColumn() + ") ");
            print("(" + node.getSourceLocation().getLine() + " . " + node.getSourceLocation().getColumn() + ") ");
            print(kind + " ");                                     //2

            // HACK:
            String displayName = node.toString().replace('\"', ' ');

            print("\"" + displayName + "\" ");
            if (node.getSourceLocation().getSourceFile().getAbsolutePath() != null) {
                print("\"" + fixFilename(node.getSourceLocation().getSourceFile().getAbsolutePath()) + "\"");  //4
            } else {
                print("nil");
            }
            if (node.getSignature() != null) {
                print("\"" + node.getDeclaringType() + "\" ");         //5
            } else {
                print("nil");
            }

            if (!recurse) {
                print("nil");
                print("nil");
                print("nil");
            } else {
                print("(");
                if (node instanceof ProgramElementNode) {
                    java.util.List relations = ((ProgramElementNode)node).getRelations();
                    if (relations != null) {
                        for (Iterator it = relations.iterator(); it.hasNext(); ) {
                            RelationNode relNode = (RelationNode)it.next();
                            if (relNode.getRelation().getAssociationName().equals(AdviceAssociation.NAME) ||
                                relNode.getRelation().getAssociationName().equals(IntroductionAssociation.NAME)) {
                                printDecls(relNode);                                   // 6
                            }
                        }
                    }
                }
                print(") ");
                print("(");
                print(") ");
                print("(");
                Iterator it3 = node.getChildren().iterator();
                if (it3.hasNext()) {
                    while (it3.hasNext()) {
                        // this ignores relations on the compile unit
                        Object nodeObject = it3.next();
                        if (nodeObject instanceof ProgramElementNode) {
                            ProgramElementNode currNode = (ProgramElementNode)nodeObject;
                            if (//!currNode.isStmntKind() &&
                                !currNode.getKind().equals("<undefined>")) {
                                printDecl(currNode, true);
                            }
                        }
                    }
                }
                print(") ");
            }

            print(node.getKind().equals("class") ? "t " : "nil ");        // 9
//            print(node.getKind().equals("introduction") ? "t " : "nil "); // 10
            print(node.getKind().equals("introduction") ? "nil " : "nil "); // 10
            print("nil ");            // 11
            print("nil ");       // 12
            print(")");
        }
================= fetch private void printDecls(ProgramElementNode node) { f1deb9c^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java

private void printDecls(ProgramElementNode node) {
            print("(");
            for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
                // this ignores relations on the compile unit
                Object nodeObject = it.next();
                if (nodeObject instanceof ProgramElementNode) {
                    ProgramElementNode child = (ProgramElementNode)nodeObject;
                    printDecl(child, true);
                } else if (nodeObject instanceof LinkNode) {
                    LinkNode child = (LinkNode)nodeObject;
                    printDecl(child.getProgramElementNode(), false);
                }
            }
            print(") ");
        }
================= fetch private void printDecls(RelationNode node) { f1deb9c^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java

private void printDecls(RelationNode node) {
            for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
                // this ignores relations on the compile unit
                Object nodeObject = it.next();
                if (nodeObject instanceof LinkNode) {
                    LinkNode child = (LinkNode)nodeObject;
                    if (//!child.getProgramElementNode().getKind().equals("stmnt") &&
                        !child.getProgramElementNode().getKind().equals("<undefined>")) {
                        printDecl(child.getProgramElementNode(), false);
//                        printDecl(child.getProgramElementNode(), false);
                    }
                }
            }
        }
================= fetch private void setupModel() { f1deb9c^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

private void setupModel() {
        String rootLabel = "<root>";
        StructureModel model = StructureModelManager.getDefault().getStructureModel();
        ProgramElementNode.Kind kind = ProgramElementNode.Kind.FILE_JAVA;
        if (buildConfig.getConfigFile() != null) {
            rootLabel = buildConfig.getConfigFile().getName();
            model.setConfigFile(
                buildConfig.getConfigFile().getAbsolutePath()
            );
            kind = ProgramElementNode.Kind.FILE_LST;  
        }
        model.setRoot(new ProgramElementNode(rootLabel, kind, new ArrayList()));
                
        HashMap modelFileMap = new HashMap();
        model.setFileMap(new HashMap());
        setStructureModel(model);            
    }
================= fetch private void testModelIntegrityHelper(StructureNode node) throws Exception { f1deb9c^:ajde/testsrc/org/aspectj/ajde/StructureModelTest.java

private void testModelIntegrityHelper(StructureNode node) throws Exception {
		for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
			StructureNode child = (StructureNode)it.next();
			if (node == child.getParent()) {
				testModelIntegrityHelper(child);
			} else {
				throw new Exception("parent-child check failed for child: " + child.toString());
			}
		}		
	}
================= fetch private void testModelIntegrityHelper(StructureNode node) throws Exception { f1deb9c^:ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java

private void testModelIntegrityHelper(StructureNode node) throws Exception {
		for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
			StructureNode child = (StructureNode)it.next();
			if (node == child.getParent()) {
				testModelIntegrityHelper(child);
			} else {
				throw new Exception("parent-child check failed for child: " + child.toString());
			}
		}		
	}
================= fetch protected AbstractIcon createIcon(String path) { f1deb9c^:testing/src/org/aspectj/testing/ajde/CompileCommand.java

public void finish() {
                super.finish();
                setEndTime(System.currentTimeMillis());
            }
================= fetch protected AbstractIcon getStructureIcon(ProgramElementNode.Kind kind, ProgramEle f1deb9c^:ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java
/**
	 * @return	null if the kind could not be resolved
	 */
protected AbstractIcon getStructureIcon(ProgramElementNode.Kind kind, ProgramElementNode.Accessibility accessibility) {
		return getStructureIcon(kind, ProgramElementNode.Accessibility.PUBLIC);
	}
================= fetch protected AbstractIcon getStructureIcon(ProgramElementNode.Kind kind, ProgramEle f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/IconRegistry.java

protected AbstractIcon getStructureIcon(ProgramElementNode.Kind kind, ProgramElementNode.Accessibility accessibility) {
		return getStructureIcon(kind);	
	}
================= fetch protected StructureModelManager() { f1deb9c^:asm/src/org/aspectj/asm/StructureModelManager.java

================= fetch protected StructureViewNode createConcreteNode(StructureNode node, AbstractIcon f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNodeFactory.java

protected StructureViewNode createConcreteNode(StructureNode node, AbstractIcon icon, List children) {
		return new SwingTreeViewNode(node, icon, children);
	}
================= fetch public AbstractIcon getRelationIcon(Relation relation) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java

public AbstractIcon getRelationIcon(Relation relation) {
		if (relation.getAssociationName().equals(AdviceAssociation.NAME)) {
			return RELATION_ADVICE_FORWARD;
		} else if (relation.getAssociationName().equals(IntroductionAssociation.NAME)) {
			return RELATION_ADVICE_FORWARD;
		} else if (relation.getAssociationName().equals(InheritanceAssociation.NAME)) {
			return RELATION_INHERITANCE_FORWARD;
		} else {
			return RELATION_REFERENCE_FORWARD;
		}
	}
================= fetch public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java
/**
	 * Assumes "public" visibility for the icon.
	 * 
	 * @return	null if the kind could not be resolved
	 */
public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) { 
		if (kind == ProgramElementNode.Kind.PROJECT) {
			return PROJECT;
		} else if (kind == ProgramElementNode.Kind.PACKAGE) {
			return PACKAGE;
		} else if (kind == ProgramElementNode.Kind.FILE) {
			return FILE;
		} else if (kind == ProgramElementNode.Kind.FILE_JAVA) {
			return FILE_JAVA;
		} else if (kind == ProgramElementNode.Kind.FILE_ASPECTJ) {
			return FILE_ASPECTJ;
		} else if (kind == ProgramElementNode.Kind.FILE_LST) {
			return FILE_LST;
		} else if (kind == ProgramElementNode.Kind.CLASS) {
			return CLASS;
		} else if (kind == ProgramElementNode.Kind.INTERFACE) {
			return INTERFACE;
		} else if (kind == ProgramElementNode.Kind.ASPECT) {
			return ASPECT;
		} else if (kind == ProgramElementNode.Kind.INITIALIZER) {
			return INITIALIZER;
		} else if (kind == ProgramElementNode.Kind.INTER_TYPE_CONSTRUCTOR) {
			return INTRODUCTION;
		} else if (kind == ProgramElementNode.Kind.INTER_TYPE_FIELD) {
			return INTRODUCTION;
		} else if (kind == ProgramElementNode.Kind.INTER_TYPE_METHOD) {
			return INTRODUCTION;
		} else if (kind == ProgramElementNode.Kind.CONSTRUCTOR) {
			return CONSTRUCTOR;
		} else if (kind == ProgramElementNode.Kind.METHOD) {
			return METHOD;
		} else if (kind == ProgramElementNode.Kind.FIELD) {
			return FIELD;
		} else if (kind == ProgramElementNode.Kind.POINTCUT) {
			return POINTCUT;
		} else if (kind == ProgramElementNode.Kind.ADVICE) {
			return ADVICE;
		} else if (kind == ProgramElementNode.Kind.DECLARE_PARENTS) {
			return DECLARE_PARENTS;
		} else if (kind == ProgramElementNode.Kind.DECLARE_WARNING) {
			return DECLARE_WARNING;
		} else if (kind == ProgramElementNode.Kind.DECLARE_ERROR) {
			return DECLARE_ERROR;
		} else if (kind == ProgramElementNode.Kind.DECLARE_SOFT) {
			return DECLARE_SOFT;
		} else if (kind == ProgramElementNode.Kind.DECLARE_PRECEDENCE) {
			return DECLARE_SOFT;
		} else if (kind == ProgramElementNode.Kind.CODE) {
			return CODE;
		} else if (kind == ProgramElementNode.Kind.ERROR) {
			return ERROR;
		} else {
			System.err.println("AJDE Message: unresolved icon kind " + kind);
			return null;
		}
	}
================= fetch public AsmDeclarationsTest(String name) { f1deb9c^:ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java

================= fetch public BuildConfigNode(String name, Kind kind, String resourcePath) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/BuildConfigNode.java

================= fetch public BuildConfigNode(String name, String kind, String resourcePath, List child f1deb9c^:ajde/src/org/aspectj/ajde/ui/BuildConfigNode.java

================= fetch public CheckBoxSelectionMenuActionListener(ProgramElementNode.Accessibility acce f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java

================= fetch public CheckBoxSelectionMenuActionListener(ProgramElementNode.Kind kind) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java

================= fetch public CheckBoxSelectionMenuActionListener(StructureViewProperties.Sorting sorti f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java

================= fetch public CheckBoxSelectionMenuButton(ProgramElementNode.Accessibility accessibilit f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java

================= fetch public CheckBoxSelectionMenuButton(ProgramElementNode.Kind kind) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java

================= fetch public CheckBoxSelectionMenuButton(Relation relation) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java

================= fetch public CheckBoxSelectionMenuButton(String name) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java

public void actionPerformed(ActionEvent e) {
			currentView.getViewProperties().setGranularity(granularity);
			Ajde.getDefault().getStructureViewManager().refreshView(currentView);
		}
================= fetch public CheckBoxSelectionMenuButton(StructureViewProperties.Sorting sorting) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java

================= fetch public Component getTreeCellRendererComponent(JTree tree, f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNodeRenderer.java

public Component getTreeCellRendererComponent(JTree tree,
                                                    Object treeNode,
                                                    boolean sel,
                                                    boolean expanded,
                                                    boolean leaf,
                                                    int row,
                                                    boolean hasFocus) {
        if (treeNode == null) return null;        
        SwingTreeViewNode viewNode = (SwingTreeViewNode)treeNode;
        StructureNode node = viewNode.getStructureNode();

        if (node instanceof LinkNode) {
            ISourceLocation sourceLoc = ((LinkNode)node).getProgramElementNode().getSourceLocation();
            if ((null != sourceLoc) 
                && (null != sourceLoc.getSourceFile().getAbsolutePath())) {
                setTextNonSelectionColor(AjdeWidgetStyles.LINK_NODE_COLOR);
            } else {
                setTextNonSelectionColor(AjdeWidgetStyles.LINK_NODE_NO_SOURCE_COLOR);
            }
        } else {
        	setTextNonSelectionColor(new Color(0, 0, 0));	
        }
        
        super.getTreeCellRendererComponent(tree, treeNode, sel, expanded, leaf, row, hasFocus);
        this.setFont(StructureTree.DEFAULT_FONT);
        
		if (viewNode.getIcon() != null && viewNode.getIcon().getIconResource() != null) {
			setIcon((Icon)viewNode.getIcon().getIconResource());
		} else {
			setIcon(null);
		}
        
        if (node instanceof ProgramElementNode) {
        	ProgramElementNode pNode = (ProgramElementNode)node;
        	if (pNode.isRunnable()) {
        		//setIcon(AjdeUIManager.getDefault().getIconRegistry().getExecuteIcon());
        	}	 
        	if (pNode.isImplementor()) {
        		//this.setText("<implementor>");
        	}
        	if (pNode.isOverrider()) {
        		//this.setText("<overrider>");
        	}
        } else if (node instanceof RelationNode) {
        	this.setFont(new Font(this.getFont().getName(), Font.ITALIC, this.getFont().getSize()));
        }

        if (node.getMessage() != null) {
        	if (node.getMessage().getKind().equals(IMessage.WARNING)) {
        		setIcon(AjdeUIManager.getDefault().getIconRegistry().getWarningIcon());
        	} else if (node.getMessage().getKind().equals(IMessage.ERROR)) {
        		setIcon(AjdeUIManager.getDefault().getIconRegistry().getErrorIcon());
        	} else {
        		setIcon(AjdeUIManager.getDefault().getIconRegistry().getInfoIcon());
        	}
        }
		
        return this;
    }
================= fetch public Component getTreeCellRendererComponent(JTree tree, f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/TreeViewBuildConfigEditor.java

boolean isCheckBox(int x, int x_) {
            int d = x - x_;
            return (d < width) && (d > 0);
        }
================= fetch public FileStructureView getDefaultFileView() { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureViewManager.java

public FileStructureView getDefaultFileView() {
		return defaultFileView;
	}
================= fetch public HashMap getInlineAnnotations( f1deb9c^:asm/src/org/aspectj/asm/StructureModelManager.java
/**
     * Constructs map each time it's called.
     */
public HashMap getInlineAnnotations(
    	String sourceFile, 
    	boolean showSubMember, 
    	boolean showMemberAndType) { 
        
        if (!model.isValid()) return null;
		
        HashMap annotations = new HashMap();
        StructureNode node = model.findRootNodeForSourceFile(sourceFile);
        if (node == StructureModel.NO_STRUCTURE) {
            return null;
        } else {
            ProgramElementNode fileNode = (ProgramElementNode)node;
            ArrayList peNodes = new ArrayList();
            getAllStructureChildren(fileNode, peNodes, showSubMember, showMemberAndType);
            for (Iterator it = peNodes.iterator(); it.hasNext(); ) {
                ProgramElementNode peNode = (ProgramElementNode)it.next();
                List entries = new ArrayList();
                entries.add(peNode);
                ISourceLocation sourceLoc = peNode.getSourceLocation();
                if (null != sourceLoc) {
                    Integer hash = new Integer(sourceLoc.getLine());
                    List existingEntry = (List)annotations.get(hash);
                    if (existingEntry != null) {
                        entries.addAll(existingEntry);
                    }
                    annotations.put(hash, entries);
                }
            }
            return annotations;
        }
    }
================= fetch public Icon getAccessibilitySwingIcon(ProgramElementNode.Accessibility accessibi f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/IconRegistry.java

public Icon getAccessibilitySwingIcon(ProgramElementNode.Accessibility accessibility) {
		if (accessibility == ProgramElementNode.Accessibility.PUBLIC) {
			return ACCESSIBILITY_PUBLIC;
		} else if (accessibility == ProgramElementNode.Accessibility.PACKAGE) {
			return ACCESSIBILITY_PACKAGE;
		} else if (accessibility == ProgramElementNode.Accessibility.PROTECTED) {
			return ACCESSIBILITY_PROTECTED;
		} else if (accessibility == ProgramElementNode.Accessibility.PRIVATE) {
			return ACCESSIBILITY_PRIVATE;
		} else if (accessibility == ProgramElementNode.Accessibility.PRIVILEGED) {
			return ACCESSIBILITY_PRIVILEGED;
		} else {
			return null;
		}
	}
================= fetch public Icon getAssociationSwingIcon(Relation relation) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/IconRegistry.java

public Icon getAssociationSwingIcon(Relation relation) {
		return convertToSwingIcon(getRelationIcon(relation));	
    }
================= fetch public Icon getStructureSwingIcon(ProgramElementNode.Kind kind) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/IconRegistry.java

public Icon getStructureSwingIcon(ProgramElementNode.Kind kind) {
		return convertToSwingIcon(getStructureIcon(kind));
	}
================= fetch public Icon getStructureSwingIcon(ProgramElementNode.Kind kind, ProgramElementNo f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/IconRegistry.java

public Icon getStructureSwingIcon(ProgramElementNode.Kind kind, ProgramElementNode.Accessibility accessibility) { 
		return convertToSwingIcon(getStructureIcon(kind, accessibility));    	
    }
================= fetch public List findMatches( f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureSearchManager.java

public List findMatches(
		String pattern, 
		ProgramElementNode.Kind kind) {
		
		List matches = new ArrayList();
		StructureModel model = Ajde.getDefault().getStructureModelManager().getStructureModel();
		if (model.equals(StructureModel.NO_STRUCTURE)) {
			return null;
		} else {
			return findMatchesHelper((ProgramElementNode)model.getRoot(), pattern, kind, matches);
		}
	}
================= fetch public List getFilteredMemberAccessibility() { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java

public List getFilteredMemberAccessibility() {
        return filteredMemberAccessibility;
    }
================= fetch public ProgramElementNode findNode(ProgramElementNode parent, ProgramElementNode f1deb9c^:asm/src/org/aspectj/asm/StructureModel.java
/** 
	 * Returns the first match
	 * 
	 * @param parent
	 * @param kind		not null
	 * @param decErrLabel
	 * @return null if not found
	 */
public ProgramElementNode findNode(ProgramElementNode parent, ProgramElementNode.Kind kind, String name) {
		for (Iterator it = parent.getChildren().iterator(); it.hasNext(); ) {
			ProgramElementNode node = (ProgramElementNode)it.next();
			if (node.getProgramElementKind().equals(kind) 
				&& name.equals(node.getName())) {
				return node;
			} else {
				ProgramElementNode childSearch = findNode(node, kind, name);
				if (childSearch != null) return childSearch;
			}
		}
		return null;
	}
================= fetch public ProgramElementNode findNodeForClass(String packageName, String className) f1deb9c^:asm/src/org/aspectj/asm/StructureModel.java
/**
	 * @param packageName	if null default package is searched
	 * @param className 	can't be null
	 */
public ProgramElementNode findNodeForClass(String packageName, String className) {
		StructureNode packageNode = null;
		if (packageName == null) {
			packageNode = root;
		} else {
			for (Iterator it = root.getChildren().iterator(); it.hasNext(); ) {
				StructureNode node = (StructureNode)it.next();
				if (packageName.equals(node.getName())) {
					packageNode = node;
				} 
			}
			if (packageNode == null) return null;
		}
		
		// this searches each file for a class
		for (Iterator it = packageNode.getChildren().iterator(); it.hasNext(); ) {
			ProgramElementNode fileNode = (ProgramElementNode)it.next();
			ProgramElementNode ret = findClassInNodes(fileNode.getChildren(), className);
			if (ret != null) return ret;
		}
		
		return null;
	}
================= fetch public ProgramElementNode navigateBack() { f1deb9c^:ajde/src/org/aspectj/ajde/ui/internal/NavigationHistoryModel.java

public ProgramElementNode navigateBack() {
		if (backHistory.isEmpty() || currNode == null) return null;
		
		forwardHistory.push(currNode);
		currNode = (ProgramElementNode)backHistory.pop();
		return currNode;
	}
================= fetch public ProgramElementNode navigateForward() { f1deb9c^:ajde/src/org/aspectj/ajde/ui/internal/NavigationHistoryModel.java
/**
     * @return 	null if the history is empty
     */
public ProgramElementNode navigateForward() {
		if (forwardHistory.isEmpty() || currNode == null) return null;
		
		backHistory.push(currNode);
		currNode = (ProgramElementNode)forwardHistory.pop();
		return currNode;
	}
================= fetch public SExpressionPrinter(BufferedWriter writer) { f1deb9c^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java

private void dumpStructureToFile(ProgramElementNode node) throws IOException {
        String s = node.getKind();
        if (!  (s.equals(ProgramElementNode.Kind.FILE_ASPECTJ.toString())
                || s.equals(ProgramElementNode.Kind.FILE_JAVA.toString()))) {
            throw new IllegalArgumentException("externalize file, not " + node);
        }
        // source files have source locations
        String sourceName = node.getSourceLocation().getSourceFile().getAbsolutePath();
        String fileName = sourceName.substring(0, sourceName.lastIndexOf(".")) + EXTERN_FILE_SUFFIX;
        BufferedWriter writer = null;
        try {
            writer = new BufferedWriter(new FileWriter(new File(fileName)));
            new SExpressionPrinter(writer).printDecls(node);
            writer.flush();
        } finally {
            if (writer != null) {
                try {  
                    writer.close();
                } catch (IOException e) {} // ignore
            }
        }
    }
================= fetch public StructureNode findNodeForSourceLine(String sourceFilePath, int lineNumber f1deb9c^:asm/src/org/aspectj/asm/StructureModel.java
/**
	 * Never returns null 
	 * 
	 * @param		sourceFilePath	canonicalized path for consistency
	 * @param 		lineNumber		if 0 or 1 the corresponding file node will be returned
	 * @return		a new structure node for the file if it was not found in the model
	 */
public StructureNode findNodeForSourceLine(String sourceFilePath, int lineNumber) {
		String correctedPath = sourceFilePath;//.replace('\\', '/');
		StructureNode node = findNodeForSourceLineHelper(root, correctedPath, lineNumber);
		if (node != null) {
			return node;	
		} else {
			return createFileStructureNode(sourceFilePath);
		}
	}
================= fetch public StructureNode findRootNodeForSourceFile(String sourceFile) { f1deb9c^:asm/src/org/aspectj/asm/StructureModel.java
/**
	 * @param		sourceFilePath	modified to '/' delimited path for consistency
	 * @return		a new structure node for the file if it was not found in the model
	 */
public StructureNode findRootNodeForSourceFile(String sourceFile) {
       	try {
	       	if (!isValid() || sourceFile == null) {   
	            return StructureModel.NO_STRUCTURE;
	        } else {
	            String correctedPath = new File(sourceFile).getCanonicalPath();//.replace('\\', '/');
	            //StructureNode node = (StructureNode)getFileMap().get(correctedPath);//findFileNode(filePath, model);
				StructureNode node = (StructureNode)findInFileMap(correctedPath);//findFileNode(filePath, model);
	            if (node != null) {
	                return node;
	            } else {
	                return createFileStructureNode(correctedPath);
	            }
	        }
		} catch (Exception e) {
			return StructureModel.NO_STRUCTURE;
		}
    }
================= fetch public StructureNode getRoot() { f1deb9c^:asm/src/org/aspectj/asm/StructureModel.java

public StructureNode getRoot() {
        return root;
    }
================= fetch public StructureTreeManager() { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java

================= fetch public StructureViewNode createNode(StructureNode node) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureViewNodeFactory.java

public StructureViewNode createNode(StructureNode node) {
		return createNode(node, null);		
	}
================= fetch public StructureViewNode createNode(StructureNode node, List children) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureViewNodeFactory.java

public StructureViewNode createNode(StructureNode node, List children) {
		AbstractIcon icon;
		if (node instanceof ProgramElementNode) {
			ProgramElementNode pNode = (ProgramElementNode)node;
			icon = iconRegistry.getStructureIcon(pNode.getProgramElementKind(), pNode.getAccessibility());
		} else if (node instanceof RelationNode) {
			RelationNode relationNode = (RelationNode)node;
			icon = iconRegistry.getRelationIcon(relationNode.getRelation());
		} else if (node instanceof LinkNode) {
			LinkNode linkNode = (LinkNode)node;
			icon = iconRegistry.getStructureIcon(
				linkNode.getProgramElementNode().getProgramElementKind(), 
				linkNode.getProgramElementNode().getAccessibility());
		} else {
			icon = new AbstractIcon(null);	
		}
		return createConcreteNode(node, icon, children);
	}
================= fetch public StructureViewNode findCorrespondingViewNode(ProgramElementNode node) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureView.java
/**
	 * Searches from the root node of the view down in order to find matches.
	 * 
	 * @return		the first match
	 */
public StructureViewNode findCorrespondingViewNode(ProgramElementNode node) {
		return findCorrespondingViewNodeHelper(rootNode, node);
	}
================= fetch public StructureViewNode getActiveNode() { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureView.java
/**
	 * @return		the view node corresponding to the active ProgramElementNode or null
	 */
public StructureViewNode getActiveNode() {
		if (activeNode != null 
			&& activeNode.getStructureNode() instanceof ProgramElementNode) {
			return activeNode;
		} else {
			return null;
		}
	}
================= fetch public StructureViewNodeFactory(AbstractIconRegistry iconRegistry) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureViewNodeFactory.java

================= fetch public SwingTreeViewNode(StructureNode structureNode, AbstractIcon icon, List ch f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNode.java

================= fetch public SwingTreeViewNodeFactory(IconRegistry iconRegistry) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNodeFactory.java

================= fetch public boolean acceptNodeAsRoot(ProgramElementNode node, StructureViewProperties f1deb9c^:ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java

public boolean acceptNodeAsRoot(ProgramElementNode node, StructureViewProperties.Hierarchy hierarchy) {
        if (hierarchy.equals(StructureViewProperties.Hierarchy.CROSSCUTTING)) {
            return node.getProgramElementKind().equals(ProgramElementNode.Kind.ADVICE)
                || node.getProgramElementKind().equals(ProgramElementNode.Kind.POINTCUT);
        } else if (hierarchy.equals(StructureViewProperties.Hierarchy.INHERITANCE)) {
            return node.getProgramElementKind().equals(ProgramElementNode.Kind.CLASS);
        } else {	
            return false;
        }
    }
================= fetch public boolean isValid() { f1deb9c^:asm/src/org/aspectj/asm/StructureModel.java

public boolean isValid() {
        return root != null && fileMap != null;
    }
================= fetch public boolean verifyAgainstSavedModel(String lstFile) { f1deb9c^:ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java

public boolean verifyAgainstSavedModel(String lstFile) {
		File modelFile = new File(genStructureModelExternFilePath(lstFile));
		StructureModel model = getModelForFile(lstFile);
		System.out.println(">> model: " + model.getRoot());	
		
		if (modelFile.exists()) {
			Ajde.getDefault().getStructureModelManager().readStructureModel(lstFile);
			StructureModel savedModel = Ajde.getDefault().getStructureModelManager().getStructureModel();
			//System.err.println( savedModel.getRoot().getClass() + ", " +  savedModel.getRoot());
			
			// AMC This test will not pass as written until StructureNode defines
			// equals. The equals loic is commented out in the StructureNode
			// class - adding it back in could have unforeseen system-wide
			// consequences, so I've defined a structureNodesEqual( ) helper
			// method here instead.
			StructureNode rootNode = model.getRoot();
			StructureNode savedRootNode = savedModel.getRoot();
			return structureNodesEqual( rootNode, savedRootNode );
		} else {
			Ajde.getDefault().getStructureModelManager().writeStructureModel(lstFile);
			return true;
		}
		//return true;
	}
================= fetch public int compare(Object o1, Object o2) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java

private static List sortArray(List oldElements) {
		Object[] temp = oldElements.toArray();
		SortArrayComparator comparator = new SortArrayComparator();

		Arrays.sort(temp, comparator);
		
		List newElements = Arrays.asList(temp);

		return newElements;
	}
================= fetch public int compare(Object o1, Object o2) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java

private void dumpView(StructureViewNode root, int level) {
		System.out.println(root.getStructureNode());
		for (Iterator it = root.getChildren().iterator(); it.hasNext(); ) {
			dumpView((StructureViewNode)it.next(), level++);	
		}
		for (int i = 0; i < level; i++) {
			System.out.print(' ');
		}		
	}
================= fetch public static BrowserManager getDefault() { f1deb9c^:ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java

public static BrowserManager getDefault() {
		return INSTANCE;
	}
================= fetch public static List getFilesInPackage(ProgramElementNode packageNode) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java
/**
	 * @return		all of the AspectJ and Java source files in a package
	 */
static List getFilesInPackage(ProgramElementNode packageNode) {
		List packageContents;
		if (packageNode == null) {
			return null;
		} else {
			packageContents = packageNode.getChildren();	
		}
		List files = new ArrayList();
		for (Iterator it = packageContents.iterator(); it.hasNext(); ) {
			ProgramElementNode packageItem = (ProgramElementNode)it.next();
			if (packageItem.getProgramElementKind() == ProgramElementNode.Kind.FILE_JAVA 
				|| packageItem.getProgramElementKind() == ProgramElementNode.Kind.FILE_ASPECTJ) {
				files.add(packageItem);
			}
		} 
		return files;
	}
================= fetch public static List getPackagesInModel() { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java

public static List getPackagesInModel() {
		List packages = new ArrayList();
		StructureModel model =
			Ajde.getDefault().getStructureModelManager().getStructureModel();
		if (model.equals(StructureModel.NO_STRUCTURE)) {
			return null;
		} else {
			return getPackagesHelper(
				(ProgramElementNode) model.getRoot(),
				ProgramElementNode.Kind.PACKAGE,
				null,
				packages);
		}
	}
================= fetch public static Map getLinesToAspectMap(String sourceFilePath) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java

public static Map getLinesToAspectMap(String sourceFilePath) {

		Map annotationsMap =
			StructureModelManager.getDefault().getInlineAnnotations(
				sourceFilePath,
				true,
				true);

		Map aspectMap = new HashMap();
		Set keys = annotationsMap.keySet();
		for (Iterator it = keys.iterator(); it.hasNext();) {
			Object key = it.next();
			List annotations = (List) annotationsMap.get(key);
			for (Iterator it2 = annotations.iterator(); it2.hasNext();) {
				ProgramElementNode node = (ProgramElementNode) it2.next();

				List relations = node.getRelations();

				for (Iterator it3 = relations.iterator(); it3.hasNext();) {
					RelationNode relationNode = (RelationNode) it3.next();

					if (relationNode.getKind().equals("Advice")) {
						List children = relationNode.getChildren();

						List aspects = new Vector();

						for (Iterator it4 = children.iterator();
							it4.hasNext();
							) {
							Object object = it4.next();

							if (object instanceof LinkNode) {
								ProgramElementNode pNode =
									((LinkNode) object).getProgramElementNode();

								if (pNode.getProgramElementKind()
									== ProgramElementNode.Kind.ADVICE) {

									StructureNode theAspect = pNode.getParent();

									aspects.add(theAspect);

								}
							}
						}
						if (!aspects.isEmpty()) {
							aspectMap.put(key, aspects);
						}
					}

				}
			}
		}
		return aspectMap;
	}
================= fetch public static ProgramElementNode lookupMember(StructureModel model, Member membe f1deb9c^:weaver/src/org/aspectj/weaver/AsmAdaptor.java

public static ProgramElementNode lookupMember(StructureModel model, Member member) {
		TypeX declaringType = member.getDeclaringType();
		ProgramElementNode classNode =
			model.findNodeForClass(declaringType.getPackageName(), declaringType.getClassName());
		return findMemberInClass(classNode, member);
	}
================= fetch public static Set getAspectsAffectingPackage(ProgramElementNode packageNode) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java
/**
	 * This method is copied from StructureModelUtil inoder for it to use the working
	 * version of getLineToAspectMap()
	 * 
	 * @return		the set of aspects with advice that affects the specified package
	 */
public static Set getAspectsAffectingPackage(ProgramElementNode packageNode) {
		List files = StructureModelUtil.getFilesInPackage(packageNode);
		Set aspects = new HashSet();
		for (Iterator it = files.iterator(); it.hasNext();) {
			ProgramElementNode fileNode = (ProgramElementNode) it.next();
			Map adviceMap =
				getLinesToAspectMap(
					fileNode.getSourceLocation().getSourceFile().getAbsolutePath());
			Collection values = adviceMap.values();
			for (Iterator it2 = values.iterator(); it2.hasNext();) {
				aspects.add(it2.next());
			}
		}
		return aspects;
	}
================= fetch public static Test suite() { f1deb9c^:ajde/testsrc/org/aspectj/ajde/AjdeTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(AjdeTests.class.getName());
        //$JUnit-BEGIN$
        suite.addTestSuite(BuildOptionsTest.class); 
        suite.addTestSuite(BuildConfigurationTests.class);
        suite.addTestSuite(StructureModelRegressionTest.class); 
        suite.addTestSuite(StructureModelTest.class); 
        suite.addTestSuite(VersionTest.class); 
		suite.addTestSuite(CompilerMessagesTest.class);
		suite.addTestSuite(AsmDeclarationsTest.class);
		suite.addTestSuite(ResourceCopyTestCase.class);
		
        //$JUnit-END$
        return suite;
    }
================= fetch public static TestSuite suite() { f1deb9c^:ajde/testsrc/org/aspectj/ajde/StructureModelTest.java

public static TestSuite suite() {
		TestSuite result = new TestSuite();
		result.addTestSuite(StructureModelTest.class);	
		return result;
	}
================= fetch public static void noteMunger(StructureModel model, Shadow shadow, ShadowMunger f1deb9c^:weaver/src/org/aspectj/weaver/AsmAdaptor.java

public static void noteMunger(StructureModel model, Shadow shadow, ShadowMunger munger) {
		if (munger instanceof Advice) {
			Advice a = (Advice)munger;
			if (a.getKind().isPerEntry() || a.getKind().isCflow()) {
				// ??? might want to show these in the future
				return;
			}

//			System.out.println("--------------------------");
			ProgramElementNode targetNode = getNode(model, shadow);
			ProgramElementNode adviceNode = getNode(model, a);  
			
			Relation relation;
			if (shadow.getKind().equals(Shadow.FieldGet) || shadow.getKind().equals(Shadow.FieldSet)) {
				relation = AdviceAssociation.FIELD_ACCESS_RELATION;
			} else if (shadow.getKind().equals(Shadow.Initialization) || shadow.getKind().equals(Shadow.StaticInitialization)) {
				relation = AdviceAssociation.INITIALIZER_RELATION;
			} else if (shadow.getKind().equals(Shadow.ExceptionHandler)) {
				relation = AdviceAssociation.HANDLER_RELATION;
			} else if (shadow.getKind().equals(Shadow.MethodCall)) {
				relation = AdviceAssociation.METHOD_CALL_SITE_RELATION;
			} else if (shadow.getKind().equals(Shadow.ConstructorCall)) {
				relation = AdviceAssociation.CONSTRUCTOR_CALL_SITE_RELATION;
			} else if (shadow.getKind().equals(Shadow.MethodExecution) || shadow.getKind().equals(Shadow.AdviceExecution)) {
				relation = AdviceAssociation.METHOD_RELATION;
			} else if (shadow.getKind().equals(Shadow.ConstructorExecution)) {
				relation = AdviceAssociation.CONSTRUCTOR_RELATION;
			} else if (shadow.getKind().equals(Shadow.PreInitialization)) {
				// TODO: someone should check that this behaves reasonably in the IDEs
				relation = AdviceAssociation.INITIALIZER_RELATION;
			} else {
				System.err.println("> unmatched relation: " + shadow.getKind());
				relation = AdviceAssociation.METHOD_RELATION;
			}
			
//			System.out.println("> target: " + targetNode + ", advice: " + adviceNode);
			createAppropriateLinks(targetNode, adviceNode, relation);
		}
	}
================= fetch public void actionPerformed(ActionEvent e) { f1deb9c^:ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java

private void jbInit() throws Exception {
        border1 = BorderFactory.createBevelBorder(BevelBorder.LOWERED,Color.white,Color.white,new Color(148, 145, 140),new Color(103, 101, 98));
        border2 = BorderFactory.createEtchedBorder(Color.white,new Color(148, 145, 140));
        border3 = BorderFactory.createBevelBorder(BevelBorder.LOWERED,Color.white,Color.white,new Color(148, 145, 140),new Color(103, 101, 98));
        border4 = BorderFactory.createBevelBorder(BevelBorder.RAISED,Color.white,Color.white,new Color(148, 145, 140),new Color(103, 101, 98));
        border5 = BorderFactory.createEmptyBorder();
        border6 = BorderFactory.createEmptyBorder();
        border7 = BorderFactory.createBevelBorder(BevelBorder.RAISED,Color.white,Color.white,new Color(148, 145, 140),new Color(103, 101, 98));
        border8 = BorderFactory.createCompoundBorder(BorderFactory.createEtchedBorder(Color.white,new Color(156, 156, 158)),BorderFactory.createEmptyBorder(2,2,2,2));
        emptyBorder = BorderFactory.createEmptyBorder(2,2,2,2);
        jMenu1.setFont(new java.awt.Font("Dialog", 0, 11));
        jMenu1.setText("File");
        jMenu1.setMnemonic(KeyEvent.VK_F);
        jMenu2.setFont(new java.awt.Font("Dialog", 0, 11));
        jMenu2.setText("Project");
        jMenu2.setMnemonic(KeyEvent.VK_P);
        projectBuild_menuItem.setFont(new java.awt.Font("Dialog", 0, 11));
        projectBuild_menuItem.setText("Build");
        projectBuild_menuItem.setMnemonic(KeyEvent.VK_B);
        projectBuild_menuItem.setAccelerator(KeyStroke.getKeyStroke(
                            KeyEvent.VK_B, ActionEvent.ALT_MASK));

        projectBuild_menuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(ActionEvent e) {
                projectBuild_menuItem_actionPerformed(e);
            }
        });
        left_flowLayout.setAlignment(FlowLayout.LEFT);
        jMenuItem1.setFont(new java.awt.Font("Dialog", 0, 11));
        jMenuItem1.setText("Save");
        jMenuItem1.setMnemonic(KeyEvent.VK_S);
        jMenuItem1.setAccelerator(KeyStroke.getKeyStroke(
                            KeyEvent.VK_S, ActionEvent.ALT_MASK));
        jMenuItem1.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(ActionEvent e) {
                jMenuItem1_actionPerformed(e);
            }
        });
        exit_menuItem.setFont(new java.awt.Font("Dialog", 0, 11));
        exit_menuItem.setText("Exit");
        exit_menuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(ActionEvent e) {
                exit_menuItem_actionPerformed(e);
            }
        });
        top_splitPane.setPreferredSize(new Dimension(706, 800));
        top_splitPane.setDividerSize(4);
        this.getContentPane().setLayout(borderLayout3);
        projectRun_menuItem.setEnabled(true);
        projectRun_menuItem.setFont(new java.awt.Font("Dialog", 0, 11));
        projectRun_menuItem.setText("Run in same VM");
        projectRun_menuItem.setToolTipText("Run in same VM (hold shift down to run in separate process)");
        projectRun_menuItem.setMnemonic(KeyEvent.VK_R);
        projectRun_menuItem.setAccelerator(KeyStroke.getKeyStroke(
                                      KeyEvent.VK_R, ActionEvent.ALT_MASK));
        projectRun_menuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(ActionEvent e) {
                projectRun_menuItem_actionPerformed(e);
            }
        });  
        projectRunOther_menuItem.setEnabled(true);
        projectRunOther_menuItem.setFont(new java.awt.Font("Dialog", 0, 11));
        projectRunOther_menuItem.setText("Run in separate process");
        projectRunOther_menuItem.setMnemonic(KeyEvent.VK_P);
        projectRunOther_menuItem.setAccelerator(KeyStroke.getKeyStroke(
                                      KeyEvent.VK_P, ActionEvent.ALT_MASK));
        projectRunOther_menuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(ActionEvent e) {
                projectRunOther_menuItem_actionPerformed(e);
            }
        });  
        statusText_label.setFont(new java.awt.Font("Dialog", 0, 11));
        statusText_label.setBorder(BorderFactory.createLoweredBevelBorder());
        statusText_label.setMaximumSize(new Dimension(2000, 20));
        statusText_label.setPreferredSize(new Dimension(300, 20));
        status_panel.setLayout(borderLayout4);
        this.addWindowListener(new java.awt.event.WindowAdapter() {
            public void windowClosed(WindowEvent e) {
                this_windowClosed(e);
            }
            public void windowClosing(WindowEvent e) {
                this_windowClosing(e);
            }
        });
        toolbar_panel.setLayout(borderLayout5);
        right_splitPane.setOrientation(JSplitPane.VERTICAL_SPLIT);
        right_splitPane.setBorder(null);
        right_splitPane.setDividerSize(4);
        tools_menu.setFont(new java.awt.Font("Dialog", 0, 11));
        tools_menu.setText("Tools");
        tools_menu.setMnemonic(KeyEvent.VK_T);
        projectDebug_menuItem.setEnabled(false);
        projectDebug_menuItem.setFont(new java.awt.Font("Dialog", 0, 11));
        projectDebug_menuItem.setText("Debug");
        svProperties_menuItem.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(ActionEvent e) {
                svProperties_menuItem_actionPerformed(e);
            }
        });
        svProperties_menuItem.setText("Options...");
        svProperties_menuItem.setActionCommand("AJDE Console...");
        svProperties_menuItem.setFont(new java.awt.Font("Dialog", 0, 11));
        svProperties_menuItem.setMnemonic(KeyEvent.VK_O);
        svProperties_menuItem.setAccelerator(KeyStroke.getKeyStroke(
                            KeyEvent.VK_O, ActionEvent.ALT_MASK));
        build_toolBar.setBorder(emptyBorder);
        build_toolBar.setFloatable(false);
        closeConfig_button.setMaximumSize(new Dimension(100, 20));
        closeConfig_button.setEnabled(true);
        closeConfig_button.setFont(new java.awt.Font("Dialog", 0, 11));
        closeConfig_button.setBorder(null);
        closeConfig_button.setMinimumSize(new Dimension(24, 20));
        closeConfig_button.setPreferredSize(new Dimension(20, 20));
        closeConfig_button.setToolTipText("Close build configuration");
        closeConfig_button.setIcon(AjdeUIManager.getDefault().getIconRegistry().getCloseConfigIcon());
        closeConfig_button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(ActionEvent e) {
                closeConfig_button_actionPerformed(e);
            }
        });
        openConfig_button.setMaximumSize(new Dimension(100, 20));
        openConfig_button.setEnabled(true);
        openConfig_button.setFont(new java.awt.Font("Dialog", 0, 11));
        openConfig_button.setBorder(null);
        openConfig_button.setMinimumSize(new Dimension(24, 20));
        openConfig_button.setPreferredSize(new Dimension(20, 20));
        openConfig_button.setToolTipText("Select build configuration...");
        openConfig_button.setIcon(AjdeUIManager.getDefault().getIconRegistry().getOpenConfigIcon());
        openConfig_button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(ActionEvent e) {
                openConfig_button_actionPerformed(e);
            }
        });
        run_button.setMaximumSize(new Dimension(60, 20));
        run_button.setEnabled(true);
        run_button.setFont(new java.awt.Font("Dialog", 0, 11));
        run_button.setBorder(null);
        run_button.setMinimumSize(new Dimension(24, 20));
        run_button.setPreferredSize(new Dimension(20, 20));
        run_button.setToolTipText("Run in same VM (hold shift down to run in separate process)");
        run_button.setIcon(AjdeUIManager.getDefault().getIconRegistry().getExecuteIcon());
        run_button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(ActionEvent e) {
                run_button_actionPerformed(e);
            }
        });
        project_toolBar.setBorder(emptyBorder);
        save_button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(ActionEvent e) {
                save_button_actionPerformed(e);
            }
        });
        save_button.setIcon(AjdeUIManager.getDefault().getIconRegistry().getSaveIcon());
        save_button.setText("Save");
        save_button.setToolTipText("Save");
        save_button.setPreferredSize(new Dimension(55, 20));
        save_button.setMinimumSize(new Dimension(24, 20));
        save_button.setFont(new java.awt.Font("Dialog", 0, 11));
        save_button.setBorder(null);
        save_button.setMaximumSize(new Dimension(60, 20));
        options_button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(ActionEvent e) {
                options_button_actionPerformed(e);
            }
        });
        options_button.setIcon(AjdeUIManager.getDefault().getIconRegistry().getBrowserOptionsIcon());
        options_button.setText("Options");
        options_button.setToolTipText("Options...");
        options_button.setPreferredSize(new Dimension(60, 20));
        options_button.setMinimumSize(new Dimension(24, 20));
        options_button.setFont(new java.awt.Font("Dialog", 0, 11));
        options_button.setBorder(null);
        options_button.setMaximumSize(new Dimension(80, 20));
        editConfig_button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(ActionEvent e) {
                editConfig_button_actionPerformed(e);
            }
        });
        editConfig_button.setIcon(AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(ProgramElementNode.Kind.FILE_LST));
        editConfig_button.setText("Edit Config");
        editConfig_button.setToolTipText("Edit Config...");
        editConfig_button.setPreferredSize(new Dimension(80, 20));
        editConfig_button.setMinimumSize(new Dimension(24, 20));
        editConfig_button.setFont(new java.awt.Font("Dialog", 0, 11));
        editConfig_button.setBorder(null);
        editConfig_button.setMaximumSize(new Dimension(80, 20));
        file_toolBar.setBorder(emptyBorder);
        toolBar_panel.setLayout(borderLayout6);
        jLabel1.setFont(new java.awt.Font("Dialog", 0, 11));
        jLabel1.setText(" Build: ");
        jLabel2.setText("      Run: ");
        jLabel2.setFont(new java.awt.Font("Dialog", 0, 11));
        //fileStructure_panel.setFont(new java.awt.Font("Dialog", 0, 11));
        //browser_panel.setFont(new java.awt.Font("Dialog", 0, 11));
        this.getContentPane().add(top_splitPane, BorderLayout.CENTER);
        top_splitPane.add(right_splitPane, JSplitPane.RIGHT);
        top_splitPane.add(multiView_panel, JSplitPane.LEFT);
        right_splitPane.add(messages_panel, JSplitPane.BOTTOM);
        right_splitPane.add(editor_panel, JSplitPane.TOP);
        //structureView_pane.add(fileStructure_panel, JSplitPane.RIGHT);
        //structureView_pane.add(browser_panel, JSplitPane.LEFT);
        this.getContentPane().add(status_panel, BorderLayout.SOUTH);
        status_panel.add(statusText_label, BorderLayout.CENTER);
        this.getContentPane().add(toolbar_panel, BorderLayout.NORTH);
        toolbar_panel.add(filler_panel, BorderLayout.CENTER);
        toolbar_panel.add(toolBar_panel,  BorderLayout.WEST);
        //file_toolBar.add(editConfig_button, null);
        file_toolBar.add(save_button, null);
        file_toolBar.add(options_button, null);
        toolBar_panel.add(build_toolBar, BorderLayout.WEST);
        toolBar_panel.add(project_toolBar, BorderLayout.CENTER);
        project_toolBar.add(jLabel2, null);
        project_toolBar.add(run_button, null);
        build_toolBar.add(jLabel1, null);
        build_toolBar.add(openConfig_button, null);
        build_toolBar.add(closeConfig_button, null);
        toolBar_panel.add(file_toolBar, BorderLayout.EAST);
        menuBar.add(jMenu1);
        menuBar.add(jMenu2);
        menuBar.add(tools_menu);
        jMenu1.add(jMenuItem1);
        jMenu1.addSeparator();
        jMenu1.add(exit_menuItem);
        jMenu2.add(projectBuild_menuItem);
        jMenu2.add(projectRun_menuItem);
        jMenu2.add(projectRunOther_menuItem);
        //jMenu2.add(projectDebug_menuItem);
        tools_menu.add(joinpointProbe_menuItem);
        tools_menu.add(svProperties_menuItem);
        top_splitPane.setDividerLocation(380);
        right_splitPane.setDividerLocation(500);
        project_toolBar.addSeparator();
        project_toolBar.addSeparator();
    }
================= fetch public void actionPerformed(ActionEvent e) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/BrowserView.java

private void jbInit() throws Exception {
        default_border = BorderFactory.createEmptyBorder();
        this.setLayout(borderLayout1);
        toolBar_panel.setLayout(borderLayout2);
        toolBar_panel.setBorder(BorderFactory.createEtchedBorder());
        config_toolBar.setBorder(default_border);
        config_toolBar.setFloatable(false);
        configs_comboBox.setPreferredSize(new Dimension(200, 20));
        configs_comboBox.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(ActionEvent e) {
                configs_comboBox_actionPerformed(e);
            }
        });
        configs_comboBox.setMinimumSize(new Dimension(40, 20));
        configs_comboBox.setFont(new java.awt.Font("SansSerif", 0, 11));
        mainToolBar_panel.setLayout(borderLayout3);
        nav_toolBar.setFloatable(false);
        nav_toolBar.setBorder(default_border);
        forward_button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(ActionEvent e) {
                forward_button_actionPerformed(e);
            }
        });
        forward_button.setIcon(icons.getForwardIcon());
        forward_button.setToolTipText("Navigate forward");
        forward_button.setPreferredSize(new Dimension(20, 20));
        forward_button.setMinimumSize(new Dimension(20, 20));
        forward_button.setBorder(default_border);
        forward_button.setMaximumSize(new Dimension(24, 20));
        back_button.setMaximumSize(new Dimension(24, 20));
        back_button.setBorder(default_border);
        back_button.setMinimumSize(new Dimension(20, 20));
        back_button.setPreferredSize(new Dimension(20, 20));
        back_button.setToolTipText("Navigate back");
        back_button.setIcon(icons.getBackIcon());
        back_button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(ActionEvent e) {
                back_button_actionPerformed(e);
            }
        });
//        structureViews_box.add(comment_editorPane, null);
        views_splitPane.setOrientation(JSplitPane.VERTICAL_SPLIT);
        views_splitPane.setDividerSize(2);
        command_toolBar.setBorder(default_border);
        command_toolBar.setFloatable(false);
        splitView_button.setFont(new java.awt.Font("Dialog", 0, 11));
        splitView_button.setBorder(default_border);
        splitView_button.setMaximumSize(new Dimension(24, 24));
        splitView_button.setPreferredSize(new Dimension(20, 20));
        splitView_button.setToolTipText("Togge split-tree view mode");
        splitView_button.setIcon(icons.getSplitStructureViewIcon());
        splitView_button.setSelectedIcon(icons.getMergeStructureViewIcon());
        splitView_button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(ActionEvent e) {
                //splitView_button_actionPerformed(e);
            }
        });
        zoomToFile_button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(ActionEvent e) {
                //zoomToFile_button_actionPerformed(e);
            }
        });
        zoomToFile_button.setIcon(icons.getZoomStructureToFileModeIcon());
        zoomToFile_button.setSelectedIcon(icons.getZoomStructureToGlobalModeIcon());
        zoomToFile_button.setBorder(BorderFactory.createRaisedBevelBorder());
        zoomToFile_button.setMaximumSize(new Dimension(24, 24));
        zoomToFile_button.setPreferredSize(new Dimension(20, 20));
        zoomToFile_button.setToolTipText("Toggle file-view mode");
        zoomToFile_button.setFont(new java.awt.Font("Dialog", 0, 11));
        joinpointProbe_button.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(ActionEvent e) {
                joinpointProbe_button_actionPerformed(e);
            }
        });
        joinpointProbe_button.setIcon(icons.getStructureSwingIcon(ProgramElementNode.Kind.POINTCUT));
        joinpointProbe_button.setToolTipText("Create joinpoint probe");
        joinpointProbe_button.setPreferredSize(new Dimension(20, 20));
        joinpointProbe_button.setMinimumSize(new Dimension(20, 20));
        joinpointProbe_button.setBorder(default_border);
        joinpointProbe_button.setMaximumSize(new Dimension(24, 20));
        this.add(toolBar_panel,  BorderLayout.NORTH);
        toolBar_panel.add(mainToolBar_panel, BorderLayout.NORTH);
        mainToolBar_panel.add(config_toolBar, BorderLayout.CENTER);
        config_toolBar.add(configs_comboBox, null);
        mainToolBar_panel.add(nav_toolBar,  BorderLayout.EAST);
        nav_toolBar.add(splitView_button, null);
        nav_toolBar.add(zoomToFile_button, null);
        nav_toolBar.add(joinpointProbe_button, null);
        nav_toolBar.add(back_button, null);
        nav_toolBar.add(forward_button, null);
        mainToolBar_panel.add(command_toolBar,  BorderLayout.WEST);
        this.add(views_splitPane,  BorderLayout.CENTER);
        views_splitPane.setDividerLocation(400);
    }
================= fetch public void actionPerformed(ActionEvent e) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java

private void maybeShowPopup(MouseEvent e) {
        if (e.getModifiers() == InputEvent.BUTTON3_MASK && tree.getSelectionCount() > 0) {
            TreePath[] selectionPaths = tree.getSelectionPaths();
            final List signatures = new ArrayList();
            for (int i = 0; i < selectionPaths.length; i++) {
                StructureNode currNode = (StructureNode)((SwingTreeViewNode)selectionPaths[i].getLastPathComponent()).getUserObject();
                if (currNode instanceof LinkNode || currNode instanceof ProgramElementNode) {
                    signatures.add(currNode);
                }
            }

            JPopupMenu popup = new JPopupMenu();
            JMenuItem showSourcesItem = new JMenuItem("Display sources", AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(ProgramElementNode.Kind.CODE));
            showSourcesItem.setFont(new java.awt.Font("Dialog", 0, 11));
            showSourcesItem.addActionListener(new AbstractAction() {
                public void actionPerformed(ActionEvent e) {
                    //AjdeUIManager.getDefault().getViewManager().showSourcesNodes(signatures);
                    // USED THE FOLLOWING FROM: BrowserViewManager:
//					public void showSourcesNodes(java.util.List nodes) {
//						for (Iterator it = nodes.iterator(); it.hasNext(); ) {
//							ProgramElementNode currNode = null;
//							StructureNode structureNode = (StructureNode)it.next();
//							if (structureNode instanceof LinkNode) {
//								currNode = ((LinkNode)structureNode).getProgramElementNode();
//							} else {
//								currNode = (ProgramElementNode)structureNode;
//							}
//							ISourceLocation sourceLoc = currNode.getSourceLocation();
//							if (null != sourceLoc) {
//								Ajde.getDefault().getEditorManager().addViewForSourceLine(
//									sourceLoc.getSourceFile().getAbsolutePath(),
//									sourceLoc.getLine());
//							}
//						}
//					}

                }
            });
            popup.add(showSourcesItem);

            popup.addSeparator();
            JMenuItem generatePCD = new JMenuItem("Pointcut Wizard (alpha)...", AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(ProgramElementNode.Kind.POINTCUT));
            generatePCD.setFont(new java.awt.Font("Dialog", 0, 11));
            generatePCD.addActionListener(new AbstractAction() {
                public void actionPerformed(ActionEvent e) {
                    AjdeUIManager.getDefault().getViewManager().extractAndInsertSignatures(signatures, true);
                }
            });
            popup.add(generatePCD);

            popup.show(e.getComponent(), e.getX(), e.getY());
        }
    }
================= fetch public void actionPerformed(ActionEvent e) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/BuildConfigPopupMenu.java

================= fetch public void addFilteredMemberAccessibility(ProgramElementNode.Accessibility acce f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java

public void addFilteredMemberAccessibility(ProgramElementNode.Accessibility accessibility) {
 	   	this.filteredMemberAccessibility.add(accessibility);
	}
================= fetch public void addFilteredMemberKind(ProgramElementNode.Kind kind) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java

public void addFilteredMemberKind(ProgramElementNode.Kind kind) {
 	   	this.filteredMemberKinds.add(kind);
	}
================= fetch public void addFilteredMemberModifiers(ProgramElementNode.Modifiers modifiers) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java

public void addFilteredMemberModifiers(ProgramElementNode.Modifiers modifiers) {
 	   	this.filteredMemberModifiers.add(modifiers);
	}
================= fetch public void addListener(StructureModelListener listener) { f1deb9c^:asm/src/org/aspectj/asm/StructureModelManager.java

public void addListener(StructureModelListener listener) {
        structureListeners.add(listener);
    }
================= fetch public void addProjectTask(String message, IMessage.Kind kind) { f1deb9c^:ajde/testsrc/org/aspectj/ajde/NullIdeTaskListManager.java

public void addProjectTask(String message, IMessage.Kind kind) {
        if (!hasWarning && IMessage.WARNING.isSameOrLessThan(kind)) {
            hasWarning = true;
        }
    	System.out.println("> added project task: " + message + ", kind: " + kind);	
    }
================= fetch public void addRelation(Relation relation) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java

public void addRelation(Relation relation) {
        relations.add(relation);
    }
================= fetch public void addSourcelineTask(IMessage message) { f1deb9c^:ajde/testsrc/org/aspectj/ajde/NullIdeTaskListManager.java

public void addSourcelineTask(IMessage message) {
    	sourceLineTasks.add(new SourceLineTask(message));
        if (!hasWarning && IMessage.WARNING.isSameOrLessThan(message.getKind())) {
            hasWarning = true;
        }
    	System.out.println("> added sourceline task: " + message + ", file: " + message.getSourceLocation().getSourceFile().getAbsolutePath()
    		+ ": " +  message.getSourceLocation().getLine());
    }
================= fetch public void buildView(StructureView view, StructureModel model) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java
/**
	 * @todo	get rid of instanceof tests
	 */
public void buildView(StructureView view, StructureModel model) {
		StructureViewProperties properties = view.getViewProperties();
		StructureNode modelRoot = null;
		boolean noStructure = false;
		if (isFileView(view)) {
			FileStructureView fileView = (FileStructureView)view;
			if (fileView.getSourceFile() == null) {	
				modelRoot = StructureModel.NO_STRUCTURE;
				noStructure = true;
			} else {
				modelRoot = model.findRootNodeForSourceFile(fileView.getSourceFile());
			}
		} else {
			modelRoot = model.getRoot();
		}
	
		StructureViewNode viewRoot = null;
		if (!isFileView(view)) {
			StructureViewProperties.Hierarchy hierarchy 
				= ((GlobalStructureView)view).getGlobalViewProperties().getHierarchy();
			if (hierarchy.equals(StructureViewProperties.Hierarchy.CROSSCUTTING) 
				|| hierarchy.equals(StructureViewProperties.Hierarchy.INHERITANCE)) {
				viewRoot = buildCustomTree((GlobalStructureView)view, model);		
			}		
		} 
		if (viewRoot == null) {
			viewRoot = createViewNode(modelRoot, view.getViewProperties());//modelRoot;
		}  
		
		if (view.getViewProperties().getSorting() == StructureViewProperties.Sorting.ALPHABETICAL
			|| (!isFileView(view) && 
			 ((GlobalStructureView)view).getGlobalViewProperties().getHierarchy().equals(StructureViewProperties.Hierarchy.DECLARATION))) {
			sortView(viewRoot, ALPHABETICAL_COMPARATOR);
		} else {
			sortView(viewRoot, DECLARATIONAL_COMPARATOR);
		}  
		
		addPackageNode(view, viewRoot);
		view.setRootNode(viewRoot);
	}
================= fetch public void displayStatusInformation(String message) { f1deb9c^:ajde/testsrc/org/aspectj/ajde/NullIdeUIAdapter.java

public void displayStatusInformation(String message) {
		System.out.println("> NullIdeUIAdapter status : " + message);
	}
================= fetch public void doubleClickNavigation(MouseEvent e) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java

public void doubleClickNavigation(MouseEvent e) {
            int clickCount = e.getClickCount();
            SwingTreeViewNode treeNode = (SwingTreeViewNode)tree.getLastSelectedPathComponent();
            if (treeNode != null) {
                StructureNode currNode = (StructureNode)treeNode.getUserObject();
                if (currNode instanceof ProgramElementNode && !e.isControlDown() && !e.isShiftDown()
                    && e.getModifiers() != 4) {
                    //AjdeUIManager.getDefault().getViewManager().showNodeInMasterView(((LinkNode)currNode).getProgramElementNode());
                    //AjdeUIManager.getDefault().getViewManager().showNodeInSlaveView(((LinkNode)currNode).getProgramElementNode());
                } else if (currNode instanceof LinkNode) {
                    if (clickCount == 1) {
                        //AjdeUIManager.getDefault().getViewManager().showLink((LinkNode)currNode);
                    } else if (clickCount == 2) {
                        //navigationAction((ProgramElementNode)((LinkNode)currNode).getProgramElementNode(), true, true);
                    }
                }
            }
        }
================= fetch public void externalizeModel() { f1deb9c^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java

public void externalizeModel() {
    	if (!StructureModelManager.getDefault().getStructureModel().isValid()) return;
        
        try {
            //Set fileSet = StructureModelManager.INSTANCE.getStructureModel().getFileMap().entrySet(); 
			Set fileSet = StructureModelManager.getDefault().getStructureModel().getFileMapEntrySet(); 
            for (Iterator it = fileSet.iterator(); it.hasNext(); ) {
                ProgramElementNode peNode = (ProgramElementNode)((Map.Entry)it.next()).getValue();
                dumpStructureToFile(peNode);
            }
        } catch (IOException ioe) {
            ioe.printStackTrace();
        }
    }
================= fetch public void extractAndInsertSignatures(java.util.List signatures, boolean calls) f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/BrowserViewManager.java

public void extractAndInsertSignatures(java.util.List signatures, boolean calls) {
        PointcutWizard pointcutWizard = new PointcutWizard(signatures);
        pointcutWizard.setVisible(true);
        pointcutWizard.setLocation(AjdeUIManager.getDefault().getRootFrame().getX()+100, AjdeUIManager.getDefault().getRootFrame().getY()+100);
    }
================= fetch public void finishedCompilationUnit(CompilationUnitDeclaration unit) { f1deb9c^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

public void finishedCompilationUnit(CompilationUnitDeclaration unit) {
		if (buildManager.doGenerateModel()) {
			AsmBuilder.build(unit, buildManager.getStructureModel());
		}
	}
================= fetch public void fireNavigateBackAction(StructureView view) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureViewManager.java

public void fireNavigateBackAction(StructureView view) {
		ProgramElementNode backNode = historyModel.navigateBack();
		
		if (backNode == null) {
			Ajde.getDefault().getIdeUIAdapter().displayStatusInformation("No node to navigate back to in history");	
		} else {
			navigationAction(backNode, false);
		}
	}
================= fetch public void fireNavigateForwardAction(StructureView view) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureViewManager.java

public void fireNavigateForwardAction(StructureView view) {
		ProgramElementNode forwardNode = historyModel.navigateForward();
		
		if (forwardNode == null) {
			Ajde.getDefault().getIdeUIAdapter().displayStatusInformation("No node to navigate forward to in history");	
		} else {
			navigationAction(forwardNode, false);
		}
	}
================= fetch public void fireNavigationAction(String newFilePath, int lineNumber) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureViewManager.java
/**
	 * Only navigations of the default view are registered with
	 * the history.
     * @param newFilePath the canonicalized path to the new file
	 */
public void fireNavigationAction(String newFilePath, int lineNumber) {				
		StructureNode currNode = Ajde.getDefault().getStructureModelManager().getStructureModel().findNodeForSourceLine(
			newFilePath,
			lineNumber);
		
		if (currNode instanceof ProgramElementNode) {
			navigationAction((ProgramElementNode)currNode, true);	
		}
	}
================= fetch public void fireNavigationAction(StructureNode structureNode) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureViewManager.java
/**
	 * History is recorded for {@link LinkNode} navigations.
	 */
public void fireNavigationAction(StructureNode structureNode) {
		ProgramElementNode node = null;
		boolean recordHistory = false;
		if (structureNode instanceof LinkNode) {
			node = ((LinkNode)structureNode).getProgramElementNode();
			recordHistory = true;
		} else if (structureNode instanceof ProgramElementNode) {
			node = (ProgramElementNode)structureNode;
		}
		if (node != null) navigationAction(node, recordHistory);
	}
================= fetch public void genLabelAndKind(MethodDeclaration methodDeclaration, ProgramElementN f1deb9c^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java

public void genLabelAndKind(MethodDeclaration methodDeclaration, ProgramElementNode node) {
		if (methodDeclaration instanceof AdviceDeclaration) { 
			AdviceDeclaration ad = (AdviceDeclaration)methodDeclaration;
			node.setKind( ProgramElementNode.Kind.ADVICE);
			String label = "";
			label += ad.kind.toString();
			label += "(" + genArguments(ad) + "): ";

			if (ad.kind == AdviceKind.Around) {
				node.setReturnType(ad.returnTypeToString(0));
			}
	
			if (ad.pointcutDesignator != null) {	
				if (ad.pointcutDesignator.getPointcut() instanceof ReferencePointcut) {
					ReferencePointcut rp = (ReferencePointcut)ad.pointcutDesignator.getPointcut();
					label += rp.name + "..";
				} else if (ad.pointcutDesignator.getPointcut() instanceof AndPointcut) {
					AndPointcut ap = (AndPointcut)ad.pointcutDesignator.getPointcut();
					if (ap.getLeft() instanceof ReferencePointcut) {
						label += ap.getLeft().toString() + "..";	
					} else {
						label += POINTCUT_ANONYMOUS + "..";
					}
				} else if (ad.pointcutDesignator.getPointcut() instanceof OrPointcut) {
					OrPointcut op = (OrPointcut)ad.pointcutDesignator.getPointcut();
					if (op.getLeft() instanceof ReferencePointcut) {
						label += op.getLeft().toString() + "..";	
					} else {
						label += POINTCUT_ANONYMOUS + "..";
					}
				} else {
					label += POINTCUT_ANONYMOUS;
				}
			} else {
				label += POINTCUT_ABSTRACT;
			}
			node.setName(label);

		} else if (methodDeclaration instanceof PointcutDeclaration) { 
			PointcutDeclaration pd = (PointcutDeclaration)methodDeclaration;
			node.setKind( ProgramElementNode.Kind.POINTCUT);
			String label = translatePointcutName(new String(methodDeclaration.selector));
			label += "(" + genArguments(pd) + ")";
			node.setName(label); 
			
		} else if (methodDeclaration instanceof DeclareDeclaration) { 
			DeclareDeclaration declare = (DeclareDeclaration)methodDeclaration;
			String label = DEC_LABEL + " ";
			if (declare.declare instanceof DeclareErrorOrWarning) {
				DeclareErrorOrWarning deow = (DeclareErrorOrWarning)declare.declare;
				
				if (deow.isError()) {
					node.setKind( ProgramElementNode.Kind.DECLARE_ERROR);
					label += DECLARE_ERROR;
				} else {
					node.setKind( ProgramElementNode.Kind.DECLARE_WARNING);
					label += DECLARE_WARNING;
				}
				node.setName(label + "\"" + genDeclareMessage(deow.getMessage()) + "\"") ;
				 
			} else if (declare.declare instanceof DeclareParents) {
				node.setKind( ProgramElementNode.Kind.DECLARE_PARENTS);
				DeclareParents dp = (DeclareParents)declare.declare;
				node.setName(label + DECLARE_PARENTS + genTypePatternLabel(dp.getChild()));	
				
			} else if (declare.declare instanceof DeclareSoft) {
				node.setKind( ProgramElementNode.Kind.DECLARE_SOFT);
				DeclareSoft ds = (DeclareSoft)declare.declare;
				node.setName(label + DECLARE_SOFT + genTypePatternLabel(ds.getException()));
			} else if (declare.declare instanceof DeclarePrecedence) {
				node.setKind( ProgramElementNode.Kind.DECLARE_PRECEDENCE);
				DeclarePrecedence ds = (DeclarePrecedence)declare.declare;
				node.setName(label + DECLARE_PRECEDENCE + genPrecedenceListLabel(ds.getPatterns()));
			} else {
				node.setKind( ProgramElementNode.Kind.ERROR);
				node.setName(DECLARE_UNKNONWN);
			}
			
		} else if (methodDeclaration instanceof InterTypeDeclaration) {
			InterTypeDeclaration itd = (InterTypeDeclaration)methodDeclaration;
			String label = itd.onType.toString() + "." + new String(itd.getDeclaredSelector()); 
			if (methodDeclaration instanceof InterTypeFieldDeclaration) {
				node.setKind(ProgramElementNode.Kind.INTER_TYPE_FIELD);				
			} else if (methodDeclaration instanceof InterTypeMethodDeclaration) {
				node.setKind(ProgramElementNode.Kind.INTER_TYPE_METHOD);
				InterTypeMethodDeclaration itmd = (InterTypeMethodDeclaration)methodDeclaration;			
				label += "(" + genArguments(itd) + ")";
			} else if (methodDeclaration instanceof InterTypeConstructorDeclaration) {
				node.setKind(ProgramElementNode.Kind.INTER_TYPE_CONSTRUCTOR);
				InterTypeConstructorDeclaration itcd = (InterTypeConstructorDeclaration)methodDeclaration;				
			} else {
				node.setKind(ProgramElementNode.Kind.ERROR);
			}
			node.setName(label);
			node.setReturnType(itd.returnType.toString());
			
		} else {
			node.setKind(ProgramElementNode.Kind.METHOD);
			node.setName(new String(methodDeclaration.selector));	
		}
	}
================= fetch public void highlightActiveNode() { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/StructureViewPanel.java

public void highlightActiveNode() {
 		if (currentView.getActiveNode() == null) return;
 		StructureNode node = currentView.getActiveNode().getStructureNode();
 		if (node instanceof ProgramElementNode) {
 			treeManager.highlightNode((ProgramElementNode)node);
 		}
 	}
================= fetch public void highlightNode(ProgramElementNode node) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java

public void highlightNode(ProgramElementNode node) {
		highlightNode((SwingTreeViewNode)structureTree.getModel().getRoot(), node);
	}
================= fetch public void init(MultiStructureViewPanel multiViewPanel, JPanel compilerMessages f1deb9c^:ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java

public void init(MultiStructureViewPanel multiViewPanel, JPanel compilerMessagesPanel, JPanel editorPanel) {
        try {
        	this.multiView_panel = multiViewPanel;
            //this.browser_panel = browserPanel;
            //this.fileStructure_panel = fileStructurePanel;
            this.messages_panel = compilerMessagesPanel;
            this.editor_panel = editorPanel;
            this.sourceEditor_panel = editorPanel;

            jbInit();
            svProperties_menuItem.setIcon(AjdeUIManager.getDefault().getIconRegistry().getBrowserOptionsIcon());
            projectBuild_menuItem.setIcon(AjdeUIManager.getDefault().getIconRegistry().getBuildIcon());
            projectRun_menuItem.setIcon(AjdeUIManager.getDefault().getIconRegistry().getExecuteIcon());
            projectRunOther_menuItem.setIcon(AjdeUIManager.getDefault().getIconRegistry().getExecuteIcon());
            projectDebug_menuItem.setIcon(AjdeUIManager.getDefault().getIconRegistry().getDebugIcon());

            this.setJMenuBar(menuBar);
            this.setIconImage(((ImageIcon)AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(ProgramElementNode.Kind.ADVICE)).getImage());
            this.setLocation(75, 10);
            this.setSize(900, 650);
            this.setTitle(BrowserManager.TITLE);
            //bindKeys();
            fixButtonBorders();
            messages_panel.setVisible(false);

			JPopupMenu orderMenu = new BuildConfigPopupMenu(new AbstractAction() {
================= fetch public void init(String testProjectPath) { f1deb9c^:ajde/testsrc/org/aspectj/ajde/NullIdeManager.java

public void init(String testProjectPath) {
		try {
			UserPreferencesAdapter preferencesAdapter = new UserPreferencesStore(false);
			projectProperties = new NullIdeProperties(testProjectPath);
			taskListManager = new NullIdeTaskListManager();
			EditorAdapter ajdeEditor = new NullIdeEditorAdapter();
			IdeUIAdapter uiAdapter = new NullIdeUIAdapter();
			JFrame nullFrame = new JFrame();
			//configurationManager.setConfigFiles(getConfigFilesList(configFiles));	

			AjdeUIManager.getDefault().init(
				ajdeEditor,
				taskListManager,
				projectProperties,  
				preferencesAdapter,
				uiAdapter,
				new IconRegistry(),
				nullFrame,
				true);	
				
			//Ajde.getDefault().enableLogging( System.out );
		} catch (Throwable t) {
			t.printStackTrace();
			Ajde.getDefault().getErrorHandler().handleError(
				"Null IDE failed to initialize.",
				t);
		}
	}
================= fetch public void init( f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/AjdeUIManager.java

public void init(
		EditorAdapter editorAdapter,
		TaskListManager taskListManager,
		ProjectPropertiesAdapter projectProperties,
		UserPreferencesAdapter userPreferencesAdapter,
		IdeUIAdapter ideUIAdapter,
		IconRegistry iconRegistry,
		Frame rootFrame,
		boolean useFileView) {
		try {	
			BuildProgressMonitor compileProgress = new DefaultBuildProgressMonitor(rootFrame);
			ErrorHandler errorHandler = new AjdeErrorHandler();
			this.iconRegistry = iconRegistry;
			//ConfigurationManager configManager = new LstConfigurationManager();
			this.ideUIAdapter = ideUIAdapter;
			this.userPreferencesAdapter = userPreferencesAdapter;
			this.buildOptionsAdapter = new AjcBuildOptions(userPreferencesAdapter);
			this.buildConfigEditor = new TreeViewBuildConfigEditor();
			this.rootFrame = rootFrame;
			Ajde.init(
				editorAdapter,
				taskListManager,
				compileProgress,
				projectProperties,
				buildOptionsAdapter,
				new SwingTreeViewNodeFactory(iconRegistry),
				ideUIAdapter,
				errorHandler);
			
			Ajde.getDefault().getBuildManager().addListener(STATUS_TEXT_UPDATER);
			//Ajde.getDefault().setConfigurationManager(configManager);	
			
			if (useFileView) {
				FileStructureView structureView = Ajde.getDefault().getStructureViewManager().createViewForSourceFile(
	    			Ajde.getDefault().getEditorAdapter().getCurrFile(),
	    			Ajde.getDefault().getStructureViewManager().getDefaultViewProperties()
		    	);
		    	Ajde.getDefault().getStructureViewManager().setDefaultFileView(structureView);			
				fileStructurePanel = new StructureViewPanel(structureView);
			}
			
			viewManager = new BrowserViewManager();
			optionsFrame = new OptionsFrame(iconRegistry);
			
			//Ajde.getDefault().getStructureViewManager().refreshView(
			//	Ajde.getDefault().getStructureViewManager().getDefaultFileStructureView()
			//);
			
			//viewManager.updateView();
		} catch (Throwable t) {
			Ajde.getDefault().getErrorHandler().handleError("AJDE failed to initialize.", t);
		}
	}
================= fetch public void scrollToHighlightedNode() { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java

public void scrollToHighlightedNode() {
        structureTree.scrollPathToVisible(structureTree.getSelectionPath());
    }
================= fetch public void setActiveNode(StructureViewNode node, int lineOffset) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/StructureViewPanel.java

public void setActiveNode(StructureViewNode node, int lineOffset) {
		if (node == null) return;
 		if (!(node.getStructureNode() instanceof ProgramElementNode)) return;
		ProgramElementNode pNode = (ProgramElementNode)node.getStructureNode();
 		treeManager.highlightNode(pNode);
 		if (pNode.getSourceLocation() != null) {
	 		Ajde.getDefault().getEditorAdapter().showSourceLine(
	 			pNode.getSourceLocation().getSourceFile().getAbsolutePath(),
	 			pNode.getSourceLocation().getLine() + lineOffset,
	 			true
	 		);
 		}
	}
================= fetch public void setFilteredMemberKinds(List memberKinds) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java

public void setFilteredMemberKinds(List memberKinds) {
		this.filteredMemberKinds = memberKinds;
	}
================= fetch public void setFilteredMemberModifiers(List memberModifiers) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java

public void setFilteredMemberModifiers(List memberModifiers) {
        this.filteredMemberModifiers = memberModifiers;
    }
================= fetch public void setRelations(List relations) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java

public void setRelations(List relations) {
    	this.relations = relations;	
    }
================= fetch public void setSourceFile(String sourceFile) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/BuildConfigModel.java

public void setSourceFile(String sourceFile) {
		this.sourceFile = sourceFile;
	}
================= fetch public void singleClickNavigation(MouseEvent e) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java

public void singleClickNavigation(MouseEvent e) {
        SwingTreeViewNode treeNode = (SwingTreeViewNode)tree.getLastSelectedPathComponent();
        if (treeNode != null && !e.isControlDown() && !e.isShiftDown() && e.getModifiers() != 4) {
            StructureNode currNode = (StructureNode)treeNode.getUserObject();
            if (currNode instanceof ProgramElementNode && !e.isControlDown()
                && !e.isShiftDown() && e.getModifiers() != 4) {
                //AjdeUIManager.getDefault().getViewManager().showNodeInMasterView((ProgramElementNode)currNode);
                //if (AjdeUIManager.getDefault().getViewManager().isSplitViewMode()) {
                //    AjdeUIManager.getDefault().getViewManager().showNodeInSlaveView((ProgramElementNode)currNode);
                //}
            } else if (currNode instanceof LinkNode) {
                //if (!AjdeUIManager.getDefault().getViewManager().isSplitViewMode()) {
                //    AjdeUIManager.getDefault().getViewManager().showNodeInMasterView((LinkNode)currNode);
                //} else {
                //    AjdeUIManager.getDefault().getViewManager().showNodeInSlaveView(((LinkNode)currNode).getProgramElementNode());
                //}
           }
        }
    }
================= fetch public void testAbstract() { f1deb9c^:ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java

public void testAbstract() {
		ProgramElementNode node = (ProgramElementNode)model.getRoot();
		assertNotNull(node);
	
		ProgramElementNode aspect = StructureModelManager.getDefault().getStructureModel().findNodeForClass(null, "AbstractAspect");
		assertNotNull(aspect);	
		
		String abst = "abPtct()";
		ProgramElementNode abstNode = model.findNode(aspect, ProgramElementNode.Kind.POINTCUT, abst);
		assertNotNull(abstNode);		
		assertEquals(abstNode.getName(), abst);			
	}
================= fetch public void testAdvice() { f1deb9c^:ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java

public void testAdvice() {
		ProgramElementNode node = (ProgramElementNode)model.getRoot();
		assertNotNull(node);
	
		ProgramElementNode aspect = StructureModelManager.getDefault().getStructureModel().findNodeForClass(null, "AdviceNamingCoverage");
		assertNotNull(aspect);	

		String anon = "before(): <anonymous pointcut>";
		ProgramElementNode anonNode = model.findNode(aspect, ProgramElementNode.Kind.ADVICE, anon);
		assertNotNull(anonNode);		
		assertEquals(anonNode.getName(), anon);			

		String named = "before(): named..";
		ProgramElementNode namedNode = model.findNode(aspect, ProgramElementNode.Kind.ADVICE, named);
		assertNotNull(namedNode);		
		assertEquals(namedNode.getName(), named);		

		String namedWithOneArg = "around(int): namedWithOneArg..";
		ProgramElementNode namedWithOneArgNode = model.findNode(aspect, ProgramElementNode.Kind.ADVICE, namedWithOneArg);
		assertNotNull(namedWithOneArgNode);		
		assertEquals(namedWithOneArgNode.getName(), namedWithOneArg);		

		String afterReturning = "afterReturning(int, int): namedWithArgs..";
		ProgramElementNode afterReturningNode = model.findNode(aspect, ProgramElementNode.Kind.ADVICE, afterReturning);
		assertNotNull(afterReturningNode);		
		assertEquals(afterReturningNode.getName(), afterReturning);

		String around = "around(int): namedWithOneArg..";
		ProgramElementNode aroundNode = model.findNode(aspect, ProgramElementNode.Kind.ADVICE, around);
		assertNotNull(aroundNode);		
		assertEquals(aroundNode.getName(), around);

		String compAnon = "before(int): <anonymous pointcut>..";
		ProgramElementNode compAnonNode = model.findNode(aspect, ProgramElementNode.Kind.ADVICE, compAnon);
		assertNotNull(compAnonNode);		
		assertEquals(compAnonNode.getName(), compAnon);

		String compNamed = "before(int): named()..";
		ProgramElementNode compNamedNode = model.findNode(aspect, ProgramElementNode.Kind.ADVICE, compNamed);
		assertNotNull(compNamedNode);		
		assertEquals(compNamedNode.getName(), compNamed);
	}
================= fetch public void testDeclares() { f1deb9c^:ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java

public void testDeclares() {
		ProgramElementNode node = (ProgramElementNode)model.getRoot();
		assertNotNull(node);
	
		ProgramElementNode aspect = StructureModelManager.getDefault().getStructureModel().findNodeForClass(null, "InterTypeDecCoverage");
		assertNotNull(aspect);
		
		String decErrMessage = "declare error: \"Illegal construct..\"";
		ProgramElementNode decErrNode = model.findNode(aspect, ProgramElementNode.Kind.DECLARE_ERROR, decErrMessage);
		assertNotNull(decErrNode);
		assertEquals(decErrNode.getName(), decErrMessage);
		
		String decWarnMessage = "declare warning: \"Illegal construct..\"";
		ProgramElementNode decWarnNode = model.findNode(aspect, ProgramElementNode.Kind.DECLARE_WARNING, decWarnMessage);
		assertNotNull(decWarnNode);
		assertEquals(decWarnNode.getName(), decWarnMessage);	
		
		String decParentsMessage = "declare parents: Point";
		ProgramElementNode decParentsNode = model.findNode(aspect, ProgramElementNode.Kind.DECLARE_PARENTS, decParentsMessage);
		assertNotNull(decParentsNode);		
		assertEquals(decParentsNode.getName(), decParentsMessage);	
			
		String decParentsPtnMessage = "declare parents: Point+";
		ProgramElementNode decParentsPtnNode = model.findNode(aspect, ProgramElementNode.Kind.DECLARE_PARENTS, decParentsPtnMessage);
		assertNotNull(decParentsPtnNode);		
		assertEquals(decParentsPtnNode.getName(), decParentsPtnMessage);			

		String decParentsTPMessage = "declare parents: <type pattern>";
		ProgramElementNode decParentsTPNode = model.findNode(aspect, ProgramElementNode.Kind.DECLARE_PARENTS, decParentsTPMessage);
		assertNotNull(decParentsTPNode);		
		assertEquals(decParentsTPNode.getName(), decParentsTPMessage);
		
		String decSoftMessage = "declare soft: SizeException";
		ProgramElementNode decSoftNode = model.findNode(aspect, ProgramElementNode.Kind.DECLARE_SOFT, decSoftMessage);
		assertNotNull(decSoftNode);		
		assertEquals(decSoftNode.getName(), decSoftMessage);		

		String decPrecMessage = "declare precedence: AdviceCoverage, InterTypeDecCoverage, <type pattern>";
		ProgramElementNode decPrecNode = model.findNode(aspect, ProgramElementNode.Kind.DECLARE_PRECEDENCE, decPrecMessage);
		assertNotNull(decPrecNode);		
		assertEquals(decPrecNode.getName(), decPrecMessage);	
	}
================= fetch public void testFileNodeFind() throws IOException { f1deb9c^:ajde/testsrc/org/aspectj/ajde/StructureModelTest.java

public void testFileNodeFind() throws IOException {
		File testFile = openFile("figures-coverage/figures/Main.java");
		//System.err.println("NodeFind, testFile: " + testFile.getCanonicalPath() + " exists: " + testFile.exists());
		StructureNode node = Ajde.getDefault().getStructureModelManager().getStructureModel().findNodeForSourceLine(
			testFile.getCanonicalPath(), 1);
		//System.err.println("   node: " + node);
		assertTrue("find result", node != null) ;	
		assertEquals("find result has children", 2, node.getChildren().size()) ;	
		ProgramElementNode pNode = (ProgramElementNode)node;
		assertTrue("found node: " + pNode.getName(), pNode.getProgramElementKind().equals(ProgramElementNode.Kind.FILE_JAVA));
	}
================= fetch public void testFindPatternAndKindMatch() { f1deb9c^:ajde/testsrc/org/aspectj/ajde/ui/StructureSearchManagerTest.java

public void testFindPatternAndKindMatch() {
		List matches = Ajde.getDefault().getStructureSearchManager().findMatches(
			"Point",
			ProgramElementNode.Kind.CONSTRUCTOR
		);
		System.err.println(matches);
		assertTrue("non existent node", true);
	}
================= fetch public void testFreshStructureModelCreation() { f1deb9c^:ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java
/**
	 * @todo	this should be moved to a StructureModelManager test
	 */
public void testFreshStructureModelCreation() {
		renderer.setHasBeenNotified(false);
		String modelPath = genStructureModelExternFilePath(CONFIG_FILE_PATH);
		openFile(modelPath).delete();
		//System.err.println("> path: " + modelPath);
		
		Ajde.getDefault().getStructureModelManager().readStructureModel(CONFIG_FILE_PATH);
		
		assertTrue("notified", renderer.getHasBeenNotified());	
		//System.err.println(">>>>>> " + currentView.getRootNode().getStructureNode());
		// AMC should this be currentView, or should we recreate the root... do the latter	
		//StructureNode n = currentView.getRootNode().getStructureNode();
		StructureNode n = Ajde.getDefault().getStructureModelManager().getStructureModel().getRoot();
		assertTrue(
			"no structure", 
			//currentView.getRootNode().getStructureNode().getChildren().get(0) 
			n == StructureModel.NO_STRUCTURE
		);	
	}
================= fetch public void testInterTypeMemberDeclares() { f1deb9c^:ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java

public void testInterTypeMemberDeclares() {
		ProgramElementNode node = (ProgramElementNode)model.getRoot();
		assertNotNull(node);
	
		ProgramElementNode aspect = StructureModelManager.getDefault().getStructureModel().findNodeForClass(null, "InterTypeDecCoverage");
		assertNotNull(aspect);
		
		String fieldMsg = "Point.xxx";
		ProgramElementNode fieldNode = model.findNode(aspect, ProgramElementNode.Kind.INTER_TYPE_FIELD, fieldMsg);
		assertNotNull(fieldNode);		
		assertEquals(fieldNode.getName(), fieldMsg);

		String methodMsg = "Point.check(int, Line)";
		ProgramElementNode methodNode = model.findNode(aspect, ProgramElementNode.Kind.INTER_TYPE_METHOD, methodMsg);
		assertNotNull(methodNode);		
		assertEquals(methodNode.getName(), methodMsg);

		// TODO: enable
//		String constructorMsg = "Point.new(int, int, int)";
//		ProgramElementNode constructorNode = model.findNode(aspect, ProgramElementNode.Kind.INTER_TYPE_CONSTRUCTOR, constructorMsg);
//		assertNotNull(constructorNode);		
//		assertEquals(constructorNode.getName(), constructorMsg);
	}
================= fetch public void testMainClassNodeInfo() throws IOException { f1deb9c^:ajde/testsrc/org/aspectj/ajde/StructureModelTest.java
/**
  	 * @todo	add negative test to make sure things that aren't runnable aren't annotated
  	 */
public void testMainClassNodeInfo() throws IOException {
        StructureModel model = Ajde.getDefault().getStructureModelManager().getStructureModel();
        assertTrue("model exists", model != null);
		assertTrue("root exists", model.getRoot() != null);
		File testFile = openFile("figures-coverage/figures/Main.java");
		StructureNode node = model.findNodeForSourceLine(testFile.getCanonicalPath(), 11);	
			
		assertTrue("find result", node != null);	
			
		ProgramElementNode pNode = (ProgramElementNode)((ProgramElementNode)node).getParent();
        if (null == pNode) {
            assertTrue("null parent of " + node, false);
        }
		assertTrue("found node: " + pNode.getName(), pNode.isRunnable());
	}
================= fetch public void testModelIntegrity() { f1deb9c^:ajde/testsrc/org/aspectj/ajde/StructureModelTest.java
/**
	 * Integrity could be checked somewhere in the API.
	 */
public void testModelIntegrity() {
		StructureNode modelRoot = Ajde.getDefault().getStructureModelManager().getStructureModel().getRoot();
		assertTrue("root exists", modelRoot != null);	
		
		try {
			testModelIntegrityHelper(modelRoot);
		} catch (Exception e) {
			assertTrue(e.toString(), false);	
		}
	}
================= fetch public void testModelIntegrity() { f1deb9c^:ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java

public void testModelIntegrity() {
		doSynchronousBuild(CONFIG_FILE_PATH);
		StructureNode modelRoot = Ajde.getDefault().getStructureModelManager().getStructureModel().getRoot();
		assertTrue("root exists", modelRoot != null);	
		
		try {
			testModelIntegrityHelper(modelRoot);
		} catch (Exception e) {
			assertTrue(e.toString(), false);	
		}
	}
================= fetch public void testNoChildIsNull() { f1deb9c^:ajde/testsrc/org/aspectj/ajde/StructureModelTest.java

public void testNoChildIsNull() {
  		ModelWalker walker = new ModelWalker() {
================= fetch public void testNotificationAfterConfigFileChange() { f1deb9c^:ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java

public void testNotificationAfterConfigFileChange() {
		doSynchronousBuild(CONFIG_FILE_PATH_2);
		renderer.setHasBeenNotified(false);
		assertTrue("not yet notified", !renderer.getHasBeenNotified());
		Ajde.getDefault().getConfigurationManager().setActiveConfigFile(CONFIG_FILE_PATH_2);			
		assertTrue("notified", renderer.getHasBeenNotified());
		renderer.setHasBeenNotified(false);
		Ajde.getDefault().getConfigurationManager().setActiveConfigFile("MumbleDoesNotExist.lst");			
		assertTrue("notified", renderer.getHasBeenNotified());		
		assertTrue(
			"no structure", 
			currentView.getRootNode().getStructureNode().getChildren().get(0) 
			== StructureModel.NO_STRUCTURE
		);			
	}
================= fetch public void testNullHandlingOfVisit() { f1deb9c^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AsmBuilderTest.java
/**
	 * Test for bug#39626
	 */
public void testNullHandlingOfVisit() { 
		ICompilationUnit cu = new ICompilationUnit() {
			public char[] getContents() {
				return null;
			}

			public char[] getMainTypeName() {
				return null;
			}

			public char[][] getPackageName() {
				return null;
			}
			
			public char[] getFileName() { 
				return null;
			}
			
		};
		LocalTypeDeclaration local = new LocalTypeDeclaration(new CompilationResult(cu, 0, 0, 0));
		local.name = new char[2];
		BlockScope scope = null;
		
		try { 
			new AsmBuilder(new CompilationResult(cu, 0, 0, 0)).visit(local, scope);
		} catch (Exception e) {
			assertTrue(e instanceof EmptyStackException);
		}
	}
================= fetch public void testPackageViewUtil() { f1deb9c^:ajde/testsrc/org/aspectj/ajde/ui/StructureModelUtilTest.java

public void testPackageViewUtil() {
		List packages = StructureModelUtil.getPackagesInModel(); 
		assertTrue("packages list not null", packages != null);
        assertTrue("packages list not empty", !packages.isEmpty());
		// System.err.println("> packages: " + packages);
	
		ProgramElementNode packageNode = (ProgramElementNode)((Object[])packages.get(0))[0];
		assertTrue("package node not null", packageNode != null);
		// System.err.println("> package node: " + packageNode);
		
		List files = StructureModelUtil.getFilesInPackage(packageNode);
		assertTrue("fle list not null", files != null);
		// System.err.println("> file list: " + files);
		
		Map lineAdviceMap = StructureModelUtil.getLinesToAspectMap(
			((ProgramElementNode)files.get(0)).getSourceLocation().getSourceFile().getAbsolutePath()
		);
		assertTrue("line->advice map not null", lineAdviceMap != null);
		// System.err.println("> line->advice map: " + lineAdviceMap);			
		
		Set aspects = StructureModelUtil.getAspectsAffectingPackage(packageNode);
		assertTrue("aspect list not null", aspects != null);
		// System.err.println("> aspects affecting package: " + aspects);			
	}
================= fetch public void testPointcutName() throws IOException { f1deb9c^:ajde/testsrc/org/aspectj/ajde/StructureModelTest.java

public void testPointcutName() throws IOException {
		File testFile = openFile("figures-coverage/figures/Main.java");	
		//System.err.println("PointcutName, testFile: " + testFile.getCanonicalPath() + " exists: " + testFile.exists());
		StructureNode node = Ajde.getDefault().getStructureModelManager().getStructureModel().findRootNodeForSourceFile(
			testFile.getCanonicalPath());
		//System.err.println("   node: " + node);
		assertTrue("find result", node != null) ;	
		ProgramElementNode pNode = (ProgramElementNode)((ProgramElementNode)node).getChildren().get(1);
		ProgramElementNode pointcut = (ProgramElementNode)pNode.getChildren().get(0);
		assertTrue("kind", pointcut.getProgramElementKind().equals(ProgramElementNode.Kind.POINTCUT));
		assertTrue("found node: " + pointcut.getName(), pointcut.getName().equals("testptct()"));
	}
================= fetch public void testPointcuts() { f1deb9c^:ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java

public void testPointcuts() {
		ProgramElementNode node = (ProgramElementNode)model.getRoot();
		assertNotNull(node);
	
		ProgramElementNode aspect = StructureModelManager.getDefault().getStructureModel().findNodeForClass(null, "AdviceNamingCoverage");
		assertNotNull(aspect);		
	
		String ptct = "named()";
		ProgramElementNode ptctNode = model.findNode(aspect, ProgramElementNode.Kind.POINTCUT, ptct);
		assertNotNull(ptctNode);		
		assertEquals(ptctNode.getName(), ptct);		

		String params = "namedWithArgs(int, int)";
		ProgramElementNode paramsNode = model.findNode(aspect, ProgramElementNode.Kind.POINTCUT, params);
		assertNotNull(paramsNode);		
		assertEquals(paramsNode.getName(), params);	


	}
================= fetch public void testRootForSourceFile() throws IOException { f1deb9c^:ajde/testsrc/org/aspectj/ajde/StructureModelTest.java
//	}
public void testRootForSourceFile() throws IOException {
		File testFile = openFile("figures-coverage/figures/Figure.java");	
		StructureNode node = Ajde.getDefault().getStructureModelManager().getStructureModel().findRootNodeForSourceFile(
			testFile.getCanonicalPath());
		assertTrue("find result", node != null) ;	
		ProgramElementNode pNode = (ProgramElementNode)node;
		String child = ((StructureNode)pNode.getChildren().get(0)).getName();
        assertTrue("expected Figure got child " + child, child.equals("Figure"));
	}
================= fetch public void valueForPathChanged(TreePath path, Object newValue) { f1deb9c^:ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java

public void valueForPathChanged(TreePath path, Object newValue) {
            DefaultMutableTreeNode node = (DefaultMutableTreeNode)path.getLastPathComponent();
            nodeChanged(node);
        }
================= fetch void doIt() { f1deb9c^:ajde/testdata/examples/coverage/ModelCoverage.java

void doIt() { 
		try {
			File f = new File(".");
			f.getCanonicalPath();
		} catch (IOException ioe) {
			System.err.println("!");	
		}	
		setX(10);
		new Point();
	}
================= fetch private LazyMethodGen makeMethodGen(LazyClassGen gen, ResolvedMember member) { 3e59745^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java

private LazyMethodGen makeMethodGen(LazyClassGen gen, ResolvedMember member) {
		return new LazyMethodGen(
			member.getModifiers(),
			BcelWorld.makeBcelType(member.getReturnType()),
			member.getName(),
			BcelWorld.makeBcelTypes(member.getParameterTypes()),
			TypeX.getNames(member.getExceptions()),
			gen);
	}
================= fetch private void doDeclareParents(DeclareParents declareParents, SourceTypeBinding s 3e59745^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java

private void doDeclareParents(DeclareParents declareParents, SourceTypeBinding sourceType) {
		List newParents = declareParents.findMatchingNewParents(factory.fromEclipse(sourceType));
		if (!newParents.isEmpty()) {
			for (Iterator i = newParents.iterator(); i.hasNext(); ) {
				ResolvedTypeX parent = (ResolvedTypeX)i.next();
				addParent(sourceType, parent);
			}
		}
	}
================= fetch private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, Collection 3e59745^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java

private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, Collection typeMungers, Collection declareParents, boolean skipInners) {
		ResolvedTypeX onType = factory.fromEclipse(sourceType);
		WeaverStateInfo info = onType.getWeaverState();

		if (info != null && !info.isOldStyle()) {		
			Collection mungers = 
				onType.getWeaverState().getTypeMungers(onType);
				
			//System.out.println("mungers: " + mungers);
			for (Iterator i = mungers.iterator(); i.hasNext(); ) {
				ConcreteTypeMunger m = (ConcreteTypeMunger)i.next();
				EclipseTypeMunger munger = factory.makeEclipseTypeMunger(m);
				if (munger.munge(sourceType)) {
					if (onType.isInterface() &&
						munger.getMunger().needsAccessToTopmostImplementor())
					{
						if (!onType.getWorld().getCrosscuttingMembersSet().containsAspect(munger.getAspectType())) {
							dangerousInterfaces.put(onType, 
								"implementors of " + onType + " must be woven by " +
								munger.getAspectType());
						}
					}
				}
				
			}
			
			return;
		}
		
		//System.out.println("dangerousInterfaces: " + dangerousInterfaces);
		
		for (Iterator i = dangerousInterfaces.entrySet().iterator(); i.hasNext();) {
			Map.Entry entry = (Map.Entry) i.next();
			ResolvedTypeX interfaceType = (ResolvedTypeX)entry.getKey();
			if (onType.isTopmostImplementor(interfaceType)) {
				factory.showMessage(IMessage.ERROR, 
					onType + ": " + entry.getValue(),
					onType.getSourceLocation(), null);
			}
		}
		
		boolean needOldStyleWarning = (info != null && info.isOldStyle());
		
		onType.clearInterTypeMungers();
		
		for (Iterator i = declareParents.iterator(); i.hasNext();) {
			doDeclareParents((DeclareParents)i.next(), sourceType);
		}
		
		for (Iterator i = typeMungers.iterator(); i.hasNext();) {
			EclipseTypeMunger munger = (EclipseTypeMunger) i.next();
			if (munger.matches(onType)) {
				if (needOldStyleWarning) {
					factory.showMessage(IMessage.WARNING, 
						"The class for " + onType + " should be recompiled with ajc-1.1.1 for best results",
						onType.getSourceLocation(), null);
					needOldStyleWarning = false;
				}
				onType.addInterTypeMunger(munger);
			}
		}
		
		for (Iterator i = onType.getInterTypeMungers().iterator(); i.hasNext();) {
			EclipseTypeMunger munger = (EclipseTypeMunger) i.next();
			//System.out.println("applying: " + munger + " to " + new String(sourceType.sourceName));
			munger.munge(sourceType);
		}
		
		if (skipInners) return;

		ReferenceBinding[] memberTypes = sourceType.memberTypes;
		for (int i = 0, length = memberTypes.length; i < length; i++) {
			if (memberTypes[i] instanceof SourceTypeBinding) {
				weaveInterTypeDeclarations((SourceTypeBinding) memberTypes[i], typeMungers, declareParents, false);
			}
		}
	}
================= fetch public MethodGen pack() { 3e59745^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
// ---- packing!
public MethodGen pack() {
    	//killNops();
        MethodGen gen =
            new MethodGen(
                getAccessFlags(),
                getReturnType(),
                getArgumentTypes(),
                null, //getArgumentNames(),
                getName(),
                getEnclosingClass().getName(),
                new InstructionList(),
                getEnclosingClass().getConstantPoolGen());
        for (int i = 0, len = declaredExceptions.length; i < len; i++) {
            gen.addException(declaredExceptions[i]);
        }
        for (int i = 0, len = attributes.length; i < len; i++) {
            gen.addAttribute(attributes[i]);
        }
        if (hasBody()) {
            packBody(gen);
            gen.setMaxLocals();
            gen.setMaxStack();
        } else {
        	gen.setInstructionList(null);
        }
        return gen;
    }
================= fetch public Message(String message, ISourceLocation location, boolean isError) { 684c9c1^:bridge/src/org/aspectj/bridge/Message.java

public static Message fail(String message, Throwable thrown) {
        return new Message(message, IMessage.FAIL, thrown, null);
    }
================= fetch public String toString() { 684c9c1^:bridge/src/org/aspectj/bridge/IMessage.java

public String toString() {
			return name;
		}
================= fetch public String toString() { 684c9c1^:testing/src/org/aspectj/testing/xml/SoftMessage.java

public String toString() {
        StringBuffer result = new StringBuffer();
        
        result.append(getKind().toString());
        
        String messageString = getMessage();
        if (!LangUtil.isEmpty(messageString)) {
            result.append(messageString);
        }

        ISourceLocation loc = getSourceLocation();
        if ((null != loc) && (loc != ISourceLocation.NO_FILE)) {
            result.append(" at " + loc);
        }
        if (null != thrown) {
            result.append(" -- " + LangUtil.renderExceptionShort(thrown));
        }
        return result.toString();
    }
================= fetch public boolean match(Shadow shadow, World world) { 684c9c1^:weaver/src/org/aspectj/weaver/Checker.java

public boolean match(Shadow shadow, World world) {
		if (super.match(shadow, world)) {
			world.getMessageHandler().handleMessage(
				new Message(msg,
							isError ? IMessage.ERROR : IMessage.WARNING,
							null,
							shadow.getSourceLocation()));
		}
		return false;
	}
================= fetch public static String render(Throwable thrown) { // XXX cf LangUtil.debugStr 684c9c1^:bridge/src/org/aspectj/bridge/Message.java

public static String render(Throwable thrown) { // XXX cf LangUtil.debugStr
        if (null == thrown) return "null throwable";
        Throwable t = null;
        if (thrown instanceof InvocationTargetException) {
            t = ((InvocationTargetException)thrown).getTargetException();
        } else if (thrown instanceof ClassNotFoundException) {
            t = ((ClassNotFoundException) thrown).getException();
        }
        if (null != t) {
            return render(t);
        }
        StringWriter buf = new StringWriter();
        PrintWriter writer = new PrintWriter(buf);
        writer.println(" Message rendering thrown=" + thrown.getClass().getName());
        writer.println(thrown.getMessage());
        thrown.printStackTrace(writer);
        try { buf.close(); } 
        catch (IOException ioe) {} 
        return buf.getBuffer().toString();        
    }
================= fetch public Component getListCellRendererComponent( acdf688^:ajde/src/org/aspectj/ajde/ui/swing/CompilerMessagesCellRenderer.java

public Component getListCellRendererComponent(
		JList list,
		Object value,
		int index,
		boolean isSelected,
		boolean cellHasFocus) {
            String label = "<no message>";
            String detail = null;
            IMessage.Kind kind = IMessage.ERROR;
            if (value instanceof IMessage) {
				IMessage cm = (IMessage) value;
                label = cm.getMessage();
                if (LangUtil.isEmpty(label)) {
                    label = cm.getMessage().toString();
                }
                kind = cm.getKind();
                Throwable thrown = cm.getThrown();
                if (null != thrown) {
                    detail = LangUtil.renderException(thrown);
                }
            } else if (null != value) {
                label = value.toString();
            }
			setText(label);
			if (kind.equals(IMessage.WARNING)) {
				setIcon(AjdeUIManager.getDefault().getIconRegistry().getWarningIcon());
			} else if (IMessage.ERROR.isSameOrLessThan(kind)) {
                setIcon(AjdeUIManager.getDefault().getIconRegistry().getErrorIcon());
			} else {
                setIcon(null);
			}
			if (isSelected) {
				setBackground(list.getSelectionBackground());
				setForeground(list.getSelectionForeground());
			} else {
				setBackground(list.getBackground());
				setForeground(list.getForeground());
			}
			setEnabled(list.isEnabled());
			setFont(list.getFont());
			setOpaque(true);
            if (null != detail) {
                setToolTipText(detail);
            }
			return this;
	}
================= fetch public static Test suite() { acdf688^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/AjdtAjcTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(AjdtAjcTests.class.getName());
        //$JUnit-BEGIN$
        suite.addTestSuite(AjdtCommandTestCase.class); 
        suite.addTestSuite(BuildArgParserTestCase.class); 
        suite.addTestSuite(ConsoleMessageHandlerTestCase.class); 
        //$JUnit-END$
        return suite;
    }
================= fetch public void testArgInConfigFile() throws InvalidInputException { acdf688^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java

public void testArgInConfigFile() throws InvalidInputException {
		String FILE_PATH =   "@" + TEST_DIR + "configWithArgs.lst";
		String OUT_PATH = "bin";
		AjBuildConfig config = parser.genBuildConfig(new String[] { FILE_PATH }, messageWriter);
		
        assertNotNull(config);
        File outputDir = config.getOutputDir();
        assertNotNull(outputDir);        
		assertEquals(outputDir.getPath(), OUT_PATH);
	}
Progress : [########################################] 102%================= fetch private void addClasspath(String classpath, List classpathCollector) { a26cac9^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java

void addClasspath(String classpath, List classpathCollector) {
		StringTokenizer tokenizer = new StringTokenizer(classpath, File.pathSeparator);
		while (tokenizer.hasMoreTokens()) {
			classpathCollector.add(tokenizer.nextToken());
		}		
	}
================= fetch protected void showWarning(String message) { a26cac9^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java

protected void showWarning(String message) {
            MessageUtil.warn(handler, message);
        }
================= fetch public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler) { a26cac9^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java
/**
	 * Generate build configuration for the input args,
	 * passing to handler any error messages.
	 * @param args the String[] arguments for the build configuration
	 * @param handler the IMessageHandler handler for any errors
	 * @return AjBuildConfig per args, 
	 *         which will be invalid unless there are no handler errors.
	 */
public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler) {
		return genBuildConfig(args, handler, true);
	}
================= fetch public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler, bool a26cac9^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java
/**
     * Generate build configuration for the input args,
     * passing to handler any error messages.
     * @param args the String[] arguments for the build configuration
     * @param handler the IMessageHandler handler for any errors
     * @param setClasspath	determines if the classpath should be parsed and set on the build configuration
     * @return AjBuildConfig per args, 
     *         which will be invalid unless there are no handler errors.
     */
public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler, boolean setClasspath) {
		AjBuildConfig buildConfig = new AjBuildConfig();
		try {
			// sets filenames to be non-null in order to make sure that file paramters are ignored
			super.filenames = new String[] { "" }; 
			
			List fileList = new ArrayList();
			
			AjcConfigParser parser = new AjcConfigParser(buildConfig, handler);
			parser.parseCommandLine(args);
            
            boolean incrementalMode = buildConfig.isIncrementalMode()
                        || buildConfig.isIncrementalFileMode();
			
            List files = parser.getFiles();
            if (!LangUtil.isEmpty(files)) {
                if (incrementalMode) {
                    MessageUtil.error(handler, "incremental mode only handles source files using -sourceroots"); 
                } else {
                    fileList.addAll(files);
                }
            }
				
			List javaArgList = new ArrayList();
			
			//	disable all special eclipse warnings by default
			//??? might want to instead override getDefaultOptions()
			javaArgList.add("-warn:none");
			
			// these next four lines are some nonsense to fool the eclipse batch compiler
			// without these it will go searching for reasonable values from properties
			//TODO fix org.eclipse.jdt.internal.compiler.batch.Main so this hack isn't needed
			javaArgList.add("-classpath");
			javaArgList.add(System.getProperty("user.dir"));
			javaArgList.add("-bootclasspath");
			javaArgList.add(System.getProperty("user.dir"));
			
			javaArgList.addAll(parser.getUnparsedArgs());

//			if (javaArgList.size() != 0) {
				super.configure((String[])javaArgList.toArray(new String[javaArgList.size()]));
//			}
			
			if (buildConfig.getSourceRoots() != null) {
				for (Iterator i = buildConfig.getSourceRoots().iterator(); i.hasNext(); ) {
					fileList.addAll(collectSourceRootFiles((File)i.next()));
				}
			}
			
			buildConfig.setFiles(fileList);
			if (destinationPath != null) { // XXX ?? unparsed but set?
				buildConfig.setOutputDir(new File(destinationPath));
			}
			
			if (setClasspath) {
				buildConfig.setClasspath(getClasspath(parser));
			}
			
			if (incrementalMode 
                && (0 == buildConfig.getSourceRoots().size())) {
                    MessageUtil.error(handler, "specify a source root when in incremental mode");
			}
			
			setDebugOptions();
			buildConfig.setJavaOptions(options);
		} catch (InvalidInputException iie) {
            MessageUtil.error(handler, iie.getMessage());
		}
		return buildConfig;
	}
================= fetch public static AjBuildConfig genBuildConfig(String[] args, CountingMessageHandler a26cac9^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java
/** @return IMessage.WARNING unless message contains error or info */
protected static IMessage.Kind inferKind(String message) { // XXX dubious
        if (-1 != message.indexOf("error")) {
            return IMessage.ERROR;
        } else if (-1 != message.indexOf("info")) {
            return IMessage.INFO;
        } else {
            return IMessage.WARNING;
        }
    }
================= fetch public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r a26cac9^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java
/**
         * Extract AspectJ-specific options (except for argfiles).
         * Caller should warn when sourceroots is empty but in 
         * incremental mode.
         * Signals warnings or errors through handler set in constructor.
         */
public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.remove()
			int nextArgIndex = args.indexOf(arg)+1; // XXX assumes unique
            // trim arg?
            if (LangUtil.isEmpty(arg)) {
                showWarning("empty arg found");
            } else if (arg.equals("-injars")) {;
				if (args.size() > nextArgIndex) {
					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_InJARs, CompilerOptions.PRESERVE);
					
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
		            	if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
			            	buildConfig.getInJars().add(jarFile);    
		            	} else {
                            showError("bad injar: " + filename);
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-aspectpath")) {;
				if (args.size() > nextArgIndex) {
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
                        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
			            	buildConfig.getAspectpath().add(jarFile);    
		            	} else {
                            showError("bad aspectpath: " + filename);
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-sourceroots")) {
				if (args.size() > nextArgIndex) {
					List sourceRoots = new ArrayList();
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	File f = makeFile(st.nextToken());
		            	if (f.isDirectory() && f.canRead()) {
			                sourceRoots.add(f);
		            	} else {
                            showError("bad sourceroot: " + f);
		            	}		            		
		            }
				    if (0 < sourceRoots.size()) {
						buildConfig.setSourceRoots(sourceRoots);	
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-sourceroots requires list of directories");
				}
			} else if (arg.equals("-outjar")) { 
				if (args.size() > nextArgIndex) {
					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_OutJAR, CompilerOptions.GENERATE);
					File jarFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
					if (FileUtil.hasZipSuffix(jarFile)) {
						try {
							if (!jarFile.exists()) {
                                jarFile.createNewFile();
                            }
                            buildConfig.setOutputJar(jarFile);  
						} catch (IOException ioe) { 
                            showError("unable to create outjar file: " + jarFile);
						}
					} else {
						showError("invalid -outjar file: " + jarFile);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-outjar requires jar path argument");
				}
            } else if (arg.equals("-incremental")) {
                buildConfig.setIncrementalMode(true);
            } else if (arg.equals("-XincrementalFile")) {
                if (args.size() > nextArgIndex) {
                    File file = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    buildConfig.setIncrementalFile(file);
                    if (!file.canRead()) {
                        showError("bad -XincrementalFile : " + file);
                        // if not created before recompile test, stop after first compile
                    }
                    args.remove(args.get(nextArgIndex));
                } else {
                    showError("-XincrementalFile requires file argument");
                }
			} else if (arg.equals("-emacssym")) {
				buildConfig.setEmacsSymMode(true);
				buildConfig.setGenerateModelMode(true);
			} else if (arg.equals("-noweave") || arg.equals( "-XnoWeave")) {
				buildConfig.setNoWeave(true);
			} else if (arg.equals("-XserializableAspects")) {
				buildConfig.setXserializableAspects(true);
			} else if (arg.equals("-XnoInline")) {
				buildConfig.setXnoInline(true);
			} else if (arg.equals("-Xlintfile")) { 
				if (args.size() > nextArgIndex) {
					File lintSpecFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
                    // XXX relax restriction on props file suffix?
					if (lintSpecFile.canRead() && lintSpecFile.getName().endsWith(".properties")) {
						buildConfig.setLintSpecFile(lintSpecFile);	
					} else {
						showError("bad -Xlintfile file: " + lintSpecFile);
						buildConfig.setLintSpecFile(null);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					showError("-Xlintfile requires .properties file argument");
				}
            } else if (arg.equals("-Xlint")) {
                buildConfig.getAjOptions().put(
                    AjCompilerOptions.OPTION_Xlint,
                    CompilerOptions.GENERATE);
                buildConfig.setLintMode(AjBuildConfig.AJLINT_DEFAULT);
            } else if (arg.startsWith("-Xlint:")) {
                if (7 < arg.length()) {
                    buildConfig.setLintMode(arg.substring(7));
                } else {
                    showError("invalid lint option " + arg);
                }
			} else if (arg.equals("-bootclasspath")) {
				if (args.size() > nextArgIndex) {
					bootclasspath = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-bootclasspath requires classpath entries");
				}
			} else if (arg.equals("-classpath")) {
				if (args.size() > nextArgIndex) {
					classpath = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					args.remove(args.get(nextArgIndex));	
				} else {
					showError("-classpath requires classpath entries");
				}
			} else if (arg.equals("-extdirs")) {
				if (args.size() > nextArgIndex) {
					extdirs = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					args.remove(args.get(nextArgIndex));
                } else {
                    showError("-extdirs requires list of external directories");
                }
            // error on directory unless -d, -{boot}classpath, or -extdirs
            } else if (arg.equals("-d")) {
                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-classpath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-bootclasspath")) {
//                dirLookahead(arg, args, nextArgIndex);
//            } else if (arg.equals("-extdirs")) {
//                dirLookahead(arg, args, nextArgIndex);
            } else if (new File(arg).isDirectory()) {
                showError("dir arg not permitted: " + arg);
			} else {
                // argfile, @file parsed by superclass
                // no eclipse options parsed:
                // -d args, -help (handled), 
                // -classpath, -target, -1.3, -1.4, -source [1.3|1.4]
                // -nowarn, -warn:[...], -deprecation, -noImportError,
                // -proceedOnError, -g:[...], -preserveAllLocals,
                // -referenceInfo, -encoding, -verbose, -log, -time
                // -noExit, -repeat
		    	unparsedArgs.add(arg);
			}
        }
================= fetch public void showError(String message) { a26cac9^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java

public void showError(String message) {
            MessageUtil.error(handler, CONFIG_MSG + message);
        }
================= fetch private StructureNode findEnclosingClass(Stack stack) { f5d31ba^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java

private StructureNode findEnclosingClass(Stack stack) {
		for (int i = stack.size()-1; i >= 0; i--) {
			ProgramElementNode pe = (ProgramElementNode)stack.get(i);
			if (pe.getProgramElementKind() == ProgramElementNode.Kind.CLASS) {
				return pe;
			}
			
		}
		return (StructureNode)stack.peek();
	}
================= fetch public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) { f5d31ba^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java
// !!! improve name and type generation
public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {
		ProgramElementNode.Kind kind = ProgramElementNode.Kind.METHOD;
		String label = new String(methodDeclaration.selector);
		
		if (methodDeclaration instanceof AdviceDeclaration) { 
			kind = ProgramElementNode.Kind.ADVICE;
			label = translateAdviceName(label);
		} else if (methodDeclaration instanceof PointcutDeclaration) { 
			kind = ProgramElementNode.Kind.POINTCUT;
			label = translatePointcutName(label);
		} else if (methodDeclaration instanceof DeclareDeclaration) { 
			DeclareDeclaration declare = (DeclareDeclaration)methodDeclaration;
			label = translateDeclareName(declare.toString());
			
			// TODO: fix this horrible way of checking what kind of declare it is
			if (label.indexOf("warning") != -1) {
				kind = ProgramElementNode.Kind.DECLARE_WARNING;
			} else if (label.indexOf("error") != -1) {
				kind = ProgramElementNode.Kind.DECLARE_ERROR;
			} else if (label.indexOf("parents") != -1) {
				kind = ProgramElementNode.Kind.DECLARE_PARENTS;
			} else if (label.indexOf("soft") != -1) {
				kind = ProgramElementNode.Kind.DECLARE_SOFT;
		    } else {
				kind = ProgramElementNode.Kind.ERROR;	
			}
		} else if (methodDeclaration instanceof InterTypeDeclaration) {
			kind = ProgramElementNode.Kind.INTRODUCTION;
			label = translateInterTypeDecName(new String(((InterTypeDeclaration)methodDeclaration).selector));
		}
		
		ProgramElementNode peNode = new ProgramElementNode(
			label,
			kind,
			makeLocation(methodDeclaration),
			methodDeclaration.modifiers,
			"",
			new ArrayList());

		if (kind == ProgramElementNode.Kind.METHOD) {
			// !! should probably discriminate more
			if (label.equals("main")) {
				((ProgramElementNode)stack.peek()).setRunnable(true);
			}	
		}

		if (methodDeclaration.binding != null) {
			Member member = EclipseFactory.makeResolvedMember(methodDeclaration.binding);
			peNode.setBytecodeName(member.getName());
			peNode.setBytecodeSignature(member.getSignature());
		}
		((StructureNode)stack.peek()).addChild(peNode);
		stack.push(peNode);
		
		return true;
	}
================= fetch public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope scope f5d31ba^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java

public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope scope) {
		String name = new String(typeDeclaration.name);
		//System.err.println("type with name: " + name);
		ProgramElementNode.Kind kind = ProgramElementNode.Kind.CLASS;
		if (typeDeclaration instanceof AspectDeclaration) kind = ProgramElementNode.Kind.ASPECT;
		else if (typeDeclaration.isInterface()) kind = ProgramElementNode.Kind.INTERFACE;

		ProgramElementNode peNode = new ProgramElementNode(
			name,
			kind,
			makeLocation(typeDeclaration),
			typeDeclaration.modifiers,
			"",
			new ArrayList());
		
		((StructureNode)stack.peek()).addChild(peNode);
		stack.push(peNode);
		return true;
	}
================= fetch private ISourceLocation makeLocation(AstNode node) { 7886970^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java
// ??? handle non-existant files
private ISourceLocation makeLocation(AstNode node) {
		String fileName = new String(currCompilationResult.getFileName());
		// AMC - different strategies based on node kind
		int startLine = getStartLine(node);
		int endLine = getEndLine(node);
		ISourceLocation loc = null;
		if ( startLine <= endLine ) {
			// found a valid end line for this node...
			loc = new SourceLocation(new File(fileName), startLine, endLine);			
		} else {
			loc = new SourceLocation(new File(fileName), startLine);
		}
		return loc;
	}
================= fetch public boolean visit(LocalTypeDeclaration memberTypeDeclaration, BlockScope scop 7886970^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java

public boolean visit(LocalTypeDeclaration memberTypeDeclaration, BlockScope scope) {
		String name = new String(memberTypeDeclaration.name);
		String fullName = new String(memberTypeDeclaration.binding.constantPoolName());
		int dollar = fullName.indexOf('$');
		fullName = fullName.substring(dollar+1);
//		
//		System.err.println("member type with name: " + name + ", " + 
//				new String(fullName));
		
		ProgramElementNode.Kind kind = ProgramElementNode.Kind.CLASS;
		if (memberTypeDeclaration.isInterface()) kind = ProgramElementNode.Kind.INTERFACE;

		ProgramElementNode peNode = new ProgramElementNode(
			fullName,
			kind,
			makeLocation(memberTypeDeclaration),
			memberTypeDeclaration.modifiers,
			"",
			new ArrayList());
		
		//??? we add this to the compilation unit
		findEnclosingClass(stack).addChild(peNode);
		stack.push(peNode);
		return true;
	}
================= fetch public static Test suite() { 7886970^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjdtBuilderTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(AjdtBuilderTests.class.getName());
        //$JUnit-BEGIN$
        suite.addTestSuite(AjBuildManagerTest.class); 
        //$JUnit-END$
        return suite;
    }
================= fetch public static void build( 7886970^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java

public static void build(
        CompilationUnitDeclaration unit,
        StructureModel structureModel) {
        LangUtil.throwIaxIfNull(unit, "unit");
          
        new AsmBuilder(unit.compilationResult()).internalBuild(unit, structureModel);
    }
================= fetch public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) { 58e3cb2^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java
// !!! improve name and type generation
public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {
		ProgramElementNode.Kind kind = ProgramElementNode.Kind.METHOD;
		String label = new String(methodDeclaration.selector);
		
		if (methodDeclaration instanceof AdviceDeclaration) { 
			kind = ProgramElementNode.Kind.ADVICE;
			label = translateAdviceName(label);
		} else if (methodDeclaration instanceof PointcutDeclaration) { 
			kind = ProgramElementNode.Kind.POINTCUT;
			label = translatePointcutName(label);
		} else if (methodDeclaration instanceof DeclareDeclaration) { 
			DeclareDeclaration declare = (DeclareDeclaration)methodDeclaration;
			label = translateDeclareName(declare.toString());
			if (label.indexOf("warning") != -1) kind = ProgramElementNode.Kind.DECLARE_WARNING;
			if (label.indexOf("error") != -1) kind = ProgramElementNode.Kind.DECLARE_ERROR;
		} else if (methodDeclaration instanceof InterTypeDeclaration) {
			kind = ProgramElementNode.Kind.INTRODUCTION;
			label = translateInterTypeDecName(new String(((InterTypeDeclaration)methodDeclaration).selector));
		} 
		
		ProgramElementNode peNode = new ProgramElementNode(
			label,
			kind,
			makeLocation(methodDeclaration),
			methodDeclaration.modifiers,
			"",
			new ArrayList());

		if (kind == ProgramElementNode.Kind.METHOD) {
			// !! should probably discriminate more
			if (label.equals("main")) {
				((ProgramElementNode)stack.peek()).setRunnable(true);
			}	
		}

		if (methodDeclaration.binding != null) {
			Member member = EclipseFactory.makeResolvedMember(methodDeclaration.binding);
			peNode.setBytecodeName(member.getName());
			peNode.setBytecodeSignature(member.getSignature());
		}
		((StructureNode)stack.peek()).addChild(peNode);
		stack.push(peNode);
		
		return true;
	}
================= fetch private static File isAspectjtoolsjar(String path) { 2502ee5^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
/** @return File if readable jar with aspectj tools name, or null */
private static File isAspectjtoolsjar(String path) {
        if (null == path) {
            return null;
        }
        final String prefix = "aspectj";        
        final String infix = "tools";        
        final String altInfix = "-tools";        
        final String suffix = ".jar";
        final int prefixLength = 7; // prefix.length();
        final int minLength = 16;
        // prefixLength + infix.length() + suffix.length();        
        if (!path.endsWith(suffix)) {
            return null;
        }
        int loc = path.lastIndexOf(prefix);
        if ((-1 != loc) && ((loc + minLength) <= path.length())) {
            String rest = path.substring(loc+prefixLength);
            if (-1 != rest.indexOf(File.pathSeparator)) {
                return null;
            }
            if (rest.startsWith(infix)
                || rest.startsWith(altInfix)) {
                File result = new File(path);
                if (result.canRead() && result.isFile()) {
                    return result;
                }
            }
        }        
        return null;
    }
================= fetch private void check(IMessageHolder holder, int num, IMessage.Kind kind) { 2502ee5^:taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java

private void check(IMessageHolder holder, int num, IMessage.Kind kind) {
            if (num != IGNORE) {
            	int actual = holder.numMessages(kind, false);
            	if (num != actual) {
            		if (actual > 0) {
	            		MessageUtil.print(System.err, holder, kind + " expected " + num + " got " + actual);
            		}
	                assertEquals(kind.toString(), num, actual);
            	}
            }
        }
================= fetch private void completeDestdir() { 2502ee5^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
/** 
     * Complete the destination directory
     * by copying resources from the source root directories
     * (if the filter is specified)
     * and non-.class files from the input jars 
     * (if XCopyInjars is enabled).
     */
private void completeDestdir() {
        if (!copyInjars && (null == sourceRootCopyFilter)) {
            return;
        } else if (!destDir.canWrite()) {
            String s = "unable to copy resources to destDir: " + destDir;
            throw new BuildException(s);
        }
        final Project project = getProject();
        if (copyInjars) {
            String taskName = getTaskName() + " - unzip";
            String[] paths = injars.list();
            if (!LangUtil.isEmpty(paths)) {
                PatternSet patternSet = new PatternSet();
                patternSet.setProject(project);        
                patternSet.setIncludes("**/*");
                patternSet.setExcludes("**/*.class");  
                for (int i = 0; i < paths.length; i++) {
                    Expand unzip = new Expand();
                    unzip.setProject(project);
                    unzip.setTaskName(taskName);
                    unzip.setDest(destDir);
                    unzip.setSrc(new File(paths[i]));
                    unzip.addPatternset(patternSet);
                    unzip.execute();
                }
            }
        }
        if ((null != sourceRootCopyFilter) && (null != sourceRoots)) {
            String[] paths = sourceRoots.list();
            if (!LangUtil.isEmpty(paths)) {
                Copy copy = new Copy();
                copy.setProject(project);
                copy.setTodir(destDir);
                for (int i = 0; i < paths.length; i++) {
                    FileSet fileSet = new FileSet();
                    fileSet.setDir(new File(paths[i]));
                    fileSet.setIncludes("**/*");
                    fileSet.setExcludes(sourceRootCopyFilter);  
                    copy.addFileset(fileSet);
                }
                copy.execute();
            }
        }        
    }
================= fetch protected AjcTask getTask(String input) { 2502ee5^:taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java

protected AjcTask getTask(String input) {
        AjcTask task = new AjcTask();
        Project p = new Project();
        task.setProject(p);
        task.setDestdir(getTempDir());
        if (NOFILE.equals(input)) {
        	// add nothing
        } else if (input.endsWith(".lst")) {
        	if (-1 != input.indexOf(",")) {
                throw new IllegalArgumentException("lists not supported: " + input);
        	} else if (null == testdataDir) {
                throw new Error("testdata not found - run in ../taskdefs");
            } else {
                String path = testdataDir + File.separator + input;
        		task.setArgfiles(new Path(task.getProject(), path));
        	}
        } else if ((input.endsWith(".java") || input.endsWith(".aj"))) {
        	// not working
        	FilenameSelector fns = new FilenameSelector();
        	fns.setName(input);
        	task.addFilename(fns);
        } else {
        	File dir = new File(input);
        	if (dir.canRead() && dir.isDirectory()) {
        		task.setSourceRoots(new Path(task.getProject(), input));
        	}        
        }
        task.setClasspath(new Path(p, "../lib/test/aspectjrt.jar"));
        task.setVerbose(true); // XXX    
        return task;
    }
================= fetch protected void verifyOptions() { 2502ee5^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
/**
     * @throw BuildException if options conflict
     */
protected void verifyOptions() {
        if (fork && isInIncrementalMode() && !isInIncrementalFileMode()) {
            String m = "can fork incremental only using tag file";
            throw new BuildException(m);
        }

    }
================= fetch public boolean quit() { 2502ee5^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
// package-private for testing
String[] makeCommand() {
        ArrayList result = new ArrayList();
        if (0 < ignored.size()) {
            for (Iterator iter = ignored.iterator(); iter.hasNext();) {
                log("ignored: " + iter.next(), Project.MSG_INFO);                   
            }
        }
        // when copying resources, use temp jar for class output
        // then copy temp jar contents and resources to output jar
        if ((null != outjar) && !outjarFixedup) {
            if (copyInjars || (null != sourceRootCopyFilter)) {
                String path = outjar.getAbsolutePath();
                int len = FileUtil.zipSuffixLength(path);
                if (len < 1) {
                    log("not copying injars - weird outjar: " + path);
                } else {
                    path = path.substring(0, path.length()-len) + ".tmp.jar";
                    tmpOutjar = new File(path);
                }
            }
            if (null == tmpOutjar) {                
                cmd.addFlagged("-outjar", outjar.getAbsolutePath());        
            } else {
                cmd.addFlagged("-outjar", tmpOutjar.getAbsolutePath());        
            }
            outjarFixedup = true;
        }

        result.addAll(cmd.extractArguments());        
        addListArgs(result);
        return (String[]) result.toArray(new String[0]);
    }
================= fetch public static String setupAjc(AjcTask ajc, Javac javac, File destDir) { 2502ee5^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java

public static String setupAjc(AjcTask ajc, Javac javac, File destDir) {        
        if (null == ajc) {
            return "null ajc";
        } else if (null == javac) {
            return "null javac";
        } else if (null == destDir) {
            destDir = javac.getDestdir();
            if (null == destDir) {
                destDir = new File(".");
            }
        }
        // no null checks b/c AjcTask handles null input gracefully
        ajc.setProject(javac.getProject());
        ajc.setLocation(javac.getLocation());
        ajc.setTaskName("javac-iajc");
        
        ajc.setDebug(javac.getDebug());
        ajc.setDeprecation(javac.getDeprecation());
        ajc.setFailonerror(javac.getFailonerror());
        final boolean fork = javac.isForkedJavac();
        ajc.setFork(fork);        
        if (fork) {
            ajc.setMaxmem(javac.getMemoryMaximumSize());
        }
        ajc.setNowarn(javac.getNowarn()); 
        ajc.setListFileArgs(javac.getListfiles());
        ajc.setVerbose(javac.getVerbose());               
        ajc.setTarget(javac.getTarget());        
        ajc.setSource(javac.getSource());        
        ajc.setEncoding(javac.getEncoding());        
        ajc.setDestdir(destDir);        
        ajc.setBootclasspath(javac.getBootclasspath());
        ajc.setExtdirs(javac.getExtdirs());
        ajc.setClasspath(javac.getClasspath());        
        // ignore srcDir -- all files picked up in recalculated file list
//      ajc.setSrcDir(javac.getSrcdir());        
        ajc.addFiles(javac.getFileList());
        // mimic javac's behavior in copying resources,
        ajc.setSourceRootCopyFilter("**/CVS/*,**/*.java,**/*.aj");
        // arguments can override the filter, add to paths, override options
        ajc.readArguments(javac.getCurrentCompilerArgs());
        
        return null;
    }
================= fetch public void setMessageHolderClass(String className) { 2502ee5^:taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java
/** 
     * Setup custom message handling.
     * @param className the String fully-qualified-name of a class
     *          reachable from this object's class loader,
     *          implementing IMessageHolder, and 
     *          having a public no-argument constructor.
     * @throws BuildException if unable to create instance of className
     */
public void setMessageHolderClass(String className) {
        try {
            Class mclass = Class.forName(className);
            IMessageHolder holder = (IMessageHolder) mclass.newInstance();
            setMessageHolder(holder);
        } catch (Throwable t) {
            String m = "unable to instantiate message holder: " + className;
            throw new BuildException(m, t);
        }
    }
================= fetch public void tearDown() { 2502ee5^:taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java

public void tearDown() {
        deleteTempDir();
        MESSAGES.setLength(0);
    }
Progress : [#########################################-] 103%================= fetch private void navigationAction(ProgramElementNode node, boolean recordHistory) { bbd832b^:ajde/src/org/aspectj/ajde/ui/StructureViewManager.java
/**
	 * Highlights the given node in all structure views.  If the node represents code
	 * and as such is below the granularity visible in the view the parent is highlighted,
	 * along with the corresponding sourceline.
	 */
private void navigationAction(ProgramElementNode node, boolean recordHistory) { 
		if (node == null 
			|| node == StructureModel.NO_STRUCTURE) {
			Ajde.getDefault().getIdeUIAdapter().displayStatusInformation("Source not available for node: " + node.getName());
			return;    	
		}
		Ajde.getDefault().logEvent("navigating to node: " + node + ", recordHistory: " + recordHistory);
		if (recordHistory) historyModel.navigateToNode(node); 
    	if (defaultFileView != null && node.getSourceLocation() != null) {
    		String newFilePath = node.getSourceLocation().getSourceFile().getAbsolutePath();
			if (defaultFileView.getSourceFile() != null
				&& !defaultFileView.getSourceFile().equals(newFilePath)) {
				defaultFileView.setSourceFile(newFilePath);
				treeViewBuilder.buildView(defaultFileView, StructureModelManager.INSTANCE.getStructureModel());
			}
		}
		   
	    for (Iterator it = structureViews.iterator(); it.hasNext(); ) {
    		StructureView view = (StructureView)it.next();
    		if (!(view instanceof GlobalStructureView) || !recordHistory || defaultFileView == null) {
	    		if (node.getProgramElementKind().equals(ProgramElementNode.Kind.CODE)) {
	    			ProgramElementNode parentNode = (ProgramElementNode)node.getParent();
	    			if (parentNode != null) {
		    			StructureViewNode currNode = view.findCorrespondingViewNode(parentNode);
		    			int lineOffset = node.getSourceLocation().getLine() - parentNode.getSourceLocation().getLine();
		    			if (currNode != null) view.setActiveNode(currNode, lineOffset);
	    			}
	    		} else {
	    			StructureViewNode currNode = view.findCorrespondingViewNode(node);
	    			if (currNode != null) view.setActiveNode(currNode);	
	    		}	
    		}
    	}
	}
================= fetch private void ok_button_actionPerformed(ActionEvent e) { bbd832b^:ajde/src/org/aspectj/ajde/ui/swing/PointcutWizard.java

void ok_button_actionPerformed(ActionEvent e) {
        Ajde.getDefault().getEditorManager().pasteToCaretPos(generatePcd());
        this.dispose();
    }
================= fetch protected void displayMessage(IMessage message) { bbd832b^:ajbrowser/src/org/aspectj/tools/ajbrowser/CompilerMessagesPanel.java
/**
     * called when user double-clicks on a message.
     */
protected void displayMessage(IMessage message) {
        ISourceLocation loc = message.getISourceLocation();
        Ajde.getDefault().getEditorManager().showSourceLine(loc, true);
        // show dialog with stack trace if thrown
        Throwable thrown = message.getThrown();
        if (null != thrown) { 
            Ajde.getDefault().getErrorHandler().handleError(message.getMessage(), thrown);
        }
    }
================= fetch public BrowserProperties getBrowserProjectProperties() { bbd832b^:ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java

public BrowserProperties getBrowserProjectProperties() {
		return browserProjectProperties;
	}
================= fetch public BuildManager getBuildManager() { bbd832b^:ajde/src/org/aspectj/ajde/Ajde.java

public BuildManager getBuildManager() {
		return buildManager;
	}
================= fetch public FileStructureView createViewForSourceFile(String sourceFilePath, Structur bbd832b^:ajde/src/org/aspectj/ajde/ui/StructureViewManager.java
/**
	 * @param	sourceFilePath	full path to corresponding source file
	 * @param	properties		if null default properties will be used
	 * @return					always returns a view intance
	 */
public FileStructureView createViewForSourceFile(String sourceFilePath, StructureViewProperties properties) {
		Ajde.getDefault().logEvent("creating view for file: " + sourceFilePath);
		if (properties == null) properties = DEFAULT_VIEW_PROPERTIES;
		FileStructureView view = new FileStructureView(properties);
		view.setSourceFile(sourceFilePath);
		treeViewBuilder.buildView(view, StructureModelManager.INSTANCE.getStructureModel()); 
		structureViews.add(view);
		return view; 
	}
================= fetch public PointcutWizard(java.util.List signatures) { bbd832b^:ajde/src/org/aspectj/ajde/ui/swing/PointcutWizard.java

================= fetch public StructureModelManager getStructureModelManager() { bbd832b^:ajde/src/org/aspectj/ajde/Ajde.java
/**
	 * The structure manager is not a part of the public API and its
	 * use should be avoided.  Used <CODE>getStructureViewManager()</CODE>
	 * instead.
	 */
public StructureModelManager getStructureModelManager() {
		return StructureModelManager.INSTANCE;	
	}
================= fetch public StructureViewManager(StructureViewNodeFactory nodeFactory) { bbd832b^:ajde/src/org/aspectj/ajde/ui/StructureViewManager.java

public void modelUpdated(StructureModel model) {        	
        	Ajde.getDefault().logEvent("updating structure views: " + structureViews);
        	
        	if (defaultFileView != null) {
        		defaultFileView.setSourceFile(Ajde.getDefault().getEditorManager().getCurrFile());
        	}
        	
        	for (Iterator it = structureViews.iterator(); it.hasNext(); ) {
        		treeViewBuilder.buildView((StructureView)it.next(), (StructureModel)model);
        	}
        }
================= fetch public StructureViewPanel getBrowserPanel() { bbd832b^:ajde/src/org/aspectj/ajde/ui/swing/BrowserViewManager.java

public StructureViewPanel getBrowserPanel() {
        return browserPanel;
    }
================= fetch public TreeViewBuildConfigEditor getBuildConfigEditor() { bbd832b^:ajde/src/org/aspectj/ajde/ui/swing/AjdeUIManager.java

public TreeViewBuildConfigEditor getBuildConfigEditor() {
		return buildConfigEditor;
	}
================= fetch public static BrowserManager getDefault() { bbd832b^:ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java

public static BrowserManager getDefault() {
		return INSTANCE;
	}
================= fetch public static Map getLinesToAspectMap(String sourceFilePath) { bbd832b^:ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java

public static Map getLinesToAspectMap(String sourceFilePath) {

		Map annotationsMap =
			StructureModelManager.INSTANCE.getInlineAnnotations(
				sourceFilePath,
				true,
				true);

		Map aspectMap = new HashMap();
		Set keys = annotationsMap.keySet();
		for (Iterator it = keys.iterator(); it.hasNext();) {
			Object key = it.next();
			List annotations = (List) annotationsMap.get(key);
			for (Iterator it2 = annotations.iterator(); it2.hasNext();) {
				ProgramElementNode node = (ProgramElementNode) it2.next();

				List relations = node.getRelations();

				for (Iterator it3 = relations.iterator(); it3.hasNext();) {
					RelationNode relationNode = (RelationNode) it3.next();

					if (relationNode.getKind().equals("Advice")) {
						List children = relationNode.getChildren();

						List aspects = new Vector();

						for (Iterator it4 = children.iterator();
							it4.hasNext();
							) {
							Object object = it4.next();

							if (object instanceof LinkNode) {
								ProgramElementNode pNode =
									((LinkNode) object).getProgramElementNode();

								if (pNode.getProgramElementKind()
									== ProgramElementNode.Kind.ADVICE) {

									StructureNode theAspect = pNode.getParent();

									aspects.add(theAspect);

								}
							}
						}
						if (!aspects.isEmpty()) {
							aspectMap.put(key, aspects);
						}
					}

				}
			}
		}
		return aspectMap;
	}
================= fetch public static void init( bbd832b^:ajde/src/org/aspectj/ajde/Ajde.java
/**
	 * This method must be called before using Ajde.  A <CODE>RuntimeException</CODE> will
	 * be thrown if use is attempted before initialization.
	 */
public static void init(
			EditorAdapter editorAdapter,
			TaskListManager taskListManager,
			BuildProgressMonitor compileProgressMonitor,
			ProjectPropertiesAdapter projectProperties,
			BuildOptionsAdapter buildOptionsAdapter,
			StructureViewNodeFactory structureViewNodeFactory,
			IdeUIAdapter ideUIAdapter,
			ErrorHandler errorHandler) {
		try {
			INSTANCE.projectProperties = projectProperties;
			INSTANCE.errorHandler = errorHandler;
			INSTANCE.taskListManager = taskListManager;
			INSTANCE.editorManager = new EditorManager(editorAdapter);
			INSTANCE.buildManager = new AspectJBuildManager(
				taskListManager, 
				compileProgressMonitor,
				buildOptionsAdapter);
 
			INSTANCE.buildManager.addListener(INSTANCE.BUILD_STATUS_LISTENER);
			INSTANCE.configurationManager.addListener(INSTANCE.STRUCTURE_UPDATE_CONFIG_LISTENER);
			INSTANCE.ideUIAdapter = ideUIAdapter;
			
			INSTANCE.structureSearchManager = new StructureSearchManager();	
			INSTANCE.structureViewManager = new StructureViewManager(structureViewNodeFactory);
			
			isInitialized = true;
//			INSTANCE.enableLogging(System.out); 
		} catch (Throwable t) {
			System.err.println("AJDE ERROR: could not initialize Ajde.");
			t.printStackTrace();	
		}
	}
================= fetch public void actionPerformed(ActionEvent e) { bbd832b^:ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java

private void maybeShowPopup(MouseEvent e) {
        if (e.getModifiers() == InputEvent.BUTTON3_MASK && tree.getSelectionCount() > 0) {
            TreePath[] selectionPaths = tree.getSelectionPaths();
            final List signatures = new ArrayList();
            for (int i = 0; i < selectionPaths.length; i++) {
                StructureNode currNode = (StructureNode)((SwingTreeViewNode)selectionPaths[i].getLastPathComponent()).getUserObject();
                if (currNode instanceof LinkNode || currNode instanceof ProgramElementNode) {
                    signatures.add(currNode);
                }
            }

            JPopupMenu popup = new JPopupMenu();
            JMenuItem showSourcesItem = new JMenuItem("Display sources", AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(ProgramElementNode.Kind.CODE));
            showSourcesItem.setFont(new java.awt.Font("Dialog", 0, 11));
            showSourcesItem.addActionListener(new AbstractAction() {
                public void actionPerformed(ActionEvent e) {
                    //AjdeUIManager.getDefault().getViewManager().showSourcesNodes(signatures);
                }
            });
            popup.add(showSourcesItem);

            popup.addSeparator();
            JMenuItem generatePCD = new JMenuItem("Pointcut Wizard (alpha)...", AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(ProgramElementNode.Kind.POINTCUT));
            generatePCD.setFont(new java.awt.Font("Dialog", 0, 11));
            generatePCD.addActionListener(new AbstractAction() {
                public void actionPerformed(ActionEvent e) {
                    AjdeUIManager.getDefault().getViewManager().extractAndInsertSignatures(signatures, true);
                }
            });
            popup.add(generatePCD);

            popup.show(e.getComponent(), e.getX(), e.getY());
        }
    }
================= fetch public void compileFinished(String buildConfig, int buildTime, boolean succeeded bbd832b^:ajde/src/org/aspectj/ajde/Ajde.java
/**
    	 * The strucutre model is annotated with error messages after an unsuccessful compile.
    	 */
public void compileFinished(String buildConfig, int buildTime, boolean succeeded, boolean warnings) { 
        	String configFilePath = projectProperties.getDefaultBuildConfigFile();
        	if (!succeeded) {
	        	StructureModelManager.INSTANCE.fireModelUpdated();	
    	    }
        }
================= fetch public void hideMessagesPanel() { bbd832b^:ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java

public void hideMessagesPanel() {
        right_splitPane.setDividerLocation(right_splitPane.getHeight());
        messages_panel.setVisible(false);
    }
================= fetch public void init(String testProjectPath) { bbd832b^:ajde/testsrc/org/aspectj/ajde/NullIdeManager.java

public void init(String testProjectPath) {
		try {
			UserPreferencesAdapter preferencesAdapter = new UserPreferencesStore(false);
			ProjectPropertiesAdapter browserProjectProperties = new NullIdeProperties(testProjectPath);
			taskListManager = new NullIdeTaskListManager();
			BasicEditor ajdeEditor = new BasicEditor();
			IdeUIAdapter uiAdapter = new NullIdeUIAdapter();
			JFrame nullFrame = new JFrame();
			//configurationManager.setConfigFiles(getConfigFilesList(configFiles));	

			AjdeUIManager.getDefault().init(
				ajdeEditor,
				taskListManager,
				browserProjectProperties,  
				preferencesAdapter,
				uiAdapter,
				new IconRegistry(),
				nullFrame,
				true);	
				
			//Ajde.getDefault().enableLogging( System.out );
		} catch (Throwable t) {
			t.printStackTrace();
			Ajde.getDefault().getErrorHandler().handleError(
				"Null IDE failed to initialize.",
				t);
		}
	}
================= fetch public void init(String[] configFilesArgs, boolean visible) { bbd832b^:ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java

public void init(String[] configFilesArgs, boolean visible) {
		try {
			UserPreferencesAdapter preferencesAdapter = new UserPreferencesStore(true);
			browserProjectProperties = new BrowserProperties(preferencesAdapter);
			TaskListManager taskListManager = new CompilerMessagesPanel();
			BasicEditor ajdeEditor = new BasicEditor();
			BrowserUIAdapter browserUIAdapter = new BrowserUIAdapter();
			topFrame = new TopFrame(); 
			configFiles = getConfigFilesList(configFilesArgs);	

			AjdeUIManager.getDefault().init(
				ajdeEditor,
				taskListManager,
				browserProjectProperties,
				preferencesAdapter,
				browserUIAdapter,
				new IconRegistry(),
				topFrame,
				true);	
			
			Ajde.getDefault().getBuildManager().addListener(BUILD_MESSAGES_LISTENER);
			
			MultiStructureViewPanel multiViewPanel = new MultiStructureViewPanel(
				AjdeUIManager.getDefault().getViewManager().getBrowserPanel(),
				AjdeUIManager.getDefault().getFileStructurePanel()
			);
			
			topFrame.init(
				multiViewPanel,
				(CompilerMessagesPanel)taskListManager,
				Ajde.getDefault().getEditorManager().getEditorPanel()
			);
				
			if (visible) topFrame.setVisible(true);
			  
			if (configFiles.size() == 0) {
				Ajde.getDefault().getErrorHandler().handleWarning(
					"No build configuration selected. "
						+ "Select a \".lst\" build configuration file in order to compile and navigate structure.");
			} else {
				//UiManager.getDefault().getViewManager().updateConfigsList();
			}
		
			AjdeUIManager.getDefault().getOptionsFrame().addOptionsPanel(new BrowserOptionsPanel());
		
			//String lastOpenFilePath = browserProjectProperties.getLastOpenSourceFilePath();
			//Ajde.getDefault().getEditorManager().showSourceLine(lastOpenFilePath, 1, false);	
			//Ajde.getDefault().getStructureViewManager().fireNavigationAction(lastOpenFilePath, 6);
			//Ajde.getDefault().enableLogging(System.out); 
		
			if (configFilesArgs.length > 0 && configFilesArgs[0] != null) {
				Ajde.getDefault().getConfigurationManager().setActiveConfigFile(configFilesArgs[0]);	
			}
		} catch (Throwable t) {
			t.printStackTrace();
			Ajde.getDefault().getErrorHandler().handleError(
				"AJDE failed to initialize.",
				t);
		}
	}
================= fetch public void init( bbd832b^:ajde/src/org/aspectj/ajde/ui/swing/AjdeUIManager.java

public void init(
		EditorAdapter editorAdapter,
		TaskListManager taskListManager,
		ProjectPropertiesAdapter projectProperties,
		UserPreferencesAdapter userPreferencesAdapter,
		IdeUIAdapter ideUIAdapter,
		IconRegistry iconRegistry,
		Frame rootFrame,
		boolean useFileView) {
		try {	
			BuildProgressMonitor compileProgress = new DefaultBuildProgressMonitor(rootFrame);
			ErrorHandler errorHandler = new AjdeErrorHandler();
			this.iconRegistry = iconRegistry;
			//ConfigurationManager configManager = new LstConfigurationManager();
			this.ideUIAdapter = ideUIAdapter;
			this.userPreferencesAdapter = userPreferencesAdapter;
			this.buildOptionsAdapter = new AjcBuildOptions(userPreferencesAdapter);
			this.buildConfigEditor = new TreeViewBuildConfigEditor();
			this.rootFrame = rootFrame;
			Ajde.init(
				editorAdapter,
				taskListManager,
				compileProgress,
				projectProperties,
				buildOptionsAdapter,
				new SwingTreeViewNodeFactory(iconRegistry),
				ideUIAdapter,
				errorHandler);
			
			Ajde.getDefault().getBuildManager().addListener(STATUS_TEXT_UPDATER);
			//Ajde.getDefault().setConfigurationManager(configManager);	
			
			if (useFileView) {
				FileStructureView structureView = Ajde.getDefault().getStructureViewManager().createViewForSourceFile(
	    			Ajde.getDefault().getEditorManager().getCurrFile(),
	    			Ajde.getDefault().getStructureViewManager().getDefaultViewProperties()
		    	);
		    	Ajde.getDefault().getStructureViewManager().setDefaultFileView(structureView);			
				fileStructurePanel = new StructureViewPanel(structureView);
			}
			
			viewManager = new BrowserViewManager();
			optionsFrame = new OptionsFrame(iconRegistry);
			
			//Ajde.getDefault().getStructureViewManager().refreshView(
			//	Ajde.getDefault().getStructureViewManager().getDefaultFileStructureView()
			//);
			
			//viewManager.updateView();
		} catch (Throwable t) {
			Ajde.getDefault().getErrorHandler().handleError("AJDE failed to initialize.", t);
		}
	}
================= fetch public void modelUpdated(StructureModel model) { bbd832b^:ajde/src/org/aspectj/ajde/ui/StructureViewManager.java

public void modelUpdated(StructureModel model) {        	
        	Ajde.getDefault().logEvent("updating structure views: " + structureViews);
        	
        	if (defaultFileView != null) {
        		defaultFileView.setSourceFile(Ajde.getDefault().getEditorManager().getCurrFile());
        	}
        	
        	for (Iterator it = structureViews.iterator(); it.hasNext(); ) {
        		treeViewBuilder.buildView((StructureView)it.next(), (StructureModel)model);
        	}
        }
================= fetch public void openFile(String filePath) { bbd832b^:ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java

public void openFile(String filePath) {
		try {
			if (filePath.endsWith(".lst")) {
				AjdeUIManager.getDefault().getBuildConfigEditor().openFile(filePath);
				topFrame.setEditorPanel(AjdeUIManager.getDefault().getBuildConfigEditor());
			} else if (filePath.endsWith(".java") || filePath.endsWith(".aj")){
				Ajde.getDefault().getEditorManager().showSourceLine(filePath, 0, false);		
			} else {
				Ajde.getDefault().getErrorHandler().handleError("File: " + filePath 
					+ " could not be opened because the extension was not recoginzed.");	
			}
		} catch (IOException ioe) {
			Ajde.getDefault().getErrorHandler().handleError("Could not open file: " + filePath, ioe);
		} catch (InvalidResourceException ire) {
			Ajde.getDefault().getErrorHandler().handleError("Invalid file: " + filePath, ire);
		} 
		
		browserProjectProperties.setLastOpenSourceFilePath(filePath);
	}
================= fetch public void saveAll() { bbd832b^:ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java

public void saveAll() {
        Ajde.getDefault().getEditorManager().saveContents();
    }
================= fetch public void setActiveNode(StructureViewNode node, int lineOffset) { bbd832b^:ajde/src/org/aspectj/ajde/ui/swing/StructureViewPanel.java

public void setActiveNode(StructureViewNode node, int lineOffset) {
		if (node == null) return;
 		if (!(node.getStructureNode() instanceof ProgramElementNode)) return;
		ProgramElementNode pNode = (ProgramElementNode)node.getStructureNode();
 		treeManager.highlightNode(pNode);
 		if (pNode.getSourceLocation() != null) {
	 		Ajde.getDefault().getEditorManager().showSourceLine(
	 			pNode.getSourceLocation().getSourceFile().getAbsolutePath(),
	 			pNode.getSourceLocation().getLine() + lineOffset,
	 			true
	 		);
 		}
	}
================= fetch public void setDefaultFileView(FileStructureView defaultFileView) { bbd832b^:ajde/src/org/aspectj/ajde/ui/StructureViewManager.java

public void setDefaultFileView(FileStructureView defaultFileView) {
		this.defaultFileView = defaultFileView;
	}
================= fetch public void setErrorHandler(ErrorHandler errorHandler) { bbd832b^:ajde/src/org/aspectj/ajde/Ajde.java

public void setErrorHandler(ErrorHandler errorHandler) {
		this.errorHandler = errorHandler;
	}
================= fetch void jMenuItem1_actionPerformed(ActionEvent e) { bbd832b^:ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java

void jMenuItem1_actionPerformed(ActionEvent e) {
        Ajde.getDefault().getEditorManager().saveContents();
    }
================= fetch void save_button_actionPerformed(ActionEvent e) { bbd832b^:ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java

void save_button_actionPerformed(ActionEvent e) {
        Ajde.getDefault().getEditorManager().saveContents();
    }
================= fetch protected boolean doCommand(IMessageHandler handler, boolean repeat) { d5ea336^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java
/** 
     * Delegate of both runCommand and repeatCommand.
     * This invokes the argument parser each time
     * (even when repeating).
     * If the parser detects errors, this signals an 
     * abort with the usage message and returns false.
     * @param handler the IMessageHandler sink for any messages
     * @param repeat if true, do incremental build, else do batch build
     * @return false if handler has any errors or command failed
     */
protected boolean doCommand(IMessageHandler handler, boolean repeat) {
        try {
			//buildManager.setMessageHandler(handler);
            CountingMessageHandler counter = new CountingMessageHandler(handler);
            if (counter.hasErrors()) {
                return false;
            }
            // regenerate configuration b/c world might have changed (?)
            AjBuildConfig config = genBuildConfig(savedArgs, counter);
            if (!config.hasSources()) {
                MessageUtil.error(counter, "no sources specified");
            }
            if (counter.hasErrors())  { // print usage for config errors
                String usage = BuildArgParser.getUsage();
                MessageUtil.abort(handler, usage);
                return false;
            }
            //System.err.println("errs: " + counter.hasErrors());          
            return ((repeat 
                        ? buildManager.incrementalBuild(config, handler)
                        : buildManager.batchBuild(config, handler))
                    && !counter.hasErrors());
        } catch (AbortException ae) {
            if (ae.isSilent()) {
                throw ae;
            } else {
                MessageUtil.abort(handler, ABORT_MESSAGE, ae);
            }
        } catch (MissingSourceFileException t) { 
            MessageUtil.error(handler, t.getMessage());
        } catch (Throwable t) {
            MessageUtil.abort(handler, ABORT_MESSAGE, t);
        } 
        return false;
    }
================= fetch public AjBuildConfig genBuildConfig(String configFile) { d5ea336^:ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java
/**
     * Generate AjBuildConfig from the local configFile parameter
     * plus global project and build options.
     * Errors signalled using signal... methods.
     * @param configFile
     * @return null if invalid configuration, 
     *   corresponding AjBuildConfig otherwise
     */
public AjBuildConfig genBuildConfig(String configFile) {
		

        init();
	    File config = new File(configFile);
        if (!config.exists()) {
            signalError("Config file \"" + configFile + "\" does not exist."); 
            return null;
        }
        String[] args = new String[] { "@" + config.getAbsolutePath() };
        CountingMessageHandler counter 
            = CountingMessageHandler.makeCountingMessageHandler(messageHandler);
        AjBuildConfig local = AjdtCommand.genBuildConfig(args, counter);
        if (counter.hasErrors()) {
            return null; 
        }
        local.setConfigFile(config);

        // -- get globals, treat as defaults used if no local values
        AjBuildConfig global = new AjBuildConfig();
        // AMC refactored into two methods to populate buildConfig from buildOptions and
        // project properties - bugzilla 29769.
        BuildOptionsAdapter buildOptions 
            = Ajde.getDefault().getBuildManager().getBuildOptions();
        if (!configureBuildOptions(global, buildOptions, counter)) {
            return null;
        }
        ProjectPropertiesAdapter projectOptions =
            Ajde.getDefault().getProjectProperties();
        configureProjectOptions(global, projectOptions);
		
        local.installGlobals(global); // XXX other post-evaluation?
        String errs = local.configErrors();
        if (null != errs) {
            MessageUtil.error(counter, errs);
            return null;
        }
        // always force model generation in AJDE
        local.setGenerateModelMode(true);       

        return fixupBuildConfig(local, global, buildOptions, projectOptions);
	}
================= fetch public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler) { d5ea336^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java
/**
     * Generate build configuration for the input args,
     * passing to handler any error messages.
     * @param args the String[] arguments for the build configuration
     * @param handler the IMessageHandler handler for any errors
     * @return AjBuildConfig per args, 
     *         which will be invalid unless there are no handler errors.
     */
public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler) {
		AjBuildConfig buildConfig = new AjBuildConfig();
		try {
			// sets filenames to be non-null in order to make sure that file paramters are ignored
			super.filenames = new String[] { "" }; 
			
			List fileList = new ArrayList();
			
			AjcConfigParser parser = new AjcConfigParser(buildConfig, handler);
			parser.parseCommandLine(args);
            
            boolean incrementalMode = buildConfig.isIncrementalMode()
                        || buildConfig.isIncrementalFileMode();
			
            List files = parser.getFiles();
            if (!LangUtil.isEmpty(files)) {
                if (incrementalMode) {
                    MessageUtil.error(handler, "incremental mode only handles source files using -sourceroots"); 
                } else {
                    fileList.addAll(files);
                }
            }
				
			List javaArgList = new ArrayList();
			
			//	disable all special eclipse warnings by default
			//??? might want to instead override getDefaultOptions()
			javaArgList.add("-warn:none");
			
			// these next four lines are some nonsense to fool the eclipse batch compiler
			// without these it will go searching for reasonable values from properties
			//TODO fix org.eclipse.jdt.internal.compiler.batch.Main so this hack isn't needed
			javaArgList.add("-classpath");
			javaArgList.add(System.getProperty("user.dir"));
			javaArgList.add("-bootclasspath");
			javaArgList.add(System.getProperty("user.dir"));
			
			javaArgList.addAll(parser.getUnparsedArgs());

//			if (javaArgList.size() != 0) {
				super.configure((String[])javaArgList.toArray(new String[javaArgList.size()]));
//			}
			
			if (buildConfig.getSourceRoots() != null) {
				for (Iterator i = buildConfig.getSourceRoots().iterator(); i.hasNext(); ) {
					fileList.addAll(collectSourceRootFiles((File)i.next()));
				}
			}
			
			buildConfig.setFiles(fileList);
			if (destinationPath != null) { // XXX ?? unparsed but set?
				buildConfig.setOutputDir(new File(destinationPath));
			}
			
			buildConfig.setClasspath(getClasspath(parser));
			
			if (incrementalMode 
                && (0 == buildConfig.getSourceRoots().size())) {
                    MessageUtil.error(handler, "specify a source root when in incremental mode");
			}
			
			setDebugOptions();
			buildConfig.setJavaOptions(options);
		} catch (InvalidInputException iie) {
            MessageUtil.error(handler, iie.getMessage());
		}
		return buildConfig;
	}
================= fetch public BuildArgParser() { d5ea336^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java

================= fetch public static AjBuildConfig genBuildConfig(String[] args, CountingMessageHandler d5ea336^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java
/** @return IMessage.WARNING unless message contains error or info */
protected static IMessage.Kind inferKind(String message) { // XXX dubious
        if (-1 != message.indexOf("error")) {
            return IMessage.ERROR;
        } else if (-1 != message.indexOf("info")) {
            return IMessage.INFO;
        } else {
            return IMessage.WARNING;
        }
    }
================= fetch private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge 026b272^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java

private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munger) {
		ResolvedMember signature = munger.getSignature();
		ResolvedMember dispatchMethod = munger.getDispatchMethod(aspectType);
		
		LazyClassGen gen = weaver.getLazyClassGen();
		
		ResolvedTypeX onType = weaver.getWorld().resolve(signature.getDeclaringType());
		boolean onInterface = onType.isInterface();
		
		if (onType.equals(gen.getType())) {
			ResolvedMember introMethod = 
					AjcMemberMaker.interMethod(signature, aspectType, onInterface);
			
			LazyMethodGen mg = makeMethodGen(gen, introMethod);

			if (!onInterface && !Modifier.isAbstract(introMethod.getModifiers())) {
				InstructionList body = mg.getBody();
				InstructionFactory fact = gen.getFactory();
				int pos = 0;
	
				if (!signature.isStatic()) {
					body.append(fact.createThis());
					pos++;
				}
				Type[] paramTypes = BcelWorld.makeBcelTypes(introMethod.getParameterTypes());
				for (int i = 0, len = paramTypes.length; i < len; i++) {
					Type paramType = paramTypes[i];
					body.append(fact.createLoad(paramType, pos));
					pos+=paramType.getSize();
				}
				body.append(Utility.createInvoke(fact, weaver.getWorld(), dispatchMethod));
				body.append(fact.createReturn(BcelWorld.makeBcelType(introMethod.getReturnType())));
			} else {
				//??? this is okay
				//if (!(mg.getBody() == null)) throw new RuntimeException("bas");
			}
			

			// XXX make sure to check that we set exceptions properly on this guy.
			weaver.addLazyMethodGen(mg);
			
			Set neededSuperCalls = munger.getSuperMethodsCalled();

			for (Iterator iter = neededSuperCalls.iterator(); iter.hasNext(); ) {
				ResolvedMember superMethod = (ResolvedMember) iter.next();
				if (weaver.addDispatchTarget(superMethod)) {
					//System.err.println("super type: " + superMethod.getDeclaringType() + ", " + gen.getType());
					boolean isSuper = !superMethod.getDeclaringType().equals(gen.getType());
					String dispatchName;
					if (isSuper) dispatchName = NameMangler.superDispatchMethod(onType, superMethod.getName());
					else dispatchName = NameMangler.protectedDispatchMethod(onType, superMethod.getName());
					LazyMethodGen dispatcher = makeDispatcher(gen, dispatchName, superMethod, weaver.getWorld(), isSuper);

					weaver.addLazyMethodGen(dispatcher);
				}
			}
			
    		return true;
		} else if (onInterface && gen.getType().isTopmostImplementor(onType) && 
						!Modifier.isAbstract(signature.getModifiers()))
		{
			ResolvedMember introMethod = 
					AjcMemberMaker.interMethod(signature, aspectType, false);
			
			LazyMethodGen mg = makeMethodGen(gen, introMethod);
			
			// 
						
			Type[] paramTypes = BcelWorld.makeBcelTypes(introMethod.getParameterTypes());
			Type returnType = BcelWorld.makeBcelType(introMethod.getReturnType());
			
			InstructionList body = mg.getBody();
			InstructionFactory fact = gen.getFactory();
			int pos = 0;

			if (!introMethod.isStatic()) {
				body.append(fact.createThis());
				pos++;
			}
			for (int i = 0, len = paramTypes.length; i < len; i++) {
				Type paramType = paramTypes[i];
				body.append(fact.createLoad(paramType, pos));
				pos+=paramType.getSize();
			}
			body.append(Utility.createInvoke(fact, weaver.getWorld(), dispatchMethod));
			body.append(fact.createReturn(returnType));
			mg.definingType = onType;
			
			weaver.addOrReplaceLazyMethodGen(mg);
			
			return true;
		} else {
			return false;
		}
	}
================= fetch private static LazyMethodGen makeDispatcher( 026b272^:weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java

private static LazyMethodGen makeDispatcher(
		LazyClassGen onGen,
		String dispatchName,
		ResolvedMember superMethod,
		BcelWorld world,
		boolean isSuper) 
	{
		Type[] paramTypes = BcelWorld.makeBcelTypes(superMethod.getParameterTypes());
		Type returnType = BcelWorld.makeBcelType(superMethod.getReturnType());
				
		LazyMethodGen mg = 
				new LazyMethodGen(
					Modifier.PUBLIC,
					returnType,
					dispatchName,
					paramTypes,
					TypeX.getNames(superMethod.getExceptions()),
					onGen);
		InstructionList body = mg.getBody();
		
		// assert (!superMethod.isStatic())
		InstructionFactory fact = onGen.getFactory();
		int pos = 0;
		
		body.append(fact.createThis());
		pos++;
		for (int i = 0, len = paramTypes.length; i < len; i++) {
			Type paramType = paramTypes[i];
			body.append(fact.createLoad(paramType, pos));
			pos+=paramType.getSize();
		}
		if (isSuper) {
			body.append(Utility.createSuperInvoke(fact, world, superMethod));
		} else {
			body.append(Utility.createInvoke(fact, world, superMethod));
		}
		body.append(fact.createReturn(returnType));

		return mg;
	}
================= fetch public void resolve(ClassScope upperScope) { 026b272^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeDeclaration.java

public void resolve(ClassScope upperScope) {
		if (ignoreFurtherInvestigation) return;
		
		
		ClassScope newParent = new InterTypeScope(upperScope, onTypeBinding);
		scope.parent = newParent;
		this.scope.isStatic = Modifier.isStatic(declaredModifiers);
		super.resolve(newParent);
		fixSuperCallsInBody();
	}
================= fetch private void makePublic(TypeBinding binding) { ba41fae^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java

private void makePublic(TypeBinding binding) {
		if (binding == null || !binding.isValidBinding()) return;  // has already produced an error
		if (binding instanceof ReferenceBinding) {
			ReferenceBinding rb = (ReferenceBinding)binding;
			if (!rb.isPublic()) handler.notePrivilegedTypeAccess(rb, null); //???
		} else if (binding instanceof ArrayBinding) {
			makePublic( ((ArrayBinding)binding).leafComponentType );
		} else {
			return;
		}
	}
================= fetch public MethodBinding getPrivilegedAccessMethod(MethodBinding baseMethod, AstNode ba41fae^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/PrivilegedHandler.java

public MethodBinding getPrivilegedAccessMethod(MethodBinding baseMethod, AstNode location) {
		if (baseMethod.alwaysNeedsAccessMethod()) return baseMethod;
		
		ResolvedMember key = inAspect.factory.makeResolvedMember(baseMethod);
		if (accessors.containsKey(key)) return (MethodBinding)accessors.get(key);
		
		MethodBinding ret;
		if (baseMethod.isConstructor()) {
			ret = baseMethod;
		} else {
			ret = inAspect.factory.makeMethodBinding(
			AjcMemberMaker.privilegedAccessMethodForMethod(inAspect.typeX, key)
			);
		}
		checkWeaveAccess(key.getDeclaringType(), location);
		//new PrivilegedMethodBinding(inAspect, baseMethod);
		accessors.put(key, ret);
		return ret;
	}
================= fetch public void endVisit(AllocationExpression send, BlockScope scope) { ba41fae^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java

public void endVisit(AllocationExpression send, BlockScope scope) {
		if (send.binding == null) return;
		//XXX TBD
		if (isPublic(send.binding)) return;
		makePublic(send.binding.declaringClass);
		send.binding = handler.getPrivilegedAccessMethod(send.binding, send);
	}
================= fetch public void endVisit(AssertStatement assertStatement, BlockScope scope) { ba41fae^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java
/* (non-Javadoc)
	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#endVisit(org.eclipse.jdt.internal.compiler.ast.AssertStatement, org.eclipse.jdt.internal.compiler.lookup.BlockScope)
	 */
public void endVisit(AssertStatement assertStatement, BlockScope scope) {
		isInlinable = false;
	}
================= fetch public void endVisit(MessageSend send, BlockScope scope) { ba41fae^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java

public void endVisit(MessageSend send, BlockScope scope) {
		if (send instanceof Proceed) return;
		if (send.binding == null) return;
		
		if (send.isSuperAccess() && !send.binding.isStatic()) {
			send.receiver = new ThisReference(send.sourceStart, send.sourceEnd);
			send.binding = send.codegenBinding = 
				getSuperAccessMethod((MethodBinding)send.binding);
		} else if (!isPublic(send.binding)) {
			send.syntheticAccessor = getAccessibleMethod((MethodBinding)send.binding);
		}
	}
================= fetch public void endVisit( ba41fae^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java
/* (non-Javadoc)
	 * @see org.eclipse.jdt.internal.compiler.IAbstractSyntaxTreeVisitor#endVisit(org.eclipse.jdt.internal.compiler.ast.ClassLiteralAccess, org.eclipse.jdt.internal.compiler.lookup.BlockScope)
	 */
public void endVisit(ClassLiteralAccess classLiteral, BlockScope scope) {
		isInlinable = false;
	}
================= fetch public void resolveStatements() { ba41fae^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AdviceDeclaration.java

public void resolveStatements() {
		if (binding == null || ignoreFurtherInvestigation) return;
		
		ClassScope upperScope = (ClassScope)scope.parent;  //!!! safety
		
		modifiers = binding.modifiers = checkAndSetModifiers(modifiers, upperScope);
		
		if (kind == AdviceKind.AfterThrowing && extraArgument != null) {
			TypeBinding argTb = extraArgument.binding.type;
			TypeBinding expectedTb = upperScope.getJavaLangThrowable();
			if (!argTb.isCompatibleWith(expectedTb)) {
				scope.problemReporter().typeMismatchError(argTb, expectedTb, extraArgument);
				ignoreFurtherInvestigation = true;
				return;
			}
		}
		
		
		pointcutDesignator.finishResolveTypes(this, this.binding, 
			baseArgumentCount, upperScope.referenceContext.binding);
		
		if (binding == null || ignoreFurtherInvestigation) return;
		
		if (kind == AdviceKind.Around) {
			ReferenceBinding[] exceptions = 
				new ReferenceBinding[] { upperScope.getJavaLangThrowable() };
			proceedMethodBinding = new MethodBinding(Modifier.STATIC,
				"proceed".toCharArray(), binding.returnType,
				resize(baseArgumentCount+1, binding.parameters),
				exceptions, binding.declaringClass);
			proceedMethodBinding.selector =
				CharArrayOps.concat(selector, proceedMethodBinding.selector);
		}
		
		super.resolveStatements(); //upperScope);
		if (binding != null) determineExtraArgumentFlags();
		
		if (kind == AdviceKind.Around) {
			int n = proceedCalls.size();
			EclipseFactory world = EclipseFactory.fromScopeLookupEnvironment(upperScope);
						
			//System.err.println("access to: " + Arrays.asList(handler.getMembers()));
			
			//XXX set these correctly
			formalsUnchangedToProceed = new boolean[baseArgumentCount];
			proceedCallSignatures = new ResolvedMember[0];
			proceedInInners = false;
			declaredExceptions = new TypeX[0];
			
			for (int i=0; i < n; i++) {
				Proceed call = (Proceed)proceedCalls.get(i);
				if (call.inInner) {
					//System.err.println("proceed in inner: " + call);
					proceedInInners = true;
					//XXX wrong
					//proceedCallSignatures[i] = world.makeResolvedMember(call.binding);
				}
			}
			
			// ??? should reorganize into AspectDeclaration
			// if we have proceed in inners we won't ever be inlined so the code below is unneeded
			if (!proceedInInners) {
				PrivilegedHandler handler = (PrivilegedHandler)upperScope.referenceContext.binding.privilegedHandler;
				if (handler == null) {
					handler = new PrivilegedHandler((AspectDeclaration)upperScope.referenceContext);
					upperScope.referenceContext.binding.privilegedHandler = handler;
				}
				
				this.traverse(new MakeDeclsPublicVisitor(), (ClassScope)null);
				
				AccessForInlineVisitor v = new AccessForInlineVisitor((AspectDeclaration)upperScope.referenceContext, handler);
				this.traverse(v, (ClassScope) null);
				
				// ??? if we found a construct that we can't inline, set
				//     proceedInInners so that we won't try to inline this body
				if (!v.isInlinable) proceedInInners = true;
			}
		}
	}
================= fetch public void outputClassFiles(CompilationResult unitResult) { c509c6f^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java

public void outputClassFiles(CompilationResult unitResult) {
		if (unitResult == null) return;
		
		String sourceFileName = new String(unitResult.fileName);
		if (!(unitResult.hasErrors() && !proceedOnError())) {
			List unwovenClassFiles = new ArrayList();
			Enumeration classFiles = unitResult.compiledTypes.elements();
			while (classFiles.hasMoreElements()) {
				ClassFile classFile = (ClassFile) classFiles.nextElement();
				String filename = new String(classFile.fileName());
				filename = filename.replace('/', File.separatorChar) + ".class";
				
				File destinationPath = buildConfig.getOutputDir();
				if (destinationPath == null) {
					destinationPath = new File(extractDestinationPathFromSourceFile(unitResult));
				}
				filename = new File(destinationPath, filename).getPath();
				//System.out.println("classfile: " + filename);
				unwovenClassFiles.add(new UnwovenClassFile(filename, classFile.getBytes()));
			}
			state.noteClassesFromFile(unitResult, sourceFileName, unwovenClassFiles);
//			System.out.println("file: " + sourceFileName);
//			for (int i=0; i < unitResult.simpleNameReferences.length; i++) {
//				System.out.println("simple: " + new String(unitResult.simpleNameReferences[i]));
//			}
//			for (int i=0; i < unitResult.qualifiedReferences.length; i++) {
//				System.out.println("qualified: " +
//					new String(CharOperation.concatWith(unitResult.qualifiedReferences[i], '/')));
//			}
		} else {
			state.noteClassesFromFile(null, sourceFileName, Collections.EMPTY_LIST);
		}
	}
================= fetch public void testMissingRuntimeError() { c509c6f^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BasicCommandTestCase.java

public void testMissingRuntimeError() {
		List args = new ArrayList();

		args.add("-d");
		args.add("out");
		
		args.add("-classpath");
		args.add("../lib/junit/junit.jar;../testing-client/bin");
		args.add("testdata/src1/ThisAndModifiers.java");
		
		ICommand command = new AjdtCommand();
		MessageHandler myHandler = new MessageHandler();
		myHandler.setInterceptor(org.aspectj.tools.ajc.Main.MessagePrinter.TERSE);
		boolean result = command.runCommand((String[])args.toArray(new String[args.size()]), myHandler);

		assertEquals("error for org.aspectj.lang.JoinPoint not found", 1, myHandler.getErrors().length);
	}
================= fetch public Member getEnclosingCodeSignature() { 2072ac1^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

public Member getEnclosingCodeSignature() {
    	if (enclosingShadow == null) {
    		return getSignature();
    	} else {
    		return enclosingShadow.getSignature();
    	}
    }
Progress : [#########################################-] 104%================= fetch public TypePattern resolveBindings(IScope scope, Bindings bindings, 7d14432^:weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java
/**
	 * Need to determine if I'm really a pattern or a reference to a formal
	 * 
	 * We may wish to further optimize the case of pattern vs. non-pattern
	 * 
	 * We will be replaced by what we return
	 */
public TypePattern resolveBindings(IScope scope, Bindings bindings, 
    								boolean allowBinding, boolean requireExactType)
    { 		
    	if (isStar()) {
			return TypePattern.ANY;  //??? loses source location
		}

		String simpleName = maybeGetSimpleName();
		if (simpleName != null) {
			FormalBinding formalBinding = scope.lookupFormal(simpleName);
			if (formalBinding != null) {
				if (!allowBinding || bindings == null) {
					scope.message(IMessage.ERROR, this, "negation doesn't allow binding");
					return this;
				}
				BindingTypePattern binding = new BindingTypePattern(formalBinding);
				binding.copyLocationFrom(this);
				bindings.register(binding, scope);
				
				return binding;
			}
		}
		
		String cleanName = maybeGetCleanName();
		if (cleanName != null) {
			TypeX type;
			
			//System.out.println("resolve: " + cleanName);
			//??? this loop has too many inefficiencies to count
			while ((type = scope.lookupType(cleanName, this)) == ResolvedTypeX.MISSING) {
				int lastDot = cleanName.lastIndexOf('.');
				if (lastDot == -1) break;
				cleanName = cleanName.substring(0, lastDot) + '$' + cleanName.substring(lastDot+1);
			}
			if (type == ResolvedTypeX.MISSING) {
				if (requireExactType) {
					if (!allowBinding) {
						scope.getWorld().getMessageHandler().handleMessage(
							MessageUtil.error("can't bind type name '" + cleanName + "'",
											getSourceLocation()));
					} else if (scope.getWorld().getLint().invalidAbsoluteTypeName.isEnabled()) {
						scope.getWorld().getLint().invalidAbsoluteTypeName.signal(cleanName, getSourceLocation());
					}
					return NO;
				} else if (scope.getWorld().getLint().invalidAbsoluteTypeName.isEnabled()) {
					scope.getWorld().getLint().invalidAbsoluteTypeName.signal(cleanName, getSourceLocation());
				}
			} else {
				if (dim != 0) type = TypeX.makeArray(type, dim);
				TypePattern ret = new ExactTypePattern(type, includeSubtypes);
				ret.copyLocationFrom(this);
				return ret;
			}
		} else {
			if (requireExactType) {
				scope.getWorld().getMessageHandler().handleMessage(
					MessageUtil.error("wildcard type pattern not allowed, must use type name",
										getSourceLocation()));
				return NO;
			}
			//XXX need to implement behavior for Lint.invalidWildcardTypeName
		}
		
		importedPrefixes = scope.getImportedPrefixes();
		knownMatches = preMatch(scope.getImportedNames());
		
		return this;
	}
================= fetch public boolean weave() { 7d14432^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java
// ----
public boolean weave() {
        if (clazz.getWeaverState().isWoven()) {
        	throw new RuntimeException("already woven: " + clazz);
        }
        
        boolean isChanged = false;
        
        // we want to "touch" all aspects
        if (clazz.getType().isAspect()) isChanged = true;
        
        
        // start by munging all typeMungers
        for (Iterator i = typeMungers.iterator(); i.hasNext(); ) {
        	Object o = i.next();
        	if ( !(o instanceof BcelTypeMunger) ) {
        		//???System.err.println("surprising: " + o);
        		continue;
        	}
        	BcelTypeMunger munger = (BcelTypeMunger)o;
        	isChanged |= munger.munge(this);
        }
        
        // XXX do major sort of stuff
        // sort according to:  Major:  type hierarchy
        //                     within each list:  dominates
        // don't forget to sort addedThisInitialiers according to dominates
        addedSuperInitializersAsList = new ArrayList(addedSuperInitializers.values());
        addedSuperInitializersAsList = PartialOrder.sort(addedSuperInitializersAsList);        
        if (addedSuperInitializersAsList == null) {
        	throw new BCException("circularity in inter-types");
        }
        
        // this will create a static initializer if there isn't one
        // this is in just as bad taste as NOPs
        LazyMethodGen staticInit = clazz.getStaticInitializer();
        staticInit.getBody().insert(genInitInstructions(addedClassInitializers, true));
        
        
        // now go through each method, and match against each method.  This
        // sets up each method's {@link LazyMethodGen#matchedShadows} field, 
        // and it also possibly adds to {@link #initializationShadows}.
        List methodGens = new ArrayList(clazz.getMethodGens());
        for (Iterator i = methodGens.iterator(); i.hasNext();) {
            LazyMethodGen mg = (LazyMethodGen)i.next();
			if (! mg.hasBody()) continue;
            isChanged |= match(mg);
        }
        if (! isChanged) return false;
        
        // now we weave all but the initialization shadows
		for (Iterator i = methodGens.iterator(); i.hasNext();) {
			LazyMethodGen mg = (LazyMethodGen)i.next();
			if (! mg.hasBody()) continue;
			implement(mg);
		}
			
        
        // if we matched any initialization shadows, we inline and weave
		if (! initializationShadows.isEmpty()) {
			inlineSelfConstructors(methodGens);
			positionAndImplement(initializationShadows);
		}
		
		
		// finally, if we changed, we add in the introduced methods.
        if (isChanged) {
        	clazz.setWeaverState(WeaverStateKind.Woven);
			weaveInAddedMethods();
        }
        
        return isChanged;
    }
================= fetch public final FuzzyBoolean matches(ResolvedTypeX type, MatchKind kind) { 7d14432^:weaver/src/org/aspectj/weaver/patterns/TypePattern.java

public final FuzzyBoolean matches(ResolvedTypeX type, MatchKind kind) {
		if (kind == STATIC) {
			return FuzzyBoolean.fromBoolean(matchesStatically(type));
		} else if (kind == DYNAMIC) {
			//System.err.println("matching: " + this + " with " + type);
			FuzzyBoolean ret = matchesInstanceof(type);
			//System.err.println("    got: " + ret);
			return ret;
		} else {
			throw new IllegalArgumentException("kind must be DYNAMIC or STATIC");
		}
	}
================= fetch private void initBcelWorld(IMessageHandler handler) throws IOException { f236927^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java
//	}	
private void initBcelWorld(IMessageHandler handler) throws IOException {
		bcelWorld = new BcelWorld(buildConfig.getClasspath(), handler);
		bcelWorld.setXnoInline(buildConfig.isXnoInline());
		bcelWeaver = new BcelWeaver(bcelWorld);
		
		for (Iterator i = buildConfig.getAspectpath().iterator(); i.hasNext();) {
			File f = (File) i.next();
			bcelWeaver.addLibraryJarFile(f);
		}
		
		String lintMode = buildConfig.getLintMode();
		
		if (buildConfig.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT)) {
			bcelWorld.getLint().loadDefaultProperties();
		} else {
			bcelWorld.getLint().setAll(buildConfig.getLintMode());
		}
		
		if (buildConfig.getLintSpecFile() != null) {
			bcelWorld.getLint().setFromProperties(buildConfig.getLintSpecFile());
		}
		
		//??? incremental issues
		for (Iterator i = buildConfig.getInJars().iterator(); i.hasNext(); ) {
			File inJar = (File)i.next();
			bcelWeaver.addJarFile(inJar, buildConfig.getOutputDir());
		}
	}
================= fetch public void testXlintError() { f236927^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BasicCommandTestCase.java

public void testXlintError() {
		List args = new ArrayList();

		args.add("-d");
		args.add("out");
		
		args.add("-classpath");
		args.add("../runtime/bin;../lib/junit/junit.jar;../testing-client/bin");
		args.add("-Xlint:error");
		args.add("testdata/src1/Xlint.java");
		
		runCompiler(args, new int[] {2});
	}
================= fetch public Pointcut concretize(ResolvedTypeX inAspect, IntMap bindings) { 1e502f5^:weaver/src/org/aspectj/weaver/patterns/Pointcut.java

public Pointcut concretize(ResolvedTypeX inAspect, IntMap bindings) {
		assertState(RESOLVED);
		Pointcut ret = this.concretize1(inAspect, bindings);
		ret.state = CONCRETE;
		return ret;
	}
================= fetch public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) { 1e502f5^:weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java

public Shadow.Kind getKind() {
		return kind;
	}
================= fetch public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) { 1e502f5^:weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java

public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {
		return this; //??? no pointers out of here so we're okay
	}
================= fetch public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) { 1e502f5^:weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java

public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {
		return this; //??? no pointers out of here so we're okay
	}
================= fetch public Pointcut concretize1( 1e502f5^:weaver/src/org/aspectj/weaver/patterns/Pointcut.java

public Pointcut concretize1(
			ResolvedTypeX inAspect,
			IntMap bindings) {
			return this;
		}
================= fetch public void setCanInline(boolean canInline) { 6c9118b^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

public void setCanInline(boolean canInline) {
		this.canInline = canInline;
	}
================= fetch public void weaveAroundInline( 6c9118b^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

void weaveAroundInline(
    	BcelAdvice munger,
    	boolean hasDynamicTest)
	{
		/* Implementation notes:
		 * 
		 * AroundInline still extracts the instructions of the original shadow into 
		 * an extracted method.  This allows inlining of even that advice that doesn't
		 * call proceed or calls proceed more than once. 
		 * 
		 * It extracts the instructions of the original shadow into a method.
		 * 
		 * Then it inlines the instructions of the advice in its place, taking care
		 * to treat the closure argument specially (it doesn't exist).
		 * 
		 * Then it searches in the instructions of the advice for any call to the
		 * proceed method.
		 * 
		 *   At such a call, there is stuff on the stack representing the arguments to
		 *   proceed.  Pop these into the frame.
		 * 
		 *   Now build the stack for the call to the extracted method, taking values 
		 *   either from the join point state or from the new frame locs from proceed.
		 *   Now call the extracted method.  The right return value should be on the
		 *   stack, so no cast is necessary.
		 *
		 * If only one call to proceed is made, we can re-inline the original shadow.
		 * We are not doing that presently.
		 */
		 
		// !!! THIS BLOCK OF CODE SHOULD BE IN A METHOD CALLED weaveAround(...);
        Member mungerSig = munger.getSignature();
        ResolvedTypeX declaringType = world.resolve(mungerSig.getDeclaringType());
        //??? might want some checks here to give better errors
        BcelObjectType ot = BcelWorld.getBcelObjectType(declaringType); 
        
		LazyMethodGen adviceMethod = ot.getLazyClassGen().getLazyMethodGen(mungerSig);
		if (!adviceMethod.getCanInline()) {
			weaveAroundClosure(munger, hasDynamicTest);
			return;
		}
		
		// We can't inline around methods if they have around advice on them, this
		// is because the weaving will extract the body and hence the proceed call.
		//??? should consider optimizations to recognize simple cases that don't require body extraction
		enclosingMethod.setCanInline(false);
		
		
		// start by exposing various useful things into the frame
		final InstructionFactory fact = getFactory();
		
		// now generate the aroundBody method
        LazyMethodGen extractedMethod = 
        	extractMethod(
        		NameMangler.aroundCallbackMethodName(
        			getSignature(),
        			getEnclosingClass()));
    
    	// the shadow is now empty.  First, create a correct call
    	// to the around advice.  This includes both the call (which may involve 
    	// value conversion of the advice arguments) and the return
    	// (which may involve value conversion of the return value).  Right now
    	// we push a null for the unused closure.  It's sad, but there it is.
    	    	
    	InstructionList advice = new InstructionList();
        InstructionHandle adviceMethodInvocation;
        {
        	// ??? we don't actually need to push NULL for the closure if we take care
		    advice.append(munger.getAdviceArgSetup(this, null, new InstructionList(fact.ACONST_NULL)));
		    adviceMethodInvocation =
		        advice.append(
		        	Utility.createInvoke(fact, getWorld(), munger.getSignature()));
			advice.append(
		        Utility.createConversion(
		            getFactory(), 
		            world.makeBcelType(munger.getSignature().getReturnType()), 
		            extractedMethod.getReturnType()));
		    if (! isFallsThrough()) {
		        advice.append(fact.createReturn(extractedMethod.getReturnType()));
		    }
        }
        
		// now, situate the call inside the possible dynamic tests,
		// and actually add the whole mess to the shadow
        if (! hasDynamicTest) {
            range.append(advice);
        } else {
        	InstructionList afterThingie = new InstructionList(fact.NOP);
            InstructionList callback = makeCallToCallback(extractedMethod);
            if (terminatesWithReturn()) {
                callback.append(fact.createReturn(extractedMethod.getReturnType()));
            } else {
            	//InstructionHandle endNop = range.insert(fact.NOP, Range.InsideAfter);
                advice.append(fact.createBranchInstruction(Constants.GOTO, afterThingie.getStart()));
            }
            range.append(munger.getTestInstructions(this, advice.getStart(), callback.getStart(), advice.getStart()));
            range.append(advice);
            range.append(callback);
            range.append(afterThingie);          
        }        
        
        // now the range contains everything we need.  We now inline the advice method.

				
        BcelClassWeaver.inlineMethod(adviceMethod, enclosingMethod, adviceMethodInvocation);

        // now search through the advice, looking for a call to PROCEED.  
        // Then we replace the call to proceed with some argument setup, and a 
        // call to the extracted method.
        String proceedName = 
        	NameMangler.proceedMethodName(munger.getSignature().getName());

        InstructionHandle curr = getRange().getStart();
        InstructionHandle end = getRange().getEnd();
        ConstantPoolGen cpg = extractedMethod.getEnclosingClass().getConstantPoolGen();
        while (curr != end) {
			InstructionHandle next = curr.getNext();
			Instruction inst = curr.getInstruction();
			if ((inst instanceof INVOKESTATIC)
					&& proceedName.equals(((INVOKESTATIC) inst).getMethodName(cpg))) {

					
				enclosingMethod.getBody().append(curr, getRedoneProceedCall(fact, extractedMethod, munger));
				Utility.deleteInstruction(curr, enclosingMethod);
			}
			curr = next;
        }
        // and that's it.
	}
Progress : [##########################################--] 105%================= fetch boolean canTreatAsStatic(String id) { 0a8dbde^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java

boolean canTreatAsStatic(String id) {
		return id.equals("toString")
			|| id.equals("toShortString")
			|| id.equals("toLongString")
			|| id.equals("getKind")
			|| id.equals("getSignature")
			|| id.equals("getSourceLocation")
			|| id.equals("getStaticPart");
	}
================= fetch private boolean alreadyDefined(LazyClassGen clazz, LazyMethodGen mg) { 808bae8^:weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java

private boolean alreadyDefined(LazyClassGen clazz, LazyMethodGen mg) {
		for (Iterator i = clazz.getMethodGens().iterator(); i.hasNext(); ) {
			if (signaturesMatch(mg, (LazyMethodGen)i.next())) {
				return true;
			}
		}
		return false;
	}
================= fetch public List getMethodGens() { 808bae8^:weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java

public List getMethodGens() {
        return Collections.unmodifiableList(methodGens);

    }
================= fetch static int getLineNumber( 808bae8^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

static int getLineNumber(
        InstructionHandle ih,
        int prevLine) 
    {
        InstructionTargeter[] targeters = ih.getTargeters();
        if (targeters == null) return prevLine;
        for (int i = targeters.length - 1; i >= 0; i--) {
            InstructionTargeter t = targeters[i];
            if (t instanceof LineNumberTag) {
                return ((LineNumberTag)t).getLineNumber();
            }
        } 
        return prevLine;
    }
================= fetch public static Test suite() { 989aaf7^:ajde/testsrc/org/aspectj/ajde/AjdeTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(AjdeTests.class.getName());
        //$JUnit-BEGIN$
        suite.addTestSuite(BuildOptionsTest.class); 
        suite.addTestSuite(BuildConfigurationTests.class);
        suite.addTestSuite(StructureModelRegressionTest.class); 
        suite.addTestSuite(StructureModelTest.class); 
        suite.addTestSuite(VersionTest.class); 
        //$JUnit-END$
        return suite;
    }
================= fetch public void init(String testProjectPath) { 989aaf7^:ajde/testsrc/org/aspectj/ajde/NullIdeManager.java

public void init(String testProjectPath) {
		try {
			UserPreferencesAdapter preferencesAdapter = new UserPreferencesStore();
			ProjectPropertiesAdapter browserProjectProperties = new NullIdeProperties(testProjectPath);
			TaskListManager taskListManager = new NullIdeTaskListManager();
			BasicEditor ajdeEditor = new BasicEditor();
			IdeUIAdapter uiAdapter = new NullIdeUIAdapter();
			JFrame nullFrame = new JFrame();
			//configurationManager.setConfigFiles(getConfigFilesList(configFiles));	

			AjdeUIManager.getDefault().init(
				ajdeEditor,
				taskListManager,
				browserProjectProperties,  
				preferencesAdapter,
				uiAdapter,
				new IconRegistry(),
				nullFrame,
				true);	
				
			//Ajde.getDefault().enableLogging( System.out );
		} catch (Throwable t) {
			t.printStackTrace();
			Ajde.getDefault().getErrorHandler().handleError(
				"Null IDE failed to initialize.",
				t);
		}
	}
================= fetch public EclipseShadow(EclipseFactory world, Kind kind, Member signature, AstNode 56cc4f2^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java

================= fetch public Member getEnclosingCodeSignature() { 56cc4f2^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java

public Member getEnclosingCodeSignature() {
		return world.makeResolvedMember(enclosingMethod.binding);
	}
================= fetch public TypeX getEnclosingType() { 56cc4f2^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java

public TypeX getEnclosingType() {
		return world.fromBinding(enclosingMethod.binding.declaringClass);
	}
================= fetch public static EclipseShadow makeShadow(EclipseFactory world, AstNode astNode, 56cc4f2^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java
// --- factory methods
public static EclipseShadow makeShadow(EclipseFactory world, AstNode astNode, 
							ReferenceContext context)
	{
		//XXX make sure we're getting the correct declaring type at call-site
		if (astNode instanceof AllocationExpression) {
			AllocationExpression e = (AllocationExpression)astNode;
			return new EclipseShadow(world, Shadow.ConstructorCall,
					world.makeResolvedMember(e.binding), astNode, context);
		} else if (astNode instanceof MessageSend) {
			MessageSend e = (MessageSend)astNode;
			return new EclipseShadow(world, Shadow.MethodCall,
					world.makeResolvedMember(e.binding), astNode, context);
		} else if (astNode instanceof ExplicitConstructorCall) {
			//??? these need to be ignored, they don't have shadows
			return null;
//			ExplicitConstructorCall e = (ExplicitConstructorCall)astNode;
//			return new EclipseShadow(world, Shadow.MethodCall,
//					world.makeResolvedMember(e.binding), astNode, context);					
		} else if (astNode instanceof AbstractMethodDeclaration) {
			AbstractMethodDeclaration e = (AbstractMethodDeclaration)astNode;
			Shadow.Kind kind;
			if (e instanceof AdviceDeclaration) {
				kind = Shadow.AdviceExecution;
			} else if (e instanceof InterTypeMethodDeclaration) {
				return new EclipseShadow(world, Shadow.MethodExecution,
					((InterTypeDeclaration)e).getSignature(), astNode, context);
			} else if (e instanceof InterTypeConstructorDeclaration) {
				return new EclipseShadow(world, Shadow.ConstructorExecution,
					((InterTypeDeclaration)e).getSignature(), astNode, context);
			} else if (e instanceof InterTypeFieldDeclaration) {
				return null;
			} else if (e instanceof MethodDeclaration) {
				kind = Shadow.MethodExecution;
			} else if (e instanceof ConstructorDeclaration) {
				kind = Shadow.ConstructorExecution;
			} else {
				throw new RuntimeException("unimplemented: " + e);
			}
			return new EclipseShadow(world, kind,
					world.makeResolvedMember(e.binding), astNode, context);
		} else {
			throw new RuntimeException("unimplemented: " + astNode);
		}		
	}
================= fetch public void unhandledException( 56cc4f2^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java

public void unhandledException(
		TypeBinding exceptionType,
		AstNode location)
	{
		if (!world.getWorld().getDeclareSoft().isEmpty()) {
			Shadow callSite = world.makeShadow(location, referenceContext);
			if (callSite == null) {
				super.unhandledException(exceptionType, location);
				return;
			}
			Shadow enclosingExec = world.makeShadow(referenceContext);
	//		System.err.println("about to show error for unhandled exception: "  + exceptionType + 
	//				" at " + location + " in " + referenceContext);
			
			
			for (Iterator i = world.getWorld().getDeclareSoft().iterator(); i.hasNext(); ) {
				DeclareSoft d = (DeclareSoft)i.next();
				FuzzyBoolean match = d.getPointcut().match(callSite);
				if (match.alwaysTrue()) {
					//System.err.println("matched callSite: "  + callSite + " with " + d);
					return;
				} else if (!match.alwaysFalse()) {
					throw new RuntimeException("unimplemented, shouldn't have fuzzy match here");
				}
				
				match = d.getPointcut().match(enclosingExec);
				if (match.alwaysTrue()) {
					//System.err.println("matched enclosingExec: "  + enclosingExec + " with " + d);
					return;
				} else if (!match.alwaysFalse()) {
					throw new RuntimeException("unimplemented, shouldn't have fuzzy match here");
				}
			}
		}
		
		//??? is this always correct
		if (location instanceof Proceed) {
			return;
		}

		super.unhandledException(exceptionType, location);
	}
================= fetch public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) { 7746fcb^:weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java

public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {
		//make this remap from formal positions to arrayIndices
		IntMap entryBindings = new IntMap();
		for (int i=0, len=freeVars.length; i < len; i++) {
			int freeVar = freeVars[i];
			//int formalIndex = bindings.get(freeVar);
			entryBindings.put(freeVar, i);
		}
		entryBindings.copyContext(bindings);
		//System.out.println(this + " bindings: " + entryBindings);
		
		World world = inAspect.getWorld();
		
		Pointcut concreteEntry;
		
		CrosscuttingMembers xcut = bindings.getConcreteAspect().crosscuttingMembers;		
		Collection previousCflowEntries = xcut.getCflowEntries();
		
		entryBindings.pushEnclosingDefinition(CFLOW_MARKER);
		try {
			concreteEntry = entry.concretize(inAspect, entryBindings);
		} finally {
			entryBindings.popEnclosingDefinitition();
		}

		List innerCflowEntries = new ArrayList(xcut.getCflowEntries());
		innerCflowEntries.removeAll(previousCflowEntries);

		
		ResolvedMember cflowField = new ResolvedMember(
			Member.FIELD, inAspect, Modifier.STATIC | Modifier.PUBLIC | Modifier.FINAL,
					NameMangler.cflowStack(xcut), 
					TypeX.forName(NameMangler.CFLOW_STACK_TYPE).getSignature());
					
		// add field and initializer to inAspect
		//XXX and then that info above needs to be mapped down here to help with
		//XXX getting the exposed state right
		bindings.getConcreteAspect().crosscuttingMembers.addConcreteShadowMunger(
				Advice.makeCflowEntry(world, concreteEntry, isBelow, cflowField, freeVars.length, innerCflowEntries));
		
		bindings.getConcreteAspect().crosscuttingMembers.addTypeMunger(
			world.makeCflowStackFieldAdder(cflowField));
			
			
		List slots = new ArrayList();
		for (int i=0, len=freeVars.length; i < len; i++) {
			int freeVar = freeVars[i];
			int formalIndex = bindings.get(freeVar);
			ResolvedTypeX formalType =
				bindings.getAdviceSignature().getParameterTypes()[formalIndex].resolve(world);
			
			ConcreteCflowPointcut.Slot slot = 
				new ConcreteCflowPointcut.Slot(formalIndex, formalType, i);
			slots.add(slot);
		}
		
		return new ConcreteCflowPointcut(cflowField, slots);
	}
Progress : [##########################################--] 106%================= fetch public EclipseTypeMunger makeEclipseTypeMunger(ConcreteTypeMunger concrete) { db37189^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java

public EclipseTypeMunger makeEclipseTypeMunger(ConcreteTypeMunger concrete) {
		if (concrete instanceof EclipseTypeMunger) return (EclipseTypeMunger)concrete;
		if (EclipseTypeMunger.supportsKind(concrete.getMunger().getKind())) {
			return new EclipseTypeMunger(this, concrete.getMunger(), concrete.getAspectType(), null);
		} else {
			return null;
		}
	}
================= fetch public void weaveAroundInline( 0fb5f69^:weaver/src/org/aspectj/weaver/bcel/BcelShadow.java

void weaveAroundInline(
    	BcelAdvice munger,
    	boolean hasDynamicTest)
	{
		/* Implementation notes:
		 * 
		 * AroundInline still extracts the instructions of the original shadow into 
		 * an extracted method.  This allows inlining of even that advice that doesn't
		 * call proceed or calls proceed more than once. 
		 * 
		 * It extracts the instructions of the original shadow into a method.
		 * 
		 * Then it inlines the instructions of the advice in its place, taking care
		 * to treat the closure argument specially (it doesn't exist).
		 * 
		 * Then it searches in the instructions of the advice for any call to the
		 * proceed method.
		 * 
		 *   At such a call, there is stuff on the stack representing the arguments to
		 *   proceed.  Pop these into the frame.
		 * 
		 *   Now build the stack for the call to the extracted method, taking values 
		 *   either from the join point state or from the new frame locs from proceed.
		 *   Now call the extracted method.  The right return value should be on the
		 *   stack, so no cast is necessary.
		 *
		 * If only one call to proceed is made, we can re-inline the original shadow.
		 * We are not doing that presently.
		 */
		 
		// !!! THIS BLOCK OF CODE SHOULD BE IN A METHOD CALLED weaveAround(...);
        Member mungerSig = munger.getSignature();
        ResolvedTypeX declaringType = world.resolve(mungerSig.getDeclaringType());
        //??? might want some checks here to give better errors
        BcelObjectType ot = BcelWorld.getBcelObjectType(declaringType); 
        
		LazyMethodGen adviceMethod = ot.getLazyClassGen().getLazyMethodGen(mungerSig);
		if (!adviceMethod.getCanInline()) {
			weaveAroundClosure(munger, hasDynamicTest);
			return;
		}
		
		
		
		// start by exposing various useful things into the frame
		final InstructionFactory fact = getFactory();
		
		// now generate the aroundBody method
        LazyMethodGen extractedMethod = 
        	extractMethod(
        		NameMangler.aroundCallbackMethodName(
        			getSignature(),
        			getEnclosingClass()));
    
    	// the shadow is now empty.  First, create a correct call
    	// to the around advice.  This includes both the call (which may involve 
    	// value conversion of the advice arguments) and the return
    	// (which may involve value conversion of the return value).  Right now
    	// we push a null for the unused closure.  It's sad, but there it is.
    	    	
    	InstructionList advice = new InstructionList();
        InstructionHandle adviceMethodInvocation;
        {
        	// ??? we don't actually need to push NULL for the closure if we take care
		    advice.append(munger.getAdviceArgSetup(this, null, new InstructionList(fact.ACONST_NULL)));
		    adviceMethodInvocation =
		        advice.append(
		        	Utility.createInvoke(fact, getWorld(), munger.getSignature()));
			advice.append(
		        Utility.createConversion(
		            getFactory(), 
		            world.makeBcelType(munger.getSignature().getReturnType()), 
		            extractedMethod.getReturnType()));
		    if (! isFallsThrough()) {
		        advice.append(fact.createReturn(extractedMethod.getReturnType()));
		    }
        }
        
		// now, situate the call inside the possible dynamic tests,
		// and actually add the whole mess to the shadow
        if (! hasDynamicTest) {
            range.append(advice);
        } else {
        	InstructionList afterThingie = new InstructionList(fact.NOP);
            InstructionList callback = makeCallToCallback(extractedMethod);
            if (terminatesWithReturn()) {
                callback.append(fact.createReturn(extractedMethod.getReturnType()));
            } else {
            	//InstructionHandle endNop = range.insert(fact.NOP, Range.InsideAfter);
                advice.append(fact.createBranchInstruction(Constants.GOTO, afterThingie.getStart()));
            }
            range.append(munger.getTestInstructions(this, advice.getStart(), callback.getStart(), advice.getStart()));
            range.append(advice);
            range.append(callback);
            range.append(afterThingie);          
        }        
        
        // now the range contains everything we need.  We now inline the advice method.

				
        BcelClassWeaver.inlineMethod(adviceMethod, enclosingMethod, adviceMethodInvocation);

        // now search through the advice, looking for a call to PROCEED.  
        // Then we replace the call to proceed with some argument setup, and a 
        // call to the extracted method.
        String proceedName = 
        	NameMangler.proceedMethodName(munger.getSignature().getName());

        InstructionHandle curr = getRange().getStart();
        InstructionHandle end = getRange().getEnd();
        ConstantPoolGen cpg = extractedMethod.getEnclosingClass().getConstantPoolGen();
        while (curr != end) {
			InstructionHandle next = curr.getNext();
			Instruction inst = curr.getInstruction();
			if ((inst instanceof INVOKESTATIC)
					&& proceedName.equals(((INVOKESTATIC) inst).getMethodName(cpg))) {

					
				enclosingMethod.getBody().append(curr, getRedoneProceedCall(fact, extractedMethod, munger));
				Utility.deleteInstruction(curr, enclosingMethod);
			}
			curr = next;
        }
        // and that's it.
	}
================= fetch public static Instruction createInstanceof(InstructionFactory fact, ObjectType t ae0ef30^:weaver/src/org/aspectj/weaver/bcel/Utility.java

public static Instruction createInstanceof(InstructionFactory fact, ObjectType t) {
        return new INSTANCEOF(fact.getConstantPool().addClass(t));        
    }
================= fetch public static Instruction createInvoke( ae0ef30^:weaver/src/org/aspectj/weaver/bcel/Utility.java
// ??? these should perhaps be cached.  Remember to profile this to see if it's a problem.
public static String[] makeArgNames(int n) {
        String[] ret = new String[n];
        for (int i=0; i<n; i++) {
            ret[i] = "arg" + i;
        }
        return ret;
    }
================= fetch public void visit(Instanceof i) { ae0ef30^:weaver/src/org/aspectj/weaver/bcel/BcelRenderer.java

public void visit(Instanceof i) {
        instructions.insert(createJumpBasedOnBooleanOnStack());
        instructions.insert(
            Utility.createInstanceof(fact, (ObjectType) world.makeBcelType(i.getType())));
        i.getVar().accept(this);
    }
================= fetch public TypeX lookupType(String name, IHasPosition location) { 0a175d2^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseScope.java

private ResolvedTypeX resolveVisible(String name) {
		ResolvedTypeX found = world.resolve(TypeX.forName(name), true);
		if (found == ResolvedTypeX.MISSING) return found;
		if (ResolvedTypeX.isVisible(found.getModifiers(), found, enclosingType)) return found;
		return ResolvedTypeX.MISSING; 
	}
================= fetch private static String makeVisibilityName(int modifiers, TypeX aspectType) { d1e5c0a^:weaver/src/org/aspectj/weaver/NameMangler.java

private static String makeVisibilityName(int modifiers, TypeX aspectType) {
		if (Modifier.isPrivate(modifiers)) {
			return getOutermostType(aspectType).getNameAsIdentifier();
		} else if (Modifier.isProtected(modifiers)) {
			throw new RuntimeException("protected inter-types not allowed");
		} else if (Modifier.isPublic(modifiers)) {
			return "";
		} else {
			return aspectType.getPackageNameAsIdentifier();
		}
	}
================= fetch public FuzzyBoolean match(Shadow shadow) { d1e5c0a^:weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java

public FuzzyBoolean match(Shadow shadow) {
		TypeX enclosingType = shadow.getEnclosingType();
//		if (shadow.getKind() == Shadow.FieldSet) {
//			System.err.println("within?" + type  + " matches " + enclosingType + " on " + shadow);
//		}
		
		while (enclosingType != null) {
			if (type.matchesStatically(shadow.getIWorld().resolve(enclosingType))) {
				return FuzzyBoolean.YES;
			}
			enclosingType = enclosingType.getDeclaringType();
		}
		return FuzzyBoolean.NO;
	}
================= fetch public List getInterTypeMungers() { d1e5c0a^:weaver/src/org/aspectj/weaver/ResolvedTypeX.java

public List getInterTypeMungers() {
		return interTypeMungers;
	}
================= fetch public TypeX getDeclaringType() { d1e5c0a^:weaver/src/org/aspectj/weaver/TypeX.java
/**
     * Returns a TypeX object representing the declaring type of this type, or
     * null if this type does not represent a non-package-level-type.
     * 
     * <strong>Warning</strong>:  This is guaranteed to work for all member types.
     * For anonymous/local types, the only guarantee is given in JLS 13.1, where
     * it guarantees that if you call getDeclaringType() repeatedly, you will eventually
     * get the top-level class, but it does not say anything about classes in between.
     *
     * @return the declaring TypeX object, or null.
     */
public TypeX getDeclaringType() {
    	if (isArray()) return null;
		String name = getName();
		int lastDollar = name.lastIndexOf('$');
		if (lastDollar != -1) {
        	return TypeX.forName(name.substring(0, lastDollar));
		} else {
			return null;
		}
    }
================= fetch public final boolean isArray() { d1e5c0a^:weaver/src/org/aspectj/weaver/TypeX.java
/**
     * Determins if this represents an array type.
     *
     * @return  true iff this represents an array type.
     */
public final boolean isArray() {
        return signature.startsWith("[");
    }
================= fetch public static String protectedDispatchMethod(TypeX classType, String name) d1e5c0a^:weaver/src/org/aspectj/weaver/NameMangler.java
/**
	 * This static method goes on the target class of the inter-type method.
	 */
public static String protectedDispatchMethod(TypeX classType, String name) 
	{
		return makeName("protectedDispatch",
					classType.getNameAsIdentifier(), name);
	}
================= fetch public static boolean isVisible(int modifiers, ResolvedTypeX targetType, Resolve d1e5c0a^:weaver/src/org/aspectj/weaver/ResolvedTypeX.java

public static boolean isVisible(int modifiers, ResolvedTypeX targetType, ResolvedTypeX fromType) {
		//System.err.println("mod: " + modifiers + ", " + targetType + " and " + fromType);
		
		if (Modifier.isPublic(modifiers)) {
			return true;
		} else if (Modifier.isPrivate(modifiers)) {
			return getOutermostType(targetType).equals(getOutermostType(fromType));
		} else if (Modifier.isProtected(modifiers)) {
			return samePackage(targetType, fromType) || targetType.isAssignableFrom(fromType);
		} else { // package-visible
			return samePackage(targetType, fromType);
		}	
	}
================= fetch public void testNameAndSigWithInners() { d1e5c0a^:weaver/testsrc/org/aspectj/weaver/TypeXTestCase.java

public void testNameAndSigWithInners() {
    	TypeX t = TypeX.forName("java.util.Map$Entry");
    	assertEquals(t.getName(), "java.util.Map$Entry");
    	assertEquals(t.getSignature(), "Ljava/util/Map$Entry;");
    	assertEquals(t.getDeclaringType(), TypeX.forName("java.util.Map"));
    	assertNull(TypeX.forName("java.util.Map").getDeclaringType());
    }
Progress : [##########################################--] 107%================= fetch public String toString() { cb77524^:weaver/src/org/aspectj/weaver/patterns/IfPointcut.java

public String toString() {
		return "if(" + testMethod + ")";
	}
================= fetch public Test findResidue(Shadow shadow, ExposedState state) { cb77524^:weaver/src/org/aspectj/weaver/patterns/IfPointcut.java

public Test findResidue(Shadow shadow, ExposedState state) {
		if (findingResidue) return Literal.TRUE;
		findingResidue = true;
		try {
			ExposedState myState = new ExposedState(baseArgsCount);
			//System.out.println(residueSource);
			//??? some of these tests are preconditions for the if to run correctly
			//    this implementation will duplicate those tests, we should be more careful
			Test preTest = residueSource.findResidue(shadow, myState); // might need this
			
			//System.out.println(myState);
			
			List args = new ArrayList();
	        for (int i=0; i < baseArgsCount; i++) {
	        	args.add(myState.get(i));
	        }
	
	        // handle thisJoinPoint parameters
	        if ((extraParameterFlags & Advice.ThisJoinPoint) != 0) {
	        	args.add(shadow.getThisJoinPointVar());
	        }
	        
	        if ((extraParameterFlags & Advice.ThisJoinPointStaticPart) != 0) {
	        	args.add(shadow.getThisJoinPointStaticPartVar());
	        }
	        
	        if ((extraParameterFlags & Advice.ThisEnclosingJoinPointStaticPart) != 0) {
	        	args.add(shadow.getThisEnclosingJoinPointStaticPartVar());
	        }
			Test myTest = Test.makeCall(testMethod, (Expr[])args.toArray(new Expr[args.size()]));
			return Test.makeAnd(preTest, myTest);
			
		} finally {
			findingResidue = false;
		}
	}
================= fetch public FuzzyBoolean match(Shadow shadow) { 19c3e16^:weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java

public FuzzyBoolean match(Shadow shadow) {
		
		
		if (shadow.getKind() != kind) return FuzzyBoolean.NO;
		
		if (!signature.matches(shadow.getSignature(), shadow.getIWorld())) return  FuzzyBoolean.NO;

		return  FuzzyBoolean.YES;
	}
================= fetch public boolean matches(Member member, World world) { 19c3e16^:weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java

public boolean matches(Member member, World world) {
		//XXX performance gains would come from matching on name before resolving
		//    to fail fast
		ResolvedMember sig = member.resolve(world);
		if (sig == null) {
			//XXX
			if (member.getName().startsWith(NameMangler.PREFIX)) {
				return false;
			}
			world.getLint().unresolvableMember.signal(member.toString(), getSourceLocation());
			return false;
		}
		if (!modifiers.matches(sig.getModifiers())) return false;
		
		if (kind == Member.STATIC_INITIALIZATION) {
			//System.err.println("match static init: " + sig.getDeclaringType() + " with " + this);
			return declaringType.matchesStatically(sig.getDeclaringType().resolve(world));
		} else if (kind == Member.FIELD) {
			
			if (!returnType.matchesStatically(sig.getReturnType().resolve(world))) return false;
			if (!name.matches(sig.getName())) return false;
			boolean ret = declaringTypeMatch(member.getDeclaringType(), member, world);
			//System.out.println("   ret: " + ret);
			return ret;
		} else if (kind == Member.METHOD) {
			if (!returnType.matchesStatically(sig.getReturnType().resolve(world))) return false;
			if (!name.matches(sig.getName())) return false;
			if (!parameterTypes.matches(world.resolve(sig.getParameterTypes()), TypePattern.STATIC).alwaysTrue()) {
				return false;
			}
			if (!throwsPattern.matches(sig.getExceptions(), world)) return false;
			return declaringTypeMatch(member.getDeclaringType(), member, world);
		} else if (kind == Member.CONSTRUCTOR) {
			if (!parameterTypes.matches(world.resolve(sig.getParameterTypes()), TypePattern.STATIC).alwaysTrue()) {
				return false;
			}
			if (!throwsPattern.matches(sig.getExceptions(), world)) return false;
			return declaringType.matchesStatically(member.getDeclaringType().resolve(world));
			//return declaringTypeMatch(member.getDeclaringType(), member, world);			
		}
		
		return false;
	}
================= fetch boolean isRef(Expression expr, Binding binding) { d15eb32^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java

boolean isRef(Expression expr, Binding binding) {
		//System.err.println("isRef: " + expr + ", " + binding);
		return expr != null
			&& expr instanceof NameReference
			&& isRef((NameReference) expr, binding);
	}
================= fetch boolean isRef(NameReference ref, Binding binding) { d15eb32^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java

boolean isRef(NameReference ref, Binding binding) {
		return ref.binding == binding;
	}
================= fetch private void replaceEffectivelyStaticRef(MessageSend call) { d15eb32^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java

private void replaceEffectivelyStaticRef(MessageSend call) {
		//System.err.println("replace static ref");
		NameReference receiver = (NameReference) call.receiver;
		receiver.binding = thisJoinPointStaticPartDecLocal; //thisJoinPointStaticPartDec;
		receiver.codegenBinding = thisJoinPointStaticPartDecLocal;

		call.binding.declaringClass =
			(ReferenceBinding) thisJoinPointStaticPartDec.type;
	}
================= fetch public void computeJoinPointParams() { d15eb32^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java

public void computeJoinPointParams() {
		// walk my body to see what is needed
		method.traverse(this, (ClassScope) null);

		//??? add support for option to disable this optimization
		//System.err.println("check:  "+ hasEffectivelyStaticRef + ", " + needsDynamic);
		if (hasEffectivelyStaticRef && !needsDynamic) {
			// replace effectively static refs with thisJoinPointStaticPart
			replaceEffectivelyStaticRefs = true;
			needsStatic = true;
			method.traverse(this, (ClassScope) null);
		}
	}
================= fetch public void endVisit(SingleNameReference ref, BlockScope scope) { d15eb32^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java

public void endVisit(SingleNameReference ref, BlockScope scope) {
		if (isRef(ref, thisJoinPointDec))
			needsDynamic = true;
================= fetch private AjAttribute makeAttribute(EclipseWorld world) { 3e2801a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeConstructorDeclaration.java

private AjAttribute makeAttribute(EclipseWorld world) {
		if (explicitConstructorCall != null && !(explicitConstructorCall.binding instanceof ProblemMethodBinding)) {
			MethodBinding explicitConstructor = explicitConstructorCall.binding;
			if (explicitConstructor.alwaysNeedsAccessMethod()) {
				explicitConstructor = explicitConstructor.getAccessMethod();
			}
			
			
			((NewConstructorTypeMunger)munger).setExplicitConstructor(
				world.makeResolvedMember(explicitConstructor));
		} else {
			((NewConstructorTypeMunger)munger).setExplicitConstructor(
				new ResolvedMember(Member.CONSTRUCTOR, 
					EclipseWorld.fromBinding(onTypeBinding.superclass()),
					0, ResolvedTypeX.VOID, "<init>", TypeX.NONE));
		}
		return new AjAttribute.TypeMunger(munger);
	}
================= fetch private MethodDeclaration makePreMethod(ClassScope scope, 3e2801a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeConstructorDeclaration.java

private MethodDeclaration makePreMethod(ClassScope scope, 
											ExplicitConstructorCall explicitConstructorCall)
	{
		EclipseWorld world = EclipseWorld.fromScopeLookupEnvironment(scope);
		
		TypeX aspectTypeX = EclipseWorld.fromBinding(binding.declaringClass);
		TypeX targetTypeX = EclipseWorld.fromBinding(onTypeBinding);
		
		ArrayBinding objectArrayBinding = scope.createArray(scope.getJavaLangObject(), 1);
		
		
		MethodDeclaration pre = new MethodDeclaration(compilationResult);
		pre.modifiers = AccPublic | AccStatic;
		pre.returnType = AstUtil.makeTypeReference(objectArrayBinding);
		pre.selector = NameMangler.postIntroducedConstructor(aspectTypeX, targetTypeX).toCharArray();
		
		
		pre.arguments = AstUtil.copyArguments(this.arguments);
		
		//XXX should do exceptions
		
		pre.scope = new MethodScope(scope, pre, true);
		//??? do we need to do anything with scope???
		
		pre.binding = world.makeMethodBinding(
			AjcMemberMaker.preIntroducedConstructor(aspectTypeX, targetTypeX, 
					world.fromBindings(binding.parameters)));
		
		pre.bindArguments();
		pre.bindThrownExceptions();
		
		
		if (explicitConstructorCall == null) {
			pre.statements = new Statement[] {};
		} else {
			pre.statements = new Statement[] {
				explicitConstructorCall
			};
		}
		
		InterTypeScope newParent =
			new InterTypeScope(scope, onTypeBinding);
		pre.scope.parent = newParent;

		pre.resolveStatements(newParent);
		
		
		
		int nParams = pre.arguments.length;
		MethodBinding explicitConstructor = null;
		if (explicitConstructorCall != null) {
			explicitConstructor = explicitConstructorCall.binding;
			if (explicitConstructor.alwaysNeedsAccessMethod()) {
				explicitConstructor = explicitConstructor.getAccessMethod();
			}
		}
		
		int nExprs;
		if (explicitConstructor == null) nExprs = 0;
		else nExprs = explicitConstructor.parameters.length;
		
		
		ArrayInitializer init = new ArrayInitializer();
		init.expressions = new Expression[nExprs + nParams];
		int index = 0;
		for (int i=0; i < nExprs; i++) {
			if (i >= explicitConstructorCall.arguments.length) {
				init.expressions[index++] = new NullLiteral(0, 0);
				continue;
			}
			
			
			Expression arg = explicitConstructorCall.arguments[i];
			ResolvedMember conversionMethod = 
				AjcMemberMaker.toObjectConversionMethod(world.fromBinding(explicitConstructorCall.binding.parameters[i]));
			if (conversionMethod != null) {
				arg = new KnownMessageSend(world.makeMethodBindingForCall(conversionMethod),
					new CastExpression(new NullLiteral(0, 0), 
						AstUtil.makeTypeReference(world.makeTypeBinding(AjcMemberMaker.CONVERSIONS_TYPE))),
				    new Expression[] {arg });
			}
			init.expressions[index++] = arg;
		}
		
		for (int i=0; i < nParams; i++) {
			LocalVariableBinding binding = pre.arguments[i].binding;
			Expression arg = AstUtil.makeResolvedLocalVariableReference(binding);
			ResolvedMember conversionMethod = 
				AjcMemberMaker.toObjectConversionMethod(world.fromBinding(binding.type));
			if (conversionMethod != null) {
				arg = new KnownMessageSend(world.makeMethodBindingForCall(conversionMethod),
					new CastExpression(new NullLiteral(0, 0), 
						AstUtil.makeTypeReference(world.makeTypeBinding(AjcMemberMaker.CONVERSIONS_TYPE))),
				    new Expression[] {arg });
			}
			init.expressions[index++] = arg;
		}
		
		init.binding =objectArrayBinding;
		
		ArrayAllocationExpression newArray = new ArrayAllocationExpression();
		newArray.initializer = init;
		newArray.type = AstUtil.makeTypeReference(scope.getJavaLangObject());
		newArray.dimensions = new Expression[1];
		newArray.constant = NotAConstant;
		

		
		
		pre.statements = new Statement[] {
			new ReturnStatement(newArray, 0, 0),
		};
		return pre;
	}
================= fetch public InterTypeMethodBinding(EclipseWorld world, ResolvedMember signature, Type 3e2801a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMethodBinding.java

================= fetch public boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invocationSi 3e2801a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMethodBinding.java
//XXX this is identical to InterTypeFieldBinding
public boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invocationSite, Scope scope) {
		if (isPublic()) return true;	
	
		SourceTypeBinding invocationType = scope.invocationType();
		//System.out.println("receiver: " + receiverType + ", " + invocationType);
		
		if (invocationType == declaringClass) return true;
	
	
	//	if (invocationType.isPrivileged) {
	//		System.out.println("privileged access to: " + this);
	//		return true;
	//	}
		
		if (isProtected()) {
			throw new RuntimeException("unimplemented");
		}
	
		//XXX make sure this walks correctly
		if (isPrivate()) {
			// answer true if the receiverType is the declaringClass
			// AND the invocationType and the declaringClass have a common enclosingType
			//if (receiverType != declaringClass) return false;
	
			if (invocationType != declaringClass) {
				ReferenceBinding outerInvocationType = invocationType;
				ReferenceBinding temp = outerInvocationType.enclosingType();
				while (temp != null) {
					outerInvocationType = temp;
					temp = temp.enclosingType();
				}
	
				ReferenceBinding outerDeclaringClass = declaringClass;
				temp = outerDeclaringClass.enclosingType();
				while (temp != null) {
					outerDeclaringClass = temp;
					temp = temp.enclosingType();
				}
				
				//System.err.println("outer dec: " + 
				if (outerInvocationType != outerDeclaringClass) return false;
			}
			return true;
		}
	
		// isDefault()
		if (invocationType.fPackage == declaringClass.fPackage) return true;
		return false;
	}
================= fetch public final int sourceStart() { 3e2801a^:org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java
/**
	 * Subtypes can override this to return true if an access method should be
	 * used when referring to this method binding.  Currently used
	 * for AspectJ's inter-type method declarations.
	 */
public boolean alwaysNeedsAccessMethod() { return false; }
================= fetch public void endVisit(MessageSend call, BlockScope scope) { 3e2801a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/SuperFixerVisitor.java

public void endVisit(MessageSend call, BlockScope scope) {
		//System.out.println("endVisit: " + call);
		// an error has already occurred
		if (call.codegenBinding == null) return; 
		
		MethodBinding superBinding = call.codegenBinding;
		if (superBinding instanceof ProblemMethodBinding) {
			return;
		}
		char[] accessName;
		if (call.isSuperAccess() && !call.binding.isStatic()) {
			call.receiver = new ThisReference();
			accessName =
				NameMangler.superDispatchMethod(EclipseWorld.fromBinding(targetClass), 
							new String(superBinding.selector)).toCharArray();
		} else if (call.receiver.isThis() && call.binding.isProtected() && !call.binding.isStatic()) {
			//XXX this is a hack that violates some binary compatibility rules
			if (superBinding.declaringClass.equals(targetClass)) {
				accessName =
					NameMangler.protectedDispatchMethod(EclipseWorld.fromBinding(targetClass), 
								new String(superBinding.selector)).toCharArray();
			} else {
				accessName =
				NameMangler.superDispatchMethod(EclipseWorld.fromBinding(targetClass), 
							new String(superBinding.selector)).toCharArray();
			}
		} else {
			return;
		}
		
		//??? do we want these to be unique
		MethodBinding superAccessBinding =
			new MethodBinding(AstNode.AccPublic, accessName, 
			superBinding.returnType, superBinding.parameters, superBinding.thrownExceptions,
			targetClass);
		
		call.codegenBinding = superAccessBinding;
		
		ResolvedMember targetMember = EclipseWorld.makeResolvedMember(superBinding);
		superMethodsCalled.add(targetMember);
	}
================= fetch public void manageSyntheticAccessIfNecessary(BlockScope currentScope) { 3e2801a^:org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java

public void manageSyntheticAccessIfNecessary(BlockScope currentScope) {
		if (binding.alwaysNeedsAccessMethod()) {
			syntheticAccessor = binding.getAccessMethod();
			return;
		}
		

		if (binding.isPrivate()
			&& (currentScope.enclosingSourceType() != binding.declaringClass)) {

			if (currentScope
				.environment()
				.options
				.isPrivateConstructorAccessChangingVisibility) {
				binding.tagForClearingPrivateModifier();
				// constructor will not be dumped as private, no emulation required thus
			} else {
				syntheticAccessor =
					((SourceTypeBinding) binding.declaringClass).addSyntheticMethod(binding);
				currentScope.problemReporter().needToEmulateMethodAccess(binding, this);
			}
		}
	}
================= fetch public void manageSyntheticAccessIfNecessary(BlockScope currentScope) { 3e2801a^:org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java

public void manageSyntheticAccessIfNecessary(BlockScope currentScope) {
		if (binding.alwaysNeedsAccessMethod()) {
			syntheticAccessor = binding.getAccessMethod();
			return;
		}
		
		// perform some emulation work in case there is some and we are inside a local type only
		if (binding.isPrivate() && (accessMode != This)) {

			if (currentScope
				.environment()
				.options
				.isPrivateConstructorAccessChangingVisibility) {
				binding.tagForClearingPrivateModifier();
				// constructor will not be dumped as private, no emulation required thus
			} else {
				syntheticAccessor =
					((SourceTypeBinding) binding.declaringClass).addSyntheticMethod(binding);
				currentScope.problemReporter().needToEmulateMethodAccess(binding, this);
			}
		}
	}
================= fetch public void manageSyntheticAccessIfNecessary(BlockScope currentScope){ 3e2801a^:org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java

public void manageSyntheticAccessIfNecessary(BlockScope currentScope){
	if (binding.alwaysNeedsAccessMethod()) {
		syntheticAccessor = binding.getAccessMethod();
		return;
	}


	if (binding.isPrivate()){

		// depth is set for both implicit and explicit access (see MethodBinding#canBeSeenBy)		
		if (currentScope.enclosingSourceType() != binding.declaringClass){
		
			syntheticAccessor = ((SourceTypeBinding)binding.declaringClass).addSyntheticMethod(binding);
			currentScope.problemReporter().needToEmulateMethodAccess(binding, this);
			return;
		}

	} else if (receiver instanceof QualifiedSuperReference){ // qualified super

		// qualified super need emulation always
		SourceTypeBinding destinationType = (SourceTypeBinding)(((QualifiedSuperReference)receiver).currentCompatibleType);
		syntheticAccessor = destinationType.addSyntheticMethod(binding);
		currentScope.problemReporter().needToEmulateMethodAccess(binding, this);
		return;

	} else if (binding.isProtected()){

		SourceTypeBinding enclosingSourceType;
		if (((bits & DepthMASK) != 0) 
				&& binding.declaringClass.getPackage() 
					!= (enclosingSourceType = currentScope.enclosingSourceType()).getPackage()){

			SourceTypeBinding currentCompatibleType = (SourceTypeBinding)enclosingSourceType.enclosingTypeAt((bits & DepthMASK) >> DepthSHIFT);
			syntheticAccessor = currentCompatibleType.addSyntheticMethod(binding);
			currentScope.problemReporter().needToEmulateMethodAccess(binding, this);
			return;
		}
	}
	// if the binding declaring class is not visible, need special action
	// for runtime compatibility on 1.2 VMs : change the declaring class of the binding
	// NOTE: from 1.4 on, method's declaring class is touched if any different from receiver type
	// and not from Object or implicit static method call.	
	if (binding.declaringClass != this.qualifyingType
		&& !this.qualifyingType.isArrayType()
		&& ((currentScope.environment().options.complianceLevel >= CompilerOptions.JDK1_4
				&& (receiver != ThisReference.ThisImplicit || !binding.isStatic())
				&& binding.declaringClass.id != T_Object) // no change for Object methods
			|| !binding.declaringClass.canBeSeenBy(currentScope))) {

		this.codegenBinding = currentScope.enclosingSourceType().getUpdatedMethodBinding(binding, (ReferenceBinding) this.qualifyingType);
	}
}
================= fetch pointcut runtimeHandlers(): mainExecution() 85a827a^:ajde/testdata/examples/figures-coverage/figures/Figure.java

================= fetch private String getFormattedOptionsString(BuildOptionsAdapter buildOptions, Proje 85a827a^:ajde/src/org/aspectj/ajde/internal/AspectJBuildManager.java

private String getFormattedOptionsString(BuildOptionsAdapter buildOptions, ProjectPropertiesAdapter properties) {
			return "Building with settings: "
				+ "\n-> output path: " + properties.getOutputPath()
				+ "\n-> classpath: " + properties.getClasspath()
				+ "\n-> bootclasspath: " + properties.getBootClasspath()
				+ "\n-> non-standard options: " + buildOptions.getNonStandardOptions()
				+ "\n-> porting mode: " + buildOptions.getPortingMode()
				+ "\n-> source 1.4 mode: " + buildOptions.getSourceOnePointFourMode()
				+ "\n-> strict spec mode: " + buildOptions.getStrictSpecMode()
				+ "\n-> lenient spec mode: " + buildOptions.getLenientSpecMode()
				+ "\n-> use javac mode: " + buildOptions.getUseJavacMode()
				+ "\n-> preprocess mode: " + buildOptions.getPreprocessMode()
				+ "\n-> working dir: " + buildOptions.getWorkingOutputPath();
		}
================= fetch private void setBooleanOptionVal(String name, boolean value) { 85a827a^:ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java

private void setBooleanOptionVal(String name, boolean value) {
		if (value) {
			preferencesAdapter.setProjectPreference(name, "true");
		} else {
			preferencesAdapter.setProjectPreference(name, "false");
		}
	}
================= fetch public AjBuildConfig genBuildConfig(String configFile) { 85a827a^:ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java

public AjBuildConfig genBuildConfig(String configFile) {
	    AjBuildConfig buildConfig = new AjBuildConfig();
	    File config = new File(configFile);
        if (!config.exists()) {
            Ajde.getDefault().getErrorHandler().handleWarning("Config file \"" + configFile + "\" does not exist."); 
        } else {
	        ConfigParser configParser = new ConfigParser();
	        configParser.parseConfigFile(config);
			buildConfig.setFiles(configParser.getFiles());
			buildConfig.setConfigFile(config);
        }
		
		String classpathString = 
			Ajde.getDefault().getProjectProperties().getBootClasspath()
			+ File.pathSeparator
			+ Ajde.getDefault().getProjectProperties().getClasspath();
			
		StringTokenizer st = new StringTokenizer(
			classpathString,
			File.pathSeparator
		);
		List classpath = new ArrayList();
		while (st.hasMoreTokens()) classpath.add(st.nextToken());
		buildConfig.setClasspath(classpath);  
		Ajde.getDefault().logEvent("building with classpath: " + classpath);

		if (Ajde.getDefault().getBuildManager().getBuildOptions().getSourceOnePointFourMode()) {
			buildConfig.getJavaOptions().put(CompilerOptions.OPTION_Compliance, CompilerOptions.VERSION_1_4);	 
		} 

		// XXX problematic restriction, support multiple source roots
		List sourceRoots = new ArrayList();
		sourceRoots.add(new File(configFile).getParentFile());
		buildConfig.setSourceRoots(sourceRoots);

		buildConfig.setOutputDir(
			new File(Ajde.getDefault().getProjectProperties().getOutputPath())
		);
		
		buildConfig.setGenerateModelMode(true);
		
		return buildConfig;
	}
================= fetch public AjcBuildOptions(UserPreferencesAdapter userPreferencesAdapter) { 85a827a^:ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java

================= fetch public String getClasspath() { 85a827a^:ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java

public String getClasspath() {
    	//XXX
    	return testProjectPath + System.getProperty("sun.boot.class.path") + File.pathSeparator +  "../../../runtime/bin";	
    }
================= fetch public String getVmArgs() { 85a827a^:ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java

public String getVmArgs() {
    	return null;	
    }
================= fetch public String getWorkingOutputPath() { 85a827a^:ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java

public String getWorkingOutputPath() {
		return preferencesAdapter.getProjectPreference(WORKING_DIR);
	}
================= fetch public boolean getLenientSpecMode() { 85a827a^:ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java

public boolean getLenientSpecMode() {
		return getBooleanOptionVal(LENIENT_MODE);
	}
================= fetch public boolean getPortingMode() { 85a827a^:ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java

public boolean getPortingMode() {
		return getBooleanOptionVal(PORTING_MODE);
	}
================= fetch public boolean getPreprocessMode() { 85a827a^:ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java

public boolean getPreprocessMode() {
		return getBooleanOptionVal(PREPROCESS_MODE);
	}
================= fetch public boolean getSourceOnePointFourMode() { 85a827a^:ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java

public boolean getSourceOnePointFourMode() {
		return getBooleanOptionVal(SOURCE_ONE_POINT_FOUR_MODE);
	}
================= fetch public boolean getStrictSpecMode() { 85a827a^:ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java

public boolean getStrictSpecMode() {
		return getBooleanOptionVal(STRICT_MODE);	
	}
================= fetch public boolean getUseJavacMode() { 85a827a^:ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java

public boolean getUseJavacMode() {
		return getBooleanOptionVal(USE_JAVAC_MODE);
	}
================= fetch public boolean verifyAgainstSavedModel(String lstFile) { 85a827a^:ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java

public boolean verifyAgainstSavedModel(String lstFile) {
		File modelFile = new File(genStructureModelExternFilePath(lstFile));
		StructureModel model = getModelForFile(lstFile);
		System.out.println(">> model: " + model.getRoot());	
		
		if (modelFile.exists()) {
			Ajde.getDefault().getStructureModelManager().readStructureModel(lstFile);
			StructureModel savedModel = Ajde.getDefault().getStructureModelManager().getStructureModel();
			//System.err.println( savedModel.getRoot().getClass() + ", " +  savedModel.getRoot());
			
			return savedModel.getRoot().equals(model.getRoot());
		} else {
			Ajde.getDefault().getStructureModelManager().writeStructureModel(lstFile);
			return true;
		}
		//return true;
	}
================= fetch public static Test suite() { 85a827a^:ajde/testsrc/org/aspectj/ajde/AjdeTests.java

public static Test suite() { 
        TestSuite suite = new TestSuite(AjdeTests.class.getName());
        //$JUnit-BEGIN$
        suite.addTestSuite(BuildOptionsTest.class); 
        suite.addTestSuite(StructureModelRegressionTest.class); 
        suite.addTestSuite(StructureModelTest.class); 
        suite.addTestSuite(VersionTest.class); 
        //$JUnit-END$
        return suite;
    }
================= fetch public void init(String testProjectPath) { 85a827a^:ajde/testsrc/org/aspectj/ajde/NullIdeManager.java

public void init(String testProjectPath) {
		try {
			UserPreferencesAdapter preferencesAdapter = new UserPreferencesStore();
			ProjectPropertiesAdapter browserProjectProperties = new NullIdeProperties(testProjectPath);
			TaskListManager taskListManager = new NullIdeTaskListManager();
			BasicEditor ajdeEditor = new BasicEditor();
			IdeUIAdapter uiAdapter = new NullIdeUIAdapter();
			JFrame nullFrame = new JFrame();
			//configurationManager.setConfigFiles(getConfigFilesList(configFiles));	

			AjdeUIManager.getDefault().init(
				ajdeEditor,
				taskListManager,
				browserProjectProperties,  
				preferencesAdapter,
				uiAdapter,
				new IconRegistry(),
				nullFrame,
				true);	
		} catch (Throwable t) {
			t.printStackTrace();
			Ajde.getDefault().getErrorHandler().handleError(
				"Null IDE failed to initialize.",
				t);
		}
	}
================= fetch public void parseOption(String arg, LinkedList args) { 85a827a^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java

public void parseOption(String arg, LinkedList args) {
			int nextArgIndex = args.indexOf(arg)+1;
			if (arg.equals("-Xlint")) {;
				buildConfig.getAjOptions().put(
					AjCompilerOptions.OPTION_Xlint,
					CompilerOptions.GENERATE);
			} else if (arg.equals("-injars")) {;
				if (args.size() > nextArgIndex) {
					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_InJARs, CompilerOptions.PRESERVE);
					
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
		            	if (filename.endsWith(".jar") && jarFile.exists()) {
			            	buildConfig.getInJars().add(jarFile);    
		            	} else {
		                	handler.handleMessage(new Message(
								"ignoring bad injar: " + filename, 
								Message.WARNING, null, null));
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-aspectpath")) {;
				if (args.size() > nextArgIndex) {
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	String filename = st.nextToken();
		            	File jarFile = makeFile(filename);
		            	if (filename.endsWith(".jar") && jarFile.exists()) {
			            	buildConfig.getAspectpath().add(jarFile);    
		            	} else {
		                	handler.handleMessage(new Message(
								"ignoring bad injar: " + filename, 
								Message.WARNING, null, null));
		            	}
		            }
					
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-sourceroots")) {
				if (args.size() > nextArgIndex) {
					List sourceRoots = new ArrayList();
					StringTokenizer st = new StringTokenizer(
						((ConfigParser.Arg)args.get(nextArgIndex)).getValue(), 
						File.pathSeparator);
		            while (st.hasMoreTokens()) {
		            	File f = makeFile(st.nextToken());
		            	if (f.isDirectory()) {
			                sourceRoots.add(f);
		            	} else {
							handler.handleMessage(new Message(
								f.getName() + " is not a file, not adding to sourceroots", 
								Message.WARNING, null, null));	
		            	}		            		
		            }
					 
									
//					if (sourceRoots.size() > 1) {
//						handler.handleMessage(new Message(
//							"can not specify more than one source root (compiler limitation)\n"
//							+ "using source root: " + sourceRoots.get(0), 
//							Message.WARNING, null, null));	
//					} else 
					if (sourceRoots.size() < 1) {
						out.println("must specify a valid source root in incremental mode");
					} else {
						buildConfig.setSourceRoots(sourceRoots);	
					}
					args.remove(args.get(nextArgIndex));
				} else {
					out.println("must specify a valid source root in incremental mode");
				}
			} else if (arg.equals("-outjar")) { 
				if (args.size() > nextArgIndex) {
					buildConfig.getAjOptions().put(AjCompilerOptions.OPTION_OutJAR, CompilerOptions.GENERATE);
					File jarFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
					if (jarFile.getName().endsWith(".jar")) {
						try {
							if (!jarFile.exists()) jarFile.createNewFile();
						} catch (IOException ioe) { 
							// fail siltenty 
						}
						buildConfig.setOutputJar(jarFile);	
					} else {
						out.println("file specified with -outjar is not a valid JAR file, ignoring");
						buildConfig.setLintSpecFile(null);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					out.println("must specify a file for -outjar");
				}
			} else if (arg.equals("-emacssym")) {
				buildConfig.setEmacsSymMode(true);
				buildConfig.setGenerateModelMode(true);
			} else if (arg.equals("-emacssym")) {
				buildConfig.setEmacsSymMode(true);
				buildConfig.setGenerateModelMode(true);
			} else if (arg.equals("-noweave")) {
				buildConfig.setNoWeave(true);
			} else if (arg.equals("-XserializableAspects")) {
				buildConfig.setXserializableAspects(true);
			} else if (arg.equals("-XnoInline")) {
				buildConfig.setXnoInline(true);
			} else if (arg.equals("-Xlintfile")) { 
				if (args.size() > nextArgIndex) {
					File lintSpecFile = makeFile(((ConfigParser.Arg)args.get(nextArgIndex)).getValue());
					if (lintSpecFile.exists() && lintSpecFile.getName().endsWith(".properties")) {
						buildConfig.setLintSpecFile(lintSpecFile);	
					} else {
						out.println("file specified with -Xlintfile does not exist, ignoring");
						buildConfig.setLintSpecFile(null);
					}
					args.remove(args.get(nextArgIndex));
				} else {
					out.println("must specify a file for -outjar");
				}
			} else if (arg.startsWith("-Xlint")) {
				int index = arg.indexOf(":");
				if (index != -1) {
					buildConfig.setLintMode(arg.substring(index+1));
				} else {
					buildConfig.setLintMode(AjBuildConfig.AJLINT_DEFAULT);
				}
			} else if (arg.equals("-bootclasspath")) {
				if (args.size() > nextArgIndex) {
					bootclasspath = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					args.remove(args.get(nextArgIndex));	
				}
			} else if (arg.equals("-extdirs")) {
				if (args.size() > nextArgIndex) {
					extdirs = ((ConfigParser.Arg)args.get(nextArgIndex)).getValue();
					args.remove(args.get(nextArgIndex));
				}	
			} else {
//				if (arg.equals("-d")) {
//					int nextArgIndex = args.indexOf(arg)+1;
//					if (args.size() > nextArgIndex) {
//						ConfigParser.Arg path = (ConfigParser.Arg)args.get(nextArgIndex);
//						path.setValue(makeFile(path.getValue()).getPath());
//					}
//		    	} 
		    	unparsedArgs.add(arg);
			}
        }
================= fetch public void setAjcWorkingDir(String path) { 85a827a^:ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserProperties.java

public void setAjcWorkingDir(String path) {
        preferencesAdapter.setProjectPreference("build.workingdir", path);
    }
================= fetch public void setCharacterEncoding(String value) { 85a827a^:ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java

public void setCharacterEncoding(String value) {
		preferencesAdapter.setProjectPreference(CHARACTER_ENCODING, value);	
	}
================= fetch public void setLenientSpecMode(boolean value) { 85a827a^:ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java

public void setLenientSpecMode(boolean value) {
		setBooleanOptionVal(LENIENT_MODE, value);	
	}
================= fetch public void setNonStandardOptions(String value) { 85a827a^:ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java

public void setNonStandardOptions(String value) {
		preferencesAdapter.setProjectPreference(NONSTANDARD_OPTIONS, value);	
	}
================= fetch public void setSourceOnePointFourMode(boolean value) { 85a827a^:ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java

public void setSourceOnePointFourMode(boolean value) {
		setBooleanOptionVal(SOURCE_ONE_POINT_FOUR_MODE, value);	
	}
================= fetch public void setStrictSpecMode(boolean value) { 85a827a^:ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java

public void setStrictSpecMode(boolean value) {
		setBooleanOptionVal(STRICT_MODE, value);
	}
================= fetch public void setUseJavacMode(boolean value) { 85a827a^:ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java

public void setUseJavacMode(boolean value) {
		setBooleanOptionVal(USE_JAVAC_MODE, value);
	}
================= fetch public void setWorkingDir(String path) { 85a827a^:ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java

public void setWorkingDir(String path) {
		preferencesAdapter.setProjectPreference(WORKING_DIR, path);	
	}
================= fetch public void test() { 85a827a^:ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java

public void test() {
		String testLstFile = "StructureModelRegressionTest/example.lst";
        File f = new File(testLstFile);
        assertTrue(testLstFile, f.canRead());
        assertTrue("saved model: " + testLstFile, verifyAgainstSavedModel(testLstFile));    
	}
================= fetch public void testFieldInitializerCorrespondence() throws IOException { 85a827a^:ajde/testsrc/org/aspectj/ajde/StructureModelTest.java

public void testFieldInitializerCorrespondence() throws IOException {
		File testFile = createFile("../examples/figures-coverage/figures/Figure.java");	
		StructureNode node = Ajde.getDefault().getStructureModelManager().getStructureModel().findNodeForSourceLine(
			testFile.getCanonicalPath(), 28);
		assertTrue("find result", node != null) ;	
		ProgramElementNode pNode = (ProgramElementNode)node;
		ProgramElementNode foundNode = null;
		final List list = pNode.getRelations();
        assertNotNull("pNode.getRelations()", list);
		for (Iterator it = list.iterator(); it.hasNext(); ) {
			RelationNode relation = (RelationNode)it.next();
			if (relation.getRelation().equals(AdviceAssociation.FIELD_ACCESS_RELATION)) {
				for (Iterator it2 = relation.getChildren().iterator(); it2.hasNext(); ) {
					LinkNode linkNode = (LinkNode)it2.next();
					if (linkNode.getProgramElementNode().getName().equals("this.currVal = 0")) {
						foundNode = linkNode.getProgramElementNode();	
					}
				}
			}
		}
		
		assertTrue("find associated node", foundNode != null) ;
		
		File pointFile = createFile("../examples/figures-coverage/figures/primitives/planar/Point.java");	
		StructureNode fieldNode = Ajde.getDefault().getStructureModelManager().getStructureModel().findNodeForSourceLine(
			pointFile.getCanonicalPath(), 12);		
		assertTrue("find result", fieldNode != null);
		
		assertTrue("matches", foundNode.getParent() == fieldNode.getParent());
	}
================= fetch public void testFileNodeFind() throws IOException { 85a827a^:ajde/testsrc/org/aspectj/ajde/StructureModelTest.java

public void testFileNodeFind() throws IOException {
		File testFile = createFile("../examples/figures-coverage/figures/Main.java");	
		StructureNode node = Ajde.getDefault().getStructureModelManager().getStructureModel().findNodeForSourceLine(
			testFile.getCanonicalPath(), 1);
		assertTrue("find result", node != null) ;	
		ProgramElementNode pNode = (ProgramElementNode)node;
		assertTrue("found node: " + pNode.getName(), pNode.getProgramElementKind().equals(ProgramElementNode.Kind.FILE_JAVA));
	}
================= fetch public void testFreshStructureModelCreation() { 85a827a^:ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java
/**
	 * @todo	this should be moved to a StructureModelManager test
	 */
public void testFreshStructureModelCreation() {
		renderer.setHasBeenNotified(false);
		String modelPath = genStructureModelExternFilePath(CONFIG_FILE_PATH);
		createFile(modelPath).delete();
		//System.err.println("> path: " + modelPath);
		
		Ajde.getDefault().getStructureModelManager().readStructureModel(CONFIG_FILE_PATH);
		
		assertTrue("notified", renderer.getHasBeenNotified());	
		//System.err.println(">>>>>> " + currentView.getRootNode().getStructureNode());	
		assertTrue(
			"no structure", 
			currentView.getRootNode().getStructureNode().getChildren().get(0) 
			== StructureModelManager.INSTANCE.getStructureModel().NO_STRUCTURE
		);	
	}
================= fetch public void testMainClassNodeInfo() throws IOException { 85a827a^:ajde/testsrc/org/aspectj/ajde/StructureModelTest.java
/**
  	 * @todo	add negative test to make sure things that aren't runnable aren't annotated
  	 */
public void testMainClassNodeInfo() throws IOException {
		assertTrue("root exists", Ajde.getDefault().getStructureModelManager().getStructureModel().getRoot() != null);
		File testFile = createFile("../examples/figures-coverage/figures/Main.java");	
		StructureNode node = Ajde.getDefault().getStructureModelManager().getStructureModel().findNodeForSourceLine(
			testFile.getCanonicalPath(), 11);
		assertTrue("find result", node != null);	
			
		ProgramElementNode pNode = (ProgramElementNode)((ProgramElementNode)node).getParent();
		assertTrue("found node: " + pNode.getName(), pNode.isRunnable());
	}
================= fetch public void testPortingMode() { 85a827a^:ajde/testsrc/org/aspectj/ajde/BuildOptionsTest.java

public void testPortingMode() {
		buildOptions.setPortingMode(true);
		assertTrue("porting mode", buildOptions.getPortingMode());
	}
================= fetch public void testXlint() throws InvalidInputException { 85a827a^:org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java

public void testXlint() throws InvalidInputException {
		AjdtCommand command = new AjdtCommand();
		AjBuildConfig config = parser.genBuildConfig(new String[] {"-Xlint"}, messageWriter);
		assertTrue("", config.getLintMode().equals(AjBuildConfig.AJLINT_DEFAULT));
		config = parser.genBuildConfig(new String[] {"-Xlint:warn"}, messageWriter);
		assertTrue("", config.getLintMode().equals(AjBuildConfig.AJLINT_WARN));
		config = parser.genBuildConfig(new String[] {"-Xlint:error"}, messageWriter);
		assertTrue("", config.getLintMode().equals(AjBuildConfig.AJLINT_ERROR));
		config = parser.genBuildConfig(new String[] {"-Xlint:ignore"}, messageWriter);
		assertTrue("", config.getLintMode().equals(AjBuildConfig.AJLINT_INGORE));
	}
Progress : [###########################################---] 108%================= fetch LazyClassGen weave(UnwovenClassFile classFile, BcelObjectType classType) throws c1260e6^:weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java
// non-private for testing
LazyClassGen weave(UnwovenClassFile classFile, BcelObjectType classType) throws IOException {
		JavaClass javaClass = classType.getJavaClass();
		List shadowMungers = fastMatch(shadowMungerList, javaClass);
		List typeMungers = fastMatch(classType.getInterTypeMungers(), javaClass);

		LazyClassGen clazz = null;
		
		if (shadowMungers.size() > 0 || typeMungers.size() > 0 || classType.isAspect()) {
			clazz = classType.getLazyClassGen();
			//System.err.println("got lazy gen: " + clazz + ", " + clazz.getWeaverState());
			try {
				boolean isChanged = BcelClassWeaver.weave(world, clazz, shadowMungers, typeMungers);
				if (isChanged) {
					dump(classFile, clazz);
					return clazz;
				}
			} catch (RuntimeException re) {
				System.err.println("trouble in: ");
				clazz.print(System.err);
				throw re;
			} catch (Error re) {
				System.err.println("trouble in: ");
				clazz.print(System.err);
				throw re;
			}
		}
		
		dumpUnchanged(classFile);
		return clazz;
	}
================= fetch private static ProgramElementNode findMemberInClass( c1260e6^:weaver/src/org/aspectj/weaver/AsmAdaptor.java

private static ProgramElementNode findMemberInClass(
		ProgramElementNode classNode,
		Member member)
	{
		if (classNode == null) return null; // XXX remove this check
		for (Iterator it = classNode.getChildren().iterator(); it.hasNext(); ) {
			ProgramElementNode node = (ProgramElementNode)it.next();
			if (member.getName().equals(node.getBytecodeName()) &&
				member.getSignature().equals(node.getBytecodeSignature()))
			{
				return node;
			}
		}
		return null;
	}
================= fetch private static ProgramElementNode findOrCreateBodyNode( c1260e6^:weaver/src/org/aspectj/weaver/AsmAdaptor.java

private static ProgramElementNode findOrCreateBodyNode(
		ProgramElementNode enclosingNode,
		Member shadowSig, Shadow shadow)
	{
		for (Iterator it = enclosingNode.getChildren().iterator(); it.hasNext(); ) {
			ProgramElementNode node = (ProgramElementNode)it.next();
			if (shadowSig.getName().equals(node.getBytecodeName()) &&
				shadowSig.getSignature().equals(node.getBytecodeSignature()))
			{
				return node;
			}
		}
		
		ISourceLocation sl = shadow.getSourceLocation();
		
		ProgramElementNode peNode = new ProgramElementNode(
			shadow.toString(),
			ProgramElementNode.Kind.CODE,
			new SourceLocation(enclosingNode.getSourceLocation().getSourceFile(), sl.getLine()),
			0,
			"",
			new ArrayList());
			
		System.err.println(peNode.getSourceLocation());
		peNode.setBytecodeName(shadowSig.getName());
		peNode.setBytecodeSignature(shadowSig.getSignature());
		enclosingNode.addChild(peNode);
		return peNode;
	}
================= fetch private static ProgramElementNode getNode(StructureModel model, Advice a) { c1260e6^:weaver/src/org/aspectj/weaver/AsmAdaptor.java

private static ProgramElementNode getNode(StructureModel model, Advice a) {
		//ResolvedTypeX inAspect = a.getConcreteAspect();
		Member member = a.getSignature();
		return lookupMember(model, member);
	}
================= fetch private static ProgramElementNode getNode(StructureModel model, Shadow shadow) { c1260e6^:weaver/src/org/aspectj/weaver/AsmAdaptor.java

private static ProgramElementNode getNode(StructureModel model, Shadow shadow) {
		Member enclosingMember = shadow.getEnclosingCodeSignature();
		
		ProgramElementNode enclosingNode = lookupMember(model, enclosingMember);
		
		Member shadowSig = shadow.getSignature();
		if (!shadowSig.equals(enclosingMember)) {
			ProgramElementNode bodyNode = findOrCreateBodyNode(enclosingNode, shadowSig, shadow);
			return bodyNode;
		} else {
			return enclosingNode;
		}
	}
================= fetch private void implementMungers() { c1260e6^:weaver/src/org/aspectj/weaver/Shadow.java
/** Actually implement the (non-empty) mungers associated with this shadow */
private void implementMungers() {
		World world = getIWorld();
		for (Iterator iter = mungers.iterator(); iter.hasNext();) {
			ShadowMunger munger = (ShadowMunger) iter.next();
			munger.implementOn(this);
			if (world.getModel() != null) {
				System.err.println("munger: " + munger + " on " + this);
				AsmAdaptor.noteMunger(world.getModel(), this, munger);
			}
		}
	}
================= fetch public ProgramElementNode findNodeForClass(String packageName, String className) c1260e6^:asm/src/org/aspectj/asm/StructureModel.java
/**
	 * @param packageName	if null default package is searched
	 * @param className 	can't be null
	 */
public ProgramElementNode findNodeForClass(String packageName, String className) {
		StructureNode packageNode = null;
		if (packageName == null) {
			packageNode = root;
		} else {
			for (Iterator it = root.getChildren().iterator(); it.hasNext(); ) {
				StructureNode node = (StructureNode)it.next();
				if (packageName.equals(node.getName())) {
					packageNode = node;
				} 
			}
			if (packageNode == null) return null;
		}
		// !!! this searches each file for a class
		for (Iterator it = packageNode.getChildren().iterator(); it.hasNext(); ) {
			ProgramElementNode fileNode = (ProgramElementNode)it.next();
			for (Iterator j = fileNode.getChildren().iterator(); j.hasNext(); ) {
				ProgramElementNode classNode = (ProgramElementNode)j.next();	
				if (classNode instanceof ProgramElementNode && className.equals(classNode.getName())) {
					return (ProgramElementNode)classNode;
				}
			}
		}
		return null;
	}
================= fetch public boolean isAspect() { c1260e6^:weaver/src/org/aspectj/weaver/ResolvedTypeX.java

public boolean isAspect() {
    	return false;
    }
================= fetch public boolean visit(MemberTypeDeclaration memberTypeDeclaration, ClassScope sco c1260e6^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java
// ??? share impl with visit(TypeDeclaration, ..) ?
public boolean visit(MemberTypeDeclaration memberTypeDeclaration, ClassScope scope) {
		String name = new String(memberTypeDeclaration.name);
		ProgramElementNode.Kind kind = ProgramElementNode.Kind.CLASS;
		if (memberTypeDeclaration instanceof AspectDeclaration) kind = ProgramElementNode.Kind.ASPECT;
		else if (memberTypeDeclaration.isInterface()) kind = ProgramElementNode.Kind.INTERFACE;

		ProgramElementNode peNode = new ProgramElementNode(
			name,
			kind,
			makeLocation(memberTypeDeclaration),
			memberTypeDeclaration.modifiers,
			"",
			new ArrayList());
		
		((StructureNode)stack.peek()).addChild(peNode);
		stack.push(peNode);
		return true;
	}
================= fetch public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) { c1260e6^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java
// !!! improve name and type generation
public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {
		ProgramElementNode.Kind kind = ProgramElementNode.Kind.METHOD;
		String label = new String(methodDeclaration.selector);
		
		if (methodDeclaration instanceof AdviceDeclaration) { 
			kind = ProgramElementNode.Kind.ADVICE;
			label = translateAdviceName(label);
		} else if (methodDeclaration instanceof PointcutDeclaration) { 
			kind = ProgramElementNode.Kind.POINTCUT;
		} else if (methodDeclaration instanceof DeclareDeclaration) { 
			DeclareDeclaration declare = (DeclareDeclaration)methodDeclaration;
			label = translateDeclareName(declare.toString());
			if (label.indexOf("warning") != -1) kind = ProgramElementNode.Kind.DECLARE_WARNING;
			if (label.indexOf("error") != -1) kind = ProgramElementNode.Kind.DECLARE_ERROR;
		} else if (methodDeclaration instanceof InterTypeDeclaration) {
			kind = ProgramElementNode.Kind.INTRODUCTION;
			label = translateInterTypeDecName(new String(((InterTypeDeclaration)methodDeclaration).selector));
		} 
		
		ProgramElementNode peNode = new ProgramElementNode(
			label,
			kind,
			makeLocation(methodDeclaration),
			methodDeclaration.modifiers,
			"",
			new ArrayList());
			
		Member member = EclipseWorld.makeResolvedMember(methodDeclaration.binding);
		peNode.setBytecodeName(member.getName());
		peNode.setBytecodeSignature(member.getSignature());
		((StructureNode)stack.peek()).addChild(peNode);
		stack.push(peNode);
		
		return true;
	}
================= fetch public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope scope c1260e6^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java

public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope scope) {
		String name = new String(typeDeclaration.name);
		ProgramElementNode.Kind kind = ProgramElementNode.Kind.CLASS;
		if (typeDeclaration instanceof AspectDeclaration) kind = ProgramElementNode.Kind.ASPECT;
		else if (typeDeclaration.isInterface()) kind = ProgramElementNode.Kind.INTERFACE;

		ProgramElementNode peNode = new ProgramElementNode(
			name,
			kind,
			makeLocation(typeDeclaration),
			typeDeclaration.modifiers,
			"",
			new ArrayList());
		
		((StructureNode)stack.peek()).addChild(peNode);
		stack.push(peNode);
		return true;
	}
================= fetch public void endVisit(MemberTypeDeclaration memberTypeDeclaration, ClassScope sco c1260e6^:org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java

public void endVisit(MemberTypeDeclaration memberTypeDeclaration, ClassScope scope) {
		stack.pop();
	}
================= fetch public LazyMethodGen(Method m, LazyClassGen enclosingClass) { 2781720^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

private int calculateMaxLocals() {
        int ret = 0;
        if (!Modifier.isStatic(accessFlags)) ret++;
        for (int i = 0, len = argumentTypes.length; i < len; i++) {
            ret += argumentTypes[i].getSize();
        }
        return ret;   
    }
================= fetch public void packBody(MethodGen gen) { 2781720^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java
/** fill the newly created method gen with our body, 
     * inspired by InstructionList.copy()
     */
public void packBody(MethodGen gen) {
        HashMap map = new HashMap();
        InstructionList fresh = gen.getInstructionList();
        
        /* Make copies of all instructions, append them to the new list
         * and associate old instruction references with the new ones, i.e.,
         * a 1:1 mapping.  
         */
        for (InstructionHandle ih = getBody().getStart(); ih != null; ih = ih.getNext()) {
            if (Range.isRangeHandle(ih)) {
                continue;
            }
            Instruction i = ih.getInstruction();
            Instruction c = i.copy(); // Use clone for shallow copy

            if (c instanceof BranchInstruction)
                map.put(ih, fresh.append((BranchInstruction) c));
            else
                map.put(ih, fresh.append(c));
        }
        // at this point, no rangeHandles are in fresh.  Let's use that...

        /* Update branch targets and insert various attributes.  
         * Insert our exceptionHandlers
         * into a sorted list, so they can be added in order later.
         */
        InstructionHandle ih = getBody().getStart();
        InstructionHandle jh = fresh.getStart();

        LinkedList exnList = new LinkedList();   

        Map localVariableStarts = new HashMap();
        Map localVariableEnds = new HashMap();

        int currLine = -1;
        
        while (ih != null) {
            if (map.get(ih) == null) {
                // we're a range instruction
                Range r = Range.getRange(ih);
                if (r instanceof ExceptionRange) {
                    ExceptionRange er = (ExceptionRange) r;
                    if (er.getStart() == ih) {
                    	//System.err.println("er " + er);
                    	if (!er.isEmpty()){
                        	// order is important, insert handlers in order of start
                        	insertHandler(er, exnList);
                    	}
                    }
                } else {
                    // we must be a shadow range or something equally useless, 
                    // so forget about doing anything
                }
                // just increment ih. 
                ih = ih.getNext();
            } else {
                // assert map.get(ih) == jh
                Instruction i = ih.getInstruction();
                Instruction j = jh.getInstruction();
    
                if (i instanceof BranchInstruction) {
                    BranchInstruction bi = (BranchInstruction) i;
                    BranchInstruction bj = (BranchInstruction) j;
                    InstructionHandle itarget = bi.getTarget(); // old target
    
//    				try {
                    // New target is in hash map
                    bj.setTarget(remap(itarget, map));
//    				} catch (NullPointerException e) {
//    					print();
//    					System.out.println("Was trying to remap " + bi);
//    					System.out.println("who's target was supposedly " + itarget);
//    					throw e;
//    				}
    
                    if (bi instanceof Select) { 
                        // Either LOOKUPSWITCH or TABLESWITCH
                        InstructionHandle[] itargets = ((Select) bi).getTargets();
                        InstructionHandle[] jtargets = ((Select) bj).getTargets();
    
                        for (int k = itargets.length - 1; k >= 0; k--) { 
                            // Update all targets
                            jtargets[k] = remap(itargets[k], map);
                            jtargets[k].addTargeter(bj);
                        }
                    }
                }
                
                // now deal with line numbers 
                // and store up info for local variables
                InstructionTargeter[] targeters = ih.getTargeters();
                if (targeters != null) {
                    for (int k = targeters.length - 1; k >= 0; k--) {
                        InstructionTargeter targeter = targeters[k];
                        if (targeter instanceof LineNumberTag) {
                            int line = ((LineNumberTag)targeter).getLineNumber();
                            if (line != currLine) {
                                gen.addLineNumber(jh, line);
                                currLine = line;
                            }
                        } else if (targeter instanceof LocalVariableTag) {
                            LocalVariableTag lvt = (LocalVariableTag) targeter;
                            if (i instanceof LocalVariableInstruction) {
                                int index = ((LocalVariableInstruction)i).getIndex();
                                if (lvt.getSlot() == index) {
                                    if (localVariableStarts.get(lvt) == null) {
                                        localVariableStarts.put(lvt, jh);
                                    }
                                    localVariableEnds.put(lvt, jh);
                                }
                            }
                        }
                    }
                }
                // now continue
                ih = ih.getNext();
                jh = jh.getNext();
            }
        }

        // now add exception handlers
        for (Iterator iter = exnList.iterator(); iter.hasNext();) {
            ExceptionRange r = (ExceptionRange) iter.next();
            if (r.isEmpty()) continue;
            gen.addExceptionHandler(
                remap(r.getRealStart(), map), 
                remap(r.getRealEnd(), map),
                remap(r.getHandler(), map),
                (r.getCatchType() == null)
                ? null 
                : (ObjectType) BcelWorld.makeBcelType(r.getCatchType()));
        }
        // now add local variables
        gen.removeLocalVariables();
        for (Iterator iter = localVariableStarts.keySet().iterator(); iter.hasNext(); ) {
            LocalVariableTag tag = (LocalVariableTag) iter.next();
            gen.addLocalVariable(
                tag.getName(), 
                BcelWorld.makeBcelType(tag.getType()),
                tag.getSlot(),
                (InstructionHandle) localVariableStarts.get(tag),
                (InstructionHandle) localVariableEnds.get(tag));
        }
    }
================= fetch void print() { 2781720^:weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java

private void printAspectAttributes(PrintStream out) {
		ISourceContext context = null;
		if (enclosingClass != null && enclosingClass.getType() != null) {
			context = enclosingClass.getType().getSourceContext();
		}
		List as = BcelAttributes.readAjAttributes(attributes, context);
		if (! as.isEmpty()) {
			out.println("    " + as.get(0)); // XXX assuming exactly one attribute, munger...
		}
	}
================= fetch public static ResolvedMember interFieldClassField(ResolvedMember field, TypeX as 99a873c^:weaver/src/org/aspectj/weaver/AjcMemberMaker.java
/**
	 * This field goes on the class the field
	 * is declared onto
	 */
public static ResolvedMember interFieldClassField(ResolvedMember field, TypeX aspectType) {
		return new ResolvedMember(Member.FIELD, field.getDeclaringType(), 
			makePublic(field.getModifiers()),
			field.getReturnType(), 
			NameMangler.interFieldClassField(field.getModifiers(), aspectType, field.getDeclaringType(), field.getName()),
			TypeX.NONE
			);
	}
================= fetch public static ResolvedMember interFieldInitializer(ResolvedMember field, TypeX a 99a873c^:weaver/src/org/aspectj/weaver/AjcMemberMaker.java

public static ResolvedMember interFieldInitializer(ResolvedMember field, TypeX aspectType) {
		return new ResolvedMember(Member.METHOD, aspectType, PUBLIC_STATIC,
			NameMangler.interFieldInitializer(aspectType, field.getDeclaringType(), field.getName()),
			field.isStatic() ? "()V" : "(" + field.getDeclaringType().getSignature() + ")V"
			);
	}
================= fetch public static ResolvedMember interFieldInterfaceField(ResolvedMember field, Type 99a873c^:weaver/src/org/aspectj/weaver/AjcMemberMaker.java
/**
	 * This field goes on top-most implementers of the interface the field
	 * is declared onto
	 */
public static ResolvedMember interFieldInterfaceField(ResolvedMember field, TypeX onClass, TypeX aspectType) {
		return new ResolvedMember(Member.FIELD, onClass, makePublic(field.getModifiers()),
			field.getReturnType(), 
			NameMangler.interFieldInterfaceField(aspectType, field.getDeclaringType(), field.getName()),
			TypeX.NONE
			);
	}
================= fetch public static ResolvedMember interMethod(ResolvedMember meth, TypeX aspectType, 99a873c^:weaver/src/org/aspectj/weaver/AjcMemberMaker.java
/**
	 * This method goes on the target type of the inter-type method. (and possibly the topmost-implemeters,
	 * if the target type is an interface) 
	 */
public static ResolvedMember interMethod(ResolvedMember meth, TypeX aspectType, boolean onInterface) 
	{
		if (Modifier.isPublic(meth.getModifiers()) && !onInterface) return meth;
		
		int modifiers = makePublic(meth.getModifiers());
		if (onInterface) modifiers |= Modifier.ABSTRACT;
		
		return new ResolvedMember(Member.METHOD, meth.getDeclaringType(),
			modifiers,
			meth.getReturnType(), 
			NameMangler.interMethod(meth.getModifiers(), aspectType, meth.getDeclaringType(), meth.getName()),
			meth.getParameterTypes());	
	}
