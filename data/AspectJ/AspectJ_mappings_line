
======= fetch "public ReferenceTypeDelegate getDelegate(ReferenceType referenceType) {" dd88d21^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

    @Before("execution(* com.foo.bar.Test.foo())")
    public void advice() {
        System.out.println("Hello");
    }
    abstract class X<T> {}
    class X1 extends X<Integer> {}
    class X2 extends X<String> {}
    public Test foo() {
        return this;
    }
    public <T> X<T> createMessage(int n) {
        X x;
        if (n == 0) {
            x = new X1();
        } else {
            x = new X2();
        }
        return x;
    }
    
    public static void main(String[] args) {
======= fetch "public static Test suite() {" dd88d21^:"tests/src/org/aspectj/systemtest/AllTests17.java"

 * Copyright (c) 2013 Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
 * @author Andy Clement
 */
 * Copyright (c) 2013 Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
======= fetch "public void testPr148285() {" dd88d21^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= fetch "public void testAspectPath_pr249212_c1() throws IOException {" dd88d21^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= fetch "public void testAdviceDidNotMatch_pr152589() {" dd88d21^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= fetch "protected String getCommonSuperClass(final String type1, final String type2) {" dd88d21^:"weaver/src/org/aspectj/weaver/bcel/asm/StackMapAdder.java"


======= fetch "private String getValue(String key, Shadow shadow) {" 9319e34^:"org.aspectj.matcher/src/org/aspectj/weaver/Checker.java"

  declare warning: call(* foo(..)): "Call to foo made inside class {joinpoint.enclosingclass}";
  declare warning: call(* foo(..)): "Call to foo made inside member {joinpoint.enclosingmember.name}";
  declare warning: call(* foo(..)): "Call to foo made inside member {joinpoint.enclosingmember}";
  public void booble() {
    foo();
  }
  public void foo() {}
  public void m() {
    foo();
  }
  public void foo() {}

======= fetch "public String getLintMode() {" b2cd5fa^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= fetch "public void setLintMode(String lintMode) {" b2cd5fa^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= fetch "public void setLintMode(String lintMode) {" b2cd5fa^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= fetch "public void setLintMode(String lintMode) {" b2cd5fa^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= fetch "public void setLintMode(String lintMode) {" b2cd5fa^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= fetch "public void setLintMode(String lintMode) {" b2cd5fa^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= fetch "public void setLintMode(String lintMode) {" b2cd5fa^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" b2cd5fa^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void setAll(IMessage.Kind messageKind) {" b2cd5fa^:"org.aspectj.matcher/src/org/aspectj/weaver/Lint.java"

======= fetch "public void setXlintfile(String xlintfile) {" b2cd5fa^:"testing/newsrc/org/aspectj/testing/CompileSpec.java"

  before(): execution(* *(String)) { }
  before(): call(* someMethod(..)) {
  }
  public void foo() {
    someMethod();
  }
  public void someMethod(){}

======= fetch "static WeavingAdaptor getWeaver(ClassLoader loader, IWeavingContext weavingConte" 9e992d6^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

                if(loader.equals(myClassLoader)){
                    adaptor = myClassLoaderAdpator;
                }
                else{
======= fetch "static WeavingAdaptor getWeaver(ClassLoader loader, IWeavingContext weavingConte" 9e992d6^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

======= fetch "static WeavingAdaptor getWeaver(ClassLoader loader, IWeavingContext weavingConte" 9e992d6^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

======= fetch "static WeavingAdaptor getWeaver(ClassLoader loader, IWeavingContext weavingConte" 9e992d6^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"


 //   public String Behavior.name;
    public static void main(String []argv) throws Exception {
      System.out.println(Target.class.getDeclaredMethod("hello").getDeclaredAnnotations()[0]);
    }
    public static void main(String []argv) throws Exception {
      System.out.println(Target2.class.getDeclaredMethod("hello").getDeclaredAnnotations()[0]);
    }
    @Wibble
    public static void main(String []argv) throws Exception {
      System.out.println(Target3.class.getDeclaredMethod("hello").getDeclaredAnnotations().length);
      System.out.println(Target3.class.getDeclaredMethod("hello").getDeclaredAnnotations()[0]);
      System.out.println(Target3.class.getDeclaredMethod("hello").getDeclaredAnnotations()[1]);
    }
    @Tagged(31)
    public static void main(String []argv) throws Exception {
      System.out.println(Target4.class.getDeclaredMethod("hello").getDeclaredAnnotations().length);
      System.out.println(Target4.class.getDeclaredMethod("hello").getDeclaredAnnotations()[0]);
    }
======= fetch "public boolean weave() {" 2393bef^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" 2393bef^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" 2393bef^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" 2393bef^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" 2393bef^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" 2393bef^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtField(LazyClassGen clazz) {" 2393bef^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtField(LazyClassGen clazz) {" 2393bef^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private void reportFieldAnnotationWeavingMessage(LazyClassGen clazz, BcelField t" 2393bef^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean doesAlreadyHaveAnnotation(ResolvedMember rm, DeclareAnnotation d" 2393bef^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public static Type makeBcelType(UnresolvedType type) {" 2393bef^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= fetch "public void demote(ResolvedType type) {" 2393bef^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= fetch "public void addParameterAnnotation(int parameterNumber, AnnotationAJ anno) {" 2393bef^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"


======= fetch "public void initialize() {" 0c0adc5^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

======= fetch "public void initialize() {" 0c0adc5^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

======= fetch "public static void checkQ() {" 0c0adc5^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

======= fetch "public static void checkQ() {" 0c0adc5^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

======= fetch "private void registerOptions(final BcelWeaver weaver, final ClassLoader loader," 0c0adc5^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= fetch "public static WeaverOption parse(String options, ClassLoader laoder, IMessageHan" 0c0adc5^:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

======= fetch "public static WeaverOption parse(String options, ClassLoader laoder, IMessageHan" 0c0adc5^:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

======= fetch "public static WeaverOption parse(String options, ClassLoader laoder, IMessageHan" 0c0adc5^:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

======= fetch "public static WeaverOption parse(String options, ClassLoader laoder, IMessageHan" 0c0adc5^:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

======= fetch "public static WeaverOption parse(String options, ClassLoader laoder, IMessageHan" 0c0adc5^:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

  before(): execution(* *(..)) {
    System.out.println("advice");
  }
  public static void main(String []argv) {
    System.out.println("running");
  }
 <aspects>
  <aspect name="Azpect"/>
 </aspects>
 <weaver options="-verbose"/>
 <aspects>
  <aspect name="Azpect"/>
 </aspects>
 <weaver options="-verbose -loadersToSkip:com.foo.Bar"/>
 <aspects>
  <aspect name="Azpect"/>
 </aspects>
 <weaver options="-verbose -loadersToSkip:org.aspectj.weaver.loadtime.WeavingURLClassLoader"/>
======= fetch "public void testSuperItdCtor_413378() throws Exception {" 0c0adc5^:"tests/src/org/aspectj/systemtest/ajc174/Ajc174Tests.java"

      <compile files="Code.java" classpath="$sandbox/foo.jar"/>
      <run class="Code" classpath="$sandbox/foo.jar" ltw="aop1.xml">
        <stdout>
          <line text="advice"/>
          <line text="running"/>
 	    </stdout>
 	    <stderr>
 	    <line text="AspectJ Weaver"/>
 	    <line text="register classloader"/>
 	    <line text="using configuration"/>
 	    <line text="register aspect"/>
 	    <line text="processing reweavable"/>
 	    </stderr>
      </run>
      <compile files="Code.java" classpath="$sandbox/foo.jar"/>
      <run class="Code" classpath="$sandbox/foo.jar" ltw="aop1.xml">
        <stdout>
          <line text="advice"/>
          <line text="running"/>
 	    </stdout>
 	    <stderr>
 	    <line text="AspectJ Weaver"/>
 	    <line text="register classloader"/>
 	    <line text="using configuration"/>
 	    <line text="no longer creating weavers for these classloaders: [foo]"/>
 	    <line text="register aspect"/>
 	    <line text="processing reweavable"/>
 	    </stderr>
      </run>
      <compile files="Code.java" classpath="$sandbox/foo.jar"/>
      <run class="Code" classpath="$sandbox/foo.jar" ltw="aop1.xml">
        <stdout>
          <line text="advice"/>
          <line text="running"/>
 	    </stdout>
 	    <stderr>
 	    <line text="AspectJ Weaver"/>
 	    <line text="register classloader"/>
 	    <line text="using configuration"/>
 	    <line text="register aspect"/>
 	    <line text="processing reweavable"/>
 	    </stderr>
      </run>
      <compile files="Code.java" classpath="$sandbox/foo.jar"/>
      <run class="Code" classpath="$sandbox/foo.jar" ltw="aop2.xml">
        <stdout>
          <line text="advice"/>
          <line text="running"/>
 	    </stdout>
 	    <stderr>
 	    <line text="AspectJ Weaver"/>
 	    <line text="register classloader"/>
 	    <line text="using configuration"/>
 	    <line text="no longer creating weavers for these classloaders: [com.foo.Bar]"/>
 	    <line text="register aspect"/>
 	    <line text="processing reweavable"/>
 	    </stderr>
      </run>
      <compile files="Code.java" classpath="$sandbox/foo.jar"/>
      <run class="Code" classpath="$sandbox/foo.jar" ltw="aop3.xml">
        <stdout>
          <line text="advice"/>
          <line text="running"/>
 	    </stdout>
 	    <stderr>
 	    <line text="AspectJ Weaver"/>
 	    <line text="register classloader"/>
 	    <line text="using configuration"/>
 	    <line text="no longer creating weavers for these classloaders: [org.aspectj.weaver.loadtime.WeavingURLClassLoader]"/>
 	    <line text="register aspect"/>
 	    <line text="processing reweavable"/>
 	    </stderr>
      </run>

    public String mParent = "John";
    
    public Child(String parent) {
        this.mParent = parent;
    }
    
    public String getParent()
    {
        return this.mParent;
    }
    private String mName = "John";
    private int mAge = 50;
    
    public int getAge(){
        return mAge;
    }
    public Child.new(String parent, int age) {
        this(parent);
        
        System.out.println("Get Age:" + super.getAge());
        System.out.println("Child Name:" + this.mParent);
    }
  public static void main(String []argv) {
    new Child("Andy",5);
  }
======= fetch "public static Test suite() {" 302c14e^:"tests/src/org/aspectj/systemtest/AllTests17.java"

 * Copyright (c) 2013 Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
 * @author Andy Clement
 */
 * Copyright (c) 2013 Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
======= fetch "private void addNeededSuperCallMethods(BcelClassWeaver weaver, ResolvedType onTy" 302c14e^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private void addNeededSuperCallMethods(BcelClassWeaver weaver, ResolvedType onTy" 302c14e^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private void addNeededSuperCallMethods(BcelClassWeaver weaver, ResolvedType onTy" 302c14e^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewConstructor(BcelClassWeaver weaver, NewConstructorTypeMu" 302c14e^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"


======= fetch "public ReferenceTypeDelegate getDelegate(ReferenceType referenceType) {" e6cb508^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"


======= fetch "synchronized void addDependentType(ReferenceType dependent) {" 3f6e166^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public void checkDuplicates(ReferenceType newRt) {" 3f6e166^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public void checkDuplicates(ReferenceType newRt) {" 3f6e166^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public void setDelegate(ReferenceTypeDelegate delegate) {" 3f6e166^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public void setDelegate(ReferenceTypeDelegate delegate) {" 3f6e166^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public void setDelegate(ReferenceTypeDelegate delegate) {" 3f6e166^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public void addParent(ResolvedType newParent) {" 3f6e166^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public ReferenceType findDerivativeType(ResolvedType[] typeParameters) {" 3f6e166^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public ReferenceType findDerivativeType(ResolvedType[] typeParameters) {" 3f6e166^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public ReferenceType findDerivativeType(ResolvedType[] typeParameters) {" 3f6e166^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"


======= fetch "public void weaveParentTypeMungers(ResolvedType onType) {" ff0859d^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


======= fetch "public ResolvedMember lookupResolvedMember(ResolvedMember aMember, boolean allow" 4e34477^:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"


======= fetch "public static ResolvedMember perObjectBind(UnresolvedType declaringType) {" be5a530^:"org.aspectj.matcher/src/org/aspectj/weaver/AjcMemberMaker.java"


======= fetch "protected void resolveAnnotationValues(ResolvedType annotationType, IScope scope" edb41e3^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

  String[] value();
  @Anno({"xyz","abc"})
  public void m() {}
  pointcut p(): execution(public * @Anno(value="xyz=abc") *..*(..));
  before() : p() { }
      <compile files="Code.java" options="-1.5">
      	<message kind="error" text="Compiler limitation: annotation value support not implemented for type java.lang.String[]"/>
      </compile>
    </ajc-test>
    

======= fetch "public String getSignature() {" 46f9079^:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariable.java"

======= fetch "public String getSignature() {" 46f9079^:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariable.java"

======= fetch "public String getSignatureForAttribute() {" 46f9079^:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariable.java"

======= fetch "public String getSignatureForAttribute() {" 46f9079^:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariable.java"

  declare parents: Bug.ClassA implements java.io.Serializable;
    public static class ClassA<T extends Interface1 & Interface2> {
    }
    public static class ClassB extends ClassA<ClassB> implements Interface1, Interface2 {
    }
    public interface Interface1 {
    }
    public interface Interface2 {
    }
    public static void main(String[] args) throws Exception {
        System.out.println(ClassB.class.getGenericSuperclass());
    }
    public static class ClassA2<T extends Interface12 & Interface22> implements java.io.Serializable {
    }
    public static class ClassB2 extends ClassA2<ClassB2> implements Interface12, Interface22 {
    }
    public interface Interface12 {
    }
    public interface Interface22 {
    }
    public static void main(String[] args) throws Exception {
        System.out.println(ClassB2.class.getGenericSuperclass());
    }
======= fetch "public void testPSignatures_pr399590() throws Exception {" 46f9079^:"tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"

======= fetch "public void testPSignatures_pr399590_2() throws Exception {" 46f9079^:"tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"

======= fetch "public void testPSignatures_pr399590_3() throws Exception {" 46f9079^:"tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"

======= fetch "public void testPSignatures_pr399590_4() throws Exception {" 46f9079^:"tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"

======= fetch "public void testPSignatures_pr399590_5() throws Exception {" 46f9079^:"tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"

      <compile files="Bug.java" options="-1.5"/>
      <compile files="Bug2.java" options="-1.5"/>
      <run class="Bug2"/>
      <run class="Bug"/>
    </ajc-test>
    

======= fetch "public UnresolvedType parameterize(Map<String, UnresolvedType> typeBindings) {" 4af4b1e^:"org.aspectj.matcher/src/org/aspectj/weaver/BoundedReferenceType.java"

  declare parents: Cage2 implements java.io.Serializable;
  declare parents: Cage2 implements java.io.Serializable;
  declare parents: Cage2 implements java.io.Serializable;
      <compile files="Cage.java" options="-1.5"/>
      <compile files="Cage2.java" options="-1.5"/>
    </ajc-test>
    
      <compile files="Cage.java" options="-1.5"/>
      <compile files="Cage2.java" options="-1.5"/>
    </ajc-test>
    
      <compile files="Cage.java" options="-1.5"/>
      <compile files="Cage2.java" options="-1.5"/>
    </ajc-test>
    
      <compile files="Cage.java" options="-1.5"/>
      <compile files="Cage2.java" options="-1.5"/>
    </ajc-test>
    
      <compile files="Cage.java" options="-1.5"/>
      <compile files="Cage2.java" options="-1.5"/>
    </ajc-test>
    

======= fetch "public boolean hasAnnotation(UnresolvedType ofType) {" d524403^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

======= fetch "public boolean hasAnnotation(UnresolvedType ofType) {" d524403^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"


 */ 
======= fetch "public void testInconsistentClassFile_pr389750() {" 96ebaae^:"tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"

======= fetch "public void testAnnotationValueError_pr389752_2() {" 96ebaae^:"tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"

  
======= fetch "public boolean hasUnsatisfiedDependency(ResolvedType aspectType) {" 96ebaae^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= fetch "public boolean hasUnsatisfiedDependency(ResolvedType aspectType) {" 96ebaae^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= fetch "public boolean hasUnsatisfiedDependency(ResolvedType aspectType) {" 96ebaae^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= fetch "public boolean hasUnsatisfiedDependency(ResolvedType aspectType) {" 96ebaae^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= fetch "public boolean hasUnsatisfiedDependency(ResolvedType aspectType) {" 96ebaae^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= fetch "public boolean hasUnsatisfiedDependency(ResolvedType aspectType) {" 96ebaae^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= fetch "public void addAspectRequires(String name, String requiredType) {" 96ebaae^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"


======= fetch "public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, I" 3e5af0f^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/AndPointcut.java"

======= fetch "public Pointcut parameterizeWith(Map typeVariableMap, World w) {" 3e5af0f^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/AndPointcut.java"


======= fetch "protected String getCommonSuperClass(final String type1, final String type2) {" fc55431^:"weaver/src/org/aspectj/weaver/bcel/asm/StackMapAdder.java"


======= fetch "public static boolean isEmpty(Object[] ra) {" df1823b^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public File getIndexFile () {" df1823b^:"weaver/src/org/aspectj/weaver/tools/cache/AbstractIndexedFileCacheBacking.java"

======= fetch "protected void writeIndex (File indexFile, Collection<? extends IndexEntry> entr" df1823b^:"weaver/src/org/aspectj/weaver/tools/cache/AbstractIndexedFileCacheBacking.java"

    public static final IndexEntry createIndexEntry (CachedClassEntry classEntry, byte[] originalBytes) {
        if (classEntry == null) {
            return null;
        }
        IndexEntry  indexEntry = new IndexEntry();
        indexEntry.key = classEntry.getKey();
        indexEntry.generated = classEntry.isGenerated();
        indexEntry.ignored = classEntry.isIgnored();
        if (!classEntry.isIgnored()) {
        	indexEntry.crcClass = crc(originalBytes);
            indexEntry.crcWeaved = crc(classEntry.getBytes());
        }
        return indexEntry;
    }
 * Copyright (c) 2012 Contributors.
 * All rights reserved.
 * This program and the accompanying materials are made available
 * under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution and is available at
 * http://eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Lyor Goldstein (vmware)	add support for weaved class being re-defined
 *******************************************************************************/
 * Uses a background thread to do the actual I/O and for caching &quot;persistence&quot;
 * so that the caching works faster on repeated activations of the application.
 * The class maintains an in-memory cache, and uses a queue of {@link AsyncCommand}s
 * to signal to a background thread various actions required to &quot;synchronize&quot;
 * the in-memory cache with the persisted copy. Whenever there is a cache miss
 * from the {@link #get(CachedClassReference)} call, the weaver issues a
 * {@link #put(CachedClassEntry)} call. This call has 2 side-effects:</BR>
 * <UL>
 * 		<LI>
 * 		The in-memory cache is updated so that subsequent calls to {@link #get(CachedClassReference)}
 * 		will not return the mapped value.
 * 		</LI>
 * 
 *  	<LI>
 *  	An &quot;update index&quot {@link AsyncCommand} is posted to the background
 *  	thread so that the newly mapped value will be persisted (eventually)
 *  	</LI> 
 * </UL>
 * The actual persistence is implemented by the <U>concrete</U> classes
 */
    private static final BlockingQueue<AsyncCommand>   commandsQ=new LinkedBlockingQueue<AsyncCommand>();
    private static final ExecutorService    execService=Executors.newSingleThreadExecutor();
    private static Future<?> commandsRunner;
    protected final Map<String, IndexEntry> index, exposedIndex;
    protected final Map<String, byte[]>   bytesMap, exposedBytes;
    protected AsynchronousFileCacheBacking (File cacheDir) {
    	super(cacheDir);
        index = readIndex(cacheDir, getIndexFile());
        exposedIndex = Collections.unmodifiableMap(index);
        bytesMap = readClassBytes(index, cacheDir);
        exposedBytes = Collections.unmodifiableMap(bytesMap);
    }
    @Override
        String              key=ref.getKey();
        final IndexEntry    indexEntry;
        synchronized(index) {
            if ((indexEntry=index.get(key)) == null) {
                return null;
            }
        }
        if (crc(originalBytes) != indexEntry.crcClass) {
            if ((logger != null) && logger.isTraceEnabled()) {
                logger.debug("get(" + getCacheDirectory() + ") mismatched original class bytes CRC for " + key);
            }
            remove(key);
            return null;
        }
        if (indexEntry.ignored) {
            return new CachedClassEntry(ref, WeavedClassCache.ZERO_BYTES, CachedClassEntry.EntryType.IGNORED);
        }
        final byte[]    bytes;
        synchronized(bytesMap) {
            /*
             * NOTE: we assume that keys represent classes so if we have their
             * bytes they will not be re-created
             */
            if ((bytes=bytesMap.remove(key)) == null) {
                return null;
            }
        }
        if (indexEntry.generated) {
            return new CachedClassEntry(ref, bytes, CachedClassEntry.EntryType.GENERATED);
        } else {
            return new CachedClassEntry(ref, bytes, CachedClassEntry.EntryType.WEAVED);
        }
    }
    public void put(CachedClassEntry entry, byte[] originalBytes) {
        String  key=entry.getKey();
        byte[]  bytes=entry.isIgnored() ? null : entry.getBytes();
        synchronized(index) {
            IndexEntry  indexEntry=index.get(key);
            if (indexEntry != null) {
                return;
            }
            /*
             * Note: we do not cache the class bytes - only send them to
             * be saved. The assumption is that the 'put' call was invoked
             * because 'get' failed to return any bytes. And since we assume
             * that each class bytes are required only once, there is no
             * need to cache them
             */
            indexEntry = createIndexEntry(entry, originalBytes);
            index.put(key, indexEntry);
        }
        if (!postCacheCommand(new InsertCommand(this, key, bytes))) {
            if ((logger != null) && logger.isTraceEnabled()) {
                logger.error("put(" + getCacheDirectory() + ") Failed to post insert command for " + key);
            }
        }
        if ((logger != null) && logger.isTraceEnabled()) {
            logger.debug("put(" + getCacheDirectory() + ")[" + key + "] inserted");
        }
    }
    public void remove(CachedClassReference ref) {
    	remove(ref.getKey());
    }
    protected IndexEntry remove (String key) {
        IndexEntry  entry;
        synchronized(index) {
            entry = index.remove(key);
        }
        synchronized(bytesMap) {
            bytesMap.remove(key);
        }
        if (!postCacheCommand(new RemoveCommand(this, key))) {
            if ((logger != null) && logger.isTraceEnabled()) {
                logger.error("remove(" + getCacheDirectory() + ") Failed to post remove command for " + key);
            }
        }
        
        if (entry != null) {
            if (!key.equals(entry.key)) {
                if ((logger != null) && logger.isTraceEnabled()) {
                    logger.error("remove(" + getCacheDirectory() + ") Mismatched keys: " + key + " / " + entry.key);
                }
            } else if ((logger != null) && logger.isTraceEnabled()) {
                logger.debug("remove(" + getCacheDirectory() + ")[" + key + "] removed");
            }
        }
        return entry;
    }
    public List<IndexEntry> getIndexEntries () {
        synchronized(index) {
            if (index.isEmpty()) {
                return Collections.emptyList();
            } else {
                return new ArrayList<IndexEntry>(index.values());
            }
        }
    }
    public Map<String, IndexEntry> getIndexMap () {
        return exposedIndex;
    }
    public Map<String, byte[]> getBytesMap () {
        return exposedBytes;
    }
    public void clear() {
        synchronized(index) {
            index.clear();
        }
        if (!postCacheCommand(new ClearCommand(this))) {
            if ((logger != null) && logger.isTraceEnabled()) {
                logger.error("Failed to post clear command for " + getIndexFile());
            }
        }
    }
    protected void executeCommand (AsyncCommand cmd) throws Exception {
        if (cmd instanceof ClearCommand) {
            executeClearCommand();
        } else if (cmd instanceof UpdateIndexCommand) {
            executeUpdateIndexCommand();
        } else if (cmd instanceof InsertCommand) {
            executeInsertCommand((InsertCommand) cmd);
        } else if (cmd instanceof RemoveCommand) {
            executeRemoveCommand((RemoveCommand) cmd);
        } else {
            throw new UnsupportedOperationException("Unknown command: " + cmd);
        }
    }
    protected void executeClearCommand () throws Exception {
        FileUtil.deleteContents(getIndexFile());
        FileUtil.deleteContents(getCacheDirectory());
    }
    protected void executeUpdateIndexCommand () throws Exception {
        writeIndex(getIndexFile(), getIndexEntries());
    }
    protected void executeInsertCommand (InsertCommand cmd) throws Exception {
        writeIndex(getIndexFile(), getIndexEntries());
        byte[]  bytes=cmd.getClassBytes();
        if (bytes != null) {
            writeClassBytes(cmd.getKey(), bytes);
        }
    }
    protected void executeRemoveCommand (RemoveCommand cmd) throws Exception {
        Exception err=null;
        try {
            removeClassBytes(cmd.getKey());
        } catch(Exception e) {
            err = e;
        }
        writeIndex(getIndexFile(), getIndexEntries());
        if (err != null) {
            throw err;  // check if the class bytes remove had any problems
        }
    }
    /**
     * Helper for {@link #executeRemoveCommand(RemoveCommand)}
     * @param key The key representing the class whose bytes are to be removed
     * @throws Exception if failed to remove class bytes
     */
    protected abstract void removeClassBytes (String key) throws Exception;
    protected abstract Map<String, byte[]> readClassBytes (Map<String,IndexEntry> indexMap, File cacheDir);
    @Override
    public String toString() {
        return getClass().getSimpleName() + "[" + String.valueOf(getCacheDirectory()) + "]";
    }
    protected static final <T extends AsynchronousFileCacheBacking> T createBacking (
                            File cacheDir, AsynchronousFileCacheBackingCreator<T> creator) {
        final Trace trace=TraceFactory.getTraceFactory().getTrace(AsynchronousFileCacheBacking.class);
        if (!cacheDir.exists()) {
            if (!cacheDir.mkdirs()) {
                if ((trace != null) && trace.isTraceEnabled()) {
                    trace.error("Unable to create cache directory at " + cacheDir.getAbsolutePath());
                }
                return null;
            }
        }
        if (!cacheDir.canWrite()) {
            if ((trace != null) && trace.isTraceEnabled()) {
                trace.error("Cache directory is not writable at " + cacheDir.getAbsolutePath());
            }
            return null;
        }
        // start the service (if needed) only if successfully create the backing instance
        T    backing=creator.create(cacheDir);
        synchronized(execService) {
            if (commandsRunner == null) {
                commandsRunner = execService.submit(new Runnable() {
                    @SuppressWarnings("synthetic-access")
                    public void run() {
                        for ( ; ; ) {
                            try {
                                AsyncCommand    cmd=commandsQ.take();
                                try {
                                    AsynchronousFileCacheBacking    cache=cmd.getCache();
                                    cache.executeCommand(cmd);
                                } catch(Exception e) {
                                    if ((trace != null) && trace.isTraceEnabled()) {
                                        trace.error("Failed (" + e.getClass().getSimpleName() + ")"
                                                  + " to execute " + cmd + ": " + e.getMessage(), e);
                                    }
                                }
                            } catch(InterruptedException e) {
                                if ((trace != null) && trace.isTraceEnabled()) {
                                    trace.warn("Interrupted");
                                }
                                Thread.currentThread().interrupt();
                                break;
                            }
                        }
                    }
                });
            }
        }
        // fire-up an update-index command in case index was changed by the constructor
        if (!postCacheCommand(new UpdateIndexCommand(backing))) {
            if ((trace != null) && trace.isTraceEnabled()) {
                trace.warn("Failed to offer update index command to " + cacheDir.getAbsolutePath());
            }
        }
        return backing;
    }
    public static final boolean postCacheCommand (AsyncCommand cmd) {
        return commandsQ.offer(cmd);
    }
    public static interface AsynchronousFileCacheBackingCreator<T extends AsynchronousFileCacheBacking> {
        T create (File cacheDir);
    }
    /**
     * Represents an asynchronous command that can be sent to the
     * {@link AsynchronousFileCacheBacking} instance to be executed
     * on it <U>asynchronously</U>
     */
    public static interface AsyncCommand {
        /**
         * @return The {@link AsynchronousFileCacheBacking} on which
         * this command is supposed to be executed
         * @see AsynchronousFileCacheBacking#executeCommand(AsyncCommand)
         */
        AsynchronousFileCacheBacking getCache ();
    }
    public static abstract class AbstractCommand implements AsyncCommand {
        private final AsynchronousFileCacheBacking  cache;
        protected AbstractCommand (AsynchronousFileCacheBacking backing) {
            if ((cache=backing) == null) {
                throw new IllegalStateException("No backing cache specified");
            }
        }
        public final AsynchronousFileCacheBacking getCache () {
            return cache;
        }
        
        @Override
        public String toString() {
            return getClass().getSimpleName() + "[" + getCache() + "]";
        }
    }
    public static class ClearCommand extends AbstractCommand {
        public ClearCommand (AsynchronousFileCacheBacking cache) {
            super(cache);
        }
    }
    public static class UpdateIndexCommand extends AbstractCommand {
        public UpdateIndexCommand (AsynchronousFileCacheBacking cache) {
            super(cache);
        }
    }
    /**
     * Base class for {@link AbstractCommand}s that refer to a cache key
     */
    public static abstract class KeyedCommand extends AbstractCommand {
        private final String    key;
        protected KeyedCommand (AsynchronousFileCacheBacking cache, String keyValue) {
            super(cache);
            
            if (LangUtil.isEmpty(keyValue)) {
                throw new IllegalStateException("No key value");
            }
            key = keyValue;
        }
        public final String getKey () {
            return key;
        }
        @Override
        public String toString() {
            return super.toString() + "[" + getKey() + "]";
        }
    }
    public static class RemoveCommand extends KeyedCommand {
        public RemoveCommand (AsynchronousFileCacheBacking cache, String keyValue) {
            super(cache, keyValue);
        }
    }
    
    public static class InsertCommand extends KeyedCommand {
        private final byte[]    bytes;
        public InsertCommand (AsynchronousFileCacheBacking cache, String keyValue, byte[] classBytes) {
            super(cache, keyValue);
            bytes = classBytes;
        }
        public final byte[] getClassBytes () {
            return bytes;
        }
    }
======= fetch "public void put(CachedClassEntry entry, byte[] originalBytes) {" df1823b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public void put(CachedClassEntry entry, byte[] originalBytes) {" df1823b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

 * Copyright (c) 2012 VMware, Inc. custard
 * 
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 * Lyor Goldstein
 * ******************************************************************/
 * Uses a &quot;flat&quot files model to store the cached instrumented classes
 * and aspects - i.e., each class/aspect is stored as a <U>separate</U> (binary)
 * file. This is a good mechanism when the number of instrumented class is
 * relatively small (a few 10's). The reason for it is that scanning a folder
 * that has many files in it quickly becomes an I/O bottleneck. Also, some
 * O/S-es may impose internal limits on the maximum number of &quot;children&quot;
 * a folder node may have. On the other hand, it is much faster (again, for
 * small number of instrumented classes) than the ZIP cache since each class/aspect
 * is represented by a single file - thus adding/removing/modifying it is easier. 
 * 
 * @author Lyor Goldstein
 */
    private static final AsynchronousFileCacheBackingCreator<FlatFileCacheBacking>    defaultCreator=
            new AsynchronousFileCacheBackingCreator<FlatFileCacheBacking>() {
                public FlatFileCacheBacking create(File cacheDir) {
                    return new FlatFileCacheBacking(cacheDir);
                }
        };
    public FlatFileCacheBacking(File cacheDir) {
        super(cacheDir);
    }
    public static final FlatFileCacheBacking createBacking (File cacheDir) {
        return createBacking(cacheDir, defaultCreator);
    }
    @Override
    protected Map<String, byte[]> readClassBytes(Map<String, IndexEntry> indexMap, File cacheDir) {
        return readClassBytes(indexMap, cacheDir.listFiles());
    }
    protected Map<String, byte[]> readClassBytes (Map<String,IndexEntry> indexMap, File[] files) {
        Map<String, byte[]> result=new TreeMap<String, byte[]>();
        if (LangUtil.isEmpty(files)) {
            return result;
        }
        for (File file : files) {
            if (!file.isFile()) {
                continue;   // skip sub-directories - we expect flat files
            }
            String  key=file.getName();
            if (INDEX_FILE.equalsIgnoreCase(key)) {
                continue;   // skip the index itself if found
            }
            IndexEntry  entry=indexMap.get(key);
            if ((entry == null) || entry.ignored) {    // if not in index or ignored then remove it
                if ((logger != null) && logger.isTraceEnabled()) {
                    logger.info("readClassBytes(" + key + ") remove orphan/ignored: " + file.getAbsolutePath());
                }
                FileUtil.deleteContents(file);
                continue;
            }
            try {
                byte[]  bytes=FileUtil.readAsByteArray(file);
                long    crc=crc(bytes);
                if (crc != entry.crcWeaved) {
                    throw new StreamCorruptedException("Mismatched CRC - expected=" + entry.crcWeaved + "/got=" + crc);
                }
                result.put(key, bytes);
                if ((logger != null) && logger.isTraceEnabled()) {
                    logger.debug("readClassBytes(" + key + ") cached from " + file.getAbsolutePath());
                }
            } catch(IOException  e) {
                if ((logger != null) && logger.isTraceEnabled()) {
                    logger.error("Failed (" + e.getClass().getSimpleName() + ")"
                               + " to read bytes from " + file.getAbsolutePath()
                               + ": " + e.getMessage());
                }
                indexMap.remove(key);   // no need for the entry if no file - force a re-write of its bytes
                FileUtil.deleteContents(file);  // assume some kind of corruption
                continue;
            }
        }
        return result;
    }
    
    @Override
    protected IndexEntry resolveIndexMapEntry (File cacheDir, IndexEntry ie) {
        File cacheEntry = new File(cacheDir, ie.key);
        if (ie.ignored || cacheEntry.canRead()) {
            return ie;
        } else {
            return null;
        }
    }
    @Override
    protected void writeClassBytes (String key, byte[] bytes) throws Exception {
        File    dir=getCacheDirectory(), file=new File(dir, key);
        FileOutputStream    out=new FileOutputStream(file);
        try {
            out.write(bytes);
        } finally {
            out.close();
        }
    }
    @Override
    protected void removeClassBytes (String key) throws Exception {
        File        dir=getCacheDirectory(), file=new File(dir, key);
        if (file.exists() && (!file.delete())) {
            throw new StreamCorruptedException("Failed to delete " + file.getAbsolutePath());
        }
    }
 * Copyright (c) 2012 Contributors.
 * All rights reserved.
 * This program and the accompanying materials are made available
 * under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution and is available at
 * http://eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Lyor Goldstein (vmware)	add support for weaved class being re-defined
 *******************************************************************************/
 * Uses a ZIP file to store the instrumented classes/aspects - each one as a
 * <U>separate</U> {@link ZipEntry}. This mechanism is suitable for relatively
 * large numbers of instrumented classes/aspects (100's and more) since it
 * holds all of them in a single (ZIP) file. The down side is that any
 * modifications to the cache require re-writing the entire ZIP file. This
 * can cause the ZIP file to become corrupted if interrupted in mid-update,
 * thus requiring the re-population of the cache on next application activation
 * (though the overhead in this case is not prohibitvely high...)
 */
    public static final String ZIP_FILE = "cache.zip";
    private static final AsynchronousFileCacheBackingCreator<ZippedFileCacheBacking>    defaultCreator=
            new AsynchronousFileCacheBackingCreator<ZippedFileCacheBacking>() {
                public ZippedFileCacheBacking create(File cacheDir) {
                    return new ZippedFileCacheBacking(cacheDir);
                }
        };
    private final File  zipFile;
    public ZippedFileCacheBacking(File cacheDir) {
        super(cacheDir);
        zipFile = new File(cacheDir, ZIP_FILE);
    }
    public File getZipFile () {
        return zipFile;
    }
    public static final ZippedFileCacheBacking createBacking (File cacheDir) {
        return createBacking(cacheDir, defaultCreator);
    }
    @Override
    protected void writeClassBytes(String key, byte[] bytes) throws Exception {
        File                  outFile=getZipFile();
        Map<String,byte[]>    entriesMap;
        try {
            entriesMap = readZipClassBytes(outFile);
        } catch(Exception e) {
            if ((logger != null) && logger.isTraceEnabled()) {
                logger.warn("writeClassBytes(" + outFile + ")[" + key + "]"
                          + " failed (" + e.getClass().getSimpleName() + ")"
                          + " to read current data: " + e.getMessage(),
                            e);
            }
            
            FileUtil.deleteContents(outFile);
            return;
        }
        if (entriesMap.isEmpty()) {
            entriesMap = Collections.singletonMap(key, bytes);
        } else {
            entriesMap.put(key, bytes);
        }
        try {
            writeZipClassBytes(outFile, entriesMap);
        } catch(Exception e) {
            if ((logger != null) && logger.isTraceEnabled()) {
                logger.warn("writeClassBytes(" + outFile + ")[" + key + "]"
                          + " failed (" + e.getClass().getSimpleName() + ")"
                          + " to write updated data: " + e.getMessage(),
                            e);
            }
            
            FileUtil.deleteContents(outFile);
        }
    }
    @Override
    protected void removeClassBytes(String key) throws Exception {
        File                  outFile=getZipFile();
        Map<String,byte[]>    entriesMap;
        try {
            entriesMap = readZipClassBytes(outFile);
        } catch(Exception e) {
            if ((logger != null) && logger.isTraceEnabled()) {
                logger.warn("removeClassBytes(" + outFile + ")[" + key + "]"
                          + " failed (" + e.getClass().getSimpleName() + ")"
                          + " to read current data: " + e.getMessage(),
                            e);
            }
            
            FileUtil.deleteContents(outFile);
            return;
        }
        if (!entriesMap.isEmpty()) {
            if (entriesMap.remove(key) == null) {
                return; // not in the data file to begin with so nothing to update
            }
        }
        try {
            writeZipClassBytes(outFile, entriesMap);
        } catch(Exception e) {
            if ((logger != null) && logger.isTraceEnabled()) {
                logger.warn("removeClassBytes(" + outFile + ")[" + key + "]"
                          + " failed (" + e.getClass().getSimpleName() + ")"
                          + " to write updated data: " + e.getMessage(),
                            e);
            }
            
            FileUtil.deleteContents(outFile);
        }
    }
    @Override
    protected Map<String, byte[]> readClassBytes(Map<String, IndexEntry> indexMap, File cacheDir) {
        File                dataFile=new File(cacheDir, ZIP_FILE);
        Map<String,byte[]>  entriesMap;
        boolean             okEntries=true;
        try {
            entriesMap = readZipClassBytes(dataFile);
        } catch(Exception e) {
            if ((logger != null) && logger.isTraceEnabled()) {
                logger.warn("Failed (" + e.getClass().getSimpleName() + ")"
                          + " to read zip entries from " + dataFile
                          + ": " + e.getMessage(),
                          e);
            }
            entriesMap = new TreeMap<String,byte[]>();
            okEntries = false;
        }
        if (!syncClassBytesEntries(dataFile, indexMap, entriesMap)) {
            okEntries = false;
        }
        if (!okEntries) {
            FileUtil.deleteContents(dataFile);
            if (!entriesMap.isEmpty()) {
                entriesMap.clear();
            }
        }
        syncIndexEntries(dataFile, indexMap, entriesMap);
        return entriesMap;
    }
    // remove all non-ignored entries that have no class bytes
    protected Collection<String> syncIndexEntries (File dataFile, Map<String, IndexEntry> indexMap, Map<String,byte[]>  entriesMap) {
        Collection<String>  toDelete=null;
        for (Map.Entry<String, IndexEntry> ie : indexMap.entrySet()) {
            String      key=ie.getKey();
            IndexEntry  indexEntry=ie.getValue();
            if (indexEntry.ignored) {
                continue;   // ignored entries have no class bytes
            }
            if (entriesMap.containsKey(key)) {
                continue;
            }
            if ((logger != null) && logger.isTraceEnabled()) {
                logger.debug("syncIndexEntries(" + dataFile + ")[" + key + "] no class bytes");
            }
            if (toDelete == null) {
                toDelete = new TreeSet<String>();
            }
            toDelete.add(key);
        }
        if (toDelete == null) {
            return Collections.emptySet();
        }
        for (String key : toDelete) {
            indexMap.remove(key);
        }
        return toDelete;
    }
    // check if all class bytes entries are valid
    protected boolean syncClassBytesEntries (File dataFile, Map<String, IndexEntry> indexMap, Map<String,byte[]>  entriesMap) {
        boolean okEntries=true;
        for (Map.Entry<String,byte[]> bytesEntry : entriesMap.entrySet()) {
            String      key=bytesEntry.getKey();
            IndexEntry  indexEntry=indexMap.get(key);
            // ignored entries should have no bytes
            if ((indexEntry == null) || indexEntry.ignored) {
                if ((logger != null) && logger.isTraceEnabled()) {
                    logger.debug("syncClassBytesEntries(" + dataFile + ")[" + key + "] bad index entry");
                }
                okEntries = false;
                continue;
            }
            long    crc=crc(bytesEntry.getValue());
            if (crc != indexEntry.crcWeaved) {
                if ((logger != null) && logger.isTraceEnabled()) {
                    logger.debug("syncClassBytesEntries(" + dataFile + ")[" + key + "]"
                               + " mismatched CRC - expected=" + indexEntry.crcWeaved + "/got=" + crc);
                }
                indexMap.remove(key);
                okEntries = false;
                continue;
            }
        }
        return okEntries;
    }
    @Override
    protected IndexEntry resolveIndexMapEntry(File cacheDir, IndexEntry ie) {
        if (cacheDir.exists()) {
            return ie;  // we will take care of non-existing index entries in the readClassBytes method
        } else {
            return null;
        }
    }
    public static final Map<String,byte[]> readZipClassBytes (File file) throws IOException {
        if (!file.canRead()) {
            return Collections.emptyMap();
        }
        Map<String,byte[]>      result=new TreeMap<String,byte[]>();
        byte[]                  copyBuf=new byte[4096];
        ByteArrayOutputStream   out=new ByteArrayOutputStream(copyBuf.length);
        ZipFile                 zipFile=new ZipFile(file);
        try {
            for (Enumeration<? extends ZipEntry> entries=zipFile.entries(); (entries != null) && entries.hasMoreElements(); ) {
                ZipEntry    e=entries.nextElement();
                String      name=e.getName();
                if (LangUtil.isEmpty(name)) {
                    continue;
                }
                out.reset();
                InputStream zipStream=zipFile.getInputStream(e);
                try {
                    for (int    nRead=zipStream.read(copyBuf); nRead != (-1); nRead=zipStream.read(copyBuf)) {
                        out.write(copyBuf, 0, nRead);
                    }
                } finally {
                    zipStream.close();
                }
                byte[]  data=out.toByteArray(), prev=result.put(name, data);
                if (prev != null) {
                    throw new StreamCorruptedException("Multiple entries for " + name);
                }
            }
        } finally {
            zipFile.close();
        }
        return result;
    }
    
    public static final void writeZipClassBytes (File file, Map<String,byte[]> entriesMap) throws IOException {
        if (entriesMap.isEmpty()) {
            FileUtil.deleteContents(file);
            return;
        }
        File	zipDir=file.getParentFile();
        if ((!zipDir.exists()) && (!zipDir.mkdirs())) {
            throw new IOException("Failed to create path to " + zipDir.getAbsolutePath());
        }
        ZipOutputStream zipOut=new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(file), 4096));
        try {
            for (Map.Entry<String,byte[]> bytesEntry : entriesMap.entrySet()) {
                String      key=bytesEntry.getKey();
                byte[]      bytes=bytesEntry.getValue();
                zipOut.putNextEntry(new ZipEntry(key));
                zipOut.write(bytes);
                zipOut.closeEntry();
            }
        } finally {
            zipOut.close();
        }
    }
 * Copyright (c) 2012 Contributors.
 * All rights reserved.
 * This program and the accompanying materials are made available
 * under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution and is available at
 * http://eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Lyor Goldstein (vmware)	add support for weaved class being re-defined
 *******************************************************************************/
 */
    /**
     * Prefix used in URL(s) that reference a resource inside a JAR
     */
    public static final String	JAR_URL_PREFIX="jar:";
    /**
     * Separator used in URL(s) that reference a resource inside a JAR
     * to denote the sub-path inside the JAR
     */
    public static final char	RESOURCE_SUBPATH_SEPARATOR='!';
    protected File ensureTempFolderExists () throws IllegalStateException {
    	synchronized(TEMP_SUBFOLDER_NAME) {
    		if (testTempFolder == null) {
    			File	parent=detectTargetFolder();
    			testTempFolder = new File(parent, TEMP_SUBFOLDER_NAME);
    		}
    	}
    	return ensureFolderExists(testTempFolder);
    }
    protected File detectTargetFolder () throws IllegalStateException {
    	synchronized(TEMP_SUBFOLDER_NAME) {
    		if (targetFolder == null) {
    			if ((targetFolder=detectTargetFolder(getClass())) == null) {
    				throw new IllegalStateException("Failed to detect target folder");
    			}
    		}
    	}
    	return targetFolder;
    }
    protected File createTempFile (String prefix, String suffix) throws IOException {
    	File	destFolder=ensureTempFolderExists();
    	return File.createTempFile(prefix, suffix, destFolder);
    }
    public static final File ensureFolderExists (File folder) throws IllegalStateException {
    	if (folder == null) {
    		throw new IllegalArgumentException("No folder to ensure existence");
    	}
    	if ((!folder.exists()) && (!folder.mkdirs())) {
    		throw new IllegalStateException("Failed to create " + folder.getAbsolutePath());
    	}
    	return folder;
    }
    /**
     * @param anchor An anchor {@link Class} whose container we want to use
     * as the starting point for the &quot;target&quot; folder lookup up the
     * hierarchy
     * @return The &quot;target&quot; <U>folder</U> - <code>null</code> if not found
     * @see #detectTargetFolder(File)
     */
    public static final File detectTargetFolder (Class<?> anchor) {
    	return detectTargetFolder(getClassContainerLocationFile(anchor));
    }
    
    /**
     * @param anchorFile An anchor {@link File) we want to use
     * as the starting point for the &quot;target&quot; folder lookup up the
     * hierarchy
     * @return The &quot;target&quot; <U>folder</U> - <code>null</code> if not found
     */
    public static final File detectTargetFolder (File anchorFile) {
    	for (File	file=anchorFile; file != null; file=file.getParentFile()) {
    		if (!file.isDirectory()) {
    			continue;
    		}
    		
    		String	name=file.getName();
    		if ("bin".equals(name) || "src".equals(name)) {
    			File	parent=file.getParentFile();
    			return new File(parent, "target");
    		}
    	}
    	return null;
    }
    /**
     * @param clazz A {@link Class} object
     * @return A {@link File} of the location of the class bytes container
     * - e.g., the root folder, the containing JAR, etc.. Returns
     * <code>null</code> if location could not be resolved
     * @throws IllegalArgumentException If location is not a valid
     * {@link File} location
     * @see #getClassContainerLocationURI(Class)
     * @see File#File(URI) 
     */
    public static File getClassContainerLocationFile (Class<?> clazz)
            throws IllegalArgumentException {
        try {
            URI uri=getClassContainerLocationURI(clazz);
            return (uri == null) ? null : new File(uri);
        } catch(URISyntaxException e) {
            throw new IllegalArgumentException(e.getClass().getSimpleName() + ": " + e.getMessage(), e);
        }
    }
    /**
     * @param clazz A {@link Class} object
     * @return A {@link URI} to the location of the class bytes container
     * - e.g., the root folder, the containing JAR, etc.. Returns
     * <code>null</code> if location could not be resolved
     * @throws URISyntaxException if location is not a valid URI
     * @see #getClassContainerLocationURL(Class)
     */
    public static URI getClassContainerLocationURI (Class<?> clazz) throws URISyntaxException {
        URL url=getClassContainerLocationURL(clazz);
        return (url == null) ? null : url.toURI();
    }
    /**
     * @param clazz A {@link Class} object
     * @return A {@link URL} to the location of the class bytes container
     * - e.g., the root folder, the containing JAR, etc.. Returns
     * <code>null</code> if location could not be resolved
     */
    public static URL getClassContainerLocationURL (Class<?> clazz) {
        ProtectionDomain    pd=clazz.getProtectionDomain();
        CodeSource          cs=(pd == null) ? null : pd.getCodeSource();
        URL					url=(cs == null) ? null : cs.getLocation();
        if (url == null) {
        	ClassLoader	cl=getDefaultClassLoader(clazz);
        	String		className=clazz.getName().replace('.', '/') + ".class";
        	if ((url=cl.getResource(className)) == null) {
        		return null;
        	}
        	
        	String	srcForm=getURLSource(url);
        	if (LangUtil.isEmpty(srcForm)) {
        		return null;
        	}
        	try {
        		url = new URL(srcForm);
        	} catch(MalformedURLException e) {
        		throw new IllegalArgumentException("getClassContainerLocationURL(" + clazz.getName() + ")"
        										  + "Failed to create URL=" + srcForm + " from " + url.toExternalForm()
        										  + ": " + e.getMessage());
        	}
        }
        return url;
    }
    /**
     * @param anchor An &quot;anchor&quot; {@link Class} to be used in case
     * no thread context loader is available
     * @return A {@link ClassLoader} to be used by the caller. The loader is
     * resolved in the following manner:</P></BR>
     * <UL>
     *      <LI>
     *      If a non-<code>null</code> loader is returned from the
     *      {@link Thread#getContextClassLoader()} call then use it.
     *      </LI>
     *      
     *      <LI>
     *      Otherwise, use the same loader that was used to load the anchor class.
     *      </LI>
     * </UL>
     * @throws IllegalArgumentException if no anchor class provided (regardless of
     * whether it is used or not) 
     */
    public static ClassLoader getDefaultClassLoader(Class<?> anchor) {
        if (anchor == null) {
            throw new IllegalArgumentException("No anchor class provided");
        }
        Thread      t=Thread.currentThread();
        ClassLoader cl=t.getContextClassLoader();
        if (cl == null) {
            // No thread context class loader -> use class loader of this class.
            cl = anchor.getClassLoader();
        }
        if (cl == null) {	// no class loader - assume system
        	cl = ClassLoader.getSystemClassLoader();
        }
        return cl;
        
    }
    public static final String getURLSource (File file) {
    	return getURLSource((file == null) ? null : file.toURI());
    }
    public static final String getURLSource (URI uri) {
    	return getURLSource((uri == null) ? null : uri.toString());
    }
    /**
     * @param url The {@link URL} value - ignored if <code>null</code>
     * @return The URL(s) source path where {@link #JAR_URL_PREFIX} and
     * any sub-resource are stripped
     * @see #getURLSource(String)
     */
    public static final String getURLSource (URL url) {
    	return getURLSource((url == null) ? null : url.toExternalForm());
    }
    
    /**
     * @param externalForm The {@link URL#toExternalForm()} string - ignored if
     * <code>null</code>/empty
     * @return The URL(s) source path where {@link #JAR_URL_PREFIX} and
     * any sub-resource are stripped
     */
    public static final String getURLSource (String externalForm) {
    	if (LangUtil.isEmpty(url)) {
    		return url;
    	}
    	url = stripJarURLPrefix(externalForm);
    	if (LangUtil.isEmpty(url)){
    		return url;
    	}
    	
    	int	sepPos=url.indexOf(RESOURCE_SUBPATH_SEPARATOR);
    	if (sepPos < 0) {
    		return adjustURLPathValue(url);
    	} else {
    		return adjustURLPathValue(url.substring(0, sepPos));
    	}
    }
    /**
     * @param path A URL path value
     * @return The path after stripping any trailing '/' provided the path
     * is not '/' itself
     */
    public static final String adjustURLPathValue(final String path) {
        final int   pathLen=LangUtil.isEmpty(path) ? 0 : path.length();
        if ((pathLen <= 1) || (path.charAt(pathLen - 1) != '/')) {
            return path;
        }
        return path.substring(0, pathLen - 1);
    }
    public static final String adjustURLPathValue(URL url) {
        return adjustURLPathValue((url == null) ? null : url.getPath());
    }
    	if (LangUtil.isEmpty(url)) {
    		return url;
    	}
    	if (url.startsWith(JAR_URL_PREFIX)) {
    		return url.substring(JAR_URL_PREFIX.length());
    	}    	
    	
    	return url;
    protected static final void writeIndex (File indexFile, IndexEntry ... entries) throws IOException {
        writeIndex(indexFile, LangUtil.isEmpty(entries) ? Collections.<IndexEntry>emptyList() : Arrays.asList(entries));
    }
    protected static final void writeIndex (File indexFile, Collection<? extends IndexEntry> entries) throws IOException {
        File    indexDir=indexFile.getParentFile();
        if ((!indexDir.exists()) && (!indexDir.mkdirs())) {
            throw new IOException("Failed to create path to " + indexFile.getAbsolutePath());
        }
        int             numEntries=LangUtil.isEmpty(entries) ? 0 : entries.size();
        IndexEntry[]    entryValues=(numEntries <= 0) ? null : entries.toArray(new IndexEntry[numEntries]);
        // if no entries, simply delete the index file
        if (LangUtil.isEmpty(entryValues)) {
            if (indexFile.exists() && (!indexFile.delete())) {
                throw new StreamCorruptedException("Failed to clean up index file at " + indexFile.getAbsolutePath());
            }
            return;
        }
        ObjectOutputStream oos=new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(indexFile), 4096));
        try {
            oos.writeObject(entryValues);
        } finally {
            oos.close();
        }
    }
    public static final void assertArrayEquals (String msg, byte[] expected, byte[] actual) {
    	int	eLen=LangUtil.isEmpty(expected) ? 0 : expected.length;
    	int	aLen=LangUtil.isEmpty(actual) ? 0 : expected.length;
    	assertEquals(msg + "[mismatched length]", eLen, aLen);
    	for (int	index=0; index < eLen; index++) {
    		byte	eb=expected[index], ab=actual[index];
    		if (eb != ab) {
    			fail(msg + ": Mismatched value at index=" + index
    			   + " - " + ab + " instead of " + eb
    			   + ": expected=" + Arrays.toString(expected) + ", actual=" + Arrays.toString(actual));
    		}
    	}
    }
 * Copyright (c) 2012 Contributors.
 * All rights reserved.
 * This program and the accompanying materials are made available
 * under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution and is available at
 * http://eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Lyor Goldstein (vmware)	add support for weaved class being re-defined
 *******************************************************************************/
 */
    private File  cacheDir, indexFile;
    protected final byte[]    bytes=new byte[Byte.MAX_VALUE];
    protected final Random    random=new Random(System.nanoTime());
    @Override
    public void setUp () throws Exception {
    	super.setUp();
    	cleanupCache();
    	
        random.nextBytes(bytes);
    }
    @Override
    public void tearDown () throws Exception {
    	cleanupCache();
    	super.tearDown();
    }
   
    protected void cleanupCache() {
    	if (indexFile != null) {
    		if (FileUtil.deleteContents(indexFile) > 0) {
    			System.out.println("Deleted " + indexFile);
    		}
    		indexFile = null;
    	}
    	if (cacheDir != null) {
    		if (FileUtil.deleteContents(cacheDir) > 0) {
    			System.out.println("Deleted " + cacheDir);
    		}
    		cacheDir = null;
    	}
    }
    protected File getIndexFile () {
    	if (indexFile == null) {
    		File	parent=getCacheDir();
    		indexFile=new File(parent, AbstractIndexedFileCacheBacking.INDEX_FILE);
    	}
    	return indexFile;
    }
    protected File getCacheDir () {
    	if (cacheDir == null) {
    		File	targetDir=detectTargetFolder();
    		cacheDir = new File(targetDir, "dir-" + String.valueOf(Math.random()));
    	}
    	
    	return ensureFolderExists(cacheDir);
    }
    protected abstract AsynchronousFileCacheBacking createFileBacking (File dir);
    public void testDeleteIndexFileOnEmptyIndex () throws Exception {
        IndexEntry[]    entries={
                createIndexEntry("weaved-empty", false, false, bytes, bytes),
                createIndexEntry("generated-empty", true, false, bytes, bytes)
            };
        File	cacheIndex=getIndexFile();
        writeIndex(cacheIndex, entries);
        assertTrue("No initial index file available: " + cacheIndex, cacheIndex.canRead());
        AsynchronousFileCacheBacking    cache=createFileBacking(getCacheDir());
        // the call should read an empty index since no data files exist
        Map<String, IndexEntry>         indexMap=cache.getIndexMap();
        assertEquals("Mismatched index size", 0, indexMap.size());
        // no data files were created
        Map<String, byte[]> bytesMap=cache.getBytesMap(); 
        assertEquals("Mismatched bytes size", 0, bytesMap.size());
        
        writeIndex(cache.getIndexFile(), cache.getIndexEntries());
        assertFalse("Index file still available: " + cacheIndex, cacheIndex.canRead());
    }
    protected long generateNewBytes () {
        final long          CRC=AbstractCacheBacking.crc(bytes);
        long                crc=CRC;
        // 8 tries should be enough to find a non-matching CRC...
        for (int    index=0; (index < Byte.SIZE) && (CRC == crc) && (crc != -1L); index++) {
            random.nextBytes(bytes);
            crc = AbstractCacheBacking.crc(bytes);
        }
        assertTrue("Could not generate different CRC for " + CRC, crc != CRC);
        return crc;
    }
    protected Map<String, File> createDataFiles (IndexEntry ... entries) throws IOException {
        return createDataFiles(LangUtil.isEmpty(entries) ? Collections.<IndexEntry>emptyList() : Arrays.asList(entries));
    }
    protected Map<String, File> createDataFiles (Collection<? extends IndexEntry> entries) throws IOException {
        if (LangUtil.isEmpty(entries)) {
            return Collections.emptyMap();
        }
        Map<String, File>  files=new TreeMap<String, File>();
        for (IndexEntry entry : entries) {
            File    file=createDataFile(entry);
            if (file != null) {
                files.put(entry.key, file);
            }
        }
        return files;
    }
    protected File createDataFile (IndexEntry entry) throws IOException {
        return createDataFile(entry, entry.ignored ? null : bytes);
    }
    protected File createDataFile (IndexEntry entry, byte[] dataBytes) throws IOException {
        return createDataFile(entry.key, dataBytes);
    }
    protected File createDataFile (String key, byte[] dataBytes) throws IOException {
        if (LangUtil.isEmpty(dataBytes)) {
            return null;
        }
        
        File    		parent=getCacheDir(), file=new File(parent, key);
        OutputStream    out=new FileOutputStream(file);
        try {
            out.write(dataBytes);
        } finally { 
            out.close();
        }
        return file;
    }
    protected static final IndexEntry createIgnoredEntry (String key) {
        return createIndexEntry(key, false, true, null, null);
    }
    protected static final IndexEntry createIndexEntry (String key, boolean generated, boolean ignored, byte[] bytes, byte[] originalBytes) {
        IndexEntry  entry=new IndexEntry();
        entry.key = key;
        entry.generated = generated;
        entry.ignored = ignored;
        if (ignored) {
            assertFalse(key + " ignored cannot be generated", generated);
        } else {
        	entry.crcClass = AbstractCacheBacking.crc(originalBytes);
            entry.crcWeaved = AbstractCacheBacking.crc(bytes);
        }
        
        return entry;
    }
======= fetch "public static Test suite() {" df1823b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/CacheTests.java"

======= fetch "public DefaultFileCacheBackingTest () {" df1823b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

 * Copyright (c) 2012 VMware, Inc.
 * 
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/epl-v10.html 
 *  
 * Contributors:
 *  Lyor Goldstein
 *******************************************************************************/
 * @author Lyor Goldstein
 */
    public FlatFileCacheBackingTest() {
        super();
    }
    @Override
    protected FlatFileCacheBacking createFileBacking(File dir) {
        return new FlatFileCacheBacking(dir);
    }
    public void testReadIndex () throws IOException {
        IndexEntry[]    entries={
                createIgnoredEntry("ignored"),
                createIndexEntry("weaved", false, false, bytes, bytes),
                createIndexEntry("generated", true, false, bytes, bytes)
            };
        File	indexFile=getIndexFile();
        writeIndex(indexFile, entries);
        Map<String, File> dataFiles=createDataFiles(entries);
        File							cacheDir=getCacheDir();
        AsynchronousFileCacheBacking    cache=createFileBacking(cacheDir);
        Map<String, IndexEntry> 		indexMap=cache.getIndexMap();
        assertEquals("Mismatched index size", entries.length, indexMap.size());
        Map<String, byte[]> bytesMap=cache.getBytesMap(); 
        assertEquals("Mismatched bytes size", dataFiles.size() /* the ignored one has no file */, bytesMap.size());
        
        for (IndexEntry entry : entries) {
            String  key=entry.key;
            assertNotNull("Missing entry for key=" + key, indexMap.get(key));
            
            if (entry.ignored) {
                assertNull("Unexpected bytes for ignored key=" + key, bytesMap.get(key));
            } else {
                assertArrayEquals("Mismatched contents for key=" + key, bytes, bytesMap.get(key));
            }
        }
    }
    public void testIgnoredBadCrcDataFiles () throws Exception {
        IndexEntry[]    entries={
                createIndexEntry("weaved-goodData", false, false, bytes, bytes),
                createIndexEntry("badData-weaved", false, false, bytes, bytes),
                createIndexEntry("generated-goodData", true, false, bytes, bytes),
                createIndexEntry("badData-generated", true, false, bytes, bytes)
            };
        File	indexFile=getIndexFile();
        writeIndex(indexFile, entries);
        Map<String,File>    dataFiles=createDataFiles(entries);
        long                newCrc=generateNewBytes();
        assertTrue("Bad new CRC", newCrc != (-1L));
        Map<String,File>    badFiles=new TreeMap<String, File>();
        for (IndexEntry entry : entries) {
            String  key=entry.key;
            if (key.startsWith("badData")) {
                File            file=dataFiles.get(key);
                OutputStream    out=new FileOutputStream(file);
                try {
                    out.write(bytes);
                } finally {
                    out.close();
                }
                dataFiles.remove(key);
                badFiles.put(key, file);
            }
        }
        File					cacheDir=getCacheDir();
        FlatFileCacheBacking    cache=createFileBacking(cacheDir);
        Map<String, IndexEntry> indexMap=cache.getIndexMap();
        assertEquals("Mismatched index size", dataFiles.size(), indexMap.size());
        Map<String, byte[]> bytesMap=cache.getBytesMap(); 
        assertEquals("Mismatched bytes size", dataFiles.size(), bytesMap.size());
        for (Map.Entry<String,File> badEntry : badFiles.entrySet()) {
            String  key=badEntry.getKey();
            assertFalse("Unexpectedly indexed: " + key, indexMap.containsKey(key));
            assertFalse("Unexpectedly loaded: " + key, bytesMap.containsKey(key));
            File    file=badEntry.getValue();
            assertFalse("Unexpectedly still readable: " + key, file.canRead());
        }
    }
    public void testSkipMissingDataFileOnReadIndex () throws IOException {
        IndexEntry[]    entries={
                createIndexEntry("weaved-noData", false, false, null, null),
                createIndexEntry("withData-weaved", false, false, bytes, bytes),
                createIndexEntry("generated-noData", true, false, null, null),
                createIndexEntry("withData-generated", true, false, bytes, bytes)
            };
        File	indexFile=getIndexFile();
        writeIndex(indexFile, entries);
        Map<String,File>    dataFiles=new TreeMap<String, File>();
        for (IndexEntry entry : entries) {
            String  key=entry.key;
            if (key.startsWith("withData")) {
                dataFiles.put(key, createDataFile(entry, bytes));
            }
        }
        File					cacheDir=getCacheDir();
        FlatFileCacheBacking    cache=createFileBacking(cacheDir);
        Map<String, IndexEntry> indexMap=cache.getIndexMap();
        assertEquals("Mismatched index size", dataFiles.size(), indexMap.size());
        Map<String, byte[]> bytesMap=cache.getBytesMap(); 
        assertEquals("Mismatched bytes size", dataFiles.size(), bytesMap.size());
        for (IndexEntry entry : entries) {
            String  key=entry.key;
            if (key.startsWith("withData")) {
                assertTrue("Not indexed: " + key, indexMap.containsKey(key));
                assertTrue("Not loaded: " + key, bytesMap.containsKey(key));
            } else {
                assertFalse("Unexpectedly indexed: " + key, indexMap.containsKey(key));
                assertFalse("Unexpectedly loaded: " + key, bytesMap.containsKey(key));
            }
        }
    }
======= fetch "public void dontIgnore(IMessage.Kind kind) {" df1823b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"

======= fetch "public void ignore(IMessage.Kind kind) {" df1823b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"

======= fetch "public void ignore(IMessage.Kind kind) {" df1823b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"

======= fetch "public void testGetCachingClassHandler() throws Exception {" df1823b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"

 * Copyright (c) 2012 VMware, Inc.
 *
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 * Lyor Goldstein
 */
 * 
 */
    public ZippedFileCacheBackingTest() {
        super();
    }
    public void testReadIndex () throws Exception {
        IndexEntry[]    entries={
                createIgnoredEntry("ignored"),
                createIndexEntry("weaved", false, false, bytes, bytes),
                createIndexEntry("generated", true, false, bytes, bytes)
            };
        File	indexFile=getIndexFile();
        writeIndex(indexFile, entries);
        Map<String,byte[]>  entriesMap=new TreeMap<String,byte[]>();
        for (IndexEntry ie : entries) {
            if (ie.ignored) {
                continue;
            }
            entriesMap.put(ie.key, bytes);
        }
        File	zipFile=getZipFile();
        ZippedFileCacheBacking.writeZipClassBytes(zipFile, entriesMap);
        File							cacheDir=getCacheDir();
        AsynchronousFileCacheBacking    cache=createFileBacking(cacheDir);
        Map<String, IndexEntry>			indexMap=cache.getIndexMap();
        assertEquals("Mismatched index size", entries.length, indexMap.size());
        Map<String, byte[]> bytesMap=cache.getBytesMap(); 
        assertEquals("Mismatched bytes size", entriesMap.size() /* the ignored one has no file */, bytesMap.size());
        
        for (IndexEntry entry : entries) {
            String  key=entry.key;
            assertNotNull("Missing entry for key=" + key, indexMap.get(key));
            
            if (entry.ignored) {
                assertNull("Unexpected bytes for ignored key=" + key, bytesMap.get(key));
            } else {
                assertArrayEquals("Mismatched contents for key=" + key, bytes, bytesMap.get(key));
            }
        }
    }
    public void testReadWriteZipClassBytes () throws IOException {
        Map<String,byte[]>  entriesMap=new TreeMap<String,byte[]>();
        for (int    index=0; index < Byte.SIZE; index++) {
            String  name="classBytes#" + index;
            random.nextBytes(bytes);
            entriesMap.put(name, bytes);
        }
        File	zipFile=getZipFile();
        ZippedFileCacheBacking.writeZipClassBytes(zipFile, entriesMap);
        Map<String, byte[]> bytesMap=ZippedFileCacheBacking.readZipClassBytes(zipFile);
        assertEquals("Mismatched recovered entries size", entriesMap.size(), bytesMap.size());
        for (Map.Entry<String,byte[]> bytesEntry : entriesMap.entrySet()) {
            String  key=bytesEntry.getKey();
            byte[]  expected=bytesEntry.getValue(), actual=bytesMap.get(key);
            assertArrayEquals("Mismatched data for " + key, expected, actual);
        }
    }
    public void testReadClassBytes () throws IOException {
        IndexEntry[]    entries={
                createIgnoredEntry("ignoredReadClassBytes"),
                createIndexEntry("weavedReadClassBytes", false, false, bytes, bytes),
                createIndexEntry("generatedReadClassBytes", true, false, bytes, bytes)
            };
        File	indexFile=getIndexFile();
        writeIndex(indexFile, entries);
        long newCrc=generateNewBytes();
        assertTrue("Bad new CRC", newCrc != (-1L));
        Map<String,byte[]>  entriesMap=new TreeMap<String,byte[]>();
        for (IndexEntry ie : entries) {
            if (ie.ignored) {
                continue;
            }
            entriesMap.put(ie.key, bytes);
        }
        File	zipFile=getZipFile();
        ZippedFileCacheBacking.writeZipClassBytes(zipFile, entriesMap);
        File							cacheDir=getCacheDir();
        AsynchronousFileCacheBacking    cache=createFileBacking(cacheDir);
        Map<String, IndexEntry> 		indexMap=cache.getIndexMap();
        assertEquals("Mismatched index size", 1 /* only the ignored entry */, indexMap.size());
        Map<String, byte[]> bytesMap=cache.getBytesMap(); 
        assertEquals("Non empty data bytes", 0, bytesMap.size());
        assertFalse("Zip file not deleted: " + zipFile, zipFile.canRead());
    }
    protected File getZipFile () {
    	if (zipTestFile == null) {
    		File	cacheDir=getCacheDir();
    		zipTestFile = new File(cacheDir, ZippedFileCacheBacking.ZIP_FILE);
    	}
    	return zipTestFile;
    }
    @Override
    @Override
    protected ZippedFileCacheBacking createFileBacking(File dir) {
        return new ZippedFileCacheBacking(dir);
    }

======= fetch "public ClassLoaderWeavingAdaptor(final ClassLoader deprecatedLoader, final IWeav" 9a3cc2b^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= fetch "public void acceptClass(String name, byte[] bytes) {" 9a3cc2b^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= fetch "public void acceptClass(String name, byte[] bytes) {" 9a3cc2b^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= fetch "public void acceptClass(String name, byte[] bytes) {" 9a3cc2b^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= fetch "private boolean weaveAndDefineConceteAspects() {" 9a3cc2b^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= fetch "public String getClassLoaderName() {" 9a3cc2b^:"loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java"

======= fetch "public static boolean isEmpty(Collection<?> collection) {" 9a3cc2b^:"util/src/org/aspectj/util/LangUtil.java"

 *     Matthew Webster, Adrian Colyer, John Kew (caching)
======= fetch "protected Boolean initialValue() {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "protected Boolean initialValue() {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "protected Boolean initialValue() {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "protected Boolean initialValue() {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public void acceptResult(IUnwovenClassFile result) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public void acceptResult(IUnwovenClassFile result) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

 *   John Kew (vmware)         initial implementation
======= fetch "public void reset() {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/CacheStatistics.java"

 *   John Kew (vmware)         initial implementation
 *   John Kew (vmware)         initial implementation
======= fetch "protected CachedClassReference(String key, CacheKeyResolver resolver) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/CachedClassReference.java"

======= fetch "public String getClassName() {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/CachedClassReference.java"

        if (obj == null)
            return false;
        if (this == obj)
            return true;
        if (getClass() != obj.getClass())
            return false;
        CachedClassReference	other=(CachedClassReference) obj;
======= fetch "public CacheBacking createBacking(String scope) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultCacheFactory.java"

 *   John Kew (vmware)         initial implementation
======= fetch "protected DefaultFileCacheBacking(File cacheDirectory, CacheKeyResolver resolver" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public static CacheBacking createBacking(File cacheDir, CacheKeyResolver resolve" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public static CacheBacking createBacking(File cacheDir, CacheKeyResolver resolve" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public static CacheBacking createBacking(File cacheDir, CacheKeyResolver resolve" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public static CacheBacking createBacking(File cacheDir, CacheKeyResolver resolve" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

    @Override
======= fetch "public static CacheBacking createBacking(File cacheDir, CacheKeyResolver resolve" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

    protected IndexEntry resolveIndexMapEntry (File cacheDir, IndexEntry ie) {
        File cacheEntry = new File(cacheDir, ie.key);
        if (ie.ignored || cacheEntry.canRead()) {
            return ie;
        } else {
            return null;
        }
    }
======= fetch "private void readIndex() {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "private void readIndex() {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "private void writeIndex() {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "private void writeIndex() {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

    @Override
======= fetch "private void removeIndexEntry(String key) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "private void removeIndexEntry(String key) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "private void addIndexEntry(IndexEntry ie) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public void clear() {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public void clear() {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public void clear() {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public static CacheBacking createBacking(String scope, CacheKeyResolver resolver" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public static CacheBacking createBacking(String scope, CacheKeyResolver resolver" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public static CacheBacking createBacking(String scope, CacheKeyResolver resolver" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public static CacheBacking createBacking(String scope, CacheKeyResolver resolver" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public boolean accept(File file, String s) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public boolean accept(File file, String s) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public CachedClassEntry get(CachedClassReference ref) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public CachedClassEntry get(CachedClassReference ref) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public CachedClassEntry get(CachedClassReference ref) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public CachedClassEntry get(CachedClassReference ref) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public void put(CachedClassEntry entry) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public void remove(CachedClassReference ref) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public void remove(CachedClassReference ref) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public void remove(CachedClassReference ref) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public void remove(CachedClassReference ref) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public void remove(CachedClassReference ref) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public void remove(CachedClassReference ref) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public void remove(CachedClassReference ref) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "public void remove(CachedClassReference ref) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "protected long write(File file, byte[] bytes) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "protected long write(File file, byte[] bytes) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "protected long write(File file, byte[] bytes) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "protected long write(File file, byte[] bytes) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "protected long write(File file, byte[] bytes) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "protected long write(File file, byte[] bytes) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= fetch "protected static void delete(File file) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

 *   John Kew (vmware)         initial implementation
======= fetch "public GeneratedCachedClassHandler(WeavedClassCache cache, GeneratedClassHandler" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/GeneratedCachedClassHandler.java"

======= fetch "public void acceptClass(String name, byte[] bytes) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/GeneratedCachedClassHandler.java"

======= fetch "public void acceptClass(String name, byte[] bytes) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/GeneratedCachedClassHandler.java"

 *   John Kew (vmware)         initial implementation
======= fetch "protected WeavedClassCache(GeneratedClassHandler existingClassHandler," 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java"

======= fetch "public static boolean isEnabled() {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java"

======= fetch "public static boolean isEnabled() {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java"

======= fetch "public void put(CachedClassReference ref, byte[] weavedBytes) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java"

======= fetch "public void put(CachedClassReference ref, byte[] weavedBytes) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java"

======= fetch "public void put(CachedClassReference ref, byte[] weavedBytes) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java"

======= fetch "public CachedClassEntry get(CachedClassReference ref) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java"

======= fetch "public CachedClassEntry get(CachedClassReference ref) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java"

======= fetch "public void ignore(CachedClassReference ref) {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java"

======= fetch "public CacheStatistics getStats() {" 9a3cc2b^:"weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java"

 *   Lyor Goldstein (vmware)	add support for weaved class being re-defined
======= fetch "public void setUp() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testCreateBacking() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testCreateBacking() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testClear() {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testClear() {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testGetKeys() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testPut() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testPut() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testGet() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testGet() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testGet() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testRemove() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testRemove() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testRemove() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testRemove() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testMultiFile() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testMultiFile() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testMultiFile() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testMultiFile() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testMultiFile() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testMultiFile() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testMultiFile() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void testMultiFile() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= fetch "public void clear() {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"

======= fetch "public CachedClassEntry get(CachedClassReference ref) {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"

======= fetch "public void ignore(IMessage.Kind kind) {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"

======= fetch "public void testGetCachingClassHandler() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"

======= fetch "public void testCache() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"

======= fetch "public void testCache() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"

======= fetch "public void testCache() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"

======= fetch "public void testRemove() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"

======= fetch "public void testRemove() throws Exception {" 9a3cc2b^:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"


======= fetch "private boolean mungeNewMethod(SourceTypeBinding sourceType, ResolvedType onType" b8ebdc3^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseTypeMunger.java"


======= fetch "public String stringify() {" 0d69bd3^:"org.aspectj.matcher/src/org/aspectj/weaver/EnumAnnotationValue.java"

======= fetch "public boolean hasNameValuePair(String n, String v) {" 0d69bd3^:"org.aspectj.matcher/src/org/aspectj/weaver/StandardAnnotation.java"

======= fetch "protected void resolveAnnotationValues(ResolvedType annotationType, IScope scope" 0d69bd3^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= fetch "protected void resolveAnnotationValues(ResolvedType annotationType, IScope scope" 0d69bd3^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= fetch "protected void resolveAnnotationValues(ResolvedType annotationType, IScope scope" 0d69bd3^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= fetch "protected void resolveAnnotationValues(ResolvedType annotationType, IScope scope" 0d69bd3^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= fetch "protected void resolveAnnotationValues(ResolvedType annotationType, IScope scope" 0d69bd3^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= fetch "protected void resolveAnnotationValues(ResolvedType annotationType, IScope scope" 0d69bd3^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= fetch "protected void resolveAnnotationValues(ResolvedType annotationType, IScope scope" 0d69bd3^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= fetch "protected void resolveAnnotationValues(ResolvedType annotationType, IScope scope" 0d69bd3^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= fetch "protected void resolveAnnotationValues(ResolvedType annotationType, IScope scope" 0d69bd3^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= fetch "protected void resolveAnnotationValues(ResolvedType annotationType, IScope scope" 0d69bd3^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= fetch "protected void resolveAnnotationValues(ResolvedType annotationType, IScope scope" 0d69bd3^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= fetch "protected void resolveAnnotationValues(ResolvedType annotationType, IScope scope" 0d69bd3^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= fetch "protected void resolveAnnotationValues(ResolvedType annotationType, IScope scope" 0d69bd3^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= fetch "protected void resolveAnnotationValues(ResolvedType annotationType, IScope scope" 0d69bd3^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

  String s() default "xyz";
  Color color();
  declare parents: (@Foo(s="abc",color="AA") *) implements java.io.Serializable;
  // declare parents: (@Foo(color="AA", s="abc") *) implements java.io.Serializable;
  String s() default "xyz";
  Color color();
  declare parents: (@Foo(color="AA") *) implements java.io.Serializable;
  // declare parents: (@Foo(color="AA", s="abc") *) implements java.io.Serializable;
  String s() default "xyz";
  Color color();
  declare parents: (@Foo(s=Color.GREEN) *) implements java.io.Serializable;
  // declare parents: (@Foo(color="AA", s="abc") *) implements java.io.Serializable;
======= fetch "public void testInconsistentClassFile_pr389750_4() {" 0d69bd3^:"tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"

    
      <compile files="Code.java" options="-1.5">
      	<message kind="error" text="Invalid annotation value 'AA', expected enum value"/>
      </compile>
    </ajc-test>
    
      <compile files="Code2.java" options="-1.5">
      	<message kind="error" text="Invalid annotation value 'AA', expected enum value"/>
      </compile>
    </ajc-test>
    
      <compile files="Code3.java" options="-1.5">
      	<message kind="error" text="Invalid annotation value 'AA', expected enum value"/>
      </compile>
    </ajc-test>

======= fetch "public static long makeLongPos(int start, int end) {" b9c7a19^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AstUtil.java"

======= fetch "public void resolve(ClassScope upperScope) {" b9c7a19^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

  public static void main(String[] argv) {
    Code.foo();
  }
  public static void main(String[] argv) {
    Bar bs = new Bar();
    String s = bs.bar("abc",null);
  }
  public static void main(String[] argv) {
    Bar<String> bs = new Bar<String>();
    String s = bs.bar("abc",null);
  }
  public static void main(String[] argv) {
    Bar<String> bs = new Bar<String>();
    String s = bs.bar("abc",new Integer(4));
  }
  public interface I<ID extends Serializable> extends Persistable<ID> {
  }
  public static void foo() {}
  public boolean I.equals(Persistable<?> that) {
    return false;
  }
  public interface I<ID extends Serializable> extends Persistable<ID> {
  }
  public static void foo() {}
  public Z I<Z>.bar(Z foo, Persistable<?> that) {
    return foo;
  }
  public interface I<ID extends Serializable> extends Persistable<ID> {
  }
  public static void foo() {}
  public Z I<Z>.bar(Z foo, Persistable<?> that) {
    return foo;
  }
  public interface I<ID extends Serializable> extends Persistable<ID> {
  }
  public static void foo() {}
  public <T> Z I<Z>.bar(Z foo, T that) {
    return foo;
  }
======= fetch "public static Test suite() {" b9c7a19^:"tests/src/org/aspectj/systemtest/AllTests17.java"

 * Copyright (c) 2012 Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
 * @author Andy Clement
 */ 
 * Copyright (c) 2008 Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
      <compile files="Code.aj" options="-1.5">
      </compile>
      <compile files="Clazz.java" options="-1.5"/>
    </ajc-test>
    
      <compile files="Code2.aj" outjar="azpect.jar" options="-1.5">
      </compile>
      <compile files="Clazz2.java" aspectpath="azpect.jar" options="-1.5"/>
    </ajc-test>
    
      <compile files="Code3.aj" outjar="azpect.jar" options="-1.5">
      </compile>
      <compile files="Clazz3.java" aspectpath="azpect.jar" options="-1.5"/>
    </ajc-test>
    
      <compile files="Code4.aj" outjar="azpect.jar" options="-1.5">
      </compile>
      <compile files="Clazz4.java" aspectpath="azpect.jar" options="-1.5"/>
    </ajc-test>

======= fetch "public MethodGen pack() {" c2ff74f^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= fetch "public MethodGen pack() {" c2ff74f^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"


======= fetch "private void resolveAndSetPointcut(MethodDeclaration methodDeclaration, Annotati" 55ebaa1^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

    public void bizLoggerWithException(JoinPoint thisJoinPoint,Throwable e) {
  //  .....// do some stuff
    }
      <compile files="X.java" options="-1.5">
      	<message kind="error" line="9" text="the advice annotation must specify a pointcut value"/>
      </compile>
    </ajc-test>

======= fetch "public void unhandledException(TypeBinding exceptionType, ASTNode location) {" 76d695f^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= fetch "public void unhandledException(TypeBinding exceptionType, ASTNode location) {" 76d695f^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

      <compile files="Color.java Code.java" options="-1.5"/>
      <!-- 
      <run class="de.scrum_master.galileo.filter.JsoupFilter">
          <line text="JsoupFilter.getLogMessage()"/>
          <line text="run()"/>
      -->

======= fetch "public void methodMustOverride(AbstractMethodDeclaration method, long compliance" cbb6f5a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= fetch "public void methodMustOverride(AbstractMethodDeclaration method, long compliance" cbb6f5a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"


======= fetch "public void checkInterTypeMungers() {" 7c6e936^:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

  public void run() {
    System.out.println("run()");
  }
      System.out.println("JsoupFilter.getLogMessage()");
  public static void main(String []argv) {
    new JsoupFilter().run();
  }
  public void m() {
    Color[] cs = Color.values();
  }
  after(): @annotation(Anno) {}
      <compile files="Code.java" options="-1.5"/>
      <!-- 
      <run class="de.scrum_master.galileo.filter.JsoupFilter">
        <stdout>
          <line text="JsoupFilter.getLogMessage()"/>
          <line text="run()"/>
        </stdout>
      </run>
      -->
    </ajc-test>
    <ajc-test dir="bugs171/pr386049" title="itd abstract">
      <compile files="de/scrum_master/galileo/filter/BasicFilter.java de/scrum_master/galileo/filter/JsoupFilter.java de/scrum_master/galileo/LoggingAspect.aj" options="-1.5"/>
      <run class="de.scrum_master.galileo.filter.JsoupFilter">
        <stdout>
          <line text="JsoupFilter.getLogMessage()"/>
          <line text="run()"/>
        </stdout>
      </run>
    </ajc-test>
======= fetch "private void addMethodDispatch(LazyClassGen gen, ResolvedMember method, Resolved" 7c6e936^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"


======= fetch "public UnresolvedType fromBinding(TypeBinding binding) {" bf949d3^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public UnresolvedType fromBinding(TypeBinding binding) {" bf949d3^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public UnresolvedType fromBinding(TypeBinding binding) {" bf949d3^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

      T aaa;
    InnerA someMethod(){
        A<String> as = new A<String>();
        return as.new InnerA();
    }
    InnerA someOtherMethod() {
        return someMethod();
    }
======= fetch "public static Test suite() {" bf949d3^:"tests/src/org/aspectj/systemtest/AllTests17.java"

 * Copyright (c) 2012 Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
 * @author Andy Clement
 */ 
 * Copyright (c) 2008 Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
   

======= fetch "public static String dumpWithException(IMessageHolder messageHolder, Throwable t" 5d0e186^:"org.aspectj.matcher/src/org/aspectj/weaver/Dump.java"

======= fetch "public static String dumpOnExit(IMessageHolder messageHolder, boolean reset) {" 5d0e186^:"org.aspectj.matcher/src/org/aspectj/weaver/Dump.java"


======= fetch "public ResolvedType parameterizedWith(UnresolvedType[] typeParameters) {" a748303^:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= fetch "public UnresolvedType parameterize(Map<String, UnresolvedType> typeBindings) {" a748303^:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= fetch "public UnresolvedType parameterize(Map<String, UnresolvedType> typeBindings) {" a748303^:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= fetch "public UnresolvedType parameterize(Map<String, UnresolvedType> typeBindings) {" a748303^:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= fetch "public UnresolvedType parameterize(Map<String, UnresolvedType> typeBindings) {" a748303^:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

    public B getSomeB(SuperB<String> b){
        return null;
    }
  public B getSomeB(SuperB<String> b) { return null; }
 public static void main(String []argv) {
    A a = new A();
  }
 public static void main(String []argv) {
    A a = new A();
    System.out.println(a.getSomeB(null));
  }
    declare parents: A extends SuperA<String>;
    declare parents: A extends SuperA<String>;
  public static void main(String[] argv) {
    new A().getList();
  }
======= fetch "public void testGenericAspectAround382723_4() {" a748303^:"tests/src/org/aspectj/systemtest/ajc170/Ajc170Tests.java"

======= fetch "private void createAnyBridgeMethodsForCovariance(BcelClassWeaver weaver, NewMeth" a748303^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private void createBridgeMethod(BcelWorld world, NewMethodTypeMunger munger, Res" a748303^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"


======= fetch "private void makePublic(TypeBinding binding) {" ba9d43c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "private void makePublic(TypeBinding binding) {" ba9d43c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

    protected int getNumber(int k) {
        return -1*k;
    }
    pointcut pc():  call(T.new()) && !within(Bar); 
    T around():pc() {
        System.out.println("superaspect getNumber returns "+getNumber(2)); 
        System.out.println("abstract method returns "+method());
        Math.random(); //<-- works
        hashCode(); //<-- works
        return null;
    }    
    private void localMethod(){}
    protected abstract T method();
  protected LinkedList method() {
    System.out.println("Bar.method() running");
  }
    public static void main(String[] argv) {
    }
    public LinkedList bar() {
        new LinkedList();
        return null;
    }
    protected int getNumber(int k) {
        return -1*k;
    }
    pointcut pc():  call(T.new()); 
    T around():pc() {
        //getNumber(1); //<-- method call to superAspect fails   
        method();  // <-- method call to abstract local defined method fails
        //localMethod(); //<-- method call to local private method fails
        Math.random(); //<-- works
        hashCode(); //<-- works
        return null;
    }    
    private void localMethod(){}
    protected abstract T method();
    public LinkedList bar() {
        new LinkedList();
        return null;
    }
    protected int getNumber(int k) {
        return -1*k;
    }
    pointcut pc():  call(T.new()); 
    T around():pc() {
        getNumber(1); //<-- method call to superAspect fails   
        //method();  // <-- method call to abstract local defined method fails
        //localMethod(); //<-- method call to local private method fails
        Math.random(); //<-- works
        hashCode(); //<-- works
        return null;
    }    
    private void localMethod(){}
    protected abstract T method();
    public LinkedList bar() {
        new LinkedList();
        return null;
    }
    protected int getNumber(int k) {
        return -1*k;
    }
    pointcut pc():  call(T.new()); 
    T around():pc() {
        //getNumber(1); //<-- method call to superAspect fails   
        //method();  // <-- method call to abstract local defined method fails
        localMethod(); //<-- method call to local private method fails
        Math.random(); //<-- works
        hashCode(); //<-- works
        return null;
    }    
    private void localMethod(){}
    protected abstract T method();
    public LinkedList bar() {
        new LinkedList();
        return null;
    }

======= fetch "public String toString() {" 89c178f^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"


  public static void main(String[] args) {
    R r = new R();
    System.out.println(r.getClass().getName());
  }
    pointcut createR() : call(R.new()) && !within(RAj);
    Object around() : createR()
    {
        System.out.println("aspect running");
        return new R1();
    }
 	<ajc-test dir="bugs170/pr376351" title="attribute issue with J7">
     <compile files="R.java R1.java" outjar="code.jar" options="-1.5"/>
     <compile files="RAj.java" options="-1.7 -Xlint:ignore" outjar="aspects.jar" classpath="code.jar"/>
     <compile inpath="code.jar" aspectpath="aspects.jar" options="-showWeaveInfo">
     <message kind="weave" text="Join point 'constructor-call(void R.&lt;init&gt;())'"/>
     </compile>
     <!-- 
     if we had a 1.7 vm we could use this:
     <compile files="RAj.java" options="-1.7 -Xlint:ignore"/>
     <run class="R" ltw="aop.xml">
     <stderr>
     <line text="org.aspectj.weaver.tools.Jdk14Trace error"/>
     <line text="Unsupported major.minor version 51.0"/>
     <line text="java.lang.UnsupportedClassVersionError: RAj :"/>
     </stderr>
     </run>
     -->
   </ajc-test>

        public static void main(String[] argv) {
                Color c = Color.R;
                switch (c) {
                }
        }
 	<ajc-test dir="bugs170/pr376139" title="switch on enum">
     <compile files="Code.java" options="-1.5"/>
     <run class="Code"/>
   </ajc-test>

======= fetch "private int getScore(Pointcut p) {" f85631f^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/PointcutEvaluationExpenseComparator.java"


======= fetch "public void addSourceTypeBinding(SourceTypeBinding binding, CompilationUnitDecla" 549d227^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public void addSourceTypeBinding(SourceTypeBinding binding, CompilationUnitDecla" 549d227^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public void addSourceTypeBinding(SourceTypeBinding binding, CompilationUnitDecla" 549d227^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public void addSourceTypeBinding(SourceTypeBinding binding, CompilationUnitDecla" 549d227^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public void addSourceTypeBinding(SourceTypeBinding binding, CompilationUnitDecla" 549d227^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public void addSourceTypeBinding(SourceTypeBinding binding, CompilationUnitDecla" 549d227^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public void addSourceTypeBinding(SourceTypeBinding binding, CompilationUnitDecla" 549d227^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public void addSourceTypeBinding(SourceTypeBinding binding, CompilationUnitDecla" 549d227^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public void addSourceTypeBinding(SourceTypeBinding binding, CompilationUnitDecla" 549d227^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public void addSourceTypeBinding(SourceTypeBinding binding, CompilationUnitDecla" 549d227^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public void addSourceTypeBinding(SourceTypeBinding binding, CompilationUnitDecla" 549d227^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public void addSourceTypeBinding(SourceTypeBinding binding, CompilationUnitDecla" 549d227^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public void addSourceTypeBinding(SourceTypeBinding binding, CompilationUnitDecla" 549d227^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public void addSourceTypeBinding(SourceTypeBinding binding, CompilationUnitDecla" 549d227^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public void addSourceTypeBinding(SourceTypeBinding binding, CompilationUnitDecla" 549d227^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public ReferenceType(ResolvedType theGenericType, ResolvedType[] theParameters," 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "synchronized void addDependentType(ReferenceType dependent) {" 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public void addAnnotation(AnnotationAJ annotationX) {" 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public WeaverStateInfo getWeaverState() {" 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "private int getRank(String tvname) {" 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "private int getRank(String tvname) {" 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "private int getRank(String tvname) {" 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public PerClause getPerClause() {" 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public void setDelegate(ReferenceTypeDelegate delegate) {" 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public void setDelegate(ReferenceTypeDelegate delegate) {" 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public void addParent(ResolvedType newParent) {" 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public void addParent(ResolvedType newParent) {" 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public World getWorld() {" 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= fetch "public boolean isGroovyObject() {" 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= fetch "public static ReferenceType createParameterizedType(ResolvedType aBaseType, Unre" 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/TypeFactory.java"

 * Copyright (c) 2005-2010 Contributors.
 * ReferenceType representing a type variable. The delegate for this reference type is the upperbound on the type variable (so
======= fetch "public TypeVariableReferenceType(TypeVariable typeVariable, World world) {" 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariableReferenceType.java"

======= fetch "public TypeVariable getTypeVariable() {" 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariableReferenceType.java"

======= fetch "public boolean equals(Object other) {" 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/UnresolvedType.java"

======= fetch "public ResolvedType resolve(World world) {" 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/UnresolvedTypeVariableReferenceType.java"

======= fetch "public ResolvedType resolveGenericTypeFor(UnresolvedType anUnresolvedType, boole" 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/World.java"

======= fetch "public void checkq() {" 549d227^:"org.aspectj.matcher/src/org/aspectj/weaver/World.java"


 * Copyright (c) 2005 Contributors.
 * @author colyer This class is responsible for tracking progress through the various phases of compilation and weaving. When an
 *         exception occurs (or a message is issued, if desired), you can ask this class for a "stack trace" that gives information
 *         about what the compiler was doing at the time. The trace will say something like:
 * 
 *         when matching pointcut xyz when matching shadow sss when weaving type ABC when weaving shadow mungers
 * 
 *         Since we can't use ThreadLocal (have to work on 1.3), we use a map from Thread -> ContextStack.
======= fetch "public static void reset() {" 6defb4e^:"bridge/src/org/aspectj/bridge/context/CompilationAndWeavingContext.java"

======= fetch "public static void reset() {" 6defb4e^:"bridge/src/org/aspectj/bridge/context/CompilationAndWeavingContext.java"

======= fetch "public static void leavingPhase(ContextToken aToken) {" 6defb4e^:"bridge/src/org/aspectj/bridge/context/CompilationAndWeavingContext.java"

======= fetch "public static void leavingPhase(ContextToken aToken) {" 6defb4e^:"bridge/src/org/aspectj/bridge/context/CompilationAndWeavingContext.java"

======= fetch "public static void resetForThread() {" 6defb4e^:"bridge/src/org/aspectj/bridge/context/CompilationAndWeavingContext.java"

======= fetch "public static void resetForThread() {" 6defb4e^:"bridge/src/org/aspectj/bridge/context/CompilationAndWeavingContext.java"

======= fetch "public static void resetForThread() {" 6defb4e^:"bridge/src/org/aspectj/bridge/context/CompilationAndWeavingContext.java"


    public AspectTest() {}
    @DeclareParents(value="java.lang.Runnable+ || java.util.concurrent.Callable+",  defaultImpl=XImpl.class)
    //@DeclareParents(value="java.lang.Runnable+",  defaultImpl=XImpl.class)
    private X xImpl;
    public static void main(String []argv) {
      ((X)new Foo()).xxx();
      ((X)new Bar()).xxx();
    }
    interface X { void xxx();}
    class XImpl implements X {
      public XImpl() {}
      public void xxx() {}
    }
  public void run() {}
  public Object call() {return null;}
   <ajc-test dir="bugs170/pr371998" title="BCException anno decp">
     <compile files="AspectTest.java" options="-1.5 -showWeaveInfo">
   	   <message kind="weave" text="Extending interface set for type 'Foo' (AspectTest.java) to include 'X' (AspectTest.java)"/>
   	   <message kind="weave" text="Type 'Foo' (AspectTest.java) has intertyped method from 'AspectTest' (AspectTest.java:'void X.xxx()')"/>
   	   <message kind="weave" text="Extending interface set for type 'Bar' (AspectTest.java) to include 'X' (AspectTest.java)"/>
   	   <message kind="weave" text="Type 'Bar' (AspectTest.java) has intertyped method from 'AspectTest' (AspectTest.java:'void X.xxx()')"/>
   	 </compile>
   	 <run class="AspectTest"/>
   </ajc-test>
   
======= fetch "private static boolean handleDeclareParentsAnnotation(RuntimeAnnos runtimeAnnota" f37c56e^:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

======= fetch "private static boolean handleDeclareParentsAnnotation(RuntimeAnnos runtimeAnnota" f37c56e^:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"


======= fetch "public static UnresolvedType createTypeFromSignature(String signature) {" 89756cd^:"org.aspectj.matcher/src/org/aspectj/weaver/TypeFactory.java"

======= fetch "private static int locateFirstBracket(StringBuffer signature) {" 89756cd^:"org.aspectj.matcher/src/org/aspectj/weaver/TypeFactory.java"


======= fetch "public AnnotationAJ getAnnotationOfType(UnresolvedType ofType) {" 942da06^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public AnnotationAJ getAnnotationOfType(UnresolvedType ofType) {" 942da06^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public AnnotationAJ getAnnotationOfType(UnresolvedType ofType) {" 942da06^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public WeaverStateInfo getWeaverState() {" 942da06^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public WeaverStateInfo getWeaverState() {" 942da06^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public WeaverStateInfo getWeaverState() {" 942da06^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public WeaverStateInfo getWeaverState() {" 942da06^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "private void clearParameterizationCaches() {" 942da06^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public void setGenericType(ReferenceType rt) {" 942da06^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "private static String makeDeclaredSignature(ResolvedType aGenericType, Unresolve" 942da06^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public void addParent(ResolvedType newParent) {" 942da06^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"


======= fetch "private void copyResourcesFromFile(File f, String filename, File src) throws IOE" 14a6eac^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"


======= fetch "public static Definition parse(final URL url) throws Exception {" e71e287^:"weaver/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

======= fetch "public static Definition parse(final URL url) throws Exception {" e71e287^:"weaver/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"


======= fetch "public ISourceLocation getBinarySourceLocation(ISourceLocation sl) {" 0f506ab^:"org.aspectj.matcher/src/org/aspectj/weaver/ShadowMunger.java"

======= fetch "private File getBinaryFile() {" 0f506ab^:"org.aspectj.matcher/src/org/aspectj/weaver/ShadowMunger.java"

======= fetch "private File getBinaryFile() {" 0f506ab^:"org.aspectj.matcher/src/org/aspectj/weaver/ShadowMunger.java"

======= fetch "private File getBinaryFile() {" 0f506ab^:"org.aspectj.matcher/src/org/aspectj/weaver/ShadowMunger.java"


======= fetch "public boolean weave() {" 6ae463a^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean doesAlreadyHaveAnnotation(LazyMethodGen rm, ResolvedMember itdfi" 6ae463a^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean inlineSelfConstructors(List<LazyMethodGen> methodGens) {" 6ae463a^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean inlineSelfConstructors(List<LazyMethodGen> methodGens) {" 6ae463a^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean inlineSelfConstructors(List<LazyMethodGen> methodGens) {" 6ae463a^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private void matchInvokeInstruction(LazyMethodGen mg, InstructionHandle ih, Invo" 6ae463a^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"


======= fetch "public ResolvedType fromType(Type aType) {" 167b801^:"weaver5/java5-src/org/aspectj/weaver/reflect/JavaLangTypeToResolvedTypeConverter.java"

======= fetch "public ResolvedType fromType(Type aType) {" 167b801^:"weaver5/java5-src/org/aspectj/weaver/reflect/JavaLangTypeToResolvedTypeConverter.java"


======= fetch "public World getIWorld() {" e8ef5bf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "private void deleteNewAndDup() {" e8ef5bf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "private void deleteNewAndDup() {" e8ef5bf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "private void deleteNewAndDup() {" e8ef5bf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "private void deleteNewAndDup() {" e8ef5bf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "private void deleteNewAndDup() {" e8ef5bf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "protected void prepareForMungers() {" e8ef5bf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "protected void prepareForMungers() {" e8ef5bf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "protected void prepareForMungers() {" e8ef5bf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"


======= fetch "public void initialize(final ClassLoader classLoader, IWeavingContext context) {" c6fb752^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= fetch "private String getClassLoaderName(ClassLoader loader) {" c6fb752^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= fetch "private void registerOptions(final BcelWeaver weaver, final ClassLoader loader," c6fb752^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= fetch "private boolean weaveAndDefineConceteAspects() {" c6fb752^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= fetch "private boolean weaveAndDefineConceteAspects() {" c6fb752^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= fetch "private void registerIncludeExclude(final BcelWeaver weaver, final ClassLoader l" c6fb752^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= fetch "private void registerIncludeExclude(final BcelWeaver weaver, final ClassLoader l" c6fb752^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= fetch "private void registerIncludeExclude(final BcelWeaver weaver, final ClassLoader l" c6fb752^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= fetch "private void registerIncludeExclude(final BcelWeaver weaver, final ClassLoader l" c6fb752^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= fetch "private String looksLikeStartsWith(String typePattern) {" c6fb752^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"


======= fetch "private void writeBack(BcelWorld world) {" 8553b30^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"


======= fetch "public void addLibraryJarFile(File inFile) throws IOException {" 2302e94^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


======= fetch "public void ensureAdvancedConfigurationProcessed() {" bb2aea4^:"org.aspectj.matcher/src/org/aspectj/weaver/World.java"

======= fetch "public void ensureAdvancedConfigurationProcessed() {" bb2aea4^:"org.aspectj.matcher/src/org/aspectj/weaver/World.java"


======= fetch "public static Instruction createSuperInvoke(InstructionFactory fact, BcelWorld w" f7b1193^:"weaver/src/org/aspectj/weaver/bcel/Utility.java"

======= fetch "public static void appendConversion(InstructionList il, InstructionFactory fact," f7b1193^:"weaver/src/org/aspectj/weaver/bcel/Utility.java"


  before(String[] ss): execution(* *(..)) && args(ss) {
  }
  before(int[] ss): execution(* *(..)) && args(ss) {
  }
  before(float[][] ss): execution(* *(..)) && args(ss) {
  }
  String[] stringArray = new String[1];
  int[] ints = new int[3];
  float[][] floats = new float[1][2];
  String[] stringArray = new String[1];
  before(Dibble d): execution(* *(..)) && args(d) {
  }

======= fetch "private static String lastbit(String fqname) {" 95e70d2^:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

======= fetch "private static String lastbit(String fqname) {" 95e70d2^:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

======= fetch "private static String lastbit(String fqname) {" 95e70d2^:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"


    void updateList(List<T> newList);
  @SuppressWarnings("rawtypes")
  pointcut IVOListUpdate(IVOList list):  target(list) && call(void updateList(*));

    private String name;
    private Country country;
    public static class City.TrafficCalculator {
        Function<City, Time> EXTREME = createExtremeTraffic(); 
        Function<City, Time> BASIC = createBasicTraffic();
    }
    private static Function<City, Time> createExtremeTraffic() {
        return null;
    } 
    private static Function<City, Time> createBasicTraffic() {
        return null;
    } 
    public static class Time { } 
  public static void main(String []argv) {}

  @MethodLevelAnnotation
  public void annotatedMethod() { }
  public void nonAnnotatedMethod() {
  }
 * TESTDATA. The testdata for these tests is kept in org.aspectj.matcher/testdata. It is a series of .java files that need to be
 * compiled and available at runtime. Since they are java5 (they include annotations) they cannot be in a source folder for the
 * project, so they are compiled separately and then jar'd into a testdata.jar file in that folder. This folder is defined to be on
 * the classpath for org.aspectj.matcher, this enables them to be seen by a simple world that uses the classpath of the matcher
 * project as the definition of what it can see. Other worlds, for example JDT World, will need to have those types defined in a
 * project that is accessible in the JDT World instance. Because these tests exercise Java5 matching, the concrete ReflectionWorld
 * subtype is not defined in here, it is defined in weaver5 (messy, but works well).
 * 

======= fetch "private void createAnyBridgeMethodsForCovariance(BcelClassWeaver weaver, NewMeth" a8e6797^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"


======= fetch "public ResolvedType getOuterClass() {" 945402f^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "public ResolvedType getOuterClass() {" 945402f^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"


======= fetch "public void setAdditionalInterfaceBounds(UnresolvedType[] superInterfaces) {" 80785bf^:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariable.java"

======= fetch "public TypeVariable getTypeVariable() {" 80785bf^:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariableReferenceType.java"

======= fetch "public ReferenceType getUpperBound() {" 80785bf^:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariableReferenceType.java"

======= fetch "public ResolvedType resolve(UnresolvedType ty, boolean allowMissing) {" 80785bf^:"org.aspectj.matcher/src/org/aspectj/weaver/World.java"


 * 
======= fetch "private FileUtil() {" 5648105^:"util/src/org/aspectj/util/FileUtil.java"

======= fetch "private FileUtil() {" 5648105^:"util/src/org/aspectj/util/FileUtil.java"


======= fetch "public IProgramElement getRoot() {" 6249672^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public String toSummaryString() {" 6249672^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public String toSummaryString() {" 6249672^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public String toSummaryString() {" 6249672^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public String toSummaryString() {" 6249672^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public void flushFileMap() {" 6249672^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public void forget(IProgramElement compilationUnitNode,IProgramElement typeNode)" 6249672^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public void forget(IProgramElement compilationUnitNode,IProgramElement typeNode)" 6249672^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public void forget(IProgramElement compilationUnitNode,IProgramElement typeNode)" 6249672^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public void forget(IProgramElement compilationUnitNode,IProgramElement typeNode)" 6249672^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public void forget(IProgramElement compilationUnitNode,IProgramElement typeNode)" 6249672^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public void updateHandleMap(Set<String> deletedFiles) {" 6249672^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"


======= fetch "private ByteArrayOutputStream getOutxmlContents(List aspectNames) {" 03c43f5^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private ByteArrayOutputStream getOutxmlContents(List aspectNames) {" 03c43f5^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"


======= fetch "public void visit(Instanceof instanceofTest) {" 2a8d684^:"org.aspectj.matcher/src/org/aspectj/weaver/reflect/ShadowMatchImpl.java"

======= fetch "private boolean needToSkipPointcutParserTests() {" 2a8d684^:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

======= fetch "private boolean needToSkipPointcutParserTests() {" 2a8d684^:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

======= fetch "public void testMatchJP() throws Exception {" 2a8d684^:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

======= fetch "public void testMatchJP() throws Exception {" 2a8d684^:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

======= fetch "public void testBinding() throws Exception {" 2a8d684^:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

======= fetch "public void testBinding() throws Exception {" 2a8d684^:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

======= fetch "public void testBinding() throws Exception {" 2a8d684^:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

======= fetch "private void checkNoMatch(ShadowMatch sMatch, Object thisObj, Object targetObj," 2a8d684^:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

======= fetch "private void checkNoMatch(ShadowMatch sMatch, Object thisObj, Object targetObj," 2a8d684^:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"


======= fetch "private boolean hasStructuralChanges(ClassFileReader reader, CompactTypeStructur" 88fab6a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "public ReferenceTypeDelegate getDelegate(ReferenceType referenceType) {" 88fab6a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"


======= fetch "public void write(CompressingDataOutputStream s) throws IOException {" e0e1330^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/ModifiersPattern.java"

======= fetch "public static int getModifierFlag(String name) {" e0e1330^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/ModifiersPattern.java"


======= fetch "public PerClause getPerClause() {" ce16a06^:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"


======= fetch "public int demote(boolean atEndOfCompile) {" f631ad6^:"org.aspectj.matcher/src/org/aspectj/weaver/World.java"

======= fetch "public int demote(boolean atEndOfCompile) {" f631ad6^:"org.aspectj.matcher/src/org/aspectj/weaver/World.java"


  public int q2.Code.i;
  public void q2.Code.something2() {}
======= fetch "public void testIncrementalFqItds_280380_3() throws Exception {" 6b35ea4^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= fetch "public void testIncrementalCtorItdHandle_280383() throws Exception {" 6b35ea4^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


======= fetch "public void completeTypeBindings() {" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "public void completeTypeBindings() {" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "public void completeTypeBindings() {" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void collectAllITDsAndDeclares(SourceTypeBinding sourceType, Collection" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveIntertypes(List<SourceTypeBinding> typesToProcess, SourceTypeB" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveIntertypes(List<SourceTypeBinding> typesToProcess, SourceTypeB" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveIntertypes(List<SourceTypeBinding> typesToProcess, SourceTypeB" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveIntertypes(List<SourceTypeBinding> typesToProcess, SourceTypeB" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(CompilationUnitScope unit, List<Concrete" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType) {" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType) {" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, List<Concr" 16adee6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"


======= fetch "protected boolean accept(String className, byte[] bytes) {" 85fd25d^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= fetch "protected boolean accept(String className, byte[] bytes) {" 85fd25d^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= fetch "public void testAcceptanceSpeedStarDotDotStar() throws Exception {" 85fd25d^:"loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java"

======= fetch "public TestClassLoaderWeavingAdaptor getAdaptor(String[] includePatterns, String" 85fd25d^:"loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java"

======= fetch "private void printMaps(TypeMap map) {" 85fd25d^:"loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java"

======= fetch "private void printExpendableMap(Map m) {" 85fd25d^:"loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java"

======= fetch "public static SyntheticRepository createRepos(String cpentry) {" 85fd25d^:"loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java"

======= fetch "public void addDefinition(Definition d) {" 85fd25d^:"loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java"

 * Copyright (c) 2009 Contributors.
 * All rights reserved.
 * This program and the accompanying materials are made available
 * under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution and is available at
 * http://eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *  Andy Clement
 *******************************************************************************/

======= fetch "private void ensureAnnotationTypesResolved() {" fe049ea^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"


 * @author Andy Clement
======= fetch "public BindingScope(ResolvedType type, ISourceContext sourceContext, FormalBindi" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/BindingScope.java"

======= fetch "public ResolvedType getEnclosingType() {" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/BindingScope.java"

======= fetch "public ISourceLocation makeSourceLocation(IHasPosition location) {" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/BindingScope.java"

======= fetch "public UnresolvedType lookupType(String name, IHasPosition location) {" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/BindingScope.java"

======= fetch "public UnresolvedType lookupType(String name, IHasPosition location) {" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/BindingScope.java"

======= fetch "public UnresolvedType lookupType(String name, IHasPosition location) {" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/BindingScope.java"

======= fetch "public UnresolvedType lookupType(String name, IHasPosition location) {" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/BindingScope.java"

======= fetch "public UnresolvedType lookupType(String name, IHasPosition location) {" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/BindingScope.java"

======= fetch "public UnresolvedType lookupType(String name, IHasPosition location) {" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/BindingScope.java"

    /** returns the type corresponding to the name in this scope
     *  returns ResolvedType.MISSING if no such type exists and reports a problem
     */
    UnresolvedType lookupType(String name, IHasPosition location);
    // these next three are used to create {@link BindingTypePattern} objects.
    /** returns the formal associated with the name, or null if no such formal exists */
    FormalBinding lookupFormal(String name);
    /** returns the formal with the index.  Throws ArrayOutOfBounds exception if out of bounds */
======= fetch "public SimpleScope(World world, FormalBinding[] bindings) {" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/SimpleScope.java"

======= fetch "public UnresolvedType lookupType(String name, IHasPosition location) {" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/SimpleScope.java"

======= fetch "public UnresolvedType lookupType(String name, IHasPosition location) {" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/SimpleScope.java"

======= fetch "public FormalBinding lookupFormal(String name) {" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/SimpleScope.java"

======= fetch "public FormalBinding lookupFormal(String name) {" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/SimpleScope.java"

======= fetch "public void setImportedPrefixes(String[] importedPrefixes) {" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/SimpleScope.java"

======= fetch "public void message(IMessage.Kind kind, IHasPosition location, String message) {" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/SimpleScope.java"

======= fetch "protected boolean couldEverMatchSameTypesAs(TypePattern other) {" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "protected boolean couldEverMatchSameTypesAs(TypePattern other) {" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "private boolean isNamePatternStar() {" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "private boolean isNamePatternStar() {" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "private boolean isNamePatternStar() {" 767bb85^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "public static Test suite() {" 767bb85^:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/PatternsTests.java"

 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *     PARC     initial implementation 
 * ******************************************************************/
======= fetch "public void testImportMatchWithInners() {" 767bb85^:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/TypePatternTestCase.java"


======= fetch "private void ensureGenericSignatureUnpacked() {" 92a52a2^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"


======= fetch "public static Advice makeCflowEntry(World world, Pointcut entry, boolean isBelow" 0e5ecd3^:"org.aspectj.matcher/src/org/aspectj/weaver/Advice.java"


======= fetch "private void ensureAspectJAttributesUnpacked() {" cf0ee0c^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "public void evictWeavingState() {" cf0ee0c^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "public BcelObjectType addSourceObjectType(String classname, byte[] bytes, boolea" cf0ee0c^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= fetch "public BcelObjectType addSourceObjectType(String classname, byte[] bytes, boolea" cf0ee0c^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= fetch "public BcelObjectType addSourceObjectType(String classname, byte[] bytes, boolea" cf0ee0c^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= fetch "protected Boolean initialValue() {" cf0ee0c^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "protected Boolean initialValue() {" cf0ee0c^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"


======= fetch "public int compare(Pointcut p1, Pointcut p2) {" 1e28b92^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/PointcutEvaluationExpenseComparator.java"

======= fetch "public int compare(Pointcut p1, Pointcut p2) {" 1e28b92^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/PointcutEvaluationExpenseComparator.java"

======= fetch "private int getScore(Pointcut p) {" 1e28b92^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/PointcutEvaluationExpenseComparator.java"

======= fetch "private int getScore(Pointcut p) {" 1e28b92^:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/PointcutEvaluationExpenseComparator.java"

 * @author colyer
 *         TODO To change the template for this generated type comment go to Window - Preferences - Java - Code Style - Code
 *         Templates
======= fetch "public void testOrderingInAnd() {" 1e28b92^:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/PointcutRewriterTest.java"

======= fetch "public void testOrderingInAnd() {" 1e28b92^:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/PointcutRewriterTest.java"


======= fetch "private static ISourceLocation getBinarySourceLocation(ResolvedType aspect, ISou" 3be69a2^:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"

======= fetch "private static void addPointcuts(AsmManager model, String sourcefilename, Resolv" 3be69a2^:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"

======= fetch "public static void addDeclareAnnotationMethodRelationship(ISourceLocation source" 3be69a2^:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"

======= fetch "public static void addDeclareAnnotationMethodRelationship(ISourceLocation source" 3be69a2^:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"

======= fetch "public static void addDeclareAnnotationMethodRelationship(ISourceLocation source" 3be69a2^:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"

======= fetch "public static void addDeclareAnnotationMethodRelationship(ISourceLocation source" 3be69a2^:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"

======= fetch "public static void addDeclareAnnotationMethodRelationship(ISourceLocation source" 3be69a2^:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"

======= fetch "public static void addDeclareAnnotationMethodRelationship(ISourceLocation source" 3be69a2^:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"

======= fetch "public static void addDeclareAnnotationMethodRelationship(ISourceLocation source" 3be69a2^:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"

======= fetch "public static void addDeclareAnnotationMethodRelationship(ISourceLocation source" 3be69a2^:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"

======= fetch "public static void addDeclareAnnotationMethodRelationship(ISourceLocation source" 3be69a2^:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"

======= fetch "public static void addDeclareAnnotationMethodRelationship(ISourceLocation source" 3be69a2^:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"

======= fetch "public static void addDeclareAnnotationMethodRelationship(ISourceLocation source" 3be69a2^:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"

======= fetch "public static void addDeclareAnnotationMethodRelationship(ISourceLocation source" 3be69a2^:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"


======= fetch "private void removeSingleNode(IProgramElement progElem) {" 728ecb8^:"asm/src/org/aspectj/asm/AsmManager.java"


======= fetch "public ProgramElement(AsmManager asm, String name, Kind kind, List children) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public ProgramElement(AsmManager asm, String name, Kind kind, List children) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setDeclaringType(String t) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setDeclaringType(String t) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String getDeclaringType() {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String getDeclaringType() {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String getPackageName() {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String getPackageName() {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setMessage(IMessage message) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setMessage(IMessage message) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setRunnable(boolean value) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setRunnable(boolean value) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setRunnable(boolean value) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setRunnable(boolean value) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setImplementor(boolean value) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setImplementor(boolean value) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setImplementor(boolean value) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setImplementor(boolean value) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setOverrider(boolean value) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setOverrider(boolean value) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setOverrider(boolean value) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setOverrider(boolean value) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setRelations(List relations) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setRelations(List relations) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String getFormalComment() {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "private static List genModifiers(int modifiers) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "private static List genModifiers(int modifiers) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "private static List genModifiers(int modifiers) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "private static List genModifiers(int modifiers) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "private static List genModifiers(int modifiers) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "private static List genModifiers(int modifiers) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "private static List genModifiers(int modifiers) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "private static List genModifiers(int modifiers) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "private static List genModifiers(int modifiers) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "private static List genModifiers(int modifiers) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "private static List genModifiers(int modifiers) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "private static List genModifiers(int modifiers) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "private static List genModifiers(int modifiers) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "private static List genModifiers(int modifiers) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setBytecodeName(String s) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setBytecodeName(String s) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setSourceSignature(String string) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setSourceSignature(String string) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setCorrespondingType(String s) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setCorrespondingType(String s) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setParentTypes(List ps) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setParentTypes(List ps) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String getCorrespondingType(boolean getFullyQualifiedType) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String getCorrespondingType(boolean getFullyQualifiedType) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String getCorrespondingType(boolean getFullyQualifiedType) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setChildren(List children) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setChildren(List children) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void addChild(IProgramElement child) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void addChild(IProgramElement child) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void addChild(int position, IProgramElement child) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void addChild(int position, IProgramElement child) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String toLongString() {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void preProcess(IProgramElement node) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void preProcess(IProgramElement node) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void preProcess(IProgramElement node) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String toSignatureString(boolean getFullyQualifiedArgTypes) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String toSignatureString(boolean getFullyQualifiedArgTypes) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setParameterNames(List list) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setParameterNames(List list) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setParameterNames(List list) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setDetails(String string) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setDetails(String string) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setFormalComment(String txt) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setFormalComment(String txt) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setExtraInfo(ExtraInformation info) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void setExtraInfo(ExtraInformation info) {" a502da8^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"


======= fetch "private static void appendNLabel(StringBuffer sink, String label, int numItems)" b21eb05^:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"

======= fetch "void setController(CommandController controller) {" b21eb05^:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"

======= fetch "public void run(String[] args, IMessageHolder holder) {" b21eb05^:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"


======= fetch "public String getAnnotationDefaultValue() {" 94d0a4e^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseResolvedMember.java"

======= fetch "public String getAnnotationDefaultValue() {" 94d0a4e^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseResolvedMember.java"

======= fetch "public String getAnnotationDefaultValue() {" 94d0a4e^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseResolvedMember.java"


  declare warning: @Anno *: "Nothing should be annotated Anno!";
  
  
  declare error: I+ && !hasmethod(* foo(..)): "Missing foo() method in I subtype";
  void foo() {}  
  
  declare warning: I+ && !hasmethod(* foo(..)): "Missing foo() method in I subtype";
  void foo() {}  
  

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, Collection" 4b43dc6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"


 * @author Andy Clement
======= fetch "public IProgramElement findElementForSignature(IProgramElement parent, IProgramE" 749078d^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public IProgramElement findElementForSignature(IProgramElement parent, IProgramE" 749078d^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public IProgramElement findElementForLabel(IProgramElement parent, IProgramEleme" 749078d^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public IProgramElement findElementForLabel(IProgramElement parent, IProgramEleme" 749078d^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public IProgramElement findElementForType(String packageName, String typeName) {" 749078d^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public IProgramElement findElementForType(String packageName, String typeName) {" 749078d^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "private IProgramElement findClassInNodes(Collection nodes, String name, String t" 749078d^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "private IProgramElement findClassInNodes(Collection nodes, String name, String t" 749078d^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "private IProgramElement findClassInNodes(Collection nodes, String name, String t" 749078d^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "private boolean hasMoreSpecificChild(IProgramElement node, String sourceFilePath" 749078d^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "private boolean hasMoreSpecificChild(IProgramElement node, String sourceFilePath" 749078d^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public IProgramElement findElementForHandleOrCreate(String handle, boolean creat" 749078d^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public IProgramElement findElementForHandleOrCreate(String handle, boolean creat" 749078d^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "private IProgramElement findElementForHandle(IProgramElement parent, String hand" 749078d^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "private IProgramElement findElementForHandle(IProgramElement parent, String hand" 749078d^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public void updateHandleMap(Set deletedFiles) {" 749078d^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public void updateHandleMap(Set deletedFiles) {" 749078d^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public void updateHandleMap(Set deletedFiles) {" 749078d^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public void updateHandleMap(Set deletedFiles) {" 749078d^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"


======= fetch "protected boolean accept(String className, byte[] bytes) {" a968890^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"




 package com.citi.gdos.smart.applib.service.cache;
 * Copyright (c) 2008 Contributors 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
 * Tests for the new all singing all dancing intertype syntax.
 * 
 * @author Andy Clement
 */
  <ajc-test dir="bugs167/pr293457" title="hierarchy builder npe">
     <compile files="com/citi/gdos/smart/applib/service/cache/CachingIntroduction.aj org/springmodules/cache/annotations/Cacheable.java" options="-1.5 -emacssym">
     <message kind="warning" text="no match for this type name: Setter"/>
     <message kind="error" text="Setter cannot be resolved to a type"/>
     <message kind="error" text="The attribute modelId is undefined for the"/>
     </compile>
  </ajc-test>
  
   
   <ajc-test dir="features167/intertype" title="simple">
     <compile files="Simple.java" options="-1.5"/>
   </ajc-test>
   
   <ajc-test dir="features167/intertype" title="simple with field">
     <compile files="Two.java" options="-1.5"/>
   </ajc-test>
   
   <ajc-test dir="features167/intertype" title="simple with field2">
     <compile files="Three.java" options="-1.5"/>
   </ajc-test>
   
   <ajc-test dir="features167/intertype" title="new instance">
     <compile files="Four.java" options="-1.5"/>
   </ajc-test>
   
   <ajc-test dir="features167/intertype" title="new instance and access">
     <compile files="Five.java" options="-1.5"/>
     <run class="Five">
       <stdout>
         <line text="5"/>
       </stdout>
     </run>
   </ajc-test>
   
   <ajc-test dir="features167/intertype" title="new instance and access to two fields">
     <compile files="Six.java" options="-1.5"/>
     <run class="Six">
       <stdout>
         <line text="5"/>
       </stdout>
     </run>
   </ajc-test>
   
   

======= fetch "public MissingResolvedTypeWithKnownSignature(String signature, World world) {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public MissingResolvedTypeWithKnownSignature(String signature, String signatureE" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public MissingResolvedTypeWithKnownSignature(String signature, String signatureE" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public MissingResolvedTypeWithKnownSignature(String signature, String signatureE" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public MissingResolvedTypeWithKnownSignature(String signature, String signatureE" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public MissingResolvedTypeWithKnownSignature(String signature, String signatureE" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public ResolvedType getSuperclass() {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public int getModifiers() {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public void tidy() {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public boolean isAssignableFrom(ResolvedType other) {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public boolean isAssignableFrom(ResolvedType other, boolean allowMissing) {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public boolean isAssignableFrom(ResolvedType other, boolean allowMissing) {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public boolean isAssignableFrom(ResolvedType other, boolean allowMissing) {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public boolean isAssignableFrom(ResolvedType other, boolean allowMissing) {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public boolean hasAnnotation(UnresolvedType ofType) {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public List getInterTypeMungers() {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public List getInterTypeMungersIncludingSupers() {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public List getInterTypeParentMungers() {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public List getInterTypeParentMungersIncludingSupers() {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public void raiseWarningOnJoinPointSignature(String signature) {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public void raiseWarningOnJoinPointSignature(String signature) {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public void raiseWarningOnMissingInterfaceWhilstFindingMethods() {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public void raiseWarningOnMissingInterfaceWhilstFindingMethods() {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "private void raiseCantFindType(String key) {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "private void raiseCantFindType(String key) {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "private void raiseCantFindType(String key, String insert) {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "private void raiseCantFindType(String key, String insert) {" a23c7e4^:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"


======= fetch "private static String lastbit(String fqname) {" 35a9649^:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

======= fetch "private static String lastbit(String fqname) {" 35a9649^:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"


======= fetch "protected Class defineClass(String name, byte[] b, CodeSource cs) throws IOExcep" 4d200d1^:"weaver/src/org/aspectj/weaver/bcel/ExtensibleURLClassLoader.java"


======= fetch "private JavaClass lookupJavaClass(ClassPathManager classPath, String name) {" 67ffda8^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= fetch "private JavaClass lookupJavaClass(ClassPathManager classPath, String name) {" 67ffda8^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= fetch "private JavaClass lookupJavaClass(ClassPathManager classPath, String name) {" 67ffda8^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= fetch "private JavaClass lookupJavaClass(ClassPathManager classPath, String name) {" 67ffda8^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"


======= fetch "public static boolean is13VMOrGreater() {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static boolean is14VMOrGreater() {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static boolean is15VMOrGreater() {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static boolean is16VMOrGreater() {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static final void throwIaxIfNull(final Object o, final String name) {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static final void throwIaxIfNotAssignable(final Object ra[], final Class" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static List commaSplit(String input) {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static List commaSplit(String input) {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static boolean getBoolean(String propertyName, boolean defaultValue) {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static List anySplit(String input, String delim) {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static List safeList(List list) {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static List safeList(List list) {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static List safeList(List list) {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static List safeList(List list) {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static String unqualifiedClassName(Class c) {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static String renderExceptionShort(Throwable e) {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static String renderException(Throwable t) {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static String renderException(Throwable t, boolean elide) {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static Throwable unwrapException(Throwable t) {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static String makeClasspath( // XXX dumb implementation" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "private static boolean addIfNotEmpty(String input, StringBuffer sink, String del" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static boolean sleepUntil(long time) {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static boolean sleepUntil(long time) {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static boolean sleepUntil(long time) {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public static boolean sleepUntil(long time) {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public ProcessController() {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public final void setOutSnoop(ByteArrayOutputStream snoop) {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public void run() {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public final boolean userStopped() {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public final boolean userStopped() {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "public final int getResult() {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"

======= fetch "protected void doCompleting(Thrown thrown, int result) {" b29f839^:"util/src/org/aspectj/util/LangUtil.java"


======= fetch "public void loadDefaultProperties() {" 3d3d03b^:"org.aspectj.matcher/src/org/aspectj/weaver/Lint.java"


======= fetch "public boolean hasAnnotation(UnresolvedType ofType) {" b664969^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "public boolean hasAnnotation(UnresolvedType ofType) {" b664969^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "public boolean hasAnnotation(UnresolvedType ofType) {" b664969^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "public boolean canAnnotationTargetType() {" b664969^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "private void ensureAnnotationsUnpacked() {" b664969^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "private void ensureAnnotationsUnpacked() {" b664969^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "private void ensureAnnotationsUnpacked() {" b664969^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"


======= fetch "public ResolvedType resolve(UnresolvedType ty, boolean allowMissing) {" dd7d879^:"org.aspectj.matcher/src/org/aspectj/weaver/World.java"

======= fetch "public ResolvedType resolve(UnresolvedType ty, boolean allowMissing) {" dd7d879^:"org.aspectj.matcher/src/org/aspectj/weaver/World.java"

======= fetch "public ResolvedType resolve(UnresolvedType ty, boolean allowMissing) {" dd7d879^:"org.aspectj.matcher/src/org/aspectj/weaver/World.java"


======= fetch "static boolean has14ToolsAvailable() {" 59d5c3b^:"ajdoc/src/org/aspectj/tools/ajdoc/JavadocRunner.java"

            Class jdMainClass = com.sun.tools.javadoc.Main.class;
======= fetch "static boolean has14ToolsAvailable() {" 59d5c3b^:"ajdoc/src/org/aspectj/tools/ajdoc/JavadocRunner.java"

        } catch (NoClassDefFoundError e) {
            return false;
        } catch (UnsupportedClassVersionError e) {
            return false;
        } catch (NoSuchMethodException e) {
======= fetch "static boolean has14ToolsAvailable() {" 59d5c3b^:"ajdoc/src/org/aspectj/tools/ajdoc/JavadocRunner.java"

     static void callJavadoc( String[] javadocargs ){
        final SecurityManager defaultSecurityManager = System.getSecurityManager();
======= fetch "static void callJavadoc( String[] javadocargs ){" 59d5c3b^:"ajdoc/src/org/aspectj/tools/ajdoc/JavadocRunner.java"

        System.setSecurityManager( new SecurityManager() {
            public void checkExit(int status) {
                if (status == 0) {
                   throw new SecurityException();
                }
                else {
                     System.setSecurityManager(defaultSecurityManager);
                //System.out.println("Error: javadoc exited unexpectedly");
                     System.exit(0);
                     throw new SecurityException();
                }
            }
            public void checkPermission( java.security.Permission permission ) {
               if ( defaultSecurityManager  != null )
                defaultSecurityManager.checkPermission( permission );
            }
             public void checkPermission( java.security.Permission permission,
               if ( defaultSecurityManager  != null )
                 defaultSecurityManager.checkPermission( permission, context );
            }
            } );
======= fetch "public void checkPermission( java.security.Permission permission," 59d5c3b^:"ajdoc/src/org/aspectj/tools/ajdoc/JavadocRunner.java"

        try {
        	// for JDK 1.4 and above call the execute method...
        	Class jdMainClass = com.sun.tools.javadoc.Main.class;
        	Method executeMethod = null;
======= fetch "public void checkPermission( java.security.Permission permission," 59d5c3b^:"ajdoc/src/org/aspectj/tools/ajdoc/JavadocRunner.java"

======= fetch "public void checkPermission( java.security.Permission permission," 59d5c3b^:"ajdoc/src/org/aspectj/tools/ajdoc/JavadocRunner.java"

======= fetch "public void checkPermission( java.security.Permission permission," 59d5c3b^:"ajdoc/src/org/aspectj/tools/ajdoc/JavadocRunner.java"

======= fetch "public void checkPermission( java.security.Permission permission," 59d5c3b^:"ajdoc/src/org/aspectj/tools/ajdoc/JavadocRunner.java"

        	// main method is documented as calling System.exit() - which stops us dead in our tracks
            //com.sun.tools.javadoc.Main.main( javadocargs );
        }
        catch ( SecurityException se ) {
            // Do nothing since we expect it to be thrown
            //System.out.println( ">> se: " + se.getMessage() );
        }
        // Set the security manager back
        System.setSecurityManager( defaultSecurityManager );
    }

======= fetch "public boolean canAnnotationTargetType() {" 3417cbe^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "public boolean canAnnotationTargetType() {" 3417cbe^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "public boolean canAnnotationTargetType() {" 3417cbe^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"


======= fetch "public InputSource resolveEntity(String publicId, String systemId) throws SAXExc" 66235e8^:"weaver/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"


======= fetch "public void generateDispatchMethod(ClassScope classScope, ClassFile classFile) {" f9578da^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

======= fetch "public void generateDispatchMethod(ClassScope classScope, ClassFile classFile) {" f9578da^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"


======= fetch "private void setupModel(AjBuildConfig config) {" 1b663a9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public World getWorld() {" 1b663a9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void acceptResult(CompilationResult unitResult) {" 1b663a9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private String checkRtJar(AjBuildConfig buildConfig) {" 1b663a9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"


======= fetch "private String getParameters(IProgramElement ipe) {" 6dbb5f3^:"asm/src/org/aspectj/asm/internal/JDTLikeHandleProvider.java"


======= fetch "public boolean accept(File pathname) {" b23cc1a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private int classFileChangedInDirSinceLastBuildRequiringFullBuild(File dir) {" b23cc1a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private int classFileChangedInDirSinceLastBuildRequiringFullBuild(File dir) {" b23cc1a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private int classFileChangedInDirSinceLastBuildRequiringFullBuild(File dir) {" b23cc1a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean isTypeWeReferTo(File file) {" b23cc1a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean isTypeWeReferTo(File file) {" b23cc1a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean isTypeWeReferTo(File file) {" b23cc1a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean isTypeWeReferTo(File file) {" b23cc1a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean hasAnyStructuralChangesSince(long lastSuccessfulBuildTime) {" b23cc1a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean pathChange(AjBuildConfig previousConfig, AjBuildConfig newConfig" b23cc1a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean pathChange(AjBuildConfig previousConfig, AjBuildConfig newConfig" b23cc1a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean pathChange(AjBuildConfig previousConfig, AjBuildConfig newConfig" b23cc1a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean pathChange(AjBuildConfig previousConfig, AjBuildConfig newConfig" b23cc1a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean changedAndNeedsFullBuild(List oldPath, List newPath, boolean che" b23cc1a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean changedAndNeedsFullBuild(List oldPath, List newPath, boolean che" b23cc1a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean classpathChangedAndNeedsFullBuild(List oldPath, List newPath, bo" b23cc1a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"


======= fetch "public static void addRelationship(AsmManager model, ResolvedType onType, Resolv" d5e900d^:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"


======= fetch "public void acceptResult(CompilationResult unitResult) {" c732808^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public static String makeLocationContext(ICompilationUnit compilationUnit, IProb" c732808^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"

======= fetch "public static String makeLocationContext(ICompilationUnit compilationUnit, IProb" c732808^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"

======= fetch "public static ISourceLocation makeSourceLocation(ICompilationUnit unit, IProblem" c732808^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"

======= fetch "public static ISourceLocation makeSourceLocation(ICompilationUnit unit, IProblem" c732808^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"

======= fetch "public static ISourceLocation makeSourceLocation(ICompilationUnit unit, IProblem" c732808^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"



======= fetch "public IProgramElement findElementForType(String packageName, String typeName) {" 7a7d6f0^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public IProgramElement findElementForType(String packageName, String typeName) {" 7a7d6f0^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public IProgramElement findElementForType(String packageName, String typeName) {" 7a7d6f0^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public IProgramElement findElementForType(String packageName, String typeName) {" 7a7d6f0^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public IProgramElement findElementForType(String packageName, String typeName) {" 7a7d6f0^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"


======= fetch "private void writeDirectory(String directory, File srcloc) throws IOException {" 5c49c0b^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeResource(String filename, byte[] content, File srcLocation) th" 5c49c0b^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private boolean pathChange(AjBuildConfig previousConfig, AjBuildConfig newConfig" 5c49c0b^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private void removeAllResultsOfLastBuild() {" 5c49c0b^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "public boolean hasResource(String resourceName) {" 5c49c0b^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "public boolean hasResource(String resourceName) {" 5c49c0b^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"


======= fetch "public IProgramElement findCloserMatchForLineNumber(IProgramElement node, int li" 2309f7b^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"


======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" 2f36e7f^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" 2f36e7f^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" 2f36e7f^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" 2f36e7f^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private void signalError(String msgid, BcelClassWeaver weaver, UnresolvedType on" 2f36e7f^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewConstructor(BcelClassWeaver weaver, NewConstructorTypeMu" 2f36e7f^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewField(BcelClassWeaver weaver, NewFieldTypeMunger munger)" 2f36e7f^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewField(BcelClassWeaver weaver, NewFieldTypeMunger munger)" 2f36e7f^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewField(BcelClassWeaver weaver, NewFieldTypeMunger munger)" 2f36e7f^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"


======= fetch "private File getBinaryFile() {" 9f80317^:"org.aspectj.matcher/src/org/aspectj/weaver/ShadowMunger.java"

======= fetch "private File getBinaryFile() {" 9f80317^:"org.aspectj.matcher/src/org/aspectj/weaver/ShadowMunger.java"


======= fetch "public String createHandleIdentifier(IProgramElement ipe) {" 0af658e^:"asm/src/org/aspectj/asm/internal/JDTLikeHandleProvider.java"


======= fetch "public static boolean weave(BcelWorld world, LazyClassGen clazz, List shadowMung" 1b54b4b^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public BcelWorld getWorld() {" 1b54b4b^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public static void setReweavableMode(boolean mode) {" 1b54b4b^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public boolean munge(BcelClassWeaver weaver) {" 1b54b4b^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private LazyClassGen weave(UnwovenClassFile classFile, BcelObjectType classType," 1b54b4b^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public void setReweavableMode(boolean xNotReweavable) {" 1b54b4b^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public void setReweavableMode(boolean xNotReweavable) {" 1b54b4b^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


 * This runs the AspectJ 1.1 compiler, 
 * supporting all the command-line options.
 * In 1.1.1, ajc copies resources from input jars, 
 * but you can copy resources from the source directories
 * using sourceRootCopyFilter.
 * When not forking, things will be copied as needed 
 * for each iterative compile,
 * but when forking things are only copied at the 
 * completion of a successful compile.
 * See the development environment guide for 
 * usage documentation.
    /*
     * This task mainly converts ant specification for ajc,
     * verbosely ignoring improper input.
     * It also has some special features for non-obvious clients:
     * (1) Javac compiler adapter supported in 
     *    <code>setupAjc(AjcTask, Javac, File)</code>
     * and
     *    <code>readArguments(String[])</code>;
     * (2) testing is supported by
     * (a) permitting the same specification to be re-run
     *     with added flags (settings once made cannot be
     *     removed); and
     * (b) permitting recycling the task with 
     *     <code>reset()</code> (untested).
     * 
     * The parts that do more than convert ant specs are
     * (a) code for forking;
     * (b) code for copying resources.
     * 
     * If you maintain/upgrade this task, keep in mind:
     * (1) changes to the semantics of ajc (new options, new
     *     values permitted, etc.) will have to be reflected here. 
     * (2) the clients:
     * the iajc ant script, Javac compiler adapter,
     * maven clients of iajc, and testing code.
     */
    // XXX move static methods after static initializer
    /**
     * This method extracts javac arguments to ajc,
     * and add arguments to make ajc behave more like javac
     * in copying resources.
     * <p>
     * Pass ajc-specific options using compilerarg sub-element:
     * <pre>
     * &lt;javac srcdir="src">
     *     &lt;compilerarg compiler="..." line="-argfile src/args.lst"/>
     * &lt;javac>
     * </pre>
     * Some javac arguments are not supported in this component (yet):
     * <pre>
     * String memoryInitialSize;
     * boolean includeAntRuntime = true;
     * boolean includeJavaRuntime = false;
     * </pre>
     * Other javac arguments are not supported in ajc 1.1:
     * <pre>
     * boolean optimize;
     * String forkedExecutable;
     * FacadeTaskHelper facade;
     * boolean depend;
     * String debugLevel;
     * Path compileSourcepath;
     * </pre>
     * @param javac the Javac command to implement (not null)
     * @param ajc the AjcTask to adapt (not null)
     * @param destDir the File class destination directory (may be null)
     * @return null if no error, or String error otherwise
     */
    public String setupAjc(Javac javac) {        
        if (null == javac) {
            return "null javac";
        }
        AjcTask ajc = this;
        // no null checks b/c AjcTask handles null input gracefully
        ajc.setProject(javac.getProject());
        ajc.setLocation(javac.getLocation());
        ajc.setTaskName("javac-iajc");
        
        ajc.setDebug(javac.getDebug());
        ajc.setDeprecation(javac.getDeprecation());
        ajc.setFailonerror(javac.getFailonerror());
        final boolean fork = javac.isForkedJavac();
        ajc.setFork(fork);        
        if (fork) {
            ajc.setMaxmem(javac.getMemoryMaximumSize());
        }
        ajc.setNowarn(javac.getNowarn()); 
        ajc.setListFileArgs(javac.getListfiles());
        ajc.setVerbose(javac.getVerbose());               
        ajc.setTarget(javac.getTarget());        
        ajc.setSource(javac.getSource());        
        ajc.setEncoding(javac.getEncoding());
        File javacDestDir = javac.getDestdir();
        if (null != javacDestDir) {
            ajc.setDestdir(javacDestDir);
            // filter requires dest dir
            // mimic Javac task's behavior in copying resources,
            ajc.setSourceRootCopyFilter("**/CVS/*,**/*.java,**/*.aj");
        }        
        ajc.setBootclasspath(javac.getBootclasspath());
        ajc.setExtdirs(javac.getExtdirs());
        ajc.setClasspath(javac.getClasspath());        
        // ignore srcDir -- all files picked up in recalculated file list
        ajc.addFiles(javac.getFileList());
        // arguments can override the filter, add to paths, override options
        ajc.readArguments(javac.getCurrentCompilerArgs());
        
        return null;
    }
    
   /**
     * Find aspectjtools.jar on the task or system classpath.
     * Accept <code>aspectj{-}tools{...}.jar</code>
     * mainly to support build systems using maven-style 
     * re-naming 
     * (e.g., <code>aspectj-tools-1.1.0.jar</code>.
     * Note that we search the task classpath first, 
     * though an entry on the system classpath would be loaded first,
     * because it seems more correct as the more specific one.
     * @return readable File for aspectjtools.jar, or null if not found.
     */            
    public static File findAspectjtoolsJar() {
        File result = null;
        ClassLoader loader = AjcTask.class.getClassLoader();
        if (loader instanceof AntClassLoader) {
            AntClassLoader taskLoader = (AntClassLoader) loader;
            String cp = taskLoader.getClasspath();
            String[] cps = LangUtil.splitClasspath(cp);
            for (int i = 0; (i < cps.length) && (null == result); i++) {
                result = isAspectjtoolsjar(cps[i]);
            }
        }
        if (null == result) {
            final Path classpath = Path.systemClasspath;
            final String[] paths = classpath.list();
            for (int i = 0; (i < paths.length) && (null == result); i++) {
                result = isAspectjtoolsjar(paths[i]);
            }
        }
        return (null == result? null : result.getAbsoluteFile());
    }
    
    /** @return File if readable jar with aspectj tools name, or null */
    private static File isAspectjtoolsjar(String path) {
        if (null == path) {
            return null;
        }
        final String prefix = "aspectj";        
        final String infix = "tools";        
        final String altInfix = "-tools";        
        final String suffix = ".jar";
        final int prefixLength = 7; // prefix.length();
        final int minLength = 16;
        // prefixLength + infix.length() + suffix.length();        
        if (!path.endsWith(suffix)) {
            return null;
        }
        int loc = path.lastIndexOf(prefix);
        if ((-1 != loc) && ((loc + minLength) <= path.length())) {
            String rest = path.substring(loc+prefixLength);
            if (-1 != rest.indexOf(File.pathSeparator)) {
                return null;
            }
            if (rest.startsWith(infix)
                || rest.startsWith(altInfix)) {
                File result = new File(path);
                if (result.canRead() && result.isFile()) {
                    return result;
                }
            }
        }        
        return null;
    }
    /** 
     * Maximum length (in chars) of command line 
     * before converting to an argfile when forking 
     */
    private static final int MAX_COMMANDLINE = 4096;
    
    private static final File DEFAULT_DESTDIR = new File(".") {
        public String toString() {
            return "(no destination dir specified)";
        }
    };
    
    /** do not throw BuildException on fail/abort message with usage */
    private static final String USAGE_SUBSTRING = "AspectJ-specific options";
    /** valid -X[...] options other than -Xlint variants */
    private static final List VALID_XOPTIONS;
======= fetch "public String toString() {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    private static final List VALID_WARNINGS;
    
======= fetch "public String toString() {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    private static final List VALID_DEBUG;
======= fetch "public String toString() {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "public String toString() {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "public String toString() {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    private static final List VALID_XLINT;
    public static final String COMMAND_EDITOR_NAME
        = AjcTask.class.getName() + ".COMMAND_EDITOR";
    static final String[] TARGET_INPUTS = new String [] 
    { "1.1", "1.2", "1.3", "1.4", "1.5", "1.6" };
    static final String[] SOURCE_INPUTS = new String [] 
    { "1.3", "1.4", "1.5", "1.6" };
    static final String[] COMPLIANCE_INPUTS = new String [] 
    { "-1.3", "-1.4", "-1.5", "-1.6" };
    private static final ICommandEditor COMMAND_EDITOR;
            
    static {
        // many now deprecated: reweavable*
        String[] xs = new String[] 
            {   "serializableAspects", "incrementalFile", "lazyTjp",
        		"reweavable", "reweavable:compress", "notReweavable", "noInline",
            	"terminateAfterCompilation","hasMember",
                "ajruntimetarget:1.2", "ajruntimetarget:1.5", 
                "addSerialVersionUID"
                
                //, "targetNearSource", "OcodeSize",
                 };
        VALID_XOPTIONS = Collections.unmodifiableList(Arrays.asList(xs));
        xs = new String[]
        	{   "constructorName", "packageDefaultMethod", "deprecation",
        		"maskedCatchBlocks", "unusedLocals", "unusedArguments",
        		"unusedImports", "syntheticAccess", "assertIdentifier",
        		"allDeprecation","allJavadoc","charConcat","conditionAssign",
        		
        		"emptyBlock",
        		"fieldHiding",
        		"finally",
        		"indirectStatic",
        		"intfNonInherited",
        		"javadoc",
        		"localHiding",
        		"nls",
        		"noEffectAssign",
        		"pkgDefaultMethod",
        		"semicolon",
        		"unqualifiedField",
        		"unusedPrivate",
        		"unusedThrown",
        		"uselessTypeCheck",
        		"specialParamHiding",
        		"staticReceiver",
        		"syntheticAccess",
        		"none" };
        VALID_WARNINGS = Collections.unmodifiableList(Arrays.asList(xs));
        xs = new String[] {"none", "lines", "vars", "source" };
        VALID_DEBUG = Collections.unmodifiableList(Arrays.asList(xs));
        
        
        xs = new String[] { "error", "warning", "ignore"};
        VALID_XLINT = Collections.unmodifiableList(Arrays.asList(xs));
    
        ICommandEditor editor = null;
        try {
            String editorClassName = System.getProperty(COMMAND_EDITOR_NAME);
            if (null != editorClassName) {
                ClassLoader cl = AjcTask.class.getClassLoader();
                Class editorClass = cl.loadClass(editorClassName);
                editor = (ICommandEditor) editorClass.newInstance();
            }
        } catch (Throwable t) {
            System.err.println("Warning: unable to load command editor");
            t.printStackTrace(System.err);
        }
        COMMAND_EDITOR = editor;
    }
======= fetch "public String toString() {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    private boolean verbose;
    private boolean listFileArgs;
    private boolean failonerror;
    private boolean fork;
    private String maxMem;
    private TaskLogger logger;
======= fetch "public String toString() {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    protected GuardedCommand cmd;
======= fetch "public String toString() {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    private Path srcdir;
    private Path injars;
    private Path inpath;
    private Path classpath;
    private Path bootclasspath;
    private Path forkclasspath;
    private Path extdirs;
    private Path aspectpath;
    private Path argfiles;
    private List ignored;
    private Path sourceRoots;
    private File xweaveDir;
    private String xdoneSignal;
    
    // ----- added by adapter - integrate better?
    private List /* File */ adapterFiles;
    private String[] adapterArguments;
    private IMessageHolder messageHolder;
    private ICommandEditor commandEditor;
    // -------- resource-copying
    /** true if copying injar non-.class files to the output jar */
    private boolean copyInjars;
    private boolean copyInpath;
    
    /** non-null if copying all source root files but the filtered ones */
    private String sourceRootCopyFilter;
    /** non-null if copying all inpath dir files but the filtered ones */
    private String inpathDirCopyFilter;
    /** directory sink for classes */
    private File destDir;
    
    /** zip file sink for classes */
    private File outjar;
    
    /** track whether we've supplied any temp outjar */
    private boolean outjarFixedup;
    /** 
     * When possibly copying resources to the output jar,
     * pass ajc a fake output jar to copy from,
     * so we don't change the modification time of the output jar
     * when copying injars/inpath into the actual outjar.
     */
    private File tmpOutjar;
    private boolean executing;
    /** non-null only while executing in same vm */
    private Main main;
    
    /** true only when executing in other vm */
    private boolean executingInOtherVM;
    /** true if -incremental  */
    private boolean inIncrementalMode;
    /** true if -XincrementalFile (i.e, setTagFile)*/
    private boolean inIncrementalFileMode; 
    /** log command in non-verbose mode */
    private boolean logCommand; 
    /** used when forking */
    private CommandlineJava javaCmd = new CommandlineJava();
    // also note MatchingTask grabs source files...
    
    public AjcTask() {
    	reset();
    }
======= fetch "public AjcTask() {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    public void reset() { // XXX possible to reset MatchingTask?
        // need declare for "all fields initialized in ..."
        adapterArguments = null;
        adapterFiles = new ArrayList();
        argfiles = null;
        executing = false;
        aspectpath = null;
        bootclasspath = null;
        classpath = null;
        cmd = new GuardedCommand();
        copyInjars = false;
        copyInpath = false;
        destDir = DEFAULT_DESTDIR;
        executing = false;
        executingInOtherVM = false;
        extdirs = null;
        failonerror = true;  // non-standard default
        forkclasspath = null;
        inIncrementalMode = false;
        inIncrementalFileMode = false;
        ignored = new ArrayList();
        injars = null;
        inpath = null;
        listFileArgs = false;
        maxMem = null;
        messageHolder = null;
        outjar = null;
        sourceRootCopyFilter = null;
        inpathDirCopyFilter = null;
        sourceRoots = null;
        srcdir = null;
        tmpOutjar = null;
        verbose = false;
        xweaveDir = null;
        xdoneSignal = null;
        logCommand = false;
        javaCmd = new CommandlineJava();
    }
    protected void ignore(String ignored) {
        this.ignored.add(ignored + " at " + getLocation());
    }
    
    //---------------------- option values
    // used by entries with internal commas
    protected String validCommaList(String list, List valid, String label) {
    	return validCommaList(list, valid, label, valid.size());
    }
    
    protected String validCommaList(String list, List valid, String label, int max) {
    	StringBuffer result = new StringBuffer();
    	StringTokenizer st = new StringTokenizer(list, ",");
======= fetch "protected String validCommaList(String list, List valid, String label, int max)" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    	while (st.hasMoreTokens()) {
======= fetch "protected String validCommaList(String list, List valid, String label, int max)" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "protected String validCommaList(String list, List valid, String label, int max)" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "protected String validCommaList(String list, List valid, String label, int max)" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    	}
    	return (0 == result.length() ? null : result.toString());
    }
    
    public void setIncremental(boolean incremental) {  
        cmd.addFlag("-incremental", incremental);
        inIncrementalMode = incremental;
    }
    public void setLogCommand(boolean logCommand) {
        this.logCommand = logCommand;
    }
    
    public void setHelp(boolean help) {  
        cmd.addFlag("-help", help);
    }
    public void setVersion(boolean version) {  
    	cmd.addFlag("-version", version);
    }
    public void setXTerminateAfterCompilation(boolean b) {  
        cmd.addFlag("-XterminateAfterCompilation", b);
    }
    public void setXReweavable(boolean reweavable) {
    	cmd.addFlag("-Xreweavable",reweavable);
    }
    
    public void setXJoinpoints(String optionalJoinpoints) {
      	cmd.addFlag("-Xjoinpoints:"+optionalJoinpoints,true);
    }
    public void setCheckRuntimeVersion(boolean b) {
      	cmd.addFlag("-checkRuntimeVersion:"+b,true);
    }
    
    public void setXNoWeave(boolean b) {
    	if (logger!=null) logger.warning("the noweave option is no longer required and is being ignored");
    }
    
    public void setNoWeave(boolean b) {
    	if (logger!=null) logger.warning("the noweave option is no longer required and is being ignored");
    }
    
    public void setXNotReweavable(boolean notReweavable) {
    	cmd.addFlag("-XnotReweavable",notReweavable);
    }
    public void setXaddSerialVersionUID(boolean addUID) {
    	cmd.addFlag("-XaddSerialVersionUID",addUID);
    }
    
    public void setXNoInline(boolean noInline) {
    	cmd.addFlag("-XnoInline",noInline);
    }
    public void setShowWeaveInfo(boolean showweaveinfo) {
    	cmd.addFlag("-showWeaveInfo",showweaveinfo);
    }
    public void setNowarn(boolean nowarn) {  
        cmd.addFlag("-nowarn", nowarn);
    }
    public void setDeprecation(boolean deprecation) {  
        cmd.addFlag("-deprecation", deprecation);
    }
    public void setWarn(String warnings) {
    	warnings = validCommaList(warnings, VALID_WARNINGS, "warn");
        cmd.addFlag("-warn:" + warnings, (null != warnings));
    }
    public void setDebug(boolean debug) {
        cmd.addFlag("-g", debug);
    }
    
    public void setDebugLevel(String level) {
    	level = validCommaList(level, VALID_DEBUG, "g");
        cmd.addFlag("-g:" + level, (null != level));
    }
    public void setEmacssym(boolean emacssym) {
        cmd.addFlag("-emacssym", emacssym);
    }
    public void setCrossrefs(boolean on) {
        cmd.addFlag("-crossrefs", on);
    }
    
======= fetch "public void setXlintwarnings(boolean xlintwarnings) {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

        cmd.addFlag("-Xlint", xlintwarnings);
======= fetch "public void setXlintwarnings(boolean xlintwarnings) {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "public void setXlintwarnings(boolean xlintwarnings) {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    public void setXlint(String xlint) {
    	xlint = validCommaList(xlint, VALID_XLINT, "Xlint", 1);
        cmd.addFlag("-Xlint:" + xlint, (null != xlint));
    }
======= fetch "public void setXlint(String xlint) {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    public void setXlintfile(File xlintFile) { 
        cmd.addFlagged("-Xlintfile", xlintFile.getAbsolutePath());
    }
    public void setPreserveAllLocals(boolean preserveAllLocals) {  
        cmd.addFlag("-preserveAllLocals", preserveAllLocals);
    }
    public void setNoImportError(boolean noImportError) {  
        cmd.addFlag("-warn:-unusedImport", noImportError);
    }
    public void setEncoding(String encoding) {   
        cmd.addFlagged("-encoding", encoding);
    }
    public void setLog(File file) {
        cmd.addFlagged("-log", file.getAbsolutePath());
    }
    
    public void setProceedOnError(boolean proceedOnError) {  
        cmd.addFlag("-proceedOnError", proceedOnError);
    }
    public void setVerbose(boolean verbose) {  
        cmd.addFlag("-verbose", verbose);
        this.verbose = verbose;
    }
    
    public void setListFileArgs(boolean listFileArgs) { 
        this.listFileArgs = listFileArgs;
    }
    public void setReferenceInfo(boolean referenceInfo) {  
        cmd.addFlag("-referenceInfo", referenceInfo);
    }
    public void setTime(boolean time) {  
        cmd.addFlag("-time", time);
    }
    public void setNoExit(boolean noExit) {  
        cmd.addFlag("-noExit", noExit);
    }
    public void setFailonerror(boolean failonerror) {  
        this.failonerror = failonerror;
    }
    /**
     * @return true if fork was set
     */
    public boolean isForked() {
        return fork;
    }
    
    public void setFork(boolean fork) {  
        this.fork = fork;
    }
    
    public void setMaxmem(String maxMem) {
        this.maxMem = maxMem;
    }
    
    /** support for nested &lt;jvmarg&gt; elements */
    public Commandline.Argument createJvmarg() {
    	return this.javaCmd.createVmArgument();
    }
======= fetch "public void setMaxmem(String maxMem) {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    public void setTagFile(File file) {
        inIncrementalMode = true;
        cmd.addFlagged(Main.CommandController.TAG_FILE_OPTION,
        inIncrementalFileMode = true;
    }
    
    public void setOutjar(File file) {
        if (DEFAULT_DESTDIR != destDir) {
            String e = "specifying both output jar ("
                + file 
                + ") and destination dir ("
                + destDir
                + ")";
            throw new BuildException(e);
        }
        outjar = file;
        outjarFixedup = false;
        tmpOutjar = null;
    }
    public void setOutxml(boolean outxml) {
    	cmd.addFlag("-outxml",outxml);
    }
    public void setOutxmlfile(String name) {
        cmd.addFlagged("-outxmlfile", name);
    }
    public void setDestdir(File dir) {
        if (null != outjar) {
            String e = "specifying both output jar ("
                + outjar 
                + ") and destination dir ("
                + dir
                + ")";
            throw new BuildException(e);
        }
        cmd.addFlagged("-d", dir.getAbsolutePath());
        destDir = dir;        
    }
    
    /**
     * @param input a String in TARGET_INPUTS
     */
    public void setTarget(String input) {
        String ignore = cmd.addOption("-target", TARGET_INPUTS, input);
        if (null != ignore) {
            ignore(ignore);
        }
    }
    
    /** 
     * Language compliance level.
     * If not set explicitly, eclipse default holds.
     * @param input a String in COMPLIANCE_INPUTS
     */
    public void setCompliance(String input) {
        String ignore = cmd.addOption(null, COMPLIANCE_INPUTS, input);
        if (null != ignore) {
            ignore(ignore);
        }
    }
    
    /** 
     * Source compliance level.
     * If not set explicitly, eclipse default holds.
     * @param input a String in SOURCE_INPUTS
     */
    public void setSource(String input) {
        String ignore = cmd.addOption("-source", SOURCE_INPUTS, input);
        if (null != ignore) {
            ignore(ignore);
        }
    }
    /**
     * Flag to copy all non-.class contents of injars
     * to outjar after compile completes.
     * Requires both injars and outjar.
     * @param doCopy
     */
    public void setCopyInjars(boolean doCopy){
        ignore("copyInJars");
        log("copyInjars not required since 1.1.1.\n", Project.MSG_WARN);
        //this.copyInjars = doCopy;
    }
    
    /**
     * Option to copy all files from
     * all source root directories
     * except those specified here.
     * If this is specified and sourceroots are specified,
     * then this will copy all files except 
     * those specified in the filter pattern.
     * Requires sourceroots.
     * 
     * @param filter a String acceptable as an excludes
     *        filter for an Ant Zip fileset.
     */
    public void setSourceRootCopyFilter(String filter){
        this.sourceRootCopyFilter = filter;
    }
    /**
     * Option to copy all files from
     * all inpath directories
     * except the files specified here.
     * If this is specified and inpath directories are specified,
     * then this will copy all files except 
     * those specified in the filter pattern.
     * Requires inpath.
     * If the input does not contain "**\/*.class", then
     * this prepends it, to avoid overwriting woven classes
     * with unwoven input.
     * @param filter a String acceptable as an excludes
     *        filter for an Ant Zip fileset.
     */
    public void setInpathDirCopyFilter(String filter){
        if (null != filter) {
            if (-1 == filter.indexOf("**/*.class")) {
                filter = "**/*.class," + filter;
            }
        }
        this.inpathDirCopyFilter = filter;
    }
    public void setX(String input) {  // ajc-only eajc-also docDone
        StringTokenizer tokens = new StringTokenizer(input, ",", false);
        while (tokens.hasMoreTokens()) {
            String token = tokens.nextToken().trim();
            if (1 < token.length()) {
            	// new special case: allow -Xset:anything
                if (VALID_XOPTIONS.contains(token) || token.indexOf("set:")==0 ||
                		token.indexOf("joinpoints:")==0) {
                    cmd.addFlag("-X" + token, true); 
                } else {
                    ignore("-X" + token);
                }
            }
        }
    }
    public void setXDoneSignal(String doneSignal) {
        this.xdoneSignal = doneSignal;
    }
    /** direct API for testing */
    public void setMessageHolder(IMessageHolder holder) {
        this.messageHolder = holder;
    }
    
    /** 
     * Setup custom message handling.
     * @param className the String fully-qualified-name of a class
     *          reachable from this object's class loader,
     *          implementing IMessageHolder, and 
     *          having a public no-argument constructor.
     * @throws BuildException if unable to create instance of className
     */
    public void setMessageHolderClass(String className) {
        try {
            Class mclass = Class.forName(className);
            IMessageHolder holder = (IMessageHolder) mclass.newInstance();
            setMessageHolder(holder);
        } catch (Throwable t) {
            String m = "unable to instantiate message holder: " + className;
            throw new BuildException(m, t);
        }
    }
    
    /** direct API for testing */
    public void setCommandEditor(ICommandEditor editor) {
        this.commandEditor = editor;
    }
    
    /**
     * Setup command-line filter.
     * To do this staticly, define the environment variable
     * <code>org.aspectj.tools.ant.taskdefs.AjcTask.COMMAND_EDITOR</code>
     * with the <code>className</code> parameter.
     * @param className the String fully-qualified-name of a class
     *          reachable from this object's class loader,
     *          implementing ICommandEditor, and 
     *          having a public no-argument constructor.
     * @throws BuildException if unable to create instance of className
     */
    public void setCommandEditorClass(String className) { // skip Ant interface?
        try {
            Class mclass = Class.forName(className);
            setCommandEditor((ICommandEditor) mclass.newInstance());
        } catch (Throwable t) {
            String m = "unable to instantiate command editor: " + className;
            throw new BuildException(m, t);
        }
    }
    //---------------------- Path lists
    /**
     * Add path elements to source path and return result.
     * Elements are added even if they do not exist.
     * @param source the Path to add to - may be null
     * @param toAdd the Path to add - may be null
     * @return the (never-null) Path that results
     */
    protected Path incPath(Path source, Path toAdd) {
        if (null == source) {
            source = new Path(project); 
        }
        if (null != toAdd) {
            source.append(toAdd);
        }
        return source;
    }
    public void setSourcerootsref(Reference ref) {
        createSourceRoots().setRefid(ref);
    }
    
    public void setSourceRoots(Path roots) {
        sourceRoots = incPath(sourceRoots, roots);
    }
    public Path createSourceRoots() {
        if (sourceRoots == null) {
            sourceRoots = new Path(project);
        }
        return sourceRoots.createPath();
    }        
    public void setXWeaveDir(File file) {
        if ((null != file) && file.isDirectory()
            && file.canRead()) {
            xweaveDir = file;
        }
    }       
    public void setInjarsref(Reference ref) {
        createInjars().setRefid(ref);
    }
    
    public void setInpathref(Reference ref) {
    	createInpath().setRefid(ref);
    }
    
    public void setInjars(Path path) {
        injars = incPath(injars, path);
    }
    
    public void setInpath(Path path) {
    	inpath = incPath(inpath,path);
    }
    public Path createInjars() {
        if (injars == null) {
            injars = new Path(project);
        }
        return injars.createPath();
    }        
    
    public Path createInpath() {
    	if (inpath == null) {
    		inpath = new Path(project);
    	}
    	return inpath.createPath();
    }
    
    public void setClasspath(Path path) {
        classpath = incPath(classpath, path);
    }
    public void setClasspathref(Reference classpathref) {
        createClasspath().setRefid(classpathref);
    }
        
    public Path createClasspath() {
        if (classpath == null) {
            classpath = new Path(project);
        }
        return classpath.createPath();
    }        
    public void setBootclasspath(Path path) {
        bootclasspath = incPath(bootclasspath, path);  
    }
    
    public void setBootclasspathref(Reference bootclasspathref) {
        createBootclasspath().setRefid(bootclasspathref);
    }
    
    public Path createBootclasspath() {
        if (bootclasspath == null) {
            bootclasspath = new Path(project);
        }
        return bootclasspath.createPath();
    }        
    
    public void setForkclasspath(Path path) {
        forkclasspath = incPath(forkclasspath, path);  
    }
    
    public void setForkclasspathref(Reference forkclasspathref) {
        createForkclasspath().setRefid(forkclasspathref);
    }
    
    public Path createForkclasspath() {
        if (forkclasspath == null) {
            forkclasspath = new Path(project);
        }
        return forkclasspath.createPath();
    }        
    
    public void setExtdirs(Path path) {
        extdirs = incPath(extdirs, path);
    }
    public void setExtdirsref(Reference ref) {
        createExtdirs().setRefid(ref);
    }
        
    public Path createExtdirs() {
        if (extdirs == null) {
            extdirs = new Path(project);
        }
        return extdirs.createPath();
    }        
   
    public void setAspectpathref(Reference ref) {
        createAspectpath().setRefid(ref);
    }
    public void setAspectpath(Path path) {
        aspectpath = incPath(aspectpath, path);
    }
    public Path createAspectpath() {
        if (aspectpath == null) {
            aspectpath = new Path(project);
        }
        return aspectpath.createPath();
    }        
    public void setSrcDir(Path path) {
        srcdir = incPath(srcdir, path);
    }
    public Path createSrc() {
        return createSrcdir();
    }
    public Path createSrcdir() {
        if (srcdir == null) {
            srcdir = new Path(project);
        }
        return srcdir.createPath();
    }
    
    /** @return true if in incremental mode (command-line or file) */
    public boolean isInIncrementalMode() {
        return inIncrementalMode;
    }
    /** @return true if in incremental file mode */
    public boolean isInIncrementalFileMode() {
        return inIncrementalFileMode;
    }
    public void setArgfilesref(Reference ref) {
        createArgfiles().setRefid(ref);
    }
    
    public void setArgfiles(Path path) { // ajc-only eajc-also docDone
        argfiles = incPath(argfiles, path);
    }
    public Path createArgfiles() {
        if (argfiles == null) {
            argfiles = new Path(project);
        }
        return argfiles.createPath();
    }
                
    // ------------------------------ run
  
    /**
     * Compile using ajc per settings.
     * @exception BuildException if the compilation has problems
     *             or if there were compiler errors and failonerror is true.
     */
    public void execute() throws BuildException {
    	this.logger = new TaskLogger(this);
        if (executing) {
            throw new IllegalStateException("already executing");
        } else {
            executing = true;
        }
        setupOptions();
        verifyOptions();
        try {
            String[] args = makeCommand();
            if (logCommand) {
                log("ajc " + Arrays.asList(args));                
            } else {
                logVerbose("ajc " + Arrays.asList(args));
            }
            if (!fork) {
                executeInSameVM(args);
            } else { // when forking, Adapter handles failonerror
                executeInOtherVM(args);
            }
        } catch (BuildException e) {
            throw e;
        } catch (Throwable x) {
        	this.logger.error(Main.renderExceptionForUser(x));
            throw new BuildException("IGNORE -- See " 
            	+ LangUtil.unqualifiedClassName(x) 
            	+ " rendered to ant logger");
        } finally {
            executing = false;
            if (null != tmpOutjar) {
                tmpOutjar.delete();
            }
        }        
    }
    /** 
     * Halt processing.
     * This tells main in the same vm to quit.
     * It fails when running in forked mode.
     * @return true if not in forked mode
     *         and main has quit or been told to quit
     */
    public boolean quit() {
        if (executingInOtherVM) {
            return false;
        }
        Main me = main;
        if (null != me) {
            me.quit();
        }
        return true;
    }
    // package-private for testing
    String[] makeCommand() {
        ArrayList result = new ArrayList();
        if (0 < ignored.size()) {
            for (Iterator iter = ignored.iterator(); iter.hasNext();) {
            	logVerbose("ignored: " + iter.next());
            }
        }
        // when copying resources, use temp jar for class output
        // then copy temp jar contents and resources to output jar
        if ((null != outjar) && !outjarFixedup) {
            if (copyInjars || copyInpath || (null != sourceRootCopyFilter)
                    || (null != inpathDirCopyFilter)) {
                String path = outjar.getAbsolutePath();
                int len = FileUtil.zipSuffixLength(path);
                path = path.substring(0, path.length()-len) + ".tmp.jar";
                tmpOutjar = new File(path);
            }
            if (null == tmpOutjar) {                
                cmd.addFlagged("-outjar", outjar.getAbsolutePath());        
            } else {
                cmd.addFlagged("-outjar", tmpOutjar.getAbsolutePath());        
            }
            outjarFixedup = true;
        }
        result.addAll(cmd.extractArguments());        
        addListArgs(result);
        String[] command = (String[]) result.toArray(new String[0]);
        if (null != commandEditor) {
            command = commandEditor.editCommand(command);
        } else if (null != COMMAND_EDITOR) {
            command = COMMAND_EDITOR.editCommand(command);
        }
        return command;
    }   
    /**
     * Create any pseudo-options required to implement
     * some of the macro options
     * @throws BuildException if options conflict
     */
    protected void setupOptions() {
        if (null != xweaveDir) {
           if (DEFAULT_DESTDIR != destDir) {
               throw new BuildException("weaveDir forces destdir"); 
           }
           if (null != outjar) {
               throw new BuildException("weaveDir forces outjar"); 
           }
           if (null != injars) {
               throw new BuildException("weaveDir incompatible with injars now"); 
           }
           if (null != inpath) {
               throw new BuildException("weaveDir incompatible with inpath now"); 
           }
           
           File injar = zipDirectory(xweaveDir);
           setInjars(new Path(getProject(), injar.getAbsolutePath()));
           setDestdir(xweaveDir);
        }
    }
    
    protected File zipDirectory(File dir) {
        File tempDir = new File(".");
        try {
            tempDir = File.createTempFile("AjcTest", ".tmp");
            tempDir.mkdirs();
            tempDir.deleteOnExit(); // XXX remove zip explicitly..
        } catch (IOException e) {
            // ignore
        }
        String filename = "AjcTask-" 
            + System.currentTimeMillis() 
            + ".zip";
        File result = new File(filename);
        Zip zip = new Zip();
        zip.setProject(getProject());
        zip.setDestFile(result);
        zip.setTaskName(getTaskName() + " - zip");
        FileSet fileset = new FileSet();
        fileset.setDir(dir);
        zip.addFileset(fileset);
        zip.execute();
        Delete delete = new Delete();
        delete.setProject(getProject());
        delete.setTaskName(getTaskName() + " - delete");
        delete.setDir(dir);
        delete.execute();
        Mkdir mkdir = new Mkdir();
        mkdir.setProject(getProject());
        mkdir.setTaskName(getTaskName() + " - mkdir");
        mkdir.setDir(dir);
        mkdir.execute();
        return result;
    }
    
    /**
     * @throw BuildException if options conflict
     */
    protected void verifyOptions() {
        StringBuffer sb = new StringBuffer();
        if (fork && isInIncrementalMode() && !isInIncrementalFileMode()) {
            sb.append("can fork incremental only using tag file.\n");
        }
        if (((null != inpathDirCopyFilter) || (null != sourceRootCopyFilter)) 
                && (null == outjar) && (DEFAULT_DESTDIR == destDir)) {        	
            final String REQ = " requires dest dir or output jar.\n";
            if (null == inpathDirCopyFilter) {
                sb.append("sourceRootCopyFilter");
            } else if (null == sourceRootCopyFilter) {
                sb.append("inpathDirCopyFilter");
            } else {
                sb.append("sourceRootCopyFilter and inpathDirCopyFilter");
            }
            sb.append(REQ);
        }
        if (0 < sb.length()) {
            throw new BuildException(sb.toString());
        }
    }
    /**
     * Run the compile in the same VM by
     * loading the compiler (Main), 
     * setting up any message holders,
     * doing the compile,
     * and converting abort/failure and error messages
     * to BuildException, as appropriate.
     * @throws BuildException if abort or failure messages
     *         or if errors and failonerror.
     * 
     */
    protected void executeInSameVM(String[] args) {
        if (null != maxMem) {
            log("maxMem ignored unless forked: " + maxMem, Project.MSG_WARN);
        }
        IMessageHolder holder = messageHolder;
        int numPreviousErrors;
        if (null == holder) {
            MessageHandler mhandler = new MessageHandler(true);
======= fetch "protected void executeInSameVM(String[] args) {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

              delegate  = new AntMessageHandler(this.logger,this.verbose, false);
            mhandler.setInterceptor(delegate);
            holder = mhandler;
            numPreviousErrors = 0;
        } else {
            numPreviousErrors = holder.numMessages(IMessage.ERROR, true);
        }
        {
            Main newmain = new Main();
            newmain.setHolder(holder);
            newmain.setCompletionRunner(new Runnable() {
                public void run() {
                    doCompletionTasks();
                }
            });
            if (null != main) {
                MessageUtil.fail(holder, "still running prior main");
                return;
            }
            main = newmain;          
        }
        main.runMain(args, false);
        if (failonerror) {
            int errs = holder.numMessages(IMessage.ERROR, false);
            errs -= numPreviousErrors;
            if (0 < errs) {
                String m =  errs + " errors";
                MessageUtil.print(System.err, holder, "", MessageUtil.MESSAGE_ALL, MessageUtil.PICK_ERROR, true);
                throw new BuildException(m); 
            }
        } 
        // Throw BuildException if there are any fail or abort
        // messages.
        // The BuildException message text has a list of class names
        // for the exceptions found in the messages, or the
        // number of fail/abort messages found if there were
        // no exceptions for any of the fail/abort messages.
        // The interceptor message handler should have already
        // printed the messages, including any stack traces.
        // HACK: this ignores the Usage message
        {
            IMessage[] fails = holder.getMessages(IMessage.FAIL, true);
            if (!LangUtil.isEmpty(fails)) {
                StringBuffer sb = new StringBuffer();
                String prefix = "fail due to ";
                int numThrown = 0;
                for (int i = 0; i < fails.length; i++) {
                    String message = fails[i].getMessage();
                    if (LangUtil.isEmpty(message)) {
                        message = "<no message>";
                    } else if (-1 != message.indexOf(USAGE_SUBSTRING)) {
                        continue;
                    }
                    Throwable t = fails[i].getThrown();
                    if (null != t) {
                        numThrown++;
                        sb.append(prefix);
                        sb.append(LangUtil.unqualifiedClassName(t.getClass()));
                        String thrownMessage = t.getMessage();
                        if (!LangUtil.isEmpty(thrownMessage)) {
                            sb.append(" \"" + thrownMessage + "\"");
                        }
                    } 
                    sb.append("\"" + message + "\"");
                    prefix = ", ";
                }
                if (0 < sb.length()) {
                    sb.append(" (" + numThrown + " exceptions)");
                    throw new BuildException(sb.toString());
                }
            }
        }
    }
    
    /**
     * Execute in a separate VM.
     * Differences from normal same-VM execution:
     * <ul>
     * <li>ignores any message holder {class} set</li>
     * <li>No resource-copying between interative runs</li>
     * <li>failonerror fails when process interface fails 
     *     to return negative values</li>
     * </ul>
     * @param args String[] of the complete compiler command to execute
     * 
     * @see DefaultCompilerAdapter#executeExternalCompile(String[], int)
     * @throws BuildException if ajc aborts (negative value)
     *         or if failonerror and there were compile errors.
     */
    protected void executeInOtherVM(String[] args) {
        javaCmd.setClassname(org.aspectj.tools.ajc.Main.class.getName());
        
        final Path vmClasspath = javaCmd.createClasspath(getProject());
        {
            File aspectjtools = null;
            int vmClasspathSize = vmClasspath.size();
            if ((null != forkclasspath) 
                && (0 != forkclasspath.size())) {
                vmClasspath.addExisting(forkclasspath);
            } else {                
                aspectjtools = findAspectjtoolsJar();
                if (null != aspectjtools) {
                    vmClasspath.createPathElement().setLocation(aspectjtools);
                }
            }
            int newVmClasspathSize = vmClasspath.size();
            if (vmClasspathSize == newVmClasspathSize) {
                String m = "unable to find aspectjtools to fork - ";
                if (null != aspectjtools) {
                    m += "tried " + aspectjtools.toString();
                } else if (null != forkclasspath) {
                    m += "tried " + forkclasspath.toString();
                } else {
                    m += "define forkclasspath or put aspectjtools on classpath";
                }
                throw new BuildException(m);
            }
        }
        if (null != maxMem) {
            javaCmd.setMaxmemory(maxMem);
        }
        File tempFile = null;
        int numArgs = args.length;
        args = GuardedCommand.limitTo(args, MAX_COMMANDLINE, getLocation());
        if (args.length != numArgs) {
            tempFile = new File(args[1]);
        }
        try {
        	boolean setMessageHolderOnForking = (this.messageHolder != null); 
            String[] javaArgs = javaCmd.getCommandline();
            String[] both = new String[javaArgs.length + args.length + (setMessageHolderOnForking ? 2 : 0)];
            System.arraycopy(javaArgs,0,both,0,javaArgs.length);
            System.arraycopy(args,0,both,javaArgs.length,args.length);
            if (setMessageHolderOnForking) {
            	both[both.length - 2] = "-messageHolder";
            	both[both.length - 1] = this.messageHolder.getClass().getName();
            }
            // try to use javaw instead on windows
            if (both[0].endsWith("java.exe")) {
                String path = both[0];
                path = path.substring(0, path.length()-4);
                path = path + "w.exe";
                File javaw = new File(path);
                if (javaw.canRead() && javaw.isFile()) {
                    both[0] = path;
                }
            }
            logVerbose("forking " + Arrays.asList(both));
            int result = execInOtherVM(both);
            if (0 > result) {
                throw new BuildException("failure[" + result + "] running ajc");
            } else if (failonerror && (0 < result)) {
                throw new BuildException("compile errors: " + result);                
            }
            // when forking, do completion only at end and when successful
            doCompletionTasks();
        } finally {
            if (null != tempFile) {
                tempFile.delete();
            }
        }
    }
    
    /**
     * Execute in another process using the same JDK
     * and the base directory of the project. XXX correct?
     * @param args
     * @return
     */
    protected int execInOtherVM(String[] args) {
        try {			
            Project project = getProject();
======= fetch "protected int execInOtherVM(String[] args) {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

            exe.setAntRun(project);
            exe.setWorkingDirectory(project.getBaseDir());
            exe.setCommandline(args);
            try {
                if (executingInOtherVM) {
                    String s = "already running in other vm?";
                    throw new BuildException(s, location);
                }
                executingInOtherVM = true;
                exe.execute();
            } finally {
                executingInOtherVM = false;
            }
            return exe.getExitValue();
        } catch (IOException e) {
            String m = "Error executing command " + Arrays.asList(args);
            throw new BuildException(m, e, location);
        }
    }
    // ------------------------------ setup and reporting
    /** @return null if path null or empty, String rendition otherwise */
    protected static void addFlaggedPath(String flag, Path path, List list) {
        if (!LangUtil.isEmpty(flag) 
            && ((null != path) && (0 < path.size()))) {
            list.add(flag);
            list.add(path.toString());
        }
    }
    
    /** 
     * Add to list any path or plural arguments.
     */
        addFlaggedPath("-classpath", classpath, list);       
        addFlaggedPath("-bootclasspath", bootclasspath, list);
        addFlaggedPath("-extdirs", extdirs, list);
        addFlaggedPath("-aspectpath", aspectpath, list);
        addFlaggedPath("-injars", injars, list);
        addFlaggedPath("-inpath", inpath, list);
        addFlaggedPath("-sourceroots", sourceRoots, list);
        
        if (argfiles != null) {
            String[] files = argfiles.list();
            for (int i = 0; i < files.length; i++) {
                File argfile = project.resolveFile(files[i]);
                if (check(argfile, files[i], false, location)) {
                    list.add("-argfile");
                    list.add(argfile.getAbsolutePath());
                }
            }
        }
        if (srcdir != null) {
            // todo: ignore any srcdir if any argfiles and no explicit includes
            String[] dirs = srcdir.list();
            for (int i = 0; i < dirs.length; i++) {
                File dir = project.resolveFile(dirs[i]);
                check(dir, dirs[i], true, location);
                // relies on compiler to prune non-source files
                String[] files = getDirectoryScanner(dir).getIncludedFiles();
                for (int j = 0; j < files.length; j++) {
                    File file = new File(dir, files[j]);
                    if (FileUtil.hasSourceSuffix(file)) {
                        list.add(file.getAbsolutePath());
                    }
                }
            }
        }
        if (0 < adapterFiles.size()) {
            for (Iterator iter = adapterFiles.iterator(); iter.hasNext();) {
                File file = (File) iter.next();
                if (file.canRead() && FileUtil.hasSourceSuffix(file)) {
                    list.add(file.getAbsolutePath());
                } else {
                    this.logger.warning("skipping file: " + file);
                }
            }
        }
    /** 
     * Throw BuildException unless file is valid.
     * @param file the File to check
     * @param name the symbolic name to print on error
     * @param isDir if true, verify file is a directory
     * @param loc the Location used to create sensible BuildException
     * @return
     * @throws BuildException unless file valid
     */
    protected final boolean check(File file, String name,
                                  boolean isDir, Location loc) {
        loc = loc != null ? loc : location;
        if (file == null) {
            throw new BuildException(name + " is null!", loc);
        }
        if (!file.exists()) {
            throw new BuildException(file + " doesn't exist!", loc);
        }
        if (isDir ^ file.isDirectory()) {
            String e = file + " should" + (isDir ? "" : "n't")  +
                " be a directory!";
            throw new BuildException(e, loc);
        }
        return true;
    }
    
    /** 
     * Called when compile or incremental compile is completing,
     * this completes the output jar or directory
     * by copying resources if requested.
     * Note: this is a callback run synchronously by the compiler.
     * That means exceptions thrown here are caught by Main.run(..)
     * and passed to the message handler.
     */
    protected void doCompletionTasks() {
        if (!executing) {
            throw new IllegalStateException("should be executing");
        }
        if (null != outjar) {
            completeOutjar();
        } else {
            completeDestdir();
        }
        if (null != xdoneSignal) {
            MessageUtil.info(messageHolder, xdoneSignal);
        }
    }
    
    /** 
     * Complete the destination directory
     * by copying resources from the source root directories
     * (if the filter is specified)
     * and non-.class files from the input jars 
     * (if XCopyInjars is enabled).
     */
    private void completeDestdir() {
        if (!copyInjars && (null == sourceRootCopyFilter)
                && (null == inpathDirCopyFilter)) {
            return;
        } else if ((destDir == DEFAULT_DESTDIR)
                    || !destDir.canWrite()) {
            String s = "unable to copy resources to destDir: " + destDir;
            throw new BuildException(s);
        }
        final Project project = getProject();
        if (copyInjars) { // XXXX remove as unused since 1.1.1
            if (null != inpath) {
                log("copyInjars does not support inpath.\n", Project.MSG_WARN);
            }
            String taskName = getTaskName() + " - unzip";
            String[] paths = injars.list();            
            if (!LangUtil.isEmpty(paths)) {
                PatternSet patternSet = new PatternSet();
                patternSet.setProject(project);        
                patternSet.setIncludes("**/*");
                patternSet.setExcludes("**/*.class");  
                for (int i = 0; i < paths.length; i++) {
                    Expand unzip = new Expand();
                    unzip.setProject(project);
                    unzip.setTaskName(taskName);
                    unzip.setDest(destDir);
                    unzip.setSrc(new File(paths[i]));
                    unzip.addPatternset(patternSet);
                    unzip.execute();
                }
            }
        }
        if ((null != sourceRootCopyFilter) && (null != sourceRoots)) {
            String[] paths = sourceRoots.list();
            if (!LangUtil.isEmpty(paths)) {
                Copy copy = new Copy();
                copy.setProject(project);
                copy.setTodir(destDir);
                for (int i = 0; i < paths.length; i++) {
                    FileSet fileSet = new FileSet();
                    fileSet.setDir(new File(paths[i]));
                    fileSet.setIncludes("**/*");
                    fileSet.setExcludes(sourceRootCopyFilter);  
                    copy.addFileset(fileSet);
                }
                copy.execute();
            }
        }        
        if ((null != inpathDirCopyFilter) && (null != inpath)) {
            String[] paths = inpath.list();
            if (!LangUtil.isEmpty(paths)) {
                Copy copy = new Copy();
                copy.setProject(project);
                copy.setTodir(destDir);
                boolean gotDir = false;
                for (int i = 0; i < paths.length; i++) {
                    File inpathDir = new File(paths[i]);
                    if (inpathDir.isDirectory() && inpathDir.canRead()) {
                        if (!gotDir) {
                            gotDir = true;
                        }
                        FileSet fileSet = new FileSet();
                        fileSet.setDir(inpathDir);
                        fileSet.setIncludes("**/*");
                        fileSet.setExcludes(inpathDirCopyFilter);  
                        copy.addFileset(fileSet);
                    }
                }
                if (gotDir) {
                    copy.execute();
                }
            }
        }        
    }
    
    /** 
     * Complete the output jar
     * by copying resources from the source root directories
     * if the filter is specified.
     * and non-.class files from the input jars if enabled.
     */
    private void completeOutjar() {
        if (((null == tmpOutjar) || !tmpOutjar.canRead()) 
            || (!copyInjars && (null == sourceRootCopyFilter)
                    && (null == inpathDirCopyFilter))) {
            return;
        }
        Zip zip = new Zip();
        Project project = getProject();
        zip.setProject(project);        
        zip.setTaskName(getTaskName() + " - zip");
        zip.setDestFile(outjar);
        ZipFileSet zipfileset = new ZipFileSet();
        zipfileset.setProject(project);        
        zipfileset.setSrc(tmpOutjar);
        zipfileset.setIncludes("**/*.class");
        zip.addZipfileset(zipfileset);
        if (copyInjars) {
            String[] paths = injars.list();
            if (!LangUtil.isEmpty(paths)) {
                for (int i = 0; i < paths.length; i++) {
                    File jarFile = new File(paths[i]);
                    zipfileset = new ZipFileSet();
                    zipfileset.setProject(project);
                    zipfileset.setSrc(jarFile);
                    zipfileset.setIncludes("**/*");
                    zipfileset.setExcludes("**/*.class");  
                    zip.addZipfileset(zipfileset);
                }
            }
        }
        if ((null != sourceRootCopyFilter) && (null != sourceRoots)) {
            String[] paths = sourceRoots.list();
            if (!LangUtil.isEmpty(paths)) {
                for (int i = 0; i < paths.length; i++) {
                    File srcRoot = new File(paths[i]);
                    FileSet fileset = new FileSet();
                    fileset.setProject(project);
                    fileset.setDir(srcRoot);
                    fileset.setIncludes("**/*");
                    fileset.setExcludes(sourceRootCopyFilter);  
                    zip.addFileset(fileset);
                }
            }
        }        
        if ((null != inpathDirCopyFilter) && (null != inpath)) {
            String[] paths = inpath.list();
            if (!LangUtil.isEmpty(paths)) {
                for (int i = 0; i < paths.length; i++) {
                    File inpathDir = new File(paths[i]);
                    if (inpathDir.isDirectory() && inpathDir.canRead()) {
                        FileSet fileset = new FileSet();
                        fileset.setProject(project);
                        fileset.setDir(inpathDir);
                        fileset.setIncludes("**/*");
                        fileset.setExcludes(inpathDirCopyFilter);  
                        zip.addFileset(fileset);
                    }
                }
            }
        }        
        zip.execute();
    }
    
    // -------------------------- compiler adapter interface extras
    /**
     * Add specified source files.
     */
    void addFiles(File[] paths) {
        for (int i = 0; i < paths.length; i++) {
            addFile(paths[i]);
        }
    }
    /**
     * Add specified source file.
     */
    void addFile(File path) {
        if (null != path) {
            adapterFiles.add(path);
        }
    }
    /**
     * Read arguments in as if from a command line, 
     * mainly to support compiler adapter compilerarg subelement. 
     * 
     * @param args the String[] of arguments to read
     */
    public void readArguments(String[] args) { // XXX slow, stupid, unmaintainable
        if ((null == args) || (0 == args.length)) {
            return;
        }
        /** String[] wrapper with increment, error reporting */
        class Args {
            final String[] args;
            int index = 0;
            Args(String[] args) {
                this.args = args; // not null or empty
            }
            boolean hasNext() {
                return index < args.length;
            }
            String next() {
                String err = null;
                if (!hasNext()) {
                    err = "need arg for flag " + args[args.length-1];
                } else {
                    String s = args[index++];
                    if (null == s) {
                        err = "null value";                                            
                    } else {
                        s = s.trim();
                        if (0 == s.trim().length()) {
                            err = "no value";                                            
                        } else {
                            return s;
                        }
                    }
                }
                err += " at [" + index + "] of " + Arrays.asList(args);
                throw new BuildException(err);
            }
        } // class Args
        Args in = new Args(args);
        String flag;
        while (in.hasNext()) {
            flag = in.next();
            if ("-1.3".equals(flag)) {
                setCompliance(flag);
            } else if ("-1.4".equals(flag)) {
            	setCompliance(flag);
            } else if ("-1.5".equals(flag)) {
                setCompliance("1.5");
            } else if ("-argfile".equals(flag)) {
                setArgfiles(new Path(project, in.next()));
            } else if ("-aspectpath".equals(flag)) {
                setAspectpath(new Path(project, in.next()));
            } else if ("-classpath".equals(flag)) {
                setClasspath(new Path(project, in.next()));
            } else if ("-Xcopyinjars".equals(flag)) {
                setCopyInjars(true); // ignored - will be flagged by setter
            } else if ("-g".equals(flag)) {
                setDebug(true);
            } else if (flag.startsWith("-g:")) {
                setDebugLevel(flag.substring(2));
            } else if ("-deprecation".equals(flag)) {
                setDeprecation(true);
            } else if ("-d".equals(flag)) {
                setDestdir(new File(in.next()));
            } else if ("-crossrefs".equals(flag)) {
                setCrossrefs(true);
            } else if ("-emacssym".equals(flag)) {
                setEmacssym(true);
            } else if ("-encoding".equals(flag)) {
                setEncoding(in.next());
            } else if ("-Xfailonerror".equals(flag)) {
                setFailonerror(true);
            } else if ("-fork".equals(flag)) {
                setFork(true);
            } else if ("-forkclasspath".equals(flag)) {
                setForkclasspath(new Path(project, in.next()));
            } else if ("-help".equals(flag)) {
                setHelp(true);
            } else if ("-incremental".equals(flag)) {
                setIncremental(true);
            } else if ("-injars".equals(flag)) {
                setInjars(new Path(project, in.next()));
            } else if ("-inpath".equals(flag)) {
            	setInpath(new Path(project,in.next()));
            } else if ("-Xlistfileargs".equals(flag)) {
                setListFileArgs(true);
            } else if ("-Xmaxmem".equals(flag)) {
                setMaxmem(in.next());
            } else if ("-Xmessageholderclass".equals(flag)) {
                setMessageHolderClass(in.next());
            } else if ("-noexit".equals(flag)) {
                setNoExit(true);
            } else if ("-noimport".equals(flag)) {
                setNoExit(true);
            } else if ("-noExit".equals(flag)) {
                setNoExit(true);
            } else if ("-noImportError".equals(flag)) {
                setNoImportError(true);
            } else if ("-noWarn".equals(flag)) {
                setNowarn(true);
            } else if ("-noexit".equals(flag)) {
                setNoExit(true);
            } else if ("-outjar".equals(flag)) {
                setOutjar(new File(in.next()));
            } else if ("-outxml".equals(flag)) {
                setOutxml(true);
            } else if ("-outxmlfile".equals(flag)) {
                setOutxmlfile(in.next());
            } else if ("-preserveAllLocals".equals(flag)) {
                setPreserveAllLocals(true);
            } else if ("-proceedOnError".equals(flag)) {
                setProceedOnError(true);
            }  else if ("-referenceInfo".equals(flag)) {
                setReferenceInfo(true);
            } else if ("-source".equals(flag)) {
                setSource(in.next());
            } else if ("-Xsourcerootcopyfilter".equals(flag)) {
                setSourceRootCopyFilter(in.next());
            } else if ("-sourceroots".equals(flag)) {
                setSourceRoots(new Path(project, in.next()));
            } else if ("-Xsrcdir".equals(flag)) {
                setSrcDir(new Path(project, in.next()));
            } else if ("-Xtagfile".equals(flag)) {
                setTagFile(new File(in.next()));
            } else if ("-target".equals(flag)) {
                setTarget(in.next());
            } else if ("-time".equals(flag)) {
                setTime(true);
            } else if ("-time".equals(flag)) {
                setTime(true);
            } else if ("-verbose".equals(flag)) {
                setVerbose(true); 
            } else if ("-showWeaveInfo".equals(flag)) {
                setShowWeaveInfo(true);
            } else if ("-version".equals(flag)) {
                setVersion(true);
            } else if ("-warn".equals(flag)) {
                setWarn(in.next());
            } else if (flag.startsWith("-warn:")) {
                setWarn(flag.substring(6));
            } else if ("-Xlint".equals(flag)) {
                setXlintwarnings(true);
            } else if (flag.startsWith("-Xlint:")) {
                setXlint(flag.substring(7));
            } else if ("-Xlintfile".equals(flag)) {
                setXlintfile(new File(in.next()));
            } else if ("-XterminateAfterCompilation".equals(flag)) {
                setXTerminateAfterCompilation(true);
            } else if ("-XnotReweavable".equals(flag)) {
            } else if (flag.startsWith("@")) {
                File file = new File(flag.substring(1));
                if (file.canRead()) {
                    setArgfiles(new Path(project, file.getPath()));
                } else {
                    ignore(flag);            
                }
            } else {
                File file = new File(flag);
                if (file.isFile() 
                	&& file.canRead() 
                	&& FileUtil.hasSourceSuffix(file)) {
                    addFile(file);
                } else {
                    ignore(flag);
                }
            }
        }
        
    }
    protected void logVerbose(String text) {
    	if (this.verbose) {
    		this.logger.info(text);
    	} else {
    		this.logger.verbose(text);
    	}
    }
 * Commandline wrapper that 
 * only permits addition of non-empty values
 * and converts to argfile form if necessary.
 */
    Commandline command;
    //int size;
    static boolean isEmpty(String s) {
        return ((null == s) || (0 == s.trim().length()));
    }
    GuardedCommand() {
        command = new Commandline();
    }
    void addFlag(String flag, boolean doAdd) {
        if (doAdd && !isEmpty(flag)) {
            command.createArgument().setValue(flag);
            //size += 1 + flag.length();
        }
    }
    
    /** @return null if added or ignoreString otherwise */
    String addOption(String prefix, String[] validOptions, String input) {
        if (isEmpty(input)) {
            return null;
        }
        for (int i = 0; i < validOptions.length; i++) {
                if (isEmpty(prefix)) {
                    addFlag(input, true);
                } else {
                    addFlagged(prefix, input);
                }
                return null;
======= fetch "String addOption(String prefix, String[] validOptions, String input) {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "String addOption(String prefix, String[] validOptions, String input) {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

        return (null == prefix ? input : prefix + " " + input);
    }
    
    void addFlagged(String flag, String argument) {
        if (!isEmpty(flag) && !isEmpty(argument)) {
            command.addArguments(new String[] {flag, argument});
            //size += 1 + flag.length() + argument.length();
        }
    }
    
    
    List extractArguments() {
        ArrayList result = new ArrayList();
        String[] cmds = command.getArguments();
        if (!LangUtil.isEmpty(cmds)) {
            result.addAll(Arrays.asList(cmds));
        }
        return result;
    }
     /**
     * Adjust args for size if necessary by creating
     * an argument file, which should be deleted by the client
     * after the compiler run has completed.
     * @param max the int maximum length of the command line (in char)
     * @return the temp File for the arguments (if generated), 
     *         for deletion when done.
     * @throws IllegalArgumentException if max is negative
     */
    static String[] limitTo(String[] args, int max, 
        Location location) {       
        if (max < 0) {
            throw new IllegalArgumentException("negative max: " + max);
        }
        // sigh - have to count anyway for now
        int size = 0;
        for (int i = 0; (i < args.length) && (size < max); i++) {
            size += 1 + (null == args[i] ? 0 : args[i].length());    
        }
        if (size <= max) {
            return args;
        }
        File tmpFile = null;
        PrintWriter out = null;
        // adapted from DefaultCompilerAdapter.executeExternalCompile
        try {
            String userDirName = System.getProperty("user.dir");
            File userDir = new File(userDirName);
            tmpFile = File.createTempFile("argfile", "", userDir);
            out = new PrintWriter(new FileWriter(tmpFile));
            for (int i = 0; i < args.length; i++) {
                out.println(args[i]);
            }
            out.flush();
            return new String[] {"-argfile", tmpFile.getAbsolutePath()};
        } catch (IOException e) {
            throw new BuildException("Error creating temporary file", 
                                     e, location);
        } finally {
            if (out != null) {
                try {out.close();} catch (Throwable t) {}
            }
        }
    }     
======= fetch "List extractArguments() {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "List extractArguments() {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    private final boolean taskLevelVerbose;
    private final boolean handledMessage;
    
        this.handledMessage = handledMessage;
======= fetch "public AntMessageHandler(TaskLogger logger, boolean taskVerbose, boolean handled" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "public boolean handleMessage(IMessage message) throws AbortException {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "public boolean handleMessage(IMessage message) throws AbortException {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "public boolean handleMessage(IMessage message) throws AbortException {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "public boolean handleMessage(IMessage message) throws AbortException {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "public boolean handleMessage(IMessage message) throws AbortException {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "public boolean handleMessage(IMessage message) throws AbortException {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "public boolean isIgnoring(Kind kind) {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "public boolean isIgnoring(Kind kind) {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "public void dontIgnore(Kind kind) {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "public void dontIgnore(Kind kind) {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "public void ignore(Kind kind) {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "public void ignore(Kind kind) {" 1da1f7c^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"


======= fetch "String stripWhitespaceAndComments(String s) {" d9bd46d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/ConfigParser.java"


    before() : execution(public void IsAdvised.doNothing()) {
        
    }
    int IsAdvised.x;
    public void doNothing() {} 
    public void doNothing2() {} 
    public void doNothing3() {} 
    public void doNothing4() {} 
    public void doNothing() {} 
    public void doNothing2() {} 
    public void doNothing3() {} 
    public void doNothing4() {} 
    public void doNothing5() {} 

    <ajc-test dir="bugs163/pr251326" title="itd anonymous inner class in wrong package">
      <compile files="pkgA/Listener.java pkgA/Target.java pkgB/InferListener.aj" options="-1.5"/>
      <run class="pkgA.Target">
        <stdout>
          <line text="Simple A"/>
          <line text="Inferred B"/>
        </stdout>
      </run>
    </ajc-test>

======= fetch "public MethodArgument(String name, int indexOnStack) {" 120b47f^:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

======= fetch "public Pointcut getPointcut() {" 120b47f^:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

======= fetch "private static void addChildNodes(AsmManager asm, ShadowMunger munger, IProgramE" 120b47f^:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"


======= fetch "private String getParameters(IProgramElement ipe) {" 155a888^:"asm/src/org/aspectj/asm/internal/JDTLikeHandleProvider.java"


======= fetch "public void testItdCCE_pr250091() {" cffe291^:"tests/src/org/aspectj/systemtest/ajc163/Ajc163Tests.java"

    <ajc-test dir="bugs163/pr249710" title="terminateAfterCompilation">
      <compile files="Foo.java" options="-1.5">
      </compile>
    </ajc-test>

======= fetch "private void deleteNewAndDup() {" 7a398a2^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "private void deleteNewAndDup() {" 7a398a2^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "private void deleteNewAndDup() {" 7a398a2^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "private void retargetFrom(InstructionHandle old, InstructionHandle fresh) {" 7a398a2^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"


    public void methodA() {
        System.out.println("methodA");
    }
    public void methodB() {
        System.out.println("methodB");
    }
    void doSomething();
    public void doSomething() {
        System.out.println("doSomething");
    }
    void methodA();
    void methodB();
   @DeclareParents(value="Foo+",defaultImpl=DefaultTestImpl.class)
   public Test implementedInterface;
   @Before("execution(* Foo.doSomething()) && this(t)")
   public void verifyRunningSender(Test t) {
       t.methodA();
       t.methodB();
   }
   
   public static void main(String[] args) {
       Foo foo = new FooImpl();
       foo.doSomething();
   }
    void methodA();
    void methodB();
======= fetch "public void testSpacewarHandles() {" 9b68a31^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= fetch "public void testAspectPath_pr247742_c16() throws IOException {" 9b68a31^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= fetch "public void testBrokenCodeCompilation() {" 9b68a31^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


======= fetch "public boolean hasAnnotation(UnresolvedType ofType) {" f376a21^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseResolvedMember.java"

======= fetch "public boolean hasAnnotation(UnresolvedType ofType) {" f376a21^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseResolvedMember.java"


======= fetch "public static BcelShadow makeMethodExecution(BcelWorld world, LazyMethodGen encl" 78a483d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public boolean arg0HoldsThis() {" 78a483d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public Var getArgVar(int i) {" 78a483d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public UnresolvedType ensureTargetTypeIsCorrect(UnresolvedType tx) {" 78a483d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public UnresolvedType ensureTargetTypeIsCorrect(UnresolvedType tx) {" 78a483d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public void initializeArgVars() {" 78a483d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public void initializeArgVars() {" 78a483d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public void initializeArgVars() {" 78a483d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public void initializeArgVars() {" 78a483d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public void initializeArgVars() {" 78a483d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public void initializeArgVars() {" 78a483d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public void initializeArgVars() {" 78a483d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public void initializeArgVars() {" 78a483d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public void initializeArgVars() {" 78a483d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public void initializeArgVars() {" 78a483d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public void initializeArgVars() {" 78a483d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public void initializeTargetAnnotationVars() {" 78a483d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public void weaveAroundInline(BcelAdvice munger, boolean hasDynamicTest) {" 78a483d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"


======= fetch "public void installGlobals(AjBuildConfig global) { // XXX relies on default valu" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

    private static boolean DO_RUNTIME_VERSION_CHECK = false;
    // If runtime version check fails, warn or fail? (unset?)
    static final boolean FAIL_IF_RUNTIME_NOT_FOUND = false;
    
    
    private static final FileFilter binarySourceFilter = 
======= fetch "public boolean accept(File f) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public boolean accept(File f) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public boolean accept(File f) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

    	CompilationAndWeavingContext.setMultiThreaded(false);
======= fetch "public boolean accept(File f) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public boolean accept(File f) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public boolean accept(File f) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public boolean accept(File f) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public boolean accept(File f) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

    
    /**
     * Enable check for runtime version, used only by Ant/command-line Main.
     * @param main Main unused except to limit to non-null clients.
     */
    public static void enableRuntimeVersionCheck(Main caller) {
    }
    
======= fetch "public AjBuildManager(IMessageHandler holder) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

        this.handler = CountingMessageHandler.makeCountingMessageHandler(holder);
======= fetch "public AjBuildManager(IMessageHandler holder) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void environmentSupportsIncrementalCompilation(boolean itDoes) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

    /** @return true if we should generate a model as a side-effect */
    public boolean doGenerateModel() {
        return buildConfig.isGenerateModelMode();
    }
        AjBuildConfig buildConfig, 
        IMessageHandler baseHandler) 
        throws IOException, AbortException {
        return doBuild(buildConfig, baseHandler, true);
    }
    public boolean incrementalBuild(
        AjBuildConfig buildConfig, 
        IMessageHandler baseHandler) 
        throws IOException, AbortException {
        return doBuild(buildConfig, baseHandler, false);
    }
    /** @throws AbortException if check for runtime fails */
    protected boolean doBuild(
        AjBuildConfig buildConfig, 
        IMessageHandler baseHandler, 
        boolean batch) throws IOException, AbortException {
        boolean ret = true;
    	batchCompile = batch;
    	wasFullBuild = batch;
    	if (baseHandler instanceof ILifecycleAware) {
    		((ILifecycleAware)baseHandler).buildStarting(!batch);
    	}
    	CompilationAndWeavingContext.reset();
    	int phase = batch ? CompilationAndWeavingContext.BATCH_BUILD : CompilationAndWeavingContext.INCREMENTAL_BUILD;
    	ContextToken ct = CompilationAndWeavingContext.enteringPhase(phase ,buildConfig);
        try {
        	if (batch) {
        		this.state = new AjState(this);
        	}
        	
        	this.state.setCouldBeSubsequentIncrementalBuild(this.environmentSupportsIncrementalCompilation);
        	
            boolean canIncremental = state.prepareForNextBuild(buildConfig);
            if (!canIncremental && !batch) { // retry as batch?
             CompilationAndWeavingContext.leavingPhase(ct);
             if (state.listenerDefined()) state.getListener().recordDecision("Falling back to batch compilation");
            	return doBuild(buildConfig, baseHandler, true);
            }
            this.handler = 
                CountingMessageHandler.makeCountingMessageHandler(baseHandler);
    		if (buildConfig==null || buildConfig.isCheckRuntimeVersion()) {
    		}
            // if (batch) {
                setBuildConfig(buildConfig);
            //}
            if (batch || !AsmManager.attemptIncrementalModelRepairs) {
                	setupModel(buildConfig);
            }
            if (batch) {
                initBcelWorld(handler);
            }
            if (handler.hasErrors()) {
               	CompilationAndWeavingContext.leavingPhase(ct);
                return false;
            }
            
            if (buildConfig.getOutputJar() != null) {
            	 if (!openOutputStream(buildConfig.getOutputJar())) {
                CompilationAndWeavingContext.leavingPhase(ct);
                return false;
            	 }
            }
            
            if (batch) {
                // System.err.println("XXXX batch: " + buildConfig.getFiles());
                if (buildConfig.isEmacsSymMode() || buildConfig.isGenerateModelMode()) {  
                    getWorld().setModel(AsmManager.getDefault().getHierarchy());
                    // in incremental build, only get updated model?
                }
                binarySourcesForTheNextCompile = state.getBinaryFilesToCompile(true);
                performCompilation(buildConfig.getFiles());
                state.clearBinarySourceFiles(); // we don't want these hanging around...
                if (!proceedOnError() && handler.hasErrors()) {
                   	CompilationAndWeavingContext.leavingPhase(ct);
                  	if (AsmManager.isReporting())
    				    AsmManager.getDefault().reportModelInfo("After a batch build");
                    return false;
                }
======= fetch "protected boolean doBuild(" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

            } else {
                // System.err.println("XXXX start inc ");
                binarySourcesForTheNextCompile = state.getBinaryFilesToCompile(true);
                Set files = state.getFilesToCompile(true);
======= fetch "protected boolean doBuild(" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

                boolean hereWeGoAgain = !(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
                for (int i = 0; (i < 5) && hereWeGoAgain; i++) {
                	   if (state.listenerDefined()) 
                		   state.getListener().recordInformation("Starting incremental compilation loop "+(i+1)+" of possibly 5");
                    // System.err.println("XXXX inc: " + files);
               
                    performCompilation(files);
                    if ((!proceedOnError() && handler.hasErrors()) || (progressListener!=null && progressListener.isCancelledRequested())) {
                        CompilationAndWeavingContext.leavingPhase(ct);
                        return false;
                    } 
                    
                    if (state.requiresFullBatchBuild()) {
                    	if (state.listenerDefined()) 
                 		   state.getListener().recordInformation(" Dropping back to full build");
                    	return batchBuild(buildConfig, baseHandler);
                    }
                    
                    binarySourcesForTheNextCompile = state.getBinaryFilesToCompile(false);
                    files = state.getFilesToCompile(false);
                    hereWeGoAgain = !(files.isEmpty() && binarySourcesForTheNextCompile.isEmpty());
                    // TODO Andy - Needs some thought here...
                    // I think here we might want to pass empty addedFiles/deletedFiles as they were
                    // dealt with on the first call to processDelta - we are going through this loop
                    // again because in compiling something we found something else we needed to
                    // rebuild.  But what case causes this?
                    if (hereWeGoAgain) {
                    }
                }
                if (!files.isEmpty()) {
                   	CompilationAndWeavingContext.leavingPhase(ct);
                    return batchBuild(buildConfig, baseHandler);
                } else {                
                	if (AsmManager.isReporting()) 
                }
            }
            // XXX not in Mik's incremental
            if (buildConfig.isEmacsSymMode()) {
                new org.aspectj.ajdt.internal.core.builder.EmacsStructureModelManager().externalizeModel();
            }
            
            // for bug 113554: support ajsym file generation for command line builds
            if (buildConfig.isGenerateCrossRefsMode()) {
            }
            
            // have to tell state we succeeded or next is not incremental
            state.successfulCompile(buildConfig,batch);
======= fetch "protected boolean doBuild(" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

            if (batch) {
            	copyResourcesToDestination();
            }
            
            if (buildConfig.getOutxmlName() != null) {
            	writeOutxmlFile();
            }
            
            /*boolean weaved = *///weaveAndGenerateClassFiles();
            // if not weaved, then no-op build, no model changes
            // but always returns true
            // XXX weaved not in Mik's incremental
            if (buildConfig.isGenerateModelMode()) {
                AsmManager.getDefault().fireModelUpdated();  
            }
           	CompilationAndWeavingContext.leavingPhase(ct);
            
        } finally {
        	if (baseHandler instanceof ILifecycleAware) {
        		((ILifecycleAware)baseHandler).buildFinished(!batch);
        	}
        	if (zos != null) {
        		closeOutputStream(buildConfig.getOutputJar());
        	}
            ret = !handler.hasErrors();
            if (getBcelWorld()!=null) getBcelWorld().tidyUp();
            if (getWeaver()!=null) getWeaver().tidyUp();
            // bug 59895, don't release reference to handler as may be needed by a nested call
            //handler = null;
        }
        return ret;
    }
    
======= fetch "private boolean openOutputStream(File outJar)  {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private boolean openOutputStream(File outJar)  {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void closeOutputStream(File outJar) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void closeOutputStream(File outJar) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void closeOutputStream(File outJar) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void closeOutputStream(File outJar) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void closeOutputStream(File outJar) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesToDestination() throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesToDestination() throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesToDestination() throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesToDestination() throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesToDestination() throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesToDestination() throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

    }
======= fetch "private void copyResourcesFromJarFile(File jarFile) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesFromJarFile(File jarFile) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesFromJarFile(File jarFile) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesFromJarFile(File jarFile) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesFromJarFile(File jarFile) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesFromJarFile(File jarFile) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesFromJarFile(File jarFile) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesFromDirectory(File dir) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesFromDirectory(File dir) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public boolean accept(File f) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public boolean accept(File f) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public boolean accept(File f) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public boolean accept(File f) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesFromFile(File f,String filename,File src) throws IOExc" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesFromFile(File f,String filename,File src) throws IOExc" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesFromFile(File f,String filename,File src) throws IOExc" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

    
======= fetch "private void copyResourcesFromFile(File f,String filename,File src) throws IOExc" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeDirectory(String directory, File srcloc) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeDirectory(String directory, File srcloc) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeResource(String filename, byte[] content, File srcLocation) th" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeResource(String filename, byte[] content, File srcLocation) th" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeResource(String filename, byte[] content, File srcLocation) th" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeResource(String filename, byte[] content, File srcLocation) th" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeResource(String filename, byte[] content, File srcLocation) th" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeResource(String filename, byte[] content, File srcLocation) th" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeResource(String filename, byte[] content, File srcLocation) th" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeManifest () throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeManifest () throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private boolean acceptResource(String resourceName,boolean fromFile) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private boolean acceptResource(String resourceName,boolean fromFile) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private ByteArrayOutputStream getOutxmlContents(List aspectNames) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private ByteArrayOutputStream getOutxmlContents(List aspectNames) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private ByteArrayOutputStream getOutxmlContents(List aspectNames) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private ByteArrayOutputStream getOutxmlContents(List aspectNames) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private ByteArrayOutputStream getOutxmlContents(List aspectNames) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private ByteArrayOutputStream getOutxmlContents(List aspectNames) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

    /**
     * Responsible for managing the ASM model between builds.  Contains the policy for
     * maintaining the persistance of elements in the model.
     * 
     * This code is driven before each 'fresh' (batch) build to create
     * a new model.
     */
     private void setupModel(AjBuildConfig config) {
     	AsmManager.setCreatingModel(config.isEmacsSymMode() || config.isGenerateModelMode());
     	if (!AsmManager.isCreatingModel()) return;
======= fetch "private void setupModel(AjBuildConfig config) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

        String rootLabel = "<root>";
        	
        IProgramElement.Kind kind = IProgramElement.Kind.FILE_JAVA;
        if (buildConfig.getConfigFile() != null) {
           	rootLabel = buildConfig.getConfigFile().getName();
           	model.setConfigFile(buildConfig.getConfigFile().getAbsolutePath());
           	kind = IProgramElement.Kind.FILE_LST;  
        }
        model.setRoot(new ProgramElement(rootLabel, kind, new ArrayList()));
                
        model.setFileMap(new HashMap());
        setStructureModel(model);
======= fetch "private void setupModel(AjBuildConfig config) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

    }
    
    
    //LTODO delegate to BcelWeaver?
     // XXX hideous, should not be Object
    public void setCustomMungerFactory(Object o) {
    }
    
======= fetch "public Object getCustomMungerFactory() {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

    /** init only on initial batch compile? no file-specific options */
======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public World getWorld() {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "void addAspectClassFilesToWeaver(List addedClassFiles) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "void addAspectClassFilesToWeaver(List addedClassFiles) throws IOException {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public FileSystem getLibraryAccess(String[] classpaths, String[] filenames) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public FileSystem getLibraryAccess(String[] classpaths, String[] filenames) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public FileSystem getLibraryAccess(String[] classpaths, String[] filenames) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public IProblemFactory getProblemFactory() {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

    
======= fetch "public IProblemFactory getProblemFactory() {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public IProblemFactory getProblemFactory() {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public IProblemFactory getProblemFactory() {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public IProblemFactory getProblemFactory() {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public IProblemFactory getProblemFactory() {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public IProblemFactory getProblemFactory() {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public IProblemFactory getProblemFactory() {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

    
======= fetch "public String extractDestinationPathFromSourceFile(CompilationResult result) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

    
    
======= fetch "public void performCompilation(Collection files) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void performCompilation(Collection files) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void performCompilation(Collection files) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void performCompilation(Collection files) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

        for (Iterator fIterator = files.iterator(); fIterator.hasNext();) {
            File f = (File) fIterator.next();
            filenames[ii++] = f.getPath();
        }
======= fetch "public void performCompilation(Collection files) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void performCompilation(Collection files) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void performCompilation(Collection files) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void performCompilation(Collection files) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void performCompilation(Collection files) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void performCompilation(Collection files) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void performCompilation(Collection files) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void acceptResult(InterimCompilationResult result) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void acceptResult(InterimCompilationResult result) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void acceptResult(InterimCompilationResult result) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public ICompilerRequestor getBatchRequestor() {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void acceptResult(CompilationResult unitResult) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void acceptResult(CompilationResult unitResult) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void acceptResult(CompilationResult unitResult) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void acceptResult(CompilationResult unitResult) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void acceptResult(CompilationResult unitResult) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void acceptResult(CompilationResult unitResult) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void acceptResult(CompilationResult unitResult) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void acceptResult(CompilationResult unitResult) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void acceptResult(CompilationResult unitResult) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeDirectoryEntry(" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeDirectoryEntry(" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeDirectoryEntry(" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeZipEntry(ClassFile classFile, String name)" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void addAspectName (String name, char[] fileContainingAspect) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void addAspectName (String name, char[] fileContainingAspect) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void addAspectName (String name, char[] fileContainingAspect) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "protected boolean proceedOnError() {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void setBuildConfig(AjBuildConfig buildConfig) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void setBuildConfig(AjBuildConfig buildConfig) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "String makeClasspathString(AjBuildConfig buildConfig) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "String makeClasspathString(AjBuildConfig buildConfig) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "String makeClasspathString(AjBuildConfig buildConfig) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "String makeClasspathString(AjBuildConfig buildConfig) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private String checkRtJar(AjBuildConfig buildConfig) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

        // omitting dev info
======= fetch "private String checkRtJar(AjBuildConfig buildConfig) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private String checkRtJar(AjBuildConfig buildConfig) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private String checkRtJar(AjBuildConfig buildConfig) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private String checkRtJar(AjBuildConfig buildConfig) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

                    String version = null;
                    Manifest manifest = new JarFile(p).getManifest();
                    if (manifest == null) {
                    	ret = "no manifest found in " + p.getAbsolutePath() + 
                    	continue;
                    }
                    Attributes attr = manifest.getAttributes("org/aspectj/lang/");
                    if (null != attr) {
                        version = attr.getValue(Attributes.Name.IMPLEMENTATION_VERSION);
                        if (null != version) {
                            version = version.trim();
                        }
                    }
======= fetch "private String checkRtJar(AjBuildConfig buildConfig) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

                        return null;
======= fetch "private String checkRtJar(AjBuildConfig buildConfig) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private String checkRtJar(AjBuildConfig buildConfig) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private String checkRtJar(AjBuildConfig buildConfig) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public String toString() {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public IHierarchy getStructureModel() {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

    
======= fetch "public void setProgressListener(IProgressListener progressListener) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public String getOutputClassFileName(char[] eclipseClassFileName, CompilationRes" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public String getOutputClassFileName(char[] eclipseClassFileName, CompilationRes" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public ICompilerAdapter getAdapter(org.aspectj.org.eclipse.jdt.internal.compiler" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public ICompilerAdapter getAdapter(org.aspectj.org.eclipse.jdt.internal.compiler" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public ICompilerAdapter getAdapter(org.aspectj.org.eclipse.jdt.internal.compiler" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public ICompilerAdapter getAdapter(org.aspectj.org.eclipse.jdt.internal.compiler" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public ICompilerAdapter getAdapter(org.aspectj.org.eclipse.jdt.internal.compiler" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public ICompilerAdapter getAdapter(org.aspectj.org.eclipse.jdt.internal.compiler" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public ICompilerAdapter getAdapter(org.aspectj.org.eclipse.jdt.internal.compiler" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public ICompilerAdapter getAdapter(org.aspectj.org.eclipse.jdt.internal.compiler" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void populateCompilerOptionsFromLintSettings(org.aspectj.org.eclipse.jdt" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void populateCompilerOptionsFromLintSettings(org.aspectj.org.eclipse.jdt" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public Map getBinarySourcesForThisWeave() {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

    public static AsmHierarchyBuilder getAsmHierarchyBuilder() {
        return asmHierarchyBuilder;
    }
    /**
     * Override the the default hierarchy builder.
     */
    public static void setAsmHierarchyBuilder(AsmHierarchyBuilder newBuilder) {
        asmHierarchyBuilder = newBuilder;
    }
    
    public AjState getState() {
        return state;
    }
======= fetch "public void setState(AjState buildState) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public String formatEntry(int phaseId, Object data) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public String formatEntry(int phaseId, Object data) {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public boolean wasFullBuild() {" d5c2ead^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"


======= fetch "protected void makeRectangular(){" 6d906dc^:"docs/dist/doc/examples/introduction/Point.java"


======= fetch "List parseDefinitions(final ClassLoader loader) {" df49b5c^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

            
======= fetch "List parseDefinitions(final ClassLoader loader) {" df49b5c^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

    			Enumeration xmls = weavingContext.getResources(st.nextToken());
    			Set seenBefore = new HashSet();
    			while (xmls.hasMoreElements()) {
    			    URL xml = (URL) xmls.nextElement();
    			    if (trace.isTraceEnabled()) trace.event("parseDefinitions",this,xml);
    			    if (!seenBefore.contains(xml)) {
    			    	info("using configuration " + weavingContext.getFile(xml));
    			    	definitions.add(DocumentParser.parse(xml));
        			    seenBefore.add(xml);
    			    }
    			    else {
    			    	warn("ignoring duplicate definition: " + xml);
    			    }

======= fetch "protected void fillDeclaredMembers() {" e9823aa^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"


======= fetch "public static AnnotationTypePattern read(VersionedDataInputStream s, ISourceCont" be03167^:"weaver/src/org/aspectj/weaver/patterns/AndAnnotationTypePattern.java"

======= fetch "public static AnnotationTypePattern read(VersionedDataInputStream s, ISourceCont" be03167^:"weaver/src/org/aspectj/weaver/patterns/NotAnnotationTypePattern.java"

======= fetch "public static AnnotationTypePattern read(VersionedDataInputStream s, ISourceCont" be03167^:"weaver/src/org/aspectj/weaver/patterns/OrAnnotationTypePattern.java"

======= fetch "public static AnnotationTypePattern read(VersionedDataInputStream s,ISourceConte" be03167^:"weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"


        public static interface Marker {}
        public static class NonGenericClass {
                public void doit(String msg) {
                        System.out.println("doit(): msg = "+msg);
                }
        }
        public static class GenericClass<T> {
                public void doit(T t) {
                        System.out.println("doit<T>(): t = "+t);
                }
        }
        declare parents: NonGenericClass implements Marker;
        declare parents: GenericClass    implements Marker;
        pointcut nonGenericCall(): call (void NonGenericClass.doit(..));
        pointcut genericCall():    call (void GenericClass.doit(..));
        pointcut markerCall():     call (void Marker+.doit(..));
        private static int mCount  = 0;
        
        before(): nonGenericCall() {
                System.out.println("nonGenericCall advice hit");
        }
        before(): genericCall() {
                System.out.println("genericCall advice hit");
        }
        before(): markerCall() {
        		mCount++;
                System.out.println("markerCall advice hit");
        }
        public static void main(String args[]) {
                new NonGenericClass().doit("message1");
                new GenericClass<Integer>().doit(new Integer(2));
                if (mCount!=2) {
                	throw new RuntimeException("Did not hit marker+ advice twice!");
                }
        }
    	<compile files="CantMatchOnInterfaceIntroducedToGenericClass.java" options="-1.5"/>
    	<run class="bug.CantMatchOnInterfaceIntroducedToGenericClass"/>
    </ajc-test>
    

======= fetch "protected Test findResidueInternal(Shadow shadow, ExposedState state) {" 248962b^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

                    if (pTypes!=null && baseArgsCount>pTypes.length) { //pr155347
                    	throw new BCException("Unexpected problem with testMethod "+testMethod+": expecting "+baseArgsCount+" arguments");
                    }
======= fetch "protected Test findResidueInternal(Shadow shadow, ExposedState state) {" 248962b^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

                                testMethod.getParameterTypes()[i].resolve(shadow.getIWorld())));

======= fetch "private TypeBinding makeTypeBinding1(UnresolvedType typeX) {" 3b2109a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "private TypeBinding makeTypeBinding1(UnresolvedType typeX) {" 3b2109a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"


======= fetch "public boolean accept(File pathname) {" 93b7bed^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public boolean accept(File pathname) {" 93b7bed^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "private void addIfAspect(byte[] bytes, String name, List toList) throws IOExcept" 93b7bed^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


======= fetch "private static void createBridgeMethod(BcelWorld world, LazyMethodGen whatToBrid" f014275^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"


======= fetch "private static int locateFirstBracket(StringBuffer signature) {" a8739e3^:"weaver/src/org/aspectj/weaver/TypeFactory.java"

======= fetch "private static int locateFirstBracket(StringBuffer signature) {" a8739e3^:"weaver/src/org/aspectj/weaver/TypeFactory.java"

======= fetch "private static int locateFirstBracket(StringBuffer signature) {" a8739e3^:"weaver/src/org/aspectj/weaver/TypeFactory.java"


======= fetch "public static IMessage makeMessage(ICompilationUnit unit, IProblem problem, Worl" d3c3e32^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"

        ISourceLocation[] seeAlsoLocations = new ISourceLocation[seeAlso.length];
======= fetch "public static IMessage makeMessage(ICompilationUnit unit, IProblem problem, Worl" d3c3e32^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"

        	seeAlsoLocations[i] = new SourceLocation(new File(new String(seeAlso[i].getOriginatingFileName())),
        											 seeAlso[i].getSourceLineNumber());

======= fetch "private void match(" 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        
        // Exception handlers (pr230817)
        if (canMatch(Shadow.ExceptionHandler) && !Range.isRangeHandle(ih)) {
            InstructionTargeter[] targeters = ih.getTargeters();
            if (targeters != null) {
                for (int j = 0; j < targeters.length; j++) {
                    InstructionTargeter t = targeters[j];
                    if (t instanceof ExceptionRange) {
                        // assert t.getHandler() == ih
                        ExceptionRange er = (ExceptionRange) t;
                        if (er.getCatchType() == null) continue;
                        if (isInitFailureHandler(ih)) return;
                        
                        if (!(ih.getInstruction() instanceof StoreInstruction) && ih.getInstruction().getOpcode()!=Constants.NOP) {
                            // If using cobertura, the catch block stats with INVOKESTATIC rather than ASTORE, in order that the ranges 
                            // for the methodcall and exceptionhandler shadows that occur at this same 
                            // line, we need to modify the instruction list to split them - adding a 
                            // NOP before the invokestatic that gets all the targeters
                            // that were aimed at the INVOKESTATIC
                            mg.getBody().insert(ih,InstructionConstants.NOP);
                            InstructionHandle newNOP = ih.getPrev();
                            // what about a try..catch that starts at the start of the exception handler? need to only include certain targeters really.
                            er.updateTarget(ih, newNOP,mg.getBody());
                            for (int ii=0;ii<targeters.length;ii++) {
                                newNOP.addTargeter(targeters[ii]);
                            }
                            ih.removeAllTargeters();
                            match(
                                BcelShadow.makeExceptionHandler(
                                    world, 
                                    er,
                                    mg, newNOP, enclosingShadow),
                                shadowAccumulator);
                        } else {                    
                            match(
                                BcelShadow.makeExceptionHandler(
                                    world, 
                                    er,
                                    mg, ih, enclosingShadow),
                                shadowAccumulator);
                        }
                    }
                }
            }
        }
        
======= fetch "private void match(" 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private void matchInvokeInstruction(LazyMethodGen mg," 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private void matchInvokeInstruction(LazyMethodGen mg," 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private void addExceptionHandlers(MethodGen gen, Map map, LinkedList exnList) {" 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

            gen.addExceptionHandler(
                remap(r.getRealStart(), map), 
                remap(r.getRealEnd(), map),
                remap(r.getHandler(), map),
                (r.getCatchType() == null)
                ? null 
                : (ObjectType) BcelWorld.makeBcelType(r.getCatchType()));
======= fetch "public static void assertGoodBody(InstructionList il, String from) {" 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        if (true) return;  // only to be enabled for debugging // should be switchonable via an option
        StringBuffer assertionLog = new StringBuffer();
        assertionLog.append("Checking state of an instruction body, from="+from+"\n");
    		if (il == null) return;
    		Set body = new HashSet();
    		Stack ranges = new Stack();
    		for (InstructionHandle ih = il.getStart(); ih != null; ih = ih.getNext()) {
    			body.add(ih);
    			if (ih.getInstruction() instanceof BranchInstruction) {
    				body.add(ih.getInstruction());
    			}
    		}
    		
    		for (InstructionHandle ih = il.getStart(); ih != null; ih = ih.getNext()) {
    			assertGoodHandle(ih, body, ranges, from, assertionLog);
    			InstructionTargeter[] ts = ih.getTargeters();
    			if (ts != null) {
    				for (int i = ts.length - 1; i >= 0; i--) {
    					assertGoodTargeter(ts[i], ih, body, from, assertionLog);
    				}
    			}
    		}
======= fetch "public static void assertGoodBody(InstructionList il, String from) {" 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= fetch "private static void assertGoodHandle(InstructionHandle ih, Set body, Stack range" 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= fetch "private static void assertGoodHandle(InstructionHandle ih, Set body, Stack range" 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= fetch "private static void assertGoodBranchInstruction(" 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= fetch "private static void assertGoodBranchInstruction(" 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= fetch "private static void assertGoodBranchInstruction(" 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= fetch "private static void assertGoodBranchInstruction(" 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= fetch "private static void assertInBody(Object ih, Set body, String from) {" 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    private static void assertGoodRangeHandle(InstructionHandle ih, Set body, Stack ranges, String from) {
======= fetch "private static void assertGoodRangeHandle(InstructionHandle ih, Set body, Stack" 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= fetch "private static void assertGoodRangeHandle(InstructionHandle ih, Set body, Stack" 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    private static void assertGoodRange(Range r, Set body, String from) {
======= fetch "private static void assertGoodRange(Range r, Set body, String from) {" 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= fetch "private static void assertGoodRange(Range r, Set body, String from) {" 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= fetch "private static void assertGoodTargeter(" 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        String from)
======= fetch "private static void assertGoodTargeter(" 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= fetch "private static void assertGoodTargeter(" 5f97d46^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"


======= fetch "public boolean match(DefaultPointcut node, Object other) {" bed3f4e^:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTMatcher.java"

======= fetch "public boolean match(DefaultTypePattern node, Object other) {" bed3f4e^:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTMatcher.java"

======= fetch "public boolean match(SignaturePattern node, Object other) {" bed3f4e^:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTMatcher.java"


======= fetch "public String toString() {" 6bdb87d^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    { "1.1", "1.2", "1.3", "1.4", "1.5" };
======= fetch "public String toString() {" 6bdb87d^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    { "1.3", "1.4", "1.5" };
======= fetch "public String toString() {" 6bdb87d^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    { "-1.3", "-1.4", "-1.5" };

======= fetch "private boolean doDeclareAnnotations(DeclareAnnotation decA, SourceTypeBinding s" 8ce9dcf^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"


======= fetch "protected void collectInterTypeMungers(List collector) {" fe99e6b^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

            }

======= fetch "public Set getAnnotations(Member onMember) {" 6c54db9^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"

            return null;// pr222987 - prevent NPE

======= fetch "private void copyResourcesFromJarFile(File jarFile) throws IOException {" 906c849^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesFromFile(File f,String filename,File src) throws IOExc" 906c849^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeManifest () throws IOException {" 906c849^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private boolean acceptResource(String resourceName) {" 906c849^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"


======= fetch "private void raiseUnboundFormalError(String name, Pointcut userPointcut) {" a31b3de^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


======= fetch "public boolean isTargettingAspectJRuntime12() {" caf8960^:"weaver/src/org/aspectj/weaver/World.java"


======= fetch "public void initialize(ReferenceType aType, Class aClass, ClassLoader classLoade" 1bbe6f9^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"


======= fetch "public AnnotationX getAnnotationOfType(UnresolvedType ofType,Member onMember) {" 9bbdb41^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"

======= fetch "public String getAnnotationDefaultValue(Member onMember) {" 9bbdb41^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"

======= fetch "public String getAnnotationDefaultValue(Member onMember) {" 9bbdb41^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"

======= fetch "public Set getAnnotations(Member onMember) {" 9bbdb41^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"

======= fetch "public Set getAnnotations(Member onMember) {" 9bbdb41^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"

======= fetch "public Set getAnnotations(Member onMember) {" 9bbdb41^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"


======= fetch "public String toResolvedString(World world) {" 5beab0e^:"weaver/src/org/aspectj/weaver/Shadow.java"

    	return getKind() + "(" + world.resolve(getSignature()).toGenericString() + ")";

     * The given args Object[] must be in the same order and size as the advice signature but
     * without the actual joinpoint instance

======= fetch "public ASTNode convert(org.aspectj.org.eclipse.jdt.internal.compiler.ast.Abstrac" 114db35^:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTConverter.java"

======= fetch "public ASTNode convert(org.aspectj.org.eclipse.jdt.internal.compiler.ast.Abstrac" 114db35^:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTConverter.java"

======= fetch "public ASTNode convert(InterTypeFieldDeclaration fieldDecl) {" 114db35^:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTConverter.java"


  @Pointcut("execution(@Tracing * *(..)) && @annotation(tracing)")
        void annotatedMethods(Tracing tracing) { }
       
        @AfterThrowing(pointcut = "annotatedMethods(tracing)", throwing = "t")
        public void logException(JoinPoint thisJoinPoint, Tracing tracing,Throwable t) {
        }
  @Tracing
  public void m() {}
  public static void main(String []argv) {}
   
  @Pointcut("execution(@Tracing * *(..)) && @annotation(tracing)")
        void annotatedMethods(Tracing tracing) { }
       
        @AfterThrowing(pointcut = "annotatedMethods(tracing)", throwing = "t")
        public void logException(JoinPoint thisJoinPoint, Throwable t,Tracing tracing) {
        }
  @Tracing
  public void m() {}
  public static void main(String []argv) {}
   <ajc-test dir="bugs154/pr211674" title="after throwing annotation style problem - 1">
     <compile options="-1.5" files="Test.java"/>
     <run class="Test"/>
   </ajc-test>
   <ajc-test dir="bugs154/pr211674" title="after throwing annotation style problem - 2">
     <compile options="-1.5" files="Test2.java"/>
     <run class="Test2"/>
   </ajc-test>

======= fetch "private boolean compareToExistingMembers(ConcreteTypeMunger munger, Iterator exi" 797ec4d^:"weaver/src/org/aspectj/weaver/ResolvedType.java"


======= fetch "public static UnresolvedType createTypeFromSignature(String signature) {" 579ec14^:"weaver/src/org/aspectj/weaver/TypeFactory.java"

======= fetch "public static UnresolvedType createTypeFromSignature(String signature) {" 579ec14^:"weaver/src/org/aspectj/weaver/TypeFactory.java"

======= fetch "public static UnresolvedType createTypeFromSignature(String signature) {" 579ec14^:"weaver/src/org/aspectj/weaver/TypeFactory.java"

======= fetch "public static UnresolvedType createTypeFromSignature(String signature) {" 579ec14^:"weaver/src/org/aspectj/weaver/TypeFactory.java"

======= fetch "public void testTypeXForParameterizedTypes() {" 579ec14^:"weaver/testsrc/org/aspectj/weaver/TypeXTestCase.java"


======= fetch "public void methodMustOverride(AbstractMethodDeclaration method) {" 4177bed^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= fetch "public void methodMustOverride(AbstractMethodDeclaration method) {" 4177bed^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"


======= fetch "public String toString() {" 5336603^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

        	{"constructorName", "packageDefaultMethod", "deprecation",
======= fetch "public String toString() {" 5336603^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

        		"unusedImports", "syntheticAccess", "assertIdentifier", "none" };

======= fetch "public boolean validate() {" e8d2556^:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

        ResolvedType current = m_world.resolve(m_concreteAspect.name, true);
        if (!current.isMissing()) {
======= fetch "public String getClassName () {" e8d2556^:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

        BcelPerClauseAspectAdder perClauseMunger = new BcelPerClauseAspectAdder(
                ResolvedType.forName(m_concreteAspect.name).resolve(m_world),
                m_perClause.getKind()
        );

======= fetch "private boolean configureBuildOptions( AjBuildConfig config, BuildOptionsAdapter" c54fa62^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= fetch "private boolean configureBuildOptions( AjBuildConfig config, BuildOptionsAdapter" c54fa62^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= fetch "private boolean configureBuildOptions( AjBuildConfig config, BuildOptionsAdapter" c54fa62^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= fetch "private boolean configureBuildOptions( AjBuildConfig config, BuildOptionsAdapter" c54fa62^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= fetch "public void testCharacterEncoding() {" c54fa62^:"ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java"

        assertTrue(configFile + " failed", null != buildConfig);            
======= fetch "public void testCharacterEncoding() {" c54fa62^:"ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java"

======= fetch "public void testSourceCompatibilityLevelJava6() {" c54fa62^:"ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java"

        assertTrue(configFile + " failed", null != buildConfig);            
======= fetch "public void testSourceIncompatibilityLevel() {" c54fa62^:"ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java"

        assertTrue(configFile + " failed", null != buildConfig);            
======= fetch "public void testSourceIncompatibilityLevel() {" c54fa62^:"ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java"

        assertTrue(configFile + " failed", null != buildConfig);            

  public List<? extends Element> getElements() {
    return new ArrayList<Element>();
  }
  class Element {};
  @Aspect
  static abstract class Base<T> {
    @Around("call(List<? extends T> *.*(..))")
    public List<? extends T> elementList(ProceedingJoinPoint thisJoinPoint) {
      try {
        return (List<? extends T>)thisJoinPoint.proceed();
      } catch (Throwable e) {
        throw new RuntimeException(e);
      }
    }
  }
  @Aspect
  static class Concrete extends Base<Element> {}
  public static void main(String[] args) {
    new Main().getElements();
  }
  public List<? extends Element> getElements() {
    return new ArrayList<Element>();
  }
  class Element {};
  @Aspect
  static abstract class Base<T> {
    @Around("call(List<? extends T> *.*(..))")
    public List<? extends T> elementList(ProceedingJoinPoint thisJoinPoint) {
      try {
        return (List<? extends T>)thisJoinPoint.proceed();
      } catch (Throwable e) {
        throw new RuntimeException(e);
      }
    }
  }
  @Aspect
  static class Concrete extends Base<String> {} // pointcut won't match because not a call to "List<? extends String> *(..)"
  public static void main(String[] args) {
    new Main2().getElements();
  }
  public void testGenericsInPointcuts_pr161502() { runTest("generics in pointcuts");}
  public void testGenericsInPointcuts_pr161502_2() { runTest("generics in pointcuts - 2");}
      <compile files="Main.java" options="-1.5 -showWeaveInfo">
        <message kind="weave" text="Join point 'method-call(java.util.List Main.getElements())' in Type 'Main' (Main.java:31) advised by around advice from 'Main$Concrete' (Main.java:18)"/>
      </compile>
      <run class="Main"/>
    </ajc-test> 
        
      <compile files="Main2.java" options="-1.5 -showWeaveInfo">
        <message kind="warning" text="advice defined in Main2$Base has not been applied"/>
      </compile>
      <run class="Main2"/>
    </ajc-test> 
    
======= fetch "public BoundedReferenceType(ReferenceType aBound, boolean isExtends, World world" 7b40e7e^:"weaver/src/org/aspectj/weaver/BoundedReferenceType.java"

======= fetch "public BoundedReferenceType(ReferenceType aBound, boolean isExtends, World world" 7b40e7e^:"weaver/src/org/aspectj/weaver/BoundedReferenceType.java"

======= fetch "public ShadowMunger parameterizeWith(ResolvedType declaringType,Map typeVariable" 7b40e7e^:"weaver/src/org/aspectj/weaver/Checker.java"

======= fetch "public PerClause getPerClause() {" 7b40e7e^:"weaver/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "protected Collection getDeclares() {" 7b40e7e^:"weaver/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public ResolvedMemberImpl parameterizedWith(UnresolvedType[] typeParameters, Res" 7b40e7e^:"weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.java"

======= fetch "public UnresolvedType parameterize(Map typeBindings) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

======= fetch "public UnresolvedType parameterize(Map typeBindings) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

======= fetch "public UnresolvedType parameterize(Map typeBindings) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

======= fetch "public static TypeVariable read(VersionedDataInputStream s) throws IOException {" 7b40e7e^:"weaver/src/org/aspectj/weaver/TypeVariable.java"

======= fetch "public TypeVariableReferenceType(" 7b40e7e^:"weaver/src/org/aspectj/weaver/TypeVariableReferenceType.java"

======= fetch "private void setAdditionalInterfaceBoundsFromTypeVar() {" 7b40e7e^:"weaver/src/org/aspectj/weaver/TypeVariableReferenceType.java"

======= fetch "public ShadowMunger parameterizeWith(ResolvedType declaringType,Map typeVariable" 7b40e7e^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= fetch "public boolean munge(BcelClassWeaver weaver) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

        		ResolvedMember declaredSig = munger.getDeclaredSignature();
        		if (declaredSig==null) declaredSig= munger.getSignature();
======= fetch "protected Test findResidueInternal(Shadow shadow, ExposedState state) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/internal/tools/PointcutDesignatorHandlerBasedPointcut.java"

======= fetch "public AnnotationTypePattern resolveBindings(IScope scope," 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/AndAnnotationTypePattern.java"

======= fetch "public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, I" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/AndPointcut.java"

======= fetch "public TypePattern resolveBindings(" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/AndTypePattern.java"

======= fetch "public AnnotationPatternList(List l) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.java"

======= fetch "public AnnotationPatternList parameterizeWith(Map typeVariableMap) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.java"

======= fetch "public int couldMatchKinds() {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= fetch "public AnnotationTypePattern remapAdviceFormals(IntMap bindings) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java"

======= fetch "public Object accept(PatternNodeVisitor visitor, Object data) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java"

    public AnnotationTypePattern parameterizeWith(Map arg0) {
======= fetch "public Object accept(PatternNodeVisitor visitor, Object data) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java"

    public AnnotationTypePattern parameterizeWith(Map arg0) {
======= fetch "public int couldMatchKinds() {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= fetch "public TypePatternList getArguments() {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

    public Pointcut parameterizeWith(Map typeVariableMap) {
    	ArgsPointcut ret = new ArgsPointcut(this.arguments.parameterizeWith(typeVariableMap));
======= fetch "private void verifyRuntimeRetention(World world, ResolvedType resolvedAnnotation" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.java"

======= fetch "public TypePattern remapAdviceFormals(IntMap bindings) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/BindingTypePattern.java"

======= fetch "public static Pointcut read(VersionedDataInputStream s, ISourceContext context)" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/ConcreteCflowPointcut.java"

======= fetch "public static Declare read(VersionedDataInputStream s, ISourceContext context) t" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/Declare.java"

    public abstract Declare parameterizeWith(Map typeVariableBindingMap);
======= fetch "public void resolve(IScope scope) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/DeclareAnnotation.java"

======= fetch "public Declare parameterizeWith(Map typeVariableBindingMap) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/DeclareAnnotation.java"

======= fetch "public Declare parameterizeWith(Map typeVariableBindingMap) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/DeclareAnnotation.java"

======= fetch "public void resolve(IScope scope) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java"

    public Declare parameterizeWith(Map typeVariableBindingMap) {
    	Declare ret = new DeclareErrorOrWarning(isError,pointcut.parameterizeWith(typeVariableBindingMap),message);
======= fetch "public Object accept(PatternNodeVisitor visitor, Object data) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/DeclareParents.java"

======= fetch "public Declare parameterizeWith(Map typeVariableBindingMap) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/DeclareParents.java"

======= fetch "public Object accept(PatternNodeVisitor visitor, Object data) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

======= fetch "public Object accept(PatternNodeVisitor visitor, Object data) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java"

======= fetch "public Declare parameterizeWith(Map typeVariableBindingMap) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java"

======= fetch "public AnnotationTypePattern resolveBindings(IScope scope," 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java"

======= fetch "public TypePattern resolveBindings(IScope scope, Bindings bindings," 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= fetch "public TypePattern parameterizeWith(Map typeVariableMap) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= fetch "public TypePattern parameterizeWith(Map typeVariableMap) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"

======= fetch "public FuzzyBoolean matchesInstanceof(ResolvedType type) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/HasMemberTypePattern.java"

======= fetch "public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType," 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType," 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

======= fetch "public AnnotationTypePattern resolveBindings(IScope scope," 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/NotAnnotationTypePattern.java"

======= fetch "public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, I" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/NotPointcut.java"

======= fetch "public TypePattern resolveBindings(" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/NotTypePattern.java"

======= fetch "public AnnotationTypePattern resolveBindings(IScope scope," 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/OrAnnotationTypePattern.java"

======= fetch "public Pointcut concretize1(ResolvedType inAspect, ResolvedType declaringType, I" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/OrPointcut.java"

======= fetch "public TypePattern resolveBindings(" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/OrTypePattern.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/PerCflow.java"

    public Pointcut parameterizeWith(Map typeVariableMap) {
    	PerCflow ret = new PerCflow(entry.parameterizeWith(typeVariableMap),isBelow);
======= fetch "public PerClause concretize(ResolvedType inAspect) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/PerObject.java"

    public Pointcut parameterizeWith(Map typeVariableMap) {
    	PerObject ret = new PerObject(entry.parameterizeWith(typeVariableMap),isThis);
======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/PerSingleton.java"

    public Pointcut parameterizeWith(Map typeVariableMap) {
======= fetch "public int couldMatchKinds() {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java"

======= fetch "public Object accept(PatternNodeVisitor visitor, Object data) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

        public Pointcut parameterizeWith(Map typeVariableMap) {
======= fetch "public void assertState(State state) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= fetch "public Pointcut concretize1(ResolvedType searchStart, ResolvedType declaringType" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= fetch "public Pointcut concretize1(ResolvedType searchStart, ResolvedType declaringType" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= fetch "public void postRead(ResolvedType enclosingType) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "public SignaturePattern parameterizeWith(Map typeVariableMap) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "public SignaturePattern parameterizeWith(Map typeVariableMap) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "public int couldMatchKinds() {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java"

======= fetch "public Pointcut parameterizeWith(Map typeVariableMap) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java"

======= fetch "public TypePattern getType() {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= fetch "public ThrowsPattern resolveBindings(IScope scope, Bindings bindings) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java"

    public ThrowsPattern parameterizeWith(Map/*name -> resolved type*/ typeVariableMap) {
======= fetch "public ThrowsPattern parameterizeWith(Map/*name -> resolved type*/ typeVariableM" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java"

    			required.parameterizeWith(typeVariableMap),
    			forbidden.parameterizeWith(typeVariableMap));
======= fetch "public void resolve(World world) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

    public abstract TypePattern parameterizeWith(Map typeVariableMap);
======= fetch "public Object accept(PatternNodeVisitor visitor, Object data) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

    public TypePattern parameterizeWith(Map typeVariableMap) {
======= fetch "public Object accept(PatternNodeVisitor visitor, Object data) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

    public TypePattern parameterizeWith(Map arg0) {
======= fetch "public FuzzyBoolean matchesInstanceof(ResolvedType type) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= fetch "public Object accept(PatternNodeVisitor visitor, Object data) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

    public TypePattern parameterizeWith(Map arg0) {
======= fetch "private static FuzzyBoolean inStar(final TypePattern[] pattern, final ResolvedTy" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/TypePatternList.java"

    public TypePatternList parameterizeWith(Map typeVariableMap) {
======= fetch "public TypePatternList parameterizeWith(Map typeVariableMap) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/TypePatternList.java"

======= fetch "public AnnotationTypePattern resolveBindings(IScope scope, Bindings bindings," 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

    public AnnotationTypePattern parameterizeWith(Map typeVariableMap) {
    	WildAnnotationTypePattern ret = new WildAnnotationTypePattern(typePattern.parameterizeWith(typeVariableMap));
======= fetch "public String maybeGetCleanName() {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "public TypePattern parameterizeWith(Map typeVariableMap) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "public TypePattern parameterizeWith(Map typeVariableMap) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "public TypePattern parameterizeWith(Map typeVariableMap) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "public TypePattern parameterizeWith(Map typeVariableMap) {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "public int couldMatchKinds() {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java"

======= fetch "public int couldMatchKinds() {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java"

======= fetch "public int couldMatchKinds() {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= fetch "public int couldMatchKinds() {" 7b40e7e^:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"


        not on the classpath when the aspects are being compiled and woven 
        with this jar on the inpath. This should result in a cantFindType 
        message. 
        
        result in an unresolvableMember message.
    pointcut tracePoints() : !within(Tracing);
    before() : tracePoints() {
            _callDepth++; print("Before", thisJoinPoint);
    }
    after() : tracePoints() {
            print("After", thisJoinPoint);
            _callDepth--;
    }
    private void print(String prefix, Object message) {
            for(int i = 0, spaces = _callDepth * 2; i < spaces; i++) {
                    //MyPrint.print(" ","");
            }
            System.out.println(prefix + ": " + message);
    }
  public void testNoNPEDueToMissingType_pr149908() { runTest("ensure no npe due to missing type");}
  public void testNoNPEDueToMember_pr149908() { runTest("ensure no npe due to missing member");}
    <ajc-test dir="bugs153/pr149908" title="ensure no npe due to missing type">
      <compile files="A.aj,C1.java,Tracing.aj" inpath="simple.jar">
    </ajc-test>
    <ajc-test dir="bugs153/pr149908" title="ensure no npe due to missing member">
      <compile files="A.aj,C1.java,Tracing.aj" inpath="simple.jar;stringBuilder.jar">
    </ajc-test>
    
    private boolean reportedCantFindDeclaringType = false;
    private boolean reportedUnresolvableMember = false;
======= fetch "public int getModifiers(World world) {" 757004c^:"weaver/src/org/aspectj/weaver/MemberImpl.java"

        return resolve(world).getModifiers();
======= fetch "public int getModifiers(World world) {" 757004c^:"weaver/src/org/aspectj/weaver/MemberImpl.java"

        return resolve(world).getExceptions();
======= fetch "protected String makeString(String[] names) {" 757004c^:"weaver/src/org/aspectj/weaver/MemberImpl.java"

    	return resolve(world).getParameterNames();
======= fetch "public Iterator getJoinPointSignatures(World inAWorld) {" 757004c^:"weaver/src/org/aspectj/weaver/MemberImpl.java"

       	if (reportedCantFindDeclaringType || reportedUnresolvableMember) return;
    }

======= fetch "public static void main(String[] args) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

                //signatureFiles[i] = createSignatureFile(inputFiles[i]);
======= fetch "public static void main(String[] args) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            ajcOptions.addElement("-noExit");
            ajcOptions.addElement("-d"); 
            ajcOptions.addElement(rootDir.getAbsolutePath());
            int i = 0;
            for ( ; i < ajcOptions.size(); i++ ) {
                argsToCompiler[i] = (String)ajcOptions.elementAt(i);
            }
            for ( int j = 0; j < inputFiles.length; j++) {
                argsToCompiler[i] = inputFiles[j].getAbsolutePath();
                //System.out.println(">> file to ajc: " + inputFiles[j].getAbsolutePath());
                i++;
            }
            System.out.println( "> Calling ajc..." );
            CompilerWrapper.main(argsToCompiler);
======= fetch "public static void main(String[] args) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            }
            for (int ii = 0; ii < inputFiles.length; ii++) {
                String tempFP = inputFiles[ii].getAbsolutePath();
                tempFP = tempFP.substring(0, tempFP.length()-4);
                tempFP += "ajsym";
                System.out.println( ">> checking: " + tempFP);
                File tempF = new File(tempFP);
                if ( !tempF.exists() ) System.out.println( ">>> doesn't exist!" );
            }
======= fetch "public static void main(String[] args) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            StubFileGenerator.doFiles(declIDTable, inputFiles, signatureFiles);
======= fetch "public static void main(String[] args) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

======= fetch "public static void main(String[] args) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            System.out.println( "> Calling javadoc..." );
            String[] javadocargs = null;
            if ( packageMode ) {
                int numExtraArgs = 2;
                if (authorStandardDocletSwitch) numExtraArgs++;
                if (versionStandardDocletSwitch) numExtraArgs++;
                javadocargs = new String[numExtraArgs + options.size() + packageList.size() +
                                         fileList.size() ];
                javadocargs[0] = "-sourcepath";
                javadocargs[1] = outputWorkingDir;
                int argIndex = 2;
                if (authorStandardDocletSwitch) {
                    javadocargs[argIndex] = "-author";
                    argIndex++;
                }
                if (versionStandardDocletSwitch) {
                    javadocargs[argIndex] = "-version";
                }
                //javadocargs[1] = getSourcepathAsString();
                for (int k = 0; k < options.size(); k++) {
                    javadocargs[numExtraArgs+k] = (String)options.elementAt(k);
                }
                for (int k = 0; k < packageList.size(); k++) {
                    javadocargs[numExtraArgs+options.size() + k] = (String)packageList.elementAt(k);
                }
                for (int k = 0; k < fileList.size(); k++) {
                    javadocargs[numExtraArgs+options.size() + packageList.size() + k] = (String)fileList.elementAt(k);
                }
            }
            else {
                javadocargs = new String[options.size() + signatureFiles.length];
                for (int k = 0; k < options.size(); k++) {
                    javadocargs[k] = (String)options.elementAt(k);
                }
                for (int k = 0; k < signatureFiles.length; k++) {
                    javadocargs[options.size() + k] = StructureUtil.translateAjPathName(signatureFiles[k].getCanonicalPath());
                }
            }
         
            JavadocRunner.callJavadoc(javadocargs);
            //for ( int o = 0; o < inputFiles.length; o++ ) {
            //    System.out.println( "file: " + inputFiles[o] );
            //}
======= fetch "public static void main(String[] args) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            /** We start with the known HTML files (the ones that correspond directly to the
            * input files.)  As we go along, we may learn that Javadoc split one .java file
            * into multiple .html files to handle inner classes or local classes.  The html
            * file decorator picks that up.
            */
            System.out.println( "> Decorating html files..." );
            HtmlDecorator.decorateHTMLFromInputFiles(declIDTable,
                                              rootDir,
                                              inputFiles,
                                              docModifier); 
            
            System.out.println( "> Removing generated tags (this may take a while)..." );
            removeDeclIDsFromFile("index-all.html", true);
            removeDeclIDsFromFile("serialized-form.html", true);
            if (packageList.size() > 0) {
            } else {
            	files = FileUtil.listFiles(rootDir, new FileFilter() {
            		public boolean accept(File f) {
            	});
            	for (int j = 0; j < files.length; j++) {
            		removeDeclIDsFromFile(files[j].getAbsolutePath(), false);
            	}
            }
======= fetch "public boolean accept(File f) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

    private static void callAjc(File[] inputFiles) {
        ajcOptions.addElement("-noExit");
        ajcOptions.addElement("-d"); 
        ajcOptions.addElement(rootDir.getAbsolutePath());
        int i = 0;
        for ( ; i < ajcOptions.size(); i++ ) {
            argsToCompiler[i] = (String)ajcOptions.elementAt(i);
        }
        for ( int j = 0; j < inputFiles.length; j++) {
            argsToCompiler[i] = inputFiles[j].getAbsolutePath();
            //System.out.println(">> file to ajc: " + inputFiles[j].getAbsolutePath());
            i++;
        }
        System.out.println( "> Calling ajc..." );
        CompilerWrapper.main(argsToCompiler);
    }
    
    private static void callJavadoc(File[] signatureFiles) throws IOException {
        System.out.println( "> Calling javadoc..." );
        String[] javadocargs = null;
        if ( packageMode ) {
            int numExtraArgs = 2;
            if (authorStandardDocletSwitch) numExtraArgs++;
            if (versionStandardDocletSwitch) numExtraArgs++;
            javadocargs = new String[numExtraArgs + options.size() + packageList.size() +
                                     fileList.size() ];
            javadocargs[0] = "-sourcepath";
            javadocargs[1] = outputWorkingDir;
            int argIndex = 2;
            if (authorStandardDocletSwitch) {
                javadocargs[argIndex] = "-author";
                argIndex++;
            }
            if (versionStandardDocletSwitch) {
                javadocargs[argIndex] = "-version";
            }
            //javadocargs[1] = getSourcepathAsString();
            for (int k = 0; k < options.size(); k++) {
                javadocargs[numExtraArgs+k] = (String)options.elementAt(k);
            }
            for (int k = 0; k < packageList.size(); k++) {
                javadocargs[numExtraArgs+options.size() + k] = (String)packageList.elementAt(k);
            }
            for (int k = 0; k < fileList.size(); k++) {
                javadocargs[numExtraArgs+options.size() + packageList.size() + k] = (String)fileList.elementAt(k);
            }
        }
        else {
            javadocargs = new String[options.size() + signatureFiles.length];
            for (int k = 0; k < options.size(); k++) {
                javadocargs[k] = (String)options.elementAt(k);
            }
            for (int k = 0; k < signatureFiles.length; k++) {
                javadocargs[options.size() + k] = StructureUtil.translateAjPathName(signatureFiles[k].getCanonicalPath());
            }
        }
     
        JavadocRunner.callJavadoc(javadocargs);    	
    }
    
    /** 
     * We start with the known HTML files (the ones that correspond directly to the
     * input files.)  As we go along, we may learn that Javadoc split one .java file
     * into multiple .html files to handle inner classes or local classes.  The html
     * file decorator picks that up.
     */
    private static void decorateHtmlFiles(File[] inputFiles) throws IOException {
        System.out.println( "> Decorating html files..." );
        HtmlDecorator.decorateHTMLFromInputFiles(declIDTable,
                                          rootDir,
                                          inputFiles,
                                          docModifier); 
        
        System.out.println( "> Removing generated tags (this may take a while)..." );
        removeDeclIDsFromFile("index-all.html", true);
        removeDeclIDsFromFile("serialized-form.html", true);
        if (packageList.size() > 0) {
            for (int p = 0; p < packageList.size(); p++) {
                removeDeclIDsFromFile(((String)packageList.elementAt(p)).replace('.','/') +
                                       Config.DIR_SEP_CHAR +
                                       "package-summary.html", true);
            }
        } else {
        	files = FileUtil.listFiles(rootDir, new FileFilter() {
        		public boolean accept(File f) {
        	});
        	for (int j = 0; j < files.length; j++) {
        		removeDeclIDsFromFile(files[j].getAbsolutePath(), false);
        	}
        }    	
    }
    
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            if ( addNextAsClasspath ) {
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            if ( addNextAsSourcePath ) {
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            }
            else if ( arg.equals( "-argfile" ) ) {
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            }
            else if ( addNextAsArgFile ) {
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            }
            else if (arg.equals("-d") ) {
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            }
            else if ( arg.equals( "-bootclasspath" ) ) {
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            } 
            else if ( arg.equals( "-source" ) ) {
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            }
            else if ( arg.equals( "-classpath" ) ) {
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            }
            else if ( arg.equals( "-encoding" ) ) {
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            }
            else if ( arg.equals( "-docencoding" ) ) {
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            }
            else if ( arg.equals( "-charset" ) ) {
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            }
            else if ( arg.equals( "-sourcepath" ) ) {
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            }
            else if (arg.equals("-XajdocDebug")) {
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            } 
            else if (arg.equals("-use")) {
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            } 
            else if (arg.equals("-splitindex")) {
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            } 
            else if (arg.startsWith("-") || addNextAsOption) {
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

                }else if ( arg.equals( "-package" ) ) {
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            } 
            else { 
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

                if (FileUtil.hasSourceSuffix(arg)
                	|| arg.endsWith(".lst") 
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

                         filenames.addElement(arg);
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" efe6cc7^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

                         filenames.addElement( currentWorkingDir + Config.DIR_SEP_CHAR + arg );

======= fetch "public void testNPEWithLTWPointcutLibraryAndMissingAspectDependency_pr158957 ()" 044542c^:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testNoNPEWithThrownExceptionWarningAndAtAspectj_pr161217() {runTest("NPE with thrown exception warning and at aspectj");}
    <ajc-test dir="bugs153/pr161217" title="NPE with thrown exception warning and at aspectj">
      <compile files="AtAspectJAspect.java, C.java" options="-warn:+unusedThrown -1.5"/>
    </ajc-test>
======= fetch "public void implementOn(Shadow s) {" 044542c^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

        		&& !thrownExceptions.isEmpty()) {

======= fetch "public void testBuildingTwoProjectsInTurns() {" bc2f36f^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= fetch "private File getProjectOutputRelativePath(String p,String filename) {" bc2f36f^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


======= fetch "protected boolean doBuild(" f7508cf^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

                String configFileProxy = buildConfig.getOutputDir().getAbsolutePath() 
            		+ File.separator 
            		+ CROSSREFS_FILE_NAME; 
            	AsmManager.getDefault().writeStructureModel(configFileProxy);

======= fetch "public void testIPEsWithSameNameHaveUniqueHandles_set() {" d532892^:"tests/src/org/aspectj/systemtest/ajc153/JDTLikeHandleProviderTests.java"

    <ajc-test dir="features153/jdtlikehandleprovider" title="advice with same name in injar aspect should have unique handles">
      <compile files="ClassForAspectpath.java" options="-emacssym" aspectpath="jarForAspectPath.jar">
        <message kind="warning" text="blah"/>
        <message kind="warning" text="blah2"/>
      </compile>
    </ajc-test>
    <ajc-test dir="features153/jdtlikehandleprovider" title="declare warnings in injar aspect should have unique handles">
      <compile files="ClassForAspectpath.java" options="-emacssym" aspectpath="jarForAspectPath.jar">
        <message kind="warning" text="blah"/>
        <message kind="warning" text="blah2"/>
      </compile>
    </ajc-test>
    <ajc-test dir="features153/jdtlikehandleprovider" title="dont increment counter for different declares">
      <compile files="ClassForAspectpath.java" options="-emacssym" aspectpath="declare.jar">
        <message kind="warning" text="warning"/>
        <message kind="error" text="error"/>
      </compile>
    </ajc-test>
    <ajc-test dir="features153/jdtlikehandleprovider" title="dont increment counter for different advice kinds">
      <compile files="ClassForAspectpath.java" options="-emacssym" aspectpath="advice.jar"/>
    </ajc-test>
======= fetch "private void addChildNodes(IProgramElement parent, Collection children) {" d532892^:"weaver/src/org/aspectj/weaver/ShadowMunger.java"

    	int afterCtr = 1;
    	int aroundCtr = 1;
    	int beforeCtr = 1;
    	int deCtr = 1;
    	int dwCtr = 1;
======= fetch "private void addChildNodes(IProgramElement parent, Collection children) {" d532892^:"weaver/src/org/aspectj/weaver/ShadowMunger.java"

======= fetch "private void addChildNodes(IProgramElement parent, Collection children) {" d532892^:"weaver/src/org/aspectj/weaver/ShadowMunger.java"

======= fetch "private void addChildNodes(IProgramElement parent, Collection children) {" d532892^:"weaver/src/org/aspectj/weaver/ShadowMunger.java"

    private IProgramElement createDeclareErrorOrWarningChild(
    		DeclareErrorOrWarning decl, int count) {
    			decl.getName(),
    			decl.isError() ? IProgramElement.Kind.DECLARE_ERROR : IProgramElement.Kind.DECLARE_WARNING,
    			getBinarySourceLocation(decl.getSourceLocation()),
    			decl.getDeclaringType().getModifiers(),
    			null,null); 
    	deowNode.setDetails("\"" + AsmRelationshipUtils.genDeclareMessage(decl.getMessage()) + "\"");
    	if (count != -1) {
    		deowNode.setBytecodeName(decl.getName() + "_" + count);
    	}
    	return deowNode;
    }
    
    private IProgramElement createAdviceChild(BcelAdvice advice, int counter ) {
    			advice.kind.getName(),
    			IProgramElement.Kind.ADVICE,
    			getBinarySourceLocation(advice.getSourceLocation()),
    			advice.signature.getModifiers(),null,Collections.EMPTY_LIST);
    	adviceNode.setDetails(AsmRelationshipUtils.genPointcutDetails(advice.getPointcut()));
    	if (counter != 1) {
    	return adviceNode;
    }
    
======= fetch "public DeclareErrorOrWarning(boolean isError, Pointcut pointcut, String message)" d532892^:"weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java"

======= fetch "public String getNameSuffix() {" d532892^:"weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java"


    
    // ------------------ affected types
    static class Untyped {
        void untypedName() {} // declare warning 16
        void untypedPrefix_blah() {} // declare warning 17
        void blah_untypedSuffix() {} // declare warning 18       
    }
    
    static class Star {
        void starName() {} // declare warning 22
        void starPrefix_blah() {} // declare warning 23
        void blah_starSuffix() {} // declare warning  24      
    }
    static class Type{
        void typeName() {} // declare warning 27
        void typePrefix_blah() {} // declare warning 28
        void blah_typeSuffix() {} // declare warning 29      
    }
    
    static class TypePlus {    
        void typeplusName() {} // declare warning 33
        void typeplusPrefix_blah() {} // declare warning 34
        void blah_typeplusSuffix() {} // declare warning 35              
    }
    static class TypePlusSubtype extends TypePlus {
        void typeplusName() {} // declare warning 39
        void typeplusPrefix_blah() {} // declare warning 40
        void blah_typeplusSuffix() {} // declare warning  41              
    }
    
    // ------------------ tests
    declare @method: * untypedName() : @MtAn;
    declare @method: * untypedPrefix*() : @MtAn;
    declare @method: * *untypedSuffix() : @MtAn;
    declare @method: * *.starName() : @MtAn;
    declare @method: * *.starPrefix*() : @MtAn;
    declare @method: * *.*starSuffix() : @MtAn;
    
    declare @method: * Type.typeName() : @MtAn;
    declare @method: * Type.typePrefix*() : @MtAn;
    declare @method: * Type.*typeSuffix() : @MtAn;
    
    declare @method: * TypePlus+.typeplusName() : @MtAn;
    declare @method: * TypePlus+.typeplusPrefix*() : @MtAn;
    declare @method: * TypePlus+.*typeplusSuffix() : @MtAn;
    // ------------------ check using warnings, expected in .xml
    declare warning : execution(@MtAn * *()): "all";
  public void testDeclareMethodAnnotations_pr159143() { runTest("declare method annotations");}
     <ajc-test dir="bugs153/pr159143" title="declare method annotations">
        <compile files="DeclareMethodAnnotation.java" options="-1.5">
            <message line="16" kind="warning" text="all"/>
            <message line="17" kind="warning" text="all"/>
            <message line="18" kind="warning" text="all"/>
            <message line="22" kind="warning" text="all"/>
            <message line="23" kind="warning" text="all"/>
            <message line="24" kind="warning" text="all"/>
            <message line="27" kind="warning" text="all"/>
            <message line="28" kind="warning" text="all"/>
            <message line="29" kind="warning" text="all"/>
            <message line="33" kind="warning" text="all"/>
            <message line="34" kind="warning" text="all"/>
            <message line="35" kind="warning" text="all"/>
            <message line="39" kind="warning" text="all"/>
            <message line="40" kind="warning" text="all"/>
            <message line="41" kind="warning" text="all"/>
        </compile>
    </ajc-test>
    

    private class Inner{
    	private void myMethod(){
    	}
    }
    private class Inner{
    	private void myMethod(){
    	}
    }
======= fetch "public void testNPEWithCustomAgent_pr158005() {" 782ade2^:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

    /////////////////////////////////////////
======= fetch "private TypePattern resolveBindingsFromFullyQualifiedTypeName(String fullyQualif" 782ade2^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "private UnresolvedType lookupTypeInScope(IScope scope, String typeName, IHasPosi" 782ade2^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"


======= fetch "public void startElement(String uri, String localName, String qName, Attributes" 7b831ff^:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

            String typePattern = attributes.getValue(WITHIN_ATTRIBUTE);
======= fetch "public void startElement(String uri, String localName, String qName, Attributes" 7b831ff^:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

            String typePattern = attributes.getValue(WITHIN_ATTRIBUTE);
======= fetch "public void startElement(String uri, String localName, String qName, Attributes" 7b831ff^:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

            String typePattern = attributes.getValue(WITHIN_ATTRIBUTE);
======= fetch "public void startElement(String uri, String localName, String qName, Attributes" 7b831ff^:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

            String typePattern = attributes.getValue(WITHIN_ATTRIBUTE);
======= fetch "public void startElement(String uri, String localName, String qName, Attributes" 7b831ff^:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

            String typePattern = attributes.getValue(WITHIN_ATTRIBUTE);
======= fetch "public void startElement(String uri, String localName, String qName, Attributes" 7b831ff^:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

    public static void main(String argz[]) {
        foo();
    }
    public static void foo() {
        (new pkg.sub.Foo()).foo();
        
        File dumpDir = new File("_ajdump"); 
        lsLR(dumpDir);
        
        // the LTW harness should clean up _ajdump files!
        cleanup(dumpDir);
    }
    
    public static void lsLR(File dir) {
        String[] files = dir.list();
        if (files == null) return;
        for (int i=0; i<files.length; i++) {
        	File f = new File(dir, files[i]);
        	if (f.isFile()) {
        		System.err.println(files[i]);
        	} else {
        		lsLR(f);
        	}
        }    	
    }
    
    public static void cleanup(File dir) {
        String[] files = dir.list();
        if (files == null) return;
        for (int i=0; i<files.length; i++) {
        	File f = new File(dir, files[i]);
        	if (f.isFile()) {
        		f.delete();
        	} else {
        		cleanup(f);
        	}
        }    	
    }
    public void foo() {}
    before() : execution(* foo()) {
        System.err.println(thisJoinPoint);
    }
    before() : staticinitialization(pkg..*) {
        System.err.println(thisJoinPoint);
    }
    before() : staticinitialization(pkg..*) {
        System.err.println("sub: "+thisJoinPoint);
    }
======= fetch "protected File getSpecFile() {" 7b831ff^:"tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.java"

  public void testInclusionAndPattern() {
    runTest("Inclusion and patterns");  		
  }
  public void testExclusionAndPattern() {
  }
  public void testAndPatternsAspects() {
  }
      
        <compile
        	files="pkg\sub\Foo.aj, pkg\Main.aj"
        	options="-outjar base.jar"
        />
        <compile
        	files="tracing/Tracer.aj"
        />
        <run class="pkg.Main" ltw="aop-include.xml">
            <stderr>
                <line text="execution(void pkg.Main.foo())"/>
                <line text="Main.class"/>
            </stderr>
        </run>
    </ajc-test>
        <compile
        	files="pkg\sub\Foo.aj, pkg\Main.aj"
        	options="-outjar base.jar"
        />
        <compile
        	files="tracing/Tracer.aj"
        />
        <run class="pkg.Main" ltw="aop-exclude.xml">
            <stderr>
                <line text="execution(void pkg.sub.Foo.foo())"/>
            </stderr>
        </run>
    </ajc-test>    
        <compile
        	files="pkg\sub\Foo.aj, pkg\Main.aj"
        	options="-outjar base.jar"
        />
        <compile
        	files="tracing/Tracer.aj, tracing/staticinit/Tracer.aj, tracing/staticinit/sub/Tracer.aj"
        />
        <run class="pkg.Main" ltw="aop-aspectinclexcl.xml">
            <stderr>
                <line text="staticinitialization(pkg.Main.&lt;clinit&gt;)"/>
                <line text="staticinitialization(pkg.sub.Foo.&lt;clinit&gt;)"/>
            </stderr>
        </run>
    </ajc-test>       

======= fetch "public void testShouldFullBuildOnExceptionChange_pr154054() {" cd9fd11^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= fetch "public boolean replaceWith(CrosscuttingMembers other,boolean careAboutShadowMung" cd9fd11^:"weaver/src/org/aspectj/weaver/CrosscuttingMembers.java"

======= fetch "public boolean replaceWith(CrosscuttingMembers other,boolean careAboutShadowMung" cd9fd11^:"weaver/src/org/aspectj/weaver/CrosscuttingMembers.java"

======= fetch "public boolean hasMatchedSomething() {" cd9fd11^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"


    public ValueChange(Q initValue) { }
        super(initValue);
    }
    public final synchronized void link(SyncValueGroup<T> ... list) {    }
    class SyncInteger extends SyncValueGroup<Integer> {
        public SyncInteger(int val) {
            super(new Integer(val));
        }
    }
    private SyncInteger a = new SyncInteger(1);
    public void testSyncValueGroup() {
        a.link(a);
    }
  before(): call(* *(..)) {}
 
  public void testGenericArrays_pr158624() { runTest("generics and arrays"); }
    
      <compile files="ValueChange.java" options="-1.5"/>
    </ajc-test> 
======= fetch "public ResolvedMemberImpl parameterizedWith(UnresolvedType[] typeParameters,Reso" ea4ff8a^:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

======= fetch "public ResolvedMemberImpl parameterizedWith(UnresolvedType[] typeParameters,Reso" ea4ff8a^:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

======= fetch "protected UnresolvedType parameterize(UnresolvedType aType, Map typeVariableMap," ea4ff8a^:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"


======= fetch "protected String generateJavadocComment(ASTNode astNode) {" fc39df1^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= fetch "protected String genSourceSignature(FieldDeclaration fieldDeclaration) {" fc39df1^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

    static final Comparator MY_COMPARATOR = new Comparator() {
        public int compare(Object o1, Object o2) {
            return 0;
        }
    };
======= fetch "public void testDeclareSoftAndInnerClasses_pr125981() {" fc39df1^:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  /////////////////////////////////////////

======= fetch "public boolean isAnnotationStyleAspect() {" e56a69a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

    
    /** Returns "" if there is a problem */
    private String getPointcutStringFromAnnotationStylePointcut(AbstractMethodDeclaration amd) {
    	Annotation[] ans = amd.annotations;
    }
======= fetch "private ResolvedPointcutDefinition makeResolvedPointcutDefinition(AbstractMethod" e56a69a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

======= fetch "private ResolvedPointcutDefinition makeResolvedPointcutDefinition(AbstractMethod" e56a69a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

======= fetch "private ResolvedPointcutDefinition makeResolvedPointcutDefinition(AbstractMethod" e56a69a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

    declare warning : (layering.SystemArchitektur.inDAOLayer() ) : "Whatever";
    @Pointcut("within(dao.*)")
    public void inDAOLayer() {}
    
  public void testAnnotationStylePointcutNPE_pr158412() { runTest("annotation style pointcut npe"); }
  public void testAnnotationStylePointcutNPE_pr158412_2() { runTest("annotation style pointcut npe - 2"); }
    <ajc-test dir="bugs153/pr158412" title="annotation style pointcut npe">
      <compile files="layering/Layering.aj,layering/SystemArchitektur.java" options="-1.5"/>
    </ajc-test>
    <ajc-test dir="bugs153/pr158412" title="annotation style pointcut npe - 2">
      <compile files="layering/Layering.aj,layering/SystemArchitektur.java,dao/Foo.java" options="-1.5">
        <message kind="warning" line="3" text="Whatever"/>
      </compile>
    </ajc-test>
    

  declare parents: Aspect implements Interface;
  public void testIllegalStateExceptionGenerics_pr153845() { runTest("IllegalStateException at GenericSignatureParser.java"); }
    <ajc-test dir="bugs153/pr153845" title="IllegalStateException at GenericSignatureParser.java">
      <compile files="GenericType.java,Aspect.java,Aspect2.java,Interface.java" options="-1.5" outjar="blob.jar"/>
      <compile files="Nothing.java" aspectpath="blob.jar" options="-1.5" outjar="bang.jar"/>
    </ajc-test>
======= fetch "private static String makeDeclaredSignature(ResolvedType aGenericType, Unresolve" 70ae0f8^:"weaver/src/org/aspectj/weaver/ReferenceType.java"


======= fetch "public Constructor getConstructor() {" 090de7e^:"runtime/src/org/aspectj/runtime/reflect/ConstructorSignatureImpl.java"

======= fetch "public Field getField() {" 090de7e^:"runtime/src/org/aspectj/runtime/reflect/FieldSignatureImpl.java"

======= fetch "public Constructor getInitializer() {" 090de7e^:"runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.java"

======= fetch "public void testReweavableAspectNotRegistered_pr129525 () {" 090de7e^:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testNPEinConstructorSignatureImpl_pr155972 () {
  }
  
  public void testNPEinFieldSignatureImpl_pr155972 () {
  }
  
  public void testNPEinInitializerSignatureImpl_pr155972 () {
  }
  
    <ajc-test dir="bugs153/pr155972" title="NPE in ConstructorSignatureImpl">
      <compile files="ConstructorTest.java, SignatureImplAspect.aj" options="-Xlint:ignore"/>
      <run class="ConstructorTest">
        <stdout>
          <line text="ConstructorTest"/>
        </stdout>
      </run>
    </ajc-test>
    
    <ajc-test dir="bugs153/pr155972" title="NPE in FieldSignatureImpl">
      <compile files="FieldTest.java, SignatureImplAspect.aj" options="-Xlint:ignore"/>
      <run class="FieldTest">
        <stdout>
          <line text="intField"/>
        </stdout>
      </run>
    </ajc-test>
    
    <ajc-test dir="bugs153/pr155972" title="NPE in InitializerSignatureImpl">
      <compile files="InitializerTest.java, SignatureImplAspect.aj" options="-Xlint:ignore"/>
      <run class="InitializerTest">
        <stdout>
          <line text="InitializerTest"/>
        </stdout>
      </run>
    </ajc-test>
    

======= fetch "public String getClassLoaderName() {" 14e8b7d^:"loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java"

    	return ((loader!=null)?loader.getClass().getName()+"@"+Integer.toHexString(loader.hashCode()):"null");
======= fetch "public String getClassLoaderName() {" 14e8b7d^:"weaver/src/org/aspectj/weaver/tools/AbstractTrace.java"


======= fetch "public String getClassLoaderName() {" 6be7097^:"loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java"

    	return ((loader!=null)?loader.getClass().getName()+"@"+loader.hashCode():"null");
======= fetch "public String getClassLoaderName() {" 6be7097^:"weaver/src/org/aspectj/weaver/tools/AbstractTrace.java"

======= fetch "public String getClassLoaderName() {" 6be7097^:"weaver/src/org/aspectj/weaver/tools/AbstractTrace.java"

======= fetch "protected String formatArgs(Object[] args) {" 6be7097^:"weaver/src/org/aspectj/weaver/tools/AbstractTrace.java"

======= fetch "public void testEnterWithThisAndArray() {" 6be7097^:"weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.java"

======= fetch "public void testEnterWithThisAndCollection() {" 6be7097^:"weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.java"

======= fetch "public String toTraceString() {" 6be7097^:"weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.java"

======= fetch "public String toTraceString() {" 6be7097^:"weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.java"

======= fetch "public void enter(String methodName, Object thiz, Object[] args) {" 6be7097^:"weaver5/java5-src/org/aspectj/weaver/tools/Jdk14Trace.java"

======= fetch "public void exit(String methodName, Object ret) {" 6be7097^:"weaver5/java5-src/org/aspectj/weaver/tools/Jdk14Trace.java"

======= fetch "public void event(String methodName, Object thiz, Object[] args) {" 6be7097^:"weaver5/java5-src/org/aspectj/weaver/tools/Jdk14Trace.java"


======= fetch "public OptionsFrame(IconRegistry icons) {" 40cf610^:"ajde/src/org/aspectj/ajde/ui/swing/OptionsFrame.java"

    public static final long time;
    // if not DEVELOPMENT version, read time text using format used to set time 
    static {
        long foundTime = NOTIME;
        time = foundTime;
======= fetch "public void testVersion() {" 40cf610^:"bridge/testsrc/org/aspectj/bridge/VersionTest.java"

        Date date = new Date(Version.time);
======= fetch "public void write(DataOutputStream s) throws IOException {" 40cf610^:"weaver/src/org/aspectj/weaver/AjAttribute.java"


======= fetch "private void registerAspects(final BcelWeaver weaver, final ClassLoader loader," 04fa1dc^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

    	boolean success = true;
    	
======= fetch "private void registerAspects(final BcelWeaver weaver, final ClassLoader loader," 04fa1dc^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

                        success = false;
======= fetch "private void registerAspects(final BcelWeaver weaver, final ClassLoader loader," 04fa1dc^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        /* We couldn't register one or more aspects so disable the adaptor */
        if (!success) {
        	disable();
    		warn("failure(s) registering aspects. Disabling weaver for class loader " + getClassLoaderName(loader));
        }
        
======= fetch "private void registerAspects(final BcelWeaver weaver, final ClassLoader loader," 04fa1dc^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        if (namespace == null) {
======= fetch "public WeavingURLClassLoader (URL[] urls, ClassLoader parent) {" 04fa1dc^:"loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java"

======= fetch "public WeavingURLClassLoader (URL[] urls, ClassLoader parent) {" 04fa1dc^:"loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java"

======= fetch "protected Class defineClass(String name, byte[] b, CodeSource cs) throws IOExcep" 04fa1dc^:"loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java"

======= fetch "protected Class defineClass(String name, byte[] b, CodeSource cs) throws IOExcep" 04fa1dc^:"loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java"

======= fetch "protected Class defineClass(String name, byte[] b, CodeSource cs) throws IOExcep" 04fa1dc^:"loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java"

            <line text="warning register definition failed"/>
            <line text="warning register definition failed"/>
======= fetch "public void testParsingBytecodeLess_pr152871() {" 04fa1dc^:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testReweavableAspectNotRegistered_pr129525 () {
  }
  
    <ajc-test dir="ltw" title="reweavableAspectNotRegistered error">
      <compile files="HelloWorld.java, ExceptionHandler.aj" options="-showWeaveInfo">
        <message kind="weave" text="Join point 'method-execution(void HelloWorld.main(java.lang.String[]))' in Type 'HelloWorld' (HelloWorld.java:3) advised by around advice from 'ExceptionHandler' (ExceptionHandler.aj:2)"/>
      </compile>
      <compile files="EmptyAspect.aj">
      </compile>
      <run class="HelloWorld" ltw="aop-missingaspect.xml">
        <stdout>
          <line text="Hello World!"/>
        </stdout>
        <stderr>
        	<line text="error aspect 'ExceptionHandler' woven into 'HelloWorld' must be defined to the weaver (placed on the aspectpath, or defined in an aop.xml file if using LTW)."/>
        </stderr>
      </run>
    </ajc-test>
    
======= fetch "private void init(List classPath, List aspectPath) {" 04fa1dc^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "protected void disable () {" 04fa1dc^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "protected void disable () {" 04fa1dc^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public boolean handleMessage(IMessage message) throws AbortException {" 04fa1dc^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public boolean handleMessage(IMessage message) throws AbortException {" 04fa1dc^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"


======= fetch "private void defineClass(ClassLoader loader, String name, byte[] bytes) {" 8549d86^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

    boolean isDebug = false;
======= fetch "public boolean isIgnoring(IMessage.Kind kind) {" 8549d86^:"loadtime/src/org/aspectj/weaver/loadtime/DefaultMessageHandler.java"

        if (kind.isSameOrLessThan(IMessage.DEBUG)) {
            return !isDebug;
        }
    private final static String OPTION_debug = "-debug";
======= fetch "public static WeaverOption parse(String options, ClassLoader laoder, IMessageHan" 8549d86^:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

            }  else if (arg.equalsIgnoreCase(OPTION_debug)) {
                weaverOption.debug = true;
======= fetch "public static WeaverOption parse(String options, ClassLoader laoder, IMessageHan" 8549d86^:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

        if (weaverOption.debug) {
            weaverOption.messageHandler.dontIgnore(IMessage.DEBUG);
        }
======= fetch "public static WeaverOption parse(String options, ClassLoader laoder, IMessageHan" 8549d86^:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

    <target name="javac.ltw" depends="compile:javac, ltw"/>
    <target name="ltw.oldAspectsDeclared">
======= fetch "public boolean handleMessage(IMessage message) throws AbortException {" 8549d86^:"tests/java5/ataspectj/ataspectj/TestHelper.java"

        if (message.getKind().isSameOrLessThan(IMessage.INFO)) {
            ;
        } else {
    <weaver options="-XlazyTjp -verbose">
    <weaver options="-verbose"/>
    <weaver options="-showWeaveInfo -verbose"/>
    <weaver options="-verbose -showWeaveInfo"/>
    <weaver options="-verbose -showWeaveInfo -Xlint:warning"/>
    <weaver options="-verbose -showWeaveInfo -Xlintfile:Xlint-nomatch.properties"/>
        <ant file="ajc-ant.xml" target="javac.ltw" verbose="true"/>
        		<line text="info not weaving 'com.foo.bar.Test$$EnhancerByCGLIB$$12345'"/>
        		<line text="info weaving 'com.foo.bar.Test'"/>
        <ant file="ajc-ant.xml" target="ltw.oldAspectsDeclared" verbose="true"/>
            options="-showWeaveInfo"
            options="-showWeaveInfo"
                <line text="info generating class 'ConcreteAspect'"/>
                <line text="info weaving 'Main'"/>
          <line text="info weaving"/>
          <line text="info not weaving"/>
======= fetch "public void addURL(URL url) {" 8549d86^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public void addURL(URL url) {" 8549d86^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public void addURL(URL url) {" 8549d86^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public void addURL(URL url) {" 8549d86^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "private static List makeClasspath(String cp) {" 8549d86^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public WeavingAdaptorMessageWriter (PrintWriter writer) {" 8549d86^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

            ignore(IMessage.DEBUG);

  @After("staticinitialization(*)")
  public void x(JoinPoint.StaticPart thisJoinPointStaticPart) {
    System.out.println("after initialization "+thisJoinPointStaticPart);
  }
  static {
  }
  public static void main(String []argv) {
  }
  after(): staticinitialization(*) {
    System.out.println("after initialization "+thisJoinPointStaticPart);
  }
  static {
  }
  public static void main(String []argv) {
    System.out.println("InstanceExists?"+Aspects.hasAspect(MyAspect.class));
  }
  public void testIncorrectStaticinitializationWeaving_pr149560_1() { runTest("incorrect staticinitialization weaving - codestyle");}
  public void testIncorrectStaticinitializationWeaving_pr149560_2() { runTest("incorrect staticinitialization weaving - annstyle");}
  public void testIncorrectDeprecatedAnnotationProcessing_pr154332() { runTest("incorrect deprecated annotation processing");}
    <ajc-test dir="bugs153/pr149560" title="incorrect staticinitialization weaving - codestyle">
      <compile files="CodeStyle.java" options="-1.5 -showWeaveInfo">
        <message kind="weave" text="Join point 'staticinitialization(void MyAspect.&lt;clinit&gt;())' in Type 'MyAspect' (CodeStyle.java:3) advised by after advice from 'MyAspect' (CodeStyle.java:4)"/>
        <message kind="weave" test="Join point 'staticinitialization(void CodeStyle.&lt;clini&gt;())' in Type 'CodeStyle' (CodeStyle.java:9) advised by after advice from 'MyAspect' (CodeStyle.java:4)"/>
      </compile>
      <run class="CodeStyle">
        <stdout>
          <line text="after initialization staticinitialization(MyAspect.&lt;clinit&gt;)"/>
          <line text="after initialization staticinitialization(CodeStyle.&lt;clinit&gt;)"/>
          <line text="InstanceExists?true"/>
        </stdout>
      </run>
    </ajc-test>
    
    <ajc-test dir="bugs153/pr149560" title="incorrect staticinitialization weaving - annstyle">
      <compile files="AnnStyle.java" options="-1.5 -showWeaveInfo">
        <message kind="weave" text="Join point 'staticinitialization(void MyAspect.&lt;clinit&gt;())' in Type 'MyAspect' (AnnStyle.java:5) advised by after advice from 'MyAspect' (AnnStyle.java:7)"/>
        <message kind="weave" test="Join point 'staticinitialization(void AnnStyle.&lt;clini&gt;())' in Type 'AnnStyle' (AnnStyle.java:12) advised by after advice from 'MyAspect' (AnnStyle.java:7)"/>
      </compile>
      <run class="AnnStyle">
        <stdout>
          <line text="after initialization staticinitialization(MyAspect.&lt;clinit&gt;)"/>
          <line text="after initialization staticinitialization(AnnStyle.&lt;clinit&gt;)"/>
          <line text="InstanceExists?true"/>
        </stdout>
      </run>
    </ajc-test>
    
======= fetch "public void testPr141956_IncrementallyCompilingAtAj() {" 945a257^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= fetch "public void testPr141956_IncrementallyCompilingAtAj() {" 945a257^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= fetch "public void testPr141956_IncrementallyCompilingAtAj() {" 945a257^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= fetch "public void testPr141956_IncrementallyCompilingAtAj() {" 945a257^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= fetch "private void generatePerSingletonAjcClinitMethod(LazyClassGen classGen) {" 945a257^:"weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.java"

            tryStart, handler, handler, new ObjectType("java.lang.Throwable"), false
======= fetch "public PerClause concretize(ResolvedType inAspect) {" 945a257^:"weaver/src/org/aspectj/weaver/patterns/PerSingleton.java"

            inAspect.crosscuttingMembers.addLateTypeMunger(
                    inAspect.getWorld().makePerClauseAspect(inAspect, getKind())
            );

 
    pointcut test() : within(@Marker *);// *);
   
    declare warning: staticinitialization(@Deprecated *): "deprecated";   
    declare warning: staticinitialization(@Marker *): "marker";   
   
    public static void main(String argz[]) {
        new Baz().foo();
    }
 
    public void foo() {}
 
 @interface Marker {
 
    <ajc-test dir="bugs153/pr154332" title="incorrect deprecated annotation processing">
      <compile files="Annot.java" options="-1.5">
        <message kind="warning" line="5" text="marker"/>
        <message kind="warning" line="31" text="marker"/>
        <message kind="warning" line="5" text="deprecated"/>
        <message kind="warning" line="31" text="deprecated"/>
      </compile>
    </ajc-test>
    
======= fetch "private void ensureAnnotationsUnpacked() {" 59123b0^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"


======= fetch "public static ResolvedType resolve(World world, Class aClass) {" 82e3e13^:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= fetch "public void testGetSuperclass() {" 82e3e13^:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"

    public void testArrayArgsSig() throws Exception {
    	Method invokeMethod = Method.class.getMethod("invoke", new Class[] { Object.class, Object[].class});
    	ResolvedMember reflectionMethod = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMethod(invokeMethod, world);
    	String exp = "(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;";
    	assertTrue("Expected: \n"+exp+"\n but got:\n"+reflectionMethod.getSignature(), reflectionMethod.getSignature().equals(exp));
    }
======= fetch "public void testCompareSubclassDelegates() {" 82e3e13^:"weaver5/java5-testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"

    public void testArrayArgsSig() throws Exception {
    	Method invokeMethod = Method.class.getMethod("invoke", new Class[] { Object.class, Object[].class});
    	ResolvedMember reflectionMethod = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMethod(invokeMethod, world);
    	String exp = "(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;";
    	assertTrue("Expected: \n"+exp+"\n but got:\n"+reflectionMethod.getSignature(), reflectionMethod.getSignature().equals(exp));
    }

======= fetch "public void unusedArgument(LocalDeclaration localDecl) {" 07c2189^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

    	
    	// If the unused argument is in a pointcut, don't report the problem (for now... pr148219)
    	if (localDecl!=null && localDecl instanceof Argument) {
    		Argument arg = (Argument)localDecl;
    		if (arg.binding!=null && arg.binding.declaringScope!=null) {
    			ReferenceContext context = arg.binding.declaringScope.referenceContext();
    			if (context!=null && context instanceof PointcutDeclaration) return;
    		}
    	}
    pointcut getResourceString(String key): args(key, ..) &&
    call (* *.getResourceString(String, ..));
    String around(String key):getResourceString(key) {
        return key;
    }
  public void testUnwantedPointcutWarning_pr148219() { runTest("unwanted warning for pointcut");}
    <ajc-test dir="bugs153/pr148219" title="unwanted warning for pointcut">
      <compile files="MyMessages.java" options="-1.5 -Xlint:ignore -warn:+unusedArgument"/>
    </ajc-test>
    

======= fetch "private void registerOptions(final BcelWeaver weaver, final ClassLoader loader," 039be68^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        world.performExtraConfiguration(weaverOption.xSet);
    private static final String OPTIONVALUED_Xset = "-Xset:";
======= fetch "public static WeaverOption parse(String options, ClassLoader laoder, IMessageHan" 039be68^:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

            } else if (arg.startsWith(OPTIONVALUED_Xset)) {
                if (arg.length() > OPTIONVALUED_Xlint.length()) {
                    weaverOption.xSet = arg.substring(OPTIONVALUED_Xset.length()).trim();
                }            	
======= fetch "public static WeaverOption parse(String options, ClassLoader laoder, IMessageHan" 039be68^:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

        boolean java5;
======= fetch "public static WeaverOption parse(String options, ClassLoader laoder, IMessageHan" 039be68^:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

        String xSet;
======= fetch "public void testAspectsIncludeWithLintWarning () {" 039be68^:"tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.java"

  	public void testXsetEnabled () {
  		runTest("Set Xset properties enabled");
  	}
  	public void testXsetDisabled () {
  		runTest("Set Xset properties disabled");
  	}
  	
      title="Set Xset properties enabled"
      keywords="xSet, ltw">
        <compile
        	files="Main.java,Aspect1.aj"
        >
        </compile>	
        <run class="Main" ltw="aop-xset-verbose.xml" xlintfile="Xlint-empty.properties">
        </run>
    </ajc-test>
      title="Set Xset properties disabled"
      keywords="xSet, ltw">
        <compile
        	files="Main.java,Aspect1.aj"
        >
        </compile>	
        <run class="Main" ltw="aop-xset-verbose.xml" xlintfile="Xlint-empty.properties">
        </run>
    </ajc-test>
    

======= fetch "public static String addExtraSourceLocations(" a38edd3^:"bridge/src/org/aspectj/bridge/MessageUtil.java"


 * @version $Id: ClassLoaderRepository.java,v 1.5 2006/03/10 13:29:05 aclement Exp $
  implements Repository
  private WeakHashMap loadedClasses =
    new WeakHashMap(); // CLASSNAME X JAVACLASS
======= fetch "public ClassLoaderRepository( java.lang.ClassLoader loader ) {" 387c3ac^:"bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"

   * Store a new JavaClass into this repository as a soft reference and return the reference
   */
  private Reference storeClassAsReference( JavaClass clazz ) {
    loadedClassesLocalCache.put( clazz.getClassName(), ref);		       
    clazz.setRepository( this );
    return ref;
  }
  
  /**
   * Store a reference in the shared cache
   */
  private void storeReferenceShared(URL url, Reference ref) {
  }
  /**
======= fetch "public void storeClass( JavaClass clazz ) {" 387c3ac^:"bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"

    loadedClasses.put( clazz.getClassName(),
    clazz.setRepository( this );
======= fetch "public void removeClass(JavaClass clazz) {" 387c3ac^:"bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"

    loadedClasses.remove(clazz.getClassName());
======= fetch "public void removeClass(JavaClass clazz) {" 387c3ac^:"bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"

   * Find an already defined JavaClass.
======= fetch "public JavaClass findClass( String className ) {" 387c3ac^:"bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"

    if ( loadedClasses.containsKey( className )) {
      return (JavaClass) loadedClasses.get( className );
    } else {
      return null;
======= fetch "public JavaClass findClass( String className ) {" 387c3ac^:"bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"

    return null;
  }
  
  /**
   * Find an already defined JavaClass in the shared cache.
   */
  private JavaClass findClassShared(URL url) {
======= fetch "public JavaClass findClass( String className ) {" 387c3ac^:"bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"

  
======= fetch "public JavaClass findClass( String className ) {" 387c3ac^:"bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"

  public JavaClass loadClass( String className ) 
    throws ClassNotFoundException
  {
======= fetch "public JavaClass loadClass( String className )" 387c3ac^:"bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"

    JavaClass RC = findClass( className );
    if (RC != null) { return RC; }
======= fetch "public JavaClass loadClass( String className )" 387c3ac^:"bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"

      InputStream is = 
======= fetch "public JavaClass loadClass( String className )" 387c3ac^:"bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"

      if(is == null) {
      }
======= fetch "public JavaClass loadClass( String className )" 387c3ac^:"bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"

      ClassParser parser = new ClassParser( is, className );
      RC = parser.parse();
======= fetch "public JavaClass loadClass( String className )" 387c3ac^:"bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"

      storeClass( RC );
======= fetch "public JavaClass loadClass( String className )" 387c3ac^:"bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"

      return RC;
======= fetch "public JavaClass loadClass( String className )" 387c3ac^:"bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"

  
======= fetch "public JavaClass loadClass( String className )" 387c3ac^:"bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"

   * Produce a report on cache usage.
   */
  public String reportAllStatistics() {
  }
  
  public int reportLocalCacheHits() {
  }
  public static int reportSharedCacheHits() {
  }
  
  /**
   * Reset statistics and clear all caches
   */
  public void reset() {
  }
  
  
======= fetch "public JavaClass loadClass(Class clazz) throws ClassNotFoundException {" 387c3ac^:"bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"

  /** Clear all entries from cache.
   */
======= fetch "public void clear() {" 387c3ac^:"bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"

    loadedClasses.clear();
======= fetch "public static Test suite() {" 387c3ac^:"bcel-builder/testsrc/org/aspectj/apache/bcel/classfile/tests/AllTests.java"

 * Tests create a simple classloader repository configuration and check sharing of information.
 */

            + File.pathSeparator + ".." + File.separator + "lib/bcel/bcel.jar";
======= fetch "public void testAspectOfWhenAspectNotInInclude() {" f239f2a^:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"

    public void testAspectOfWhenAspectExcluded_pr152873() {
        runTest("AspectOfWhenAspectExcluded");
    }
    public void testAspectOfWhenNonAspectExcluded_pr152873() {
    	runTest("AspectOfWhenNonAspectExcluded");
    }
    <ajc-test dir="java5/ataspectj" title="AspectOfWhenAspectExcluded">
        <compile
            files="ataspectj/bugs/AspectOfWhenAspectNotInIncludeTest.java,ataspectj/TestHelper.java"
            options="-1.5 -XterminateAfterCompilation"/>
        <run class="ataspectj.bugs.AspectOfWhenAspectNotInIncludeTest" ltw="ataspectj/bugs/aop-aspectofwhenaspectexcludedtest.xml"/>
    </ajc-test>
    <ajc-test dir="java5/ataspectj" title="AspectOfWhenNonAspectExcluded">
        <compile
            files="ataspectj/bugs/NotAspect.java"
            options="-1.5 -XterminateAfterCompilation"/>
        <run class="ataspectj.bugs.NotAspect" ltw="ataspectj/bugs/aop-aspectofwhennonaspectexcludedtest.xml"/>
    </ajc-test>
======= fetch "public void setSynchronizationPointcutsInUse() {" f239f2a^:"weaver/src/org/aspectj/weaver/World.java"

 * Copyright (c) 2006 Contributors
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *     Eugene Kuleshov, Ron Bodkin    initial implementation 
 * ******************************************************************/
======= fetch "public void addURL(URL url) {" f239f2a^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public void addURL(URL url) {" f239f2a^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

     * @return true if should weave (but maybe we still need to munge it for @AspectJ aspectof support)
======= fetch "public void addURL(URL url) {" f239f2a^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

    private boolean shouldWeave (String name, byte[] bytes) {
        return b && accept(name, bytes);
======= fetch "private boolean shouldWeaveAnnotationStyleAspect(String name, byte[] bytes) {" f239f2a^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

        // we reuse bytes[] here to do a fast lookup for @Aspect annotation
======= fetch "private boolean shouldWeaveAnnotationStyleAspect(String name, byte[] bytes) {" f239f2a^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"


======= fetch "public static String makeLocationContext(ICompilationUnit compilationUnit, IProb" 908b405^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"

        if (begin==-1)
        	return "(no source information available)"; // Dont like this - why does it occur? pr152835

    before() : cflow(execution(* *(..))) {}
  declare parents: EMA extends C;
  public void EMA.m() {}
  abstract void m();
  public void testDecpAndCflowadderMungerClash_pr152631() { runTest("decp and cflowadder munger clash");}
    <ajc-test dir="bugs153/pr152631" title="decp and cflowadder munger clash">
      <compile files="EMA.java" options="-1.5"/>
    </ajc-test>
    
======= fetch "private boolean enforceDecpRule1_abstractMethodsImplemented(BcelClassWeaver weav" ff2377a^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

                            if (m.getMunger().getKind() == ResolvedTypeMunger.Method) {
======= fetch "private boolean enforceDecpRule1_abstractMethodsImplemented(BcelClassWeaver weav" ff2377a^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

                            } else if (m.getMunger().getKind() == ResolvedTypeMunger.MethodDelegate) {

======= fetch "public static String getLicense(String module) {" 7aa6cfe^:"build/testsrc/org/aspectj/build/BuildModuleTests.java"

            Arrays.asList(new String[]{"src", "testsrc", "java5-src", "aspectj-src"}));
======= fetch "public void testLicense_weaver() {" 7aa6cfe^:"build/testsrc/org/aspectj/build/BuildModuleTests.java"

        // skip (testdata) packages fluffy, reflect
======= fetch "public void testLicense_weaver() {" 7aa6cfe^:"build/testsrc/org/aspectj/build/BuildModuleTests.java"

    public void testLicense_ajdoc() {
        checkLicense("ajdoc");
    }
    
    public void testLicense_loadtime() {
        checkLicense("loadtime");
    }
    
    public void testLicense_loadtime5() {
        checkLicense("loadtime5");
    }
    
    public void testLicense_weaver5() {
        checkLicense("weaver5");
    }

======= fetch "public void beforeCompiling(ICompilationUnit[] sourceUnits) {" 9664058^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java"

======= fetch "public void afterCompiling(CompilationUnitDeclaration[] units) {" 9664058^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java"

======= fetch "private void queueForWeaving(InterimCompilationResult intRes) {" 9664058^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java"

    		weaveQueuedEntries();
======= fetch "private void notifyRequestor() {" 9664058^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java"

======= fetch "private void weaveQueuedEntries() throws IOException {" 9664058^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java"

======= fetch "private void weaveQueuedEntries() throws IOException {" 9664058^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java"

======= fetch "private void postWeave() {" 9664058^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java"

    after () throwing (Throwable th) :  execution(* *(..)) {
 
    after () throwing (Throwable th) :  execution(* *(..)) {
======= fetch "public void testPr134471_IncrementallyRecompilingTheClassAffectedByDeclare() {" 9664058^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


======= fetch "public static void premain(String options, Instrumentation instrumentation) {" bebb364^:"loadtime5/java5-src/org/aspectj/weaver/loadtime/Agent.java"

    	/* Handle duplicate agents */
    	if (s_instrumentation != null) {
    		return;
    	}
    public void dontIgnore(IMessage.Kind kind) {
    	
    }
    <target name="Duplicate JVMTI agents">
        <copy file="${aj.root}/tests/java5/ataspectj/aop-messagehandler.xml"
              tofile="${aj.sandbox}/META-INF/aop.xml"/>
        <java fork="yes" classname="HelloWorld" failonerror="yes">
            <classpath refid="aj.path"/>
            <!-- use META-INF/aop.xml style -->
            <classpath>
                <pathelement path="${aj.sandbox}/aspects.jar"/>
            </classpath>
            <jvmarg value="-javaagent:${aj.root}/lib/test/loadtime5.jar"/>
            <jvmarg value="-javaagent:${aj.root}/lib/test/loadtime5.jar"/>
            <jvmarg value="-Daj.weaving.verbose=true"/>
            <jvmarg value="-Djava.util.logging.config.file=${aj.root}/weaver5/testdata/logging.properties"/>
        </java>
    </target>
======= fetch "public void testVerificationFailureForAspectOf_pr148693() {" bebb364^:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  

   public void testMissingLineNumbersInStacktraceBefore_pr145442() { runTest("missing line numbers in stacktrace before");}
   public void testMissingLineNumbersInStacktraceAfter_pr145442() { runTest("missing line numbers in stacktrace after");}
   public void testMissingLineNumbersInStacktraceAround_pr145442() { runTest("missing line numbers in stacktrace around");}

                    RETURN
                    RETURN
                    RETURN
======= fetch "private List findReturnInstructions() {" e4ab0ae^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "private BcelVar generateReturnInstructions(List returns, InstructionList returnI" e4ab0ae^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    	InstructionHandle lastReturnHandle = (InstructionHandle)returns.get(returns.size() - 1);
    	Instruction newReturnInstruction = Utility.copyInstruction(lastReturnHandle.getInstruction());
======= fetch "private BcelVar generateReturnInstructions(List returns, InstructionList returnI" e4ab0ae^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    		// Find the last *correct* return - this is a method with a non-void return type
    		// so ignore RETURN
    		Instruction  newReturnInstruction = null;
    		int i=returns.size()-1;
    		while (newReturnInstruction == null && i>=0) {
    			InstructionHandle ih = (InstructionHandle)returns.get(i);
    			if (!(ih.getInstruction() instanceof RETURN)) {
    				newReturnInstruction = Utility.copyInstruction(ih.getInstruction());
    			}
    			i--;
    		}
======= fetch "private BcelVar generateReturnInstructions(List returns, InstructionList returnI" e4ab0ae^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        	returnInstructions.append(newReturnInstruction);
======= fetch "private BcelVar generateReturnInstructions(List returns, InstructionList returnI" e4ab0ae^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        	InstructionHandle lastReturnHandle = (InstructionHandle)returns.get(returns.size() - 1);
        	Instruction newReturnInstruction = Utility.copyInstruction(lastReturnHandle.getInstruction());
======= fetch "private BcelVar generateReturnInstructions(List returns, InstructionList returnI" e4ab0ae^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    	returnInstructions.append(newReturnInstruction);
    |               RETURN
    |               RETURN
    |               RETURN
    |               RETURN
    |               RETURN
    |               RETURN
    |               RETURN
    |               RETURN
    |               RETURN
    |               RETURN
    |               RETURN
    |               RETURN
    |               RETURN

======= fetch "public void removeUnnecessaryProblems(Member member, int problemLineNumber) {" 54f7bb4^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseSourceContext.java"


======= fetch "public void initialize() {" 397a19d^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

            WeavingAdaptor weavingAdaptor = WeaverContainer.getWeaver(loader, weavingContext);
            if (weavingAdaptor == null) {
        		if (trace.isTraceEnabled()) trace.exit("preProcess",bytes);
            	return bytes;
            }
            return weavingAdaptor.weaveClass(className, bytes);

======= fetch "public void testVerificationFailureForAspectOf_pr148693() {" 357bbe9^:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testMatchVolatileField_pr150671() {runTest("match volatile field");};
  
  
    <ajc-test dir="bugs153" title="match volatile field">
      <compile files="pr150671.aj" options="-Xset:activateLightweightDelegates=false">
        <message kind="error" line="7" text="Changing state"/>
        <message kind="error" line="8" text="test"/>
      </compile>
    </ajc-test>
======= fetch "public boolean isBridgeMethod() {" 357bbe9^:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

    	return (modifiers & Constants.ACC_BRIDGE)!=0;

  public void m(B b) {
  }
  public static void main(String []argv) {
    new Foo<Interface1,Impl1>();
   }
  before(): staticinitialization(Fo*) { }
  before(): call(Fo*.new(..)) { }
    <aspects>
         <aspect name="X"/> 
    </aspects>
======= fetch "public void testVerificationFailureForAspectOf_pr148693() {" 369de87^:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  //public void testVisibilityProblem_pr149071()                 { runTest("visibility problem");}
  //public void testAdviceNotWovenAspectPath_pr147841() { runTest("advice not woven on aspectpath");}
======= fetch "public static UnresolvedType forGenericTypeSignature(String sig,String declaredG" 369de87^:"weaver/src/org/aspectj/weaver/UnresolvedType.java"


======= fetch "private void generateMethod(ClassFile classFile, MethodBinding methodBinding, Li" 82f217f^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= fetch "private void generateMethod(ClassFile classFile, MethodBinding methodBinding, Li" 82f217f^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

  // work in progress

======= fetch "public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r" f6834c7^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

            		if (level.equals("1.5")){

  //public void testSuperITDExplosion_pr134425() { runTest("super ITDs");}
  //public void testMisbehavingDeclareAnnotation_pr135865() { runTest("misbehaving declare annotation");}
  //public void testMisbehavingDeclareAnnotation_pr135865_2() { runTest("misbehaving declare annotation - 2");}
======= fetch "private boolean mungeNewParent(BcelClassWeaver weaver, NewParentTypeMunger munge" 2f2f568^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

            	if (!(subMethod.isStatic() && subMethod.getName().startsWith("access$"))) { // ignore generated accessors
                  cont = enforceDecpRule3_visibilityChanges(weaver, newParent, superMethod, subMethod) && cont;
======= fetch "private boolean mungeNewParent(BcelClassWeaver weaver, NewParentTypeMunger munge" 2f2f568^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

                }
======= fetch "private boolean enforceDecpRule4_compatibleReturnTypes(BcelClassWeaver weaver, R" 2f2f568^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

          superReturnTypeSig = superReturnTypeSig.replace('.','/');
          subReturnTypeSig = subReturnTypeSig.replace('.','/');
======= fetch "private boolean enforceDecpRule4_compatibleReturnTypes(BcelClassWeaver weaver, R" 2f2f568^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"


    public static void main(String argz[]) {
        if (!Asp.hasAspect()) 
          throw new RuntimeException("ou est le aspect?");
        System.out.println("Can call aspectOf? "+Asp.aspectOf());
    }
        if (name.equals("aspectOf") || name.equals("hasAspect")) continue;
  public void testSeparateCallAspectOf_pr148727() { runTest("separate compilation calling aspectOf and hasAspect"); }
  public void testIntegratedCallAspectOf_pr148727() { runTest("integrated compilation calling aspectOf and hasAspect"); }
    <ajc-test dir="bugs152/binaryDecp" title="incorrect overrides evaluation - 1.4">
      <compile files="IsItSynthetic.java" options="-1.5"/>
      <compile files="Top.java" options="-source 1.5 -target 1.5" outjar="a.jar"/>
      <compile files="Bottom.java" classpath="$sandbox/a.jar" options="-source 1.4 -target 1.4" outjar="b.jar"/>
      <compile files="Middle.java" classpath="$sandbox/a.jar" options="-source 1.4 -target 1.4" outjar="c.jar"/>
      <compile files="X2.aj" classpath="$sandbox/a.jar;$sandbox/b.jar;$sandbox/c.jar" options="-Xlint:ignore" outjar="x.jar"/>
      <run class="Bottom" classpath="a.jar;b.jar;c.jar;x.jar" ltw="aop.xml"/>
        <!--message kind="weave" text="Setting superclass of type 'Bottom' (Bottom.java) to 'Middle' (X2.aj)"/-->
    </ajc-test>
    
    
    <ajc-test dir="bugs152/pr148727"  pr="148727"
        <run class="Client">
          <stdout>
            <line text="Can call aspectOf? Asp@"/>
          </stdout>
        </run>
    </ajc-test>
    <ajc-test dir="bugs152/pr148727"  pr="148727"
        <run class="Client">
          <stdout>
            <line text="Can call aspectOf? Asp@"/>
          </stdout>
        </run>
    </ajc-test>

======= fetch "public void setParameters(AbstractMethodDeclaration md, IProgramElement pe) {" b59b036^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java"


======= fetch "public void acceptResult(UnwovenClassFile result) {" 99d1c18^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"


  public static void main(String []argv) {
    byte[][] bytes = new byte[][]{{0},{1}};
  }
  after() returning(Object o) : call(*[][].new(..)) {
    System.err.println("new array: "+o.getClass());
  }
  public void testFreakyNewArrayJoinpoint_pr148786() { runTest("freaky new array joinpoint"); }
    
    <ajc-test dir="bugs152/pr148786" title="freaky new array joinpoint">
        <compile files="A.java" options="-Xjoinpoints:arrayconstruction"/>
        <run class="A">
          <stderr>
            <line text="new array: class [[B"/>
          </stderr>
        </run>
    </ajc-test>    
======= fetch "public Member makeJoinPointSignatureForArrayConstruction(LazyClassGen cg, Instru" 792d1df^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= fetch "public Member makeJoinPointSignatureForArrayConstruction(LazyClassGen cg, Instru" 792d1df^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"


======= fetch "public void resolveStatements() {" c9f311a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AdviceDeclaration.java"

======= fetch "public void generateCode(ClassScope classScope, ClassFile classFile) {" c9f311a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/DeclareDeclaration.java"

======= fetch "public void generateCode(ClassScope classScope, ClassFile classFile) {" c9f311a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"

======= fetch "public FieldBinding internalMakeFieldBinding(ResolvedMember member,List aliases)" c9f311a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public MethodBinding internalMakeMethodBinding(ResolvedMember member,List aliase" c9f311a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

          <line text="public java.lang.String Test.ajc$interField$Declaration1$TestInterface$secondProperty has annotation:true"/>
          <line text="public java.lang.String Test.ajc$interField$Declaration2$TestInterface$secondProperty has annotation:true"/>
======= fetch "private NameMangler() {" c9f311a^:"weaver/src/org/aspectj/weaver/NameMangler.java"

======= fetch "private void addField(Field field) {" c9f311a^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

   			  ConstantPoolGen cpg = myGen.getConstantPool();
   			  int index = cpg.addUtf8("Synthetic");
   			  Attribute synthetic  = new Synthetic(index, 0, new byte[0], cpg.getConstantPool());
   			  newAttrs[newAttrs.length - 1] = synthetic;
   			  field.setAttributes(newAttrs);
======= fetch "private void addField(Field field) {" c9f311a^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= fetch "public MethodGen pack() {" c9f311a^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    	forceSyntheticForAjcMagicMembers();
    	
======= fetch "public MethodGen pack() {" c9f311a^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        	if (enclosingClass.getWorld().isInJava5Mode()) {
        		gen.setModifiers(gen.getModifiers() | ACC_SYNTHETIC);
        	}
        	// belt and braces, do the attribute even on Java 5 in addition to the modifier flag
   			ConstantPoolGen cpg = gen.getConstantPool();
   			int index = cpg.addUtf8("Synthetic");
   			gen.addAttribute(new Synthetic(index, 0, new byte[0], cpg.getConstantPool()));        		
======= fetch "public MethodGen pack() {" c9f311a^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    public void makeSynthetic() {
  private static final org.aspectj.lang.JoinPoint$EnclosingStaticPart ajc$tjp_0
  private static final org.aspectj.lang.JoinPoint$EnclosingStaticPart ajc$tjp_1
                    ALOAD_0     // HelloWorld this   (line 5)
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_1
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_2
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_3
                    ALOAD_0     // HelloWorld this   (line 5)
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_1
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_2
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_3
                    ALOAD_0     // HelloWorld this   (line 5)
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_1
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_2
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_3
                    ALOAD_0     // HelloWorld this   (line 5)
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_1
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_2
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_3
                    ALOAD_0     // HelloWorld this   (line 5)

                L0: GOTO L1   (line 33)
                L1: INVOKESTATIC Three.aspectOf ()LThree;
    
======= fetch "public void weaveAfterReturning(BcelAdvice munger) {" 426cbdc^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        BcelVar returnValueVar = null;
        
======= fetch "public void weaveAfterReturning(BcelAdvice munger) {" 426cbdc^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

            retList = new InstructionList(ret);
======= fetch "public void weaveAfterReturning(BcelAdvice munger) {" 426cbdc^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        
======= fetch "public void weaveAfterReturning(BcelAdvice munger) {" 426cbdc^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        
======= fetch "public void weaveAfterReturning(BcelAdvice munger) {" 426cbdc^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public void weaveAfterReturning(BcelAdvice munger) {" 426cbdc^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    private boolean isLastInstructionInRange(InstructionHandle ih, ShadowRange aRange) {
    	return ih.getNext() == aRange.getEnd();
    }
    
======= fetch "public static void replaceInstruction(" 426cbdc^:"weaver/src/org/aspectj/weaver/bcel/Utility.java"

                    ALOAD_0     // FancyHelloWorld this   (line 7)
    | | | |         ALOAD_1     // java.io.PrintStream out   (line 11)
    | | |           ALOAD_1     // java.io.PrintStream out   (line 13)
    | | |           ALOAD_2     // java.lang.Exception e
    | |             ALOAD_1     // java.io.PrintStream out   (line 15)
    | |             ILOAD_0     // int x   (line 21)
    | |             ISTORE_0     // int x
    | |             ILOAD_0     // int x
                    ALOAD_0     // HelloWorld this   (line 5)
                    ALOAD_0     // FancyHelloWorld this   (line 7)
    | | |           ALOAD_1     // java.io.PrintStream out   (line 11)
    | |             ALOAD_1     // java.io.PrintStream out   (line 13)
    | |             ALOAD_2     // java.lang.Exception e
    |               ALOAD_1     // java.io.PrintStream out   (line 15)
    |               ILOAD_0     // int x   (line 21)
    |               ISTORE_0     // int x
    |               ILOAD_0     // int x
                    ALOAD_0     // HelloWorld this   (line 5)
                    ALOAD_0     // FancyHelloWorld this   (line 7)
    | | |           ALOAD_1     // java.io.PrintStream out   (line 11)
    | |             ALOAD_1     // java.io.PrintStream out   (line 13)
    | |             ALOAD_2     // java.lang.Exception e
    |               ALOAD_1     // java.io.PrintStream out   (line 15)
    |               ILOAD_0     // int x   (line 21)
    |               ISTORE_0     // int x
    |               ILOAD_0     // int x
                    ALOAD_0     // FancyHelloWorld this   (line 7)
    |               GOTO L0
    |           L0: INVOKESTATIC Aspect.ajc_afterReturning_constructor_execution ()V
    | | |           ALOAD_1     // java.io.PrintStream out   (line 11)
    | |             ALOAD_1     // java.io.PrintStream out   (line 13)
    | |             ALOAD_2     // java.lang.Exception e
    |               ALOAD_1     // java.io.PrintStream out   (line 15)
    |           L2: GOTO L3   (line 17)
    |           L3: INVOKESTATIC Aspect.ajc_afterReturning_method_execution ()V
    |               ILOAD_0     // int x   (line 21)
    |               ISTORE_0     // int x
    |               ILOAD_0     // int x
    |               GOTO L0
    |           L0: INVOKESTATIC Aspect.ajc_afterReturning_method_execution ()V
                    ALOAD_0     // HelloWorld this   (line 5)
    |               GOTO L0
    |           L0: INVOKESTATIC Aspect.ajc_afterReturning_constructor_execution ()V
    |               GOTO L0   (line 11)
    |           L0: INVOKESTATIC Aspect.ajc_afterReturning_method_execution ()V
                    ALOAD_0     // FancyHelloWorld this   (line 7)
    | | |           ALOAD_1     // java.io.PrintStream out   (line 11)
    | |             ALOAD_1     // java.io.PrintStream out   (line 13)
    | |             ALOAD_2     // java.lang.Exception e
    |               ALOAD_1     // java.io.PrintStream out   (line 15)
    |               ILOAD_0     // int x   (line 21)
    |               ISTORE_0     // int x
    |               ILOAD_0     // int x
                    ALOAD_0     // HelloWorld this   (line 5)
                    ALOAD_0     // FancyHelloWorld this   (line 7)
    | | |           ALOAD_1     // java.io.PrintStream out   (line 11)
    | |             ALOAD_1     // java.io.PrintStream out   (line 13)
    | |             ALOAD_2     // java.lang.Exception e
    |               ALOAD_1     // java.io.PrintStream out   (line 15)
    |           L2: GOTO L3   (line 17)
    |           L3: ALOAD 8
    |               ILOAD_0     // int x   (line 21)
    |               ISTORE_0     // int x
    |               ILOAD_0     // int x
                    ALOAD_0     // HelloWorld this   (line 5)
    |               GOTO L0   (line 11)
    |           L0: ALOAD_2
                    ALOAD_0     // HelloWorld this   (line 5)
                    ALOAD_0     // HelloWorld this   (line 5)
                    ALOAD_0     // FancyHelloWorld this   (line 7)
    | | | |         ALOAD_1     // java.io.PrintStream out   (line 11)
    | | |           ALOAD_1     // java.io.PrintStream out   (line 13)
    | | |           ALOAD_2     // java.lang.Exception e
    | |             ALOAD_1     // java.io.PrintStream out   (line 15)
    |               ILOAD_0     // int x   (line 21)
    |               ISTORE_0     // int x
    |               ILOAD_0     // int x
                    ALOAD_0     // HelloWorld this   (line 5)
                    ALOAD_0     // FancyHelloWorld this   (line 7)
    | |             ALOAD_1     // java.io.PrintStream out   (line 11)
    |               ALOAD_1     // java.io.PrintStream out   (line 13)
    |               ALOAD 7
                    ALOAD_1     // java.io.PrintStream out   (line 15)
                    ILOAD_0     // int x   (line 21)
                    ISTORE_0     // int x
                    ILOAD_0     // int x
                    ALOAD_0     // HelloWorld this   (line 5)
                    ALOAD_0     // FancyHelloWorld this   (line 7)
    | | |           ALOAD_1     // java.io.PrintStream out   (line 11)
    | |             ALOAD_1     // java.io.PrintStream out   (line 13)
    | |             ALOAD_2     // java.lang.Exception e
    |               ALOAD_1     // java.io.PrintStream out   (line 15)
    |               ILOAD_0     // int x   (line 21)
    |               ISTORE_0     // int x
    |               ILOAD_0     // int x
                    ALOAD_0     // HelloWorld this   (line 5)
                    ALOAD_0     // FancyHelloWorld this   (line 7)
    | | |           ALOAD_1     // java.io.PrintStream out   (line 11)
    | |             ALOAD_1     // java.io.PrintStream out   (line 13)
    | |             ALOAD_2     // java.lang.Exception e
    |               ALOAD_1     // java.io.PrintStream out   (line 15)
    |               ILOAD_0     // int x   (line 21)
    |               ISTORE_0     // int x
    |               ILOAD_0     // int x
                    ALOAD_0     // HelloWorld this   (line 5)
                    ALOAD_0     // DynamicHelloWorld this   (line 8)
                    ALOAD_1     // java.lang.UnsupportedOperationException t
    |               GOTO L0
    |           L0: DUP
    |               ALOAD 7
                    ALOAD_2     // java.util.List l   (line 21)
                    ALOAD_1     // java.lang.String s
                    ALOAD_2     // java.util.List l   (line 22)

  before(): staticinitialization(*oo) {
    System.err.println("x");
  }
  declare parents: Foo implements java.io.Serializable;
  public static void main(String []argv) throws Exception {
    new Foo().getParameterMetaData();
    Method[] m = Foo.class.getMethods();
    int count = 1;
    for (int i = 0; i < m.length; i++) {
  }
  public Sub getParameterMetaData() throws MyException {
     return null;
  }
   public ParameterMetaData getParameterMetaData() throws MyException;
 <weaver options="-verbose"/>
    <aspects>
      <aspect name="Advisor"/>
    </aspects>
  public void testDuplicateBridgeMethods_pr147801_1() { runTest("duplicate bridge methods");}
   <ajc-test dir="bugs152/pr147801" title="duplicate bridge methods">
      <compile files="Advisor.aj" inpath="foo.jar" options="-1.5"/>
      <run class="Foo">
        <stderr>
          <line text="x"/>
          <line text="1) public Sub Foo.getParameterMetaData() throws MyException"/>
        </stderr>
      </run>
    </ajc-test>
    
======= fetch "public Properties getExtraConfiguration() {" 13dde4e^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public void ensureAdvancedConfigurationProcessed() {" 13dde4e^:"weaver/src/org/aspectj/weaver/World.java"

        		runMinimalMemory = s.equalsIgnoreCase("true");
        		
        		
        		s = p.getProperty(xsetDEBUG_STRUCTURAL_CHANGES_CODE,"false");
        		forDEBUG_structuralChangesCode = s.equalsIgnoreCase("true");
        		
        		s = p.getProperty(xsetDEBUG_BRIDGING,"false");
        		forDEBUG_bridgingCode = s.equalsIgnoreCase("true");
======= fetch "public void ensureAdvancedConfigurationProcessed() {" 13dde4e^:"weaver/src/org/aspectj/weaver/World.java"

    		}
        	checkedAdvancedConfiguration=true;
======= fetch "private static void createBridgeMethod(BcelWorld world, LazyMethodGen whatToBrid" 13dde4e^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public boolean weave() {" 13dde4e^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

    // debug flag for bridge method creation
    
======= fetch "private static ResolvedMember isOverriding(ResolvedType typeToCheck,ResolvedMemb" 13dde4e^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private static ResolvedMember isOverriding(ResolvedType typeToCheck,ResolvedMemb" 13dde4e^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public static ResolvedMember checkForOverride(ResolvedType typeToCheck,String mn" 13dde4e^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

    	if (debug) System.err.println("  Checking for override of "+mname+" in "+typeToCheck);
======= fetch "public static ResolvedMember checkForOverride(ResolvedType typeToCheck,String mn" 13dde4e^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public static boolean calculateAnyRequiredBridgeMethods(BcelWorld world,LazyClas" 13dde4e^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public static boolean calculateAnyRequiredBridgeMethods(BcelWorld world,LazyClas" 13dde4e^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public static boolean calculateAnyRequiredBridgeMethods(BcelWorld world,LazyClas" 13dde4e^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public static boolean calculateAnyRequiredBridgeMethods(BcelWorld world,LazyClas" 13dde4e^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public static boolean calculateAnyRequiredBridgeMethods(BcelWorld world,LazyClas" 13dde4e^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public static boolean calculateAnyRequiredBridgeMethods(BcelWorld world,LazyClas" 13dde4e^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"


 pointcut somePC() : execution(* A.*(..));
 declare warning : somePC() : "a match";
         
         
  public void foo() {}
  public void foo() {}  // CW L 25
  
  public void bar() {}  // CW L 27
  public void testGenericAspectHierarchyWithBounds_pr147845() { runTest("Generic abstract aspect hierarchy with bounds"); }
      <compile files="GenericAspectHierarchy.aj" options="-1.5">
        <message kind="warning" line="25" text="a match"/>
        <message kind="warning" line="27" text="a match"/>     
      </compile>
    </ajc-test>
======= fetch "private boolean matchingBounds(TypeVariableReferenceType tvrt) {" 791f8a7^:"weaver/src/org/aspectj/weaver/TypeVariable.java"

======= fetch "private boolean matchingBounds(TypeVariableReferenceType tvrt) {" 791f8a7^:"weaver/src/org/aspectj/weaver/TypeVariable.java"

======= fetch "private boolean matchingBounds(TypeVariableReferenceType tvrt) {" 791f8a7^:"weaver/src/org/aspectj/weaver/TypeVariable.java"

======= fetch "private boolean matchingBounds(TypeVariableReferenceType tvrt) {" 791f8a7^:"weaver/src/org/aspectj/weaver/TypeVariable.java"


======= fetch "public String toString() {" 008efca^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    /** log command in non-verbose mode */
    private boolean logCommand; 
======= fetch "public void reset() { // XXX possible to reset MatchingTask?" 008efca^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

        logCommand = false;
======= fetch "public void setIncremental(boolean incremental) {" 008efca^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    public void setLogCommand(boolean logCommand) {
        this.logCommand = logCommand;
    }
    
======= fetch "public void execute() throws BuildException {" 008efca^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

            logVerbose("ajc " + Arrays.asList(args));
======= fetch "public void testNoSuchFile() {" 008efca^:"taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java"

    public void testDefaultFileComplete() {
        AjcTask task = getTask("default.lst");
        defaultSettings(task);
        runTest(task, NO_EXCEPTION, MessageHolderChecker.INFOS);
    }
    private void defaultSettings(AjcTask task) {
        task.setDebugLevel("none");
        task.setDeprecation(true);
        task.setFailonerror(false);
        task.setNoExit(true); // ok to override Ant?
        task.setNoImportError(true);
        task.setNowarn(true);
        task.setXTerminateAfterCompilation(true);
        task.setPreserveAllLocals(true);
        task.setProceedOnError(true);
        task.setReferenceInfo(true);
        task.setSource("1.3");
        task.setTarget("1.1");
        task.setTime(true);
        task.setVerbose(true);
        task.setXlint("info");        
    }
    
    public void testLogCommand() {
        final String DEFAULT = "default.lst";
        AjcTask task = getTask(DEFAULT);
        defaultSettings(task);
        task.setVerbose(false);
        task.setLogCommand(true);
        LogListener listener = new LogListener(Project.MSG_INFO);
        task.getProject().addBuildListener(listener);
        runTest(task, NO_EXCEPTION, MessageHolderChecker.INFOS);
        String[] results = listener.getResults();
        boolean matched = false;
        for (int i = 0; !matched && (i < results.length); i++) {
            String s = results[i];
            matched = (null != s) && (-1 != s.indexOf(DEFAULT));
        }
        if (!matched) {
            fail(DEFAULT + " not found in " + Arrays.asList(results));
        }
    }
======= fetch "private void check(" 008efca^:"taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java"

    private static class LogListener implements BuildListener {
        private final ArrayList results = new ArrayList();
        private final int priority;
        private LogListener(int priority) {
            this.priority = priority;
        }
        public void buildFinished(BuildEvent event) {}
        public void buildStarted(BuildEvent event) {}
        public void messageLogged(BuildEvent event) {
            if (priority == event.getPriority()) {
                results.add(event.getMessage());
            }
        }
        public void targetFinished(BuildEvent event) {}
        public void targetStarted(BuildEvent event) {}
        public void taskFinished(BuildEvent event) {}
        public void taskStarted(BuildEvent event) {}
        String[] getResults() {
            return (String[]) results.toArray(new String[0]);
        }
    }

======= fetch "private void dumprelsStderr(String key) {" 38cc0dd^:"asm/src/org/aspectj/asm/AsmManager.java"

======= fetch "private String getFilename(String hid) {" 38cc0dd^:"asm/src/org/aspectj/asm/AsmManager.java"

======= fetch "public void updateHandleMap(Set deletedFiles) {" 38cc0dd^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

    // XXX shouldn't be aware of the delimiter
======= fetch "private String getFilename(String hid) {" 38cc0dd^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"


======= fetch "public void initialize() {" 75afb31^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

        } catch (Throwable t) {
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *   Alexandre Vasseur         initial implementation (derivative from AspectWerkz)
 * JRockit (tested with 7SP4 and 8.1) preprocessor Adapter based on JMAPI <p/>JRockit has a low
 * level API for hooking ClassPreProcessor, allowing the use of online weaving at full speed.
 * Moreover, JRockit does not allow java.lang.ClassLoader overriding thru -Xbootclasspath/p option.
 * <p/>The ClassPreProcessor
 * implementation and all third party jars CAN reside in the standard classpath. <p/>The command
 * line will look like:
 * <code>"%JAVA_COMMAND%" -Xmanagement:class=org.aspectj.weaver.loadtime.JRockitAgent -cp ...</code>
 * Note: there can be some NoClassDefFoundError due to classpath limitation - as described in
 * http://edocs.bea.com/wls/docs81/adminguide/winservice.html <p/>In order to use the BEA JRockit
 * management server (for further connection of management console or runtime analyzer), the regular
 * option -Xmanagement will not have any effect prior to JRockit 8.1 SP2. Instead, use <code>-Dmanagement</code>.
 *
 * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
    /**
     * Concrete preprocessor
     */
    private final static ClassPreProcessor s_preProcessor;
    private static boolean START_RMP_SERVER = false;
    static {
        START_RMP_SERVER = System.getProperties().containsKey("management");
        try {
            s_preProcessor = new Aj();
            s_preProcessor.initialize();
        } catch (Exception e) {
            throw new ExceptionInInitializerError("could not initialize JRockitAgent preprocessor due to: " + e.toString());
        }
    }
    /**
     * The JMAPI ClassPreProcessor must be self registrating
     */
    public JRockitAgent() {
        if (START_RMP_SERVER) {
            // the management server will be spawned in a new thread
            /*RmpSocketListener management = */new RmpSocketListener();
        }
        JVMFactory.getJVM().getClassLibrary().setClassPreProcessor(this);
    }
======= fetch "public JRockitAgent() {" 75afb31^:"loadtime/src/org/aspectj/weaver/loadtime/JRockitAgent.java"

    /**
     * Weave a class
     *
     * @param caller   classloader
     * @param name     of the class to weave
     * @param bytecode original
     * @return bytecode weaved
     */
    public byte[] preProcess(ClassLoader caller, String name, byte[] bytecode) {
        if (caller == null || caller.getParent() == null) {
            return bytecode;
        } else {
            return s_preProcessor.preProcess(name, bytecode, caller);
        }
    }
======= fetch "public static Test suite() {" 75afb31^:"loadtime/testsrc/LoadtimeModuleTests.java"

        suite.addTestSuite(JRockitAgentTest.class);
 * Copyright (c) 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
 * Copyright (c) 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
 * Copyright (c) 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/

======= fetch "public void testCompareSubclassDelegates() {" 3e0650d^:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"

        // the good old ibm vm seems to offer clinit through its reflection support (see pr145322)
        if (rms1.length==rms2.length) return;
======= fetch "public void testCompareSubclassDelegates() {" 3e0650d^:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"

        	if (rms1.length!=(rms2.length+1)) {
        		for (int i = 0; i < rms1.length; i++) {
        		for (int i = 0; i < rms2.length; i++) {
        	}

======= fetch "static boolean getUseCache () {" f821ca3^:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

======= fetch "static boolean getUseCache () {" f821ca3^:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

======= fetch "public CacheImpl() {" f821ca3^:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

======= fetch "public String get(int cacheOffset) {" f821ca3^:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

          String[] cachedArray = array();
          if (cachedArray == null) {
 		     return null;
 		  }
 		  return cachedArray[cacheOffset];
======= fetch "public void set(int cacheOffset, String result) {" f821ca3^:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

======= fetch "public void set(int cacheOffset, String result) {" f821ca3^:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

======= fetch "public void set(int cacheOffset, String result) {" f821ca3^:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

======= fetch "public void set(int cacheOffset, String result) {" f821ca3^:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
======= fetch "public void testToShortMiddleLongString () {" f821ca3^:"runtime/testsrc/org/aspectj/runtime/reflect/SignatureTest.java"


======= fetch "public Map getSourcePathResources() {" 319a0d1^:"ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java"

======= fetch "public boolean accept(File pathname) {" 319a0d1^:"ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java"

======= fetch "public boolean accept(File pathname) {" 319a0d1^:"ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java"

======= fetch "public boolean accept(File pathname) {" 319a0d1^:"ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java"

======= fetch "public void testOutxmlfileToOutjar () {" 319a0d1^:"ajde/testsrc/org/aspectj/ajde/OutxmlTest.java"

======= fetch "public boolean accept(File f) {" 319a0d1^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeResource(String filename, byte[] content, File srcLocation) th" 319a0d1^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeOutxmlFile () throws IOException {" 319a0d1^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"


======= fetch "public void addCrossReference(ISourceLocation from, ISourceLocation to, IRelatio" 4513e92^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        if (enabled) {
======= fetch "public void addCrossReference(ISourceLocation from, ISourceLocation to, IRelatio" 4513e92^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        //bcelWorld.setResolutionLoader(loader.getParent());//(ClassLoader)null);//
        
        // after adding aspects
        weaver.prepareForWeave();
======= fetch "private void registerAspects(final BcelWeaver weaver, final ClassLoader loader," 4513e92^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

    <aspects/>
                files="ataspectj/ltwlog/MessageHolder.java,ataspectj/ltwreweavable/MainReweavableLogging.java,ataspectj/ltwreweavable/AspectReweavableLogging.java,ataspectj/ltwreweavable/Advisable.java"
======= fetch "public void testDeclareAtMethodRelationship_pr143924() {" 4513e92^:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

      title="Ensure no weaving without included aspects"
      keywords="reweavable">
        <compile
        	files="TestMain.java, Main.java"
        >
        </compile>	
        <run class="TestMain" ltw="aop-optionsonly.xml">
        	<stdout>
                <line text="Main.main"/>
                <line text="Main.test1"/>
                <line text="Main.test2"/>
            </stdout>
        	<stderr>
            </stderr>
        </run>
    </ajc-test>

======= fetch "private IScope buildResolutionScope(Class inScope, PointcutParameter[] formalPar" 97cd71a^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

======= fetch "public void tidy() {}" 97cd71a^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    private UnresolvedType toUnresolvedType(Class clazz) {
    	if (clazz.isArray()) {
    	} else {
    		return UnresolvedType.forName(clazz.getName());
    	}
    }
    
======= fetch "private ResolvedMember createGenericFieldMember(Field forField) {" 97cd71a^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"

======= fetch "public void testReferencePCsInOtherType() throws Exception {" 97cd71a^:"weaver5/java5-testsrc/org/aspectj/weaver/tools/Java15PointcutExpressionTest.java"

======= fetch "public void d() {}" 97cd71a^:"weaver5/java5-testsrc/org/aspectj/weaver/tools/Java15PointcutExpressionTest.java"


======= fetch "public void testAdvisesRelationshipCoverage() throws Exception {" 26a8a86^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

======= fetch "private String genPrecedenceListLabel(TypePatternList list) {" 26a8a86^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java"

======= fetch "public boolean visit(ConstructorDeclaration constructorDeclaration, ClassScope s" 26a8a86^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= fetch "public boolean visit(ConstructorDeclaration constructorDeclaration, ClassScope s" 26a8a86^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

    declare @method : * debit(..) : @Secured(role="supervisor");
    public void debit(String accId,long amount) {
    }
    String role();
======= fetch "public void testDeclareAnnotationAppearsInStructureModel_pr132130() {" 26a8a86^:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  			  IProgramElement.Kind.CONSTRUCTOR,"BankAccount(String,int)");
======= fetch "public void addDeclareAnnotationRelationship(ISourceLocation sourceLocation, Str" 26a8a86^:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"


======= fetch "public boolean validate() {" 69e24e9^:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

        Iterator methods = m_parent.getMethods();
        while (methods.hasNext()) {
            ResolvedMember method = (ResolvedMember) methods.next();
            if (method.isAbstract()) {
                if ("()V".equals(method.getSignature())) {
                	String n = method.getName();
                	if (n.startsWith("ajc$pointcut")) { // Allow for the abstract pointcut being from a code style aspect compiled with -1.5 (see test for 128744)
                		n = n.substring(14);
                		n = n.substring(0,n.indexOf("$"));
                		elligibleAbstractions.add(n);
                	} else {
                		// Only interested in abstract methods that take no parameters and are marked @Pointcut
                		if (hasPointcutAnnotation(method))
                			elligibleAbstractions.add(method.getName());
                	}
                } else {
                    reportError("Abstract method '" + method.getName() + "' cannot be concretized as a pointcut (illegal signature, must have no arguments, must return void): " + stringify());
                    return false;
                }
======= fetch "public boolean validate() {" 69e24e9^:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

        }
======= fetch "public boolean validate() {" 69e24e9^:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

    /**

  boolean readOnly() default false;
 pointcut methodInTxType(Tx tx) : 
   execution(* *(..)) && @this(tx) && if(tx.readOnly());
 pointcut txMethod(Tx tx) :
   execution(* *(..)) && @annotation(tx) && if(tx.readOnly());
 pointcut transactionalOperation() :
   methodInTxType(Tx) || txMethod(Tx);
 before() : transactionalOperation() {
   // do something
 }
  public void foo() {}
  
  @Tx public void bar() {}
======= fetch "protected Test findResidueInternal(Shadow shadow, ExposedState state) {" 6b2d9ae^:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"


======= fetch "public void finishTypeMungers() {" 5f6a6b1^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

        baseTypeMungers.addAll(getWorld().getCrosscuttingMembersSet().getLateTypeMungers());
======= fetch "public void testPr115251() {" 5f6a6b1^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= fetch "private void addAndRecurse(Set knowninterfaces,List collector, ResolvedType rtx," 5f6a6b1^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

                if (munger.getMunger().getKind() == ResolvedTypeMunger.Parent) {

  pointcut mypc() : SomeOtherType.pc();
======= fetch "public static void verifyClassSignature(Ajc ajc,String classname,String sig) {" b166a7e^:"tests/src/org/aspectj/systemtest/ajc150/GenericITDsDesign.java"

      <compile files="PerThisWithReference.aj,SomeOtherType.aj" options="-1.5">
======= fetch "public CrosscuttingMembers(ResolvedType inAspect) {" b166a7e^:"weaver/src/org/aspectj/weaver/CrosscuttingMembers.java"

======= fetch "public boolean replaceWith(CrosscuttingMembers other,boolean careAboutShadowMung" b166a7e^:"weaver/src/org/aspectj/weaver/CrosscuttingMembers.java"

======= fetch "public boolean replaceWith(CrosscuttingMembers other,boolean careAboutShadowMung" b166a7e^:"weaver/src/org/aspectj/weaver/CrosscuttingMembers.java"

======= fetch "public void setPerClause(PerClause perClause) {" b166a7e^:"weaver/src/org/aspectj/weaver/CrosscuttingMembers.java"

======= fetch "public boolean addOrReplaceAspect(ResolvedType aspectType) {" b166a7e^:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

======= fetch "public boolean addOrReplaceAspect(ResolvedType aspectType,boolean careAboutShado" b166a7e^:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

======= fetch "public boolean addOrReplaceAspect(ResolvedType aspectType,boolean careAboutShado" b166a7e^:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

======= fetch "public boolean addOrReplaceAspect(ResolvedType aspectType,boolean careAboutShado" b166a7e^:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

======= fetch "public boolean addOrReplaceAspect(ResolvedType aspectType,boolean careAboutShado" b166a7e^:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

======= fetch "public boolean addOrReplaceAspect(ResolvedType aspectType,boolean careAboutShado" b166a7e^:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

======= fetch "private boolean addOrReplaceDescendantsOf(ResolvedType aspectType,boolean careAb" b166a7e^:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

======= fetch "public ResolvedPointcutDefinition findPointcut(String name) {" b166a7e^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

======= fetch "public void testBeforeCflow() throws IOException {" b166a7e^:"weaver/testsrc/org/aspectj/weaver/bcel/NonstaticWeaveTestCase.java"

======= fetch "public void testBeforePerThis() throws IOException {" b166a7e^:"weaver/testsrc/org/aspectj/weaver/bcel/NonstaticWeaveTestCase.java"

======= fetch "private void checkWeave(" b166a7e^:"weaver/testsrc/org/aspectj/weaver/bcel/PointcutResidueTestCase.java"

======= fetch "public void testDominates() {" b166a7e^:"weaver/testsrc/org/aspectj/weaver/bcel/WeaveOrderTestCase.java"

======= fetch "public void testDominatesHarder() {" b166a7e^:"weaver/testsrc/org/aspectj/weaver/bcel/WeaveOrderTestCase.java"


======= fetch "public static void main (String[] args) {" fc7db25^:"tests/java5/ataspectj/ataspectj/ltwreweavable/MainReweavableLogging.java"

        String ERROR_STRING = "error aspect 'ataspectj.ltwreweavable.AspectReweavableLogging' woven into 'ataspectj.ltwreweavable.MainReweavableLogging' must be declared in an aop.xml file.";

======= fetch "private void validateAspectDeclaration(TypeDeclaration typeDecl) {" 9ffc63b^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

======= fetch "private void validateAdvice(MethodDeclaration methodDeclaration) {" 9ffc63b^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

  static before(): call(* *(..)) {}
  <aspects>
    <aspect name="t.Ajava"/>
  </aspects>
  <weaver>
    <include within="t..*"/>
  </weaver>
  public void testVerifyErrorLTW_pr135068() { runTest("ltw verifyerror");}
  public void testVerifyErrorLTW_pr135068_2() { runTest("ltw verifyerror - 2");}
  public void testVerifyErrorLTW_pr135068_3() { runTest("ltw verifyerror - 3");}
  public void testVerifyErrorLTW_pr135068_4() { runTest("ltw verifyerror - 4");}
    </ajc-test>
    
    	<ajc-test dir="bugs152/pr135068" title="ltw verifyerror - 2">
    </ajc-test>
    
    	<ajc-test dir="bugs152/pr135068" title="ltw verifyerror - 3">
        <compile files="t/Ajava.java" options="-1.5">
          <message kind="warning" line="13" text="advice defined"/>
        </compile>
        <run class="t.C" ltw="aop.xml"/>
    </ajc-test>
    
    	<ajc-test dir="bugs152/pr135068" title="ltw verifyerror - 4">
        <compile files="t/Ajava2.java" options="-1.5">
        </compile>
    </ajc-test>
    
======= fetch "public static List readAj5MethodAttributes(Method method, BcelMethod bMethod, Re" 9ffc63b^:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

        
        // semantic check - advice must not be static
        if (hasAtAspectJAnnotation && struct.method.isStatic()) {
            msgHandler.handleMessage(MessageUtil.error("Advice cannot be declared static '" + methodToString(struct.method) + "'",type.getSourceLocation()));
            ;// go ahead
        }
        

    pointcut publicMethods() : execution(public * *(..));
    before() : publicMethods() {
        System.out.println("Entering "+thisJoinPoint);
    }
    pointcut publicMethods() : execution(public * *(..));
    before() : publicMethods() {
        System.out.println("Entering "+thisJoinPoint);
    }
    
    after() : publicMethods() {
    	System.out.println("Exiting " + thisJoinPoint);
    }
======= fetch "public void testPr129163_3() {" 3fa4d24^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

    private boolean hasReportedNoGuardForLazyTJP = false;
======= fetch "public void specializeOn(Shadow shadow) {" 3fa4d24^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= fetch "public void specializeOn(Shadow shadow) {" 3fa4d24^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= fetch "public void specializeOn(Shadow shadow) {" 3fa4d24^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"


 @Marker void getData(){}
  before(Marker a): execution(* getData(..)) && @annotation(a) { System.err.println(a);  }
  public void testAnnotationsAndGenericsBCException_pr129704() { runTest("annotations and generics leading to BCException");}
    <ajc-test dir="bugs152/pr129704" title="annotations and generics leading to BCException">
      <compile files="A.java" options="-1.5"/>
      <run class="A">
        <stderr>
          <line text="@Marker()"/>
        </stderr>
      </run>
    </ajc-test>
    
======= fetch "public void initializeKindedAnnotationVars() {" 3ca976f^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    	
    	if (getKind() == Shadow.StaticInitialization) {
======= fetch "public void initializeKindedAnnotationVars() {" 3ca976f^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    		annotations = getAnnotations(foundMember, relevantMember,relevantType);

 * @version $Id: InstructionList.java,v 1.3 2006/02/14 13:32:07 aclement Exp $
======= fetch "public void setPositions(boolean check) {" 5d2b5b8^:"bcel-builder/src/org/aspectj/apache/bcel/generic/InstructionList.java"

    byte[] byteCode = b.toByteArray();
    if (byteCode.length > Constants.MAX_CODE_SIZE) 
    	  throw new ClassGenException("Code size too big: " + byteCode.length);
======= fetch "public void setPositions(boolean check) {" 5d2b5b8^:"bcel-builder/src/org/aspectj/apache/bcel/generic/InstructionList.java"

    return b.toByteArray();

======= fetch "public static PointcutParser getPointcutParserSupportingSpecifiedPrimitivesAndUs" b954b26^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    private PointcutParser() {
======= fetch "private PointcutParser(Set/*<PointcutPrimitives>*/ supportedPointcutKinds) {" b954b26^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    public void setWorld(ReflectionWorld aWorld) {
======= fetch "public void setWorld(ReflectionWorld aWorld) {" b954b26^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    private void setClassLoader(ClassLoader aLoader) {
======= fetch "public PointcutExpression parsePointcutExpression(" b954b26^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

        	 PatternParser parser = new PatternParser(expression);
        	 parser.setPointcutDesignatorHandlers(pointcutDesignators, world);
             Pointcut pc = parser.parsePointcut();
             validateAgainstSupportedPrimitives(pc,expression);
             IScope resolutionScope = buildResolutionScope((inScope == null ? Object.class : inScope),formalParameters);
             pc = pc.resolve(resolutionScope);
             ResolvedType declaringTypeForResolution = null;
             if (inScope != null) {
            	 declaringTypeForResolution = getWorld().resolve(inScope.getName());
             } else {
            	 declaringTypeForResolution = ResolvedType.OBJECT.resolve(getWorld());
             }
             IntMap arity = new IntMap(formalParameters.length);
             for (int i = 0; i < formalParameters.length; i++) {
            	 arity.put(i, i);
             }             
             pc = pc.concretize(declaringTypeForResolution, declaringTypeForResolution, arity);
======= fetch "public PointcutExpression parsePointcutExpression(" b954b26^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    protected Pointcut resolvePointcutExpression(
    		String expression, 
    		Class inScope,
    		PointcutParameter[] formalParameters) {
    	try {
      	 PatternParser parser = new PatternParser(expression);
    	 parser.setPointcutDesignatorHandlers(pointcutDesignators, world);
         Pointcut pc = parser.parsePointcut();
         validateAgainstSupportedPrimitives(pc,expression);
         IScope resolutionScope = buildResolutionScope((inScope == null ? Object.class : inScope),formalParameters);
         pc = pc.resolve(resolutionScope);
         return pc;
    	} catch (ParserException pEx) {
             throw new IllegalArgumentException(buildUserMessageFromParserException(expression,pEx));
        }
    }
    
    protected Pointcut concretizePointcutExpression(Pointcut pc, Class inScope, PointcutParameter[] formalParameters) {
        ResolvedType declaringTypeForResolution = null;
        if (inScope != null) {
       	 declaringTypeForResolution = getWorld().resolve(inScope.getName());
        } else {
       	 declaringTypeForResolution = ResolvedType.OBJECT.resolve(getWorld());
        }
        IntMap arity = new IntMap(formalParameters.length);
        for (int i = 0; i < formalParameters.length; i++) {
       	 arity.put(i, i);
        }             
        return pc.concretize(declaringTypeForResolution, declaringTypeForResolution, arity);
    }
    
 * When a Java15ReflectionBasedDelegate gets the pointcuts for a given class it 
 * tries to resolve them before returning.
 * This can cause problems if the resolution of one pointcut in the type depends
 * on another pointcut in the same type. 
 * Therefore the algorithm proceeds in two phases, first we create and store
 * instances of this class in the pointcuts array, and once that is done, we
 * come back round and resolve the actual pointcut expression. This means that
 * if we recurse doing resolution, we will find the named pointcut we are 
 * looking for!
 * 
 * @author adrian colyer
 *
 */
======= fetch "private ResolvedMember createGenericFieldMember(Field forField) {" b954b26^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"

======= fetch "private ResolvedMember createGenericFieldMember(Field forField) {" b954b26^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"

======= fetch "private ResolvedMember createGenericFieldMember(Field forField) {" b954b26^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"

======= fetch "private ResolvedMember createGenericFieldMember(Field forField) {" b954b26^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"

======= fetch "public void testJavaLangMatching() throws Exception {" b954b26^:"weaver5/java5-testsrc/org/aspectj/weaver/tools/Java15PointcutExpressionTest.java"

======= fetch "public void foo() {}" b954b26^:"weaver5/java5-testsrc/org/aspectj/weaver/tools/Java15PointcutExpressionTest.java"


======= fetch "private void generatePerSupportMembers(ClassFile classFile) {" 299c3a4^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= fetch "private TypeBinding generatePerObjectInterface(" 299c3a4^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= fetch "public void addTypeBinding(TypeBinding binding) {" 299c3a4^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "private void recordClassFile(UnwovenClassFile thisTime, File lastTime) {" 299c3a4^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "public void testBuildingTwoProjectsMakingSmallChanges() {" 299c3a4^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


    SoftReference toStringCacheRef;
======= fetch "String toString (StringMaker sm) {" cb5dfe7^:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

======= fetch "String toString (StringMaker sm) {" cb5dfe7^:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

======= fetch "String toString (StringMaker sm) {" cb5dfe7^:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

======= fetch "String toString (StringMaker sm) {" cb5dfe7^:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

======= fetch "static boolean getUseCache () {" cb5dfe7^:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"


    /** The default of Void means ANY throwable */
    Class[] value() default Void.class; 
    before(Throwable throwable) : handler(*) && args(throwable) && !@withincode(NormalException) {
    	System.err.println("Caught in "+thisEnclosingJoinPointStaticPart.getSignature().getName());
    }    
    public static void main(String argz[]) {
    	new Test().checkConnection();
    }
    @NormalException(Exception.class)
    protected void checkConnection() {
        try {
            foo();
        } catch (Exception e) {
        	;//skip warning
        }
    }
    
    private void foo() {
    	try {
    		throw new RuntimeException();
    	} catch (RuntimeException e) {
    		throw e;
    	}
    }
  public void testAtWithinCodeBug_pr138798() { runTest("atWithinCodeBug"); }
    <ajc-test dir="bugs152/pr138798" title="atWithinCodeBug">
      <compile files="ErrorHandling.aj" options="-1.5"/>
      <run class="ErrorHandling">
         <stderr>
           <line text="Caught in foo"/>
         </stderr>
      </run>      
    </ajc-test>
    

  public void testNoClassCastExceptionWithPerThis_pr138286() { runTest("No ClassCastException with perThis");}
  
    <ajc-test dir="bugs152/pr138286" pr="138286" title="No ClassCastException with perThis">
      <compile files="A.aj" options="-1.5 -showWeaveInfo">      
      </compile>
      <run class="A">
        <stderr>
          <line text="class Foo"/>
          <line text="class Boo"/>
          <line text="class Boo"/> <!-- this one is because of the super() call in Soo's default ctor -->
          <line text="class Soo"/>
        </stderr>
      </run>
    </ajc-test>
======= fetch "public Object visit(WithinAnnotationPointcut node, Object data) {" c667bcb^:"weaver/src/org/aspectj/weaver/patterns/PerThisOrTargetPointcutVisitor.java"

            return node.getAnnotationTypePattern();
======= fetch "public Object visit(ThisOrTargetAnnotationPointcut node, Object data) {" c667bcb^:"weaver/src/org/aspectj/weaver/patterns/PerThisOrTargetPointcutVisitor.java"

            return node.getAnnotationTypePattern();
======= fetch "public Object visit(ThisOrTargetAnnotationPointcut node, Object data) {" c667bcb^:"weaver/src/org/aspectj/weaver/patterns/PerThisOrTargetPointcutVisitor.java"

            return node.getAnnotationTypePattern();

======= fetch "public void setX(String input) {  // ajc-only eajc-also docDone" 99882cb^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

                if (VALID_XOPTIONS.contains(token)) {

  public void foo() {}
======= fetch "public void testPr131505() {" 1535ee7^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= fetch "public boolean equals(Object other) {" 1535ee7^:"weaver/src/org/aspectj/weaver/PerObjectInterfaceTypeMunger.java"

    	if (!(other instanceof PerObjectInterfaceTypeMunger)) return false;
======= fetch "public boolean equals(Object other) {" 1535ee7^:"weaver/src/org/aspectj/weaver/PerObjectInterfaceTypeMunger.java"

    	return ((o.testPointcut == null) ? (testPointcut == null ) : testPointcut.equals(o.testPointcut))
    			&& ((o.lazyTestTypePattern == null) ? (lazyTestTypePattern == null ) : lazyTestTypePattern.equals(o.lazyTestTypePattern));

======= fetch "public ClassFile find(UnresolvedType type) {" d1a252e^:"weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"

======= fetch "public List getAllClassFiles() {" d1a252e^:"weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"

======= fetch "public List getAllClassFiles() {" d1a252e^:"weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"

======= fetch "public ZipFile getZipFile() {" d1a252e^:"weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"

======= fetch "public ClassFile find(String name) {" d1a252e^:"weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"

======= fetch "public List getAllClassFiles() {" d1a252e^:"weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"

======= fetch "private void ensureOpen() {" d1a252e^:"weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"

======= fetch "private void ensureOpen() {" d1a252e^:"weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"


======= fetch "public static Test suite() {" 1a6f695^:"tests/src/org/aspectj/systemtest/AllTests15.java"

 * Copyright (c) 2006 IBM 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
  public void testAspectLibrariesAndASM_pr135001() { runTest("aspect libraries and asm");}
  
  
  /////////////////////////////////////////
  public static Test suite() {
    return XMLBasedAjcTestCase.loadSuite(Ajc152Tests.class);
  }
  protected File getSpecFile() {
    return new File("../tests/src/org/aspectj/systemtest/ajc152/ajc152.xml");
  }
  
 * Copyright (c) 2006 IBM 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
        //$JUnit-END$
    <ajc-test dir="bugs152/pr135001" title="aspect libraries and asm">
      <compile files="AbstractAspect.java" outjar="lib.jar" options="-1.5"/>
      <compile files="Foo.java,ConcreteAspect.java" classpath="lib.jar" options="-1.5 -showWeaveInfo">
        <message kind="weave" text="Join point 'method-call(void Foo.foo())' in Type 'Foo' (Foo.java:3) advised by around advice from 'ConcreteAspect' (AbstractAspect.java:5)"/>
      </compile>
      <run class="Foo">
         <stderr>
           <line text="In the advice!"/>
         </stderr>
      </run>
    </ajc-test>
    
======= fetch "public void weaveAroundInline(" 1a6f695^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        BcelObjectType ot = BcelWorld.getBcelObjectType((declaringType.isParameterizedType()?declaringType.getGenericType():declaringType)); 
        
======= fetch "public ResolvedType resolve(Type t) {" 1a6f695^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

    }       
======= fetch "protected ReferenceTypeDelegate resolveDelegate(ReferenceType ty) {" 1a6f695^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= fetch "public void testWeDontGoBang() {" 1a6f695^:"weaver/testsrc/org/aspectj/weaver/bcel/AsmDelegateTests.java"

        world.fallbackToLoadingBcelDelegatesForAspects = false;
======= fetch "public void testWeDontGoBang() {" 1a6f695^:"weaver/testsrc/org/aspectj/weaver/bcel/AsmDelegateTests.java"

    	
======= fetch "public void testLoadingAttributesForTypes() {" 1a6f695^:"weaver/testsrc/org/aspectj/weaver/bcel/AsmDelegateTests.java"

    	BcelWorld slowWorld = new BcelWorld(BcweaverTests.TESTDATA_PATH+"/forAsmDelegateTesting/stuff.jar");slowWorld.setFastDelegateSupport(false);
======= fetch "public void testLoadingAttributesForTypes() {" 1a6f695^:"weaver/testsrc/org/aspectj/weaver/bcel/AsmDelegateTests.java"

        fastWorld.fallbackToLoadingBcelDelegatesForAspects = false;
======= fetch "public void testLoadingAttributesForMethods() {" 1a6f695^:"weaver/testsrc/org/aspectj/weaver/bcel/AsmDelegateTests.java"

        

======= fetch "public void testPr133532_2() {" 94d8b82^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= fetch "public boolean replaceWith(CrosscuttingMembers other,boolean careAboutShadowMung" 94d8b82^:"weaver/src/org/aspectj/weaver/CrosscuttingMembers.java"

======= fetch "public boolean replaceWith(CrosscuttingMembers other,boolean careAboutShadowMung" 94d8b82^:"weaver/src/org/aspectj/weaver/CrosscuttingMembers.java"

======= fetch "public boolean addOrReplaceAspect(ResolvedType aspectType,boolean careAboutShado" 94d8b82^:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"


======= fetch "private void ensureVoidReturnType(MethodDeclaration methodDeclaration) {" 41f1f3a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

======= fetch "private void ensureVoidReturnType(MethodDeclaration methodDeclaration) {" 41f1f3a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

            TypeBinding argTypeBinding = mDecl.binding.parameters[i];

======= fetch "public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {" fa2ed1b^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"


======= fetch "public void genLabelAndKind(MethodDeclaration methodDeclaration, IProgramElement" 91473b3^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java"

                if (true && methodDeclaration!=null && methodDeclaration.annotations != null) {

======= fetch "public void completeTypeBindings() {" c9a60e5^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

       <message kind="error" line="16" text="The method m4(String) is undefined for the type Base"/>
======= fetch "public void reset() {" c9a60e5^:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

======= fetch "public boolean hasChangedSinceLastReset() {" c9a60e5^:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

======= fetch "public boolean hasChangedSinceLastReset() {" c9a60e5^:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

 * Copyright (c) 2006 Contributors
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *     Andy Clement IBM     initial implementation 
 * ******************************************************************/
 * Implementors provide a 'verify()' method that is invoked at the end of type
 * binding completion.
 * @see WildTypePattern.VerifyBoundsForTypePattern
 */
======= fetch "private boolean verifyTypeParameters(ResolvedType baseType,IScope scope, boolean" c9a60e5^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "private boolean verifyTypeParameters(ResolvedType baseType,IScope scope, boolean" c9a60e5^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "private boolean verifyTypeParameters(ResolvedType baseType,IScope scope, boolean" c9a60e5^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "public boolean checkBoundsOK(IScope scope,ResolvedType genericType,boolean requi" c9a60e5^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "public boolean checkBoundsOK(IScope scope,ResolvedType genericType,boolean requi" c9a60e5^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"


  public void m() {}
  declare @method: * Target.*(..): @One;
  declare @method: * Target.*(..): @Two;
  public static void main(String []argv) {
  }
  public void testCrashingWithASM_pr132926_1() { runTest("crashing on annotation type resolving with asm - 1");}
  public void testCrashingWithASM_pr132926_2() { runTest("crashing on annotation type resolving with asm - 2");}
  public void testCrashingWithASM_pr132926_3() { runTest("crashing on annotation type resolving with asm - 3");}
    <ajc-test dir="bugs151/pr132926" pr="132926" title="crashing on annotation type resolving with asm - 1">
     <compile files="InputAnnotation.java,AffectedType.java" options="-1.5"/>
    </ajc-test>
    
    <ajc-test dir="bugs151/pr132926" pr="132926" title="crashing on annotation type resolving with asm - 2">
     <compile files="InputAnnotation.java" outjar="foo.jar" options="-1.5"/>
     <compile files="AffectedType.java" classpath="foo.jar" options="-1.5"/>
    </ajc-test>
    
    <ajc-test dir="bugs151/pr132926" pr="132926" title="crashing on annotation type resolving with asm - 3">
     <compile files="InputAnnotation2.java" outjar="foo.jar" options="-1.5"/>
     <compile files="AffectedType.java" classpath="foo.jar" options="-1.5">
     	<message kind="error" line="9" text="AffectedType is not a valid target for annotation InputAnnotation, this annotation can only be applied to these element types {METHOD}"/>
     </compile>
    </ajc-test>
    <ajc-test dir="bugs151/Deca" title="doubly annotating a method with declare">
      <compile files="DecA.java" options="-1.5"/>
      <run class="DecA">
        <stderr>
          <line text="There are 2 annotations on public void m()"/>
          <line text="1) @One()"/>
          <line text="2) @Two()"/>
        </stderr>
      </run>
    </ajc-test>
    
======= fetch "private void ensureAtTargetInitialized() {" 2fb86fe^:"weaver/src/org/aspectj/weaver/AnnotationX.java"

  			supportedTargets = new HashSet();
  			List values = atTargetAnnotation.getBcelAnnotation().getValues();
  		  	ElementNameValuePair envp = (ElementNameValuePair)values.get(0);
  		  	ArrayElementValue aev = (ArrayElementValue)envp.getValue();
  		  	ElementValue[] evs = aev.getElementValuesArray();
  		  	for (int i = 0; i < evs.length; i++) {
  				EnumElementValue ev = (EnumElementValue)evs[i];
  				supportedTargets.add(ev.getEnumValueString());
  			}
======= fetch "private void ensureAtTargetInitialized() {" 2fb86fe^:"weaver/src/org/aspectj/weaver/AnnotationX.java"

  
  /**
   * For the @Target annotation, this will return a set of the elementtypes it can be applied to.
   * For non @Target annotations, it returns null.
   */
  public Set /* of String */ getTargets() {
  }

======= fetch "public void testInterTypeMemberDeclares() {" 9dca72e^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testPointcuts() {" 9dca72e^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testAdvice() {" 9dca72e^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testInterTypeDeclarations() {" 9dca72e^:"ajde/testsrc/org/aspectj/ajde/AsmRelationshipsTest.java"

======= fetch "public void testAdviceNamingCoverage() throws Exception {" 9dca72e^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

======= fetch "public String toSignatureString(boolean getFullyQualifiedArgTypes) {" 9dca72e^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

 aspect basic {
    declare @method : * debit(..) : @Secured(role="supervisor");
    declare @constructor : BankAccount+.new(..) : @Secured(role="supervisor");
    public void debit(long accId,long amount) {
    }
    String role();
======= fetch "public void testIProgramElementMethods_pr125295() {" 9dca72e^:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  	  assertEquals("foo(int, java.lang.Object)",pe.toLabelString());
  	  assertEquals("C.foo(int, java.lang.Object)",pe.toLinkLabelString());
  	  assertEquals("foo(int, java.lang.Object)",pe.toSignatureString());
======= fetch "public void testIProgramElementMethods_pr125295() {" 9dca72e^:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  	  assertEquals("foo(int, Object)",pe.toLabelString(false));
  	  assertEquals("C.foo(int, Object)",pe.toLinkLabelString(false));
  	  assertEquals("foo(int, Object)",pe.toSignatureString(false));
======= fetch "public void testStructureModelForGenericITD_pr131932() {" 9dca72e^:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  
  public void testDeclareAnnotationAppearsInStructureModel_pr132130() {
  	  // get the IProgramElements corresponding to the different code entries
  	  IProgramElement decam = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.DECLARE_ANNOTATION_AT_METHOD,"declare @method: * debit(..) : @Secured(role = \"supervisor\")");  	   	 
  	  assertNotNull("Couldn't find 'declare @method' element in the tree",decam);
  	  IProgramElement method = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.METHOD,"debit(long,long)");
  	  assertNotNull("Couldn't find the 'debit(long,long)' method element in the tree",method);
  	  IProgramElement decac = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.DECLARE_ANNOTATION_AT_CONSTRUCTOR,"declare @constructor: BankAccount+.new(..) : @Secured(role = \"supervisor\")");  	   	 
  	  assertNotNull("Couldn't find 'declare @constructor' element in the tree",decac);
  	  IProgramElement ctr = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.CONSTRUCTOR,"BankAccount(String,int)");
  	  assertNotNull("Couldn't find the 'BankAccount(String,int)' constructor element in the tree",ctr);
  	  
  	  // check that decam has a annotates relationship with the debit method
  	  List matches = AsmManager.getDefault().getRelationshipMap().get(decam);	
  	  assertNotNull("'declare @method' should have some relationships but does not",matches);
  	  assertTrue("'declare @method' should have one relationships but has " + matches.size(),matches.size()==1);
  	  List matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("'declare @method' should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
  	  IProgramElement target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the 'debit(long,long)' method but is IPE with label "
  			  + target.toLabelString(),method,target);
  	  
  	  // check that the debit method has an annotated by relationship with the declare @method
  	  matches = AsmManager.getDefault().getRelationshipMap().get(method);	
  	  assertNotNull("'debit(long,long)' should have some relationships but does not",matches);
  	  assertTrue("'debit(long,long)' should have one relationships but has " + matches.size(),matches.size()==1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("'debit(long,long)' should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the 'declare @method' ipe but is IPE with label "
  			  + target.toLabelString(),decam,target);
  	  // check that decac has a annotates relationship with the constructor
  	  matches = AsmManager.getDefault().getRelationshipMap().get(decac);	
  	  assertNotNull("'declare @method' should have some relationships but does not",matches);
  	  assertTrue("'declare @method' should have one relationships but has " + matches.size(),matches.size()==1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("'declare @method' should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the 'debit(long, long)' method but is IPE with label "
  			  + target.toLabelString(),ctr,target);
  	  
  	  // check that the constructor has an annotated by relationship with the declare @constructor
  	  matches = AsmManager.getDefault().getRelationshipMap().get(ctr);	
  	  assertNotNull("'debit(long, long)' should have some relationships but does not",matches);
  	  assertTrue("'debit(long, long)' should have one relationships but has " + matches.size(),matches.size()==1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("'debit(long, long)' should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the 'declare @method' ipe but is IPE with label "
  			  + target.toLabelString(),decac,target);
  }
  
    <ajc-test dir="bugs151" title="declare annotation appears in structure model when in same file">
        <compile files="pr132130.aj" options="-1.5 -emacssym"/>
    </ajc-test>

    }
    static class Bar<T> {
        List<T> lts;
    }   
    
======= fetch "public void testGenericAspectWithUnknownType_pr131933() {" e2703cf^:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  public void testStructureModelForGenericITD_pr131932() {
 	  //AsmManager.setReporting("c:/debug.txt",true,true,true,true);
 	   
  	  // get the IProgramElements corresponding to the ITDs and classes
  	  IProgramElement foo = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.CLASS,"Foo");
  	  assertNotNull("Couldn't find Foo element in the tree",foo);
  	  IProgramElement bar = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.CLASS,"Bar");
  	  assertNotNull("Couldn't find Bar element in the tree",bar);
  	  IProgramElement method = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.INTER_TYPE_METHOD,"Bar.getFirst()");  	   	 
  	  assertNotNull("Couldn't find 'Bar.getFirst()' element in the tree",method);
  	  IProgramElement field = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.INTER_TYPE_FIELD,"Bar.children");  	   	 
  	  assertNotNull("Couldn't find 'Bar.children' element in the tree",field);
  	  IProgramElement constructor = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR,"Foo.Foo(List<T>)");  	   	 
  	  assertNotNull("Couldn't find 'Foo.Foo(List<T>)' element in the tree",constructor);
  	  
  	  // check that the relationship map has 'itd method declared on bar'
  	  List matches = AsmManager.getDefault().getRelationshipMap().get(method);
  	  assertNotNull("itd Bar.getFirst() should have some relationships but does not",matches);
  	  assertTrue("method itd should have one relationship but has " + matches.size(), matches.size() == 1);
  	  List matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("itd Bar.getFirst() should have one target but has " + matchesTargets.size(),matchesTargets.size() == 1);
  	  IProgramElement target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the Bar class but is IPE with label "
  			  + target.toLabelString(),bar,target);
  	  // check that the relationship map has 'itd field declared on bar'
  	  matches = AsmManager.getDefault().getRelationshipMap().get(field);
  	  assertNotNull("itd Bar.children should have some relationships but does not",matches);
  	  assertTrue("field itd should have one relationship but has " + matches.size(), matches.size() == 1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("itd Bar.children should have one target but has " + matchesTargets.size(),matchesTargets.size() == 1);
  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the Bar class but is IPE with label "
  			  + target.toLabelString(),bar,target);
  	  // check that the relationship map has 'itd constructor declared on foo'
  	  matches = AsmManager.getDefault().getRelationshipMap().get(constructor);
  	  assertNotNull("itd Foo.Foo(List<T>) should have some relationships but does not",matches);
  	  assertTrue("constructor itd should have one relationship but has " + matches.size(), matches.size() == 1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("itd Foo.Foo(List<T>) should have one target but has " + matchesTargets.size(),matchesTargets.size() == 1);
  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the Foo class but is IPE with label "
  			  + target.toLabelString(),foo,target);
  	  
  	  // check that the relationship map has 'bar aspect declarations method and field itd'
  	  matches = AsmManager.getDefault().getRelationshipMap().get(bar);
  	  assertNotNull("Bar should have some relationships but does not",matches);
  	  assertTrue("Bar should have one relationship but has " + matches.size(), matches.size() == 1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("Bar should have two targets but has " + matchesTargets.size(),matchesTargets.size() == 2);
  	  for (Iterator iter = matchesTargets.iterator(); iter.hasNext();) {
  	  // check that the relationship map has 'foo aspect declarations constructor itd'
 	  matches = AsmManager.getDefault().getRelationshipMap().get(foo);
  	  assertNotNull("Foo should have some relationships but does not",matches);
  	  assertTrue("Foo should have one relationship but has " + matches.size(), matches.size() == 1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("Foo should have one target but has " + matchesTargets.size(),matchesTargets.size() == 1);
 	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the Foo.Foo(List<T>) itd but is IPE with label "
  			  + target.toLabelString(),constructor,target);
  }
  
    <ajc-test dir="bugs151" title="structure model for generic itd">
        <compile files="pr131932.aj" options="-1.5 -emacssym"/>
    </ajc-test>
======= fetch "public ResolvedTypeMunger parameterizedFor(ResolvedType target) {" e2703cf^:"weaver/src/org/aspectj/weaver/NewConstructorTypeMunger.java"

======= fetch "public ResolvedTypeMunger parameterizedFor(ResolvedType target) {" e2703cf^:"weaver/src/org/aspectj/weaver/NewFieldTypeMunger.java"

======= fetch "public ResolvedTypeMunger parameterizedFor(ResolvedType target) {" e2703cf^:"weaver/src/org/aspectj/weaver/NewMethodTypeMunger.java"


        before(): GenericType<String>.foo() {}
        before(): GenericType<MyList>.foo() {}
        //before(): GenericType.foo() {}
        public pointcut foo(): execution(* T.*(..));
======= fetch "public void testSwallowedExceptionIgnored() {" f2cd94f^:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  
  public void testGenericAspectWithUnknownType_pr131933() {
  }
  
    <ajc-test dir="bugs151" title="no ClassCastException with generic aspect and unknown type">
        <compile files="pr131933.aj" options="-1.5">
          <message kind="error" line="5" text="can't bind type name 'MyList'"/>
        </compile>
    </ajc-test> 
======= fetch "public UnresolvedType resolveExactType(IScope scope, Bindings bindings) {" f2cd94f^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"


======= fetch "public boolean accept(File f) {" b3cd01d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeOutxmlFile () throws IOException {" b3cd01d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void addAspectName (String name) {" b3cd01d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void wipeAllKnowledge() {" b3cd01d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "public void testPr129163_3() {" b3cd01d^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= fetch "private static void log(String msg) {" b3cd01d^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


 * @version $Id: ClassGen.java,v 1.5 2005/03/10 12:15:04 aclement Exp $
======= fetch "public final boolean isEnum() {" 6e6658a^:"bcel-builder/src/org/aspectj/apache/bcel/generic/ClassGen.java"

  
  /**
   * Calculate the SerialVersionUID for a class.
   */  
  public long getSUID() {
  	try {
        Field[] fields   = getFields();
        Method[] methods = getMethods();
        
    	ByteArrayOutputStream baos = new ByteArrayOutputStream();
    	DataOutputStream dos = new DataOutputStream(baos);
    	
    	// 1. classname
    	dos.writeUTF(getClassName());
    	
    	// 2. classmodifiers: ACC_PUBLIC, ACC_FINAL, ACC_INTERFACE, and ACC_ABSTRACT
    	int classmods = 0; 
    	classmods|=(isPublic()?Constants.ACC_PUBLIC:0); 
    	classmods|=(isFinal()?Constants.ACC_FINAL:0);
    	classmods|=(isInterface()?Constants.ACC_INTERFACE:0);
    	if (isInterface() && isAbstract()) { // remove abstract if we have it but have no methods 
    		if (methods.length>0) classmods|=Constants.ACC_ABSTRACT;
    	}
    	dos.writeInt(classmods);
    	
    	// 3. ordered list of interfaces
    	List list = new ArrayList();
        String[] names = getInterfaceNames();
        if (names!=null) {
        	Arrays.sort(names);
        	for (int i = 0; i < names.length; i++) dos.writeUTF(names[i]);
        }
    
        // 4. ordered list of fields (ignoring private static and private transient fields):
        //  (relevant modifiers are ACC_PUBLIC, ACC_PRIVATE, 
        //   ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_VOLATILE, 
        //   ACC_TRANSIENT)
        list.clear();
        for (int i = 0; i < fields.length; i++) {
        Collections.sort(list,new FieldComparator());
        int relevantFlags = Constants.ACC_PUBLIC | Constants.ACC_PRIVATE | Constants.ACC_PROTECTED |
        					Constants.ACC_STATIC | Constants.ACC_FINAL | Constants.ACC_VOLATILE | Constants.ACC_TRANSIENT;
        for (Iterator iter = list.iterator(); iter.hasNext();) {
        // some up front method processing: discover clinit, init and ordinary methods of interest:
        list.clear(); // now used for methods
        List ctors = new ArrayList();
        boolean hasClinit = false;
        for (int i = 0; i < methods.length; i++) {
        	Method m = methods[i];
        	boolean couldBeInitializer = m.getName().charAt(0)=='<';
        	if (couldBeInitializer && m.getName().equals("<clinit>")) {
        		hasClinit=true;
        	} else if (couldBeInitializer && m.getName().equals("<init>")) {
        		if (!m.isPrivate()) ctors.add(m);
        	} else {
        	    if (!m.isPrivate()) list.add(m);
        	}
        Collections.sort(ctors, new ConstructorComparator());
        Collections.sort(list, new MethodComparator());
        
        
        if (hasClinit) {
        	dos.writeUTF("<clinit>");
        	dos.writeInt(Modifier.STATIC);
        	dos.writeUTF("()V");
        }
        
        // for methods and constructors: 
        //               ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, 
        //               ACC_NATIVE, ACC_ABSTRACT and ACC_STRICT
        relevantFlags = 	
        	Constants.ACC_PUBLIC | Constants.ACC_PRIVATE | Constants.ACC_PROTECTED |
        	Constants.ACC_STATIC | Constants.ACC_FINAL | Constants.ACC_SYNCHRONIZED | 
        	Constants.ACC_NATIVE | Constants.ACC_ABSTRACT | Constants.ACC_STRICT;
        
        for (Iterator iter = ctors.iterator(); iter.hasNext();) {
        // 7. sorted non-private methods 
        for (Iterator iter = list.iterator(); iter.hasNext();) {
        dos.flush();
        dos.close();
        byte[] bs = baos.toByteArray();
        MessageDigest md = MessageDigest.getInstance("SHA");
        byte[] result = md.digest(bs);
                
        long suid = 0L;
        int pos = result.length>8?7:result.length-1; // use the bytes we have
        while (pos>=0) {
        	suid = suid<<8 | ((long)result[pos--]&0xff);
        }
        // if it was definetly 8 everytime...
        //	    long suid = ((long)(sha[0]&0xff) | (long)(sha[1]&0xff) << 8  |
  	} catch (Exception e) {
  		System.err.println("Unable to calculate suid for "+getClassName());
  		throw new RuntimeException(e);
  	}
  }
  
  private static class FieldComparator implements Comparator {
  }
  private static class ConstructorComparator implements Comparator {
  }
  private static class MethodComparator implements Comparator {
  }
        <term>-XaddSerialVersionUID</term>
        <listitem><para>Causes the compiler to calculate and add
        the SerialVersionUID field to any type implementing
        Serializable that is affected by an aspect.  The field
        is calculated based on the class before weaving has
        taken place.
        </para></listitem>
      </varlistentry>
      
      <varlistentry>
======= fetch "public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r" 6e6658a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= fetch "public void installGlobals(AjBuildConfig global) { // XXX relies on default valu" 6e6658a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

        setAddSerialVerUID(global.isAddSerialVerUID());
======= fetch "public boolean isXdevPinpoint() {" 6e6658a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" 6e6658a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

  public static void main(String[] args) {
    try {
      Basic b = (Basic)Basic.class.newInstance();
      Field f = Basic.class.getDeclaredField("serialVersionUID");
      long l = f.getLong(b);
      System.err.println("SerialVersionUID is "+l);
    } catch (Exception e) {
      System.err.println("Problem: "+e.toString());
    }
  }
  public static void main(String[] args) {
  }
  
  public int anInt;
  
  public static boolean aBoolean = false;
  
  public long foo = 376;
  
  public void m() {}
  public int compareTo(Object o) { return 0;}
  public String m2(boolean b,long l, String s) { return "";}
  
  public static transient short fo2 = 3;
  
======= fetch "public static Test suite() {" 6e6658a^:"tests/src/org/aspectj/systemtest/ajc151/AllTestsAspectJ151.java"

 * Copyright (c) 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Andy Clement - initial implementation
 *******************************************************************************/
  public void testTheBasics() { runTest("basic"); }
  public void testTheBasicsWithLint() { runTest("basic - lint"); }
  public void testHorrible() { runTest("horrible"); }
  
  //
  public static Test suite() {
    return XMLBasedAjcTestCase.loadSuite(SerialVersionUIDTests.class);
  }
  protected File getSpecFile() {
    return new File("../tests/src/org/aspectj/systemtest/ajc151/serialversionuid.xml");
  }
    
    <ajc-test dir="features151/serialveruid" title="basic">
        <compile files="Basic.java" options="-1.5 -XaddSerialVersionUID"/>
        <run class="Basic">
          <stderr>
             <line text="SerialVersionUID is 7052682057082172300"/>
          </stderr>
        </run>
    </ajc-test>
    
    <ajc-test dir="features151/serialveruid" title="basic - lint">
        <compile files="Basic.java" options="-1.5 -XaddSerialVersionUID -Xlint:warning">
          <message kind="warning" text="calculated SerialVersionUID for type Basic"/>
        </compile>
        <run class="Basic">
          <stderr>
             <line text="SerialVersionUID is 7052682057082172300"/>
          </stderr>
        </run>
    </ajc-test>
    
    <ajc-test dir="features151/serialveruid" title="horrible">
        <compile files="BigHorribleClass.java,AnAspect.java" options="-1.5 -XaddSerialVersionUID -Xlint:warning">
          <message kind="warning" text="calculated SerialVersionUID for type BigHorribleClass"/>
        </compile>
        <run class="BigHorribleClass">
          <stderr>
             <line text="SerialVersionUID is 6512414869923012873"/>
          </stderr>
        </run>
    </ajc-test>
    
    private boolean addSerialVerUID = false;
    
    
======= fetch "public void forgetTypeVariablesCurrentlyBeingProcessed(Class baseClass) {" 6e6658a^:"weaver/src/org/aspectj/weaver/World.java"

    public void setAddSerialVerUID(boolean b) { addSerialVerUID=b;}
    public boolean isAddSerialVerUID() { return addSerialVerUID;}
    
======= fetch "public LazyClassGen(BcelObjectType myType) {" 6e6658a^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= fetch "public LazyClassGen(BcelObjectType myType) {" 6e6658a^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

        
======= fetch "private void addAjcInitializers() {" 6e6658a^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

    	if (tjpFields.size() == 0) return;
======= fetch "private void addAjcInitializers() {" 6e6658a^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

    	InstructionList il = initializeAllTjps();

======= fetch "public void testNonStandardOptions() {" b225911^:"ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java"

======= fetch "public void testNonStandardOptions() {" b225911^:"ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java"

        <term>-Xnoweave</term>
        <listitem><para>(Experimental) produce unwoven class files
        for input using -injars. (deprecated - .class files are by
        default reweavable and can be input using -inpath.)
            	noWeave,
                    (reweavable, noWeave, etc.).
======= fetch "public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r" b225911^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

        	} else if (arg.equals("-noweave") || arg.equals( "-XnoWeave")) {
======= fetch "public AjCompilerAdapter(Compiler compiler," b225911^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= fetch "public AjCompilerAdapter(Compiler compiler," b225911^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= fetch "public void afterCompiling(CompilationUnitDeclaration[] units) {" b225911^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= fetch "public void afterProcessing(CompilationUnitDeclaration unit, int unitIndex) {" b225911^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= fetch "public void installGlobals(AjBuildConfig global) { // XXX relies on default valu" b225911^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

        if (!isNoWeave() && global.isNoWeave()) {
            setNoWeave(true);
======= fetch "public void setLintMode(String lintMode) {" b225911^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= fetch "public boolean isNoWeave() {" b225911^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= fetch "public ICompilerAdapter getAdapter(org.aspectj.org.eclipse.jdt.internal.compiler" b225911^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public Map getMap() {" b225911^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= fetch "public void set(Map optionsMap) {" b225911^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= fetch "public void set(Map optionsMap) {" b225911^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= fetch "public void set(Map optionsMap) {" b225911^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= fetch "public String toString() {" b225911^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= fetch "public static void makeJar1a() throws IOException {" b225911^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"

======= fetch "public void testDefaultValues() {" b225911^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= fetch "public void testDirectSet() {" b225911^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= fetch "public void testDirectSet() {" b225911^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= fetch "public void testMapSet() {" b225911^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= fetch "public void testMapSet() {" b225911^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= fetch "public String toString() {" b225911^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

        // many now deprecated: reweavable*, noWeave, ...
======= fetch "public String toString() {" b225911^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

            	"noWeave","hasMember",
======= fetch "public void setVersion(boolean version) {" b225911^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    public void setXNoweave(boolean noweave) {  
        cmd.addFlag("-XnoWeave", noweave);
======= fetch "public void setXReweavable(boolean reweavable) {" b225911^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    public void setXNoWeave(boolean b) {
    	if (logger!=null) logger.warning("the noweave option is no longer required and is being ignored");
    }
    
    public void setNoWeave(boolean b) {
    	if (logger!=null) logger.warning("the noweave option is no longer required and is being ignored");
    }
    
======= fetch "String next() {" b225911^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

            } else if ("-Xnoweave".equals(flag)) {
                setXNoweave(true);
======= fetch "public void testDefaultFileComplete() {" b225911^:"taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java"

======= fetch "private CRSOptions() {" b225911^:"testing/src/org/aspectj/testing/harness/bridge/CompilerRun.java"

                        factory.create("XnoWeave"),
     -noweave \
======= fetch "public void testIllegalAccessErrorWithAroundAdviceNotSelf_pr119657() {" b225911^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testIllegalAccessErrorWithAroundAdviceNoWeaveLTW_pr119657() {
   <ajc-test dir="bugs150/pr119657" title="IllegalAccessError with around advice on interface method call using -XnoWeave and LTW">
     <compile files="accounts/recovery/Recovery.aj" options="-XnoWeave"/>
======= fetch "public void testRunThemAllWithJavacCompiledAndLTW() {" b225911^:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"

======= fetch "public void testJavaCAjcLTWPerClauseTest() {" b225911^:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"

    public void testAjcLTWAroundInlineMungerTest_XnoWeave() {
        runTest("AjcLTW AroundInlineMungerTest -XnoWeave");
    <ajc-test dir="java5/ataspectj" title="AjcLTW PerClauseTest -XnoWeave">
                options="-1.5 -XnoWeave"/>
                options="-1.5 -XnoWeave"/>
    <ajc-test dir="java5/ataspectj" title="AjcLTW AroundInlineMungerTest -XnoWeave">
                options="-1.5 -XnoWeave"/>
    		options="-1.5 -XnoWeave"
    		options="-1.5 -XnoWeave"
    		options="-1.5 -XnoWeave"
    		options="-1.5 -XnoWeave"
            options="-1.5 -XnoWeave"
            options="-1.5 -Xdev:NoAtAspectJProcessing -XnoWeave"
            options="-1.5 -Xdev:NoAtAspectJProcessing -XnoWeave"
            options="-1.5 -XnoWeave"/>
            options="-1.5 -XnoWeave"
======= fetch "public void test003(){" b225911^:"tests/src/org/aspectj/systemtest/inpath/InPathTests.java"

      title="The compiler crashes when using aspect libraries created without using -noweave">

======= fetch "public String getSignature() {" a116142^:"weaver/src/org/aspectj/weaver/JoinPointSignature.java"

======= fetch "public static Kind read(DataInputStream s) throws IOException {" a116142^:"weaver/src/org/aspectj/weaver/Member.java"

======= fetch "public MemberImpl(" a116142^:"weaver/src/org/aspectj/weaver/MemberImpl.java"

======= fetch "public  MemberImpl(" a116142^:"weaver/src/org/aspectj/weaver/MemberImpl.java"

======= fetch "public  MemberImpl(" a116142^:"weaver/src/org/aspectj/weaver/MemberImpl.java"

======= fetch "public String toLongString() {" a116142^:"weaver/src/org/aspectj/weaver/MemberImpl.java"

    /* (non-Javadoc)

 *   Adrian Colyer			Initial implementation
 * Problems with classes that are loaded by delegates
 * of our classloader
 * 
======= fetch "protected ReferenceTypeDelegate resolveDelegate(ReferenceType ty) {" cafdecb^:"weaver/src/org/aspectj/weaver/ltw/LTWWorld.java"

    protected ReferenceTypeDelegate resolveIfBootstrapDelegate(ReferenceType ty) {
        // first check for anything available in the bootstrap loader: these types are just defined from that without allowing nondelegation
    	String name = ty.getName();
        Reference bootRef = (Reference)bootstrapTypes.get(name);
        if (bootRef != null) {        	
        	ReferenceTypeDelegate rtd = (ReferenceTypeDelegate)bootRef.get();
        	if (rtd != null) {
        		return rtd;
        	}
        }
======= fetch "public Advice createAdviceMunger(AdviceAttribute attribute, Pointcut pointcut, M" cafdecb^:"weaver/src/org/aspectj/weaver/ltw/LTWWorld.java"

        char fc = name.charAt(0);
        if (fc=='j' || fc=='c' || fc=='o' || fc=='s') { // cheaper than imminent string startsWith tests
        }
        return null;
    }
    
    /**
     * Helper method to resolve the delegate from the reflection delegate factory.
     */
    private ReferenceTypeDelegate resolveReflectionTypeDelegate(ReferenceType ty, ClassLoader resolutionLoader) {
        ReferenceTypeDelegate res = ReflectionBasedReferenceTypeDelegateFactory.createDelegate(ty, this, resolutionLoader);
        return res;
    }
======= fetch "public ConcreteTypeMunger makeCflowStackFieldAdder(ResolvedMember cflowField) {" cafdecb^:"weaver/src/org/aspectj/weaver/ltw/LTWWorld.java"

    /**
     * Remove this class from the typeMap. Call back to be made from a publishing class loader
     * The class loader should, ideally, make this call on each
     * not yet working
     * 
     * @param clazz
     */
    public void loadedClass(Class clazz) {
    }
    
    private static final long serialVersionUID = 1;
======= fetch "public ConcreteTypeMunger makeCflowCounterFieldAdder(ResolvedMember cflowField)" cafdecb^:"weaver/src/org/aspectj/weaver/ltw/LTWWorld.java"

    public AnnotationFinder getAnnotationFinder() {
        return this.annotationFinder;
    }
======= fetch "public ConcreteTypeMunger makePerClauseAspect(ResolvedType aspect, Kind kind) {" cafdecb^:"weaver/src/org/aspectj/weaver/ltw/LTWWorld.java"

    /* (non-Javadoc)
     * @see org.aspectj.weaver.reflect.IReflectionWorld#resolve(java.lang.Class)
     */
    public ResolvedType resolve(Class aClass) {
        return ReflectionWorld.resolve(this, aClass); 
    }
======= fetch "public ConcreteTypeMunger concreteTypeMunger(ResolvedTypeMunger munger, Resolved" cafdecb^:"weaver/src/org/aspectj/weaver/ltw/LTWWorld.java"

    private static Map makeConcurrentMap() {
    	if (concurrentMapClass != null) {
    		try {
    			return (Map)concurrentMapClass.newInstance();
    		} catch (InstantiationException _) {
    		} catch (IllegalAccessException _) {    			
    		}
    		// fall through if exceptions
    	}
    	return Collections.synchronizedMap(new HashMap());
    }
    
    private static Class makeConcurrentMapClass() {
    	String betterChoices[] = { 
    			"java.util.concurrent.ConcurrentHashMap", 
    			"edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap", 
    			"EDU.oswego.cs.dl.util.concurrent.ConcurrentHashMap"
    	};
    	return null;
    }
    
 * Copyright (c) 2005 Contributors
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *    Ron Bodkin     initial implementation 
 * ******************************************************************/
 package org.aspectj.weaver.reflect;
======= fetch "public static ResolvedMember createResolvedMethod(Method aMethod, World inWorld)" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createResolvedMethod(Method aMethod, World inWorld)" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createResolvedMethod(Method aMethod, World inWorld)" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createResolvedAdviceMember(Method aMethod, World in" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createResolvedAdviceMember(Method aMethod, World in" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createResolvedAdviceMember(Method aMethod, World in" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createStaticInitMember(Class forType, World inWorld" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createResolvedConstructor(Constructor aConstructor," cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createResolvedConstructor(Constructor aConstructor," cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createResolvedConstructor(Constructor aConstructor," cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createResolvedField(Field aField, World inWorld) {" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createResolvedField(Field aField, World inWorld) {" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createResolvedField(Field aField, World inWorld) {" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createHandlerMember(Class exceptionType, Class inTy" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedType resolveTypeInWorld(Class aClass, World aWorld) {" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "private static ResolvedType toResolvedType(Class aClass, ReflectionWorld aWorld)" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public ReflectionShadow(World world, Kind kind, Member signature, Shadow enclosi" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= fetch "private ReflectionWorld() {" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= fetch "public ReflectionWorld(ClassLoader aClassLoader) {" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= fetch "public ReflectionWorld(ClassLoader aClassLoader) {" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= fetch "private void initializeAnnotationFinder(ClassLoader loader) {" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= fetch "private void initializeAnnotationFinder(ClassLoader loader) {" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= fetch "public AnnotationFinder getAnnotationFinder() {" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= fetch "public ResolvedType resolve(Class aClass) {" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= fetch "public ResolvedType resolve(Class aClass) {" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= fetch "public ResolvedType resolve(Class aClass) {" cafdecb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= fetch "public void testArrayTypes() {" cafdecb^:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.java"

======= fetch "public void testPrimitiveTypes() {" cafdecb^:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.java"


======= fetch "public void testSwallowedException() {" 3fa1bdd^:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

    </ajc-test>  
    
======= fetch "public UnresolvedType getExtraParameterType() {" 3fa1bdd^:"weaver/src/org/aspectj/weaver/Advice.java"


======= fetch "public boolean handleMessage(IMessage message) throws AbortException {" 89d66dc^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java"

======= fetch "public void testPr125405() {" 89d66dc^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


    @Pointcut("(execution(public * Foo.anotherMethod*(..)) || execution(public * Foo.methodA(..))) && this(obj)")
    protected void methodExec(Object obj){};
        
    @Before("methodExec(obj)")
    public void beforeMethodExec(JoinPoint thisJoinPoint, Object obj) {
      	System.out.println("Before " + thisJoinPoint.getSignature().toString());
    }
======= fetch "public void testAtAspectDeclareParentsRetainsFieldState_pr122370() {" ba42a09^:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  public void testAtAspectNoNPEWithPcdContainingOrThisAndWildcard_pr128237() {
  }
  
    <ajc-test dir="bugs151" title="@AJ no npe with pointcut containing or, this and a wildcard">
        <compile files="pr128237.java" options="-1.5"/>
    </ajc-test>
======= fetch "private void validateOrBranch(OrPointcut pc, Pointcut userPointcut, int numForma" ba42a09^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


======= fetch "public boolean validate() {" 7a2087e^:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

                    elligibleAbstractions.add(method.getName());

======= fetch "public Declare parseDeclare() {" f95d2c9^:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"


    static Object s;
    public static void main(String[] args) {
        String t = "Hello, World!";
        t.toString();
        if (s != t) throw new Error();
    }
    static abstract aspect GenericAspect<T> {
        abstract pointcut checkpoint(T t);
        // advice declaration causes error
        after(T t): checkpoint(t) { s = t;}
    }
    static aspect AAA extends GenericAspect<String>{
        pointcut checkpoint(String s) : target(s) && 
            call(String String.toString());
    }  
    
  public void testGenericAdviceParameters_pr123553()    { runTest("generic advice parameters");}
    <ajc-test dir="bugs151/pr123553" title="generic advice parameters">
        <compile files="A.java" options="-1.5"/>
        <run class="A"/>
    </ajc-test>  
    

   public interface Moody {
      Mood getMood();
      void setMood(Mood mood);
   }
   public static class MoodyImpl implements Moody {
      private Mood mood = Mood.HAPPY;
      public Mood getMood() { return mood; }
      public void setMood(Mood mood) { this.mood = mood; }
   }
  
   private Moody implementedInterface;
======= fetch "public void testAtAspectWithoutJoinPointImport_pr121616() {" e874581^:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  public void testAtAspectDeclareParentsRetainsFieldState_pr122370() {
  }
  
    <ajc-test dir="bugs151/pr122370" title="@AJ declare parents retains field state">
        <compile files="moody/AnnotationMoodImplementor.java, moody/AnnotationMoodIndicator.java, moody/Mood.java, moody/MainClass.java" options="-1.5"/>
       <run class="moody.MainClass">
            <stdout>
             <line text="ami0's mood is HAPPY"/>
             <line text="ami1's mood is now JOLLY"/>
             <line text="ami0's mood is still HAPPY"/>
            </stdout>
        </run>
    </ajc-test>
======= fetch "private boolean mungeMethodDelegate(BcelClassWeaver weaver, MethodDelegateTypeMu" e874581^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

            BranchInstruction ifNonNull = InstructionFactory.createBranchInstruction(Constants.IFNULL, null);
======= fetch "private boolean mungeMethodDelegate(BcelClassWeaver weaver, MethodDelegateTypeMu" e874581^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

            InstructionHandle ifNonNullElse = body.append(InstructionConstants.ALOAD_0);
======= fetch "private boolean mungeMethodDelegate(BcelClassWeaver weaver, MethodDelegateTypeMu" e874581^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

            
            // if not null use the instance we've got
            InstructionHandle ifNonNullElse =  body.append(InstructionConstants.ALOAD_0);
======= fetch "private boolean mungeMethodDelegate(BcelClassWeaver weaver, MethodDelegateTypeMu" e874581^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

            body.append(InstructionConstants.ALOAD_0);

======= fetch "public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {" d4219e1^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

        public static void main(String[] args) {
                System.out.println("Main");
        }
    @Before("execution(* main(..))")
    public void log(JoinPoint thisJoinPoint) {
            System.out.println("Before " + thisJoinPoint);
    }
======= fetch "public void testAtAspectNoNPEWithDEOWWithoutStructureModel_pr120356() {" d4219e1^:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  public void testAtAspectWithoutJoinPointImport_pr121616() {
  }
  
    <ajc-test dir="bugs151" title="@AJ without JoinPoint import">
        <compile files="pr121616.java" options="-1.5">
          <message kind="error" line="13" text="JoinPoint cannot be resolved to a type"/>
        </compile>
    </ajc-test>

======= fetch "public void testPr113531() {" 0b39aa5^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= fetch "public Collection weave(IClassFileProvider input) throws IOException {" 0b39aa5^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


    static final String warning = "warning";
    @DeclareError("execution(* C.badMethod())")
    static final String error = "error";
======= fetch "public void testAtAspectInheritsAbstractPointcut_pr125810 () {" f743fb2^:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  public void testAtAspectDEOWInStructureModel_pr120356() {
  	  IHierarchy top = AsmManager.getDefault().getHierarchy();
  	   
  	  // get the IProgramElements corresponding to the @DeclareWarning statement
  	  // and the method it matches.
  	  IProgramElement warningMethodIPE = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.METHOD,"warningMethod()");  	   	 
  	  assertNotNull("Couldn't find 'warningMethod()' element in the tree",warningMethodIPE);
  	  IProgramElement atDeclareWarningIPE = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.FIELD,"warning");
  	  assertNotNull("Couldn't find @DeclareWarning element in the tree",atDeclareWarningIPE);
  	  // check that the method has a matches declare relationship with @DeclareWarning
  	  List matches = AsmManager.getDefault().getRelationshipMap().get(warningMethodIPE);	
  	  assertNotNull("warningMethod should have some relationships but does not",matches);
  	  assertTrue("warningMethod should have one relationships but has " + matches.size(),matches.size()==1);
  	  List matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("warningMethod should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
  	  IProgramElement target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the @DeclareWarning 'warning' but is IPE with label "
  			  + target.toLabelString(),atDeclareWarningIPE,target);
  	  
  	  // check that the @DeclareWarning has a matches relationship with the warningMethod
  	  List matchedBy = AsmManager.getDefault().getRelationshipMap().get(atDeclareWarningIPE);
  	  assertNotNull("@DeclareWarning should have some relationships but does not",matchedBy);
  	  assertTrue("@DeclareWarning should have one relationship but has " + matchedBy.size(), matchedBy.size() == 1);
  	  List matchedByTargets = ((Relationship)matchedBy.get(0)).getTargets();
  	  assertTrue("@DeclareWarning 'matched by' relationship should have one target " +
  	  		"but has " + matchedByTargets.size(), matchedByTargets.size() == 1);
  	  IProgramElement matchedByTarget = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchedByTargets.get(0));
  	  assertEquals("target of relationship should be the warningMethod but is IPE with label "
  			  + matchedByTarget.toLabelString(),warningMethodIPE,matchedByTarget);
  	  
  	  // get the IProgramElements corresponding to the @DeclareError statement
  	  // and the method it matches.
  	  IProgramElement errorMethodIPE = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.METHOD,"badMethod()");  	   	 
  	  assertNotNull("Couldn't find 'badMethod()' element in the tree",errorMethodIPE);
  	  IProgramElement atDeclarErrorIPE = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.FIELD,"error");
  	  assertNotNull("Couldn't find @DeclareError element in the tree",atDeclarErrorIPE);
  	  // check that the @DeclareError has a matches relationship with the badMethod
  	  List matchedByE = AsmManager.getDefault().getRelationshipMap().get(atDeclarErrorIPE);
  	  assertNotNull("@DeclareError should have some relationships but does not",matchedByE);
  	  assertTrue("@DeclareError should have one relationship but has " + matchedByE.size(), matchedByE.size() == 1);
  	  List matchedByTargetsE = ((Relationship)matchedByE.get(0)).getTargets();
  	  assertTrue("@DeclareError 'matched by' relationship should have one target " +
  	  		"but has " + matchedByTargetsE.size(), matchedByTargetsE.size() == 1);
  	  IProgramElement matchedByTargetE = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchedByTargetsE.get(0));
  	  assertEquals("target of relationship should be the badMethod but is IPE with label "
  			  + matchedByTargetE.toLabelString(),errorMethodIPE,matchedByTargetE);
  }
  
  public void testAtAspectNoNPEWithDEOWWithoutStructureModel_pr120356() {
  }
  
    <ajc-test dir="bugs151/pr120356" title="@AJ deow appear correctly when structure model is generated">
        <compile files="C.java, A.java" options="-1.5, -emacssym">
         <message kind="error" line="8" text="error"/>
          <message kind="warning" line="5" text="warning"/>
        </compile>
    </ajc-test> 
    <ajc-test dir="bugs151/pr120356" title="@AJ no NPE with deow when structure model isn't generated">
        <compile files="C.java, A.java" options="-1.5">
         <message kind="error" line="8" text="error"/>
          <message kind="warning" line="5" text="warning"/>
        </compile>
    </ajc-test>
======= fetch "private static boolean handleDeclareErrorOrWarningAnnotation(RuntimeAnnotations" f743fb2^:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

                    deow.setLocation(struct.context, -1, -1);
======= fetch "private static boolean handleDeclareErrorOrWarningAnnotation(RuntimeAnnotations" f743fb2^:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

                    deow.setLocation(struct.context, -1, -1);
======= fetch "private static boolean handleDeclareErrorOrWarningAnnotation(RuntimeAnnotations" f743fb2^:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

     * Sets the location for the declare error / warning using the corresponding 
     * IProgramElement in the structure model. This will only fix bug 120356 if
     * compiled with -emacssym, however, it does mean that the cross references 
     * view in AJDT will show the correct information.
     * 
     * Other possibilities for fix: 
     *  1. using the information in ajcDeclareSoft (if this is set correctly) 
     *     which will fix the problem if compiled with ajc but not if compiled 
     *     with javac.
     *  2. creating an AjAttribute called FieldDeclarationLineNumberAttribute 
     *     (much like MethodDeclarationLineNumberAttribute) which we can ask 
     *     for the offset. This will fix bug 120356 both when compiled with ajc 
     *     and javac.
     * 
     * @param deow
     * @param struct
     */
    private static void setDeclareErrorOrWarningLocation(DeclareErrorOrWarning deow, AjAttributeFieldStruct struct) {
        IHierarchy top = AsmManager.getDefault().getHierarchy();
        if (top.getRoot() != null) {
        	IProgramElement ipe = top.findElementForLabel(top.getRoot(),
      			  IProgramElement.Kind.FIELD,struct.field.getName());
        	if (ipe != null && ipe.getSourceLocation() != null) {
    			ISourceLocation sourceLocation = ipe.getSourceLocation();
    			int start = sourceLocation.getOffset();
    			int end = start + struct.field.getName().length();
    			deow.setLocation(struct.context,start,end);
    			return;
    		}
        deow.setLocation(struct.context, -1, -1);												
    }
    
    /**

======= fetch "private boolean acceptResource(String resourceName) {" d856e4f^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"


======= fetch "public AjTypeDeclaration(AST ast) {" eec4990^:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjTypeDeclaration.java"

======= fetch "boolean internalGetSetBooleanProperty(SimplePropertyDescriptor property, boolean" eec4990^:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjTypeDeclaration.java"

 	/**
 	 * Returns a list of structural property descriptors for this node type.
 	 * Clients must not modify the result.
 	 * 
 	 * @param apiLevel the API level; one of the
 	 * <code>AST.JLS&ast;</code> constants
 	 * @return a list of property descriptors (element type: 
 	 * {@link StructuralPropertyDescriptor})
 	 * @since 3.0
 	 */
 	public static List propertyDescriptors(int apiLevel) {
 		if (apiLevel == AST.JLS2_INTERNAL) {
 			return ajPROPERTY_DESCRIPTORS_2_0;
 		} else {
 			return ajPROPERTY_DESCRIPTORS_3_0;
 		}
 	}
 	
======= fetch "final ASTNode internalGetSetChildProperty(ChildPropertyDescriptor property,boole" eec4990^:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AspectDeclaration.java"

======= fetch "public void testPropertyDescriptorsForAspectDeclaration() {" eec4990^:"org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/AjASTTest.java"

======= fetch "public void testPropertyDescriptorsForAspectDeclaration() {" eec4990^:"org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/AjASTTest.java"

======= fetch "public void testPropertyDescriptorsForAspectDeclaration() {" eec4990^:"org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/AjASTTest.java"

======= fetch "public void testGetAndSetIsAspect() {" eec4990^:"org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/AjASTTest.java"


======= fetch "public UnresolvedType ensureTargetTypeIsCorrect(UnresolvedType tx) {" 4934132^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

            	return lvt.getType();
======= fetch "public UnresolvedType ensureTargetTypeIsCorrect(UnresolvedType tx) {" 4934132^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

              searchPtr.getInstruction());

======= fetch "public void endVisit(QualifiedNameReference ref, BlockScope scope) {" 693945f^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "public void endVisit(QualifiedNameReference ref, BlockScope scope) {" 693945f^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

   public void x(){} 
   void around():call(void *(..)){ 
      A a = new A();
      a.A.a.x(); // This line raises the NPE    
      proceed();    
   }
       @Pointcut("")
       protected void scope () {}
  //public void testEmptyPointcut_pr125475()    { runTest("empty pointcut in atAJ");}
  public void testInlinevisitorNPE_pr123901() { runTest("inlinevisitor NPE");}
    </ajc-test>  
    
    <ajc-test dir="bugs151/pr123901" title="inlinevisitor NPE">
        <compile files="A.java,B.java" options="-1.5">
          <message kind="error" line="5" text="a.A cannot be resolved or is not a field"/>
        </compile>
    <ajc-test dir="bugs151/pr125475" title="empty pointcut in atAJ">
        <compile files="TestEmptyPointcutAtAspect.java" options="-1.5"/>
    </ajc-test>

======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" 551b446^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public static void configureNonStandardCompileOptions(String options) {" 551b446^:"tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"

======= fetch "protected void setUp() throws Exception {" 551b446^:"tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"

======= fetch "public static ProjectPropertiesAdapter getInstance() {" 551b446^:"tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"

======= fetch "public static ProjectPropertiesAdapter getInstance() {" 551b446^:"tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"

======= fetch "public void setClasspath(String path) {" 551b446^:"tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"

======= fetch "public Set getAspectPath() {" 551b446^:"tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"

======= fetch "public void testTheBasics() {" 551b446^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


======= fetch "public String toString() {" 7e40a60^:"asm/src/org/aspectj/asm/IProgramElement.java"

======= fetch "public String toString() {" 7e40a60^:"asm/src/org/aspectj/asm/IProgramElement.java"

======= fetch "public String toString() {" 7e40a60^:"asm/src/org/aspectj/asm/IProgramElement.java"

======= fetch "public String toSignatureString() {" 7e40a60^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String toSignatureString() {" 7e40a60^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String toSignatureString() {" 7e40a60^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String toSignatureString() {" 7e40a60^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String toLinkLabelString() {" 7e40a60^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String toLinkLabelString() {" 7e40a60^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String toLinkLabelString() {" 7e40a60^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String toLabelString() {" 7e40a60^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String toLabelString() {" 7e40a60^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "private void setParameters(MethodDeclaration md, IProgramElement pe) {" 7e40a60^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java"

======= fetch "public void testMixingNumbersOfTypeParameters_pr125080_2() {" 7e40a60^:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  public void testIProgramElementMethods_pr125295() {
  	  IHierarchy top = AsmManager.getDefault().getHierarchy();
  	  IProgramElement pe = top.findElementForType("pkg","foo");
  	  assertNotNull("Couldn't find 'foo' element in the tree",pe);
  	  // check that the defaults return the fully qualified arg
  	  assertEquals("foo(int, java.lang.Object)",pe.toLabelString());
  	  assertEquals("C.foo(int, java.lang.Object)",pe.toLinkLabelString());
  	  assertEquals("foo(int, java.lang.Object)",pe.toSignatureString());
  	  // check that can get hold of the non qualified args
  	  assertEquals("foo(int, Object)",pe.toLabelString(false));
  	  assertEquals("C.foo(int, Object)",pe.toLinkLabelString(false));
  	  assertEquals("foo(int, Object)",pe.toSignatureString(false));
  	  IProgramElement pe2 = top.findElementForType("pkg","printParameters");
  	  assertNotNull("Couldn't find 'printParameters' element in the tree",pe2);
  	  // the argument is org.aspectj.lang.JoinPoint, check that this is added
  	  assertFalse("printParameters method should have arguments",pe2.getParameterTypes().isEmpty());	  
  }
  
    <ajc-test dir="bugs151/pr125295" title="new IProgramElement methods">
        <compile files="pkg/C.java,pkg/A.aj" options="-emacssym"/>
    </ajc-test>

======= fetch "public BcelObjectType addSourceObjectType(JavaClass jc) {" efb20c5^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"


======= fetch "private MethodBinding getAccessibleMethod(MethodBinding binding, TypeBinding rec" a4bd19d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

   protected  T getSomething() {
       return null;
   }
   // Runtime Error
   void around() : execution(void someMethod()) {
       System.out.println(getSomething());
   }
   public static void main(String[] args) {
     new C().someMethod();
   }
   
   public void someMethod() { }
  public void testCallInheritedGenericMethod_pr124999() { runTest("calling inherited generic method from around advice");}
    <ajc-test dir="bugs151" title="calling inherited generic method from around advice">
        <compile files="pr124999.aj" options="-1.5"/>
        <run class="pr124999"/>
    </ajc-test>
    

    // main
    public static void main(String[] args) {
        for (String arg : args) {
            System.out.println("got: " + arg);
        }
    }
    pointcut printlnCalls(PrintStream ps, String out):
        call(* PrintStream+.println(String)) && target(ps) && args(out);
    Object around(PrintStream ps, String out):
        printlnCalls(ps, out) && !adviceexecution() {
        return proceed(ps, out);
    }
    // main
    public static void main(String[] args) {
        for (String arg : args) {
            System.out.println("got: " + arg);
            System.out.printf("got: %s\n", arg);
        }
    }
    pointcut printlnCalls(PrintStream ps, String out):
        call(* PrintStream+.println(String)) && target(ps) && args(out);
    Object around(PrintStream ps, String out):
        printlnCalls(ps, out) && !adviceexecution() {
        return proceed(ps, out);
    }
    pointcut printfCalls(PrintStream ps, String fmt, Object[] objs):
        call(* PrintStream+.printf(String, Object...))
        && target(ps) && args(fmt, objs);
======= fetch "public void testPr115251() {" d916002^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


   pointcut annotatedCall(A a) : call(@A * *.*(..)) && @annotation(a);
   before(A a) : annotatedCall(a) {
       System.err.println("Reference pointcut advice. "+a.annotationType());
   }
   before(A a) : call(@A * *.*(..)) && @annotation(a) {
       System.err.println("Inlined pointcut advice. "+a.annotationType());
   }
  public static void main(String []argv) {
    new BasicType().run();
  }
  @MyAnnotation
  public void run() {
    System.err.println("run running");
  }
  public void testGenericAspectsAndAnnotations_pr124654() { runTest("generic aspects and annotations");}
    
    <ajc-test dir="bugs151/pr124654" title="generic aspects and annotations">
        <compile files="GenericAnnotation.java,TestSubAspect.java" options="-1.5"/>
        <run class="TestSubAspect">
          <stderr>
            <line text="Reference pointcut advice. interface MyAnnotation"/>
            <line text="Inlined pointcut advice. interface MyAnnotation"/>
            <line text="run running"/>
          </stderr>
        </run>
    </ajc-test>
======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" 28f8c69^:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"


       Set<T> ints = new HashSet<T>();
       public Set<T> foo() {
               return ints;
       }
       public static void main(String[] args) {
               Test<Integer> t2 = new Test<Integer>();
               Set<Integer> ints2 = t2.foo();
       }
   pointcut gettingMemberCollection() : get(Set<Number+> *);
   after() : gettingMemberCollection() {
     System.err.println("GO Aspects!  "+thisJoinPoint);
   }
  public void testParameterizedCollectionFieldMatching_pr124808() { runTest("parameterized collection fields matched via pointcut");}
    
    <ajc-test dir="bugs151/pr124808" title="parameterized collection fields matched via pointcut">
        <compile files="Test.java,TestAspect.java" options="-1.5"/>
        <run class="Test">
          <stderr>
             <line text="GO Aspects!  get(Set Test.ints)"/>
          </stderr>
        </run>
    </ajc-test>
======= fetch "private boolean matchesTypeVariable(TypeVariableReferenceType matchType) {" 01a8b2e^:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= fetch "protected boolean matchesSubtypes(ResolvedType type) {" 01a8b2e^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= fetch "protected boolean matchesSubtypes(ResolvedType type) {" 01a8b2e^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"


  public void foo(T p);
  public void foo2(Y p);
  public void foo2(Y p) { }
  public void foo(Y p) { }
  public static void main(String []argv) {
    Test<Integer> t = new Test<Integer>();
    t.foo(7);
    t.foo2(9);
  }
  public void foo(T p) { }
  public void foo2(Y p) {}
  public void foo2(Y p) { }
  public void foo(Y p) { }
  public static void main(String []argv) {
    Test2<Integer> t = new Test2<Integer>();
    t.foo(7);
    t.foo2(9);
  }
       pointcut TestInheritance(Test test) : target(test) && execution (* Generic1.*(..));
       after (Test test) : TestInheritance(test) {
               System.err.println("Aspects:"+thisJoinPoint);
       }
       pointcut TestInheritance(Test2 test) : target(test) && execution (* Generic1.*(..));
       after (Test2 test) : TestInheritance(test) {
               System.err.println("Aspects:"+thisJoinPoint);
       }
  public void testDifferentNumbersofTVars_pr124803() { runTest("generics and different numbers of type variables");}
  public void testDifferentNumbersofTVars_pr124803_2() { runTest("generics and different numbers of type variables - classes");}
    <ajc-test dir="bugs151/pr124803" title="generics and different numbers of type variables">
        <compile files="Test.java,TestAspect.java" options="-1.5 -showWeaveInfo">
          <message kind="weave" text="Join point 'method-execution(void Test.foo(java.lang.Number))' in Type 'Test' (Test.java:12) advised by after advice from 'TestAspect' (TestAspect.java:4)"/>
        </compile>
        <run class="Test">
          <stderr>
             <line text="Aspects:execution(void Test.foo(Number))"/>
          </stderr>
        </run>
    </ajc-test>
    
    <ajc-test dir="bugs151/pr124803" title="generics and different numbers of type variables - classes">
        <compile files="Test2.java,TestAspect2.java" options="-1.5 -showWeaveInfo">
          <message kind="weave" text="Join point 'method-execution(void Test2.foo(java.lang.Number))' in Type 'Test2' (Test2.java:12) advised by after advice from 'TestAspect2' (TestAspect2.java:4)"/>
        </compile>
        <run class="Test2">
          <stderr>
             <line text="Aspects:execution(void Test2.foo(Number))"/>
          </stderr>
        </run>
    </ajc-test>
======= fetch "public WeaverStateInfo getWeaverState() {" 8676df9^:"weaver/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public WeaverStateInfo getWeaverState() {" 8676df9^:"weaver/src/org/aspectj/weaver/ReferenceType.java"


    protected TypeMap typeMap = new TypeMap(); // Signature to ResolvedType
======= fetch "public boolean isTargettingAspectJRuntime12() {" 04067a6^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public boolean isTargettingAspectJRuntime12() {" 04067a6^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public boolean isTargettingAspectJRuntime12() {" 04067a6^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public boolean isTargettingAspectJRuntime12() {" 04067a6^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public ResolvedType put(String key, ResolvedType type) {" 04067a6^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public ResolvedType put(String key, ResolvedType type) {" 04067a6^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public ResolvedType put(String key, ResolvedType type) {" 04067a6^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public ResolvedType get(String key) {" 04067a6^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public ResolvedType get(String key) {" 04067a6^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public ResolvedType remove(String key) {" 04067a6^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public ResolvedType remove(String key) {" 04067a6^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "private String dumpthem(Map m) {" 04067a6^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "private String dumpthem(Map m) {" 04067a6^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "private String dumpthem(Map m) {" 04067a6^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "private String dumpthem(Map m) {" 04067a6^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public void tidyUp() {" 04067a6^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"


======= fetch "public void testPr113257() {" ab2f89b^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= fetch "private void clearCaches() {" ab2f89b^:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"


 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 *     Mik Kersten	  port to AspectJ 1.1+ code base
 * ******************************************************************/
 * @author Mik Kersten
 * @deprecated org.aspectj.asm.IProgramElement should be used instead
 */
    private int beginLine;
    private int endLine;
    private int beginColumn;
    private int endColumn;
    private String modifiers;
    private String fullSignature;
    private String signature;
    private String crosscutDesignator;
    private String packageName;
    private String kind;
    private String declaringType;
    private String filename;
    private String formalComment;
    private Declaration[] declarations;
    private Handle crosscutDeclarationHandle;
    private Handle[] pointedToByHandles;
    private Handle[] pointsToHandles;
    transient private Declaration crosscutDeclaration;
    transient private Declaration[] pointedToBy = null;
    transient private Declaration[] pointsTo = null;
    private Declaration parentDeclaration = null;
    public Declaration(int beginLine, int endLine, int beginColumn, int endColumn,
                       String modifiers, String signature, String fullSignature,
                       String crosscutDesignator,
                       String declaringType, String kind,
                       String filename, String formalComment,
                       String packageName,
    {
        this.beginLine = beginLine;
        this.endLine = endLine;
        this.beginColumn = beginColumn;
        this.endColumn = endColumn;
        this.modifiers = modifiers;
        this.signature = signature;
        this.fullSignature = fullSignature;
        this.crosscutDesignator = crosscutDesignator;
        this.declaringType = declaringType;
        this.kind = kind;
        this.filename = filename;
        this.formalComment = formalComment;
        this.packageName = packageName;
        this.pointedToByHandles = new Handle[0];
        this.pointsToHandles = new Handle[0];
        //???
        this.declarations = new Declaration[0];
        this.node = node;
    }
    public int getBeginLine() { return beginLine; }
    public int getEndLine() { return endLine; }
    public int getBeginColumn() { return beginColumn; }
    public int getEndColumn() { return endColumn; }
    public String getModifiers() { return modifiers; }
    public String getFullSignature() { return fullSignature; }
    public String getSignature() { return signature; }
    public String getPackageName() { return packageName; }
    public String getCrosscutDesignator() { return crosscutDesignator; }
    public Declaration getParentDeclaration() { return parentDeclaration; }
    public Declaration getCrosscutDeclaration() {
        if (crosscutDeclaration == null && crosscutDeclarationHandle != null) {
            crosscutDeclaration = crosscutDeclarationHandle.resolve();
        }
        return crosscutDeclaration;
    }
    public void setCrosscutDeclaration(Declaration _crosscutDeclaration) {
        crosscutDeclaration = _crosscutDeclaration;
    }
    public String getDeclaringType() { return declaringType; }
    public String getKind() {
        if (kind.startsWith("introduced-")) {
            return kind.substring(11);
        } else {
            return kind;
        }
    }
    public String getFilename() { return filename; }
    public String getFormalComment() { return formalComment; }
    public Declaration[] getDeclarations() {
        return declarations;
    }
    public void setDeclarations(Declaration[] decs) {
        declarations = decs;
        if (decs != null) {
            for (int i = 0; i < decs.length; i++) {
                decs[i].parentDeclaration = this;
            }
        }
    }
    public void setPointedToBy(Declaration[] decs) { pointedToBy = decs; }
    public void setPointsTo(Declaration[] decs) { pointsTo = decs; }
    public Declaration[] getPointedToBy() {
        if (pointedToBy == null) {
            pointedToBy = resolveHandles(pointedToByHandles);
        }
        return pointedToBy; //.elements();
    }
    public Declaration[] getPointsTo() {
        if (pointsTo == null) {
            pointsTo = resolveHandles(pointsToHandles);
        }
        return pointsTo; //.elements();
    }
    private Declaration[] filterTypes(Declaration[] a_decs) {
        List decs = new LinkedList(Arrays.asList(a_decs));
        for(Iterator i = decs.iterator(); i.hasNext(); ) {
            Declaration dec = (Declaration)i.next();
            if (!dec.isType()) i.remove();
        }
        return (Declaration[])decs.toArray(new Declaration[decs.size()]);
    }
    public Declaration[] getTargets() {
        Declaration[] pointsTo = getPointsTo();
        if (kind.equals("advice")) {
            return pointsTo;
        } else if (kind.equals("introduction")) {
            return filterTypes(pointsTo);
        } else {
            return new Declaration[0];
        }
    }
    // Handles are used to deal with dependencies between Declarations in different files
    private Handle getHandle() {
        return new Handle(filename, beginLine, beginColumn);
    }
    private Declaration[] resolveHandles(Handle[] handles) {
        Declaration[] declarations = new Declaration[handles.length];
        int missed = 0;
        for(int i=0; i<handles.length; i++) {
            //if (handles[i] == null) continue;
            declarations[i] = handles[i].resolve();
            if (declarations[i] == null) missed++;
        }
        if (missed > 0) {
            Declaration[] decs = new Declaration[declarations.length - missed];
            for (int i=0, j=0; i < declarations.length; i++) {
                if (declarations[i] != null) decs[j++] = declarations[i];
            }
            declarations = decs;
        }
        return declarations;
    }
    private Handle[] getHandles(Declaration[] declarations) {
        Handle[] handles = new Handle[declarations.length];
        for(int i=0; i<declarations.length; i++) {
            //if (declarations[i] == null) continue;
            handles[i] = declarations[i].getHandle();
        }
        return handles;
    }
    // Make sure that all decs are convertted to handles before serialization
    private void writeObject(ObjectOutputStream out) throws IOException {
        pointedToByHandles = getHandles(getPointedToBy());
        pointsToHandles = getHandles(getPointsTo());
        if (crosscutDeclaration != null) {
           crosscutDeclarationHandle = crosscutDeclaration.getHandle();
        }
        out.defaultWriteObject();
    }
    // support functions
    public Declaration[] getCrosscutDeclarations() {
        return getDeclarationsHelper("pointcut");
    }
    public Declaration[] getAdviceDeclarations() {
        return getDeclarationsHelper("advice");
    }
    public Declaration[] getIntroductionDeclarations() {
        return getDeclarationsHelper("introduction");
    }
    private Declaration[] getDeclarationsHelper(String kind) {
        Declaration[] decls  = getDeclarations();
        List result = new ArrayList();
        for ( int i = 0; i < decls.length; i++ ) {
            Declaration decl = decls[i];
            if ( decl.getKind().equals(kind) ) {
                result.add(decl);
            }
        }
        return (Declaration[])result.toArray(new Declaration[result.size()]);
    }
    public boolean isType() {
    }
    public boolean hasBody() {
        String kind = getKind();
        return kind.equals("class") || kind.endsWith("constructor") ||
            (kind.endsWith("method") && getModifiers().indexOf("abstract") == -1 &&
              getModifiers().indexOf("native") == -1);
    }  
    public boolean isIntroduced() {
        return kind.startsWith("introduced-");
    }
    public boolean hasSignature() {
        String kind = getKind();
        if ( kind.equals( "class" ) ||
             kind.equals( "interface" ) ||
             kind.equals( "initializer" ) ||
             kind.equals( "field" ) ||
             kind.equals( "constructor" ) ||
             kind.equals( "method" ) ) {
            return true;
        }
        else {
            return false;
        }
    }
    private static class Handle implements Serializable {
        public String filename;
        public int line, column;
        public Handle(String filename, int line, int column) {
            this.filename = filename;
            this.line = line;
            this.column = column;
        }
        public Declaration resolve() {
            SymbolManager manager = SymbolManager.getDefault();
            return manager.getDeclarationAtPoint(filename, line, column);
        }
    }
    static SymbolManager symbolManager = null;
======= fetch "static void decorateHTMLFromInputFiles(Hashtable table," f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

                                           SymbolManager sm,
======= fetch "static void decorateHTMLFromInputFiles(Hashtable table," f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        symbolManager = sm;
======= fetch "static void decorateHTMLFromInputFiles(Hashtable table," f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

            decorateHTMLFromDecls(symbolManager.getDeclarations(inputFiles[i].getCanonicalPath()),
                                  rootDir.getCanonicalPath() + Config.DIR_SEP_CHAR,
                                  docModifier,
                                  false);
======= fetch "static void decorateHTMLFromInputFiles(Hashtable table," f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

    static void decorateHTMLFromDecls(Declaration[] decls, String base, String docModifier, boolean exceededNestingLevel) throws IOException {
======= fetch "static void decorateHTMLFromDecls(Declaration[] decls, String base, String docMo" f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

                Declaration decl = decls[i];
                decorateHTMLFromDecl(decl, base, docModifier, exceededNestingLevel);
======= fetch "static void decorateHTMLFromDecls(Declaration[] decls, String base, String docMo" f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

    static void decorateHTMLFromDecl(Declaration decl,
                                     String base,
                                     String docModifier,
                                     boolean exceededNestingLevel ) throws IOException {
        boolean nestedClass = false;
        if ( decl.isType() ) {
            boolean decorateFile = true;
            if (isAboveVisibility(decl.getNode())) {
                visibleFileList.add(decl.getSignature());
                String packageName = decl.getPackageName();
                String filename    = "";
                if ( packageName != null ) {
                   
                   int index1 = base.lastIndexOf(Config.DIR_SEP_CHAR);
                   int index2 = base.lastIndexOf(".");
                   String currFileClass = "";
                   if (index1 > -1 && index2 > 0 && index1 < index2) {
                      currFileClass = base.substring(index1+1, index2);
                   }
                   
                   // XXX only one level of nexting
                   if (currFileClass.equals(decl.getDeclaringType())) {
                   	  nestedClass = true;
                      packageName = packageName.replace( '.','/' );
                      String newBase = "";
                      if ( base.lastIndexOf(Config.DIR_SEP_CHAR) > 0 ) {
                         newBase = base.substring(0, base.lastIndexOf(Config.DIR_SEP_CHAR));
                      }
                      String signature = constructNestedTypeName(decl.getNode());
                     
                      filename = newBase + Config.DIR_SEP_CHAR + packageName +
                                 Config.DIR_SEP_CHAR + currFileClass + //"." +
                                 signature + ".html"; 
                   } else {
                       packageName = packageName.replace( '.','/' ); 
                       filename = base + packageName + Config.DIR_SEP_CHAR + decl.getSignature() + ".html";
                   }
                }
                else {
                    filename = base + decl.getSignature() + ".html";
                }
                if (!exceededNestingLevel) {
                    
                   decorateHTMLFile(new File(filename));
                   
                   decorateHTMLFromDecls(decl.getDeclarations(),
                                         base + decl.getSignature() + ".",
                                         docModifier,
                                         nestedClass);
                }
                else {
                   System.out.println("Warning: can not generate documentation for nested " +
                                      "inner class: " + decl.getSignature() );
                }
            }
        }
    }
======= fetch "static void decorateHTMLFromDecls(Declaration[] decls, String base, String docMo" f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

======= fetch "static void addAspectDocumentation(IProgramElement node, StringBuffer fileBuffer" f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

    
======= fetch "static void decorateDocWithRel(" f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

======= fetch "static String generateIntroductionSignatures(IProgramElement decl, boolean isDet" f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

    	//        Declaration[] decls = decl.getDeclarations();
======= fetch "static String generateHREFName(IProgramElement decl) {" f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        //String hrefLink = decl.toLabelString().replace("\"", "quot;"); // !!!
======= fetch "static String getFormattedComment(IProgramElement decl) {" f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

    static SymbolManager symbolManager = null;
======= fetch "public static void clearState() {" f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

        symbolManager = null;
======= fetch "public static void main(String[] args) {" f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

        symbolManager = SymbolManager.getDefault();
======= fetch "public static void main(String[] args) {" f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            StubFileGenerator.doFiles(declIDTable, symbolManager, inputFiles, signatureFiles);
======= fetch "public static void main(String[] args) {" f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

                                              symbolManager,
======= fetch "public static void main(String[] args) {" f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            	String entryName = arg.substring(arg.lastIndexOf(File.separator)+1);
======= fetch "static void doFiles (Hashtable table," f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

                        SymbolManager symbolManager,
======= fetch "static void doFiles (Hashtable table," f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

            processFile(symbolManager, inputFiles[i], signatureFiles[i]);
======= fetch "static void doFiles (Hashtable table," f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

    static void processFile(SymbolManager symbolManager, File inputFile, File signatureFile) throws DocException {
======= fetch "static String addToFormal(String formalComment, String string) {" f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

        boolean appendPeriod = true;
======= fetch "static String addToFormal(String formalComment, String string) {" f4c8bf9^:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

            appendPeriod = false;
 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 *     Mik Kersten	  port to AspectJ 1.1+ code base
 * ******************************************************************/
 * @author Mik Kersten
 */
    private static SymbolManager INSTANCE = new SymbolManager();
    public static SymbolManager getDefault() {
        return INSTANCE;
    }
 
    public Declaration[] getDeclarations(String filename) {
    	
    	IProgramElement file = (IProgramElement)AsmManager.getDefault().getHierarchy().findElementForSourceFile(filename);
    }
    
    /**
     * Rejects anonymous kinds by checking if their name is an integer
     */
    
    private String genPartiallyQualifiedName(IProgramElement node, String name) {
        Declaration[] declarations = lookupDeclarations(filename);
        //System.out.println("getting "+filename+", "+line+":"+column);
        //System.out.println("decs: "+declarations);
        return getDeclarationAtPoint(declarations, line, column);
    }
    public Declaration getDeclarationAtPoint(Declaration[] declarations, int line, int column) {
        //!!! when we care about the performance of this method
        //!!! these should be guaranteed to be sorted and a binary search used here
        //!!! for now we use the simple (and reliable) linear search
        if (declarations == null) return null;
        for(int i=0; i<declarations.length; i++) {
            Declaration dec = declarations[i];
            if (dec.getBeginLine() == line) { // && dec.getEndLine() >= line) {
                if (column == -1) return dec;
                if (dec.getBeginColumn() == column) { // && dec.getEndColumn() >= column) {
                    return dec;
                }
            }
            Declaration[] enclosedDecs = dec.getDeclarations();
            if (enclosedDecs.length == 0) continue;
            Declaration dec1 = getDeclarationAtPoint(enclosedDecs, line, column);
            if (dec1 != null) return dec1;
        }
        //??? what should be returned for no declaration found
        return null;
    }
    private Declaration[] lookupDeclarations(String filename) {
    	return null;
    }
    /* generic code for dealing with correlation files, serialization, and caching */
    /**
      * @param      methodName  method name without type or parameter list
      * @return     method name with ajc-specific name mangling removed,
      *             unchanged if there's not ajc name mangling present
      */
    public static String translateMethodName(String methodName) {
        int firstDollar = methodName.indexOf('$');
        if (firstDollar == -1) return methodName;
        String baseName = methodName.substring(firstDollar);
        if (methodName.indexOf("ajc") != -1) {
            return "<" + baseName + " advice>";
        } else {
            return baseName;
        }
    }
    /************************************************************************
      The rest of the code in this file is just for testing purposes
     ************************************************************************/

======= fetch "private void unpackGenericSignature() {" 3f77e75^:"weaver/src/org/aspectj/weaver/bcel/BcelField.java"

======= fetch "private void unpackGenericSignature() {" 3f77e75^:"weaver/src/org/aspectj/weaver/bcel/BcelMethod.java"

 		 if (!world.isInJava5Mode()) { 
 			 this.genericReturnType = getReturnType();
 			 this.genericParameterTypes = getParameterTypes();
 			 return;
 		 }
 		 // ok, we have work to do...
======= fetch "private void unpackGenericSignature() {" 3f77e75^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "public void testCanBeParameterizedGenericMethod() {" 3f77e75^:"weaver/testsrc/org/aspectj/weaver/MemberTestCase15.java"

======= fetch "public void testCanBeParameterizedMethodInGenericType() {" 3f77e75^:"weaver/testsrc/org/aspectj/weaver/MemberTestCase15.java"


    static String PREINTIALIZATION = "preinitialization";
======= fetch "public UnresolvedType getReturnType() {" a9ef1b0^:"weaver/src/org/aspectj/weaver/Shadow.java"

    public static final Kind PreInitialization    = new Kind(JoinPoint.PREINTIALIZATION, 8,  false);

======= fetch "public static UnresolvedType createTypeFromSignature(String signature) {" 24a785f^:"weaver/src/org/aspectj/weaver/TypeFactory.java"


    public void setInnerClasses(InnerClass[] classes){};
    public static class InnerClass {}
    public void setInnerClasses(InnerClass[] classes){};
    public static class InnerClass {}
   public static void main(String []argv) {
     new pr112458_2();
   }
  before(pr112458_2.InnerClass[] ics): execution(void setInnerClasses(..)) && args(ics) {
  }
======= fetch "public static Test suite() {" 53284da^:"tests/src/org/aspectj/systemtest/AllTests15.java"

======= fetch "public static Test suite() {" 53284da^:"tests/src/org/aspectj/systemtest/ajc150/AllTestsAspectJ150.java"

 * Copyright (c) 2006 IBM 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
  public void testMemberTypesInGenericTypes_pr112458()    { runTest("member types in generic types");}
  public void testMemberTypesInGenericTypes_pr112458_2()  { runTest("member types in generic types - 2");}
  
  
  /////////////////////////////////////////
  public static Test suite() {
    return XMLBasedAjcTestCase.loadSuite(Ajc151Tests.class);
  }
  protected File getSpecFile() {
    return new File("../tests/src/org/aspectj/systemtest/ajc151/ajc151.xml");
  }
  
 * Copyright (c) 2006 IBM 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
        //$JUnit-END$
    
    <ajc-test dir="bugs151" title="member types in generic types">
        <compile files="pr112458.aj" options="-1.5 -emacssym"/>
    </ajc-test>
    
    <ajc-test dir="bugs151" title="member types in generic types - 2">
        <compile files="pr112458_2.aj" options="-1.5 -emacssym"/>
        <run class="pr112458_2"/>
    </ajc-test>
======= fetch "public static UnresolvedType createTypeFromSignature(String signature) {" 53284da^:"weaver/src/org/aspectj/weaver/TypeFactory.java"

======= fetch "public static UnresolvedType createTypeFromSignature(String signature) {" 53284da^:"weaver/src/org/aspectj/weaver/TypeFactory.java"


======= fetch "private static void processMembers(List/*IProgramElement*/ members, PrintWriter" d69ce9a^:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

======= fetch "public static Test suite() {" d69ce9a^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java"

        suite.addTestSuite(EnumTest.class);
 * Copyright (c) 2005 Contributors. All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: IBM Corporation - initial API and implementation 
 * 				 Helen Hawkins   - iniital version
 *******************************************************************/
    public void testEnum() throws Exception {
        outdir.delete();
    	
        String[] args = { 
              "-XajdocDebug",
              "-private",
              "-source", 
              "1.5",
            "-d", 
            outdir.getAbsolutePath(),
            f.getAbsolutePath()
        };
        org.aspectj.tools.ajdoc.Main.main(args);
    }
    public void testInlinedEnum() throws Exception {
    	outdir.delete();
    	
        String[] args = { 
              "-XajdocDebug",
              "-private",
              "-source", 
              "1.5",
            "-d", 
            outdir.getAbsolutePath(),
            f.getAbsolutePath()
        };
        org.aspectj.tools.ajdoc.Main.main(args);
    }
    
    public void testEnumWithMethods() throws Exception {
    	outdir.delete();
    	
        String[] args = { 
              "-XajdocDebug",
              "-private",
              "-source", 
              "1.5",
            "-d", 
            outdir.getAbsolutePath(),
            f.getAbsolutePath()
        };
        org.aspectj.tools.ajdoc.Main.main(args);
    }

 abstract aspect X {
  void around(): execution(* foo(..)) {}
  public void foo() { } 
   new A().foo();
    pointcut greeting() :
    	execution(* Hello.sayWorld(..))
    	|| execution(* Hello.sayHello(..));
        public static void main(String[] args) {
                sayHello();
        } 
        public static void sayHello() {
                System.out.println("Hello");
                sayWorld();
        } 
        public static int sayWorld() {
                System.out.println("World");
                return 0;
        }
    //private Object result;
        pointcut greeting() : execution(* Hello.sayWorld(..)); 
        Object around(): greeting() {
        System.out.println("around start!");
        Object result = proceed();
        System.out.println("around end!");
        return result;
        }
    void greeting() {}
    <!-- using this we can debug the forked VM -->
    <property
        name="jdwp"
        value="-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005"/>
    <target name="compile:javac">
        <!-- compile only javac compilable stuff, exclude the one that needs other dependencies -->
        <javac destdir="${aj.sandbox}" classpathref="aj.path"
            srcdir="${basedir}"
            includes="ataspectj/*"
            excludes="ataspectj/UnweavableTest.java"
            debug="true">
        </javac>
    </target>
    <target name="ltw">
        <java fork="yes" classname="ataspectj.AllLTWTests" failonerror="yes">
            <classpath refid="aj.path"/>
            <!-- use META-INF/aop.xml style -->
            <classpath path="ataspectj/pathentry"/>
            <jvmarg value="-javaagent:${aj.root}/lib/test/loadtime5.jar"/>
        </java>
    </target>
    <target name="ConcreteAsepectTest">
    	<copy file="aop.xml" todir="${aj.sandbox}/META-INF">
    	</copy>
        <java fork="yes" classname="Hello" failonerror="yes">
            <classpath refid="aj.path"/>
            <jvmarg value="-javaagent:${aj.root}/lib/test/loadtime5.jar"/>
            <jvmarg value="-Daj5.def=aop.xml"/>
            <jvmarg value="-Daj.weaving.verbose=true"/>
        </java>
    </target>
        <concrete-aspect name="World1" extends="World">
        	<pointcut name="greeting" expression="execution(* Hello.sayWorld(..)) || execution(* Hello.sayHello(..))"/>
        </concrete-aspect>
    	<aspect name="World"/>
    	<aspect name="ConcreteWorld"/>
    	<include within="Hello"/>
======= fetch "protected File getSpecFile() {" a778ac4^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testMixingCodeStyles_pr121385()  { runTest("mixing aspect styles");}
======= fetch "public void testAbstractPerThisInAtAspectJ() {" a778ac4^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testNPEInBcelAdviceWithConcreteAspect_pr121385() {
  }
  
  
    
    <ajc-test dir="bugs150/pr121385" title="mixing aspect styles">
        <compile files="A.java" options="-1.5"/>
        <run class="A"/>
    </ajc-test>
   
   <ajc-test dir="bugs150/pr121385" title="override protected pointcut in aop.xml concrete aspect">
     <compile files="Hello.java"/>
     <compile files="World.aj, ConcreteWorld.aj"/>
     <run class="Hello" ltw="aop.xml">
       <stdout>
           <line text="around start!"/>
           <line text="Hello"/>
           <line text="around start!"/>
           <line text="World"/>
           <line text="around end!"/>
           <line text="around end!"/>
       </stdout>
     </run>
     <ant file="ant.xml" target="ConcreteAsepectTest" verbose="true"/>
   </ajc-test>
======= fetch "public InstructionList getAdviceArgSetup(" a778ac4^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

        final boolean isAnnotationStyleAspect = getConcreteAspect()!=null && getConcreteAspect().isAnnotationStyleAspect();
======= fetch "public InstructionList getAdviceArgSetup(" a778ac4^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

                        //extra var can be null here (@Aj aspect extends abstract code style, advice in code style)
                        if (extraVar != null) {
======= fetch "public InstructionList getAdviceArgSetup(" a778ac4^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

                        }
======= fetch "public void weaveAroundInline(" a778ac4^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

                    (munger.getConcreteAspect().isAnnotationStyleAspect())?
======= fetch "public void weaveAroundClosure(BcelAdvice munger, boolean hasDynamicTest) {" a778ac4^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        if (munger.getConcreteAspect()!=null && munger.getConcreteAspect().isAnnotationStyleAspect()) {

======= fetch "private String method2(){" bbdd496^:"ajdoc/testdata/pr119453/src/pack/C.java"

======= fetch "public static Test suite() {" bbdd496^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java"

        suite.addTestSuite(FullyQualifiedArgumentTest.class);
 * Copyright (c) 2005 Contributors. All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: IBM Corporation - initial API and implementation 
 * 				 Helen Hawkins   - iniital version
 *******************************************************************/
    
    public void testPr58520() throws Exception {
        outdir.delete();
        String[] args = { 
              "-XajdocDebug",
              "-private",
            "-d", 
            outdir.getAbsolutePath(),
            c.getAbsolutePath(),
            a.getAbsolutePath()
        };
        org.aspectj.tools.ajdoc.Main.main(args);
        
        checkContentsOfA();        
    }
        
    // check whether the "advises" section of the "Advice Summary" contains
    // the fully qualified argument, so for example, it says it has href
    // .../ajdoc/testdata/pr119453/doc/pack/C.html#method3(java.lang.String) 
    // rather than .../ajdoc/testdata/pr119453/doc/pack/C.html#method3(String)
    private void checkContentsOfA() throws Exception {
        File htmlA = new File("../ajdoc/testdata/pr119453/doc/pack/A.html");
        if (htmlA == null) {
        boolean containsAdviceSummary = false;
        String lineA = readerA.readLine();
        while( lineA != null && (!containsAdviceSummary)) {
        	if (lineA.indexOf("ADVICE SUMMARY") != -1) {
        		containsAdviceSummary = true;
        		boolean containsFullyQualifiedArgument = false;
        		boolean containsUnqualifiedArgument = false;
        		// walk through the information in this section
        }
        readerA.close();
        assertTrue("should have Advice Summary information in " +
        		"../ajdoc/testdata/pr119453/doc/pack/A.html", containsAdviceSummary);
               
    }
======= fetch "private void setParameters(MethodDeclaration md, IProgramElement pe) {" bbdd496^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java"

======= fetch "public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {" bbdd496^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"


        @interface Me{}
                        log(thisJoinPoint, "execMe[" + me + "]");
             <line text="execution(void pr119749.C.m()): execMe[@pr119749$Me()]"/>
======= fetch "public void testCompareSubclassDelegates() {" 9abfc40^:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"

        BcelWorld bcelWorld = new BcelWorld();
======= fetch "protected void setUp() throws Exception {" 9abfc40^:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"

======= fetch "public void testDelegateCreation() {" 9abfc40^:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.java"

======= fetch "public void testArrayTypes() {" 9abfc40^:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.java"

======= fetch "public void testPrimitiveTypes() {" 9abfc40^:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.java"


======= fetch "public void initialize() {" 588e7b9^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

            if (weavingAdaptor == null) {
            	return bytes;
            }
======= fetch "static WeavingAdaptor getWeaver(ClassLoader loader, IWeavingContext weavingConte" 588e7b9^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

                    // create it and put it back in the weavingAdaptors map but avoid any kind of instantiation
                    // within the synchronized block
                    ClassLoaderWeavingAdaptor weavingAdaptor = new ClassLoaderWeavingAdaptor(loader, weavingContext);
                    adaptor = new ExplicitlyInitializedClassLoaderWeavingAdaptor(weavingAdaptor);
                    weavingAdaptors.put(loader, adaptor);

======= fetch "public void suppressKinds(Collection lintKind) {" bdafe31^:"weaver/src/org/aspectj/weaver/Lint.java"

======= fetch "public void clearSuppressions() {" bdafe31^:"weaver/src/org/aspectj/weaver/Lint.java"

======= fetch "public ShadowMunger concretize(ResolvedType fromType, World world, PerClause cla" bdafe31^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= fetch "public boolean match(Shadow shadow, World world) {" bdafe31^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= fetch "public void specializeOn(Shadow shadow) {" bdafe31^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= fetch "protected void suppressLintWarnings(World inWorld) {" bdafe31^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"


======= fetch "private void createMessageHandler() {" 9d32b76^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"


       public static void main(String[] args) {
               C.run();
       }
       static class C {
               static void run() {}
       }
       pointcut doit() : execution(void C.run());
       // no error if not pertarget
       static aspect CPT pertarget(pc()){
               // no error if doit() defined in CPT
               protected pointcut pc() : doit(); // unexpected CE
               before() : doit() {} // no CE
       }
======= fetch "protected File getSpecFile() {" ae500c6^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  //public void testNamedPointcutPertarget_pr120521() { runTest("named pointcut not resolved in pertarget pointcut");}
    
    <ajc-test dir="bugs150/pr120521" pr="120521" title="named pointcut not resolved in pertarget pointcut">
     <compile files="PerTargetSubaspectError.java"/>
    </ajc-test>  

======= fetch "public UnresolvedType parameterize(Map typeBindings) {" 3ac4627^:"weaver/src/org/aspectj/weaver/UnresolvedType.java"

    	throw new UnsupportedOperationException("resolve this type first");

======= fetch "protected boolean accept(String className, byte[] bytes) {" 9edb4b6^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        boolean fastAccept = false;//defaults to false if no fast include
        for (int i = 0; i < m_includeStartsWith.size(); i++) {
            fastAccept = fastClassName.startsWith((String)m_includeStartsWith.get(i));
            if (fastAccept) {
                break;
======= fetch "protected boolean accept(String className, byte[] bytes) {" 9edb4b6^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        if (fastAccept) {
            return true;
        }
 * Copyright (c) 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
    <weaver options="-verbose">
        <dump within="ataspectj..*" beforeandafter="true"/> 
    </weaver>
======= fetch "public void testLTWDumpBeforeAndAfter() {" 9edb4b6^:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"

        
        // before
        File f = new File("_ajdump/_before/com/foo/bar");
        CountingFilenameFilter cff = new CountingFilenameFilter();
        f.listFiles(cff);
        assertEquals("Expected dump file in " + f.getAbsolutePath(),1,cff.getCount());
======= fetch "public void testLTWDumpBeforeAndAfter() {" 9edb4b6^:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"

        File f = new File("_ajdump/_before/ataspectj/Test$$EnhancerByCGLIB$$12345.class");
        assertTrue(f.exists());
        f = new File("_ajdump/ataspectj/Test$$EnhancerByCGLIB$$12345.class");
        assertTrue(f.exists());
======= fetch "public void testLTWDumpProxy() {" 9edb4b6^:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"

        System.out.println("AtAjLTWTests.testLTWDumpProxy() f=" + f.getAbsolutePath());
======= fetch "public void testLTWDumpProxy() {" 9edb4b6^:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"

        System.out.println("AtAjLTWTests.testLTWDumpProxy() f=" + f.getAbsolutePath());
                files="ataspectj/Test$$EnhancerByCGLIB$$12345.java"
        <run class="ataspectj.Test$$EnhancerByCGLIB$$12345" ltw="ataspectj/aop-dumpbeforeandafter.xml"/>

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 *   Alexandre Vasseur         initial implementation
 *******************************************************************************/
 * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
 */
    public void testMe() {
        assertTrue(true);
    }
    public static void main(String[] args) {
        TestHelper.runAndThrowOnFailure(suite());
    }
    public static Test suite() {
        return new TestSuite(CflowBelowStackTest.class);
    }
    @Aspect
    public static class TestAspect {
        @Pointcut("this(testCase) && execution(void test*())")
        public void inTestClass(TestCase testCase) {
        }
        private Map<String, Map<String, Integer>> coverage;
        @Before("cflowbelow(inTestClass(testCase)) && execution(* *(..))")
        public void beforeMethodExecution(JoinPoint thisJoinPoint, TestCase testCase) {
            String testname = testCase.getClass().getName();
            String methodSignature = thisJoinPoint.getStaticPart().getSignature().toString();
            Map<String, Integer> tests = coverage.get(methodSignature);
            if (tests == null) {
                tests = new HashMap<String, Integer>();
                coverage.put(methodSignature, tests);
            }
            Integer count = tests.get(testname);
            if (count == null) {
                count = 1;
            } else {
                count++;
            }
            tests.put(testname, count);
        }
        @Before("inTestClass(testCase)")
        public void beforeExecutingTestMethod(TestCase testCase) {
            try {
                File file = new File("results.ser");
                if (file.exists()) {
                    ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));
                    coverage = (Map<String, Map<String, Integer>>) ois.readObject();
                    ois.close();
                } else {
                    coverage = new HashMap<String, Map<String, Integer>>();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        @After("inTestClass(testCase)")
        public void afterExecutingTestMethod(TestCase testCase) {
            try {
                File file = new File("results.ser");
                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));
                oos.writeObject(coverage);
                oos.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    <weaver options="-1.5 -showWeaveInfo">
    </weaver>
    <aspects>
        <aspect name="ataspectj.bugs.CflowBelowStackTest.TestAspect"/>
    </aspects>
======= fetch "public void testAppContainer() {" 979124d^:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"

    public void testCflowBelowStack() {
        runTest("CflowBelowStack");
    }
    <ajc-test dir="java5/ataspectj" title="CflowBelowStack">
        <compile
            files="ataspectj/bugs/CflowBelowStackTest.java,ataspectj/TestHelper.java"
            options="-1.5 -verbose "/>
        <run class="ataspectj.bugs.CflowBelowStackTest" ltw="ataspectj/bugs/aop-cflowbelowstacktest.xml"/>
    </ajc-test>
======= fetch "public int compareTo(Object other) {" 979124d^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= fetch "public int compareTo(Object other) {" 979124d^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

        // the closure instantiation has the same mapping as the extracted method from wich it is called
        if (getConcreteAspect()!= null && getConcreteAspect().isAnnotationStyleAspect()) {
            return BcelVar.NONE;
======= fetch "public int compareTo(Object other) {" 979124d^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

        //System.out.println("vars: " + Arrays.asList(exposedState.vars));
======= fetch "public void weaveCflowEntry(final BcelAdvice munger, final Member cflowField) {" 979124d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public InstructionList getAdviceInstructions(" 979124d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "private InstructionList getRedoneProceedCall(" 979124d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public void weaveAroundClosure(BcelAdvice munger, boolean hasDynamicTest) {" 979124d^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    	BcelVar[] adviceVars = munger.getExposedStateAsBcelVars();

======= fetch "public void testAspectAccessibility() {" 5f8d2cd^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "private static String genSourceSignature(IProgramElement classNode) {" 5f8d2cd^:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

======= fetch "public StringBuffer printHeader(int indent, StringBuffer output) {" 5f8d2cd^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"


======= fetch "public static ResolvedMember createResolvedConstructor(Constructor aConstructor," b52515f^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public void testGetDeclaredMethods() {" b52515f^:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"

======= fetch "public void testGenericInterfaceSuperclass_BcelWorldResolution() {" b52515f^:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"

    // FIXME asc maybe.  The reflection list of methods returned doesn't include <clinit> (the static initializer) ... is that really a problem.
    public void testCompareSubclassDelegates() {
    	
    	boolean barfIfClinitMissing = false;
        world.setBehaveInJava5Way(true);
        
        BcelWorld bcelWorld = new BcelWorld();
        bcelWorld.setBehaveInJava5Way(true);
        UnresolvedType javaUtilHashMap = UnresolvedType.forName("java.util.HashMap");
        ReferenceType rawType =(ReferenceType)bcelWorld.resolve(javaUtilHashMap );
        
        ReferenceType rawReflectType =(ReferenceType)world.resolve(javaUtilHashMap );
        ResolvedMember[] rms1 = rawType.getDelegate().getDeclaredMethods();
        ResolvedMember[] rms2 = rawReflectType.getDelegate().getDeclaredMethods();
        StringBuffer errors = new StringBuffer();
        Set one = new HashSet();
        for (int i = 0; i < rms1.length; i++) {
        Set two = new HashSet();
        for (int i = 0; i < rms2.length; i++) {
        for (int i = 0;i<rms2.length;i++) {
        	if (!one.contains(rms2[i].toString())) {
        		errors.append("Couldn't find "+rms2[i].toString()+" in the bcel set\n");
        	}
        }
        for (int i = 0;i<rms1.length;i++) {
        	if (!two.contains(rms1[i].toString())) {
        		if (!barfIfClinitMissing && rms1[i].getName().equals("<clinit>")) continue;
        		errors.append("Couldn't find "+rms1[i].toString()+" in the reflection set\n");
        	}
        }
        assertTrue("Errors:"+errors.toString(),errors.length()==0);
        
        if (barfIfClinitMissing) {
        	// the numbers must be exact
            assertEquals(rms1.length,rms2.length);        	
        } else {
        	// the numbers can be out by one in favour of bcel
        	assertTrue("Should be one extra (clinit) in BCEL case, but bcel="+rms1.length+" reflect="+rms2.length,rms1.length==rms2.length+1);
        }
    }
    	    
======= fetch "private ResolvedMember createGenericConstructorMember(Constructor forConstructor" b52515f^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"


    Object around() : call( NoClassDefFoundError.new(..)) {
      return proceed();
    } 
    
    public static void main(String []argv) {
    	new ContractChecking();
    }
    public static final boolean enabled = Boolean.getBoolean(ContractChecking.class.getName());
======= fetch "protected File getSpecFile() {" 94159f9^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testRangeProblem_pr109614() { runTest("Range problem");}
======= fetch "private void deleteNewAndDup() {" 94159f9^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "private void deleteNewAndDup() {" 94159f9^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "private void retargetFrom(InstructionHandle old, InstructionHandle fresh) {" 94159f9^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"


======= fetch "public int getModifiers() {" 6e8bf52^:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/AjTypeImpl.java"

======= fetch "public void testGetSupertype() {" 6e8bf52^:"aspectj5rt/java5-testsrc/org/aspectj/internal/lang/reflect/AjTypeTests.java"

======= fetch "public void testGetSupertype() {" 6e8bf52^:"aspectj5rt/java5-testsrc/org/aspectj/internal/lang/reflect/AjTypeTests.java"


======= fetch "private void registerOptions(final BcelWeaver weaver, final ClassLoader loader," 1e1bbb3^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        //-Xlintfile: first so that lint wins
======= fetch "private void registerOptions(final BcelWeaver weaver, final ClassLoader loader," 1e1bbb3^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

                    world.getMessageHandler().handleMessage(new Message(
                            "Cannot access resource for -Xlintfile:"+weaverOption.lintFile,
                            IMessage.WARNING,
                            failure,
                            null));
======= fetch "private void registerOptions(final BcelWeaver weaver, final ClassLoader loader," 1e1bbb3^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        }
        if (weaverOption.lint == null) {
        		bcelWorld.getLint().loadDefaultProperties();
        		bcelWorld.getLint().adviceDidNotMatch.setKind(IMessage.INFO);
        } else {
======= fetch "public void matchAgainst(String output) {" 1e1bbb3^:"testing/newsrc/org/aspectj/testing/OutputSpec.java"

======= fetch "public void execute(AjcTestCase inTestCase) {" 1e1bbb3^:"testing/newsrc/org/aspectj/testing/RunSpec.java"

======= fetch "private boolean copyLtwFile (File sandboxDirectory) {" 1e1bbb3^:"testing/newsrc/org/aspectj/testing/RunSpec.java"

======= fetch "protected Digester getDigester() {" 1e1bbb3^:"testing/newsrc/org/aspectj/testing/XMLBasedAjcTestCase.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 *   Matthew Webster         initial implementation
 *******************************************************************************/
    
    <weaver options="-verbose -showWeaveInfo"/>
    
    <weaver options="-verbose -showWeaveInfo -Xlint:warning"/>
    
    <weaver options="-verbose -showWeaveInfo -Xlintfile:Xlint-nomatch.properties"/>
======= fetch "public void testAspectsIncludeWithLintWarning () {" 1e1bbb3^:"tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.java"

  	public void testXlintfileEmpty () {
  		runTest("Empty Xlint.properties file");
  	}
  	public void testXlintfileMissing () {
  		runTest("Warning with missing Xlint.properties file");
  	}
  	public void testXlintWarningAdviceDidNotMatchSuppressed () {
  		runTest("Warning when advice doesn't match suppressed for LTW");
  	}
  	public void testXlintfile () {
  		runTest("Override suppressing of warning when advice doesn't match using -Xlintfile");
  	}
  	public void testXlintDefault () {
  		runTest("Warning when advice doesn't match using -Xlint:default");
  	}
  	public void testXlintWarning () {
  		runTest("Override suppressing of warning when advice doesn't match using -Xlint:warning");
  	}
  	
      title="Empty Xlint.properties file"
      keywords="xlint, ltw">
        <compile
        	files="Main.java"
        >
        </compile>	
        <run class="Main" ltw="aop-xlintfile.xml" xlintfile="Xlint-empty.properties">
        	<stderr>
        	</stderr>
        </run>
    </ajc-test>
    
      title="Warning with missing Xlint.properties file"
      keywords="xlint, ltw">
        <compile
        	files="Main.java"
        >
        </compile>	
        <run class="Main" ltw="aop-xlintfile.xml">
        	<stderr>
        		<line text="warning Cannot access resource for -Xlintfile:Xlint-empty.properties"/>
        	</stderr>
        </run>
    </ajc-test>
    
      title="Warning when advice doesn't match suppressed for LTW"
      keywords="xlint, ltw">
        <compile
        	files="Main.java"
        >
        </compile>	
        <compile
        	files="Aspect3.aj"
        >
        </compile>	
        <run class="Main" ltw="aop-nomatch.xml">
        	<stderr>
        	</stderr>
        </run>
    </ajc-test>
    
      title="Override suppressing of warning when advice doesn't match using -Xlintfile"
      keywords="xlint, ltw">
        <compile
        	files="Main.java"
        >
        </compile>	
        <compile
        	files="Aspect3.aj"
        >
        </compile>	
        <run class="Main" ltw="aop-nomatchxlintfile.xml" xlintfile="Xlint-nomatch.properties">
        	<stderr>
        		<line text="advice defined in Aspect3 has not been applied [Xlint:adviceDidNotMatch]"/>
        	</stderr>
        </run>
    </ajc-test>
    
      title="Warning when advice doesn't match using -Xlint:default"
      keywords="xlint, ltw">
        <compile
        	files="Main.java"
        >
        </compile>	
        <compile
        	files="Aspect3.aj"
        >
        </compile>	
        <run class="Main" ltw="aop-nomatchxlint.xml">
        	<stderr>
        		<line text="advice defined in Aspect3 has not been applied [Xlint:adviceDidNotMatch]"/>
        	</stderr>
        </run>
    </ajc-test>
    
      title="Override suppressing of warning when advice doesn't match using -Xlint:warning"
      keywords="xlint, ltw">
        <compile
        	files="Main.java"
        >
        </compile>	
        <compile
        	files="Aspect3.aj"
        >
        </compile>	
        <run class="Main" ltw="aop-nomatchxlint.xml">
        	<stderr>
        		<line text="advice defined in Aspect3 has not been applied [Xlint:adviceDidNotMatch]"/>
        	</stderr>
        </run>
    </ajc-test>
    
======= fetch "protected boolean warn (String message, Throwable th) {" 1e1bbb3^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

        return messageHandler.handleMessage(new Message("Register definition failed", IMessage.WARNING, th, null));

======= fetch "public void testNoNPEWhenInaccessibleMethodIsCalledWithinITD_pr119019() {" d43e74b^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testNoNPEWithOrPointcutAndMoreThanOneArgs_pr118149() {
  }
        <compile files="PR118149.aj"/>
    </ajc-test>
======= fetch "protected Test findResidueInternal(Shadow shadow, ExposedState state) {" d43e74b^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

                    // pr118149
                    // It is possible for vars in myState (which would normally be set
                    // in the call to residueSource.findResidue) to not be set (be null)
                    // in an Or pointcut with if expressions in both branches, and where
                    // one branch is known statically to not match. In this situation we
                    // simply return Test.
======= fetch "protected Test findResidueInternal(Shadow shadow, ExposedState state) {" d43e74b^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

                        if (v == null) continue;  // pr118149

======= fetch "public boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invocationSi" 6d94d09^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeFieldBinding.java"

    private static interface Marker {}   
    private class Foo implements Marker {
            bar = null; // allowed
            listener = null; // should also be allowed
            this.listener = null; // so should this
            ((Marker)this).listener = null; // and this
        }
    }
    public static void main(String []argv) {
      pr118698.aspectOf().x();
    }
    
    public void x() {
    	new Foo();
    }
    private Object Marker.listener;
    private Object bar;
======= fetch "protected File getSpecFile() {" 6d94d09^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  //public void testIllegalInitialization_pr118326_1() { runTest("illegal initialization - 1");}
  //public void testIllegalInitialization_pr118326_2() { runTest("illegal initialization - 2");}
======= fetch "protected File getSpecFile() {" 6d94d09^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testAccesstoPrivateITDInNested_pr118698() { runTest("access to private ITD from nested type");}
    <ajc-test dir="bugs150" title="access to private ITD from nested type">
        <compile files="pr118698.aj"/>
        <run class="pr118698"/>
    </ajc-test>

       pointcut callPointCut(): call(public * blah.MyClass+.*(..));
       Object around() : callPointCut() {
               System.out.println("start of around");
               Object result = proceed();
               System.out.println("end of around");
               return result;
       }
       public Integer[] getRandomInt(String[][] param)
       {
               for (int i = 0; i < param.length; i++)
               {
                       System.out.print("[" + i + "] = [");
                       for (int j = 0; j < param[i].length; j++)
                       {
                               System.out.print(param[i][j]);
                               if (j != param[i].length-1)
                                       System.out.print(',');
                       }
                       System.out.println(']');
               }
               return new Integer[] { new Integer(new Random().nextInt())};
       }
       /**
        * @param args
        */
       public static void main(String[] args)
       {
               MyClass mc = new MyClass();
               mc.getRandomInt(new String[][]{{ "a", "b",
       }
======= fetch "protected File getSpecFile() {" a75b7fa^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  
======= fetch "protected File getSpecFile() {" a75b7fa^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testAroundAdviceArrayAdviceSigs_pr118781()     { runTest("verify error with around advice array sigs");}
    <ajc-test dir="bugs150/pr118781" pr="118781" title="verify error with around advice array sigs">
     <compile files="MyMain.java,MyAspect.java,MyClass.java" options="-XnoInline"/>
     <run class="blah.MyMain"/>
    </ajc-test>
    
======= fetch "public ResolvedType resolve(UnresolvedType ty, boolean allowMissing) {" a75b7fa^:"weaver/src/org/aspectj/weaver/World.java"

        	String brackets = signature.substring(0,signature.lastIndexOf("[")+1);
            ret = new ResolvedType.Array(signature, brackets+componentType.getErasureSignature(),
======= fetch "public ResolvedType put(String key, ResolvedType type) {" a75b7fa^:"weaver/src/org/aspectj/weaver/World.java"


======= fetch "public void installGlobals(AjBuildConfig global) { // XXX relies on default valu" 551b9ca^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

        if (!getProceedOnError() && global.getProceedOnError()) {
        	setProceedOnError(true);
        }
       	setTargetAspectjRuntimeLevel(global.getTargetAspectjRuntimeLevel());
  public static void main(String []argv) {
    new Aspect().m();
  }
  public void m() {
  }
  public int Aspect.x = 5;
  public void Aspect.foo() {
  }
  before():execution(* m()) {
  }
  before(): staticinitialization(*) {
  }
        public void foo(int number, String name)
======= fetch "public static void configureNewProjectDependency(String fromProject, String proj" 551b9ca^:"tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"

======= fetch "private static boolean build(String projectName,String configFile) {" 551b9ca^:"tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"

======= fetch "private MyBuildOptionsAdapter() {}" 551b9ca^:"tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"

======= fetch "public String getNonStandardOptions() {" 551b9ca^:"tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"

======= fetch "public void testPr92837() {" 551b9ca^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


======= fetch "protected File getSpecFile() {" 2c81907^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  //public void testLintForAdviceSorting_pr111667() { runTest("lint for advice sorting");}
     <compile files="A.java,X.java,Y.java" options="-1.5">
======= fetch "private void sortMungers() {" 2c81907^:"weaver/src/org/aspectj/weaver/Shadow.java"

======= fetch "private void sortMungers() {" 2c81907^:"weaver/src/org/aspectj/weaver/Shadow.java"

======= fetch "private void sortMungers() {" 2c81907^:"weaver/src/org/aspectj/weaver/Shadow.java"

    // not quite optimal... but the xlint is ignore by default
======= fetch "public int compareByPrecedence(ResolvedType aspect1, ResolvedType aspect2) {" 2c81907^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public int compareByPrecedence(ResolvedType firstAspect, ResolvedType secondAspe" 2c81907^:"weaver/src/org/aspectj/weaver/World.java"


======= fetch "private static ReflectionBasedReferenceTypeDelegate create15Delegate(ReferenceTy" d1a295c^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"


======= fetch "public void testParameterizedPointcutAndAdvice() {" 508dbcb^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

    </ajc-test>acj
======= fetch "private static ReflectionBasedReferenceTypeDelegate create15Delegate(ReferenceTy" 508dbcb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "private static ReflectionBasedReferenceTypeDelegate create15Delegate(ReferenceTy" 508dbcb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "private static ReflectionBasedReferenceTypeDelegate create15Delegate(ReferenceTy" 508dbcb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "private static ReflectionBasedReferenceTypeDelegate create15Delegate(ReferenceTy" 508dbcb^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"


======= fetch "public void testDeclareSoftInGenericAspect() {" 6eb77c5^:"tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java"

======= fetch "public void raiseWarningOnJoinPointSignature(String signature) {" 6eb77c5^:"weaver/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public void raiseWarningOnMissingInterfaceWhilstFindingMethods() {" 6eb77c5^:"weaver/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "private void raiseCantFindType(String key) {" 6eb77c5^:"weaver/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "private void raiseCantFindType(String key,String insert) {" 6eb77c5^:"weaver/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= fetch "public ResolvedType resolve(UnresolvedType ty,ISourceLocation isl) {" 6eb77c5^:"weaver/src/org/aspectj/weaver/World.java"

            IMessage msg = null;
            if (isl!=null) {
              msg = MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE,ty.getName()),isl);
            } else {
              msg = MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE,ty.getName())); 
            }
            messageHandler.handleMessage(msg);
======= fetch "private Collection collectCheckedExceptions(UnresolvedType[] excs) {" 6eb77c5^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

                IMessage msg = new Message(
                  WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_EXCEPTION_TYPE,excs[i].getName()),
                  "",IMessage.ERROR,getSourceLocation(),null,null);
                world.getMessageHandler().handleMessage(msg);
======= fetch "public void weaveAroundInline(" 6eb77c5^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

          IMessage msg = new Message(
                WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE,declaringType.getClassName()),
                "",IMessage.ERROR,getSourceLocation(),null,
                new ISourceLocation[]{ munger.getSourceLocation()});
          world.getMessageHandler().handleMessage(msg);
======= fetch "public void weaveAroundClosure(BcelAdvice munger, boolean hasDynamicTest) {" 6eb77c5^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

                    IMessage msg = new Message(
                             WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE_PREINIT,bcelTX.getClassName()),
                              "",IMessage.ERROR,getSourceLocation(),null,
                              new ISourceLocation[]{ munger.getSourceLocation()});
                    world.getMessageHandler().handleMessage(msg);
======= fetch "protected Test findResidueInternal(Shadow shadow, ExposedState state) {" 6eb77c5^:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= fetch "private Test findResidueNoEllipsis(Shadow shadow, ExposedState state, TypePatter" 6eb77c5^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

                  IMessage msg = new Message(
                    WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_ARG_TYPE,argType.getName()),
                    "",IMessage.ERROR,shadow.getSourceLocation(),null,new ISourceLocation[]{getSourceLocation()});
                  shadow.getIWorld().getMessageHandler().handleMessage(msg);
======= fetch "private void warnOnConfusingSig(Shadow shadow) {" 6eb77c5^:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" 6eb77c5^:"weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java"

======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" 6eb77c5^:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"


======= fetch "public static WeaverOption parse(String options, ClassLoader laoder, IMessageHan" 76d7e83^:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

            weaverOption.messageHandler.dontIgnore(IMessage.DEBUG);
======= fetch "public MessageHolder() {" 76d7e83^:"tests/java5/ataspectj/ataspectj/ltwlog/MessageHolder.java"

    <weaver options="-XmessageHandlerClass:ataspectj.ltwlog.MessageHolder"/>
    <weaver options="-XmessageHandlerClass:ataspectj.ltwlog.MessageHolder -verbose"/>
    <weaver options="-XmessageHandlerClass:ataspectj.ltwlog.MessageHolder -showWeaveInfo -verbose -Xreweavable"/>
    <weaver options="-showWeaveInfo -verbose"/>
======= fetch "public void testAjcAspect1LTWAspect2_Xreweavable() {" 76d7e83^:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"

    public void testLTWLog() {
        runTest("LTW Log");
    <ajc-test dir="java5/ataspectj" title="LTW Log">
        <ant file="ajc-ant.xml" target="ltwlog.LTWLog" verbose="true"/>

        public static void main(String[] args) {
                C.go();
        }
        static class C {
                static void go() {}
        }
        pointcut going() :call(void Target.go()) ;
        before() : going() {
                System.out.println("AA.going()");
        }
        declare warning : going() : "going()"; // works fine
        before() : going() { // advice not applied
                System.out.println("A.going()");
        }
======= fetch "public void testPerTargetAndNegation() {" 86880f7^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testParameterizedPointcutAndAdvice() {
  }
  
    <ajc-test dir="bugs150" pr="114495" title="parameterized pointcut and advice">
    		<compile files="Pr114495.aj" options="-1.5">
    			<message kind="warning" line="3" text="going()"/>
    		</compile>
    		<run class="Pr114495">
    			<stdout>
    				<line text="A.going()"/>
    				<line text="AA.going()"/>
    			</stdout>
    		</run>
    </ajc-test>acj
    
    
======= fetch "protected Collection getDeclares() {" 86880f7^:"weaver/src/org/aspectj/weaver/ReferenceType.java"

======= fetch "public Collection getDeclaredAdvice() {" 86880f7^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

======= fetch "public Collection getDeclaredAdvice() {" 86880f7^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

======= fetch "public boolean isParameterizedWithAMemberTypeVariable() {" 86880f7^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

======= fetch "public ShadowMunger parameterizeWith(ResolvedType declaringType,Map typeVariable" 86880f7^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"


======= fetch "public void testReturningObjectBinding() {" a4caeb9^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testPerTargetAndNegation() {
  }
  
    <ajc-test dir="bugs150" pr="114054" title="pertarget and negated pointcut">
     <compile files="Pr114054.aj" options=""/>
     <run class="Pr114054"/>
    </ajc-test>
    
======= fetch "public Object visit(NotPointcut node, Object data) {" a4caeb9^:"weaver/src/org/aspectj/weaver/patterns/PerThisOrTargetPointcutVisitor.java"

        TypePattern negated = getPerTypePointcut(node.getNegatedPointcut());
        if (MAYBE.equals(negated)) {
            return MAYBE;
        }
        return new NotTypePattern(negated);

======= fetch "public DeclareSoftImpl(AjType declaringType, String pcut, String exceptionTypeNa" 81e6b60^:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/DeclareSoftImpl.java"

======= fetch "public static Type stringToType(String typeName, Class classScope)" 81e6b60^:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/StringToType.java"

======= fetch "private static Type makeParameterizedType(String typeName, Class classScope)" 81e6b60^:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/StringToType.java"

        <compile files="DeclareParentsTest.aj" options="-1.5">
        <run class="DeclareParentsTest"/>
        <compile files="DeclareParentsTestAdvanced.aj" options="-1.5">
        <run class="a.b.c.DeclareParentsTestAdvanced"/>
        <compile files="ITDTest.aj" options="-1.5">
        <run class="a.b.c.ITDTest"/>

   public String getLastUpdatedBy();
   public void   setLastUpdatedBy(String un);
   private String lastUpdatedBy;
   public String getLastUpdatedBy() {
       return lastUpdatedBy;
   }
   public void setLastUpdatedBy(String un) {
       lastUpdatedBy = un;
   }
  public final static Mood HAPPY=new Mood();
   // this interface can be outside of the aspect
    interface Moody {
     Mood getMood(int i);
   };
   // this implementation can be outside of the aspect
    class MoodyImpl implements Moody {
      private Mood mood = Mood.HAPPY;
      public Mood getMood(int i) {
        return mood;
      }
   }
   // here is the actual ITD syntax when using @AspectJ
   // public static is mandatory
   // the field type must be the introduced interface. It can't be a class.
   @DeclareParents("C")
   public static Moody introduced = new MoodyImpl();
  public static void main(String []argv) {
    ((Moody)new C()).getMood(7);
  }
  
    public static void main(String[] args) {
        Audit a = (Audit)new Test();
        a.setLastUpdatedBy("username");
        System.out.println("Username ="+a.getLastUpdatedBy());
    }
  @DeclareParents("Test")
  public static Audit introduced = new AuditImpl();
======= fetch "protected File getSpecFile() {" 11ab99f^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testAtDeclareParents_pr117681() { runTest("at declare parents");}
    <ajc-test dir="bugs150/pr117681" pr="117681" title="at declare parents">
     <compile files="Test.java,TestAspect.java,Audit.java,AuditImpl.java" options="-1.5"/>
     <run class="Test"/>
    </ajc-test>
    
======= fetch "private boolean mungeMethodDelegate(BcelClassWeaver weaver, MethodDelegateTypeMu" 11ab99f^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

    		if (!introduced.isStatic()) { // skip 'this'
    		  //body.append(InstructionFactory.createThis());
    		  pos++;
    		}

        execution(ManagedBean+.new(..)) && this(bean); 
    		System.out.println("I just constructed " + bean);
    public static void main(String[] args) {
    		new ManagedBean("super-bean");
    		new ManagedSubBean();
======= fetch "public static void main(String[] args) {" 8b294d9^:"tests/new/AfterReturningParam.java"

        Tester.checkAndClearEvents(new String[] { "constr exec as Object null" });
======= fetch "private void callEvent(String s, Object o) {" 8b294d9^:"tests/new/AfterReturningParam.java"

    	                                                                       // in 1.5 does not match - no return value for this jp
======= fetch "public static void main(String[] args) {" 8b294d9^:"tests/new/ConstructorExecInit.java"

    after () returning (Object target) : initialization(new(..)) && !this(A) { 
======= fetch "pointcut j():" 8b294d9^:"tests/new/OddConstructors.java"

     after() returning(Object o): j() {
======= fetch "public void testDeclareSoftWithExclusions() {" 8b294d9^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

    		<run class="Pr113368"/>
======= fetch "public boolean match(Shadow shadow, World world) {" 8b294d9^:"weaver/src/org/aspectj/weaver/Advice.java"

    			boolean matches = resolvedExtraParameterType.isConvertableFrom(shadowReturnType);
======= fetch "public boolean hasHighPriorityExceptions() {" 8b294d9^:"weaver/src/org/aspectj/weaver/Shadow.java"


======= fetch "public void acceptClass(String name, byte[] bytes) {" a5ac5af^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        List definitions = parseDefinitions(loader);
        if (!enabled) {
        	return;
        }
        
======= fetch "public void addCrossReference(ISourceLocation from, ISourceLocation to, IRelatio" a5ac5af^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= fetch "public void addCrossReference(ISourceLocation from, ISourceLocation to, IRelatio" a5ac5af^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        registerDefinitions(weaver, loader);
======= fetch "public void addCrossReference(ISourceLocation from, ISourceLocation to, IRelatio" a5ac5af^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        // AV - see #113511 - not sure it is good to skip message handler
        if (enabled) {
            messageHandler = bcelWorld.getMessageHandler();
            // after adding aspects
            weaver.prepareForWeave();
        }
======= fetch "public void addCrossReference(ISourceLocation from, ISourceLocation to, IRelatio" a5ac5af^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

    private void registerDefinitions(final BcelWeaver weaver, final ClassLoader loader) {
        try {
            MessageUtil.info(messageHandler, "register classloader " + getClassLoaderName(loader));
======= fetch "private void registerDefinitions(final BcelWeaver weaver, final ClassLoader load" a5ac5af^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

            List definitions = new ArrayList();
======= fetch "private void registerDefinitions(final BcelWeaver weaver, final ClassLoader load" a5ac5af^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

                    MessageUtil.info(messageHandler, "using (-Daj5.def) " + file);
======= fetch "private void registerDefinitions(final BcelWeaver weaver, final ClassLoader load" a5ac5af^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

    			    MessageUtil.info(messageHandler, "using " + xml.getFile());
======= fetch "private void registerDefinitions(final BcelWeaver weaver, final ClassLoader load" a5ac5af^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

            // still go thru if definitions is empty since we will configure
            // the default message handler in there
            registerOptions(weaver, loader, definitions);
            // AV - see #113511
            if (!definitions.isEmpty()) {
                registerAspectExclude(weaver, loader, definitions);
                registerAspectInclude(weaver, loader, definitions);
                registerAspects(weaver, loader, definitions);
                registerIncludeExclude(weaver, loader, definitions);
                registerDump(weaver, loader, definitions);
            } else {
======= fetch "private void registerDefinitions(final BcelWeaver weaver, final ClassLoader load" a5ac5af^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

            }
======= fetch "public void flushGeneratedClasses(){" a5ac5af^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

    
======= fetch "public void addURL(URL url) {" a5ac5af^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

            //System.out.println("WeavingAdaptor.weaveClass " + name);
            // an @AspectJ aspect needs to be at least munged by the aspectOf munger
            info("weaving '" + name + "'");
            bytes = getAtAspectJAspectBytes(name, bytes);
        }
======= fetch "private boolean shouldWeave (String name, byte[] bytes) {" a5ac5af^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"


======= fetch "public ResolvedMember makeResolvedMember(MethodBinding binding) {" 554e733^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public ResolvedMember makeResolvedMemberForITD(MethodBinding binding,TypeBinding" 554e733^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public ResolvedMember makeResolvedMember(MethodBinding binding, TypeBinding decl" 554e733^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public ResolvedMember makeResolvedMember(MethodBinding binding, TypeBinding decl" 554e733^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public static EclipseShadow makeShadow(EclipseFactory world, ASTNode astNode," 554e733^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"

    declare soft: IOException: within(Pr103051) && adviceexecution();
    before() : execution(* main(..)) {
        throw new IOException("test");
    }
    public static void main(String args[]) {
    }
======= fetch "public void testReflectionOfAbstractITDs() {" 554e733^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  
  public void testDeclareSoftWithAdviceExecution() {
  }

======= fetch "public InterTypeMethodDeclaration getDeclaredITDMethod(String name," 735d94f^:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/AjTypeImpl.java"

======= fetch "public InterTypeConstructorDeclarationImpl(AjType<?> decType," 735d94f^:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/InterTypeConstructorDeclarationImpl.java"

======= fetch "public Type getGenericType() {" 735d94f^:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/InterTypeFieldDeclarationImpl.java"

======= fetch "public Type getGenericReturnType() {" 735d94f^:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/InterTypeMethodDeclarationImpl.java"

    
     * Connections give the appropriate call rate
     */
    public abstract long Connection.callRate();
    public long LongDistance.callRate() { return 1; }
    public long Local.callRate() { return 2; }
    /**
     * Customers have a bill paying aspect with state
     */
    public long Customer.totalCharge = 0;
    public void Customer.addCharge(long charge){
        totalCharge += charge;
    }
======= fetch "public void testPointcutParsingOfCompiledPointcuts() {" 735d94f^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  
  public void testReflectionOfAbstractITDs() {
  }

======= fetch "public int getColumn() {" 9ed75a1^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceLocation.java"

            } else if (0 < lineNumber && lineNumber == result.lineSeparatorPositions.length) {
            	column = 0;
  declare @type: Simple : @I;
======= fetch "protected File getSpecFile() {" 9ed75a1^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

 // public void testSelfBoundGenerics_pr117296() { runTest("self bounding generic types");}
======= fetch "public void testNoStackOverflowWithCircularPCDInGenericAspect2() {" 9ed75a1^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

    

======= fetch "public static void main(String[] args) throws Exception {" 522911e^:"tests/java5/ataspectj/annotationGen/RuntimePointcuts.java"

======= fetch "public void testNoStackOverflowWithCircularPCDInGenericAspect2() {" 522911e^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

    
        <run class="RuntimePointcuts" classpath="../lib/bcel/bcel.jar"/>
======= fetch "public boolean isAnnotationStyleAspect(String name, byte[] bytes) {" 522911e^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

            boolean couldBeAtAspectJStyle = false;
======= fetch "public boolean isAnnotationStyleAspect(String name, byte[] bytes) {" 522911e^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

                    return true;
======= fetch "public boolean isAnnotationStyleAspect(String name, byte[] bytes) {" 522911e^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

            return false;
======= fetch "public ReflectionBasedReferenceTypeDelegate() {}" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.java"

======= fetch "public void initialize(ReferenceType aType, Class aClass, World aWorld) {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.java"

======= fetch "protected World getWorld() {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.java"

======= fetch "public boolean hasAnnotation(UnresolvedType ofType) {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.java"

======= fetch "public ResolvedType getSuperclass() {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.java"

======= fetch "private static ReflectionBasedReferenceTypeDelegate create15Delegate(ReferenceTy" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "private static ReflectionBasedReferenceTypeDelegate create15Delegate(ReferenceTy" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createResolvedMethod(Method aMethod, World inWorld)" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createResolvedAdviceMember(Method aMethod, World in" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createResolvedAdviceMember(Method aMethod, World in" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createResolvedConstructor(Constructor aConstructor," 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createResolvedConstructor(Constructor aConstructor," 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createResolvedField(Field aField, World inWorld) {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createResolvedField(Field aField, World inWorld) {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public static ResolvedMember createHandlerMember(Class exceptionType, Class inTy" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= fetch "public ReflectionBasedResolvedMemberImpl(Kind kind," 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedResolvedMemberImpl.java"

======= fetch "public ReflectionShadow(World world, Kind kind, Member signature, Shadow enclosi" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= fetch "public Var getThisVar() {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= fetch "public Var getTargetVar() {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= fetch "public Var getArgVar(int i) {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= fetch "public Var getKindedAnnotationVar(UnresolvedType forAnnotationType) {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= fetch "public Var getWithinAnnotationVar(UnresolvedType forAnnotationType) {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= fetch "public Var getWithinCodeAnnotationVar(UnresolvedType forAnnotationType) {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= fetch "public Var getThisAnnotationVar(UnresolvedType forAnnotationType) {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= fetch "public Var getTargetAnnotationVar(UnresolvedType forAnnotationType) {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= fetch "public Var getArgAnnotationVar(int i, UnresolvedType forAnnotationType) {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= fetch "public static ReflectionVar createThisVar(ResolvedType type) {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java"

======= fetch "public static ReflectionVar createTargetVar(ResolvedType type) {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java"

======= fetch "public static ReflectionVar createArgsVar(ResolvedType type, int index) {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java"

======= fetch "public static ReflectionVar createThisAnnotationVar(ResolvedType type) {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java"

======= fetch "public static ReflectionVar createTargetAnnotationVar(ResolvedType type) {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java"

======= fetch "public static ReflectionVar createArgsAnnotationVar(ResolvedType type, int index" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java"

======= fetch "public static ReflectionVar createWithinAnnotationVar(ResolvedType annType) {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java"

======= fetch "public static ReflectionVar createWithinCodeAnnotationVar(ResolvedType annType)" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java"

======= fetch "public static ReflectionVar createAtAnnotationVar(ResolvedType annType) {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java"

======= fetch "private ReflectionVar(ResolvedType type) {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java"

======= fetch "public ReflectionWorld() {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= fetch "protected ReferenceTypeDelegate resolveDelegate(ReferenceType ty) {" 522911e^:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= fetch "public PointcutParser() {" 522911e^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

        setClassLoader(PointcutParser.class.getClassLoader());
======= fetch "public PointcutParser(Set/*<PointcutPrimitives>*/ supportedPointcutKinds) {" 522911e^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

        setClassLoader(PointcutParser.class.getClassLoader());
    }
    
    /**
     * Create a pointcut parser that can parse pointcut expressions built
     * from a user-defined subset of AspectJ's supported pointcut primitives. 
     * The following restrictions apply:
     * <ul>
     * <li>The <code>if, cflow, and cflowbelow</code> pointcut designators are not supported
     * <li>Pointcut expressions must be self-contained :- they cannot contain references
     * to other named pointcuts
     * <li>The pointcut expression must be anonymous with no formals allowed.
     * </ul>
     * @param supportedPointcutKinds a set of PointcutPrimitives this parser
     * should support
     * @param classLoader the class loader to use for resolving types
     * @throws UnsupportedOperationException if the set contains if, cflow, or
     * cflow below
     */
    public PointcutParser(Set/*<PointcutPrimitives>*/ supportedPointcutKinds,ClassLoader cl) {
    	this(supportedPointcutKinds);
    	setClassLoader(cl);
    }
    /**
     * Set the classloader that this parser should use for
     * type resolution.
     * @param aLoader
     */
    public void setClassLoader(ClassLoader aLoader) {
    	this.classLoader = aLoader;
    	world = new ReflectionWorld(this.classLoader);
    }
    /**
     * Set the lint properties for this parser from the
     * given resource on the classpath. 
     * @param resourcePath path to a file containing aspectj
     * lint properties
     */
    public void setLintProperties(String resourcePath)throws IOException {
    	URL url = this.classLoader.getResource(resourcePath);
    	InputStream is = url.openStream();
    	Properties p = new Properties();
    }
    
    /**
     * Set the lint properties for this parser from the 
     * given properties set.
     * @param properties
     */
    public void setLintProperties(Properties properties) {
    	getWorld().getLint().setFromProperties(properties);
======= fetch "public PointcutExpression parsePointcutExpression(" 522911e^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

            	 declaringTypeForResolution = world.resolve(inScope.getName());
======= fetch "public PointcutExpression parsePointcutExpression(" 522911e^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

            	 declaringTypeForResolution = ResolvedType.OBJECT.resolve(world);
======= fetch "public PointcutExpression parsePointcutExpression(" 522911e^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

             pcExpr = new PointcutExpressionImpl(pc,expression,formalParameters,world);
======= fetch "public PointcutExpression parsePointcutExpression(" 522911e^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    /**
     * Parse the given aspectj type pattern, and return a 
     * matcher that can be used to match types using it.
     * @param typePattern an aspectj type pattern
     * @return a type pattern matcher that matches using the given
     * pattern 
     * @throws IllegalArgumentException if the type pattern cannot
     * be successfully parsed.
     */
    public TypePatternMatcher parseTypePattern(String typePattern) 
    throws IllegalArgumentException {
        try {
        	TypePattern tp = new PatternParser(typePattern).parseTypePattern();
        	tp.resolve(world);
        	return new TypePatternMatcherImpl(tp,world);
        } catch (ParserException pEx) {
            throw new IllegalArgumentException(buildUserMessageFromParserException(typePattern,pEx));
        } catch (ReflectionWorld.ReflectionWorldException rwEx) {
       	 	throw new IllegalArgumentException(rwEx.getMessage());
        }
    }
    
    private World getWorld() {
    	return world;
    }
    
======= fetch "IMessageHandler setCustomMessageHandler(IMessageHandler aHandler) {" 522911e^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    	IMessageHandler current = world.getMessageHandler();
    	world.setMessageHandler(aHandler);
======= fetch "private IScope buildResolutionScope(Class inScope, PointcutParameter[] formalPar" 522911e^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    		return new SimpleScope(world,formalBindings);
======= fetch "private IScope buildResolutionScope(Class inScope, PointcutParameter[] formalPar" 522911e^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    		ResolvedType inType = world.resolve(inScope.getName());
======= fetch "public void testFormals() {" 522911e^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java"

======= fetch "public static Test suite() {" 522911e^:"weaver/testsrc/org/aspectj/weaver/tools/ToolsTests.java"

 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
======= fetch "public Java15AnnotationFinder() {" 522911e^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"

======= fetch "public Object getAnnotation(ResolvedType annotationType, Object onObject) {" 522911e^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"

======= fetch "public Object getAnnotationFromClass(ResolvedType annotationType, Class aClass)" 522911e^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"

======= fetch "public Object getAnnotationFromMember(ResolvedType annotationType, Member aMembe" 522911e^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"

======= fetch "public Java15ReflectionBasedReferenceTypeDelegate() {}" 522911e^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"

======= fetch "public void initialize(ReferenceType aType, Class aClass, World aWorld) {" 522911e^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"

======= fetch "private ResolvedMember createGenericMethodMember(Method forMethod) {" 522911e^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"

======= fetch "private ResolvedMember createGenericConstructorMember(Constructor forConstructor" 522911e^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"

======= fetch "private ResolvedMember createGenericFieldMember(Field forField) {" 522911e^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"

======= fetch "private ResolvedMember createGenericFieldMember(Field forField) {" 522911e^:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"


======= fetch "public FuzzyBoolean matches(AnnotatedElement annotated) {" 557f5b4^:"weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"


======= fetch "public static ResolvedMember checkForOverride(ResolvedType typeToCheck,String mn" dd9a9b2^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"


      pointcut TestToArray(Test mt) :
                target(mt) &&
                !within(TestAspect);
    Object[] around(Test mt, Object[] objs) :
            TestToArray(mt) &&
            args(objs) &&
            execution(Object[] Test.getObjs(Object[])) {
        objs = proceed(mt, objs);
        System.out.println("GO Aspects!");
        return objs;
    }
======= fetch "public void testNoStackOverflowWithCircularPCDInGenericAspect2() {" c760895^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  /*
   * Load-time weaving bugs
   */
  public void testNPEinWeavingAdaptor_pr116626() { runTest("NPE in WeavingAdaptor");}
   
   <ajc-test dir="bugs150/pr116626" title="NPE in WeavingAdaptor">
     <compile files="com/foo/bar/Test.java, TestAspect.aj" options="-1.5"/>
     <run class="com.foo.bar.Test" ltw="aop.xml"
     >
     </run>
   </ajc-test>
======= fetch "public void dontIgnore (IMessage.Kind kind) {" c760895^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public WeavingClassFileProvider (String name, byte[] bytes) {" c760895^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public boolean isApplyAtAspectJMungersOnly() {" c760895^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

        	if (wovenClass != null) return wovenClass.getBytes();
        	else return unwovenClass.getBytes();

======= fetch "private DocumentParser() {" fabf159^:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

    
======= fetch "public static Definition parse(final URL url) throws Exception {" fabf159^:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

            XMLReader xmlReader = SAXParserFactory.newInstance().newSAXParser().getXMLReader();
======= fetch "public static Definition parse(final URL url) throws Exception {" fabf159^:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"


======= fetch "private void warnOnConfusingSig(Shadow shadow) {" 676aa08^:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"


======= fetch "public void testNoVerifyErrorWithTwoArgsPCDs_pr113447() {" 4b8bed7^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testNoStackOverflowWithCircularPCDInGenericAspect() {
  }
  
  public void testNoStackOverflowWithCircularPCDInGenericAspect2() {
  }
    <ajc-test dir="bugs150" title="no StackOverflowError with circular pcd in generic aspect">
        <compile files="pr115235.aj" options="-1.5">
        	<message kind="warning" line="3" text="advice defined in GenericAbstractAspect has not been applied [Xlint:adviceDidNotMatch]"/>
        	<message kind="error" text="circular pointcut declaration involving: pc()"/>
        	<message kind="error" line="20" text="circular pointcut declaration involving: pc2()"/>
    </ajc-test> 
    <ajc-test dir="bugs150" title="no StackOverflowError with circular pcd in generic aspect - 2">
        <compile files="pr115235b.aj" options="-1.5">
        </compile>
    </ajc-test>
======= fetch "public State(String name, int key) {" 4b8bed7^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= fetch "public Pointcut concretize1(ResolvedType searchStart, ResolvedType declaringType" 4b8bed7^:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"


======= fetch "private void fixupGenericSignatureAttribute () {" d7d5947^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"


  private ThreadLocal counts = new ThreadLocal();
  public pointcut testMethodExecution() : 
    execution(void Test+.test*());
  public pointcut assertCall() : 
    cflow(testMethodExecution()) && call(void Assert+.assert*(..));
  void around() : testMethodExecution() {
    counts.set( new Counter());
  
    proceed();
  
    if(((Counter) counts.get()).getCount()==0) {
      throw new RuntimeException("No assertions had been called");
    }
  }
  before() : assertCall() {
    ((Counter) counts.get()).inc();
  }
  
======= fetch "public void testAdviceExecutionJPToStringForms() {" 7a1002a^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testAssertWithinPointcutExpression() {
  }
  
    <ajc-test dir="bugs150" pr="112756" title="pointcut expression containing 'assert'">
     <compile files="Pr112756.aj" options="-warn:assertIdentifier -Xdev:Pinpoint"/>
    </ajc-test>
    

======= fetch "public String checkRtJar(AjBuildConfig buildConfig) {" 1f51499^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public String checkRtJar(AjBuildConfig buildConfig) {" 1f51499^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public String checkRtJar(AjBuildConfig buildConfig) {" 1f51499^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

                    	return "no manifest found in " + p.getAbsolutePath() + 
======= fetch "public String checkRtJar(AjBuildConfig buildConfig) {" 1f51499^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

                    	continue;
======= fetch "public String checkRtJar(AjBuildConfig buildConfig) {" 1f51499^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public String checkRtJar(AjBuildConfig buildConfig) {" 1f51499^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public String checkRtJar(AjBuildConfig buildConfig) {" 1f51499^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public String checkRtJar(AjBuildConfig buildConfig) {" 1f51499^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public String checkRtJar(AjBuildConfig buildConfig) {" 1f51499^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"


    @SampleAnnotation 
    // ITD on the interface
    @SampleAnnotation 
    // ITD on the interface
======= fetch "protected File getSpecFile() {" d9757d7^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testITDCtor_pr112783()          { runTest("Problem with constructor ITDs");}
======= fetch "private boolean mungeNewField(BcelClassWeaver weaver, NewFieldTypeMunger munger)" d9757d7^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewField(BcelClassWeaver weaver, NewFieldTypeMunger munger)" d9757d7^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewField(BcelClassWeaver weaver, NewFieldTypeMunger munger)" d9757d7^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"


======= fetch "public InterSuperFixerVisitor(InterTypeDeclaration dec, EclipseFactory world, Sc" 21cf37d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.java"

======= fetch "public void endVisit(MessageSend send, BlockScope scope) {" 21cf37d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.java"

======= fetch "private Expression fixReceiver(Expression expression, BlockScope scope) {" 21cf37d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.java"

  interface C2 { }
  public void C2.hello() {
        return 
  // ok
  class C { }
  public void C.hello() {
  
======= fetch "protected File getSpecFile() {" 21cf37d^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testCantCallSuperMethods_pr90143() { runTest("cant call super methods");}
======= fetch "protected File getSpecFile() {" 21cf37d^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testCantCallSuperMethods_pr90143() { runTest("cant call super methods");}

 * Created on Oct 13, 2005 
 * \u00462004-2005 Business Process Engineering S.r.L.  All rights reserved
 */
======= fetch "protected File getSpecFile() {" a7e13f1^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

 
   <ajc-test dir="bugs150" title="ITDC with no explicit cons call">
 
======= fetch "public boolean attemptToModifySuperCalls(BcelClassWeaver weaver,LazyClassGen new" a7e13f1^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

        					int idx = cpg.addMethodref(newParent.getClassName(), invokeSpecial.getMethodName(cpg), invokeSpecial.getSignature(cpg));

======= fetch "public TypeBinding makeTypeBinding(UnresolvedType typeX) {" ade32bc^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "private TypeBinding makeTypeBinding1(UnresolvedType typeX) {" ade32bc^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "private TypeBinding makeTypeBinding1(UnresolvedType typeX) {" ade32bc^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "private TypeBinding makeTypeBinding1(UnresolvedType typeX) {" ade32bc^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "private TypeBinding makeTypeBinding1(UnresolvedType typeX) {" ade32bc^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

  Class<? extends pr114744> pr114744.cl;
  void foo() throws Exception {
    pr114744 ci = cl.newInstance();
  }
======= fetch "protected File getSpecFile() {" ade32bc^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testCaptureBinding_pr114744()   { runTest("capturebinding wildcard problem");}
    <ajc-test dir="bugs150" title="capturebinding wildcard problem">
      <compile files="pr114744.aj" options="-1.5">
      </compile>
    </ajc-test>
    

======= fetch "private void registerAspects(final BcelWeaver weaver, final ClassLoader loader," 62d16d5^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

                	String aspectCode = readAspect(aspectClassName, loader);
======= fetch "private void registerAspects(final BcelWeaver weaver, final ClassLoader loader," 62d16d5^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

                    	namespace=new StringBuffer(aspectCode);
======= fetch "private void registerAspects(final BcelWeaver weaver, final ClassLoader loader," 62d16d5^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

                    	namespace = namespace.append(";"+aspectCode);
======= fetch "private void registerAspects(final BcelWeaver weaver, final ClassLoader loader," 62d16d5^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= fetch "private void registerAspects(final BcelWeaver weaver, final ClassLoader loader," 62d16d5^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

                	String aspectCode = readAspect(concreteAspect.name, loader);
======= fetch "private void registerAspects(final BcelWeaver weaver, final ClassLoader loader," 62d16d5^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

                    	namespace=new StringBuffer(aspectCode);
======= fetch "private void registerAspects(final BcelWeaver weaver, final ClassLoader loader," 62d16d5^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

                    	namespace = namespace.append(";"+aspectCode);
======= fetch "public void flushGeneratedClasses(){" 62d16d5^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

    /**
     * Read in an aspect from the disk and return its bytecode as a String
     * @param name	the name of the aspect to read in
     * @return the bytecode representation of the aspect
     */
    private String readAspect(String name, ClassLoader loader){
        if (true) return name+"@"+(loader==null?"0":Integer.toString(loader.hashCode()));
        // FIXME AV - ?? can someone tell me why we read the whole bytecode
        // especially one byte by one byte
        // also it does some NPE sometime (see AtAjLTW "LTW Decp2")
        InputStream is = null;
        try {
    		String result = "";
        	is = loader.getResourceAsStream(name.replace('.','/')+".class");
            try {is.close();} catch (Throwable t) {;}
        }
    }
    

======= fetch "private boolean isAspect(TypeDeclaration typeDecl) {" 794f9b5^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

     * aspect must be public
======= fetch "private void validateAspectDeclaration(TypeDeclaration typeDecl) {" 794f9b5^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

        //FIXME AV - do we really want that
        TypeReference parentRef = typeDecl.superclass;
    <target name="ltw.AppContainer">
        <!-- mkdir the 2 sub app root folder -->
        <mkdir dir="${aj.sandbox}/META-INF"/>
        <mkdir dir="${aj.sandbox}/app_1"/>
        <mkdir dir="${aj.sandbox}/app_1/META-INF"/>
        <!-- install sub app -->
        <copy todir="${aj.sandbox}/app_1">
            <fileset dir="${aj.sandbox}" includes="ataspectj/hierarchy/app/*"/>
        </copy>
        <copy todir="${aj.sandbox}/app_2">
            <fileset dir="${aj.sandbox}" includes="ataspectj/hierarchy/app/*"/>
        </copy>
        <delete dir="${aj.sandbox}/ataspectj/hierarchy/app"/>
        <!-- install the aop.xml DD -->
        <copy file="${aj.root}/tests/java5/ataspectj/ataspectj/hierarchy/aop-global.xml"
              tofile="${aj.sandbox}/META-INF/aop.xml"/>
        <!-- only app1 gets local aspect -->
        <copy file="${aj.root}/tests/java5/ataspectj/ataspectj/hierarchy/aop-local.xml"
              tofile="${aj.sandbox}/app_1/META-INF/aop.xml"/>
        <!-- run -->
        <java fork="yes" classname="ataspectj.hierarchy.AppContainerTest" failonerror="yes">
            <classpath refid="aj.path"/>
            <jvmarg value="-javaagent:${aj.root}/lib/test/loadtime5.jar"/>
            <jvmarg value="-Daj.weaving.verbose=true"/>
        </java>
    </target>
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 *   Alexandre Vasseur         initial implementation
 *******************************************************************************/
 * Assumes ataspect.hierarchy.app DOES NOT EXISTS in system classpath
 * but exists in 2 folder located at "/app_1" and /app_2
 * ie "/app_1/ataspect.hierarchy.app.*.class"
 *
 * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
 */
    public static interface IApp {
        String invoke(String input);
    }
    IApp app1;
    IApp app2;
    public void setUp() throws Exception {
        try {
            Class k = Class.forName("ataspectj.hierarchy.app.SubApp");
            throw new Exception("config error, app must not be in system classpath");
        } catch (ClassNotFoundException e) {
            ;//fine
        }
        //build path and app
        URL path = AppContainerTest.class.getProtectionDomain().getCodeSource().getLocation();
        String path1 = path.toString() + "app_1/";
        String path2 = path.toString() + "app_2/";
        URLClassLoader app1CL = new URLClassLoader(
                new URL[]{new URL(path1)},
                AppContainerTest.class.getClassLoader()
        );
        URLClassLoader app2CL = new URLClassLoader(
                new URL[]{new URL(path2)},
                AppContainerTest.class.getClassLoader()
        );
        app1 = (IApp)Class.forName("ataspectj.hierarchy.app.SubApp", false, app1CL).newInstance();
        app2 = (IApp)Class.forName("ataspectj.hierarchy.app.SubApp", false, app2CL).newInstance();
    }
    public void testApp1LocalAspect() {
        String res = app1.invoke("app1");
        assertEquals("globalAspect[localAspect[app1]]", res);
    }
    public void testApp2NoLocalAspect() {
        String res = app2.invoke("app2");
        assertEquals("globalAspect[app2]", res);
    }
    @Aspect
    public static class BaseAspect {
        @Around("execution(* ataspectj.hierarchy.app.SubApp.invoke(..))")//TODO IApp
        public Object around(ProceedingJoinPoint jp) throws Throwable {
            String out = (String) jp.proceed();
            return "globalAspect[" + out + "]";
        }
    }
    public static void main(String[] args) {
        TestHelper.runAndThrowOnFailure(suite());
    }
    public static Test suite() {
        return new TestSuite(AppContainerTest.class);
    }
    <weaver options="-1.5 -XmessageHandlerClass:ataspectj.TestHelper -Xlint:ignore"/>
    <aspects>
        <aspect name="ataspectj.hierarchy.AppContainerTest.BaseAspect"/>
    </aspects>
    <weaver options="-1.5 -XmessageHandlerClass:ataspectj.TestHelper -Xlint:ignore"/>
    <aspects>
        <aspect name="ataspectj.hierarchy.app.SubApp.SubAspect"/>
    </aspects>
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 *   Alexandre Vasseur         initial implementation
 *******************************************************************************/
 * Leaves in child classloader in two forms, like 2 webapp
 *
 * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
 */
    // simple echo. May be advised or not depending on the aspect deployed there
    public String invoke(String input) {
        return input;
    }
    // this child aspect will be LTW for only one variation of the SubApp
    @Aspect
    public static class SubAspect {
        @Around("execution(* ataspectj.hierarchy.app.SubApp.invoke(..))")
        public Object around(ProceedingJoinPoint jp) throws Throwable {
            String out = (String) jp.proceed();
            return "localAspect[" + out + "]";
        }
    }
======= fetch "public void testAspectOfWhenAspectNotInInclude() {" 794f9b5^:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"

    public void testAppContainer() {
        runTest("AppContainer");
    }
    <ajc-test dir="java5/ataspectj" title="AppContainer">
        <compile
            files="ataspectj/hierarchy/AppContainerTest.java,ataspectj/hierarchy/app/SubApp.java,ataspectj/TestHelper.java"
            options="-1.5 -XnoWeave"
            />
        <ant file="ajc-ant.xml" target="ltw.AppContainer" verbose="true"/>
    </ajc-test>
======= fetch "public static List readAj5ClassAttributes(JavaClass javaClass, ReferenceType typ" 794f9b5^:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

        //FIXME turn on when ajcMightHaveAspect
======= fetch "public static List readAj5ClassAttributes(JavaClass javaClass, ReferenceType typ" 794f9b5^:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

        // the following block will not detect @Pointcut in non @Aspect types for optimization purpose
        if (!hasAtAspectAnnotation) {
            return EMPTY_LIST;
        }

  public static void main(String [] argv) {
    new Test().foo();
  }
  Set<Integer> intsSet = new HashSet<Integer>();
  public Set<Integer> foo() {
    return intsSet;
  }
  pointcut gettingMember(Test t) :
             target(t) &&
             get(!public Set<Integer> com.*.*) &&
             !within(TestAspect);
  Set<Integer> around(Test t) : gettingMember(t)  {
    Set s =  proceed(t);
    return s;
  }
======= fetch "protected File getSpecFile() {" 8cea30f^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testUnboundFormal_pr112027()    { runTest("unexpected error unboundFormalInPC");}
  public void testCCEGenerics_pr113445()      { runTest("Generics ClassCastException");}
======= fetch "protected File getSpecFile() {" 8cea30f^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  
======= fetch "protected File getSpecFile() {" 8cea30f^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

    
 
======= fetch "public boolean match(Shadow shadow, World world) {" 8cea30f^:"weaver/src/org/aspectj/weaver/Advice.java"

    				} else if(!shadow.getReturnType().resolve(world).isAssignableFrom(getSignature().getReturnType().resolve(world))) {
    					//System.err.println(this + ", " + sourceContext + ", " + start);
======= fetch "public static Kind read(DataInputStream s) throws IOException {" 8cea30f^:"weaver/src/org/aspectj/weaver/Member.java"

======= fetch "public String toLongString() {" 8cea30f^:"weaver/src/org/aspectj/weaver/MemberImpl.java"

    
    public UnresolvedType getGenericReturnType() { return getReturnType(); }

    declare @field : int C.noSuchField : @Annotation; // should be an error
    
    
    
======= fetch "protected File getSpecFile() {" 2da9b31^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testDeclareAnnotationOnNonExistentType_pr99191_1() { runTest("declare annotation on non existent type - 1");}
  public void testDeclareAnnotationOnNonExistentType_pr99191_2() { runTest("declare annotation on non existent type - 2");}  
  public void testDeclareAnnotationOnNonExistentType_pr99191_3() { runTest("declare annotation on non existent type - 3");}  
  public void testDeclareAnnotationOnNonExistentType_pr99191_4() { runTest("declare annotation on non existent type - 4");}  
  public void testDeclareAnnotationOnNonExistentType_pr99191_5() { runTest("declare annotation on non existent type - 5");}  
  
    
    
    <ajc-test dir="bugs150/pr99191" title="declare annotation on non existent type - 1">
        <compile files="pr99191_1.java" options="-1.5">
        	<message kind="error" line="4" text="The field 'int C.noSuchField' does not exist"/>
        </compile>
    </ajc-test> 
    <!-- Currently a warning doesn't occur if the annotation is already on the field
         (see bug 113029). If this is fixed, need to add check for this warning to this
         test as in test "declare annotation on non existent type - 4" -->
    <ajc-test dir="bugs150/pr99191" title="declare annotation on non existent type - 2">
        <compile files="pr99191_2.java" options="-1.5">
        </compile>
    </ajc-test> 
    <ajc-test dir="bugs150/pr99191" title="declare annotation on non existent type - 3">
        <compile files="pr99191_3.java" options="-1.5">
        	<message kind="error" line="4" text="The method 'public * C.noSuchMethod(..)' does not exist"/>
        </compile>
    </ajc-test> 
    <ajc-test dir="bugs150/pr99191" title="declare annotation on non existent type - 4">
        <compile files="pr99191_4.java" options="-1.5">
        	<message kind="warning" text="void C.amethod() - already has an annotation of type Annotation, cannot add a second instance [Xlint:elementAlreadyAnnotated]"/>
        </compile>
    </ajc-test> 
    <ajc-test dir="bugs150/pr99191" title="declare annotation on non existent type - 5">
        <compile files="pr99191_5.java" options="-1.5">
        	<message kind="error" line="4" text="The method 'C.new(java.lang.String)' does not exist"/>
        </compile>
    </ajc-test> 
    <ajc-test dir="bugs150/pr99191" title="declare annotation on non existent type - 6">
        <compile files="pr99191_6.java" options="-1.5">
        	<message kind="warning" text="void C.&lt;init&gt;(int) - already has an annotation of type Annotation, cannot add a second instance [Xlint:elementAlreadyAnnotated]"/>
        </compile>
    </ajc-test>
======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" 2da9b31^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" 2da9b31^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

            			if (doesAlreadyHaveAnnotation(mg.getMemberView(),decaM,reportedProblems)) continue; // skip this one...
======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" 2da9b31^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

            			unusedDecams.remove(decaM);           			
======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" 2da9b31^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

            				if (doesAlreadyHaveAnnotation(mg.getMemberView(),decaM,reportedProblems)) continue; // skip this one...
======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" 2da9b31^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

    						// remove the declare @method since have matched against it
            				unusedDecams.remove(decaM);
======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" 2da9b31^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtField(LazyClassGen clazz) {" 2da9b31^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtField(LazyClassGen clazz) {" 2da9b31^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

            				// remove the declare @field since don't want an error when 
            				// the annotation is already there
            				unusedDecafs.remove(decaF);
======= fetch "private boolean weaveDeclareAtField(LazyClassGen clazz) {" 2da9b31^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        			unusedDecafs.remove(decaF); 
======= fetch "private boolean weaveDeclareAtField(LazyClassGen clazz) {" 2da9b31^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        				// remove the declare @field since don't want an error when 
        				// the annotation is already there
        				unusedDecafs.remove(decaF);
======= fetch "private boolean weaveDeclareAtField(LazyClassGen clazz) {" 2da9b31^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        			unusedDecafs.remove(decaF); 
======= fetch "private boolean weaveDeclareAtField(LazyClassGen clazz) {" 2da9b31^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtField(LazyClassGen clazz) {" 2da9b31^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"


======= fetch "public void testOutJar() {" cc6862f^:"ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java"

        assertTrue(configFile + " failed", null != buildConfig);            
======= fetch "public void installGlobals(AjBuildConfig global) { // XXX relies on default valu" cc6862f^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

        if (!isXHasMemberEnabled() && global.isXHasMemberEnabled()) {
        	setXHasMemberSupport(true);
        }

======= fetch "static WeavingAdaptor getWeaver(ClassLoader loader, IWeavingContext weavingConte" 70888dd^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

            ExplicitlyInitializedClassLaoderWeavingAdaptor adaptor = null;
======= fetch "static WeavingAdaptor getWeaver(ClassLoader loader, IWeavingContext weavingConte" 70888dd^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

                adaptor = (ExplicitlyInitializedClassLaoderWeavingAdaptor) weavingAdaptors.get(loader);
======= fetch "static WeavingAdaptor getWeaver(ClassLoader loader, IWeavingContext weavingConte" 70888dd^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

                    adaptor = new ExplicitlyInitializedClassLaoderWeavingAdaptor(weavingAdaptor);
======= fetch "static WeavingAdaptor getWeaver(ClassLoader loader, IWeavingContext weavingConte" 70888dd^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

    static class ExplicitlyInitializedClassLaoderWeavingAdaptor {
======= fetch "static WeavingAdaptor getWeaver(ClassLoader loader, IWeavingContext weavingConte" 70888dd^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

        public ExplicitlyInitializedClassLaoderWeavingAdaptor(ClassLoaderWeavingAdaptor weavingAdaptor) {
======= fetch "public void addCrossReference(ISourceLocation from, ISourceLocation to, IRelatio" 70888dd^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        messageHandler = bcelWorld.getMessageHandler();
======= fetch "public void addCrossReference(ISourceLocation from, ISourceLocation to, IRelatio" 70888dd^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        // after adding aspects
        weaver.prepareForWeave();
======= fetch "private void registerDefinitions(final BcelWeaver weaver, final ClassLoader load" 70888dd^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

            registerAspectExclude(weaver, loader, definitions);
            registerAspects(weaver, loader, definitions);
            registerIncludeExclude(weaver, loader, definitions);
            registerDump(weaver, loader, definitions);

    public void doSomething() { }
    declare parents : SomeClass implements Serializable;
    pointcut doSomething(SomeClass someClass) :
            execution(void SomeClass.doSomething()) &&
            this(someClass);
    void around(Serializable myWorld) : doSomething(myWorld) { }
    
======= fetch "public void testParameterizedGenericMethods() {" 3021284^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testIllegalChangeToPointcutDeclaration_pr111915() {
  }
  
    
    <ajc-test dir="bugs150" title="test illegal change to pointcut declaration">
        <compile files="pr111915.java" options="-1.5 -showWeaveInfo">
          <message kind="weave" text="Join point 'method-execution(void SomeClass.doSomething())' in Type 'SomeClass' (pr111915.java:4) advised by around advice from 'DoesntCompile' (pr111915.java:15)"/>
          <message kind="weave" text="Extending interface set for type 'SomeClass' (pr111915.java) to include 'java.io.Serializable' (pr111915.java)"/>
        </compile>
    </ajc-test> 
======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" 3021284^:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= fetch "public Pointcut concretize1(ResolvedType searchStart, ResolvedType declaringType" 3021284^:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= fetch "public Pointcut concretize1(ResolvedType searchStart, ResolvedType declaringType" 3021284^:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"


======= fetch "public void testVarArgsIITDInConstructor() {" f06df41^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

   
  public void testWeaveInfoMessageForDeclareAtMethodOnITDdMethod() {
  }
    <ajc-test dir="bugs150" title="weaveinfo message for declare at method on an ITDd method">
        <compile files="pr113073.java" options="-1.5 -showWeaveInfo">
        </compile>
    </ajc-test> 
======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" f06df41^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

            			
            			reportMethodCtorWeavingMessage(clazz, mg, decaM);
======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" f06df41^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

    // TAG: WeavingMessage
======= fetch "private void reportMethodCtorWeavingMessage(LazyClassGen clazz, LazyMethodGen mg" f06df41^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private void reportMethodCtorWeavingMessage(LazyClassGen clazz, LazyMethodGen mg" f06df41^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private void reportMethodCtorWeavingMessage(LazyClassGen clazz, LazyMethodGen mg" f06df41^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private void reportMethodCtorWeavingMessage(LazyClassGen clazz, LazyMethodGen mg" f06df41^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private void reportMethodCtorWeavingMessage(LazyClassGen clazz, LazyMethodGen mg" f06df41^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private void reportMethodCtorWeavingMessage(LazyClassGen clazz, LazyMethodGen mg" f06df41^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private void reportMethodCtorWeavingMessage(LazyClassGen clazz, LazyMethodGen mg" f06df41^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveAtMethodOnITDSRepeatedly(List decaMCs, List itdMethodsCtors" f06df41^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"


  pointcut pc() : this(pr112027);
  before(pr112027 tis) : pc() && this(tis) { }
======= fetch "protected File getSpecFile() {" ae612d9^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testUnboundFormal_pr112027() { runTest("unexpected error unboundFormalInPC");}
  
   
   <ajc-test dir="bugs150" title="unexpected error unboundFormalInPC">
     <compile files="pr112027.aj"/>
   </ajc-test>
======= fetch "public int hashCode() {" ae612d9^:"weaver/src/org/aspectj/weaver/patterns/BindingTypePattern.java"

        result = 37*result + type.hashCode();
======= fetch "public boolean equals(Object other) {" ae612d9^:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

    	if (other instanceof BindingTypePattern) return false;
======= fetch "public int hashCode() {" ae612d9^:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

        result = 37*result + new Boolean(includeSubtypes).hashCode();
        result = 37*result + new Boolean(isVarArgs).hashCode();
        result = 37*result + typeParameters.hashCode();

======= fetch "private File makeFile(File dir, String name) {" 332a5df^:"util/src/org/aspectj/util/ConfigParser.java"

        if (dir != null && !ret.isAbsolute()) { 

 * @version $Id: ClassParser.java,v 1.3 2005/09/14 11:10:57 aclement Exp $
======= fetch "private final void readConstantPool() throws IOException, ClassFormatException" 999d9b0^:"bcel-builder/src/org/aspectj/apache/bcel/classfile/ClassParser.java"

    constant_pool = new ConstantPool(file);

======= fetch "public ResolvedType put(String key, ResolvedType type) {" 04e8dca^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public BcelObjectType addSourceObjectType(JavaClass jc) {" 04e8dca^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

        ReferenceType nameTypeX = (ReferenceType)typeMap.get(signature);

    static List visibleFileList = new ArrayList();
        int pointcutSummaryIndex = fileContents.toString().indexOf("Pointcut Summary");
        int adviceSummaryIndex = fileContents.toString().indexOf("Advice Summary");
======= fetch "static void addAspectDocumentation(IProgramElement node, StringBuffer fileBuffer" ab6c7a5^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

    	List declares = new ArrayList();
======= fetch "static void addAspectDocumentation(IProgramElement node, StringBuffer fileBuffer" ab6c7a5^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

    		} else if (member.getKind().isDeclare() || member.getKind().isInterTypeMember()) {
    			declares.add(member);
======= fetch "static void addAspectDocumentation(IProgramElement node, StringBuffer fileBuffer" ab6c7a5^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

    	if (declares.size() > 0) {
    		insertDeclarationsDetails(fileBuffer, declares, DECLARE_DETAIL, index);
    		insertDeclarationsSummary(fileBuffer, declares, DECLARE_SUMMARY, index);
    	}
======= fetch "static void addAspectDocumentation(IProgramElement node, StringBuffer fileBuffer" ab6c7a5^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

    		insertDeclarationsSummary(fileBuffer, pointcuts, "Pointcut Summary", index);
    		insertDeclarationsDetails(fileBuffer, pointcuts, "Pointcut Detail", index);
======= fetch "static void addAspectDocumentation(IProgramElement node, StringBuffer fileBuffer" ab6c7a5^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

    		insertDeclarationsSummary(fileBuffer, advice, "Advice Summary", index);
    		insertDeclarationsDetails(fileBuffer, advice, "Advice Detail", index);
======= fetch "static void insertDeclarationsSummary(StringBuffer  fileBuffer," ab6c7a5^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

                if ( kind.equals( "Advice Summary" ) ) {
======= fetch "static void insertDeclarationsSummary(StringBuffer  fileBuffer," ab6c7a5^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

                else if ( kind.equals( "Pointcut Summary" ) ) {
======= fetch "static void insertDeclarationsSummary(StringBuffer  fileBuffer," ab6c7a5^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

                else if ( kind.equals( "Introduction Summary" ) ) {
======= fetch "static void insertDeclarationsSummary(StringBuffer  fileBuffer," ab6c7a5^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

                            "<TT>introduction " + decl.toLabelString() + "</TT></A><P>" +
                            generateIntroductionSignatures(decl, false) +
======= fetch "static void insertDeclarationsDetails(StringBuffer  fileBuffer," ab6c7a5^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

                if ( kind.equals( "Advice Detail" ) ) {
======= fetch "static void insertDeclarationsDetails(StringBuffer  fileBuffer," ab6c7a5^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

                else if (kind.equals("Pointcut Detail")) {
======= fetch "static void insertDeclarationsDetails(StringBuffer  fileBuffer," ab6c7a5^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

                else if (kind.equals("Introduction Detail")) {
                	entry += "<H3>introduction " + decl.toLabelString() + "</H3><P>";
======= fetch "static void decorateMemberDocumentation(IProgramElement node," ab6c7a5^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        if (targets != null && !targets.isEmpty()) {
            String prevName = "";
            
======= fetch "static String generateAffects(IProgramElement decl, boolean isIntroduction) {" ab6c7a5^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

      List targets = StructureUtil.getTargets(decl, IRelationship.Kind.ADVICE);
      if (targets == null) return null;
        List packageList = new ArrayList();
        String entry
        = "<TABLE WIDTH=\"100%\" BGCOLOR=#FFFFFF><TR>" +
          "<TD width=\"10%\" bgcolor=\"#FFD8B0\"><B><FONT COLOR=000000>&nbsp;Advises:</b></font></td><td>";
    
======= fetch "static String generateHREFName(IProgramElement decl) {" ab6c7a5^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        String hrefLink = decl.toLabelString(); // !!!
======= fetch "private static void processMembers(List/*IProgramElement*/ members, PrintWriter" ab6c7a5^:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

    public static File ASPECTJRT_PATH;
======= fetch "public static Test suite() {" ab6c7a5^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java"

        suite.addTestSuite(DeclareFormsTest.class);
 * Copyright (c) 2003 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Mik Kersten     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
            "-classpath",
            AjdocTests.ASPECTJRT_PATH.getPath(),
======= fetch "public void testFailingBuild() {" ab6c7a5^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/ExecutionTestCase.java"

======= fetch "public void testSimpleExample() {" ab6c7a5^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/PatternsTestCase.java"

    protected File file1 = new File("testdata/bug82340/Pointcuts.java");
    protected File outdir = new File("testdata/bug82340/doc");
======= fetch "protected void setUp() throws Exception {" ab6c7a5^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.java"

======= fetch "public void testPublicModeExample() {" ab6c7a5^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.java"


    Object x = getLogger();  
    Object x = getLogger();  
======= fetch "public void testBuildingDependantProjects() {" 727b0f5^:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


======= fetch "private void registerOptions(final BcelWeaver weaver, final ClassLoader loader," 12e6334^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        weaver.setReweavableMode(weaverOption.reWeavable, false);
    private final static String OPTION_reweavable = "-Xreweavable";
======= fetch "public static WeaverOption parse(String options, ClassLoader laoder) {" 12e6334^:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

            } else if (arg.equalsIgnoreCase(OPTION_reweavable)) {
                weaverOption.reWeavable = true;
======= fetch "public static WeaverOption parse(String options, ClassLoader laoder) {" 12e6334^:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

        boolean reWeavable;
======= fetch "public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r" 12e6334^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

            	buildConfig.setXreweavable(true);
======= fetch "public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r" 12e6334^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

            		buildConfig.setXreweavableCompressClasses(true);
======= fetch "public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r" 12e6334^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

            	buildConfig.setXnotReweavable(true);
======= fetch "public void installGlobals(AjBuildConfig global) { // XXX relies on default valu" 12e6334^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

        if (!isXreweavable() && global.isXreweavable()) {
        	setXreweavable(true);
        }
        if (!getXreweavableCompressClasses() && global.getXreweavableCompressClasses()) {
        	setXreweavableCompressClasses(true);
======= fetch "public void setXlazyTjp(boolean b) {" 12e6334^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= fetch "public boolean isXdevPinpoint() {" 12e6334^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" 12e6334^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public Map getMap() {" 12e6334^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= fetch "public void set(Map optionsMap) {" 12e6334^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= fetch "public void set(Map optionsMap) {" 12e6334^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= fetch "public void set(Map optionsMap) {" 12e6334^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= fetch "public void set(Map optionsMap) {" 12e6334^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= fetch "public void set(Map optionsMap) {" 12e6334^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= fetch "public String toString() {" 12e6334^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= fetch "private void initWorldAndWeaver(AjCompilerOptions options) {" 12e6334^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AspectJBuilder.java"

======= fetch "public void testJar1() throws IOException {" 12e6334^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BinaryFormsTestCase.java"

======= fetch "public void testJar1() throws IOException {" 12e6334^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BinaryFormsTestCase.java"

======= fetch "public void testJar1() throws IOException {" 12e6334^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BinaryFormsTestCase.java"

======= fetch "public void testJar1() throws IOException {" 12e6334^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BinaryFormsTestCase.java"

======= fetch "public void testJar1() throws IOException {" 12e6334^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BinaryFormsTestCase.java"

======= fetch "public void testDefaultValues() {" 12e6334^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= fetch "public void testDirectSet() {" 12e6334^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= fetch "public void testDirectSet() {" 12e6334^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= fetch "public void testMapSet() {" 12e6334^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= fetch "public void testMapSet() {" 12e6334^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= fetch "public String toString() {" 12e6334^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

        		"reweavable", "reweavable:compress", "noInline"
======= fetch "public void setXReweavable(boolean reweavable) {" 12e6334^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    public void setXNotReweavable(boolean notReweavable) {
    	cmd.addFlag("-XnotReweavable",notReweavable);
    }
    
======= fetch "String next() {" 12e6334^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

            } else if ("-XnotReweavable".equals(flag)) {
======= fetch "public void execute(AjcTestCase inTestCase) {" 12e6334^:"testing/newsrc/org/aspectj/testing/WeaveSpec.java"

======= fetch "private CRSOptions() {" 12e6334^:"testing/src/org/aspectj/testing/harness/bridge/CompilerRun.java"

                 options="-Xreweavable"
                 options="-Xreweavable"
======= fetch "public static void main(String args[]) throws Throwable {" 12e6334^:"tests/java5/ataspectj/ataspectj/ltwlog/MainVerboseAndShow.java"

        
======= fetch "public static void main(String args[]) throws Throwable {" 12e6334^:"tests/java5/ataspectj/ataspectj/ltwlog/MainVerboseAndShow.java"

                "info weaver operating in reweavable mode.  Need to verify any required types exist.",
======= fetch "public static void main(String args[]) throws Throwable {" 12e6334^:"tests/java5/ataspectj/ataspectj/ltwlog/MainVerboseAndShow.java"

                "info weaving 'ataspectj/ltwlog/Aspect1'"}))) {
    <weaver options="-XmessageHandlerClass:ataspectj.ltwlog.MessageHolder -verbose"/>
        		   pack/MyInterface.java"/>
   	   <compile files="TestA_generictype.java" outjar="code.jar" options="-1.5,-Xreweavable"/>
       <compile files="TestA_aspect.aj,TestA_class.java" inpath="code.jar" options="-1.5,-Xreweavable"/>
   	   <compile files="TestB_generictype.java" outjar="code.jar" options="-1.5,-Xreweavable"/>
       <compile files="TestB_aspect1.aj,TestB_aspect2.aj,TestB_class.java" inpath="code.jar" options="-1.5,-Xreweavable"/>
   	   <compile files="BaseClass.java" outjar="code.jar" options="-1.5,-Xreweavable"/>
       <compile files="A1.aj" inpath="code.jar" options="-1.5,-Xreweavable"/>
   	   <compile files="BaseClass.java,A1.aj" outjar="code.jar" options="-1.5,-Xreweavable,-showWeaveInfo">
       <compile files="A2.aj" inpath="code.jar" options="-1.5,-Xreweavable,-showWeaveInfo">
   	   <compile files="BaseClass.java,A1.aj,A2.aj" outjar="code.jar" options="-1.5,-Xreweavable"/>
       <compile files="A3.aj" inpath="code.jar" options="-1.5,-Xreweavable"/>
   	 <compile files="Sub1.java,Super1.java" outjar="code.jar" options="-1.5,-Xreweavable"/>
   	 <compile files="X1.aj,Util.java" inpath="code.jar" options ="-1.5,-Xreweavable"/>
   	 <compile files="Sub2.java,Super2.java" outjar="code.jar" options="-1.5,-Xreweavable"/>
   	 <compile files="X2.aj,Util.java" inpath="code.jar" options ="-1.5,-Xreweavable"/>
   	 <compile files="Sub3.java,Super3.java" outjar="code.jar" options="-1.5,-Xreweavable"/>
   	 <compile files="X3.aj,Util.java" inpath="code.jar" options ="-1.5,-Xreweavable"/>
======= fetch "public void testAjcLTWAroundInlineMungerTest_Xreweavable() {" 12e6334^:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"

        runTest("AjcLTW AroundInlineMungerTest -Xreweavable");
            options="-1.5 -Xreweavable"/>
            options="-1.5 -Xreweavable"/>
            options="-1.5 -Xreweavable"/>
            options="-1.5 -Xlint:ignore -XnoInline -Xreweavable"/>
            options="-1.5 -Xreweavable -XnoInline"/>
            options="-1.5 -Xreweavable"/>
            options="-1.5 -Xreweavable"
        <compile staging="true" options="-incremental,-emacssym" sourceroots="src"/>
        <compile staging="true" options="-incremental,-emacssym" sourceroots="src"/>
======= fetch "public WeaverStateInfo() {" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public WeaverStateInfo() {" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "private WeaverStateInfo(List typeMungers, boolean oldStyle,boolean reweavableMod" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "private WeaverStateInfo(List typeMungers, boolean oldStyle,boolean reweavableMod" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public static void setReweavableModeDefaults(boolean mode, boolean compress) {" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public static void setReweavableModeDefaults(boolean mode, boolean compress) {" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public static void setReweavableModeDefaults(boolean mode, boolean compress) {" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public static final WeaverStateInfo read(VersionedDataInputStream s, ISourceCont" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public static final WeaverStateInfo read(VersionedDataInputStream s, ISourceCont" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public static final WeaverStateInfo read(VersionedDataInputStream s, ISourceCont" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public static final WeaverStateInfo read(VersionedDataInputStream s, ISourceCont" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public String toString() {" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public boolean isOldStyle() {" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

        	unwovenClassFileIsADiff = false;
======= fetch "public boolean isOldStyle() {" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

    }
======= fetch "public boolean isReweavable() {" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public void setReweavable(boolean rw,boolean compressData) {" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public void addAspectAffectingType(String aspectType) {" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

    ////
    
======= fetch "private static void readAnyReweavableData(WeaverStateInfo wsi,DataInputStream s)" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "private static void readAnyReweavableData(WeaverStateInfo wsi,DataInputStream s)" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "private static void readAnyReweavableData(WeaverStateInfo wsi,DataInputStream s)" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "private static void readAnyReweavableData(WeaverStateInfo wsi,DataInputStream s)" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "private static void readAnyReweavableData(WeaverStateInfo wsi,DataInputStream s)" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

    }
        for(int i = wovenClassFile.length - 1; i > 0; i--)
            if(endOfKeyHere(wovenClassFile, i)){
                return i + 1;
            }
        throw new RuntimeException("key not found in wovenClassFile"); // should never happen
    }
        for(int j = 0; j < key.length; j++)
            if(key[key.length - 1 - j] != lookIn[i - j]){
                return false;
            }
        return true;
    }
        byte result[] = new byte[original.length + toInsert.length];
        System.arraycopy(original, 0, result, 0, offset);
        System.arraycopy(toInsert, 0, result, offset, toInsert.length);
        System.arraycopy(original, offset, result, offset + toInsert.length, original.length - offset);
        return result;
    }
        ByteArrayInputStream b = new ByteArrayInputStream(a, offset, 4);
        DataInputStream d = new DataInputStream(b);
        int length = -1;
        try{
            length = d.readInt();
        }
        catch(IOException e) {
        	throw(new RuntimeException("readInt called with a bad array or offset")); // should never happen
        }
        return length;
    }
        byte result[] = new byte[a.length - lengthToDelete]; // make a new array
        System.arraycopy(a, 0, result, 0, start); // copy in the bit before the deleted bit
        System.arraycopy(a, end, result, start, a.length - end); // copy in the bit after the deleted bit
        return result;
    }
======= fetch "private static void writeAnyReweavableData(WeaverStateInfo wsi,DataOutputStream" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "private static void writeAnyReweavableData(WeaverStateInfo wsi,DataOutputStream" 12e6334^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public static boolean weave(" 12e6334^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public boolean weave() {" 12e6334^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        	clazz.getOrCreateWeaverStateInfo();
======= fetch "public boolean weave() {" 12e6334^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        if (inReweavableMode || clazz.getType().isAspect()) {
        	WeaverStateInfo wsi = clazz.getOrCreateWeaverStateInfo();
======= fetch "public boolean weave() {" 12e6334^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        	wsi.setReweavable(true,compressReweavableAttributes);
======= fetch "public boolean weave() {" 12e6334^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        	clazz.getOrCreateWeaverStateInfo().setReweavable(false,false);
======= fetch "private Set findAspectsForMungers(LazyMethodGen mg) {" 12e6334^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private void implement(LazyMethodGen mg) {" 12e6334^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        mg.matchedShadows = null;
======= fetch "public BcelWorld getWorld() {" 12e6334^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public static void setReweavableMode(boolean mode,boolean compress) {" 12e6334^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public boolean munge(BcelClassWeaver weaver) {" 12e6334^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "public void processReweavableStateIfPresent(String className, BcelObjectType cla" 12e6334^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public void addNormalTypeMungers(String typeName) {" 12e6334^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

    	ret[0] = new UnwovenClassFile(clazz.getFileName(),clazz.getJavaClass(world).getBytes());
======= fetch "public void setProgressListener(IProgressListener listener, double previousProgr" 12e6334^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public JavaClass getJavaClass(BcelWorld world) {" 12e6334^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

    
    public byte [] getJavaClassBytesIncludingReweavable(BcelWorld world){
        writeBack(world);
        byte [] wovenClassFileData = myGen.getJavaClass().getBytes();
        WeaverStateInfo wsi = myType.getWeaverState();//getOrCreateWeaverStateInfo();
        if(wsi != null && wsi.isReweavable()){ // && !reweavableDataInserted
            //reweavableDataInserted = true;
            return wsi.replaceKeyWithDiff(wovenClassFileData);
        } else{
            return wovenClassFileData;
        }
    }
======= fetch "public boolean isReweavable() {" 12e6334^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= fetch "public Set getAspectsAffectingType() {" 12e6334^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= fetch "public WeaverStateInfo getOrCreateWeaverStateInfo() {" 12e6334^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"


======= fetch "public AnnotationPatternList(List l) {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.java"

======= fetch "public Set couldMatchKinds() {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= fetch "public Set couldMatchKinds() {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= fetch "public TypePatternList getArguments() {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

    public Pointcut parameterizeWith(Map typeVariableMap) {
    	ArgsPointcut ret = new ArgsPointcut(this.arguments.parameterizeWith(typeVariableMap));
    	ret.copyLocationFrom(this);
    	return ret;
    }
    
======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= fetch "private Test findResidueNoEllipsis(Shadow shadow, ExposedState state, TypePatter" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

                  shadow.getIWorld().getMessageHandler().handleMessage(msg);
======= fetch "public static Pointcut read(VersionedDataInputStream s, ISourceContext context)" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/ConcreteCflowPointcut.java"

======= fetch "public Declare parameterizeWith(Map typeVariableBindingMap) {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/DeclareAnnotation.java"

======= fetch "public Declare parameterizeWith(Map typeVariableBindingMap) {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/PerCflow.java"

    public Pointcut parameterizeWith(Map typeVariableMap) {
    	PerCflow ret = new PerCflow(entry.parameterizeWith(typeVariableMap),isBelow);
    	ret.copyLocationFrom(this);
    	return ret;
    }
    
======= fetch "public PerClause concretize(ResolvedType inAspect) {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/PerObject.java"

    public Pointcut parameterizeWith(Map typeVariableMap) {
    	PerObject ret = new PerObject(entry.parameterizeWith(typeVariableMap),isThis);
    	ret.copyLocationFrom(this);
    	return ret;
    }
    
======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/PerSingleton.java"

    public Pointcut parameterizeWith(Map typeVariableMap) {
    	return this;
    }
    
======= fetch "public Set couldMatchKinds() {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java"

======= fetch "public void assertState(State state) {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= fetch "public Set couldMatchKinds() {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java"

======= fetch "public TypePattern getType() {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= fetch "public TypePattern parameterizeWith(Map typeVariableMap) {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= fetch "public Set couldMatchKinds() {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java"

======= fetch "public Set couldMatchKinds() {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java"

======= fetch "public Set couldMatchKinds() {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= fetch "public Set couldMatchKinds() {" 451fea8^:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"


======= fetch "public EclipseTypeMunger build(ClassScope classScope) {" 2b0e675^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeConstructorDeclaration.java"

  public static void main(String []argv) {
    new pr111481(new Object[]{"a","b","c"});
    new pr111481("a","b","c");
  }
    public pr111481.new(Object... names) {
    	System.out.println(names[0]);
    }
======= fetch "public void testDWInStructureModelWithAnonymousInnerClass_pr77269() {" 2b0e675^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testVarArgsIITDInConstructor() {
  }
   <ajc-test dir="bugs150" title="ITD varargs in constructor">
     <compile files="pr111481.aj" options="-1.5"/>
       <stdout>
           <line text="a"/>
           <line text="a"/>
       </stdout>
      </run>
   </ajc-test>

======= fetch "public IProgramElement findElementForType(String packageName, String typeName) {" 4573068^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public IProgramElement findElementForType(String packageName, String typeName) {" 4573068^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "private IProgramElement findClassInNodes(Collection nodes, String name) {" 4573068^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "private IProgramElement findClassInNodes(Collection nodes, String name) {" 4573068^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public boolean visit(TypeDeclaration memberTypeDeclaration, BlockScope scope) {" 4573068^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= fetch "public void testDebugInfoForAroundAdvice() {" 4573068^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testAdviceInStructureModelWithAnonymousInnerClass_pr77269() {
  	  IHierarchy top = AsmManager.getDefault().getHierarchy();
  	    	  
  	  // checking that the run() method inside anonymous inner class is in 
  	  // the structure model
  	  IProgramElement anonRunMethodIPE = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.METHOD,"run()");  	 
  	 
  	  assertNotNull("Couldn't find 'run()' element in the tree",anonRunMethodIPE);
  	  List l = AsmManager.getDefault().getRelationshipMap().get(anonRunMethodIPE);	
  	  assertNotNull("Should have some relationships but does not",l);
  	  assertTrue("Should have one relationship but has " + l.size(),l.size()==1);
  	  Relationship rel = (Relationship)l.get(0);
  	  List targets = rel.getTargets();
  	  assertTrue("Should have one target but has" + targets.size(),
  			  targets.size()==1);
  	  IProgramElement target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)targets.get(0));
  	  assertEquals("target of relationship should be 'before(): p..' but is "
  			  + target.toLabelString(),"before(): p..",target.toLabelString());
  	  
  	  IProgramElement adviceIPE = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.ADVICE,"before(): p..");  	  
  	  assertNotNull("Couldn't find 'before(): p..' element in the tree",adviceIPE);
  	  l = AsmManager.getDefault().getRelationshipMap().get(adviceIPE);
  	  assertNotNull("Should have some relationships but does not",l);
  	  assertTrue("Should have a relationship but does not ",l.size()>0);
  	  for (Iterator iter = l.iterator(); iter.hasNext();) {
  	  targets = rel.getTargets();
  	  assertTrue("Should have one target but has" + targets.size(),
  			  targets.size()==1);
  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)targets.get(0));
  	  assertEquals("target of relationship should be 'run()' but is "
  			  + target.toLabelString(),"run()",target.toLabelString());
  	  
  }
 
  public void testAdviceInStructureModelWithNamedInnerClass_pr77269() {
  	  IHierarchy top = AsmManager.getDefault().getHierarchy();
  	    	  
  	  // checking that the m() method inside named inner class is in 
  	  // the structure model
  	  IProgramElement namedMethodIPE = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.METHOD,"m()");  	  
  	  assertNotNull("Couldn't find 'm()' element in the tree",namedMethodIPE);
  	  List l = AsmManager.getDefault().getRelationshipMap().get(namedMethodIPE);	
  	  assertNotNull("Should have some relationships but does not",l);
  	  assertTrue("Should have one relationship but has " + l.size(),l.size()==1);
  	  Relationship rel = (Relationship)l.get(0);
  	  List targets = rel.getTargets();
  	  assertTrue("Should have one target but has" + targets.size(),
  			  targets.size()==1);
  	  IProgramElement target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)targets.get(0));
  	  assertEquals("target of relationship should be 'before(): p..' but is "
  			  + target.toLabelString(),"before(): p..",target.toLabelString());
  	  
  	  IProgramElement adviceIPE = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.ADVICE,"before(): p..");  	  
  	  assertNotNull("Couldn't find 'before(): p..' element in the tree",adviceIPE);
  	  l = AsmManager.getDefault().getRelationshipMap().get(adviceIPE);
  	  assertNotNull("Should have some relationships but does not",l);
  	  assertTrue("Should have a relationship but does not ",l.size()>0);
  	  for (Iterator iter = l.iterator(); iter.hasNext();) {
  	  targets = rel.getTargets();
  	  assertTrue("Should have one target but has" + targets.size(),
  			  targets.size()==1);
  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)targets.get(0));
  	  assertEquals("target of relationship should be 'm()' but is "
  			  + target.toLabelString(),"m()",target.toLabelString());
  	  
  }
  
  public void testDWInStructureModelWithAnonymousInnerClass_pr77269() {
      // AsmManager.setReporting("c:/debug.txt",true,true,true,true);
  	  IHierarchy top = AsmManager.getDefault().getHierarchy();
  	  IProgramElement pe = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.CODE,"method-call(void pack.Test.someMethod())");  	 	 
  	  assertNotNull("Couldn't find 'method-call(void pack.Test.someMethod())' element in the tree",pe);
  }
  
  
    <ajc-test dir="bugs150/pr77269" title="advice in structure model with anonymous inner class">
        <compile files="pack/pr77269.aj" options="-emacssym">
        </compile>
    </ajc-test> 
    <ajc-test dir="bugs150" title="advice in structure model with named inner class">
        <compile files="pr77269b.aj" options="-emacssym">
        </compile>
    </ajc-test> 
    <ajc-test dir="bugs150/pr77269" title="declare warning in structure model with anonymous inner class">
        <compile files="pack/pr77269c.aj" options="-emacssym">
        	<message kind="warning" line="8" text="blah blah blah"/>
        </compile>
    </ajc-test> 
   <ajc-test dir="bugs150" title="ITD varargs problem">
     <compile files="pr110906.aj"/>
   </ajc-test>
   

  @org.aspectj.lang.annotation.SuppressAjWarnings
======= fetch "public void testSuppressionWithCflow_pr93345() {" 81a0790^:"tests/src/org/aspectj/systemtest/ajc150/SuppressedWarnings.java"

  
  public void testSuppressionOfMessagesIssuedDuringMatching() {
  }
   
   <ajc-test dir="java5/suppressedWarnings" title="SuppressAjWarnings raised during matching">
       <compile files="SuppressionDuringMatching.aj" options="-1.5">
       </compile>
   </ajc-test>
======= fetch "public BcelAdvice(AdviceKind kind, Pointcut pointcut, Member signature," 81a0790^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= fetch "public void specializeOn(Shadow shadow) {" 81a0790^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

    	if (suppressedLintKinds == null) {
    		if (signature instanceof BcelMethod) {
    			this.suppressedLintKinds = Utility.getSuppressedWarnings(signature.getAnnotations(), world.getLint());
    		} else {
    			this.suppressedLintKinds = Collections.EMPTY_LIST;
    		}
    	}
    	world.getLint().suppressKinds(suppressedLintKinds);
======= fetch "public void specializeOn(Shadow shadow) {" 81a0790^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= fetch "public boolean hasMatchedSomething() {" 81a0790^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

    		if (signature instanceof BcelMethod) {
    			this.suppressedLintKinds = Utility.getSuppressedWarnings(signature.getAnnotations(), inWorld.getLint());
    		} else {
    			this.suppressedLintKinds = Collections.EMPTY_LIST;
    		}
    	}
    	inWorld.getLint().suppressKinds(suppressedLintKinds);
======= fetch "public static boolean isSuppressing(AnnotationX[] anns,String lintkey) {" 81a0790^:"weaver/src/org/aspectj/weaver/bcel/Utility.java"


 * @version $Id: MethodGen.java,v 1.4 2005/03/10 12:15:04 aclement Exp $
======= fetch "public MethodGen(Method m, String class_name, ConstantPoolGen cp) {" 85a4b0a^:"bcel-builder/src/org/aspectj/apache/bcel/generic/MethodGen.java"


 * @version $Id: LocalVariableGen.java,v 1.3 2004/11/22 08:31:27 aclement Exp $
======= fetch "public LocalVariable getLocalVariable(ConstantPoolGen cp) {" 97520cf^:"bcel-builder/src/org/aspectj/apache/bcel/generic/LocalVariableGen.java"

    if(length > 0)
======= fetch "public LocalVariable getLocalVariable(ConstantPoolGen cp) {" 97520cf^:"bcel-builder/src/org/aspectj/apache/bcel/generic/LocalVariableGen.java"

      // AMC - the above calculation is off by one. The spec says that the variable
      // must have a range from start pos to start pos + length INCLUSIVE.
      // but the calculation above puts start pos + length as the address of 
      // the first instruction outside of the range. 
      // So we need to subtract 1... which gives the very end of the last inst in the range
      length = length - 1; 
    }
======= fetch "private void unpackLocals(MethodGen gen) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

                        LocalVariableTag lr = new LocalVariableTag(BcelWorld.fromBcel(lng.getType()), lng.getName(), lng.getIndex());
======= fetch "public void packBody(MethodGen gen) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        HashMap map = new HashMap();
======= fetch "public void packBody(MethodGen gen) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        Map map = copyAllInstructionsExceptRangeInstructionsInto(fresh);
======= fetch "public void packBody(MethodGen gen) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        /* Make copies of all instructions, append them to the new list
         * and associate old instruction references with the new ones, i.e.,
         * a 1:1 mapping.
         */
        for (InstructionHandle ih = getBody().getStart(); ih != null; ih = ih.getNext()) {
            if (Range.isRangeHandle(ih)) {
                continue;
            }
            Instruction i = ih.getInstruction();
            Instruction c = Utility.copyInstruction(i);
            if (c instanceof BranchInstruction)
                map.put(ih, fresh.append((BranchInstruction) c));
            else
                map.put(ih, fresh.append(c));
        }
======= fetch "public void packBody(MethodGen gen) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        InstructionHandle ih = getBody().getStart();
        InstructionHandle jh = fresh.getStart();
        LinkedList exnList = new LinkedList();   
======= fetch "public void packBody(MethodGen gen) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        while (ih != null) {
            if (map.get(ih) == null) {
                // we're a range instruction
                Range r = Range.getRange(ih);
                if (r instanceof ExceptionRange) {
                    ExceptionRange er = (ExceptionRange) r;
                    if (er.getStart() == ih) {
                    	//System.err.println("er " + er);
                    	if (!er.isEmpty()){
                        	// order is important, insert handlers in order of start
                        	insertHandler(er, exnList);
                    	}
                    }
                } else {
                    // we must be a shadow range or something equally useless, 
                    // so forget about doing anything
                }
======= fetch "public void packBody(MethodGen gen) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

                ih = ih.getNext();
======= fetch "public void packBody(MethodGen gen) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

                Instruction i = ih.getInstruction();
                Instruction j = jh.getInstruction();
    
                if (i instanceof BranchInstruction) {
                    BranchInstruction bi = (BranchInstruction) i;
                    BranchInstruction bj = (BranchInstruction) j;
                    InstructionHandle itarget = bi.getTarget(); // old target
    
                    // New target is in hash map
                    bj.setTarget(remap(itarget, map));
    
                    if (bi instanceof Select) { 
                        // Either LOOKUPSWITCH or TABLESWITCH
                        InstructionHandle[] itargets = ((Select) bi).getTargets();
                        InstructionHandle[] jtargets = ((Select) bj).getTargets();
======= fetch "public void packBody(MethodGen gen) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

                        for (int k = itargets.length - 1; k >= 0; k--) { 
                            // Update all targets
                            jtargets[k] = remap(itargets[k], map);
                            jtargets[k].addTargeter(bj);
                        }
                    }
                }
======= fetch "public void packBody(MethodGen gen) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

                InstructionTargeter[] targeters = ih.getTargeters();
======= fetch "public void packBody(MethodGen gen) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

                                gen.addLineNumber(jh, line + lineNumberOffset);
======= fetch "public void packBody(MethodGen gen) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

                            if (localVariableStarts.get(lvt) == null) {
                            	localVariableStarts.put(lvt, newInstructionHandle);
                            }
                            localVariableEnds.put(lvt, newInstructionHandle);
======= fetch "public void packBody(MethodGen gen) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

                
======= fetch "public void packBody(MethodGen gen) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

                ih = ih.getNext();
                jh = jh.getNext();
======= fetch "public void packBody(MethodGen gen) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        // now add exception handlers
        for (Iterator iter = exnList.iterator(); iter.hasNext();) {
            ExceptionRange r = (ExceptionRange) iter.next();
            if (r.isEmpty()) continue;
            gen.addExceptionHandler(
                remap(r.getRealStart(), map), 
                remap(r.getRealEnd(), map),
                remap(r.getHandler(), map),
                (r.getCatchType() == null)
                ? null 
                : (ObjectType) BcelWorld.makeBcelType(r.getCatchType()));
======= fetch "public void packBody(MethodGen gen) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        // now add local variables
======= fetch "public void packBody(MethodGen gen) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        
        // JAVAC adds line number tables (with just one entry) to generated accessor methods - this
        // keeps some tools that rely on finding at least some form of linenumbertable happy.
        // Let's check if we have one - if we don't then let's add one.
        // TODO Could be made conditional on whether line debug info is being produced
        if (gen.getLineNumbers().length==0) { 
        	gen.addLineNumber(gen.getInstructionList().getStart(),1);
======= fetch "public void packBody(MethodGen gen) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    }
======= fetch "public void packBody(MethodGen gen) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    public LocalVariableTag(UnresolvedType type, String name, int slot) {
======= fetch "public LocalVariableTag(UnresolvedType type, String name, int slot) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LocalVariableTag.java"

        this.startPos = startPosition;
======= fetch "public boolean equals(Object other) {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LocalVariableTag.java"

        return o.type.equals(type) && o.name.equals(name) && o.slot == slot;
======= fetch "public int hashCode() {" 97520cf^:"weaver/src/org/aspectj/weaver/bcel/LocalVariableTag.java"

            ret = 37*ret + startPos;

    public void test() {
    	pr102933[] array = new pr102933[0];
    	pr102933[] arrayClone = (pr102933[])array.clone();
    }
    declare warning: call(* *(..)) :
======= fetch "public void testNoRequirementForUnwovenTypesToBeExposedToWeaver() {" fb428d0^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testArrayCloneCallJoinPoints() {
  }
  
     <ajc-test dir="bugs150" title="array clone call join points in 1.4 vs 1.3">
        <compile files="pr102933.aj" options="-1.3">
            <message kind="warning" line="7" text="a call within pr102933"/>
        </compile>
        <compile files="pr102933.aj" options="-1.4">
            <message kind="warning" line="7" text="a call within pr102933"/>
        </compile>     
        <compile files="pr102933.aj" options="-1.5">
            <message kind="warning" line="7" text="a call within pr102933"/>
        </compile>   
     </ajc-test> 
     

    @DefaultImplementation 
                // join point is found by pointcut here!  This is ok!
======= fetch "public void testParameterizedGenericMethods() {" e76b370^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testCallJoinPointsInAnonymousInnerClasses() {
  }
  
  public void testNoRequirementForUnwovenTypesToBeExposedToWeaver() {
  }
  
    <ajc-test dir="bugs150" title="call join points in anonymous inner classes">
        <compile files="pr104229.aj" options="-1.5">
            <message kind="warning" line="54" text="bingo"/>
            <message kind="warning" line="115" text="bingo"/>
            <message kind="warning" line="130" text="bingo"/>
        </compile>
        <run class="pr104229">
            <stdout>
                <line text="call match class pr104229"/>
                <line text="OK it worked!"/>
            </stdout>
        </run>
    </ajc-test>
    <ajc-test dir="bugs150" title="default impl of Runnable">
        <compile files="pr88900.aj" options="-Xdev:Pinpoint">
        </compile>
    </ajc-test> 
    
======= fetch "public boolean matches(ResolvedType matchType, ResolvedType aspectType) {" e76b370^:"weaver/src/org/aspectj/weaver/ResolvedTypeMunger.java"

   				if (onType.getWeaverState() == null) {

======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" a4a9090^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void testOutjarDeletedOnError () {" a4a9090^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/OutjarTest.java"

======= fetch "public String getSignatureString(World world) {" a4a9090^:"weaver/src/org/aspectj/weaver/JoinPointSignature.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * Iterates over the signatures of a join point, calculating new signatures
 * lazily to minimize processing and to avoid unneccessary "can't find type"
 * errors. Iterator can be cached and reused by calling the "reset" method
 * between iterations.
 */
    	// first defining type
    	ResolvedType originalDeclaringType = signaturesOfMember.getDeclaringType().resolve(world);
    	firstDefiningMember = (ResolvedMemberImpl) signaturesOfMember.resolve(world);
    	if (firstDefiningMember == null) {
    		couldBeFurtherAsYetUndiscoveredSignatures = false;
    		return;
    	} 
    	
    	// declaringType can be unresolved if we matched a synthetic member generated by Aj...
    	// should be fixed elsewhere but add this resolve call on the end for now so that we can
    	// focus on one problem at a time...
    	firstDefiningType = firstDefiningMember.getDeclaringType().resolve(world);
    	if (firstDefiningType != originalDeclaringType) {
    		if (signaturesOfMember.getKind() == Member.CONSTRUCTOR) {
    			return;
    		} 
    	}
    	List declaringTypes = new ArrayList();
    	accumulateTypesInBetween(originalDeclaringType, 
    							 firstDefiningType,
    							 declaringTypes);
    	for (Iterator iter = declaringTypes.iterator(); iter.hasNext();) {
    /**
     * Build a list containing every type between subtype and supertype, inclusively. 
     */
    private void accumulateTypesInBetween(ResolvedType subType, ResolvedType superType, List types) {
    	types.add(subType);
    	if (subType == superType) {
    		return;
    	} else {
    		for (Iterator iter = subType.getDirectSupertypes(); iter.hasNext();) {
    	}
    }
    
    private boolean shouldWalkUpHierarchy() {
    	if (signaturesOfMember.getKind() == Member.CONSTRUCTOR) return false;
    	if (signaturesOfMember.getKind() == Member.FIELD) return false;
    	if (signaturesOfMember.isStatic()) return false;
    	return true;
    }
    
    private boolean findSignaturesFromSupertypes() {
    	iteratingOverDiscoveredSignatures = false;
    	if (superTypeIterator == null) {
    		superTypeIterator = firstDefiningType.getDirectSupertypes();
    	}
    	if (superTypeIterator.hasNext()) {
    		ResolvedType superType = (ResolvedType) superTypeIterator.next();
    		if (visitedSuperTypes.contains(superType)) {
    			return findSignaturesFromSupertypes();
    		} else {
    			// we haven't looked in this type yet
    			visitedSuperTypes.add(superType);
    			if (superType.isMissing()) {
    				// issue a warning, stop looking for join point signatures in this line
    				warnOnMissingType(superType);
    				return findSignaturesFromSupertypes();
    			}
    		}
    	}
    	if (!yetToBeProcessedSuperMembers.isEmpty()) {
    		SearchPair nextUp = (SearchPair) yetToBeProcessedSuperMembers.remove(0);
    		firstDefiningType = nextUp.type;
    		firstDefiningMember = nextUp.member;
    		superTypeIterator = null;
    		return findSignaturesFromSupertypes();
    	}
    	couldBeFurtherAsYetUndiscoveredSignatures = false;
    	return false;
    }
    
    /**
     * Returns true if the parent member is visible to the child member 
     * In the same declaring type this is always true, otherwise if parent is private
     * it is false.
     * @param childMember
     * @param parentMember
     * @return
     */
    private boolean isVisibleTo(ResolvedMember childMember, ResolvedMember parentMember) {
    	if (childMember.getDeclaringType().equals(parentMember.getDeclaringType())) return true;
    	if (Modifier.isPrivate(parentMember.getModifiers())) {
    		return false;
    	} else {
    		return true;
    	}
    }
    
    private void warnOnMissingType(ResolvedType missing) {
    	if (missing instanceof MissingResolvedTypeWithKnownSignature) {
    		// which it should be...
    		MissingResolvedTypeWithKnownSignature mrt = (MissingResolvedTypeWithKnownSignature) missing;
    		mrt.raiseWarningOnJoinPointSignature(signaturesOfMember.toString());
    	}
    }
    
    private static class SearchPair {
    	public ResolvedMember member;
    	public ResolvedType type;
    	public SearchPair(ResolvedMember member, ResolvedType type) {
    		this.member = member;
    		this.type = type;
    	}
    }
======= fetch "public static Kind read(DataInputStream s) throws IOException {" a4a9090^:"weaver/src/org/aspectj/weaver/Member.java"

    public JoinPointSignature[] getJoinPointSignatures(World world);
    private JoinPointSignature[] joinPointSignatures = null;
======= fetch "protected String makeString(String[] names) {" a4a9090^:"weaver/src/org/aspectj/weaver/MemberImpl.java"

======= fetch "protected String makeString(String[] names) {" a4a9090^:"weaver/src/org/aspectj/weaver/MemberImpl.java"

======= fetch "protected String makeString(String[] names) {" a4a9090^:"weaver/src/org/aspectj/weaver/MemberImpl.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * When we try to resolve a type in the world that we require to be present,
 * and then fail to find it, we return an instance of this class. This class 
 * defers the production of the "can't find type error" until the first time
 * that someone asks a question that can't be answered solely from the signature.
 * This enables the weaver to be more tolerant of missing types.
 *
 */
======= fetch "private final boolean isCoerceableFromParameterizedType(ResolvedType other) {" a4a9090^:"weaver/src/org/aspectj/weaver/ReferenceType.java"

    // true iff the statement "this = other" would compile.
======= fetch "public final boolean isAssignableFrom(ResolvedType other) {" a4a9090^:"weaver/src/org/aspectj/weaver/ReferenceType.java"

    	return isAssignableFrom(other,false);
    }
    
    // true iff the statement "this = other" would compile.
    public final boolean isAssignableFrom(ResolvedType other,boolean allowMissing) {
======= fetch "public final boolean isAssignableFrom(ResolvedType other) {" a4a9090^:"weaver/src/org/aspectj/weaver/ReferenceType.java"

       	if (this.getSignature().equals(ResolvedType.OBJECT.getSignature())) return true;
======= fetch "public final boolean isAssignableFrom(ResolvedType other) {" a4a9090^:"weaver/src/org/aspectj/weaver/ReferenceType.java"

       	if (allowMissing && other.isMissing()) return false;
       	
======= fetch "public final boolean isAssignableFrom(ResolvedType other) {" a4a9090^:"weaver/src/org/aspectj/weaver/ReferenceType.java"

            if (this.isAssignableFrom((ResolvedType) i.next())) return true;
======= fetch "private static void accumulateMembersMatching(" a4a9090^:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

======= fetch "public void resetReturnTypeToObjectArray() {" a4a9090^:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

======= fetch "public final Iterator getDirectSupertypes() {" a4a9090^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

    // return true if this resolved type couldn't be found (but we know it's name maybe)
    public boolean isMissing() { return false; }
    
======= fetch "public void remove() {" a4a9090^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

    public List getMethodsWithoutIterator(boolean includeITDs) {
======= fetch "public List getMethodsWithoutIterator(boolean includeITDs) {" a4a9090^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

        addAndRecurse(knowninterfaces,methods,this,includeITDs);
======= fetch "public List getMethodsWithoutIterator(boolean includeITDs) {" a4a9090^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

    private void addAndRecurse(Set knowninterfaces,List collector, ResolvedType rtx, boolean includeITDs) {
======= fetch "private void addAndRecurse(Set knowninterfaces,List collector, ResolvedType rtx," a4a9090^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

    	  if (rtx == null || rtx == ResolvedType.MISSING) {
    		  // can't find type message - with context!
    		  world.showMessage(Message.ERROR,
    	  } else {
    		  addAndRecurse(knowninterfaces,collector,superType,includeITDs); // Recurse if we aren't at the top
======= fetch "private void addAndRecurse(Set knowninterfaces,List collector, ResolvedType rtx," a4a9090^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

          addAndRecurse(knowninterfaces,collector,iface,includeITDs);
======= fetch "private ResolvedMember lookupMember(Member m, ResolvedMember[] a) {" a4a9090^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

     public ResolvedMember lookupResolvedMember(ResolvedMember aMember) {
======= fetch "public ResolvedMember lookupResolvedMember(ResolvedMember aMember) {" a4a9090^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

    		toSearch = getMethodsWithoutIterator(true).iterator();
======= fetch "public final boolean isAssignableFrom(ResolvedType o) {" a4a9090^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

        
        public boolean isAssignableFrom(ResolvedType o, boolean allowMissing) {
        	return isAssignableFrom(o);
        }
        
======= fetch "public final boolean isAssignableFrom(ResolvedType other) {" a4a9090^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

        public final boolean isAssignableFrom(ResolvedType other, boolean allowMissing) {
        	return isAssignableFrom(other);
        }        
======= fetch "public final String getName() {" a4a9090^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

        
        public final boolean isMissing() { return true; }
        
======= fetch "public final boolean isAssignableFrom(ResolvedType other) {" a4a9090^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

        public final boolean isAssignableFrom(ResolvedType other, boolean allowMissing) {
            return false;
        }   
======= fetch "private void collectInterTypeParentMungers(List collector) {" a4a9090^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

    private void collectInterTypeMungers(List collector) {
======= fetch "public void addInterTypeMunger(ConcreteTypeMunger munger) {" a4a9090^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

======= fetch "public boolean isTopmostImplementor(ResolvedType interfaceType) {" a4a9090^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

======= fetch "public boolean isTopmostImplementor(ResolvedType interfaceType) {" a4a9090^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

======= fetch "public final boolean isConvertableFrom(ResolvedType other) {" a4a9090^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

    public static final String CANT_FIND_PARENT_TYPE_NO_SUB = "cantFindParentTypeNoSub";
    public static final String CANT_FIND_TYPE_FIELDS = "cantFindTypeFields";
    public static final String CANT_FIND_TYPE_SUPERCLASS = "cantFindTypeSuperclass";
    public static final String CANT_FIND_TYPE_INTERFACES = "cantFindTypeInterfaces";
    public static final String CANT_FIND_TYPE_METHODS = "cantFindTypeMethods";
    public static final String CANT_FIND_TYPE_POINTCUTS = "cantFindTypePointcuts";
    public static final String CANT_FIND_TYPE_MODIFIERS = "cantFindTypeModifiers";
    public static final String CANT_FIND_TYPE_ANNOTATION = "cantFindTypeAnnotation";
    public static final String CANT_FIND_TYPE_ASSIGNABLE = "cantFindTypeAssignable";
    public static final String CANT_FIND_TYPE_COERCEABLE = "cantFindTypeCoerceable";
    public static final String CANT_FIND_TYPE_JOINPOINT = "cantFindTypeJoinPoint";
    public static final String CANT_FIND_TYPE_INTERFACE_METHODS = "cantFindTypeInterfaceMethods";
======= fetch "public ResolvedType resolve(UnresolvedType ty, boolean allowMissing) {" a4a9090^:"weaver/src/org/aspectj/weaver/World.java"

                handleRequiredMissingTypeDuringResolution(ty);
======= fetch "public ResolvedType resolve(UnresolvedType ty, boolean allowMissing) {" a4a9090^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "private void handleRequiredMissingTypeDuringResolution(UnresolvedType ty) {" a4a9090^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "private void openAroundAdvice(LazyMethodGen aroundAdvice) {" a4a9090^:"weaver/src/org/aspectj/weaver/bcel/BcelAccessForInlineMunger.java"

                List methods = callee.getMethodsWithoutIterator(false);
======= fetch "private boolean mungeNewParent(BcelClassWeaver weaver, NewParentTypeMunger munge" a4a9090^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

        List methods = newParent.getMethodsWithoutIterator(false);
======= fetch "private boolean enforceDecpRule1_abstractMethodsImplemented(BcelClassWeaver weav" a4a9090^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

            List methods = newParent.getMethodsWithoutIterator(false);
======= fetch "private boolean enforceDecpRule1_abstractMethodsImplemented(BcelClassWeaver weav" a4a9090^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

                    List newParentTargetMethods = newParentTarget.getType().getMethodsWithoutIterator(false);
======= fetch "public LazyClassGen(BcelObjectType myType) {" a4a9090^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= fetch "public void addAnnotation(Annotation a) {" a4a9090^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

    // only we don't do that because this forces us to find all the supertypes of the type,
======= fetch "public boolean matches(Member joinPointSignature, World world, boolean allowBrid" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "public boolean matches(Member joinPointSignature, World world, boolean allowBrid" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactly(JoinPointSignature aMember, World inAWorld, boole" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactly(JoinPointSignature aMember, World inAWorld, boole" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactly(JoinPointSignature aMember, World inAWorld, boole" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactly(JoinPointSignature aMember, World inAWorld, boole" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactly(JoinPointSignature aMember, World inAWorld, boole" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactlyStaticInitialization(JoinPointSignature aMember,Wo" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactlyField(JoinPointSignature aField, World world) {" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactlyField(JoinPointSignature aField, World world) {" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactlyField(JoinPointSignature aField, World world) {" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactlyMethod(JoinPointSignature aMethod, World world) {" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactlyMethod(JoinPointSignature aMethod, World world) {" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactlyMethod(JoinPointSignature aMethod, World world) {" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactlyMethod(JoinPointSignature aMethod, World world) {" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactlyMethod(JoinPointSignature aMethod, World world) {" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactlyMethod(JoinPointSignature aMethod, World world) {" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactlyMethod(JoinPointSignature aMethod, World world) {" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactlyConstructor(JoinPointSignature aConstructor, World" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactlyConstructor(JoinPointSignature aConstructor, World" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactlyConstructor(JoinPointSignature aConstructor, World" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactlyConstructor(JoinPointSignature aConstructor, World" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesExactlyConstructor(JoinPointSignature aConstructor, World" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesVarArgs(JoinPointSignature aMethodOrConstructor, World in" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesAnnotations(ResolvedMember member,World world) {" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesAnnotations(ResolvedMember member,World world) {" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesAnnotations(ResolvedMember member,World world) {" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean matchesAnnotations(ResolvedMember member,World world) {" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "public String toString() {" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/TypePatternList.java"

    /*
     * return true iff this pattern could ever match a signature with the
     * given number of parameters
     */
    public boolean canMatchSignatureWithNParameters(int numParams) {
    	if (ellipsisCount == 0) {
    		return numParams == size();
    	} else {
    		return (size() -ellipsisCount) <= numParams;
    	}
    }
    
======= fetch "private TypePattern resolveBindingsFromFullyQualifiedTypeName(String fullyQualif" a4a9090^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"


======= fetch "public void initialize() {" 03b20bc^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

            WeavingAdaptor weavingAdaptor = WeaverContainer.getWeaver(loader);
======= fetch "public void initialize() {" 03b20bc^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

        static WeavingAdaptor getWeaver(ClassLoader loader) {
======= fetch "static WeavingAdaptor getWeaver(ClassLoader loader) {" 03b20bc^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

                        weavingAdaptor = new ClassLoaderWeavingAdaptor(loader);
======= fetch "static void dump(String name, byte[] b) throws Throwable {" 03b20bc^:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

    public ClassLoaderWeavingAdaptor(final ClassLoader loader) {
======= fetch "public void acceptClass(String name, byte[] bytes) {" 03b20bc^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        
        if(wContext==null){
        	weavingContext = new DefaultWeavingContext(loader);
        }else{
        	weavingContext = wContext ;
        }
======= fetch "private void registerDefinitions(final BcelWeaver weaver, final ClassLoader load" 03b20bc^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

            Enumeration xmls = loader.getResources(AOP_XML);
======= fetch "private void registerDefinitions(final BcelWeaver weaver, final ClassLoader load" 03b20bc^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

            
            String resourcePath = System.getProperty("org.aspectj.weaver.loadtime.configuration",AOP_XML);
    		StringTokenizer st = new StringTokenizer(resourcePath,";");
    		while(st.hasMoreTokens()){
    			Enumeration xmls = weavingContext.getResources(st.nextToken());
======= fetch "private void registerDefinitions(final BcelWeaver weaver, final ClassLoader load" 03b20bc^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

            while (xmls.hasMoreElements()) {
                URL xml = (URL) xmls.nextElement();
                MessageUtil.info(messageHandler, "using " + xml.getFile());
                definitions.add(DocumentParser.parse(xml));
            }
======= fetch "private void registerAspects(final BcelWeaver weaver, final ClassLoader loader," 03b20bc^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

                	
                	//generate key for SC
                	String aspectCode = readAspect(aspectClassName, loader);
                    if(namespace==null){
                    	namespace=new StringBuffer(aspectCode);
                    }else{
                    	namespace = namespace.append(";"+aspectCode);
                    }
======= fetch "public boolean shouldDump(String className) {" 03b20bc^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

    
    /*
     *  shared classes methods
     */
    
    /**
    /**
     * Check to see if any classes are stored in the generated classes cache.
     * Then flush the cache if it is not empty
     * @return true if a class has been generated and is stored in the cache
     */
    public boolean generatedClassesExist(){
    	if(generatedClasses.size()>0) {
    		return true;
    	}
    	return false;
    }
    
    /**
     * Flush the generated classes cache
     */
    public void flushGeneratedClasses(){
    	generatedClasses = new HashMap();
    }
    
    /**
     * Read in an aspect from the disk and return its bytecode as a String
     * @param name	the name of the aspect to read in
     * @return the bytecode representation of the aspect
     */
    private String readAspect(String name, ClassLoader loader){
    	try {
    		String result = "";
        	InputStream is = loader.getResourceAsStream(name.replace('.','/')+".class");
    }
    
 * Copyright (c) 2005 Contributors.
 * All rights reserved.
 * This program and the accompanying materials are made available
 * under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution and is available at
 * http://eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   David Knibb         initial implementation
 *******************************************************************************/
 * Use in non-OSGi environment
 * 
 * @author David Knibb
 */
 * Copyright (c) 2005 Contributors.
 * All rights reserved.
 * This program and the accompanying materials are made available
 * under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution and is available at
 * http://eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   David Knibb         initial implementation
 *******************************************************************************/
 * This class adds support to AspectJ for an OSGi environment
 * 
 * @author David Knibb
 */

======= fetch "private void buildPerClause(ClassScope scope) {" 8a0f59a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= fetch "private ReferenceBinding lookupBinding(String sname) {" 8a0f59a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public void testMessageOnMissingTypeInDecP() {" 8a0f59a^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

       <message kind="error" line="7" text="The method m(List&lt;Integer&gt;) in the type Base&lt;N&gt; is not applicable for the arguments (List&lt;String&gt;)"/>
       <message kind="error" line="23" text="The method m0(Integer) in the type GenericAspect&lt;A,B&gt;.SimpleI&lt;L&gt; is not applicable for the arguments (String)"/>
       <message kind="error" line="24" text="The method m1(List&lt;Integer&gt;) in the type GenericAspect&lt;A,B&gt;.SimpleI&lt;L&gt; is not applicable for the arguments (List&lt;String&gt;)"/>
       <message kind="error" line="26" text="The method add(Bottom) in the type List&lt;E&gt; is not applicable for the arguments (Top)"/>
======= fetch "public static ResolvedMember perObjectHasAspectMethod(UnresolvedType declaringTy" 8a0f59a^:"weaver/src/org/aspectj/weaver/AjcMemberMaker.java"

======= fetch "public static ResolvedMember perTypeWithinAspectOfMethod(UnresolvedType declarin" 8a0f59a^:"weaver/src/org/aspectj/weaver/AjcMemberMaker.java"

======= fetch "private void generatePerTWAspectOfMethod(LazyClassGen classGen) {" 8a0f59a^:"weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.java"

        LazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perTypeWithinAspectOfMethod(aspectType));
======= fetch "private void generatePerTWHasAspectMethod(LazyClassGen classGen) {" 8a0f59a^:"weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.java"

        LazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perTypeWithinHasAspectMethod(aspectType));

======= fetch "public void testAtAnnotationBindingWithAround() {" ca9c1f7^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

    public void testUnableToBuildShadows_pr109728() { runTest("Unable to build shadows");}

 * @version $Id: InstructionComparator.java,v 1.2 2004/11/19 16:45:19 aclement Exp $
  public static final InstructionComparator DEFAULT =
    new InstructionComparator() {
======= fetch "public boolean equals(Instruction i1, Instruction i2) {" 0e1bb19^:"bcel-builder/src/org/aspectj/apache/bcel/generic/InstructionComparator.java"

======= fetch "public boolean equals(Instruction i1, Instruction i2) {" 0e1bb19^:"bcel-builder/src/org/aspectj/apache/bcel/generic/InstructionComparator.java"

      };

======= fetch "private Pointcut asPointcut(Method method) {" a39f595^:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/AjTypeImpl.java"

======= fetch "protected PointcutImpl(String name, String pc, Method method, AjType declaringTy" a39f595^:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/PointcutImpl.java"

======= fetch "public AjType getDeclaringType() {" a39f595^:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/PointcutImpl.java"

======= fetch "public AjType getDeclaringType() {" a39f595^:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/PointcutImpl.java"

 * @version $Id: JavaClass.java,v 1.6 2005/07/08 15:17:23 aclement Exp $
======= fetch "public Method getMethod(java.lang.reflect.Method m) {" a39f595^:"bcel-builder/src/org/aspectj/apache/bcel/classfile/JavaClass.java"

 * @version $Id: Type.java,v 1.5 2005/06/01 14:57:23 aclement Exp $
======= fetch "public static String getSignature(java.lang.reflect.Method meth) {" a39f595^:"bcel-builder/src/org/aspectj/apache/bcel/generic/Type.java"

  public static String getSignature(java.lang.reflect.Constructor cons) {
  
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 *
 */
  private Repository bcelRepository;
  private JavaClass jc;
  public void testGetMethod() throws Exception {
  }
  
  public void testGetConstructor() throws Exception {
  }
  
  public void testGetField() throws Exception {
  }
  
  protected void setUp() throws Exception {
  }
  
  protected void tearDown() throws Exception {
  }
  
  private static class GetMe {
  }
======= fetch "public static Annotation createAroundAnnotation(String pointcutExpression, int p" a39f595^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AtAspectJAnnotationFactory.java"

======= fetch "public static Annotation createPointcutAnnotation(String pointcutExpression, int" a39f595^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AtAspectJAnnotationFactory.java"

======= fetch "public void addAtAspectJAnnotations() {" a39f595^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"

======= fetch "public void addAtAspectJAnnotations() {" a39f595^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"

    private PseudoTokens tokens; //XXX redundant
======= fetch "public Pointcut getPointcut() {" a39f595^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDesignator.java"

    public String getPointcutDeclarationText() {
    	StringBuffer sb = new StringBuffer();
    	PseudoToken[] toks = tokens.tokens;
    	for (int i = 0; i < (toks.length -1); i++) {
    	return sb.toString();
    }
    
======= fetch "public void testRawAndGenericTypeConversionITDCons() {" a39f595^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testUnableToBuildShadows_pr109728() { runTest("Unable to build shadows");}
======= fetch "public void testDeows() {" a39f595^:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjAnnotationGenTests.java"

   <ajc-test dir="java5/ataspectj/annotationGen" title="runtime pointcut resolution referencing compiled pointcuts">
        <compile files="PCLib.aj,RuntimePointcuts.java" options="-1.5">
        </compile>
        <run class="RuntimePointcuts"/>
    </ajc-test>          
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * Find the given annotation (if present) on the given object
 *
 */
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 * Provides Java 5 behaviour in reflection based delegates (overriding
 * 1.4 behaviour from superclass where appropriate)
 */
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 *
 */
======= fetch "public UnresolvedType getReturnType() {" a39f595^:"weaver/src/org/aspectj/weaver/Shadow.java"

    public static final Set ALL_SHADOW_KINDS = new HashSet();   
======= fetch "public UnresolvedType getReturnType() {" a39f595^:"weaver/src/org/aspectj/weaver/Shadow.java"

    	HashSet aSet = new HashSet();
======= fetch "public UnresolvedType getReturnType() {" a39f595^:"weaver/src/org/aspectj/weaver/Shadow.java"

======= fetch "public UnresolvedType getReturnType() {" a39f595^:"weaver/src/org/aspectj/weaver/Shadow.java"

    	ALL_SHADOW_KINDS = Collections.unmodifiableSet(aSet);
======= fetch "public static UnresolvedType forGenericTypeSignature(String sig,String declaredG" a39f595^:"weaver/src/org/aspectj/weaver/UnresolvedType.java"

    public static UnresolvedType forGenericTypeVariables(String sig, TypeVariable[] tVars) {
      	UnresolvedType ret = UnresolvedType.forSignature(sig);
    	ret.typeKind=TypeKind.GENERIC; 	
    	ret.typeVariables = tVars;
    	ret.signatureErasure = sig;
    	ret.signature = ret.signatureErasure;
    	return ret;
    }
    
======= fetch "private final ResolvedType resolveToReferenceType(UnresolvedType ty) {" a39f595^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public ResolvedType resolveGenericTypeFor(UnresolvedType anUnresolvedType, boole" a39f595^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public ResolvedType resolveGenericTypeFor(UnresolvedType anUnresolvedType, boole" a39f595^:"weaver/src/org/aspectj/weaver/World.java"

    
    private ReferenceType makeGenericTypeFrom(ReferenceTypeDelegate delegate, ReferenceType rawType) {
    	String genericSig = delegate.getDeclaredGenericSignature();
    	if (genericSig != null) {
    		return new ReferenceType(
    	} else {
    		return new ReferenceType(
    				UnresolvedType.forGenericTypeVariables(rawType.getSignature(), delegate.getTypeVariables()),this);
    	}
    }
======= fetch "public PointcutExpressionImpl(Pointcut pointcut, String expression) {" a39f595^:"weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java"

======= fetch "public boolean couldMatchJoinPointsInType(Class aClass) {" a39f595^:"weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java"

======= fetch "public boolean mayNeedDynamicTest() {" a39f595^:"weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java"

======= fetch "public FuzzyBoolean matchesMethodCall(Method aMethod, Class thisClass," a39f595^:"weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java"

======= fetch "public FuzzyBoolean matchesMethodExecution(Method aMethod, Class thisClass) {" a39f595^:"weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java"

======= fetch "public FuzzyBoolean matchesConstructorCall(Constructor aConstructor," a39f595^:"weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java"

======= fetch "public FuzzyBoolean matchesConstructorExecution(Constructor aConstructor, Class" a39f595^:"weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java"

======= fetch "public FuzzyBoolean matchesAdviceExecution(Method anAdviceMethod," a39f595^:"weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java"

======= fetch "public FuzzyBoolean matchesHandler(Class exceptionType, Class inClass," a39f595^:"weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java"

======= fetch "public FuzzyBoolean matchesInitialization(Constructor aConstructor) {" a39f595^:"weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java"

======= fetch "public FuzzyBoolean matchesPreInitialization(Constructor aConstructor) {" a39f595^:"weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java"

======= fetch "public FuzzyBoolean matchesStaticInitialization(Class aClass) {" a39f595^:"weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java"

======= fetch "public FuzzyBoolean matchesFieldSet(Field aField, Class thisClass," a39f595^:"weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java"

======= fetch "public FuzzyBoolean matchesFieldGet(Field aField, Class thisClass," a39f595^:"weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java"

======= fetch "public String getPointcutExpression() {" a39f595^:"weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java"

======= fetch "public Object visit(ThisOrTargetPointcut node, Object data) {" a39f595^:"weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/AndPointcut.java"

======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/AndPointcut.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/AndPointcut.java"

======= fetch "protected boolean matchesExactly(ResolvedType type, ResolvedType annotatedType)" a39f595^:"weaver/src/org/aspectj/weaver/patterns/AndTypePattern.java"

======= fetch "public TypePattern parameterizeWith(Map typeVariableMap) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/AndTypePattern.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo info) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= fetch "protected void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= fetch "public ArgsAnnotationPointcut(AnnotationPatternList arguments) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo info) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= fetch "protected void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= fetch "protected Test findResidueInternal(Shadow shadow, ExposedState state) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= fetch "private FuzzyBoolean checkSignatureMatch(Class[] pTypes) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

    
======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ConcreteCflowPointcut.java"

    
======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ConcreteCflowPointcut.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ConcreteCflowPointcut.java"

======= fetch "public FuzzyBoolean matchesInstanceof(ResolvedType matchType) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= fetch "public FuzzyBoolean willMatchDynamically(Class staticType) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= fetch "public TypePattern resolveBindings(IScope scope, Bindings bindings," a39f595^:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"

======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"

 	public FuzzyBoolean match(JoinPoint jp, JoinPoint.StaticPart jpsp) {
 	/* (non-Javadoc)
======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"

======= fetch "public FuzzyBoolean matchesInstanceof(ResolvedType type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/HasMemberTypePattern.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

    
======= fetch "public Pointcut getResidueSource() {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo info) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/NotPointcut.java"

======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/NotPointcut.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/NotPointcut.java"

======= fetch "protected boolean matchesExactly(ResolvedType type, ResolvedType annotatedType)" a39f595^:"weaver/src/org/aspectj/weaver/patterns/NotTypePattern.java"

======= fetch "public TypePattern parameterizeWith(Map typeVariableMap) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/NotTypePattern.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/OrPointcut.java"

======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/OrPointcut.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/OrPointcut.java"

======= fetch "public boolean matchesStatically(ResolvedType type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/OrTypePattern.java"

======= fetch "public TypePattern parameterizeWith(Map typeVariableMap) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/OrTypePattern.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/PerCflow.java"

======= fetch "public static Kind read(VersionedDataInputStream s) throws IOException {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/PerClause.java"

    	throw new UnsupportedOperationException("Can't resolve per-clauses at runtime");
    }
======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/PerObject.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/PerSingleton.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo info) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java"

======= fetch "public State(String name, int key) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= fetch "public Pointcut() {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= fetch "public final FuzzyBoolean match(Shadow shadow) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= fetch "public FuzzyBoolean matchesStatically(" a39f595^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= fetch "public final Pointcut resolve(IScope scope) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

    /**
     * Returns this pointcut with type patterns etc resolved based on available RTTI 
     */
    public Pointcut resolve() {
    	assertState(SYMBOLIC);
    	this.resolveBindingsFromRTTI();
    	this.state = RESOLVED;
    	return this;
    }
======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

 * Copyright (c) 2004 IBM Corporation 
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 * ******************************************************************/
 * Interface used by PointcutExpressionImpl to determine matches.
 */
======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= fetch "public SignaturePattern resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

    public SignaturePattern resolveBindingsFromRTTI() {
    	return this;    	
    }
    
    
======= fetch "public boolean declaringTypeMatchAllowingForCovariance(Member member, Unresolved" a39f595^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "public ThisOrTargetAnnotationPointcut(boolean isThis, ExactAnnotationTypePattern" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo info) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java"

======= fetch "protected void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= fetch "public ThrowsPattern resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java"

    
    public ThrowsPattern resolveBindingsFromRTTI() {
    	required = required.resolveBindingsFromRTTI(false,false);
    	forbidden = forbidden.resolveBindingsFromRTTI(false,false);
    	return this;
    }
    
======= fetch "public boolean matches(UnresolvedType[] tys, World world) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java"

======= fetch "private boolean matchesAny(" a39f595^:"weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java"

======= fetch "public final FuzzyBoolean matches(ResolvedType type, MatchKind kind) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= fetch "public final FuzzyBoolean matches(Class toMatch, MatchKind kind) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= fetch "public TypePattern resolveBindings(IScope scope, Bindings bindings," a39f595^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

    public TypePattern resolveBindingsFromRTTI(boolean allowBindng, boolean requireExactType) {
    	return this;
    }
    
======= fetch "public FuzzyBoolean matchesInstanceof(ResolvedType type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= fetch "public FuzzyBoolean matchesInstanceof(ResolvedType type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= fetch "public FuzzyBoolean matchesInstanceof(ResolvedType type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= fetch "public FuzzyBoolean matchesInstanceof(ResolvedType type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= fetch "public String toString() {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/TypePatternList.java"

    
    
    /**
     * Used by reflection-based matching for args pcds.
     * Returns YES if types will always be matched by the pattern,
     *         NO if types do not match the pattern,
     *         MAYBE if types may match the pattern dependent on a runtime test
     */
    public FuzzyBoolean matchesArgsPatternSubset(Class[] types) {
    	int argsLength = types.length;
    	int patternLength = typePatterns.length;
    	int argsIndex = 0;
    	
    	if ((argsLength < patternLength) && (ellipsisCount == 0)) return FuzzyBoolean.NO;
    	if (argsLength < (patternLength -1)) return FuzzyBoolean.NO;
    	
    	int ellipsisMatchCount = argsLength - (patternLength - ellipsisCount);
    	
    	FuzzyBoolean ret = FuzzyBoolean.YES;
    	
    	for (int i = 0; i < typePatterns.length; i++) {
    	
    	return ret;
    }
    
======= fetch "public FuzzyBoolean matches(ResolvedType[] types, TypePattern.MatchKind kind) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/TypePatternList.java"

    
    // TODO Add TypePatternList.matches(Object[] objs)
    public FuzzyBoolean matches(Object[] objs, TypePattern.MatchKind kind) {
    	int nameLength = objs.length;
            FuzzyBoolean b =  outOfStar(typePatterns, objs, 0, 0, patternLength - ellipsisCount, nameLength, ellipsisCount, kind);
            return b;
    	}
    }
 
    // XXX run-time signature matching, too much duplicated code
    public FuzzyBoolean matches(Class[] types, TypePattern.MatchKind kind) {
    	int nameLength = types.length;
            FuzzyBoolean b =  outOfStar(typePatterns, types, 0, 0, patternLength - ellipsisCount, nameLength, ellipsisCount, kind);
            return b;
    	}
    }
    
======= fetch "private static FuzzyBoolean inStar(final TypePattern[] pattern, final ResolvedTy" a39f595^:"weaver/src/org/aspectj/weaver/patterns/TypePatternList.java"

    
    
    private static FuzzyBoolean outOfStar(final TypePattern[] pattern,
  
    private static FuzzyBoolean inStar(final TypePattern[] pattern,
    private static FuzzyBoolean outOfStar(final TypePattern[] pattern,
  
    private static FuzzyBoolean inStar(final TypePattern[] pattern,
  
======= fetch "public TypePatternList resolveBindings(IScope scope, Bindings bindings, boolean" a39f595^:"weaver/src/org/aspectj/weaver/patterns/TypePatternList.java"

======= fetch "private boolean verifyTypeParameters(ResolvedType baseType,IScope scope, boolean" a39f595^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "public int hashCode() {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

    
    public FuzzyBoolean matchesInstanceof(Class type) {
    	return FuzzyBoolean.NO;
    }
    
    public boolean matchesExactly(Class type) {
    	return matchesExactlyByName(type.getName());
    }
    
======= fetch "public WithinAnnotationPointcut(AnnotationTypePattern type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java"

======= fetch "public WithinAnnotationPointcut(AnnotationTypePattern type, ShadowMunger munger)" a39f595^:"weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo info) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java"

======= fetch "protected void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java"

======= fetch "public WithinCodeAnnotationPointcut(ExactAnnotationTypePattern type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java"

======= fetch "public WithinCodeAnnotationPointcut(ExactAnnotationTypePattern type, ShadowMunge" a39f595^:"weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo info) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java"

======= fetch "protected void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo info) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

    
======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo type) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

    
======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

======= fetch "public void resolveBindings(IScope scope, Bindings bindings) {" a39f595^:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 * Used in 1.4 code to access annotations safely
 */
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 * Implementation of JoinPointMatch for reflection based worlds.
 */
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 * A delegate for a resolved type that uses runtime type information (java.lang.reflect)
 * to answer questions. This class uses only Java 1.4 features to answer questions.
 * In a Java 1.5 environment use the Java5ReflectionBasedReferenceTypeDelegate subtype.
 */
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 * Creates the appropriate ReflectionBasedReferenceTypeDelegate according to
 * the VM level we are running at. Uses reflection to avoid 1.5 dependencies in
 * 1.4 and 1.3 code base.
 */
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * Subtype of ResolvedMemberImpl used in reflection world.
 * Knows how to get annotations from a java.lang.reflect.Member
 *
 */
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 *
 */
    	if (getKind().isEnclosingKind()) {
    		return getSignature();
    	} else if (getKind() == Shadow.PreInitialization) {
          // PreInit doesn't enclose code but its signature
          // is correctly the signature of the ctor.
    	  return getSignature();
    	} else if (enclosingShadow == null) {
    		return this.enclosingMember;
    	} else {
    		return enclosingShadow.getSignature();
    	}
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * A variable at a reflection shadow, used by the residual tests.
 */
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * A ReflectionWorld is used solely for purposes of type resolution based on 
 * the runtime classpath (java.lang.reflect). It does not support weaving operations
 * (creation of mungers etc..).
 *
 */
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 * Implementation of ShadowMatch for reflection based worlds.
 */
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 * The result of asking a ShadowMatch to match at a given join point.
 */
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 * Represents a parameter in a pointcut expression.
 * For example pointcut pc(String s) : .....; has a PointcutParameter of
 * name "s" and type String.
 */
======= fetch "public static Set getAllSupportedPointcutPrimitives() {" a39f595^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

        primitives.add(PointcutPrimitive.AT_ANNOTATION);
        primitives.add(PointcutPrimitive.AT_THIS);
        primitives.add(PointcutPrimitive.AT_TARGET);
        primitives.add(PointcutPrimitive.AT_ARGS);
        primitives.add(PointcutPrimitive.AT_WITHIN);
        primitives.add(PointcutPrimitive.AT_WITHINCODE);
        primitives.add(PointcutPrimitive.REFERENCE);
        
======= fetch "public PointcutParser(Set/*<PointcutPrimitives>*/ supportedPointcutKinds) {" a39f595^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    public PointcutParameter createPointcutParameter(String name, Class type) {
    	return new PointcutParameterImpl(name,type);
    }
======= fetch "public PointcutParser(Set/*<PointcutPrimitives>*/ supportedPointcutKinds) {" a39f595^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

     * A global scope is assumed for resolving any type references, and the pointcut
     * must contain no formals (variables to be bound).
======= fetch "public PointcutExpression parsePointcutExpression(String expression)" a39f595^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

        PointcutExpressionImpl pcExpr = null;
        try {
            Pointcut pc = new PatternParser(expression).parsePointcut();
            validateAgainstSupportedPrimitives(pc,expression);
            pc.resolve();
            pcExpr = new PointcutExpressionImpl(pc,expression);
        } catch (ParserException pEx) {
            throw new IllegalArgumentException(buildUserMessageFromParserException(expression,pEx));
        }
        return pcExpr;
======= fetch "Set getSupportedPrimitives() {" a39f595^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    /* for testing */
    IMessageHandler setCustomMessageHandler(IMessageHandler aHandler) {
    	IMessageHandler current = world.getMessageHandler();
    	world.setMessageHandler(aHandler);
    	return current;
    }
    
    private IScope buildResolutionScope(Class inScope, PointcutParameter[] formalParameters) {
    	if (formalParameters == null) formalParameters = new PointcutParameter[0];
    	FormalBinding[] formalBindings = new FormalBinding[formalParameters.length];
    	for (int i = 0; i < formalBindings.length; i++) {
    	if (inScope == null) {
    		return new SimpleScope(world,formalBindings);
    	} else {
    		ResolvedType inType = world.resolve(inScope.getName());
    		ISourceContext sourceContext = new ISourceContext() {
    			public ISourceLocation makeSourceLocation(IHasPosition position) {
    				return new SourceLocation(new File(""),0);
    			}
    			public ISourceLocation makeSourceLocation(int line, int offset) {
    				return new SourceLocation(new File(""),line);
    			}
    			public int getOffset() {
    				return 0;
    			}
    		};
    		return new AtAjAttributes.BindingScope(inType,sourceContext,formalBindings);
    	}
    }
    
======= fetch "private void validateAgainstSupportedPrimitives(Pointcut pc, String expression)" a39f595^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

        	case Pointcut.REFERENCE:
        	    throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.REFERENCE);
======= fetch "private void validateAgainstSupportedPrimitives(Pointcut pc, String expression)" a39f595^:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

        	case Pointcut.ATTHIS_OR_TARGET:
           	    isThis = ((ThisOrTargetAnnotationPointcut)pc).isThis();
        		if (isThis && !supportedPrimitives.contains(PointcutPrimitive.AT_THIS)) {
        		    throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.AT_THIS);
        		} else if (!supportedPrimitives.contains(PointcutPrimitive.AT_TARGET)) {
        		    throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.AT_TARGET);
        		}
        	    break;       	
        	case Pointcut.ATARGS:
        	    if (!supportedPrimitives.contains(PointcutPrimitive.AT_ARGS))
        	        throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.AT_ARGS);
        	    break;
        	case Pointcut.ANNOTATION:
        		if (!supportedPrimitives.contains(PointcutPrimitive.AT_ANNOTATION))
        	        throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.AT_ANNOTATION);
        	    break;        			
        	case Pointcut.ATWITHIN:
        	    if (!supportedPrimitives.contains(PointcutPrimitive.AT_WITHIN))
        	        throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.AT_WITHIN);
        	    break;
        	case Pointcut.ATWITHINCODE:
        	    if (!supportedPrimitives.contains(PointcutPrimitive.AT_WITHINCODE))
        	        throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.AT_WITHINCODE);
        	    break;
        	case Pointcut.REFERENCE:
        	    if (!supportedPrimitives.contains(PointcutPrimitive.REFERENCE))
        	        throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.REFERENCE);
        	    break;        		
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * The result of asking a PointcutExpression to match at a shadow (method execution,
 * handler, constructor call, and so on).
 *
 */
======= fetch "public static Test suite() {" a39f595^:"weaver/testsrc/BcweaverModuleTests15.java"

======= fetch "public void testMatch() throws IOException {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/AndOrNotTestCase.java"

======= fetch "private void checkEquals(String pattern, Pointcut p) throws IOException {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/AndOrNotTestCase.java"

======= fetch "public void testMatchJP() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java"

======= fetch "public void testMatchJP() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java"

======= fetch "public void testMatchJP() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java"

======= fetch "public void testMatchJP() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java"

======= fetch "public void testMatchJP() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java"

======= fetch "public void testMatchJP() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java"

======= fetch "public void testMatchJPWithPrimitiveTypes() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java"

======= fetch "public void testMatchJPWithPrimitiveTypes() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java"

======= fetch "public void testMatchJPWithPrimitiveTypes() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java"

======= fetch "public void testMatchJPWithPrimitiveTypes() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java"

======= fetch "public void testMatchJPWithPrimitiveTypes() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java"

======= fetch "public void testMatchJPWithPrimitiveTypes() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java"

======= fetch "private void checkMatches(Pointcut p, JoinPoint jp, JoinPoint.StaticPart jpsp, F" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java"

======= fetch "protected void setUp() throws Exception {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java"

 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
 * @author colyer
 *
 */
======= fetch "public static Test suite() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/PatternsTests.java"

        suite.addTestSuite(PointcutTestCase.class);
======= fetch "public static Test suite() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/PatternsTests.java"

        suite.addTestSuite(HandlerTestCase.class);
        suite.addTestSuite(KindedTestCase.class);
        suite.addTestSuite(WithinCodeTestCase.class);
 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
 *     PARC     initial implementation 
======= fetch "public void testMatch() throws IOException {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

======= fetch "public void testMatchJP() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

======= fetch "public void testMatchJP() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

======= fetch "public void testMatchJP() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

======= fetch "public void testMatchJP() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

======= fetch "private void checkMatches(Pointcut p, JoinPoint jp, JoinPoint.StaticPart jpsp, F" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

======= fetch "private void checkMatches(Pointcut p, JoinPoint jp, JoinPoint.StaticPart jpsp, F" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

======= fetch "private void checkMatches(Pointcut p, JoinPoint jp, JoinPoint.StaticPart jpsp, F" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
======= fetch "public void testMatch() throws IOException {" a39f595^:"weaver/testsrc/org/aspectj/weaver/patterns/WithinTestCase.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
======= fetch "public void testMatchesMethodCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesMethodExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesConstructorCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesConstructorCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesConstructorCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesConstructorCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesConstructorCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesConstructorCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesConstructorCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesConstructorCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesConstructorCall() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesConstructorExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesConstructorExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesConstructorExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesConstructorExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesConstructorExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesConstructorExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesConstructorExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesConstructorExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesConstructorExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesAdviceExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesAdviceExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesAdviceExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesAdviceExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesAdviceExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesAdviceExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesAdviceExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesAdviceExecution() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesHandler() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesHandler() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesHandler() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesHandler() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesHandler() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesHandler() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesHandler() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesPreInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesPreInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesPreInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesPreInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesPreInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesPreInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesPreInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesStaticInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesStaticInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesStaticInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesStaticInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesStaticInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesStaticInitialization() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesFieldSet() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesFieldSet() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesFieldSet() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesFieldSet() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesFieldSet() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesFieldSet() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesFieldSet() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesFieldGet() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesFieldGet() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesFieldGet() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesFieldGet() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesFieldGet() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesFieldGet() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMatchesFieldGet() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testArgsMatching() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testArgsMatching() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testArgsMatching() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testArgsMatching() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testArgsMatching() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testArgsMatching() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testArgsMatching() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testArgsMatching() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testCouldMatchJoinPointsInType() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testCouldMatchJoinPointsInType() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testMayNeedDynamicTest() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "protected void setUp() throws Exception {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void aa(int i) {}" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void bar(String s, int i, Integer i2, Number n) {}" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= fetch "public void testGetAllSupportedPointcutPrimitives() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java"

======= fetch "public void testEmptyConstructor() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java"

======= fetch "public void testParsePointcutExpression() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java"

======= fetch "public void testParseExceptionErrorMessages() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java"

======= fetch "public void testParseReferencePCDs() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java"

======= fetch "public void testParseReferencePCDs() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java"

======= fetch "public void testParseUnsupportedPCDs() {" a39f595^:"weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 * Part of the testdata for the org.aspectj.weaver.reflect tests
 */

 * @version $Id: ClassParser.java,v 1.2 2004/11/19 16:45:18 aclement Exp $
======= fetch "private final void readClassInfo() throws IOException, ClassFormatException" 87e5c2e^:"bcel-builder/src/org/aspectj/apache/bcel/classfile/ClassParser.java"

    if(((access_flags & Constants.ACC_ABSTRACT) != 0) && 
       ((access_flags & Constants.ACC_FINAL)    != 0 ))
      throw new ClassFormatException("Class can't be both final and abstract");
======= fetch "public void testIfEvaluationExplosion_pr94086() {" 87e5c2e^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testFinalAbstractClass_pr109486() { runTest("Internal compiler error (ClassParser.java:242)");}
  
    <ajc-test dir="bugs150" pr="109486" title="Internal compiler error (ClassParser.java:242)">
        <compile files="PR109486.java" >
          <message kind="error" line="1" text="The class PR109486 can be either abstract or final, not both"/>
        </compile>
    </ajc-test>  
    

  before(): !@annotation(AroundAdvice) && execution(* C.*(..)) { }
  public static void m1() {}
  @AroundAdvice public static void m2() {}
  public void m3() {}
  @AroundAdvice public void m4() {}
======= fetch "public void testSuperCallInITD() {" 2ae4f53^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  
======= fetch "public void testSuperCallInITDPart2() {" 2ae4f53^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  
  public void testAtAnnotationBadTest_pr103740() {
  }
  
    <ajc-test dir="bugs150/pr103740" pr="103740" title="Compiler failure on at_annotation">
     <compile files="AroundAdvice.aj" options="-1.5,-showWeaveInfo">
       <message kind="weave" text="Join point 'method-execution(void C.m1())' in Type 'C' (AroundAdvice.aj:12) advised by before advice from 'ErrorHandling' (AroundAdvice.aj:8)"/>
    </ajc-test>
======= fetch "protected Test findResidueInternal(Shadow shadow, ExposedState state) {" 2ae4f53^:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= fetch "protected Test findResidueInternal(Shadow shadow, ExposedState state) {" 2ae4f53^:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"


======= fetch "public UnresolvedType fromBinding(TypeBinding binding) {" 2942ca0^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

  class Inner { // works if static
    private Integer field;
    void bug() {
      field = new Integer(0);
    }
  }
  public static void main(String[] args) {
    new pr106874().new Inner().bug();
  }
  before(Object t) :
    // target(Object) && // works
    // this(t) && // works
    target(t) && // fails
    // set(* Bug.Inner.field) // works
    // set(Integer Bug.Inner.*) // works
    // get(* Bug.Inner.*) // works
    set(* pr106874.Inner.*) // fails
  {}
    public <T> T[] method(T[] array) {
        return null;
    }
======= fetch "public void testNoVerifyErrorWithSetOnInnerType() {" 2942ca0^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

    

       class Node {
               int value;
               Node(int v)
               {
                       value = v;
               }
       }
       public VerifyErrorOnSet()
       {
               new Node(1);
       }
       public static void main(String[] args) {
    	   VerifyErrorOnSet l = new VerifyErrorOnSet();
       }
 
       pointcut setField(Object t) : target(t) && set(* VerifyErrorOnSet.Node+.*);
       
       before(Object t) : setField(t) {
               System.out.println("WRITE");
               // Do something with t...
       }
       
======= fetch "public void testNoUnusedParameterWarningsForSyntheticAdviceArgs() {" a9ca915^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  
  public void testNoVerifyErrorWithSetOnInnerType() {
  }
    
    <ajc-test dir="bugs150" pr="109124" title="no verify error with set on inner type">
        <compile files="VerifyErrorOnSet.aj" options="-1.5" >
        </compile>
        <run class="test.VerifyErrorOnSet"/>
    </ajc-test>  
        
    
======= fetch "private void unpackAttributes(World world) {" a9ca915^:"weaver/src/org/aspectj/weaver/bcel/BcelField.java"


======= fetch "private static boolean configureBuildOptions( AjBuildConfig config, BuildOptions" 5187437^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"


======= fetch "public void completeTypeBindings() {" 2d21db0^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "public void anonymousTypeBindingCreated(LocalTypeBinding aBinding) {" 2d21db0^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "public Shadow makeShadow(ReferenceContext context) {" 2d21db0^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public void addSourceTypeBinding(SourceTypeBinding binding) {" 2d21db0^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public void addSourceTypeBinding(SourceTypeBinding binding) {" 2d21db0^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public EclipseSourceType(ReferenceType resolvedTypeX, EclipseFactory factory," 2d21db0^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

======= fetch "public EclipseSourceType(ReferenceType resolvedTypeX, EclipseFactory factory," 2d21db0^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

======= fetch "protected void fillDeclaredMembers() {" 2d21db0^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

            <message kind="error" line="8" text="can't override final void A$TestInterface.m()"></message>
======= fetch "public ResolvedMemberImpl parameterizedWith(UnresolvedType[] typeParameters,Reso" 2d21db0^:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

======= fetch "public ResolvedMemberImpl parameterizedWith(UnresolvedType[] typeParameters,Reso" 2d21db0^:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

======= fetch "public boolean checkLegalOverride(ResolvedMember parent, ResolvedMember child) {" 2d21db0^:"weaver/src/org/aspectj/weaver/ResolvedType.java"


======= fetch "public void unusedPrivateMethod(AbstractMethodDeclaration methodDecl) {" 08d6a5d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

    
    public void unusedArgument(LocalDeclaration localDecl) {
    	// don't warn if this is an aj synthetic arg
    	String argType = new String(localDecl.type.resolvedType.signature());
    	if (argType.startsWith("Lorg/aspectj/runtime/internal")) return;
    	super.unusedArgument(localDecl);
    }
    private static PlayList instance;
    
    private List<Song> list;
    
    private PlayList() {
        list = new ArrayList<Song>();         
    }
    public static PlayList instance() {
        if(instance==null ) {
            instance = new PlayList();
        }
        return instance;
    }
    public void enqueue(Song song) {
        list.add(song);
        if(Player.instance().isIdle()) {
            new Thread() {
                public void run() {
                    System.out.println("Playing playlist...");
                    for (Song s : list) {
                        Player.instance().play(s.getName());
                    }
                }  
            }.start();            
        }
    }
    private String name; 
    public Song(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
    private static Player instance;
    
    private Player() {}
    public static Player instance() {
        if(instance==null ) {
            instance = new Player();
        }
        return instance;
    }
    public void play(String name) {
        System.out.println("Playing Song "+name+"...");
    }
    public boolean isIdle() {
        return true;
    }
    
    public static void main(String[] args) {
        Song song = new Song("Merry XMas");
        Jukebox jukebox = new Jukebox();
        
        jukebox.play(song);
    }
    
    
    void around(Song song) :
        call(public void Jukebox.play(Song))
        && args(song) {
        PlayList.instance().enqueue(song);
    }
    void around() : call(public void Jukebox.play(Song)) {
        if(Credits.instance().enoughCredits()) {
            System.out.println("Withdrawing credit.");
            Credits.instance().withDraw();
            proceed();
        } else {
            throw new InsufficientCreditsException();
        }
    }
    
    private static final int INITIAL_CREDITS = 10;
    private static Credits instance;
    
    private int credits;
    
    private Credits() {
        credits = INITIAL_CREDITS;        
    }
    
    public static Credits instance() {
        if(instance==null ) {
            instance = new Credits();
        }
        return instance;
    }
    public boolean enoughCredits() {
        return credits > 0;
    }
    
    public void withDraw() {
        credits--;
    }
    public InsufficientCreditsException() {
        super();
    }
    public InsufficientCreditsException(String message, Throwable cause) {
        super(message, cause);
    }
    public InsufficientCreditsException(String message) {
        super(message);
    }
    /**
     * @param cause
     */
    public InsufficientCreditsException(Throwable cause) {
        super(cause);
    }
======= fetch "public void testSuperCallInITD() {" 08d6a5d^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  
  public void testNoUnusedParameterWarningsForSyntheticAdviceArgs() {
  }
    <ajc-test dir="bugs150" pr="109042" title="no unused parameter warnings for synthetic advice args">
        <compile files="pr109042.aj" options="-warn:+unusedArgument -warn:+unusedPrivate -warn:+unusedImport -1.5">
        </compile>
    </ajc-test>  

======= fetch "public void resolveStatements() {" 2505485^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

        // XXX AMC we need to do this, but I'm not 100% comfortable as I don't
        // know why the return type is wrong in this case. Also, we don't seem to need
        // to do it for args...
        if (munger.getSignature().getReturnType().isRawType()) {
        	if (!binding.returnType.isRawType()) {
        		binding.returnType = world.makeTypeBinding(munger.getSignature().getReturnType()); 
        	}
        }
======= fetch "public void resolveStatements() {" 2505485^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

 public void update();
 
  public Collection aCollection;	
 public void addObserver(Observer observer);
 public void removeObserver(Observer observer);
 public Collection getObservers();
     
     public void print() {  }
   declare parents : SalesOrder extends Order;
   public void SalesOrder.print()
   {
      super.print();  //  Line 12
   }
   protected pointcut print(Order order) : target(order) && call(public void print());
======= fetch "public void testAdviceOnCflow() {" 2505485^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testNoTypeMismatchOnSameGenericTypes() {
  }
  
  public void testSuperCallInITD() {
  }
    <ajc-test dir="bugs150/pr108902" pr="108902" title="no type mismatch on generic types in itds">
        <compile files="Subject.java,Observer.java,ObserverProtocol.aj" >
        </compile>
    </ajc-test>   
    <ajc-test dir="bugs150" pr="108903" title="super call in ITD">
        <compile files="pr108903.aj" >
            <message kind="error" line="14" text="The method print() is undefined for the type Object"/>
        </compile>
    </ajc-test>  

    after(Object controller) returning (Object foo): 
      cflow(adviceexecution() && args(controller, ..) && this(BadAdvice)) && 
      call(Bar+.new(..)) 
    {
    }    
    
    Object around(Object controller) : call(* whoKnows()) && target(controller) 
    {
        return new Bar();
    }
    
    public static void main(String args[]) {
        (new Bar()).whoKnows();
    }
    void whoKnows() {}
======= fetch "public void testPrivatePointcutOverriding() {" 71771ab^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

    
======= fetch "protected Test findResidueInternal(Shadow shadow, ExposedState state) {" 71771ab^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= fetch "protected Test findResidueInternal(Shadow shadow, ExposedState state) {" 71771ab^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"


======= fetch "public void testNoWarningOnUnusedPointcut() {" df46c6f^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testITDOnInterfaceWithExistingMember() {
  }
  
    
    <ajc-test dir="bugs150/pr99125" pr="99125" title="itd interface method already existing on interface">
        <compile files="p/pr99125.aj,p/I.java,p/J.java" options="-1.5">
        </compile>
        <compile files="Aspects.aj" options="-inpath p"/>
        <run class="p.pr99125"/>
        <compile files="p2/pr99125.aj,p/I.java,p/J.java"/> <!-- actually in package p, introduces incompatible change -->
        <compile files="Aspects.aj" options="-inpath p">
            <message kind="error" line="7" text="inter-type declaration from X conflicts with existing member"/>
        </compile>
    </ajc-test>
    
======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" df46c6f^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "public LazyMethodGen getLazyMethodGen(Member m) {" df46c6f^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= fetch "public LazyMethodGen getLazyMethodGen(String name, String signature) {" df46c6f^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= fetch "public LazyMethodGen getLazyMethodGen(String name, String signature) {" df46c6f^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"


======= fetch "public void unusedPrivateType(TypeDeclaration typeDecl) {" 2c88c59^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

    public void unusedPrivateMethod(AbstractMethodDeclaration methodDecl) {
    	// don't output unused warnings for pointcuts...
    	if (!(methodDecl instanceof PointcutDeclaration))
    			super.unusedPrivateMethod(methodDecl);
    }
======= fetch "public void testSynchronizedITDInterfaceMethods() {" 2c88c59^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

         

======= fetch "public void testAbstractSynchronizedITDMethods() {" b17ff4e^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testSynchronizedITDInterfaceMethods() {
  }
  
    <ajc-test dir="bugs150" pr="102212" title="synchronized itd interface methods">
        <compile files="SynchronizedInterfaceMethods.aj" options="-1.5">
        </compile>
        <run class="SynchronizedInterfaceMethods"/>
    </ajc-test>
======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" b17ff4e^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" b17ff4e^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" b17ff4e^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "public int getAccessFlags() {" b17ff4e^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    
    public void setAccessFlags(int newFlags) {
    	this.accessFlags = newFlags;
    }

  private interface Test {
    Object getId();
    int hashCode();
  }
 
  public int Test.hashCode() {
    return getId().hashCode();
  }
 
  declare parents : ReturnTypeTester implements Test;
  static Set<ReturnTypeTester> set = new HashSet<ReturnTypeTester>();
  static {
    ReturnTypeTester tester = new ReturnTypeTester();
    set.add(tester);
  }
 
  public String getId() {
    return "id";
  }
  private interface Test {
    Object getId();
    int hashCode();
  }
 
  public int Test.hashCode() {
    return getId().hashCode();
  }
 
  declare parents : ReturnTypeTester implements Test;
  static Set<ReturnTypeTester> set = new HashSet<ReturnTypeTester>();
  static {
    ReturnTypeTester tester = new ReturnTypeTester();
    set.add(tester);
  }
 
  public String getId() {
    return "id";
  }
======= fetch "public void testParsingOfGenericTypeSignature() {" 047173e^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

     
======= fetch "public void test019(){" 047173e^:"tests/src/org/aspectj/systemtest/xlint/XLintTests.java"

  
  public void testBug99136(){
  }
    <ajc-test dir="harness" 
        title="Two Xlint warnings wth cflow?">
        <compile files="XLintcflow.java" options="-1.5">
        	<message kind="warning" line="4"  text="advice defined in A has not been applied [Xlint:adviceDidNotMatch]"/>
        </compile>
    </ajc-test>
======= fetch "public Collection weave(IClassFileProvider input) throws IOException {" 047173e^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

        requestor.weaveCompleted();
    	return wovenClassNames;
    }
    /**
     * In 1.5 mode and with XLint:adviceDidNotMatch enabled, put out messages for any
     * mungers that did not match anything.
     */
======= fetch "public Collection weave(IClassFileProvider input) throws IOException {" 047173e^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

        	Set alreadyWarnedLocations = new HashSet();
        	
======= fetch "public Collection weave(IClassFileProvider input) throws IOException {" 047173e^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public Collection weave(IClassFileProvider input) throws IOException {" 047173e^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

        requestor.weaveCompleted();
    	return wovenClassNames;
    }

======= fetch "private String eatIdentifier() {" ad753aa^:"bcel-builder/src/org/aspectj/apache/bcel/classfile/GenericSignatureParser.java"

======= fetch "private String eatIdentifier() {" ad753aa^:"bcel-builder/src/org/aspectj/apache/bcel/classfile/GenericSignatureParser.java"

 * GenericsError.java
 *
 * Created on September 1, 2005, 9:36 AM
 *
 */
  public Collection<String> test(
      boolean arg1,
      boolean arg2,
      Object arg3) ;
 * GenericsErrorImpl.java
 *
 * Created on September 1, 2005, 9:37 AM
 *
 */
  public Collection<String> test(
      boolean arg1,
      boolean arg2,
      Object arg3)  { return null; }
 
======= fetch "public void testSyntheticArgumentsOnITDConstructorsNotUsedInMatching() {" ad753aa^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  

======= fetch "public ISourceLocation getSourceLocation() {" 619f8bc^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public ISourceLocation getSourceLocation() {" 619f8bc^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public int getDeclarationLineNumber() {" 619f8bc^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    	if (hasDeclaredLineNumberInfo()) {
    		return memberView.getDeclarationOffset();
    	} else {
    		return 0;
    	}
    
======= fetch "public void addAttribute(Attribute attr) {" 619f8bc^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"


    // %6 is information like "[with runtime test]"
======= fetch "public static void main(String args[]) throws Throwable {" c6bc7a2^:"tests/java5/ataspectj/ataspectj/ltwlog/MainVerboseAndShow.java"

                "weaveinfo Type 'ataspectj.ltwlog.MainVerboseAndShow' (MainVerboseAndShow.java:22) advised by before advice from 'ataspectj.ltwlog.Aspect1' (Aspect1.java)",
======= fetch "private void reportWeavingMessage(ShadowMunger munger) {" c6bc7a2^:"weaver/src/org/aspectj/weaver/Shadow.java"

======= fetch "private void reportWeavingMessage(ShadowMunger munger) {" c6bc7a2^:"weaver/src/org/aspectj/weaver/Shadow.java"


    static Hashtable prims = new Hashtable();
    static {
        prims.put("void", Void.TYPE);
        prims.put("boolean", Boolean.TYPE);
        prims.put("byte", Byte.TYPE);
        prims.put("char", Character.TYPE);
        prims.put("short", Short.TYPE);
        prims.put("int", Integer.TYPE);
        prims.put("long", Long.TYPE);
        prims.put("float", Float.TYPE);
        prims.put("double", Double.TYPE);
    }
        
    static Class makeClass(String s, ClassLoader loader) {
        if (s.equals("*")) return null;
        Class ret = (Class)prims.get(s);
        if (ret != null) return ret;
        try {
            /* The documentation of Class.forName explains why this is the right thing
             * better than I could here.
             */
            if (loader == null) {
                return Class.forName(s);
            } else {
            	// used to be 'return loader.loadClass(s)' but that didn't cause
            	// array types to be created and loaded correctly. (pr70404)
                return Class.forName(s,false,loader);
            }
        } catch (ClassNotFoundException e) {
            //System.out.println("null for: " + s);
            //XXX there should be a better return value for this
            return ClassNotFoundException.class;
        }
    }
    
======= fetch "public Factory(String filename, Class lexicalClass) {" a5e645f^:"runtime/src/org/aspectj/runtime/reflect/Factory.java"

    
    
======= fetch "public MethodSignature makeMethodSig(String stringRep) {" a5e645f^:"runtime/src/org/aspectj/runtime/reflect/Factory.java"

    
   	public MethodSignature makeMethodSig(String modifiers, String methodName, String declaringType, String paramTypes, String paramNames, String exceptionTypes, String returnType) {
   		int modifiersAsInt = Integer.parseInt(modifiers, 16);
   
   		Class declaringTypeClass = makeClass(declaringType,lookupClassLoader);
   
   		StringTokenizer st = new StringTokenizer(paramTypes, ":");
   		int numParams = st.countTokens();
   		Class[] paramTypeClasses = new Class[numParams];
   		for(int i = 0; i < numParams; i++) paramTypeClasses[i] = makeClass(st.nextToken(),lookupClassLoader);
   
   		st = new StringTokenizer(paramNames, ":");
   		numParams = st.countTokens();
   		String[] paramNamesArray = new String[numParams];
   		for(int i = 0; i < numParams; i++) paramNamesArray[i] = st.nextToken();
   			
   		st = new StringTokenizer(exceptionTypes, ":");
   		numParams = st.countTokens();
   		Class[] exceptionTypeClasses = new Class[numParams];
   		for(int i = 0; i < numParams; i++) exceptionTypeClasses[i] = makeClass(st.nextToken(),lookupClassLoader);
   
   		Class returnTypeClass = makeClass(returnType,lookupClassLoader);
   
   		MethodSignatureImpl ret =
   			new MethodSignatureImpl(modifiersAsInt, methodName, declaringTypeClass, paramTypeClasses, paramNamesArray, exceptionTypeClasses, returnTypeClass);
   
   		return ret;
   	}
   	
======= fetch "public ConstructorSignature makeConstructorSig(String stringRep) {" a5e645f^:"runtime/src/org/aspectj/runtime/reflect/Factory.java"

    public ConstructorSignature makeConstructorSig(String modifiers, String declaringType, String paramTypes, String paramNames, String exceptionTypes) {
    	
    	ConstructorSignatureImpl ret = new ConstructorSignatureImpl(modifiersAsInt, declaringTypeClass, paramTypeClasses, paramNamesArray, exceptionTypeClasses);
    	ret.setLookupClassLoader(lookupClassLoader);
    	return ret;
   }
     
    
======= fetch "public FieldSignature makeFieldSig(String stringRep) {" a5e645f^:"runtime/src/org/aspectj/runtime/reflect/Factory.java"

    
    public FieldSignature makeFieldSig(String modifiers, String name, String declaringType, String fieldType) {
    	int modifiersAsInt = Integer.parseInt(modifiers, 16);
    	Class declaringTypeClass = makeClass(declaringType,lookupClassLoader);
    	Class fieldTypeClass = makeClass(fieldType,lookupClassLoader);
    			
    	FieldSignatureImpl ret = new FieldSignatureImpl(modifiersAsInt, name, declaringTypeClass, fieldTypeClass);
    	ret.setLookupClassLoader(lookupClassLoader);
    	return ret;
    }
    
======= fetch "public AdviceSignature makeAdviceSig(String stringRep) {" a5e645f^:"runtime/src/org/aspectj/runtime/reflect/Factory.java"

    public AdviceSignature makeAdviceSig(String modifiers, String name, String declaringType, String paramTypes, String paramNames, String exceptionTypes, String returnType) {
    	int modifiersAsInt = Integer.parseInt(modifiers, 16);
    	
    	Class declaringTypeClass = makeClass(declaringType,lookupClassLoader);
    		
    	StringTokenizer st = new StringTokenizer(paramTypes, ":");
    	int numParams = st.countTokens();
    	Class[] paramTypeClasses = new Class[numParams];
    	for(int i = 0; i < numParams; i++) paramTypeClasses[i] = makeClass(st.nextToken(),lookupClassLoader);
    	
    	st = new StringTokenizer(paramNames, ":");
    	numParams = st.countTokens();
    	String[] paramNamesArray = new String[numParams];
    	for(int i = 0; i < numParams; i++) paramNamesArray[i] = st.nextToken();
    	
    	st = new StringTokenizer(exceptionTypes, ":");
    	numParams = st.countTokens();
    	Class[] exceptionTypeClasses = new Class[numParams];
    	for(int i = 0; i < numParams; i++) exceptionTypeClasses[i] = makeClass(st.nextToken(),lookupClassLoader);;
    	
    	Class returnTypeClass = makeClass(returnType,lookupClassLoader);
    			
    	AdviceSignatureImpl ret = new AdviceSignatureImpl(modifiersAsInt, name, declaringTypeClass, paramTypeClasses, paramNamesArray, exceptionTypeClasses, returnTypeClass);
    	ret.setLookupClassLoader(lookupClassLoader);
    	return ret;
    }
    
======= fetch "public InitializerSignature makeInitializerSig(String stringRep) {" a5e645f^:"runtime/src/org/aspectj/runtime/reflect/Factory.java"

    public InitializerSignature makeInitializerSig(String modifiers, String declaringType) {
    	int modifiersAsInt = Integer.parseInt(modifiers, 16);
    	Class declaringTypeClass = makeClass(declaringType,lookupClassLoader);
    		
    	InitializerSignatureImpl ret = new InitializerSignatureImpl(modifiersAsInt, declaringTypeClass);
    	ret.setLookupClassLoader(lookupClassLoader);
    	return ret;
    }
    
======= fetch "public CatchClauseSignature makeCatchClauseSig(String stringRep) {" a5e645f^:"runtime/src/org/aspectj/runtime/reflect/Factory.java"

 
    public CatchClauseSignature makeCatchClauseSig(String declaringType, String parameterType, String parameterName) {
    	Class declaringTypeClass = makeClass(declaringType,lookupClassLoader);
    		
    	StringTokenizer st = new StringTokenizer(parameterType, ":");
    	Class parameterTypeClass = makeClass(st.nextToken(),lookupClassLoader);
    
    	st = new StringTokenizer(parameterName, ":");
    	String parameterNameForReturn = st.nextToken();
    
       	CatchClauseSignatureImpl ret = new CatchClauseSignatureImpl(declaringTypeClass, parameterTypeClass, parameterNameForReturn);
       	ret.setLookupClassLoader(lookupClassLoader);
      	return ret;
    }
======= fetch "Class extractType(int n) {" a5e645f^:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

        return makeClass(s);
======= fetch "Class extractType(int n) {" a5e645f^:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

    static Hashtable prims = new Hashtable();
    static {
        prims.put("void", Void.TYPE);
        prims.put("boolean", Boolean.TYPE);
        prims.put("byte", Byte.TYPE);
        prims.put("char", Character.TYPE);
        prims.put("short", Short.TYPE);
        prims.put("int", Integer.TYPE);
        prims.put("long", Long.TYPE);
        prims.put("float", Float.TYPE);
        prims.put("double", Double.TYPE);
    }
        
    Class makeClass(String s) {
        if (s.equals("*")) return null;
        Class ret = (Class)prims.get(s);
        if (ret != null) return ret;
        try {
            /* The documentation of Class.forName explains why this is the right thing
             * better than I could here.
             */
            ClassLoader loader = getLookupClassLoader();
            if (loader == null) {
                return Class.forName(s);
            } else {
            	// used to be 'return loader.loadClass(s)' but that didn't cause
            	// array types to be created and loaded correctly. (pr70404)
                return Class.forName(s,false,loader);
            }
        } catch (ClassNotFoundException e) {
            //System.out.println("null for: " + s);
            //XXX there should be a better return value for this
            return ClassNotFoundException.class;
        }
    }
======= fetch "Class makeClass(String s) {" a5e645f^:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

        for (int i = 0; i < N; i++) ret[i]= makeClass(st.nextToken());
======= fetch "private void initializeTjp(InstructionFactory fact, InstructionList list," a5e645f^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

    	list.append(new PUSH(getConstantPoolGen(), sig.getSignatureString(shadow.getWorld())));
    	list.append(fact.createInvoke(factoryType.getClassName(), 
    					sig.getSignatureMakerName(),
    					new ObjectType(sig.getSignatureType()),
    					new Type[] { Type.STRING },
    					Constants.INVOKEVIRTUAL));
======= fetch "private void initializeTjp(InstructionFactory fact, InstructionList list," a5e645f^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

    	if (sig.getKind().equals(Member.METHOD)) {
    		BcelWorld w = shadow.getWorld();
    		// For methods, push the parts of the signature on.
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getModifiers(w))));
    		list.append(new PUSH(getConstantPoolGen(),sig.getName()));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getDeclaringType())));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getParameterTypes())));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getParameterNames(w))));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getExceptions(w))));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getReturnType())));
    		// And generate a call to the variant of makeMethodSig() that takes 7 strings
    		list.append(fact.createInvoke(factoryType.getClassName(), 
    				sig.getSignatureMakerName(),
    				new ObjectType(sig.getSignatureType()),
    				new Type[] { Type.STRING,Type.STRING,Type.STRING,Type.STRING,Type.STRING,Type.STRING,Type.STRING },
    				Constants.INVOKEVIRTUAL));
    	} else if (sig.getKind().equals(Member.HANDLER)) {
    		BcelWorld w = shadow.getWorld();
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getDeclaringType())));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getParameterTypes())));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getParameterNames(w))));
    		list.append(fact.createInvoke(factoryType.getClassName(),
    				sig.getSignatureMakerName(),
    				new ObjectType(sig.getSignatureType()),
    				new Type[] { Type.STRING, Type.STRING, Type.STRING },
    				Constants.INVOKEVIRTUAL));    	
    	} else if(sig.getKind().equals(Member.CONSTRUCTOR)) {
    		BcelWorld w = shadow.getWorld();
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getModifiers(w))));	
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getDeclaringType())));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getParameterTypes())));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getParameterNames(w))));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getExceptions(w))));
    		list.append(fact.createInvoke(factoryType.getClassName(),
    				sig.getSignatureMakerName(),
    				new ObjectType(sig.getSignatureType()),
    				new Type[] { Type.STRING, Type.STRING, Type.STRING, Type.STRING, Type.STRING },
    				Constants.INVOKEVIRTUAL));    	
    	} else if(sig.getKind().equals(Member.FIELD)) {
    		BcelWorld w = shadow.getWorld();
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getModifiers(w))));
    		list.append(new PUSH(getConstantPoolGen(),sig.getName()));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getDeclaringType())));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getReturnType())));
    		list.append(fact.createInvoke(factoryType.getClassName(),
    				sig.getSignatureMakerName(),
    				new ObjectType(sig.getSignatureType()),
    				new Type[] { Type.STRING, Type.STRING, Type.STRING, Type.STRING },
    				Constants.INVOKEVIRTUAL));    	
    	} else if(sig.getKind().equals(Member.ADVICE)) {
    		BcelWorld w = shadow.getWorld();
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getModifiers(w))));
    		list.append(new PUSH(getConstantPoolGen(),sig.getName()));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getDeclaringType())));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getParameterTypes())));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getParameterNames(w))));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getExceptions(w))));
    		list.append(new PUSH(getConstantPoolGen(),makeString((sig.getReturnType()))));    		
    		list.append(fact.createInvoke(factoryType.getClassName(),
    				sig.getSignatureMakerName(),
    				new ObjectType(sig.getSignatureType()),
    				new Type[] { Type.STRING, Type.STRING, Type.STRING, Type.STRING, Type.STRING, Type.STRING, Type.STRING },
    				Constants.INVOKEVIRTUAL));    	
    	} else if(sig.getKind().equals(Member.STATIC_INITIALIZATION)) {
    		BcelWorld w = shadow.getWorld();
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getModifiers(w))));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getDeclaringType())));
    		list.append(fact.createInvoke(factoryType.getClassName(),
    				sig.getSignatureMakerName(),
    				new ObjectType(sig.getSignatureType()),
    				new Type[] { Type.STRING, Type.STRING },
    				Constants.INVOKEVIRTUAL));
    	} else {
    	  list.append(new PUSH(getConstantPoolGen(), sig.getSignatureString(shadow.getWorld())));
    	  list.append(fact.createInvoke(factoryType.getClassName(), 
    	}   	
======= fetch "private void initializeTjp(InstructionFactory fact, InstructionList list," a5e645f^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

                    LDC "1--HelloWorld----"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeConstructorSig (Ljava/lang/String;)Lorg/aspectj/lang/reflect/ConstructorSignature;
                    LDC "9-main-HelloWorld-[Ljava.lang.String;:-args:--void-"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeMethodSig (Ljava/lang/String;)Lorg/aspectj/lang/reflect/MethodSignature;
                    LDC "1--HelloWorld----"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeConstructorSig (Ljava/lang/String;)Lorg/aspectj/lang/reflect/ConstructorSignature;
                    LDC "19-out-java.lang.System-java.io.PrintStream-"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeFieldSig (Ljava/lang/String;)Lorg/aspectj/lang/reflect/FieldSignature;
                    LDC "1-println-java.io.PrintStream-java.lang.String:-arg0:--void-"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeMethodSig (Ljava/lang/String;)Lorg/aspectj/lang/reflect/MethodSignature;
                    LDC "9-main-HelloWorld-[Ljava.lang.String;:-args:--void-"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeMethodSig (Ljava/lang/String;)Lorg/aspectj/lang/reflect/MethodSignature;
                    LDC "1--HelloWorld----"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeConstructorSig (Ljava/lang/String;)Lorg/aspectj/lang/reflect/ConstructorSignature;
                    LDC "19-out-java.lang.System-java.io.PrintStream-"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeFieldSig (Ljava/lang/String;)Lorg/aspectj/lang/reflect/FieldSignature;
                    LDC "1-println-java.io.PrintStream-java.lang.String:-arg0:--void-"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeMethodSig (Ljava/lang/String;)Lorg/aspectj/lang/reflect/MethodSignature;
                    LDC "9-main-HelloWorld-[Ljava.lang.String;:-args:--void-"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeMethodSig (Ljava/lang/String;)Lorg/aspectj/lang/reflect/MethodSignature;
                    LDC "1--HelloWorld----"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeConstructorSig (Ljava/lang/String;)Lorg/aspectj/lang/reflect/ConstructorSignature;
                    LDC "19-out-java.lang.System-java.io.PrintStream-"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeFieldSig (Ljava/lang/String;)Lorg/aspectj/lang/reflect/FieldSignature;
                    LDC "1-println-java.io.PrintStream-java.lang.String:-arg0:--void-"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeMethodSig (Ljava/lang/String;)Lorg/aspectj/lang/reflect/MethodSignature;
                    LDC "9-main-HelloWorld-[Ljava.lang.String;:-args:--void-"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeMethodSig (Ljava/lang/String;)Lorg/aspectj/lang/reflect/MethodSignature;
                    LDC "1--HelloWorld----"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeConstructorSig (Ljava/lang/String;)Lorg/aspectj/lang/reflect/ConstructorSignature;
                    LDC "19-out-java.lang.System-java.io.PrintStream-"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeFieldSig (Ljava/lang/String;)Lorg/aspectj/lang/reflect/FieldSignature;
                    LDC "1-println-java.io.PrintStream-java.lang.String:-arg0:--void-"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeMethodSig (Ljava/lang/String;)Lorg/aspectj/lang/reflect/MethodSignature;
                    LDC "9-main-HelloWorld-[Ljava.lang.String;:-args:--void-"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeMethodSig (Ljava/lang/String;)Lorg/aspectj/lang/reflect/MethodSignature;

======= fetch "public void visibilityConflict(MethodBinding currentMethod, MethodBinding inheri" 16512b2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

    
    public void unusedPrivateType(TypeDeclaration typeDecl) {
    	// don't output unused type warnings for aspects!
    	if (!(typeDecl instanceof AspectDeclaration))
    		super.unusedPrivateType(typeDecl);
    }
======= fetch "public void testArgsGeneratedCorrectlyForAdviceExecution() {" 16512b2^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testNoUnusedWarningsOnAspectTypes() {
  }
  
    <ajc-test dir="bugs150" pr="74048" title="no unused warnings on aspect types">
        <compile files="pr74048.aj" options="-warn:unusedPrivate"/>
    </ajc-test>  
  

   pointcut call_m(int a, int b) : call(int *.m(..)) && args(a, b);
 
   int m(int p, int q) { return 2; }
   
   void foo() {
   }
   
   int around(int x, int y) : call_m(x, y) {  return 5; }
 
   before(int x, int y) : 
       adviceexecution() && within(some_aspect) &&  args(x, y) {
   }
======= fetch "public void testVisibiltyInSignatureMatchingWithOverridesPart3() {" a66e0a2^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testArgsGeneratedCorrectlyForAdviceExecution() {
  }
  
 
    <ajc-test dir="bugs150" pr="59196" title="args generated correctly for advice execution join point">
        <compile files="pr59196.aj" options="-XnoInline -1.5"/>
    </ajc-test>  
======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" a66e0a2^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" a66e0a2^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" a66e0a2^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= fetch "private Test findResidueNoEllipsis(Shadow shadow, ExposedState state, TypePatter" a66e0a2^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= fetch "protected Test findResidueInternal(Shadow shadow, ExposedState state) {" a66e0a2^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"


======= fetch "public void testInlinedFieldAccessInProceedCall() {" 7e0c3cd^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testVisibiltyInSignatureMatchingWithOverridesPart1() {
  }
  public void testVisibiltyInSignatureMatchingWithOverridesPart2() {
  }
  public void testVisibiltyInSignatureMatchingWithOverridesPart3() {
  }
  
    <ajc-test dir="bugs150/pr71159" pr="71159" title="visibility in signature matching with overrides - 1">
        <compile files="pr71159.aj">
            <message kind="warning" line="26" text="should match"/>
        </compile>
    </ajc-test>  
    <ajc-test dir="bugs150/pr71159" pr="71159" title="visibility in signature matching with overrides - 2">
        <compile files="PrivateITD.aj">
            <message kind="warning" line="28" text="should match"/>
        </compile>
    </ajc-test>  
    <ajc-test dir="bugs150/pr71159" pr="71159" title="visibility in signature matching with overrides - 3">
        <compile files="pkg1/A.java,pkg1/B.java,pkg1/C.java,pkg2/ITDInDiffPackage.aj">
            <message kind="warning" line="10" text="should match"/>
        </compile>
    </ajc-test>  
  
======= fetch "private static void accumulateMembersMatching(" 7e0c3cd^:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

======= fetch "private static void accumulateMembersMatching(" 7e0c3cd^:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

    /**
     * Returns true if the parent member is visible to the child member 
     * In the same declaring type this is always true, otherwise if parent is private
     * it is false.
     * @param childMember
     * @param parentMember
     * @return
     */
    private static boolean isVisibleTo(ResolvedMember childMember, ResolvedMember parentMember) {
    	if (childMember.getDeclaringType().equals(parentMember.getDeclaringType())) return true;
    	if (Modifier.isPrivate(parentMember.getModifiers())) {
    		return false;
    	} else {
    		return true;
    	}
    }

======= fetch "private FieldBinding getAccessibleField(FieldBinding binding, TypeBinding receiv" 6c8747b^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

  Foo field;
  void test() {}
  void around() : call(void Foo.test()) {
    Foo foo = new Foo().field;
    proceed(foo); // caught at compile time
    proceed(new Foo().field); // crashes
  }
======= fetch "public void testInnerClassPassedToVarargs() {" 6c8747b^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testInlinedFieldAccessInProceedCall() {
  }
  
    <ajc-test dir="bugs150" pr="107858" title="inlined field access in proceed call">
        <compile files="pr107858.aj" options="-1.5">
            <message kind="error" line="9" text="too many arguments to proceed, expected 0"></message>
            <message kind="error" line="10" text="too many arguments to proceed, expected 0"></message>
        </compile>
    </ajc-test>  
 

  public class Inner {}
  public void varargs(Object... varargs) {}
  public void test() {
    Outer.Inner inner = new Outer().new Inner();
    varargs(inner); // works
    varargs(new Outer().new Inner()); // crashes
  }
======= fetch "public void testDeclareParentsIntroducingCovariantReturnType() {" f2af562^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testInnerClassPassedToVarargs() {
  }
  
    <ajc-test dir="bugs150" pr="104024" title="inner class passed as argument to varargs method">
        <compile files="pr104024.aj" options="-1.5"/>
    </ajc-test>  
    

    static interface Inner {
    }
    static class InnerTest implements Inner {
    }
======= fetch "public void testEnumSwitchInITD() {" b953c03^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

                

======= fetch "private void unpackGenericSignature() {" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelField.java"

======= fetch "public static ResolvedType classTypeSignature2TypeX(" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= fetch "private static ResolvedType classTypeSignature2TypeX(" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= fetch "public static ResolvedType fieldTypeSignature2TypeX(" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= fetch "private static ResolvedType fieldTypeSignature2TypeX(" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= fetch "private static ResolvedType fieldTypeSignature2TypeX(" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= fetch "public static TypeVariable formalTypeParameter2TypeVariable(" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= fetch "private static TypeVariable formalTypeParameter2TypeVariable(" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= fetch "private static ResolvedType typeArgument2TypeX(" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= fetch "public static ResolvedType typeSignature2TypeX(" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= fetch "private static ResolvedType typeSignature2TypeX(" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= fetch "private static ResolvedType typeVariableSignature2TypeX(" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= fetch "private static ResolvedType typeVariableSignature2TypeX(" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= fetch "public ResolvedType resolve(World world) {" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= fetch "private void unpackGenericSignature() {" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelMethod.java"

======= fetch "private void unpackGenericSignature() {" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelMethod.java"

======= fetch "public void setJavaClass(JavaClass newclass) {" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "private void unpackGenericSignature() {" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "private void unpackGenericSignature() {" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "private ReferenceType getOuterClass() {" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "private ReferenceType getOuterClass() {" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "private ReferenceType getOuterClass() {" 2c9ea11^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "public void testEnumFromHell() {" 2c9ea11^:"weaver/testsrc/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXTestCase.java"


    public static void main(String[] args) {
    	System.out.println(new pr108377().foo());
    }
    public pr108377 pr108377.a;
    public String pr108377.value;
    public String pr108377.foo() {
    	if (a == null) a = this;
    	return a.value;
    }
======= fetch "public void testParameterizedVarArgsMatch() {" be750d5^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testFieldAccessInsideITDM() {
  }
  
    <ajc-test dir="bugs150" pr="108377" title="itd field access inside itd method">
        <compile files="pr108377.aj"/>
        <run class="pr108377"/>
    </ajc-test>
    
    <!-- ============================================================================ -->
    <!-- ============================================================================ -->
    

    protected void doPost() {
    }    
    protected void doPost() {
    }
    
    private static aspect FindMatches {
    	  declare warning: execution(* HttpServlet.do*(..)): "servlet request";
    }
    private static final long serialVersionUID = 1; 
    protected void doPost()
    {
    } 
======= fetch "public void testMultipleAnonymousInnerClasses_pr108104() {" 27e68f3^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

       
======= fetch "public void resetReturnTypeToObjectArray() {" 27e68f3^:"weaver/src/org/aspectj/weaver/JoinPointSignature.java"

======= fetch "public ResolvedMemberImpl(" 27e68f3^:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

    	List memberSignatures = new ArrayList();
======= fetch "private static void accumulateMembersMatching(" 27e68f3^:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

    		List foundMembers) {
======= fetch "private static void accumulateMembersMatching(" 27e68f3^:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"


======= fetch "public Collection weave(IClassFileProvider input) throws IOException {" 100d9e0^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "private void weaveAndNotify(UnwovenClassFile classFile, BcelObjectType classType" 100d9e0^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public ConcreteTypeMunger makePerClauseAspect(ResolvedType aspect, PerClause.Kin" 100d9e0^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

    /**
     * Retrieve a bcel delegate for an aspect - this will return NULL if the
     * delegate is an EclipseSourceType and not a BcelObjectType - this happens
     * quite often when incrementally compiling.
     */
======= fetch "public static BcelObjectType getBcelObjectType(ResolvedType concreteAspect) {" 100d9e0^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"


 * @version $Id: SWITCH.java,v 1.2 2004/11/19 16:45:19 aclement Exp $
======= fetch "public SWITCH(int[] match, InstructionHandle[] targets," bf767a9^:"bcel-builder/src/org/aspectj/apache/bcel/generic/SWITCH.java"

      instruction = new TABLESWITCH(match, targets, target);
 * @version $Id: TABLESWITCH.java,v 1.2 2004/11/19 16:45:19 aclement Exp $
======= fetch "public TABLESWITCH(int[] match, InstructionHandle[] targets," bf767a9^:"bcel-builder/src/org/aspectj/apache/bcel/generic/TABLESWITCH.java"

    
======= fetch "public void dump(DataOutputStream out) throws IOException {" bf767a9^:"bcel-builder/src/org/aspectj/apache/bcel/generic/TABLESWITCH.java"

    

======= fetch "public void testMultipleAnonymousInnerClasses() {" cc6e681^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testPrivilegedMethodAccessorsGetRightExceptions_pr82989() {
  }
  
======= fetch "public void testDeclareSoftInGenericAspect() {" cc6e681^:"tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java"

   <ajc-test dir="java5/generics/itds/bridgeMethods" title="abstract intertype methods and covariant returns - error">
   	   <compile files="pr91381_2.aj">
   	     <message kind="error" line="15" text="The return type is incompatible with A.foo()"/>
   	   </compile>
   </ajc-test>
   
   <ajc-test dir="bugs150" title="Compiler error due to a wrong exception check in try blocks">
     <compile files="pr82989.aj" options="-1.5"/>
   </ajc-test>
   
======= fetch "public static ResolvedMember privilegedAccessMethodForMethod(UnresolvedType aspe" cc6e681^:"weaver/src/org/aspectj/weaver/AjcMemberMaker.java"


======= fetch "public void testAtSuppressWarnings() {" 93fdce1^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

            
======= fetch "public Pointcut concretize1(ResolvedType searchStart, IntMap bindings) {" 93fdce1^:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"


     * me a type safety warning when I don't specify the type when declaring a generic 
     * even though I have the @SuppressWarnings( "unchecked" ) annotation specified.
======= fetch "public void testPointcutOverriding() {" 7b32570^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testAtSuppressWarnings() {
  }
  
    <ajc-test dir="bugs150" pr="104529" title="@SuppressWarnings should suppress">
        <compile files="pr104529.aj" options = "-1.5 -warn:+unchecked">
            <message line="11" kind="warning" text="needs unchecked conversion"/>
        </compile>
    </ajc-test>
            
            

======= fetch "public void testDetectVoidFieldType() {" 86ce1f7^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testPointcutOverriding() {
  }
  
    <ajc-test dir="bugs150" pr="86057" title="overriding final pointcut from super-aspect">
        <compile files="pr86057.aj">
            <message line="9" kind="error" text="can't override final pointcut Base.foo()"/>
        </compile>
    </ajc-test>
======= fetch "private boolean isDuplicateMemberWithinTargetType(ResolvedMember existingMember," 86ce1f7^:"weaver/src/org/aspectj/weaver/ResolvedType.java"

======= fetch "public boolean checkLegalOverride(ResolvedMember parent, ResolvedMember child) {" 86ce1f7^:"weaver/src/org/aspectj/weaver/ResolvedType.java"


======= fetch "public void testNoBeforeReturningAdvice() {" 2b23e91^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

                

======= fetch "public void testAjKeywordsAsIdentifiers() {" 169a488^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

            

======= fetch "public void testBadRuntimeTestGeneration() {" 5e9aca9^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testErrorMessageOnITDWithTypePatterns() {
  }
  
  public void testAjKeywordsAsIdentifiers() {
  }
  
    <ajc-test dir="bugs150" pr="64568" title="clear error message on itd with type pattern">
        <compile files="pr64568.aj">
            <message line="4" kind="error" text="Syntax error on token &quot;*&quot;, delete this token"/>
            <message line="4" kind="error" text="foo cannot be resolved to a type"/>
        </compile>
    </ajc-test>
    <ajc-test dir="bugs150" pr="74562" title="before and after are valid identifiers in classes">
        <compile files="pr74562.aj">
        </compile>
    </ajc-test>
            

======= fetch "public void testIfEvaluationExplosion_pr94086() {" 477c575^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

    <ajc-test dir="bugs150" title="missing name pattern">
     <compile files="GenericAspect1.aj" options="-1.5"/>
       <message kind="error" line="9" text="can not extend"/>

======= fetch "public void testIfEvaluationExplosion_pr94086() {" 5735e96^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testMissingNamePattern_pr106461() { runTest("missing name pattern"); }
  
    
    <ajc-test dir="bugs150" title="missing name pattern">
        <compile files="PR106461.aj">
            <message kind="error" line="3" text="Syntax error on token &quot;(&quot;, &quot;name pattern&quot; expected"/>
            <message kind="error" line="5" text="Syntax error on token &quot;)&quot;, &quot;name pattern&quot; expected"/>
            <message kind="error" line="7" text="Syntax error on token &quot;.&quot;, &quot;name pattern&quot; expected"/>
        </compile>
    </ajc-test>
======= fetch "public SignaturePattern parseFieldSignaturePattern() {" 5735e96^:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"

======= fetch "public NamePattern extractName() {" 5735e96^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"


 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 *   Alexandre Vasseur         initial implementation
 *******************************************************************************/
 * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
 */
    static int s_i = 0;
    public static void main(String[] args) {
        TestHelper.runAndThrowOnFailure(suite());
    }
    public static junit.framework.Test suite() {
        return new junit.framework.TestSuite(Bug104212.class);
    }
    public void testStaticMethodFromSuperClass() {
        Child.doSome();
        assertEquals(1, s_i);
    }
    static class Parent {
        static void foo() {}
    }
    static class Child extends Parent {
        static void doSome() {
            foo();// this is the bug
        }
    }
    @Aspect
    public static class TestAspect {
        @Before("call(* ataspectj.Bug104212.Parent.foo()) && within(ataspectj.Bug104212.Child)")
        public void before(JoinPoint jp) {
            // AJ bug was here since Java 1.4...
            // was: call(Bug104212.Child.foo())
            assertEquals("call(Bug104212.Parent.foo())", jp.toShortString());
            assertEquals(Parent.class, jp.getSignature().getDeclaringType());
            assertNotNull(((MethodSignature)jp.getSignature()).getMethod());
            s_i++;
        }
    }
======= fetch "public void testMultipleBinding() {" 619a6ad^:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjSyntaxTests.java"

    public void testBug104212() {
        runTest("Bug104212");
    }
    <ajc-test dir="java5/ataspectj" title="Bug104212">
        <compile files="ataspectj/Bug104212.java,ataspectj/TestHelper.java" options="-1.5"/>
        <run class="ataspectj.Bug104212"/>
    </ajc-test>
======= fetch "private void matchInvokeInstruction(LazyMethodGen mg," 619a6ad^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public static BcelShadow makeConstructorCall(" 619a6ad^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        Member sig = BcelWorld.makeMethodSignature(
======= fetch "public static BcelShadow makeMethodCall(" 619a6ad^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

                BcelWorld.makeMethodSignature(
======= fetch "public Member makeMethodSignature(LazyMethodGen mg, Member.Kind kind) {" 619a6ad^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

    public static Member makeMethodSignature(LazyClassGen cg, InvokeInstruction ii) {
======= fetch "public static Member makeMethodSignature(LazyClassGen cg, InvokeInstruction ii)" 619a6ad^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

        // in Java 1.4 and after, static method call of super class within subclass method appears
        // as declared by the subclass in the bytecode - but they are not
        // see #104212
        if (ii instanceof INVOKESTATIC) {
            ResolvedType appearsDeclaredBy = resolve(declaring);
            // look for the method there
            for (Iterator iterator = appearsDeclaredBy.getMethods(); iterator.hasNext();) {
                ResolvedMember method = (ResolvedMember) iterator.next();
                if (method.isStatic()) {
                    if (name.equals(method.getName()) && signature.equals(method.getSignature())) {
                        // we found it
                        declaring = method.getDeclaringType().getName();
                        break;
                    }
                }
            }
        }
        //FIXME if not found we ll end up again with the bug.. can this happen?

======= fetch "public void endVisit(ConstructorDeclaration decl, ClassScope scope) {" bba9c50^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/MakeDeclsPublicVisitor.java"

======= fetch "public void endVisit(FieldDeclaration decl, MethodScope scope) {" bba9c50^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/MakeDeclsPublicVisitor.java"

======= fetch "public void endVisit(MethodDeclaration decl, ClassScope scope) {" bba9c50^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/MakeDeclsPublicVisitor.java"

======= fetch "public void endVisit(" bba9c50^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/MakeDeclsPublicVisitor.java"

======= fetch "public void endVisit(" bba9c50^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/MakeDeclsPublicVisitor.java"

    after() returning (RequestContext newContext) : call(RequestContext+.new(..)) {        
        System.out.println("constructing "+newContext+" at "+thisJoinPoint.toLongString()+" from "+thisEnclosingJoinPointStaticPart+":");
    }
     abstract class RequestContext {
        public final Object execute() {
            return doExecute();
        }
        
        /** template method */
        public abstract Object doExecute();
    }
    public static void main(String args[]) {
        new Runnable() {
            public void run() {}
        }.run();
    };
    Object around(final Object runnable) : execution(void Runnable.run()) && this(runnable) {
        System.out.println("monitoring operation: "+runnable+" at "+thisJoinPoint+", for "+thisJoinPoint.getThis());
        RequestContext requestContext = new RequestContext() {
            public Object doExecute() {
                return proceed(runnable);
            }
            
        };
        return requestContext.execute();
    }
    
    
    Object around() : call(void awqeyuwqer()) {
        RequestContext requestContext = new ConnectionRequestContext() {
            public Object doExecute() {                
                return proceed();
            }
            
        };
        return requestContext.execute();
    }
    
======= fetch "public void testIfEvaluationExplosion_pr94086() {" bba9c50^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testSyntaxErrorNPE_pr103266() {runTest("NPE on syntax error");}
  
   
   <ajc-test dir="bugs150" pr="103266" title="NPE on syntax error">
     <compile files="pr103266.aj">
          <message kind="error" line="41" text="ConnectionRequestContext cannot be resolved to a type"/>
     </compile>
   </ajc-test>

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 *   Alexandre Vasseur         initial implementation
 *******************************************************************************/
 * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
 */
    static StringBuffer s_log = new StringBuffer();
    static void log(String s) {
        s_log.append(s).append(" ");
    }
    public static void main(String[] args) {
        TestHelper.runAndThrowOnFailure(suite());
    }
    public static junit.framework.Test suite() {
        return new junit.framework.TestSuite(MultipleBindingTest.class);
    }
    public void testMultipleJoinPoint() {
        s_log = new StringBuffer();
        Target.dump(new JoinPoint() {
            public String toShortString() {
                return "jpFromApp";
            }
            public String toLongString() {
                return null;
            }
            public Object getThis() {
                return null;
            }
            public Object getTarget() {
                return null;
            }
            public Object[] getArgs() {
                return new Object[0];
            }
            public Signature getSignature() {
                return null;
            }
            public SourceLocation getSourceLocation() {
                return null;
            }
            public String getKind() {
                return null;
            }
            public StaticPart getStaticPart() {
                return null;
            }
        });
        assertEquals("jpFromApp execution(MultipleBindingTest.Target.dump(..)) execution(MultipleBindingTest.Target.dump(..)) jpFromApp ", s_log.toString());
    }
    public void testMultipleProceedingJoinPoint() {
        s_log = new StringBuffer();
        Target.dump2(new ProceedingJoinPoint() {
            public void set$AroundClosure(AroundClosure arc) {
            }
            public Object proceed() throws Throwable {
                return null;
            }
            public Object proceed(Object[] args) throws Throwable {
                return null;
            }
            public String toShortString() {
                return "pjpFromApp";
            }
            public String toLongString() {
                return null;
            }
            public Object getThis() {
                return null;
            }
            public Object getTarget() {
                return null;
            }
            public Object[] getArgs() {
                return new Object[0];
            }
            public Signature getSignature() {
                return null;
            }
            public SourceLocation getSourceLocation() {
                return null;
            }
            public String getKind() {
                return null;
            }
            public StaticPart getStaticPart() {
                return null;
            }
        });
        assertEquals("pjpFromApp execution(MultipleBindingTest.Target.dump2(..)) execution(MultipleBindingTest.Target.dump2(..)) pjpFromApp ", s_log.toString());
    }
    static class Target {
        static void dump(JoinPoint jp) {
            log(jp.toShortString());
        }
        static void dump2(ProceedingJoinPoint pjp) {
            log(pjp.toShortString());
        }
    }
    @Aspect
    public static class TestAspect {
        @Before("execution(* ataspectj.MultipleBindingTest.Target.dump(..)) && args(ajp)")
        public void before(JoinPoint ajp, JoinPoint jp, JoinPoint jpbis) {
            log(ajp.toShortString());
            log(jp.toShortString());
            log(jpbis.toShortString());
        }
        @Around("execution(* ataspectj.MultipleBindingTest.Target.dump2(..)) && args(apjp)")
        public Object around(ProceedingJoinPoint apjp, ProceedingJoinPoint pjp, ProceedingJoinPoint pjpbis) throws Throwable {
            log(apjp.toShortString());
            log(pjp.toShortString());
            log(pjpbis.toShortString());
            return pjp.proceed();
        }
    }
======= fetch "public void before(String s, JoinPoint.StaticPart sjp) {" 639b4fd^:"tests/java5/ataspectj/ataspectj/SingletonAspectBindingsTest.java"

======= fetch "public void before(String s, JoinPoint.StaticPart sjp) {" 639b4fd^:"tests/java5/ataspectj/ataspectj/SingletonAspectBindingsTest.java"

======= fetch "public void before(String s, JoinPoint.StaticPart sjp) {" 639b4fd^:"tests/java5/ataspectj/ataspectj/SingletonAspectBindingsTest.java"

======= fetch "public void testSingletonAspectBindings() {" 639b4fd^:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjSyntaxTests.java"

        org.aspectj.asm.AsmManager.setReporting("debug.txt",true,true,true,true);
======= fetch "public void testSingletonAspectBindings() {" 639b4fd^:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjSyntaxTests.java"

        //runTest("singletonAspectBindings2");
======= fetch "public void testIfPointcut2() {" 639b4fd^:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjSyntaxTests.java"

    public void testMultipleBinding() {
        runTest("MultipleBinding");
    }
        <compile files="ataspectj/PerClauseInheritanceTest.java,ataspectj/TestHelper.java" options="-1.5 -XnoInline"/>
        <run class="ataspectj.PerClauseInheritanceTest"/>
    <ajc-test dir="java5/ataspectj" title="MultipleBinding">
        <compile files="ataspectj/MultipleBindingTest.java,ataspectj/TestHelper.java" options="-1.5 -Xdev:NoAtAspectJProcessing -XnoInline"/>
        <run class="ataspectj.MultipleBindingTest"/>
        <compile files="ataspectj/MultipleBindingTest.java,ataspectj/TestHelper.java" options="-1.5 -Xdev:NoAtAspectJProcessing"/>
        <run class="ataspectj.MultipleBindingTest"/>
    </ajc-test>
======= fetch "public InstructionList getAdviceArgSetup(" 639b4fd^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= fetch "public InstructionList getAdviceArgSetup(" 639b4fd^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

        final boolean isAnnotationStyleAspect = getConcreteAspect()!=null && getConcreteAspect().isAnnotationStyleAspect();
        boolean previousIsClosure = false;
======= fetch "public InstructionList getAdviceArgSetup(" 639b4fd^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

            	if (getConcreteAspect()==null || !getConcreteAspect().isAnnotationStyleAspect()) {
======= fetch "public InstructionList getAdviceArgSetup(" 639b4fd^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

                    //    previousIsClosure = true;
                    if ("Lorg/aspectj/lang/ProceedingJoinPoint;".equals(getSignature().getParameterTypes()[i].getSignature())) {
                        //make sure we are in an around, since we deal with the closure, not the arg here
                        if (getKind() != AdviceKind.Around) {
                            previousIsClosure = false;
                            getConcreteAspect().getWorld().getMessageHandler().handleMessage(
                                    new Message(
                                            "use of ProceedingJoinPoint is allowed only on around advice ("
                                            + "arg " + i + " in " + toString() + ")",
                                            this.getSourceLocation(),
                                            true
                                    )
                            );
                            // try to avoid verify error and pass in null
                            il.append(InstructionConstants.ACONST_NULL);
                        } else {
                            if (previousIsClosure) {
                                il.append(InstructionConstants.DUP);
                            } else {
                                previousIsClosure = true;
                                il.append(closureInstantiation.copy());
                            }
                        }
======= fetch "public InstructionList getAdviceArgSetup(" 639b4fd^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

                        previousIsClosure = false;
======= fetch "public InstructionList getAdviceArgSetup(" 639b4fd^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

                        previousIsClosure = false;
======= fetch "public InstructionList getAdviceArgSetup(" 639b4fd^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

                        previousIsClosure = false;
======= fetch "public InstructionList getAdviceArgSetup(" 639b4fd^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

                        previousIsClosure = false;
======= fetch "public InstructionList getAdviceArgSetup(" 639b4fd^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

                        previousIsClosure = false;
======= fetch "public InstructionList getAdviceArgSetup(" 639b4fd^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

        
======= fetch "public InstructionList getAdviceArgSetup(" 639b4fd^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

        if (getConcreteAspect()==null || !getConcreteAspect().isAnnotationStyleAspect()) {

  public void Generic_Parent.inherited_method() {}
  public int Generic_Parent.inherited_field;
  public static void test() {
    int inherited_field;
    inherited_field = new Generic_Child().inherited_field; // works
    inherited_field = new Generic_Child<Integer>().inherited_field; // works
    inherited_field = new Child().inherited_field; // works
    new Generic_Child().inherited_method(); // works
    new Generic_Child<Integer>().inherited_method(); // unresolved
    new Child().inherited_method(); // unresolved
  }
  public static void main(String []argv) {
    test();
  }
======= fetch "public void testIfEvaluationExplosion_pr94086() {" b54831f^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testItdGenerics_pr100260() {runTest("methods inherited from a generic parent");}
  
   <ajc-test dir="bugs150" pr="100260" title="methods inherited from a generic parent">
     <compile files="pr100260.aj" options="-1.5"/>
     <run class="pr100260"/>
   </ajc-test>
   

======= fetch "public static TypeX fromBinding(TypeBinding binding) {" 7d5002a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

  class Inner {public void p() {System.err.println("Outer.Inner.p() executing");} }
  public void m() { new Inner().p(); }
  class Inner {public void p() {System.err.println("Generic_Outer.Inner.p() executing");} }
  public void m() { new Inner().p(); }
  int Outer.outer = 1;
  int Outer.Inner.inner = 2;
  int Generic_Outer.outer = 3; 
  int Generic_Outer.Inner.inner = 4;
  before(Object o): execution(* p()) && this(o) {
    if (o instanceof Outer.Inner) {
      System.err.println("Outer.Inner.inner="+((Outer.Inner)o).inner);
    }
    if (o instanceof Generic_Outer.Inner) {
      System.err.println("Generic_Outer.Inner.inner="+((Generic_Outer.Inner)o).inner);
    }
  }
  public static void main(String []argv) {
    new Outer().m();
    new Generic_Outer<String>().m();
  }
======= fetch "public void testIfEvaluationExplosion_pr94086() {" 7d5002a^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testItdGenerics_pr99228() {runTest("ITD of a field into a generic class");}
  public void testItdGenerics_pr98320() {runTest("intertype with nested generic type");}
  
======= fetch "public static TypeX forParameterizedTypeNames(String name, String[] paramTypeNam" 7d5002a^:"weaver/src/org/aspectj/weaver/TypeX.java"

======= fetch "public static TypeX forParameterizedTypeNames(String name, String[] paramTypeNam" 7d5002a^:"weaver/src/org/aspectj/weaver/TypeX.java"

======= fetch "public static TypeX forParameterizedTypeNames(String name, String[] paramTypeNam" 7d5002a^:"weaver/src/org/aspectj/weaver/TypeX.java"

======= fetch "public static TypeX forRawTypeNames(String name) {" 7d5002a^:"weaver/src/org/aspectj/weaver/TypeX.java"

======= fetch "public String getBaseName() {" 7d5002a^:"weaver/src/org/aspectj/weaver/TypeX.java"

======= fetch "public final boolean isArray() {" 7d5002a^:"weaver/src/org/aspectj/weaver/TypeX.java"

======= fetch "public final boolean isParameterized() {" 7d5002a^:"weaver/src/org/aspectj/weaver/TypeX.java"

======= fetch "public final boolean isRawType() {" 7d5002a^:"weaver/src/org/aspectj/weaver/TypeX.java"

======= fetch "private final void setParameterized(boolean b) {" 7d5002a^:"weaver/src/org/aspectj/weaver/TypeX.java"

    private final void setRawtype(boolean b) {
    }

======= fetch "private SourceTypeBinding makeSourceTypeBinding(ReferenceBinding onType) {" 588023e^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeScope.java"


  public static void m() {System.err.println("static method running");}
  public static void main(String []argv) {
    m();
  }
  public static void main(String []argv) {
    m();
  }
======= fetch "public void testReflectNPE_pr94167() {" f747b82^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testStaticImports_pr84260() {
  } 
  
    <ajc-test dir="bugs150/pr84260" vm="1.5" title="static import failures">
        <compile files="A.java,I1.java,I2.java" options="-1.5"/>
        <run class="I1">
          <stderr>
            <line text="static method running"/>
          </stderr>
        </run>
        <run class="I2">
          <stderr>
            <line text="static method running"/>
          </stderr>
        </run>
    </ajc-test>
    

======= fetch "static ITokenSource makeTokenSource(String input, ISourceContext context) {" 743566f^:"weaver/src/org/aspectj/weaver/patterns/BasicTokenSource.java"

======= fetch "static ITokenSource makeTokenSource(String input, ISourceContext context) {" 743566f^:"weaver/src/org/aspectj/weaver/patterns/BasicTokenSource.java"

======= fetch "public TypePattern parseSingleTypePattern() {" 743566f^:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"

        // FIXME AV for Adrian - varargs need special handling since Token are 3x"." and not "..."
        // the following works for 'call(* *(int, Integer...))' but not in the general case (see testAJDKExamples test f.e.)
        // and the current code does not work for 'call(* *(int, Integer...))'
======= fetch "public List parseDottedNamePattern() {" 743566f^:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"

======= fetch "public List parseDottedNamePattern() {" 743566f^:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"

======= fetch "public List parseDottedNamePattern() {" 743566f^:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"

======= fetch "public void testMock() {" 743566f^:"weaver/testsrc/org/aspectj/weaver/patterns/VisitorTestCase.java"

    public void testTemp() {
        Pointcut.fromString("call(* *(int, Integer...))");
    }

======= fetch "public Method getAdvice() {" 3824b1c^:"runtime/src/org/aspectj/runtime/reflect/AdviceSignatureImpl.java"

======= fetch "public Method getMethod() {" 3824b1c^:"runtime/src/org/aspectj/runtime/reflect/MethodSignatureImpl.java"

    before() : call(* *(..)) && !within(Test) {
       MethodSignature sig = (MethodSignature)thisJoinPoint.getSignature();
       //sig.getDeclaringType(); // uncomment to work-around
       Method method = sig.getMethod();
   }
    public static void main(String args[]) {
    }
    public static class Inner {
    }
======= fetch "public void testInternalCompilerError_pr86832() {" 3824b1c^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testIfEvaluationExplosiion_PR94086() {
======= fetch "public void testIfEvaluationExplosiion_PR94086() {" 3824b1c^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testReflectNPE_pr94167() {
  }
  
   
  <ajc-test dir="bugs150" title="NPE in reflect implementation" pr="94167">
     <compile files="PR94167.java"/>
     <run class="reflect.PR94167"/>
  </ajc-test>

======= fetch "public static String makeLocationContext(ICompilationUnit compilationUnit, IProb" a675b65^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"

        while (((c = extract[trimLeftIndex++]) == TAB) || (c == SPACE)) {
        };

    private final static String AOP_XML = "META-INF/aop.xml";
======= fetch "private void registerDefinitions(final BcelWeaver weaver, final ClassLoader load" f14646f^:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

            Enumeration xmls = loader.getResources("/META-INF/aop.xml");
            <jvmarg value="-Daj5.def=ataspectj/aop.xml"/>
    <weaver options="-XmessageHolderClass:ataspectj.TestHelper"/>
    <aspects>
        <!-- see here nested class with ".", "$" is accepted as well -->
        <aspect name="ataspectj.SingletonAspectBindingsTest.TestAspect"/>
        <aspect name="ataspectj.CflowTest.TestAspect"/>
        <aspect name="ataspectj.PointcutReferenceTest.TestAspect"/>
        <aspect name="ataspectj.AfterXTest.TestAspect"/>
        <aspect name="ataspectj.XXJoinPointTest.TestAspect"/>
        <aspect name="ataspectj.PrecedenceTest.TestAspect_2"/>
        <aspect name="ataspectj.PrecedenceTest.TestAspect_1"/>
        <aspect name="ataspectj.PrecedenceTest.TestAspect_3"/>
        <aspect name="ataspectj.PrecedenceTest.TestAspect_Order"/>
        <aspect name="ataspectj.BindingTest.TestAspect_1"/>
        <aspect name="ataspectj.PerClauseTestAspects.TestAspectPerSingleton"/>
        <aspect name="ataspectj.PerClauseTestAspects.TestAspectPerTarget"/>
        <aspect name="ataspectj.PerClauseTestAspects.TestAspectPerCflow"/>
        <aspect name="ataspectj.PerClauseTestAspects.TestAspectPTW"/>
        <aspect name="ataspectj.AroundInlineMungerTestAspects.Open"/>
    </aspects>

    private static final SimpleLogger sl
        = new SimpleLogger();
    pointcut PC() :
        (execution(* Test.a(..)) && if (sl.isEnabled()))
        || (execution(* Test.b(..)) && if (sl.isEnabled()))
        || (execution(* Test.c(..)) && if (sl.isEnabled()))
        || (execution(* Test.d(..)) && if (sl.isEnabled()))
        || (execution(* Test.e(..)) && if (sl.isEnabled()))
        || (execution(* Test.f(..)) && if (sl.isEnabled()))
        || (execution(* Test.g(..)) && if (sl.isEnabled()))
        || (execution(* Test.h(..)) && if (sl.isEnabled()))
        || (execution(* Test.i(..)) && if (sl.isEnabled()))
        || (execution(* Test.j(..)) && if (sl.isEnabled()))
        ;
    before() : PC() {
        sl.log("Before");
    }
    after() : PC() {
        sl.log("After");
    }
        public void a() {}
        public void b() {}
        public void c() {}
        public void d() {}
        public void e() {}
        public void f() {}
        public void g() {}
        public void h() {}
        public void i() {}
        public void j() {}
        public void k() {}
        public void l() {}
        public void m() {}
        public void n() {}
        public void o() {}
        public void p() {}
    private boolean enabled;
    public SimpleLogger() {
        enabled = false;
    }
    public void disable() {
        enabled = false;
    }
    public void enable() {
        enabled = true;
    }
    public boolean isEnabled() {
        return enabled;
    }
    public void log(String str) {
        if (enabled) {
            System.out.println("> Log: " + str);
        }
    }
======= fetch "public void testInternalCompilerError_pr86832() {" 88d477d^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  /**
   * IfPointcut.findResidueInternal() was modified to make this test complete in a short amount
   * of time - if you see it hanging, someone has messed with the optimization.
   */
  public void testIfEvaluationExplosiion_PR94086() {
  }
   
   <ajc-test dir="bugs150" title="Exploding compile time with if() statements in pointcut">
     <compile files="PR94086.aj" options="-1.5"/>
   </ajc-test>
======= fetch "public String toString() {" 88d477d^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

    private boolean findingResidue = false;
======= fetch "protected Test findResidueInternal(Shadow shadow, ExposedState state) {" 88d477d^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "protected Test findResidueInternal(Shadow shadow, ExposedState state) {" 88d477d^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "protected Test findResidueInternal(Shadow shadow, ExposedState state) {" 88d477d^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "protected Test findResidueInternal(Shadow shadow, ExposedState state) {" 88d477d^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"


======= fetch "public boolean isAnnotationWithRuntimeRetention() {" f9eebd4^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

    
    pointcut doSomethingExecution() : execution(* doSomething());
    pointcut doSomethingCall() : call(* doSomething());
    
    // CE L7
    before() : doSomethingExecution() && @this(MyClassRetentionAnnotation) {
    	// should be compile-time error!
        System.out.println("How did I get here?");
    }
    
    // CE L13
    after() returning : doSomethingCall() && @target(MyClassRetentionAnnotation) {
    	// should be compile-time error!
        System.out.println("How did I get here?");
    }
    
        <compile options="-1.5" files="TestingAnnotations.java,NotRuntimeRetention.aj">
               <message kind="error" line="7" text="Annotation type MyClassRetentionAnnotation does not have runtime retention"/>
               <message kind="error" line="13" text="Annotation type MyClassRetentionAnnotation does not have runtime retention"/>
======= fetch "public void resolveBinding(World world) {" f9eebd4^:"weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.java"

        if (!annotationType.isAnnotationWithRuntimeRetention(world)) { // default is class visibility
======= fetch "public void resolveBinding(World world) {" f9eebd4^:"weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.java"


======= fetch "public void testEnumCalledEnumEtc() {" 0cb826c^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testInternalCompilerError_pr86832() {
  }
  
   
   <ajc-test dir="bugs150" title="Internal compiler error">
     <compile files="PR86832.aj" options="-1.5"/>
   </ajc-test>

======= fetch "public boolean isType() {" 7b7c7b2^:"ajdoc/src/org/aspectj/tools/ajdoc/Declaration.java"

        return getKind().equals("interface") || getKind().equals("class") || getKind().equals("aspect");
======= fetch "private static void processMembers(List/*IProgramElement*/ members, PrintWriter" 7b7c7b2^:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

======= fetch "protected String generateJavadocComment(ASTNode astNode) {" 7b7c7b2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= fetch "protected String genSourceSignature(FieldDeclaration fieldDeclaration) {" 7b7c7b2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= fetch "protected String genSourceSignature(FieldDeclaration fieldDeclaration) {" 7b7c7b2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= fetch "protected String genSourceSignature(FieldDeclaration fieldDeclaration) {" 7b7c7b2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"


        pointcut a() : cflow( execution(* *(..)) );
        before() : a() {
                System.out.println("before a");
        }
 public static void main(String [] args){
  out.println("hello world");
 }
======= fetch "public static Test suite() {" f603458^:"tests/src/org/aspectj/systemtest/ajc150/AllTestsAspectJ150.java"

 * Copyright (c) 2005 Contributors 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *   Andrew Huff - initial implementation
 *******************************************************************************/
   public static Test suite() {
     return XMLBasedAjcTestCase.loadSuite(StaticImports.class);
   }
   protected File getSpecFile() {
     return new File("../tests/src/org/aspectj/systemtest/ajc150/ajc150.xml");
   }
   
  public void testImportStaticSystemDotOut() {
   runTest("import static java.lang.System.out");
  }
======= fetch "public void testSuppression2() {" f603458^:"tests/src/org/aspectj/systemtest/ajc150/SuppressedWarnings.java"

  
  public void testSuppressionWithCflow_pr93345() {
    runTest("XLint warning for advice not applied with cflow(execution)");
  }
    <ajc-test dir="java5/staticImports" title="import static java.lang.System.out">
        <compile files="StaticImport.aj" options="-1.5"/>
    </ajc-test>
   
   <ajc-test dir="bugs150" title="XLint warning for advice not applied with cflow(execution)" pr="93345">
     <compile options="-Xlint,-1.5" files="PR93345.aj" >
       <message kind="warning" line="7" text="advice defined in AnAspect has not been applied [Xlint:adviceDidNotMatch]"/>
     </compile>
  </ajc-test>
======= fetch "public Collection weave(IClassFileProvider input) throws IOException {" f603458^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public Collection weave(IClassFileProvider input) throws IOException {" f603458^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

                  if (!ba.hasMatchedSomething()) {
                    BcelMethod meth = (BcelMethod)ba.getSignature();
                    if (meth!=null) {
                      AnnotationX[] anns = (AnnotationX[])meth.getAnnotations();
                      // Check if they want to suppress the warning on this piece of advice
               	      if (!Utility.isSuppressing(anns,"adviceDidNotMatch")) {
                        world.getLint().adviceDidNotMatch.signal(ba.getDeclaringAspect().toString(),element.getSourceLocation());
                      }
                    }

 
  private ArrayList<B> PR87282.m_Array = new ArrayList<B>();  
  public void PR87282.addB(B tmp){
    m_Array.add(tmp);
  }
    private java.util.List<Foo> PR88606.list;
    
    private void bar() {
        java.util.List<Foo> li = new PR88606().list;
    }
======= fetch "public void testPR91053() {" 51c018d^:"tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java"

   
   <ajc-test dir="java5/generics/bugs" title="Compilation error on generic member introduction" vm="1.5">
      <compile files="PR87282.aj" options="-1.5"/>
   </ajc-test>
   
   <ajc-test dir="java5/generics/bugs" title="Parameterized types on introduced fields not correctly recognized" vm="1.5">
      <compile files="PR88606.aj" options="-1.5"/>
   </ajc-test>

======= fetch "public static TypeX fromBinding(TypeBinding binding) {" 952dda9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "private TypeBinding makeTypeBinding1(TypeX typeX) {" 952dda9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "private TypeBinding makeTypeBinding1(TypeX typeX) {" 952dda9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

    private Set PR91053.aSet = new HashSet();
    public void PR91053.add(String s) {
        aSet.add(s);
    }
  public static void main(String[]argv) {
    new PR91053().add("hello");
  }
======= fetch "public void testPR91267_2() {" 952dda9^:"tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java"

    
    <ajc-test dir="java5/generics/bugs" title="Generics problem with Set" vm="1.5">
      <compile files="PR91053.aj" options="-1.5"/>
      <run class="PR91053"/>
   </ajc-test>
======= fetch "public static TypeX forParameterizedTypeNames(String name, String[] paramTypeNam" 952dda9^:"weaver/src/org/aspectj/weaver/TypeX.java"

======= fetch "public static TypeX forParameterizedTypeNames(String name, String[] paramTypeNam" 952dda9^:"weaver/src/org/aspectj/weaver/TypeX.java"

======= fetch "public String getBaseName() {" 952dda9^:"weaver/src/org/aspectj/weaver/TypeX.java"

======= fetch "public final boolean isParameterized() {" 952dda9^:"weaver/src/org/aspectj/weaver/TypeX.java"

======= fetch "public final boolean isParameterized() {" 952dda9^:"weaver/src/org/aspectj/weaver/TypeX.java"

======= fetch "public ResolvedTypeX resolve(TypeX ty, boolean allowMissing) {" 952dda9^:"weaver/src/org/aspectj/weaver/World.java"


======= fetch "public ResolvedTypeX fromTypeBindingToRTX(TypeBinding tb) {" 7389d9f^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "private static String getName(TypeBinding binding) {" 7389d9f^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "private static String getName(TypeBinding binding) {" 7389d9f^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public static TypeX fromBinding(TypeBinding binding) {" 7389d9f^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

    static <T> void addToEnv(Map<String,T> env, String key, T value) {
    }
    public static void main(String[] argv) {
      Map<String,Integer> msi = new HashMap<String,Integer>();
      addToEnv(msi,"andy",new Integer(42));
      if (msi.get("andy")!=42) throw new RuntimeException("Failed to add");
    }
    static <T> T lookupEnv(Map<String,T> env, String key) {
    }
    public static void main(String[] argv) {
      Map<String,Integer> msi = new HashMap<String,Integer>();
      msi.put("andy",42);
      if (lookupEnv(msi,"andy")!=42) throw new RuntimeException("Failed to lookup");
    }
======= fetch "public void testITDReturningParameterizedType() {" 7389d9f^:"tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java"

    
    <ajc-test dir="java5/generics/bugs/pr91267" title="NPE using generic methods in aspects 1" vm="1.5">
        <compile files="TestBug1.aj" options="-1.5"/>
        <run class="TestBug1"/>
    </ajc-test>
    
     <ajc-test dir="java5/generics/bugs/pr91267" title="NPE using generic methods in aspects 2" vm="1.5">
        <compile files="TestBug2.aj" options="-1.5"/>
        <run class="TestBug2"/>
    </ajc-test>
======= fetch "public static TypeX forName(String name) {" 7389d9f^:"weaver/src/org/aspectj/weaver/TypeX.java"

======= fetch "public static TypeX forParameterizedTypeNames(String name, String[] paramTypeNam" 7389d9f^:"weaver/src/org/aspectj/weaver/TypeX.java"

======= fetch "public static TypeX forParameterizedTypeNames(String name, String[] paramTypeNam" 7389d9f^:"weaver/src/org/aspectj/weaver/TypeX.java"


 * Copyright (c) 2005 Contributors
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *
 * Created on 25.03.2005
 * 
 * Contributors
 *  Oliver Boehm               initial implementation
 */
 * Test Aspect to check the different Xlint warnings
 */
    
    /*
     * examples for "invalidAbsoluteTypeName"
     */
 
    pointcut correctName() :
        call(String java.lang.Object.toString());
    
    pointcut wrongPackageName() :
        call(String java.xxx.Object.toString());
    
    pointcut wrongTypeName() :
        call(String java.lang.Xxx.toString());
    
    /** no warning!!! */
    pointcut wrongMethodName() :
        call(String java.lang.Object.xxx());
    
    @SuppressAjWarnings
    after() : call(String java.lang.Xxx.toString()) {
        System.out.println(thisJoinPoint);
    }
    
    
    
    /*
     * no example for "invalidWildcardTypeName"
     * 
     * Never signalled anywhere in the codebase
     * @see http://dev.eclipse.org/mhonarc/lists/aspectj-dev/msg01404.html
     */
    
    
    /*
     * example for "unresolvableMember"
     * 
     * hard to reproduce - I tried different things but at last I give up
     * @see https://bugs.eclipse.org/bugs/show_bug.cgi?id=59596#c2
     */
    
    
    
    /*
     * example for "typeNotExposedToWeaver"
     */
    
    public int Object.dummy = 0;
    
    
    
    /*
     * no example for "shadowNotInStructure"
     * 
     * Signalled if the structure model is broken, probably can't happen
     * @see http://dev.eclipse.org/mhonarc/lists/aspectj-dev/msg01404.html
     */
    
    /*
     * example for "unmatchedSuperTypeInCall"
     */
    pointcut unmatchedToStringCall() :
        call(String Car.toString());
    pointcut matchedToStringCall() :
        call(String Object.toString()) && target(Car);
    
    before() : unmatchedToStringCall() && !within(XlintTest) {
        System.out.println(thisJoinPoint);
    }
        
    @SuppressAjWarnings
    before() : call(String Car.toString()) {
        System.out.println(thisJoinPoint);
    }
    
    @SuppressAjWarnings({"adviceDidNotMatch"})
    before() : call(* java.lang.String.helloWorld()) {
        System.out.println(thisJoinPoint);
    }
    
        
    /*
     * example for "canNotImplementLazyTjp"
     * 
     * This example is from the README-12.html. To get the warning you must
     * compile it with "-XlazyTjp"
     * 
     * NOTE: The expected warnung does not appear. I don't know why.
     *       Here is the commandline:
     *       ajc -XlazyTjp -Xlint:warning -inpath src -d classes src
     */
    
    public static boolean enabled = false;
    
    pointcut toBeTraced() : execution(* *(..)) && !within(XlintTest);
    Object around() : toBeTraced() && if(enabled) {
        Object[] args = thisJoinPoint.getArgs();
        System.out.println(thisJoinPoint + ", arg's: " + args.length);
        return proceed();
    }
    
    
    /*
     * example for "needsSerialVersionUIDField"
     */
    
    declare parents : Main implements java.io.Serializable;
    
    
    
    /*
     * example for "brokeSerialVersionCompatibility"
     * 
     * NOTE: I don't see this warning inside Eclipse with 
     *      AJDT 1.2.0.20050308091611 although I activate the warning
     *      via the project properties.
     *      I see it only when I start the compiler from the commandline
     *      (ajc -XlazyTjp -Xlint:warning -inpath src -d classes src/x/...)
     */
    public int Car.breakSerial = 1;
    
    
    /*
     * example for "noInterfaceCtorJoinpoint"
     */
    
    pointcut interfaceConstructor() :
        execution(java.util.List.new());
    
    /**
     * @param args
     */
    public static void main(String[] args) {
        new Main().run();
        Long l = new Long(1);
        String s = l.toString();
    }
    
    public void run() {
        new Car().toString();
    }
======= fetch "public void test019(){" 70b9ffd^:"tests/src/org/aspectj/systemtest/xlint/XLintTests.java"

  
  public void test020(){
     runTest("7 lint warnings");
  }
   <ajc-test dir="bugs/seven/lint" title="7 lint warnings" pr="91719">
  <compile options="-1.5" files="Main.java">
   <message kind="warning" line="31"  text="no match for this type name: java.xxx.Object [Xlint:invalidAbsoluteTypeName]">
   </message> 
   <message kind="warning" line="34"  text="no match for this type name: java.lang.Xxx [Xlint:invalidAbsoluteTypeName]">
   </message>
   <message kind="warning" line="41"  text="no match for this type name: java.lang.Xxx [Xlint:invalidAbsoluteTypeName]">
   </message>
   <message kind="warning" line="69"  text="this affected type is not exposed to the weaver: java.lang.Object [Xlint:typeNotExposedToWeaver]">
   </message>
   <message kind="warning" line="87"  text="does not match because declaring type is java.lang.Object, if match desired use target(Car) [Xlint:unmatchedSuperTypeInCall]">
   </message>
   <message kind="warning" line="92"  text="advice defined in XlintTest has not been applied [Xlint:adviceDidNotMatch]">
   </message>
   <message kind="warning" line="157"  text="no interface constructor-execution join point - use java.util.List+ for implementing classes [Xlint:noInterfaceCtorJoinpoint]">
   </message>
  </compile>
  </ajc-test>

  declare @type : Test : @anInterface;
  declare @constructor : Test.new(String,int) : @anInterface;
  declare @method : int Test.fac(int) : @anInterface;
  declare @field : int Test.a : @anInterface;
  public Test(String say, int something){
    System.out.println(say + something);
  }
  public int fac(int n){
   return (n == 0)? 1 : n * fac(n-1);
  }
  public int a = 1;
======= fetch "protected void tearDown() throws Exception {" abc9a58^:"ajde/testsrc/org/aspectj/ajde/ShowWeaveMessagesTestCase.java"

======= fetch "public void testWeaveMessagesDeclareSoft() {" abc9a58^:"ajde/testsrc/org/aspectj/ajde/ShowWeaveMessagesTestCase.java"

======= fetch "private void compareWeaveMessages(File f) {" abc9a58^:"ajde/testsrc/org/aspectj/ajde/ShowWeaveMessagesTestCase.java"

======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" abc9a58^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

                    
======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" abc9a58^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtField(LazyClassGen clazz) {" abc9a58^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtField(LazyClassGen clazz) {" abc9a58^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public void weaveParentTypeMungers(ResolvedTypeX onType) {" abc9a58^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "private boolean applyDeclareAtType(DeclareAnnotation decA, ResolvedTypeX onType," abc9a58^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "private boolean applyDeclareAtType(DeclareAnnotation decA, ResolvedTypeX onType," abc9a58^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "private Utility() {" abc9a58^:"weaver/src/org/aspectj/weaver/bcel/Utility.java"


======= fetch "public boolean accept(File dir, String name) {" 02f75ba^:"weaver/src/org/aspectj/weaver/bcel/UnwovenClassFile.java"


        public static final Kind DECLARE_WARNING       = new Kind("declare warning");
        public static final Kind DECLARE_ERROR         = new Kind("declare error");
        public static final Kind DECLARE_SOFT          = new Kind("declare soft");
        public static final Kind DECLARE_INTER_TYPE    = new Kind("inter-type declaration");
    public static final String SOFTENS = "softens";
    public static final String SOFTENED_BY = "softened by"; 
    public static final String MATCHED_BY = "matched by";
======= fetch "public void adviceMunger(IHierarchy model, Shadow shadow, ShadowMunger munger) {" 7a61380^:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

                    String targetHandle = targetNode.getHandleIdentifier(); 
                    if (advice.getKind().equals(AdviceKind.Softener)) {
                        IRelationship foreward = mapper.get(adviceHandle, IRelationship.Kind.DECLARE_SOFT, SOFTENS,runtimeTest,true);
                        if (foreward != null) foreward.addTarget(targetHandle);//foreward.getTargets().add(targetHandle);
                        
                        IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE, SOFTENED_BY,runtimeTest,true);
                        if (back != null)     back.addTarget(adviceHandle);//back.getTargets().add(adviceHandle);
                    } else {
    					IRelationship foreward = mapper.get(adviceHandle, IRelationship.Kind.ADVICE, ADVISES,runtimeTest,true);
    					if (foreward != null) foreward.addTarget(targetHandle);//foreward.getTargets().add(targetHandle);
    					
    					IRelationship back = mapper.get(targetHandle, IRelationship.Kind.ADVICE, ADVISED_BY,runtimeTest,true);
    					if (back != null)     back.addTarget(adviceHandle);//back.getTargets().add(adviceHandle);
                    }
                }

  public static void main(String[] args) {
    C a = new C();
    abc(a);
  }
  static void abc(C y) {}
  before(Ann ann) : call(* Test3.*(..)) && @args(ann) { }
======= fetch "public void testAnnotationBindingAndITDs7_asmtest() {" 3f942a4^:"tests/src/org/aspectj/systemtest/ajc150/AnnotationBinding.java"

  
  public void testAnnotationBindingArgsVerifyError_pr92053() {
  }  
    
    <ajc-test dir="java5/annotations/binding/bugs" title="AtArgs causes a VerifyError: Unable to pop operand off an empty stack" vm="1.5">
        <compile files="Test3.java" options="-1.5"/>
        <run class="Test3"/>
    </ajc-test>
======= fetch "protected Test findResidueInternal(Shadow shadow, ExposedState state) {" 3f942a4^:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= fetch "protected Test findResidueInternal(Shadow shadow, ExposedState state) {" 3f942a4^:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"


======= fetch "public void postParse(TypeDeclaration typeDec) {" 78abc76^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/DeclareAnnotationDeclaration.java"

  declare @Type: A : @myInterface;
======= fetch "public void testStructureModel() {" 78abc76^:"tests/src/org/aspectj/systemtest/ajc150/DeclareAnnotationTests.java"

    <ajc-test dir="bugs150" pr="83645" title="pertypewithin({interface}) illegal field modifier">
        <compile files="PR83645.java"/>
        <run class="PR83645"/>
    </ajc-test>
======= fetch "public Declare parseDeclareAnnotation() {" 78abc76^:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"


    private IElementHandleProvider handleProvider;
======= fetch "protected AsmManager() {" df7fff4^:"asm/src/org/aspectj/asm/AsmManager.java"

        handleProvider = new FullPathHandleProvider(); 
======= fetch "private void notifyListeners() {" df7fff4^:"asm/src/org/aspectj/asm/AsmManager.java"

    public IElementHandleProvider getHandleProvider() {
        return handleProvider;
    }
    
    public void setHandleProvider(IElementHandleProvider handleProvider) {
        this.handleProvider = handleProvider;
    }
    
======= fetch "public static ModelInfo summarizeModel() {" df7fff4^:"asm/src/org/aspectj/asm/AsmManager.java"

 * Copyright (c) 2003 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Mik Kersten     initial implementation 
 * ******************************************************************/
 * Adapter used to uniquely identify program element handles.  Can be
 * implemented and overridden in @see{AsmManager} in order to provide
 * IDE-specific mechanisms of identifying elements.  For example, AJDT
 * uses workspace-relative paths that are understood by its JavaCore 
 * class.  
 * 
 * @author Mik Kersten
 */
    /**
     * @return  a String uniquely identifying this element
     */
    public String createHandleIdentifier(ISourceLocation location);
    /**
     * @return  a String uniquely identifying this element
     */
    public String createHandleIdentifier(File sourceFile, int line,int column,int offset);
    /**
     * NOTE: this is necessary for the current implementation to look up nodes, 
     * but we may want to consider removing it.
     * 
     * @return a String corresponding to the  
     */
    public String getFileForHandle(String handle);
    
    /**
     * NOTE: this is necessary for the current implementation to look up nodes, 
     * but we may want to consider removing it.
     * 
     * @return the line number corresponding to this handel
     */
    public int getLineNumberForHandle(String handle);
    
======= fetch "public IProgramElement getElement(String handle) {" df7fff4^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

        // int col = new Integer(st.nextToken()).intValue(); TODO: use column number when available
        String file = AsmManager.getDefault().getHandleProvider().getFileForHandle(handle); // st.nextToken();
        int line = AsmManager.getDefault().getHandleProvider().getLineNumberForHandle(handle); // st.nextToken();
        
        String canonicalSFP = AsmManager.getDefault().getCanonicalFilePath(new File(file));
======= fetch "public IProgramElement findElementForHandle(String handle) {" df7fff4^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= fetch "public IProgramElement findElementForHandle(String handle) {" df7fff4^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

        String file = AsmManager.getDefault().getHandleProvider().getFileForHandle(handle); // st.nextToken();
        int line = AsmManager.getDefault().getHandleProvider().getLineNumberForHandle(handle); // st.nextToken();
        
 * Copyright (c) 2003 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Mik Kersten     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
    static final String ID_DELIM = "|";
    
    public String createHandleIdentifier(ISourceLocation location) {
        StringBuffer sb = new StringBuffer();
        sb.append(AsmManager.getDefault()
                            .getCanonicalFilePath(location.getSourceFile()));
        sb.append(ID_DELIM);
        sb.append(location.getLine());
        sb.append(ID_DELIM);
        sb.append(location.getColumn());
        sb.append(ID_DELIM);
        sb.append(location.getOffset());
        return sb.toString();
    }
    
    public String createHandleIdentifier(File sourceFile, int line,int column,int offset) {
        StringBuffer sb = new StringBuffer();
        sb.append(AsmManager.getDefault().getCanonicalFilePath(sourceFile));
        sb.append(ID_DELIM);
        sb.append(line);
        sb.append(ID_DELIM);
        sb.append(column);
        sb.append(ID_DELIM);
        sb.append(offset);
        return sb.toString();       
    }
    public String getFileForHandle(String handle) {
        StringTokenizer st = new StringTokenizer(handle, ID_DELIM);
        String file = st.nextToken();
        return file;
    }
    public int getLineNumberForHandle(String handle) {
        StringTokenizer st = new StringTokenizer(handle, ID_DELIM);
        st.nextToken(); // skip over the file
        return new Integer(st.nextToken()).intValue();
    }
======= fetch "public String toLabelString() {" df7fff4^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String getHandleIdentifier() {" df7fff4^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

                return AsmManager.getDefault().getHandleProvider().createHandleIdentifier(sourceLocation);
======= fetch "public String getHandleIdentifier() {" df7fff4^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public void addDeclareParentsRelationship(ISourceLocation decp," df7fff4^:"docs/sandbox/api-clients/org/aspectj/samples/AsmRelationshipMapExtensionTest.java"

    		String sourceHandle = ProgramElement.createHandleIdentifier(
======= fetch "public void addDeclareParentsRelationship(ISourceLocation decp," df7fff4^:"docs/sandbox/api-clients/org/aspectj/samples/AsmRelationshipMapExtensionTest.java"

    		String superHandle = ProgramElement.createHandleIdentifier(
======= fetch "public void addRelationship(" df7fff4^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AsmInterTypeRelationshipProvider.java"

======= fetch "public void addRelationship(" df7fff4^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AsmInterTypeRelationshipProvider.java"

======= fetch "private void addUsesPointcutRelationsForNode(IProgramElement peNode, List namedP" df7fff4^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

                foreward.addTarget(ProgramElement.genHandleIdentifier(member.getSourceLocation()));            
======= fetch "private void addUsesPointcutRelationsForNode(IProgramElement peNode, List namedP" df7fff4^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

                IRelationship back = AsmManager.getDefault().getRelationshipMap().get(ProgramElement.genHandleIdentifier(member.getSourceLocation()), IRelationship.Kind.USES_POINTCUT, "pointcut used by", false, true);
======= fetch "public void checkerMunger(IHierarchy model, Shadow shadow, Checker checker) {" df7fff4^:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

======= fetch "public void checkerMunger(IHierarchy model, Shadow shadow, Checker checker) {" df7fff4^:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

======= fetch "public void addRelationship(" df7fff4^:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

======= fetch "public void addRelationship(" df7fff4^:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

======= fetch "public void addRelationship(" df7fff4^:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

======= fetch "public void addDeclareParentsRelationship(ISourceLocation decp,ResolvedTypeX tar" df7fff4^:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

======= fetch "public void addDeclareParentsRelationship(ISourceLocation decp,ResolvedTypeX tar" df7fff4^:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

======= fetch "public void addDeclareAnnotationRelationship(ISourceLocation declareAnnotationLo" df7fff4^:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

======= fetch "public void addDeclareAnnotationRelationship(ISourceLocation declareAnnotationLo" df7fff4^:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

======= fetch "public void addDeclareAnnotationRelationship(ISourceLocation sourceLocation, Str" df7fff4^:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

            AsmManager.getDefault().getHandleProvider().createHandleIdentifier(sourceLocation.getSourceFile(),sourceLocation.getLine(),
======= fetch "public void addDeclareAnnotationRelationship(ISourceLocation sourceLocation, Str" df7fff4^:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

            AsmManager.getDefault().getHandleProvider().createHandleIdentifier(sourceLocation.getSourceFile(),sourceLocation.getLine(),
======= fetch "public String getHandle() {" df7fff4^:"weaver/src/org/aspectj/weaver/ShadowMunger.java"


 public static Test suite() {
   return XMLBasedAjcTestCase.loadSuite(KnownfailuresTests.class);
 }
 protected File getSpecFile() {
   return new File("../tests/src/org/aspectj/systemtest/knownfailures/knownfailures.xml");
 }
 public void test001(){
   runTest("NullPointerException in jdt when using generics and inpath");
   // the NPE goes away if you don't use generics
 }
    
    <ajc-test dir="bugs150/pr90588"
        <compile files="AbstractClass.java,ConcreteClass.java">
        </compile>
    </ajc-test>

======= fetch "boolean prepareForNextBuild(AjBuildConfig newBuildConfig) {" e460b1e^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "public boolean accept(File pathname) {" e460b1e^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean pathChange(AjBuildConfig oldConfig, AjBuildConfig newConfig) {" e460b1e^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean pathChange(AjBuildConfig oldConfig, AjBuildConfig newConfig) {" e460b1e^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean pathChange(AjBuildConfig oldConfig, AjBuildConfig newConfig) {" e460b1e^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean pathChange(AjBuildConfig oldConfig, AjBuildConfig newConfig) {" e460b1e^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean pathChange(AjBuildConfig oldConfig, AjBuildConfig newConfig) {" e460b1e^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean changed(List oldPath, List newPath, boolean checkClassFiles) {" e460b1e^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "protected void addDependentsOf(File sourceFile) {" e460b1e^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

 * Copyright (c) 2005 IBM and other contributors
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Andy Clement     initial implementation 
 * ******************************************************************/
 * Implementations of this interface get told interesting information about
 * decisions made in AjState objects.  Should help us improve incremental
 * compilation, and ease the testing of incremental compilation!
 *
 * Not yet complete, will expand as we determine what extra useful information
 * should be recorded.
 * 
 * @author AndyClement
 */
======= fetch "public void test008() throws Exception {" e460b1e^:"tests/src/org/aspectj/systemtest/incremental/IncrementalTests.java"

  
  /**
   * See bug report 85297.  We plugged a hole so that we check whether the contents of
   * directories on the classpath have changed when deciding whether we can do an
   * incremental build or not - the implementation didn't allow for the output location
   * being on the classpath.  This test verifies the fix is OK
   */
  public void testIncrementalOKWithOutputPathOnClasspath() throws Exception {
  	    public boolean pathChange = false;
  }

======= fetch "public void testCallsAndExecutionsOfStaticMethods() {" 0d14ccf^:"tests/src/org/aspectj/systemtest/ajc150/AnnotationBinding.java"

  
  /////////////////////////////////////////////////////////////////////////////////
  // annotation binding with ITDs
  
  public void testAnnotationBindingAndITDs1() {
  	runTest("simple binding annotation values where itd method is annotated");
  }
  
  public void testAnnotationBindingAndITDs2() {
  	runTest("simple binding annotation values where itd field is annotated");
  }
 
  public void testAnnotationBindingAndITDs3() {
  	runTest("simple binding annotation values where itd ctor is annotated");
  }
  
  public void testAnnotationBindingAndITDs4() {
  	runTest("simple binding annotation values where itd method is annotated via declare");
  }  
  
  public void testAnnotationBindingAndITDs5() {
  	runTest("simple binding annotation values where itd field is annotated via declare");
  }  
  
  public void testAnnotationBindingAndITDs6() {
  	runTest("simple binding annotation values where itd field is annotated multiple times via declare");
  }  
  
  public void testAnnotationBindingAndITDs7() {
  	runTest("simple binding annotation values where itd ctor is annotated via declare");
  }  
  
======= fetch "public void testAnnotatedITDs() {" 0d14ccf^:"tests/src/org/aspectj/systemtest/ajc150/Annotations.java"

======= fetch "public void testAnnotatedITDs() {" 0d14ccf^:"tests/src/org/aspectj/systemtest/ajc150/Annotations.java"

            <message kind="warning" line="25" text="execution(@SomeAnnotation ...)"/>        
            <message kind="warning" line="28" text="execution(@SomeAnnotation ...)"/>        
            <message kind="warning" line="52" text="execution(@SomeAnnotation ...)"/>        
            <message kind="warning" line="53" text="execution(@SomeAnnotation ...)"/>    
            <stdout>
                <line text="@type System"/>
                <line text="hello AnnotationsAndITDs"/>
                <line text="goodbye String"/>
                <line text="x Object"/>
                <line text="y Integer"/>
                <line text="d Double"/>
                <line text="f Double"/>
                <line text="@type System"/>
                <line text="@cons String"/>
                <line text="@cons String"/>
                <line text="@method ITDMe2"/>
                <line text="@method ITDMe2"/>
                <line text="@field ITDMe2"/>
                <line text="@field ITDMe2"/>
            </stdout>
    <!-- ============================================================== -->
======= fetch "public NewFieldTypeMunger(ResolvedMember signature, Set superMethodsCalled) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/NewFieldTypeMunger.java"

    private Set annotationTypes = null;
======= fetch "public boolean isAjSynthetic() {" 0d14ccf^:"weaver/src/org/aspectj/weaver/ResolvedMember.java"

======= fetch "public boolean hasAnnotation(TypeX ofType) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/ResolvedMember.java"

    	return false;
======= fetch "public boolean hasAnnotation(TypeX ofType) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/ResolvedMember.java"

    	return null;
======= fetch "public boolean hasAnnotation(TypeX ofType) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/ResolvedMember.java"

======= fetch "public ResolvedMember resolve(World world) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/ResolvedMember.java"

        if (annotationTypes!=null) {
          Set r = new HashSet();
          for (Iterator iter = annotationTypes.iterator(); iter.hasNext();) {
======= fetch "public void setCheckedExceptions(TypeX[] checkedExceptions) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/ResolvedMember.java"

======= fetch "public static boolean weave(" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        List decaMs = getMatchingSubset(world.getDeclareAnnotationOnMethods(),clazz.getType());
======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

          // go through all the fields
======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

            // go through all the declare @field statements
======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtMethodCtor(LazyClassGen clazz) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private List getMatchingSubset(List declareAnnotations, ResolvedTypeX type) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private List getMatchingSubset(List declareAnnotations, ResolvedTypeX type) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private List getMatchingSubset(List declareAnnotations, ResolvedTypeX type) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

    /**
     * Get a subset of all the type mungers defined on this aspect
     */
    /**
     * Applies some set of declare @field constructs (List<DeclareAnnotation>) to some bunch 
     * of ITDfields (List<BcelTypeMunger>.  It will iterate over the fields repeatedly until
     * everything has been applied.
     * 
     */
                List forRemoval = new ArrayList();
                for (Iterator iter2 = worthRetrying.iterator(); iter.hasNext();) {
                }
     * Applies some set of declare @method/@ctor constructs (List<DeclareAnnotation>) to some bunch 
     * of ITDmembers (List<BcelTypeMunger>.  It will iterate over the fields repeatedly until
     * everything has been applied.
     */
                List forRemoval = new ArrayList();
                for (Iterator iter2 = worthRetrying.iterator(); iter.hasNext();) {
                }
======= fetch "private List getMatchingSubset(List declareAnnotations, ResolvedTypeX type) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

     * the interfieldinit method in the aspect, but the public field is placed in the target
     * type and then is processed in the 2nd pass over fields that occurs.  I think it would be
     * more expensive to avoid putting the annotation on that inserted public field than just to
     * have it put there as well as on the interfieldinit method.
======= fetch "private boolean weaveDeclareAtField(LazyClassGen clazz) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        List decaFs = getMatchingSubset(world.getDeclareAnnotationOnFields(),clazz.getType());
======= fetch "private boolean weaveDeclareAtField(LazyClassGen clazz) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        List decaFs = getMatchingSubset(allDecafs,clazz.getType());
======= fetch "private boolean weaveDeclareAtField(LazyClassGen clazz) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

          // go through all the fields
======= fetch "private boolean weaveDeclareAtField(LazyClassGen clazz) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtField(LazyClassGen clazz) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtField(LazyClassGen clazz) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean weaveDeclareAtField(LazyClassGen clazz) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean doesAlreadyHaveAnnotation(ResolvedMember rm,DeclareAnnotation de" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        world.getLint().elementAlreadyAnnotated.signal(
      		new String[]{rm.toString(),deca.getAnnotationTypeX().toString()},
      		rm.getSourceLocation(),new ISourceLocation[]{deca.getSourceLocation()});
======= fetch "private boolean doesAlreadyHaveAnnotation(ResolvedMember rm,DeclareAnnotation de" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

      	return true;
======= fetch "private boolean doesAlreadyHaveAnnotation(ResolvedMember rm,DeclareAnnotation de" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean match(LazyMethodGen mg) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private boolean match(LazyMethodGen mg) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private void matchGetInstruction(LazyMethodGen mg, InstructionHandle ih, BcelSha" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private void matchInvokeInstruction(LazyMethodGen mg," 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private void matchInvokeInstruction(LazyMethodGen mg," 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public void initializeThisAnnotationVars() {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public void initializeArgAnnotationVars() {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public void initializeKindedAnnotationVars() {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    	// FIXME asc Refactor these once all shadow kinds added - there is lots of commonality
======= fetch "public void initializeKindedAnnotationVars() {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    	TypeX relevantType = null;
======= fetch "public void initializeKindedAnnotationVars() {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    	}
    	if (getKind() == Shadow.ExceptionHandler) {
    		relevantType = getSignature().getParameterTypes()[0];
    		annotations  =  relevantType.resolve(world).getAnnotationTypes();
    	}
    	if (getKind() == Shadow.MethodCall  || getKind() == Shadow.ConstructorCall) {
======= fetch "public void initializeKindedAnnotationVars() {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    		ResolvedMember rm[] = relevantType.getDeclaredMethods(world);
    		ResolvedMember found = null;
    		String searchString = getSignature().getName()+getSignature().getParameterSignature();
    		for (int i = 0; i < rm.length && found==null; i++) {
======= fetch "public void initializeKindedAnnotationVars() {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    		annotations = found.getAnnotationTypes();
    	}
    	if (getKind() == Shadow.MethodExecution || getKind() == Shadow.ConstructorExecution || 
    		getKind() == Shadow.AdviceExecution) {
======= fetch "public void initializeKindedAnnotationVars() {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    		ResolvedMember rm[] = relevantType.getDeclaredMethods(world);
    		ResolvedMember found = null;
    		String searchString = getSignature().getName()+getSignature().getParameterSignature();
    		for (int i = 0; i < rm.length && found==null; i++) {
======= fetch "public void initializeKindedAnnotationVars() {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    		annotations = found.getAnnotationTypes();
    	}
    	if (getKind() == Shadow.PreInitialization || getKind() == Shadow.Initialization) {
======= fetch "public void initializeKindedAnnotationVars() {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    		ResolvedMember found = null;
    		String searchString = getSignature().getName()+getSignature().getParameterSignature();
    		for (int i = 0; i < rm.length && found==null; i++) {
    		annotations = found.getAnnotationTypes();
    	}
    	if (getKind() == Shadow.FieldSet) {
    		relevantType = getSignature().getDeclaringType();
    		ResolvedMember rm[] = relevantType.getDeclaredFields(world);
    		ResolvedMember found = null;
    		for (int i = 0; i < rm.length && found==null; i++) {
======= fetch "public void initializeKindedAnnotationVars() {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    		annotations = found.getAnnotationTypes();
    	}
    	if (getKind() == Shadow.FieldGet) {
======= fetch "public void initializeKindedAnnotationVars() {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    		ResolvedMember rm[] = relevantType.getDeclaredFields(world);
    		ResolvedMember found = null;
    		for (int i = 0; i < rm.length && found==null; i++) {
======= fetch "public void initializeKindedAnnotationVars() {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    		throw new BCException("Didn't recognize shadow: "+getKind());
======= fetch "public void initializeKindedAnnotationVars() {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    		kindedAnnotationVars.put(aTX,
    				new KindedAnnotationAccessVar(getKind(),aTX.resolve(world),relevantType,getSignature()));
======= fetch "public void initializeKindedAnnotationVars() {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    	
    	
======= fetch "public void initializeKindedAnnotationVars() {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    public void initializeWithinAnnotationVars() {
======= fetch "private boolean applyDeclareAtType(DeclareAnnotation decA, ResolvedTypeX onType," 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

    private AnnotationGen[]  annotations;
======= fetch "public void addAnnotation(AnnotationX ax) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    	AnnotationGen ag = new AnnotationGen(ax.getBcelAnnotation(),enclosingClass.getConstantPoolGen(),true);
    	AnnotationGen[] newAnnotations = new AnnotationGen[annotations.length+1];
    	System.arraycopy(annotations,0,newAnnotations,0,annotations.length);
    	newAnnotations[annotations.length]=ag;
    	annotations = newAnnotations;
    	// FIXME asc does this mean we are managing two levels of annotations again?
    	// one here and one in the memberView??!?
    	memberView.addAnnotation(ax);
======= fetch "public void addAnnotation(AnnotationX ax) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    
======= fetch "private void initialize() {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    	if (returnType != null) return;
======= fetch "private void initialize() {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= fetch "public MethodGen pack() {" 0d14ccf^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        if (annotations!=null) { 
          for (int i = 0, len = annotations.length; i < len; i++) {
            gen.addAnnotation(annotations[i]);
======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= fetch "protected Test findResidueInternal(Shadow shadow, ExposedState state) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= fetch "public boolean matchesAnnotations(Member member,World world) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "public boolean matchesAnnotations(Member member,World world) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "public boolean matchesIgnoringAnnotations(Member member, World world) {" 0d14ccf^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"


======= fetch "public static TypeX fromBinding(TypeBinding binding) {" fb01cad^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public void testAspectpathdirs() {" fb01cad^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testIntroSample() {
  }
  
    
    <ajc-test dir="../docs/dist/doc/examples/introduction" title="introduction sample" vm="1.5">
        <compile files="CloneablePoint.java,ComparablePoint.java,HashablePoint.java,Point.java" options="-1.5"/>
    </ajc-test>
    <!-- Generics tests -->
    <ajc-test dir="java5/generics" title="ITD with parameterized type" vm="1.5">
        <compile files="ITDReturningParameterizedType.aj" options="-1.5"/>
        <run class="ITDReturningParameterizedType"/>
    </ajc-test>
 

  
   <sect1>
      <title>Tools</title>
      
      <sect2>
          <title>Aspectpath</title>
          
          <para>AspectJ 5 allows the specification of directories (containing .class files) on the aspectpath in
              addition to jar/zip files.</para>
      </sect2>
      
    </sect1>
======= fetch "public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r" 68f6350^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

                        if (jarFile.exists() && FileUtil.hasZipSuffix(filename)) {
======= fetch "Collection getModifiedBinaryFiles(long lastBuildTime) {" 68f6350^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean pathChange(AjBuildConfig oldConfig, AjBuildConfig newConfig) {" 68f6350^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean pathChange(AjBuildConfig oldConfig, AjBuildConfig newConfig) {" 68f6350^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean pathChange(AjBuildConfig oldConfig, AjBuildConfig newConfig) {" 68f6350^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean pathChange(AjBuildConfig oldConfig, AjBuildConfig newConfig) {" 68f6350^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean pathChange(AjBuildConfig oldConfig, AjBuildConfig newConfig) {" 68f6350^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private boolean changed(List oldPath, List newPath) {" 68f6350^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "public void testVarargsInConsBug() {" 68f6350^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

    
======= fetch "public void addLibraryJarFile(File inFile) throws IOException  {" 68f6350^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public void addLibraryJarFile(File inFile) throws IOException  {" 68f6350^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public void addLibraryJarFile(File inFile) throws IOException  {" 68f6350^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public void addLibraryJarFile(File inFile) throws IOException  {" 68f6350^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

    		if (type.isAspect()) {
    			addedAspects.add(type);
    		}
======= fetch "public void addLibraryJarFile(File inFile) throws IOException  {" 68f6350^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public void addLibraryJarFile(File inFile) throws IOException  {" 68f6350^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public void addLibraryJarFile(File inFile) throws IOException  {" 68f6350^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public void addLibraryJarFile(File inFile) throws IOException  {" 68f6350^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public void addLibraryJarFile(File inFile) throws IOException  {" 68f6350^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


======= fetch "public Set couldMatchKinds() {" b0f270e^:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= fetch "public boolean alwaysTrue() {" b0f270e^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"


======= fetch "public void testSyntaxError() {" b5f4d09^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testVarargsInConsBug() {
  }
  
    <ajc-test dir="java5/varargs" title="varargs in constructor sig" vm="1.5">
        <compile files="Pr88652.aj" options="-1.5">
            <message kind="warning" line="8" text="should match"/>
            <message kind="warning" line="9" text="should match"/>        
        </compile>
    </ajc-test>
======= fetch "public ExactTypePattern(TypeX type, boolean includeSubtypes,boolean isVarArgs) {" b5f4d09^:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= fetch "private boolean isNotMatchBecauseOfVarargsIssue(TypePatternList params,int modif" b5f4d09^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "private boolean isNotMatchBecauseOfVarargsIssue(TypePatternList params,int modif" b5f4d09^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "public boolean isStarAnnotation() {" b5f4d09^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= fetch "public int getDimensions() {" b5f4d09^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"


======= fetch "private ResolvedMember getPointcutDeclaration(ReferencePointcut rp, MethodDeclar" 85aa152^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

  
  pointcut ii(I i) : execution(* I.*(..)) && this(i);
  after(I i) returning : ii(i) {
      System.out.println(i);
  }
  
======= fetch "public void testBadASMforEnums() throws IOException {" 85aa152^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void npeOnTypeNotFound() {
  }
  
    <ajc-test dir="bugs150/pr87376" title="structure model npe on type not found">
        <compile files="I.java,NPE.aj" options="-emacssym">
            <message kind="error" line="8" text="I cannot be resolved to a type"/>
            <message kind="error" line="10" text="I cannot be resolved to a type"/>
        </compile>
    </ajc-test>
    

======= fetch "private boolean matchesExactlyByName(String targetTypeName) {" f90186c^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "public TypePattern resolveBindings(IScope scope, Bindings bindings," f90186c^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

    	if (isStar()) {
======= fetch "public boolean isStar() {" f90186c^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"


    }
    
    public AST() { } 
    
    public AST(T element) {  }
======= fetch "public static Test suite() {" 5765d53^:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

 * Created on Jan 27, 2005
  */
 * @author Mik Kersten
 */
    
    private AsmManager manager = null;
 
    
======= fetch "protected void genBytecodeInfo(MethodDeclaration methodDeclaration, IProgramElem" 5765d53^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= fetch "protected void genBytecodeInfo(MethodDeclaration methodDeclaration, IProgramElem" 5765d53^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= fetch "public boolean visit(ConstructorDeclaration constructorDeclaration, ClassScope s" 5765d53^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"


 * @version $Id: MethodGen.java,v 1.2 2004/11/19 16:45:19 aclement Exp $
======= fetch "public void removeNOPs() {" 7b4c7d7^:"bcel-builder/src/org/aspectj/apache/bcel/generic/MethodGen.java"

  public String[] getArgumentNames()                   { return (String[])arg_names.clone(); }

    public static void main(String[] args) {
        new NestedTest().run();
        int c = PertypewithinTest.aspectOf(PR83563_1.class).cnt;
        if (c!=2)
          throw new RuntimeException("Expected 2 advice executions: "+c);
    }
    static class NestedTest implements Runnable {
        public void run() {
            System.out.println("Running...");
        }
    }
 
    public static int cnt = 0;
    before() : execution(* *.*(..)) {
        cnt++;
        System.out.println(thisJoinPointStaticPart);
    }	
    public void bar() {
        new Runnable() {
            public void run() {
                System.out.println("Running...");
            }
        }.run();
    }
        
    public static void main(String[] args) {
        new PR83563_2().bar();
        int c = PertypewithinTest.aspectOf(PR83563_2.class).cnt;
        if (c!=3)
          throw new RuntimeException("Expected 3 advice executions but got:"+c);
    }
 
    public static int cnt = 0;
    before() : execution(* *.*(..)) {
        cnt++;
        System.out.println(thisJoinPoint);
    }    
======= fetch "public void testCanOverrideProtectedMethodsViaITDandDecp_pr83303() {" 1b01255^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.java"

  
  public void testPerTypeWithinMissesNamedInnerTypes() {
  	CompilationResult cR = ajc(baseDir,new String[]{"PR83563_1.java"});
  	assertTrue("Should be no errors:"+cR,!cR.hasErrorMessages());
  	RunResult rR = run("PR83563_1");
  }
  
  public void testPerTypeWithinMissesAnonymousInnerTypes() {
  	CompilationResult cR = ajc(baseDir,new String[]{"PR83563_2.java"});
  	assertTrue("Should be no errors:"+cR,!cR.hasErrorMessages());
  	RunResult rR = run("PR83563_2");
  }
======= fetch "public Pointcut getTestPointcut() {" 1b01255^:"weaver/src/org/aspectj/weaver/PerTypeWithinTargetTypeMunger.java"

======= fetch "public boolean matches(ResolvedTypeX matchType, ResolvedTypeX aspectType) {" 1b01255^:"weaver/src/org/aspectj/weaver/PerTypeWithinTargetTypeMunger.java"

======= fetch "public PerClause concretize(ResolvedTypeX inAspect) {" 1b01255^:"weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java"

======= fetch "public PerClause concretize(ResolvedTypeX inAspect) {" 1b01255^:"weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java"

======= fetch "public PerClause concretize(ResolvedTypeX inAspect) {" 1b01255^:"weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java"


======= fetch "public void abstractMethodCannotBeOverridden(" 5d281fd^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

            if (!Modifier.isAbstract(sig.getModifiers())) {
  protected void m1 (){System.err.println("A.m1()");}
  public static void main(String []argv) {
    System.err.println("Hi");
    new PR83303().m1();
  }
  declare parents: PR83303 implements I;
  public void PR83303.m1(){System.err.println("ITD version of m1");}
  public void m1();
======= fetch "public void testMissingDebugInfoForGeneratedMethods_pr82570() throws ClassNotFou" 5d281fd^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.java"

  public void testCanOverrideProtectedMethodsViaITDandDecp_pr83303() {
  	CompilationResult cR = ajc(baseDir,new String[]{"PR83303.java"});
  	assertTrue("Should be no errors:"+cR,!cR.hasErrorMessages());
  }
  

    static String docVisibilityModifier;
======= fetch "static void decorateHTMLFromInputFiles(Hashtable table," b460597^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        docVisibilityModifier = docModifier;
======= fetch "static void decorateHTMLFromDecl(Declaration decl," b460597^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

            if ( (docModifier.equals("private")) || // everything
                 (docModifier.equals("package") && decl.getModifiers().indexOf( "private" ) == -1) || // package
                 (docModifier.equals("protected") && (decl.getModifiers().indexOf( "protected" ) != -1 ||
                                                        decl.getModifiers().indexOf( "public" ) != -1 )) ||
                 (docModifier.equals("public") && decl.getModifiers().indexOf( "public" ) != -1) ) {
======= fetch "static void decorateHTMLFromDecl(Declaration decl," b460597^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        // Change "Class" to "Aspect", HACK: depends on "affects:"
        int classStartIndex = fileContents.toString().indexOf("<BR>\nClass");
======= fetch "static void decorateHTMLFromDecl(Declaration decl," b460597^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        	fileContents.toString().indexOf("Advises:") != -1) {
======= fetch "static void addAspectDocumentation(IProgramElement node, StringBuffer fileBuffer" b460597^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        
======= fetch "static void insertDeclarationsSummary(StringBuffer  fileBuffer," b460597^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        if (!declsAboveVisibilityExist(decls)) return;
        
======= fetch "static void insertDeclarationsSummary(StringBuffer  fileBuffer," b460597^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

            // insert the table row accordingly
            String comment = generateSummaryComment(decl);
            String entry = "";
            if ( kind.equals( "Advice Summary" ) ) {
                entry +=
                        "<TR><TD>" +
                        "<A HREF=\"#" + generateHREFName(decl) + "\">" +
                        "<TT>" + generateAdviceSignatures(decl) +
                if (!comment.equals("")) {
                    entry += comment + "<P>";
======= fetch "static void insertDeclarationsSummary(StringBuffer  fileBuffer," b460597^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

                entry +=
                        generateAffects(decl, false) + "</TD>" +
                        "</TR><TD>\n";
            }
            else if ( kind.equals( "Pointcut Summary" ) ) {
                entry +=
                        "<TR><TD WIDTH=\"1%\">" +
                        "<FONT SIZE=-1><TT>" + genAccessibility(decl) + "</TT></FONT>" +
                        "</TD>\n" +
                        "<TD>" +
                        "<TT><A HREF=\"#" + generateHREFName(decl) + "\">" +
                        decl.toLabelString() + "</A></TT><BR>&nbsp;";
                if (!comment.equals("")) {
                    entry += comment + "<P>";
======= fetch "static void insertDeclarationsSummary(StringBuffer  fileBuffer," b460597^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

                entry +=
                        "</TR></TD>\n";
            }
            else if ( kind.equals( "Introduction Summary" ) ) {
                entry +=
                        "<TR><TD WIDTH=\"1%\">" +
                        "<FONT SIZE=-1><TT>" + decl.getModifiers() + "</TT></FONT>" +
                        "</TD>" +
                        "<TD>" +
                        "<A HREF=\"#" + generateHREFName(decl) + "\">" +
                        "<TT>introduction " + decl.toLabelString() + "</TT></A><P>" +
                        generateIntroductionSignatures(decl, false) +
                        generateAffects(decl, true);
======= fetch "static void insertDeclarationsSummary(StringBuffer  fileBuffer," b460597^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

            // insert the entry
            fileBuffer.insert(insertIndex, entry);
            insertIndex += entry.length();
======= fetch "static void insertDeclarationsSummary(StringBuffer  fileBuffer," b460597^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

    
    private static boolean declsAboveVisibilityExist(List decls) {
        boolean exist = false;
        for (Iterator it = decls.iterator(); it.hasNext();) {
            IProgramElement element = (IProgramElement) it.next();
            if (isAboveVisibility(element)) exist = true;
        }
        return exist;
    }
    private static boolean isAboveVisibility(IProgramElement element) {
        return 
            (docVisibilityModifier.equals("private")) || // everything
            (docVisibilityModifier.equals("package") && element.getAccessibility().equals(IProgramElement.Accessibility.PACKAGE)) || // package
            (docVisibilityModifier.equals("protected") && (element.getAccessibility().equals(IProgramElement.Accessibility.PROTECTED) ||
                    element.getAccessibility().equals(IProgramElement.Accessibility.PUBLIC))) ||
            (docVisibilityModifier.equals("public") && element.getAccessibility().equals(IProgramElement.Accessibility.PUBLIC));
    }
======= fetch "static void insertDeclarationsDetails(StringBuffer  fileBuffer," b460597^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        if (!declsAboveVisibilityExist(decls)) return;
======= fetch "static void insertDeclarationsDetails(StringBuffer  fileBuffer," b460597^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

            String entry = "";
            // insert the table row accordingly
            entry +=  "<A NAME=\"" + generateHREFName(decl) + "\"><!-- --></A>\n";
            if ( kind.equals( "Advice Detail" ) ) {
                entry += "<H3>" + decl.getName() + "</H3><P>";
                entry +=
                        "<TT>" +
                        generateAdviceSignatures(decl) + "</TT>\n" + "<P>" +
                        generateDetailsComment(decl) + "<P>" +
                        generateAffects(decl, false);
            }
            else if (kind.equals("Pointcut Detail")) {
                entry +=
                        "<H3>" +
                        decl.toLabelString() +
                        "</H3><P>" +
                        generateDetailsComment(decl);
            }
            else if (kind.equals("Introduction Detail")) {
            	entry += "<H3>introduction " + decl.toLabelString() + "</H3><P>";
                entry +=
                        generateIntroductionSignatures(decl, true) +
                        generateAffects(decl, true) +
                        generateDetailsComment(decl);
            }
            // insert the entry
            if (i != decls.size()-1) {
                entry += "<P><HR>\n";
            }
            else {
                entry += "<P>";
======= fetch "static void insertDeclarationsDetails(StringBuffer  fileBuffer," b460597^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

            fileBuffer.insert(insertIndex, entry);
            insertIndex += entry.length();
======= fetch "private static void processMembers(List/*IProgramElement*/ members, PrintWriter" b460597^:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

                } 
 * Created on Jan 12, 2005
 */
 * @author Mik Kersten
 */
    private pointcut privatePointcut ();
    protected pointcut protectedPointcut ();
    public pointcut publicPointcut ();
    
    private void privateMethod () {
        
    }
    
    public void protectedMethod () {
        
    }
    
    public void publicMethod () {
        
    }
 * Created on Jan 12, 2005
  */
 * @author Mik Kersten
 */
    protected File file1 = new File("testdata/bug82340/Pointcuts.java");
    protected File outdir = new File("testdata/bug82340/doc");
    
    public void testCoveragePublicMode() {
        outdir.delete();
        String[] args = { 
              "-XajdocDebug",
            "-protected",
            "-d", 
            outdir.getAbsolutePath(),
            file1.getAbsolutePath()
        };
        org.aspectj.tools.ajdoc.Main.main(args);
    }

======= fetch "static int findSummaryIndex(StringBuffer fileBuffer, int index) {" f70b383^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        if (index1 < index2) {
======= fetch "static int findSummaryIndex(StringBuffer fileBuffer, int index) {" f70b383^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        }
        else {
======= fetch "static int findSummaryIndex(StringBuffer fileBuffer, int index) {" f70b383^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        } else {
            return index;
======= fetch "static int findDetailsIndex(StringBuffer fileBuffer, int index) {" f70b383^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        int index3 = fbs.indexOf(MARKER_3, index);
        if (index1 < index2 && index1 < index3) {
======= fetch "static int findDetailsIndex(StringBuffer fileBuffer, int index) {" f70b383^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        }
        else if (index2 < index1 && index2 < index3) {
======= fetch "static int findDetailsIndex(StringBuffer fileBuffer, int index) {" f70b383^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        }
        else {
======= fetch "static int findDetailsIndex(StringBuffer fileBuffer, int index) {" f70b383^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        } else {
            return index;
 * Created on Jan 12, 2005
  */
 * @author Mik Kersten
 */
    public static boolean isExecutingOnJava5() {
        String version = System.getProperty("java.class.version","44.0");
        return version.equals("49.0");
    }
    
======= fetch "void doIt() {" f70b383^:"ajdoc/testdata/coverage/foo/ModelCoverage.java"

    declare parents: Point+ implements java.util.Observable;
======= fetch "public void testOptions() {" f70b383^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

    public void testCoveragePublicMode() {
        outdir.delete();
        String[] args = { 
            "-public",
            "-source", 
            "1.4",
            "-d", 
            outdir.getAbsolutePath(),
            file3.getAbsolutePath(),
            file9.getAbsolutePath() 
        };
        org.aspectj.tools.ajdoc.Main.main(args);
    }
    
======= fetch "public void testCoverage() {" f70b383^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

            file10.getAbsolutePath()
 * Created on Jan 12, 2005
  */
 * @author Mik Kersten
 */
    public void testIsUsing1point5() {
        assertTrue(Util.isExecutingOnJava5());
    }
    

       protected static Integer counter = new Integer(4);
       public static void main(String[] args) throws Exception {
         try {
           doSomething();
           System.err.println("TEST HAS PASSED");
         } catch (Exception e) {
           System.err.println("TEST HAS FAILED: Exception thrown by doSomething: " +e.getMessage());
           throw e;
         }
       }
       public static void doSomething() {
         int i = 0;
         while (i++<1) { 
           counter=null;
           try {
             counter = new Integer(4);
             // The inclusion of the next line changes the weaving !  If it is included the woven code is wrong and the exception escapes
              if (counter == null) { break; }
             commit();
           } catch (Throwable e) {
             System.err.println("Caught exception " + e);
           } finally {
             System.err.println("In finally block");
           }
         }
       }
       protected static void commit() throws MyException {
         System.err.println("Main.commit");
       }
   pointcut commitOperation() : call (* PR78021+.commit(..));
   before() throws MyException : commitOperation() {
        throw new MyException("Dummy My Exception", "55102");
   }
 * Created on 22.10.2004
 */
 * @author Thomas Knauth
 */
    public static void main(String[] args)
    {
        try
        {
        }
        catch ( Throwable e )
        {
            System.out.println( "exception caught!" );
            //e.printStackTrace();
        }
        finally
        {
        	System.out.println("finally block entered!");
        }
    }
  
======= fetch "public static Test suite() {" 603b063^:"tests/src/org/aspectj/systemtest/AllTests.java"

 * Copyright (c) 2004 IBM 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
 * @author colyer
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
======= fetch "public void packBody(MethodGen gen) {" 603b063^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= fetch "private static InstructionHandle remap(InstructionHandle ih, Map map) {" 603b063^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    // Update to all these comments, ASC 11-01-2005
    // The right thing to do may be to do more with priorities as
    // we create new exception handlers, but that is a relatively
    // complex task.  In the meantime, just taking account of the
    // priority here enables a couple of bugs to be fixed to do
    // with using return or break in code that contains a finally
    // block (pr78021,pr79554).
======= fetch "private static InstructionHandle remap(InstructionHandle ih, Map map) {" 603b063^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    
======= fetch "private static InstructionHandle remap(InstructionHandle ih, Map map) {" 603b063^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        l.add(0, fresh);        
    | | | catch java.lang.Throwable -> E5
    | | | catch java.lang.Throwable -> E5
    | | |       E5: ASTORE 5
    | | finally -> E4
    | | | catch java.lang.Exception -> E3
    | | | catch java.lang.Exception -> E3
    | | |       E3: ASTORE_2   (line 12)
    | | finally -> E4
    | |         E4: ASTORE 4   (line 14)
    | | | catch java.lang.Throwable -> E5
    | | | catch java.lang.Throwable -> E5
    | | |       E5: ASTORE 5
    | | finally -> E4
    | | | catch java.lang.Exception -> E3
    | | | catch java.lang.Exception -> E3
    | | |       E3: ASTORE_2   (line 12)
    | | finally -> E4
    | |         E4: ASTORE 4   (line 14)
    | | catch java.lang.Throwable -> E2
    | | catch java.lang.Throwable -> E2
    | |         E2: ASTORE 5
    | finally -> E1
    | | catch java.lang.Exception -> E0
    | | catch java.lang.Exception -> E0
    | |         E0: ASTORE_2   (line 12)
    | finally -> E1
    |           E1: ASTORE 4   (line 14)

======= fetch "public static Test suite() {" 797b6a6^:"tests/src/org/aspectj/systemtest/ajc150/AllTestsJava5_binaryWeaving.java"

 * Copyright (c) 2004 IBM 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
 * Checks if we are obeying migration rules. 
 */
  protected void setUp() throws Exception {
  }
  /**
   * Compile a simple java class with an aspect library built with aspectj 1.2.1 - this
   * checks that we can load in attributes (especially pointcuts) that were written out
   * in the 'old way'
   *
   */
  public void testMigrationFrom121_pointcutsAndAdvice() {
  	CompilationResult cR = ajc(baseDir,new String[]{"-aspectpath","aspects121.jar","Program.java"});
  	System.err.println(cR.getStandardError());
  	assertTrue("Should not coredump: "+cR.getStandardError(),cR.getStandardError().indexOf("Dumping to ajcore")==-1);
    assertTrue("Should be no error messages: \n"+cR.getErrorMessages(),cR.getErrorMessages().size()==0);
    File f = new File(ajc.getSandboxDirectory()+File.separator+"Program.class");
    assertTrue("Missing class file",f.exists());
  	run("Program");
  }
  
 
======= fetch "public AdviceKind(String name, int key, int precedence, boolean isAfter, boolean" 797b6a6^:"weaver/src/org/aspectj/weaver/AdviceKind.java"

    public static AdviceKind read(DataInputStream s) throws IOException {
======= fetch "public static AjAttribute read(String name, byte[] bytes, ISourceContext context" 797b6a6^:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= fetch "public WeaverStateInfo reify() {" 797b6a6^:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= fetch "public WeaverStateInfo reify() {" 797b6a6^:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= fetch "public WeaverStateInfo reify() {" 797b6a6^:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= fetch "public static WeaverVersionInfo read(DataInputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= fetch "public AdviceAttribute(AdviceKind kind, Pointcut pointcut, int extraArgumentFlag" 797b6a6^:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.java"

 * Copyright (c) 2005 IBM
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Andy Clement           initial implementation
 * ******************************************************************/
 * Lightweight subclass of DataInputStream that knows what version of the weaver was used to construct the data in it.
 */
======= fetch "public static void setReweavableModeDefaults(boolean mode, boolean compress) {" 797b6a6^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public static List readAjAttributes(Attribute[] as, ISourceContext context,IMess" 797b6a6^:"weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java"

======= fetch "public static List readAjAttributes(Attribute[] as, ISourceContext context,IMess" 797b6a6^:"weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java"

======= fetch "private void unpackAttributes(World world) {" 797b6a6^:"weaver/src/org/aspectj/weaver/bcel/BcelField.java"

======= fetch "private void unpackAjAttributes(World world) {" 797b6a6^:"weaver/src/org/aspectj/weaver/bcel/BcelMethod.java"

======= fetch "private void unpackAspectAttributes() {" 797b6a6^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "private void unpackAspectAttributes() {" 797b6a6^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "private void unpackAspectAttributes() {" 797b6a6^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "private void printAspectAttributes(PrintStream out) {" 797b6a6^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= fetch "public AnnotationTypePattern resolveBindings(IScope scope," 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/AndAnnotationTypePattern.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/AndPointcut.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/AndTypePattern.java"

======= fetch "public int hashCode() {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= fetch "public AnnotationTypePattern resolveBindings(IScope scope, Bindings bindings," 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.java"

======= fetch "public void write(DataOutputStream out) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/BindingTypePattern.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/DeclareParents.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java"

======= fetch "public void write(DataOutputStream out) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

    }
======= fetch "public static TypePattern read(DataInputStream s, ISourceContext context) throws" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

    public String toString() {
======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

======= fetch "public boolean matches(int modifiers) {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/ModifiersPattern.java"

======= fetch "public void write(DataOutputStream out) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/NamePattern.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/NotAnnotationTypePattern.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/NotPointcut.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/NotTypePattern.java"

======= fetch "public AnnotationTypePattern resolveBindings(IScope scope," 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/OrAnnotationTypePattern.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/OrPointcut.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/OrTypePattern.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/PerCflow.java"

======= fetch "public final Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/PerClause.java"

        public static Kind read(DataInputStream s) throws IOException {
======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/PerObject.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/PerSingleton.java"

======= fetch "public void postRead(ResolvedTypeX enclosingType) {}" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "public static SignaturePattern read(DataInputStream s, ISourceContext context) t" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= fetch "private boolean matchesAny(TypePattern typePattern, Class[] types) {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java"

======= fetch "public TypePattern remapAdviceFormals(IntMap bindings) {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= fetch "public int hashCode() {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/TypePatternList.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

    }
    public static TypePattern readTypePattern150(VersionedDataInputStream s, ISourceContext context) throws IOException {
    
======= fetch "public static TypePattern read(DataInputStream s, ISourceContext context) throws" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "public static TypePattern read(DataInputStream s, ISourceContext context) throws" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 797b6a6^:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

======= fetch "public void checkSerialize(Pointcut p) throws IOException {" 797b6a6^:"weaver/testsrc/org/aspectj/weaver/bcel/PatternWeaveTestCase.java"

======= fetch "public void checkSerialize(Pointcut p) throws IOException {" 797b6a6^:"weaver/testsrc/org/aspectj/weaver/bcel/PointcutResidueTestCase.java"

======= fetch "private void checkSerialization(String string) throws IOException {" 797b6a6^:"weaver/testsrc/org/aspectj/weaver/patterns/AndOrNotTestCase.java"

======= fetch "private void checkSerialization(Declare declare) throws IOException {" 797b6a6^:"weaver/testsrc/org/aspectj/weaver/patterns/DeclareErrorOrWarningTestCase.java"

======= fetch "private void checkSerialization(String string) throws IOException {" 797b6a6^:"weaver/testsrc/org/aspectj/weaver/patterns/ModifiersPatternTestCase.java"

======= fetch "private void checkSerialization(NamePattern p) throws IOException {" 797b6a6^:"weaver/testsrc/org/aspectj/weaver/patterns/NamePatternTestCase.java"

======= fetch "private void checkSerialization(SignaturePattern p) throws IOException {" 797b6a6^:"weaver/testsrc/org/aspectj/weaver/patterns/SignaturePatternTestCase.java"

======= fetch "private void checkSerialization(String string) throws IOException {" 797b6a6^:"weaver/testsrc/org/aspectj/weaver/patterns/TypePatternListTestCase.java"

======= fetch "private void checkSerialization(String string) throws IOException {" 797b6a6^:"weaver/testsrc/org/aspectj/weaver/patterns/TypePatternTestCase.java"

======= fetch "private void checkSerialization(Pointcut p) throws IOException {" 797b6a6^:"weaver/testsrc/org/aspectj/weaver/patterns/WithinTestCase.java"


======= fetch "public void test002_AtAnnotationMatching() {" 8a8930f^:"tests/src/org/aspectj/systemtest/ajc150/AnnotationPointcutsTests.java"

  public void test003_Within_Code() {
  	baseDir = new File("../tests/java5/annotations/within_code");
      CompilationResult cR = binaryWeave("TestingAnnotations.jar","WithinAndWithinCodeTests.java",0,5);
      List warnings = new ArrayList();
      warnings.add(new Message(32,"@within match on non-inherited annotation"));
      warnings.add(new Message(39,"@within match on non-inherited annotation"));
      warnings.add(new Message(39,"@within match on inheritable annotation"));
      warnings.add(new Message(43,"@within match on inheritable annotation"));
      warnings.add(new Message(32,"@withincode match"));
      MessageSpec mSpec = new MessageSpec(warnings,new ArrayList());
      assertMessages(cR,mSpec); 	
  }
  
  public void test004_Within() {
    	baseDir = new File("../tests/java5/annotations/within");
        CompilationResult cR = binaryWeave("PlainWithin.jar","PlainWithinTests.java",0,2);
        List warnings = new ArrayList();
        warnings.add(new Message(21,"positive within match on annotation"));
        warnings.add(new Message(25,"negative within match on annotation"));
        MessageSpec mSpec = new MessageSpec(warnings,new ArrayList());
        assertMessages(cR,mSpec); 	
    }
======= fetch "public void test002_AtAnnotationMatching() {" 8a8930f^:"tests/src/org/aspectj/systemtest/ajc150/AnnotationPointcutsTests.java"

  // 1) @within  (matches, does not match, matches inherited annotation)
  // 2) @withincode (matches, does not match)
======= fetch "public void test006_CantUseinDecEoW() {" 8a8930f^:"tests/src/org/aspectj/systemtest/ajc150/AnnotationRuntimeTests.java"

    public void test007_Within_Code() {
    	baseDir = new File("../tests/java5/annotations/within_code");
        CompilationResult cR = binaryWeave("TestingAnnotations.jar","WithinAndWithinCodeTests.java",0,5);
        List warnings = new ArrayList();
        warnings.add(new Message(32,"@within match on non-inherited annotation"));
        warnings.add(new Message(39,"@within match on non-inherited annotation"));
        warnings.add(new Message(39,"@within match on inheritable annotation"));
        warnings.add(new Message(43,"@within match on inheritable annotation"));
        warnings.add(new Message(32,"@withincode match"));
        MessageSpec mSpec = new MessageSpec(warnings,new ArrayList());
        assertMessages(cR,mSpec); 	
    }
======= fetch "public static AnnotationTypePattern read(DataInputStream s, ISourceContext conte" 8a8930f^:"weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java"

    public FuzzyBoolean fastMatches(AnnotatedElement annotated) {
        return FuzzyBoolean.YES;
    }
    
======= fetch "public void resolve(World world) {" 8a8930f^:"weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java"

======= fetch "protected boolean matchesExactly(ResolvedTypeX matchType) {" 8a8930f^:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= fetch "public FuzzyBoolean matchesInstanceof(ResolvedTypeX matchType) {" 8a8930f^:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= fetch "public FuzzyBoolean matchesInstanceof(ResolvedTypeX matchType) {" 8a8930f^:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" 8a8930f^:"weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"

======= fetch "public final FuzzyBoolean matches(ResolvedTypeX type, MatchKind kind) {" 8a8930f^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= fetch "public final FuzzyBoolean matches(ResolvedTypeX type, MatchKind kind) {" 8a8930f^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= fetch "public final FuzzyBoolean matches(ResolvedTypeX type, MatchKind kind) {" 8a8930f^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= fetch "public TypePattern resolveBindingsFromRTTI(boolean allowBindng, boolean requireE" 8a8930f^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

    public void resolve(World world) {
        annotationPattern.resolve(world);
    }
    
======= fetch "protected boolean matchesExactly(ResolvedTypeX type) {" 8a8930f^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "private FuzzyBoolean isWithinType(ResolvedTypeX type) {" 8a8930f^:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= fetch "public FuzzyBoolean fastMatch(FastMatchInfo info) {" 8a8930f^:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= fetch "protected FuzzyBoolean matchInternal(Shadow shadow) {" 8a8930f^:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"


======= fetch "private WeaveMessage(String message) {" 9897659^:"bridge/src/org/aspectj/bridge/WeaveMessage.java"

======= fetch "private WeaveMessage(String message) {" 9897659^:"bridge/src/org/aspectj/bridge/WeaveMessage.java"

     * @return new weaving message
     */
    /**
     * Static helper method for constructing weaving messages.
     * @param kind what kind of message (e.g. declare parents)
     * @param inserts inserts for the message (inserts are marked %n in the message)
======= fetch "public static WeaveMessage constructWeavingMessage(" 9897659^:"bridge/src/org/aspectj/bridge/WeaveMessage.java"

======= fetch "public static WeaveMessage constructWeavingMessage(" 9897659^:"bridge/src/org/aspectj/bridge/WeaveMessage.java"

======= fetch "public static WeaveMessage constructWeavingMessage(" 9897659^:"bridge/src/org/aspectj/bridge/WeaveMessage.java"

======= fetch "public static WeaveMessage constructWeavingMessage(" 9897659^:"bridge/src/org/aspectj/bridge/WeaveMessage.java"

======= fetch "private void reportWeavingMessage(ShadowMunger munger) {" 9897659^:"weaver/src/org/aspectj/weaver/Shadow.java"

======= fetch "private void reportWeavingMessage(ShadowMunger munger) {" 9897659^:"weaver/src/org/aspectj/weaver/Shadow.java"

======= fetch "private void reportWeavingMessage(ShadowMunger munger) {" 9897659^:"weaver/src/org/aspectj/weaver/Shadow.java"

======= fetch "public boolean munge(BcelClassWeaver weaver) {" 9897659^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "public boolean munge(BcelClassWeaver weaver) {" 9897659^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

        					 fName+":'"+munger.getSignature()+"'"}));
======= fetch "private boolean mungeNewField(BcelClassWeaver weaver, NewFieldTypeMunger munger)" 9897659^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "public ResolvedTypeX resolve(Type t) {" 9897659^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"


======= fetch "public void checkerMunger(IHierarchy model, Shadow shadow, Checker checker) {" 427c0d3^:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"


======= fetch "public void completeTypeBindings() {" 9052d5d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "public void completeTypeBindings() {" 9052d5d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "public void completeTypeBindings() {" 9052d5d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

        
======= fetch "public void completeTypeBindings() {" 9052d5d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, Collection" 9052d5d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

  declare parents: A+ implements java.io.Serializable;
======= fetch "protected File getSpecFile() {" 9052d5d^:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void test() {
  	// placeholder for the first test...
    

       <!-- run appliaction with LTW to add tracing -->
======= fetch "private List getFullClassPath (ClassLoader loader) {" edd6539^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "private void init(List classPath, List aspectPath) {" edd6539^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "private void init(List classPath, List aspectPath) {" edd6539^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public void addURL(URL url) {" edd6539^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public void addURL(URL url) {" edd6539^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public void addURL(URL url) {" edd6539^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public void addURL(URL url) {" edd6539^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "private boolean shouldWeave (String name) {" edd6539^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "private void registerAspectLibraries(List aspectPath) {" edd6539^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "private void registerAspectLibraries(List aspectPath) {" edd6539^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "private static List makeClasspath(String cp) {" edd6539^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "private static List makeClasspath(String cp) {" edd6539^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "private static List makeClasspath(String cp) {" edd6539^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public boolean handleMessage(IMessage message) throws AbortException {" edd6539^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public boolean handleMessage(IMessage message) throws AbortException {" edd6539^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public boolean handleMessage(IMessage message) throws AbortException {" edd6539^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public WeavingURLClassLoaderTest(String name) {" edd6539^:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= fetch "public void testLoadClass () {" edd6539^:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= fetch "public void testLoadWovenClass () {" edd6539^:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= fetch "public void testWeaveWovenClass () {" edd6539^:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= fetch "public void testWeaveAdvice () {" edd6539^:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= fetch "public void testWeaveDeclareWarningAdvice () {" edd6539^:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= fetch "public void testWeaveDeclareErrorAdvice () {" edd6539^:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= fetch "public void testWeaveAroundClosure () {" edd6539^:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= fetch "public void testJunkJar () {" edd6539^:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= fetch "public void testIncompletePath () {" edd6539^:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= fetch "public void testPackage () {" edd6539^:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= fetch "public static void invokeMain (Class clazz, String[] args)" edd6539^:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"


======= fetch "private List findMatchesHelper(" aab9c2c^:"ajde/src/org/aspectj/ajde/ui/StructureSearchManager.java"


======= fetch "public static AjAttribute read(String name, byte[] bytes, ISourceContext context" 6aa7516^:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= fetch "public static AjAttribute read(String name, byte[] bytes, ISourceContext context" 6aa7516^:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= fetch "public WeaverStateInfo reify() {" 6aa7516^:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= fetch "public static List readAjAttributes(Attribute[] as, ISourceContext context) {" 6aa7516^:"weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java"

======= fetch "private void unpackAttributes(World world) {" 6aa7516^:"weaver/src/org/aspectj/weaver/bcel/BcelField.java"

======= fetch "private void unpackAjAttributes(World world) {" 6aa7516^:"weaver/src/org/aspectj/weaver/bcel/BcelMethod.java"

======= fetch "private void unpackAspectAttributes() {" 6aa7516^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "private void unpackAspectAttributes() {" 6aa7516^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "public ISourceLocation getSourceLocation() {" 6aa7516^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= fetch "private void writeBack(BcelWorld world) {" 6aa7516^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

    	if (myType != null && myType.getWeaverState() != null) {
======= fetch "private void printAspectAttributes(PrintStream out) {" 6aa7516^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"


======= fetch "public final boolean isCoerceableFrom(TypeX o) {" 8a64fa2^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

            ResolvedMember[] b = ((Name)other).getDeclaredMethods();  //??? is this cast always safe

    static public void main (String [] args) { }
    static private int level = 0;
    static private void offset() {
        for (int i = 0; i < level; ++i)  System.err.print("  ");
    }
    pointcut pc() : 
        !cflow(within(Trace*))
        ;
    before () : pc() {
        offset();
        System.err.println("-> " + thisJoinPoint);
        ++level;
    }
    after  () : pc() {
        --level;
        offset();
        System.err.println("<- " + thisJoinPoint);
    }
    static private int level = 0;
    static private void offset() {
        for (int i = 0; i < level; ++i)         System.err.print("  ");
    }
    
    pointcut pc() : within(TraceClass);
    before () : pc() {
        offset();
        System.err.println("=> " + thisJoinPoint);
        ++level;
    }
    after  () : pc() {
        --level;
        offset();
        System.err.println("<= " + thisJoinPoint);
    }
======= fetch "public void test064() {" a303a09^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
  private int countLines(String s) {
    int lines = 0;
    int idx = 0;
    while (s.indexOf("\n",idx)!=-1) {
    	lines++;
    	idx = s.indexOf("\n",idx)+1;
    }
    return lines;
  }
  
  public void test065() {
  	runTest("before,after not (cflow(within(Trace*))) prints nothing");
  	String s = getLastRunResult().getStdErr();
  	int lines = countLines(s);
  }
    
    <ajc-test dir="bugs" pr="74952" title="before,after not (cflow(within(Trace*))) prints nothing">
        <compile files="WhatsGoingOn.java"/>
        <run class="WhatsGoingOn"/>
    </ajc-test>
======= fetch "protected void prepareForMungers() {" a303a09^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public void weaveAfterReturning(BcelAdvice munger) {" a303a09^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        	/*
        	 * 
 27:  getstatic       #72; //Field ajc$cflowCounter$0:Lorg/aspectj/runtime/internal/CFlowCounter;
 30:  invokevirtual   #87; //Method org/aspectj/runtime/internal/CFlowCounter.dec:()V
 33:  aload   6
 35:  athrow
 36:  nop
 37:  getstatic       #72; //Field ajc$cflowCounter$0:Lorg/aspectj/runtime/internal/CFlowCounter;
 40:  invokevirtual   #87; //Method org/aspectj/runtime/internal/CFlowCounter.dec:()V
 43:  d2i
 44:  invokespecial   #23; //Method java/lang/Object."<init>":()V
        	 */
======= fetch "public void weaveAfterReturning(BcelAdvice munger) {" a303a09^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        } else {
======= fetch "public void weaveCflowEntry(final BcelAdvice munger, final Member cflowField) {" a303a09^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public void weaveCflowEntry(final BcelAdvice munger, final Member cflowField) {" a303a09^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"


======= fetch "public void abstractMethodMustBeImplemented(" 6beb43f^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

 public void a1();
 public void a2();
  public void a1() {
    System.out.println("AbstractClassA.a()");
  }
  public void someMethod() {
    InterfaceA a = new AbstractClassA() {  };
    a.a2(); 
  }
  
  public static void main(String[]argv) {
  	new ConcreteClassA().someMethod();
  	new concCB().someMethod();
  }
  public void AbstractClassA.a2() {
    System.out.println("AbstractClassA.a2() from IntroAspectA");
  }
======= fetch "public void test063_cflowOptimization_countersWithAbstractPcuts() {" 6beb43f^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  public void test064() {
  	runTest("Anonymous classes unaware of introductions into abstract classes");
  }
    
    <ajc-test dir="bugs/pr76096" pr="76096" title="Anonymous classes unaware of introductions into abstract classes">
        <compile files="ConcreteClassA.java"/>
        <run class="ConcreteClassA"/>
    </ajc-test>

======= fetch "public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r" 0a77939^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

            } else if (arg.equals("-proceedOnError")) {
            	buildConfig.setProceedOnError(true);
======= fetch "public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r" 0a77939^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

                // -proceedOnError, -g:[...], -preserveAllLocals,
======= fetch "public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r" 0a77939^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= fetch "public AjCompilerAdapter(Compiler compiler," 0a77939^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= fetch "public AjCompilerAdapter(Compiler compiler," 0a77939^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= fetch "public void afterCompiling() {" 0a77939^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= fetch "public boolean getShowWeavingInformation() {" 0a77939^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= fetch "protected boolean proceedOnError() {" 0a77939^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public ICompilerAdapter getAdapter(org.aspectj.org.eclipse.jdt.internal.compiler" 0a77939^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public ICompilerAdapter getAdapter(Compiler forCompiler) {" 0a77939^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AspectJBuilder.java"

======= fetch "public static Test suite() {" 0a77939^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java"

        suite.addTestSuite(ProceedOnErrorTestCase.class);
 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     PARC     initial implementation 
 * ******************************************************************/
        // Without -proceedOnError supplied, we should *not* change the time stamp on the .class file
        // Without -proceedOnError supplied, we should *not* change the time stamp on the .class file

 * Created on 28-Sep-2004
 *
 * TODO To change the template for this generated file go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
 * @author websterm
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
 * Created on 28-Sep-2004
 *
 * TODO To change the template for this generated file go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
 * @author websterm
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
======= fetch "private static void selectFactoryForVMVersion() {" 6e155a6^:"runtime/src/org/aspectj/runtime/internal/CFlowCounter.java"

======= fetch "private static void selectFactoryForVMVersion() {" 6e155a6^:"runtime/src/org/aspectj/runtime/internal/CFlowCounter.java"

======= fetch "private static void selectFactoryForVMVersion() {" 6e155a6^:"runtime/src/org/aspectj/runtime/internal/CFlowStack.java"

======= fetch "private static void selectFactoryForVMVersion() {" 6e155a6^:"runtime/src/org/aspectj/runtime/internal/CFlowStack.java"


======= fetch "public void unhandledException(" eca1429^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= fetch "public PersistenceException(Throwable cause) {" eca1429^:"tests/bugs/ConvertToUnchecked.java"

    public PR72157() throws Exception {
        throw new Exception();
    }
    public static void main(String[] args) {
        new SCE2();
    }
    public SCE2() {  
        super();    // CE L13?
    }
    
    
    public Foo() throws Exception {
        throw new Exception();
    }
    
    public Goo() {
        new Foo();
    }
    declare soft: Exception: within(SCE2);
    declare soft: Exception: within(Goo);
======= fetch "public void test056_arrayCloning() {" eca1429^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  public void test057_decSoftWithSuper() {
      runTest("declare soft can cause programs with invalid exception behaviour to be generated");
    }
    <ajc-test dir="bugs" pr="72157"
 	      <message kind="error" line="13" text="Unhandled"/>

======= fetch "public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r" 8e4d898^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"


======= fetch "private void configureProjectOptions( AjBuildConfig config, ProjectPropertiesAda" b133299^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

       
======= fetch "public void performCompilation(List files) {" b133299^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public String getOutputClassFileName(char[] eclipseClassFileName, CompilationRes" b133299^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private static long performCompile() throws IOException {" b133299^:"org.aspectj.ajdt.core/testsrc/WeaveTests.java"

======= fetch "private static long performCompile() throws IOException {" b133299^:"org.aspectj.ajdt.core/testsrc/WeaveTests.java"

======= fetch "private static long performCompile() throws IOException {" b133299^:"org.aspectj.ajdt.core/testsrc/WeaveTests.java"


======= fetch "private static boolean configureNonStandardOptions(" d1551bd^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

     * <li>New bootclasspath entries are ignored XXX</li>
======= fetch "private void configureProjectOptions( AjBuildConfig config, ProjectPropertiesAda" d1551bd^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

        String propcp = properties.getClasspath(); // XXX omitting bootclasspath...
======= fetch "private void configureProjectOptions( AjBuildConfig config, ProjectPropertiesAda" d1551bd^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

       
        // Handle boot classpath
        propcp = properties.getBootClasspath();
        if (!LangUtil.isEmpty(propcp)) {
            StringTokenizer st = new StringTokenizer(propcp, File.pathSeparator);
            List configClasspath = config.getBootclasspath();
            ArrayList toAdd = new ArrayList();
            while (st.hasMoreTokens()) {
                String entry = st.nextToken();
                if (!configClasspath.contains(entry)) {
                    toAdd.add(entry);
                }
            }
            if (0 < toAdd.size()) {
                ArrayList both = new ArrayList(configClasspath.size() + toAdd.size());
                both.addAll(configClasspath);
                both.addAll(toAdd);
                config.setBootclasspath(both);
                Ajde.getDefault().logEvent("building with boot classpath: " + both);
            }
        }
       
        
        
======= fetch "public AjBuildConfig populateBuildConfig(AjBuildConfig buildConfig, String[] arg" d1551bd^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= fetch "private Collection collectSourceRootFiles(File dir) {" d1551bd^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

    	
    	if (parser.bootclasspath == null) {
    		addClasspath(System.getProperty("sun.boot.class.path", ""), ret);
    	} else {  
    		addClasspath(parser.bootclasspath, ret);
    	}
    	return ret;
======= fetch "public List getClasspath(AjcConfigParser parser) {" d1551bd^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

    	if (parser.bootclasspath == null) {
    		addClasspath(System.getProperty("sun.boot.class.path", ""), ret);
    	} else {  
    		addClasspath(parser.bootclasspath, ret);
    	}
======= fetch "public AjCompilerOptions getOptions() {" d1551bd^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= fetch "public void setClasspath(List classpath) {" d1551bd^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= fetch "public boolean isIncrementalFileMode() {" d1551bd^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

     * @return List (String) classpath of injars, inpath, aspectpath 
     *   entries, specified classpath (bootclasspath, extdirs, and 
     *   classpath), and output dir or jar
======= fetch "public List getFullClasspath() {" d1551bd^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

        full.addAll(getBootclasspath()); // XXX Is it OK that boot classpath overrides inpath/injars/aspectpath?
======= fetch "public List getFullClasspath() {" d1551bd^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

            full.add(((File)i.next()).getAbsolutePath());
======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" d1551bd^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "String makeClasspathString() {" d1551bd^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "String makeClasspathString() {" d1551bd^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public String checkRtJar(AjBuildConfig buildConfig) {" d1551bd^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void testPathResolutionFromConfigArgs() {" d1551bd^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

======= fetch "public void testBootclasspath() throws InvalidInputException {" d1551bd^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

======= fetch "public void testBootclasspath() throws InvalidInputException {" d1551bd^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"


    public static void main(String[] args) {
        ArrayCloning ArrayCloning = new ArrayCloning();
        Integer[] clonedStaticField = ArrayCloning.clone1();
        checkIdentical(clonedStaticField,ArrayCloning.staticField);
    
        Integer[] clonedField = ArrayCloning.clone2();
        checkIdentical(clonedField,ArrayCloning.nonStaticField);
        Integer[] clown = null;
        clown = ArrayCloning.clone3();
        clown = ArrayCloning.clone4();
        Integer[][] ArrayCloningArrayCloning = ArrayCloning.clone5();
    }
    public static void checkIdentical(Integer[] one, Integer[] two) {
      if (one[0]!=two[0]) throw new RuntimeException("Not the same (a)");
      if (one[1]!=two[1]) throw new RuntimeException("Not the same (b)");
    }
    private static Integer[] staticField = new Integer[2];
    private Integer[] nonStaticField = new Integer[2];
    public ArrayCloning() {
      nonStaticField[0] = new Integer(32);
      nonStaticField[1] = new Integer(64);
    }
    static {
      staticField[0] = new Integer(1);
      staticField[1] = new Integer(2);
    }
    
    public Integer[] clone1() {
      System.err.println("Clone call on a static field");
      return (Integer[])staticField.clone();
    }
    public Integer[] clone2() {
       System.err.println("Clone call on a non-static field");
       return (Integer[])nonStaticField.clone();
    }
    public Integer[] clone3() {
       System.err.println("Clone call on a local variable");
       Integer[] ArrayCloningArrayCloning = staticField;
       return (Integer[])ArrayCloningArrayCloning.clone();
    }
    // Clone call on anonymous 'thing' !
    public Integer[] clone4() {
      System.err.println("Clone call on a 1 dimensional anonymous integer array");
      return (Integer[])new Integer[5].clone();
    }
    // Sick
    public Integer[][] clone5() {
      System.err.println("Clone call on a 2 dimensional anonymous integer array");
      return (Integer[][])new Integer[5][3].clone();
    }
    Object[] around(): call(* java.lang.Object.clone()) && within(ArrayCloning) {
  	Object[] ret = proceed(); 
    }
======= fetch "public void test055_cnfe() {" 27d204c^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
  public void test056_arrayCloning() {
    runTest("around advice throws java.lang.VerifyError at runtime");
  }
    <ajc-test dir="bugs" pr="72528"
======= fetch "public boolean isExposedToWeaver() {" 27d204c^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

            return ResolvedMember.NONE;
======= fetch "public void initializeTargetVar() {" 27d204c^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

            type = ensureTargetTypeIsCorrect(type);
======= fetch "public void initializeTargetVar() {" 27d204c^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    
    /* PR 72528
     * This method double checks the target type under certain conditions.  The Java 1.4
     * compilers seem to take calls to clone methods on array types and create bytecode that
     * looks like clone is being called on Object.  If we advise a clone call with around
     * advice we extract the call into a helper method which we can then refer to.  Because the
     * type in the bytecode for the call to clone is Object we create a helper method with
     * an Object parameter - this is not correct as we have lost the fact that the actual
     * type is an array type.  If we don't do the check below we will create code that fails
     * java verification.  This method checks for the peculiar set of conditions and if they
     * are true, it has a sneak peek at the code before the call to see what is on the stack.
     */
    public TypeX ensureTargetTypeIsCorrect(TypeX tx) {
    	if (tx.equals(ResolvedTypeX.OBJECT) && getKind() == MethodCall && 
    	    getSignature().getReturnType().equals(ResolvedTypeX.OBJECT) && 
    		
    		// Lets go back through the code from the start of the shadow
            InstructionHandle searchPtr = range.getStart().getPrev();
            while (Range.isRangeHandle(searchPtr) || 
            	   searchPtr.getInstruction() instanceof StoreInstruction) { // ignore this instruction - it doesnt give us the info we want
            	searchPtr = searchPtr.getPrev();  
            }
            
            // A load instruction may tell us the real type of what the clone() call is on
            if (searchPtr.getInstruction() instanceof LoadInstruction) {
            	LoadInstruction li = (LoadInstruction)searchPtr.getInstruction();
            	li.getIndex();
            	LocalVariableTag lvt = LazyMethodGen.getLocalVariableTag(searchPtr,li.getIndex());
            	return lvt.getType();
            }
            // A field access instruction may tell us the real type of what the clone() call is on
            if (searchPtr.getInstruction() instanceof FieldInstruction) {
            	FieldInstruction si = (FieldInstruction)searchPtr.getInstruction();
            	Type t = si.getFieldType(getEnclosingClass().getConstantPoolGen());
            	return BcelWorld.fromBcel(t);
            } 
            // A new array instruction obviously tells us it is an array type !
            if (searchPtr.getInstruction() instanceof ANEWARRAY) {
            	//ANEWARRAY ana = (ANEWARRAY)searchPoint.getInstruction();
            	//Type t = ana.getType(getEnclosingClass().getConstantPoolGen());
            	// Just use a standard java.lang.object array - that will work fine
            	return BcelWorld.fromBcel(new ArrayType(Type.OBJECT,1));
            }
            // A multi new array instruction obviously tells us it is an array type !
            if (searchPtr.getInstruction() instanceof MULTIANEWARRAY) {
            	MULTIANEWARRAY ana = (MULTIANEWARRAY)searchPtr.getInstruction();
                // Type t = ana.getType(getEnclosingClass().getConstantPoolGen());
            	// t = new ArrayType(t,ana.getDimensions());
            	// Just use a standard java.lang.object array - that will work fine
            	return BcelWorld.fromBcel(new ArrayType(Type.OBJECT,ana.getDimensions()));
            }
            throw new BCException("Can't determine real target of clone() when processing instruction "+
              searchPtr.getInstruction());
    	}
    	return tx;
    }
    
    
======= fetch "private LazyMethodGen createMethodGen(String newMethodName, int visibilityModifi" 27d204c^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

            targetType = ensureTargetTypeIsCorrect(targetType);
======= fetch "private LazyMethodGen createMethodGen(String newMethodName, int visibilityModifi" 27d204c^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

            
======= fetch "private LazyMethodGen createMethodGen(String newMethodName, int visibilityModifi" 27d204c^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

            	!samePackage(targetType.getPackageName(), getEnclosingType().getPackageName()))

======= fetch "protected void prepareForMungers() {" 4921f0c^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

 		
======= fetch "protected void prepareForMungers() {" 4921f0c^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "protected void prepareForMungers() {" 4921f0c^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

            TypeX tx = getArgType(0);
            argVars[0] = genTempVar(tx, "ajc$arg0");
            InstructionHandle insertedInstruction = 
            	range.insert(argVars[0].createStore(getFactory()), Range.OutsideBefore);
            // Now the exception range starts just after our new instruction.
            // The next bit of code changes the exception range to point at
            // the store instruction
======= fetch "protected void prepareForMungers() {" 4921f0c^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "protected void prepareForMungers() {" 4921f0c^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "protected void prepareForMungers() {" 4921f0c^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "protected void prepareForMungers() {" 4921f0c^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "protected void prepareForMungers() {" 4921f0c^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"


======= fetch "public Class getReturnType() {" 438e61c^:"runtime/src/org/aspectj/runtime/reflect/AdviceSignatureImpl.java"

    String toString(StringMaker sm) {
======= fetch "public String getParameterName() {" 438e61c^:"runtime/src/org/aspectj/runtime/reflect/CatchClauseSignatureImpl.java"

    String toString(StringMaker sm) {
    String toString(StringMaker sm) {
======= fetch "public SourceLocation makeSourceLoc(int line, int col)" 438e61c^:"runtime/src/org/aspectj/runtime/reflect/Factory.java"

        return new SourceLocationImpl(lexicalClass, this.filename, line, col);
======= fetch "public Class getFieldType() {" 438e61c^:"runtime/src/org/aspectj/runtime/reflect/FieldSignatureImpl.java"

    String toString(StringMaker sm) {
======= fetch "public String getName() {" 438e61c^:"runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.java"

    String toString(StringMaker sm) {
======= fetch "public Class getReturnType() {" 438e61c^:"runtime/src/org/aspectj/runtime/reflect/MethodSignatureImpl.java"

    String toString(StringMaker sm) {
    abstract String toString(StringMaker sm);
======= fetch "void addTypeArray(StringBuffer buf, Class[] types) {" 438e61c^:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

    String stringRep;
======= fetch "Class makeClass(String s) {" 438e61c^:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

    int column;
    SourceLocationImpl(Class withinType, String fileName, int line, int column) {
        this.column = column;
    public int getColumn() { return column; }
======= fetch "public String toString() {" 438e61c^:"runtime/src/org/aspectj/runtime/reflect/SourceLocationImpl.java"

    	return getFileName() + ":" + getLine() +
    		((getColumn() == -1) ? ""  : ":" + getColumn());
======= fetch "public static TestSuite suite() {" 438e61c^:"runtime/testsrc/RuntimeModuleTests.java"

        suite.addTestSuite(JoinPointImplTest.class);
======= fetch "public void testGetDeclaringTypeName() {" 438e61c^:"runtime/testsrc/org/aspectj/runtime/reflect/SignatureTest.java"


======= fetch "public void postParse(TypeDeclaration typeDec) {" 5e08765^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"

======= fetch "public void javadocMissingParamTag(Argument arg, int modifiers) {" 5e08765^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

    
    public void abstractMethodInAbstractClass(SourceTypeBinding type, AbstractMethodDeclaration methodDecl) {
    	String abstractMethodName = new String(methodDecl.selector);
    	if (abstractMethodName.startsWith("ajc$pointcut")) {
    		// This will already have been reported, see: PointcutDeclaration.postParse()
    		return;
    	}
    	String[] arguments = new String[] {new String(type.sourceName()), abstractMethodName};
    	super.handle(
    		IProblem.AbstractMethodInAbstractClass,
    		arguments,
    		arguments,
    		methodDecl.sourceStart,
    		methodDecl.sourceEnd,this.referenceContext, 
    }
======= fetch "public void test051_arrayCloningInJava5() {" 5e08765^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
  public void test052_bogusMessage1() {
    runTest("Bogus error message: The abstract method ajc$pointcut$$tracingScope$a2 in type Tracing can only be defined by an abstract class (1)");
  }
  
  public void test053_bogusMessage2() {
    runTest("Bogus error message: The abstract method ajc$pointcut$$tracingScope$a2 in type Tracing can only be defined by an abstract class (2)");
  }
    <ajc-test dir="bugs" pr="72699"
    </ajc-test>
    
    <ajc-test dir="bugs" pr="72699"
    </ajc-test>
    

  Object around(): call(* clone(..)) {
    return proceed();
  }
  public static B.D[] arr = new B.D[5];
  public static void main(String[]argv) {
    arr[0] = new B.D(42);
    arr[1] = new B.D(22);
    arr[2] = new B.D(46);
    arr[3] = new B.D(50);
    arr[4] = new B.D(54);
    B.D[] arr2 = arr.clone();
    // Check the clone is OK
    if (arr2[0].i!=42) throw new RuntimeException("Call that a clone 0");
    if (arr2[1].i!=22) throw new RuntimeException("Call that a clone 1");
    if (arr2[2].i!=46) throw new RuntimeException("Call that a clone 2");
    if (arr2[3].i!=50) throw new RuntimeException("Call that a clone 3");
    if (arr2[4].i!=54) throw new RuntimeException("Call that a clone 4");
    System.err.println("Clone OK - attempting value manipulation");
    // Change the clone, check the original is OK
    arr2[2] = new B.D(1);
    if (arr[2].i == 1)  throw new RuntimeException("Shouldnt have affected original");
    if (arr2[2].i != 1) throw new RuntimeException("Should have affected clone");
    System.err.println("Clone OK - finished");
  }
  public static class D {
    public int i;
    D(int x) { i=x;}
  }
======= fetch "public void test050_typePatternMatchingWithArrays() {" b5e6307^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  public void test051_arrayCloningInJava5() {
    runTest("AJC possible bug with static nested classes");
  }
    </ajc-test>
======= fetch "private static String nameToSignature(String name) {" b5e6307^:"weaver/src/org/aspectj/weaver/TypeX.java"

        if (name.length() != 0)  // lots more tests could be made here...
            return "L" + name.replace('.', '/') + ";";

    public static void main(String[] args) {
        PrinterWorld p = new PrinterWorld();
        p.print(); 
        Integer i = p.returnInt();
        Integer[] intArray = p.returnArrayWithCloning();
        Integer[] array2 = p.returnArrayWithoutCloning();
    }
    
    public HelloWorldAspect() {
    }
    
    pointcut hello(): !within(HelloWorldAspect);
    
    pointcut method(): execution(public (*[]) de..*(..));
    
    pointcut cloning(): call(* java.lang.Object.clone());
    declare warning: method() && hello(): "*[] returning method called" ;
    
    Object[] around(): cflow(method()) && cloning() && hello() {
    	print("", thisEnclosingJoinPointStaticPart);
    	Object[] ret = proceed(); 
    	return (Object[])ret.clone();
    }
    private void print(String prefix, Object message) {
        for (int i = 0, spaces = callDepth * 2; i < spaces; i++) {
            System.out.print(" ");
        }
        System.out.println(prefix + message);
    }
    public void print() {
        System.out.println("Hello World!"); 
    }
    
    public Integer returnInt() {
    	return new Integer(3);
    }
    
    public Integer[] returnArrayWithCloning() {
    	for (int i = 0; i < intArray.length; i++) {
    	return (Integer[])intArray.clone();
    }
    
    public Integer[] returnArrayWithoutCloning() {
    	return intArray;
    }
======= fetch "public void test049_interfaceITD_pr70794_4() {" 82eae55^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  public void test050_typePatternMatchingWithArrays() {
  	runTest("declare warning warns at wrong points");
  }
======= fetch "private boolean matchesExactlyByName(String targetTypeName) {" 82eae55^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "public TypePattern resolveBindings(IScope scope, Bindings bindings," 82eae55^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

    		if (dim == 0) { // pr72531
    			return TypePattern.ANY;  //??? loses source location
    		} 
======= fetch "public void testInstanceofMatch() {" 82eae55^:"weaver/testsrc/org/aspectj/weaver/patterns/TypePatternTestCase.java"

  	
  	public void testArrayMatch() {
  		world = new BcelWorld();
  		checkMatch("*[][]","java.lang.Object",false);
  		checkMatch("*[]","java.lang.Object[]",true);
  		checkMatch("*[][]","java.lang.Object[][]",true);
  		checkMatch("java.lang.Object[]","java.lang.Object",false);
  		checkMatch("java.lang.Object[]","java.lang.Object[]",true);
  		checkMatch("java.lang.Object[][]","java.lang.Object[][]",true);
  		checkMatch("java.lang.String[]","java.lang.Object",false);
  		checkMatch("java.lang.String[]","java.lang.Object[]",false);
  		checkMatch("java.lang.String[][]","java.lang.Object[][]",false);
  		checkMatch("java.lang.Object+[]","java.lang.String[]",true);
  	}

======= fetch "protected boolean doCommand(IMessageHandler handler, boolean repeat) {" f503523^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"

            return ((repeat 
                        ? buildManager.incrementalBuild(config, handler)
                        : buildManager.batchBuild(config, handler))
                    && !counter.hasErrors());
======= fetch "protected boolean doCommand(IMessageHandler handler, boolean repeat) {" f503523^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"

======= fetch "public AjBuildConfig genBuildConfig(String[] args) {" f503523^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= fetch "public void performCompilation(List files) {" f503523^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void run(String[] args, IMessageHolder holder) {" f503523^:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"

    	Dump.saveMessageHolder(holder);
======= fetch "public static Test suite() {" f503523^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java"

        suite.addTestSuite(CompilerDumpTestCase.class); 
 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
 * Copyright (c) 2004 IBM Corporation
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Matthew Webster 
 * ******************************************************************/
 * @author websterm
 *
 * To change the template for this generated type comment go to
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
            Object o = i.next();
            if (o instanceof Exception) {
                println((Exception)o);
            } else {
            	println(i.next().toString());
            }
    
    private List dumpState_cantFindTypeExceptions = null;
======= fetch "protected World() {" f503523^:"weaver/src/org/aspectj/weaver/World.java"

        Dump.registerNode(this.getClass(),this);
======= fetch "protected World() {" f503523^:"weaver/src/org/aspectj/weaver/World.java"

    
    public void accept (Dump.IVisitor visitor) {
        if (dumpState_cantFindTypeExceptions!=null) {
          visitor.visitString("Cant find type problems:");
          visitor.visitList(dumpState_cantFindTypeExceptions);
          dumpState_cantFindTypeExceptions = null;
        }
    }
======= fetch "public ResolvedTypeX resolve(TypeX ty, boolean allowMissing) {" f503523^:"weaver/src/org/aspectj/weaver/World.java"

            	//Thread.currentThread().dumpStack();
======= fetch "public ResolvedTypeX resolve(TypeX ty, boolean allowMissing) {" f503523^:"weaver/src/org/aspectj/weaver/World.java"

                // + " on classpath " + classPath);
======= fetch "public ResolvedPointcutDefinition findPointcut(TypeX typeX, String name) {" f503523^:"weaver/src/org/aspectj/weaver/World.java"

    public static final World EMPTY = new World() {
        public List getShadowMungers() { return Collections.EMPTY_LIST; }
        public ResolvedTypeX.ConcreteName resolveObjectType(ResolvedTypeX.Name ty) {
            return null;
        }
        public Advice concreteAdvice(AjAttribute.AdviceAttribute attribute, Pointcut p, Member m) {
            throw new RuntimeException("unimplemented");
        }
        public ConcreteTypeMunger concreteTypeMunger(ResolvedTypeMunger munger, ResolvedTypeX aspectType) {
            throw new RuntimeException("unimplemented");
        }        
    };
======= fetch "public static Test suite() {" f503523^:"weaver/testsrc/org/aspectj/weaver/BcweaverTests.java"

 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster 
 *******************************************************************************/
 * @author websterm
 *
 * Test Dump facility. Ensure it can be configured and files contain expected contents. Testcase 
 * returns Dump configuration to orginal state.
 */

            else if ( arg.equals( "-encoding" ) ) {
                addNextAsOption = true;
                addNextToAJCOptions = false;
                options.addElement( arg );
            }
            else if ( arg.equals( "-docencoding" ) ) {
                addNextAsOption = true;
                addNextToAJCOptions = false;
                options.addElement( arg );
            }
            else if ( arg.equals( "-charset" ) ) {
                addNextAsOption = true;
                addNextToAJCOptions = false;
                options.addElement( arg );
            }
======= fetch "public void testCoverage() {" 5f80c8c^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"


    int x;
    Base() {
    }
    abstract void foo();
    int y;
    public Derived() {
    }
    public void foo() {}
    public static void main(String args[]) {
    }
    public interface Traced {}
    declare parents: (sample.* && !Trace) extends Traced;
    before(Traced current) : 
    }
    public Logger Traced.getLogger() {
 //       if (logger == null) {
 //       }
    }
======= fetch "public static Test suite() {" dbe1024^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java"

        suite.addTestSuite(PartiallyExposedHierarchyTestCase.class);
 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
 * If you need to rebuild the components for this test, I'm afraid you will have
 * to run build.cmd in the testdata/partialHierarchy directory which calls ajc and
 * does some jar manipulation.
 */
======= fetch "public boolean isTopmostImplementor(ResolvedTypeX interfaceType) {" dbe1024^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

     for(Iterator i = other.getDirectSupertypes(); i.hasNext(); ) {
     	ResolvedTypeX rtx = (ResolvedTypeX)i.next();
     	boolean b = this.isAssignableFrom(rtx);
     	if (b) return rtx;
     }       
     return null;
======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" dbe1024^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

    		
    		if (!gen.getType().isTopmostImplementor(onType)) {
    			ResolvedTypeX rtx = gen.getType().getTopmostImplementor(onType);
    			if (!rtx.isExposedToWeaver()) {
    				ISourceLocation sLoc = munger.getSourceLocation();
    			    weaver.getWorld().getMessageHandler().handleMessage(MessageUtil.error(
    			    		WeaverMessages.format(WeaverMessages.ITD_NON_EXPOSED_IMPLEMENTOR,rtx,getAspectType().getName()),
    			} else {
    				// XXX what does this state mean?
    				// We have incorrectly identified what is the top most implementor and its not because
    				// a type wasn't exposed to the weaver
    			}
    		} else {
======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" dbe1024^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" dbe1024^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" dbe1024^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" dbe1024^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" dbe1024^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" dbe1024^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" dbe1024^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" dbe1024^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" dbe1024^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

    		}

    public void Foo.doing() {
    System.out.println(i()); // CE L8
    System.out.println(ancientI()); // CE L9
    System.out.println(ancientJ()); // CE L10
    System.out.println(this.clone()); // CE L11
    System.out.println(clone()); // CE L12
    }
    before(Foo f) : call(* doStuff(..)) && target(f) {
        f.doing();
    }
    public void Foo.doingMore() {
    System.out.println(i());
    System.out.println(ancientI());
    System.out.println(ancientJ()); 
 }
    }
    before(Foo f) : call(* doStuff(..)) && target(f) {
        f.doing();
    }
    protected int i() { return 42; }
    public static void main(String[] args) {
        new Foo().doStuff();
    }
    public void doStuff() { }
    protected int ancientI() { return 42; }
    protected int ancientI() { return -42; }
    protected int ancientJ() { return 0; }
======= fetch "public void test043_pr62642_ExceptionInInitializerError() {" dfb15c1^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
======= fetch "public void test044_ITDnameClashes() {" dfb15c1^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  public void test045_ITDprotectedVisibility() {
  	runTest("Inconsistency in scoping of protected members in ITDs");
  }
  

 * A comment
 * @see AspectJavadocComment
 */
    
    public void test0() {}
    
    /**
     * A comment
     * @see PointcutJavadocComment1
     */
    public void test1() {}
    
     * @see AfterReturningJavadocComment
    public void test2(){}
    
    /**
     * comment2
     * @see PointcutJavadocComment2
     */   
    public pointcut secondPC(): execution(* *(..));
    
    public void test3(){}
    
    /**
     * I am a comment attached to a warning
     * @see declarewarningJavadocComment
     */
    declare warning: call(* *elephant*(..)) : "I am a warning";
    
    public void test4() {}
    
    /**
     * comment attached to around advice
     * @see AroundAdviceJavadocComment
     */
    void around(): call(* *abc*(..)) {
    }
    public void test5() {}
   
    /**
     * ITD method attached comment
     * @see IntertypeMethodComment
     */
    public void X.method() {       }
    
    public void test6() {}
    
    /**
     * ITD field attached comment
     * @see IntertypeFieldComment
     */
    public int X.i;
    
    public int test7;
    
    static class X {
        
    }
   
======= fetch "public static Test suite() {" 5b90224^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java"

        suite.addTestSuite(JavadocTest.class);
 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Andy Clement - initial implementation
 *******************************************************************************/
    public static final String PROJECT_DIR = "javadoc";
    private File baseDir;
    
    protected void setUp() throws Exception {
        super.setUp();
        baseDir = new File("../org.aspectj.ajdt.core/testdata",PROJECT_DIR);
    }
    
    /**
     * Aim: Check javadoc warning that appear are appropriate
     * 
     *   ajc -warn:allJavadoc World.java
     * 
     */
    public void testMissingJavadoc () {
        String[] args = new String[] {"World.java","-warn:allJavadoc"};
        
        List warningMessages = new ArrayList();
        // These warnings are against public textX() methods declared in the World.java
        // type.  These test methods are spread between AJ constructuts, meaning
        // if someone messes up and the javadoc is not associated with the aspectj
        // construct then it will associated by accident with one of the testX() methods.
        // By checking we get a warning against every testX() method, we are verifying
        // that the javadoc is being attached to the aspectj constructs.
        warningMessages.add(new Message(10,"Missing comment for public declaration"));
        warningMessages.add(new Message(18,"Missing comment for public declaration"));
        warningMessages.add(new Message(28,"Missing comment for public declaration"));
        warningMessages.add(new Message(36,"Missing comment for public declaration"));
        warningMessages.add(new Message(44,"Missing comment for public declaration"));
        warningMessages.add(new Message(53,"Missing comment for public declaration"));
        warningMessages.add(new Message(61,"Missing comment for public declaration"));
        warningMessages.add(new Message(69,"Missing comment for public declaration"));
        MessageSpec spec = new MessageSpec(warningMessages,null);
        
        CompilationResult result = ajc(baseDir,args);
        assertMessages(result,spec);
        
    }
    
    private void dump(List l) {
         for (Iterator iter = l.iterator(); iter.hasNext();) {
    }

        
        	C m = new C();
        	m.y = 3;
        	System.out.println("hi");
    public static void main(String[] args) {
        try {
         C.main(null);   
        } catch (ExceptionInInitializerError eiie) {
        	System.err.println("EIIE="+eiie.toString());
            System.err.println("CAUSE="+eiie.getCause().toString());
        }
    before () :  within(*) && !within(pr62642) { 
        System.out.println("BEFORE "+ thisJoinPointStaticPart.getKind() +
        System.out.println("AFTER " + thisJoinPointStaticPart.getKind() +
======= fetch "public void test042_ITDaccessingPrivateMethod_pr67578_2() {" 84e4e53^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
  public void test043_pr62642_ExceptionInInitializerError() {
    runTest("proper handling of ExceptionInIntializer inside clinit in presence of after throwing advice");
    String s = getLastRunResult().getStdErr();
    assertTrue("Output should contain java.lang.ExceptionInInitializerError but is '"+s+"'",
            s.indexOf("java.lang.ExceptionInInitializerError")!=-1);
    assertTrue("Output should contain 'CAUSE=org.aspectj.lang.NoAspectBoundException' but is '"+s+"'",
            s.indexOf("CAUSE=org.aspectj.lang.NoAspectBoundException")!=-1);
  }
======= fetch "public void weaveAfterThrowing(BcelAdvice munger, TypeX catchType) {" 84e4e53^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        // pr62642
        // I will now jump through some firey BCEL hoops to generate a trivial bit of code:
        // if (exc instanceof ExceptionInInitializerError) 
        //    throw (ExceptionInInitializerError)exc;
        if (this.getEnclosingMethod().getName().equals("<clinit>")) {
            ResolvedTypeX eiieType = world.resolve("java.lang.ExceptionInInitializerError");
            ObjectType eiieBcelType = (ObjectType)BcelWorld.makeBcelType(eiieType);
        	InstructionList ih = new InstructionList(InstructionConstants.NOP);
        	handler.append(exceptionVar.createLoad(fact));
        	handler.append(fact.createInstanceOf(eiieBcelType));
        	BranchInstruction bi = 
                InstructionFactory.createBranchInstruction(Constants.IFEQ,ih.getStart());
        	handler.append(bi);
        	handler.append(exceptionVar.createLoad(fact));
        	handler.append(fact.createCheckCast(eiieBcelType));
        	handler.append(InstructionConstants.ATHROW);
        	handler.append(ih);
        }

======= fetch "public void testOutjarInInjars () {" a2469c7^:"ajde/testsrc/org/aspectj/ajde/ExtensionTests.java"

  InnerClasses.java
    import declarations
    InnerClasses
      A							A
        method						method
        1								new Runnable() {..}
          run								run
      main						main
      2								new Runnable() {..}
      	  run							run
      3 							new Object() {..}
        toString						toString
      4								new Runnable
        run								run
======= fetch "public boolean visit(TypeDeclaration memberTypeDeclaration, BlockScope scope) {" a2469c7^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= fetch "public boolean visit(TypeDeclaration memberTypeDeclaration, BlockScope scope) {" a2469c7^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= fetch "public boolean visit(TypeDeclaration memberTypeDeclaration, BlockScope scope) {" a2469c7^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"


    private void returnNothing(Object a) {
    }
  public void ITD.newFun() {
      returnNothing("a");
  }
  public static void main(String [] argv) {
    new ITD().newFun();
  }
  public void ITD.newFun() {
      returnNothing("a");
  }
  public static void main(String [] argv) {
    new ITD().newFun();
  }
  void blah(ITD x) { x.returnNothing("y"); }
  public static void main(String[]argv) {
    ITD a = new ITD();
    a.returnNothing("a");
    System.err.println("Call returned OK!");
  }
    private void returnNothing(Object a) {
    }
    private void returnNothing(Object a) {
    }
  void blah(ITD x) { x.returnNothing("y"); }
  public static void main(String[]argv) {
    ITD a = new ITD();
    a.returnNothing("a");
    System.err.println("Call returned OK!");
  }
======= fetch "public void test038_innerAspectCallsPrivateMethod_pr71372_4() {" 6b1ef0f^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  public void test039_privilegedAspectAccessingPrivateMethods_pr67579() {
  	runTest("NPE on privileged aspect error");
  }
  
  public void test040_privilegedAspectAccessingPrivateMethods_pr67579_2() {
  	runTest("NPE on privileged aspect error (2)");
  }
  
  public void test041_ITDaccessingPrivateMethod_pr67578() {
  	runTest("Privileged Aspect Access Problem Across Packages");
  }
  
  public void test042_ITDaccessingPrivateMethod_pr67578_2() {
  	runTest("Privileged Aspect Access Problem Across Packages (2)");
  }
    <ajc-test dir="bugs/privilegedAccess" pr="67578"

======= fetch "private IProgramElement createFileStructureNode(String sourceFilePath) {" 2dfc738^:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"


  <target name="extractAndJar" depends="extract,jar,srcjar" />
  <target name="extract" depends="unzipSource,createPatchedSource" />
  <target name="diff" depends="pack">
  <target name="createPatchedSource" depends="patch,unpack" />
      <fileset dir="bcel/src/java" />
  <li>ant extractAndJar -- this is just the composition of the extract,
  patches it, compiles the patched version into a jar and drops the new archives:
  <li>ant extract -- this extracts the source from bcel-5.1-src.zip,
  patches it, and copies the patched source into the project src directory, 
======= fetch "public String toShortString() {" 228fc8d^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

            org.apache.bcel.classfile.Utility.accessToString(myGen.getAccessFlags(), true);
======= fetch "public String toShortString() {" 228fc8d^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

        s += org.apache.bcel.classfile.Utility.classOrInterface(myGen.getAccessFlags());
======= fetch "private void printOne(PrintStream out) {" 228fc8d^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

            org.apache.bcel.classfile.Utility.compactClassName(
======= fetch "public String toShortString() {" 228fc8d^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        String access = org.apache.bcel.classfile.Utility.accessToString(getAccessFlags());
======= fetch "public String toShortString() {" 228fc8d^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= fetch "public String toShortString() {" 228fc8d^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= fetch "public String toShortString() {" 228fc8d^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"


 public int A.x = z; // CE L14 error: z not visible.
======= fetch "public void test027_itdsOnInnerClassesAsStatic() {" 8c5d743^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  public void test028_itdsAndInitializers() {
    runTest("resolution of IT field inits");
  }
======= fetch "public void test029_falseInvalidAbsoluteTypeName() {" 8c5d743^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

    public void test030_privateITDinitialisersBeingMatched() {
======= fetch "public void test033_stringConcatForDEOWErrorCase() {" 8c5d743^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

   	<ajc-test dir="bugs/PR68991" pr="68991"

 "def" + // def was here
 "ghijklmnopqrstuv" /* silly
 "wxyz";
======= fetch "public void test025_proceedInAround3() {" d43a391^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

    public void test026_bindingThisAndTargetToTheSameFormal() {
======= fetch "public void test029_falseInvalidAbsoluteTypeName() {" d43a391^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  public void test030_privateITDinitialisersBeingMatched() {
======= fetch "public void test031_privateITDinitialisersBeingMatched_OxfordTest() {" d43a391^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
  public void test032_stringConcatForDEOW() {
    runTest("Compile time declarations (warning and error) do not accept string concatenation (with +)");
  }
======= fetch "public void test031_privateITDinitialisersBeingMatched_OxfordTest() {" d43a391^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

   	</ajc-test>
======= fetch "private Declare parseErrorOrWarning(boolean isError) {" d43a391^:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"

======= fetch "private NamePattern tryToExtractName(TypePattern nextType) {" d43a391^:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"


======= fetch "public void resolve(ClassScope upperScope) {" 64183c3^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeFieldDeclaration.java"

 private int C.n = 13;
 before() : get(* C.*) {
 }
 before() : set(* C.*)  {
 }
 public void C.foo() {
 }
 int m = 20;
 public static void main(String[] args) {
 }
    private int C.n = 13;
    before() : get(* C.*) {
    	tjps.add(thisJoinPointStaticPart.toString());
    	ejps.add(thisEnclosingJoinPointStaticPart.toString());
    	//System.out.println("get field "+thisJoinPointStaticPart);
    }
    before(int x) : set(* C.*) && args(x)  {
    	tjps.add(thisJoinPointStaticPart.toString());
    	ejps.add(thisEnclosingJoinPointStaticPart.toString());
    	values.add(new String(thisJoinPointStaticPart+"="+new Integer(x)));
    	//System.err.println("set field "+thisJoinPointStaticPart);
    }
    
    public void C.foo() {
    	m++;
    	n++;
    }
  //  int m = 20;
    public static void main(String[] args) {
    	C c = new C();
    	c.foo();
    	System.err.println("\nSummaryJPs:"+Aspect.tjps);
    	System.err.println("\nSummaryEJPs:"+Aspect.ejps);
    	System.err.println("\nSummaryVals:"+Aspect.values);
    	// Ought to have a nicer signature for the ejpsp in the case of an initializer ...
    	chkNext(Aspect.tjps,"set(int C.m)");chkNext(Aspect.values,"set(int C.m)=13");chkNext(Aspect.ejps,"execution(void Aspect.ajc$interFieldInit$Aspect$C$m(C))");
    	chkNext(Aspect.tjps,"set(int C.n)");chkNext(Aspect.values,"set(int C.n)=13");chkNext(Aspect.ejps,"execution(void Aspect.ajc$interFieldInit$Aspect$C$n(C))");
    	chkNext(Aspect.tjps,"get(int C.m)");                                         chkNext(Aspect.ejps,"execution(void C.foo())");
    	chkNext(Aspect.tjps,"set(int C.m)");chkNext(Aspect.values,"set(int C.m)=14");chkNext(Aspect.ejps,"execution(void C.foo())");
    	chkNext(Aspect.tjps,"get(int C.n)");                                         chkNext(Aspect.ejps,"execution(void C.foo())");
    	chkNext(Aspect.tjps,"set(int C.n)");chkNext(Aspect.values,"set(int C.n)=14");chkNext(Aspect.ejps,"execution(void C.foo())");
    }
    
    public static void chkNext(List l,String expected) {
    	String s = (String)l.remove(0);
    	if (!s.equals(expected)) throw new RuntimeException("Expected next thing on list to be '"+expected+"' but it was '"+s+"'");
    }
======= fetch "public void test025_proceedInAround3() {" 64183c3^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
  public void test026_bindingThisAndTargetToTheSameFormal() {
======= fetch "public void test029_falseInvalidAbsoluteTypeName() {" 64183c3^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
  public void test030_privateITDinitialisersBeingMatched() {
    runTest("intertype initialisers should match field set pointcuts");
  }
  public void test031_privateITDinitialisersBeingMatched_OxfordTest() {
    runTest("intertype initialisers should match field set pointcuts (oxford testcase)");
    //System.err.println(">"+getLastRunResult().getStdErr());
    String exp = ":set field set(int C.n):set field set(int C.m):get field get(int C.n):set field set(int C.n)";
    assertTrue("Expected output '"+exp+"' but got "+getLastRunResult().getStdErr(),
    		getLastRunResult().getStdErr().equals(exp));
  }
   	<ajc-test dir="bugs/PR68991" pr="68991"
    	title="intertype initialisers should match field set pointcuts">
    	<compile files="Simple.java"/>
    	<run class="Simple"/>
   	</ajc-test>
   	 	
   	<ajc-test dir="bugs/PR68991" pr="68991"
    	title="intertype initialisers should match field set pointcuts (oxford testcase)">
    	<compile files="Oxford.java"/>
    	<run class="Oxford"/>
   	</ajc-test>

======= fetch "public void test025_proceedInAround3() {" b75cd93^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

   	</ajc-test>
======= fetch "public InstructionList getAdviceArgSetup(" b75cd93^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

        	if (exposedState.isErroneousVar(i)) continue; // Erroneous vars have already had error msgs reported!
======= fetch "private Test findResidueNoEllipsis(Shadow shadow, ExposedState state, TypePatter" b75cd93^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

                    " using args(..) at this line.  Use one args(..) per matched join point,"+"" +                    " see secondary source location for location of extraneous args(..)",
======= fetch "private Test findResidueNoEllipsis(Shadow shadow, ExposedState state, TypePatter" b75cd93^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= fetch "public ExposedState(int size) {" b75cd93^:"weaver/src/org/aspectj/weaver/patterns/ExposedState.java"

======= fetch "public void set(int i, Var var) {" b75cd93^:"weaver/src/org/aspectj/weaver/patterns/ExposedState.java"

======= fetch "public String toString() {" b75cd93^:"weaver/src/org/aspectj/weaver/patterns/ExposedState.java"

======= fetch "public Test findResidue(Shadow shadow, ExposedState state) {" b75cd93^:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"


 *     PARC     initial implementation 
 * of an <code>around</code> advice and if not this will be treated like any other
======= fetch "private AdviceDeclaration findEnclosingAround(Scope scope) {" 05dabd1^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/Proceed.java"

======= fetch "private AdviceDeclaration findEnclosingAround(Scope scope) {" 05dabd1^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/Proceed.java"

    public static void main(String[] args) { 
       Tester.checkAllEvents();
    }
    static aspect A {
        interface IProceed {
            void proceeds(Runnable next);
        }
        IProceed decorator = new IProceed() {
            public void proceeds(Runnable next) {
                Tester.event("IProceed.proceed()");
                next.run();
            }
        };
        void around() : execution(void main(String[])) {
            Tester.expectEvent("IProceed.proceed()");
            decorator.proceeds(new Runnable() {
                public void run() {
                    proceed();
                }
            });
        }
    }
    public static void main(String[] args) {
        Tester.checkFailed("Proceed with a receiver should be treated as a method call, not the special form");
    }
    static aspect A {
        void around() : execution(void main(String[])) {
            Proceeding2.proceed(null); // BUG: treated as proceed(Object);
        }
    }
    static void proceed(Object o) {}
    public static void main(String[] args) {
    }
    static aspect A {
        void around() : execution(void main(String[])) {
            proceed(); // special form or Proceeding.proceed()?
        }
    }
    void proceed() {
        Tester.checkFailed("A bare call to proceed inside around advice should never refer to a method");
    }
======= fetch "public void test019_PrivateFieldGetsInAroundAdvice() {" 05dabd1^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
  public void test023_proceedInAround1() {
      runTest("proceed used as method name in around advice (1)");
  }
  public void test024_proceedInAround2() {
      runTest("proceed used as method name in around advice (2)");
  }
  public void test025_proceedInAround3() {
      runTest("proceed used as method name in around advice (3)");
  }
  	<ajc-test dir="bugs/pr53981" pr="538981"
    	title="proceed used as method name in around advice (1)">
    	<compile files="Proceeding1.aj"/>
    	<run class="Proceeding1"/>
   	</ajc-test>
  	<ajc-test dir="bugs/pr53981" pr="538981"
    	title="proceed used as method name in around advice (2)">
    	<compile files="Proceeding2.aj"/>
    	<run class="Proceeding2"/>
   	</ajc-test>
  	<ajc-test dir="bugs/pr53981" pr="538981"
    	title="proceed used as method name in around advice (3)">
    	<compile files="Proceeding3.aj"/>
    	<run class="Proceeding3"/>
   	</ajc-test>

    boolean around() : (target(java.util.HashSet) && call(boolean add(..) ) )
       {
         return false;
       }
   }
  public static final int N_METHODS = 50;
  public static final int N_STATEMENTS = Short.MAX_VALUE/(2*N_METHODS);  
  public static void main(String[] args) {
    System.out.println("public class Foo {");
    System.out.println("static java.util.Set hs = new java.util.HashSet();");
    for (int i = 0; i < N_METHODS; i++) {
      System.out.println("public void test" + i + "() {");
      for (int j=0; j < N_STATEMENTS; j++) {
        System.out.println("hs.add(new Object());");
      } 
      System.out.println("}");
    }
    System.out.println("}");
  }
======= fetch "public void test019_PrivateFieldGetsInAroundAdvice() {" 44a92e1^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
    	title="Weaver fails in BCEL for large classes">
        <compile files="Foo.java, A.aj">
    	title="Weaver fails in BCEL for large classes (binary)">
        <compile 
        	aspectpath="test.jar"
        	inpath="classes">
======= fetch "private void writeBack(BcelWorld world) {" 44a92e1^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

        if (getConstantPoolGen().getSize() > Short.MAX_VALUE) {
            // PR 59208
            // we've generated a class that is just toooooooooo big (you've been generating programs
            // again haven't you? come on, admit it, no-one writes classes this big by hand).
            // create an empty myGen so that we can give back a return value that doesn't upset the
            // rest of the process.
            myGen = new ClassGen(myGen.getClassName(), myGen.getSuperclassName(), 
                    myGen.getFileName(), myGen.getAccessFlags(), myGen.getInterfaceNames());
            // raise an error against this compilation unit.
       		getWorld().showMessage(
        			IMessage.ERROR, 
    				WeaverMessages.format(WeaverMessages.CLASS_TOO_BIG,
    						              this.getClassName()),
    			    new SourceLocation(new File(myGen.getFileName()),0), null
    			    );
        	return;
        }

======= fetch "public JoinPointImpl(org.aspectj.lang.JoinPoint.StaticPart staticPart, Object _t" f6436e3^:"runtime/src/org/aspectj/runtime/reflect/JoinPointImpl.java"

    public Object[] getArgs() { return args; }
======= fetch "public static TestSuite suite() {" f6436e3^:"runtime/testsrc/RuntimeModuleTests.java"

        suite.addTestSuite(JoinPointImplTest.class);
 * Created on 09-Aug-2004
 *
 * TODO To change the template for this generated file go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
 * @author colyer
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */

======= fetch "private void generateMethod(ClassFile classFile, MethodBinding methodBinding, Bo" 851da68^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= fetch "private void generateMethod(ClassFile classFile, MethodBinding methodBinding, Bo" 851da68^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= fetch "private void generateInlineAccessors(ClassFile classFile, final InlineAccessFiel" 851da68^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= fetch "public void generate(CodeStream codeStream) {" 851da68^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= fetch "private void generateInlineAccessMethod(ClassFile classFile, final MethodBinding" 851da68^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

      System.out.println("? test()");
      System.out.println("? test()");
      System.out.println("? test()");
======= fetch "public void test001(){" 851da68^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

    runTest("false ambigous binding error (introduced in 1.2rc2)");
======= fetch "public void test016_ByteConversionInstructions() {" 851da68^:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
  public void test017_PrivateMethodCallsInAroundAdvice() {
    runTest("Cannot advise private method call in around advice");
    System.err.println(getLastRunResult().getStdErr());
  }
  
  public void test018_PrivateFieldSetsInAroundAdvice() {
    runTest("Cannot advise private field sets in around advice");
    System.err.println(getLastRunResult().getStdErr());
  }
  
  public void test019_PrivateFieldGetsInAroundAdvice() {
    runTest("Cannot advise private field gets in around advice");
    System.err.println(getLastRunResult().getStdErr());
  }
    <ajc-test dir="bugs/AroundAdviceJPs" pr="71377"
    	title="Cannot advise private method call in around advice">
    	<compile files="JoinPointInAroundAdvice.java"/>
    	<run class="JoinPointInAroundAdvice"/>
   	</ajc-test>
    
   <ajc-test dir="bugs/AroundAdviceJPs" pr="71377"
    	title="Cannot advise private field sets in around advice">
    	<compile files="FieldJoinPointsInAroundAdvice.java"/>
    	<run class="FieldJoinPointsInAroundAdvice"/>
   	</ajc-test>
   	
   	<ajc-test dir="bugs/AroundAdviceJPs" pr="71377"
    	title="Cannot advise private field gets in around advice">
    	<compile files="FieldGetJoinPointsInAroundAdvice.java"/>
    	<run class="FieldGetJoinPointsInAroundAdvice"/>
   	</ajc-test>
======= fetch "public Field getTjpField(BcelShadow shadow) {" 851da68^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"


======= fetch "public boolean canBeSeenBy(" 061395c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= fetch "public boolean canBeSeenBy(" 061395c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= fetch "public ResolvedTypeX getSuperclass() {" 061395c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

======= fetch "public boolean isExposedToWeaver() {" 061395c^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

                    world.resolve(CLONEABLE), 
                    world.resolve(SERIALIZABLE)
======= fetch "public final ResolvedTypeX getSuperclass() {" 061395c^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

            return world.resolve(OBJECT);
======= fetch "public void addInterTypeMunger(ConcreteTypeMunger munger) {" 061395c^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= fetch "private Collection collectCheckedExceptions(TypeX[] excs) {" 061395c^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= fetch "InstructionList createThisJoinPoint() {" 061395c^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "InstructionList createThisJoinPoint() {" 061395c^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public BcelVar getThisJoinPointStaticPartBcelVar() {" 061395c^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    				world.resolve(TypeX.forName("org.aspectj.lang.JoinPoint$StaticPart")),
======= fetch "private void addPreInitializationReturnCode(" 061395c^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "private ResolvedTypeX maybeGetNewParent(ResolvedTypeX targetType, TypePattern ty" 061395c^:"weaver/src/org/aspectj/weaver/patterns/DeclareParents.java"

======= fetch "public void resolve(IScope scope) {" 061395c^:"weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java"

    		if (!scope.getWorld().resolve(TypeX.THROWABLE).isAssignableFrom(excType)) {

======= fetch "public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r" 648c0f4^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= fetch "public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r" 648c0f4^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= fetch "public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r" 648c0f4^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= fetch "private AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler) {" 648c0f4^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

======= fetch "public void testDefaultClasspathAndTargetCombo() throws InvalidInputException {" 648c0f4^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

    		List cp = config.getClasspath();
    		boolean jar1Found = false;
    		boolean jar2Found = false;
    		for (Iterator iter = cp.iterator(); iter.hasNext();) {
                String element = (String) iter.next();
                if (element.indexOf("1.jar") != -1) jar1Found = true;
                if (element.indexOf("2.jar") != -1) jar2Found = true;
            }
======= fetch "public void testDefaultClasspathAndTargetCombo() throws InvalidInputException {" 648c0f4^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

    			config.getClasspath().contains("1.jar"));
======= fetch "public void testDefaultClasspathAndTargetCombo() throws InvalidInputException {" 648c0f4^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

    			config.getClasspath().contains("2.jar"));
======= fetch "public void testDefaultClasspathAndTargetCombo() throws InvalidInputException {" 648c0f4^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

======= fetch "public void testSourceRootDirWithFiles() throws InvalidInputException, IOExcepti" 648c0f4^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

======= fetch "public void testExtDirs() throws InvalidInputException {" 648c0f4^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

======= fetch "public void testBootclasspath() throws InvalidInputException {" 648c0f4^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

======= fetch "public void testClasspathSetting() throws InvalidInputException {" 648c0f4^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

   		List cp = config.getClasspath();
            String element = (String) iter.next();
            if (element.indexOf("1.jar") != -1) jar1Found = true;
            if (element.indexOf("2.jar") != -1) jar2Found = true;
        }
======= fetch "public void testClasspathSetting() throws InvalidInputException {" 648c0f4^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

======= fetch "public void testClasspathSetting() throws InvalidInputException {" 648c0f4^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

    protected File relativeDirectory = null;
======= fetch "private void parseConfigFileHelper(File configFile) {" 648c0f4^:"util/src/org/aspectj/util/ConfigParser.java"

        File oldRelativeDirectory = relativeDirectory; // for nested arg files;
        relativeDirectory = configFile.getParentFile();
======= fetch "private void parseConfigFileHelper(File configFile) {" 648c0f4^:"util/src/org/aspectj/util/ConfigParser.java"

        relativeDirectory = oldRelativeDirectory;
======= fetch "public File makeFile(String name) {" 648c0f4^:"util/src/org/aspectj/util/ConfigParser.java"

        return makeFile(getCurrentDir(), name);

    
    <ajc-test dir="bugs" pr="60015"
      title="NPE, Incorrect XLint:unmatchedSuperTypeInCall warning">
      <compile files="IncorrectXlintOnInterface.java">
      </compile>
    </ajc-test>
======= fetch "private void warnOnConfusingSig(Shadow shadow) {" ef7885f^:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"


======= fetch "public static Test suite() {" 2b8fa31^:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
======= fetch "private void copyResourcesFromJarFile(File jarFile) throws IOException {" 2b8fa31^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private boolean acceptResource(String resourceName) {" 2b8fa31^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public static void main(String[] args) throws IOException {" 2b8fa31^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"

======= fetch "public static void makeURLWeavingClassLoaderJars() throws IOException {" 2b8fa31^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"

======= fetch "public static void makeURLWeavingClassLoaderJars() throws IOException {" 2b8fa31^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"

======= fetch "public List addJarFile(File inFile, File outDir, boolean canBeDirectory){" 2b8fa31^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public List addJarFile(File inFile, File outDir, boolean canBeDirectory){" 2b8fa31^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public List addJarFile(File inFile, File outDir, boolean canBeDirectory){" 2b8fa31^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public List addJarFile(File inFile, File outDir, boolean canBeDirectory){" 2b8fa31^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public List addJarFile(File inFile, File outDir, boolean canBeDirectory){" 2b8fa31^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public List addJarFile(File inFile, File outDir, boolean canBeDirectory){" 2b8fa31^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public List addJarFile(File inFile, File outDir, boolean canBeDirectory){" 2b8fa31^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public void addManifest (Manifest newManifest) {" 2b8fa31^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public void addManifest (Manifest newManifest) {" 2b8fa31^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


    <ajc-test dir="bugs"
        <compile files="WithincodeNPE01.java">
          <!-- there are 3 join points that result in decw match, but 2 are on the same line! -->
          <message kind="warning" line="2" text="In String ctor"/>
          <message kind="warning" line="11" text="In String ctor"/>
        </compile>
    </ajc-test>
  public A.new(String s) { }
  public void A.foo() { int i = 1; }
  
  declare warning: withincode(void main(..)): "X"; // Would NPE without the fix for PR67774
  
  declare warning: withincode(A.new(String)): "In String ctor";
  
  private final static String name = A.class.getName();
======= fetch "public Member getEnclosingCodeSignature() {" 7f19ab4^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    	} else if (getKind() == Shadow.PreInitialization) {
          // PreInit doesn't enclose code but its signature
          // is correctly the signature of the ctor.
    	  return getSignature();

======= fetch "public void warnOnAddedInterface (ResolvedTypeX type, ResolvedTypeX parent) {" 9aed31d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "public BinaryTypeBinding createBinaryTypeFrom(" 9aed31d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "public BinaryTypeBinding createBinaryTypeFrom(" 9aed31d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "public BinaryTypeBinding createBinaryTypeFrom(" 9aed31d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "public BinaryTypeBinding createBinaryTypeFrom(" 9aed31d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "public BinaryTypeBinding createBinaryTypeFrom(" 9aed31d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"


======= fetch "public boolean match(Shadow shadow, World world) {" 4feb835^:"weaver/src/org/aspectj/weaver/Advice.java"

======= fetch "public boolean match(Shadow shadow, World world) {" 4feb835^:"weaver/src/org/aspectj/weaver/Advice.java"

======= fetch "public boolean match(Shadow shadow, World world) {" 4feb835^:"weaver/src/org/aspectj/weaver/Advice.java"

======= fetch "public boolean match(Shadow shadow, World world) {" 4feb835^:"weaver/src/org/aspectj/weaver/Advice.java"

======= fetch "public boolean match(Shadow shadow, World world) {" 4feb835^:"weaver/src/org/aspectj/weaver/Advice.java"

    							"applying to join point that doesn't return void: " + shadow,
======= fetch "public boolean match(Shadow shadow, World world) {" 4feb835^:"weaver/src/org/aspectj/weaver/Advice.java"

======= fetch "public void setFromProperties(File file) {" 4feb835^:"weaver/src/org/aspectj/weaver/Lint.java"

======= fetch "public void loadDefaultProperties() {" 4feb835^:"weaver/src/org/aspectj/weaver/Lint.java"

======= fetch "public void loadDefaultProperties() {" 4feb835^:"weaver/src/org/aspectj/weaver/Lint.java"

======= fetch "public void setFromProperties(Properties properties) {" 4feb835^:"weaver/src/org/aspectj/weaver/Lint.java"

======= fetch "public void setFromProperties(Properties properties) {" 4feb835^:"weaver/src/org/aspectj/weaver/Lint.java"

======= fetch "public void check(World world) {" 4feb835^:"weaver/src/org/aspectj/weaver/NewConstructorTypeMunger.java"

======= fetch "private boolean compareToExistingMembers(ConcreteTypeMunger munger, Iterator exi" 4feb835^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= fetch "public boolean checkLegalOverride(ResolvedMember parent, ResolvedMember child) {" 4feb835^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= fetch "public boolean checkLegalOverride(ResolvedMember parent, ResolvedMember child) {" 4feb835^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= fetch "public boolean checkLegalOverride(ResolvedMember parent, ResolvedMember child) {" 4feb835^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= fetch "public boolean checkLegalOverride(ResolvedMember parent, ResolvedMember child) {" 4feb835^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= fetch "public boolean checkLegalOverride(ResolvedMember parent, ResolvedMember child) {" 4feb835^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= fetch "public boolean checkLegalOverride(ResolvedMember parent, ResolvedMember child) {" 4feb835^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= fetch "private void interTypeConflictError(" 4feb835^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= fetch "public List getExposedPointcuts() {" 4feb835^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= fetch "private void addPointcutsResolvingConflicts(List acc, List added, boolean isOver" 4feb835^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= fetch "protected boolean checkCanThrow(ShadowMunger munger, ResolvedTypeX resolvedTypeX" 4feb835^:"weaver/src/org/aspectj/weaver/Shadow.java"

======= fetch "private void sortMungers() {" 4feb835^:"weaver/src/org/aspectj/weaver/Shadow.java"

 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
======= fetch "public List getTypeMungers(ResolvedTypeX onType) {" 4feb835^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public ResolvedTypeX resolve(TypeX ty, boolean allowMissing) {" 4feb835^:"weaver/src/org/aspectj/weaver/World.java"

                MessageUtil.error(messageHandler, "can't find type " + ty.getName());
======= fetch "public boolean weave() {" 4feb835^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        		  WeaverMessages.format(WeaverMessages.ALREADY_WOVEN,clazz.getType().getName()),
======= fetch "public void prepareToProcessReweavableState() {" 4feb835^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public void processReweavableStateIfPresent(String className, BcelObjectType cla" 4feb835^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public void processReweavableStateIfPresent(String className, BcelObjectType cla" 4feb835^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public void processReweavableStateIfPresent(String className, BcelObjectType cla" 4feb835^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public void weave(ResolvedTypeX onType) {" 4feb835^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public void addPath (String name, IMessageHandler handler) {" 4feb835^:"weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"

======= fetch "public void addPath (String name, IMessageHandler handler) {" 4feb835^:"weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"

======= fetch "public void addPath (String name, IMessageHandler handler) {" 4feb835^:"weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"

======= fetch "private void writeBack(BcelWorld world) {" 4feb835^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= fetch "public Method getMethod() {" 4feb835^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    			IMessage.ERROR, "problem generating method " + 
    			this.getClassName() + "." + this.getName() + ": " + e.getMessage(),
======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= fetch "private ResolvedTypeX maybeGetNewParent(ResolvedTypeX targetType, TypePattern ty" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/DeclareParents.java"

======= fetch "private ResolvedTypeX maybeGetNewParent(ResolvedTypeX targetType, TypePattern ty" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/DeclareParents.java"

======= fetch "private ResolvedTypeX maybeGetNewParent(ResolvedTypeX targetType, TypePattern ty" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/DeclareParents.java"

======= fetch "private ResolvedTypeX maybeGetNewParent(ResolvedTypeX targetType, TypePattern ty" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/DeclareParents.java"

======= fetch "public void resolve(IScope scope) {" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

    					"circularity in declare precedence, '*' occurs more than once",
    					pi.getSourceLocation(), null);    				
======= fetch "public void resolve(IScope scope) {" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

    				"Non-aspect types can only be specified in a declare precedence statement when subtypes are included.  Non-aspect type is : "+exactType.getName(),
    				pi.getSourceLocation(),null);
======= fetch "public void resolve(IScope scope) {" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

    					"circularity in declare precedence, '" + exactType.getName() + 
    						"' matches two patterns", pi.getSourceLocation(), pj.getSourceLocation());
======= fetch "private int matchingIndex(ResolvedTypeX a) {" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

======= fetch "public void resolve(IScope scope) {" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java"

    					excType.getName() + " is not a subtype of Throwable",
======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "public Pointcut concretize1(" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "public Pointcut concretize1(" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "public PerClause concretize(ResolvedTypeX inAspect) {" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java"

======= fetch "public PerClause concretize(ResolvedTypeX inAspect) {" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java"

======= fetch "public Pointcut concretize1(ResolvedTypeX searchStart, IntMap bindings) {" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= fetch "public Pointcut concretize1(ResolvedTypeX searchStart, IntMap bindings) {" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= fetch "public Pointcut concretize1(ResolvedTypeX searchStart, IntMap bindings) {" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= fetch "protected TypePattern notExactType(IScope s) {" 4feb835^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= fetch "public TypePattern resolveBindings(IScope scope, Bindings bindings," 4feb835^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "public TypePattern resolveBindings(IScope scope, Bindings bindings," 4feb835^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "public static Test suite() {" 4feb835^:"weaver/testsrc/org/aspectj/weaver/BcweaverTests.java"

 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
 * @author colyer
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Generation - Code and Comments
 */

    <ajc-test dir="bugs"
        <compile files="EllipsesStar.java">
          <message kind="error" line="3" text="Syntax error on token"/>
          <message kind="error" line="4" text="Syntax error on token"/>
          <message kind="error" line="5" text="Syntax error on token"/>
          <message kind="error" line="6" text="Syntax error on token"/>
          <message kind="error" line="8" text="Syntax error on token"/>
          <message kind="error" line="10" text="Syntax error on token"/>
          <message kind="error" line="12" text="Syntax error on token"/>
        </compile>
    </ajc-test>
    
======= fetch "public List parseDottedNamePattern() {" 45bce91^:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"

======= fetch "public List parseDottedNamePattern() {" 45bce91^:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"

======= fetch "public List parseDottedNamePattern() {" 45bce91^:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"

======= fetch "public List parseDottedNamePattern() {" 45bce91^:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"

======= fetch "public List parseDottedNamePattern() {" 45bce91^:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"

======= fetch "public List parseDottedNamePattern() {" 45bce91^:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"

======= fetch "public List parseDottedNamePattern() {" 45bce91^:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"


======= fetch "public Pointcut maybeGetParsedPointcut() {" 10c6de6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/IfPseudoToken.java"

======= fetch "public Pointcut maybeGetParsedPointcut() {" 10c6de6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/IfPseudoToken.java"

   
      <ajc-test dir="new"
      title="if(false) optimisation" pr="48990">
        <compile files="IfFalse.aj"/>
        <run class="IfFalse"/>
    </ajc-test>
   
    <ajc-test dir="new"
      title="if(true) optimisation" pr="48990">
        <compile files="IfTrue.aj"/>
        <run class="IfTrue"/>
    </ajc-test> 
======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" 10c6de6^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" 10c6de6^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "public FuzzyBoolean match(JoinPoint.StaticPart jpsp) {" 10c6de6^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= fetch "public static Pointcut read(DataInputStream s, ISourceContext context) throws IO" 10c6de6^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= fetch "public static Pointcut makeMatchesNothing(State state) {" 10c6de6^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

    

======= fetch "private ReferenceContext findReferenceContextFor(CompilationResult result) {" 573741c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java"

======= fetch "private ReferenceContext findReferenceContextFor(CompilationResult result) {" 573741c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java"

======= fetch "private ReferenceContext findReferenceContextFor(CompilationResult result) {" 573741c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java"

======= fetch "private ReferenceContext findReferenceContextFor(CompilationResult result) {" 573741c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java"

======= fetch "private ReferenceContext findReferenceContextFor(CompilationResult result) {" 573741c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java"

======= fetch "private ReferenceContext findReferenceContextFor(CompilationResult result) {" 573741c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java"

    <ajc-test dir="bugs/abstractITDs"
        <compile files="A.java,C.java" aspectpath="B.jar">
          <message kind="error" line="1" text="must implement abstract inter-type declaration: void A.foo()"/>
        </compile>
    </ajc-test>
    
======= fetch "public void checkInterTypeMungers() {" 573741c^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

            	ISourceLocation xtraLocation = element.getSourceLocation();
            	if (xtraLocation == null) {
            		// Until intertype mungers remember where they came from, the source location
            		// for the element is null when binary weaving.  In these cases uses the
            		// source location for the aspect containing the ITD
     				xtraLocation = element.getAspectType().getSourceLocation();
            	}
======= fetch "public void checkInterTypeMungers() {" 573741c^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

                        new ISourceLocation[] { element.getSourceLocation() }));

======= fetch "public boolean runCommand(String[] args, IMessageHandler handler) {" 6ea8300^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"

            if ("-help".equals(args[i])) {
                // should be info, but handler usually suppresses
                MessageUtil.abort(handler, BuildArgParser.getUsage());
======= fetch "public static String getUsage() {" 6ea8300^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

    public static String getXOptionUsage() {
    	return Main.bind("xoption.usage");
    }
    
======= fetch "protected void showWarning(String message) {" 6ea8300^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= fetch "public void run(String[] args, IMessageHolder holder) {" 6ea8300^:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"

            args = new String[] { "-help" };
======= fetch "public static Test suite() {" 6ea8300^:"org.aspectj.ajdt.core/testsrc/EajcModuleTests.java"

        suite.addTestSuite(org.aspectj.tools.ajc.MainTest.class);
======= fetch "public void testMainbare() {" 6ea8300^:"org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/MainTest.java"

        Main.bareMain(new String[] {"-help"}, false, list, null, null, null);
        assertTrue(1 == list.size());
        Object o = list.get(0);
======= fetch "public void testMainbare() {" 6ea8300^:"org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/MainTest.java"

        assertTrue(-1 != ((String)o).indexOf("-aspectpath"));
        assertTrue(-1 != ((String)o).indexOf("-incremental"));

    
    <ajc-test dir="bugs/intertypeOverrides"
        <compile files="IntertypeOverrides.java">
          <message kind="error" line="8" text="void Sub.m() cannot override void Super.m(); overriding method is static"/>
        </compile>
        <compile files="IntertypeOverrides2.java">
          <message kind="error" line="8" text="void Sub.m() cannot override void Super.m(); overridden method is static"/>
        </compile>
        <compile files="Superclass.java,Subclass.java,Aspect1.java">
          <message file="Aspect1.java" kind="error" line="2" 
             text="void Subclass.staticMethod() cannot override void Superclass.staticMethod(); overridden method is static"/>
        </compile>
        <compile files="Superclass.java,Subclass.java,Aspect2.java">
          <message file="Aspect2.java" kind="error" line="2"
             text="void Subclass.nonstaticMethod() cannot override void Superclass.nonstaticMethod(); overriding method is static"/>
        </compile>
    </ajc-test>
    
  public void Subclass.staticMethod() {};
  public static void Subclass.nonstaticMethod() {};
  public void m(){};
  public static void Sub.m(){}
  public static void m(){};
  public void Sub.m(){}
  public static void staticMethod(){} {}
  public void nonstaticMethod() {};
======= fetch "private boolean compareToExistingMembers(ConcreteTypeMunger munger, Iterator exi" b184363^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= fetch "private boolean compareToExistingMembers(ConcreteTypeMunger munger, Iterator exi" b184363^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= fetch "public boolean checkLegalOverride(ResolvedMember parent, ResolvedMember child) {" b184363^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"


    <ajc-test dir="bugs"
        <compile files="Cosmetic.java">
        <message kind="error" line="9" text="can't bind type name 'unknown.Error'"/>
        </compile>
    </ajc-test> 
 class Test {
======= fetch "public TypePattern resolveBindings(IScope scope, Bindings bindings," 936459c^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "public TypePattern resolveBindings(IScope scope, Bindings bindings," 936459c^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "public TypePattern resolveBindings(IScope scope, Bindings bindings," 936459c^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "public TypePattern resolveBindings(IScope scope, Bindings bindings," 936459c^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"


    
    <ajc-test dir="bugs/bug70619"
        <compile files="Precedence.java">
          <message kind="error" line="0" text="conflicting declare precedence"/>
        </compile>
        <compile files="Conflict.java,Order2.aj,Order1.aj">        
          <message kind="error" line="0" text="conflicting declare precedence"/>
        </compile>
        <compile files="Conflict.java,Order1.aj,Order2.aj">
          <message kind="error" line="0" text="conflicting declare precedence"/>
        </compile>
    </ajc-test>
  
  
  
  declare precedence: Conflict1, Conflict2;
   before(): execution(* *(..)) { }
  declare precedence: Conflict2, Conflict1;
 
  declare precedence: Conflict1,Conflict2;
  before(): execution(* *(..)) { }
  declare precedence: Conflict2, Conflict1;
  after(): execution(* *(..)) { }
======= fetch "public int compareByDominates(ResolvedTypeX aspect1, ResolvedTypeX aspect2) {" 75852d7^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public int compareByDominates(ResolvedTypeX aspect1, ResolvedTypeX aspect2) {" 75852d7^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public int compareByDominates(ResolvedTypeX aspect1, ResolvedTypeX aspect2) {" 75852d7^:"weaver/src/org/aspectj/weaver/World.java"


======= fetch "static void decorateHTMLFromDecl(Declaration decl," 8dc0845^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

                    
======= fetch "private static String constructNestedTypeName(IProgramElement node) {" 8dc0845^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

    /**
     * Skips files that are public in the model but not public in the source,
     * e.g. nested aspects.
     */
======= fetch "static void decorateHTMLFile(File file) throws IOException {" 8dc0845^:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        System.out.println( "> Decorating " + file.getCanonicalPath() + "..." );
        BufferedReader reader = new BufferedReader(new FileReader(file));
======= fetch "public void testCoverage() {" 8dc0845^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

======= fetch "public void testCoverage() {" 8dc0845^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

======= fetch "public void testCoverage() {" 8dc0845^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

======= fetch "public void testCoverage() {" 8dc0845^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

======= fetch "public void testCoverage() {" 8dc0845^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

======= fetch "public void testCoverage() {" 8dc0845^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

    
======= fetch "public void testSimpleExample() {" 8dc0845^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.java"

======= fetch "public void testSimpleExample() {" 8dc0845^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.java"

======= fetch "public void testSimpleExample() {" 8dc0845^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.java"


======= fetch "static void processFile(SymbolManager symbolManager, File inputFile, File signat" 2cc4826^:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

            if (packageName != null ) {
======= fetch "public void testCoverage() {" 2cc4826^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

======= fetch "public void testCoverage() {" 2cc4826^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"


    <classpathentry kind="src" path="src"/>
    <classpathentry kind="con" path="org.eclipse.jdt.launching.JRE_CONTAINER"/>
    <classpathentry kind="src" path="/asm"/>
    <classpathentry kind="src" path="/org.aspectj.ajdt.core"/>
    <classpathentry kind="src" path="/bridge"/>
    <classpathentry kind="src" path="/util"/>
    <classpathentry kind="lib" path="C:/Apps/j2sdk1.4.2/lib/tools.jar"/>
    <classpathentry kind="src" path="testsrc"/>
    <classpathentry kind="lib" path="/lib/junit/junit.jar" sourcepath="/lib/junit/junit-src.jar"/>
    <classpathentry kind="output" path="bin"/>
======= fetch "public static void main(String[] args) {" 3707411^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

                inputFiles[i]     = findFile((String)filenames.elementAt(i));
======= fetch "public static void main(String[] args) {" 3707411^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

                    javadocargs[options.size() + k] = signatureFiles[k].getCanonicalPath();
======= fetch "private static void removeDeclIDsFromFile(String filename, boolean relativePath)" 3707411^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

    /**
     * If the file doesn't exist on the specified path look for it in all the other
     * paths specified by the "sourcepath" option.
     */
    static File findFile( String filename ) throws IOException {
        return new File( filename );
        /*
        File file = new File(filename);
        if (file.exists()) {
            return file;
        }
        else {
            for ( int i = 0; i < sourcePath.size(); i++ ) {
                File currPath = new File((String)sourcePath.elementAt(i));
                File currFile = new File(currPath + "/" + filename); // !!!
                if ( file.exists()) {
                    return file;
                }
            }
        }
        throw new IOException("couldn't find source file: " + filename);
        */
    }
======= fetch "static void parseCommandLine(String[] args) {" 3707411^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

        	
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" 3707411^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            String arg = (String)vargs.get(i);
======= fetch "static void parseArgs(List vargs, File currentWorkingDir) {" 3707411^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

                if ((arg.endsWith(".java") && entryName.indexOf('.') == entryName.length()-5) ||
                     arg.endsWith(".lst") &&
                     arg != null ) {
======= fetch "public boolean accept( File dir, String name )  {" 3707411^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

                                        (name.substring(index1, index2).equals( ".java" ) ) ) {
======= fetch "public boolean accept( File dir, String name )  {" 3707411^:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

        }
======= fetch "public static boolean isAnonymous(IProgramElement node) {" 3707411^:"ajdoc/src/org/aspectj/tools/ajdoc/StructureUtil.java"

    	if (path.endsWith(".aj")) {
    		path = path.substring(0, path.lastIndexOf(".aj")) + ".java";
    	} 
    	return path;
======= fetch "static void processFile(SymbolManager symbolManager, File inputFile, File signat" 3707411^:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

            PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(signatureFile.getCanonicalPath())));
            
 
======= fetch "public void testCoverage() {" 3707411^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

======= fetch "public void testCoverage() {" 3707411^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

======= fetch "public void testCoverage() {" 3707411^:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"


======= fetch "public boolean onWindowsPro() {" 39c3a3b^:"build/src/$installer$/org/aspectj/Main.java"

        return getOS().equals("Windows NT") || getOS().equals("Windows 2000");

======= fetch "public static void makeURLWeavingClassLoaderJars() throws IOException {" 9ebfc84^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"

======= fetch "public boolean handleMessage(IMessage message) throws AbortException {" 9ebfc84^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public boolean isIgnoring(Kind kind) {" 9ebfc84^:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= fetch "public void testWeaveAdvice () {" 9ebfc84^:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"


    private static final boolean EXISTS = true;
======= fetch "public boolean start(IMessageHandler handler, File baseDir) {" bd16033^:"testing/src/org/aspectj/testing/harness/bridge/DirChanges.java"

     * This sleeps before checking until at least DELAY milliseconds after start.
======= fetch "public boolean end(IMessageHandler handler, File srcBaseDir) {" bd16033^:"testing/src/org/aspectj/testing/harness/bridge/DirChanges.java"

        final long targetTime = startTime + DELAY;
        do {
            long curTime = System.currentTimeMillis();
            if (curTime >= targetTime) {
                break;
            }
            try {
                break;
            }
        } while (true);

    private Hashtable stacks = new Hashtable();
    private Thread cached_thread;
    private Stack cached_stack;
    private int change_count = 0;
    private static final int COLLECT_AT = 20000;
    private static final int MIN_COLLECT_AT = 100;
    private synchronized Stack getThreadStack() {
        if (Thread.currentThread() != cached_thread) {
            cached_thread = Thread.currentThread();
            cached_stack = (Stack)stacks.get(cached_thread);
            if (cached_stack == null) {
                cached_stack = new Stack();
                stacks.put(cached_thread, cached_stack);
            }
            change_count++;
            // Collect more often if there are many threads, but not *too* often
            int size = Math.max(1, stacks.size()); // should be >1 b/c always live threads, but...
            if (change_count > Math.max(MIN_COLLECT_AT, COLLECT_AT/size)) {
                Stack dead_stacks = new Stack();
                for (Enumeration e = stacks.keys(); e.hasMoreElements(); ) {
                    Thread t = (Thread)e.nextElement();
                    if (!t.isAlive()) dead_stacks.push(t);
                }
                for (Enumeration e = dead_stacks.elements(); e.hasMoreElements(); ) {
                    Thread t = (Thread)e.nextElement();
                    stacks.remove(t);
                }
                change_count = 0;
            }
        }
        return cached_stack;
======= fetch "public boolean isValid() {" 5f6b18b^:"runtime/src/org/aspectj/runtime/internal/CFlowStack.java"

        
    
 * Copyright (c) 2004 IBM Corporation
 * 
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     initial implementation 
 * ******************************************************************/
 * Copyright (c) 2004 IBM Corporation
 * 
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     initial implementation 
 * ******************************************************************/
  public ThreadStack getNewThreadStack();  
  
 * Copyright (c) 2004 IBM Corporation
 * 
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     initial implementation 
 * ******************************************************************/
 * Copyright (c) 2004 IBM Corporation
 * 
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     initial implementation 
 * ******************************************************************/
 * Copyright (c) 2004 IBM Corporation
 * 
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     initial implementation 
 * 					   Copied from bits of original CFlowStack
 * ******************************************************************/

======= fetch "public void showSourceLine(ISourceLocation sourceLocation, boolean highlight) {" a17b51b^:"ajbrowser/src/org/aspectj/tools/ajbrowser/BasicEditor.java"

    	try {
    		showSourceLine(sourceLocation.getSourceFile().getAbsolutePath(), sourceLocation.getLine(), highlight);
    	} catch (NullPointerException npe) {
    		Ajde.getDefault().getIdeUIAdapter().displayStatusInformation(" no corresponding source line to seek to");
    	}
    }
    	

======= fetch "public static String makeLocationContext(ICompilationUnit compilationUnit, IProb" a97f3b6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"

            || ((startPosition <= 0) && (endPosition <= 0)))

======= fetch "private void generateMethod(ClassFile classFile, MethodBinding methodBinding, Bo" b0d32ca^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"


======= fetch "public void afterCompiling() {" e7ac54f^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"


======= fetch "public FieldBinding getField(" 0521e79^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.java"

======= fetch "public static void makeTestJars() throws IOException {" 0521e79^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"

======= fetch "public static void makeURLWeavingClassLoaderJars() throws IOException {" 0521e79^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"

    <ajc-test dir="bugs/StringToString" pr="55341"
     		comment="make helloworld.jar with 'ajc -outjar helloworld.jar HW.java' or run BcweaverJarMaker"
     		keywords="">
        <compile files="X.java" classpath="helloworld.jar">
        	<message kind="warning" line="3"/>
        	<message kind="warning" line="7"/>
        </compile>
    </ajc-test>
  String message = "Hello World!";
  private int HW.intField = 999;
  public String HW.getMessage () {
    return message;
  }
======= fetch "public void testWeavingITD () {" 0521e79^:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= fetch "public void testWeavingAspects () {" 0521e79^:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"


       description="javadoc for AspectJ lang and lang.reflect">
        <javadoc sourcepath="${aspectj.modules.dir}/runtime/src"
               packagenames="org.aspectj.lang,org.aspectj.lang.reflect" />
======= fetch "public static void main(String[] args) throws IOException {" 33d8ee9^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"

======= fetch "public static void makeTestJars() throws IOException {" 33d8ee9^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"

======= fetch "private static void listFiles(final File baseDir, String dir, ArrayList result)" 33d8ee9^:"util/src/org/aspectj/util/FileUtil.java"

 * Copyright (c) 2004 IBM Corporation
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Matthew Webster, Adrian Colyer, 
 *     Martin Lippert     initial implementation 
 * ******************************************************************/
 * Copyright (c) 2004 IBM Corporation
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Matthew Webster, Adrian Colyer, 
 *     Martin Lippert     initial implementation 
 * ******************************************************************/
 * Copyright (c) 2004 IBM Corporation
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Matthew Webster, Adrian Colyer, 
 *     Martin Lippert     initial implementation 
 * ******************************************************************/
 * Interface implemented by weaving class loaders to allow classes generated by
 * the weaving process to be defined.
 */
 * Copyright (c) 2004 IBM Corporation
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Matthew Webster, Adrian Colyer, 
 *     Martin Lippert     initial implementation 
 * ******************************************************************/
 * This adaptor allows the AspectJ compiler to be embedded in an existing
 * system to facilitate load-time weaving. It provides an interface for a
 * weaving class loader to provide a classpath to be woven by a set of
 * aspects. A callback is supplied to allow a class loader to define classes
 * generated by the compiler during the weaving process.
 * <p>
 * A weaving class loader should create a <code>WeavingAdaptor</code> before
 * any classes are defined, typically during construction. The set of aspects 
 * passed to the adaptor is fixed for the lifetime of the adaptor although the
 * classpath can be augmented. A system property can be set to allow verbose
 * weaving messages to be written to the console.
 *
 */
     * @param loader instance of <code>ClassLoader</code>
     * @param classURLs the URLs from which to resolve classes
     * @param aspectURLs the aspects used to weave classes defined by this class loader
     * @exception IOException weave failed
 * Copyright (c) 2004 IBM Corporation
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Matthew Webster, Adrian Colyer, 
 *     Martin Lippert     initial implementation 
 * ******************************************************************/
 * An interface for weaving class loaders to provide callbacks for a
 * WeavingAdaptor.
 */
======= fetch "public static Test suite() {" 33d8ee9^:"weaver/testsrc/BcweaverModuleTests.java"

        suite.addTest(org.aspectj.weaver.patterns.PatternsTests.suite()); 
======= fetch "public static Test suite() {" 33d8ee9^:"weaver/testsrc/org/aspectj/weaver/BcweaverTests.java"

        suite.addTestSuite(TypeXTestCase.class); 

    <ajc-test dir="bugs/declarePrecedenceWithClasses" pr="53012"
   	 title="declare precedence on a class should be a compile-time error">
        <compile files="DeclarePrecedenceTestClass.java" >
          <message kind="error" line="10" text="Non-aspect types can only be specified"/>
        </compile>
    </ajc-test>
    
    <ajc-test dir="bugs/declarePrecedenceWithClasses" pr="53012"
   	 title="declare precedence on a class should be a compile-time error">
        <compile files="Priority.aj" />
    </ajc-test>
======= fetch "public void resolve(IScope scope) {" 0a01759^:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

    		
    		// Cannot do a dec prec specifying a non-aspect types unless suffixed with a '+'
    		if (!exactType.isAspect() && !pi.isIncludeSubtypes()) {
    			scope.getWorld().showMessage(IMessage.ERROR,
    				"Non-aspect types can only be specified in a declare precedence statement when subtypes are included.  Non-aspect type is : "+exactType.getName(),
    				pi.getSourceLocation(),null);
    		}
    		

    

    
     
    <ajc-test dir="incremental/initialTests/classWAroundClosureRemoved"
      title="make sure additional classes generated during weave are deleted with src class file"
      keywords="incremental-test">
      <compile staging="true" 
        	options="-incremental"
        	sourceroots="."/>
        <inc-compile tag="20" >
            <dir-changes removed="AdviceOnIntroduced$AjcClosure1"/>
        </inc-compile>
    </ajc-test>
    
    public static void main(String[] args) { test(); }
    public static void test() {
    }
    
    int Foo.foo(int n) { return n; }
    Foo.new(int w) {}
        
    int around(int n):
        within(AdviceOnIntroduced) &&
        (args(n) && execution(int foo(int))) {
            int result = proceed(n);
            return result+1;
        }
    
    before(): within(Foo) && execution(new(..)) {
    }
    public static void main(String[] args) { test(); }
    public static void test() {
    }
    
    int Foo.foo(int n) { return n; }
    Foo.new(int w) {}
        
    int around(int n):
        within(AdviceOnIntroduced) &&
        (args(n) && execution(int foo(int))) {
            int result = proceed(n);
            return result+1;
        }
    
    before(): within(Foo) && execution(new(..)) {
    }
======= fetch "public String toString() {" 7d6b500^:"weaver/src/org/aspectj/weaver/bcel/UnwovenClassFile.java"

======= fetch "public void deleteRealFile() throws IOException {" 7d6b500^:"weaver/src/org/aspectj/weaver/bcel/UnwovenClassFile.java"

======= fetch "public void deleteRealFile() throws IOException {" 7d6b500^:"weaver/src/org/aspectj/weaver/bcel/UnwovenClassFile.java"


======= fetch "public void setText(String text) {" 183fc23^:"ajde/src/org/aspectj/ajde/internal/BuildNotifierAdapter.java"

  pointcut m1(): execution(* main(..));
  
  before(): m1() {
    System.err.println("Before main runs");
  }
  pointcut m1(): execution(* main(..));
  
  after(): m1() {
    System.err.println("After main runs");
  }
  pointcut m1(): call(* *print*(..));
  
  before(): m1() {
    System.err.println("Calling print");
  }
  pointcut m1(): call(* *print*(..));
  
  after(): m1() {
    System.err.println("After call to print");
  }
======= fetch "public static Test suite() {" 183fc23^:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

 * Copyright (c) 2004 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     Initial version
 * ******************************************************************/
 * It is now possible to cancel the compiler during either the
 * compilation or weaving phases - this testcase verifies a few
 * cases, making sure the process stops when expected.  It can
 * check the disk contents, but it doesn't right now.
 * 
 * Two different .lst files are used during these tests: LoadsaCode.lst and 
 * EvenMoreCode.lst which contain mixes of aspects and classes
 * 
 * Here are some things to think about that will help you understand what is 
 * on the disk when we cancel the compiler.
 * 
 * There are 3 important phases worth remembering :
 * - Compile all the types 
 * - Weave all the aspects
 * - Weave all the classes
 * 
 * Each of those steps goes through all the types.  This
 * means during the 'weave all the aspects' step we are 
 * jumping over classes and during the 'weave all the
 * classes ' step we are jumping over aspects.  Why is this important?
 * 
 *  
 * We only write bytes out during the 'weave all the classes ' phase and it is even
 * during that phase that we write out the bytes for aspects.  This means if you cancel
 * during compilation or during the weaving of aspects - there will be nothing on the 
 * disk.  If you cancel whilst in the 'weave all the classes ' phase then the disk
 * will contain anything finished with by the cancellation point.
 */
        public int numWovenClassMessages = 0;
        public int numWovenAspectMessages = 0;
        public int numCompiledMessages = 0;
        
        
    /**
     * @param cancelRequested true if the caller wants the current compilation to stop asap
     */
======= fetch "public AjCompilerAdapter(Compiler compiler," 183fc23^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= fetch "public AjCompilerAdapter(Compiler compiler," 183fc23^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= fetch "public void afterProcessing(CompilationUnitDeclaration unit, int unitIndex) {" 183fc23^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= fetch "private void weave() throws IOException {" 183fc23^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= fetch "public WeaverAdapter(AjCompilerAdapter forCompiler," 183fc23^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java"

======= fetch "public WeaverAdapter(AjCompilerAdapter forCompiler," 183fc23^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java"

======= fetch "public Iterator getClassFileIterator() {" 183fc23^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java"

======= fetch "public Object next() {" 183fc23^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java"

======= fetch "public Object next() {" 183fc23^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java"

======= fetch "public void remove() {" 183fc23^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java"

======= fetch "public void remove() {" 183fc23^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java"

======= fetch "public void remove() {" 183fc23^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java"

======= fetch "public void weaveCompleted() {" 183fc23^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java"

======= fetch "public void acceptResult(UnwovenClassFile result) {" 183fc23^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java"

======= fetch "private void removeFromHashtable(Hashtable table, char[] key) {" 183fc23^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java"

======= fetch "protected boolean doBuild(" 183fc23^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

                    if (handler.hasErrors()) {
======= fetch "public void performCompilation(List files) {" 183fc23^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void acceptResult(InterimCompilationResult result) {" 183fc23^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public ICompilerAdapter getAdapter(org.eclipse.jdt.internal.compiler.Compiler fo" 183fc23^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"


 * Created on 30-Jul-03
 *
 * To change this generated comment go to 
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
 * @author websterm
 *
 * To change this generated comment go to 
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
======= fetch "public static Test suite() {" 34dbb0c^:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

======= fetch "public int fetchFromJar(File outjarFile, String filename) {" 34dbb0c^:"ajde/testsrc/org/aspectj/ajde/InpathTestcase.java"

======= fetch "public int fetchFromJar(File outjarFile, String filename) {" 34dbb0c^:"ajde/testsrc/org/aspectj/ajde/InpathTestcase.java"

======= fetch "public int fetchFromJar(File outjarFile, String filename) {" 34dbb0c^:"ajde/testsrc/org/aspectj/ajde/InpathTestcase.java"

======= fetch "public void compareJars(" 34dbb0c^:"ajde/testsrc/org/aspectj/ajde/InpathTestcase.java"

======= fetch "public void compareSourceToOutjar(String indirName, File outjarFile) {" 34dbb0c^:"ajde/testsrc/org/aspectj/ajde/InpathTestcase.java"

 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
 * Created on 16-Mar-2004
 *
 * To change the template for this generated file go to
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
 * @author websterm
 *
 * To change the template for this generated type comment go to
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
 
======= fetch "public void compareSourceToOutjar (String indirName, File outjarFile) {" 34dbb0c^:"ajde/testsrc/org/aspectj/ajde/ResourceCopyTestCase.java"

======= fetch "private boolean openOutputStream(File outJar)  {" 34dbb0c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesToDestination() throws IOException {" 34dbb0c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesFromJarFile(File jarFile) throws IOException {" 34dbb0c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void copyResourcesFromJarFile(File jarFile) throws IOException {" 34dbb0c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "private void writeResource(String filename, byte[] content, File srcLocation) th" 34dbb0c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public BcelWeaver() {" 34dbb0c^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public void addLibraryJarFile(File inFile) throws IOException  {" 34dbb0c^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public List addJarFile(File inFile, File outDir, boolean canBeDirectory){" 34dbb0c^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public List addJarFile(File inFile, File outDir, boolean canBeDirectory){" 34dbb0c^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public int compare(Object o1, Object o2) {" 34dbb0c^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

    
    public Manifest getManifest (boolean shouldCreate) {
    }
    

======= fetch "boolean prepareForNextBuild(AjBuildConfig newBuildConfig) {" 1a4c02c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"


======= fetch "boolean prepareForNextBuild(AjBuildConfig newBuildConfig) {" 41c6f6d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "public List getFilesToCompile(boolean firstPass) {" 41c6f6d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "public List getFilesToCompile(boolean firstPass) {" 41c6f6d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "public List getFilesToCompile(boolean firstPass) {" 41c6f6d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "public List getFilesToCompile(boolean firstPass) {" 41c6f6d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "public List getFilesToCompile(boolean firstPass) {" 41c6f6d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "public List getFilesToCompile(boolean firstPass) {" 41c6f6d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "public List getFilesToCompile(boolean firstPass) {" 41c6f6d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "private static StringSet makeStringSet(List strings) {" 41c6f6d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= fetch "protected void addAffectedSourceFiles(List sourceFiles) {" 41c6f6d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"


======= fetch "public EclipseTypeMunger build(ClassScope classScope) {" 5c67166^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

    
    <ajc-test dir="bugs"  pr="51322"
    	title="Introduce Unknown Type to class causes Null pointer exception"  >
        <compile files="Pr51322.java"> 
        	<message kind="error" line="5"/>
        </compile>
    </ajc-test>
  public void A.aMethod(Object x) {}
  public void A.someMethod(WCharType a) { }

    
      <ajc-test dir="bugs" pr="44272"
    		title="retitle warning to circular {advice} dependency at ...">
        <compile files="CircularAdvicePrecedence.java">
            <message kind="error" line="4"/> 
            <message kind="error" line="5"/> 
            <message kind="error" line="6"/> 
        </compile>
    </ajc-test>
    pointcut crun() : execution (void run()) ;
    before() : crun() {}
    after() returning : crun() {}
    void around() : crun() { proceed(); }
======= fetch "private void sortMungers() {" 0109534^:"weaver/src/org/aspectj/weaver/Shadow.java"

======= fetch "public void resolve(IScope scope) {" 0109534^:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

    					"circularity in declare dominates, '*' occurs more than once",
======= fetch "public void resolve(IScope scope) {" 0109534^:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

    					"circularity in declare dominates, '" + exactType.getName() + 

======= fetch "public MethodBinding getExactMethod(" c798923^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.java"

======= fetch "public MethodBinding getExactMethod(" c798923^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.java"

======= fetch "public MethodBinding getExactMethod(" c798923^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.java"

   	 title="fail in compiling aspect with overriding method introduction with different throws clause ">
        <compile files="IntertypeDifferentThrows.java" />
    </ajc-test>
  public A(){}
  public void m() throws Exception{}
  public B(){}
  public void some_code(){
  }
  public void B.m(){}

======= fetch "protected void generatePostSyntheticCode(" 5d73494^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java"

======= fetch "protected void generatePostSyntheticCode(" 5d73494^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java"

======= fetch "protected void generatePostSyntheticCode(" 5d73494^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java"

======= fetch "private boolean isInitFailureHandler(InstructionHandle ih) {" 5d73494^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"


    
    <ajc-test dir="bugs" pr="51320"
   	 title="ClasscastException on concretization of if(false)">
        <compile files="DecwClassCastException.java">
        
         <!-- These are the illegal PCDs against a deow -->
         <message kind="error" line="27" text="if() pointcut designator cannot be used"/>
         <message kind="error" line="29" text="if() pointcut designator cannot be used"/>
         
         <message kind="error" line="31" text="cflow() pointcut designator cannot be used"/>
         <message kind="error" line="33" text="cflow() pointcut designator cannot be used"/>
         
         <message kind="error" line="35" text="cflowbelow() pointcut designator cannot be used"/>
         <message kind="error" line="37" text="cflowbelow() pointcut designator cannot be used"/>
         
         <message kind="error" line="39" text="this() pointcut designator cannot be used"/>
         <message kind="error" line="41" text="this() pointcut designator cannot be used"/>
         
         <message kind="error" line="43" text="target() pointcut designator cannot be used"/>
         <message kind="error" line="45" text="target() pointcut designator cannot be used"/>
         
         <message kind="error" line="47" text="args() pointcut designator cannot be used"/>
         <message kind="error" line="49" text="args() pointcut designator cannot be used"/>
         
        </compile>
    </ajc-test>
 * From:
 * 
 * http://dev.eclipse.org/viewcvs/indextech.cgi/~checkout~/aspectj-home/doc/progguide/semantics-declare.html#d0e6499
 *
 * Pointcuts that appear inside of declare forms have certain restrictions. 
 * Like other pointcuts, these pick out join points, but they do so in a 
 * way that is statically determinable. 
 * 
 * Consequently, such pointcuts may not include, directly or indirectly 
 * (through user-defined pointcut declarations) pointcuts that discriminate 
 * based on dynamic (runtime) context. Therefore, such pointcuts may not be 
 * defined in terms of
 * 
 * cflow
 * cflowbelow
 * this
 * target
 * args
 * if
 * 
 * all of which can discriminate on runtime information. 
 */
    public static void main(String[] args) {
    }
    
======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" fbc0aa3^:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" fbc0aa3^:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" fbc0aa3^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" fbc0aa3^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" fbc0aa3^:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"


  
  after(): call(* approximate(..)) {
  	if (CalculatePI.iteration%10000==0) 
  	  System.out.println("Approximation is now:"+
  	    (CalculatePI.inCircle/CalculatePI.inSquare)*4.0f);
  }
  
  declare parents: Logger implements java.io.Serializable;
   static final void println(String s){ System.out.println(s); }
   pointcut goCut(): cflow(this(Demo) && execution(void go()));
   pointcut demoExecs(): within(Demo) && execution(* *(..));
   Object around(): demoExecs() && !execution(* go()) && goCut() {
   }
   static private void printParameters(JoinPoint jp) {
   }
======= fetch "public static Test suite() {" 16a0abd^:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

 * Copyright (c) 2004 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     Initial version
 * ******************************************************************/
      
      <varlistentry>
        <term>-Xreweavable[:compress]</term>
        <listitem><para>(Experimental) runs weaver in reweavable mode which causes
        it to create woven classes that can be rewoven, subject to the restriction that
        on attempting a reweave all the types that advised the woven type must be accessible.
        </para></listitem>
      </varlistentry>
======= fetch "public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r" 16a0abd^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

            } else if (arg.startsWith("-Xreweavable")) {
            	buildConfig.setXreweavable(true);
            	if (arg.endsWith(":compress")) {
            		buildConfig.setXreweavableCompressClasses(true);
            	}
======= fetch "public void setInJars(List sourceJars) {" 16a0abd^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= fetch "public void setXlazyTjp(boolean b) {" 16a0abd^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" 16a0abd^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void setXNoweave(boolean noweave) {" 16a0abd^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    
    public void setXReweavable(boolean reweavable) {
    	cmd.addFlag("-Xreweavable",reweavable);
    }
======= fetch "String next() {" 16a0abd^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "private CRSOptions() {" 16a0abd^:"testing/src/org/aspectj/testing/harness/bridge/CompilerRun.java"

    public static Advice makeCflowEntry(World world, Pointcut entry, boolean isBelow, Member stackField, int nFreeVars, List innerCflowEntries) {
======= fetch "public static Advice makeCflowEntry(World world, Pointcut entry, boolean isBelow" 16a0abd^:"weaver/src/org/aspectj/weaver/Advice.java"

    	ret.concreteAspect = inAspect;
======= fetch "public static Advice makePerObjectEntry(World world, Pointcut entry, boolean isT" 16a0abd^:"weaver/src/org/aspectj/weaver/Advice.java"

    public static Advice makeSoftener(World world, Pointcut entry, TypePattern exceptionType) {
======= fetch "public static Advice makeSoftener(World world, Pointcut entry, TypePattern excep" 16a0abd^:"weaver/src/org/aspectj/weaver/Advice.java"

    	//System.out.println("made ret: " + ret + " with " + exceptionType);
======= fetch "public void addDeclare(Declare declare) {" 16a0abd^:"weaver/src/org/aspectj/weaver/CrosscuttingMembers.java"

======= fetch "public List getDeclareDominates() {" 16a0abd^:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

======= fetch "protected Shadow(Kind kind, Member signature, Shadow enclosingShadow) {" 16a0abd^:"weaver/src/org/aspectj/weaver/Shadow.java"

    
======= fetch "public WeaverStateInfo() {" 16a0abd^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public WeaverStateInfo() {" 16a0abd^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "private WeaverStateInfo(List typeMungers, boolean oldStyle) {" 16a0abd^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "private WeaverStateInfo(List typeMungers, boolean oldStyle) {" 16a0abd^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public static final WeaverStateInfo read(DataInputStream s, ISourceContext conte" 16a0abd^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public static final WeaverStateInfo read(DataInputStream s, ISourceContext conte" 16a0abd^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public static final WeaverStateInfo read(DataInputStream s, ISourceContext conte" 16a0abd^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public static final WeaverStateInfo read(DataInputStream s, ISourceContext conte" 16a0abd^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 16a0abd^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public void write(DataOutputStream s) throws IOException {" 16a0abd^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= fetch "public boolean isOldStyle() {" 16a0abd^:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

    ////
    
======= fetch "public BcelCflowStackFieldAdder(ResolvedMember cflowStackField) {" 16a0abd^:"weaver/src/org/aspectj/weaver/bcel/BcelCflowStackFieldAdder.java"

======= fetch "public static boolean weave(" 16a0abd^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

    
======= fetch "public boolean weave() {" 16a0abd^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        if (clazz.isWoven()) {
======= fetch "public boolean weave() {" 16a0abd^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public boolean weave() {" 16a0abd^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

       
        Set aspectsAffectingType = null;
        if (inReweavableMode) aspectsAffectingType = new HashSet();
======= fetch "public boolean weave() {" 16a0abd^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        	isChanged |= munger.munge(this);
======= fetch "public boolean weave() {" 16a0abd^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

            isChanged |= match(mg);
======= fetch "public boolean weave() {" 16a0abd^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        if (inReweavableMode) {
        	WeaverStateInfo wsi = clazz.getOrCreateWeaverStateInfo();
        	wsi.addAspectsAffectingType(aspectsAffectingType);
        	wsi.setUnwovenClassFileData(ty.getJavaClass().getBytes());
        	wsi.setReweavable(true,compressReweavableAttributes);
        } else {
        	clazz.getOrCreateWeaverStateInfo().setReweavable(false,false);
        }
        
======= fetch "public boolean weave() {" 16a0abd^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public BcelWorld getWorld() {" 16a0abd^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public Collection getPrivilegedAccesses() {" 16a0abd^:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

    
    // repeat initialization
    public void setJavaClass(JavaClass newclass) {
    	this.javaClass = newclass;
    	resetState();
    }
    
    
    private boolean inReweavableMode = false;
    private boolean compressReweavableAttributes = false;
    
======= fetch "public Collection weave() throws IOException {" 16a0abd^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

    	 	
    	
    	Set alreadyConfirmedOK = new HashSet();
======= fetch "public Collection weave() throws IOException {" 16a0abd^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

            classType.resetState();
======= fetch "public void weave(ResolvedTypeX onType) {" 16a0abd^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "LazyClassGen weave(UnwovenClassFile classFile, BcelObjectType classType) throws" 16a0abd^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public void setProgressListener(IProgressListener listener, double previousProgr" 16a0abd^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= fetch "public boolean isWoven() {" 16a0abd^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" 16a0abd^:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"


======= fetch "public void endVisit(SingleNameReference ref, BlockScope scope) {" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "public void endVisit(QualifiedNameReference ref, BlockScope scope) {" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "public void endVisit(QualifiedNameReference ref, BlockScope scope) {" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "public void endVisit(QualifiedNameReference ref, BlockScope scope) {" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "public void endVisit(QualifiedNameReference ref, BlockScope scope) {" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "public void endVisit(FieldReference ref, BlockScope scope) {" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "public void endVisit(MessageSend send, BlockScope scope) {" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "public void endVisit(MessageSend send, BlockScope scope) {" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "public void endVisit(" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "private FieldBinding getAccessibleField(FieldBinding binding) {" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "private FieldBinding getAccessibleField(FieldBinding binding) {" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "private FieldBinding getAccessibleField(FieldBinding binding) {" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "private FieldBinding getAccessibleField(FieldBinding binding) {" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "private MethodBinding getAccessibleMethod(MethodBinding binding) {" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "private MethodBinding getAccessibleMethod(MethodBinding binding) {" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "public void endVisit(ClassLiteralAccess classLiteral, BlockScope scope) {" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "public static ResolvedMember makeResolvedMember(MethodBinding binding) {" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public static ResolvedMember makeResolvedMember(MethodBinding binding) {" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public static ResolvedMember makeResolvedMember(FieldBinding binding) {" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public static ResolvedMember makeResolvedMember(FieldBinding binding) {" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "public InlineAccessFieldBinding(AspectDeclaration inAspect, FieldBinding baseFie" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InlineAccessFieldBinding.java"

======= fetch "public InlineAccessFieldBinding(AspectDeclaration inAspect, FieldBinding baseFie" 6ddae42^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InlineAccessFieldBinding.java"

    
======= fetch "private void doOtherStuff() {" 6ddae42^:"tests/bugs/protectedvf/main/Driver.java"

======= fetch "private void doStuff() {" 6ddae42^:"tests/bugs/protectedvf/main/Driver.java"


======= fetch "public static Test suite() {" 669cd7c^:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Mik Kersten     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
        IHierarchy model = Ajde.getDefault().getStructureModelManager().getHierarchy();
        assertTrue("model exists", model != null);
        
        IHierarchy model = Ajde.getDefault().getStructureModelManager().getHierarchy();
        assertTrue("model exists", model != null);
        final List preBuildKinds = new ArrayList();
  		    public void preProcess(IProgramElement node) {
  		    	preBuildKinds.add(node.getKind());
  		    }
  		};
  		Ajde.getDefault().getStructureModelManager().getHierarchy().getRoot().walk(walker);
        final List postBuildKinds = new ArrayList();
  		    public void preProcess(IProgramElement node) {
  		    	postBuildKinds.add(node.getKind());
  		    }
  		};
  		Ajde.getDefault().getStructureModelManager().getHierarchy().getRoot().walk(walker2);
======= fetch "private Object readResolve() throws ObjectStreamException {" 669cd7c^:"asm/src/org/aspectj/asm/IProgramElement.java"

======= fetch "private Object readResolve() throws ObjectStreamException {" 669cd7c^:"asm/src/org/aspectj/asm/IProgramElement.java"

======= fetch "private Object readResolve() throws ObjectStreamException {" 669cd7c^:"asm/src/org/aspectj/asm/IProgramElement.java"


    <ajc-test dir="bugs" pr="50570"
      title="CatchClauseSignature has broken operation">
        <compile files="HandlerSig.java"/>
        <run class="HandlerSig"/>
    </ajc-test>
======= fetch "private static Member pointcut(TypeX declTy, int mods, TypeX rTy, String name, T" 19bac86^:"weaver/src/org/aspectj/weaver/Member.java"

======= fetch "private String getHandlerSignatureString(World world) {" 19bac86^:"weaver/src/org/aspectj/weaver/Member.java"

        //XXX we don't actually try to find the handler parameter name
        //XXX it probably wouldn't be too hard
======= fetch "private String getHandlerSignatureString(World world) {" 19bac86^:"weaver/src/org/aspectj/weaver/Member.java"

        //String[] pNames = getParameterNames(world);
        //if (pNames != null) pName = pNames[0];
    protected String[] parameterNames = null;
======= fetch "public static BcelShadow makeExceptionHandler(" 19bac86^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public static BcelShadow makeExceptionHandler(" 19bac86^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

                Member.makeExceptionHandlerSignature(inType, catchType),
======= fetch "public static BcelShadow makeExceptionHandler(" 19bac86^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

 			}

======= fetch "public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r" 0c83343^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= fetch "public void doNotProceed() {" 0c83343^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" 0c83343^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public static Test suite() {" 0c83343^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java"

        suite.addTestSuite(CompileAndRunTestCase.class); 
======= fetch "public static void checkCompile(String source, int[] expectedErrors) {" 0c83343^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CommandTestCase.java"

======= fetch "public static void checkCompile(String source, int[] expectedErrors) {" 0c83343^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CommandTestCase.java"

 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     PARC     initial implementation 
 * ******************************************************************/
======= fetch "public Factory(String filename, Class lexicalClass) {" 0c83343^:"runtime/src/org/aspectj/runtime/reflect/Factory.java"

    public static JoinPoint makeJP(JoinPoint.StaticPart staticPart, 
                        Object _this, Object target, Object[] args)
    {
        return new JoinPointImpl(staticPart, _this, target, args);
    }
======= fetch "public void setXnoInline(boolean xnoInline) {" 0c83343^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public void setXnoInline(boolean xnoInline) {" 0c83343^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public void specializeOn(Shadow shadow) {" 0c83343^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

        	((BcelShadow)shadow).getThisJoinPointVar();
======= fetch "public InstructionList getAdviceArgSetup(" 0c83343^:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

        	shadow.getThisJoinPointBcelVar().appendLoad(il, fact);
======= fetch "protected void prepareForMungers() {" 0c83343^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "protected void prepareForMungers() {" 0c83343^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public Var getArgVar(int i) {" 0c83343^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    private boolean isThisJoinPointLazy;
    private int lazyTjpConsumers = 0;
======= fetch "public Var getArgVar(int i) {" 0c83343^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= fetch "public final Var getThisEnclosingJoinPointStaticPartVar() {" 0c83343^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    public BcelVar getThisJoinPointBcelVar() {
======= fetch "public BcelVar getThisJoinPointBcelVar() {" 0c83343^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    		thisJoinPointVar = genTempVar(TypeX.forName("org.aspectj.lang.JoinPoint"));
    		InstructionFactory fact = getFactory();
    		InstructionList il = new InstructionList();
    		BcelVar staticPart = getThisJoinPointStaticPartBcelVar();
    		staticPart.appendLoad(il, fact);
    		if (hasThis()) {
    			((BcelVar)getThisVar()).appendLoad(il, fact);
    		} else {
    			il.append(new ACONST_NULL());
    		}
    		if (hasTarget()) {
    			((BcelVar)getTargetVar()).appendLoad(il, fact);
    		} else {
    			il.append(new ACONST_NULL());
    		}
    		
    		il.append(fact.createInvoke("org.aspectj.runtime.reflect.Factory", 
    							"makeJP", LazyClassGen.tjpType,
    							new Type[] { LazyClassGen.staticTjpType,
    									Type.OBJECT, Type.OBJECT, new ArrayType(Type.OBJECT, 1)},
    							Constants.INVOKESTATIC));
    		il.append(thisJoinPointVar.createStore(fact));
    		range.insert(il, Range.OutsideBefore);
======= fetch "public BcelVar getThisJoinPointBcelVar() {" 0c83343^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    }
    
    
    public Var getThisJoinPointVar() {
    	requireThisJoinPoint(false);
======= fetch "public BcelVar getThisJoinPointBcelVar() {" 0c83343^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

                    BIPUSH 0
                    ANEWARRAY java.lang.Object
                    ASTORE_2
                    ALOAD_2
                    INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
    |               ASTORE 4
    |               ALOAD 4
    |               ALOAD 4
    |               ALOAD 4
                    ASTORE 11
                    BIPUSH 1
                    ANEWARRAY java.lang.Object
                    ASTORE 13
                    ALOAD 13
                    BIPUSH 0
                    ALOAD 11
                    AASTORE
                    ALOAD 13
                    INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                    ASTORE 12
    |               ASTORE 15
    |               ALOAD 15
    |               ALOAD 11
    |               ALOAD 15
    |               BIPUSH 1
    |               ALOAD 15
    |               INVOKESPECIAL HelloWorld$AjcClosure15.<init> ([Ljava/lang/Object;)V
                    BIPUSH 0
                    ANEWARRAY java.lang.Object
                    ALOAD_2
                    INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                    ASTORE 4
    |               ASTORE 6
    |               ALOAD 6
    |               BIPUSH 0
    |               ALOAD 6
    |               INVOKESPECIAL HelloWorld$AjcClosure7.<init> ([Ljava/lang/Object;)V
                    ASTORE 10
                    ALOAD 10
                    BIPUSH 1
                    ANEWARRAY java.lang.Object
                    ASTORE 12
                    ALOAD 12
                    BIPUSH 0
                    AASTORE
                    ALOAD 12
                    INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                    ASTORE 14
    |               ASTORE 16
    |               ALOAD 16
    |               ALOAD 10
    |               ALOAD 16
    |               ALOAD 8
    |               ALOAD 16
    |               ALOAD 14
    |               ALOAD 16
    |               ALOAD 14
                    BIPUSH 0
                    ANEWARRAY java.lang.Object
                    ASTORE_2
                    ALOAD_2
                    INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
    |               ASTORE_3
    |               ALOAD_3
    |               ALOAD_3
    |               ALOAD_3
                    ASTORE 9
                    BIPUSH 1
                    ANEWARRAY java.lang.Object
                    ASTORE 11
                    ALOAD 11
                    BIPUSH 0
                    ALOAD 9
                    AASTORE
                    ALOAD 11
                    INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                    ASTORE 10
    |               ASTORE 12
    |               ALOAD 12
    |               BIPUSH 0
    |               ALOAD 12
    |               ALOAD 10
    |               ALOAD 12
    |               ALOAD 10
                    BIPUSH 0
                    ANEWARRAY java.lang.Object
                    ALOAD_2
                    INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                    ASTORE 4
    |               ASTORE 6
    |               ALOAD 6
    |               BIPUSH 0
    |               ALOAD 6
    |               INVOKESPECIAL HelloWorld$AjcClosure3.<init> ([Ljava/lang/Object;)V
                    ASTORE 10
                    ALOAD 10
                    BIPUSH 1
                    ANEWARRAY java.lang.Object
                    ASTORE 12
                    ALOAD 12
                    BIPUSH 0
                    AASTORE
                    ALOAD 12
                    INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                    ASTORE 14
    |               ASTORE 16
    |               ALOAD 16
    |               ALOAD 10
    |               ALOAD 16
    |               ALOAD 8
    |               ALOAD 16
    |               ALOAD 14
    |               ALOAD 16
    |               ALOAD 14
                    BIPUSH 0
                    ANEWARRAY java.lang.Object
                    ASTORE_2
                    ALOAD_2
                    INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                    ASTORE 9
                    BIPUSH 1
                    ANEWARRAY java.lang.Object
                    ASTORE 8
                    ALOAD 8
                    BIPUSH 0
                    ALOAD 9
                    AASTORE
                    ALOAD 8
                    INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                    ASTORE 7
    |               ALOAD 7
    |               BIPUSH 0
    |               ANEWARRAY java.lang.Object
    |               ASTORE_2
    |               ALOAD_2
    |               INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
    |               ASTORE 5
    |               ALOAD 5
    |               BIPUSH 1
    |               ANEWARRAY java.lang.Object
    |               ASTORE 6
    |               ALOAD 6
    |               BIPUSH 0
    |               AASTORE
    |               ALOAD 6
    |               INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;[Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
    |               ASTORE_3
    | |             ALOAD_3
    | |             ALOAD 5

======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" f24286d^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public boolean match(Shadow shadow, World world) {" f24286d^:"weaver/src/org/aspectj/weaver/Checker.java"

 * Copyright (c) 2000, 2003 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
 * Clients can pass a single cross-reference handler to the weaver on construction
 * of a BcelWorld. Any cross-references detected during munging will be notified
 * to the handler.
 */
======= fetch "private void implementMungers() {" f24286d^:"weaver/src/org/aspectj/weaver/Shadow.java"

======= fetch "public void setMessageHandler(IMessageHandler messageHandler) {" f24286d^:"weaver/src/org/aspectj/weaver/World.java"

======= fetch "public BcelWorld(String cp) {" f24286d^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= fetch "private static List getPathEntries(String s) {" f24286d^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= fetch "public BcelWorld(List classPath, IMessageHandler handler) {" f24286d^:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"


======= fetch "protected boolean assemble(Module module, File classesDir, List errors) {" 6f099df^:"build/src/org/aspectj/internal/tools/ant/taskdefs/AntBuilder.java"

                copyFile(manifest, new File(metaInfDir, "manifest.mf"), FILTER_ON);  // XXXFileLiteral

    

======= fetch "public void runMain(String[] args, boolean useSystemExit) {" b3b1eec^:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"

        run(args, holder);

 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * <code>getWrappedThrowable()</code>.
    Throwable inner;
======= fetch "public SoftException(Throwable inner) {" ad2fb7a^:"runtime/src/org/aspectj/lang/SoftException.java"

    public void printStackTrace() {
        printStackTrace(System.err);                
    }
    
    public void printStackTrace(PrintStream stream) {
        super.printStackTrace(stream);
        final Throwable _inner = this.inner;
        if (!HAVE_JAVA_14 && (null != _inner)) {
            stream.print("Caused by: ");
            _inner.printStackTrace(stream);
        }
    }
    
    public void printStackTrace(PrintWriter stream) {
        super.printStackTrace(stream);
        final Throwable _inner = this.inner;
        if (!HAVE_JAVA_14 && (null != _inner)) {
            stream.print("Caused by: ");
            _inner.printStackTrace(stream);
        }
    }
======= fetch "public static TestSuite suite() {" ad2fb7a^:"runtime/testsrc/RuntimeModuleTests.java"

    public void testNothing() {}
======= fetch "public void testNoAspectBoundException() {" ad2fb7a^:"runtime/testsrc/RuntimeModuleTests.java"

    	RuntimeException fun = new RuntimeException("fun");
    	NoAspectBoundException nab = new NoAspectBoundException("Foo", fun);
    	assertEquals(fun,nab.getCause());

======= fetch "public void abstractMethodMustBeImplemented(" 0071cb4^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= fetch "public void abstractMethodMustBeImplemented(" 0071cb4^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

                if (!Modifier.isAbstract(sig.getModifiers())) {
======= fetch "public List getInterTypeMungers() {" 0071cb4^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

    private List getInterTypeMungersIncludingSupers() {
======= fetch "private List getInterTypeMungersIncludingSupers() {" 0071cb4^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

    /**
     * ??? This method is O(N*M) where N = number of methods and M is number of
     * inter-type declarations in my super
     */

======= fetch "public AspectClinit(Clinit old, CompilationResult compilationResult, boolean has" 5834de9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java"

======= fetch "public AspectClinit(Clinit old, CompilationResult compilationResult, boolean has" 5834de9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java"

======= fetch "protected void generateSyntheticCode(" 5834de9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java"

======= fetch "protected void generatePostSyntheticCode(" 5834de9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java"

======= fetch "public boolean canBeSeenBy(" 5834de9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= fetch "public void generateCode(ClassFile enclosingClassFile) {" 5834de9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= fetch "public void generateCode(ClassFile enclosingClassFile) {" 5834de9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= fetch "public void generateCode(ClassFile enclosingClassFile) {" 5834de9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= fetch "public void generate(CodeStream codeStream) {" 5834de9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= fetch "public void generate(CodeStream codeStream) {" 5834de9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= fetch "public void generate(CodeStream codeStream) {" 5834de9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= fetch "public void testNothing() {}" 5834de9^:"runtime/testsrc/RuntimeModuleTests.java"

    
    public void testNoAspectBoundException() {
    	RuntimeException fun = new RuntimeException("fun");
    	NoAspectBoundException nab = new NoAspectBoundException("Foo", fun);
    	assertEquals(fun,nab.getCause());
    }
    <ajc-test dir="bugs" pr="44587"
      title="Erroneous exception conversion">
        <compile files="ErroneousExceptionConversion.java">
        </compile>
        <run class="ErroneousExceptionConversion"/>
    </ajc-test>
    
  <ajc-test dir="bugs" pr="34206"
      title="before():execution(new(..)) does not throw NoAspectBoundException">
        <compile files="ErroneousExceptionConversion1.java">
        </compile>
        <run class="ErroneousExceptionConversion1"/>
    </ajc-test>
    
======= fetch "public static void main(String[] args) {" 5834de9^:"tests/new/ConstructorExecInitFails.java"

    	} catch (ExceptionInInitializerError e) {
======= fetch "public static Member noAspectBoundExceptionInit() {" 5834de9^:"weaver/src/org/aspectj/weaver/AjcMemberMaker.java"

======= fetch "public static Member noAspectBoundExceptionInit() {" 5834de9^:"weaver/src/org/aspectj/weaver/AjcMemberMaker.java"

======= fetch "public static Member noAspectBoundExceptionInit() {" 5834de9^:"weaver/src/org/aspectj/weaver/AjcMemberMaker.java"

======= fetch "public static ResolvedMember perSingletonField(TypeX declaringType) {" 5834de9^:"weaver/src/org/aspectj/weaver/AjcMemberMaker.java"

======= fetch "private NameMangler() {" 5834de9^:"weaver/src/org/aspectj/weaver/NameMangler.java"

======= fetch "private void match(" 5834de9^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private void match(" 5834de9^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private void matchSetInstruction(" 5834de9^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "private void matchGetInstruction(LazyMethodGen mg, InstructionHandle ih, BcelSha" 5834de9^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"


======= fetch "protected void consumeAspectHeaderName(boolean isPrivileged) {" 7bbd1f4^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/parser/AjParser.java"

    
    <ajc-test dir="bugs" 
        <compile files="PrivilegedParsing.java"/>
        <run class="PrivilegedParsing"/>
    </ajc-test>
   private int hidden;
   public int visible;
   public PrivilegedParsing(int priv, int pub) {
      hidden = priv;
      visible = pub;
   }
   public void doSomething() {
      System.out.println("" + hidden + ", " + visible + "");
   }
   public static void main(String[] args) {
      PrivilegedParsing capsule = new PrivilegedParsing(1, 1);
      capsule.doSomething();
   }
   static privileged //<== JUST TRY TO UNCOMMENT THIS!
   aspect Inner {
      pointcut call2doSomething(PrivilegedParsing capsule):
         call(void PrivilegedParsing.doSomething())
         && target(capsule);
      before(PrivilegedParsing capsule): call2doSomething(capsule) {
         capsule.visible++;
         capsule.hidden++;
      }
   }
   static privileged //<== JUST TRY TO UNCOMMENT THIS!
   aspect Inner {
      pointcut call2doSomething(PrivilegedParsing capsule):
         call(void PrivilegedParsing.doSomething())
         && target(capsule);
      before(PrivilegedParsing capsule): call2doSomething(capsule) {
         capsule.visible++;
         capsule.hidden++;
      }
   }

    <ajc-test dir="bugs" pr="44586"
      title="After throwing advice on ctors doesn't execute for inter-type decl field inits">
        <compile files="AfterThrowingCtor.java">
        </compile>
  		<run class="AfterThrowingCtor"/>
    </ajc-test>

======= fetch "public void testBadInJars() throws InvalidInputException {" a4a1234^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

======= fetch "void addFiles(File dir, FileFilter filter) {" a4a1234^:"util/src/org/aspectj/util/ConfigParser.java"

        }
======= fetch "void addFiles(File dir, FileFilter filter) {" a4a1234^:"util/src/org/aspectj/util/ConfigParser.java"

        File[] files = dir.listFiles(filter);
        if (files.length == 0) {
======= fetch "void addFiles(File dir, FileFilter filter) {" a4a1234^:"util/src/org/aspectj/util/ConfigParser.java"

        }
======= fetch "void addFiles(File dir, FileFilter filter) {" a4a1234^:"util/src/org/aspectj/util/ConfigParser.java"

        for (int i = 0; i < files.length; i++) {
======= fetch "void addFiles(File dir, FileFilter filter) {" a4a1234^:"util/src/org/aspectj/util/ConfigParser.java"

          }

======= fetch "protected void consumeExtraParameterNoFormal() {" 7b081f2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/parser/AjParser.java"

   

======= fetch "public String toString() {" 97ab1e9^:"bridge/src/org/aspectj/bridge/IMessage.java"

    
    public List getExtraSourceLocations();
    private final List/*SourceLocation*/ extraSourceLocations;
======= fetch "public Message(String message, String details, IMessage.Kind kind," 97ab1e9^:"bridge/src/org/aspectj/bridge/Message.java"

======= fetch "public Message(String message, String details, IMessage.Kind kind," 97ab1e9^:"bridge/src/org/aspectj/bridge/Message.java"

======= fetch "public Message(String message, String details, IMessage.Kind kind," 97ab1e9^:"bridge/src/org/aspectj/bridge/Message.java"

        
======= fetch "public Message(String message, String details, IMessage.Kind kind," 97ab1e9^:"bridge/src/org/aspectj/bridge/Message.java"

        else {
            this.extraSourceLocations = Collections.EMPTY_LIST;
        }
======= fetch "public Message(String message, IMessage.Kind kind, Throwable thrown," 97ab1e9^:"bridge/src/org/aspectj/bridge/Message.java"

        this.message = message;
        this.kind = kind;
        this.thrown = thrown;
        this.sourceLocation = sourceLocation;
        this.details = "";
        if (null == message) {
            if (null != thrown) {
                message = thrown.getMessage();
            } 
            if (null == message) {
                throw new IllegalArgumentException("null message");
            }
        }
        if (null == kind) {
             throw new IllegalArgumentException("null kind");
        }
======= fetch "public String toString() {" 97ab1e9^:"bridge/src/org/aspectj/bridge/Message.java"

        return Message.renderToString(this);
======= fetch "public String toString() {" 97ab1e9^:"bridge/src/org/aspectj/bridge/Message.java"

    public static String renderToString(IMessage message) { 
        ISourceLocation loc = message.getSourceLocation();
        String locString = (null == loc ? "" : " at " + loc);
        Throwable thrown = message.getThrown();
        return message.getKind() + locString + ": " + message.getMessage()
            + (null == thrown ? "" : render(thrown));
    }
======= fetch "public String getDetails() {" 97ab1e9^:"bridge/src/org/aspectj/bridge/Message.java"

    
======= fetch "public static String renderMessage(IMessage message, boolean elide) {" 97ab1e9^:"bridge/src/org/aspectj/bridge/MessageUtil.java"

        StringBuffer result = new StringBuffer();
        
        result.append(message.getKind().toString());
        result.append(" ");
        
        String messageString = message.getMessage();
        if (!LangUtil.isEmpty(messageString)) {
            result.append(messageString);
            result.append(" ");
        }
======= fetch "public static String renderMessage(IMessage message, boolean elide) {" 97ab1e9^:"bridge/src/org/aspectj/bridge/MessageUtil.java"

        if ((null != loc) && (loc != ISourceLocation.EMPTY)) {
            result.append("at " + renderSourceLocation(loc));
        }
        Throwable thrown = message.getThrown(); 
        if (null != thrown) {
            result.append(" -- " + LangUtil.renderExceptionShort(thrown));
            result.append("\n" + LangUtil.renderException(thrown, elide));            
======= fetch "public static String renderMessage(IMessage message, boolean elide) {" 97ab1e9^:"bridge/src/org/aspectj/bridge/MessageUtil.java"

        return result.toString();
    }
======= fetch "public String toString() {" 97ab1e9^:"bridge/src/org/aspectj/bridge/SourceLocation.java"

        sb.append("" + startLine + "-" + endLine);
======= fetch "protected String render(IMessage message) {" 97ab1e9^:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"

            return sb.toString();
======= fetch "public void setDetails(String string) {" 97ab1e9^:"testing/src/org/aspectj/testing/xml/SoftMessage.java"

        <compile files="Simple.java"/>
        <compile files="MethodSignatures.java" options="-1.4"/>
        <compile files="CallTypes.java" options="-1.4"/>
        <compile files="CallTypesI.java" options="-1.4"/>
        <compile files="PR519.java"/>
        <compile files="IntroductionsOverriding.java"/>
        <compile files="MultiAndAround.java"/>
        <compile files="NotAndDeclaringTypes.java"/>
        <compile files="Driver.java,p1/C1.java,p1/p2/C2.java"/>
    
======= fetch "private final static Collection sort(String str) {" 97ab1e9^:"tests/new/CallTypesI.java"

======= fetch "public void mI() { }" 97ab1e9^:"tests/new/CallTypesI.java"

    
======= fetch "public void mI() { }" 97ab1e9^:"tests/new/CallTypesI.java"

    
======= fetch "void check(String pc, JoinPoint jp) {" 97ab1e9^:"tests/new/IndeterminateArg.java"

    pointcut safe()                                : (call(C+.new(..)) || call(* C+.*(..))); 
======= fetch "void check(String pc, JoinPoint jp) {" 97ab1e9^:"tests/new/IndeterminateArgType.java"

    pointcut safe()                                : call(Safe+.new(..)) || call(* Safe+.*(..)); 
======= fetch "public boolean match(Shadow shadow, World world) {" 97ab1e9^:"weaver/src/org/aspectj/weaver/Checker.java"

                null,
                new ISourceLocation[]{this.getSourceLocation()});
    public final Kind unmatchedSuperTypeInCall = 
        new Kind("unmatchedSuperTypeInCall", "does not match because declaring type is {0}, if match desired use target({1})");
            
======= fetch "public void signal(String info, ISourceLocation location) {" 97ab1e9^:"weaver/src/org/aspectj/weaver/Lint.java"

            if (kind == null) return;
            
            String text = MessageFormat.format(message, infos );
            text += " [Xlint:" + name + "]";
            world.getMessageHandler().handleMessage(
                new Message(text, "", kind, location, null, extraLocations));
======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" 97ab1e9^:"weaver/src/org/aspectj/weaver/patterns/AndPointcut.java"

======= fetch "public String toString() {" 97ab1e9^:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

    	return "ExactTypePattern(" + type.toString() + (includeSubtypes ? "+" : "") + ")";
======= fetch "public FuzzyBoolean match(Shadow shadow) {" 97ab1e9^:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

            if(kind == Shadow.MethodCall) {
                warnOnConfusingSig(shadow);
            }
            return  FuzzyBoolean.NO; 
        }
======= fetch "public FuzzyBoolean match(Shadow shadow) {" 97ab1e9^:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

        // no warnings for declare error/warning
        if (munger instanceof Checker) return;
        
        World world = shadow.getIWorld();
        
        
        
        // warning not needed if match type couldn't ever be the declaring type
            return;
                shadow.getIWorld().getLint().unmatchedSuperTypeInCall.signal(
                    new String[] {
                        shadow.getSignature().getDeclaringType().toString(),
                        signature.getDeclaringType().toString()
                    },
                    this.getSourceLocation(),
                    new ISourceLocation[] {shadow.getSourceLocation()} );               
======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" 97ab1e9^:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

        ret.copyLocationFrom(this);
        return ret;
======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" 97ab1e9^:"weaver/src/org/aspectj/weaver/patterns/NotPointcut.java"

======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" 97ab1e9^:"weaver/src/org/aspectj/weaver/patterns/OrPointcut.java"

======= fetch "public Pointcut concretize(ResolvedTypeX inAspect, IntMap bindings) {" 97ab1e9^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= fetch "public Pointcut concretize(ResolvedTypeX inAspect, IntMap bindings) {" 97ab1e9^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

        if (shouldCopyLocationForConcretize()) ret.copyLocationFrom(this);
======= fetch "public Pointcut concretize(ResolvedTypeX inAspect, IntMap bindings) {" 97ab1e9^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= fetch "public Pointcut concretize1(ResolvedTypeX searchStart, IntMap bindings) {" 97ab1e9^:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= fetch "public Pointcut concretize1(ResolvedTypeX searchStart, IntMap bindings) {" 97ab1e9^:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

    
    // We want to keep the original source location, not the reference location
    protected boolean shouldCopyLocationForConcretize() {
        return false;
    }
======= fetch "public static SignaturePattern read(DataInputStream s, ISourceContext context) t" 97ab1e9^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"


======= fetch "public void resolveStatements() {" 7322131^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

    
    <ajc-test dir="bugs" pr="47754"
      title="static method introduction on interfaces, should not be allowed">
        <compile files="StaticInterfaceMethods.java">
        </compile>
    </ajc-test>

======= fetch "public SoftException(Throwable inner) {" eac16ae^:"runtime/src/org/aspectj/lang/SoftException.java"

    public Throwable getCause() { return inner; }
======= fetch "public SoftException(Throwable inner) {" eac16ae^:"runtime/src/org/aspectj/lang/SoftException.java"

    //XXX should add a getCause() method to parallel j2se 1.4's new
    //XXX chained exception mechanism

======= fetch "public void resolve() {" c517e85^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= fetch "private void resolvePointcutDeclarations(ClassScope s) {" c517e85^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

        
======= fetch "private void resolvePointcutDeclarations(ClassScope s) {" c517e85^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

                	hasPointcuts = true;
======= fetch "private void resolvePointcutDeclarations(ClassScope s) {" c517e85^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

        


======= fetch "public boolean compile(String configFile, BuildProgressMonitor progressMonitor," 3e4b59a^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= fetch "public boolean compile(String configFile, BuildProgressMonitor progressMonitor," 3e4b59a^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= fetch "public boolean compile(String configFile, BuildProgressMonitor progressMonitor," 3e4b59a^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

            signalWarning("build cancelled by user");
======= fetch "public boolean compile(String configFile, BuildProgressMonitor progressMonitor," 3e4b59a^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

                signalWarning(message.getMessage());
======= fetch "public boolean compile(String configFile, BuildProgressMonitor progressMonitor," 3e4b59a^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

     * @param configFile
======= fetch "public AjBuildConfig genBuildConfig(String configFilePath) {" 3e4b59a^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

            signalError("Config file \"" + configFile + "\" does not exist."); 
======= fetch "public AjBuildConfig genBuildConfig(String configFilePath) {" 3e4b59a^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

    /** signal error text to user */
    protected void signalError(String text) {
        Ajde.getDefault().getErrorHandler().handleError(text);
    }
    /** signal warning text to user */
    protected void signalWarning(String text) {
        Ajde.getDefault().getErrorHandler().handleWarning(text);
    }

======= fetch "public static void checkerMunger(IHierarchy model, Shadow shadow, Checker checke" 3117255^:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"


======= fetch "public String toSignatureString() {" 426d89b^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= fetch "public String toLinkLabelString() {" 426d89b^:"asm/src/org/aspectj/asm/internal/ProgramElement.java"


    
  	<ajc-test dir="bugs/concretizeNpe" pr="43033"
    public abstract pointcut scope();
    declare soft: Exception: scope();
    public pointcut scope() : within(*);
    protected RuntimeException convertCheckedException(Throwable t) {
        return new RuntimeException(t.getMessage(),t
======= fetch "public Pointcut concretize1(ResolvedTypeX searchStart, IntMap bindings) {" 5357086^:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= fetch "public Pointcut concretize1(ResolvedTypeX searchStart, IntMap bindings) {" 5357086^:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"


    
    <ajc-test dir="bugs" pr="43194"
   	 title="Non-functional concretezation of ReferencePointcut">
        <compile files="AdviceInteraction.java"/>
        <run class="AdviceInteraction"/>
    </ajc-test>
    public static void main(String [] args) {
        new C().m1();
    }
    public void m1() {}
    public void m2() {}
    pointcut exec1(C c): this(c) && execution(void m1());
    pointcut execs(C c): exec1(c); 
    
    before (): execs(*) {}
    before (C c):  execs(c) {}
    // This ordering works correctly
    pointcut exec2(C c): this(c) && execution(void m2());
    pointcut execs2(C c): exec2(c); 
    
    before (C c):  execs2(c) {}
    before (): execs2(*) {}
======= fetch "public Pointcut concretize1(ResolvedTypeX searchStart, IntMap bindings) {" fc0d2af^:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"


======= fetch "public void completeTypeBindings() {" b512738^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

            }
        }
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
                resolvePointcutDeclarations(b[j].scope);
            }
        }
        
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
======= fetch "public void completeTypeBindings() {" b512738^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

        }
======= fetch "public void completeTypeBindings() {" b512738^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

            units[i] = null; // release unnecessary reference to the parsed unit
======= fetch "public void completeTypeBindings() {" b512738^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

        
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
                resolvePointcutDeclarations(b[j].scope);
            }
        }
        
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
                addAdviceLikeDeclares(b[j].scope);
            }
        }
        
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            units[i] = null; // release unnecessary reference to the parsed unit
        }
======= fetch "private void doPendingWeaves() {" b512738^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

    
    private void addAdviceLikeDeclares(ClassScope s) {
        TypeDeclaration dec = s.referenceContext;
        
        if (dec instanceof AspectDeclaration) {
            ResolvedTypeX typeX = factory.fromEclipse(dec.binding);
            factory.getWorld().getCrosscuttingMembersSet().addAdviceLikeDeclares(typeX);
        }
        
        SourceTypeBinding sourceType = s.referenceContext.binding;
        ReferenceBinding[] memberTypes = sourceType.memberTypes;
        for (int i = 0, length = memberTypes.length; i < length; i++) {
            addCrosscuttingStructures(((SourceTypeBinding) memberTypes[i]).scope);
        }
    }
    <ajc-test dir="bugs" pr="42993"
   	    title="Interaction between pointcut binding and declare parents">
        <compile files="ParentsAndPointcuts.java"/>
        <run class="ParentsAndPointcuts"/>
    </ajc-test>
    public static void main(String[] args) {
        ContainerDescriptor d = new ContainerDescriptor();
        Tester.check(d instanceof AbstractCaching.Key, "instanceof");
    }
    declare parents: ContainerDescriptor implements AbstractCaching.Key;
    protected pointcut loadExecutions( Key key ):
        ContainerLoader.containerLoads( *, key );
    interface Key {}
    protected abstract pointcut loadExecutions(Key key);
    public ActiveContainer createContainer(ContainerDescriptor c) {
        return null;
    }
    public pointcut containerLoads(ContainerLoader loader,
                                   
        this(loader) && args(containerDesc)
        && execution(ActiveContainer ContainerLoader.createContainer
======= fetch "public boolean addOrReplaceAspect(ResolvedTypeX aspectType) {" b512738^:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

    
    public void addAdviceLikeDeclares(ResolvedTypeX aspectType) {
        CrosscuttingMembers xcut = (CrosscuttingMembers)members.get(aspectType);
        xcut.addDeclares(aspectType.collectDeclares(true));
    }
======= fetch "public boolean containsAspect(TypeX aspectType) {" b512738^:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

    
======= fetch "public List getDeclareDominates() {" b512738^:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

======= fetch "public CrosscuttingMembers collectCrosscuttingMembers() {" b512738^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= fetch "public CrosscuttingMembers collectCrosscuttingMembers() {" b512738^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= fetch "private final Collection collectDeclares() {" b512738^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

        
        if (!includeAdviceLike) return ret;
        

======= fetch "public void buildInterTypeAndPerClause(ClassScope classScope) {" d78d9ed^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

        
        concreteName.getDeclaredPointcuts();
    
    private ResolvedPointcutDefinition resolvedPointcutDeclaration = null;
======= fetch "public void postParse(TypeDeclaration typeDec) {" d78d9ed^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"

    
    public void resolve(ClassScope upperScope) {
        // this method should do nothing, use the entry point below...
    }
    public void resolvePointcut(ClassScope upperScope) {
        super.resolve(upperScope);
    }
======= fetch "public void resolveStatements() {" d78d9ed^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"

======= fetch "public void resolveStatements() {" d78d9ed^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"

        
        //System.out.println("resolved: " + getPointcut() + ", " + getPointcut().state);
        resolvedPointcutDeclaration.setPointcut(getPointcut());
======= fetch "public ResolvedPointcutDefinition makeResolvedPointcutDefinition() {" d78d9ed^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"

        if (resolvedPointcutDeclaration != null) return resolvedPointcutDeclaration;
======= fetch "public ResolvedPointcutDefinition makeResolvedPointcutDefinition() {" d78d9ed^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"

======= fetch "public ResolvedPointcutDefinition makeResolvedPointcutDefinition() {" d78d9ed^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"

======= fetch "public void completeTypeBindings() {" d78d9ed^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
                buildInterTypeAndPerClause(b[j].scope);
            }
        }
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
                resolvePointcutDeclarations(b[j].scope);
            }
        }
        
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
                addCrosscuttingStructures(b[j].scope);
            }
        }
======= fetch "public void completeTypeBindings() {" d78d9ed^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

            units[i] = null; // release unnecessary reference to the parsed unit
======= fetch "public void completeTypeBindings() {" d78d9ed^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

                
======= fetch "private void doPendingWeaves() {" d78d9ed^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

    private void addCrosscuttingStructures(ClassScope s) {
        TypeDeclaration dec = s.referenceContext;
        
        if (dec instanceof AspectDeclaration) {
            ResolvedTypeX typeX = factory.fromEclipse(dec.binding);
            factory.getWorld().getCrosscuttingMembersSet().addOrReplaceAspect(typeX);
        
            if (typeX.getSuperclass().isAspect() && !typeX.getSuperclass().isExposedToWeaver()) {
                factory.getWorld().getCrosscuttingMembersSet().addOrReplaceAspect(typeX.getSuperclass());
            }
        }
        
        SourceTypeBinding sourceType = s.referenceContext.binding;
        ReferenceBinding[] memberTypes = sourceType.memberTypes;
        for (int i = 0, length = memberTypes.length; i < length; i++) {
            addCrosscuttingStructures(((SourceTypeBinding) memberTypes[i]).scope);
        }
    }
    
    private void resolvePointcutDeclarations(ClassScope s) {
        TypeDeclaration dec = s.referenceContext;
        SourceTypeBinding sourceType = s.referenceContext.binding;
        
        AbstractMethodDeclaration[] methods = dec.methods;
        boolean initializedMethods = false;
        if (methods != null) {
            for (int i=0; i < methods.length; i++) {
                if (methods[i] instanceof PointcutDeclaration) {
                    if (!initializedMethods) {
                        sourceType.methods(); //force initialization
                        initializedMethods = true;
                    }
                    ((PointcutDeclaration)methods[i]).resolvePointcut(s);
                }
            }
        }
        
        ReferenceBinding[] memberTypes = sourceType.memberTypes;
        for (int i = 0, length = memberTypes.length; i < length; i++) {
            resolvePointcutDeclarations(((SourceTypeBinding) memberTypes[i]).scope);
        }
    }
    
    
    
    public void mumble() throws java.io.IOException { } // CE expected
    public pointcut executionsThrowingChecked() : 
        execution(* *(..) throws (Exception+ && !RuntimeException));
    public pointcut scope() : within(SampleExceptionHandling1);
    
    public pointcut executionsThrowingChecked() : 
        Library.executionsThrowingChecked() && scope();
    declare error : executionsThrowingChecked(): 
        "no checked exceptions";
 * @author Ron Bodkin
 * @author Jim Hugunin
 */
    public pointcut scope() : within(NoSoftener);
    abstract pointcut scope();
    public pointcut callsThrowingChecked() : call(* *(..)) && scope();
    declare soft: NoSuchMethodException: callsThrowingChecked();
 * @author Ron Bodkin
 * @author Jim Hugunin
 */
    public static void main(String[] args) {
        Throwable wrapped = null;
        try {
            new NoSoftener().foo(Integer.class);
        } catch (org.aspectj.lang.SoftException se) {
            wrapped = se.getWrappedThrowable();
        }
        Tester.checkNonNull(wrapped, "exception thrown");
        Tester.check(wrapped instanceof NoSuchMethodException,
                "must be NoSuchMethodException");
        
    }
    
    public void foo(Class clazz) {
        Class[] keyArgType = {};
        Constructor ctor = clazz.getConstructor(keyArgType);
    }
======= fetch "public boolean isAjSynthetic() {" d78d9ed^:"weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.java"


    pointcut exceptionThrower() :
        execution(public * ExceptionBugTest.*(..) throws Exception+);
    declare warning : exceptionThrower() : "throws both";
    
    declare error : execution(public * ExceptionBugTest.*(..) throws Exception) : 
        "throws Exception";
    int x;
    class MyException extends Exception {}
    public void method1() throws Exception { x = 1; } // warning here
    public void method2() throws MyException { x = 2; } // warning here
======= fetch "private boolean matchesAny(" 8660cc1^:"weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java"


======= fetch "public void generate(CodeStream codeStream) {" 5a07dce^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

        PerClause perClause;
        if (binding instanceof BinaryTypeBinding) {
            ResolvedTypeX superTypeX = factory.fromEclipse(binding);
            perClause = superTypeX.getPerClause();
        } else if (binding instanceof SourceTypeBinding ) {
======= fetch "public void generate(CodeStream codeStream) {" 5a07dce^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= fetch "public void generate(CodeStream codeStream) {" 5a07dce^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

        if (perClause == null) {
            return lookupPerClauseKind(binding.superclass()); 
        } else {
            return perClause.getKind();
    }
    public static void main(String[] args) throws Exception {

    public static void main (String[] args) {
        // don't move these lines without changing expectEvents below
        new Sub().run();
        new SubSub().run();
        new SubSubSub().run();
        ((Super) new Sub()).run();
        ((Super) new SubSub()).run();
        ((Super) new SubSubSub()).run();
        ((Sub) new SubSub()).run();
        ((Sub) new SubSubSub()).run();
        ((SubSub) new SubSubSub()).run();
    } 
    static {
        // generated from System.out call below
        Tester.expectEvent("Super  1 10");
        Tester.expectEvent("Sub  2 10");
        Tester.expectEvent("Super  3 11");
        Tester.expectEvent("Sub  4 11");
        Tester.expectEvent("SubSub 5 11");
        Tester.expectEvent("Super  6 12");
        Tester.expectEvent("Sub  7 12");
        Tester.expectEvent("SubSub 8 12");
        Tester.expectEvent("SubSubSub 9 12");
        Tester.expectEvent("Super  10 13");
        Tester.expectEvent("Super  11 14");
        Tester.expectEvent("Super  12 15");
        Tester.expectEvent("Super  13 16");
        Tester.expectEvent("Sub  14 16");
        Tester.expectEvent("Super  15 17");
        Tester.expectEvent("Sub  16 17");
        Tester.expectEvent("Super  17 18");
        Tester.expectEvent("Sub  18 18");
        Tester.expectEvent("SubSub 19 18");
    }
    int count;
    void advice(String s, JoinPoint.StaticPart jp) {
        s = s 
            + " " 
            + ++count 
            + " " 
            + jp.getSourceLocation().getLine();
        Tester.event(s);
        // use after moving code lines above
        //System.out.println("Tester.expectEvent(\"" + s + "\");");
    }
    before() : call (void Super.run()) {
        advice("Super ", thisJoinPointStaticPart);
    }
    before() : call (void Sub.run()) {
        advice("Sub ", thisJoinPointStaticPart);
    }
    before() : call (void SubSub.run()) {
        advice("SubSub", thisJoinPointStaticPart);
    }
    before() : call (void SubSubSub.run()) {
        advice("SubSubSub", thisJoinPointStaticPart);
    }
    after() returning : execution(void CallReference.main(String[])) {
        Tester.checkAllEvents();
    }

======= fetch "private void unpackLocals(MethodGen gen) {" d90acdc^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

                            lng.setStart(null);
======= fetch "private void unpackLocals(MethodGen gen) {" d90acdc^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

                            lng.setEnd(null);
======= fetch "public void packBody(MethodGen gen) {" d90acdc^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

                            if (i instanceof LocalVariableInstruction) {
                                int index = ((LocalVariableInstruction)i).getIndex();
                                if (lvt.getSlot() == index) {
                                    if (localVariableStarts.get(lvt) == null) {
                                        localVariableStarts.put(lvt, jh);
                                    }
                                    localVariableEnds.put(lvt, jh);
                                }
                            }
======= fetch "public void packBody(MethodGen gen) {" d90acdc^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= fetch "public void packBody(MethodGen gen) {" d90acdc^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        
======= fetch "public void packBody(MethodGen gen) {" d90acdc^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

                         LocalVariableTag taga = (LocalVariableTag)a; 
                         LocalVariableTag tagb = (LocalVariableTag)b; 
                         return taga.getName().compareTo(tagb.getName()); 
                 }}); 
         for (Iterator iter = keys.iterator(); iter.hasNext(); ) { 

======= fetch "public static BrowserManager getDefault() {" f1deb9c^:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"

======= fetch "public void init(MultiStructureViewPanel multiViewPanel, JPanel compilerMessages" f1deb9c^:"ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java"

            this.setIconImage(((ImageIcon)AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(ProgramElementNode.Kind.ADVICE)).getImage());
======= fetch "public void actionPerformed(ActionEvent e) {" f1deb9c^:"ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java"

        editConfig_button.setIcon(AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(ProgramElementNode.Kind.FILE_LST));
======= fetch "private boolean pruneEmptyDirs(BuildConfigNode node) {" f1deb9c^:"ajde/src/org/aspectj/ajde/internal/LstBuildConfigManager.java"

======= fetch "public AbstractIcon getRelationIcon(Relation relation) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getRelationIcon(Relation relation) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getRelationIcon(Relation relation) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "protected AbstractIcon getStructureIcon(ProgramElementNode.Kind kind, ProgramEle" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public AbstractIcon getStructureIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= fetch "public void setSourceFile(String sourceFile) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/BuildConfigModel.java"

 * 
 * TODO: clean-up after merging of org.aspectj.asm.StructureNode
======= fetch "public BuildConfigNode(String name, Kind kind, String resourcePath) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/BuildConfigNode.java"

======= fetch "public BuildConfigNode(String name, Kind kind, String resourcePath) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/BuildConfigNode.java"

    
    
======= fetch "public BuildConfigNode(String name, String kind, String resourcePath, List child" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/BuildConfigNode.java"

======= fetch "public static Map getLinesToAspectMap(String sourceFilePath) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= fetch "public static Map getLinesToAspectMap(String sourceFilePath) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= fetch "public static Map getLinesToAspectMap(String sourceFilePath) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= fetch "public static Map getLinesToAspectMap(String sourceFilePath) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= fetch "public static Map getLinesToAspectMap(String sourceFilePath) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= fetch "public static Set getAspectsAffectingPackage(ProgramElementNode packageNode) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= fetch "public static List getPackagesInModel() {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= fetch "private static List getPackagesHelper(" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= fetch "private static List getPackagesHelper(" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= fetch "private static List getPackagesHelper(" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= fetch "private static List getPackagesHelper(" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= fetch "public int compare(Object o1, Object o2) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= fetch "public int compare(Object o1, Object o2) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= fetch "public int compare(Object o1, Object o2) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= fetch "public static List getFilesInPackage(ProgramElementNode packageNode) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= fetch "public List findMatches(" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureSearchManager.java"

======= fetch "public List findMatches(" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureSearchManager.java"

======= fetch "private List findMatchesHelper(" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureSearchManager.java"

======= fetch "private List findMatchesHelper(" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureSearchManager.java"

======= fetch "private List findMatchesHelper(" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureSearchManager.java"

======= fetch "private List findMatchesHelper(" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureSearchManager.java"

======= fetch "private List findMatchesHelper(" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureSearchManager.java"

======= fetch "public StructureViewNode getActiveNode() {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureView.java"

======= fetch "public StructureViewNode getActiveNode() {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureView.java"

======= fetch "public StructureViewNode findCorrespondingViewNode(ProgramElementNode node) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureView.java"

    public final StructureModelListener VIEW_LISTENER = new StructureModelListener() {
======= fetch "public void fireNavigateBackAction(StructureView view) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= fetch "public void fireNavigateForwardAction(StructureView view) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= fetch "public void fireNavigationAction(String newFilePath, int lineNumber) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= fetch "public void fireNavigationAction(String newFilePath, int lineNumber) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= fetch "public void fireNavigationAction(String newFilePath, int lineNumber) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= fetch "public void fireNavigationAction(StructureNode structureNode) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= fetch "public void fireNavigationAction(StructureNode structureNode) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= fetch "private void navigationAction(ProgramElementNode node, boolean recordHistory) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= fetch "private void navigationAction(ProgramElementNode node, boolean recordHistory) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= fetch "public FileStructureView getDefaultFileView() {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

        AVAILABLE_RELATIONS.add(AdviceAssociation.METHOD_CALL_SITE_RELATION);
        AVAILABLE_RELATIONS.add(AdviceAssociation.METHOD_RELATION);
        AVAILABLE_RELATIONS.add(AdviceAssociation.CONSTRUCTOR_CALL_SITE_RELATION);
        AVAILABLE_RELATIONS.add(AdviceAssociation.CONSTRUCTOR_RELATION);
        AVAILABLE_RELATIONS.add(AdviceAssociation.FIELD_ACCESS_RELATION);
        AVAILABLE_RELATIONS.add(AdviceAssociation.INITIALIZER_RELATION);
        AVAILABLE_RELATIONS.add(AdviceAssociation.HANDLER_RELATION);
        AVAILABLE_RELATIONS.add(AdviceAssociation.INTRODUCTION_RELATION);
        AVAILABLE_RELATIONS.add(IntroductionAssociation.INTRODUCES_RELATION);
        AVAILABLE_RELATIONS.add(InheritanceAssociation.IMPLEMENTS_RELATION);
        AVAILABLE_RELATIONS.add(InheritanceAssociation.INHERITS_RELATION);
        AVAILABLE_RELATIONS.add(InheritanceAssociation.INHERITS_MEMBERS_RELATION);
        AVAILABLE_RELATIONS.add(ReferenceAssociation.USES_POINTCUT_RELATION);
        AVAILABLE_RELATIONS.add(ReferenceAssociation.IMPORTS_RELATION);
======= fetch "public StructureViewNodeFactory(AbstractIconRegistry iconRegistry) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewNodeFactory.java"

======= fetch "public StructureViewNode createNode(StructureNode node) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewNodeFactory.java"

======= fetch "public StructureViewNode createNode(StructureNode node, List children) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewNodeFactory.java"

======= fetch "public StructureViewNode createNode(StructureNode node, List children) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewNodeFactory.java"

======= fetch "public StructureViewNode createNode(StructureNode node, List children) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewNodeFactory.java"

======= fetch "public StructureViewNode createNode(StructureNode node, List children) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewNodeFactory.java"

======= fetch "public void setRelations(List relations) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java"

    public void addRelation(Relation relation) {
        relations.add(relation);
======= fetch "public void addRelation(Relation relation) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java"

    public void removeRelation(Relation relation) {
        relations.remove(relation);
======= fetch "public List getFilteredMemberAccessibility() {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java"

    public void addFilteredMemberAccessibility(ProgramElementNode.Accessibility accessibility) {
======= fetch "public void addFilteredMemberAccessibility(ProgramElementNode.Accessibility acce" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java"

======= fetch "public void setFilteredMemberModifiers(List memberModifiers) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java"

    public void addFilteredMemberModifiers(ProgramElementNode.Modifiers modifiers) {
======= fetch "public void addFilteredMemberModifiers(ProgramElementNode.Modifiers modifiers) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java"

======= fetch "public void setFilteredMemberKinds(List memberKinds) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java"

    public void addFilteredMemberKind(ProgramElementNode.Kind kind) {
======= fetch "public void addFilteredMemberKind(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java"

    private ProgramElementNode currNode = null;
======= fetch "public ProgramElementNode navigateBack() {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/NavigationHistoryModel.java"

======= fetch "public ProgramElementNode navigateBack() {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/NavigationHistoryModel.java"

======= fetch "public ProgramElementNode navigateForward() {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/NavigationHistoryModel.java"

======= fetch "public ProgramElementNode navigateForward() {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/NavigationHistoryModel.java"

    public void navigateToNode(ProgramElementNode toNode) {
======= fetch "public void buildView(StructureView view, StructureModel model) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

======= fetch "public void buildView(StructureView view, StructureModel model) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

======= fetch "private void addPackageNode(StructureView view, StructureViewNode viewRoot) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

======= fetch "private void addPackageNode(StructureView view, StructureViewNode viewRoot) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

======= fetch "private StructureViewNode createViewNode(StructureNode node, StructureViewProper" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

======= fetch "private StructureViewNode createViewNode(StructureNode node, StructureViewProper" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

======= fetch "private boolean isFileView(StructureView view) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

======= fetch "private boolean acceptGranularity(ProgramElementNode.Kind kind, StructureViewPro" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

======= fetch "private boolean acceptGranularity(ProgramElementNode.Kind kind, StructureViewPro" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

======= fetch "private boolean acceptGranularity(ProgramElementNode.Kind kind, StructureViewPro" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

======= fetch "private boolean acceptGranularity(ProgramElementNode.Kind kind, StructureViewPro" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

======= fetch "private boolean acceptGranularity(ProgramElementNode.Kind kind, StructureViewPro" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

======= fetch "private boolean acceptNode(StructureNode node, StructureViewProperties propertie" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

======= fetch "private boolean acceptNode(StructureNode node, StructureViewProperties propertie" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

======= fetch "private StructureViewNode buildCustomTree(GlobalStructureView view, StructureMod" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

        StructureNode rootNode = model.getRoot();
======= fetch "private StructureViewNode buildCustomTree(GlobalStructureView view, StructureMod" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

                treeNode.add(getCrosscuttingChildren((StructureNode)it.next()));
======= fetch "private StructureViewNode buildCustomTree(GlobalStructureView view, StructureMod" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

                	(StructureNode)it.next(),
======= fetch "private StructureViewNode buildCustomTree(GlobalStructureView view, StructureMod" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

    private void getRoots(StructureNode rootNode, List roots, StructureViewProperties.Hierarchy hierarchy) {
        if (rootNode != null && rootNode.getChildren() != null) {
            for (Iterator it = rootNode.getChildren().iterator(); it.hasNext(); ) {
                StructureNode node = (StructureNode)it.next();
                if (node instanceof ProgramElementNode) {
                    if (acceptNodeAsRoot((ProgramElementNode)node, hierarchy)) {
                        ProgramElementNode pNode = (ProgramElementNode)node;
                        List relations = pNode.getRelations();
                        String delimiter = "";
                        if (hierarchy.equals(StructureViewProperties.Hierarchy.CROSSCUTTING)) {
                            delimiter = "uses pointcut";
                        } else if (hierarchy.equals(StructureViewProperties.Hierarchy.INHERITANCE)) {
                            delimiter = "inherits";
                        } 
                        if (relations != null && relations.toString().indexOf(delimiter) == -1) {
                            boolean found = false;
                            for (Iterator it2 = roots.iterator(); it2.hasNext(); ) {
                                if (((ProgramElementNode)it2.next()).equals(pNode)) found = true;
                            }
                            if (!found) roots.add(pNode);
                        } 
                    } 
                }
                getRoots(node, roots, hierarchy);
            }
        }
======= fetch "private void getRoots(StructureNode rootNode, List roots, StructureViewPropertie" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

    public boolean acceptNodeAsRoot(ProgramElementNode node, StructureViewProperties.Hierarchy hierarchy) {
======= fetch "public boolean acceptNodeAsRoot(ProgramElementNode node, StructureViewProperties" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

            return node.getProgramElementKind().equals(ProgramElementNode.Kind.ADVICE)
                || node.getProgramElementKind().equals(ProgramElementNode.Kind.POINTCUT);
======= fetch "public boolean acceptNodeAsRoot(ProgramElementNode node, StructureViewProperties" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

            return node.getProgramElementKind().equals(ProgramElementNode.Kind.CLASS);
======= fetch "public boolean acceptNodeAsRoot(ProgramElementNode node, StructureViewProperties" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

    private StructureViewNode getInheritanceChildren(StructureNode node, List associations) {
======= fetch "private StructureViewNode getInheritanceChildren(StructureNode node, List associ" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

        List relations = ((ProgramElementNode)node).getRelations();
        if (relations != null) {
            for (Iterator it = relations.iterator(); it.hasNext(); ) {
                RelationNode relation = (RelationNode)it.next();
                if (relation.getName().equals("is inherited by")) {
                    for (Iterator it2 = relation.getChildren().iterator(); it2.hasNext(); ) {
                        ProgramElementNode pNode = ((LinkNode)it2.next()).getProgramElementNode();
                        StructureViewNode newNode = getInheritanceChildren(pNode, associations);
                        StructureViewNode typeChildren = buildTree(newNode.getStructureNode(), associations);
                        for (int i = 0; i < typeChildren.getChildren().size(); i++) {
                            newNode.add((StructureViewNode)typeChildren.getChildren().get(i));
                        }
                    }
                }
            }
        }
        return treeNode;
======= fetch "private StructureViewNode getInheritanceChildren(StructureNode node, List associ" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

    private StructureViewNode getCrosscuttingChildren(StructureNode node) {
======= fetch "private StructureViewNode getCrosscuttingChildren(StructureNode node) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

        List relations = ((ProgramElementNode)node).getRelations();
        if (relations != null) {
            for (Iterator it = relations.iterator(); it.hasNext(); ) {
                RelationNode relation = (RelationNode)it.next();
                if (relation.getName().equals("pointcut used by")) {
                    for (Iterator it2 = relation.getChildren().iterator(); it2.hasNext(); ) {
                        ProgramElementNode pNode = ((LinkNode)it2.next()).getProgramElementNode();
                        StructureViewNode newNode = getCrosscuttingChildren(pNode);
                        for (Iterator it3 = pNode.getRelations().iterator(); it3.hasNext(); ) {
                            RelationNode relationNode = (RelationNode)it3.next();
                            if (relationNode.getName().indexOf("pointcut") == -1) {
                                newNode.add(getRelations(relationNode));
                            }
                        }
                        treeNode.add(newNode);
                    }
                } else if (relations.toString().indexOf("uses pointcut") == -1) {
                    for (Iterator it4 = relations.iterator(); it4.hasNext(); ) {
                        RelationNode relationNode = (RelationNode)it4.next();
                        if (relationNode.getName().indexOf("pointcut") == -1) {
                            treeNode.add(getRelations(relationNode));
                        }
                    }
                }
            }
        }
        return treeNode;
======= fetch "private StructureViewNode getCrosscuttingChildren(StructureNode node) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

    private StructureViewNode buildTree(StructureNode node, List associations) {
======= fetch "private StructureViewNode buildTree(StructureNode node, List associations) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

        if (node instanceof ProgramElementNode) {
            List relations = ((ProgramElementNode)node).getRelations();
            if (relations != null) {
                for (Iterator it = relations.iterator(); it.hasNext(); ) {
                    RelationNode relationNode = (RelationNode)it.next();
                    if (associations.contains(relationNode.getRelation().toString())) {
                        treeNode.add(buildTree(relationNode, associations));
                    }
                }
            }
        }
======= fetch "private StructureViewNode buildTree(StructureNode node, List associations) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

                    StructureNode child = (StructureNode)itt.next();
                    if (child instanceof ProgramElementNode) {
                        ProgramElementNode progNode = (ProgramElementNode)child;
======= fetch "private StructureViewNode buildTree(StructureNode node, List associations) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

    private StructureViewNode getRelations(RelationNode node) {
======= fetch "private StructureViewNode getRelations(RelationNode node) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

        for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
======= fetch "private StructureViewNode getRelations(RelationNode node) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

            	nodeFactory.createNode((StructureNode)it.next())
======= fetch "public int compare(Object o1, Object o2) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

        	StructureNode sv1 = ((StructureViewNode)o1).getStructureNode();
        	StructureNode sv2 = ((StructureViewNode)o2).getStructureNode();        
            if (sv1 instanceof ProgramElementNode && sv2 instanceof ProgramElementNode) {
            	ProgramElementNode p1 = (ProgramElementNode)sv1;
            	ProgramElementNode p2 = (ProgramElementNode)sv2;
======= fetch "public int compare(Object o1, Object o2) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

        	StructureNode sv1 = ((StructureViewNode)o1).getStructureNode();
        	StructureNode sv2 = ((StructureViewNode)o2).getStructureNode();        
            if (sv1 instanceof ProgramElementNode && sv2 instanceof ProgramElementNode) {
            	ProgramElementNode p1 = (ProgramElementNode)sv1;
            	ProgramElementNode p2 = (ProgramElementNode)sv2;
======= fetch "public void init(" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/AjdeUIManager.java"

======= fetch "public void init(" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/AjdeUIManager.java"

======= fetch "public void init(" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/AjdeUIManager.java"

======= fetch "private JPopupMenu createFilterMenu() {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= fetch "private JPopupMenu createFilterMenu() {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= fetch "private JPopupMenu createFilterMenu() {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= fetch "private JPopupMenu createRelationsMenu() {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= fetch "public CheckBoxSelectionMenuButton(String name) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= fetch "public CheckBoxSelectionMenuButton(ProgramElementNode.Accessibility accessibilit" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= fetch "public CheckBoxSelectionMenuButton(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= fetch "public CheckBoxSelectionMenuButton(StructureViewProperties.Sorting sorting) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= fetch "public CheckBoxSelectionMenuButton(Relation relation) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= fetch "public CheckBoxSelectionMenuButton(Relation relation) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= fetch "public CheckBoxSelectionMenuButton(Relation relation) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= fetch "public CheckBoxSelectionMenuActionListener(ProgramElementNode.Accessibility acce" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= fetch "public CheckBoxSelectionMenuActionListener(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= fetch "public CheckBoxSelectionMenuActionListener(StructureViewProperties.Sorting sorti" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= fetch "public void actionPerformed(ActionEvent e) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserView.java"

        joinpointProbe_button.setIcon(icons.getStructureSwingIcon(ProgramElementNode.Kind.POINTCUT));
    private ProgramElementNode currNode = null;
======= fetch "public void extractAndInsertSignatures(java.util.List signatures, boolean calls)" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewManager.java"

        CROSSCUTTING_VIEW_PROPERTIES.addRelation(AdviceAssociation.METHOD_RELATION);
        CROSSCUTTING_VIEW_PROPERTIES.addRelation(AdviceAssociation.METHOD_CALL_SITE_RELATION);
        CROSSCUTTING_VIEW_PROPERTIES.addRelation(AdviceAssociation.CONSTRUCTOR_RELATION);
        CROSSCUTTING_VIEW_PROPERTIES.addRelation(AdviceAssociation.CONSTRUCTOR_CALL_SITE_RELATION);
        CROSSCUTTING_VIEW_PROPERTIES.addRelation(AdviceAssociation.HANDLER_RELATION);
        CROSSCUTTING_VIEW_PROPERTIES.addRelation(AdviceAssociation.INITIALIZER_RELATION);
        CROSSCUTTING_VIEW_PROPERTIES.addRelation(AdviceAssociation.FIELD_ACCESS_RELATION);
        INHERITANCE_VIEW_PROPERTIES.addRelation(InheritanceAssociation.IMPLEMENTS_RELATION);
        INHERITANCE_VIEW_PROPERTIES.addRelation(InheritanceAssociation.INHERITS_MEMBERS_RELATION);
        INHERITANCE_VIEW_PROPERTIES.addRelation(InheritanceAssociation.INHERITS_RELATION);
======= fetch "public void singleClickNavigation(MouseEvent e) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java"

            StructureNode currNode = (StructureNode)treeNode.getUserObject();
            if (currNode instanceof ProgramElementNode && !e.isControlDown()
======= fetch "public void singleClickNavigation(MouseEvent e) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java"

            } else if (currNode instanceof LinkNode) {
======= fetch "public void singleClickNavigation(MouseEvent e) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java"

           }
======= fetch "public void doubleClickNavigation(MouseEvent e) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java"

                StructureNode currNode = (StructureNode)treeNode.getUserObject();
                if (currNode instanceof ProgramElementNode && !e.isControlDown() && !e.isShiftDown()
======= fetch "public void doubleClickNavigation(MouseEvent e) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java"

                } else if (currNode instanceof LinkNode) {
                    if (clickCount == 1) {
                        //AjdeUIManager.getDefault().getViewManager().showLink((LinkNode)currNode);
                    } else if (clickCount == 2) {
                        //navigationAction((ProgramElementNode)((LinkNode)currNode).getProgramElementNode(), true, true);
                    }
                }
======= fetch "private void maybeShowPopup(MouseEvent e) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java"

                StructureNode currNode = (StructureNode)((SwingTreeViewNode)selectionPaths[i].getLastPathComponent()).getUserObject();
                if (currNode instanceof LinkNode || currNode instanceof ProgramElementNode) {
                    signatures.add(currNode);
                }
======= fetch "private void maybeShowPopup(MouseEvent e) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java"

            JMenuItem showSourcesItem = new JMenuItem("Display sources", AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(ProgramElementNode.Kind.CODE));
======= fetch "public void actionPerformed(ActionEvent e) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java"

======= fetch "public void actionPerformed(ActionEvent e) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java"

======= fetch "public void actionPerformed(ActionEvent e) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java"

            JMenuItem generatePCD = new JMenuItem("Pointcut Wizard (alpha)...", AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(ProgramElementNode.Kind.POINTCUT));
======= fetch "public void actionPerformed(ActionEvent e) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/BuildConfigPopupMenu.java"

    public Icon getAssociationSwingIcon(Relation relation) {
======= fetch "public Icon getAssociationSwingIcon(Relation relation) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/IconRegistry.java"

======= fetch "protected AbstractIcon getStructureIcon(ProgramElementNode.Kind kind, ProgramEle" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/IconRegistry.java"

    public Icon getStructureSwingIcon(ProgramElementNode.Kind kind, ProgramElementNode.Accessibility accessibility) { 
======= fetch "public Icon getStructureSwingIcon(ProgramElementNode.Kind kind, ProgramElementNo" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/IconRegistry.java"

======= fetch "public Icon getStructureSwingIcon(ProgramElementNode.Kind kind) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/IconRegistry.java"

======= fetch "public Icon getAccessibilitySwingIcon(ProgramElementNode.Accessibility accessibi" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/IconRegistry.java"

======= fetch "public Icon getAccessibilitySwingIcon(ProgramElementNode.Accessibility accessibi" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/IconRegistry.java"

======= fetch "public Icon getAccessibilitySwingIcon(ProgramElementNode.Accessibility accessibi" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/IconRegistry.java"

======= fetch "public Icon getAccessibilitySwingIcon(ProgramElementNode.Accessibility accessibi" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/IconRegistry.java"

======= fetch "private Map getViewProperties() {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/PointcutWizard.java"

        INHERITANCE_VIEW.addRelation(InheritanceAssociation.INHERITS_RELATION);
    public final StructureModelListener MODEL_LISTENER = new StructureModelListener() {
======= fetch "private void hideNonAJ_button_actionPerformed(ActionEvent e) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/SimpleStructureViewToolPanel.java"

======= fetch "public StructureTreeManager() {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java"

======= fetch "public void highlightNode(ProgramElementNode node) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java"

    public StructureNode getSelectedStructureNode() {
        return (StructureNode)((SwingTreeViewNode)structureTree.getLastSelectedPathComponent()).getUserObject();
======= fetch "public void scrollToHighlightedNode() {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java"

    private void highlightNode(SwingTreeViewNode parent, ProgramElementNode node) {
======= fetch "private void highlightNode(SwingTreeViewNode parent, ProgramElementNode node) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java"

            StructureNode sNode = (StructureNode)currNode.getUserObject();
            if (sNode instanceof ProgramElementNode &&
                ((ProgramElementNode)sNode).equals(node)) {
======= fetch "private void expandTreeToFiles() {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java"

            if (node.getUserObject() instanceof ProgramElementNode) {
======= fetch "private void expandTree(int depth) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java"

            if (path.getPath().length-1 > depth || node.getUserObject() instanceof RelationNode) {
======= fetch "public void valueForPathChanged(TreePath path, Object newValue) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java"

======= fetch "public void valueForPathChanged(TreePath path, Object newValue) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java"

======= fetch "public void valueForPathChanged(TreePath path, Object newValue) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java"

======= fetch "public void valueForPathChanged(TreePath path, Object newValue) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java"

======= fetch "public void valueForPathChanged(TreePath path, Object newValue) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java"

======= fetch "public void valueForPathChanged(TreePath path, Object newValue) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java"

======= fetch "public void setActiveNode(StructureViewNode node, int lineOffset) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/StructureViewPanel.java"

 		if (!(node.getStructureNode() instanceof ProgramElementNode)) return;
======= fetch "public void highlightActiveNode() {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/StructureViewPanel.java"

 		StructureNode node = currentView.getActiveNode().getStructureNode();
 		if (node instanceof ProgramElementNode) {
 			treeManager.highlightNode((ProgramElementNode)node);
======= fetch "public SwingTreeViewNode(StructureNode structureNode, AbstractIcon icon, List ch" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNode.java"

======= fetch "public SwingTreeViewNode(StructureNode structureNode, AbstractIcon icon, List ch" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNode.java"

======= fetch "public SwingTreeViewNodeFactory(IconRegistry iconRegistry) {" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNodeFactory.java"

======= fetch "protected StructureViewNode createConcreteNode(StructureNode node, AbstractIcon" f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNodeFactory.java"

======= fetch "public Component getTreeCellRendererComponent(JTree tree," f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNodeRenderer.java"

        StructureNode node = viewNode.getStructureNode();
======= fetch "public Component getTreeCellRendererComponent(JTree tree," f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNodeRenderer.java"

        if (node instanceof LinkNode) {
            ISourceLocation sourceLoc = ((LinkNode)node).getProgramElementNode().getSourceLocation();
            if ((null != sourceLoc) 
                && (null != sourceLoc.getSourceFile().getAbsolutePath())) {
                setTextNonSelectionColor(AjdeWidgetStyles.LINK_NODE_COLOR);
            } else {
                setTextNonSelectionColor(AjdeWidgetStyles.LINK_NODE_NO_SOURCE_COLOR);
            }
        } else {
======= fetch "public Component getTreeCellRendererComponent(JTree tree," f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNodeRenderer.java"

        }
======= fetch "public Component getTreeCellRendererComponent(JTree tree," f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNodeRenderer.java"

        if (node instanceof ProgramElementNode) {
        	ProgramElementNode pNode = (ProgramElementNode)node;
        	if (pNode.isRunnable()) {
        		//setIcon(AjdeUIManager.getDefault().getIconRegistry().getExecuteIcon());
        	}	 
        	if (pNode.isImplementor()) {
        		//this.setText("<implementor>");
        	}
        	if (pNode.isOverrider()) {
        		//this.setText("<overrider>");
        	}
        } else if (node instanceof RelationNode) {
        	this.setFont(new Font(this.getFont().getName(), Font.ITALIC, this.getFont().getSize()));
        }
======= fetch "public Component getTreeCellRendererComponent(JTree tree," f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNodeRenderer.java"

        if (node.getMessage() != null) {
        	if (node.getMessage().getKind().equals(IMessage.WARNING)) {
        		setIcon(AjdeUIManager.getDefault().getIconRegistry().getWarningIcon());
        	} else if (node.getMessage().getKind().equals(IMessage.ERROR)) {
        		setIcon(AjdeUIManager.getDefault().getIconRegistry().getErrorIcon());
        	} else {
        		setIcon(AjdeUIManager.getDefault().getIconRegistry().getInfoIcon());
        	}
======= fetch "public Component getTreeCellRendererComponent(JTree tree," f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/TreeViewBuildConfigEditor.java"

            	setIcon(AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(ProgramElementNode.Kind.FILE_ASPECTJ));	
======= fetch "public Component getTreeCellRendererComponent(JTree tree," f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/TreeViewBuildConfigEditor.java"

            	setIcon(AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(ProgramElementNode.Kind.FILE_JAVA));	
======= fetch "public Component getTreeCellRendererComponent(JTree tree," f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/TreeViewBuildConfigEditor.java"

            	setIcon(AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(ProgramElementNode.Kind.FILE_LST));	
======= fetch "public Component getTreeCellRendererComponent(JTree tree," f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/TreeViewBuildConfigEditor.java"

            	setIcon(AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(ProgramElementNode.Kind.PACKAGE));	
======= fetch "public Component getTreeCellRendererComponent(JTree tree," f1deb9c^:"ajde/src/org/aspectj/ajde/ui/swing/TreeViewBuildConfigEditor.java"

            	setIcon((Icon)AjdeUIManager.getDefault().getIconRegistry().getStructureIcon(ProgramElementNode.Kind.ERROR).getIconResource());	
======= fetch "void doIt() {" f1deb9c^:"ajde/testdata/examples/coverage/ModelCoverage.java"

======= fetch "public static Test suite() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

======= fetch "public AsmDeclarationsTest(String name) {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public AsmDeclarationsTest(String name) {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testDeclares() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testDeclares() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testDeclares() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testDeclares() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testDeclares() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testDeclares() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testDeclares() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testDeclares() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testDeclares() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testInterTypeMemberDeclares() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testInterTypeMemberDeclares() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testInterTypeMemberDeclares() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testInterTypeMemberDeclares() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testPointcuts() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testPointcuts() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testPointcuts() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testPointcuts() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testAbstract() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testAbstract() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testAbstract() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testAdvice() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testAdvice() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testAdvice() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testAdvice() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testAdvice() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testAdvice() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testAdvice() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testAdvice() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= fetch "public void testAdvice() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 * 
 * ******************************************************************/
 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 * ******************************************************************/
 * @author Mik Kersten
 */
======= fetch "public void init(String testProjectPath) {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/NullIdeManager.java"

======= fetch "public void init(String testProjectPath) {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/NullIdeManager.java"

 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 * ******************************************************************/
 * @author Mik Kersten
 */
======= fetch "public void addSourcelineTask(IMessage message) {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/NullIdeTaskListManager.java"

    	System.out.println("> added sourceline task: " + message + ", file: " + message.getSourceLocation().getSourceFile().getAbsolutePath()
======= fetch "public void addProjectTask(String message, IMessage.Kind kind) {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/NullIdeTaskListManager.java"

    	System.out.println("> added project task: " + message + ", kind: " + kind);	
======= fetch "public void displayStatusInformation(String message) {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/NullIdeUIAdapter.java"

======= fetch "public boolean verifyAgainstSavedModel(String lstFile) {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java"

======= fetch "public boolean verifyAgainstSavedModel(String lstFile) {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java"

======= fetch "public boolean verifyAgainstSavedModel(String lstFile) {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java"

======= fetch "public boolean verifyAgainstSavedModel(String lstFile) {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java"

======= fetch "private boolean structureNodesEqual( StructureNode s1, StructureNode s2 ) {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java"

======= fetch "public static TestSuite suite() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= fetch "public static TestSuite suite() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= fetch "public void testRootForSourceFile() throws IOException {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= fetch "public void testRootForSourceFile() throws IOException {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= fetch "public void testPointcutName() throws IOException {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= fetch "public void testPointcutName() throws IOException {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= fetch "public void testFileNodeFind() throws IOException {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= fetch "public void testFileNodeFind() throws IOException {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= fetch "public void testMainClassNodeInfo() throws IOException {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= fetch "public void testMainClassNodeInfo() throws IOException {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= fetch "public void testModelIntegrity() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= fetch "public void testModelIntegrity() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= fetch "private void testModelIntegrityHelper(StructureNode node) throws Exception {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= fetch "public void testNoChildIsNull() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

  		ModelWalker walker = new ModelWalker() {
  		    public void preProcess(StructureNode node) {
======= fetch "public void testPackageViewUtil() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/ui/StructureModelUtilTest.java"

======= fetch "public void testPackageViewUtil() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/ui/StructureModelUtilTest.java"

======= fetch "public void testFindPatternAndKindMatch() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/ui/StructureSearchManagerTest.java"

======= fetch "public void testNotificationAfterConfigFileChange() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java"

======= fetch "public void testFreshStructureModelCreation() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java"

======= fetch "public void testFreshStructureModelCreation() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java"

======= fetch "public void testFreshStructureModelCreation() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java"

======= fetch "public void testModelIntegrity() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java"

======= fetch "public void testModelIntegrity() {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java"

======= fetch "private void testModelIntegrityHelper(StructureNode node) throws Exception {" f1deb9c^:"ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java"

 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
    public static final String NAME = "Advice";
    public static final Relation METHOD_RELATION = new Relation("advises methods", "method advised by", NAME, true, false);
    public static final Relation METHOD_CALL_SITE_RELATION = new Relation("advises method call sites", "method call site advised by", NAME, true, false);
    public static final Relation CONSTRUCTOR_RELATION = new Relation("advises constructors", "constructors advised by", NAME, true, false);
    public static final Relation CONSTRUCTOR_CALL_SITE_RELATION = new Relation("advises constructions", "construction advised by", NAME, true, false);
    public static final Relation HANDLER_RELATION = new Relation("advises exception handlers", "exception handler advised by", NAME, true, false);
    public static final Relation INITIALIZER_RELATION = new Relation("advises initializers", "initializers advised by", NAME, true, false);
    public static final Relation FIELD_ACCESS_RELATION = new Relation("advises field access", "field access advised by", NAME, true, false);
    public static final Relation INTRODUCTION_RELATION = new Relation("advises introduction", "introduction advised by", NAME, true, false);
    private List relations = new ArrayList();
    public AdviceAssociation() {
        relations.add(METHOD_RELATION);
        relations.add(METHOD_CALL_SITE_RELATION);
        relations.add(CONSTRUCTOR_RELATION);
        relations.add(CONSTRUCTOR_CALL_SITE_RELATION);
        relations.add(HANDLER_RELATION);
        relations.add(INITIALIZER_RELATION);
        relations.add(FIELD_ACCESS_RELATION);
        relations.add(INTRODUCTION_RELATION);
    }
    public List getRelations() {
        return relations;
    }
    public List getRelationNodes() {
        List relations = new ArrayList();
        List methods = new ArrayList();
        List methodCallSites = new ArrayList();
        List constructors = new ArrayList();
        List constructorCallSites = new ArrayList();
        List handlers = new ArrayList();
        List initializers = new ArrayList();
        List fieldAccesses = new ArrayList();
        List introductions = new ArrayList();
        return relations;
    }
    public String getName() {
        return NAME;
    }
 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
    public List getRelations();
    public List getRelationNodes();
    public String getName();
 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
    public static final String NAME = "Inheritance";
    public static final Relation INHERITS_RELATION = new Relation("inherits", "is inherited by", NAME, true, true);
    public static final Relation IMPLEMENTS_RELATION = new Relation("implements", "is implemented by", NAME, true, true);
    public static final Relation INHERITS_MEMBERS_RELATION = new Relation("inherits members", NAME, false);
    private List relations = new ArrayList();
    public InheritanceAssociation() {
        relations.add(INHERITS_RELATION);
        relations.add(IMPLEMENTS_RELATION);
        relations.add(INHERITS_MEMBERS_RELATION);
    }
    public List getRelations() {
        return relations;
    }
    public List getRelationNodes() {
        List relations = new ArrayList();
        return relations;
    }
    public String getName() {
        return NAME;
    }
 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
    public static final String NAME = "Introduction";
    public static final Relation INTRODUCES_RELATION = new Relation("declares member on", "inter-type declared members", NAME, true, false);
    private List relations = new ArrayList();
    public IntroductionAssociation() {
        relations.add(INTRODUCES_RELATION);
    }
    public List getRelations() {
        return relations;
    }
    public List getRelationNodes() {
        List relations = new ArrayList();
        List introduces = new ArrayList();
        return relations;
    }
    public String getName() {
        return NAME;
    }
 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
    
    private ProgramElementNode programElementNode = null;
    /**
     * Used during de-serialization.
     */
    public LinkNode() { }
    public LinkNode(ProgramElementNode node) {
        super(node.getSignature().toString(), "internal", null);
        this.programElementNode = node;
    }
    public ProgramElementNode getProgramElementNode() {
        return programElementNode;
    }
    public String toString() {
        String name = "";
        if (programElementNode.getProgramElementKind().equals(ProgramElementNode.Kind.ADVICE) ||
            programElementNode.getProgramElementKind().equals(ProgramElementNode.Kind.INTER_TYPE_FIELD) ||
            programElementNode.getProgramElementKind().equals(ProgramElementNode.Kind.CODE)) {
            name = programElementNode.parent.toString() + ": " + programElementNode.getName();
            if ( grandparent instanceof ProgramElementNode ) {
            	ProgramElementNode pe_grandparent = (ProgramElementNode)grandparent;
            	if ( pe_grandparent.getProgramElementKind().equals(ProgramElementNode.Kind.CLASS) ||
            	    ) {
            		name = pe_grandparent.toString() + "." + name;	
            	}
            }
            
        } else if (programElementNode.isMemberKind()) {
            name = programElementNode.parent.toString() + '.' + programElementNode.getName(); 
        } else {
            name = programElementNode.toString();
        }
        return name;
    }
 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
    }
    protected void preProcess(StructureNode node) { }
    
    protected void postProcess(StructureNode node) { }
    public StructureNode process(StructureNode node) {
        node.walk(this);
        postProcess(node);
        return node;
    }
 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
    private List relations = new ArrayList();
    private String declaringType = "";
    private String formalComment = "";
    private String packageName = null;
    private boolean runnable = false;
    private boolean implementor = false; 
    private boolean overrider = false;
    
    private String bytecodeName;
    private String bytecodeSignature;
    private String fullSignature;
    
    /**
     * Used during de-externalization.
     */
    public ProgramElementNode() { }
        super(signature, kind.toString(), children);
        super.sourceLocation = sourceLocation;
        this.kind = kind;
        this.formalComment = formalComment;
        this.modifiers = genModifiers(modifiers);
        this.accessibility = genAccessibility(modifiers);
    }
    public ProgramElementNode(
    	String signature, 
    	Kind kind, 
    	List modifiers, 
    	Accessibility accessibility,
        String declaringType, 
        String packageName, 
        String formalComment, 
        ISourceLocation sourceLocation,
        List relations, 
        List children, 
        boolean member) {
        super(signature, kind.toString(), children);
        super.sourceLocation = sourceLocation;
        this.kind = kind;
        this.modifiers = modifiers;
        this.accessibility = accessibility;
        this.declaringType = declaringType;
        this.packageName = packageName;
        this.formalComment = formalComment;
        this.relations = relations;
    }
    public List getModifiers() {
        return modifiers;
    }
    public Accessibility getAccessibility() {
        return accessibility;
    }
    public String getDeclaringType() {
        return declaringType;
    }
    public String getPackageName() {
    	if (kind == Kind.PACKAGE) return getSignature();
    	if (getParent() == null || !(getParent() instanceof ProgramElementNode)) {
    		return "";
    	}
    	return ((ProgramElementNode)getParent()).getPackageName();
    }
    public String getKind() {
        return super.kind;
    }
    public String getSignature() {
        return super.name;
    }
    public boolean isCode() {
        return kind.equals(Kind.CODE);
    }
    public boolean isMemberKind() {
        return kind.isMemberKind();
    }
    public List getRelations() {
        return relations;
    }
    public void setRelations(List relations) {
        if (relations.size() > 0) {
            this.relations = relations;
        }
    }
    public String getFormalComment() {
        return formalComment;
    }
    public String toString() {
        return super.name;
    }
    /**
 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
    public static final String NAME = "Reference";
    public static final Relation USES_POINTCUT_RELATION = new Relation("uses pointcut", "pointcut used by", NAME, true, true);
    public static final Relation IMPORTS_RELATION = new Relation("imports", NAME, false);
    //public static final Relation THROWS_RELATION = new Relation("throws", NAME, false);
    //public static final Relation USES_TYPE_RELATION = new Relation("uses type", NAME, false);
    private List relations = new ArrayList();
    public ReferenceAssociation() {
        relations.add(USES_POINTCUT_RELATION);
        relations.add(IMPORTS_RELATION);
        //relations.add(THROWS_RELATION);
        //relations.add(USES_TYPE_RELATION);
    }
    public List getRelations() {
        return relations;
    }
    public List getRelationNodes() {
        List relations = new ArrayList();
        List pointcutsUsed = new ArrayList();
        List pointcutUsedBy = new ArrayList();
        List throwsTypes = new ArrayList();
        List imports = new ArrayList();
        List usesType = new ArrayList();
        return relations;
    }
    public String getName() {
        return NAME;
    }
 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
    private String forwardNavigationName;
    private String backNavigationName;
    private String associationName;
    private boolean symmetrical;
    private boolean transitive;
    public Relation(String forwardNavigationName,
                    String backNavigationName,
                    String associationName,
                    boolean symmetrical,
                    boolean transitive) {
        this.forwardNavigationName = forwardNavigationName;
        this.backNavigationName = backNavigationName;
        this.associationName = associationName;
        this.symmetrical = symmetrical;
        this.transitive = transitive;
    }
    /**
     * Constructor for asymetrical relations.
     */
    public Relation(String forwardNavigationName,
                    String associationName,
                    boolean transitive) {
        this(forwardNavigationName, "<no back navigation name>", associationName, false, transitive);
    }
    public String getForwardNavigationName() {
        return forwardNavigationName;
    }
    public String getBackNavigationName() {
        return backNavigationName;
    }
    public String getAssociationName() {
        return associationName;
    }
    public boolean isSymmetrical() {
        return symmetrical;
    }
    public boolean isTransitive() {
        return transitive;
    }
    public String toString() {
        if (symmetrical) {
            return forwardNavigationName + " / " + backNavigationName;
        } else {
            return forwardNavigationName;
        }
    }
 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
    private Relation relation;
    /**
     * Used during de-externalization.
     */
    public RelationNode() { }
    public RelationNode(Relation relation, String name, List children) {
        super(name, relation.getAssociationName(), children);
        this.relation = relation;
    }
    public Relation getRelation() {
        return relation;
    }
    protected  StructureNode root = null;
    public static final ProgramElementNode NO_STRUCTURE = new ProgramElementNode("<build to view structure>", ProgramElementNode.Kind.ERROR, null);
    public StructureNode getRoot() {
======= fetch "public StructureNode getRoot() {" f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

    public void setRoot(StructureNode root) {
======= fetch "public boolean isValid() {" f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "public ProgramElementNode findNode(ProgramElementNode parent, ProgramElementNode" f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "public ProgramElementNode findNode(ProgramElementNode parent, ProgramElementNode" f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "public ProgramElementNode findNode(ProgramElementNode parent, ProgramElementNode" f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "public ProgramElementNode findNodeForClass(String packageName, String className)" f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "public ProgramElementNode findNodeForClass(String packageName, String className)" f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "public ProgramElementNode findNodeForClass(String packageName, String className)" f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "private ProgramElementNode findClassInNodes(Collection nodes, String name) {" f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "private ProgramElementNode findClassInNodes(Collection nodes, String name) {" f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "public StructureNode findRootNodeForSourceFile(String sourceFile) {" f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "public StructureNode findRootNodeForSourceFile(String sourceFile) {" f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "public StructureNode findNodeForSourceLine(String sourceFilePath, int lineNumber" f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "public StructureNode findNodeForSourceLine(String sourceFilePath, int lineNumber" f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "private StructureNode createFileStructureNode(String sourceFilePath) {" f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "private StructureNode createFileStructureNode(String sourceFilePath) {" f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "private StructureNode findNodeForSourceLineHelper(StructureNode node, String sou" f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "private StructureNode findNodeForSourceLineHelper(StructureNode node, String sou" f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "private boolean matches(StructureNode node, String sourceFilePath, int lineNumbe" f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "private boolean matches(StructureNode node, String sourceFilePath, int lineNumbe" f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "private boolean hasMoreSpecificChild(StructureNode node, String sourceFilePath," f1deb9c^:"asm/src/org/aspectj/asm/StructureModel.java"

 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * Compiler listeners get notified of structure model update events.
 *
 * @author Mik Kersten
 */
    public void modelUpdated(StructureModel rootNode);
======= fetch "protected StructureModelManager() {" f1deb9c^:"asm/src/org/aspectj/asm/StructureModelManager.java"

        associations.add(new AdviceAssociation());
        associations.add(new IntroductionAssociation());
        associations.add(new InheritanceAssociation());
        associations.add(new ReferenceAssociation());
======= fetch "public HashMap getInlineAnnotations(" f1deb9c^:"asm/src/org/aspectj/asm/StructureModelManager.java"

        if (!model.isValid()) return null;
        HashMap annotations = new HashMap();
        StructureNode node = model.findRootNodeForSourceFile(sourceFile);
        if (node == StructureModel.NO_STRUCTURE) {
            return null;
        } else {
            ProgramElementNode fileNode = (ProgramElementNode)node;
            ArrayList peNodes = new ArrayList();
            getAllStructureChildren(fileNode, peNodes, showSubMember, showMemberAndType);
            for (Iterator it = peNodes.iterator(); it.hasNext(); ) {
                ProgramElementNode peNode = (ProgramElementNode)it.next();
                List entries = new ArrayList();
                entries.add(peNode);
                ISourceLocation sourceLoc = peNode.getSourceLocation();
                if (null != sourceLoc) {
                    Integer hash = new Integer(sourceLoc.getLine());
                    List existingEntry = (List)annotations.get(hash);
                    if (existingEntry != null) {
                        entries.addAll(existingEntry);
                    }
                    annotations.put(hash, entries);
                }
            }
            return annotations;
        }
======= fetch "public HashMap getInlineAnnotations(" f1deb9c^:"asm/src/org/aspectj/asm/StructureModelManager.java"

    private void getAllStructureChildren(ProgramElementNode node, List result, boolean showSubMember, boolean showMemberAndType) {
        List children = node.getChildren();
        for (Iterator it = children.iterator(); it.hasNext(); ) {
            StructureNode next = (StructureNode)it.next();
            if (next instanceof ProgramElementNode) {
                ProgramElementNode pNode = (ProgramElementNode)next;
                if (pNode != null
                	&& ((pNode.isCode() && showSubMember) || (!pNode.isCode() && showMemberAndType))
                	&& pNode.getRelations() != null 
                	&& pNode.getRelations().size() > 0) {
                    result.add(next);
                }
                getAllStructureChildren((ProgramElementNode)next, result, showSubMember, showMemberAndType);
            }
        }
    }
======= fetch "private void getAllStructureChildren(ProgramElementNode node, List result, boole" f1deb9c^:"asm/src/org/aspectj/asm/StructureModelManager.java"

    public void addListener(StructureModelListener listener) {
======= fetch "public void addListener(StructureModelListener listener) {" f1deb9c^:"asm/src/org/aspectj/asm/StructureModelManager.java"

    public void removeStructureListener(StructureModelListener listener) {
======= fetch "private void notifyListeners() {" f1deb9c^:"asm/src/org/aspectj/asm/StructureModelManager.java"

            ((StructureModelListener)it.next()).modelUpdated(model);
 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * Children are non-repeating making the parent-child structure a strict
 * tree.
 * 
 * !!! relies on a java.io.Serializable implementation of ISourceLocation
 * 
 * @author Mik Kersten
 */
    protected String name = "";
    protected String kind = "";
    // children.listIterator() should support remove() operation
    protected List children = new ArrayList();
    protected IMessage message = null;
    protected ISourceLocation sourceLocation = null;
    /**
     * Used during serialization.
     */
    public StructureNode() { }
    public StructureNode(String name, String kind, List children) {
        this.name = name;
        this.kind = kind;
        if (children != null) {
        }
     	setParents();
    }
    public StructureNode(String name, String kind) {
        this.name = name;
        this.kind = kind;
    }
    public String toString() {
        return  name;
    }
    public String getKind() {
        return kind;
    }
    public List getChildren() {
        return children;
    }
    public void addChild(StructureNode child) {
        if (children == null) {
            children = new ArrayList();
        }
        children.add(child);
        child.setParent(this);
    }
    
    public void addChild(int position, StructureNode child) {
        if (children == null) {
            children = new ArrayList();
        }
        children.add(position, child);
        child.setParent(this);
    }
    
    public boolean removeChild(StructureNode child) {
    	child.setParent(null);
    	return children.remove(child);	
    }
    /**
     * Comparison is string-name based only.
     */
    public int compareTo(Object o) throws ClassCastException {
        if (this == o) {
            return 0;
        } else {
            StructureNode sn = (StructureNode)o;
            return this.getName().compareTo(sn.getName());
        }
    }
    public String getName() {
        return name;
    }
 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
    private static Hashtable programElementNodes = new Hashtable();
    
    private static final ProgramElementNode UNRESOLVED_LINK_NODE = new ProgramElementNode("<error: unresolved link>", ProgramElementNode.Kind.ERROR, null, null, "", "", "", null, null, null, false);
    public static void clear() {
        programElementNodes.clear();
    }
    public static ProgramElementNode makeNode(List relations, List children) {
        return makeNode(relations, children, false);
    }
    public static LinkNode makeLink(boolean terminal) {
        ProgramElementNode peNode = null;
        if (terminal) {
            peNode = makeNode(null, null, false);
        } else {
        	peNode = makeNode(null, null, true);
        }
        
        if (peNode == null) {
    		return new LinkNode(UNRESOLVED_LINK_NODE);
    	} else {
    		return new LinkNode(peNode);
    	}
    }
    private static ProgramElementNode makeNode(List relations, List children, boolean resolve) {
    }
======= fetch "public void finishedCompilationUnit(CompilationUnitDeclaration unit) {" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fetch "private void setupModel() {" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

        ProgramElementNode.Kind kind = ProgramElementNode.Kind.FILE_JAVA;
======= fetch "private void setupModel() {" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

            kind = ProgramElementNode.Kind.FILE_LST;  
======= fetch "private void setupModel() {" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

        model.setRoot(new ProgramElementNode(rootLabel, kind, new ArrayList()));
 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     PARC     initial implementation 
 * ******************************************************************/
    public static void build(
        CompilationUnitDeclaration unit,
        StructureModel structureModel) {
        LangUtil.throwIaxIfNull(unit, "unit");
          
        new AsmBuilder(unit.compilationResult()).internalBuild(unit, structureModel);
    }
    protected AsmBuilder(CompilationResult result) {
        LangUtil.throwIaxIfNull(result, "result");
        currCompilationResult = result;
        stack = new Stack();
    }
    /** 
     * Called only by 
     * build(CompilationUnitDeclaration unit, StructureModel structureModel) 
     */
    private void internalBuild(
        CompilationUnitDeclaration unit, 
        StructureModel structureModel) {
        LangUtil.throwIaxIfNull(structureModel, "structureModel");
        if (!currCompilationResult.equals(unit.compilationResult())) {
            throw new IllegalArgumentException("invalid unit: " + unit);
        }
        // ---- summary
        // add unit to package (or root if no package),
        // first removing any duplicate (XXX? removes children if 3 classes in same file?)
        // push the node on the stack
        // and traverse
        
        // -- create node to add
        final File file = new File(new String(unit.getFileName()));
        final ProgramElementNode cuNode;
        {
            // AMC - use the source start and end from the compilation unit decl
            int startLine = getStartLine(unit);
            int endLine = getEndLine(unit);     
            ISourceLocation sourceLocation 
                = new SourceLocation(file, startLine, endLine);
            cuNode = new ProgramElementNode(
                new String(file.getName()),
                ProgramElementNode.Kind.FILE_JAVA,
                sourceLocation,
                0,
                "",
                new ArrayList());
        }
        // -- get node (package or root) to add to
        final StructureNode addToNode;
        {
            ImportReference currentPackage = unit.currentPackage;
            if (null == currentPackage) {
                addToNode = structureModel.getRoot();
            } else {
                String pkgName;
                {
                    StringBuffer nameBuffer = new StringBuffer();
                    final char[][] importName = currentPackage.getImportName();
                    final int last = importName.length-1;
                    for (int i = 0; i < importName.length; i++) {
                        nameBuffer.append(new String(importName[i]));
                        if (i < last) {
                            nameBuffer.append('.');
                        } 
                    }
                    pkgName = nameBuffer.toString();
                }
            
                ProgramElementNode pkgNode = null;
                for (Iterator it = structureModel.getRoot().getChildren().iterator(); 
                    it.hasNext(); ) {
                    ProgramElementNode currNode = (ProgramElementNode)it.next();
                    if (pkgName.equals(currNode.getName())) {
                        pkgNode = currNode;
                        break; // any reason not to quit when found?
                    } 
                }
                if (pkgNode == null) {
                    // note packages themselves have no source location
                    pkgNode = new ProgramElementNode(
                        pkgName, 
                        ProgramElementNode.Kind.PACKAGE, 
                        new ArrayList());
                    structureModel.getRoot().addChild(pkgNode);
                }
                addToNode = pkgNode;
            }
        }
        
        // -- remove duplicates before adding (XXX use them instead?)
        for (ListIterator itt = addToNode.getChildren().listIterator(); itt.hasNext(); ) {
            ProgramElementNode child = (ProgramElementNode)itt.next();
            ISourceLocation childLoc = child.getSourceLocation();
            if (null == childLoc) {
                // XXX ok, packages have null source locations
                // signal others?
            } else if (childLoc.getSourceFile().equals(file)) {
                itt.remove();
            }
        }
        // -- add and traverse
        addToNode.addChild(cuNode);     
        stack.push(cuNode);
        unit.traverse(this, unit.scope);  
        
        // -- update file map (XXX do this before traversal?)
        try {
            structureModel.addToFileMap(file.getCanonicalPath(), cuNode);
        } catch (IOException e) { 
            System.err.println("IOException " + e.getMessage() 
                + " creating path for " + file );
            // XXX signal IOException when canonicalizing file path
        }
    }
  
======= fetch "public void genLabelAndKind(MethodDeclaration methodDeclaration, ProgramElementN" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java"

======= fetch "public void genLabelAndKind(MethodDeclaration methodDeclaration, ProgramElementN" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java"

======= fetch "public void genLabelAndKind(MethodDeclaration methodDeclaration, ProgramElementN" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java"

======= fetch "public void genLabelAndKind(MethodDeclaration methodDeclaration, ProgramElementN" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java"

======= fetch "public void genLabelAndKind(MethodDeclaration methodDeclaration, ProgramElementN" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java"

======= fetch "public void genLabelAndKind(MethodDeclaration methodDeclaration, ProgramElementN" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java"

======= fetch "public void genLabelAndKind(MethodDeclaration methodDeclaration, ProgramElementN" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java"

======= fetch "public void genLabelAndKind(MethodDeclaration methodDeclaration, ProgramElementN" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java"

======= fetch "public void genLabelAndKind(MethodDeclaration methodDeclaration, ProgramElementN" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java"

======= fetch "public void genLabelAndKind(MethodDeclaration methodDeclaration, ProgramElementN" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java"

======= fetch "public void genLabelAndKind(MethodDeclaration methodDeclaration, ProgramElementN" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java"

======= fetch "public void genLabelAndKind(MethodDeclaration methodDeclaration, ProgramElementN" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java"

======= fetch "public void genLabelAndKind(MethodDeclaration methodDeclaration, ProgramElementN" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java"

======= fetch "public void genLabelAndKind(MethodDeclaration methodDeclaration, ProgramElementN" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java"

======= fetch "public void externalizeModel() {" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java"

                ProgramElementNode peNode = (ProgramElementNode)((Map.Entry)it.next()).getValue();
======= fetch "public void externalizeModel() {" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java"

    private void dumpStructureToFile(ProgramElementNode node) throws IOException {
        String s = node.getKind();
        if (!  (s.equals(ProgramElementNode.Kind.FILE_ASPECTJ.toString())
                || s.equals(ProgramElementNode.Kind.FILE_JAVA.toString()))) {
======= fetch "public SExpressionPrinter(BufferedWriter writer) {" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java"

        private void printDecls(ProgramElementNode node) {
======= fetch "private void printDecls(ProgramElementNode node) {" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java"

                if (nodeObject instanceof ProgramElementNode) {
                    ProgramElementNode child = (ProgramElementNode)nodeObject;
======= fetch "private void printDecls(ProgramElementNode node) {" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java"

                } else if (nodeObject instanceof LinkNode) {
                    LinkNode child = (LinkNode)nodeObject;
                    printDecl(child.getProgramElementNode(), false);
                }
======= fetch "private void printDecls(ProgramElementNode node) {" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java"

        private void printDecls(RelationNode node) {
            for (Iterator it = node.getChildren().iterator(); it.hasNext(); ) {
======= fetch "private void printDecls(RelationNode node) {" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java"

                if (nodeObject instanceof LinkNode) {
                    LinkNode child = (LinkNode)nodeObject;
                    if (//!child.getProgramElementNode().getKind().equals("stmnt") &&
                        !child.getProgramElementNode().getKind().equals("<undefined>")) {
                        printDecl(child.getProgramElementNode(), false);
======= fetch "private void printDecls(RelationNode node) {" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java"

                    }
                }
======= fetch "private void printDecls(RelationNode node) {" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java"

        private void printDecl(ProgramElementNode node, boolean recurse) {
======= fetch "private void printDecl(ProgramElementNode node, boolean recurse) {" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java"

            String kind = node.getKind().toLowerCase();
======= fetch "private void printDecl(ProgramElementNode node, boolean recurse) {" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java"

                if (node instanceof ProgramElementNode) {
                    java.util.List relations = ((ProgramElementNode)node).getRelations();
======= fetch "private void printDecl(ProgramElementNode node, boolean recurse) {" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java"

                            RelationNode relNode = (RelationNode)it.next();
                            if (relNode.getRelation().getAssociationName().equals(AdviceAssociation.NAME) ||
                                relNode.getRelation().getAssociationName().equals(IntroductionAssociation.NAME)) {
======= fetch "private void printDecl(ProgramElementNode node, boolean recurse) {" f1deb9c^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java"

                        if (nodeObject instanceof ProgramElementNode) {
                            ProgramElementNode currNode = (ProgramElementNode)nodeObject;
======= fetch "public void testNullHandlingOfVisit() {" f1deb9c^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AsmBuilderTest.java"

======= fetch "protected AbstractIcon createIcon(String path) {" f1deb9c^:"testing/src/org/aspectj/testing/ajde/CompileCommand.java"

            protected StructureViewNode createConcreteNode(
                StructureNode node,
                AbstractIcon icon,
                List children) {
                return new SwingTreeViewNode(node, icon, children);
            }
======= fetch "public static void noteMunger(StructureModel model, Shadow shadow, ShadowMunger" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "public static void noteMunger(StructureModel model, Shadow shadow, ShadowMunger" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static void createAppropriateLinks(" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static void createAppropriateLinks(" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static void addLink(" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static void addLink(" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static void addLink(" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static void addLink(" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static void addLink(" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static void addLink(" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static ProgramElementNode getNode(StructureModel model, Advice a) {" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static ProgramElementNode getNode(StructureModel model, Shadow shadow) {" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static ProgramElementNode getNode(StructureModel model, Shadow shadow) {" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static ProgramElementNode getNode(StructureModel model, Shadow shadow) {" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static ProgramElementNode findOrCreateBodyNode(" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static ProgramElementNode findOrCreateBodyNode(" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static ProgramElementNode findOrCreateBodyNode(" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static ProgramElementNode findOrCreateBodyNode(" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "public static ProgramElementNode lookupMember(StructureModel model, Member membe" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "public static ProgramElementNode lookupMember(StructureModel model, Member membe" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static ProgramElementNode findMemberInClass(" f1deb9c^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"


======= fetch "private void weaveInterTypeDeclarations(SourceTypeBinding sourceType, Collection" 3e59745^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= fetch "private void doDeclareParents(DeclareParents declareParents, SourceTypeBinding s" 3e59745^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

    public interface MonitoredItem {}
    private void MonitoredItem.record(String eventType, String eventName) {}
======= fetch "private LazyMethodGen makeMethodGen(LazyClassGen gen, ResolvedMember member) {" 3e59745^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private LazyMethodGen makeMethodGen(LazyClassGen gen, ResolvedMember member) {" 3e59745^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

    private boolean isSynthetic = false;
    
======= fetch "public MethodGen pack() {" 3e59745^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        
        if (isSynthetic) {
        }
        
======= fetch "public MethodGen pack() {" 3e59745^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    
    public void makeSynthetic() {
    	isSynthetic = true;
    }    	

======= fetch "public String toString() {" 684c9c1^:"bridge/src/org/aspectj/bridge/IMessage.java"

    private final String details;
======= fetch "public Message(String message, ISourceLocation location, boolean isError) {" 684c9c1^:"bridge/src/org/aspectj/bridge/Message.java"

======= fetch "public Message(String message, IMessage.Kind kind, Throwable thrown," 684c9c1^:"bridge/src/org/aspectj/bridge/Message.java"

        this.details = "";
======= fetch "public static String render(Throwable thrown) { // XXX cf LangUtil.debugStr" 684c9c1^:"bridge/src/org/aspectj/bridge/Message.java"

    
======= fetch "public String toString() {" 684c9c1^:"testing/src/org/aspectj/testing/xml/SoftMessage.java"

    
======= fetch "public boolean match(Shadow shadow, World world) {" 684c9c1^:"weaver/src/org/aspectj/weaver/Checker.java"


 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
======= fetch "public Component getListCellRendererComponent(" acdf688^:"ajde/src/org/aspectj/ajde/ui/swing/CompilerMessagesCellRenderer.java"

                setIcon(null);
======= fetch "public static Test suite() {" acdf688^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/AjdtAjcTests.java"

        return suite;
======= fetch "public void testArgInConfigFile() throws InvalidInputException {" acdf688^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"


    public static void main(String[] args) {
        lib.Library.method();
    }
    public static void method() {
    }

======= fetch "public static AjBuildConfig genBuildConfig(String[] args, CountingMessageHandler" a26cac9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"

        String message = parser.getOtherMessages(true);
======= fetch "public static AjBuildConfig genBuildConfig(String[] args, CountingMessageHandler" a26cac9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"

======= fetch "public static AjBuildConfig genBuildConfig(String[] args, CountingMessageHandler" a26cac9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"

            IMessage m = new Message(message, kind, null, null);            
======= fetch "public static AjBuildConfig genBuildConfig(String[] args, CountingMessageHandler" a26cac9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"

        }
        message = config.configErrors();
        if (null != message) {
            IMessage.Kind kind = inferKind(message);
            IMessage m = new Message(message, kind, null, null);            
            handler.handleMessage(m);
        }
        
======= fetch "public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler) {" a26cac9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= fetch "public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler) {" a26cac9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

     * @param configFile	can be null
======= fetch "public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler) {" a26cac9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= fetch "public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler, bool" a26cac9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= fetch "public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler, bool" a26cac9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= fetch "public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler, bool" a26cac9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

                        || buildConfig.isIncrementalFileMode();
======= fetch "public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler, bool" a26cac9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= fetch "public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler, bool" a26cac9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= fetch "public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler, bool" a26cac9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= fetch "public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler, bool" a26cac9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= fetch "public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler, bool" a26cac9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= fetch "public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler, bool" a26cac9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

            MessageUtil.error(handler, iie.getMessage());
======= fetch "private void addClasspath(String classpath, List classpathCollector) {" a26cac9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

    // !!! extract error handling to be common so that the IDEs can use it
======= fetch "public void parseOption(String arg, LinkedList args) { // XXX use ListIterator.r" a26cac9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

                            showError("bad injar: " + filename);
======= fetch "public void showError(String message) {" a26cac9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

            MessageUtil.error(handler, CONFIG_MSG + message);
======= fetch "protected void showWarning(String message) {" a26cac9^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

            MessageUtil.warn(handler, message);

======= fetch "public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope scope" f5d31ba^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

======= fetch "private StructureNode findEnclosingClass(Stack stack) {" f5d31ba^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

======= fetch "public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {" f5d31ba^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"


======= fetch "public static void build(" 7886970^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

    private AsmBuilder(CompilationResult result) {
======= fetch "public boolean visit(LocalTypeDeclaration memberTypeDeclaration, BlockScope scop" 7886970^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

======= fetch "private ISourceLocation makeLocation(AstNode node) {" 7886970^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

======= fetch "public static Test suite() {" 7886970^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjdtBuilderTests.java"

 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     PARC     initial implementation 
 * ******************************************************************/
    public static Test suite() { 
        TestSuite suite = new TestSuite(AsmBuilderTest.class.getName());
        //$JUnit-BEGIN$
        suite.addTestSuite(AsmBuilderTest.class); 
        //$JUnit-END$
        return suite;
    }

  
    <ajc-test dir="bugs/bootstrapClasspath" pr="39959" 
            title="AJC Compiler generates invalid class files under certain circumstances."> 
        <compile files="UsesDOMParser.java" classpath="xerces.jar" /> 
        <run class="UsesDOMParser"/> 
    </ajc-test> 

======= fetch "public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {" 58e3cb2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

======= fetch "public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {" 58e3cb2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"


======= fetch "public static String setupAjc(AjcTask ajc, Javac javac, File destDir) {" 2502ee5^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

            if (null == destDir) {
                destDir = new File(".");
            }
======= fetch "public static String setupAjc(AjcTask ajc, Javac javac, File destDir) {" 2502ee5^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

        ajc.setDestdir(destDir);        
======= fetch "private static File isAspectjtoolsjar(String path) {" 2502ee5^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    private static final File DEFAULT_DESTDIR = new File(".");
======= fetch "private static File isAspectjtoolsjar(String path) {" 2502ee5^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

        
======= fetch "private static File isAspectjtoolsjar(String path) {" 2502ee5^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

        
======= fetch "private static File isAspectjtoolsjar(String path) {" 2502ee5^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    private ICommandEditor commandEditor;
======= fetch "public void setMessageHolderClass(String className) {" 2502ee5^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    
    /** direct API for testing */
    public void setCommandEditor(ICommandEditor editor) {
        this.commandEditor = editor;
    }
    
    /**
     * Setup command-line filter.
     * To do this staticly, define the environment variable
     * <code>org.aspectj.tools.ant.taskdefs.AjcTask.COMMAND_EDITOR</code>
     * with the <code>className</code> parameter.
     * @param className the String fully-qualified-name of a class
     *          reachable from this object's class loader,
     *          implementing ICommandEditor, and 
     *          having a public no-argument constructor.
     * @throws BuildException if unable to create instance of className
     */
    public void setCommandEditorClass(String className) { // skip Ant interface?
        try {
            Class mclass = Class.forName(className);
            setCommandEditor((ICommandEditor) mclass.newInstance());
        } catch (Throwable t) {
            String m = "unable to instantiate command editor: " + className;
            throw new BuildException(m, t);
        }
    }
======= fetch "public boolean quit() {" 2502ee5^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

        return (String[]) result.toArray(new String[0]);
======= fetch "protected void verifyOptions() {" 2502ee5^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

        StringBuffer sb = new StringBuffer();
======= fetch "protected void verifyOptions() {" 2502ee5^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

            String m = "can fork incremental only using tag file";
            throw new BuildException(m);
======= fetch "protected void verifyOptions() {" 2502ee5^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= fetch "private void completeDestdir() {" 2502ee5^:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

        } else if (!destDir.canWrite()) {
======= fetch "public void tearDown() {" 2502ee5^:"taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java"

    public void testNullDestDir() {
        AjcTask task = getTask(NOFILE, null);
        String[] cmd = task.makeCommand();
        
        for (int i = 0; i < cmd.length; i++) {
            assertTrue(!"-d".equals(cmd[i]));
        }
    }
    
    public void testOutputRequirement() {
        AjcTask task = getTask("default.lst");
        checkRun(task, null);
        task = getTask("default.lst", null);
        task.setCopyInjars(true);
        checkRun(task, "copyInjars");
        task = getTask("default.lst", null);
        task.setSourceRootCopyFilter("*.java");
        checkRun(task, "sourceRoot");
    }
    
    private void checkRun(AjcTask task, String exceptionString) {
        try {
            task.execute();
            assertTrue(null == exceptionString);
        } catch (BuildException e) {
            if(-1 == e.getMessage().indexOf(exceptionString)) {
                assertEquals(exceptionString, e.getMessage());
            }
        }
        
    }
    public void testCommandEditor() {
        String className = VerboseCommandEditor.class.getName();
        System.setProperty(AjcTask.COMMAND_EDITOR_NAME, className);
        assertEquals(className, 
            System.getProperty(AjcTask.COMMAND_EDITOR_NAME));
        AjcTask task = getTask(NOFILE);
        task.setCommandEditor(new VerboseCommandEditor());
        String[] cmd = task.makeCommand();
        assertEquals(VerboseCommandEditor.VERBOSE, cmd[0]);
        task = getTask(NOFILE);
        task.setCommandEditorClass(VerboseCommandEditor.class.getName());
        cmd = task.makeCommand();
        assertEquals(VerboseCommandEditor.VERBOSE, cmd[0]);
    }
======= fetch "protected AjcTask getTask(String input) {" 2502ee5^:"taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java"

        return getTask(input, getTempDir());
    }
    
    protected AjcTask getTask(String input, File destDir) {
======= fetch "protected AjcTask getTask(String input) {" 2502ee5^:"taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java"

        task.setDestdir(getTempDir());
======= fetch "protected AjcTask getTask(String input) {" 2502ee5^:"taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java"

        task.setVerbose(true); // XXX    
======= fetch "private void check(IMessageHolder holder, int num, IMessage.Kind kind) {" 2502ee5^:"taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java"

    public static final String VERBOSE = "-verbose";
    public String[] editCommand(String[] command) {
        for (int i = 0; i < command.length; i++) {
            if (VERBOSE.equals(command[i])) {
                return command;
            }
        }
        
        String[] result = new String[1+command.length];
        result[0] = VERBOSE;
        System.arraycopy(result, 1, command, 0, command.length);
        return result;
    }
    private static String[] NONE = new String[0];
    public static ICommandEditor VERBOSE = 
        new AppendingCommandEditor(new String[] {"-verbose"}, NONE);
    public static ICommandEditor INVALID = 
        new AppendingCommandEditor(NONE, new String[] {"-invalidOption"});
    final String[] prefix;
    final String[] suffix;
    public AppendingCommandEditor(String[] prefix, String[] suffix) {
        this.prefix = prefix;
        this.suffix = suffix;
    }
    public String[] editCommand(String[] command) {
        int len = command.length + prefix.length + suffix.length;
        String[] result = new String[len];
        System.arraycopy(result, 0, prefix, 0, prefix.length);
        System.arraycopy(result, prefix.length, command, 0, command.length);
        System.arraycopy(result, prefix.length + command.length, suffix, 0, suffix.length);
        return result;
    }

 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * Bare-bones editor implementation used when the framework is being used
 * standalone.
 *
 * @author Mik Kersten
 */
    private String filePath = NO_FILE;
    private JPanel editor_panel = new JPanel();
    // @todo    get rid of these
    private int currHighlightStart = 0;
    private int currHighlightEnd = 0;
    private BorderLayout borderLayout1 = new BorderLayout();
    private JScrollPane jScrollPane1 = new JScrollPane();
    private JEditorPane editorPane = new JEditorPane();
    public BasicEditor() {
        try {
            editorPane.setEditable(true);
            editorPane.setContentType("text/plain");
            editorPane.setFont(new Font("Monospaced", 0, 11));
            editor_panel.add(editorPane);
            jbInit();
        }
        catch(Exception e) {
            Ajde.getDefault().getErrorHandler().handleError("Could not initialize GUI.", e);
        }
    }
    public String getCurrFile() {
    }
    public void showSourceLine(ISourceLocation sourceLocation, boolean highlight) {
    public void showSourceLine(int lineNumber, boolean highlight) {
        showSourceLine(filePath, lineNumber, highlight);
    }
    public void pasteToCaretPos(String text) {
        if (currHighlightEnd < 1) return;
        String contents = editorPane.getText();
        String pasted = contents.substring(0, currHighlightEnd) +
            text + contents.substring(currHighlightEnd, contents.length());
        editorPane.setText(pasted);
    }
    public void showSourceLine(String filePath, int lineNumber, boolean highlight) {
    	//AjdeUIManager.getDefault().getIdeUIAdapter().resetEditor();
        
        String oldPath = this.filePath;
        this.filePath = filePath;
        currHighlightStart = 0;
        currHighlightEnd = 0;
        editorPane.setText(readFile(filePath, lineNumber));
        try {
            editorPane.getHighlighter().addHighlight(currHighlightStart, currHighlightEnd, DefaultHighlighter.DefaultPainter);
            editorPane.setCaretPosition(currHighlightStart);
        } catch (BadLocationException ble) {
            Ajde.getDefault().getErrorHandler().handleError("Could not highlight location.", ble);
        }
        BrowserManager.getDefault().getEditorManager().notifyCurrentFileChanged(filePath);
    }
    /**
     * Not implemented.
     */
    public void showSourcelineAnnotation(String filePath, int lineNumber, java.util.List items) { }
    public void saveContents() throws IOException {
        if (filePath != NO_FILE && filePath != "" && editorPane.getText() != "") {
            BufferedWriter writer = new BufferedWriter(new FileWriter(filePath));
            writer.write(editorPane.getText());
            writer.flush();
        }
    }
    public JPanel getPanel() {
        return editor_panel;
    }
    public void showSourceForFile(String filePath) { }
    public void showSourceForLine(int lineNumber, boolean highlight) { }
    public void showSourceForSourceLine(String filePath, int lineNumber, boolean highlight) { }
    public String getCurrSourceFilePath() { return null; }
    public void setBreakpointRequest(String filePath, int lineNumber, boolean isDeferred) { }
    public void clearBreakpointRequest(String filePath, int lineNumber) { }
    private String readFile(String filePath, int lineNumber) {
        try {
            URL url = ClassLoader.getSystemResource(filePath);
            File file = new File(filePath);
            if (!file.exists()) {
                return "ERROR: file \"" + filePath + "\" does not exist.";
            }
            BufferedReader reader = new BufferedReader(new FileReader(file));
            StringBuffer contents = new StringBuffer();
            String line = reader.readLine();
            int numChars = 0;
            int numLines = 0;
            while (line != null) {
                numLines++;
                if (numLines < lineNumber) {
                    currHighlightStart += line.length()+1;
                }
                if (numLines == lineNumber) {
                    currHighlightEnd = currHighlightStart + line.length();
                }
                contents.append(line);
                contents.append('\n');
                line = reader.readLine();
            }
            return contents.toString();
        } catch (IOException ioe) {
            return "ERROR: could not read file \"" + filePath + "\", make sure that you have mounted /project/aop on X:\\";
        }
    }
    private void jbInit() throws Exception {
        editor_panel.setFont(new java.awt.Font("DialogInput", 1, 12));
        editor_panel.setLayout(borderLayout1);
        editor_panel.add(jScrollPane1, BorderLayout.CENTER);
        jScrollPane1.getViewport().add(editorPane, null);
    }
======= fetch "public static BrowserManager getDefault() {" bbd832b^:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"

    
======= fetch "public void init(String[] configFilesArgs, boolean visible) {" bbd832b^:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"

======= fetch "public void init(String[] configFilesArgs, boolean visible) {" bbd832b^:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"

======= fetch "public void init(String[] configFilesArgs, boolean visible) {" bbd832b^:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"

======= fetch "public void init(String[] configFilesArgs, boolean visible) {" bbd832b^:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"

======= fetch "public void init(String[] configFilesArgs, boolean visible) {" bbd832b^:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"

======= fetch "public void saveAll() {" bbd832b^:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"

        Ajde.getDefault().getEditorManager().saveContents();
======= fetch "public void openFile(String filePath) {" bbd832b^:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"

======= fetch "public BrowserProperties getBrowserProjectProperties() {" bbd832b^:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"

 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
                        if (EditorManager.isShiftDown(e.getModifiers())) {
                            Ajde.getDefault().getBuildManager().buildFresh();
                        } else {
                            Ajde.getDefault().getBuildManager().build();
                        }
======= fetch "protected void displayMessage(IMessage message) {" bbd832b^:"ajbrowser/src/org/aspectj/tools/ajbrowser/CompilerMessagesPanel.java"

        Ajde.getDefault().getEditorManager().showSourceLine(loc, true);
======= fetch "void save_button_actionPerformed(ActionEvent e) {" bbd832b^:"ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java"

        Ajde.getDefault().getEditorManager().saveContents();
======= fetch "public void hideMessagesPanel() {" bbd832b^:"ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java"

    void emacsTest_button_actionPerformed(ActionEvent e) {
    }
======= fetch "void jMenuItem1_actionPerformed(ActionEvent e) {" bbd832b^:"ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java"

        Ajde.getDefault().getEditorManager().saveContents();
======= fetch "public static void init(" bbd832b^:"ajde/src/org/aspectj/ajde/Ajde.java"

======= fetch "public BuildManager getBuildManager() {" bbd832b^:"ajde/src/org/aspectj/ajde/Ajde.java"

======= fetch "public StructureModelManager getStructureModelManager() {" bbd832b^:"ajde/src/org/aspectj/ajde/Ajde.java"

======= fetch "public void compileFinished(String buildConfig, int buildTime, boolean succeeded" bbd832b^:"ajde/src/org/aspectj/ajde/Ajde.java"

======= fetch "public void setErrorHandler(ErrorHandler errorHandler) {" bbd832b^:"ajde/src/org/aspectj/ajde/Ajde.java"

 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * Responsible for controlling the editor.
 *
 * @todo    remove coupling to <CODE>BasicEditor</CODE>
 * @author  Mik Kersten
 */
    /** @return true if input modifiers have shift down */
    public static boolean isShiftDown(int modifiers) {
        return (0 != (modifiers & KeyEvent.SHIFT_MASK));
    }
    private EditorAdapter editor = null;
    private BasicEditor basicEditor = null;
    private ArrayList editorListeners = new ArrayList();
    private Vector editors = new Vector();
    private JPanel editor_panel = null;
    private Box editors_box = Box.createVerticalBox();
    public EditorManager(EditorAdapter ajdeEditor) {
    	if (ajdeEditor instanceof BasicEditor) {
    	} else {
        	editors.add(ajdeEditor);
        	this.editor = ajdeEditor;   		
    	}
    }
    public void addListener(EditorListener editorListener) {
        editorListeners.add(editorListener);
    }
    public void removeListener(EditorListener editorListener) {
        editorListeners.remove(editorListener);
    }
    public void notifyCurrentFileChanged(String filePath) {
        for (Iterator it = editorListeners.iterator(); it.hasNext(); ) {
            ((EditorListener)it.next()).currentFileChanged(filePath);
        }
    }
    public void addViewForSourceLine(final String filePath, final int lineNumber) {
        if (basicEditor == null) return;
        editors_box.remove(basicEditor.getPanel());
        final BasicEditor newEditor = new BasicEditor();
        editors.add(newEditor);
        
        Runnable update = new Runnable() {
            public void run() {
                editors_box.add(newEditor.getPanel());
                newEditor.showSourceLine(filePath, lineNumber, true);
                //AjdeUIManager.getDefault().getIdeUIAdapter().resetGUI();
            }
        };
        if (SwingUtilities.isEventDispatchThread()) {
            update.run(); 
        } else {
            try {
                SwingUtilities.invokeAndWait(update);
            } catch (Exception e) {
                Ajde.getDefault().getErrorHandler().handleError("Could not add view for source line.", e);
            }
        }
    }
    public String getCurrFile() {
    	if (basicEditor != null) {
    		return basicEditor.getCurrFile();
    	} else {
    	}
    }
    /**
     * @todo    remove "instanceof AjdeManager" hack
     */
    public void showSourceLine(String filePath, int lineNumber, boolean highlight) {
        if (editors.size() > 1) {
            editors_box.removeAll();
            editors_box.add(basicEditor.getPanel());
            //AjdeUIManager.getDefault().getIdeUIAdapter().resetGUI();
            editors.removeAllElements();
            editors.add(basicEditor);
        } 
        
        if (basicEditor != null) {
        	basicEditor.showSourceLine(filePath, lineNumber, highlight);
        } else {
        	editor.showSourceLine(filePath, lineNumber, highlight);
        }
    }
    public void pasteToCaretPos(String text) {
        if (basicEditor != null) {
        	basicEditor.pasteToCaretPos(text);
        } else {
        	editor.pasteToCaretPos(text);
        }    	
    }
    public void showSourcelineAnnotation(String filePath, int lineNumber, java.util.List items) {
        editor.showSourcelineAnnotation(filePath, lineNumber, items);
    }
    public void saveContents() {
        try {
            for (Iterator it = editors.iterator(); it.hasNext(); ) {
                ((EditorAdapter)it.next()).saveContents();
            }
        } catch (IOException ioe) {
            Ajde.getDefault().getErrorHandler().handleError("Editor could not save the current file.", ioe);
        }
    }
    public JPanel getEditorPanel() {
        if (editor_panel != null) {
            return editor_panel;
        } else {
            return basicEditor.getPanel();
        }
    }
======= fetch "public static Map getLinesToAspectMap(String sourceFilePath) {" bbd832b^:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= fetch "public void modelUpdated(StructureModel model) {" bbd832b^:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

        	
        	if (defaultFileView != null) {
        		defaultFileView.setSourceFile(Ajde.getDefault().getEditorManager().getCurrFile());
        	}
======= fetch "public StructureViewManager(StructureViewNodeFactory nodeFactory) {" bbd832b^:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= fetch "private void navigationAction(ProgramElementNode node, boolean recordHistory) {" bbd832b^:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= fetch "public FileStructureView createViewForSourceFile(String sourceFilePath, Structur" bbd832b^:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= fetch "public void setDefaultFileView(FileStructureView defaultFileView) {" bbd832b^:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= fetch "public void setDefaultFileView(FileStructureView defaultFileView) {" bbd832b^:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= fetch "public void init(" bbd832b^:"ajde/src/org/aspectj/ajde/ui/swing/AjdeUIManager.java"

======= fetch "public void init(" bbd832b^:"ajde/src/org/aspectj/ajde/ui/swing/AjdeUIManager.java"

======= fetch "public TreeViewBuildConfigEditor getBuildConfigEditor() {" bbd832b^:"ajde/src/org/aspectj/ajde/ui/swing/AjdeUIManager.java"

 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * Bare-bones editor implementation used when the framework is being used
 * standalone.
 *
 * @author Mik Kersten
 */
    private String filePath = NO_FILE;
    private JPanel editor_panel = new JPanel();
    // @todo    get rid of these
    private int currHighlightStart = 0;
    private int currHighlightEnd = 0;
    private BorderLayout borderLayout1 = new BorderLayout();
    private JScrollPane jScrollPane1 = new JScrollPane();
    private JEditorPane editorPane = new JEditorPane();
    public BasicEditor() {
        try {
            editorPane.setEditable(true);
            editorPane.setContentType("text/plain");
            editorPane.setFont(new Font("Monospaced", 0, 11));
            editor_panel.add(editorPane);
            jbInit();
        }
        catch(Exception e) {
            Ajde.getDefault().getErrorHandler().handleError("Could not initialize GUI.", e);
        }
    }
    public String getCurrFile() {
    }
    public void showSourceLine(ISourceLocation sourceLocation, boolean highlight) {
    public void showSourceLine(int lineNumber, boolean highlight) {
        showSourceLine(filePath, lineNumber, highlight);
    }
    public void pasteToCaretPos(String text) {
        if (currHighlightEnd < 1) return;
        String contents = editorPane.getText();
        String pasted = contents.substring(0, currHighlightEnd) +
            text + contents.substring(currHighlightEnd, contents.length());
        editorPane.setText(pasted);
    }
    public void showSourceLine(String filePath, int lineNumber, boolean highlight) {
    	//AjdeUIManager.getDefault().getIdeUIAdapter().resetEditor();
        
        String oldPath = this.filePath;
        this.filePath = filePath;
        currHighlightStart = 0;
        currHighlightEnd = 0;
        editorPane.setText(readFile(filePath, lineNumber));
        try {
            editorPane.getHighlighter().addHighlight(currHighlightStart, currHighlightEnd, DefaultHighlighter.DefaultPainter);
            editorPane.setCaretPosition(currHighlightStart);
        } catch (BadLocationException ble) {
            Ajde.getDefault().getErrorHandler().handleError("Could not highlight location.", ble);
        }
        Ajde.getDefault().getEditorManager().notifyCurrentFileChanged(filePath);
    }
    /**
     * Not implemented.
     */
    public void showSourcelineAnnotation(String filePath, int lineNumber, java.util.List items) { }
    public void saveContents() throws IOException {
        if (filePath != NO_FILE && filePath != "" && editorPane.getText() != "") {
            BufferedWriter writer = new BufferedWriter(new FileWriter(filePath));
            writer.write(editorPane.getText());
            writer.flush();
        }
    }
    public JPanel getPanel() {
        return editor_panel;
    }
    public void showSourceForFile(String filePath) { }
    public void showSourceForLine(int lineNumber, boolean highlight) { }
    public void showSourceForSourceLine(String filePath, int lineNumber, boolean highlight) { }
    public String getCurrSourceFilePath() { return null; }
    public void setBreakpointRequest(String filePath, int lineNumber, boolean isDeferred) { }
    public void clearBreakpointRequest(String filePath, int lineNumber) { }
    private String readFile(String filePath, int lineNumber) {
        try {
            URL url = ClassLoader.getSystemResource(filePath);
            File file = new File(filePath);
            if (!file.exists()) {
                return "ERROR: file \"" + filePath + "\" does not exist.";
            }
            BufferedReader reader = new BufferedReader(new FileReader(file));
            StringBuffer contents = new StringBuffer();
            String line = reader.readLine();
            int numChars = 0;
            int numLines = 0;
            while (line != null) {
                numLines++;
                if (numLines < lineNumber) {
                    currHighlightStart += line.length()+1;
                }
                if (numLines == lineNumber) {
                    currHighlightEnd = currHighlightStart + line.length();
                }
                contents.append(line);
                contents.append('\n');
                line = reader.readLine();
            }
            return contents.toString();
        } catch (IOException ioe) {
            return "ERROR: could not read file \"" + filePath + "\", make sure that you have mounted /project/aop on X:\\";
        }
    }
    private void jbInit() throws Exception {
        editor_panel.setFont(new java.awt.Font("DialogInput", 1, 12));
        editor_panel.setLayout(borderLayout1);
        editor_panel.add(jScrollPane1, BorderLayout.CENTER);
        jScrollPane1.getViewport().add(editorPane, null);
    }
======= fetch "public StructureViewPanel getBrowserPanel() {" bbd832b^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewManager.java"

    public void showSourcesNodes(java.util.List nodes) {
        for (Iterator it = nodes.iterator(); it.hasNext(); ) {
            ProgramElementNode currNode = null;
            StructureNode structureNode = (StructureNode)it.next();
            if (structureNode instanceof LinkNode) {
                currNode = ((LinkNode)structureNode).getProgramElementNode();
            } else {
                currNode = (ProgramElementNode)structureNode;
            }
            ISourceLocation sourceLoc = currNode.getSourceLocation();
            if (null != sourceLoc) {
                Ajde.getDefault().getEditorManager().addViewForSourceLine(
                    sourceLoc.getSourceFile().getAbsolutePath(),
                    sourceLoc.getLine());
            }
        }
    }
======= fetch "public void actionPerformed(ActionEvent e) {" bbd832b^:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java"

 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
                        if (EditorManager.isShiftDown(e.getModifiers())) {
                            Ajde.getDefault().getBuildManager().buildFresh();
                        } else {
                            Ajde.getDefault().getBuildManager().build();
                        }
======= fetch "public PointcutWizard(java.util.List signatures) {" bbd832b^:"ajde/src/org/aspectj/ajde/ui/swing/PointcutWizard.java"

        typeTreeView.updateTree(Ajde.getDefault().getEditorManager().getCurrFile());
        try {
            jbInit();
        }
        catch(Exception e) {
            Ajde.getDefault().getErrorHandler().handleError("Could not initialize GUI.", e);
        }
        this.setSize(400, 400);
        this.setIconImage(((ImageIcon)AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(ProgramElementNode.Kind.POINTCUT)).getImage());
======= fetch "private void ok_button_actionPerformed(ActionEvent e) {" bbd832b^:"ajde/src/org/aspectj/ajde/ui/swing/PointcutWizard.java"

        Ajde.getDefault().getEditorManager().pasteToCaretPos(generatePcd());
        this.dispose();
======= fetch "public void setActiveNode(StructureViewNode node, int lineOffset) {" bbd832b^:"ajde/src/org/aspectj/ajde/ui/swing/StructureViewPanel.java"

    public static Test suite() { 
======= fetch "public void init(String testProjectPath) {" bbd832b^:"ajde/testsrc/org/aspectj/ajde/NullIdeManager.java"

======= fetch "public void init(String testProjectPath) {" bbd832b^:"ajde/testsrc/org/aspectj/ajde/NullIdeManager.java"


======= fetch "public AjBuildConfig genBuildConfig(String configFile) {" d5ea336^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

        AjBuildConfig local = AjdtCommand.genBuildConfig(args, counter);
======= fetch "public AjBuildConfig genBuildConfig(String configFile) {" d5ea336^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

        }
======= fetch "protected boolean doCommand(IMessageHandler handler, boolean repeat) {" d5ea336^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"

======= fetch "public static AjBuildConfig genBuildConfig(String[] args, CountingMessageHandler" d5ea336^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"

        if (null != message) {
======= fetch "public BuildArgParser() {" d5ea336^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

    
======= fetch "public BuildArgParser() {" d5ea336^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

     * @param setClasspath	determines if the classpath should be parsed and set on the build configuration
======= fetch "public BuildArgParser() {" d5ea336^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= fetch "public AjBuildConfig genBuildConfig(String[] args, IMessageHandler handler) {" d5ea336^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"


 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     PARC     initial implementation 
 * ******************************************************************/
 * Walks the body of inter-type declarations and replaces SuperReference with InterSuperReference
 * 
 * @author Jim Hugunin
 */
 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     PARC     initial implementation 
 * ******************************************************************/
 * Used to represent super references inside of inter-type declarations.  Special mechanism
 * needed for handling in an interface context.
 * 
 * @author Jim Hugunin
 */
======= fetch "public void resolve(ClassScope upperScope) {" 026b272^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeDeclaration.java"

======= fetch "public void resolve(ClassScope upperScope) {" 026b272^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeDeclaration.java"

    
    <ajc-test dir="bugs" pr="39993"
   	 title="ajc stack trace on declaring hashcode() method in aspect">
        <compile files="OverridingInterfaceObjectMethod.java"/>
        <run class="OverridingInterfaceObjectMethod"/>
    </ajc-test>
    <ajc-test dir="bugs"
   	 title="using super in method introduced on interface with multiple supertypes">
        <compile files="MultipleSuperCf.java">
        	<message kind="error" line="14"/>
        </compile>
    </ajc-test>
 
       return this.id;
    }
 
======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" 026b272^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" 026b272^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private boolean mungeNewMethod(BcelClassWeaver weaver, NewMethodTypeMunger munge" 026b272^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private static LazyMethodGen makeDispatcher(" 026b272^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private static LazyMethodGen makeDispatcher(" 026b272^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= fetch "private static LazyMethodGen makeDispatcher(" 026b272^:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"


======= fetch "public void endVisit(MessageSend send, BlockScope scope) {" ba41fae^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "public void endVisit(AllocationExpression send, BlockScope scope) {" ba41fae^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "public void endVisit(" ba41fae^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "public void endVisit(" ba41fae^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "private void makePublic(TypeBinding binding) {" ba41fae^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "public void endVisit(AssertStatement assertStatement, BlockScope scope) {" ba41fae^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= fetch "public void resolveStatements() {" ba41fae^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AdviceDeclaration.java"

======= fetch "public MethodBinding getPrivilegedAccessMethod(MethodBinding baseMethod, AstNode" ba41fae^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/PrivilegedHandler.java"

======= fetch "public MethodBinding getPrivilegedAccessMethod(MethodBinding baseMethod, AstNode" ba41fae^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/PrivilegedHandler.java"

======= fetch "public MethodBinding getPrivilegedAccessMethod(MethodBinding baseMethod, AstNode" ba41fae^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/PrivilegedHandler.java"

    
    <ajc-test dir="bugs" pr="39458"
   	 title="Compiler crash in ajc 1.1 - terrible error for inaccessible constructor">
        <compile files="NewVoid.java">
            <message kind="error" line="17"/>        
            <message kind="error" line="20"/>        
            <message kind="error" line="21"/>
                  
            <message kind="error" line="28"/>        
            <message kind="warning" line="29"/>        
            <message kind="warning" line="30"/>            
        </compile>
    </ajc-test>
    
    <ajc-test dir="bugs" pr="39460"
   	 title="Missing import crashes compiler">
        <compile files="MissingImport.java">
            <message kind="error" line="13"/>       
        </compile>
    </ajc-test>
    

======= fetch "public void outputClassFiles(CompilationResult unitResult) {" c509c6f^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void outputClassFiles(CompilationResult unitResult) {" c509c6f^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

    public static void main(String[] args) {
    	Runnable r = new Runnable() {
    		public void run() {}
    	};
    	r.run();
    }
======= fetch "public void testMissingRuntimeError() {" c509c6f^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BasicCommandTestCase.java"


    
    <ajc-test dir="bugs" pr="37739"
   	 title="Unexpected Xlint:unresolvableMember warning with withincode">
        <compile files="CatchSig.java">
        </compile>
        <run class="CatchSig"/>
    </ajc-test>
 * Bugzilla Bug 37739  
   Unexpected Xlint:unresolvableMember warning with withincode 
 */
======= fetch "public BcelVar getThisEnclosingJoinPointStaticPartBcelVar() {" 2072ac1^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    //??? need to better understand all the enclosing variants
======= fetch "public Member getEnclosingCodeSignature() {" 2072ac1^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    	if (enclosingShadow == null) {
======= fetch "public Member getEnclosingCodeSignature() {" 2072ac1^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    	} else if (enclosingShadow == null) {
    		return getEnclosingMethod().getMemberView();

    <ajc-test dir="new/binaryWarnings/src" pr="37020"
   	 title="declare warnings on main">
        <compile files="aspects/MainWarnings.java,app/Main.java">
        	<message kind="warning" file="app/Main.java"
        	  line="6" text="set(String Main.staticString)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="8" text="set(String Main.s)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="12" text="get(String Main.staticString)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="14" text="set(String Main.staticString)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="16" text="call(Main.new())"/>
        	<message kind="warning" file="app/Main.java"
        	  line="19" text="call(void Main.go(String))"/>
        	<message kind="warning" file="app/Main.java"
        	  line="23" text="execution(Main.new())"/>
        	<message kind="warning" file="app/Main.java"
        	  line="26" text="execution(void Main.go(String))"/>
        	<message kind="warning" file="app/Main.java"
        	  line="29" text="get(String Main.s)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="31" text="set(String Main.s)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="33" text="handler(RuntimeException)"/>        	  
        	<message kind="warning" file="app/Main.java"
        	  line="35" text="withincode(void Main.go(String))"/>
        	<message kind="warning" file="app/Main.java"
        	  line="42" text="withincode(void Main.stop())"/>
        	<message kind="warning" file="app/Main.java"
        	  line="50" text="preinitialization(app.C.new())"/>
        </compile>
        
        <run class="app.Main"/>
    </ajc-test>
    <ajc-test dir="new/binaryWarnings/src"  pr="37020"
   	title="declare warnings on binary javac 1.4 classes">
        <compile files="aspects/MainWarnings.java,../injars/app-javac-1.4.jar">
        	<message kind="warning" file="app/Main.java"
        	  line="6" text="set(String Main.staticString)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="8" text="set(String Main.s)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="12" text="get(String Main.staticString)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="14" text="set(String Main.staticString)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="16" text="call(Main.new())"/>
        	<message kind="warning" file="app/Main.java"
        	  line="19" text="call(void Main.go(String))"/>
        	<message kind="warning" file="app/Main.java"
        	  line="23" text="execution(Main.new())"/>
        	<message kind="warning" file="app/Main.java"
        	  line="26" text="execution(void Main.go(String))"/>
        	<message kind="warning" file="app/Main.java"
        	  line="29" text="get(String Main.s)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="31" text="set(String Main.s)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="33" text="handler(RuntimeException)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="35" text="withincode(void Main.go(String))"/>
        	<message kind="warning" file="app/Main.java"
        	  line="42" text="withincode(void Main.stop())"/>
        	<message kind="warning" file="app/Main.java"
        	  line="50" text="preinitialization(app.C.new())"/>
        </compile>
        <run class="app.Main"/>
    </ajc-test>
   <ajc-test dir="new/binaryWarnings/src" pr="37023"
   	title="declare warnings on binary ajc 1.1 classes">
        <compile files="aspects/MainWarnings.java,../injars/app-ajc-1.1.jar">
        	<message kind="warning" file="app/Main.java"
        	  line="6" text="set(String Main.staticString)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="8" text="set(String Main.s)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="12" text="get(String Main.staticString)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="14" text="set(String Main.staticString)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="16" text="call(Main.new())"/>
        	<message kind="warning" file="app/Main.java"
        	  line="19" text="call(void Main.go(String))"/>
        	<message kind="warning" file="app/Main.java"
        	  line="23" text="execution(Main.new())"/>
        	<message kind="warning" file="app/Main.java"
        	  line="26" text="execution(void Main.go(String))"/>
        	<message kind="warning" file="app/Main.java"
        	  line="29" text="get(String Main.s)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="31" text="set(String Main.s)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="33" text="handler(RuntimeException)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="35" text="withincode(void Main.go(String))"/>
        	<message kind="warning" file="app/Main.java"
        	  line="42" text="withincode(void Main.stop())"/>
        	<message kind="warning" file="app/Main.java"
        	  line="50" text="preinitialization(app.C.new())"/>
        	  
        </compile>
        <run class="app.Main"/>
    </ajc-test>
  - source-only 
  - binary (javac) application, source aspect
  - binary (ajc) application, source aspect
  - binary (javac) application, binary aspect (todo)
  - binary (ajc) application, binary aspect   (todo)
  warning line values in the test specifications
  warning text values in the test specifications
  should resolve to unique lines 
  (until we verify based on more than line)
  
  as each other as as specified in MainWarnings.java
  mkdir classes
  javac -d  classes app/Main.java
  jar cfM ../injars/app-javac-1.4.jar -C classes .
  rm -rf classes
  ajc -classpath ../../../lib/test/aspectjrt.jar  \
    -outjar ../injars/app-ajc-1.1.jar app/Main.java
  {ajc} -classpath ../lib/test/aspectjrt.jar  
    -outjar ../tests/new/binaryWarnings/injars/app-ajc-1.1.jar  
    ../test/new/binnaryWarnings/src/app/Main.java
    static String staticString = "hello";
    
    String s = "me";
    
    public static void main(String[] args) {
        String temp = staticString;        // 12
        staticString = temp + " world!";   // 14
        Main main = new Main();            // 16
        for (int i = 0; i < args.length; i++) {
            main.go(args[i]);              // 19
        }
    }
    Main() {                // 23
    }
    void go(String s) {     // 26
        try {
            String temp = this.s;  // 29
            this.s = temp + ", " + s;  // 31
        } catch (RuntimeException e) {   // 33
            
            stop();                      // 35 
        }
    }
    void stop() {                        // 40
        new Main();                      // 42
    }
    C() {                               // 50
    }
    declare warning : staticinitialization(Main)
        : "staticinitializtion(Main)";
        
    declare warning : initialization(Main.new())
        : "initialization(Main.new())";
    declare warning : execution(Main.new())
        : "execution(Main.new())";
    declare warning : execution(void Main.go(String))
        : "execution(void Main.go(String))";
    declare warning : call(Main.new())
        : "call(Main.new())";
    declare warning : call(void Main.go(String))
        : "call(void Main.go(String))";
    declare warning : call(Main.new())
        && withincode(void Main.stop())
        : "call(Main.new()) && withincode(void Main.stop())";
    declare warning : call(void Main.stop())
    && withincode(void Main.go(String))
        : "call(void Main.stop()) && withincode(void Main.go(String))";
    declare warning : get(String Main.s)
        : "get(String Main.s)";
    declare warning : set(String Main.s)
        : "set(String Main.s)";
    declare warning : get(String Main.staticString)
        : "get(String Main.staticString)";
    declare warning : set(String Main.staticString)
        : "set(String Main.staticString)";
    declare warning : handler(RuntimeException)
        && within(Main)
        : "handler(RuntimeException) && within(Main)";
    declare warning : preinitialization(app.C.new())
        : "preinitialization(app.C.new())";
    

   <ajc-test dir="new/options11"  pr="36329"
   	  comment="the line number might change, we're really interested only in the files here"
      title="The compiler crashes when using aspect libraries created without using -noweave">
        <compile files="Main.java,injar.jar,Aspect.java,aspectlib1.jar,aspectlib2.jar">
            <message kind="error" line="0"/>
        </compile>
   </ajc-test>
   
    <ajc-test dir="bugs" title="lame error message: negation doesn't allow binding"
      pr="30663">
        <compile files="BadBindingError.java">
            <message kind="error" line="7"/>
        </compile>
    </ajc-test>
    
    <ajc-test dir="bugs/interSpecials" pr="36936"
      title="Error when introducing members of type Class">
        <compile files="Trg.java,Asp.java"/>
        <run class="Trg"/>
    </ajc-test>
  pointcut p(int i): call(void f(i));
    <ajc-test dir="options/injars/simple" 
      title="options -injars">
        <compile files="Simple.java,main.jar"
        	options="!eclipse"/>
        <run class="Main"/>
    </ajc-test>
======= fetch "public boolean weave() {" 7d14432^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        	throw new RuntimeException("already woven: " + clazz);
======= fetch "public final FuzzyBoolean matches(ResolvedTypeX type, MatchKind kind) {" 7d14432^:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= fetch "public TypePattern resolveBindings(IScope scope, Bindings bindings," 7d14432^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= fetch "public TypePattern resolveBindings(IScope scope, Bindings bindings," 7d14432^:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"



======= fetch "private void initBcelWorld(IMessageHandler handler) throws IOException {" f236927^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= fetch "public void testXlintError() {" f236927^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BasicCommandTestCase.java"


    
======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" 1e502f5^:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

======= fetch "public Pointcut concretize(ResolvedTypeX inAspect, IntMap bindings) {" 1e502f5^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= fetch "public Pointcut concretize1(" 1e502f5^:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" 1e502f5^:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" 1e502f5^:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"


    <ajc-test dir="bugs" pr="29665"
      title="Inconsistant stack height with around">
        <compile files="StackError.java"/>
        <run class="StackError"/>
    </ajc-test>
    
      title="Ajc 1.1 rc1 java.lang.VerifyError with messy arounds">
        <compile files="aspects/Trace.aj,cap/OptionList.java,DebugTrace.aj">
            <message kind="warning" line="102"/>
        	<message kind="warning" line="124"/>
        	<message kind="warning" line="138"/>
        </compile>
        <run class="cap.OptionList"/>
    </ajc-test>  
    
 
 */
                                 
    declare precedence: DebugTrace, *;
    
    //private static Logger _log = null;
    
    static
    {
        //String log4jPath = GlobalPaths.getPath("properties_dir")+"log4j.properties";
        //PropertyConfigurator.configure(log4jPath);
        //_log = Logger.getLogger(TestLog.class);    
    }
        
    /** define the pointcut for what we trace */
    protected pointcut lexicalScope() :within(cap.OptionList);
        
    protected void log(String data)
    {
        System.err.println("data: " + data);
        //_log.debug(data);        
    }  
    
 * 
 */
    // our internal instance
    private static Trace _trace;
    
    // Call depth on trace
    private static final ThreadLocal traceDepths = new ThreadLocal();
    // An object to synchronize on
    protected static final Object  lock = new Object();
    private static final String NL = System.getProperty("line.separator");
    
    // Space indentation increment
    private static final int INDENT = 4;
    // Used for indentation
    private static final byte[] SPACES = new byte[100];
    
    private static boolean traceActive = true;
    static
    {
        Arrays.fill(SPACES,(byte)' ');
    }
       
    /** Trace constructor. Since this aspect is a singleton, we can be
     * assured that only a single instance exists.  
     */
    protected Trace() {_trace = this;}
    
    /**
    * This abstract pointcut indicates what classes we should trace.  Typically
    * you will define this using a within() PCD. We leave that up to concrete aspects.
    */
    protected abstract pointcut lexicalScope();
    
    /**
     * Common scope for all traces - includes lexicalScope
     */
    final pointcut scope() : if(_trace != null && _trace.canTraceJoinpoint(thisJoinPoint)) && lexicalScope() && !within(Trace+);
    /**
     * This pointcut designates tracing constructors within lexicalScope()
     */
    protected final pointcut constructorTrace() : scope() && (call( new(..) ) || execution( new(..)));
    /**
     * This pointcut designates tracing method executions within lexicalScope()
     */
    protected final pointcut methodTrace() : scope() && (call(* *(..)) || execution(* *(..)));
    /**
     * This pointcut designates tracing exception handlers within lexicalScope()
     */
    protected final pointcut handlerTrace(Exception e) : scope() &&  args(e) && handler(Exception+);
    /**
     * This pointcut picks out joinpoints within this aspect that implement
     * the actual tracing.  Since parameters and return values are printed
     * out via implicit or explicit call to Object.toString(), there is the possibility
     * of an execution joinpoint on toString() causing the trace logic
     * to be re-entered. This is undesireable because it makes the trace output
     * difficult to read and adds unecessary overhead. <p>
     * This pointcut is used within a cflowbelow pointcut to prevent recursive
     * trace calls.
     */
    private pointcut internalMethods() : 
        execution( void Trace.trace*(..,(JoinPoint||JoinPoint.StaticPart),..) );
    /**
     * For methods, we use around() advice to capture calls/executions.
     */
    Object around() : methodTrace() && !cflowbelow(internalMethods())
    {
        traceEnter(thisJoinPoint); 
        try
        {
            Object result = proceed();
            traceResult(result,thisJoinPoint);
            return result;
        }
        finally
        {
            traceExit(thisJoinPoint);
        }
    }
    
    /**
     * For Constructors, we use around() advice to capture calls/executions.
     */
    Object around() : constructorTrace() && !cflowbelow(internalMethods())
    {
        traceEnter(thisJoinPoint); 
        try
        {
            return proceed();
        }
        finally
        {
            traceExit(thisJoinPoint);
        }
    }
    
    /**
     * Trace Exceptions that may occur with constructors or methods
     */
    after() throwing(Throwable e): (constructorTrace() || methodTrace()) && !cflowbelow(internalMethods())
    {   
        traceThrowable(e,thisJoinPoint);
    }
    /**
     * Trace Exception handlers entry
     */    
    before(Exception e) : handlerTrace(e) && !cflowbelow(internalMethods())
    {
        traceHandlerEntry(e,thisJoinPointStaticPart);
    }
    /**
     * Trace Exception handlers exit
     */
    after(Exception e) : handlerTrace(e) && !cflowbelow(internalMethods())
    {
        traceHandlerExit();
    }
    /**
     * Subaspects can override this method to log the data as needed. The default
     * mechanism is to log to System.out
     * 
     * Clients should be aware that this method is not synchronized.
     */
    protected void log(String data) {System.out.println(data);}
    
    /**
     * Can be overridden by subaspects to filter what constructors/methods should be 
     * traced at runtime.  This method is always called prior to the log()
     * method. The default always returns true.<p> Note that exceptions thrown
     * by constructors/methods are filtered through this method.
     * @param currentlyExecutingClass The Class that is currently executing.
     * @param signature The signature of the member being traced
     * @param traceType The type of trace entry (see AspectJ doc for the available types)
     */
    protected boolean isTraceable(Class currentlyExecutingClass, CodeSignature signature,String traceType) {return true;}
    /**
     * Can be overridden by subaspects to filter what exception handlers should be 
     * traced at runtime.  This method is always called prior to the log()
     * method. The default always returns false.<p>
     * Note that exception handlers are catch(...){} blocks and are filtered
     * independently from constructor/method calls and execution.
     * @param currentlyExecutingClass The Class that is currently executing.
     * @param signature The signature of the member being traced
     */
    protected boolean isTraceable(Class currentlyExecutingClass, CatchClauseSignature signature) {return false;}
    
    /**
     * Retrieves the signature of the joinpoint and asks if it can be traced
     */
    private boolean canTraceJoinpoint(JoinPoint jp)
    {
        if ( !traceActive ) return false;
        final Signature sig = jp.getSignature();
        final Object o = jp.getThis();  // current object
        Class currentType;
        if ( o == null ) // must be a static
            currentType = jp.getStaticPart().getSourceLocation().getWithinType();
        else
            currentType = o.getClass();
            
        // dispatch the correct filter method
        if ( sig instanceof CodeSignature )            
            return isTraceable(currentType,(CodeSignature)sig,jp.getKind());
        else
            return isTraceable(currentType,(CatchClauseSignature)sig);            
    }
    
    /**
     * This method creates a trace entry line based on information in the
     * supplied join point.
     */
    private void traceEnter(JoinPoint thisJoinPoint)
    { 
   
        // Get the indent level (call depth for current thread * 4).
        int depth = getTraceDepth(INDENT);
    
        Class[] parameterTypes = ((CodeSignature)thisJoinPoint.getSignature()).getParameterTypes();
        String[] parameterNames = ((CodeSignature)thisJoinPoint.getSignature()).getParameterNames();
    
        boolean isCall = thisJoinPoint.getKind().endsWith("call");
        StringBuffer enterPhrase = new StringBuffer(100);
        enterPhrase.append(getSpaces(depth));
        if ( isCall )
            enterPhrase.append("Call ");
        else
            enterPhrase.append("Entering ");
        enterPhrase.append(methodSignature(parameterNames,parameterTypes,thisJoinPoint));
        
        // Prepare the methods parameter list
        String parmStr = null;
        Object[] parameters = thisJoinPoint.getArgs();
        if (parameters.length > 0)
        {
            String spaces = getSpaces(depth + 6);
            StringBuffer parms = new StringBuffer();
            for (int i = 0; i < parameters.length; i++)
            {
                if (parameters[i] != null && parameters[i].getClass().isArray())
                {
                    // arrays can be huge...limit to first 100 elements
                    final int len = Math.min(Array.getLength(parameters[i]),100);
                    if ( len == 0 )
                    {
                        parms.append(spaces);
                        parms.append(parameterNames[i]);
                        parms.append(": 0 length array");
                        parms.append(NL);
                    }
                    else
                    {
                        Object o = null;
                        for ( int x = 0; x < len; x++ )
                        {
                            parms.append(spaces);
                            parms.append(parameterNames[i]);
                            parms.append("[");
                            parms.append(x);
                            parms.append("]:");
                            o = Array.get(parameters[i],x);
                            try{parms.append(" " + (o != null?o:"null"));}  // implicit toString()
                            catch(Throwable t) {parms.append(" " + parameters[i]);}
                            parms.append(NL);                            
                        }
                    }
                }
                else
                {
                    // Not an array.
                    parms.append(spaces);
                    parms.append(parameterNames[i]);
                    parms.append(": ");
                    try
                    {
                        parms.append("" + parameters[i]);
                    }
                    catch (Throwable t ) {parms.append("" + parameters[i].getClass().getName());}
                }
                parmStr = parms.toString();
            }
        }
        if (parmStr != null)
            enterPhrase.append(NL).append(parmStr);
        log(enterPhrase.toString());
    }
    /**
     * This method creates an exception handler trace entry based on a Throwable
     * and information contained in the join point.
     */
    private void traceHandlerEntry(Throwable t, JoinPoint.StaticPart thisJoinPoint)
    {
        int depth = getTraceDepth(INDENT);
        String phrase = getSpaces(depth) +
                        "Exception caught at: " +
                        thisJoinPoint;
        log(printStackTrace(phrase,t));
    }
    /**
     * This method simply adjusts the trace depth - no other information printed.
     */
    private void traceHandlerExit()
    {
        getTraceDepth(-INDENT);
    }
    /**
     * This method creates a stack trace entry based on a Throwable and
     * information contained in the join point.
     */
    private void traceThrowable(Throwable t, JoinPoint thisJoinPoint)
    {
        int depth = getTraceDepth(0);
        String phrase = getSpaces(depth+4) +
                                        "Throwing Exception at: " +
                                        thisJoinPoint;
        log(printStackTrace(phrase,t));
    }
    private String printStackTrace(String phrase, Throwable t)
      {
    try {
      StringWriter sw = new StringWriter(4096);
      PrintWriter  pw = new PrintWriter(sw,true);
      pw.println(phrase);
      pw.println();
      pw.println("Exception Stack Trace:");
      pw.println();
      t.printStackTrace(pw);
      pw.println();
      pw.flush();
      sw.flush();
      pw.close();
      sw.close();
      return sw.toString();
    }
    catch(IOException IOE) {
      log(IOE.toString());
      return IOE.getMessage();
    }
      }
    /**
     * This method creates a trace exit entry based on the join point
     * information.
     */
    private void traceExit(JoinPoint thisJoinPoint)
    {
        int depth = getTraceDepth(-INDENT);
        // Assemble the method's signature.
        Class[] parameterTypes = ((CodeSignature)thisJoinPoint.getSignature()).getParameterTypes();
        String[] parameterNames = ((CodeSignature)thisJoinPoint.getSignature()).getParameterNames();
        boolean isCall = thisJoinPoint.getKind().endsWith("call");
        StringBuffer exitPhrase = new StringBuffer(100);
        exitPhrase.append(getSpaces(depth));
        if ( isCall )
            exitPhrase.append("Return ");
        else
            exitPhrase.append("Exiting ");
        exitPhrase.append(methodSignature(parameterNames,parameterTypes,thisJoinPoint)).append(NL);
        
        log(exitPhrase.toString());
    }
    /**
     * This method creates a trace result entry based on a result and the
     * join point.
     */
    private void traceResult(Object thisResult, JoinPoint thisJoinPoint)
    {
        Class returnType = ((MethodSignature)thisJoinPoint.getSignature()).getReturnType();
        if ( returnType.toString().equals("void") )
            return;
        int depth = getTraceDepth(0);
        if ( thisResult == null )
            thisResult = "null";
        if ( thisResult.getClass().isArray() )
        {
            // arrays can be Oprah-sized - limit to 100 elements
            final int len = Math.min(Array.getLength(thisResult),100);
            StringBuffer buf = new StringBuffer();
            if ( len == 0 )
                buf.append(">>>zero-length array<<<");
            else
            {
                Object o;
                for ( int i = 0; i < len; i++ )
                {
                    o = Array.get(thisResult,i);
                    buf.append("data[").append(i).append("] ");
                    try{buf.append(o != null?o:"null");} // implicit toString() 
                    catch(Throwable t) {buf.append(thisResult);}
                    buf.append(NL);
                }
            }
            thisResult = buf.toString();                
        }
        thisResult = thisResult.toString();
        
        StringBuffer returnPhrase = new StringBuffer(100);
        returnPhrase.append(getSpaces(depth+2)).append(thisJoinPoint);
        returnPhrase.append(" returned >>>>>>> ").append(thisResult);
        log(returnPhrase.toString());
    }
    /**
     * This method returns the current trace line indentation for the
     * thread.
     */
    private int getTraceDepth(int incr)
    {
            int rc = 0;
            Integer depth = (Integer) traceDepths.get();
            if (depth == null)
            {
                if ( incr > 0 )
                {
                    traceDepths.set(new Integer(incr));
                    return incr;
                }
                else return rc;
            }    
            
            rc = depth.intValue();
                            
            if ( incr > 0 )
            {
                depth = new Integer(rc += incr);            
                traceDepths.set(depth);
            }
            else if ( incr < 0 )
            {
                depth = new Integer(rc + incr);            
                traceDepths.set(depth);
            }
            
            return rc;
    }
    /**
     * This method returns a String containing the number of spaces desired to
     * be used as padding for formatting trace log entries.
     */
    private String getSpaces(int num)
    {
        return new String(SPACES,0,Math.min(num,SPACES.length));
    }
    /**
     * Create a method signature
     */
    private String methodSignature(String[] parameterNames,
                    Class[] parameterTypes,
                    JoinPoint thisJoinPoint)
    {
        // Assemble the method's signature.
        StringBuffer signature = new StringBuffer("(");
        for (int i = 0; i < parameterTypes.length; i++)
        {
            signature.append(parameterTypes[i].getName());
            signature.append(" ");
            signature.append(parameterNames[i]);
            if (i < (parameterTypes.length-1))
                signature.append(", ");
        }
        signature.append(")");
        return thisJoinPoint.getSignature().getDeclaringType().getName() + "." +
            thisJoinPoint.getSignature().getName() +
            signature;
    }
    
 * This class builds a list of &lt;option&gt; HTML elements given a data object,
 * typically a GAPI output object, and a list of accessor method names.  
 * <p>
 * <b>Usage:</b><pre>
 *   // Create the bank account list select
 *   RBBankAcctList2Input acctIn = new RBBankAcctList2Input();
 *   initApiHeader(acctIn.getHeader(),sessInfo);
 *   ArrayList accts = new ArrayList();
 *   getBankAccounts(acctIn,accts);
 *   
 *   String ol = OptionList.createListHtmlFromApi(accts.toArray(),
 *                                   new String[]{"getBankAcctNbr","getBankRtgNbr","getBankAcctTyp"},
 *                                   new String[]{"getBankAcctNbr"},
 *                                   new MessageFormat("{0}"),
 *                                   Integer.parseInt(acctIndex));
 * 
 * </pre>
 * @author Rich Price
 */
    
    
                        
            
    
    
    <ajc-test dir="bugs" pr="29665"
      title="Inconsistant stack height with around">
        <compile files="StackError.java"/>
        <run class="StackError"/>
    </ajc-test>
    
      title="Ajc 1.1 rc1 java.lang.VerifyError with messy arounds">
        <compile files="aspects/Trace.aj,cap/OptionList.java,DebugTrace.aj">
            <message kind="warning" line="102"/>
        	<message kind="warning" line="124"/>
        	<message kind="warning" line="138"/>
        </compile>
        <run class="cap.OptionList"/>
    </ajc-test>  
  
======= fetch "public void weaveAroundInline(" 6c9118b^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    private boolean hasExceptionHandlers;
======= fetch "private void unpackHandlers(MethodGen gen) {" 6c9118b^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

            if (len > 0) hasExceptionHandlers = true;
======= fetch "public void setCanInline(boolean canInline) {" 6c9118b^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"


======= fetch "boolean canTreatAsStatic(String id) {" 0a8dbde^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java"

    <ajc-test dir="new" pr="559"
      title="subclass advice not run for join points selected by superclass cflow-based pointcuts"
      keywords="from-resolved_10rc3">
        <compile files="PR559.java"/>
        <run class="PR559"/>
    </ajc-test>

    <ajc-test dir="bugs/interInherit" pr="35725"
      title="Inter type declaration to base class not seen by derived class">
        <compile files="a_impl/AImpl.java,a_impl/Af.java,a_intf/A.java,b_impl/BImpl.java,b_intf/B.java"/>
        <run class="b_impl.BImpl"/>
    </ajc-test>
    
  implements A
  public A AImpl.f()
  {
  }
  A f();
  extends AImpl
  implements B
  public B g()
  {
  }
  
  public static void main(String[] args) {
  	new BImpl().g();
  	new BImpl().f();
  }
  extends A
  B g();

    <ajc-test dir="new" title="new around construct"
      keywords="from-resolved_10x">
        <compile files="AroundAdvice.java"/>
        <run class="AroundAdvice"/>
    </ajc-test>
======= fetch "private boolean alreadyDefined(LazyClassGen clazz, LazyMethodGen mg) {" 808bae8^:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= fetch "public List getMethodGens() {" 808bae8^:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

        return Collections.unmodifiableList(methodGens);
======= fetch "static int getLineNumber(" 808bae8^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    public boolean isStatic() {
        return Modifier.isStatic(getAccessFlags());
    }

======= fetch "public static Test suite() {" 989aaf7^:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

 *     Xerox/PARC     initial implementation 
======= fetch "public void init(String testProjectPath) {" 989aaf7^:"ajde/testsrc/org/aspectj/ajde/NullIdeManager.java"

======= fetch "public void init(String testProjectPath) {" 989aaf7^:"ajde/testsrc/org/aspectj/ajde/NullIdeManager.java"

======= fetch "public void addSourcelineTask(String message, ISourceLocation sourceLocation, IM" 989aaf7^:"ajde/testsrc/org/aspectj/ajde/NullIdeTaskListManager.java"

    	sourceLineTasks.add(new SourceLineTask(message,sourceLocation,kind));
======= fetch "public void clearTasks() {" 989aaf7^:"ajde/testsrc/org/aspectj/ajde/NullIdeTaskListManager.java"

    	sourceLineTasks = new ArrayList();
======= fetch "public void clearTasks() {" 989aaf7^:"ajde/testsrc/org/aspectj/ajde/NullIdeTaskListManager.java"

    

======= fetch "public EclipseShadow(EclipseFactory world, Kind kind, Member signature, AstNode" 56cc4f2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"

======= fetch "public TypeX getEnclosingType() {" 56cc4f2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"

======= fetch "public Member getEnclosingCodeSignature() {" 56cc4f2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"

======= fetch "public static EclipseShadow makeShadow(EclipseFactory world, AstNode astNode," 56cc4f2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"

======= fetch "public static EclipseShadow makeShadow(EclipseFactory world, AstNode astNode," 56cc4f2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"

======= fetch "public static EclipseShadow makeShadow(EclipseFactory world, AstNode astNode," 56cc4f2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"

======= fetch "public static EclipseShadow makeShadow(EclipseFactory world, AstNode astNode," 56cc4f2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"

======= fetch "public static EclipseShadow makeShadow(EclipseFactory world, AstNode astNode," 56cc4f2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"

======= fetch "public static EclipseShadow makeShadow(EclipseFactory world, AstNode astNode," 56cc4f2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"

======= fetch "public void unhandledException(" 56cc4f2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= fetch "public void unhandledException(" 56cc4f2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= fetch "public void unhandledException(" 56cc4f2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= fetch "public void unhandledException(" 56cc4f2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

    <ajc-test dir="bugs" pr="34925"
      title="declare soft and throw statements">
        <compile files="ConvertToUnchecked.java"/>
        <run class="ConvertToUnchecked"/>
    </ajc-test>
    
   compiler crash on yesterday's rc1 build 
 */
    // convert IOExceptions in Foo to PersistenceException
    pointcut module() : within(Foo);
  
    declare soft: (IOException): module();
  public PersistenceException(Throwable cause) {
    super(cause);
  }

    
    <ajc-test dir="bugs" pr="34858"
      title="cflow binding issues with ignoring state">
        <compile files="CflowBinding.java"/>
        <run class="CflowBinding"/>
    </ajc-test>
    <ajc-test dir="bugs" pr="34858"
      title="cflow binding -- original weaver crash">
        <compile files="CflowBindingOrig.java"/>
        <run class="CflowBindingOrig"/>
    </ajc-test>
 * Almost an exact duplicate of the reported issue
 */
    static aspect MockProcessing {
        pointcut testFlow(final Thread thread) : 
            cflow(execution(void run()) && this(thread) && within(Thread)); //  the within is an optimization
        Object around() :
                call(* DummyConfiguration.createRootApplicationModule(..)) &&  testFlow(Thread)
        {
            return null;
        }
    }
    void foo() {
        DummyConfiguration.createRootApplicationModule();
    }
    static Object createRootApplicationModule() {
        return null;
    }
    <ajc-test dir="errors"  
    		title="type not imported in around advice">
        <compile files="TypeNotImportedInAroundCE.java">
        	<message kind="error" line="10"/>
        </compile>
    <ajc-test dir="errors"  
    		title="type not imported in aspect">
        <compile files="TypeInAspectNotImportedCE.java">
        	<message kind="error" line="6"/>
        </compile>
======= fetch "public Pointcut concretize1(ResolvedTypeX inAspect, IntMap bindings) {" 7746fcb^:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"


 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     PARC     initial implementation 
 * ******************************************************************/
 *     PARC     initial implementation 
======= fetch "public EclipseTypeMunger makeEclipseTypeMunger(ConcreteTypeMunger concrete) {" db37189^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

    
    
    // added this to cover Bugzilla Bug 34820  
    //     ajc -aspectpath fails with NPE for cflow pointcuts 
    int counter = 0;
    before(): cflow(within(client..*)) && call(* println(..)) {
        counter ++;
    }

    
    <ajc-test dir="new" pr="29934"
      title="can't apply around advice to the execution of around advice"
      keywords="from-resolved_10x">
        <compile files="CflowCycles.java"/>
        <run class="CflowCycles"/>
    </ajc-test>
======= fetch "public void weaveAroundInline(" 0fb5f69^:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"


======= fetch "public void visit(Instanceof i) {" ae0ef30^:"weaver/src/org/aspectj/weaver/bcel/BcelRenderer.java"

            Utility.createInstanceof(fact, (ObjectType) world.makeBcelType(i.getType())));
======= fetch "public static Instruction createInvoke(" ae0ef30^:"weaver/src/org/aspectj/weaver/bcel/Utility.java"

    public static Instruction createInstanceof(InstructionFactory fact, ObjectType t) {
        return new INSTANCEOF(fact.getConstantPool().addClass(t));        
======= fetch "public static Instruction createInstanceof(InstructionFactory fact, ObjectType t" ae0ef30^:"weaver/src/org/aspectj/weaver/bcel/Utility.java"


======= fetch "public TypeX lookupType(String name, IHasPosition location) {" 0a175d2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseScope.java"

======= fetch "public TypeX lookupType(String name, IHasPosition location) {" 0a175d2^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseScope.java"

    
======= fetch "aspect Aspect pertarget(target(EachObjectTarget)) {" 0a175d2^:"tests/new/EachObjectInDeepPackage.java"

  	EachObjectTarget t = null;

    <ajc-test dir="bugs" pr="33948" 
    		title="default constructor inter-type declaration">
        <compile files="ConstructorDeclaration.java"/>
        <run class="ConstructorDeclaration"/>
    </ajc-test>
    public static void main(String[] args) {
        Tester.expectEvent("create");
        new ConstructorDeclaration();
        Tester.checkAllEvents();
    }
    ConstructorDeclaration.new() {
        Tester.event("create");
    }

    <ajc-test dir="bugs" pr="33635" 
    		title="Negation of if pointcut does not work">
        <compile files="NotIf.java"/>
        <run class="NotIf"/>
    </ajc-test>
    
======= fetch "public static String protectedDispatchMethod(TypeX classType, String name)" d1e5c0a^:"weaver/src/org/aspectj/weaver/NameMangler.java"

======= fetch "private static String makeVisibilityName(int modifiers, TypeX aspectType) {" d1e5c0a^:"weaver/src/org/aspectj/weaver/NameMangler.java"

======= fetch "public List getInterTypeMungers() {" d1e5c0a^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

    /**
     * Returns a ResolvedTypeX object representing the declaring type of this type, or
     * null if this type does not represent a non-package-level-type.
     * 
     * <strong>Warning</strong>:  This is guaranteed to work for all member types.
     * For anonymous/local types, the only guarantee is given in JLS 13.1, where
     * it guarantees that if you call getDeclaringType() repeatedly, you will eventually
     * get the top-level class, but it does not say anything about classes in between.
     *
     * @return the declaring TypeX object, or null.
     */
    public ResolvedTypeX getDeclaringType() {
    	if (isArray()) return null;
    }
======= fetch "public static boolean isVisible(int modifiers, ResolvedTypeX targetType, Resolve" d1e5c0a^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= fetch "public final boolean isArray() {" d1e5c0a^:"weaver/src/org/aspectj/weaver/TypeX.java"

    
======= fetch "public final boolean isArray() {" d1e5c0a^:"weaver/src/org/aspectj/weaver/TypeX.java"

     * Returns a TypeX object representing the declaring type of this type, or
     * null if this type does not represent a non-package-level-type.
======= fetch "public final boolean isArray() {" d1e5c0a^:"weaver/src/org/aspectj/weaver/TypeX.java"

     * <strong>Warning</strong>:  This is guaranteed to work for all member types.
     * For anonymous/local types, the only guarantee is given in JLS 13.1, where
     * it guarantees that if you call getDeclaringType() repeatedly, you will eventually
     * get the top-level class, but it does not say anything about classes in between.
     *
     * @return the declaring TypeX object, or null.
======= fetch "public final boolean isArray() {" d1e5c0a^:"weaver/src/org/aspectj/weaver/TypeX.java"

    public TypeX getDeclaringType() {
    	if (isArray()) return null;
        	return TypeX.forName(name.substring(0, lastDollar));
======= fetch "public TypeX getDeclaringType() {" d1e5c0a^:"weaver/src/org/aspectj/weaver/TypeX.java"

======= fetch "public FuzzyBoolean match(Shadow shadow) {" d1e5c0a^:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= fetch "public FuzzyBoolean match(Shadow shadow) {" d1e5c0a^:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= fetch "public void testNameAndSigWithInners() {" d1e5c0a^:"weaver/testsrc/org/aspectj/weaver/TypeXTestCase.java"

    	assertEquals(t.getDeclaringType(), TypeX.forName("java.util.Map"));
    	assertNull(TypeX.forName("java.util.Map").getDeclaringType());

    public static void main(String[] args) {
    }
    <ajc-test dir="bugs" pr="33635" 
    		title="Negation of if pointcut does not work">
        <compile files="NotIf.java"/>
        <run class="NotIf"/>
    </ajc-test>
    
    
======= fetch "public String toString() {" cb77524^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "public Test findResidue(Shadow shadow, ExposedState state) {" cb77524^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "public Test findResidue(Shadow shadow, ExposedState state) {" cb77524^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "public Test findResidue(Shadow shadow, ExposedState state) {" cb77524^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fetch "public Test findResidue(Shadow shadow, ExposedState state) {" cb77524^:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"


    
    <ajc-test dir="bugs" pr="30026" 
    		title="problems with finalize call">
        <compile files="Finalizer.java">
            <message kind="error" line="22"/>
        </compile>
    </ajc-test>
    public static void main(String args[]) {
        Finalizer np = new Finalizer();
        np = null;
    }
    public void finalize() throws Throwable {
    }
    pointcut finalizeCall(Object o):
        this(Object+) &&
        this(o) &&
        execution(void finalize());
    void around(Object o) throws Throwable: finalizeCall(o) {
        o.finalize();               // error
        //((Finalizer) o).finalize();   // ok
        proceed(o);
    }

    <ajc-test dir="bugs" pr="31423" 
    		title="Pointcut adviceexecution() does not work">
        <compile files="AdviceExec.java"/>
        <run class="AdviceExec"/>
    </ajc-test>
    public static void main(String[] args) {
    	Tester.checkEqual(Aspect1.ran, 2, "Aspect1 ran");
    	Tester.checkEqual(Aspect2.ran, 2, "Aspect2 ran");
    }
    before() : execution(* AdviceExec.*(..)) {
    }
    
    void around(): execution(* AdviceExec.*(..)) {
    	ran++;
    	proceed();
    }
    before() : adviceexecution() && !within(Aspect2) {
    }
======= fetch "public FuzzyBoolean match(Shadow shadow) {" 19c3e16^:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

======= fetch "public boolean matches(Member member, World world) {" 19c3e16^:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"


======= fetch "public void computeJoinPointParams() {" d15eb32^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java"

======= fetch "public void computeJoinPointParams() {" d15eb32^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java"

======= fetch "boolean isRef(NameReference ref, Binding binding) {" d15eb32^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java"

======= fetch "boolean isRef(Expression expr, Binding binding) {" d15eb32^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java"

======= fetch "public void endVisit(SingleNameReference ref, BlockScope scope) {" d15eb32^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java"

======= fetch "public void endVisit(SingleNameReference ref, BlockScope scope) {" d15eb32^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java"

======= fetch "public void endVisit(SingleNameReference ref, BlockScope scope) {" d15eb32^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java"

======= fetch "public void endVisit(SingleNameReference ref, BlockScope scope) {" d15eb32^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java"

======= fetch "public void endVisit(SingleNameReference ref, BlockScope scope) {" d15eb32^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java"

======= fetch "private void replaceEffectivelyStaticRef(MessageSend call) {" d15eb32^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java"

======= fetch "private void replaceEffectivelyStaticRef(MessageSend call) {" d15eb32^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java"

======= fetch "private void replaceEffectivelyStaticRef(MessageSend call) {" d15eb32^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java"

    
    <ajc-test dir="bugs" pr="29959"
            title="super call in intertype method declaration body causes VerifyError">
        <compile files="SuperToIntro.java"/>
        <run class="SuperToIntro"/>
    </ajc-test>

======= fetch "private MethodDeclaration makePreMethod(ClassScope scope," 3e2801a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeConstructorDeclaration.java"

======= fetch "private AjAttribute makeAttribute(EclipseWorld world) {" 3e2801a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeConstructorDeclaration.java"

======= fetch "public void endVisit(MessageSend call, BlockScope scope) {" 3e2801a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/SuperFixerVisitor.java"

======= fetch "public InterTypeMethodBinding(EclipseWorld world, ResolvedMember signature, Type" 3e2801a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMethodBinding.java"

======= fetch "public InterTypeMethodBinding(EclipseWorld world, ResolvedMember signature, Type" 3e2801a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMethodBinding.java"

======= fetch "public InterTypeMethodBinding(EclipseWorld world, ResolvedMember signature, Type" 3e2801a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMethodBinding.java"

======= fetch "public boolean canBeSeenBy(TypeBinding receiverType, InvocationSite invocationSi" 3e2801a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMethodBinding.java"

======= fetch "public void manageSyntheticAccessIfNecessary(BlockScope currentScope) {" 3e2801a^:"org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java"

======= fetch "public void manageSyntheticAccessIfNecessary(BlockScope currentScope) {" 3e2801a^:"org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java"

======= fetch "public void manageSyntheticAccessIfNecessary(BlockScope currentScope){" 3e2801a^:"org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java"

======= fetch "public final int sourceStart() {" 3e2801a^:"org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java"

    <ajc-test dir="bugs" pr="29691"
    		title="Static inner aspects cannot reference user defined pointcuts">
        <compile files="PcdLookup.java" />
        <run class="PcdLookup"/>
    </ajc-test>
    <ajc-test dir="new"
      title="work nicely with inner class method look-up rules and call-site advice"
      keywords="from-resolved_10x">
        <compile files="InnerMethods.java"/>
        <run class="InnerMethods"/>
    </ajc-test>

 * 	   AMC 01.20.2003 extended for new AspectJ 1.1 project options
======= fetch "public void setAjcWorkingDir(String path) {" 85a827a^:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserProperties.java"

 *     Xerox/PARC     initial implementation 
 *     Xerox/PARC     initial implementation 
======= fetch "public void run() {" 85a827a^:"ajde/src/org/aspectj/ajde/internal/AspectJBuildManager.java"

  		// AMC - updated for AspectJ 1.1 options
======= fetch "private String getFormattedOptionsString(BuildOptionsAdapter buildOptions, Proje" 85a827a^:"ajde/src/org/aspectj/ajde/internal/AspectJBuildManager.java"

======= fetch "private String getFormattedOptionsString(BuildOptionsAdapter buildOptions, Proje" 85a827a^:"ajde/src/org/aspectj/ajde/internal/AspectJBuildManager.java"

 *     Xerox/PARC     initial implementation 
======= fetch "public AjBuildConfig genBuildConfig(String configFile) {" 85a827a^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= fetch "public AjBuildConfig genBuildConfig(String configFile) {" 85a827a^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= fetch "public AjBuildConfig genBuildConfig(String configFile) {" 85a827a^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= fetch "public AjBuildConfig genBuildConfig(String configFile) {" 85a827a^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= fetch "public AjBuildConfig genBuildConfig(String configFile) {" 85a827a^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= fetch "public AjBuildConfig genBuildConfig(String configFile) {" 85a827a^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= fetch "public AjBuildConfig genBuildConfig(String configFile) {" 85a827a^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= fetch "public AjBuildConfig genBuildConfig(String configFile) {" 85a827a^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= fetch "public AjBuildConfig genBuildConfig(String configFile) {" 85a827a^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= fetch "public AjBuildConfig genBuildConfig(String configFile) {" 85a827a^:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

 *     AMC 01.20.2003 extended to support AspectJ 1.1 options,
 * 					  bugzilla #29769
======= fetch "public AjcBuildOptions(UserPreferencesAdapter userPreferencesAdapter) {" 85a827a^:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

======= fetch "public boolean getUseJavacMode() {" 85a827a^:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

======= fetch "public void setUseJavacMode(boolean value) {" 85a827a^:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

======= fetch "public String getWorkingOutputPath() {" 85a827a^:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

======= fetch "public void setWorkingDir(String path) {" 85a827a^:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

======= fetch "public boolean getPreprocessMode() {" 85a827a^:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

======= fetch "public void setCharacterEncoding(String value) {" 85a827a^:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

======= fetch "public boolean getSourceOnePointFourMode() {" 85a827a^:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

======= fetch "public void setSourceOnePointFourMode(boolean value) {" 85a827a^:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

======= fetch "public boolean getLenientSpecMode() {" 85a827a^:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

======= fetch "public void setLenientSpecMode(boolean value) {" 85a827a^:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

======= fetch "public boolean getStrictSpecMode() {" 85a827a^:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

======= fetch "public void setStrictSpecMode(boolean value) {" 85a827a^:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

======= fetch "public boolean getPortingMode() {" 85a827a^:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

======= fetch "public void setNonStandardOptions(String value) {" 85a827a^:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

======= fetch "private void setBooleanOptionVal(String name, boolean value) {" 85a827a^:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

======= fetch "pointcut runtimeHandlers(): mainExecution()" 85a827a^:"ajde/testdata/examples/figures-coverage/figures/Figure.java"

    declare soft: Point: call(* *(..));
======= fetch "public static Test suite() {" 85a827a^:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

        suite.addTestSuite(BuildConfigurationTests.class);
 * Tests that a correctly populated AjBuildConfig object is created
 * in reponse to the setting in BuildOptionsAdapter and 
 * ProjectPropretiesAdapter
 */
 * 	   AMC 01.21.2003 extended to cover new AspectJ1.1 options
======= fetch "public void testPortingMode() {" 85a827a^:"ajde/testsrc/org/aspectj/ajde/BuildOptionsTest.java"

======= fetch "public void init(String testProjectPath) {" 85a827a^:"ajde/testsrc/org/aspectj/ajde/NullIdeManager.java"

 * 	   AMC 01.20.2003 extended to support AspectJ 1.1 options
======= fetch "public String getClasspath() {" 85a827a^:"ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java"

    	return testProjectPath + System.getProperty("sun.boot.class.path") + File.pathSeparator +  "../../../runtime/bin";	
======= fetch "public String getVmArgs() {" 85a827a^:"ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java"

    
    public void setInJars( Set jars ) { this.inJars = jars; }
    
    public Set getInJars( ) {
    	return inJars;
    }
    public String getOutJar() {
    	return outJar;
    }
    
    public void setSourceRoots( Set roots ) { this.sourceRoots = roots; }
    public Set getSourceRoots() {
    	return sourceRoots;
    }
    public Set getAspectPath() {
    	return aspectPath;
    }
======= fetch "public void test() {" 85a827a^:"ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java"

======= fetch "public boolean verifyAgainstSavedModel(String lstFile) {" 85a827a^:"ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java"

======= fetch "public boolean verifyAgainstSavedModel(String lstFile) {" 85a827a^:"ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java"

 *     AMC 21.01.2003 fixed for new source location in eclipse.org
======= fetch "public void testFieldInitializerCorrespondence() throws IOException {" 85a827a^:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= fetch "public void testFieldInitializerCorrespondence() throws IOException {" 85a827a^:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= fetch "public void testFileNodeFind() throws IOException {" 85a827a^:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= fetch "public void testMainClassNodeInfo() throws IOException {" 85a827a^:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= fetch "public void testFreshStructureModelCreation() {" 85a827a^:"ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java"

======= fetch "public void parseOption(String arg, LinkedList args) {" 85a827a^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

 *     Adrian Colyer  added constructor to populate javaOptions with
 * 					  default settings - 01.20.2003
 * 					  Bugzilla #29768, 29769
======= fetch "public void testXlint() throws InvalidInputException {" 85a827a^:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"


    
    <ajc-test dir="bugs" pr="29662"
    		title="VerifyError on accessing objects not accessible to the weaver">
        <compile files="AroundAccess.java">
        </compile>
        <run class="AroundAccess"/>
    </ajc-test>
   VerifyError on accessing objects not accessible to the weaver: Incompatible object argument for invokespecial 
 */
    public static void main(String args[]) throws Throwable {
        AroundAccess ve = new AroundAccess();
        ve.foo();
        Tester.checkEqual(FinalizeContract.fromAround, "s3:2,ME");
    }
    protected void foo() throws Throwable {}
    pointcut finalizeCall(Object o):
        this(Object+) &&
        this(o) &&
        execution(void foo());
    void around(Object o) throws Throwable: finalizeCall(o) {
    	String p = getS(3.14, 2); // + Foo.x;
    	fromAround = p + "," + toString();
    	Tester.checkNotEqual(super.toString(), toString());
        proceed(o);
        counter++;
    }

======= fetch "public ProgramElementNode findNodeForClass(String packageName, String className)" c1260e6^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "public ProgramElementNode findNodeForClass(String packageName, String className)" c1260e6^:"asm/src/org/aspectj/asm/StructureModel.java"

======= fetch "public boolean visit(TypeDeclaration typeDeclaration, CompilationUnitScope scope" c1260e6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

======= fetch "public boolean visit(MemberTypeDeclaration memberTypeDeclaration, ClassScope sco" c1260e6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

======= fetch "public void endVisit(MemberTypeDeclaration memberTypeDeclaration, ClassScope sco" c1260e6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

======= fetch "public boolean visit(MethodDeclaration methodDeclaration, ClassScope scope) {" c1260e6^:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

======= fetch "private static ProgramElementNode getNode(StructureModel model, Advice a) {" c1260e6^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static ProgramElementNode getNode(StructureModel model, Shadow shadow) {" c1260e6^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static ProgramElementNode findOrCreateBodyNode(" c1260e6^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static ProgramElementNode findMemberInClass(" c1260e6^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "private static ProgramElementNode findMemberInClass(" c1260e6^:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= fetch "public boolean isAspect() {" c1260e6^:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

    public boolean isSynthetic() {
    	return signature.indexOf("$ajc") != -1;
    }
    
======= fetch "private void implementMungers() {" c1260e6^:"weaver/src/org/aspectj/weaver/Shadow.java"

======= fetch "LazyClassGen weave(UnwovenClassFile classFile, BcelObjectType classType) throws" c1260e6^:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


======= fetch "public LazyMethodGen(Method m, LazyClassGen enclosingClass) {" 2781720^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        if (!m.isAbstract() && m.getCode() == null) {
======= fetch "void run() {" 2781720^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        	killNops();
======= fetch "void print() {" 2781720^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= fetch "public MethodGen pack() {" 2781720^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    	//killNops();
======= fetch "public void packBody(MethodGen gen) {" 2781720^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

         * a 1:1 mapping.  
======= fetch "public void packBody(MethodGen gen) {" 2781720^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= fetch "public void packBody(MethodGen gen) {" 2781720^:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    	InstructionHandle curr = body.getStart();
    	while (true) {
    		if (curr.getInstruction() instanceof NOP) {
    			InstructionTargeter[] targeters = curr.getTargeters();
    			if (targeters != null) {
    				for (int i = 0, len = targeters.length; i < len; i++) {
    				}
    			}
    		}
    	}

======= fetch "public static ResolvedMember interFieldInitializer(ResolvedMember field, TypeX a" 99a873c^:"weaver/src/org/aspectj/weaver/AjcMemberMaker.java"

======= fetch "public static ResolvedMember interFieldClassField(ResolvedMember field, TypeX as" 99a873c^:"weaver/src/org/aspectj/weaver/AjcMemberMaker.java"

======= fetch "public static ResolvedMember interFieldInterfaceField(ResolvedMember field, Type" 99a873c^:"weaver/src/org/aspectj/weaver/AjcMemberMaker.java"

======= fetch "public static ResolvedMember interMethod(ResolvedMember meth, TypeX aspectType," 99a873c^:"weaver/src/org/aspectj/weaver/AjcMemberMaker.java"

