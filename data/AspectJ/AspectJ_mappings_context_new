
======= dd88d21:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= dd88d21:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

    @Before("execution(* com.foo.bar.Test.foo())")
    public void advice() {
        System.out.println("Hello");
    }
======= dd88d21:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

    abstract class X<T> {}
    class X1 extends X<Integer> {}
    class X2 extends X<String> {}
    public Test foo() {
        return this;
    }
    public <T> X<T> createMessage(int n) {
        X x;
        if (n == 0) {
            x = new X1();
        } else {
            x = new X2();
        }
        return x;
    }
    
    public static void main(String[] args) {
======= dd88d21:"tests/src/org/aspectj/systemtest/AllTests17.java"

======= dd88d21:"tests/src/org/aspectj/systemtest/AllTests17.java"

 * Copyright (c) 2013 Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
 * @author Andy Clement
 */
======= dd88d21:"tests/src/org/aspectj/systemtest/AllTests17.java"

 * Copyright (c) 2013 Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
======= dd88d21:"tests/src/org/aspectj/systemtest/AllTests17.java"

======= dd88d21:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= dd88d21:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= dd88d21:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= dd88d21:"weaver/src/org/aspectj/weaver/bcel/asm/StackMapAdder.java"


======= 9319e34:"org.aspectj.matcher/src/org/aspectj/weaver/Checker.java"

======= 9319e34:"org.aspectj.matcher/src/org/aspectj/weaver/Checker.java"

  declare warning: call(* foo(..)): "Call to foo made inside class {joinpoint.enclosingclass}";
  declare warning: call(* foo(..)): "Call to foo made inside member {joinpoint.enclosingmember.name}";
  declare warning: call(* foo(..)): "Call to foo made inside member {joinpoint.enclosingmember}";
  public void booble() {
    foo();
  }
  public void foo() {}
  public void m() {
    foo();
  }
  public void foo() {}
======= 9319e34:"tests/src/org/aspectj/systemtest/ajc174/Ajc174Tests.java"


======= b2cd5fa:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= b2cd5fa:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= b2cd5fa:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= b2cd5fa:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= b2cd5fa:"org.aspectj.matcher/src/org/aspectj/weaver/Lint.java"

======= b2cd5fa:"testing/newsrc/org/aspectj/testing/CompileSpec.java"

======= b2cd5fa:"testing/newsrc/org/aspectj/testing/CompileSpec.java"

  before(): execution(* *(String)) { }
  before(): call(* someMethod(..)) {
  }
  public void foo() {
    someMethod();
  }
  public void someMethod(){}
======= b2cd5fa:"tests/src/org/aspectj/systemtest/ajc174/Ajc174Tests.java"


======= 9e992d6:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

                if (loader.equals(myClassLoader)){
                    adaptor = myClassLoaderAdaptor;
                } else {
======= 9e992d6:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

======= 9e992d6:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"


 //   public String Behavior.name;
    public static void main(String []argv) throws Exception {
      System.out.println(Target.class.getDeclaredMethod("hello").getDeclaredAnnotations()[0]);
    }
    public static void main(String []argv) throws Exception {
      System.out.println(Target2.class.getDeclaredMethod("hello").getDeclaredAnnotations()[0]);
    }
    @Wibble
    public static void main(String []argv) throws Exception {
      System.out.println(Target3.class.getDeclaredMethod("hello").getDeclaredAnnotations().length);
      System.out.println(Target3.class.getDeclaredMethod("hello").getDeclaredAnnotations()[0]);
      System.out.println(Target3.class.getDeclaredMethod("hello").getDeclaredAnnotations()[1]);
    }
    @Tagged(31)
    public static void main(String []argv) throws Exception {
      System.out.println(Target4.class.getDeclaredMethod("hello").getDeclaredAnnotations().length);
      System.out.println(Target4.class.getDeclaredMethod("hello").getDeclaredAnnotations()[0]);
    }
======= 2393bef:"tests/src/org/aspectj/systemtest/ajc174/Ajc174Tests.java"

======= 2393bef:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 2393bef:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 2393bef:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 2393bef:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 2393bef:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 2393bef:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 2393bef:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 2393bef:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 2393bef:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= 2393bef:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= 2393bef:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= 2393bef:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"


======= 0c0adc5:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

======= 0c0adc5:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

======= 0c0adc5:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

======= 0c0adc5:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

======= 0c0adc5:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= 0c0adc5:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= 0c0adc5:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

======= 0c0adc5:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

======= 0c0adc5:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

======= 0c0adc5:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

======= 0c0adc5:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

======= 0c0adc5:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

  before(): execution(* *(..)) {
    System.out.println("advice");
  }
======= 0c0adc5:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

  public static void main(String []argv) {
    System.out.println("running");
  }
======= 0c0adc5:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

 <aspects>
  <aspect name="Azpect"/>
 </aspects>
 <weaver options="-verbose"/>
======= 0c0adc5:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

 <aspects>
  <aspect name="Azpect"/>
 </aspects>
 <weaver options="-verbose -loadersToSkip:com.foo.Bar"/>
======= 0c0adc5:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

 <aspects>
  <aspect name="Azpect"/>
 </aspects>
 <weaver options="-verbose -loadersToSkip:org.aspectj.weaver.loadtime.WeavingURLClassLoader"/>
======= 0c0adc5:"tests/src/org/aspectj/systemtest/ajc174/Ajc174Tests.java"

      <compile files="Code.java" classpath="$sandbox/foo.jar"/>
      <run class="Code" classpath="$sandbox/foo.jar" ltw="aop1.xml">
        <stdout>
          <line text="advice"/>
          <line text="running"/>
 	    </stdout>
 	    <stderr>
 	    <line text="AspectJ Weaver"/>
 	    <line text="register classloader"/>
 	    <line text="using configuration"/>
 	    <line text="register aspect"/>
 	    <line text="processing reweavable"/>
 	    </stderr>
      </run>
      <compile files="Code.java" classpath="$sandbox/foo.jar"/>
      <run class="Code" classpath="$sandbox/foo.jar" ltw="aop1.xml">
        <stdout>
          <line text="advice"/>
          <line text="running"/>
 	    </stdout>
 	    <stderr>
 	    <line text="AspectJ Weaver"/>
 	    <line text="register classloader"/>
 	    <line text="using configuration"/>
 	    <line text="no longer creating weavers for these classloaders: [foo]"/>
 	    <line text="register aspect"/>
 	    <line text="processing reweavable"/>
 	    </stderr>
      </run>
      <compile files="Code.java" classpath="$sandbox/foo.jar"/>
      <run class="Code" classpath="$sandbox/foo.jar" ltw="aop1.xml">
        <stdout>
          <line text="advice"/>
          <line text="running"/>
 	    </stdout>
 	    <stderr>
 	    <line text="AspectJ Weaver"/>
 	    <line text="register classloader"/>
 	    <line text="using configuration"/>
 	    <line text="register aspect"/>
 	    <line text="processing reweavable"/>
 	    </stderr>
      </run>
      <compile files="Code.java" classpath="$sandbox/foo.jar"/>
      <run class="Code" classpath="$sandbox/foo.jar" ltw="aop2.xml">
        <stdout>
          <line text="advice"/>
          <line text="running"/>
 	    </stdout>
 	    <stderr>
 	    <line text="AspectJ Weaver"/>
 	    <line text="register classloader"/>
 	    <line text="using configuration"/>
 	    <line text="no longer creating weavers for these classloaders: [com.foo.Bar]"/>
 	    <line text="register aspect"/>
 	    <line text="processing reweavable"/>
 	    </stderr>
      </run>
      <compile files="Code.java" classpath="$sandbox/foo.jar"/>
      <run class="Code" classpath="$sandbox/foo.jar" ltw="aop3.xml">
        <stdout>
          <line text="advice"/>
          <line text="running"/>
 	    </stdout>
 	    <stderr>
 	    <line text="AspectJ Weaver"/>
 	    <line text="register classloader"/>
 	    <line text="using configuration"/>
 	    <line text="no longer creating weavers for these classloaders: [org.aspectj.weaver.loadtime.WeavingURLClassLoader]"/>
 	    <line text="register aspect"/>
 	    <line text="processing reweavable"/>
 	    </stderr>
      </run>

    public String mParent = "John";
    
    public Child(String parent) {
        this.mParent = parent;
    }
    
    public String getParent()
    {
        return this.mParent;
    }
    private String mName = "John";
    private int mAge = 50;
    
    public int getAge(){
        return mAge;
    }
    public Child.new(String parent, int age) {
        this(parent);
        
        System.out.println("Get Age:" + super.getAge());
        System.out.println("Child Name:" + this.mParent);
    }
  public static void main(String []argv) {
    new Child("Andy",5);
  }
======= 302c14e:"tests/src/org/aspectj/systemtest/AllTests17.java"

======= 302c14e:"tests/src/org/aspectj/systemtest/AllTests17.java"

 * Copyright (c) 2013 Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
 * @author Andy Clement
 */
======= 302c14e:"tests/src/org/aspectj/systemtest/AllTests17.java"

 * Copyright (c) 2013 Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
======= 302c14e:"tests/src/org/aspectj/systemtest/AllTests17.java"

======= 302c14e:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= 302c14e:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= 302c14e:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"


======= e6cb508:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"


======= 3f6e166:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= 3f6e166:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= 3f6e166:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= 3f6e166:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"


======= ff0859d:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


======= 4e34477:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"


======= be5a530:"org.aspectj.matcher/src/org/aspectj/weaver/AjcMemberMaker.java"


======= edb41e3:"org.aspectj.matcher/src/org/aspectj/weaver/WeaverMessages.java"

======= edb41e3:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

  String[] value();
  @Anno({"xyz","abc"})
  public void m() {}
  pointcut p(): execution(public * @Anno(value="xyz=abc") *..*(..));
  before() : p() { }
======= edb41e3:"tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"

      <compile files="Code.java" options="-1.5">
      	<message kind="error" text="Compiler limitation: annotation value support not implemented for type java.lang.String[]"/>
      </compile>
    </ajc-test>
    

======= 46f9079:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariable.java"

======= 46f9079:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariable.java"

======= 46f9079:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariable.java"

  declare parents: Bug.ClassA implements java.io.Serializable;
    public static class ClassA<T extends Interface1 & Interface2> {
    }
    public static class ClassB extends ClassA<ClassB> implements Interface1, Interface2 {
    }
    public interface Interface1 {
    }
    public interface Interface2 {
    }
    public static void main(String[] args) throws Exception {
        System.out.println(ClassB.class.getGenericSuperclass());
    }
======= 46f9079:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariable.java"

    public static class ClassA2<T extends Interface12 & Interface22> implements java.io.Serializable {
    }
    public static class ClassB2 extends ClassA2<ClassB2> implements Interface12, Interface22 {
    }
    public interface Interface12 {
    }
    public interface Interface22 {
    }
    public static void main(String[] args) throws Exception {
        System.out.println(ClassB2.class.getGenericSuperclass());
    }
======= 46f9079:"tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"

======= 46f9079:"tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"

======= 46f9079:"tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"

======= 46f9079:"tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"

======= 46f9079:"tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"

======= 46f9079:"tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"

      <compile files="Bug.java" options="-1.5"/>
      <compile files="Bug2.java" options="-1.5"/>
      <run class="Bug2"/>
      <run class="Bug"/>
    </ajc-test>
    

======= 4af4b1e:"org.aspectj.matcher/src/org/aspectj/weaver/BoundedReferenceType.java"

======= 4af4b1e:"org.aspectj.matcher/src/org/aspectj/weaver/BoundedReferenceType.java"

======= 4af4b1e:"org.aspectj.matcher/src/org/aspectj/weaver/BoundedReferenceType.java"

======= 4af4b1e:"org.aspectj.matcher/src/org/aspectj/weaver/BoundedReferenceType.java"

======= 4af4b1e:"org.aspectj.matcher/src/org/aspectj/weaver/BoundedReferenceType.java"

  declare parents: Cage2 implements java.io.Serializable;
======= 4af4b1e:"org.aspectj.matcher/src/org/aspectj/weaver/BoundedReferenceType.java"

======= 4af4b1e:"org.aspectj.matcher/src/org/aspectj/weaver/BoundedReferenceType.java"

  declare parents: Cage2 implements java.io.Serializable;
======= 4af4b1e:"org.aspectj.matcher/src/org/aspectj/weaver/BoundedReferenceType.java"

======= 4af4b1e:"org.aspectj.matcher/src/org/aspectj/weaver/BoundedReferenceType.java"

  declare parents: Cage2 implements java.io.Serializable;
======= 4af4b1e:"org.aspectj.matcher/src/org/aspectj/weaver/BoundedReferenceType.java"

======= 4af4b1e:"org.aspectj.matcher/src/org/aspectj/weaver/BoundedReferenceType.java"

======= 4af4b1e:"tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"

      <compile files="Cage.java" options="-1.5"/>
      <compile files="Cage2.java" options="-1.5"/>
    </ajc-test>
    
      <compile files="Cage.java" options="-1.5"/>
      <compile files="Cage2.java" options="-1.5"/>
    </ajc-test>
    
      <compile files="Cage.java" options="-1.5"/>
      <compile files="Cage2.java" options="-1.5"/>
    </ajc-test>
    
      <compile files="Cage.java" options="-1.5"/>
      <compile files="Cage2.java" options="-1.5"/>
    </ajc-test>
    
      <compile files="Cage.java" options="-1.5"/>
      <compile files="Cage2.java" options="-1.5"/>
    </ajc-test>
    

======= d524403:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"


  before(): execution(@Anno * *(..)) {System.out.println("A");}
  before():staticinitialization(!Aspect*) { System.out.println("staticinitialization");}
  before(): execution(@Blah * *(..)) {System.out.println("C");}
  before(): execution(@Anno2 * *(..)) {System.out.println("D");}
  @Blah
  public static void main(String[] argv) {
    System.out.println("abcde");
  }
  @Anno
  public static void main(String[] argv) {
    System.out.println("abcde");
  }
  <aspects>
    <aspect name="AspectA" requires="a.b.c.Anno"/>
    <aspect name="AspectB"/>
    <aspect name="AspectC" requires="a.b.c.Blah"/>
    <aspect name="AspectD" requires="a.b.c.Anno2"/>
  </aspects>
  <weaver options="-showWeaveInfo -verbose"/>
======= 96ebaae:"tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"

 */
======= 96ebaae:"tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"

  
======= 96ebaae:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"


======= 3e5af0f:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/AndPointcut.java"


======= fc55431:"weaver/src/org/aspectj/weaver/bcel/asm/StackMapAdder.java"


======= df1823b:"build/src/org/aspectj/internal/tools/ant/taskdefs/Checklics.java"

======= df1823b:"build/src/org/aspectj/internal/tools/ant/taskdefs/Checklics.java"

======= df1823b:"build/src/org/aspectj/internal/tools/ant/taskdefs/Checklics.java"

======= df1823b:"util/src/org/aspectj/util/LangUtil.java"

======= df1823b:"weaver/src/org/aspectj/weaver/tools/cache/AbstractIndexedFileCacheBacking.java"

======= df1823b:"weaver/src/org/aspectj/weaver/tools/cache/AbstractIndexedFileCacheBacking.java"

    public static final IndexEntry createIndexEntry (CachedClassEntry classEntry, byte[] originalBytes) {
        if (classEntry == null) {
            return null;
        }
        IndexEntry  indexEntry = new IndexEntry();
        indexEntry.key = classEntry.getKey();
        indexEntry.generated = classEntry.isGenerated();
        indexEntry.ignored = classEntry.isIgnored();
        if (!classEntry.isIgnored()) {
        	indexEntry.crcClass = crc(originalBytes);
            indexEntry.crcWeaved = crc(classEntry.getBytes());
        }
        return indexEntry;
    }
======= df1823b:"weaver/src/org/aspectj/weaver/tools/cache/AbstractIndexedFileCacheBacking.java"

 * Copyright (c) 2012 Contributors.
 * All rights reserved.
 * This program and the accompanying materials are made available
 * under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution and is available at
 * http://eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Lyor Goldstein (vmware)	add support for weaved class being re-defined
 *******************************************************************************/
 * Uses a background thread to do the actual I/O and for caching &quot;persistence&quot;
 * so that the caching works faster on repeated activations of the application.
 * The class maintains an in-memory cache, and uses a queue of {@link AsyncCommand}s
 * to signal to a background thread various actions required to &quot;synchronize&quot;
 * the in-memory cache with the persisted copy. Whenever there is a cache miss
 * from the {@link #get(CachedClassReference)} call, the weaver issues a
 * {@link #put(CachedClassEntry)} call. This call has 2 side-effects:</BR>
 * <UL>
 * 		<LI>
 * 		The in-memory cache is updated so that subsequent calls to {@link #get(CachedClassReference)}
 * 		will not return the mapped value.
 * 		</LI>
 * 
 *  	<LI>
 *  	An &quot;update index&quot {@link AsyncCommand} is posted to the background
 *  	thread so that the newly mapped value will be persisted (eventually)
 *  	</LI> 
 * </UL>
 * The actual persistence is implemented by the <U>concrete</U> classes
 */
    private static final BlockingQueue<AsyncCommand>   commandsQ=new LinkedBlockingQueue<AsyncCommand>();
    private static final ExecutorService    execService=Executors.newSingleThreadExecutor();
    private static Future<?> commandsRunner;
    protected final Map<String, IndexEntry> index, exposedIndex;
    protected final Map<String, byte[]>   bytesMap, exposedBytes;
    protected AsynchronousFileCacheBacking (File cacheDir) {
    	super(cacheDir);
        index = readIndex(cacheDir, getIndexFile());
        exposedIndex = Collections.unmodifiableMap(index);
        bytesMap = readClassBytes(index, cacheDir);
        exposedBytes = Collections.unmodifiableMap(bytesMap);
    }
    @Override
        String              key=ref.getKey();
        final IndexEntry    indexEntry;
        synchronized(index) {
            if ((indexEntry=index.get(key)) == null) {
                return null;
            }
        }
        if (crc(originalBytes) != indexEntry.crcClass) {
            if ((logger != null) && logger.isTraceEnabled()) {
                logger.debug("get(" + getCacheDirectory() + ") mismatched original class bytes CRC for " + key);
            }
            remove(key);
            return null;
        }
        if (indexEntry.ignored) {
            return new CachedClassEntry(ref, WeavedClassCache.ZERO_BYTES, CachedClassEntry.EntryType.IGNORED);
        }
        final byte[]    bytes;
        synchronized(bytesMap) {
            /*
             * NOTE: we assume that keys represent classes so if we have their
             * bytes they will not be re-created
             */
            if ((bytes=bytesMap.remove(key)) == null) {
                return null;
            }
        }
        if (indexEntry.generated) {
            return new CachedClassEntry(ref, bytes, CachedClassEntry.EntryType.GENERATED);
        } else {
            return new CachedClassEntry(ref, bytes, CachedClassEntry.EntryType.WEAVED);
        }
    }
    public void put(CachedClassEntry entry, byte[] originalBytes) {
        String  key=entry.getKey();
        byte[]  bytes=entry.isIgnored() ? null : entry.getBytes();
        synchronized(index) {
            IndexEntry  indexEntry=index.get(key);
            if (indexEntry != null) {
                return;
            }
            /*
             * Note: we do not cache the class bytes - only send them to
             * be saved. The assumption is that the 'put' call was invoked
             * because 'get' failed to return any bytes. And since we assume
             * that each class bytes are required only once, there is no
             * need to cache them
             */
            indexEntry = createIndexEntry(entry, originalBytes);
            index.put(key, indexEntry);
        }
        if (!postCacheCommand(new InsertCommand(this, key, bytes))) {
            if ((logger != null) && logger.isTraceEnabled()) {
                logger.error("put(" + getCacheDirectory() + ") Failed to post insert command for " + key);
            }
        }
        if ((logger != null) && logger.isTraceEnabled()) {
            logger.debug("put(" + getCacheDirectory() + ")[" + key + "] inserted");
        }
    }
    public void remove(CachedClassReference ref) {
    	remove(ref.getKey());
    }
    protected IndexEntry remove (String key) {
        IndexEntry  entry;
        synchronized(index) {
            entry = index.remove(key);
        }
        synchronized(bytesMap) {
            bytesMap.remove(key);
        }
        if (!postCacheCommand(new RemoveCommand(this, key))) {
            if ((logger != null) && logger.isTraceEnabled()) {
                logger.error("remove(" + getCacheDirectory() + ") Failed to post remove command for " + key);
            }
        }
        
        if (entry != null) {
            if (!key.equals(entry.key)) {
                if ((logger != null) && logger.isTraceEnabled()) {
                    logger.error("remove(" + getCacheDirectory() + ") Mismatched keys: " + key + " / " + entry.key);
                }
            } else if ((logger != null) && logger.isTraceEnabled()) {
                logger.debug("remove(" + getCacheDirectory() + ")[" + key + "] removed");
            }
        }
        return entry;
    }
    public List<IndexEntry> getIndexEntries () {
        synchronized(index) {
            if (index.isEmpty()) {
                return Collections.emptyList();
            } else {
                return new ArrayList<IndexEntry>(index.values());
            }
        }
    }
    public Map<String, IndexEntry> getIndexMap () {
        return exposedIndex;
    }
    public Map<String, byte[]> getBytesMap () {
        return exposedBytes;
    }
    public void clear() {
        synchronized(index) {
            index.clear();
        }
        if (!postCacheCommand(new ClearCommand(this))) {
            if ((logger != null) && logger.isTraceEnabled()) {
                logger.error("Failed to post clear command for " + getIndexFile());
            }
        }
    }
    protected void executeCommand (AsyncCommand cmd) throws Exception {
        if (cmd instanceof ClearCommand) {
            executeClearCommand();
        } else if (cmd instanceof UpdateIndexCommand) {
            executeUpdateIndexCommand();
        } else if (cmd instanceof InsertCommand) {
            executeInsertCommand((InsertCommand) cmd);
        } else if (cmd instanceof RemoveCommand) {
            executeRemoveCommand((RemoveCommand) cmd);
        } else {
            throw new UnsupportedOperationException("Unknown command: " + cmd);
        }
    }
    protected void executeClearCommand () throws Exception {
        FileUtil.deleteContents(getIndexFile());
        FileUtil.deleteContents(getCacheDirectory());
    }
    protected void executeUpdateIndexCommand () throws Exception {
        writeIndex(getIndexFile(), getIndexEntries());
    }
    protected void executeInsertCommand (InsertCommand cmd) throws Exception {
        writeIndex(getIndexFile(), getIndexEntries());
        byte[]  bytes=cmd.getClassBytes();
        if (bytes != null) {
            writeClassBytes(cmd.getKey(), bytes);
        }
    }
    protected void executeRemoveCommand (RemoveCommand cmd) throws Exception {
        Exception err=null;
        try {
            removeClassBytes(cmd.getKey());
        } catch(Exception e) {
            err = e;
        }
        writeIndex(getIndexFile(), getIndexEntries());
        if (err != null) {
            throw err;  // check if the class bytes remove had any problems
        }
    }
    /**
     * Helper for {@link #executeRemoveCommand(RemoveCommand)}
     * @param key The key representing the class whose bytes are to be removed
     * @throws Exception if failed to remove class bytes
     */
    protected abstract void removeClassBytes (String key) throws Exception;
    protected abstract Map<String, byte[]> readClassBytes (Map<String,IndexEntry> indexMap, File cacheDir);
    @Override
    public String toString() {
        return getClass().getSimpleName() + "[" + String.valueOf(getCacheDirectory()) + "]";
    }
    protected static final <T extends AsynchronousFileCacheBacking> T createBacking (
                            File cacheDir, AsynchronousFileCacheBackingCreator<T> creator) {
        final Trace trace=TraceFactory.getTraceFactory().getTrace(AsynchronousFileCacheBacking.class);
        if (!cacheDir.exists()) {
            if (!cacheDir.mkdirs()) {
                if ((trace != null) && trace.isTraceEnabled()) {
                    trace.error("Unable to create cache directory at " + cacheDir.getAbsolutePath());
                }
                return null;
            }
        }
        if (!cacheDir.canWrite()) {
            if ((trace != null) && trace.isTraceEnabled()) {
                trace.error("Cache directory is not writable at " + cacheDir.getAbsolutePath());
            }
            return null;
        }
        // start the service (if needed) only if successfully create the backing instance
        T    backing=creator.create(cacheDir);
        synchronized(execService) {
            if (commandsRunner == null) {
                commandsRunner = execService.submit(new Runnable() {
                    @SuppressWarnings("synthetic-access")
                    public void run() {
                        for ( ; ; ) {
                            try {
                                AsyncCommand    cmd=commandsQ.take();
                                try {
                                    AsynchronousFileCacheBacking    cache=cmd.getCache();
                                    cache.executeCommand(cmd);
                                } catch(Exception e) {
                                    if ((trace != null) && trace.isTraceEnabled()) {
                                        trace.error("Failed (" + e.getClass().getSimpleName() + ")"
                                                  + " to execute " + cmd + ": " + e.getMessage(), e);
                                    }
                                }
                            } catch(InterruptedException e) {
                                if ((trace != null) && trace.isTraceEnabled()) {
                                    trace.warn("Interrupted");
                                }
                                Thread.currentThread().interrupt();
                                break;
                            }
                        }
                    }
                });
            }
        }
        // fire-up an update-index command in case index was changed by the constructor
        if (!postCacheCommand(new UpdateIndexCommand(backing))) {
            if ((trace != null) && trace.isTraceEnabled()) {
                trace.warn("Failed to offer update index command to " + cacheDir.getAbsolutePath());
            }
        }
        return backing;
    }
    public static final boolean postCacheCommand (AsyncCommand cmd) {
        return commandsQ.offer(cmd);
    }
    public static interface AsynchronousFileCacheBackingCreator<T extends AsynchronousFileCacheBacking> {
        T create (File cacheDir);
    }
    /**
     * Represents an asynchronous command that can be sent to the
     * {@link AsynchronousFileCacheBacking} instance to be executed
     * on it <U>asynchronously</U>
     */
    public static interface AsyncCommand {
        /**
         * @return The {@link AsynchronousFileCacheBacking} on which
         * this command is supposed to be executed
         * @see AsynchronousFileCacheBacking#executeCommand(AsyncCommand)
         */
        AsynchronousFileCacheBacking getCache ();
    }
    public static abstract class AbstractCommand implements AsyncCommand {
        private final AsynchronousFileCacheBacking  cache;
        protected AbstractCommand (AsynchronousFileCacheBacking backing) {
            if ((cache=backing) == null) {
                throw new IllegalStateException("No backing cache specified");
            }
        }
        public final AsynchronousFileCacheBacking getCache () {
            return cache;
        }
        
        @Override
        public String toString() {
            return getClass().getSimpleName() + "[" + getCache() + "]";
        }
    }
    public static class ClearCommand extends AbstractCommand {
        public ClearCommand (AsynchronousFileCacheBacking cache) {
            super(cache);
        }
    }
    public static class UpdateIndexCommand extends AbstractCommand {
        public UpdateIndexCommand (AsynchronousFileCacheBacking cache) {
            super(cache);
        }
    }
    /**
     * Base class for {@link AbstractCommand}s that refer to a cache key
     */
    public static abstract class KeyedCommand extends AbstractCommand {
        private final String    key;
        protected KeyedCommand (AsynchronousFileCacheBacking cache, String keyValue) {
            super(cache);
            
            if (LangUtil.isEmpty(keyValue)) {
                throw new IllegalStateException("No key value");
            }
            key = keyValue;
        }
        public final String getKey () {
            return key;
        }
        @Override
        public String toString() {
            return super.toString() + "[" + getKey() + "]";
        }
    }
    public static class RemoveCommand extends KeyedCommand {
        public RemoveCommand (AsynchronousFileCacheBacking cache, String keyValue) {
            super(cache, keyValue);
        }
    }
    
    public static class InsertCommand extends KeyedCommand {
        private final byte[]    bytes;
        public InsertCommand (AsynchronousFileCacheBacking cache, String keyValue, byte[] classBytes) {
            super(cache, keyValue);
            bytes = classBytes;
        }
        public final byte[] getClassBytes () {
            return bytes;
        }
    }
======= df1823b:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= df1823b:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

 * Copyright (c) 2012 VMware, Inc. custard
 * 
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 * Lyor Goldstein
 * ******************************************************************/
 * Uses a &quot;flat&quot files model to store the cached instrumented classes
 * and aspects - i.e., each class/aspect is stored as a <U>separate</U> (binary)
 * file. This is a good mechanism when the number of instrumented class is
 * relatively small (a few 10's). The reason for it is that scanning a folder
 * that has many files in it quickly becomes an I/O bottleneck. Also, some
 * O/S-es may impose internal limits on the maximum number of &quot;children&quot;
 * a folder node may have. On the other hand, it is much faster (again, for
 * small number of instrumented classes) than the ZIP cache since each class/aspect
 * is represented by a single file - thus adding/removing/modifying it is easier. 
 * 
 * @author Lyor Goldstein
 */
    private static final AsynchronousFileCacheBackingCreator<FlatFileCacheBacking>    defaultCreator=
            new AsynchronousFileCacheBackingCreator<FlatFileCacheBacking>() {
                public FlatFileCacheBacking create(File cacheDir) {
                    return new FlatFileCacheBacking(cacheDir);
                }
        };
    public FlatFileCacheBacking(File cacheDir) {
        super(cacheDir);
    }
    public static final FlatFileCacheBacking createBacking (File cacheDir) {
        return createBacking(cacheDir, defaultCreator);
    }
    @Override
    protected Map<String, byte[]> readClassBytes(Map<String, IndexEntry> indexMap, File cacheDir) {
        return readClassBytes(indexMap, cacheDir.listFiles());
    }
    protected Map<String, byte[]> readClassBytes (Map<String,IndexEntry> indexMap, File[] files) {
        Map<String, byte[]> result=new TreeMap<String, byte[]>();
        if (LangUtil.isEmpty(files)) {
            return result;
        }
        for (File file : files) {
            if (!file.isFile()) {
                continue;   // skip sub-directories - we expect flat files
            }
            String  key=file.getName();
            if (INDEX_FILE.equalsIgnoreCase(key)) {
                continue;   // skip the index itself if found
            }
            IndexEntry  entry=indexMap.get(key);
            if ((entry == null) || entry.ignored) {    // if not in index or ignored then remove it
                if ((logger != null) && logger.isTraceEnabled()) {
                    logger.info("readClassBytes(" + key + ") remove orphan/ignored: " + file.getAbsolutePath());
                }
                FileUtil.deleteContents(file);
                continue;
            }
            try {
                byte[]  bytes=FileUtil.readAsByteArray(file);
                long    crc=crc(bytes);
                if (crc != entry.crcWeaved) {
                    throw new StreamCorruptedException("Mismatched CRC - expected=" + entry.crcWeaved + "/got=" + crc);
                }
                result.put(key, bytes);
                if ((logger != null) && logger.isTraceEnabled()) {
                    logger.debug("readClassBytes(" + key + ") cached from " + file.getAbsolutePath());
                }
            } catch(IOException  e) {
                if ((logger != null) && logger.isTraceEnabled()) {
                    logger.error("Failed (" + e.getClass().getSimpleName() + ")"
                               + " to read bytes from " + file.getAbsolutePath()
                               + ": " + e.getMessage());
                }
                indexMap.remove(key);   // no need for the entry if no file - force a re-write of its bytes
                FileUtil.deleteContents(file);  // assume some kind of corruption
                continue;
            }
        }
        return result;
    }
    
    @Override
    protected IndexEntry resolveIndexMapEntry (File cacheDir, IndexEntry ie) {
        File cacheEntry = new File(cacheDir, ie.key);
        if (ie.ignored || cacheEntry.canRead()) {
            return ie;
        } else {
            return null;
        }
    }
    @Override
    protected void writeClassBytes (String key, byte[] bytes) throws Exception {
        File    dir=getCacheDirectory(), file=new File(dir, key);
        FileOutputStream    out=new FileOutputStream(file);
        try {
            out.write(bytes);
        } finally {
            out.close();
        }
    }
    @Override
    protected void removeClassBytes (String key) throws Exception {
        File        dir=getCacheDirectory(), file=new File(dir, key);
        if (file.exists() && (!file.delete())) {
            throw new StreamCorruptedException("Failed to delete " + file.getAbsolutePath());
        }
    }
======= df1823b:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

 * Copyright (c) 2012 Contributors.
 * All rights reserved.
 * This program and the accompanying materials are made available
 * under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution and is available at
 * http://eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Lyor Goldstein (vmware)	add support for weaved class being re-defined
 *******************************************************************************/
 * Uses a ZIP file to store the instrumented classes/aspects - each one as a
 * <U>separate</U> {@link ZipEntry}. This mechanism is suitable for relatively
 * large numbers of instrumented classes/aspects (100's and more) since it
 * holds all of them in a single (ZIP) file. The down side is that any
 * modifications to the cache require re-writing the entire ZIP file. This
 * can cause the ZIP file to become corrupted if interrupted in mid-update,
 * thus requiring the re-population of the cache on next application activation
 * (though the overhead in this case is not prohibitvely high...)
 */
    public static final String ZIP_FILE = "cache.zip";
    private static final AsynchronousFileCacheBackingCreator<ZippedFileCacheBacking>    defaultCreator=
            new AsynchronousFileCacheBackingCreator<ZippedFileCacheBacking>() {
                public ZippedFileCacheBacking create(File cacheDir) {
                    return new ZippedFileCacheBacking(cacheDir);
                }
        };
    private final File  zipFile;
    public ZippedFileCacheBacking(File cacheDir) {
        super(cacheDir);
        zipFile = new File(cacheDir, ZIP_FILE);
    }
    public File getZipFile () {
        return zipFile;
    }
    public static final ZippedFileCacheBacking createBacking (File cacheDir) {
        return createBacking(cacheDir, defaultCreator);
    }
    @Override
    protected void writeClassBytes(String key, byte[] bytes) throws Exception {
        File                  outFile=getZipFile();
        Map<String,byte[]>    entriesMap;
        try {
            entriesMap = readZipClassBytes(outFile);
        } catch(Exception e) {
            if ((logger != null) && logger.isTraceEnabled()) {
                logger.warn("writeClassBytes(" + outFile + ")[" + key + "]"
                          + " failed (" + e.getClass().getSimpleName() + ")"
                          + " to read current data: " + e.getMessage(),
                            e);
            }
            
            FileUtil.deleteContents(outFile);
            return;
        }
        if (entriesMap.isEmpty()) {
            entriesMap = Collections.singletonMap(key, bytes);
        } else {
            entriesMap.put(key, bytes);
        }
        try {
            writeZipClassBytes(outFile, entriesMap);
        } catch(Exception e) {
            if ((logger != null) && logger.isTraceEnabled()) {
                logger.warn("writeClassBytes(" + outFile + ")[" + key + "]"
                          + " failed (" + e.getClass().getSimpleName() + ")"
                          + " to write updated data: " + e.getMessage(),
                            e);
            }
            
            FileUtil.deleteContents(outFile);
        }
    }
    @Override
    protected void removeClassBytes(String key) throws Exception {
        File                  outFile=getZipFile();
        Map<String,byte[]>    entriesMap;
        try {
            entriesMap = readZipClassBytes(outFile);
        } catch(Exception e) {
            if ((logger != null) && logger.isTraceEnabled()) {
                logger.warn("removeClassBytes(" + outFile + ")[" + key + "]"
                          + " failed (" + e.getClass().getSimpleName() + ")"
                          + " to read current data: " + e.getMessage(),
                            e);
            }
            
            FileUtil.deleteContents(outFile);
            return;
        }
        if (!entriesMap.isEmpty()) {
            if (entriesMap.remove(key) == null) {
                return; // not in the data file to begin with so nothing to update
            }
        }
        try {
            writeZipClassBytes(outFile, entriesMap);
        } catch(Exception e) {
            if ((logger != null) && logger.isTraceEnabled()) {
                logger.warn("removeClassBytes(" + outFile + ")[" + key + "]"
                          + " failed (" + e.getClass().getSimpleName() + ")"
                          + " to write updated data: " + e.getMessage(),
                            e);
            }
            
            FileUtil.deleteContents(outFile);
        }
    }
    @Override
    protected Map<String, byte[]> readClassBytes(Map<String, IndexEntry> indexMap, File cacheDir) {
        File                dataFile=new File(cacheDir, ZIP_FILE);
        Map<String,byte[]>  entriesMap;
        boolean             okEntries=true;
        try {
            entriesMap = readZipClassBytes(dataFile);
        } catch(Exception e) {
            if ((logger != null) && logger.isTraceEnabled()) {
                logger.warn("Failed (" + e.getClass().getSimpleName() + ")"
                          + " to read zip entries from " + dataFile
                          + ": " + e.getMessage(),
                          e);
            }
            entriesMap = new TreeMap<String,byte[]>();
            okEntries = false;
        }
        if (!syncClassBytesEntries(dataFile, indexMap, entriesMap)) {
            okEntries = false;
        }
        if (!okEntries) {
            FileUtil.deleteContents(dataFile);
            if (!entriesMap.isEmpty()) {
                entriesMap.clear();
            }
        }
        syncIndexEntries(dataFile, indexMap, entriesMap);
        return entriesMap;
    }
    // remove all non-ignored entries that have no class bytes
    protected Collection<String> syncIndexEntries (File dataFile, Map<String, IndexEntry> indexMap, Map<String,byte[]>  entriesMap) {
        Collection<String>  toDelete=null;
        for (Map.Entry<String, IndexEntry> ie : indexMap.entrySet()) {
            String      key=ie.getKey();
            IndexEntry  indexEntry=ie.getValue();
            if (indexEntry.ignored) {
                continue;   // ignored entries have no class bytes
            }
            if (entriesMap.containsKey(key)) {
                continue;
            }
            if ((logger != null) && logger.isTraceEnabled()) {
                logger.debug("syncIndexEntries(" + dataFile + ")[" + key + "] no class bytes");
            }
            if (toDelete == null) {
                toDelete = new TreeSet<String>();
            }
            toDelete.add(key);
        }
        if (toDelete == null) {
            return Collections.emptySet();
        }
        for (String key : toDelete) {
            indexMap.remove(key);
        }
        return toDelete;
    }
    // check if all class bytes entries are valid
    protected boolean syncClassBytesEntries (File dataFile, Map<String, IndexEntry> indexMap, Map<String,byte[]>  entriesMap) {
        boolean okEntries=true;
        for (Map.Entry<String,byte[]> bytesEntry : entriesMap.entrySet()) {
            String      key=bytesEntry.getKey();
            IndexEntry  indexEntry=indexMap.get(key);
            // ignored entries should have no bytes
            if ((indexEntry == null) || indexEntry.ignored) {
                if ((logger != null) && logger.isTraceEnabled()) {
                    logger.debug("syncClassBytesEntries(" + dataFile + ")[" + key + "] bad index entry");
                }
                okEntries = false;
                continue;
            }
            long    crc=crc(bytesEntry.getValue());
            if (crc != indexEntry.crcWeaved) {
                if ((logger != null) && logger.isTraceEnabled()) {
                    logger.debug("syncClassBytesEntries(" + dataFile + ")[" + key + "]"
                               + " mismatched CRC - expected=" + indexEntry.crcWeaved + "/got=" + crc);
                }
                indexMap.remove(key);
                okEntries = false;
                continue;
            }
        }
        return okEntries;
    }
    @Override
    protected IndexEntry resolveIndexMapEntry(File cacheDir, IndexEntry ie) {
        if (cacheDir.exists()) {
            return ie;  // we will take care of non-existing index entries in the readClassBytes method
        } else {
            return null;
        }
    }
    public static final Map<String,byte[]> readZipClassBytes (File file) throws IOException {
        if (!file.canRead()) {
            return Collections.emptyMap();
        }
        Map<String,byte[]>      result=new TreeMap<String,byte[]>();
        byte[]                  copyBuf=new byte[4096];
        ByteArrayOutputStream   out=new ByteArrayOutputStream(copyBuf.length);
        ZipFile                 zipFile=new ZipFile(file);
        try {
            for (Enumeration<? extends ZipEntry> entries=zipFile.entries(); (entries != null) && entries.hasMoreElements(); ) {
                ZipEntry    e=entries.nextElement();
                String      name=e.getName();
                if (LangUtil.isEmpty(name)) {
                    continue;
                }
                out.reset();
                InputStream zipStream=zipFile.getInputStream(e);
                try {
                    for (int    nRead=zipStream.read(copyBuf); nRead != (-1); nRead=zipStream.read(copyBuf)) {
                        out.write(copyBuf, 0, nRead);
                    }
                } finally {
                    zipStream.close();
                }
                byte[]  data=out.toByteArray(), prev=result.put(name, data);
                if (prev != null) {
                    throw new StreamCorruptedException("Multiple entries for " + name);
                }
            }
        } finally {
            zipFile.close();
        }
        return result;
    }
    
    public static final void writeZipClassBytes (File file, Map<String,byte[]> entriesMap) throws IOException {
        if (entriesMap.isEmpty()) {
            FileUtil.deleteContents(file);
            return;
        }
        File	zipDir=file.getParentFile();
        if ((!zipDir.exists()) && (!zipDir.mkdirs())) {
            throw new IOException("Failed to create path to " + zipDir.getAbsolutePath());
        }
        ZipOutputStream zipOut=new ZipOutputStream(new BufferedOutputStream(new FileOutputStream(file), 4096));
        try {
            for (Map.Entry<String,byte[]> bytesEntry : entriesMap.entrySet()) {
                String      key=bytesEntry.getKey();
                byte[]      bytes=bytesEntry.getValue();
                zipOut.putNextEntry(new ZipEntry(key));
                zipOut.write(bytes);
                zipOut.closeEntry();
            }
        } finally {
            zipOut.close();
        }
    }
======= df1823b:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

 * Copyright (c) 2012 Contributors.
 * All rights reserved.
 * This program and the accompanying materials are made available
 * under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution and is available at
 * http://eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Lyor Goldstein (vmware)	add support for weaved class being re-defined
 *******************************************************************************/
 */
    /**
     * Prefix used in URL(s) that reference a resource inside a JAR
     */
    public static final String	JAR_URL_PREFIX="jar:";
    /**
     * Separator used in URL(s) that reference a resource inside a JAR
     * to denote the sub-path inside the JAR
     */
    public static final char	RESOURCE_SUBPATH_SEPARATOR='!';
    protected File ensureTempFolderExists () throws IllegalStateException {
    	synchronized(TEMP_SUBFOLDER_NAME) {
    		if (testTempFolder == null) {
    			File	parent=detectTargetFolder();
    			testTempFolder = new File(parent, TEMP_SUBFOLDER_NAME);
    		}
    	}
    	return ensureFolderExists(testTempFolder);
    }
    protected File detectTargetFolder () throws IllegalStateException {
    	synchronized(TEMP_SUBFOLDER_NAME) {
    		if (targetFolder == null) {
    			if ((targetFolder=detectTargetFolder(getClass())) == null) {
    				throw new IllegalStateException("Failed to detect target folder");
    			}
    		}
    	}
    	return targetFolder;
    }
    protected File createTempFile (String prefix, String suffix) throws IOException {
    	File	destFolder=ensureTempFolderExists();
    	return File.createTempFile(prefix, suffix, destFolder);
    }
    public static final File ensureFolderExists (File folder) throws IllegalStateException {
    	if (folder == null) {
    		throw new IllegalArgumentException("No folder to ensure existence");
    	}
    	if ((!folder.exists()) && (!folder.mkdirs())) {
    		throw new IllegalStateException("Failed to create " + folder.getAbsolutePath());
    	}
    	return folder;
    }
    /**
     * @param anchor An anchor {@link Class} whose container we want to use
     * as the starting point for the &quot;target&quot; folder lookup up the
     * hierarchy
     * @return The &quot;target&quot; <U>folder</U> - <code>null</code> if not found
     * @see #detectTargetFolder(File)
     */
    public static final File detectTargetFolder (Class<?> anchor) {
    	return detectTargetFolder(getClassContainerLocationFile(anchor));
    }
    
    /**
     * @param anchorFile An anchor {@link File) we want to use
     * as the starting point for the &quot;target&quot; folder lookup up the
     * hierarchy
     * @return The &quot;target&quot; <U>folder</U> - <code>null</code> if not found
     */
    public static final File detectTargetFolder (File anchorFile) {
    	for (File	file=anchorFile; file != null; file=file.getParentFile()) {
    		if (!file.isDirectory()) {
    			continue;
    		}
    		
    		String	name=file.getName();
    		if ("bin".equals(name) || "src".equals(name)) {
    			File	parent=file.getParentFile();
    			return new File(parent, "target");
    		}
    	}
    	return null;
    }
    /**
     * @param clazz A {@link Class} object
     * @return A {@link File} of the location of the class bytes container
     * - e.g., the root folder, the containing JAR, etc.. Returns
     * <code>null</code> if location could not be resolved
     * @throws IllegalArgumentException If location is not a valid
     * {@link File} location
     * @see #getClassContainerLocationURI(Class)
     * @see File#File(URI) 
     */
    public static File getClassContainerLocationFile (Class<?> clazz)
            throws IllegalArgumentException {
        try {
            URI uri=getClassContainerLocationURI(clazz);
            return (uri == null) ? null : new File(uri);
        } catch(URISyntaxException e) {
            throw new IllegalArgumentException(e.getClass().getSimpleName() + ": " + e.getMessage(), e);
        }
    }
    /**
     * @param clazz A {@link Class} object
     * @return A {@link URI} to the location of the class bytes container
     * - e.g., the root folder, the containing JAR, etc.. Returns
     * <code>null</code> if location could not be resolved
     * @throws URISyntaxException if location is not a valid URI
     * @see #getClassContainerLocationURL(Class)
     */
    public static URI getClassContainerLocationURI (Class<?> clazz) throws URISyntaxException {
        URL url=getClassContainerLocationURL(clazz);
        return (url == null) ? null : url.toURI();
    }
    /**
     * @param clazz A {@link Class} object
     * @return A {@link URL} to the location of the class bytes container
     * - e.g., the root folder, the containing JAR, etc.. Returns
     * <code>null</code> if location could not be resolved
     */
    public static URL getClassContainerLocationURL (Class<?> clazz) {
        ProtectionDomain    pd=clazz.getProtectionDomain();
        CodeSource          cs=(pd == null) ? null : pd.getCodeSource();
        URL					url=(cs == null) ? null : cs.getLocation();
        if (url == null) {
        	ClassLoader	cl=getDefaultClassLoader(clazz);
        	String		className=clazz.getName().replace('.', '/') + ".class";
        	if ((url=cl.getResource(className)) == null) {
        		return null;
        	}
        	
        	String	srcForm=getURLSource(url);
        	if (LangUtil.isEmpty(srcForm)) {
        		return null;
        	}
        	try {
        		url = new URL(srcForm);
        	} catch(MalformedURLException e) {
        		throw new IllegalArgumentException("getClassContainerLocationURL(" + clazz.getName() + ")"
        										  + "Failed to create URL=" + srcForm + " from " + url.toExternalForm()
        										  + ": " + e.getMessage());
        	}
        }
        return url;
    }
    /**
     * @param anchor An &quot;anchor&quot; {@link Class} to be used in case
     * no thread context loader is available
     * @return A {@link ClassLoader} to be used by the caller. The loader is
     * resolved in the following manner:</P></BR>
     * <UL>
     *      <LI>
     *      If a non-<code>null</code> loader is returned from the
     *      {@link Thread#getContextClassLoader()} call then use it.
     *      </LI>
     *      
     *      <LI>
     *      Otherwise, use the same loader that was used to load the anchor class.
     *      </LI>
     * </UL>
     * @throws IllegalArgumentException if no anchor class provided (regardless of
     * whether it is used or not) 
     */
    public static ClassLoader getDefaultClassLoader(Class<?> anchor) {
        if (anchor == null) {
            throw new IllegalArgumentException("No anchor class provided");
        }
        Thread      t=Thread.currentThread();
        ClassLoader cl=t.getContextClassLoader();
        if (cl == null) {
            // No thread context class loader -> use class loader of this class.
            cl = anchor.getClassLoader();
        }
        if (cl == null) {	// no class loader - assume system
        	cl = ClassLoader.getSystemClassLoader();
        }
        return cl;
        
    }
    public static final String getURLSource (File file) {
    	return getURLSource((file == null) ? null : file.toURI());
    }
    public static final String getURLSource (URI uri) {
    	return getURLSource((uri == null) ? null : uri.toString());
    }
    /**
     * @param url The {@link URL} value - ignored if <code>null</code>
     * @return The URL(s) source path where {@link #JAR_URL_PREFIX} and
     * any sub-resource are stripped
     * @see #getURLSource(String)
     */
    public static final String getURLSource (URL url) {
    	return getURLSource((url == null) ? null : url.toExternalForm());
    }
    
    /**
     * @param externalForm The {@link URL#toExternalForm()} string - ignored if
     * <code>null</code>/empty
     * @return The URL(s) source path where {@link #JAR_URL_PREFIX} and
     * any sub-resource are stripped
     */
    public static final String getURLSource (String externalForm) {
    	if (LangUtil.isEmpty(url)) {
    		return url;
    	}
    	url = stripJarURLPrefix(externalForm);
    	if (LangUtil.isEmpty(url)){
    		return url;
    	}
    	
    	int	sepPos=url.indexOf(RESOURCE_SUBPATH_SEPARATOR);
    	if (sepPos < 0) {
    		return adjustURLPathValue(url);
    	} else {
    		return adjustURLPathValue(url.substring(0, sepPos));
    	}
    }
    /**
     * @param path A URL path value
     * @return The path after stripping any trailing '/' provided the path
     * is not '/' itself
     */
    public static final String adjustURLPathValue(final String path) {
        final int   pathLen=LangUtil.isEmpty(path) ? 0 : path.length();
        if ((pathLen <= 1) || (path.charAt(pathLen - 1) != '/')) {
            return path;
        }
        return path.substring(0, pathLen - 1);
    }
    public static final String adjustURLPathValue(URL url) {
        return adjustURLPathValue((url == null) ? null : url.getPath());
    }
    	if (LangUtil.isEmpty(url)) {
    		return url;
    	}
    	if (url.startsWith(JAR_URL_PREFIX)) {
    		return url.substring(JAR_URL_PREFIX.length());
    	}    	
    	
    	return url;
    protected static final void writeIndex (File indexFile, IndexEntry ... entries) throws IOException {
        writeIndex(indexFile, LangUtil.isEmpty(entries) ? Collections.<IndexEntry>emptyList() : Arrays.asList(entries));
    }
    protected static final void writeIndex (File indexFile, Collection<? extends IndexEntry> entries) throws IOException {
        File    indexDir=indexFile.getParentFile();
        if ((!indexDir.exists()) && (!indexDir.mkdirs())) {
            throw new IOException("Failed to create path to " + indexFile.getAbsolutePath());
        }
        int             numEntries=LangUtil.isEmpty(entries) ? 0 : entries.size();
        IndexEntry[]    entryValues=(numEntries <= 0) ? null : entries.toArray(new IndexEntry[numEntries]);
        // if no entries, simply delete the index file
        if (LangUtil.isEmpty(entryValues)) {
            if (indexFile.exists() && (!indexFile.delete())) {
                throw new StreamCorruptedException("Failed to clean up index file at " + indexFile.getAbsolutePath());
            }
            return;
        }
        ObjectOutputStream oos=new ObjectOutputStream(new BufferedOutputStream(new FileOutputStream(indexFile), 4096));
        try {
            oos.writeObject(entryValues);
        } finally {
            oos.close();
        }
    }
    public static final void assertArrayEquals (String msg, byte[] expected, byte[] actual) {
    	int	eLen=LangUtil.isEmpty(expected) ? 0 : expected.length;
    	int	aLen=LangUtil.isEmpty(actual) ? 0 : expected.length;
    	assertEquals(msg + "[mismatched length]", eLen, aLen);
    	for (int	index=0; index < eLen; index++) {
    		byte	eb=expected[index], ab=actual[index];
    		if (eb != ab) {
    			fail(msg + ": Mismatched value at index=" + index
    			   + " - " + ab + " instead of " + eb
    			   + ": expected=" + Arrays.toString(expected) + ", actual=" + Arrays.toString(actual));
    		}
    	}
    }
======= df1823b:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

 * Copyright (c) 2012 Contributors.
 * All rights reserved.
 * This program and the accompanying materials are made available
 * under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution and is available at
 * http://eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   Lyor Goldstein (vmware)	add support for weaved class being re-defined
 *******************************************************************************/
 */
    private File  cacheDir, indexFile;
    protected final byte[]    bytes=new byte[Byte.MAX_VALUE];
    protected final Random    random=new Random(System.nanoTime());
    @Override
    public void setUp () throws Exception {
    	super.setUp();
    	cleanupCache();
    	
        random.nextBytes(bytes);
    }
    @Override
    public void tearDown () throws Exception {
    	cleanupCache();
    	super.tearDown();
    }
   
    protected void cleanupCache() {
    	if (indexFile != null) {
    		if (FileUtil.deleteContents(indexFile) > 0) {
    			System.out.println("Deleted " + indexFile);
    		}
    		indexFile = null;
    	}
    	if (cacheDir != null) {
    		if (FileUtil.deleteContents(cacheDir) > 0) {
    			System.out.println("Deleted " + cacheDir);
    		}
    		cacheDir = null;
    	}
    }
    protected File getIndexFile () {
    	if (indexFile == null) {
    		File	parent=getCacheDir();
    		indexFile=new File(parent, AbstractIndexedFileCacheBacking.INDEX_FILE);
    	}
    	return indexFile;
    }
    protected File getCacheDir () {
    	if (cacheDir == null) {
    		File	targetDir=detectTargetFolder();
    		cacheDir = new File(targetDir, "dir-" + String.valueOf(Math.random()));
    	}
    	
    	return ensureFolderExists(cacheDir);
    }
    protected abstract AsynchronousFileCacheBacking createFileBacking (File dir);
    public void testDeleteIndexFileOnEmptyIndex () throws Exception {
        IndexEntry[]    entries={
                createIndexEntry("weaved-empty", false, false, bytes, bytes),
                createIndexEntry("generated-empty", true, false, bytes, bytes)
            };
        File	cacheIndex=getIndexFile();
        writeIndex(cacheIndex, entries);
        assertTrue("No initial index file available: " + cacheIndex, cacheIndex.canRead());
        AsynchronousFileCacheBacking    cache=createFileBacking(getCacheDir());
        // the call should read an empty index since no data files exist
        Map<String, IndexEntry>         indexMap=cache.getIndexMap();
        assertEquals("Mismatched index size", 0, indexMap.size());
        // no data files were created
        Map<String, byte[]> bytesMap=cache.getBytesMap(); 
        assertEquals("Mismatched bytes size", 0, bytesMap.size());
        
        writeIndex(cache.getIndexFile(), cache.getIndexEntries());
        assertFalse("Index file still available: " + cacheIndex, cacheIndex.canRead());
    }
    protected long generateNewBytes () {
        final long          CRC=AbstractCacheBacking.crc(bytes);
        long                crc=CRC;
        // 8 tries should be enough to find a non-matching CRC...
        for (int    index=0; (index < Byte.SIZE) && (CRC == crc) && (crc != -1L); index++) {
            random.nextBytes(bytes);
            crc = AbstractCacheBacking.crc(bytes);
        }
        assertTrue("Could not generate different CRC for " + CRC, crc != CRC);
        return crc;
    }
    protected Map<String, File> createDataFiles (IndexEntry ... entries) throws IOException {
        return createDataFiles(LangUtil.isEmpty(entries) ? Collections.<IndexEntry>emptyList() : Arrays.asList(entries));
    }
    protected Map<String, File> createDataFiles (Collection<? extends IndexEntry> entries) throws IOException {
        if (LangUtil.isEmpty(entries)) {
            return Collections.emptyMap();
        }
        Map<String, File>  files=new TreeMap<String, File>();
        for (IndexEntry entry : entries) {
            File    file=createDataFile(entry);
            if (file != null) {
                files.put(entry.key, file);
            }
        }
        return files;
    }
    protected File createDataFile (IndexEntry entry) throws IOException {
        return createDataFile(entry, entry.ignored ? null : bytes);
    }
    protected File createDataFile (IndexEntry entry, byte[] dataBytes) throws IOException {
        return createDataFile(entry.key, dataBytes);
    }
    protected File createDataFile (String key, byte[] dataBytes) throws IOException {
        if (LangUtil.isEmpty(dataBytes)) {
            return null;
        }
        
        File    		parent=getCacheDir(), file=new File(parent, key);
        OutputStream    out=new FileOutputStream(file);
        try {
            out.write(dataBytes);
        } finally { 
            out.close();
        }
        return file;
    }
    protected static final IndexEntry createIgnoredEntry (String key) {
        return createIndexEntry(key, false, true, null, null);
    }
    protected static final IndexEntry createIndexEntry (String key, boolean generated, boolean ignored, byte[] bytes, byte[] originalBytes) {
        IndexEntry  entry=new IndexEntry();
        entry.key = key;
        entry.generated = generated;
        entry.ignored = ignored;
        if (ignored) {
            assertFalse(key + " ignored cannot be generated", generated);
        } else {
        	entry.crcClass = AbstractCacheBacking.crc(originalBytes);
            entry.crcWeaved = AbstractCacheBacking.crc(bytes);
        }
        
        return entry;
    }
======= df1823b:"weaver/testsrc/org/aspectj/weaver/tools/cache/CacheTests.java"

======= df1823b:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultCacheKeyResolverTest.java"

======= df1823b:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= df1823b:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

 * Copyright (c) 2012 VMware, Inc.
 * 
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/epl-v10.html 
 *  
 * Contributors:
 *  Lyor Goldstein
 *******************************************************************************/
 * @author Lyor Goldstein
 */
    public FlatFileCacheBackingTest() {
        super();
    }
    @Override
    protected FlatFileCacheBacking createFileBacking(File dir) {
        return new FlatFileCacheBacking(dir);
    }
    public void testReadIndex () throws IOException {
        IndexEntry[]    entries={
                createIgnoredEntry("ignored"),
                createIndexEntry("weaved", false, false, bytes, bytes),
                createIndexEntry("generated", true, false, bytes, bytes)
            };
        File	indexFile=getIndexFile();
        writeIndex(indexFile, entries);
        Map<String, File> dataFiles=createDataFiles(entries);
        File							cacheDir=getCacheDir();
        AsynchronousFileCacheBacking    cache=createFileBacking(cacheDir);
        Map<String, IndexEntry> 		indexMap=cache.getIndexMap();
        assertEquals("Mismatched index size", entries.length, indexMap.size());
        Map<String, byte[]> bytesMap=cache.getBytesMap(); 
        assertEquals("Mismatched bytes size", dataFiles.size() /* the ignored one has no file */, bytesMap.size());
        
        for (IndexEntry entry : entries) {
            String  key=entry.key;
            assertNotNull("Missing entry for key=" + key, indexMap.get(key));
            
            if (entry.ignored) {
                assertNull("Unexpected bytes for ignored key=" + key, bytesMap.get(key));
            } else {
                assertArrayEquals("Mismatched contents for key=" + key, bytes, bytesMap.get(key));
            }
        }
    }
    public void testIgnoredBadCrcDataFiles () throws Exception {
        IndexEntry[]    entries={
                createIndexEntry("weaved-goodData", false, false, bytes, bytes),
                createIndexEntry("badData-weaved", false, false, bytes, bytes),
                createIndexEntry("generated-goodData", true, false, bytes, bytes),
                createIndexEntry("badData-generated", true, false, bytes, bytes)
            };
        File	indexFile=getIndexFile();
        writeIndex(indexFile, entries);
        Map<String,File>    dataFiles=createDataFiles(entries);
        long                newCrc=generateNewBytes();
        assertTrue("Bad new CRC", newCrc != (-1L));
        Map<String,File>    badFiles=new TreeMap<String, File>();
        for (IndexEntry entry : entries) {
            String  key=entry.key;
            if (key.startsWith("badData")) {
                File            file=dataFiles.get(key);
                OutputStream    out=new FileOutputStream(file);
                try {
                    out.write(bytes);
                } finally {
                    out.close();
                }
                dataFiles.remove(key);
                badFiles.put(key, file);
            }
        }
        File					cacheDir=getCacheDir();
        FlatFileCacheBacking    cache=createFileBacking(cacheDir);
        Map<String, IndexEntry> indexMap=cache.getIndexMap();
        assertEquals("Mismatched index size", dataFiles.size(), indexMap.size());
        Map<String, byte[]> bytesMap=cache.getBytesMap(); 
        assertEquals("Mismatched bytes size", dataFiles.size(), bytesMap.size());
        for (Map.Entry<String,File> badEntry : badFiles.entrySet()) {
            String  key=badEntry.getKey();
            assertFalse("Unexpectedly indexed: " + key, indexMap.containsKey(key));
            assertFalse("Unexpectedly loaded: " + key, bytesMap.containsKey(key));
            File    file=badEntry.getValue();
            assertFalse("Unexpectedly still readable: " + key, file.canRead());
        }
    }
    public void testSkipMissingDataFileOnReadIndex () throws IOException {
        IndexEntry[]    entries={
                createIndexEntry("weaved-noData", false, false, null, null),
                createIndexEntry("withData-weaved", false, false, bytes, bytes),
                createIndexEntry("generated-noData", true, false, null, null),
                createIndexEntry("withData-generated", true, false, bytes, bytes)
            };
        File	indexFile=getIndexFile();
        writeIndex(indexFile, entries);
        Map<String,File>    dataFiles=new TreeMap<String, File>();
        for (IndexEntry entry : entries) {
            String  key=entry.key;
            if (key.startsWith("withData")) {
                dataFiles.put(key, createDataFile(entry, bytes));
            }
        }
        File					cacheDir=getCacheDir();
        FlatFileCacheBacking    cache=createFileBacking(cacheDir);
        Map<String, IndexEntry> indexMap=cache.getIndexMap();
        assertEquals("Mismatched index size", dataFiles.size(), indexMap.size());
        Map<String, byte[]> bytesMap=cache.getBytesMap(); 
        assertEquals("Mismatched bytes size", dataFiles.size(), bytesMap.size());
        for (IndexEntry entry : entries) {
            String  key=entry.key;
            if (key.startsWith("withData")) {
                assertTrue("Not indexed: " + key, indexMap.containsKey(key));
                assertTrue("Not loaded: " + key, bytesMap.containsKey(key));
            } else {
                assertFalse("Unexpectedly indexed: " + key, indexMap.containsKey(key));
                assertFalse("Unexpectedly loaded: " + key, bytesMap.containsKey(key));
            }
        }
    }
======= df1823b:"weaver/testsrc/org/aspectj/weaver/tools/cache/SimpleClassCacheTest.java"

======= df1823b:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"

======= df1823b:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"

======= df1823b:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"

======= df1823b:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"

======= df1823b:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"

 * Copyright (c) 2012 VMware, Inc.
 *
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 * Lyor Goldstein
 */
 * 
 */
    public ZippedFileCacheBackingTest() {
        super();
    }
    public void testReadIndex () throws Exception {
        IndexEntry[]    entries={
                createIgnoredEntry("ignored"),
                createIndexEntry("weaved", false, false, bytes, bytes),
                createIndexEntry("generated", true, false, bytes, bytes)
            };
        File	indexFile=getIndexFile();
        writeIndex(indexFile, entries);
        Map<String,byte[]>  entriesMap=new TreeMap<String,byte[]>();
        for (IndexEntry ie : entries) {
            if (ie.ignored) {
                continue;
            }
            entriesMap.put(ie.key, bytes);
        }
        File	zipFile=getZipFile();
        ZippedFileCacheBacking.writeZipClassBytes(zipFile, entriesMap);
        File							cacheDir=getCacheDir();
        AsynchronousFileCacheBacking    cache=createFileBacking(cacheDir);
        Map<String, IndexEntry>			indexMap=cache.getIndexMap();
        assertEquals("Mismatched index size", entries.length, indexMap.size());
        Map<String, byte[]> bytesMap=cache.getBytesMap(); 
        assertEquals("Mismatched bytes size", entriesMap.size() /* the ignored one has no file */, bytesMap.size());
        
        for (IndexEntry entry : entries) {
            String  key=entry.key;
            assertNotNull("Missing entry for key=" + key, indexMap.get(key));
            
            if (entry.ignored) {
                assertNull("Unexpected bytes for ignored key=" + key, bytesMap.get(key));
            } else {
                assertArrayEquals("Mismatched contents for key=" + key, bytes, bytesMap.get(key));
            }
        }
    }
    public void testReadWriteZipClassBytes () throws IOException {
        Map<String,byte[]>  entriesMap=new TreeMap<String,byte[]>();
        for (int    index=0; index < Byte.SIZE; index++) {
            String  name="classBytes#" + index;
            random.nextBytes(bytes);
            entriesMap.put(name, bytes);
        }
        File	zipFile=getZipFile();
        ZippedFileCacheBacking.writeZipClassBytes(zipFile, entriesMap);
        Map<String, byte[]> bytesMap=ZippedFileCacheBacking.readZipClassBytes(zipFile);
        assertEquals("Mismatched recovered entries size", entriesMap.size(), bytesMap.size());
        for (Map.Entry<String,byte[]> bytesEntry : entriesMap.entrySet()) {
            String  key=bytesEntry.getKey();
            byte[]  expected=bytesEntry.getValue(), actual=bytesMap.get(key);
            assertArrayEquals("Mismatched data for " + key, expected, actual);
        }
    }
    public void testReadClassBytes () throws IOException {
        IndexEntry[]    entries={
                createIgnoredEntry("ignoredReadClassBytes"),
                createIndexEntry("weavedReadClassBytes", false, false, bytes, bytes),
                createIndexEntry("generatedReadClassBytes", true, false, bytes, bytes)
            };
        File	indexFile=getIndexFile();
        writeIndex(indexFile, entries);
        long newCrc=generateNewBytes();
        assertTrue("Bad new CRC", newCrc != (-1L));
        Map<String,byte[]>  entriesMap=new TreeMap<String,byte[]>();
        for (IndexEntry ie : entries) {
            if (ie.ignored) {
                continue;
            }
            entriesMap.put(ie.key, bytes);
        }
        File	zipFile=getZipFile();
        ZippedFileCacheBacking.writeZipClassBytes(zipFile, entriesMap);
        File							cacheDir=getCacheDir();
        AsynchronousFileCacheBacking    cache=createFileBacking(cacheDir);
        Map<String, IndexEntry> 		indexMap=cache.getIndexMap();
        assertEquals("Mismatched index size", 1 /* only the ignored entry */, indexMap.size());
        Map<String, byte[]> bytesMap=cache.getBytesMap(); 
        assertEquals("Non empty data bytes", 0, bytesMap.size());
        assertFalse("Zip file not deleted: " + zipFile, zipFile.canRead());
    }
    protected File getZipFile () {
    	if (zipTestFile == null) {
    		File	cacheDir=getCacheDir();
    		zipTestFile = new File(cacheDir, ZippedFileCacheBacking.ZIP_FILE);
    	}
    	return zipTestFile;
    }
    @Override
    @Override
    protected ZippedFileCacheBacking createFileBacking(File dir) {
        return new ZippedFileCacheBacking(dir);
    }

======= 9a3cc2b:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= 9a3cc2b:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= 9a3cc2b:"loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java"

======= 9a3cc2b:"org.aspectj.matcher/src/org/aspectj/weaver/tools/GeneratedClassHandler.java"

======= 9a3cc2b:"util/src/org/aspectj/util/LangUtil.java"

======= 9a3cc2b:"util/src/org/aspectj/util/LangUtil.java"

======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

 *     Matthew Webster, Adrian Colyer, John Kew + Lyor Goldstein (caching)
======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/CacheBacking.java"

 *   John Kew (vmware)         	initial implementation
 *   Lyor Goldstein (vmware)	add support for weaved class being re-defined
======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/CacheBacking.java"

======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/CacheStatistics.java"

======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/CachedClassEntry.java"

 *   John Kew (vmware)          initial implementation
 *   Lyor Goldstein (vmware)	add support for weaved class being re-defined
======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/CachedClassEntry.java"

    static enum EntryType {
        GENERATED,
        WEAVED,
        IGNORED,
    }
    private final CachedClassReference ref;
    private final byte[] weavedBytes;
    private final EntryType type;
    public CachedClassEntry(CachedClassReference ref, byte[] weavedBytes, EntryType type) {
        this.weavedBytes = weavedBytes;
        this.ref = ref;
        this.type = type;
    }
    public String getClassName() {
        return ref.getClassName();
    }
    public byte[] getBytes() {
        return weavedBytes;
    }
    public String getKey() {
        return ref.getKey();
    }
    public boolean isGenerated() {
        return type == EntryType.GENERATED;
    }
    public boolean isWeaved() {
        return type == EntryType.WEAVED;
    }
    public boolean isIgnored() {
        return type == EntryType.IGNORED;
    }
    @Override
    public int hashCode() {
        return getClassName().hashCode()
             + getKey().hashCode()
             + type.hashCode()
             ;
    }
    @Override
    public boolean equals(Object obj) {
        if (obj == null)
            return false;
        if (this == obj)
            return true;
        if (getClass() != obj.getClass())
            return false;
        CachedClassEntry    other=(CachedClassEntry) obj;
        if (getClassName().equals(other.getClassName())
         && getKey().equals(other.getKey())
         && (type == other.type)) {
             return true;
        } else {
            return false;
        }
    }
    @Override
    public String toString() {
        return getClassName() + "[" + type + "]";
    }
======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/CachedClassReference.java"

 *   John Kew (vmware)         	initial implementation
 *   Lyor Goldstein (vmware)	add support for weaved class being re-defined
======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/CachedClassReference.java"

======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/CachedClassReference.java"

======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/CachedClassReference.java"

        if (obj == null)
            return false;
        if (this == obj)
            return true;
        if (getClass() != obj.getClass())
            return false;
        CachedClassReference	other=(CachedClassReference) obj;
======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/DefaultCacheFactory.java"

======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/DefaultCacheKeyResolver.java"

======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

 *   John Kew (vmware)         	initial implementation
 *   Lyor Goldstein (vmware)	add support for weaved class being re-defined
======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

    @Override
    protected IndexEntry resolveIndexMapEntry (File cacheDir, IndexEntry ie) {
        File cacheEntry = new File(cacheDir, ie.key);
        if (ie.ignored || cacheEntry.canRead()) {
            return ie;
        } else {
            return null;
        }
    }
    @Override
======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/DefaultFileCacheBacking.java"

======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/GeneratedCachedClassHandler.java"

 *   John Kew (vmware)         	initial implementation
 *   Lyor Goldstein (vmware)	add support for weaved class being re-defined
======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/GeneratedCachedClassHandler.java"

======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java"

 *   John Kew (vmware)         	initial implementation
 *   Lyor Goldstein (vmware)	add support for weaved class being re-defined
======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java"

======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java"

======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java"

======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java"

======= 9a3cc2b:"weaver/src/org/aspectj/weaver/tools/cache/WeavedClassCache.java"

======= 9a3cc2b:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

 *   Lyor Goldstein (vmware)	add support for weaved class being re-defined
======= 9a3cc2b:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= 9a3cc2b:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= 9a3cc2b:"weaver/testsrc/org/aspectj/weaver/tools/cache/DefaultFileCacheBackingTest.java"

======= 9a3cc2b:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"

======= 9a3cc2b:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"

======= 9a3cc2b:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"

======= 9a3cc2b:"weaver/testsrc/org/aspectj/weaver/tools/cache/WeavedClassCacheTest.java"


======= b8ebdc3:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseTypeMunger.java"

======= b8ebdc3:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseTypeMunger.java"


======= 0d69bd3:"org.aspectj.matcher/src/org/aspectj/weaver/EnumAnnotationValue.java"

======= 0d69bd3:"org.aspectj.matcher/src/org/aspectj/weaver/StandardAnnotation.java"

======= 0d69bd3:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= 0d69bd3:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= 0d69bd3:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= 0d69bd3:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= 0d69bd3:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= 0d69bd3:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= 0d69bd3:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= 0d69bd3:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= 0d69bd3:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= 0d69bd3:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= 0d69bd3:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= 0d69bd3:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

  String s() default "xyz";
  Color color();
  declare parents: (@Foo(s="abc",color="AA") *) implements java.io.Serializable;
  // declare parents: (@Foo(color="AA", s="abc") *) implements java.io.Serializable;
======= 0d69bd3:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

  String s() default "xyz";
  Color color();
  declare parents: (@Foo(color="AA") *) implements java.io.Serializable;
  // declare parents: (@Foo(color="AA", s="abc") *) implements java.io.Serializable;
======= 0d69bd3:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

  String s() default "xyz";
  Color color();
  declare parents: (@Foo(s=Color.GREEN) *) implements java.io.Serializable;
  // declare parents: (@Foo(color="AA", s="abc") *) implements java.io.Serializable;
======= 0d69bd3:"tests/src/org/aspectj/systemtest/ajc172/Ajc172Tests.java"

    
      <compile files="Code.java" options="-1.5">
      	<message kind="error" text="Invalid annotation value 'AA', expected enum value"/>
      </compile>
    </ajc-test>
    
      <compile files="Code2.java" options="-1.5">
      	<message kind="error" text="Invalid annotation value 'AA', expected enum value"/>
      </compile>
    </ajc-test>
    
      <compile files="Code3.java" options="-1.5">
      	<message kind="error" text="Invalid annotation value 'AA', expected enum value"/>
      </compile>
    </ajc-test>

======= b9c7a19:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AstUtil.java"

======= b9c7a19:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AstUtil.java"

======= b9c7a19:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AstUtil.java"

======= b9c7a19:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

======= b9c7a19:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

======= b9c7a19:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

======= b9c7a19:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

  public static void main(String[] argv) {
    Code.foo();
  }
======= b9c7a19:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

  public static void main(String[] argv) {
    Bar bs = new Bar();
    String s = bs.bar("abc",null);
  }
======= b9c7a19:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

  public static void main(String[] argv) {
    Bar<String> bs = new Bar<String>();
    String s = bs.bar("abc",null);
  }
======= b9c7a19:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

  public static void main(String[] argv) {
    Bar<String> bs = new Bar<String>();
    String s = bs.bar("abc",new Integer(4));
  }
======= b9c7a19:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

  public interface I<ID extends Serializable> extends Persistable<ID> {
  }
  public static void foo() {}
  public boolean I.equals(Persistable<?> that) {
    return false;
  }
======= b9c7a19:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

  public interface I<ID extends Serializable> extends Persistable<ID> {
  }
  public static void foo() {}
  public Z I<Z>.bar(Z foo, Persistable<?> that) {
    return foo;
  }
======= b9c7a19:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

  public interface I<ID extends Serializable> extends Persistable<ID> {
  }
  public static void foo() {}
  public Z I<Z>.bar(Z foo, Persistable<?> that) {
    return foo;
  }
======= b9c7a19:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

  public interface I<ID extends Serializable> extends Persistable<ID> {
  }
  public static void foo() {}
  public <T> Z I<Z>.bar(Z foo, T that) {
    return foo;
  }
======= b9c7a19:"tests/src/org/aspectj/systemtest/AllTests17.java"

======= b9c7a19:"tests/src/org/aspectj/systemtest/AllTests17.java"

 * Copyright (c) 2012 Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
 * @author Andy Clement
 */ 
======= b9c7a19:"tests/src/org/aspectj/systemtest/AllTests17.java"

 * Copyright (c) 2008 Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
======= b9c7a19:"tests/src/org/aspectj/systemtest/AllTests17.java"

      <compile files="Code.aj" options="-1.5">
      </compile>
      <compile files="Clazz.java" options="-1.5"/>
    </ajc-test>
    
      <compile files="Code2.aj" outjar="azpect.jar" options="-1.5">
      </compile>
      <compile files="Clazz2.java" aspectpath="azpect.jar" options="-1.5"/>
    </ajc-test>
    
      <compile files="Code3.aj" outjar="azpect.jar" options="-1.5">
      </compile>
      <compile files="Clazz3.java" aspectpath="azpect.jar" options="-1.5"/>
    </ajc-test>
    
      <compile files="Code4.aj" outjar="azpect.jar" options="-1.5">
      </compile>
      <compile files="Clazz4.java" aspectpath="azpect.jar" options="-1.5"/>
    </ajc-test>

======= c2ff74f:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= c2ff74f:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"


======= 55ebaa1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

======= 55ebaa1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

    public void bizLoggerWithException(JoinPoint thisJoinPoint,Throwable e) {
  //  .....// do some stuff
    }
======= 55ebaa1:"tests/src/org/aspectj/systemtest/ajc171/Ajc171Tests.java"

      <compile files="X.java" options="-1.5">
      	<message kind="error" line="9" text="the advice annotation must specify a pointcut value"/>
      </compile>
    </ajc-test>

======= 76d695f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= 76d695f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= 76d695f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

  public void m() { // throws IOException {
    try (FileReader reader = new FileReader("test.txt")) {
      System.out.println("");
    }
  }
  declare soft: IOException: within(*);
======= 76d695f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

  public static void main(String[]argv) {
    try {
      new Code2().m();
    } catch (SoftException se) {
      System.out.println(se.getWrappedThrowable().getMessage());
    }
  }
  
  public void m() { 
    try (MyReader reader = new MyReader()) {
      System.out.println("");
    }
  }
  declare soft: MyException: within(Code2);
  public void close() throws MyException {
    throw new MyException("foo");
  }
  public MyException(String s) {
  }
======= 76d695f:"tests/src/org/aspectj/systemtest/ajc171/Ajc171Tests.java"

======= 76d695f:"tests/src/org/aspectj/systemtest/ajc171/Ajc171Tests.java"

 * Copyright (c) 2012 Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
 * @author Andy Clement
 */ 
      <compile files="Code.java" options="-1.7"/>
    </ajc-test>
      <compile files="Code2.java" options="-1.7"/>
      <run class="Code2">
          <line text="foo"/>
    </ajc-test>
      <compile files="Color.java Code.java" options="-1.5"/>

======= cbb6f5a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= cbb6f5a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"


======= 7c6e936:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= 7c6e936:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= 7c6e936:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

  public void run() {
    System.out.println("run()");
  }
======= 7c6e936:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

      System.out.println("JsoupFilter.getLogMessage()");
  public static void main(String []argv) {
    new JsoupFilter().run();
  }
======= 7c6e936:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

  public void m() {
    Color[] cs = Color.values();
  }
  after(): @annotation(Anno) {}
======= 7c6e936:"tests/src/org/aspectj/systemtest/ajc171/Ajc171Tests.java"

      <compile files="Code.java" options="-1.5"/>
      <!-- 
      <run class="de.scrum_master.galileo.filter.JsoupFilter">
        <stdout>
          <line text="JsoupFilter.getLogMessage()"/>
          <line text="run()"/>
        </stdout>
      </run>
      -->
    </ajc-test>
    <ajc-test dir="bugs171/pr386049" title="itd abstract">
      <compile files="de/scrum_master/galileo/filter/BasicFilter.java de/scrum_master/galileo/filter/JsoupFilter.java de/scrum_master/galileo/LoggingAspect.aj" options="-1.5"/>
      <run class="de.scrum_master.galileo.filter.JsoupFilter">
        <stdout>
          <line text="JsoupFilter.getLogMessage()"/>
          <line text="run()"/>
        </stdout>
      </run>
    </ajc-test>
======= 7c6e936:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"


======= bf949d3:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= bf949d3:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= bf949d3:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= bf949d3:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= bf949d3:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= bf949d3:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= bf949d3:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

      T aaa;
======= bf949d3:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

    InnerA someMethod(){
        A<String> as = new A<String>();
        return as.new InnerA();
    }
    InnerA someOtherMethod() {
        return someMethod();
    }
======= bf949d3:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= bf949d3:"tests/src/org/aspectj/systemtest/AllTests17.java"

======= bf949d3:"tests/src/org/aspectj/systemtest/AllTests17.java"

 * Copyright (c) 2012 Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
 * @author Andy Clement
 */ 
======= bf949d3:"tests/src/org/aspectj/systemtest/AllTests17.java"

 * Copyright (c) 2008 Contributors
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
======= bf949d3:"tests/src/org/aspectj/systemtest/AllTests17.java"

   

======= 5d0e186:"org.aspectj.matcher/src/org/aspectj/weaver/Dump.java"

======= 5d0e186:"org.aspectj.matcher/src/org/aspectj/weaver/Dump.java"


======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

    public B getSomeB(SuperB<String> b){
        return null;
    }
======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

  public B getSomeB(SuperB<String> b) { return null; }
 public static void main(String []argv) {
    A a = new A();
  }
======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

 public static void main(String []argv) {
    A a = new A();
    System.out.println(a.getSomeB(null));
  }
======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

    declare parents: A extends SuperA<String>;
======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

    declare parents: A extends SuperA<String>;
======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= a748303:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

  public static void main(String[] argv) {
    new A().getList();
  }
======= a748303:"tests/src/org/aspectj/systemtest/ajc170/Ajc170Tests.java"

======= a748303:"tests/src/org/aspectj/systemtest/ajc170/Ajc170Tests.java"

======= a748303:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= a748303:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"


======= ba9d43c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= ba9d43c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= ba9d43c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

    protected int getNumber(int k) {
        return -1*k;
    }
    pointcut pc():  call(T.new()) && !within(Bar); 
    T around():pc() {
        System.out.println("superaspect getNumber returns "+getNumber(2)); 
        System.out.println("abstract method returns "+method());
        Math.random(); //<-- works
        hashCode(); //<-- works
        return null;
    }    
    private void localMethod(){}
    protected abstract T method();
  protected LinkedList method() {
    System.out.println("Bar.method() running");
  }
    public static void main(String[] argv) {
    }
    public LinkedList bar() {
        new LinkedList();
        return null;
    }
======= ba9d43c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

    protected int getNumber(int k) {
        return -1*k;
    }
    pointcut pc():  call(T.new()); 
    T around():pc() {
        //getNumber(1); //<-- method call to superAspect fails   
        method();  // <-- method call to abstract local defined method fails
        //localMethod(); //<-- method call to local private method fails
        Math.random(); //<-- works
        hashCode(); //<-- works
        return null;
    }    
    private void localMethod(){}
    protected abstract T method();
    public LinkedList bar() {
        new LinkedList();
        return null;
    }
======= ba9d43c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

    protected int getNumber(int k) {
        return -1*k;
    }
    pointcut pc():  call(T.new()); 
    T around():pc() {
        getNumber(1); //<-- method call to superAspect fails   
        //method();  // <-- method call to abstract local defined method fails
        //localMethod(); //<-- method call to local private method fails
        Math.random(); //<-- works
        hashCode(); //<-- works
        return null;
    }    
    private void localMethod(){}
    protected abstract T method();
    public LinkedList bar() {
        new LinkedList();
        return null;
    }
======= ba9d43c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

    protected int getNumber(int k) {
        return -1*k;
    }
    pointcut pc():  call(T.new()); 
    T around():pc() {
        //getNumber(1); //<-- method call to superAspect fails   
        //method();  // <-- method call to abstract local defined method fails
        localMethod(); //<-- method call to local private method fails
        Math.random(); //<-- works
        hashCode(); //<-- works
        return null;
    }    
    private void localMethod(){}
    protected abstract T method();
    public LinkedList bar() {
        new LinkedList();
        return null;
    }
======= ba9d43c:"tests/src/org/aspectj/systemtest/ajc170/Ajc170Tests.java"


======= 89c178f:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"


  public static void main(String[] args) {
    R r = new R();
    System.out.println(r.getClass().getName());
  }
    pointcut createR() : call(R.new()) && !within(RAj);
    Object around() : createR()
    {
        System.out.println("aspect running");
        return new R1();
    }
======= be063b8:"tests/src/org/aspectj/systemtest/ajc170/Ajc170Tests.java"

 	<ajc-test dir="bugs170/pr376351" title="attribute issue with J7">
     <compile files="R.java R1.java" outjar="code.jar" options="-1.5"/>
     <compile files="RAj.java" options="-1.7 -Xlint:ignore" outjar="aspects.jar" classpath="code.jar"/>
     <compile inpath="code.jar" aspectpath="aspects.jar" options="-showWeaveInfo">
     <message kind="weave" text="Join point 'constructor-call(void R.&lt;init&gt;())'"/>
     </compile>
     <!-- 
     if we had a 1.7 vm we could use this:
     <compile files="RAj.java" options="-1.7 -Xlint:ignore"/>
     <run class="R" ltw="aop.xml">
     <stderr>
     <line text="org.aspectj.weaver.tools.Jdk14Trace error"/>
     <line text="Unsupported major.minor version 51.0"/>
     <line text="java.lang.UnsupportedClassVersionError: RAj :"/>
     </stderr>
     </run>
     -->
   </ajc-test>
======= be063b8:"weaver/src/org/aspectj/weaver/bcel/asm/StackMapAdder.java"

======= be063b8:"weaver/src/org/aspectj/weaver/bcel/asm/StackMapAdder.java"


        public static void main(String[] argv) {
                Color c = Color.R;
                switch (c) {
                }
        }
======= 62fca9a:"tests/src/org/aspectj/systemtest/ajc170/Ajc170Tests.java"

 	<ajc-test dir="bugs170/pr376139" title="switch on enum">
     <compile files="Code.java" options="-1.5"/>
     <run class="Code"/>
   </ajc-test>

======= f85631f:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/PointcutEvaluationExpenseComparator.java"

======= f85631f:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/PointcutEvaluationExpenseComparator.java"

======= f85631f:"tests/src/org/aspectj/systemtest/ajc170/Ajc170Tests.java"


======= 549d227:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/ResolvedType.java"

======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/TypeFactory.java"

======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariableReferenceType.java"

 * Copyright (c) 2005-2012 Contributors.
======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariableReferenceType.java"

 * ReferenceType pointing to a type variable. The delegate for this reference type is the upperbound on the type variable (so
======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariableReferenceType.java"

======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariableReferenceType.java"

======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/UnresolvedType.java"

======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/UnresolvedTypeVariableReferenceType.java"

======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/World.java"

======= 549d227:"org.aspectj.matcher/src/org/aspectj/weaver/World.java"


======= 6defb4e:"bridge/src/org/aspectj/bridge/context/CompilationAndWeavingContext.java"

 * Copyright (c) 2005-2012 Contributors.
======= 6defb4e:"bridge/src/org/aspectj/bridge/context/CompilationAndWeavingContext.java"

 *   Andy Clement			various fixes
 *   Trask Stanalker		#373195
 * This class is responsible for tracking progress through the various phases of compilation and weaving. 
 * When an exception occurs (or a message is issued, if desired), you can ask this class for a 
 * "stack trace" that gives information about what the compiler was doing at the time. 
 * The trace will say something like: 
 * "when matching pointcut xyz when matching shadow sss when weaving type ABC when weaving shadow mungers"
======= 6defb4e:"bridge/src/org/aspectj/bridge/context/CompilationAndWeavingContext.java"

======= 6defb4e:"bridge/src/org/aspectj/bridge/context/CompilationAndWeavingContext.java"

======= 6defb4e:"bridge/src/org/aspectj/bridge/context/CompilationAndWeavingContext.java"

======= 6defb4e:"bridge/src/org/aspectj/bridge/context/CompilationAndWeavingContext.java"


    public AspectTest() {}
    @DeclareParents(value="java.lang.Runnable+ || java.util.concurrent.Callable+",  defaultImpl=XImpl.class)
    //@DeclareParents(value="java.lang.Runnable+",  defaultImpl=XImpl.class)
    private X xImpl;
    public static void main(String []argv) {
      ((X)new Foo()).xxx();
      ((X)new Bar()).xxx();
    }
    interface X { void xxx();}
    class XImpl implements X {
      public XImpl() {}
      public void xxx() {}
    }
  public void run() {}
  public Object call() {return null;}
======= f37c56e:"tests/src/org/aspectj/systemtest/ajc170/Ajc170Tests.java"

   <ajc-test dir="bugs170/pr371998" title="BCException anno decp">
     <compile files="AspectTest.java" options="-1.5 -showWeaveInfo">
   	   <message kind="weave" text="Extending interface set for type 'Foo' (AspectTest.java) to include 'X' (AspectTest.java)"/>
   	   <message kind="weave" text="Type 'Foo' (AspectTest.java) has intertyped method from 'AspectTest' (AspectTest.java:'void X.xxx()')"/>
   	   <message kind="weave" text="Extending interface set for type 'Bar' (AspectTest.java) to include 'X' (AspectTest.java)"/>
   	   <message kind="weave" text="Type 'Bar' (AspectTest.java) has intertyped method from 'AspectTest' (AspectTest.java:'void X.xxx()')"/>
   	 </compile>
   	 <run class="AspectTest"/>
   </ajc-test>
   
======= f37c56e:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

======= f37c56e:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"


======= 89756cd:"org.aspectj.matcher/src/org/aspectj/weaver/TypeFactory.java"

======= 89756cd:"org.aspectj.matcher/src/org/aspectj/weaver/TypeFactory.java"

======= 89756cd:"tests/src/org/aspectj/systemtest/ajc170/Ajc170Tests.java"


======= 942da06:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= 942da06:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= 942da06:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= 942da06:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= 942da06:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= 942da06:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= 942da06:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"

======= 942da06:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"


======= 14a6eac:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"


======= e71e287:"weaver/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

======= e71e287:"weaver/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

======= e71e287:"weaver/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"


======= 0f506ab:"org.aspectj.matcher/src/org/aspectj/weaver/ShadowMunger.java"

======= 0f506ab:"org.aspectj.matcher/src/org/aspectj/weaver/ShadowMunger.java"


======= 6ae463a:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 6ae463a:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 6ae463a:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 6ae463a:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"


======= 167b801:"weaver5/java5-src/org/aspectj/weaver/reflect/JavaLangTypeToResolvedTypeConverter.java"


======= e8ef5bf:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= e8ef5bf:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= e8ef5bf:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= e8ef5bf:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"


======= c6fb752:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= c6fb752:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= c6fb752:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= c6fb752:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= c6fb752:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= c6fb752:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= c6fb752:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"


======= 8553b30:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= 8553b30:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"


======= 2302e94:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


======= bb2aea4:"org.aspectj.matcher/src/org/aspectj/weaver/World.java"

======= bb2aea4:"org.aspectj.matcher/src/org/aspectj/weaver/World.java"

======= bb2aea4:"org.aspectj.matcher/src/org/aspectj/weaver/World.java"


======= f7b1193:"weaver/src/org/aspectj/weaver/bcel/Utility.java"

======= f7b1193:"weaver/src/org/aspectj/weaver/bcel/Utility.java"


  before(String[] ss): execution(* *(..)) && args(ss) {
  }
  before(int[] ss): execution(* *(..)) && args(ss) {
  }
  before(float[][] ss): execution(* *(..)) && args(ss) {
  }
  String[] stringArray = new String[1];
  int[] ints = new int[3];
  float[][] floats = new float[1][2];
  String[] stringArray = new String[1];
  before(Dibble d): execution(* *(..)) && args(d) {
  }

======= 95e70d2:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

======= 95e70d2:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"


    void updateList(List<T> newList);
  @SuppressWarnings("rawtypes")
  pointcut IVOListUpdate(IVOList list):  target(list) && call(void updateList(*));
======= 199299c:"tests/src/org/aspectj/systemtest/ajc1612/Ajc1612Tests.java"


    private String name;
    private Country country;
    public static class City.TrafficCalculator {
        Function<City, Time> EXTREME = createExtremeTraffic(); 
        Function<City, Time> BASIC = createBasicTraffic();
    }
    private static Function<City, Time> createExtremeTraffic() {
        return null;
    } 
    private static Function<City, Time> createBasicTraffic() {
        return null;
    } 
    public static class Time { } 
  public static void main(String []argv) {}
======= 249f832:"tests/src/org/aspectj/systemtest/ajc1612/Ajc1612Tests.java"


======= 293a075:"org.aspectj.matcher/testdata/AnnotatedClass.java"

======= 293a075:"org.aspectj.matcher/testdata/MethodLevelAnnotation.java"

======= 293a075:"org.aspectj.matcher/testdata/SomeAnnotation.java"

======= 293a075:"org.aspectj.matcher/testsrc/org/aspectj/matcher/tools/CommonAdvancedPointcutExpressionTests.java"

======= 293a075:"org.aspectj.matcher/testsrc/org/aspectj/matcher/tools/CommonAdvancedPointcutExpressionTests.java"

  @MethodLevelAnnotation
  public void annotatedMethod() { }
  public void nonAnnotatedMethod() {
  }
======= 293a075:"org.aspectj.matcher/testsrc/org/aspectj/matcher/tools/CommonAdvancedPointcutExpressionTests.java"

======= 293a075:"org.aspectj.matcher/testsrc/org/aspectj/matcher/tools/CommonAdvancedPointcutExpressionTests.java"


======= a8e6797:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"


======= 945402f:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= 945402f:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= 945402f:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"


======= 80785bf:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariable.java"

======= 80785bf:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariable.java"

======= 80785bf:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariableReferenceType.java"

======= 80785bf:"org.aspectj.matcher/src/org/aspectj/weaver/TypeVariableReferenceType.java"

======= 80785bf:"org.aspectj.matcher/src/org/aspectj/weaver/World.java"


======= 5648105:"util/src/org/aspectj/util/FileUtil.java"

======= 5648105:"util/src/org/aspectj/util/FileUtil.java"

 * @author Andy Clement
 * @author Kris De Volder
======= 5648105:"util/src/org/aspectj/util/FileUtil.java"


======= 6249672:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= 6249672:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= 6249672:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"


======= 03c43f5:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"


======= 2a8d684:"org.aspectj.matcher/src/org/aspectj/weaver/reflect/ShadowMatchImpl.java"

======= 2a8d684:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

======= 2a8d684:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

======= 2a8d684:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

======= 2a8d684:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

======= 2a8d684:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"


======= 88fab6a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= 88fab6a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"


======= e0e1330:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/ModifiersPattern.java"

======= e0e1330:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/ModifiersPattern.java"


======= ce16a06:"org.aspectj.matcher/src/org/aspectj/weaver/ReferenceType.java"


======= f631ad6:"org.aspectj.matcher/src/org/aspectj/weaver/World.java"

======= f631ad6:"org.aspectj.matcher/src/org/aspectj/weaver/World.java"


  public int q2.Code.i;
  public void q2.Code.something2() {}
======= 6b35ea4:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


======= 16adee6:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= 16adee6:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= 16adee6:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= 16adee6:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= 16adee6:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= 16adee6:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= 16adee6:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= 16adee6:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"


======= 85fd25d:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= 85fd25d:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= 85fd25d:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= 85fd25d:"loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java"

======= 85fd25d:"loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java"

======= 85fd25d:"loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java"

======= 85fd25d:"loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java"

======= 85fd25d:"loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java"

======= 85fd25d:"loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java"

======= 85fd25d:"loadtime/testsrc/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptorTest.java"

 * Copyright (c) 2009 Contributors.
 * All rights reserved.
 * This program and the accompanying materials are made available
 * under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution and is available at
 * http://eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *  Andy Clement
 *******************************************************************************/

======= fe049ea:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"


======= 767bb85:"org.aspectj.matcher/src/org/aspectj/weaver/BindingScope.java"

 * @author Andy Clement
======= 767bb85:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/IScope.java"

======= 767bb85:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/IScope.java"

======= 767bb85:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/SimpleScope.java"

======= 767bb85:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/SimpleScope.java"

======= 767bb85:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/SimpleScope.java"

======= 767bb85:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/SimpleScope.java"

======= 767bb85:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/SimpleScope.java"

======= 767bb85:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= 767bb85:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= 767bb85:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= 767bb85:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= 767bb85:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/PatternsTests.java"

======= 767bb85:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/PatternsTests.java"

======= 767bb85:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/PatternsTests.java"

 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *     PARC     initial implementation 
 * ******************************************************************/
======= 767bb85:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/TypePatternTestCase.java"


======= 92a52a2:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"


======= 0e5ecd3:"org.aspectj.matcher/src/org/aspectj/weaver/Advice.java"


======= cf0ee0c:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= cf0ee0c:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= cf0ee0c:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= cf0ee0c:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= cf0ee0c:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"


======= 1e28b92:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/PointcutEvaluationExpenseComparator.java"

======= 1e28b92:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/PointcutEvaluationExpenseComparator.java"

======= 1e28b92:"org.aspectj.matcher/src/org/aspectj/weaver/patterns/PointcutEvaluationExpenseComparator.java"

======= 1e28b92:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/PointcutRewriterTest.java"

 * Testing the pointcut rewriter.
 * @author Adrian Colyer
 * @author Andy Clement
======= 1e28b92:"org.aspectj.matcher/testsrc/org/aspectj/weaver/patterns/PointcutRewriterTest.java"


======= 3be69a2:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"

======= 3be69a2:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"

======= 3be69a2:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"

======= 3be69a2:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"

======= 3be69a2:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"


======= 728ecb8:"asm/src/org/aspectj/asm/AsmManager.java"


======= a502da8:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= a502da8:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= a502da8:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= a502da8:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= a502da8:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= a502da8:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= a502da8:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= a502da8:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= a502da8:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= a502da8:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= a502da8:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= a502da8:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= a502da8:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= a502da8:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= a502da8:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= a502da8:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= a502da8:"asm/src/org/aspectj/asm/internal/ProgramElement.java"


======= b21eb05:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"

======= b21eb05:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"

======= b21eb05:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"


======= 94d0a4e:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseResolvedMember.java"

======= 94d0a4e:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseResolvedMember.java"

======= 94d0a4e:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseResolvedMember.java"


  declare warning: @Anno *: "Nothing should be annotated Anno!";
  
  
  declare error: I+ && !hasmethod(* foo(..)): "Missing foo() method in I subtype";
  void foo() {}  
  
  declare warning: I+ && !hasmethod(* foo(..)): "Missing foo() method in I subtype";
  void foo() {}  
  

======= 4b43dc6:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"


======= 749078d:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

 * @author Andy Clement
======= 749078d:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= 749078d:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= 749078d:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= 749078d:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= 749078d:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= 749078d:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= 749078d:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= 749078d:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= 749078d:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"


======= a968890:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"


======= 28fb861:"org.aspectj.matcher/src/org/aspectj/weaver/AjAttribute.java"

======= 28fb861:"org.aspectj.matcher/src/org/aspectj/weaver/AjAttribute.java"


======= 19355dd:"loadtime5/java5-src/org/aspectj/weaver/loadtime/ClassPreProcessorAgentAdapter.java"


 package com.citi.gdos.smart.applib.service.cache;
======= dc53b77:"tests/src/org/aspectj/systemtest/ajc167/Ajc167Tests.java"

======= dc53b77:"tests/src/org/aspectj/systemtest/ajc167/Ajc167Tests.java"

 * Copyright (c) 2008 Contributors 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
 * Tests for the new all singing all dancing intertype syntax.
 * 
 * @author Andy Clement
 */
  <ajc-test dir="bugs167/pr293457" title="hierarchy builder npe">
     <compile files="com/citi/gdos/smart/applib/service/cache/CachingIntroduction.aj org/springmodules/cache/annotations/Cacheable.java" options="-1.5 -emacssym">
     <message kind="warning" text="no match for this type name: Setter"/>
     <message kind="error" text="Setter cannot be resolved to a type"/>
     <message kind="error" text="The attribute modelId is undefined for the"/>
     </compile>
  </ajc-test>
  
   
   <ajc-test dir="features167/intertype" title="simple">
     <compile files="Simple.java" options="-1.5"/>
   </ajc-test>
   
   <ajc-test dir="features167/intertype" title="simple with field">
     <compile files="Two.java" options="-1.5"/>
   </ajc-test>
   
   <ajc-test dir="features167/intertype" title="simple with field2">
     <compile files="Three.java" options="-1.5"/>
   </ajc-test>
   
   <ajc-test dir="features167/intertype" title="new instance">
     <compile files="Four.java" options="-1.5"/>
   </ajc-test>
   
   <ajc-test dir="features167/intertype" title="new instance and access">
     <compile files="Five.java" options="-1.5"/>
     <run class="Five">
       <stdout>
         <line text="5"/>
       </stdout>
     </run>
   </ajc-test>
   
   <ajc-test dir="features167/intertype" title="new instance and access to two fields">
     <compile files="Six.java" options="-1.5"/>
     <run class="Six">
       <stdout>
         <line text="5"/>
       </stdout>
     </run>
   </ajc-test>
   
   

======= a23c7e4:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= a23c7e4:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= a23c7e4:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= a23c7e4:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= a23c7e4:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= a23c7e4:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= a23c7e4:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= a23c7e4:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= a23c7e4:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= a23c7e4:"org.aspectj.matcher/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"


======= 35a9649:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"


======= 4d200d1:"weaver/src/org/aspectj/weaver/bcel/ExtensibleURLClassLoader.java"


======= 67ffda8:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"


======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"

======= b29f839:"util/src/org/aspectj/util/LangUtil.java"


======= 3d3d03b:"org.aspectj.matcher/src/org/aspectj/weaver/Lint.java"


======= b664969:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= b664969:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= b664969:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"


======= dd7d879:"org.aspectj.matcher/src/org/aspectj/weaver/World.java"


======= 59d5c3b:"ajdoc/src/org/aspectj/tools/ajdoc/JavadocRunner.java"

======= 59d5c3b:"ajdoc/src/org/aspectj/tools/ajdoc/JavadocRunner.java"


======= 3417cbe:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= 3417cbe:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= 3417cbe:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"


======= 66235e8:"weaver/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

======= 66235e8:"weaver/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"


======= f9578da:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"


======= 1b663a9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 1b663a9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 1b663a9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 1b663a9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"


======= 6dbb5f3:"asm/src/org/aspectj/asm/internal/JDTLikeHandleProvider.java"


======= b23cc1a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= b23cc1a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= b23cc1a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= b23cc1a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= b23cc1a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= b23cc1a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= b23cc1a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= b23cc1a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= b23cc1a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= b23cc1a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= b23cc1a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"


======= d5e900d:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"


======= c732808:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= c732808:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"

======= c732808:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"


======= 752f895:"aspectj5rt/java5-src/org/aspectj/lang/reflect/AjTypeSystem.java"

======= 752f895:"aspectj5rt/java5-src/org/aspectj/lang/reflect/AjTypeSystem.java"


======= 7a7d6f0:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"


======= 5c49c0b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 5c49c0b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 5c49c0b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= 5c49c0b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= 5c49c0b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= 5c49c0b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"


======= 2309f7b:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"


======= 2f36e7f:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= 2f36e7f:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= 2f36e7f:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= 2f36e7f:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= 2f36e7f:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"


======= 9f80317:"org.aspectj.matcher/src/org/aspectj/weaver/ShadowMunger.java"


======= 0af658e:"asm/src/org/aspectj/asm/internal/JDTLikeHandleProvider.java"


======= 1b54b4b:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 1b54b4b:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 1b54b4b:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 1b54b4b:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= 1b54b4b:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 1b54b4b:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


======= 1da1f7c:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= 1da1f7c:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

 * This runs the AspectJ 1.1 compiler, supporting all the command-line options. In 1.1.1, ajc copies resources from input jars, but
 * you can copy resources from the source directories using sourceRootCopyFilter. When not forking, things will be copied as needed
 * for each iterative compile, but when forking things are only copied at the completion of a successful compile.
 * See the development environment guide for usage documentation.

======= d9bd46d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/ConfigParser.java"


    before() : execution(public void IsAdvised.doNothing()) {
        
    }
    int IsAdvised.x;
    public void doNothing() {} 
    public void doNothing2() {} 
    public void doNothing3() {} 
    public void doNothing4() {} 
    public void doNothing() {} 
    public void doNothing2() {} 
    public void doNothing3() {} 
    public void doNothing4() {} 
    public void doNothing5() {} 

======= f1a83b5:"tests/src/org/aspectj/systemtest/ajc163/Ajc163Tests.java"

    <ajc-test dir="bugs163/pr251326" title="itd anonymous inner class in wrong package">
      <compile files="pkgA/Listener.java pkgA/Target.java pkgB/InferListener.aj" options="-1.5"/>
      <run class="pkgA.Target">
        <stdout>
          <line text="Simple A"/>
          <line text="Inferred B"/>
        </stdout>
      </run>
    </ajc-test>

======= 120b47f:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

======= 120b47f:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

======= 120b47f:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"

======= 120b47f:"weaver/src/org/aspectj/weaver/model/AsmRelationshipProvider.java"


======= 155a888:"asm/src/org/aspectj/asm/internal/JDTLikeHandleProvider.java"


======= cffe291:"tests/src/org/aspectj/systemtest/ajc163/Ajc163Tests.java"

    <ajc-test dir="bugs163/pr249710" title="terminateAfterCompilation">
      <compile files="Foo.java" options="-1.5">
      </compile>
    </ajc-test>

======= 7a398a2:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 7a398a2:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 7a398a2:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"


    public void methodA() {
        System.out.println("methodA");
    }
    public void methodB() {
        System.out.println("methodB");
    }
    void doSomething();
    public void doSomething() {
        System.out.println("doSomething");
    }
    void methodA();
    void methodB();
   @DeclareParents(value="Foo+",defaultImpl=DefaultTestImpl.class)
   public Test implementedInterface;
   @Before("execution(* Foo.doSomething()) && this(t)")
   public void verifyRunningSender(Test t) {
       t.methodA();
       t.methodB();
   }
   
   public static void main(String[] args) {
       Foo foo = new FooImpl();
       foo.doSomething();
   }
    void methodA();
    void methodB();
======= 9b68a31:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= 9b68a31:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= 9b68a31:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


======= f376a21:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseResolvedMember.java"


======= 78a483d:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 78a483d:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 78a483d:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 78a483d:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 78a483d:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 78a483d:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 78a483d:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 78a483d:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"


======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d5c2ead:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"


======= 6d906dc:"docs/dist/doc/examples/introduction/Point.java"


======= df49b5c:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= df49b5c:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

            
    			String nextDefinition = st.nextToken();
    			if (nextDefinition.startsWith("file:")) {
    				try {
    					String fpath = new URL(nextDefinition).getFile();
    					File configFile = new File(fpath);
    					if (!configFile.exists()) {
    						warn("configuration does not exist: "+nextDefinition);
    					} else {
    						definitions.add(DocumentParser.parse(configFile.toURL()));
    					}
    				} catch (MalformedURLException mue) {
    					error("malformed definition url: "+nextDefinition);
    				}
    			} else {

======= e9823aa:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"


======= be03167:"weaver/src/org/aspectj/weaver/patterns/AndAnnotationTypePattern.java"

======= be03167:"weaver/src/org/aspectj/weaver/patterns/NotAnnotationTypePattern.java"

======= be03167:"weaver/src/org/aspectj/weaver/patterns/OrAnnotationTypePattern.java"

======= be03167:"weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"


        public static interface Marker {}
        public static class NonGenericClass {
                public void doit(String msg) {
                        System.out.println("doit(): msg = "+msg);
                }
        }
        public static class GenericClass<T> {
                public void doit(T t) {
                        System.out.println("doit<T>(): t = "+t);
                }
        }
        declare parents: NonGenericClass implements Marker;
        declare parents: GenericClass    implements Marker;
        pointcut nonGenericCall(): call (void NonGenericClass.doit(..));
        pointcut genericCall():    call (void GenericClass.doit(..));
        pointcut markerCall():     call (void Marker+.doit(..));
        private static int mCount  = 0;
        
        before(): nonGenericCall() {
                System.out.println("nonGenericCall advice hit");
        }
        before(): genericCall() {
                System.out.println("genericCall advice hit");
        }
        before(): markerCall() {
        		mCount++;
                System.out.println("markerCall advice hit");
        }
        public static void main(String args[]) {
                new NonGenericClass().doit("message1");
                new GenericClass<Integer>().doit(new Integer(2));
                if (mCount!=2) {
                	throw new RuntimeException("Did not hit marker+ advice twice!");
                }
        }
======= 11ebdd8:"tests/src/org/aspectj/systemtest/ajc161/Ajc161Tests.java"

    	<compile files="CantMatchOnInterfaceIntroducedToGenericClass.java" options="-1.5"/>
    	<run class="bug.CantMatchOnInterfaceIntroducedToGenericClass"/>
    </ajc-test>
    

======= 248962b:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= 248962b:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

                    if (pTypes!=null && baseArgsCount>pTypes.length) { //pr155347
                    	throw new BCException("Unexpected problem with testMethod "+testMethod+": expecting "+baseArgsCount+" arguments");
                    }
======= 248962b:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

                                pTypes[i].resolve(shadow.getIWorld())));

======= 3b2109a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 3b2109a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"


======= 93b7bed:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


======= f014275:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"


======= a8739e3:"weaver/src/org/aspectj/weaver/TypeFactory.java"


======= d3c3e32:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"

        // If the user has turned off classfile line number gen, then we may not be able to tell them
        // about all secondary locations (pr209372)
        int validPlaces = 0;
        for (int ii=0;ii<seeAlso.length;ii++) {
            if (seeAlso[ii].getSourceLineNumber()>=0) validPlaces++;
        }
        ISourceLocation[] seeAlsoLocations = new ISourceLocation[validPlaces];
        int pos = 0;
            if (seeAlso[i].getSourceLineNumber()>=0) {
                seeAlsoLocations[pos++] = new SourceLocation(new File(new String(seeAlso[i].getOriginatingFileName())),
        											 seeAlso[i].getSourceLineNumber());	
            }

======= 5f97d46:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 5f97d46:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        
        // Exception handlers (pr230817)
        if (canMatch(Shadow.ExceptionHandler) && !Range.isRangeHandle(ih)) {
            InstructionTargeter[] targeters = ih.getTargeters();
            if (targeters != null) {
                for (int j = 0; j < targeters.length; j++) {
                    InstructionTargeter t = targeters[j];
                    if (t instanceof ExceptionRange) {
                        // assert t.getHandler() == ih
                        ExceptionRange er = (ExceptionRange) t;
                        if (er.getCatchType() == null) continue;
                        if (isInitFailureHandler(ih)) return;
                        
                        if (!(ih.getInstruction() instanceof StoreInstruction) && ih.getInstruction().getOpcode()!=Constants.NOP) {
                            // If using cobertura, the catch block stats with INVOKESTATIC rather than ASTORE, in order that the ranges 
                            // for the methodcall and exceptionhandler shadows that occur at this same 
                            // line, we need to modify the instruction list to split them - adding a 
                            // NOP before the invokestatic that gets all the targeters
                            // that were aimed at the INVOKESTATIC
                            mg.getBody().insert(ih,InstructionConstants.NOP);
                            InstructionHandle newNOP = ih.getPrev();
                            // what about a try..catch that starts at the start of the exception handler? need to only include certain targeters really.
                            er.updateTarget(ih, newNOP,mg.getBody());
                            for (int ii=0;ii<targeters.length;ii++) {
                                newNOP.addTargeter(targeters[ii]);
                            }
                            ih.removeAllTargeters();
                            match(
                                BcelShadow.makeExceptionHandler(
                                    world, 
                                    er,
                                    mg, newNOP, enclosingShadow),
                                shadowAccumulator);
                        } else {                    
                            match(
                                BcelShadow.makeExceptionHandler(
                                    world, 
                                    er,
                                    mg, ih, enclosingShadow),
                                shadowAccumulator);
                        }
                    }
                }
            }
        }
        
======= 5f97d46:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 5f97d46:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 5f97d46:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

            InstructionHandle rMappedStart = remap(r.getRealStart(), map);
            InstructionHandle rMappedEnd = remap(r.getRealEnd(), map);
            InstructionHandle rMappedHandler = remap(r.getHandler(), map);
            gen.addExceptionHandler(rMappedStart,rMappedEnd,rMappedHandler,
            (r.getCatchType() == null)
            ? null 
            : (ObjectType) BcelWorld.makeBcelType(r.getCatchType()));
======= 5f97d46:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        if (true) return;  // only to be enabled for debugging // should be switchonable via an option
        StringBuffer assertionLog = new StringBuffer();
        assertionLog.append("Checking state of an instruction body, from="+from+"\n");
    		if (il == null) return;
    		Set body = new HashSet();
    		Stack ranges = new Stack();
    		for (InstructionHandle ih = il.getStart(); ih != null; ih = ih.getNext()) {
    			body.add(ih);
    			if (ih.getInstruction() instanceof BranchInstruction) {
    				body.add(ih.getInstruction());
    			}
    		}
    		
    		for (InstructionHandle ih = il.getStart(); ih != null; ih = ih.getNext()) {
    			assertGoodHandle(ih, body, ranges, from, assertionLog);
    			InstructionTargeter[] ts = ih.getTargeters();
    			if (ts != null) {
    				for (int i = ts.length - 1; i >= 0; i--) {
    					assertGoodTargeter(ts[i], ih, body, from, assertionLog);
    				}
    			}
    		}
======= 5f97d46:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    private static void assertGoodRangeHandle(InstructionHandle ih, Set body, Stack ranges, String from, StringBuffer log) {
======= 5f97d46:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    private static void assertGoodRange(Range r, Set body, String from, StringBuffer log) {
======= 5f97d46:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        String from, StringBuffer log)

======= bed3f4e:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTMatcher.java"

======= bed3f4e:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTMatcher.java"


======= 6bdb87d:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    { "1.1", "1.2", "1.3", "1.4", "1.5", "1.6" };
    { "1.3", "1.4", "1.5", "1.6" };
    { "-1.3", "-1.4", "-1.5", "-1.6" };

======= 8ce9dcf:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"


======= fe99e6b:"weaver/src/org/aspectj/weaver/ResolvedType.java"

            }

======= 6c54db9:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"

            return null;// pr222987 - prevent NPE

======= 906c849:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 906c849:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 906c849:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 906c849:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"


======= a31b3de:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


======= caf8960:"weaver/src/org/aspectj/weaver/World.java"

======= caf8960:"weaver/src/org/aspectj/weaver/World.java"


======= 1bbe6f9:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"


======= 9bbdb41:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"

======= 9bbdb41:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"

======= 9bbdb41:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"

======= 9bbdb41:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"

======= 9bbdb41:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"


======= 5beab0e:"weaver/src/org/aspectj/weaver/Shadow.java"

    	StringBuffer sb = new StringBuffer();
    	sb.append(getKind());
    	sb.append("(");
    	Member m = getSignature();
    	if (m==null) {
    		sb.append("<<missing signature>>");
    	} else {
    		ResolvedMember rm = world.resolve(m);
    		if (rm==null) {
    			sb.append("<<unresolvableMember:").append(m).append(">>");
    		} else {
    			String genString = rm.toGenericString();
    			if (genString==null) {
    				sb.append("<<unableToGetGenericStringFor:").append(rm).append(">>");
    			} else {
    				sb.append(genString);
    			}
    			
    		}
    	}
    	sb.append(")");
    	return sb.toString();
    	// was: return getKind() + "(" + world.resolve(getSignature()).toGenericString() + ")";

======= b4715bc:"runtime/src/org/aspectj/lang/ProceedingJoinPoint.java"

     * <p>Unlike code style, proceed(..) in annotation style places different requirements on the 
     * parameters passed to it.  The proceed(..) call takes, in this order:
     * <ul>
     * <li> If 'this()' was used in the pointcut for binding, it must be passed first in proceed(..).
     * <li> If 'target()' was used in the pointcut for binding, it must be passed next in proceed(..) - 
     * it will be the first argument to proceed(..) if this() was not used for binding.
     * <li> Finally come all the arguments expected at the join point, in the order they are supplied 
     * at the join point. Effectively the advice signature is ignored - it doesn't matter 
     * if a subset of arguments were bound or the ordering was changed in the advice signature, 
     * the proceed(..) calls takes all of them in the right order for the join point. 
     * </ul>
     * <p>Since proceed(..) in this case takes an Object array, AspectJ cannot do as much 
     * compile time checking as it can for code style. If the rules above aren't obeyed 
     * then it will unfortunately manifest as a runtime error. 
     * </p>

======= 114db35:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTConverter.java"

======= 114db35:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjASTConverter.java"

======= 114db35:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/InterTypeFieldDeclaration.java"

======= 114db35:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/InterTypeMethodDeclaration.java"


  @Pointcut("execution(@Tracing * *(..)) && @annotation(tracing)")
        void annotatedMethods(Tracing tracing) { }
       
        @AfterThrowing(pointcut = "annotatedMethods(tracing)", throwing = "t")
        public void logException(JoinPoint thisJoinPoint, Tracing tracing,Throwable t) {
        }
  @Tracing
  public void m() {}
  public static void main(String []argv) {}
   
  @Pointcut("execution(@Tracing * *(..)) && @annotation(tracing)")
        void annotatedMethods(Tracing tracing) { }
       
        @AfterThrowing(pointcut = "annotatedMethods(tracing)", throwing = "t")
        public void logException(JoinPoint thisJoinPoint, Throwable t,Tracing tracing) {
        }
  @Tracing
  public void m() {}
  public static void main(String []argv) {}
======= 9de03b7:"tests/src/org/aspectj/systemtest/ajc154/Ajc154Tests.java"

   <ajc-test dir="bugs154/pr211674" title="after throwing annotation style problem - 1">
     <compile options="-1.5" files="Test.java"/>
     <run class="Test"/>
   </ajc-test>
   <ajc-test dir="bugs154/pr211674" title="after throwing annotation style problem - 2">
     <compile options="-1.5" files="Test2.java"/>
     <run class="Test2"/>
   </ajc-test>

======= 797ec4d:"weaver/src/org/aspectj/weaver/ResolvedType.java"


======= 579ec14:"weaver/src/org/aspectj/weaver/TypeFactory.java"

======= 579ec14:"weaver/src/org/aspectj/weaver/TypeFactory.java"

======= 579ec14:"weaver/src/org/aspectj/weaver/TypeFactory.java"

======= 579ec14:"weaver/testsrc/org/aspectj/weaver/TypeXTestCase.java"


======= 4177bed:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"


======= 5336603:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

        	{   "constructorName", "packageDefaultMethod", "deprecation",
        		"unusedImports", "syntheticAccess", "assertIdentifier",
        		"allDeprecation","allJavadoc","charConcat","conditionAssign",
        		
        		"emptyBlock",
        		"fieldHiding",
        		"finally",
        		"indirectStatic",
        		"intfNonInherited",
        		"javadoc",
        		"localHiding",
        		"nls",
        		"noEffectAssign",
        		"pkgDefaultMethod",
        		"semicolon",
        		"unqualifiedField",
        		"unusedPrivate",
        		"unusedThrown",
        		"uselessTypeCheck",
        		"specialParamHiding",
        		"staticReceiver",
        		"syntheticAccess",
        		"none" };

======= e8d2556:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

======= e8d2556:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

        // TODO only convert the name to signature once, probably earlier than this
        ResolvedType current = m_world.lookupBySignature(UnresolvedType.forName(m_concreteAspect.name).getSignature());
        
        if (current!=null && !current.isMissing()) {
======= e8d2556:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

        ReferenceType rt = new ReferenceType(ResolvedType.forName(m_concreteAspect.name).getSignature(),m_world);
        BcelPerClauseAspectAdder perClauseMunger = new BcelPerClauseAspectAdder(rt,m_perClause.getKind());

======= c54fa62:"ajde/src/org/aspectj/ajde/BuildOptionsAdapter.java"

======= c54fa62:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= c54fa62:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= c54fa62:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= c54fa62:"ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java"

        assertTrue(configFile + " failed", null != buildConfig);            
======= c54fa62:"ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java"

        assertTrue(configFile + " failed", null != buildConfig);            
======= c54fa62:"ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java"

        assertTrue(configFile + " failed", null != buildConfig);            
        assertTrue(configFile + " failed", null != buildConfig);            

  public List<? extends Element> getElements() {
    return new ArrayList<Element>();
  }
  class Element {};
  @Aspect
  static abstract class Base<T> {
    @Around("call(List<? extends T> *.*(..))")
    public List<? extends T> elementList(ProceedingJoinPoint thisJoinPoint) {
      try {
        return (List<? extends T>)thisJoinPoint.proceed();
      } catch (Throwable e) {
        throw new RuntimeException(e);
      }
    }
  }
  @Aspect
  static class Concrete extends Base<Element> {}
  public static void main(String[] args) {
    new Main().getElements();
  }
  public List<? extends Element> getElements() {
    return new ArrayList<Element>();
  }
  class Element {};
  @Aspect
  static abstract class Base<T> {
    @Around("call(List<? extends T> *.*(..))")
    public List<? extends T> elementList(ProceedingJoinPoint thisJoinPoint) {
      try {
        return (List<? extends T>)thisJoinPoint.proceed();
      } catch (Throwable e) {
        throw new RuntimeException(e);
      }
    }
  }
  @Aspect
  static class Concrete extends Base<String> {} // pointcut won't match because not a call to "List<? extends String> *(..)"
  public static void main(String[] args) {
    new Main2().getElements();
  }
======= 7b40e7e:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testGenericsInPointcuts_pr161502() { runTest("generics in pointcuts");}
  public void testGenericsInPointcuts_pr161502_2() { runTest("generics in pointcuts - 2");}
      <compile files="Main.java" options="-1.5 -showWeaveInfo">
        <message kind="weave" text="Join point 'method-call(java.util.List Main.getElements())' in Type 'Main' (Main.java:31) advised by around advice from 'Main$Concrete' (Main.java:18)"/>
      </compile>
      <run class="Main"/>
    </ajc-test> 
        
      <compile files="Main2.java" options="-1.5 -showWeaveInfo">
        <message kind="warning" text="advice defined in Main2$Base has not been applied"/>
      </compile>
      <run class="Main2"/>
    </ajc-test> 
    
======= 7b40e7e:"weaver/src/org/aspectj/weaver/BoundedReferenceType.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/BoundedReferenceType.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/BoundedReferenceType.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/Checker.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/ReferenceType.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/ReferenceType.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/ResolvedType.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/ResolvedType.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/TypeVariable.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/TypeVariableReferenceType.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/TypeVariableReferenceType.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/TypeVariableReferenceType.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

        		ResolvedMember declaredSig = munger.getSignature();
======= 7b40e7e:"weaver/src/org/aspectj/weaver/internal/tools/PointcutDesignatorHandlerBasedPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/internal/tools/PointcutDesignatorHandlerBasedPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/AndAnnotationTypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/AndPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/AndPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/AndTypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/AndTypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java"

    public AnnotationTypePattern parameterizeWith(Map arg0,World w) {
======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java"

    public AnnotationTypePattern parameterizeWith(Map arg0,World w) {
======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

    public Pointcut parameterizeWith(Map typeVariableMap,World w) {
    	ArgsPointcut ret = new ArgsPointcut(this.arguments.parameterizeWith(typeVariableMap,w));
======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/BindingTypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/BindingTypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/ConcreteCflowPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/ConcreteCflowPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/Declare.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/Declare.java"

    public abstract Declare parameterizeWith(Map typeVariableBindingMap,World w);
======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/DeclareAnnotation.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java"

    public Declare parameterizeWith(Map typeVariableBindingMap,World w) {
    	Declare ret = new DeclareErrorOrWarning(isError,pointcut.parameterizeWith(typeVariableBindingMap,w),message);
======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/DeclareParents.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/HasMemberTypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/NotAnnotationTypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/NotPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/NotPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/NotTypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/NotTypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/OrAnnotationTypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/OrPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/OrPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/OrTypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/OrTypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/PerCflow.java"

    public Pointcut parameterizeWith(Map typeVariableMap,World w) {
    	PerCflow ret = new PerCflow(entry.parameterizeWith(typeVariableMap,w),isBelow);
======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/PerObject.java"

    public Pointcut parameterizeWith(Map typeVariableMap,World w) {
    	PerObject ret = new PerObject(entry.parameterizeWith(typeVariableMap,w),isThis);
======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/PerSingleton.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/PerSingleton.java"

    public Pointcut parameterizeWith(Map typeVariableMap,World w) {
======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

        public Pointcut parameterizeWith(Map typeVariableMap,World w) {
======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java"

    public ThrowsPattern parameterizeWith(Map/*name -> resolved type*/ typeVariableMap,World w) {
    			required.parameterizeWith(typeVariableMap,w),
    			forbidden.parameterizeWith(typeVariableMap,w));
======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

    public abstract TypePattern parameterizeWith(Map typeVariableMap,World w);
======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

    public TypePattern parameterizeWith(Map typeVariableMap,World w) {
======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

    public TypePattern parameterizeWith(Map arg0,World w) {
======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

    public TypePattern parameterizeWith(Map arg0,World w) {
======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/TypePatternList.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/TypePatternList.java"

    public TypePatternList parameterizeWith(Map typeVariableMap,World w) {
======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

    public AnnotationTypePattern parameterizeWith(Map typeVariableMap,World w) {
    	WildAnnotationTypePattern ret = new WildAnnotationTypePattern(typePattern.parameterizeWith(typeVariableMap,w));
======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

======= 7b40e7e:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"


        not on the classpath when the aspects are being compiled and woven 
        with this jar on the inpath. This should result in a cantFindType 
        message. 
        
        result in an unresolvableMember message.
    pointcut tracePoints() : !within(Tracing);
    before() : tracePoints() {
            _callDepth++; print("Before", thisJoinPoint);
    }
    after() : tracePoints() {
            print("After", thisJoinPoint);
            _callDepth--;
    }
    private void print(String prefix, Object message) {
            for(int i = 0, spaces = _callDepth * 2; i < spaces; i++) {
                    //MyPrint.print(" ","");
            }
            System.out.println(prefix + ": " + message);
    }
======= 757004c:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testNoNPEDueToMissingType_pr149908() { runTest("ensure no npe due to missing type");}
  public void testNoNPEDueToMember_pr149908() { runTest("ensure no npe due to missing member");}
    <ajc-test dir="bugs153/pr149908" title="ensure no npe due to missing type">
      <compile files="A.aj,C1.java,Tracing.aj" inpath="simple.jar">
    </ajc-test>
    <ajc-test dir="bugs153/pr149908" title="ensure no npe due to missing member">
      <compile files="A.aj,C1.java,Tracing.aj" inpath="simple.jar;stringBuilder.jar">
    </ajc-test>
    
======= 757004c:"weaver/src/org/aspectj/weaver/MemberImpl.java"

    private boolean reportedCantFindDeclaringType = false;
    private boolean reportedUnresolvableMember = false;
======= 757004c:"weaver/src/org/aspectj/weaver/MemberImpl.java"

    	ResolvedMember resolved = resolve(world);
    	if (resolved == null) {
       		reportDidntFindMember(world);
    		return 0;
    	ResolvedMember resolved = resolve(world);
    	if (resolved == null) {
       		reportDidntFindMember(world);
    		return UnresolvedType.NONE;
======= 757004c:"weaver/src/org/aspectj/weaver/MemberImpl.java"

    	ResolvedMember resolved = resolve(world);
    	if (resolved == null) {
       		reportDidntFindMember(world);
    		return null;
======= 757004c:"weaver/src/org/aspectj/weaver/MemberImpl.java"

       	if (reportedCantFindDeclaringType || reportedUnresolvableMember) return;
    }

======= efe6cc7:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            callAjc(inputFiles);
            }    
======= efe6cc7:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

======= efe6cc7:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

    private static void callAjc(File[] inputFiles) {
        ajcOptions.addElement("-noExit");
        ajcOptions.addElement("-d"); 
        ajcOptions.addElement(rootDir.getAbsolutePath());
        int i = 0;
        for ( ; i < ajcOptions.size(); i++ ) {
            argsToCompiler[i] = (String)ajcOptions.elementAt(i);
        }
        for ( int j = 0; j < inputFiles.length; j++) {
            argsToCompiler[i] = inputFiles[j].getAbsolutePath();
            //System.out.println(">> file to ajc: " + inputFiles[j].getAbsolutePath());
            i++;
        }
        System.out.println( "> Calling ajc..." );
        CompilerWrapper.main(argsToCompiler);
    }
    
    private static void callJavadoc(File[] signatureFiles) throws IOException {
        System.out.println( "> Calling javadoc..." );
        String[] javadocargs = null;
        if ( packageMode ) {
            int numExtraArgs = 2;
            if (authorStandardDocletSwitch) numExtraArgs++;
            if (versionStandardDocletSwitch) numExtraArgs++;
            javadocargs = new String[numExtraArgs + options.size() + packageList.size() +
                                     fileList.size() ];
            javadocargs[0] = "-sourcepath";
            javadocargs[1] = outputWorkingDir;
            int argIndex = 2;
            if (authorStandardDocletSwitch) {
                javadocargs[argIndex] = "-author";
                argIndex++;
            }
            if (versionStandardDocletSwitch) {
                javadocargs[argIndex] = "-version";
            }
            //javadocargs[1] = getSourcepathAsString();
            for (int k = 0; k < options.size(); k++) {
                javadocargs[numExtraArgs+k] = (String)options.elementAt(k);
            }
            for (int k = 0; k < packageList.size(); k++) {
                javadocargs[numExtraArgs+options.size() + k] = (String)packageList.elementAt(k);
            }
            for (int k = 0; k < fileList.size(); k++) {
                javadocargs[numExtraArgs+options.size() + packageList.size() + k] = (String)fileList.elementAt(k);
            }
        }
        else {
            javadocargs = new String[options.size() + signatureFiles.length];
            for (int k = 0; k < options.size(); k++) {
                javadocargs[k] = (String)options.elementAt(k);
            }
            for (int k = 0; k < signatureFiles.length; k++) {
                javadocargs[options.size() + k] = StructureUtil.translateAjPathName(signatureFiles[k].getCanonicalPath());
            }
        }
     
        JavadocRunner.callJavadoc(javadocargs);    	
    }
    
    /** 
     * We start with the known HTML files (the ones that correspond directly to the
     * input files.)  As we go along, we may learn that Javadoc split one .java file
     * into multiple .html files to handle inner classes or local classes.  The html
     * file decorator picks that up.
     */
    private static void decorateHtmlFiles(File[] inputFiles) throws IOException {
        System.out.println( "> Decorating html files..." );
        HtmlDecorator.decorateHTMLFromInputFiles(declIDTable,
                                          rootDir,
                                          inputFiles,
                                          docModifier); 
        
        System.out.println( "> Removing generated tags (this may take a while)..." );
        removeDeclIDsFromFile("index-all.html", true);
        removeDeclIDsFromFile("serialized-form.html", true);
        if (packageList.size() > 0) {
            for (int p = 0; p < packageList.size(); p++) {
                removeDeclIDsFromFile(((String)packageList.elementAt(p)).replace('.','/') +
                                       Config.DIR_SEP_CHAR +
                                       "package-summary.html", true);
            }
        } else {
        	files = FileUtil.listFiles(rootDir, new FileFilter() {
        		public boolean accept(File f) {
        	});
        	for (int j = 0; j < files.length; j++) {
        		removeDeclIDsFromFile(files[j].getAbsolutePath(), false);
        	}
        }    	
    }
    
======= efe6cc7:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            if (addNextAsClasspath) {
            if (addNextAsSourcePath) {
            
            } else if ( arg.equals( "-argfile" ) ) {
            } else if ( addNextAsArgFile ) {
            } else if (arg.equals("-d") ) {
            } else if ( arg.equals( "-bootclasspath" ) ) {
            } else if ( arg.equals( "-source" ) ) {
            } else if ( arg.equals( "-classpath" ) ) {
            } else if ( arg.equals( "-encoding" ) ) {
            } else if ( arg.equals( "-docencoding" ) ) {
            } else if ( arg.equals( "-charset" ) ) {
            } else if ( arg.equals( "-sourcepath" ) ) {
            } else if (arg.equals("-XajdocDebug")) {
            } else if (arg.equals("-use")) {
            } else if (arg.equals("-splitindex")) {
            } else if (arg.startsWith("-") || addNextAsOption) {
                } else if ( arg.equals( "-package" ) ) {
======= efe6cc7:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            } else { 
                if (FileUtil.hasSourceSuffix(arg) || arg.endsWith(".lst") && arg != null ) {
                    	filenames.addElement(arg);
                        filenames.addElement( currentWorkingDir + Config.DIR_SEP_CHAR + arg );

======= 044542c:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testNoNPEWithThrownExceptionWarningAndAtAspectj_pr161217() {runTest("NPE with thrown exception warning and at aspectj");}
    <ajc-test dir="bugs153/pr161217" title="NPE with thrown exception warning and at aspectj">
      <compile files="AtAspectJAspect.java, C.java" options="-warn:+unusedThrown -1.5"/>
    </ajc-test>
======= 044542c:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

        		&& !getThrownExceptions().isEmpty()) {

======= bc2f36f:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= bc2f36f:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


======= f7508cf:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"


======= d532892:"tests/src/org/aspectj/systemtest/ajc153/JDTLikeHandleProviderTests.java"

    <ajc-test dir="features153/jdtlikehandleprovider" title="advice with same name in injar aspect should have unique handles">
      <compile files="ClassForAspectpath.java" options="-emacssym" aspectpath="jarForAspectPath.jar">
        <message kind="warning" text="blah"/>
        <message kind="warning" text="blah2"/>
      </compile>
    </ajc-test>
    <ajc-test dir="features153/jdtlikehandleprovider" title="declare warnings in injar aspect should have unique handles">
      <compile files="ClassForAspectpath.java" options="-emacssym" aspectpath="jarForAspectPath.jar">
        <message kind="warning" text="blah"/>
        <message kind="warning" text="blah2"/>
      </compile>
    </ajc-test>
    <ajc-test dir="features153/jdtlikehandleprovider" title="dont increment counter for different declares">
      <compile files="ClassForAspectpath.java" options="-emacssym" aspectpath="declare.jar">
        <message kind="warning" text="warning"/>
        <message kind="error" text="error"/>
      </compile>
    </ajc-test>
    <ajc-test dir="features153/jdtlikehandleprovider" title="dont increment counter for different advice kinds">
      <compile files="ClassForAspectpath.java" options="-emacssym" aspectpath="advice.jar"/>
    </ajc-test>
======= d532892:"weaver/src/org/aspectj/weaver/ShadowMunger.java"

    	int afterCtr = 1;
    	int aroundCtr = 1;
    	int beforeCtr = 1;
    	int deCtr = 1;
    	int dwCtr = 1;
    private IProgramElement createDeclareErrorOrWarningChild(
    		DeclareErrorOrWarning decl, int count) {
    			decl.getName(),
    			decl.isError() ? IProgramElement.Kind.DECLARE_ERROR : IProgramElement.Kind.DECLARE_WARNING,
    			getBinarySourceLocation(decl.getSourceLocation()),
    			decl.getDeclaringType().getModifiers(),
    			null,null); 
    	deowNode.setDetails("\"" + AsmRelationshipUtils.genDeclareMessage(decl.getMessage()) + "\"");
    	if (count != -1) {
    		deowNode.setBytecodeName(decl.getName() + "_" + count);
    	}
    	return deowNode;
    }
    
    private IProgramElement createAdviceChild(BcelAdvice advice, int counter ) {
    			advice.kind.getName(),
    			IProgramElement.Kind.ADVICE,
    			getBinarySourceLocation(advice.getSourceLocation()),
    			advice.signature.getModifiers(),null,Collections.EMPTY_LIST);
    	adviceNode.setDetails(AsmRelationshipUtils.genPointcutDetails(advice.getPointcut()));
    	if (counter != 1) {
    	return adviceNode;
    }
    
======= d532892:"weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java"

======= d532892:"weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java"


    
    // ------------------ affected types
    static class Untyped {
        void untypedName() {} // declare warning 16
        void untypedPrefix_blah() {} // declare warning 17
        void blah_untypedSuffix() {} // declare warning 18       
    }
    
    static class Star {
        void starName() {} // declare warning 22
        void starPrefix_blah() {} // declare warning 23
        void blah_starSuffix() {} // declare warning  24      
    }
    static class Type{
        void typeName() {} // declare warning 27
        void typePrefix_blah() {} // declare warning 28
        void blah_typeSuffix() {} // declare warning 29      
    }
    
    static class TypePlus {    
        void typeplusName() {} // declare warning 33
        void typeplusPrefix_blah() {} // declare warning 34
        void blah_typeplusSuffix() {} // declare warning 35              
    }
    static class TypePlusSubtype extends TypePlus {
        void typeplusName() {} // declare warning 39
        void typeplusPrefix_blah() {} // declare warning 40
        void blah_typeplusSuffix() {} // declare warning  41              
    }
    
    // ------------------ tests
    declare @method: * untypedName() : @MtAn;
    declare @method: * untypedPrefix*() : @MtAn;
    declare @method: * *untypedSuffix() : @MtAn;
    declare @method: * *.starName() : @MtAn;
    declare @method: * *.starPrefix*() : @MtAn;
    declare @method: * *.*starSuffix() : @MtAn;
    
    declare @method: * Type.typeName() : @MtAn;
    declare @method: * Type.typePrefix*() : @MtAn;
    declare @method: * Type.*typeSuffix() : @MtAn;
    
    declare @method: * TypePlus+.typeplusName() : @MtAn;
    declare @method: * TypePlus+.typeplusPrefix*() : @MtAn;
    declare @method: * TypePlus+.*typeplusSuffix() : @MtAn;
    // ------------------ check using warnings, expected in .xml
    declare warning : execution(@MtAn * *()): "all";
======= 513564a:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testDeclareMethodAnnotations_pr159143() { runTest("declare method annotations");}
     <ajc-test dir="bugs153/pr159143" title="declare method annotations">
        <compile files="DeclareMethodAnnotation.java" options="-1.5">
            <message line="16" kind="warning" text="all"/>
            <message line="17" kind="warning" text="all"/>
            <message line="18" kind="warning" text="all"/>
            <message line="22" kind="warning" text="all"/>
            <message line="23" kind="warning" text="all"/>
            <message line="24" kind="warning" text="all"/>
            <message line="27" kind="warning" text="all"/>
            <message line="28" kind="warning" text="all"/>
            <message line="29" kind="warning" text="all"/>
            <message line="33" kind="warning" text="all"/>
            <message line="34" kind="warning" text="all"/>
            <message line="35" kind="warning" text="all"/>
            <message line="39" kind="warning" text="all"/>
            <message line="40" kind="warning" text="all"/>
            <message line="41" kind="warning" text="all"/>
        </compile>
    </ajc-test>
    

    private class Inner{
    	private void myMethod(){
    	}
    }
    private class Inner{
    	private void myMethod(){
    	}
    }
======= 782ade2:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testNoInvalidAbsoluteTypeNameWarning_pr156904_1() {runTest("ensure no invalidAbsoluteTypeName when do match - 1");}
  public void testNoInvalidAbsoluteTypeNameWarning_pr156904_2() {runTest("ensure no invalidAbsoluteTypeName when do match - 2");}
  public void testNoInvalidAbsoluteTypeNameWarning_pr156904_3() {runTest("ensure no invalidAbsoluteTypeName when do match - 3");}
  public void testNoInvalidAbsoluteTypeNameWarning_pr156904_4() {runTest("ensure no invalidAbsoluteTypeName when do match - 4");}
  
  /////////////////////////////////////////
    <ajc-test dir="bugs153/pr156904/inSameFile" title="ensure no invalidAbsoluteTypeName when do match - 1">
      <compile files="A.aj"/>
    </ajc-test>
    <ajc-test dir="bugs153/pr156904/inDiffPkgAndImport" title="ensure no invalidAbsoluteTypeName when do match - 2">
      <compile files="A.aj,Outer.java"/>
    </ajc-test>
    <ajc-test dir="bugs153/pr156904/inSamePkg" title="ensure no invalidAbsoluteTypeName when do match - 3">
      <compile files="A.aj,Outer.java"/>
    </ajc-test>
    <ajc-test dir="bugs153/pr156904/inDiffPkgWithoutImport" title="ensure no invalidAbsoluteTypeName when do match - 4">
      <compile files="A.aj,Outer.java">
    </ajc-test>
======= 782ade2:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= 782ade2:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"


======= 7b831ff:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

            String typePattern = getWithinAttribute(attributes);
            String typePattern = getWithinAttribute(attributes);
            String typePattern = getWithinAttribute(attributes);
======= 7b831ff:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

            String typePattern = getWithinAttribute(attributes);
            String typePattern = getWithinAttribute(attributes);
======= 7b831ff:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

======= 7b831ff:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

======= 7b831ff:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

======= 7b831ff:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

======= 7b831ff:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

    public static void main(String argz[]) {
        foo();
    }
    public static void foo() {
        (new pkg.sub.Foo()).foo();
        
        File dumpDir = new File("_ajdump"); 
        lsLR(dumpDir);
        
        // the LTW harness should clean up _ajdump files!
        cleanup(dumpDir);
    }
    
    public static void lsLR(File dir) {
        String[] files = dir.list();
        if (files == null) return;
        for (int i=0; i<files.length; i++) {
        	File f = new File(dir, files[i]);
        	if (f.isFile()) {
        		System.err.println(files[i]);
        	} else {
        		lsLR(f);
        	}
        }    	
    }
    
    public static void cleanup(File dir) {
        String[] files = dir.list();
        if (files == null) return;
        for (int i=0; i<files.length; i++) {
        	File f = new File(dir, files[i]);
        	if (f.isFile()) {
        		f.delete();
        	} else {
        		cleanup(f);
        	}
        }    	
    }
======= 7b831ff:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

    public void foo() {}
======= 7b831ff:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

    before() : execution(* foo()) {
        System.err.println(thisJoinPoint);
    }
======= 7b831ff:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

    before() : staticinitialization(pkg..*) {
        System.err.println(thisJoinPoint);
    }
======= 7b831ff:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

    before() : staticinitialization(pkg..*) {
        System.err.println("sub: "+thisJoinPoint);
    }
======= 7b831ff:"tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.java"

  public void testInclusionAndPattern() {
    runTest("Inclusion and patterns");  		
  }
  public void testExclusionAndPattern() {
  }
  public void testAndPatternsAspects() {
  }
      
        <compile
        	files="pkg\sub\Foo.aj, pkg\Main.aj"
        	options="-outjar base.jar"
        />
        <compile
        	files="tracing/Tracer.aj"
        />
        <run class="pkg.Main" ltw="aop-include.xml">
            <stderr>
                <line text="execution(void pkg.Main.foo())"/>
                <line text="Main.class"/>
            </stderr>
        </run>
    </ajc-test>
        <compile
        	files="pkg\sub\Foo.aj, pkg\Main.aj"
        	options="-outjar base.jar"
        />
        <compile
        	files="tracing/Tracer.aj"
        />
        <run class="pkg.Main" ltw="aop-exclude.xml">
            <stderr>
                <line text="execution(void pkg.sub.Foo.foo())"/>
            </stderr>
        </run>
    </ajc-test>    
        <compile
        	files="pkg\sub\Foo.aj, pkg\Main.aj"
        	options="-outjar base.jar"
        />
        <compile
        	files="tracing/Tracer.aj, tracing/staticinit/Tracer.aj, tracing/staticinit/sub/Tracer.aj"
        />
        <run class="pkg.Main" ltw="aop-aspectinclexcl.xml">
            <stderr>
                <line text="staticinitialization(pkg.Main.&lt;clinit&gt;)"/>
                <line text="staticinitialization(pkg.sub.Foo.&lt;clinit&gt;)"/>
            </stderr>
        </run>
    </ajc-test>       

======= cd9fd11:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= cd9fd11:"weaver/src/org/aspectj/weaver/CrosscuttingMembers.java"

======= cd9fd11:"weaver/src/org/aspectj/weaver/CrosscuttingMembers.java"

======= cd9fd11:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"


    public ValueChange(Q initValue) { }
        super(initValue);
    }
    public final synchronized void link(SyncValueGroup<T> ... list) {    }
    class SyncInteger extends SyncValueGroup<Integer> {
        public SyncInteger(int val) {
            super(new Integer(val));
        }
    }
    private SyncInteger a = new SyncInteger(1);
    public void testSyncValueGroup() {
        a.link(a);
    }
  before(): call(* *(..)) {}
 
======= ea4ff8a:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testGenericArrays_pr158624() { runTest("generics and arrays"); }
    
      <compile files="ValueChange.java" options="-1.5"/>
    </ajc-test> 
======= ea4ff8a:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

======= ea4ff8a:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"


======= fc39df1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= fc39df1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= fc39df1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

    static final Comparator MY_COMPARATOR = new Comparator() {
        public int compare(Object o1, Object o2) {
            return 0;
        }
    };
======= fc39df1:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

======= fc39df1:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testGetSourceSignature_pr148908() {
  }
  
    /////////////////////////////////////////
      <compile files="BadInterface.java" options="-emacssym"/>
    </ajc-test> 

======= e56a69a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

======= e56a69a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

    
    /** Returns "" if there is a problem */
    private String getPointcutStringFromAnnotationStylePointcut(AbstractMethodDeclaration amd) {
    	Annotation[] ans = amd.annotations;
    }
======= e56a69a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

======= e56a69a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

======= e56a69a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

    declare warning : (layering.SystemArchitektur.inDAOLayer() ) : "Whatever";
======= e56a69a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

    @Pointcut("within(dao.*)")
    public void inDAOLayer() {}
    
======= e56a69a:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testAnnotationStylePointcutNPE_pr158412() { runTest("annotation style pointcut npe"); }
  public void testAnnotationStylePointcutNPE_pr158412_2() { runTest("annotation style pointcut npe - 2"); }
    <ajc-test dir="bugs153/pr158412" title="annotation style pointcut npe">
      <compile files="layering/Layering.aj,layering/SystemArchitektur.java" options="-1.5"/>
    </ajc-test>
    <ajc-test dir="bugs153/pr158412" title="annotation style pointcut npe - 2">
      <compile files="layering/Layering.aj,layering/SystemArchitektur.java,dao/Foo.java" options="-1.5">
        <message kind="warning" line="3" text="Whatever"/>
      </compile>
    </ajc-test>
    

  declare parents: Aspect implements Interface;
======= 70ae0f8:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testIllegalStateExceptionGenerics_pr153845() { runTest("IllegalStateException at GenericSignatureParser.java"); }
    <ajc-test dir="bugs153/pr153845" title="IllegalStateException at GenericSignatureParser.java">
      <compile files="GenericType.java,Aspect.java,Aspect2.java,Interface.java" options="-1.5" outjar="blob.jar"/>
      <compile files="Nothing.java" aspectpath="blob.jar" options="-1.5" outjar="bang.jar"/>
    </ajc-test>
======= 70ae0f8:"weaver/src/org/aspectj/weaver/ReferenceType.java"


======= 090de7e:"runtime/src/org/aspectj/runtime/reflect/ConstructorSignatureImpl.java"

======= 090de7e:"runtime/src/org/aspectj/runtime/reflect/FieldSignatureImpl.java"

======= 090de7e:"runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.java"

======= 090de7e:"runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.java"

======= 090de7e:"runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.java"

======= 090de7e:"runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.java"

======= 090de7e:"runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.java"

======= 090de7e:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testNPEinConstructorSignatureImpl_pr155972 () {
  }
  
  public void testNPEinFieldSignatureImpl_pr155972 () {
  }
  
  public void testNPEinInitializerSignatureImpl_pr155972 () {
  }
  
    <ajc-test dir="bugs153/pr155972" title="NPE in ConstructorSignatureImpl">
      <compile files="ConstructorTest.java, SignatureImplAspect.aj" options="-Xlint:ignore"/>
      <run class="ConstructorTest">
        <stdout>
          <line text="ConstructorTest"/>
        </stdout>
      </run>
    </ajc-test>
    
    <ajc-test dir="bugs153/pr155972" title="NPE in FieldSignatureImpl">
      <compile files="FieldTest.java, SignatureImplAspect.aj" options="-Xlint:ignore"/>
      <run class="FieldTest">
        <stdout>
          <line text="intField"/>
        </stdout>
      </run>
    </ajc-test>
    
    <ajc-test dir="bugs153/pr155972" title="NPE in InitializerSignatureImpl">
      <compile files="InitializerTest.java, SignatureImplAspect.aj" options="-Xlint:ignore"/>
      <run class="InitializerTest">
        <stdout>
          <line text="InitializerTest"/>
        </stdout>
      </run>
    </ajc-test>
    

======= 14e8b7d:"loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java"

    	return ((loader!=null)?loader.getClass().getName()+"@"+Integer.toHexString(System.identityHashCode(loader)):"null");
======= 14e8b7d:"weaver/src/org/aspectj/weaver/tools/AbstractTrace.java"


======= 6be7097:"loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java"

    	return ((loader!=null)?loader.getClass().getName()+"@"+Integer.toHexString(loader.hashCode()):"null");
======= 6be7097:"weaver/src/org/aspectj/weaver/tools/AbstractTrace.java"

======= 6be7097:"weaver/src/org/aspectj/weaver/tools/AbstractTrace.java"

======= 6be7097:"weaver/testsrc/org/aspectj/weaver/AbstractTraceTest.java"

======= 6be7097:"weaver5/java5-src/org/aspectj/weaver/tools/Jdk14Trace.java"

======= 6be7097:"weaver5/java5-src/org/aspectj/weaver/tools/Jdk14Trace.java"

======= 6be7097:"weaver5/java5-src/org/aspectj/weaver/tools/Jdk14Trace.java"


======= 40cf610:"ajde/src/org/aspectj/ajde/ui/swing/OptionsFrame.java"

======= 40cf610:"bridge/src/org/aspectj/bridge/Version.java"

    private static long time = -1; // -1 = uninitialized
    public static long getTime() {
    	if (time==-1) {
    		long foundTime = NOTIME;
    	    // if not DEVELOPMENT version, read time text using format used to set time 
            try {
                SimpleDateFormat format = new SimpleDateFormat(SIMPLE_DATE_FORMAT);
                ParsePosition pos = new ParsePosition(0);
                Date date = format.parse(time_text, pos);
                if (date!=null) foundTime = date.getTime();
            } catch (Throwable t) {            
            }
            time = foundTime;
    	}
    	return time;
======= 40cf610:"bridge/testsrc/org/aspectj/bridge/VersionTest.java"

        Date date = new Date(Version.getTime());
======= 40cf610:"weaver/src/org/aspectj/weaver/AjAttribute.java"


======= 04fa1dc:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

    	boolean success = true;
    	
======= 04fa1dc:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

                        success = false;
======= 04fa1dc:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        /* We couldn't register one or more aspects so disable the adaptor */
        if (!success) {
        	disable();
    		warn("failure(s) registering aspects. Disabling weaver for class loader " + getClassLoaderName(loader));
        }
        
        else if (namespace == null) {
======= 04fa1dc:"loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java"

======= 04fa1dc:"loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java"

======= 04fa1dc:"loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java"

======= 04fa1dc:"loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java"

======= 04fa1dc:"loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java"

======= 04fa1dc:"loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java"

======= 04fa1dc:"loadtime/src/org/aspectj/weaver/loadtime/WeavingURLClassLoader.java"

            <line text="error Concrete-aspect 'TraceHelloWorld' could not be registered"/>
            <line text="warning failure(s) registering aspects. Disabling weaver for class loader"/>
            <line text="error Concrete-aspect 'TraceHelloWorld' could not be registered"/>
            <line text="warning failure(s) registering aspects. Disabling weaver for class loader"/>
======= 04fa1dc:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testReweavableAspectNotRegistered_pr129525 () {
  }
  
    <ajc-test dir="ltw" title="reweavableAspectNotRegistered error">
      <compile files="HelloWorld.java, ExceptionHandler.aj" options="-showWeaveInfo">
        <message kind="weave" text="Join point 'method-execution(void HelloWorld.main(java.lang.String[]))' in Type 'HelloWorld' (HelloWorld.java:3) advised by around advice from 'ExceptionHandler' (ExceptionHandler.aj:2)"/>
      </compile>
      <compile files="EmptyAspect.aj">
      </compile>
      <run class="HelloWorld" ltw="aop-missingaspect.xml">
        <stdout>
          <line text="Hello World!"/>
        </stdout>
        <stderr>
        	<line text="error aspect 'ExceptionHandler' woven into 'HelloWorld' must be defined to the weaver (placed on the aspectpath, or defined in an aop.xml file if using LTW)."/>
        </stderr>
      </run>
    </ajc-test>
    
======= 04fa1dc:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= 04fa1dc:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= 04fa1dc:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= 04fa1dc:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= 04fa1dc:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"


======= 8549d86:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= 8549d86:"loadtime/src/org/aspectj/weaver/loadtime/DefaultMessageHandler.java"

    boolean isDebug = false;
======= 8549d86:"loadtime/src/org/aspectj/weaver/loadtime/DefaultMessageHandler.java"

        if (kind.isSameOrLessThan(IMessage.DEBUG)) {
            return !isDebug;
        }
======= 8549d86:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

    private final static String OPTION_debug = "-debug";
======= 8549d86:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

            }  else if (arg.equalsIgnoreCase(OPTION_debug)) {
                weaverOption.debug = true;
======= 8549d86:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

        if (weaverOption.debug) {
            weaverOption.messageHandler.dontIgnore(IMessage.DEBUG);
        }
======= 8549d86:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

        boolean debug;
    <target name="RunThemAllWithJavacCompiledAndLTW" depends="compile:javac, ltw"/>
    <target name="Compile time aspects declared to ltw weaver">
======= 8549d86:"tests/java5/ataspectj/ataspectj/TestHelper.java"

        if (message.getKind().isSameOrLessThan(IMessage.INFO));
        if (message.getKind().isSameOrLessThan(IMessage.DEBUG));
        else {
    <weaver options="-XlazyTjp -verbose -debug">
    <weaver options="-verbose -debug"/>
    <weaver options="-showWeaveInfo -verbose -debug"/>
    <weaver options="-verbose -debug -showWeaveInfo"/>
    <weaver options="-verbose -debug -showWeaveInfo -Xlint:warning"/>
    <weaver options="-verbose -debug -showWeaveInfo -Xlintfile:Xlint-nomatch.properties"/>
        <ant file="ajc-ant.xml" target="RunThemAllWithJavacCompiledAndLTW" verbose="true"/>
        		<line text="debug not weaving 'com.foo.bar.Test$$EnhancerByCGLIB$$12345'"/>
        		<line text="debug weaving 'com.foo.bar.Test'"/>
        <ant file="ajc-ant.xml" target="Compile time aspects declared to ltw weaver" verbose="true"/>
            options="-showWeaveInfo -verbose"
            options="-showWeaveInfo -verbose"
                <line text="debug generating class 'ConcreteAspect'"/>
                <line text="debug weaving 'Main'"/>
            <line text="debug not weaving"/>
======= 8549d86:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= 8549d86:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= 8549d86:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

            ignore(IMessage.DEBUG);

  @After("staticinitialization(*)")
  public void x(JoinPoint.StaticPart thisJoinPointStaticPart) {
    System.out.println("after initialization "+thisJoinPointStaticPart);
  }
  static {
  }
  public static void main(String []argv) {
  }
  after(): staticinitialization(*) {
    System.out.println("after initialization "+thisJoinPointStaticPart);
  }
  static {
  }
  public static void main(String []argv) {
    System.out.println("InstanceExists?"+Aspects.hasAspect(MyAspect.class));
  }
======= 945a257:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testIncorrectStaticinitializationWeaving_pr149560_1() { runTest("incorrect staticinitialization weaving - codestyle");}
  public void testIncorrectStaticinitializationWeaving_pr149560_2() { runTest("incorrect staticinitialization weaving - annstyle");}
  public void testIncorrectDeprecatedAnnotationProcessing_pr154332() { runTest("incorrect deprecated annotation processing");}
    <ajc-test dir="bugs153/pr149560" title="incorrect staticinitialization weaving - codestyle">
      <compile files="CodeStyle.java" options="-1.5 -showWeaveInfo">
        <message kind="weave" text="Join point 'staticinitialization(void MyAspect.&lt;clinit&gt;())' in Type 'MyAspect' (CodeStyle.java:3) advised by after advice from 'MyAspect' (CodeStyle.java:4)"/>
        <message kind="weave" test="Join point 'staticinitialization(void CodeStyle.&lt;clini&gt;())' in Type 'CodeStyle' (CodeStyle.java:9) advised by after advice from 'MyAspect' (CodeStyle.java:4)"/>
      </compile>
      <run class="CodeStyle">
        <stdout>
          <line text="after initialization staticinitialization(MyAspect.&lt;clinit&gt;)"/>
          <line text="after initialization staticinitialization(CodeStyle.&lt;clinit&gt;)"/>
          <line text="InstanceExists?true"/>
        </stdout>
      </run>
    </ajc-test>
    
    <ajc-test dir="bugs153/pr149560" title="incorrect staticinitialization weaving - annstyle">
      <compile files="AnnStyle.java" options="-1.5 -showWeaveInfo">
        <message kind="weave" text="Join point 'staticinitialization(void MyAspect.&lt;clinit&gt;())' in Type 'MyAspect' (AnnStyle.java:5) advised by after advice from 'MyAspect' (AnnStyle.java:7)"/>
        <message kind="weave" test="Join point 'staticinitialization(void AnnStyle.&lt;clini&gt;())' in Type 'AnnStyle' (AnnStyle.java:12) advised by after advice from 'MyAspect' (AnnStyle.java:7)"/>
      </compile>
      <run class="AnnStyle">
        <stdout>
          <line text="after initialization staticinitialization(MyAspect.&lt;clinit&gt;)"/>
          <line text="after initialization staticinitialization(AnnStyle.&lt;clinit&gt;)"/>
          <line text="InstanceExists?true"/>
        </stdout>
      </run>
    </ajc-test>
    
======= 945a257:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= 945a257:"weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.java"

            tryStart, handler.getPrev(), handler, new ObjectType("java.lang.Throwable"), false
======= 945a257:"weaver/src/org/aspectj/weaver/patterns/PerSingleton.java"

        	if (getKind()==SINGLETON) { // pr149560
        	} else {
        	}

 
    pointcut test() : within(@Marker *);// *);
   
    declare warning: staticinitialization(@Deprecated *): "deprecated";   
    declare warning: staticinitialization(@Marker *): "marker";   
   
    public static void main(String argz[]) {
        new Baz().foo();
    }
 
    public void foo() {}
 
 @interface Marker {
 
======= 59123b0:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

    <ajc-test dir="bugs153/pr154332" title="incorrect deprecated annotation processing">
      <compile files="Annot.java" options="-1.5">
        <message kind="warning" line="5" text="marker"/>
        <message kind="warning" line="31" text="marker"/>
        <message kind="warning" line="5" text="deprecated"/>
        <message kind="warning" line="31" text="deprecated"/>
      </compile>
    </ajc-test>
    
======= 59123b0:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"


======= 82e3e13:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= 82e3e13:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"

======= 82e3e13:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"

    public void testArrayArgsSig() throws Exception {
    	Method invokeMethod = Method.class.getMethod("invoke", new Class[] { Object.class, Object[].class});
    	ResolvedMember reflectionMethod = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMethod(invokeMethod, world);
    	String exp = "(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;";
    	assertTrue("Expected: \n"+exp+"\n but got:\n"+reflectionMethod.getSignature(), reflectionMethod.getSignature().equals(exp));
    }
======= 82e3e13:"weaver5/java5-testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"

======= 82e3e13:"weaver5/java5-testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"

    public void testArrayArgsSig() throws Exception {
    	Method invokeMethod = Method.class.getMethod("invoke", new Class[] { Object.class, Object[].class});
    	ResolvedMember reflectionMethod = ReflectionBasedReferenceTypeDelegateFactory.createResolvedMethod(invokeMethod, world);
    	String exp = "(Ljava/lang/Object;[Ljava/lang/Object;)Ljava/lang/Object;";
    	assertTrue("Expected: \n"+exp+"\n but got:\n"+reflectionMethod.getSignature(), reflectionMethod.getSignature().equals(exp));
    }

======= 07c2189:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= 07c2189:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

    	
    	// If the unused argument is in a pointcut, don't report the problem (for now... pr148219)
    	if (localDecl!=null && localDecl instanceof Argument) {
    		Argument arg = (Argument)localDecl;
    		if (arg.binding!=null && arg.binding.declaringScope!=null) {
    			ReferenceContext context = arg.binding.declaringScope.referenceContext();
    			if (context!=null && context instanceof PointcutDeclaration) return;
    		}
    	}
======= 07c2189:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

    pointcut getResourceString(String key): args(key, ..) &&
    call (* *.getResourceString(String, ..));
    String around(String key):getResourceString(key) {
        return key;
    }
======= 07c2189:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testUnwantedPointcutWarning_pr148219() { runTest("unwanted warning for pointcut");}
    <ajc-test dir="bugs153/pr148219" title="unwanted warning for pointcut">
      <compile files="MyMessages.java" options="-1.5 -Xlint:ignore -warn:+unusedArgument"/>
    </ajc-test>
    

======= 039be68:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        world.performExtraConfiguration(weaverOption.xSet);
======= 039be68:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

    private static final String OPTIONVALUED_Xset = "-Xset:";
======= 039be68:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

            } else if (arg.startsWith(OPTIONVALUED_Xset)) {
                if (arg.length() > OPTIONVALUED_Xlint.length()) {
                    weaverOption.xSet = arg.substring(OPTIONVALUED_Xset.length()).trim();
                }            	
======= 039be68:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

======= 039be68:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

        String xSet;
======= 039be68:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

======= 039be68:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

======= 039be68:"tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.java"

  	public void testXsetEnabled () {
  		runTest("Set Xset properties enabled");
  	}
  	public void testXsetDisabled () {
  		runTest("Set Xset properties disabled");
  	}
  	
      title="Set Xset properties enabled"
      keywords="xSet, ltw">
        <compile
        	files="Main.java,Aspect1.aj"
        >
        </compile>	
        <run class="Main" ltw="aop-xset-verbose.xml" xlintfile="Xlint-empty.properties">
        </run>
    </ajc-test>
      title="Set Xset properties disabled"
      keywords="xSet, ltw">
        <compile
        	files="Main.java,Aspect1.aj"
        >
        </compile>	
        <run class="Main" ltw="aop-xset-verbose.xml" xlintfile="Xlint-empty.properties">
        </run>
    </ajc-test>
    

======= a38edd3:"bridge/src/org/aspectj/bridge/MessageUtil.java"


======= 387c3ac:"bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"

======= 387c3ac:"bcel-builder/src/org/aspectj/apache/bcel/util/ClassLoaderRepository.java"

 * @version $Id: ClassLoaderRepository.java,v 1.6 2006/08/08 11:26:28 aclement Exp $
  private WeakHashMap /*<String classname,JavaClass>*/loadedClassesLocalCache = new WeakHashMap(); 
  private static Map /*<URL,JavaClass>*/loadedUrlsSharedCache = new HashMap(); 
  public static boolean useSharedCache = true;
  
  private static long timeManipulatingURLs = 0L; 
  private static long timeSpentLoading     = 0L;
  private static int  classesLoadedCount = 0;
  private static int  cacheHitsShared    = 0;
  private static int  missSharedEvicted  = 0; // Misses in shared cache access due to reference GC
  private static int  misses             = 0;
  private int  cacheHitsLocal     = 0;
  private int  missLocalEvicted   = 0; // Misses in local cache access due to reference GC
  static {
    useSharedCache = System.getProperty("org.aspectj.apache.bcel.useSharedCache","true").equalsIgnoreCase("true");
  }
  
   * Store a new JavaClass into this repository as a soft reference and return the reference
   */
  private Reference storeClassAsReference( JavaClass clazz ) {
    loadedClassesLocalCache.put( clazz.getClassName(), ref);		       
    clazz.setRepository( this );
    return ref;
  }
  
  /**
   * Store a reference in the shared cache
   */
  private void storeReferenceShared(URL url, Reference ref) {
  }
  /**
    loadedClassesLocalCache.remove(clazz.getClassName());
   * Find an already defined JavaClass in the local cache.
    Object o = loadedClassesLocalCache.get( className );
    if (o != null) {
    	o = ((Reference)o).get();
    	if (o != null) {
    		return (JavaClass)o;
    	} else {
    		missLocalEvicted++;
    	}
    return null;
  }
  
  /**
   * Find an already defined JavaClass in the shared cache.
   */
  private JavaClass findClassShared(URL url) {
  
  public JavaClass loadClass( String className ) throws ClassNotFoundException {
    // Check the local cache
    JavaClass clazz = findClass(className);
    if (clazz != null) { cacheHitsLocal++; return clazz; }
    	// Work out the URL
    	long time = System.currentTimeMillis();
    	java.net.URL url = (useSharedCache?loader.getResource( classFile + ".class" ):null);
    	if (useSharedCache && url==null) throw new ClassNotFoundException(className + " not found.");
        if (is == null) { // TODO move this up?
    	  throw new ClassNotFoundException(className + " not found.");
        }
        ClassParser parser = new ClassParser( is, className );
        clazz = parser.parse();
        // Store it in both caches
        Reference ref = storeClassAsReference( clazz );
        storeReferenceShared(url,ref);
        timeSpentLoading += (System.currentTimeMillis() - time);
        return clazz;
  
   * Produce a report on cache usage.
   */
  public String reportAllStatistics() {
  }
  
  public int reportLocalCacheHits() {
  }
  public static int reportSharedCacheHits() {
  }
  
  /**
   * Reset statistics and clear all caches
   */
  public void reset() {
  }
  
  
  /** Clear all entries from the local cache */
      loadedClassesLocalCache.clear();
  }
  /** Clear all entries from the shared cache */
  public static void clearShared() {
======= 387c3ac:"bcel-builder/testsrc/org/aspectj/apache/bcel/classfile/tests/AllTests.java"

======= 387c3ac:"bcel-builder/testsrc/org/aspectj/apache/bcel/classfile/tests/AllTests.java"

 * Tests create a simple classloader repository configuration and check sharing of information.
 */

======= f239f2a:"testing/newsrc/org/aspectj/testing/AntSpec.java"

            + File.pathSeparator + ".." + File.separator + "lib/bcel/bcel.jar"
    		+ File.pathSeparator + ".." + File.separator + "lib/asm/asm-aj.jar";
======= f239f2a:"testing/newsrc/org/aspectj/testing/AntSpec.java"

======= f239f2a:"testing/newsrc/org/aspectj/testing/AntSpec.java"

    <weaver options="-1.5 -showWeaveInfo">
        <exclude within="ataspectj..*"/>
    </weaver>
    <aspects>
        <aspect name="ataspectj.bugs.AspectOfWhenAspectNotInIncludeTest.TestAspect"/>
        <aspect name="ataspectj.bugs.AspectOfWhenAspectNotInIncludeTest.TestAspectForAspect"/>
    </aspects>
======= f239f2a:"testing/newsrc/org/aspectj/testing/AntSpec.java"

    <weaver options="-1.5 -verbose">
        <exclude within="ataspectj..*"/>
    </weaver>
    <aspects>
        <aspect name="ataspectj.bugs.NotAspect"/>
    </aspects>
======= f239f2a:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"

    public void testAspectOfWhenAspectExcluded_pr152873() {
        runTest("AspectOfWhenAspectExcluded");
    }
    public void testAspectOfWhenNonAspectExcluded_pr152873() {
    	runTest("AspectOfWhenNonAspectExcluded");
    }
    <ajc-test dir="java5/ataspectj" title="AspectOfWhenAspectExcluded">
        <compile
            files="ataspectj/bugs/AspectOfWhenAspectNotInIncludeTest.java,ataspectj/TestHelper.java"
            options="-1.5 -XterminateAfterCompilation"/>
        <run class="ataspectj.bugs.AspectOfWhenAspectNotInIncludeTest" ltw="ataspectj/bugs/aop-aspectofwhenaspectexcludedtest.xml"/>
    </ajc-test>
    <ajc-test dir="java5/ataspectj" title="AspectOfWhenNonAspectExcluded">
        <compile
            files="ataspectj/bugs/NotAspect.java"
            options="-1.5 -XterminateAfterCompilation"/>
        <run class="ataspectj.bugs.NotAspect" ltw="ataspectj/bugs/aop-aspectofwhennonaspectexcludedtest.xml"/>
    </ajc-test>
======= f239f2a:"weaver/src/org/aspectj/weaver/World.java"

======= f239f2a:"weaver/src/org/aspectj/weaver/World.java"

 * Copyright (c) 2006 Contributors
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *     Eugene Kuleshov, Ron Bodkin    initial implementation 
 * ******************************************************************/
======= f239f2a:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= f239f2a:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= f239f2a:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

     * @return true if even valid to weave: either with an accept check or to munge it for @AspectJ aspectof support
    private boolean couldWeave (String name, byte[] bytes) {
======= f239f2a:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

    	if (delegateForCurrentClass==null) {
    		if (weaver.getWorld().isASMAround()) return asmCheckAnnotationStyleAspect(bytes);
    		else ensureDelegateInitialized(name, bytes);
    	}

======= 908b405:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"

        if (begin==-1)
        	return "(no source information available)"; // Dont like this - why does it occur? pr152835

    before() : cflow(execution(* *(..))) {}
  declare parents: EMA extends C;
  public void EMA.m() {}
  abstract void m();
======= ff2377a:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testDecpAndCflowadderMungerClash_pr152631() { runTest("decp and cflowadder munger clash");}
    <ajc-test dir="bugs153/pr152631" title="decp and cflowadder munger clash">
      <compile files="EMA.java" options="-1.5"/>
    </ajc-test>
    
======= ff2377a:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

                            if (m.getMunger()!=null && m.getMunger().getKind() == ResolvedTypeMunger.Method) {
======= ff2377a:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

                            } else if (m.getMunger()!=null && m.getMunger().getKind() == ResolvedTypeMunger.MethodDelegate) {

======= 7aa6cfe:"build/testsrc/org/aspectj/build/BuildModuleTests.java"

            Arrays.asList(new String[]{"src", "testsrc", "java5-src", "java5-testsrc", "aspectj-src"}));
======= 7aa6cfe:"build/testsrc/org/aspectj/build/BuildModuleTests.java"

        // skip (testdata) packages fluffy, reflect
    public void testLicense_ajdoc() {
        checkLicense("ajdoc");
    }
    
    public void testLicense_loadtime() {
        checkLicense("loadtime");
    }
    
    public void testLicense_loadtime5() {
        checkLicense("loadtime5");
    }
    
    public void testLicense_weaver5() {
        checkLicense("weaver5");
    }

======= 9664058:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java"

======= 9664058:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java"

======= 9664058:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java"

======= 9664058:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java"

    		if (weaveQueuedEntries()) droppingBackToFullBuild=true;
======= 9664058:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java"

======= 9664058:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java"

======= 9664058:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java"

======= 9664058:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java"

    after () throwing (Throwable th) :  execution(* *(..)) {
======= 9664058:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjPipeliningCompilerAdapter.java"

 
    after () throwing (Throwable th) :  execution(* *(..)) {
======= 9664058:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


======= bebb364:"loadtime5/java5-src/org/aspectj/weaver/loadtime/Agent.java"

    	/* Handle duplicate agents */
    	if (s_instrumentation != null) {
    		return;
    	}
======= bebb364:"loadtime5/java5-src/org/aspectj/weaver/loadtime/Agent.java"

======= bebb364:"loadtime5/java5-src/org/aspectj/weaver/loadtime/Agent.java"

======= bebb364:"loadtime5/java5-src/org/aspectj/weaver/loadtime/Agent.java"

    public void dontIgnore(IMessage.Kind kind) {
    	
    }
    <target name="Duplicate JVMTI agents">
        <copy file="${aj.root}/tests/java5/ataspectj/aop-messagehandler.xml"
              tofile="${aj.sandbox}/META-INF/aop.xml"/>
        <java fork="yes" classname="HelloWorld" failonerror="yes">
            <classpath refid="aj.path"/>
            <!-- use META-INF/aop.xml style -->
            <classpath>
                <pathelement path="${aj.sandbox}/aspects.jar"/>
            </classpath>
            <jvmarg value="-javaagent:${aj.root}/lib/test/loadtime5.jar"/>
            <jvmarg value="-javaagent:${aj.root}/lib/test/loadtime5.jar"/>
            <jvmarg value="-Daj.weaving.verbose=true"/>
            <jvmarg value="-Djava.util.logging.config.file=${aj.root}/weaver5/testdata/logging.properties"/>
        </java>
    </target>
======= bebb364:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testDuplicateJVMTIAgents_pr151938() {runTest("Duplicate JVMTI agents");};
    <ajc-test dir="java5/ataspectj" title="Duplicate JVMTI agents">
        <compile files="HelloWorld.java"/>
        <compile files="MessageHandler.java"/>
        <compile files="Aspect.aj" options="-outxml -outjar aspects.jar"/>
        <ant file="ajc-ant.xml" target="Duplicate JVMTI agents" verbose="true"/>
    </ajc-test>

  void publish();
  StackTraceElement[] getStackTrace();
  public <T extends E> T create(Class<T> theObjectType, Object[]
  public <T extends IMessage> T create(Class<T> theObjectType, Object[]
    return null;
  }
  public static void main(String[] args) {
    IErrorMessage message = new MessageFactory().create(IErrorMessage.class,
  }
======= 68c36e3:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  //public void testGenericsProblem_pr151978() { runTest("generics problem");}
  public void testMissingLineNumbersInStacktraceBefore_pr145442() { runTest("missing line numbers in stacktrace before");}
  public void testMissingLineNumbersInStacktraceAfter_pr145442() { runTest("missing line numbers in stacktrace after");}
  public void testMissingLineNumbersInStacktraceAround_pr145442() { runTest("missing line numbers in stacktrace around");}
    <ajc-test dir="bugs153/pr151978" title="generics problem">
      <compile files="IMessage.java" options="-1.5">
      </compile>
    </ajc-test>
    

======= e4ab0ae:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= e4ab0ae:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= e4ab0ae:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    		// Find the last *correct* return - this is a method with a non-void return type
    		// so ignore RETURN
    		Instruction  newReturnInstruction = null;
    		int i=returns.size()-1;
    		while (newReturnInstruction == null && i>=0) {
    			InstructionHandle ih = (InstructionHandle)returns.get(i);
    			if (!(ih.getInstruction() instanceof RETURN)) {
    				newReturnInstruction = Utility.copyInstruction(ih.getInstruction());
    			}
    			i--;
    		}
        	returnInstructions.append(newReturnInstruction);
        	InstructionHandle lastReturnHandle = (InstructionHandle)returns.get(returns.size() - 1);
        	Instruction newReturnInstruction = Utility.copyInstruction(lastReturnHandle.getInstruction());

======= 54f7bb4:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseSourceContext.java"


======= 397a19d:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

        	synchronized (loader) {
                WeavingAdaptor weavingAdaptor = WeaverContainer.getWeaver(loader, weavingContext);
                if (weavingAdaptor == null) {
            		if (trace.isTraceEnabled()) trace.exit("preProcess",bytes);
                	return bytes;
                }
                return weavingAdaptor.weaveClass(className, bytes);

======= 357bbe9:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testMatchVolatileField_pr150671() {runTest("match volatile field");};
  
  
    <ajc-test dir="bugs153" title="match volatile field">
      <compile files="pr150671.aj" options="-Xset:activateLightweightDelegates=false">
        <message kind="error" line="7" text="Changing state"/>
        <message kind="error" line="8" text="test"/>
      </compile>
    </ajc-test>
======= 357bbe9:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

    	return (modifiers & Constants.ACC_BRIDGE)!=0 && getKind().equals(METHOD);

  public void m(B b) {
  }
  public static void main(String []argv) {
    new Foo<Interface1,Impl1>();
   }
  before(): staticinitialization(Fo*) { }
  before(): call(Fo*.new(..)) { }
    <aspects>
         <aspect name="X"/> 
    </aspects>
======= 369de87:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  // public void testVisibilityProblem_pr149071()                 { runTest("visibility problem");}
  // public void testAdviceNotWovenAspectPath_pr147841()          { runTest("advice not woven on aspectpath");}
  public void testGenericSignatures_pr148409()                 { runTest("generic signature problem"); }
     <ajc-test dir="bugs153/pr148409" title="generic signature problem">
      <compile files="Blurgh.java" options="-1.5"/>
      <compile files="X.java" options="-1.5 -Xlint:ignore"/>
      <run class="Blurgh" options="-1.5" ltw="aop.xml"/>
    </ajc-test>    
    
======= 369de87:"weaver/src/org/aspectj/weaver/UnresolvedType.java"


======= 82f217f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= 82f217f:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

======= 82f217f:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testVerificationFailureForAspectOf_pr148693() {
  }
======= 82f217f:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

 * Copyright (c) 2006 IBM 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
 * Not quite the right place for this class..
 */

======= f6834c7:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

            		if (level.equals("1.5") || level.equals("5")) {
======= f6834c7:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

    public A() { }
    public void setUniqueID(Object o) {}
    public B() {}    
    public void method() {
        B b = new B();
        b.setUniqueID(null);
    }
======= f6834c7:"tests/src/org/aspectj/systemtest/ajc153/Ajc153Tests.java"

  public void testIllegalStateException_pr148737() { runTest("illegalstateexception for non generic type");}
    <ajc-test dir="bugs153/pr148737" title="illegalstateexception for non generic type">
      <compile files="A.java" options="-source 5 -target 5">
        <message kind="warning" line="18" text="advice defined in TestAspect has not been applied"/>
      </compile>
    </ajc-test>
    

======= 2f2f568:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

  // tests added post 152rc1 and before final
  // tests adding during 152 development
======= 2f2f568:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

======= 2f2f568:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

======= 2f2f568:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

            	if (!(subMethod.isStatic() && subMethod.getName().startsWith("access$"))) { // ignore generated accessors
                  cont = enforceDecpRule3_visibilityChanges(weaver, newParent, superMethod, subMethod) && cont;
                }
======= 2f2f568:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

          superReturnTypeSig = superReturnTypeSig.replace('.','/');
          subReturnTypeSig = subReturnTypeSig.replace('.','/');
======= 2f2f568:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"


    public static void main(String argz[]) {
        if (!Asp.hasAspect()) 
          throw new RuntimeException("ou est le aspect?");
        System.out.println("Can call aspectOf? "+Asp.aspectOf());
    }
        if (name.equals("aspectOf") || name.equals("hasAspect")) continue;
======= 21e06a6:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

  public void testSeparateCallAspectOf_pr148727() { runTest("separate compilation calling aspectOf and hasAspect"); }
  public void testIntegratedCallAspectOf_pr148727() { runTest("integrated compilation calling aspectOf and hasAspect"); }
======= 21e06a6:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

    <ajc-test dir="bugs152/binaryDecp" title="incorrect overrides evaluation - 1.4">
      <compile files="IsItSynthetic.java" options="-1.5"/>
      <compile files="Top.java" options="-source 1.5 -target 1.5" outjar="a.jar"/>
      <compile files="Bottom.java" classpath="$sandbox/a.jar" options="-source 1.4 -target 1.4" outjar="b.jar"/>
      <compile files="Middle.java" classpath="$sandbox/a.jar" options="-source 1.4 -target 1.4" outjar="c.jar"/>
      <compile files="X2.aj" classpath="$sandbox/a.jar;$sandbox/b.jar;$sandbox/c.jar" options="-Xlint:ignore" outjar="x.jar"/>
      <run class="Bottom" classpath="a.jar;b.jar;c.jar;x.jar" ltw="aop.xml"/>
        <!--message kind="weave" text="Setting superclass of type 'Bottom' (Bottom.java) to 'Middle' (X2.aj)"/-->
    </ajc-test>
    
    
    <ajc-test dir="bugs152/pr148727"  pr="148727"
        <run class="Client">
          <stdout>
            <line text="Can call aspectOf? Asp@"/>
          </stdout>
        </run>
    </ajc-test>
    <ajc-test dir="bugs152/pr148727"  pr="148727"
        <run class="Client">
          <stdout>
            <line text="Can call aspectOf? Asp@"/>
          </stdout>
        </run>
    </ajc-test>
======= 21e06a6:"weaver/src/org/aspectj/weaver/NameMangler.java"


======= b59b036:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java"


======= 99d1c18:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"


  public static void main(String []argv) {
    byte[][] bytes = new byte[][]{{0},{1}};
  }
  after() returning(Object o) : call(*[][].new(..)) {
    System.err.println("new array: "+o.getClass());
  }
======= 792d1df:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

  public void testFreakyNewArrayJoinpoint_pr148786() { runTest("freaky new array joinpoint"); }
    
    <ajc-test dir="bugs152/pr148786" title="freaky new array joinpoint">
        <compile files="A.java" options="-Xjoinpoints:arrayconstruction"/>
        <run class="A">
          <stderr>
            <line text="new array: class [[B"/>
          </stderr>
        </run>
    </ajc-test>    
======= 792d1df:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"


======= c9f311a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AdviceDeclaration.java"

======= c9f311a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AdviceDeclaration.java"

======= c9f311a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/DeclareDeclaration.java"

======= c9f311a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/DeclareDeclaration.java"

======= c9f311a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"

======= c9f311a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= c9f311a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= c9f311a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= c9f311a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= c9f311a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

  private int f;
  public void foo() {}
  private void bar() {}
  
  public static void main(String[] args) {
    Field[] twsFields = TheWholeShow.class.getDeclaredFields();
    for (Field f : twsFields) {
      if (!f.getName().equals("f") && !f.getName().equals("x")) {
        if (!f.isSynthetic()) {
          System.err.println("Found non-synthetic field: " + f.getName());
          throw new IllegalStateException("Found non-synthetic field: " + f.getName());
        }
        if (!Modifier.isStatic(f.getModifiers()) && !Modifier.isTransient(f.getModifiers())) {
          System.err.println("Found non-transient field: " + f.getName());
          throw new IllegalStateException("Found non-transient field: " + f.getName());        
        }
      }
    }
    
    Method[] twsMethods = TheWholeShow.class.getDeclaredMethods();
    for (Method m: twsMethods) {
      if (! (m.getName().equals("foo") || m.getName().equals("bar") || m.getName().equals("<init>") ||
             m.getName().equals("main") || m.getName().equals("checkOnlyHasAdviceMembers") || m.getName().equals("getX")) ) {
        if (!m.isSynthetic()) {
          System.err.println("Found non-synthetic method: " + m.getName());
          throw new IllegalStateException("Found non-synthetic method: " + m.getName());        
        }
      }
    }
    
    checkOnlyHasAdviceMembers(MakeITDs.class);
    checkOnlyHasAdviceMembers(Declares.class);
    checkOnlyHasAdviceMembers(Advises.class);
    checkOnlyHasAdviceMembers(PerObject.class);
    checkOnlyHasAdviceMembers(PTW.class);
    checkOnlyHasAdviceMembers(Priv.class);
    
  }
  
  
  private static void checkOnlyHasAdviceMembers(Class c) {
    Method[] ms = c.getDeclaredMethods();
    Field[] fs = c.getDeclaredFields();
    
    for (Field f : fs) {
      if (!f.isSynthetic()) {
          System.err.println("Found non-synthetic field: " + f.getName() + " in " + c.getName());
          throw new IllegalStateException("Found non-synthetic field: " + f.getName());      
      }
    }
    
    for (Method m : ms) {
      if (!m.isSynthetic()) {
        String name = m.getName();
        if ( ! (name.startsWith("ajc$before") || name.startsWith("ajc$after") || name.startsWith("ajc$around")  ||
             name.startsWith("ajc$interMethod$"))) {
          System.err.println("Found non-synthetic method: " + m.getName() + " in " + c.getName());
          throw new IllegalStateException("Found non-synthetic method: " + m.getName());                
        } else if (name.startsWith("ajc$around") && name.endsWith("proceed")) {
          System.err.println("Found non-synthetic method: " + m.getName() + " in " + c.getName());
          throw new IllegalStateException("Found non-synthetic method: " + m.getName());                        
        }
      }
    }
  }
  public int TheWholeShow.x = 5;
  private int TheWholeShow.y = 6;
  int TheWholeShow.z = 7;
  
  public int TheWholeShow.getX() { return x; }
  
  private int TheWholeShow.getY() { return y; }
  
  int TheWholeShow.getZ() { return z; }
  interface Foo {}
  
  declare parents : TheWholeShow implements Foo;
  
  declare warning : execution(* TheWholeShow.notThere(..)) : "foo";
  declare soft : Exception : execution(* TheWholeShow.foo(..));
  
  pointcut pc() : execution(* TheWholeShow.*(..));
  before() : pc() {}
  Object around(Object tws) : pc() && this(tws) {
    return proceed(new TheWholeShow());
  }
  
  after() : pc() {}
  
  after() returning : pc() {}
  
  after() throwing : pc() {}
  
  
  before() : set(* x) && cflow(execution(* TheWholeShow.*(..))) {}
  
 before(TheWholeShow tws) : execution(* TheWholeShow.foo()) && this(tws) {
 	tws.bar();
 	tws.f = 12;
 }
          <line text="public transient java.lang.String Test.ajc$interField$Declaration1$TestInterface$secondProperty has annotation:true"/>
          <line text="public transient java.lang.String Test.ajc$interField$Declaration2$TestInterface$secondProperty has annotation:true"/>
======= c9f311a:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

  public void testSyntheticAjcMembers_pr147711() { runTest("synthetic ajc$ members"); }
    </ajc-test>
    
    <ajc-test dir="features152/synthetic" title="synthetic ajc$ members">
        <compile files="TheWholeShow.aj" options="-1.5"/>
        <run class="TheWholeShow"/>
======= c9f311a:"weaver/src/org/aspectj/weaver/NameMangler.java"

======= c9f311a:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= c9f311a:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= c9f311a:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

   			  ConstantPoolGen cpg = myGen.getConstantPool();
   			  int index = cpg.addUtf8("Synthetic");
   			  Attribute synthetic  = new Synthetic(index, 0, new byte[0], cpg.getConstantPool());
   			  newAttrs[newAttrs.length - 1] = synthetic;
   			  field.setAttributes(newAttrs);
======= c9f311a:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= c9f311a:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= c9f311a:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    	forceSyntheticForAjcMagicMembers();
    	
======= c9f311a:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        	if (enclosingClass.getWorld().isInJava5Mode()) {
        		gen.setModifiers(gen.getModifiers() | ACC_SYNTHETIC);
        	}
        	// belt and braces, do the attribute even on Java 5 in addition to the modifier flag
   			ConstantPoolGen cpg = gen.getConstantPool();
   			int index = cpg.addUtf8("Synthetic");
   			gen.addAttribute(new Synthetic(index, 0, new byte[0], cpg.getConstantPool()));        		
======= c9f311a:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    private void forceSyntheticForAjcMagicMembers() {	
    
    private boolean inAspect() {
    	BcelObjectType objectType = enclosingClass.getBcelObjectType();
    	return (objectType == null ? false : objectType.isAspect()); 
    }
  private static final org.aspectj.lang.JoinPoint$EnclosingStaticPart ajc$tjp_0 [Synthetic]
  private static final org.aspectj.lang.JoinPoint$EnclosingStaticPart ajc$tjp_1 [Synthetic]
                    ALOAD_0     // LHelloWorld; this   (line 5)
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0 [Synthetic]
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_1 [Synthetic]
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_2 [Synthetic]
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_3 [Synthetic]
                    ALOAD_0     // LHelloWorld; this   (line 5)
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0 [Synthetic]
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_1 [Synthetic]
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_2 [Synthetic]
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_3 [Synthetic]
                    ALOAD_0     // LHelloWorld; this   (line 5)
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0 [Synthetic]
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_1 [Synthetic]
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_2 [Synthetic]
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_3 [Synthetic]
                    ALOAD_0     // LHelloWorld; this   (line 5)
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_0 [Synthetic]
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_1 [Synthetic]
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_2 [Synthetic]
  private static final org.aspectj.lang.JoinPoint$StaticPart ajc$tjp_3 [Synthetic]
                    ALOAD_0     // LHelloWorld; this   (line 5)

 * Understands . . .
 *
 * @author Randy Stearns
 */
    public void test1() {
        assertEquals("1a WRONG!", false, invert1a());
        assertEquals("1b WRONG!", true, invert1b());
        assertEquals("2 WRONG!", false, invert2());
        assertEquals("3 WRONG!", true, invert3());
        assertEquals("4 WRONG!", true, invert4());
        assertEquals("5 WRONG!", false, invert5());
    }
    
    private void assertEquals(String msg, boolean a, boolean b) {
    	if (a != b) {
    		throw new RuntimeException(msg);
    	}
    }
    private boolean invert1a() {
        return ! true;
    }
    private boolean invert1b() {
        return ! false;
    }
    private boolean invert2() {
    	boolean ret = false;
    	try {
    	}
    	catch (RuntimeException t) {
    	}
   		LoggingAspect.aspectOf().ajc$afterReturning$test_LoggingAspect$1$188fbb36();
   		return ret;
    }
    private boolean invert3() {
        return ! isFalse();
    }
    private boolean invert4() {
        boolean temp = isFalse();
        return ! temp;
    }
    private boolean invert5() {
        boolean temp = isTrue();
        return ! temp;
    }
    private boolean isTrue() {
        return true;
    }
    private boolean isFalse() {
        return false;
    }
    public void ajc$afterReturning$test_LoggingAspect$1$188fbb36()  {
    }
    
    private static void ajc$postClinit() {
    	ajc$perSingletonInstance = new LoggingAspect();
    }
 * Understands . . .
 *
 * @author Randy Stearns
 */
    public void test1() {
        assertEquals("1a WRONG!", false, invert1a());
        assertEquals("1b WRONG!", true, invert1b());
        assertEquals("2 WRONG!", false, invert2());
        assertEquals("3 WRONG!", true, invert3());
        assertEquals("4 WRONG!", true, invert4());
        assertEquals("5 WRONG!", false, invert5());
    }
    
    private void assertEquals(String msg, boolean a, boolean b) {
    	if (a != b) {
    		throw new RuntimeException(msg);
    	}
    }
    private boolean invert1a() {
        return ! true;
    }
    private boolean invert1b() {
        return ! false;
    }
    private boolean invert2() {
        return ! isTrue();
    }
    private boolean invert3() {
        return ! isFalse();
    }
    private boolean invert4() {
        boolean temp = isFalse();
        return ! temp;
    }
    private boolean invert5() {
        boolean temp = isTrue();
        return ! temp;
    }
    private boolean isTrue() {
        return true;
    }
    private boolean isFalse() {
        return false;
    }
        && within (test..*)
    after() : logPointcut() {
            System.out.println("exiting");
    }
 * Hello world!
 */
    protected void service(HttpServletRequest request, HttpServletResponse response)
            throws ServletException, IOException {
        booleanTest(response);
    }
    private void booleanTest(HttpServletResponse response) throws ServletException {
        PrintWriter out = null;
        try {
            out = response.getWriter();
        } catch (IOException ioe) {
            throw new ServletException("Could not get writer.");
        }
        out.println("Test 1a. Should be false. Was: " + invert1a());
        out.println("Test 1b. Should be true. Was: " + invert1b());
        out.println("Test 2. Should be false. Was: " + invert2());
        out.println("Test 3. Should be true. Was: " + invert3());
        out.println("Test 4. Should be true. Was: " + invert4());
        out.println("Test 5. Should be false. Was: " + invert5());
    }
    private boolean invert1a() {
        return ! true;
    }
    private boolean invert1b() {
        return ! false;
    }
    private Boolean invert2() {
        return new Boolean(! isTrue());
    }
    private Boolean invert3() {
        return new Boolean(! isFalse());
    }
    private boolean invert4() {
        boolean temp = isFalse();
        return ! temp;
    }
    private Boolean invert5() {
        boolean temp = isTrue();
        return new Boolean(! temp);
    }
    private boolean isTrue() {
        return true;
    }
    private boolean isFalse() {
        return false;
    }
                    RETURN
                    RETURN
                L0: NOP   (line 33)
                    INVOKESTATIC Three.aspectOf ()LThree;
                    RETURN
======= 426cbdc:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

  public void testJRockitBooleanReturn_pr148007() { runTest("jrockit boolean fun");}
  public void testJRockitBooleanReturn2_pr148007() { runTest("jrockit boolean fun (no aspects)");}
    </ajc-test>
    </ajc-test>    
======= 426cbdc:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        BcelVar returnValueVar = null;
        
        	if (this.getReturnType() != ResolvedType.VOID) {
        	} else {
        		retList = new InstructionList(ret);
        	}
            retList.append(ret);
======= 426cbdc:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        
======= 426cbdc:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        
======= 426cbdc:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    private boolean isLastInstructionInRange(InstructionHandle ih, ShadowRange aRange) {
    	return ih.getNext() == aRange.getEnd();
    }
    
======= 426cbdc:"weaver/src/org/aspectj/weaver/bcel/Utility.java"

    public static void replaceInstruction(
    	InstructionHandle ih,
    	InstructionList replacementInstructions,
    	LazyMethodGen enclosingMethod) {
    	InstructionList il = enclosingMethod.getBody();
    	InstructionHandle fresh = il.append(ih, replacementInstructions);
    	deleteInstruction(ih,fresh,enclosingMethod);
    }
       
                    ALOAD_0     // LFancyHelloWorld; this   (line 7)
    |               RETURN
    | | | |         ALOAD_1     // Ljava/io/PrintStream; out   (line 11)
    | | |           ALOAD_1     // Ljava/io/PrintStream; out   (line 13)
    | | |           ALOAD_2     // Ljava/lang/Exception; e
    | |             ALOAD_1     // Ljava/io/PrintStream; out   (line 15)
    |               RETURN
    | |             ILOAD_0     // I x   (line 21)
    | |             ISTORE_0     // I x
    | |             ILOAD_0     // I x
    | |             ASTORE 7
    |               ALOAD 7
                    ALOAD_0     // LHelloWorld; this   (line 5)
    |               RETURN
    |               RETURN
                    ALOAD_0     // LFancyHelloWorld; this   (line 7)
    | | |           ALOAD_1     // Ljava/io/PrintStream; out   (line 11)
    | |             ALOAD_1     // Ljava/io/PrintStream; out   (line 13)
    | |             ALOAD_2     // Ljava/lang/Exception; e
    |               ALOAD_1     // Ljava/io/PrintStream; out   (line 15)
    |               ILOAD_0     // I x   (line 21)
    |               ISTORE_0     // I x
    |               ILOAD_0     // I x
                    ALOAD_0     // LHelloWorld; this   (line 5)
                    ALOAD_0     // LFancyHelloWorld; this   (line 7)
    | | |           ALOAD_1     // Ljava/io/PrintStream; out   (line 11)
    | |             ALOAD_1     // Ljava/io/PrintStream; out   (line 13)
    | |             ALOAD_2     // Ljava/lang/Exception; e
    |               ALOAD_1     // Ljava/io/PrintStream; out   (line 15)
    |               ILOAD_0     // I x   (line 21)
    |               ISTORE_0     // I x
    |               ILOAD_0     // I x
                    ALOAD_0     // LFancyHelloWorld; this   (line 7)
    |               NOP
    |               INVOKESTATIC Aspect.ajc_afterReturning_constructor_execution ()V
    |               RETURN
    | | |           ALOAD_1     // Ljava/io/PrintStream; out   (line 11)
    | |             ALOAD_1     // Ljava/io/PrintStream; out   (line 13)
    | |             ALOAD_2     // Ljava/lang/Exception; e
    |               ALOAD_1     // Ljava/io/PrintStream; out   (line 15)
    |           L2: NOP   (line 17)
    |               INVOKESTATIC Aspect.ajc_afterReturning_method_execution ()V
    |               RETURN
    |               ILOAD_0     // I x   (line 21)
    |               ISTORE_0     // I x
    |               ILOAD_0     // I x
    |               ASTORE_2
    |               INVOKESTATIC Aspect.ajc_afterReturning_method_execution ()V
    |               ALOAD_2
                    ALOAD_0     // LHelloWorld; this   (line 5)
    |               NOP
    |               INVOKESTATIC Aspect.ajc_afterReturning_constructor_execution ()V
    |               RETURN
    |               NOP   (line 11)
    |               INVOKESTATIC Aspect.ajc_afterReturning_method_execution ()V
    |               RETURN
                    ALOAD_0     // LFancyHelloWorld; this   (line 7)
    | | |           ALOAD_1     // Ljava/io/PrintStream; out   (line 11)
    | |             ALOAD_1     // Ljava/io/PrintStream; out   (line 13)
    | |             ALOAD_2     // Ljava/lang/Exception; e
    |               ALOAD_1     // Ljava/io/PrintStream; out   (line 15)
    |               ILOAD_0     // I x   (line 21)
    |               ISTORE_0     // I x
    |               ILOAD_0     // I x
                    ALOAD_0     // LHelloWorld; this   (line 5)
                    ALOAD_0     // LFancyHelloWorld; this   (line 7)
    | | |           ALOAD_1     // Ljava/io/PrintStream; out   (line 11)
    | |             ALOAD_1     // Ljava/io/PrintStream; out   (line 13)
    | |             ALOAD_2     // Ljava/lang/Exception; e
    |               ALOAD_1     // Ljava/io/PrintStream; out   (line 15)
    |           L2: NOP   (line 17)
    |               ALOAD 8
    |               RETURN
    |               ILOAD_0     // I x   (line 21)
    |               ISTORE_0     // I x
    |               ILOAD_0     // I x
                    ALOAD_0     // LHelloWorld; this   (line 5)
    |               NOP   (line 11)
    |               ALOAD_2
    |               RETURN
                    ALOAD_0     // LHelloWorld; this   (line 5)
                    ALOAD_0     // LHelloWorld; this   (line 5)
    |               RETURN
                    ALOAD_0     // LFancyHelloWorld; this   (line 7)
    | | | |         ALOAD_1     // Ljava/io/PrintStream; out   (line 11)
    | | |           ALOAD_1     // Ljava/io/PrintStream; out   (line 13)
    | | |           ALOAD_2     // Ljava/lang/Exception; e
    | |             ALOAD_1     // Ljava/io/PrintStream; out   (line 15)
    |               RETURN
    |               ILOAD_0     // I x   (line 21)
    |               ISTORE_0     // I x
    |               ILOAD_0     // I x
                    ALOAD_0     // LHelloWorld; this   (line 5)
    |               RETURN
                    ALOAD_0     // LFancyHelloWorld; this   (line 7)
    | |             ALOAD_1     // Ljava/io/PrintStream; out   (line 11)
    |               ALOAD_1     // Ljava/io/PrintStream; out   (line 13)
    |               ALOAD 7     // Ljava/lang/Exception; e
                    ALOAD_1     // Ljava/io/PrintStream; out   (line 15)
                    ILOAD_0     // I x   (line 21)
                    ISTORE_0     // I x
                    ILOAD_0     // I x
                    ALOAD_0     // LHelloWorld; this   (line 5)
                    ALOAD_0     // LFancyHelloWorld; this   (line 7)
    | | |           ALOAD_1     // Ljava/io/PrintStream; out   (line 11)
    | |             ALOAD_1     // Ljava/io/PrintStream; out   (line 13)
    | |             ALOAD_2     // Ljava/lang/Exception; e
    |               ALOAD_1     // Ljava/io/PrintStream; out   (line 15)
    |               ILOAD_0     // I x   (line 21)
    |               ISTORE_0     // I x
    |               ILOAD_0     // I x
                    ALOAD_0     // LHelloWorld; this   (line 5)
                    ALOAD_0     // LFancyHelloWorld; this   (line 7)
    | | |           ALOAD_1     // Ljava/io/PrintStream; out   (line 11)
    | |             ALOAD_1     // Ljava/io/PrintStream; out   (line 13)
    | |             ALOAD_2     // Ljava/lang/Exception; e
    |               ALOAD_1     // Ljava/io/PrintStream; out   (line 15)
    |               ILOAD_0     // I x   (line 21)
    |               ISTORE_0     // I x
    |               ILOAD_0     // I x
                    ALOAD_0     // LHelloWorld; this   (line 5)
                    ALOAD_0     // LDynamicHelloWorld; this   (line 8)
                    ALOAD_1     // Ljava/lang/UnsupportedOperationException; t
    |               DUP
    |               DUP
    |               ASTORE 8
    |               ALOAD 8
    |               ALOAD 7
                    ALOAD_2     // Ljava/util/List; l   (line 21)
                    ALOAD_1     // Ljava/lang/String; s
                    ALOAD_2     // Ljava/util/List; l   (line 22)

  before(): staticinitialization(*oo) {
    System.err.println("x");
  }
  declare parents: Foo implements java.io.Serializable;
  public static void main(String []argv) throws Exception {
    new Foo().getParameterMetaData();
    Method[] m = Foo.class.getMethods();
    int count = 1;
    for (int i = 0; i < m.length; i++) {
  }
  public Sub getParameterMetaData() throws MyException {
     return null;
  }
   public ParameterMetaData getParameterMetaData() throws MyException;
 <weaver options="-verbose"/>
    <aspects>
      <aspect name="Advisor"/>
    </aspects>
======= 13dde4e:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

  public void testDuplicateBridgeMethods_pr147801_1() { runTest("duplicate bridge methods");}
   <ajc-test dir="bugs152/pr147801" title="duplicate bridge methods">
      <compile files="Advisor.aj" inpath="foo.jar" options="-1.5"/>
      <run class="Foo">
        <stderr>
          <line text="x"/>
          <line text="1) public Sub Foo.getParameterMetaData() throws MyException"/>
        </stderr>
      </run>
    </ajc-test>
    
======= 13dde4e:"weaver/src/org/aspectj/weaver/World.java"

======= 13dde4e:"weaver/src/org/aspectj/weaver/World.java"

======= 13dde4e:"weaver/src/org/aspectj/weaver/World.java"

        		runMinimalMemory = s.equalsIgnoreCase("true");
        		
        		
        		s = p.getProperty(xsetDEBUG_STRUCTURAL_CHANGES_CODE,"false");
        		forDEBUG_structuralChangesCode = s.equalsIgnoreCase("true");
        		
        		s = p.getProperty(xsetDEBUG_BRIDGING,"false");
        		forDEBUG_bridgingCode = s.equalsIgnoreCase("true");
    		}
        	checkedAdvancedConfiguration=true;
======= 13dde4e:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 13dde4e:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 13dde4e:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 13dde4e:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 13dde4e:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

    	if (typeToCheck.getWorld().forDEBUG_bridgingCode) System.err.println("  Bridging:checking for override of "+mname+" in "+typeToCheck);
======= 13dde4e:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 13dde4e:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 13dde4e:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 13dde4e:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 13dde4e:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"


 pointcut somePC() : execution(* A.*(..));
 declare warning : somePC() : "a match";
         
         
  public void foo() {}
  public void foo() {}  // CW L 25
  
  public void bar() {}  // CW L 27
======= 791f8a7:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

  public void testGenericAspectHierarchyWithBounds_pr147845() { runTest("Generic abstract aspect hierarchy with bounds"); }
      <compile files="GenericAspectHierarchy.aj" options="-1.5">
        <message kind="warning" line="25" text="a match"/>
        <message kind="warning" line="27" text="a match"/>     
      </compile>
    </ajc-test>
======= 791f8a7:"weaver/src/org/aspectj/weaver/TypeVariable.java"


======= 008efca:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    /** log command in non-verbose mode */
    private boolean logCommand; 
======= 008efca:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

        logCommand = false;
======= 008efca:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    public void setLogCommand(boolean logCommand) {
        this.logCommand = logCommand;
    }
    
======= 008efca:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

            if (logCommand) {
                log("ajc " + Arrays.asList(args));                
            } else {
                logVerbose("ajc " + Arrays.asList(args));
            }
======= 008efca:"taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java"

======= 008efca:"taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java"

    public void testDefaultFileComplete() {
        AjcTask task = getTask("default.lst");
        defaultSettings(task);
        runTest(task, NO_EXCEPTION, MessageHolderChecker.INFOS);
    }
    private void defaultSettings(AjcTask task) {
        task.setDebugLevel("none");
        task.setDeprecation(true);
        task.setFailonerror(false);
        task.setNoExit(true); // ok to override Ant?
        task.setNoImportError(true);
        task.setNowarn(true);
        task.setXTerminateAfterCompilation(true);
        task.setPreserveAllLocals(true);
        task.setProceedOnError(true);
        task.setReferenceInfo(true);
        task.setSource("1.3");
        task.setTarget("1.1");
        task.setTime(true);
        task.setVerbose(true);
        task.setXlint("info");        
    }
    
    public void testLogCommand() {
        final String DEFAULT = "default.lst";
        AjcTask task = getTask(DEFAULT);
        defaultSettings(task);
        task.setVerbose(false);
        task.setLogCommand(true);
        LogListener listener = new LogListener(Project.MSG_INFO);
        task.getProject().addBuildListener(listener);
        runTest(task, NO_EXCEPTION, MessageHolderChecker.INFOS);
        String[] results = listener.getResults();
        boolean matched = false;
        for (int i = 0; !matched && (i < results.length); i++) {
            String s = results[i];
            matched = (null != s) && (-1 != s.indexOf(DEFAULT));
        }
        if (!matched) {
            fail(DEFAULT + " not found in " + Arrays.asList(results));
        }
    }
======= 008efca:"taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java"

    private static class LogListener implements BuildListener {
        private final ArrayList results = new ArrayList();
        private final int priority;
        private LogListener(int priority) {
            this.priority = priority;
        }
        public void buildFinished(BuildEvent event) {}
        public void buildStarted(BuildEvent event) {}
        public void messageLogged(BuildEvent event) {
            if (priority == event.getPriority()) {
                results.add(event.getMessage());
            }
        }
        public void targetFinished(BuildEvent event) {}
        public void targetStarted(BuildEvent event) {}
        public void taskFinished(BuildEvent event) {}
        public void taskStarted(BuildEvent event) {}
        String[] getResults() {
            return (String[]) results.toArray(new String[0]);
        }
    }

======= 38cc0dd:"asm/src/org/aspectj/asm/AsmManager.java"

======= 38cc0dd:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"


======= 75afb31:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

        } catch (Exception t) {
======= 75afb31:"loadtime/src/org/aspectj/weaver/loadtime/JRockitAgent.java"

 * Copyright (c) 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *     Matthew Webster - initial implementation
 * BEA JRocket JMAPI agent. 
 * 
 * Use "-Xmanagement:class=org.aspectj.weaver.loadtime.JRockitAgent"
        cl.setClassPreProcessor(this);
======= 75afb31:"loadtime/testsrc/LoadtimeModuleTests.java"

======= 75afb31:"loadtime/testsrc/LoadtimeModuleTests.java"

        suite.addTestSuite(JRockitAgentTest.class);
======= 75afb31:"loadtime/testsrc/LoadtimeModuleTests.java"

 * Copyright (c) 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
======= 75afb31:"loadtime/testsrc/LoadtimeModuleTests.java"

 * Copyright (c) 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
======= 75afb31:"loadtime/testsrc/LoadtimeModuleTests.java"

 * Copyright (c) 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/

======= 3e0650d:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"

        // the good old ibm vm seems to offer clinit through its reflection support (see pr145322)
        if (rms1.length==rms2.length) return;
        	if (rms1.length!=(rms2.length+1)) {
        		for (int i = 0; i < rms1.length; i++) {
        		for (int i = 0; i < rms2.length; i++) {
        	}

======= f821ca3:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

======= f821ca3:"runtime/testsrc/org/aspectj/runtime/reflect/JoinPointImplTest.java"

======= f821ca3:"runtime/testsrc/org/aspectj/runtime/reflect/SignatureTest.java"

======= f821ca3:"runtime/testsrc/org/aspectj/runtime/reflect/SignatureTest.java"


======= 319a0d1:"ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java"

======= 319a0d1:"ajde/testsrc/org/aspectj/ajde/OutxmlTest.java"

======= 319a0d1:"ajde/testsrc/org/aspectj/ajde/OutxmlTest.java"

======= 319a0d1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 319a0d1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 319a0d1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"


======= 4513e92:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        if (enabled) {
            //bcelWorld.setResolutionLoader(loader.getParent());//(ClassLoader)null);//
            
            // after adding aspects
            weaver.prepareForWeave();
        }
        else {
        	bcelWorld = null;
        	weaver = null;
        }
======= 4513e92:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        
        /* We didn't register any aspects so disable the adaptor */
        if (namespace == null) {
        	enabled = false;
    		info("no aspects registered. Disabling weaver for class loader " + getClassLoaderName(loader));
        }
======= 4513e92:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

    
    <aspects>
    </aspects>
    <weaver options="-verbose"/>
                files="ataspectj/EmptyAspect.aj"
                options="-1.5 -Xlint:ignore"/>
        <compile
                files="ataspectj/EmptyAspect.aj"
                options="-1.5 -Xlint:ignore"/>
        <compile
                files="ataspectj/EmptyAspect.aj"
                options="-1.5 -Xlint:ignore"/>
        <compile
                files="ataspectj/ltwlog/MessageHolder.java,ataspectj/ltwreweavable/MainReweavableLogging.java,ataspectj/ltwreweavable/AspectReweavableLogging.java,ataspectj/ltwreweavable/Advisable.java,ataspectj/ltwreweavable/EmptyAtAspect.java"
======= 4513e92:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

======= 4513e92:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

      title="Ensure no weaving without included aspects"
      keywords="reweavable">
        <compile
        	files="TestMain.java, Main.java"
        >
        </compile>	
        <run class="TestMain" ltw="aop-optionsonly.xml">
        	<stdout>
                <line text="Main.main"/>
                <line text="Main.test1"/>
                <line text="Main.test2"/>
            </stdout>
        	<stderr>
            </stderr>
        </run>
    </ajc-test>

======= 97cd71a:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

======= 97cd71a:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    private UnresolvedType toUnresolvedType(Class clazz) {
    	if (clazz.isArray()) {
    	} else {
    		return UnresolvedType.forName(clazz.getName());
    	}
    }
    
======= 97cd71a:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"

======= 97cd71a:"weaver5/java5-testsrc/org/aspectj/weaver/tools/Java15PointcutExpressionTest.java"

======= 97cd71a:"weaver5/java5-testsrc/org/aspectj/weaver/tools/Java15PointcutExpressionTest.java"

======= 97cd71a:"weaver5/java5-testsrc/org/aspectj/weaver/tools/Java15PointcutExpressionTest.java"


======= 26a8a86:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

======= 26a8a86:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java"

======= 26a8a86:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java"

======= 26a8a86:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= 26a8a86:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

    declare @method : * debit(..) : @Secured(role="supervisor");
    public void debit(String accId,long amount) {
    }
    String role();
======= 26a8a86:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  			  IProgramElement.Kind.CONSTRUCTOR,"BankAccount(java.lang.String,int)");
======= 26a8a86:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

======= 26a8a86:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

  public void testDeclareAtMethodRelationship_pr143924() {
  	  // get the IProgramElements corresponding to the different code entries
  	  IProgramElement decam = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.DECLARE_ANNOTATION_AT_METHOD,
  			  "declare @method: * debit(..) : @Secured(role = \"supervisor\")");  	   	 
  	  assertNotNull("Couldn't find 'declare @method' element in the tree",decam);
  	  IProgramElement method = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.METHOD,"debit(java.lang.String,long)");
  	  assertNotNull("Couldn't find the 'debit(String,long)' method element in the tree",method);
  	  List matches = AsmManager.getDefault().getRelationshipMap().get(decam);	
  	  assertNotNull("'declare @method' should have some relationships but does not",matches);
  	  assertTrue("'declare @method' should have one relationships but has " + matches.size(),matches.size()==1);
  	  List matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("'declare @method' should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
  	  IProgramElement target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the 'debit(java.lang.String,long)' method but is IPE with label "
  			  + target.toLabelString(),method,target);
  	  
  	  // check that the debit method has an annotated by relationship with the declare @method
  	  matches = AsmManager.getDefault().getRelationshipMap().get(method);	
  	  assertNotNull("'debit(java.lang.String,long)' should have some relationships but does not",matches);
  	  assertTrue("'debit(java.lang.String,long)' should have one relationships but has " + matches.size(),matches.size()==1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("'debit(java.lang.String,long)' should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the 'declare @method' ipe but is IPE with label "
  			  + target.toLabelString(),decam,target);
  	  
  }
  
    <ajc-test dir="bugs152" title="declare @method relationship">
     <compile files="pr143924.aj" options="-1.5 -showWeaveInfo -emacssym">
        <message kind="weave" text="'public void BankAccount.debit(String,long)' (pr143924.aj:7) is annotated with @Secured"/>
     </compile>
    </ajc-test>
======= 26a8a86:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"


======= 69e24e9:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

======= 69e24e9:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

        
        Collection abstractMethods = getOutstandingAbstractMethods(m_parent);
        for (Iterator iter = abstractMethods.iterator(); iter.hasNext();) {
            	 if (n.startsWith("ajc$pointcut")) { // Allow for the abstract pointcut being from a code style aspect compiled with -1.5 (see test for 128744)
            		n = n.substring(14);
            		n = n.substring(0,n.indexOf("$"));
            		elligibleAbstractions.add(n);         
            	 } else if (hasPointcutAnnotation(method)) {
         			elligibleAbstractions.add(method.getName());
            	 } else {
             	 // error, an outstanding abstract method that can't be concretized in XML
            		 reportError("Abstract method '" + method.toString() + "' cannot be concretized in XML: " + stringify());
                  return false;
            	 }
            } else {
            	  if (method.getName().startsWith("ajc$pointcut") || hasPointcutAnnotation(method)) {
            		// it may be a pointcut but it doesn't meet the requirements for XML concretization
            		reportError("Abstract method '" + method.toString() + "' cannot be concretized as a pointcut (illegal signature, must have no arguments, must return void): " + stringify());
                 return false;
            	  } else {
            		// error, an outstanding abstract method that can't be concretized in XML
                 reportError("Abstract method '" + method.toString() + "' cannot be concretized in XML: " + stringify());
                 return false;
            	  }
======= 69e24e9:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

    private Collection getOutstandingAbstractMethods(ResolvedType type) {
    		Map collector = new HashMap();
    		// let's get to the top of the hierarchy and then walk down ... recording abstract methods then removing
    		// them if they get defined further down the hierarchy
    		getOutstandingAbstractMethodsHelper(type,collector);
    
    // We are trying to determine abstract methods left over at the bottom of a hierarchy that have not been
    // concretized.
    private void getOutstandingAbstractMethodsHelper(ResolvedType type,Map collector) {
    	  if (type==null) return;
    	  // Get to the top
    	  if (type!=null && !type.equals(ResolvedType.OBJECT)) {
    		  if (type.getSuperclass()!=null)
    		    getOutstandingAbstractMethodsHelper(type.getSuperclass(),collector);
    	  }
    	  ResolvedMember[] rms = type.getDeclaredMethods();
    	  if (rms!=null) {
    	  }
    }
======= 69e24e9:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

  @Pointcut
  protected abstract void tracingScope();
  @Before("tracingScope()")
  public void doit() {
    test();
    System.out.println("advice running");
  }
  protected abstract void test();
                System.out.println("advice running");
======= 69e24e9:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

======= 69e24e9:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

  public abstract void foo(int i) ;
======= 69e24e9:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

======= 69e24e9:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

        <concrete-aspect name="TraceHelloWorld" extends="ConcreteMethods">
        	<pointcut name="tracingScope" expression="within(HelloWorld) AND call(* println(..))"/>
        </concrete-aspect>
    
    <weaver options=""/>
======= 69e24e9:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

  @Pointcut
  protected abstract void tracingScope();
  @Before("tracingScope()")
  public void doit() {
    test();
    System.out.println("advice running");
  }
  protected abstract void test();
                System.out.println("advice running");
======= 69e24e9:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

======= 69e24e9:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

======= 69e24e9:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

======= 69e24e9:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

        <concrete-aspect name="TraceHelloWorld" extends="ConcreteMethods">
        	<pointcut name="tracingScope" expression="within(HelloWorld) AND call(* println(..))"/>
        </concrete-aspect>
    
    <weaver options=""/>
======= 69e24e9:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

  public void testConcretizingAbstractMethods_pr142466() { runTest("aop.xml aspect inheriting but not concretizing abstract method");}
  public void testConcretizingAbstractMethods_pr142466_2() { runTest("aop.xml aspect inheriting but not concretizing abstract method - 2");}
    <ajc-test dir="bugs152/pr142466" title="aop.xml aspect inheriting but not concretizing abstract method">
        <compile files="HelloWorld.java"/>
        <compile files="AbstractMethods.aj, ConcreteMethods.aj" options="-1.5"/>
        <run class="HelloWorld" ltw="aop-tracing.xml">
          <stderr>
            <line text="error Abstract method 'void ConcreteMethods.foo(int)' cannot be concretized in XML:"/>
            <line text="warning register definition failed"/>
          </stderr>
          <stdout>
            <line text="Hello World!"/>
          </stdout>
        </run>
    </ajc-test>
     
    <ajc-test dir="bugs152/pr142466/case2" title="aop.xml aspect inheriting but not concretizing abstract method - 2">
        <compile files="HelloWorld.java"/>
        <compile files="AbstractMethods.aj, ConcreteMethods.aj" options="-1.5"/>
        <run class="HelloWorld" ltw="aop-tracing.xml">
          <stderr>
            <line text="error Abstract method 'void AbstractMethods.test()' cannot be concretized in XML"/>
            <line text="warning register definition failed"/>
          </stderr>
          <stdout>
            <line text="Hello World!"/>
          </stdout>
        </run>
    </ajc-test>   

  pointcut methodInTxType(Tx tx) : 
    execution(* *(..)) && @this(tx) && if(tx.value());
  pointcut txMethod(Tx tx) :
    execution(* *(..)) && @annotation(tx) && if(tx.value());
  pointcut transactionalOperation() :
    methodInTxType(Tx) || txMethod(Tx);
  before() : transactionalOperation() {
    System.err.println("advice running at "+thisJoinPoint);
  }
  public static void main(String [] argv) {
  }
  @Tx(true) public void a() {}
  @Tx(false) public void b() {}
  public void c() {}
  @Tx(true) public void a() {}
  @Tx(false) public void b() {}
  public void c() {}
  @Tx(true) public void a() {}
  @Tx(false) public void b() {}
  public void c() {}
======= 6b2d9ae:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

  public void testDoubleAnnotationMatching_pr138223() { runTest("Double at annotation matching (no binding)");}
      <run class="DoubleAnnotationMatching">
        <stderr>
          <line text="advice running at execution(void Foo.a())"/>
          <line text="advice running at execution(void TxTrueFoo.a())"/>
          <line text="advice running at execution(void TxTrueFoo.b())"/>
          <line text="advice running at execution(void TxTrueFoo.c())"/>
          <line text="advice running at execution(void TxFalseFoo.a())"/>
        </stderr>
      </run>
======= 6b2d9ae:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= 6b2d9ae:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"


======= 5f6a6b1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 5f6a6b1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

        //   baseTypeMungers.addAll(getWorld().getCrosscuttingMembersSet().getLateTypeMungers());
======= 5f6a6b1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

        @Before("within(C) && call(* foo(..))")
        public void touchBeforeExecute() {
        	  System.err.println("foo called");
        }
======= 5f6a6b1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 5f6a6b1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 5f6a6b1:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= 5f6a6b1:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= 5f6a6b1:"weaver/src/org/aspectj/weaver/ResolvedType.java"

                if (munger.getMunger()!=null && munger.getMunger().getKind() == ResolvedTypeMunger.Parent) {

        // compiler issues the following line with
        // can not find pointcut test on test.PointcutConsumer
        pointcut mytest(): PointcutProvider.test();
 
        // this also does not work with the same error message
        pointcut mytest2(): test1.PointcutProvider.test();
        pointcut flow(): mytest() || mytest2();
        public void foo() {
        }
        public pointcut test(): execution(* Test.*(..));
  private static int id = 0;
  
  public PerThisWithReference() {
    id++;
  }
  
  public String toString() {
    return "PerThisWithReference:" + id;
  }
  public static void main(String[] args) {
    new C().foo();
    new C().foo();
  }
  pointcut mypc() : SomeOtherType.pc() && within(C);
  before() : mypc() {
    System.out.println("before " + this);
  }
 public void foo() {}
  pointcut refersToMypc() : mypc();
  pointcut mypc() : SomeOtherType.pc();
======= b166a7e:"tests/src/org/aspectj/systemtest/ajc150/GenericITDsDesign.java"

======= b166a7e:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

  public void testReferencePCutInPerClause_pr138219() { runTest("Can't use a FQ Reference pointcut in any pointcut expression referenced by a per-clause");}
  public void testReferencePCutInPerClause_pr130722() { runTest("FQ Reference pointcut from perclause ref pc"); }
      <compile files="PerThisWithReference.aj,SomeOtherType.aj,RegularPCWithReference.aj" options="-1.5">
      <run class="PerThisWithReference">
        <stdout>
         <line text="before PerThisWithReference:1"/>
         <line text="before PerThisWithReference:2"/>
        </stdout>
      </run>
    </ajc-test>
    
    <ajc-test dir="bugs152/pr130722" pr="130722" title="FQ Reference pointcut from perclause ref pc">
      <compile files="test/Test.java,test/PointcutConsumer.aj,test1/PointcutProvider.aj"/>
======= b166a7e:"weaver/src/org/aspectj/weaver/CrosscuttingMembers.java"

======= b166a7e:"weaver/src/org/aspectj/weaver/CrosscuttingMembers.java"

======= b166a7e:"weaver/src/org/aspectj/weaver/CrosscuttingMembers.java"

======= b166a7e:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

======= b166a7e:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

======= b166a7e:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

======= b166a7e:"weaver/src/org/aspectj/weaver/ResolvedType.java"

======= b166a7e:"weaver/testsrc/org/aspectj/weaver/bcel/NonstaticWeaveTestCase.java"

======= b166a7e:"weaver/testsrc/org/aspectj/weaver/bcel/NonstaticWeaveTestCase.java"

======= b166a7e:"weaver/testsrc/org/aspectj/weaver/bcel/PointcutResidueTestCase.java"

======= b166a7e:"weaver/testsrc/org/aspectj/weaver/bcel/WeaveOrderTestCase.java"

======= b166a7e:"weaver/testsrc/org/aspectj/weaver/bcel/WeaveOrderTestCase.java"


======= fc7db25:"tests/java5/ataspectj/ataspectj/ltwreweavable/MainReweavableLogging.java"

        String ERROR_STRING = "error aspect 'ataspectj.ltwreweavable.AspectReweavableLogging' woven into 'ataspectj.ltwreweavable.MainReweavableLogging' must be defined to the weaver (placed on the aspectpath, or defined in an aop.xml file if using LTW).";

======= 9ffc63b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

======= 9ffc63b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

======= 9ffc63b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

  static before(): call(* *(..)) {}
======= 9ffc63b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

======= 9ffc63b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

======= 9ffc63b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

======= 9ffc63b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

======= 9ffc63b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

======= 9ffc63b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

  <aspects>
    <aspect name="t.Ajava"/>
  </aspects>
  <weaver>
    <include within="t..*"/>
  </weaver>
======= 9ffc63b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

======= 9ffc63b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

======= 9ffc63b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

======= 9ffc63b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

======= 9ffc63b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

======= 9ffc63b:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

  public void testVerifyErrorLTW_pr135068() { runTest("ltw verifyerror");}
  public void testVerifyErrorLTW_pr135068_2() { runTest("ltw verifyerror - 2");}
  public void testVerifyErrorLTW_pr135068_3() { runTest("ltw verifyerror - 3");}
  public void testVerifyErrorLTW_pr135068_4() { runTest("ltw verifyerror - 4");}
    </ajc-test>
    
    	<ajc-test dir="bugs152/pr135068" title="ltw verifyerror - 2">
    </ajc-test>
    
    	<ajc-test dir="bugs152/pr135068" title="ltw verifyerror - 3">
        <compile files="t/Ajava.java" options="-1.5">
          <message kind="warning" line="13" text="advice defined"/>
        </compile>
        <run class="t.C" ltw="aop.xml"/>
    </ajc-test>
    
    	<ajc-test dir="bugs152/pr135068" title="ltw verifyerror - 4">
        <compile files="t/Ajava2.java" options="-1.5">
        </compile>
    </ajc-test>
    
======= 9ffc63b:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

======= 9ffc63b:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

        
        // semantic check - advice must not be static
        if (hasAtAspectJAnnotation && struct.method.isStatic()) {
            msgHandler.handleMessage(MessageUtil.error("Advice cannot be declared static '" + methodToString(struct.method) + "'",type.getSourceLocation()));
            ;// go ahead
        }
        

    pointcut publicMethods() : execution(public * *(..));
    before() : publicMethods() {
        System.out.println("Entering "+thisJoinPoint);
    }
    pointcut publicMethods() : execution(public * *(..));
    before() : publicMethods() {
        System.out.println("Entering "+thisJoinPoint);
    }
    
    after() : publicMethods() {
    	System.out.println("Exiting " + thisJoinPoint);
    }
======= 3fa4d24:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= 3fa4d24:"weaver/src/org/aspectj/weaver/Lint.java"

======= 3fa4d24:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= 3fa4d24:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

    private boolean hasReportedNoGuardForLazyTJP = false;
======= 3fa4d24:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"


 @Marker void getData(){}
  before(Marker a): execution(* getData(..)) && @annotation(a) { System.err.println(a);  }
======= 3ca976f:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

  public void testAnnotationsAndGenericsBCException_pr129704() { runTest("annotations and generics leading to BCException");}
    <ajc-test dir="bugs152/pr129704" title="annotations and generics leading to BCException">
      <compile files="A.java" options="-1.5"/>
      <run class="A">
        <stderr>
          <line text="@Marker()"/>
        </stderr>
      </run>
    </ajc-test>
    
======= 3ca976f:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 3ca976f:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    		annotations = getAnnotations(foundMember, relevantMember, relevantType);

======= 5d2b5b8:"bcel-builder/src/org/aspectj/apache/bcel/generic/InstructionList.java"

 * @version $Id: InstructionList.java,v 1.4 2006/05/12 08:17:43 aclement Exp $
======= 5d2b5b8:"bcel-builder/src/org/aspectj/apache/bcel/generic/InstructionList.java"

    byte[] byteCode = b.toByteArray();
    if (byteCode.length > Constants.MAX_CODE_SIZE) 
    	  throw new ClassGenException("Code size too big: " + byteCode.length);
    return byteCode;
======= 5d2b5b8:"bcel-builder/src/org/aspectj/apache/bcel/generic/InstructionList.java"

======= 5d2b5b8:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

  public void testMethodTooBigAfterWeaving_pr138384() { runTest("method too big"); }
    <ajc-test dir="bugs152/pr138384" title="method too big">
      <compile files="BigMethod.java" options="-1.5"> <!-- will be 67628 bytes in the big method -->
        <message kind="error" line="1" text="problem generating method BigMethod.i_am_a_big_method : Code size too big: 67629"/>
      </compile>
      <!--run class="BigMethod"/-->
    </ajc-test>
    

======= b954b26:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    protected PointcutParser() {
======= b954b26:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    protected void setWorld(ReflectionWorld aWorld) {
======= b954b26:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    protected void setClassLoader(ClassLoader aLoader) {
======= b954b26:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

        	 Pointcut pc = resolvePointcutExpression(expression,inScope,formalParameters);  
             pc = concretizePointcutExpression(pc,inScope,formalParameters);
======= b954b26:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    protected Pointcut resolvePointcutExpression(
    		String expression, 
    		Class inScope,
    		PointcutParameter[] formalParameters) {
    	try {
      	 PatternParser parser = new PatternParser(expression);
    	 parser.setPointcutDesignatorHandlers(pointcutDesignators, world);
         Pointcut pc = parser.parsePointcut();
         validateAgainstSupportedPrimitives(pc,expression);
         IScope resolutionScope = buildResolutionScope((inScope == null ? Object.class : inScope),formalParameters);
         pc = pc.resolve(resolutionScope);
         return pc;
    	} catch (ParserException pEx) {
             throw new IllegalArgumentException(buildUserMessageFromParserException(expression,pEx));
        }
    }
    
    protected Pointcut concretizePointcutExpression(Pointcut pc, Class inScope, PointcutParameter[] formalParameters) {
        ResolvedType declaringTypeForResolution = null;
        if (inScope != null) {
       	 declaringTypeForResolution = getWorld().resolve(inScope.getName());
        } else {
       	 declaringTypeForResolution = ResolvedType.OBJECT.resolve(getWorld());
        }
        IntMap arity = new IntMap(formalParameters.length);
        for (int i = 0; i < formalParameters.length; i++) {
       	 arity.put(i, i);
        }             
        return pc.concretize(declaringTypeForResolution, declaringTypeForResolution, arity);
    }
    
======= b954b26:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

 * When a Java15ReflectionBasedDelegate gets the pointcuts for a given class it 
 * tries to resolve them before returning.
 * This can cause problems if the resolution of one pointcut in the type depends
 * on another pointcut in the same type. 
 * Therefore the algorithm proceeds in two phases, first we create and store
 * instances of this class in the pointcuts array, and once that is done, we
 * come back round and resolve the actual pointcut expression. This means that
 * if we recurse doing resolution, we will find the named pointcut we are 
 * looking for!
 * 
 * @author adrian colyer
 *
 */
======= b954b26:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

======= b954b26:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"

======= b954b26:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"

======= b954b26:"weaver5/java5-testsrc/org/aspectj/weaver/tools/Java15PointcutExpressionTest.java"

======= b954b26:"weaver5/java5-testsrc/org/aspectj/weaver/tools/Java15PointcutExpressionTest.java"


======= 299c3a4:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= 299c3a4:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= 299c3a4:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 299c3a4:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= 299c3a4:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= 299c3a4:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= 299c3a4:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= 299c3a4:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


======= cb5dfe7:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

======= cb5dfe7:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

    Cache stringCache;
======= cb5dfe7:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

======= cb5dfe7:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"


    /** The default of Void means ANY throwable */
    Class[] value() default Void.class; 
    before(Throwable throwable) : handler(*) && args(throwable) && !@withincode(NormalException) {
    	System.err.println("Caught in "+thisEnclosingJoinPointStaticPart.getSignature().getName());
    }    
    public static void main(String argz[]) {
    	new Test().checkConnection();
    }
    @NormalException(Exception.class)
    protected void checkConnection() {
        try {
            foo();
        } catch (Exception e) {
        	;//skip warning
        }
    }
    
    private void foo() {
    	try {
    		throw new RuntimeException();
    	} catch (RuntimeException e) {
    		throw e;
    	}
    }
======= c5c18aa:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

  public void testAtWithinCodeBug_pr138798() { runTest("atWithinCodeBug"); }
    <ajc-test dir="bugs152/pr138798" title="atWithinCodeBug">
      <compile files="ErrorHandling.aj" options="-1.5"/>
      <run class="ErrorHandling">
         <stderr>
           <line text="Caught in foo"/>
         </stderr>
      </run>      
    </ajc-test>
    

======= c667bcb:"tests/src/org/aspectj/systemtest/ajc152/Ajc152Tests.java"

  public void testNoClassCastExceptionWithPerThis_pr138286() { runTest("No ClassCastException with perThis");}
  
    <ajc-test dir="bugs152/pr138286" pr="138286" title="No ClassCastException with perThis">
      <compile files="A.aj" options="-1.5 -showWeaveInfo">      
      </compile>
      <run class="A">
        <stderr>
          <line text="class Foo"/>
          <line text="class Boo"/>
          <line text="class Boo"/> <!-- this one is because of the super() call in Soo's default ctor -->
          <line text="class Soo"/>
        </stderr>
      </run>
    </ajc-test>
======= c667bcb:"weaver/src/org/aspectj/weaver/patterns/PerThisOrTargetPointcutVisitor.java"

        	return new AnyWithAnnotationTypePattern( node.getAnnotationTypePattern());
======= c667bcb:"weaver/src/org/aspectj/weaver/patterns/PerThisOrTargetPointcutVisitor.java"

        	return new AnyWithAnnotationTypePattern( node.getAnnotationTypePattern());
        	return new AnyWithAnnotationTypePattern( node.getAnnotationTypePattern());

======= 99882cb:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

            	// new special case: allow -Xset:anything
                if (VALID_XOPTIONS.contains(token) || token.indexOf("set:")==0) {

  public void foo() {}
======= 1535ee7:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= 1535ee7:"weaver/src/org/aspectj/weaver/PerObjectInterfaceTypeMunger.java"

    	if (other==null || !(other instanceof PerObjectInterfaceTypeMunger)) return false;
    	return ((testPointcut == null) ? (o.testPointcut == null ) : testPointcut.equals(o.testPointcut))
    			&& ((lazyTestTypePattern == null) ? (o.lazyTestTypePattern == null ) : lazyTestTypePattern.equals(o.lazyTestTypePattern));

======= d1a252e:"weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"

======= d1a252e:"weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"

======= d1a252e:"weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"

======= d1a252e:"weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"

======= d1a252e:"weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"

======= d1a252e:"weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"

======= d1a252e:"weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"


======= 1a6f695:"tests/src/org/aspectj/systemtest/AllTests15.java"

======= 1a6f695:"tests/src/org/aspectj/systemtest/AllTests15.java"

======= 1a6f695:"tests/src/org/aspectj/systemtest/AllTests15.java"

 * Copyright (c) 2006 IBM 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
  public void testAspectLibrariesAndASM_pr135001() { runTest("aspect libraries and asm");}
  
  
  /////////////////////////////////////////
  public static Test suite() {
    return XMLBasedAjcTestCase.loadSuite(Ajc152Tests.class);
  }
  protected File getSpecFile() {
    return new File("../tests/src/org/aspectj/systemtest/ajc152/ajc152.xml");
  }
  
======= 1a6f695:"tests/src/org/aspectj/systemtest/AllTests15.java"

 * Copyright (c) 2006 IBM 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
        //$JUnit-END$
======= 1a6f695:"tests/src/org/aspectj/systemtest/AllTests15.java"

    <ajc-test dir="bugs152/pr135001" title="aspect libraries and asm">
      <compile files="AbstractAspect.java" outjar="lib.jar" options="-1.5"/>
      <compile files="Foo.java,ConcreteAspect.java" classpath="lib.jar" options="-1.5 -showWeaveInfo">
        <message kind="weave" text="Join point 'method-call(void Foo.foo())' in Type 'Foo' (Foo.java:3) advised by around advice from 'ConcreteAspect' (AbstractAspect.java:5)"/>
      </compile>
      <run class="Foo">
         <stderr>
           <line text="In the advice!"/>
         </stderr>
      </run>
    </ajc-test>
    
======= 1a6f695:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 1a6f695:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        ResolvedType rt = (declaringType.isParameterizedType()?declaringType.getGenericType():declaringType);
        BcelObjectType ot = BcelWorld.getBcelObjectType(rt); 
======= 1a6f695:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

    } 
    
    // SECRETAPI: used for testing ASM loading of delegates...
    public boolean fallbackToLoadingBcelDelegatesForAspects = true;
    
======= 1a6f695:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= 1a6f695:"weaver/testsrc/org/aspectj/weaver/bcel/AsmDelegateTests.java"

        world.fallbackToLoadingBcelDelegatesForAspects = false;
    	
======= 1a6f695:"weaver/testsrc/org/aspectj/weaver/bcel/AsmDelegateTests.java"

    	BcelWorld slowWorld = new BcelWorld(BcweaverTests.TESTDATA_PATH+"/forAsmDelegateTesting/stuff.jar");
    	slowWorld.setFastDelegateSupport(false);
        fastWorld.fallbackToLoadingBcelDelegatesForAspects = false;
======= 1a6f695:"weaver/testsrc/org/aspectj/weaver/bcel/AsmDelegateTests.java"

        fastWorld.fallbackToLoadingBcelDelegatesForAspects = false;

======= 94d8b82:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= 94d8b82:"weaver/src/org/aspectj/weaver/CrosscuttingMembers.java"

======= 94d8b82:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"


======= 41f1f3a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

======= 41f1f3a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

            TypeBinding argTypeBinding = mDecl.binding.parameters[i];

======= fa2ed1b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"


======= 91473b3:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java"

                if (true && methodDeclaration!=null && methodDeclaration.annotations != null && methodDeclaration.scope!=null) {

======= c9a60e5:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= c9a60e5:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

   declare parents: TestClass implements TestIF<TestClass>;
       <!--message kind="error" line="16" text="The method m4(String) is undefined for the type Base"/-->
======= c9a60e5:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  public void testCircularGenerics_pr133307() { runTest("circular generics");}
  //  public void testDeca() { runTest("doubly annotating a method with declare");}	
  //  public void testDeca2() { runTest("doubly annotating a method with declare - 2");}	
    <ajc-test dir="bugs151/pr133307" title="circular generics">
      <compile files="Broken.aj" options="-1.5"/>
    </ajc-test>  
    
======= c9a60e5:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

======= c9a60e5:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

======= c9a60e5:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

======= c9a60e5:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

 * Copyright (c) 2006 Contributors
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *     Andy Clement IBM     initial implementation 
 * ******************************************************************/
 * Implementors provide a 'verify()' method that is invoked at the end of type
 * binding completion.
 * @see WildTypePattern.VerifyBoundsForTypePattern
 */
======= c9a60e5:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= c9a60e5:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"


  public void m() {}
  declare @method: * Target.*(..): @One;
  declare @method: * Target.*(..): @Two;
  public static void main(String []argv) {
  }
======= 2fb86fe:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  public void testCrashingWithASM_pr132926_1() { runTest("crashing on annotation type resolving with asm - 1");}
  public void testCrashingWithASM_pr132926_2() { runTest("crashing on annotation type resolving with asm - 2");}
  public void testCrashingWithASM_pr132926_3() { runTest("crashing on annotation type resolving with asm - 3");}
    <ajc-test dir="bugs151/pr132926" pr="132926" title="crashing on annotation type resolving with asm - 1">
     <compile files="InputAnnotation.java,AffectedType.java" options="-1.5"/>
    </ajc-test>
    
    <ajc-test dir="bugs151/pr132926" pr="132926" title="crashing on annotation type resolving with asm - 2">
     <compile files="InputAnnotation.java" outjar="foo.jar" options="-1.5"/>
     <compile files="AffectedType.java" classpath="foo.jar" options="-1.5"/>
    </ajc-test>
    
    <ajc-test dir="bugs151/pr132926" pr="132926" title="crashing on annotation type resolving with asm - 3">
     <compile files="InputAnnotation2.java" outjar="foo.jar" options="-1.5"/>
     <compile files="AffectedType.java" classpath="foo.jar" options="-1.5">
     	<message kind="error" line="9" text="AffectedType is not a valid target for annotation InputAnnotation, this annotation can only be applied to these element types {METHOD}"/>
     </compile>
    </ajc-test>
    <ajc-test dir="bugs151/Deca" title="doubly annotating a method with declare">
      <compile files="DecA.java" options="-1.5"/>
      <run class="DecA">
        <stderr>
          <line text="There are 2 annotations on public void m()"/>
          <line text="1) @One()"/>
          <line text="2) @Two()"/>
        </stderr>
      </run>
    </ajc-test>
    
======= 2fb86fe:"weaver/src/org/aspectj/weaver/AnnotationX.java"

  			supportedTargets = atTargetAnnotation.getTargets();
  
  /**
   * For the @Target annotation, this will return a set of the elementtypes it can be applied to.
   * For non @Target annotations, it returns null.
   */
  public Set /* of String */ getTargets() {
  }

======= 9dca72e:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= 9dca72e:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= 9dca72e:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= 9dca72e:"ajde/testsrc/org/aspectj/ajde/AsmRelationshipsTest.java"

======= 9dca72e:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

======= 9dca72e:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= 9dca72e:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

 aspect basic {
    declare @method : * debit(..) : @Secured(role="supervisor");
    declare @constructor : BankAccount+.new(..) : @Secured(role="supervisor");
    public void debit(long accId,long amount) {
    }
    String role();
======= 9dca72e:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  	  assertEquals("foo(int,java.lang.Object)",pe.toLabelString());
  	  assertEquals("C.foo(int,java.lang.Object)",pe.toLinkLabelString());
  	  assertEquals("foo(int,java.lang.Object)",pe.toSignatureString());
  	  assertEquals("foo(int,Object)",pe.toLabelString(false));
  	  assertEquals("C.foo(int,Object)",pe.toLinkLabelString(false));
  	  assertEquals("foo(int,Object)",pe.toSignatureString(false));
======= 9dca72e:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  
  public void testDeclareAnnotationAppearsInStructureModel_pr132130() {
  	  // get the IProgramElements corresponding to the different code entries
  	  IProgramElement decam = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.DECLARE_ANNOTATION_AT_METHOD,"declare @method: * debit(..) : @Secured(role = \"supervisor\")");  	   	 
  	  assertNotNull("Couldn't find 'declare @method' element in the tree",decam);
  	  IProgramElement method = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.METHOD,"debit(long,long)");
  	  assertNotNull("Couldn't find the 'debit(long,long)' method element in the tree",method);
  	  IProgramElement decac = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.DECLARE_ANNOTATION_AT_CONSTRUCTOR,"declare @constructor: BankAccount+.new(..) : @Secured(role = \"supervisor\")");  	   	 
  	  assertNotNull("Couldn't find 'declare @constructor' element in the tree",decac);
  	  IProgramElement ctr = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.CONSTRUCTOR,"BankAccount(String,int)");
  	  assertNotNull("Couldn't find the 'BankAccount(String,int)' constructor element in the tree",ctr);
  	  
  	  // check that decam has a annotates relationship with the debit method
  	  List matches = AsmManager.getDefault().getRelationshipMap().get(decam);	
  	  assertNotNull("'declare @method' should have some relationships but does not",matches);
  	  assertTrue("'declare @method' should have one relationships but has " + matches.size(),matches.size()==1);
  	  List matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("'declare @method' should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
  	  IProgramElement target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the 'debit(long,long)' method but is IPE with label "
  			  + target.toLabelString(),method,target);
  	  
  	  // check that the debit method has an annotated by relationship with the declare @method
  	  matches = AsmManager.getDefault().getRelationshipMap().get(method);	
  	  assertNotNull("'debit(long,long)' should have some relationships but does not",matches);
  	  assertTrue("'debit(long,long)' should have one relationships but has " + matches.size(),matches.size()==1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("'debit(long,long)' should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the 'declare @method' ipe but is IPE with label "
  			  + target.toLabelString(),decam,target);
  	  // check that decac has a annotates relationship with the constructor
  	  matches = AsmManager.getDefault().getRelationshipMap().get(decac);	
  	  assertNotNull("'declare @method' should have some relationships but does not",matches);
  	  assertTrue("'declare @method' should have one relationships but has " + matches.size(),matches.size()==1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("'declare @method' should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the 'debit(long, long)' method but is IPE with label "
  			  + target.toLabelString(),ctr,target);
  	  
  	  // check that the constructor has an annotated by relationship with the declare @constructor
  	  matches = AsmManager.getDefault().getRelationshipMap().get(ctr);	
  	  assertNotNull("'debit(long, long)' should have some relationships but does not",matches);
  	  assertTrue("'debit(long, long)' should have one relationships but has " + matches.size(),matches.size()==1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("'debit(long, long)' should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the 'declare @method' ipe but is IPE with label "
  			  + target.toLabelString(),decac,target);
  }
  
    <ajc-test dir="bugs151" title="declare annotation appears in structure model when in same file">
        <compile files="pr132130.aj" options="-1.5 -emacssym"/>
    </ajc-test>

    }
    static class Bar<T> {
        List<T> lts;
    }   
    
======= e2703cf:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

======= e2703cf:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  public void testStructureModelForGenericITD_pr131932() {
 	  //AsmManager.setReporting("c:/debug.txt",true,true,true,true);
 	   
  	  // get the IProgramElements corresponding to the ITDs and classes
  	  IProgramElement foo = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.CLASS,"Foo");
  	  assertNotNull("Couldn't find Foo element in the tree",foo);
  	  IProgramElement bar = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.CLASS,"Bar");
  	  assertNotNull("Couldn't find Bar element in the tree",bar);
  	  IProgramElement method = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.INTER_TYPE_METHOD,"Bar.getFirst()");  	   	 
  	  assertNotNull("Couldn't find 'Bar.getFirst()' element in the tree",method);
  	  IProgramElement field = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.INTER_TYPE_FIELD,"Bar.children");  	   	 
  	  assertNotNull("Couldn't find 'Bar.children' element in the tree",field);
  	  IProgramElement constructor = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.INTER_TYPE_CONSTRUCTOR,"Foo.Foo(List<T>)");  	   	 
  	  assertNotNull("Couldn't find 'Foo.Foo(List<T>)' element in the tree",constructor);
  	  
  	  // check that the relationship map has 'itd method declared on bar'
  	  List matches = AsmManager.getDefault().getRelationshipMap().get(method);
  	  assertNotNull("itd Bar.getFirst() should have some relationships but does not",matches);
  	  assertTrue("method itd should have one relationship but has " + matches.size(), matches.size() == 1);
  	  List matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("itd Bar.getFirst() should have one target but has " + matchesTargets.size(),matchesTargets.size() == 1);
  	  IProgramElement target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the Bar class but is IPE with label "
  			  + target.toLabelString(),bar,target);
  	  // check that the relationship map has 'itd field declared on bar'
  	  matches = AsmManager.getDefault().getRelationshipMap().get(field);
  	  assertNotNull("itd Bar.children should have some relationships but does not",matches);
  	  assertTrue("field itd should have one relationship but has " + matches.size(), matches.size() == 1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("itd Bar.children should have one target but has " + matchesTargets.size(),matchesTargets.size() == 1);
  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the Bar class but is IPE with label "
  			  + target.toLabelString(),bar,target);
  	  // check that the relationship map has 'itd constructor declared on foo'
  	  matches = AsmManager.getDefault().getRelationshipMap().get(constructor);
  	  assertNotNull("itd Foo.Foo(List<T>) should have some relationships but does not",matches);
  	  assertTrue("constructor itd should have one relationship but has " + matches.size(), matches.size() == 1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("itd Foo.Foo(List<T>) should have one target but has " + matchesTargets.size(),matchesTargets.size() == 1);
  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the Foo class but is IPE with label "
  			  + target.toLabelString(),foo,target);
  	  
  	  // check that the relationship map has 'bar aspect declarations method and field itd'
  	  matches = AsmManager.getDefault().getRelationshipMap().get(bar);
  	  assertNotNull("Bar should have some relationships but does not",matches);
  	  assertTrue("Bar should have one relationship but has " + matches.size(), matches.size() == 1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("Bar should have two targets but has " + matchesTargets.size(),matchesTargets.size() == 2);
  	  for (Iterator iter = matchesTargets.iterator(); iter.hasNext();) {
  	  // check that the relationship map has 'foo aspect declarations constructor itd'
 	  matches = AsmManager.getDefault().getRelationshipMap().get(foo);
  	  assertNotNull("Foo should have some relationships but does not",matches);
  	  assertTrue("Foo should have one relationship but has " + matches.size(), matches.size() == 1);
  	  matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("Foo should have one target but has " + matchesTargets.size(),matchesTargets.size() == 1);
 	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the Foo.Foo(List<T>) itd but is IPE with label "
  			  + target.toLabelString(),constructor,target);
  }
  
    <ajc-test dir="bugs151" title="structure model for generic itd">
        <compile files="pr131932.aj" options="-1.5 -emacssym"/>
    </ajc-test>
======= e2703cf:"weaver/src/org/aspectj/weaver/NewConstructorTypeMunger.java"

======= e2703cf:"weaver/src/org/aspectj/weaver/NewFieldTypeMunger.java"

======= e2703cf:"weaver/src/org/aspectj/weaver/NewMethodTypeMunger.java"


        before(): GenericType<String>.foo() {}
        before(): GenericType<MyList>.foo() {}
        //before(): GenericType.foo() {}
        public pointcut foo(): execution(* T.*(..));
======= f2cd94f:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  
  public void testGenericAspectWithUnknownType_pr131933() {
  }
  
    <ajc-test dir="bugs151" title="no ClassCastException with generic aspect and unknown type">
        <compile files="pr131933.aj" options="-1.5">
          <message kind="error" line="5" text="can't bind type name 'MyList'"/>
        </compile>
    </ajc-test> 
======= f2cd94f:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"


======= b3cd01d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= b3cd01d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= b3cd01d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= b3cd01d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= b3cd01d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= b3cd01d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= b3cd01d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= b3cd01d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= b3cd01d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= b3cd01d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= b3cd01d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= b3cd01d:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= b3cd01d:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= b3cd01d:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


======= 6e6658a:"bcel-builder/src/org/aspectj/apache/bcel/generic/ClassGen.java"

======= 6e6658a:"bcel-builder/src/org/aspectj/apache/bcel/generic/ClassGen.java"

 * @version $Id: ClassGen.java,v 1.6 2006/03/09 17:25:48 aclement Exp $
 *
 * Upgraded, Andy Clement 9th Mar 06 - calculates SUID
======= 6e6658a:"bcel-builder/src/org/aspectj/apache/bcel/generic/ClassGen.java"

  
  /**
   * Calculate the SerialVersionUID for a class.
   */  
  public long getSUID() {
  	try {
        Field[] fields   = getFields();
        Method[] methods = getMethods();
        
    	ByteArrayOutputStream baos = new ByteArrayOutputStream();
    	DataOutputStream dos = new DataOutputStream(baos);
    	
    	// 1. classname
    	dos.writeUTF(getClassName());
    	
    	// 2. classmodifiers: ACC_PUBLIC, ACC_FINAL, ACC_INTERFACE, and ACC_ABSTRACT
    	int classmods = 0; 
    	classmods|=(isPublic()?Constants.ACC_PUBLIC:0); 
    	classmods|=(isFinal()?Constants.ACC_FINAL:0);
    	classmods|=(isInterface()?Constants.ACC_INTERFACE:0);
    	if (isInterface() && isAbstract()) { // remove abstract if we have it but have no methods 
    		if (methods.length>0) classmods|=Constants.ACC_ABSTRACT;
    	}
    	dos.writeInt(classmods);
    	
    	// 3. ordered list of interfaces
    	List list = new ArrayList();
        String[] names = getInterfaceNames();
        if (names!=null) {
        	Arrays.sort(names);
        	for (int i = 0; i < names.length; i++) dos.writeUTF(names[i]);
        }
    
        // 4. ordered list of fields (ignoring private static and private transient fields):
        //  (relevant modifiers are ACC_PUBLIC, ACC_PRIVATE, 
        //   ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_VOLATILE, 
        //   ACC_TRANSIENT)
        list.clear();
        for (int i = 0; i < fields.length; i++) {
        Collections.sort(list,new FieldComparator());
        int relevantFlags = Constants.ACC_PUBLIC | Constants.ACC_PRIVATE | Constants.ACC_PROTECTED |
        					Constants.ACC_STATIC | Constants.ACC_FINAL | Constants.ACC_VOLATILE | Constants.ACC_TRANSIENT;
        for (Iterator iter = list.iterator(); iter.hasNext();) {
        // some up front method processing: discover clinit, init and ordinary methods of interest:
        list.clear(); // now used for methods
        List ctors = new ArrayList();
        boolean hasClinit = false;
        for (int i = 0; i < methods.length; i++) {
        	Method m = methods[i];
        	boolean couldBeInitializer = m.getName().charAt(0)=='<';
        	if (couldBeInitializer && m.getName().equals("<clinit>")) {
        		hasClinit=true;
        	} else if (couldBeInitializer && m.getName().equals("<init>")) {
        		if (!m.isPrivate()) ctors.add(m);
        	} else {
        	    if (!m.isPrivate()) list.add(m);
        	}
        Collections.sort(ctors, new ConstructorComparator());
        Collections.sort(list, new MethodComparator());
        
        
        if (hasClinit) {
        	dos.writeUTF("<clinit>");
        	dos.writeInt(Modifier.STATIC);
        	dos.writeUTF("()V");
        }
        
        // for methods and constructors: 
        //               ACC_PUBLIC, ACC_PRIVATE, ACC_PROTECTED, ACC_STATIC, ACC_FINAL, ACC_SYNCHRONIZED, 
        //               ACC_NATIVE, ACC_ABSTRACT and ACC_STRICT
        relevantFlags = 	
        	Constants.ACC_PUBLIC | Constants.ACC_PRIVATE | Constants.ACC_PROTECTED |
        	Constants.ACC_STATIC | Constants.ACC_FINAL | Constants.ACC_SYNCHRONIZED | 
        	Constants.ACC_NATIVE | Constants.ACC_ABSTRACT | Constants.ACC_STRICT;
        
        for (Iterator iter = ctors.iterator(); iter.hasNext();) {
        // 7. sorted non-private methods 
        for (Iterator iter = list.iterator(); iter.hasNext();) {
        dos.flush();
        dos.close();
        byte[] bs = baos.toByteArray();
        MessageDigest md = MessageDigest.getInstance("SHA");
        byte[] result = md.digest(bs);
                
        long suid = 0L;
        int pos = result.length>8?7:result.length-1; // use the bytes we have
        while (pos>=0) {
        	suid = suid<<8 | ((long)result[pos--]&0xff);
        }
        // if it was definetly 8 everytime...
        //	    long suid = ((long)(sha[0]&0xff) | (long)(sha[1]&0xff) << 8  |
  	} catch (Exception e) {
  		System.err.println("Unable to calculate suid for "+getClassName());
  		throw new RuntimeException(e);
  	}
  }
  
  private static class FieldComparator implements Comparator {
  }
  private static class ConstructorComparator implements Comparator {
  }
  private static class MethodComparator implements Comparator {
  }
        <term>-XaddSerialVersionUID</term>
        <listitem><para>Causes the compiler to calculate and add
        the SerialVersionUID field to any type implementing
        Serializable that is affected by an aspect.  The field
        is calculated based on the class before weaving has
        taken place.
        </para></listitem>
      </varlistentry>
      
      <varlistentry>
======= 6e6658a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= 6e6658a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

        setAddSerialVerUID(global.isAddSerialVerUID());
======= 6e6658a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= 6e6658a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 6e6658a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= 6e6658a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= 6e6658a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

  public static void main(String[] args) {
    try {
      Basic b = (Basic)Basic.class.newInstance();
      Field f = Basic.class.getDeclaredField("serialVersionUID");
      long l = f.getLong(b);
      System.err.println("SerialVersionUID is "+l);
    } catch (Exception e) {
      System.err.println("Problem: "+e.toString());
    }
  }
======= 6e6658a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

  public static void main(String[] args) {
  }
  
  public int anInt;
  
  public static boolean aBoolean = false;
  
  public long foo = 376;
  
  public void m() {}
  public int compareTo(Object o) { return 0;}
  public String m2(boolean b,long l, String s) { return "";}
  
  public static transient short fo2 = 3;
  
======= 6e6658a:"tests/src/org/aspectj/systemtest/ajc151/AllTestsAspectJ151.java"

======= 6e6658a:"tests/src/org/aspectj/systemtest/ajc151/AllTestsAspectJ151.java"

 * Copyright (c) 2006 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 * 
 * Contributors:
 *     Andy Clement - initial implementation
 *******************************************************************************/
  public void testTheBasics() { runTest("basic"); }
  public void testTheBasicsWithLint() { runTest("basic - lint"); }
  public void testHorrible() { runTest("horrible"); }
  
  //
  public static Test suite() {
    return XMLBasedAjcTestCase.loadSuite(SerialVersionUIDTests.class);
  }
  protected File getSpecFile() {
    return new File("../tests/src/org/aspectj/systemtest/ajc151/serialversionuid.xml");
  }
======= 6e6658a:"tests/src/org/aspectj/systemtest/ajc151/AllTestsAspectJ151.java"

    
    <ajc-test dir="features151/serialveruid" title="basic">
        <compile files="Basic.java" options="-1.5 -XaddSerialVersionUID"/>
        <run class="Basic">
          <stderr>
             <line text="SerialVersionUID is 7052682057082172300"/>
          </stderr>
        </run>
    </ajc-test>
    
    <ajc-test dir="features151/serialveruid" title="basic - lint">
        <compile files="Basic.java" options="-1.5 -XaddSerialVersionUID -Xlint:warning">
          <message kind="warning" text="calculated SerialVersionUID for type Basic"/>
        </compile>
        <run class="Basic">
          <stderr>
             <line text="SerialVersionUID is 7052682057082172300"/>
          </stderr>
        </run>
    </ajc-test>
    
    <ajc-test dir="features151/serialveruid" title="horrible">
        <compile files="BigHorribleClass.java,AnAspect.java" options="-1.5 -XaddSerialVersionUID -Xlint:warning">
          <message kind="warning" text="calculated SerialVersionUID for type BigHorribleClass"/>
        </compile>
        <run class="BigHorribleClass">
          <stderr>
             <line text="SerialVersionUID is 6512414869923012873"/>
          </stderr>
        </run>
    </ajc-test>
    
======= 6e6658a:"weaver/src/org/aspectj/weaver/Lint.java"

======= 6e6658a:"weaver/src/org/aspectj/weaver/World.java"

    private boolean addSerialVerUID = false;
    
    
======= 6e6658a:"weaver/src/org/aspectj/weaver/World.java"

    public void setAddSerialVerUID(boolean b) { addSerialVerUID=b;}
    public boolean isAddSerialVerUID() { return addSerialVerUID;}
    
======= 6e6658a:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= 6e6658a:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= 6e6658a:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= 6e6658a:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

        
======= 6e6658a:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

    	if (tjpFields.size() == 0 && !serialVersionUIDRequiresInitialization) return;
    	InstructionList il = null;
    	
    	if (tjpFields.size()>0) {
    	    il = initializeAllTjps();
    	}
    	
    	if (serialVersionUIDRequiresInitialization) {
    		if (il==null) {
    			il= new InstructionList();
    		}
    	    il.append(new PUSH(getConstantPoolGen(),calculatedSerialVersionUID));
    	    il.append(getFactory().createFieldAccess(getClassName(), "serialVersionUID", BasicType.LONG, Constants.PUTSTATIC));
    	}

======= b225911:"ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java"

        </para></listitem>
        <term>-XterminateAfterCompilation</term>
        <listitem><para>Causes compiler to terminate before weaving
            	terminateAfterCompilation,
                    (reweavable, terminateAfterCompilation, etc.).
======= b225911:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

        	} else if (arg.equals("-noWeave") || arg.equals( "-XnoWeave")) {
        	} else if (arg.equals( "-XterminateAfterCompilation")) {
======= b225911:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/core/AspectJCore.java"

======= b225911:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= b225911:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= b225911:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= b225911:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= b225911:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= b225911:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= b225911:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

        if (!isTerminateAfterCompilation() && global.isTerminateAfterCompilation()) {
            setTerminateAfterCompilation(true);
======= b225911:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= b225911:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= b225911:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= b225911:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= b225911:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= b225911:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= b225911:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= b225911:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"

======= b225911:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= b225911:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= b225911:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= b225911:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= b225911:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= b225911:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

        // many now deprecated: reweavable*
            	"terminateAfterCompilation","hasMember",
======= b225911:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    public void setXTerminateAfterCompilation(boolean b) {  
        cmd.addFlag("-XterminateAfterCompilation", b);
    public void setXNoWeave(boolean b) {
    	if (logger!=null) logger.warning("the noweave option is no longer required and is being ignored");
    }
    
    public void setNoWeave(boolean b) {
    	if (logger!=null) logger.warning("the noweave option is no longer required and is being ignored");
    }
    
======= b225911:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

            } else if ("-XterminateAfterCompilation".equals(flag)) {
                setXTerminateAfterCompilation(true);
======= b225911:"taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java"

======= b225911:"testing/src/org/aspectj/testing/harness/bridge/CompilerRun.java"

                        factory.create("XterminateAfterCompilation"),
     -XterminateAfterCompilation \
======= b225911:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testIllegalAccessErrorWithAroundAdviceTerminateAfterCompilationLTW_pr119657() {
   <ajc-test dir="bugs150/pr119657" title="IllegalAccessError with around advice on interface method call using -XterminateAfterCompilation and LTW">
     <compile files="accounts/recovery/Recovery.aj" options="-XterminateAfterCompilation"/>
======= b225911:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"

======= b225911:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"

    public void testAjcLTWAroundInlineMungerTest_XterminateAfterCompilation() {
        runTest("AjcLTW AroundInlineMungerTest -XterminateAfterCompilation");
    <ajc-test dir="java5/ataspectj" title="AjcLTW PerClauseTest -XterminateAfterCompilation">
                options="-1.5 -XterminateAfterCompilation"/>
                options="-1.5 -XterminateAfterCompilation"/>
    <ajc-test dir="java5/ataspectj" title="AjcLTW AroundInlineMungerTest -XterminateAfterCompilation">
                options="-1.5 -XterminateAfterCompilation"/>
    		options="-1.5 -XterminateAfterCompilation"
    		options="-1.5 -XterminateAfterCompilation"
    		options="-1.5 -XterminateAfterCompilation"
    		options="-1.5 -XterminateAfterCompilation"
            options="-1.5 -XterminateAfterCompilation"
            options="-1.5 -Xdev:NoAtAspectJProcessing -XterminateAfterCompilation"
            options="-1.5 -Xdev:NoAtAspectJProcessing -XterminateAfterCompilation"
            options="-1.5 -XterminateAfterCompilation"/>
            options="-1.5 -XterminateAfterCompilation"
======= b225911:"tests/src/org/aspectj/systemtest/inpath/InPathTests.java"

      title="The compiler crashes when using aspect libraries created without using -terminateAfterCompile">

======= a116142:"weaver/src/org/aspectj/weaver/JoinPointSignature.java"

======= a116142:"weaver/src/org/aspectj/weaver/Member.java"

======= a116142:"weaver/src/org/aspectj/weaver/MemberImpl.java"

======= a116142:"weaver/src/org/aspectj/weaver/MemberImpl.java"

======= a116142:"weaver/src/org/aspectj/weaver/MemberImpl.java"

======= a116142:"weaver/src/org/aspectj/weaver/MemberImpl.java"


======= cafdecb:"weaver/src/org/aspectj/weaver/ltw/LTWWorld.java"

 *   Ron Bodkin		Initial implementation
 * @author Ron Bodkin
======= cafdecb:"weaver/src/org/aspectj/weaver/ltw/LTWWorld.java"

    private AnnotationFinder annotationFinder;
    private ClassLoader loader; // weavingContext?
    
    protected final static Class concurrentMapClass = makeConcurrentMapClass();
    protected static Map/*<String, WeakReference<ReflectionBasedReferenceTypeDelegate>>*/ bootstrapTypes = makeConcurrentMap();
    
    /**
     * Build a World from a ClassLoader, for LTW support
     */
    public LTWWorld(ClassLoader loader, IMessageHandler handler, ICrossReferenceHandler xrefHandler) {
        super(loader, handler, xrefHandler);
        this.loader = loader;
        
        setBehaveInJava5Way(LangUtil.is15VMOrGreater());
        annotationFinder = ReflectionWorld.makeAnnotationFinderIfAny(loader, this);
    }
    
        return this.loader;
    }
    
    //TEST
    //this is probably easier: just mark anything loaded while loading aspects as not
    //expendible... it also fixes a possible bug whereby non-rewoven aspects are deemed expendible
    //<exclude within="org.foo.aspects..*"/>
    /**
    protected ReferenceTypeDelegate resolveDelegate(ReferenceType ty) {  	
        String name = ty.getName();
        // use reflection delegates for all bootstrap types
        ReferenceTypeDelegate bootstrapLoaderDelegate = resolveIfBootstrapDelegate(ty);
        if (bootstrapLoaderDelegate != null) {
            return bootstrapLoaderDelegate;
        }
        
       	return super.resolveDelegate(ty);
    }
    protected ReferenceTypeDelegate resolveIfBootstrapDelegate(ReferenceType ty) {
        // first check for anything available in the bootstrap loader: these types are just defined from that without allowing nondelegation
    	String name = ty.getName();
        Reference bootRef = (Reference)bootstrapTypes.get(name);
        if (bootRef != null) {        	
        	ReferenceTypeDelegate rtd = (ReferenceTypeDelegate)bootRef.get();
        	if (rtd != null) {
        		return rtd;
        	}
        }
        char fc = name.charAt(0);
        if (fc=='j' || fc=='c' || fc=='o' || fc=='s') { // cheaper than imminent string startsWith tests
        }
        return null;
    }
    
    /**
     * Helper method to resolve the delegate from the reflection delegate factory.
     */
    private ReferenceTypeDelegate resolveReflectionTypeDelegate(ReferenceType ty, ClassLoader resolutionLoader) {
        ReferenceTypeDelegate res = ReflectionBasedReferenceTypeDelegateFactory.createDelegate(ty, this, resolutionLoader);
        return res;
    }
    /**
     * Remove this class from the typeMap. Call back to be made from a publishing class loader
     * The class loader should, ideally, make this call on each
     * not yet working
     * 
     * @param clazz
     */
    public void loadedClass(Class clazz) {
    }
    
    private static final long serialVersionUID = 1;
    public AnnotationFinder getAnnotationFinder() {
        return this.annotationFinder;
    }
    /* (non-Javadoc)
     * @see org.aspectj.weaver.reflect.IReflectionWorld#resolve(java.lang.Class)
     */
    public ResolvedType resolve(Class aClass) {
        return ReflectionWorld.resolve(this, aClass); 
    }
    private static Map makeConcurrentMap() {
    	if (concurrentMapClass != null) {
    		try {
    			return (Map)concurrentMapClass.newInstance();
    		} catch (InstantiationException _) {
    		} catch (IllegalAccessException _) {    			
    		}
    		// fall through if exceptions
    	}
    	return Collections.synchronizedMap(new HashMap());
    }
    
    private static Class makeConcurrentMapClass() {
    	String betterChoices[] = { 
    			"java.util.concurrent.ConcurrentHashMap", 
    			"edu.emory.mathcs.backport.java.util.concurrent.ConcurrentHashMap", 
    			"EDU.oswego.cs.dl.util.concurrent.ConcurrentHashMap"
    	};
    	return null;
    }
    
======= cafdecb:"weaver/src/org/aspectj/weaver/ltw/LTWWorld.java"

 * Copyright (c) 2005 Contributors
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *    Ron Bodkin     initial implementation 
 * ******************************************************************/
 package org.aspectj.weaver.reflect;
======= cafdecb:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= cafdecb:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= cafdecb:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= cafdecb:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= cafdecb:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= cafdecb:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= cafdecb:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= cafdecb:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= cafdecb:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= cafdecb:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= cafdecb:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= cafdecb:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= cafdecb:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= cafdecb:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.java"


======= 3fa1bdd:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  public void testAtAspectVerifyErrorWithAfterThrowingAndthisJoinPoint_pr122742() {
  }
  
  public void testAtAspectVerifyErrorWithAfterReturningAndthisJoinPoint_pr122742() {
  }
  
    </ajc-test>
      
    <ajc-test dir="bugs151/pr122742" title="@AJ VerifyError with @AfterThrowing and thisJoinPoint argument">
    	<compile files="AfterThrowingTest.java" options="-1.5"/>
    	<run class="AfterThrowingTest">
    	</run>
    </ajc-test>
    <ajc-test dir="bugs151/pr122742" title="@AJ VerifyError with @AfterReturning and thisJoinPoint argument">
    	<compile files="AfterReturningTest.java" options="-1.5"/>
    	<run class="AfterReturningTest">
    	</run>
    </ajc-test>
   
======= 3fa1bdd:"weaver/src/org/aspectj/weaver/Advice.java"


======= 89d66dc:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java"

======= 89d66dc:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java"

======= 89d66dc:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java"

======= 89d66dc:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java"

======= 89d66dc:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java"

======= 89d66dc:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java"

======= 89d66dc:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


    @Pointcut("(execution(public * Foo.anotherMethod*(..)) || execution(public * Foo.methodA(..))) && this(obj)")
    protected void methodExec(Object obj){};
        
    @Before("methodExec(obj)")
    public void beforeMethodExec(JoinPoint thisJoinPoint, Object obj) {
      	System.out.println("Before " + thisJoinPoint.getSignature().toString());
    }
======= ba42a09:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  public void testAtAspectNoNPEWithPcdContainingOrThisAndWildcard_pr128237() {
  }
  
    <ajc-test dir="bugs151" title="@AJ no npe with pointcut containing or, this and a wildcard">
        <compile files="pr128237.java" options="-1.5"/>
    </ajc-test>
======= ba42a09:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


======= 7a2087e:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

                	String n = method.getName();
                	if (n.startsWith("ajc$pointcut")) { // Allow for the abstract pointcut being from a code style aspect compiled with -1.5 (see test for 128744)
                		n = n.substring(14);
                		n = n.substring(0,n.indexOf("$"));
                		elligibleAbstractions.add(n);
                	} else {
                		elligibleAbstractions.add(method.getName());
                	}
======= 7a2087e:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

======= 7a2087e:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

======= 7a2087e:"loadtime/src/org/aspectj/weaver/loadtime/ConcreteAspectCodeGen.java"

  <aspects>
    <aspect name="World" /> 
    <concrete-aspect name="World1" extends="World">
      <pointcut name="monitoredOperation" expression="execution(* sayHello())" /> 
    </concrete-aspect>
  </aspects>
  <weaver options="-verbose -showWeaveInfo" /> 
======= 7a2087e:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  public void testBrokenLTW_pr128744() { runTest("broken ltw"); }
    <ajc-test dir="bugs151/pr128744" title="broken ltw">
        <compile files="Hello.java World.java" options="-1.5" />
        <run class="Hello" ltw="aop.xml">
        	<stdout>
                <line text="Hello"/>
                <line text="World"/>
            </stdout>
        </run>
    </ajc-test>
    

======= f95d2c9:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"


    static Object s;
    public static void main(String[] args) {
        String t = "Hello, World!";
        t.toString();
        if (s != t) throw new Error();
    }
    static abstract aspect GenericAspect<T> {
        abstract pointcut checkpoint(T t);
        // advice declaration causes error
        after(T t): checkpoint(t) { s = t;}
    }
    static aspect AAA extends GenericAspect<String>{
        pointcut checkpoint(String s) : target(s) && 
            call(String String.toString());
    }  
======= 1f1ace1:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

    
  public void testGenericAdviceParameters_pr123553()    { runTest("generic advice parameters");}
    <ajc-test dir="bugs151/pr123553" title="generic advice parameters">
        <compile files="A.java" options="-1.5"/>
        <run class="A"/>
    </ajc-test>  
    

   public interface Moody {
      Mood getMood();
      void setMood(Mood mood);
   }
   public static class MoodyImpl implements Moody {
      private Mood mood = Mood.HAPPY;
      public Mood getMood() { return mood; }
      public void setMood(Mood mood) { this.mood = mood; }
   }
  
   private Moody implementedInterface;
======= e874581:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  public void testAtAspectDeclareParentsRetainsFieldState_pr122370() {
  }
  
    <ajc-test dir="bugs151/pr122370" title="@AJ declare parents retains field state">
        <compile files="moody/AnnotationMoodImplementor.java, moody/AnnotationMoodIndicator.java, moody/Mood.java, moody/MainClass.java" options="-1.5"/>
       <run class="moody.MainClass">
            <stdout>
             <line text="ami0's mood is HAPPY"/>
             <line text="ami1's mood is now JOLLY"/>
             <line text="ami0's mood is still HAPPY"/>
            </stdout>
        </run>
    </ajc-test>
======= e874581:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

            BranchInstruction ifNonNull = InstructionFactory.createBranchInstruction(Constants.IFNONNULL, null);
            
            // Create and store a new instance
           	body.append(InstructionConstants.ALOAD_0);
            
            // if not null use the instance we've got
            InstructionHandle ifNonNullElse =  body.append(InstructionConstants.ALOAD_0);

======= d4219e1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

======= d4219e1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

        public static void main(String[] args) {
                System.out.println("Main");
        }
    @Before("execution(* main(..))")
    public void log(JoinPoint thisJoinPoint) {
            System.out.println("Before " + thisJoinPoint);
    }
======= d4219e1:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  public void testAtAspectWithoutJoinPointImport_pr121616() {
  }
  
    <ajc-test dir="bugs151" title="@AJ without JoinPoint import">
        <compile files="pr121616.java" options="-1.5">
          <message kind="error" line="13" text="JoinPoint cannot be resolved to a type"/>
        </compile>
    </ajc-test>

======= 0b39aa5:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= 0b39aa5:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


    static final String warning = "warning";
    @DeclareError("execution(* C.badMethod())")
    static final String error = "error";
======= f743fb2:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

======= f743fb2:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  public void testAtAspectDEOWInStructureModel_pr120356() {
  	  IHierarchy top = AsmManager.getDefault().getHierarchy();
  	   
  	  // get the IProgramElements corresponding to the @DeclareWarning statement
  	  // and the method it matches.
  	  IProgramElement warningMethodIPE = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.METHOD,"warningMethod()");  	   	 
  	  assertNotNull("Couldn't find 'warningMethod()' element in the tree",warningMethodIPE);
  	  IProgramElement atDeclareWarningIPE = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.FIELD,"warning");
  	  assertNotNull("Couldn't find @DeclareWarning element in the tree",atDeclareWarningIPE);
  	  // check that the method has a matches declare relationship with @DeclareWarning
  	  List matches = AsmManager.getDefault().getRelationshipMap().get(warningMethodIPE);	
  	  assertNotNull("warningMethod should have some relationships but does not",matches);
  	  assertTrue("warningMethod should have one relationships but has " + matches.size(),matches.size()==1);
  	  List matchesTargets = ((Relationship)matches.get(0)).getTargets();
  	  assertTrue("warningMethod should have one targets but has" + matchesTargets.size(),matchesTargets.size()==1);
  	  IProgramElement target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchesTargets.get(0));
  	  assertEquals("target of relationship should be the @DeclareWarning 'warning' but is IPE with label "
  			  + target.toLabelString(),atDeclareWarningIPE,target);
  	  
  	  // check that the @DeclareWarning has a matches relationship with the warningMethod
  	  List matchedBy = AsmManager.getDefault().getRelationshipMap().get(atDeclareWarningIPE);
  	  assertNotNull("@DeclareWarning should have some relationships but does not",matchedBy);
  	  assertTrue("@DeclareWarning should have one relationship but has " + matchedBy.size(), matchedBy.size() == 1);
  	  List matchedByTargets = ((Relationship)matchedBy.get(0)).getTargets();
  	  assertTrue("@DeclareWarning 'matched by' relationship should have one target " +
  	  		"but has " + matchedByTargets.size(), matchedByTargets.size() == 1);
  	  IProgramElement matchedByTarget = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchedByTargets.get(0));
  	  assertEquals("target of relationship should be the warningMethod but is IPE with label "
  			  + matchedByTarget.toLabelString(),warningMethodIPE,matchedByTarget);
  	  
  	  // get the IProgramElements corresponding to the @DeclareError statement
  	  // and the method it matches.
  	  IProgramElement errorMethodIPE = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.METHOD,"badMethod()");  	   	 
  	  assertNotNull("Couldn't find 'badMethod()' element in the tree",errorMethodIPE);
  	  IProgramElement atDeclarErrorIPE = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.FIELD,"error");
  	  assertNotNull("Couldn't find @DeclareError element in the tree",atDeclarErrorIPE);
  	  // check that the @DeclareError has a matches relationship with the badMethod
  	  List matchedByE = AsmManager.getDefault().getRelationshipMap().get(atDeclarErrorIPE);
  	  assertNotNull("@DeclareError should have some relationships but does not",matchedByE);
  	  assertTrue("@DeclareError should have one relationship but has " + matchedByE.size(), matchedByE.size() == 1);
  	  List matchedByTargetsE = ((Relationship)matchedByE.get(0)).getTargets();
  	  assertTrue("@DeclareError 'matched by' relationship should have one target " +
  	  		"but has " + matchedByTargetsE.size(), matchedByTargetsE.size() == 1);
  	  IProgramElement matchedByTargetE = AsmManager.getDefault().getHierarchy().findElementForHandle((String)matchedByTargetsE.get(0));
  	  assertEquals("target of relationship should be the badMethod but is IPE with label "
  			  + matchedByTargetE.toLabelString(),errorMethodIPE,matchedByTargetE);
  }
  
  public void testAtAspectNoNPEWithDEOWWithoutStructureModel_pr120356() {
  }
  
    <ajc-test dir="bugs151/pr120356" title="@AJ deow appear correctly when structure model is generated">
        <compile files="C.java, A.java" options="-1.5, -emacssym">
         <message kind="error" line="8" text="error"/>
          <message kind="warning" line="5" text="warning"/>
        </compile>
    </ajc-test> 
    <ajc-test dir="bugs151/pr120356" title="@AJ no NPE with deow when structure model isn't generated">
        <compile files="C.java, A.java" options="-1.5">
         <message kind="error" line="8" text="error"/>
          <message kind="warning" line="5" text="warning"/>
        </compile>
    </ajc-test>
======= f743fb2:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

======= f743fb2:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

                    setDeclareErrorOrWarningLocation(deow,struct);
======= f743fb2:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

                    setDeclareErrorOrWarningLocation(deow,struct);
======= f743fb2:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

     * Sets the location for the declare error / warning using the corresponding 
     * IProgramElement in the structure model. This will only fix bug 120356 if
     * compiled with -emacssym, however, it does mean that the cross references 
     * view in AJDT will show the correct information.
     * 
     * Other possibilities for fix: 
     *  1. using the information in ajcDeclareSoft (if this is set correctly) 
     *     which will fix the problem if compiled with ajc but not if compiled 
     *     with javac.
     *  2. creating an AjAttribute called FieldDeclarationLineNumberAttribute 
     *     (much like MethodDeclarationLineNumberAttribute) which we can ask 
     *     for the offset. This will fix bug 120356 both when compiled with ajc 
     *     and javac.
     * 
     * @param deow
     * @param struct
     */
    private static void setDeclareErrorOrWarningLocation(DeclareErrorOrWarning deow, AjAttributeFieldStruct struct) {
        IHierarchy top = AsmManager.getDefault().getHierarchy();
        if (top.getRoot() != null) {
        	IProgramElement ipe = top.findElementForLabel(top.getRoot(),
      			  IProgramElement.Kind.FIELD,struct.field.getName());
        	if (ipe != null && ipe.getSourceLocation() != null) {
    			ISourceLocation sourceLocation = ipe.getSourceLocation();
    			int start = sourceLocation.getOffset();
    			int end = start + struct.field.getName().length();
    			deow.setLocation(struct.context,start,end);
    			return;
    		}
        deow.setLocation(struct.context, -1, -1);												
    }
    
    /**

======= d856e4f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"


======= eec4990:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjTypeDeclaration.java"

======= eec4990:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjTypeDeclaration.java"

======= eec4990:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjTypeDeclaration.java"

======= eec4990:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AjTypeDeclaration.java"

 	/**
 	 * Returns a list of structural property descriptors for this node type.
 	 * Clients must not modify the result.
 	 * 
 	 * @param apiLevel the API level; one of the
 	 * <code>AST.JLS&ast;</code> constants
 	 * @return a list of property descriptors (element type: 
 	 * {@link StructuralPropertyDescriptor})
 	 * @since 3.0
 	 */
 	public static List propertyDescriptors(int apiLevel) {
 		if (apiLevel == AST.JLS2_INTERNAL) {
 			return ajPROPERTY_DESCRIPTORS_2_0;
 		} else {
 			return ajPROPERTY_DESCRIPTORS_3_0;
 		}
 	}
 	
======= eec4990:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AspectDeclaration.java"

======= eec4990:"org.aspectj.ajdt.core/src/org/aspectj/org/eclipse/jdt/core/dom/AspectDeclaration.java"

======= eec4990:"org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/AjASTTest.java"

======= eec4990:"org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/AjASTTest.java"

======= eec4990:"org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/AjASTTest.java"

======= eec4990:"org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/AjASTTest.java"


======= 4934132:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

            	if (lvt!=null) 	return lvt.getType();
======= 4934132:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

              searchPtr.getInstruction()+".  Perhaps avoid selecting clone with your pointcut?");

======= 693945f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= 693945f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= 693945f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

   public void x(){} 
======= 693945f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

   void around():call(void *(..)){ 
      A a = new A();
      a.A.a.x(); // This line raises the NPE    
      proceed();    
   }
======= 693945f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

       @Pointcut("")
       protected void scope () {}
======= 693945f:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  //public void testEmptyPointcut_pr125475()    { runTest("empty pointcut in atAJ");}
  public void testInlinevisitorNPE_pr123901() { runTest("inlinevisitor NPE");}
    </ajc-test>  
    
    <ajc-test dir="bugs151/pr123901" title="inlinevisitor NPE">
        <compile files="A.java,B.java" options="-1.5">
          <message kind="error" line="5" text="a.A cannot be resolved or is not a field"/>
        </compile>
    <ajc-test dir="bugs151/pr125475" title="empty pointcut in atAJ">
        <compile files="TestEmptyPointcutAtAspect.java" options="-1.5"/>
    </ajc-test>

======= 551b446:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 551b446:"tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"

======= 551b446:"tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"

======= 551b446:"tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"

======= 551b446:"tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"

======= 551b446:"tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"

======= 551b446:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= 551b446:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


======= 7e40a60:"asm/src/org/aspectj/asm/IProgramElement.java"

======= 7e40a60:"asm/src/org/aspectj/asm/IProgramElement.java"

======= 7e40a60:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= 7e40a60:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= 7e40a60:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= 7e40a60:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java"

======= 7e40a60:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java"

======= 7e40a60:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java"

======= 7e40a60:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

======= 7e40a60:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  public void testIProgramElementMethods_pr125295() {
  	  IHierarchy top = AsmManager.getDefault().getHierarchy();
  	  IProgramElement pe = top.findElementForType("pkg","foo");
  	  assertNotNull("Couldn't find 'foo' element in the tree",pe);
  	  // check that the defaults return the fully qualified arg
  	  assertEquals("foo(int, java.lang.Object)",pe.toLabelString());
  	  assertEquals("C.foo(int, java.lang.Object)",pe.toLinkLabelString());
  	  assertEquals("foo(int, java.lang.Object)",pe.toSignatureString());
  	  // check that can get hold of the non qualified args
  	  assertEquals("foo(int, Object)",pe.toLabelString(false));
  	  assertEquals("C.foo(int, Object)",pe.toLinkLabelString(false));
  	  assertEquals("foo(int, Object)",pe.toSignatureString(false));
  	  IProgramElement pe2 = top.findElementForType("pkg","printParameters");
  	  assertNotNull("Couldn't find 'printParameters' element in the tree",pe2);
  	  // the argument is org.aspectj.lang.JoinPoint, check that this is added
  	  assertFalse("printParameters method should have arguments",pe2.getParameterTypes().isEmpty());	  
  }
  
    <ajc-test dir="bugs151/pr125295" title="new IProgramElement methods">
        <compile files="pkg/C.java,pkg/A.aj" options="-emacssym"/>
    </ajc-test>

======= efb20c5:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"


======= a4bd19d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= a4bd19d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= a4bd19d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

   protected  T getSomething() {
       return null;
   }
   // Runtime Error
   void around() : execution(void someMethod()) {
       System.out.println(getSomething());
   }
   public static void main(String[] args) {
     new C().someMethod();
   }
   
   public void someMethod() { }
======= a4bd19d:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  public void testCallInheritedGenericMethod_pr124999() { runTest("calling inherited generic method from around advice");}
    <ajc-test dir="bugs151" title="calling inherited generic method from around advice">
        <compile files="pr124999.aj" options="-1.5"/>
        <run class="pr124999"/>
    </ajc-test>
    

    // main
    public static void main(String[] args) {
        for (String arg : args) {
            System.out.println("got: " + arg);
        }
    }
    pointcut printlnCalls(PrintStream ps, String out):
        call(* PrintStream+.println(String)) && target(ps) && args(out);
    Object around(PrintStream ps, String out):
        printlnCalls(ps, out) && !adviceexecution() {
        return proceed(ps, out);
    }
    // main
    public static void main(String[] args) {
        for (String arg : args) {
            System.out.println("got: " + arg);
            System.out.printf("got: %s\n", arg);
        }
    }
    pointcut printlnCalls(PrintStream ps, String out):
        call(* PrintStream+.println(String)) && target(ps) && args(out);
    Object around(PrintStream ps, String out):
        printlnCalls(ps, out) && !adviceexecution() {
        return proceed(ps, out);
    }
    pointcut printfCalls(PrintStream ps, String fmt, Object[] objs):
        call(* PrintStream+.printf(String, Object...))
        && target(ps) && args(fmt, objs);
======= d916002:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


   pointcut annotatedCall(A a) : call(@A * *.*(..)) && @annotation(a);
   before(A a) : annotatedCall(a) {
       System.err.println("Reference pointcut advice. "+a.annotationType());
   }
   before(A a) : call(@A * *.*(..)) && @annotation(a) {
       System.err.println("Inlined pointcut advice. "+a.annotationType());
   }
  public static void main(String []argv) {
    new BasicType().run();
  }
  @MyAnnotation
  public void run() {
    System.err.println("run running");
  }
======= 28f8c69:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  public void testGenericAspectsAndAnnotations_pr124654() { runTest("generic aspects and annotations");}
    
    <ajc-test dir="bugs151/pr124654" title="generic aspects and annotations">
        <compile files="GenericAnnotation.java,TestSubAspect.java" options="-1.5"/>
        <run class="TestSubAspect">
          <stderr>
            <line text="Reference pointcut advice. interface MyAnnotation"/>
            <line text="Inlined pointcut advice. interface MyAnnotation"/>
            <line text="run running"/>
          </stderr>
        </run>
    </ajc-test>
======= 28f8c69:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= 28f8c69:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"


       Set<T> ints = new HashSet<T>();
       public Set<T> foo() {
               return ints;
       }
       public static void main(String[] args) {
               Test<Integer> t2 = new Test<Integer>();
               Set<Integer> ints2 = t2.foo();
       }
   pointcut gettingMemberCollection() : get(Set<Number+> *);
   after() : gettingMemberCollection() {
     System.err.println("GO Aspects!  "+thisJoinPoint);
   }
======= 01a8b2e:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  public void testParameterizedCollectionFieldMatching_pr124808() { runTest("parameterized collection fields matched via pointcut");}
    
    <ajc-test dir="bugs151/pr124808" title="parameterized collection fields matched via pointcut">
        <compile files="Test.java,TestAspect.java" options="-1.5"/>
        <run class="Test">
          <stderr>
             <line text="GO Aspects!  get(Set Test.ints)"/>
          </stderr>
        </run>
    </ajc-test>
======= 01a8b2e:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= 01a8b2e:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= 01a8b2e:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"


  public void foo(T p);
  public void foo2(Y p);
  public void foo2(Y p) { }
  public void foo(Y p) { }
  public static void main(String []argv) {
    Test<Integer> t = new Test<Integer>();
    t.foo(7);
    t.foo2(9);
  }
  public void foo(T p) { }
  public void foo2(Y p) {}
  public void foo2(Y p) { }
  public void foo(Y p) { }
  public static void main(String []argv) {
    Test2<Integer> t = new Test2<Integer>();
    t.foo(7);
    t.foo2(9);
  }
       pointcut TestInheritance(Test test) : target(test) && execution (* Generic1.*(..));
       after (Test test) : TestInheritance(test) {
               System.err.println("Aspects:"+thisJoinPoint);
       }
       pointcut TestInheritance(Test2 test) : target(test) && execution (* Generic1.*(..));
       after (Test2 test) : TestInheritance(test) {
               System.err.println("Aspects:"+thisJoinPoint);
       }
======= 8676df9:"tests/src/org/aspectj/systemtest/ajc151/Ajc151Tests.java"

  public void testDifferentNumbersofTVars_pr124803() { runTest("generics and different numbers of type variables");}
  public void testDifferentNumbersofTVars_pr124803_2() { runTest("generics and different numbers of type variables - classes");}
    <ajc-test dir="bugs151/pr124803" title="generics and different numbers of type variables">
        <compile files="Test.java,TestAspect.java" options="-1.5 -showWeaveInfo">
          <message kind="weave" text="Join point 'method-execution(void Test.foo(java.lang.Number))' in Type 'Test' (Test.java:12) advised by after advice from 'TestAspect' (TestAspect.java:4)"/>
        </compile>
        <run class="Test">
          <stderr>
             <line text="Aspects:execution(void Test.foo(Number))"/>
          </stderr>
        </run>
    </ajc-test>
    
    <ajc-test dir="bugs151/pr124803" title="generics and different numbers of type variables - classes">
        <compile files="Test2.java,TestAspect2.java" options="-1.5 -showWeaveInfo">
          <message kind="weave" text="Join point 'method-execution(void Test2.foo(java.lang.Number))' in Type 'Test2' (Test2.java:12) advised by after advice from 'TestAspect2' (TestAspect2.java:4)"/>
        </compile>
        <run class="Test2">
          <stderr>
             <line text="Aspects:execution(void Test2.foo(Number))"/>
          </stderr>
        </run>
    </ajc-test>
======= 8676df9:"weaver/src/org/aspectj/weaver/ReferenceType.java"

======= 8676df9:"weaver/src/org/aspectj/weaver/ReferenceType.java"


======= 04067a6:"weaver/src/org/aspectj/weaver/World.java"

======= 04067a6:"weaver/src/org/aspectj/weaver/World.java"

======= 04067a6:"weaver/src/org/aspectj/weaver/World.java"

    protected TypeMap typeMap = new TypeMap(this); // Signature to ResolvedType
======= 04067a6:"weaver/src/org/aspectj/weaver/World.java"

======= 04067a6:"weaver/src/org/aspectj/weaver/World.java"

======= 04067a6:"weaver/src/org/aspectj/weaver/World.java"

======= 04067a6:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"


======= ab2f89b:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"

======= ab2f89b:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"


======= f4c8bf9:"ajdoc/src/org/aspectj/tools/ajdoc/Declaration.java"

======= f4c8bf9:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

======= f4c8bf9:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        	decorateHTMLFromIPEs(getProgramElements(inputFiles[i].getCanonicalPath()),
                  rootDir.getCanonicalPath() + Config.DIR_SEP_CHAR,
                  docModifier,
                  false);
    static void decorateHTMLFromIPEs(IProgramElement[] decls, String base, String docModifier, boolean exceededNestingLevel) throws IOException {
            	IProgramElement decl = decls[i];
                decorateHTMLFromIPE(decl, base, docModifier, exceededNestingLevel);
======= f4c8bf9:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

    static void decorateHTMLFromIPE(IProgramElement decl,
            String base,
            String docModifier,
            boolean exceededNestingLevel ) throws IOException {
======= f4c8bf9:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

======= f4c8bf9:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

======= f4c8bf9:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

======= f4c8bf9:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

======= f4c8bf9:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

======= f4c8bf9:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

    static public IProgramElement[] getProgramElements(String filename) {
    	
    	IProgramElement file = (IProgramElement)AsmManager.getDefault().getHierarchy().findElementForSourceFile(filename);
    }
    
    /**
     * Rejects anonymous kinds by checking if their name is an integer
     */
    
======= f4c8bf9:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

======= f4c8bf9:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

======= f4c8bf9:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

======= f4c8bf9:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            StubFileGenerator.doFiles(declIDTable, inputFiles, signatureFiles);
======= f4c8bf9:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

======= f4c8bf9:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

======= f4c8bf9:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

            processFile(inputFiles[i], signatureFiles[i]);
    static void processFile(File inputFile, File signatureFile) throws DocException {
======= f4c8bf9:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

        //boolean appendPeriod = true;
            //appendPeriod = false;
======= f4c8bf9:"ajdoc/src/org/aspectj/tools/ajdoc/SymbolManager.java"


======= 3f77e75:"weaver/src/org/aspectj/weaver/bcel/BcelField.java"

======= 3f77e75:"weaver/src/org/aspectj/weaver/bcel/BcelMethod.java"

 		 if (!world.isInJava5Mode()) { 
 			 this.genericReturnType = getReturnType();
 			 this.genericParameterTypes = getParameterTypes();
 			 return;
 		 }
 		 // ok, we have work to do...
======= 3f77e75:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= 3f77e75:"weaver/testsrc/org/aspectj/weaver/MemberTestCase15.java"

======= 3f77e75:"weaver/testsrc/org/aspectj/weaver/MemberTestCase15.java"


======= a9ef1b0:"runtime/src/org/aspectj/lang/JoinPoint.java"

    static String PREINITIALIZATION = "preinitialization";
======= a9ef1b0:"weaver/src/org/aspectj/weaver/Shadow.java"

    public static final Kind PreInitialization    = new Kind(JoinPoint.PREINITIALIZATION, 8,  false);

======= 24a785f:"weaver/src/org/aspectj/weaver/TypeFactory.java"


    public void setInnerClasses(InnerClass[] classes){};
    public static class InnerClass {}
    public void setInnerClasses(InnerClass[] classes){};
    public static class InnerClass {}
   public static void main(String []argv) {
     new pr112458_2();
   }
  before(pr112458_2.InnerClass[] ics): execution(void setInnerClasses(..)) && args(ics) {
  }
======= 53284da:"tests/src/org/aspectj/systemtest/AllTests15.java"

======= 53284da:"tests/src/org/aspectj/systemtest/AllTests15.java"

======= 53284da:"tests/src/org/aspectj/systemtest/ajc150/AllTestsAspectJ150.java"

======= 53284da:"tests/src/org/aspectj/systemtest/ajc150/AllTestsAspectJ150.java"

 * Copyright (c) 2006 IBM 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
  public void testMemberTypesInGenericTypes_pr112458()    { runTest("member types in generic types");}
  public void testMemberTypesInGenericTypes_pr112458_2()  { runTest("member types in generic types - 2");}
  
  
  /////////////////////////////////////////
  public static Test suite() {
    return XMLBasedAjcTestCase.loadSuite(Ajc151Tests.class);
  }
  protected File getSpecFile() {
    return new File("../tests/src/org/aspectj/systemtest/ajc151/ajc151.xml");
  }
  
======= 53284da:"tests/src/org/aspectj/systemtest/ajc150/AllTestsAspectJ150.java"

 * Copyright (c) 2006 IBM 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
        //$JUnit-END$
======= 53284da:"tests/src/org/aspectj/systemtest/ajc150/AllTestsAspectJ150.java"

    
    <ajc-test dir="bugs151" title="member types in generic types">
        <compile files="pr112458.aj" options="-1.5 -emacssym"/>
    </ajc-test>
    
    <ajc-test dir="bugs151" title="member types in generic types - 2">
        <compile files="pr112458_2.aj" options="-1.5 -emacssym"/>
        <run class="pr112458_2"/>
    </ajc-test>
======= 53284da:"weaver/src/org/aspectj/weaver/TypeFactory.java"


======= d69ce9a:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

======= d69ce9a:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

======= d69ce9a:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

======= d69ce9a:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

======= d69ce9a:"ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java"

        suite.addTestSuite(EnumTest.class);
======= d69ce9a:"ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java"

 * Copyright (c) 2005 Contributors. All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: IBM Corporation - initial API and implementation 
 * 				 Helen Hawkins   - iniital version
 *******************************************************************/
    public void testEnum() throws Exception {
        outdir.delete();
    	
        String[] args = { 
              "-XajdocDebug",
              "-private",
              "-source", 
              "1.5",
            "-d", 
            outdir.getAbsolutePath(),
            f.getAbsolutePath()
        };
        org.aspectj.tools.ajdoc.Main.main(args);
    }
    public void testInlinedEnum() throws Exception {
    	outdir.delete();
    	
        String[] args = { 
              "-XajdocDebug",
              "-private",
              "-source", 
              "1.5",
            "-d", 
            outdir.getAbsolutePath(),
            f.getAbsolutePath()
        };
        org.aspectj.tools.ajdoc.Main.main(args);
    }
    
    public void testEnumWithMethods() throws Exception {
    	outdir.delete();
    	
        String[] args = { 
              "-XajdocDebug",
              "-private",
              "-source", 
              "1.5",
            "-d", 
            outdir.getAbsolutePath(),
            f.getAbsolutePath()
        };
        org.aspectj.tools.ajdoc.Main.main(args);
    }

 abstract aspect X {
  void around(): execution(* foo(..)) {}
  public void foo() { } 
   new A().foo();
    pointcut greeting() :
    	execution(* Hello.sayWorld(..))
    	|| execution(* Hello.sayHello(..));
        public static void main(String[] args) {
                sayHello();
        } 
        public static void sayHello() {
                System.out.println("Hello");
                sayWorld();
        } 
        public static int sayWorld() {
                System.out.println("World");
                return 0;
        }
    //private Object result;
        pointcut greeting() : execution(* Hello.sayWorld(..)); 
        Object around(): greeting() {
        System.out.println("around start!");
        Object result = proceed();
        System.out.println("around end!");
        return result;
        }
    void greeting() {}
    <!-- using this we can debug the forked VM -->
    <property
        name="jdwp"
        value="-Xdebug -Xnoagent -Djava.compiler=NONE -Xrunjdwp:transport=dt_socket,server=y,suspend=y,address=5005"/>
    <target name="compile:javac">
        <!-- compile only javac compilable stuff, exclude the one that needs other dependencies -->
        <javac destdir="${aj.sandbox}" classpathref="aj.path"
            srcdir="${basedir}"
            includes="ataspectj/*"
            excludes="ataspectj/UnweavableTest.java"
            debug="true">
        </javac>
    </target>
    <target name="ltw">
        <java fork="yes" classname="ataspectj.AllLTWTests" failonerror="yes">
            <classpath refid="aj.path"/>
            <!-- use META-INF/aop.xml style -->
            <classpath path="ataspectj/pathentry"/>
            <jvmarg value="-javaagent:${aj.root}/lib/test/loadtime5.jar"/>
        </java>
    </target>
    <target name="ConcreteAsepectTest">
    	<copy file="aop.xml" todir="${aj.sandbox}/META-INF">
    	</copy>
        <java fork="yes" classname="Hello" failonerror="yes">
            <classpath refid="aj.path"/>
            <jvmarg value="-javaagent:${aj.root}/lib/test/loadtime5.jar"/>
            <jvmarg value="-Daj5.def=aop.xml"/>
            <jvmarg value="-Daj.weaving.verbose=true"/>
        </java>
    </target>
        <concrete-aspect name="World1" extends="World">
        	<pointcut name="greeting" expression="execution(* Hello.sayWorld(..)) || execution(* Hello.sayHello(..))"/>
        </concrete-aspect>
    	<aspect name="World"/>
    	<aspect name="ConcreteWorld"/>
    	<include within="Hello"/>
======= a778ac4:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testMixingCodeStyles_pr121385()  { runTest("mixing aspect styles");}
======= a778ac4:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testNPEInBcelAdviceWithConcreteAspect_pr121385() {
  }
  
  
    
    <ajc-test dir="bugs150/pr121385" title="mixing aspect styles">
        <compile files="A.java" options="-1.5"/>
        <run class="A"/>
    </ajc-test>
   
   <ajc-test dir="bugs150/pr121385" title="override protected pointcut in aop.xml concrete aspect">
     <compile files="Hello.java"/>
     <compile files="World.aj, ConcreteWorld.aj"/>
     <run class="Hello" ltw="aop.xml">
       <stdout>
           <line text="around start!"/>
           <line text="Hello"/>
           <line text="around start!"/>
           <line text="World"/>
           <line text="around end!"/>
           <line text="around end!"/>
       </stdout>
     </run>
     <ant file="ant.xml" target="ConcreteAsepectTest" verbose="true"/>
   </ajc-test>
======= a778ac4:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

        final boolean isAnnotationStyleAspect = getConcreteAspect()!=null && getConcreteAspect().isAnnotationStyleAspect() && x;
======= a778ac4:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= a778ac4:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

                    (munger.getConcreteAspect().isAnnotationStyleAspect() && munger.getDeclaringAspect()!=null && munger.getDeclaringAspect().resolve(world).isAnnotationStyleAspect())?
======= a778ac4:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        if (munger.getConcreteAspect()!=null && munger.getConcreteAspect().isAnnotationStyleAspect() 
           && munger.getDeclaringAspect()!=null && munger.getDeclaringAspect().resolve(world).isAnnotationStyleAspect()) {

======= bbdd496:"ajdoc/testdata/pr119453/src/pack/C.java"

======= bbdd496:"ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java"

        suite.addTestSuite(FullyQualifiedArgumentTest.class);
======= bbdd496:"ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java"

 * Copyright (c) 2005 Contributors. All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: IBM Corporation - initial API and implementation 
 * 				 Helen Hawkins   - iniital version
 *******************************************************************/
    
    public void testPr58520() throws Exception {
        outdir.delete();
        String[] args = { 
              "-XajdocDebug",
              "-private",
            "-d", 
            outdir.getAbsolutePath(),
            c.getAbsolutePath(),
            a.getAbsolutePath()
        };
        org.aspectj.tools.ajdoc.Main.main(args);
        
        checkContentsOfA();        
    }
        
    // check whether the "advises" section of the "Advice Summary" contains
    // the fully qualified argument, so for example, it says it has href
    // .../ajdoc/testdata/pr119453/doc/pack/C.html#method3(java.lang.String) 
    // rather than .../ajdoc/testdata/pr119453/doc/pack/C.html#method3(String)
    private void checkContentsOfA() throws Exception {
        File htmlA = new File("../ajdoc/testdata/pr119453/doc/pack/A.html");
        if (htmlA == null) {
        boolean containsAdviceSummary = false;
        String lineA = readerA.readLine();
        while( lineA != null && (!containsAdviceSummary)) {
        	if (lineA.indexOf("ADVICE SUMMARY") != -1) {
        		containsAdviceSummary = true;
        		boolean containsFullyQualifiedArgument = false;
        		boolean containsUnqualifiedArgument = false;
        		// walk through the information in this section
        }
        readerA.close();
        assertTrue("should have Advice Summary information in " +
        		"../ajdoc/testdata/pr119453/doc/pack/A.html", containsAdviceSummary);
               
    }
======= bbdd496:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java"

======= bbdd496:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"


======= 9abfc40:"loadtime/src/org/aspectj/weaver/loadtime/DefaultWeavingContext.java"

        @interface Me { String value() default "Me"; }
                    log(thisJoinPoint, "execMe[" + me.value() + "]");
             <line text="execution(void pr119749.C.m()): execMe[Me]"/>
======= 9abfc40:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= 9abfc40:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"

======= 9abfc40:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"

        BcelWorld bcelWorld = new BcelWorld(getClass().getClassLoader(),IMessageHandler.THROW,null);
======= 9abfc40:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"

======= 9abfc40:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionWorldTest.java"


======= 588e7b9:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

            if (weavingAdaptor == null) {
            	return bytes;
            }
======= 588e7b9:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

                	String loaderClassName = loader.getClass().getName(); 
                	if (loaderClassName.equals("sun.reflect.DelegatingClassLoader")) {
                		// we don't weave reflection generated types at all! 
                		return null;
                	} else {
                	}

======= bdafe31:"weaver/src/org/aspectj/weaver/Lint.java"

======= bdafe31:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= bdafe31:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= bdafe31:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= bdafe31:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"


======= 9d32b76:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= 9d32b76:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"


       public static void main(String[] args) {
               C.run();
       }
       static class C {
               static void run() {}
       }
       pointcut doit() : execution(void C.run());
       // no error if not pertarget
       static aspect CPT pertarget(pc()){
               // no error if doit() defined in CPT
               protected pointcut pc() : doit(); // unexpected CE
               before() : doit() {} // no CE
       }
======= ae500c6:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  //public void testNamedPointcutPertarget_pr120521() { runTest("named pointcut not resolved in pertarget pointcut");}
    
    <ajc-test dir="bugs150/pr120521" pr="120521" title="named pointcut not resolved in pertarget pointcut">
     <compile files="PerTargetSubaspectError.java"/>
    </ajc-test>  

======= 3ac4627:"weaver/src/org/aspectj/weaver/UnresolvedType.java"

    	throw new UnsupportedOperationException("unable to parameterize unresolved type: " + signature);

======= 9edb4b6:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        
        /* 
         * Bug 120363
         * If we have an exclude pattern that cannot be matched using "starts with"
         * then we cannot fast accept
         */ 
        if (m_excludeTypePattern.isEmpty()) {
            boolean fastAccept = false;//defaults to false if no fast include
            for (int i = 0; i < m_includeStartsWith.size(); i++) {
                fastAccept = fastClassName.startsWith((String)m_includeStartsWith.get(i));
                if (fastAccept) {
                    break;
                }
======= 9edb4b6:"tests/java5/ataspectj/ataspectj/Test$$EnhancerByCGLIB$$12345.java"

    <weaver options="-XlazyTjp -verbose">
        <dump within="com.foo.bar..*" beforeandafter="true"/> 
        <include within="com.foo..*"/>
        <exclude within="com.foo.bar..*CGLIB*"/>
 * Copyright (c) 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
 * Copyright (c) 2005 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
======= 9edb4b6:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"

        
        // before
        File f = new File("_ajdump/_before/com/foo/bar");
        CountingFilenameFilter cff = new CountingFilenameFilter();
        f.listFiles(cff);
        assertEquals("Expected dump file in " + f.getAbsolutePath(),1,cff.getCount());
        // after
        f = new File("_ajdump/com/foo/bar");
        cff = new CountingFilenameFilter();
        f.listFiles(cff);
        assertEquals("Expected dump file in " + f.getAbsolutePath(),1,cff.getCount());
======= 9edb4b6:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"

    
                files="com/foo/bar/Test.java, com/foo/bar/Test$$EnhancerByCGLIB$$12345.java"
        <run class="com.foo.bar.Test$$EnhancerByCGLIB$$12345" ltw="ataspectj/aop-dumpbeforeandafter.xml">
        	<stdout>
        		<line text="Test$$EnhancerByCGLIB$$12345.main()"/>
        		<line text="Test.main()"/>
            </stdout>
        	<stderr>
        		<line text="info weaving 'com.foo.bar.Test'"/>
            </stderr>
        </run>

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 *   Alexandre Vasseur         initial implementation
 *******************************************************************************/
 * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
 */
    public void testMe() {
        assertTrue(true);
    }
    public static void main(String[] args) {
        TestHelper.runAndThrowOnFailure(suite());
    }
    public static Test suite() {
        return new TestSuite(CflowBelowStackTest.class);
    }
    @Aspect
    public static class TestAspect {
        @Pointcut("this(testCase) && execution(void test*())")
        public void inTestClass(TestCase testCase) {
        }
        private Map<String, Map<String, Integer>> coverage;
        @Before("cflowbelow(inTestClass(testCase)) && execution(* *(..))")
        public void beforeMethodExecution(JoinPoint thisJoinPoint, TestCase testCase) {
            String testname = testCase.getClass().getName();
            String methodSignature = thisJoinPoint.getStaticPart().getSignature().toString();
            Map<String, Integer> tests = coverage.get(methodSignature);
            if (tests == null) {
                tests = new HashMap<String, Integer>();
                coverage.put(methodSignature, tests);
            }
            Integer count = tests.get(testname);
            if (count == null) {
                count = 1;
            } else {
                count++;
            }
            tests.put(testname, count);
        }
        @Before("inTestClass(testCase)")
        public void beforeExecutingTestMethod(TestCase testCase) {
            try {
                File file = new File("results.ser");
                if (file.exists()) {
                    ObjectInputStream ois = new ObjectInputStream(new FileInputStream(file));
                    coverage = (Map<String, Map<String, Integer>>) ois.readObject();
                    ois.close();
                } else {
                    coverage = new HashMap<String, Map<String, Integer>>();
                }
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
        @After("inTestClass(testCase)")
        public void afterExecutingTestMethod(TestCase testCase) {
            try {
                File file = new File("results.ser");
                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(file));
                oos.writeObject(coverage);
                oos.close();
            } catch (Exception e) {
                e.printStackTrace();
            }
        }
    }
    <weaver options="-1.5 -showWeaveInfo">
    </weaver>
    <aspects>
        <aspect name="ataspectj.bugs.CflowBelowStackTest.TestAspect"/>
    </aspects>
======= 979124d:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"

    public void testCflowBelowStack() {
        runTest("CflowBelowStack");
    }
    <ajc-test dir="java5/ataspectj" title="CflowBelowStack">
        <compile
            files="ataspectj/bugs/CflowBelowStackTest.java,ataspectj/TestHelper.java"
            options="-1.5 -verbose "/>
        <run class="ataspectj.bugs.CflowBelowStackTest" ltw="ataspectj/bugs/aop-cflowbelowstacktest.xml"/>
    </ajc-test>
======= 979124d:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

        if (isAround) {
            // the closure instantiation has the same mapping as the extracted method from wich it is called
            if (getConcreteAspect()!= null && getConcreteAspect().isAnnotationStyleAspect()) {
                return BcelVar.NONE;
            }
        //System.out.println("vars: " + Arrays.asList(exposedState.vars));
======= 979124d:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 979124d:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 979124d:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 979124d:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    	BcelVar[] adviceVars = munger.getExposedStateAsBcelVars(true);

======= 5f8d2cd:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= 5f8d2cd:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

======= 5f8d2cd:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"


======= b52515f:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= b52515f:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"

======= b52515f:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"

======= b52515f:"weaver/testsrc/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateTest.java"

    // FIXME asc maybe.  The reflection list of methods returned doesn't include <clinit> (the static initializer) ... is that really a problem.
    public void testCompareSubclassDelegates() {
    	
    	boolean barfIfClinitMissing = false;
        world.setBehaveInJava5Way(true);
        
        BcelWorld bcelWorld = new BcelWorld();
        bcelWorld.setBehaveInJava5Way(true);
        UnresolvedType javaUtilHashMap = UnresolvedType.forName("java.util.HashMap");
        ReferenceType rawType =(ReferenceType)bcelWorld.resolve(javaUtilHashMap );
        
        ReferenceType rawReflectType =(ReferenceType)world.resolve(javaUtilHashMap );
        ResolvedMember[] rms1 = rawType.getDelegate().getDeclaredMethods();
        ResolvedMember[] rms2 = rawReflectType.getDelegate().getDeclaredMethods();
        StringBuffer errors = new StringBuffer();
        Set one = new HashSet();
        for (int i = 0; i < rms1.length; i++) {
        Set two = new HashSet();
        for (int i = 0; i < rms2.length; i++) {
        for (int i = 0;i<rms2.length;i++) {
        	if (!one.contains(rms2[i].toString())) {
        		errors.append("Couldn't find "+rms2[i].toString()+" in the bcel set\n");
        	}
        }
        for (int i = 0;i<rms1.length;i++) {
        	if (!two.contains(rms1[i].toString())) {
        		if (!barfIfClinitMissing && rms1[i].getName().equals("<clinit>")) continue;
        		errors.append("Couldn't find "+rms1[i].toString()+" in the reflection set\n");
        	}
        }
        assertTrue("Errors:"+errors.toString(),errors.length()==0);
        
        if (barfIfClinitMissing) {
        	// the numbers must be exact
            assertEquals(rms1.length,rms2.length);        	
        } else {
        	// the numbers can be out by one in favour of bcel
        	assertTrue("Should be one extra (clinit) in BCEL case, but bcel="+rms1.length+" reflect="+rms2.length,rms1.length==rms2.length+1);
        }
    }
    	    
======= b52515f:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"


    Object around() : call( NoClassDefFoundError.new(..)) {
      return proceed();
    } 
    
    public static void main(String []argv) {
    	new ContractChecking();
    }
    public static final boolean enabled = Boolean.getBoolean(ContractChecking.class.getName());
======= 94159f9:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testRangeProblem_pr109614() { runTest("Range problem");}
======= 94159f9:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 94159f9:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 94159f9:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"


======= 6e8bf52:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/AjTypeImpl.java"

======= 6e8bf52:"aspectj5rt/java5-testsrc/org/aspectj/internal/lang/reflect/AjTypeTests.java"


======= 1e1bbb3:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= 1e1bbb3:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        /* First load defaults */
        
        /* Third load user file using -Xlintfile so that -Xlint wins */
======= 1e1bbb3:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

                	warn("Cannot access resource for -Xlintfile:"+weaverOption.lintFile,failure);
       } 
        
       /* Fourth override with -Xlint */
       if (weaverOption.lint != null) {
======= 1e1bbb3:"testing/newsrc/org/aspectj/testing/OutputSpec.java"

======= 1e1bbb3:"testing/newsrc/org/aspectj/testing/RunSpec.java"

======= 1e1bbb3:"testing/newsrc/org/aspectj/testing/RunSpec.java"

======= 1e1bbb3:"testing/newsrc/org/aspectj/testing/RunSpec.java"

======= 1e1bbb3:"testing/newsrc/org/aspectj/testing/XMLBasedAjcTestCase.java"

======= 1e1bbb3:"testing/newsrc/org/aspectj/testing/XMLBasedAjcTestCase.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 *   Matthew Webster         initial implementation
 *******************************************************************************/
======= 1e1bbb3:"testing/newsrc/org/aspectj/testing/XMLBasedAjcTestCase.java"

======= 1e1bbb3:"testing/newsrc/org/aspectj/testing/XMLBasedAjcTestCase.java"

    
    <weaver options="-verbose -showWeaveInfo"/>
======= 1e1bbb3:"testing/newsrc/org/aspectj/testing/XMLBasedAjcTestCase.java"

    
    <weaver options="-verbose -showWeaveInfo -Xlint:warning"/>
======= 1e1bbb3:"testing/newsrc/org/aspectj/testing/XMLBasedAjcTestCase.java"

    
    <weaver options="-verbose -showWeaveInfo -Xlintfile:Xlint-nomatch.properties"/>
======= 1e1bbb3:"testing/newsrc/org/aspectj/testing/XMLBasedAjcTestCase.java"

======= 1e1bbb3:"tests/src/org/aspectj/systemtest/ajc150/ltw/LTWTests.java"

  	public void testXlintfileEmpty () {
  		runTest("Empty Xlint.properties file");
  	}
  	public void testXlintfileMissing () {
  		runTest("Warning with missing Xlint.properties file");
  	}
  	public void testXlintWarningAdviceDidNotMatchSuppressed () {
  		runTest("Warning when advice doesn't match suppressed for LTW");
  	}
  	public void testXlintfile () {
  		runTest("Override suppressing of warning when advice doesn't match using -Xlintfile");
  	}
  	public void testXlintDefault () {
  		runTest("Warning when advice doesn't match using -Xlint:default");
  	}
  	public void testXlintWarning () {
  		runTest("Override suppressing of warning when advice doesn't match using -Xlint:warning");
  	}
  	
      title="Empty Xlint.properties file"
      keywords="xlint, ltw">
        <compile
        	files="Main.java"
        >
        </compile>	
        <run class="Main" ltw="aop-xlintfile.xml" xlintfile="Xlint-empty.properties">
        	<stderr>
        	</stderr>
        </run>
    </ajc-test>
    
      title="Warning with missing Xlint.properties file"
      keywords="xlint, ltw">
        <compile
        	files="Main.java"
        >
        </compile>	
        <run class="Main" ltw="aop-xlintfile.xml">
        	<stderr>
        		<line text="warning Cannot access resource for -Xlintfile:Xlint-empty.properties"/>
        	</stderr>
        </run>
    </ajc-test>
    
      title="Warning when advice doesn't match suppressed for LTW"
      keywords="xlint, ltw">
        <compile
        	files="Main.java"
        >
        </compile>	
        <compile
        	files="Aspect3.aj"
        >
        </compile>	
        <run class="Main" ltw="aop-nomatch.xml">
        	<stderr>
        	</stderr>
        </run>
    </ajc-test>
    
      title="Override suppressing of warning when advice doesn't match using -Xlintfile"
      keywords="xlint, ltw">
        <compile
        	files="Main.java"
        >
        </compile>	
        <compile
        	files="Aspect3.aj"
        >
        </compile>	
        <run class="Main" ltw="aop-nomatchxlintfile.xml" xlintfile="Xlint-nomatch.properties">
        	<stderr>
        		<line text="advice defined in Aspect3 has not been applied [Xlint:adviceDidNotMatch]"/>
        	</stderr>
        </run>
    </ajc-test>
    
      title="Warning when advice doesn't match using -Xlint:default"
      keywords="xlint, ltw">
        <compile
        	files="Main.java"
        >
        </compile>	
        <compile
        	files="Aspect3.aj"
        >
        </compile>	
        <run class="Main" ltw="aop-nomatchxlint.xml">
        	<stderr>
        		<line text="advice defined in Aspect3 has not been applied [Xlint:adviceDidNotMatch]"/>
        	</stderr>
        </run>
    </ajc-test>
    
      title="Override suppressing of warning when advice doesn't match using -Xlint:warning"
      keywords="xlint, ltw">
        <compile
        	files="Main.java"
        >
        </compile>	
        <compile
        	files="Aspect3.aj"
        >
        </compile>	
        <run class="Main" ltw="aop-nomatchxlint.xml">
        	<stderr>
        		<line text="advice defined in Aspect3 has not been applied [Xlint:adviceDidNotMatch]"/>
        	</stderr>
        </run>
    </ajc-test>
    
======= 1e1bbb3:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

        return messageHandler.handleMessage(new Message(message, IMessage.WARNING, th, null));
======= 1e1bbb3:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"


======= d43e74b:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testNoNPEWithOrPointcutAndMoreThanOneArgs_pr118149() {
  }
        <compile files="PR118149.aj"/>
    </ajc-test>
======= d43e74b:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

                    // pr118149
                    // It is possible for vars in myState (which would normally be set
                    // in the call to residueSource.findResidue) to not be set (be null)
                    // in an Or pointcut with if expressions in both branches, and where
                    // one branch is known statically to not match. In this situation we
                    // simply return Test.
                        if (v == null) continue;  // pr118149

======= 6d94d09:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeFieldBinding.java"

======= 6d94d09:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeFieldBinding.java"

    private static interface Marker {}   
    private class Foo implements Marker {
            bar = null; // allowed
            listener = null; // should also be allowed
            this.listener = null; // so should this
            ((Marker)this).listener = null; // and this
        }
    }
    public static void main(String []argv) {
      pr118698.aspectOf().x();
    }
    
    public void x() {
    	new Foo();
    }
    private Object Marker.listener;
    private Object bar;
======= 6d94d09:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  //public void testIllegalInitialization_pr118326_1() { runTest("illegal initialization - 1");}
  //public void testIllegalInitialization_pr118326_2() { runTest("illegal initialization - 2");}
  public void testAccesstoPrivateITDInNested_pr118698() { runTest("access to private ITD from nested type");}
    <ajc-test dir="bugs150" title="access to private ITD from nested type">
        <compile files="pr118698.aj"/>
        <run class="pr118698"/>
    </ajc-test>

       pointcut callPointCut(): call(public * blah.MyClass+.*(..));
       Object around() : callPointCut() {
               System.out.println("start of around");
               Object result = proceed();
               System.out.println("end of around");
               return result;
       }
       public Integer[] getRandomInt(String[][] param)
       {
               for (int i = 0; i < param.length; i++)
               {
                       System.out.print("[" + i + "] = [");
                       for (int j = 0; j < param[i].length; j++)
                       {
                               System.out.print(param[i][j]);
                               if (j != param[i].length-1)
                                       System.out.print(',');
                       }
                       System.out.println(']');
               }
               return new Integer[] { new Integer(new Random().nextInt())};
       }
       /**
        * @param args
        */
       public static void main(String[] args)
       {
               MyClass mc = new MyClass();
               mc.getRandomInt(new String[][]{{ "a", "b",
       }
======= a75b7fa:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testAroundAdviceArrayAdviceSigs_pr118781()     { runTest("verify error with around advice array sigs");}
    <ajc-test dir="bugs150/pr118781" pr="118781" title="verify error with around advice array sigs">
     <compile files="MyMain.java,MyAspect.java,MyClass.java" options="-XnoInline"/>
     <run class="blah.MyMain"/>
    </ajc-test>
    
======= a75b7fa:"weaver/src/org/aspectj/weaver/World.java"

        	//String brackets = signature.substring(0,signature.lastIndexOf("[")+1);
            ret = new ResolvedType.Array(signature, "["+componentType.getErasureSignature(),
======= a75b7fa:"weaver/src/org/aspectj/weaver/World.java"


======= 551b9ca:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

        if (!getProceedOnError() && global.getProceedOnError()) {
        	setProceedOnError(true);
        }
       	setTargetAspectjRuntimeLevel(global.getTargetAspectjRuntimeLevel());
======= 551b9ca:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

  public static void main(String []argv) {
    new Aspect().m();
  }
  public void m() {
  }
  public int Aspect.x = 5;
  public void Aspect.foo() {
  }
  before():execution(* m()) {
  }
  before(): staticinitialization(*) {
  }
======= 551b9ca:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= 551b9ca:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= 551b9ca:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

        public void foo(int number, String name)
======= 551b9ca:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= 551b9ca:"tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"

======= 551b9ca:"tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"

======= 551b9ca:"tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"

======= 551b9ca:"tests/src/org/aspectj/systemtest/incremental/tools/AjdeInteractionTestbed.java"

======= 551b9ca:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


======= 2c81907:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testLintForAdviceSorting_pr111667() { runTest("lint for advice sorting");}
     <compile files="A.java,X.java,Y.java" options="-1.5 -Xlint:warning">
       <message kind="warning" line="9" text="at this shadow method-execution(void A.m1()) no precedence is specified between advice applying from aspect X and aspect Y [Xlint:unorderedAdviceAtShadow]"/>
======= 2c81907:"weaver/src/org/aspectj/weaver/Lint.java"

======= 2c81907:"weaver/src/org/aspectj/weaver/Shadow.java"

======= 2c81907:"weaver/src/org/aspectj/weaver/Shadow.java"

    // not quite optimal... but the xlint is ignore by default
======= 2c81907:"weaver/src/org/aspectj/weaver/World.java"

======= 2c81907:"weaver/src/org/aspectj/weaver/World.java"


======= d1a295c:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"


======= 508dbcb:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testDoublyParameterizedAbstractType() {
  }
  
    </ajc-test>
    <ajc-test dir="bugs150" pr="112880" title="double parameter generic abstract type">
    	  <compile files="Pr112880.aj" options="-1.5">
    	  </compile>
    	  <run class="Pr112880">
    	  	<stdout>
    	  		<line text="method returning C1 or C2"/>
    	  		<line text="method returning C1 or C2"/>
    	  	</stdout>
    	  </run>
    </ajc-test>
======= 508dbcb:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"


======= 6eb77c5:"tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java"

======= 6eb77c5:"weaver/src/org/aspectj/weaver/Lint.java"

======= 6eb77c5:"weaver/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= 6eb77c5:"weaver/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= 6eb77c5:"weaver/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= 6eb77c5:"weaver/src/org/aspectj/weaver/MissingResolvedTypeWithKnownSignature.java"

======= 6eb77c5:"weaver/src/org/aspectj/weaver/World.java"

            //IMessage msg = null;
            getLint().cantFindType.signal(WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE,ty.getName()),isl);
            //if (isl!=null) {
              //msg = MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE,ty.getName()),isl);
            //} else {
              //msg = MessageUtil.error(WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE,ty.getName())); 
            //}
            //messageHandler.handleMessage(msg);
======= 6eb77c5:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

            		world.getLint().cantFindType.signal(
            				WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_EXCEPTION_TYPE,excs[i].getName()),
            				getSourceLocation()
            				);
======= 6eb77c5:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        	world.getLint().cantFindType.signal(
        			new String[] {WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE,declaringType.getClassName())},
        			getSourceLocation(),
        			new ISourceLocation[]{ munger.getSourceLocation()}
        			);
======= 6eb77c5:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

                		world.getLint().cantFindType.signal(
                				new String[] {WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE_DURING_AROUND_WEAVE_PREINIT,bcelTX.getClassName())},
                				getSourceLocation(),
                				new ISourceLocation[]{ munger.getSourceLocation()}
                				);
======= 6eb77c5:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= 6eb77c5:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= 6eb77c5:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

======= 6eb77c5:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

======= 6eb77c5:"weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java"

======= 6eb77c5:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"


======= 76d7e83:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

            weaverOption.messageHandler.dontIgnore(IMessage.INFO);
======= 76d7e83:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 *   Alexandre Vasseur         initial implementation
 *******************************************************************************/
 * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
 */
    void target() {};
    public static void main(String args[]) throws Throwable {
        new Main().target();
    }
======= 76d7e83:"tests/java5/ataspectj/ataspectj/ltwlog/MessageHolder.java"

    	System.out.println("MessageHolder.MessageHolder()");
======= 76d7e83:"tests/java5/ataspectj/ataspectj/ltwlog/MessageHolder.java"

    <weaver options="-XmessageHandlerClass:ataspectj.ltwlog.MessageHolder -showWeaveInfo -verbose"/>
    <aspects>
        <aspect name="ataspectj.ltwlog.Aspect1"/>
    </aspects>
    <weaver options="-verbose"/>
    <weaver options="-showWeaveInfo -verbose"/>
    <weaver options="-showWeaveInfo"/>
======= 76d7e83:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"

    public void testLTWLogSilent() {
        runTest("LTW Log silent");
    }
    public void testLTWLogVerbose() {
        runTest("LTW Log verbose");
    }
    public void testLTWLogVerboseAndShow() {
        runTest("LTW Log verbose and showWeaveInfo");
    }
    public void testLTWLogMessageHandlerClass() {
        runTest("LTW Log messageHandlerClass");
    <ajc-test dir="java5/ataspectj" title="LTW Log silent">
    	<compile
    		files="ataspectj/ltwlog/Main.java"
    		options="-1.5"
    	/>
    	<compile
    		files="ataspectj/ltwlog/Aspect1.java"
    		options="-1.5 -XnoWeave"
    	>
        </compile>	
        <run class="ataspectj.ltwlog.Main" ltw="ataspectj/ltwlog/aop-silent.xml">
        	<stdout>
 				<line text="execution(Main.target())"/>
            </stdout>
        	<stderr>
            </stderr>
        </run>
    </ajc-test>
    <ajc-test dir="java5/ataspectj" title="LTW Log verbose">
    	<compile
    		files="ataspectj/ltwlog/Main.java"
    		options="-1.5"
    	/>
    	<compile
    		files="ataspectj/ltwlog/Aspect1.java"
    		options="-1.5 -XnoWeave"
    	>
        </compile>	
        <run class="ataspectj.ltwlog.Main" ltw="ataspectj/ltwlog/aop-verbose.xml">
        	<stdout>
 				<line text="execution(Main.target())"/>
            </stdout>
        	<stderr>
            </stderr>
        </run>
    </ajc-test>
    <ajc-test dir="java5/ataspectj" title="LTW Log verbose and showWeaveInfo">
    	<compile
    		files="ataspectj/ltwlog/Main.java"
    		options="-1.5"
    	/>
    	<compile
    		files="ataspectj/ltwlog/Aspect1.java"
    		options="-1.5 -XnoWeave"
    	>
        </compile>	
        <run class="ataspectj.ltwlog.Main" ltw="ataspectj/ltwlog/aop-verboseandshow.xml">
        	<stdout>
 				<line text="execution(Main.target())"/>
            </stdout>
        	<stderr>
            </stderr>
        </run>
    </ajc-test>
    <ajc-test dir="java5/ataspectj" title="LTW Log messageHandlerClass">
    	<compile
    		files="ataspectj/ltwlog/Main.java, ataspectj/ltwlog/MessageHolder.java"
    		options="-1.5"
    	/>
    	<compile
    		files="ataspectj/ltwlog/Aspect1.java"
    		options="-1.5 -XnoWeave"
    	>
        </compile>	
        <run class="ataspectj.ltwlog.Main" ltw="ataspectj/ltwlog/aop-messagehandler.xml">
        	<stdout>
 				<line text="execution(Main.target())"/>
            </stdout>
        	<stderr>
            </stderr>
        </run>

        public static void main(String[] args) {
                C.go();
        }
        static class C {
                static void go() {}
        }
        pointcut going() :call(void Target.go()) ;
        before() : going() {
                System.out.println("AA.going()");
        }
        declare warning : going() : "going()"; // works fine
        before() : going() { // advice not applied
                System.out.println("A.going()");
        }
======= 86880f7:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testParameterizedPointcutAndAdvice() {
  }
  
    <ajc-test dir="bugs150" pr="114495" title="parameterized pointcut and advice">
    		<compile files="Pr114495.aj" options="-1.5">
    			<message kind="warning" line="3" text="going()"/>
    		</compile>
    		<run class="Pr114495">
    			<stdout>
    				<line text="A.going()"/>
    				<line text="AA.going()"/>
    			</stdout>
    		</run>
    </ajc-test>acj
    
    
======= 86880f7:"weaver/src/org/aspectj/weaver/ReferenceType.java"

======= 86880f7:"weaver/src/org/aspectj/weaver/ResolvedType.java"

======= 86880f7:"weaver/src/org/aspectj/weaver/ResolvedType.java"

======= 86880f7:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"


======= a4caeb9:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testPerTargetAndNegation() {
  }
  
    <ajc-test dir="bugs150" pr="114054" title="pertarget and negated pointcut">
     <compile files="Pr114054.aj" options=""/>
     <run class="Pr114054"/>
    </ajc-test>
    
======= a4caeb9:"weaver/src/org/aspectj/weaver/patterns/PerThisOrTargetPointcutVisitor.java"

    	    // AMC - the only safe thing to return here is maybe...
    		// see for example pr114054
    	return MAYBE;

======= 81e6b60:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/DeclareSoftImpl.java"

======= 81e6b60:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/StringToType.java"

======= 81e6b60:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/StringToType.java"

        <compile files="DeclareParentsTest.aj" options="-1.5, -outxml">
        <run class="DeclareParentsTest" ltw=""/>
        <compile files="DeclareParentsTestAdvanced.aj" options="-1.5, -outxml">
        <run class="a.b.c.DeclareParentsTestAdvanced" ltw=""/>
        <compile files="ITDTest.aj" options="-1.5, -outxml">
        <run class="a.b.c.ITDTest" ltw=""/>

   public String getLastUpdatedBy();
   public void   setLastUpdatedBy(String un);
   private String lastUpdatedBy;
   public String getLastUpdatedBy() {
       return lastUpdatedBy;
   }
   public void setLastUpdatedBy(String un) {
       lastUpdatedBy = un;
   }
  public final static Mood HAPPY=new Mood();
   // this interface can be outside of the aspect
    interface Moody {
     Mood getMood(int i);
   };
   // this implementation can be outside of the aspect
    class MoodyImpl implements Moody {
      private Mood mood = Mood.HAPPY;
      public Mood getMood(int i) {
        return mood;
      }
   }
   // here is the actual ITD syntax when using @AspectJ
   // public static is mandatory
   // the field type must be the introduced interface. It can't be a class.
   @DeclareParents("C")
   public static Moody introduced = new MoodyImpl();
  public static void main(String []argv) {
    ((Moody)new C()).getMood(7);
  }
  
    public static void main(String[] args) {
        Audit a = (Audit)new Test();
        a.setLastUpdatedBy("username");
        System.out.println("Username ="+a.getLastUpdatedBy());
    }
  @DeclareParents("Test")
  public static Audit introduced = new AuditImpl();
======= 11ab99f:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testAtDeclareParents_pr117681() { runTest("at declare parents");}
    <ajc-test dir="bugs150/pr117681" pr="117681" title="at declare parents">
     <compile files="Test.java,TestAspect.java,Audit.java,AuditImpl.java" options="-1.5"/>
     <run class="Test"/>
    </ajc-test>
    
======= 11ab99f:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

    		if (!introduced.isStatic()) { // skip 'this'
    		  //body.append(InstructionFactory.createThis());
    		  pos++;
    		}

    
    public static void main(String[] args) {
    	try {
    		aspectOf().hook();
    	}  catch (ExceptionInInitializerError ex) {
    		Throwable cause = ex.getCause();
    		if (! (cause instanceof org.aspectj.lang.NoAspectBoundException)) {
    			throw new RuntimeException("Unexpected exception: " + cause);
    		}
    	}
    }
    
    void hook() {}
    private pointcut managedBeanConstruction(ManagedBean bean) : 
        execution(ManagedBean+.new(..)) && this(bean); 
    
            System.out.println("I just constructed " + bean);
    before() : execution(* hook()) {        
    before() : staticinitialization(ManagedBean) {
        ManagedSubBean.aspectOf();
    }
    before() : !within(Tracer) {
======= 8b294d9:"tests/new/AfterReturningParam.java"

 //       Tester.checkAndClearEvents(new String[] { "constr exec as Object null" });
 //        see pr 103157 for reason why this no longer matches
======= 8b294d9:"tests/new/AfterReturningParam.java"

    	                                                                       // in 1.5 does not match - no return value for this jp
======= 8b294d9:"tests/new/ConstructorExecInit.java"

    after () returning : initialization(new(..)) && !this(A) { 
======= 8b294d9:"tests/new/OddConstructors.java"

     after() returning: j() {
======= 8b294d9:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testReturningObjectBinding() {
  }
  
    		<run class="Pr113368">
    		</run>
======= 8b294d9:"weaver/src/org/aspectj/weaver/Advice.java"

    			boolean matches = 
    				(resolvedExtraParameterType.isConvertableFrom(shadowReturnType) &&
    				 shadow.getKind().hasReturnValue());
======= 8b294d9:"weaver/src/org/aspectj/weaver/Shadow.java"


======= a5ac5af:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= a5ac5af:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= a5ac5af:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= a5ac5af:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        List definitions = parseDefinitions(loader);
        if (!enabled) {
        	return;
        }
        
======= a5ac5af:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= a5ac5af:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        registerDefinitions(weaver, loader, definitions);
        messageHandler = bcelWorld.getMessageHandler();
        //bcelWorld.setResolutionLoader(loader.getParent());//(ClassLoader)null);//
        
        // after adding aspects
        weaver.prepareForWeave();
======= a5ac5af:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

    private List parseDefinitions(final ClassLoader loader) {
        List definitions = new ArrayList();
    	try {
            info("register classloader " + getClassLoaderName(loader));
                    info("using (-Daj5.def) " + file);
======= a5ac5af:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

    			    info("using " + xml.getFile());
    		if (definitions.isEmpty()) {
    		}
        } catch (Exception e) {
            enabled = false;// will allow very fast skip in shouldWeave()
            warn("parse definitions failed",e);
        }
    }
        
    private void registerDefinitions(final BcelWeaver weaver, final ClassLoader loader, List definitions) {
    	try {
            registerOptions(weaver, loader, definitions);
            registerAspectExclude(weaver, loader, definitions);
            registerAspectInclude(weaver, loader, definitions);
            registerAspects(weaver, loader, definitions);
            registerIncludeExclude(weaver, loader, definitions);
            registerDump(weaver, loader, definitions);
======= a5ac5af:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= a5ac5af:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= a5ac5af:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"


======= 554e733:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 554e733:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 554e733:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 554e733:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"

======= 554e733:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"

    declare soft: IOException: within(Pr103051) && adviceexecution();
    before() : execution(* main(..)) {
        throw new IOException("test");
    }
    public static void main(String args[]) {
    }
======= 554e733:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  
  public void testDeclareSoftWithAdviceExecution() {
  }

======= 735d94f:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/AjTypeImpl.java"

======= 735d94f:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/InterTypeConstructorDeclarationImpl.java"

======= 735d94f:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/InterTypeDeclarationImpl.java"

======= 735d94f:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/InterTypeFieldDeclarationImpl.java"

======= 735d94f:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/InterTypeMethodDeclarationImpl.java"

======= 735d94f:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/InterTypeMethodDeclarationImpl.java"

    
     * Connections give the appropriate call rate
     */
    public abstract long Connection.callRate();
    public long LongDistance.callRate() { return 1; }
    public long Local.callRate() { return 2; }
    /**
     * Customers have a bill paying aspect with state
     */
    public long Customer.totalCharge = 0;
    public void Customer.addCharge(long charge){
        totalCharge += charge;
    }
======= 735d94f:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/InterTypeMethodDeclarationImpl.java"

======= 735d94f:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  
  public void testReflectionOfAbstractITDs() {
  }

======= 9ed75a1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceLocation.java"

            } else if (0 < lineNumber && lineNumber == result.lineSeparatorPositions.length) {
            	column = 0;
======= 9ed75a1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceLocation.java"

  declare @type: Simple : @I;
======= 9ed75a1:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

 // public void testSelfBoundGenerics_pr117296() { runTest("self bounding generic types");}
======= 9ed75a1:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  
  public void testDeclareAtTypeInStructureModel_pr115607() {
      AsmManager.setReporting("c:/debug.txt",true,true,true,true);
  	  IHierarchy top = AsmManager.getDefault().getHierarchy();
  	  IProgramElement pe = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.DECLARE_ANNOTATION_AT_TYPE,"declare @type: Simple : @I");  	 	 
  	  assertNotNull("Couldn't find 'declare @type: Simple : @I' element in the tree",pe);
  	  List l = AsmManager.getDefault().getRelationshipMap().get(pe);	
  }
  
    
    <ajc-test dir="bugs150" pr="117296" title="self bounding generic types">
     <compile files="PropertySupport.java" options="-1.5"/>
    </ajc-test>
        <compile files="pr115607.java" options="-1.5,-emacssym">
        </compile>
    </ajc-test>

======= 522911e:"tests/java5/ataspectj/annotationGen/RuntimePointcuts.java"

======= 522911e:"tests/java5/ataspectj/annotationGen/RuntimePointcuts.java"

======= 522911e:"tests/java5/ataspectj/annotationGen/RuntimePointcuts.java"

======= 522911e:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

        <run class="RuntimePointcuts" classpath=".;../lib/bcel/bcel.jar" ltw=""/>
======= 522911e:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= 522911e:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= 522911e:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

            boolean couldBeAtAspectJStyle = false;
                    couldBeAtAspectJStyle = true;
            
            if (!couldBeAtAspectJStyle) return false;
            
            // ok, so it has the annotation, but it could have been put
            // on a code style aspect by the annotation visitor
            Attribute[] attributes = jc.getAttributes();
            for (int i = 0; i < attributes.length; i++) {
            	if (attributes[i].getName().equals(Aspect.AttributeName)) {
            		return false;
            	}
            }
            return true;
======= 522911e:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

 * Copyright (c) 2004 IBM Corporation.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * ******************************************************************/
======= 522911e:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author adrian
 * 
 * For use in LT weaving
 * 
 * Backed by both a BcelWorld and a ReflectionWorld
 * 
 * Needs a callback when a woven class is defined
 * This is the trigger for us to ditch the class from
 * Bcel and cache it in the reflective world instead.
 *
 * Problems with classes that are loaded by delegates
 * of our classloader
 * 
 * Create by passing in a classloader, message handler
 */
======= 522911e:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author adrian
 *
 */
======= 522911e:"weaver/src/org/aspectj/weaver/reflect/AnnotationFinder.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegate.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedReferenceTypeDelegateFactory.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedResolvedMemberImpl.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionBasedResolvedMemberImpl.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionShadow.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionVar.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= 522911e:"weaver/src/org/aspectj/weaver/reflect/ReflectionWorld.java"

======= 522911e:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

======= 522911e:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

======= 522911e:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

======= 522911e:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

======= 522911e:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

        setClassLoader(PointcutParser.class.getClassLoader());
======= 522911e:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

        setClassLoader(PointcutParser.class.getClassLoader());
    }
    
    /**
     * Create a pointcut parser that can parse pointcut expressions built
     * from a user-defined subset of AspectJ's supported pointcut primitives. 
     * The following restrictions apply:
     * <ul>
     * <li>The <code>if, cflow, and cflowbelow</code> pointcut designators are not supported
     * <li>Pointcut expressions must be self-contained :- they cannot contain references
     * to other named pointcuts
     * <li>The pointcut expression must be anonymous with no formals allowed.
     * </ul>
     * @param supportedPointcutKinds a set of PointcutPrimitives this parser
     * should support
     * @param classLoader the class loader to use for resolving types
     * @throws UnsupportedOperationException if the set contains if, cflow, or
     * cflow below
     */
    public PointcutParser(Set/*<PointcutPrimitives>*/ supportedPointcutKinds,ClassLoader cl) {
    	this(supportedPointcutKinds);
    	setClassLoader(cl);
    }
    /**
     * Set the classloader that this parser should use for
     * type resolution.
     * @param aLoader
     */
    public void setClassLoader(ClassLoader aLoader) {
    	this.classLoader = aLoader;
    	world = new ReflectionWorld(this.classLoader);
    }
    /**
     * Set the lint properties for this parser from the
     * given resource on the classpath. 
     * @param resourcePath path to a file containing aspectj
     * lint properties
     */
    public void setLintProperties(String resourcePath)throws IOException {
    	URL url = this.classLoader.getResource(resourcePath);
    	InputStream is = url.openStream();
    	Properties p = new Properties();
    }
    
    /**
     * Set the lint properties for this parser from the 
     * given properties set.
     * @param properties
     */
    public void setLintProperties(Properties properties) {
    	getWorld().getLint().setFromProperties(properties);
======= 522911e:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

            	 declaringTypeForResolution = getWorld().resolve(inScope.getName());
            	 declaringTypeForResolution = ResolvedType.OBJECT.resolve(getWorld());
======= 522911e:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

             pcExpr = new PointcutExpressionImpl(pc,expression,formalParameters,getWorld());
======= 522911e:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    /**
     * Parse the given aspectj type pattern, and return a 
     * matcher that can be used to match types using it.
     * @param typePattern an aspectj type pattern
     * @return a type pattern matcher that matches using the given
     * pattern 
     * @throws IllegalArgumentException if the type pattern cannot
     * be successfully parsed.
     */
    public TypePatternMatcher parseTypePattern(String typePattern) 
    throws IllegalArgumentException {
        try {
        	TypePattern tp = new PatternParser(typePattern).parseTypePattern();
        	tp.resolve(world);
        	return new TypePatternMatcherImpl(tp,world);
        } catch (ParserException pEx) {
            throw new IllegalArgumentException(buildUserMessageFromParserException(typePattern,pEx));
        } catch (ReflectionWorld.ReflectionWorldException rwEx) {
       	 	throw new IllegalArgumentException(rwEx.getMessage());
        }
    }
    
    private World getWorld() {
    	return world;
    }
    
======= 522911e:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    	IMessageHandler current = getWorld().getMessageHandler();
    	getWorld().setMessageHandler(aHandler);
======= 522911e:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    		return new SimpleScope(getWorld(),formalBindings);
    		ResolvedType inType = getWorld().resolve(inScope.getName());
======= 522911e:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

 * Copyright (c) 2004 IBM Corporation.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * ******************************************************************/
 * A compiled AspectJ type pattern that can be used to
 * match against types at runtime.
 */
======= 522911e:"weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java"

======= 522911e:"weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java"

======= 522911e:"weaver/testsrc/org/aspectj/weaver/tools/ToolsTests.java"

======= 522911e:"weaver/testsrc/org/aspectj/weaver/tools/ToolsTests.java"

 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
======= 522911e:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"

======= 522911e:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"

======= 522911e:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"

======= 522911e:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15AnnotationFinder.java"

======= 522911e:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"

======= 522911e:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"

======= 522911e:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"

======= 522911e:"weaver5/java5-src/org/aspectj/weaver/reflect/Java15ReflectionBasedReferenceTypeDelegate.java"


======= 557f5b4:"weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"


======= dd9a9b2:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"


      pointcut TestToArray(Test mt) :
                target(mt) &&
                !within(TestAspect);
    Object[] around(Test mt, Object[] objs) :
            TestToArray(mt) &&
            args(objs) &&
            execution(Object[] Test.getObjs(Object[])) {
        objs = proceed(mt, objs);
        System.out.println("GO Aspects!");
        return objs;
    }
======= c760895:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  /*
   * Load-time weaving bugs
   */
  public void testNPEinWeavingAdaptor_pr116626() { runTest("NPE in WeavingAdaptor");}
   
   <ajc-test dir="bugs150/pr116626" title="NPE in WeavingAdaptor">
     <compile files="com/foo/bar/Test.java, TestAspect.aj" options="-1.5"/>
     <run class="com.foo.bar.Test" ltw="aop.xml"
     >
     </run>
   </ajc-test>
======= c760895:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= c760895:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

        	if (wovenClass != null) return wovenClass.getBytes();
        	else return unwovenClass.getBytes();

======= fabf159:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

======= fabf159:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

======= fabf159:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"

    
            XMLReader xmlReader = getXMLReader();
======= fabf159:"loadtime/src/org/aspectj/weaver/loadtime/definition/DocumentParser.java"


======= 676aa08:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"


======= 4b8bed7:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testNoStackOverflowWithCircularPCDInGenericAspect() {
  }
  
  public void testNoStackOverflowWithCircularPCDInGenericAspect2() {
  }
    <ajc-test dir="bugs150" title="no StackOverflowError with circular pcd in generic aspect">
        <compile files="pr115235.aj" options="-1.5">
        	<message kind="warning" line="3" text="advice defined in GenericAbstractAspect has not been applied [Xlint:adviceDidNotMatch]"/>
        	<message kind="error" text="circular pointcut declaration involving: pc()"/>
        	<message kind="error" line="20" text="circular pointcut declaration involving: pc2()"/>
    </ajc-test> 
    <ajc-test dir="bugs150" title="no StackOverflowError with circular pcd in generic aspect - 2">
        <compile files="pr115235b.aj" options="-1.5">
        </compile>
    </ajc-test>
======= 4b8bed7:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= 4b8bed7:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"


======= d7d5947:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"


  private ThreadLocal counts = new ThreadLocal();
  public pointcut testMethodExecution() : 
    execution(void Test+.test*());
  public pointcut assertCall() : 
    cflow(testMethodExecution()) && call(void Assert+.assert*(..));
  void around() : testMethodExecution() {
    counts.set( new Counter());
  
    proceed();
  
    if(((Counter) counts.get()).getCount()==0) {
      throw new RuntimeException("No assertions had been called");
    }
  }
  before() : assertCall() {
    ((Counter) counts.get()).inc();
  }
  
======= 7a1002a:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testAssertWithinPointcutExpression() {
  }
  
    <ajc-test dir="bugs150" pr="112756" title="pointcut expression containing 'assert'">
     <compile files="Pr112756.aj" options="-warn:assertIdentifier -Xdev:Pinpoint"/>
    </ajc-test>
    

======= 1f51499:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

                    	ret = "no manifest found in " + p.getAbsolutePath() + 
                    	continue;
======= 1f51499:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"


    @SampleAnnotation 
    // ITD on the interface
    @SampleAnnotation 
    // ITD on the interface
======= d9757d7:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testITDCtor_pr112783()                 { runTest("Problem with constructor ITDs");}
  public void testAnnotatedITDFs_pr114005_1()        { runTest("Annotated ITDFs - 1");}
  public void testAnnotatedITDFs_pr114005_2()        { runTest("Annotated ITDFs - 2");}
    <ajc-test dir="bugs150/pr114005" title="Annotated ITDFs - 1">
      <compile files="Declaration1.java" options="-1.5"/>
      <run class="Declaration1">
        <stdout>
          <line text="public java.lang.String Test.firstProperty has annotation:true"/>
          <line text="public java.lang.String Test.ajc$interField$Declaration1$TestInterface$secondProperty has annotation:true"/>
        </stdout>
      </run>
    </ajc-test>
    
    <ajc-test dir="bugs150/pr114005" title="Annotated ITDFs - 2">
      <compile files="Declaration2.java" options="-1.5"/>
      <run class="Declaration2">
        <stdout>
          <line text="public java.lang.String Test.firstProperty has annotation:true"/>
          <line text="public java.lang.String Test.ajc$interField$Declaration2$TestInterface$secondProperty has annotation:true"/>
        </stdout>
      </run>
    </ajc-test>
======= d9757d7:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"


======= 21cf37d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.java"

======= 21cf37d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.java"

======= 21cf37d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.java"

  interface C { }
  public void C.hello() {
        return super.method();
  
  class C2 { }
  public void C2.hello() {
======= 21cf37d:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testCantCallSuperMethods_pr90143() { runTest("cant call super methods");}

 * Created on Oct 13, 2005 
 * \u00462004-2005 Business Process Engineering S.r.L.  All rights reserved
 */
======= a7e13f1:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testBrokenDecp_pr112476()       { runTest("binary weaving decp broken");}
    <ajc-test dir="bugs150/pr112476/case1" title="binary weaving decp broken">
        <compile files="lib/A.java,lib/B.java,lib/C.java" outjar="library.jar" options="-1.5"/>
        <!-- library.jar on the aspectpath here just for resolution when compiling SuperC -->
        <compile aspectpath="library.jar" files="weaved/SuperC.java" outjar="newsuper.jar" options="-1.5"/>
        <compile inpath="library.jar;newsuper.jar" files="weaved/DeclareAspect.aj" options="-1.5 -showWeaveInfo">
          <message kind="weave" text="Setting superclass of type 'lib.C' (C.java) to 'weaved.SuperC' (DeclareAspect.aj)"/>
        </compile>
        <run class="weaved.SuperC">
          <stdout>
             <line text="Is [class lib.C] subcass of [class weaved.SuperC]? true"/>
          </stdout>
        </run>
    </ajc-test>
    
    <ajc-test dir="bugs150" title="ITDC with no explicit cons call">
    
======= a7e13f1:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

        					int idx = cpg.addMethodref(newParent.getName(), invokeSpecial.getMethodName(cpg), invokeSpecial.getSignature(cpg));

======= ade32bc:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= ade32bc:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= ade32bc:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= ade32bc:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

  Class<? extends pr114744> pr114744.cl;
  void foo() throws Exception {
    pr114744 ci = cl.newInstance();
  }
======= ade32bc:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testCaptureBinding_pr114744()   { runTest("capturebinding wildcard problem");}
    <ajc-test dir="bugs150" title="capturebinding wildcard problem">
      <compile files="pr114744.aj" options="-1.5">
      </compile>
    </ajc-test>
    

======= 62d16d5:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

                    	namespace=new StringBuffer(aspectClassName);
                    	namespace = namespace.append(";"+aspectClassName);
======= 62d16d5:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

                    	namespace=new StringBuffer(concreteAspect.name);
                    	namespace = namespace.append(";"+concreteAspect.name);
======= 62d16d5:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"


======= 794f9b5:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

     * aspect must be public
======= 794f9b5:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ValidateAtAspectJAnnotationsVisitor.java"

        //FIXME AV - do we really want that
        TypeReference parentRef = typeDecl.superclass;
    <target name="ltw.AppContainer">
        <!-- mkdir the 2 sub app root folder -->
        <mkdir dir="${aj.sandbox}/META-INF"/>
        <mkdir dir="${aj.sandbox}/app_1"/>
        <mkdir dir="${aj.sandbox}/app_1/META-INF"/>
        <!-- install sub app -->
        <copy todir="${aj.sandbox}/app_1">
            <fileset dir="${aj.sandbox}" includes="ataspectj/hierarchy/app/*"/>
        </copy>
        <copy todir="${aj.sandbox}/app_2">
            <fileset dir="${aj.sandbox}" includes="ataspectj/hierarchy/app/*"/>
        </copy>
        <delete dir="${aj.sandbox}/ataspectj/hierarchy/app"/>
        <!-- install the aop.xml DD -->
        <copy file="${aj.root}/tests/java5/ataspectj/ataspectj/hierarchy/aop-global.xml"
              tofile="${aj.sandbox}/META-INF/aop.xml"/>
        <!-- only app1 gets local aspect -->
        <copy file="${aj.root}/tests/java5/ataspectj/ataspectj/hierarchy/aop-local.xml"
              tofile="${aj.sandbox}/app_1/META-INF/aop.xml"/>
        <!-- run -->
        <java fork="yes" classname="ataspectj.hierarchy.AppContainerTest" failonerror="yes">
            <classpath refid="aj.path"/>
            <jvmarg value="-javaagent:${aj.root}/lib/test/loadtime5.jar"/>
            <jvmarg value="-Daj.weaving.verbose=true"/>
        </java>
    </target>
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 *   Alexandre Vasseur         initial implementation
 *******************************************************************************/
 * Assumes ataspect.hierarchy.app DOES NOT EXISTS in system classpath
 * but exists in 2 folder located at "/app_1" and /app_2
 * ie "/app_1/ataspect.hierarchy.app.*.class"
 *
 * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
 */
    public static interface IApp {
        String invoke(String input);
    }
    IApp app1;
    IApp app2;
    public void setUp() throws Exception {
        try {
            Class k = Class.forName("ataspectj.hierarchy.app.SubApp");
            throw new Exception("config error, app must not be in system classpath");
        } catch (ClassNotFoundException e) {
            ;//fine
        }
        //build path and app
        URL path = AppContainerTest.class.getProtectionDomain().getCodeSource().getLocation();
        String path1 = path.toString() + "app_1/";
        String path2 = path.toString() + "app_2/";
        URLClassLoader app1CL = new URLClassLoader(
                new URL[]{new URL(path1)},
                AppContainerTest.class.getClassLoader()
        );
        URLClassLoader app2CL = new URLClassLoader(
                new URL[]{new URL(path2)},
                AppContainerTest.class.getClassLoader()
        );
        app1 = (IApp)Class.forName("ataspectj.hierarchy.app.SubApp", false, app1CL).newInstance();
        app2 = (IApp)Class.forName("ataspectj.hierarchy.app.SubApp", false, app2CL).newInstance();
    }
    public void testApp1LocalAspect() {
        String res = app1.invoke("app1");
        assertEquals("globalAspect[localAspect[app1]]", res);
    }
    public void testApp2NoLocalAspect() {
        String res = app2.invoke("app2");
        assertEquals("globalAspect[app2]", res);
    }
    @Aspect
    public static class BaseAspect {
        @Around("execution(* ataspectj.hierarchy.app.SubApp.invoke(..))")//TODO IApp
        public Object around(ProceedingJoinPoint jp) throws Throwable {
            String out = (String) jp.proceed();
            return "globalAspect[" + out + "]";
        }
    }
    public static void main(String[] args) {
        TestHelper.runAndThrowOnFailure(suite());
    }
    public static Test suite() {
        return new TestSuite(AppContainerTest.class);
    }
    <weaver options="-1.5 -XmessageHandlerClass:ataspectj.TestHelper -Xlint:ignore"/>
    <aspects>
        <aspect name="ataspectj.hierarchy.AppContainerTest.BaseAspect"/>
    </aspects>
    <weaver options="-1.5 -XmessageHandlerClass:ataspectj.TestHelper -Xlint:ignore"/>
    <aspects>
        <aspect name="ataspectj.hierarchy.app.SubApp.SubAspect"/>
    </aspects>
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 *   Alexandre Vasseur         initial implementation
 *******************************************************************************/
 * Leaves in child classloader in two forms, like 2 webapp
 *
 * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
 */
    // simple echo. May be advised or not depending on the aspect deployed there
    public String invoke(String input) {
        return input;
    }
    // this child aspect will be LTW for only one variation of the SubApp
    @Aspect
    public static class SubAspect {
        @Around("execution(* ataspectj.hierarchy.app.SubApp.invoke(..))")
        public Object around(ProceedingJoinPoint jp) throws Throwable {
            String out = (String) jp.proceed();
            return "localAspect[" + out + "]";
        }
    }
======= 794f9b5:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"

    public void testAppContainer() {
        runTest("AppContainer");
    }
    <ajc-test dir="java5/ataspectj" title="AppContainer">
        <compile
            files="ataspectj/hierarchy/AppContainerTest.java,ataspectj/hierarchy/app/SubApp.java,ataspectj/TestHelper.java"
            options="-1.5 -XnoWeave"
            />
        <ant file="ajc-ant.xml" target="ltw.AppContainer" verbose="true"/>
    </ajc-test>
======= 794f9b5:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

        // the following block will not detect @Pointcut in non @Aspect types for optimization purpose
        if (!hasAtAspectAnnotation) {
            return EMPTY_LIST;
        }
        //FIXME AV - turn on when ajcMightHaveAspect
======= 794f9b5:"weaver/src/org/aspectj/weaver/bcel/AtAjAttributes.java"

        // semantic check: @Aspect must be public
        // FIXME AV - do we really want to enforce that?

  public static void main(String [] argv) {
    new Test().foo();
  }
  Set<Integer> intsSet = new HashSet<Integer>();
  public Set<Integer> foo() {
    return intsSet;
  }
  pointcut gettingMember(Test t) :
             target(t) &&
             get(!public Set<Integer> com.*.*) &&
             !within(TestAspect);
  Set<Integer> around(Test t) : gettingMember(t)  {
    Set s =  proceed(t);
    return s;
  }
======= 8cea30f:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testUnboundFormal_pr112027() { runTest("unexpected error unboundFormalInPC");}
  public void testCCEGenerics_pr113445()       { runTest("Generics ClassCastException");}
  
======= 8cea30f:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testFieldGetProblemWithGenericField_pr113861() {runTest("field-get problems with generic field");}
    
    <ajc-test dir="bugs150/pr113861" title="field-get problems with generic field">
        <compile files="Test.java,TestAspect.java" options="-1.5"/>
        <run class="com.Test"/>
    </ajc-test>
    
    
 
======= 8cea30f:"weaver/src/org/aspectj/weaver/Advice.java"

    				} else {
    					ResolvedType shadowReturnType = shadow.getReturnType().resolve(world);
    					ResolvedType adviceReturnType = getSignature().getGenericReturnType().resolve(world);
    					if(!shadowReturnType.isAssignableFrom(adviceReturnType)) {
    					}
======= 8cea30f:"weaver/src/org/aspectj/weaver/Member.java"

======= 8cea30f:"weaver/src/org/aspectj/weaver/MemberImpl.java"

    
    public UnresolvedType getGenericReturnType() { return getReturnType(); }

    declare @field : int C.noSuchField : @Annotation; // should be an error
    
    
    
======= 2da9b31:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testDeclareAnnotationOnNonExistentType_pr99191_1() { runTest("declare annotation on non existent type - 1");}
  public void testDeclareAnnotationOnNonExistentType_pr99191_2() { runTest("declare annotation on non existent type - 2");}  
  public void testDeclareAnnotationOnNonExistentType_pr99191_3() { runTest("declare annotation on non existent type - 3");}  
  public void testDeclareAnnotationOnNonExistentType_pr99191_4() { runTest("declare annotation on non existent type - 4");}  
  public void testDeclareAnnotationOnNonExistentType_pr99191_5() { runTest("declare annotation on non existent type - 5");}  
  
    
    
    <ajc-test dir="bugs150/pr99191" title="declare annotation on non existent type - 1">
        <compile files="pr99191_1.java" options="-1.5">
        	<message kind="error" line="4" text="The field 'int C.noSuchField' does not exist"/>
        </compile>
    </ajc-test> 
    <!-- Currently a warning doesn't occur if the annotation is already on the field
         (see bug 113029). If this is fixed, need to add check for this warning to this
         test as in test "declare annotation on non existent type - 4" -->
    <ajc-test dir="bugs150/pr99191" title="declare annotation on non existent type - 2">
        <compile files="pr99191_2.java" options="-1.5">
        </compile>
    </ajc-test> 
    <ajc-test dir="bugs150/pr99191" title="declare annotation on non existent type - 3">
        <compile files="pr99191_3.java" options="-1.5">
        	<message kind="error" line="4" text="The method 'public * C.noSuchMethod(..)' does not exist"/>
        </compile>
    </ajc-test> 
    <ajc-test dir="bugs150/pr99191" title="declare annotation on non existent type - 4">
        <compile files="pr99191_4.java" options="-1.5">
        	<message kind="warning" text="void C.amethod() - already has an annotation of type Annotation, cannot add a second instance [Xlint:elementAlreadyAnnotated]"/>
        </compile>
    </ajc-test> 
    <ajc-test dir="bugs150/pr99191" title="declare annotation on non existent type - 5">
        <compile files="pr99191_5.java" options="-1.5">
        	<message kind="error" line="4" text="The method 'C.new(java.lang.String)' does not exist"/>
        </compile>
    </ajc-test> 
    <ajc-test dir="bugs150/pr99191" title="declare annotation on non existent type - 6">
        <compile files="pr99191_6.java" options="-1.5">
        	<message kind="warning" text="void C.&lt;init&gt;(int) - already has an annotation of type Annotation, cannot add a second instance [Xlint:elementAlreadyAnnotated]"/>
        </compile>
    </ajc-test>
======= 2da9b31:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 2da9b31:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 2da9b31:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 2da9b31:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

            			if (doesAlreadyHaveAnnotation(mg.getMemberView(),decaM,reportedProblems)) {
            				// remove the declare @method since don't want an error when 
            				// the annotation is already there
            				unusedDecams.remove(decaM);
            				continue; // skip this one...
            			}
======= 2da9b31:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

            			unusedDecams.remove(decaM);           			
======= 2da9b31:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

            				if (doesAlreadyHaveAnnotation(mg.getMemberView(),decaM,reportedProblems)) {
            					// remove the declare @method since don't want an error when 
                				// the annotation is already there
                				unusedDecams.remove(decaM);
            					continue; // skip this one...
            				}
    						// remove the declare @method since have matched against it
            				unusedDecams.remove(decaM);
======= 2da9b31:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 2da9b31:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

            				// remove the declare @field since don't want an error when 
            				// the annotation is already there
            				unusedDecafs.remove(decaF);
======= 2da9b31:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        			unusedDecafs.remove(decaF); 
======= 2da9b31:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        				// remove the declare @field since don't want an error when 
        				// the annotation is already there
        				unusedDecafs.remove(decaF);
        			unusedDecafs.remove(decaF); 

======= cc6862f:"ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java"

        assertTrue(configFile + " failed", null != buildConfig);            
======= cc6862f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

        if (!isXHasMemberEnabled() && global.isXHasMemberEnabled()) {
        	setXHasMemberSupport(true);
        }

======= 70888dd:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

            ExplicitlyInitializedClassLoaderWeavingAdaptor adaptor = null;
                adaptor = (ExplicitlyInitializedClassLoaderWeavingAdaptor) weavingAdaptors.get(loader);
                    adaptor = new ExplicitlyInitializedClassLoaderWeavingAdaptor(weavingAdaptor);
======= 70888dd:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

    static class ExplicitlyInitializedClassLoaderWeavingAdaptor {
        public ExplicitlyInitializedClassLoaderWeavingAdaptor(ClassLoaderWeavingAdaptor weavingAdaptor) {
======= 70888dd:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        // AV - see #113511 - not sure it is good to skip message handler
        if (enabled) {
            messageHandler = bcelWorld.getMessageHandler();
            // after adding aspects
            weaver.prepareForWeave();
        }
======= 70888dd:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

            // AV - see #113511
            if (!definitions.isEmpty()) {
                registerAspectExclude(weaver, loader, definitions);
                registerAspects(weaver, loader, definitions);
                registerIncludeExclude(weaver, loader, definitions);
                registerDump(weaver, loader, definitions);
            } else {
                enabled = false;// will allow very fast skip in shouldWeave()
            }

    public void doSomething() { }
    declare parents : SomeClass implements Serializable;
    pointcut doSomething(SomeClass someClass) :
            execution(void SomeClass.doSomething()) &&
            this(someClass);
    void around(Serializable myWorld) : doSomething(myWorld) { }
    
======= 3021284:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testIllegalChangeToPointcutDeclaration_pr111915() {
  }
  
    
    <ajc-test dir="bugs150" title="test illegal change to pointcut declaration">
        <compile files="pr111915.java" options="-1.5 -showWeaveInfo">
          <message kind="weave" text="Join point 'method-execution(void SomeClass.doSomething())' in Type 'SomeClass' (pr111915.java:4) advised by around advice from 'DoesntCompile' (pr111915.java:15)"/>
          <message kind="weave" text="Extending interface set for type 'SomeClass' (pr111915.java) to include 'java.io.Serializable' (pr111915.java)"/>
        </compile>
    </ajc-test> 
======= 3021284:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= 3021284:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= 3021284:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"


======= f06df41:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

   
  public void testWeaveInfoMessageForDeclareAtMethodOnITDdMethod() {
  }
    <ajc-test dir="bugs150" title="weaveinfo message for declare at method on an ITDd method">
        <compile files="pr113073.java" options="-1.5 -showWeaveInfo">
        </compile>
    </ajc-test> 
======= f06df41:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

            			reportMethodCtorWeavingMessage(clazz, mg.getMemberView(), decaM,mg.getDeclarationLineNumber());
======= f06df41:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

    // TAG: WeavingMessage
======= f06df41:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= f06df41:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"


  pointcut pc() : this(pr112027);
  before(pr112027 tis) : pc() && this(tis) { }
======= ae612d9:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testUnboundFormal_pr112027() { runTest("unexpected error unboundFormalInPC");}
  
   
   <ajc-test dir="bugs150" title="unexpected error unboundFormalInPC">
     <compile files="pr112027.aj"/>
   </ajc-test>
======= ae612d9:"weaver/src/org/aspectj/weaver/patterns/BindingTypePattern.java"

        result = 37*result + super.hashCode();
======= ae612d9:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

    	if (other instanceof BindingTypePattern) return false;
======= ae612d9:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

        result = 37*result + new Boolean(includeSubtypes).hashCode();
        result = 37*result + new Boolean(isVarArgs).hashCode();
        result = 37*result + typeParameters.hashCode();

======= 332a5df:"util/src/org/aspectj/util/ConfigParser.java"

        if (!ret.exists() && (dir != null) && !ret.isAbsolute()) { 

======= 999d9b0:"bcel-builder/src/org/aspectj/apache/bcel/classfile/ClassParser.java"

 * @version $Id: ClassParser.java,v 1.4 2005/10/14 08:39:32 aclement Exp $
======= 999d9b0:"bcel-builder/src/org/aspectj/apache/bcel/classfile/ClassParser.java"

    try {

======= 04e8dca:"weaver/src/org/aspectj/weaver/World.java"

======= 04e8dca:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= 04e8dca:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

        

======= ab6c7a5:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

======= ab6c7a5:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

    private static final String POINTCUT_DETAIL = "Pointcut Detail";
======= ab6c7a5:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        int pointcutSummaryIndex = fileContents.toString().indexOf(POINTCUT_SUMMARY);
        int adviceSummaryIndex = fileContents.toString().indexOf(ADVICE_SUMMARY);
======= ab6c7a5:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

    	List declares = new ArrayList();
    		} else if (member.getKind().isDeclare() || member.getKind().isInterTypeMember()) {
    			declares.add(member);
    	if (declares.size() > 0) {
    		insertDeclarationsDetails(fileBuffer, declares, DECLARE_DETAIL, index);
    		insertDeclarationsSummary(fileBuffer, declares, DECLARE_SUMMARY, index);
    	}
    		insertDeclarationsSummary(fileBuffer, pointcuts, POINTCUT_SUMMARY, index);
    		insertDeclarationsDetails(fileBuffer, pointcuts, POINTCUT_DETAIL, index);
    		insertDeclarationsSummary(fileBuffer, advice, ADVICE_SUMMARY, index);
    		insertDeclarationsDetails(fileBuffer, advice, ADVICE_DETAIL, index);
======= ab6c7a5:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

                if ( kind.equals( ADVICE_SUMMARY ) ) {
======= ab6c7a5:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

                else if ( kind.equals( POINTCUT_SUMMARY ) ) {
======= ab6c7a5:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

                else if ( kind.equals( DECLARE_SUMMARY ) ) {
                            "<TT>" + decl.toLabelString() + "</TT></A><P>" +
                            generateIntroductionSignatures(decl, true) +
======= ab6c7a5:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

                if ( kind.equals( ADVICE_DETAIL ) ) {
======= ab6c7a5:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

                else if (kind.equals(POINTCUT_DETAIL)) {
                else if (kind.equals(DECLARE_DETAIL)) {
                	entry += "<H3>declare " + decl.toLabelString() + "</H3><P>";
======= ab6c7a5:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        if (targets != null && !targets.isEmpty()) {            
======= ab6c7a5:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

    	List targets = null;
    	if (isIntroduction) {
    		targets = StructureUtil.getDeclareTargets(decl);
    	} else {
    		targets = StructureUtil.getTargets(decl, IRelationship.Kind.ADVICE);
    	}
    	if (targets == null) return "";
        String entry = "<TABLE WIDTH=\"100%\" BGCOLOR=#FFFFFF><TR>";
        if (!isIntroduction) {
        	entry += "<TD width=\"10%\" bgcolor=\"#FFD8B0\"><B><FONT COLOR=000000>&nbsp;Advises:</b></font></td><td>";
        } else {
        	entry += "<TD width=\"10%\" bgcolor=\"#FFD8B0\"><B><FONT COLOR=000000>&nbsp;Affects:</b></font></td><td>";
        }
        	
======= ab6c7a5:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        String hrefLink = decl.toLabelString().replace("\"", "quot;"); // !!!
======= ab6c7a5:"ajdoc/src/org/aspectj/tools/ajdoc/StructureUtil.java"

======= ab6c7a5:"ajdoc/src/org/aspectj/tools/ajdoc/StructureUtil.java"

======= ab6c7a5:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

======= ab6c7a5:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

======= ab6c7a5:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

 
    pointcut illegalNewFigElt(): call(Point.new(..)) && !withincode(* *.doIt(..));
    declare error: illegalNewFigElt(): "Illegal constructor call.";
    declare warning: call(* Point.setX(..)): "Illegal call.";
    declare parents: Point extends java.io.Serializable;
    declare soft: SizeException : call(* Point.getX());
    public int Point.xxx = 0;
    public int Point.check(int i, int j) { return 1; }
======= ab6c7a5:"ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java"

    
    
======= ab6c7a5:"ajdoc/testsrc/org/aspectj/tools/ajdoc/AjdocTests.java"

        suite.addTestSuite(DeclareFormsTest.class);
======= ab6c7a5:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

======= ab6c7a5:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

 * Copyright (c) 2003 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Mik Kersten     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
            "-classpath",
            AjdocTests.ASPECTJRT_PATH.getPath(),
======= ab6c7a5:"ajdoc/testsrc/org/aspectj/tools/ajdoc/ExecutionTestCase.java"

======= ab6c7a5:"ajdoc/testsrc/org/aspectj/tools/ajdoc/PatternsTestCase.java"

======= ab6c7a5:"ajdoc/testsrc/org/aspectj/tools/ajdoc/PointcutVisibilityTest.java"

    protected File file1 = new File("../ajdoc/testdata/bug82340/Pointcuts.java");
    protected File outdir = new File("../ajdoc/testdata/bug82340/doc");
======= ab6c7a5:"ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.java"

======= ab6c7a5:"ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.java"

======= ab6c7a5:"asm/src/org/aspectj/asm/IRelationship.java"


    Object x = getLogger();  
    Object x = getLogger();  
======= 727b0f5:"tests/src/org/aspectj/systemtest/incremental/tools/MultiProjectIncrementalTests.java"


======= 12e6334:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        weaver.setReweavableMode(weaverOption.notReWeavable);
======= 12e6334:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

    private final static String OPTION_notReweavable = "-XNotReweavable";
======= 12e6334:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

            } else if (arg.equalsIgnoreCase(OPTION_notReweavable)) {
                weaverOption.notReWeavable = true;
======= 12e6334:"loadtime/src/org/aspectj/weaver/loadtime/Options.java"

        boolean notReWeavable;
======= 12e6334:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

            	showWarning("-Xreweavable is on by default");
            		showWarning("-Xreweavable:compress is no longer available - reweavable is now default");
            	buildConfig.setXnotReweavable(true);
======= 12e6334:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/core/AspectJCore.java"

======= 12e6334:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

        if (!isXNotReweavable() && global.isXNotReweavable()) {
        	setXnotReweavable(true);
======= 12e6334:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= 12e6334:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= 12e6334:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 12e6334:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= 12e6334:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= 12e6334:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= 12e6334:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= 12e6334:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= 12e6334:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= 12e6334:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AspectJBuilder.java"

======= 12e6334:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BinaryFormsTestCase.java"

======= 12e6334:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BinaryFormsTestCase.java"

======= 12e6334:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BinaryFormsTestCase.java"

======= 12e6334:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BinaryFormsTestCase.java"

======= 12e6334:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BinaryFormsTestCase.java"

======= 12e6334:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= 12e6334:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= 12e6334:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= 12e6334:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= 12e6334:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= 12e6334:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

        		"reweavable", "reweavable:compress", "notReweavable", "noInline"
======= 12e6334:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    public void setXNotReweavable(boolean notReweavable) {
    	cmd.addFlag("-XnotReweavable",notReweavable);
    }
    
======= 12e6334:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

            } else if ("-XnotReweavable".equals(flag)) {
======= 12e6334:"testing/newsrc/org/aspectj/testing/WeaveSpec.java"

======= 12e6334:"testing/src/org/aspectj/testing/harness/bridge/CompilerRun.java"

                        factory.create("XnotReweavable"),
                 options=""
======= 12e6334:"tests/java5/ataspectj/ataspectj/ltwlog/MainVerboseAndShow.java"

        
                "info weaver operating in reweavable mode.  Need to verify any required types exist.",
                "info weaving 'ataspectj/ltwlog/Aspect1'",
                "info weaver operating in reweavable mode.  Need to verify any required types exist."}))) {
    <weaver options="-XmessageHandlerClass:ataspectj.ltwlog.MessageHolder -verbose -xNotReweavable"/>
        		   pack/MyInterface.java" options="-XnotReweavable"/>
   	   <compile files="TestA_generictype.java" outjar="code.jar" options="-1.5"/>
       <compile files="TestA_aspect.aj,TestA_class.java" inpath="code.jar" options="-1.5"/>
   	   <compile files="TestB_generictype.java" outjar="code.jar" options="-1.5"/>
       <compile files="TestB_aspect1.aj,TestB_aspect2.aj,TestB_class.java" inpath="code.jar" options="-1.5"/>
   	   <compile files="BaseClass.java" outjar="code.jar" options="-1.5"/>
       <compile files="A1.aj" inpath="code.jar" options="-1.5"/>
   	   <compile files="BaseClass.java,A1.aj" outjar="code.jar" options="-1.5,-showWeaveInfo">
       <compile files="A2.aj" inpath="code.jar" options="-1.5,-showWeaveInfo">
   	   <compile files="BaseClass.java,A1.aj,A2.aj" outjar="code.jar" options="-1.5"/>
       <compile files="A3.aj" inpath="code.jar" options="-1.5"/>
   	 <compile files="Sub1.java,Super1.java" outjar="code.jar" options="-1.5"/>
   	 <compile files="X1.aj,Util.java" inpath="code.jar" options ="-1.5"/>
   	 <compile files="Sub2.java,Super2.java" outjar="code.jar" options="-1.5"/>
   	 <compile files="X2.aj,Util.java" inpath="code.jar" options ="-1.5"/>
   	 <compile files="Sub3.java,Super3.java" outjar="code.jar" options="-1.5"/>
   	 <compile files="X3.aj,Util.java" inpath="code.jar" options ="-1.5"/>
======= 12e6334:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjLTWTests.java"

        runTest("AjcLTW AroundInlineMungerTest");
            options="-1.5"/>
            options="-1.5"/>
            options="-1.5"/>
            options="-1.5 -Xlint:ignore -XnoInline"/>
            options="-1.5 -XnoInline"/>
            options="-1.5"/>
            options="-1.5"
        <compile staging="true" options="-incremental,-emacssym, -XnotReweavable" sourceroots="src"/>
        <compile staging="true" options="-incremental,-emacssym, -XnotReweavable" sourceroots="src"/>
======= 12e6334:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= 12e6334:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= 12e6334:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

        -51, 34, 105, 56, -34, 65, 45, 78, -26, 125, 114, 97, 98, 1, -1, -42
    };
======= 12e6334:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= 12e6334:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= 12e6334:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= 12e6334:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

        	unwovenClassFileIsADiff = false;
    }
======= 12e6334:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= 12e6334:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

   
======= 12e6334:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= 12e6334:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

    }
        for(int i = wovenClassFile.length - 1; i > 0; i--)
            if(endOfKeyHere(wovenClassFile, i)){
                return i + 1;
            }
        throw new RuntimeException("key not found in wovenClassFile"); // should never happen
    }
        for(int j = 0; j < key.length; j++)
            if(key[key.length - 1 - j] != lookIn[i - j]){
                return false;
            }
        return true;
    }
        byte result[] = new byte[original.length + toInsert.length];
        System.arraycopy(original, 0, result, 0, offset);
        System.arraycopy(toInsert, 0, result, offset, toInsert.length);
        System.arraycopy(original, offset, result, offset + toInsert.length, original.length - offset);
        return result;
    }
        ByteArrayInputStream b = new ByteArrayInputStream(a, offset, 4);
        DataInputStream d = new DataInputStream(b);
        int length = -1;
        try{
            length = d.readInt();
        }
        catch(IOException e) {
        	throw(new RuntimeException("readInt called with a bad array or offset")); // should never happen
        }
        return length;
    }
        byte result[] = new byte[a.length - lengthToDelete]; // make a new array
        System.arraycopy(a, 0, result, 0, start); // copy in the bit before the deleted bit
        System.arraycopy(a, end, result, start, a.length - end); // copy in the bit after the deleted bit
        return result;
    }
======= 12e6334:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= 12e6334:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 12e6334:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        	clazz.getOrCreateWeaverStateInfo(inReweavableMode);
        if (inReweavableMode) {
        	WeaverStateInfo wsi = clazz.getOrCreateWeaverStateInfo(true);
        	wsi.setReweavable(true);
        	clazz.getOrCreateWeaverStateInfo(false).setReweavable(false);
======= 12e6334:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 12e6334:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 12e6334:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 12e6334:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= 12e6334:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 12e6334:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

    	ret[0] = new UnwovenClassFile(clazz.getFileName(),clazz.getJavaClassBytesIncludingReweavable(world));
======= 12e6334:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 12e6334:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

    
    public byte [] getJavaClassBytesIncludingReweavable(BcelWorld world){
        writeBack(world);
        byte [] wovenClassFileData = myGen.getJavaClass().getBytes();
        WeaverStateInfo wsi = myType.getWeaverState();//getOrCreateWeaverStateInfo();
        if(wsi != null && wsi.isReweavable()){ // && !reweavableDataInserted
            //reweavableDataInserted = true;
            return wsi.replaceKeyWithDiff(wovenClassFileData);
        } else{
            return wovenClassFileData;
        }
    }
======= 12e6334:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= 12e6334:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"


======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

    public Pointcut parameterizeWith(Map typeVariableMap) {
    	ArgsPointcut ret = new ArgsPointcut(this.arguments.parameterizeWith(typeVariableMap));
    	ret.copyLocationFrom(this);
    	return ret;
    }
    
======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

                  shadow.getIWorld().getMessageHandler().handleMessage(msg);
======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/ConcreteCflowPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/ConcreteCflowPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/DeclareAnnotation.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/PerCflow.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/PerCflow.java"

    public Pointcut parameterizeWith(Map typeVariableMap) {
    	PerCflow ret = new PerCflow(entry.parameterizeWith(typeVariableMap),isBelow);
    	ret.copyLocationFrom(this);
    	return ret;
    }
    
======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/PerObject.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/PerObject.java"

    public Pointcut parameterizeWith(Map typeVariableMap) {
    	PerObject ret = new PerObject(entry.parameterizeWith(typeVariableMap),isThis);
    	ret.copyLocationFrom(this);
    	return ret;
    }
    
======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/PerSingleton.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/PerSingleton.java"

    public Pointcut parameterizeWith(Map typeVariableMap) {
    	return this;
    }
    
======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

======= 451fea8:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"


======= 2b0e675:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeConstructorDeclaration.java"

======= 2b0e675:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeConstructorDeclaration.java"

  public static void main(String []argv) {
    new pr111481(new Object[]{"a","b","c"});
    new pr111481("a","b","c");
  }
    public pr111481.new(Object... names) {
    	System.out.println(names[0]);
    }
======= 2b0e675:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testVarArgsIITDInConstructor() {
  }
   <ajc-test dir="bugs150" title="ITD varargs in constructor">
     <compile files="pr111481.aj" options="-1.5"/>
       <stdout>
           <line text="a"/>
           <line text="a"/>
       </stdout>
      </run>
   </ajc-test>

======= 4573068:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= 4573068:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= 4573068:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

======= 4573068:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= 4573068:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= 4573068:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= 4573068:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= 4573068:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

======= 4573068:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

======= 4573068:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testAdviceInStructureModelWithAnonymousInnerClass_pr77269() {
  	  IHierarchy top = AsmManager.getDefault().getHierarchy();
  	    	  
  	  // checking that the run() method inside anonymous inner class is in 
  	  // the structure model
  	  IProgramElement anonRunMethodIPE = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.METHOD,"run()");  	 
  	 
  	  assertNotNull("Couldn't find 'run()' element in the tree",anonRunMethodIPE);
  	  List l = AsmManager.getDefault().getRelationshipMap().get(anonRunMethodIPE);	
  	  assertNotNull("Should have some relationships but does not",l);
  	  assertTrue("Should have one relationship but has " + l.size(),l.size()==1);
  	  Relationship rel = (Relationship)l.get(0);
  	  List targets = rel.getTargets();
  	  assertTrue("Should have one target but has" + targets.size(),
  			  targets.size()==1);
  	  IProgramElement target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)targets.get(0));
  	  assertEquals("target of relationship should be 'before(): p..' but is "
  			  + target.toLabelString(),"before(): p..",target.toLabelString());
  	  
  	  IProgramElement adviceIPE = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.ADVICE,"before(): p..");  	  
  	  assertNotNull("Couldn't find 'before(): p..' element in the tree",adviceIPE);
  	  l = AsmManager.getDefault().getRelationshipMap().get(adviceIPE);
  	  assertNotNull("Should have some relationships but does not",l);
  	  assertTrue("Should have a relationship but does not ",l.size()>0);
  	  for (Iterator iter = l.iterator(); iter.hasNext();) {
  	  targets = rel.getTargets();
  	  assertTrue("Should have one target but has" + targets.size(),
  			  targets.size()==1);
  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)targets.get(0));
  	  assertEquals("target of relationship should be 'run()' but is "
  			  + target.toLabelString(),"run()",target.toLabelString());
  	  
  }
 
  public void testAdviceInStructureModelWithNamedInnerClass_pr77269() {
  	  IHierarchy top = AsmManager.getDefault().getHierarchy();
  	    	  
  	  // checking that the m() method inside named inner class is in 
  	  // the structure model
  	  IProgramElement namedMethodIPE = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.METHOD,"m()");  	  
  	  assertNotNull("Couldn't find 'm()' element in the tree",namedMethodIPE);
  	  List l = AsmManager.getDefault().getRelationshipMap().get(namedMethodIPE);	
  	  assertNotNull("Should have some relationships but does not",l);
  	  assertTrue("Should have one relationship but has " + l.size(),l.size()==1);
  	  Relationship rel = (Relationship)l.get(0);
  	  List targets = rel.getTargets();
  	  assertTrue("Should have one target but has" + targets.size(),
  			  targets.size()==1);
  	  IProgramElement target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)targets.get(0));
  	  assertEquals("target of relationship should be 'before(): p..' but is "
  			  + target.toLabelString(),"before(): p..",target.toLabelString());
  	  
  	  IProgramElement adviceIPE = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.ADVICE,"before(): p..");  	  
  	  assertNotNull("Couldn't find 'before(): p..' element in the tree",adviceIPE);
  	  l = AsmManager.getDefault().getRelationshipMap().get(adviceIPE);
  	  assertNotNull("Should have some relationships but does not",l);
  	  assertTrue("Should have a relationship but does not ",l.size()>0);
  	  for (Iterator iter = l.iterator(); iter.hasNext();) {
  	  targets = rel.getTargets();
  	  assertTrue("Should have one target but has" + targets.size(),
  			  targets.size()==1);
  	  target = AsmManager.getDefault().getHierarchy().findElementForHandle((String)targets.get(0));
  	  assertEquals("target of relationship should be 'm()' but is "
  			  + target.toLabelString(),"m()",target.toLabelString());
  	  
  }
  
  public void testDWInStructureModelWithAnonymousInnerClass_pr77269() {
      // AsmManager.setReporting("c:/debug.txt",true,true,true,true);
  	  IHierarchy top = AsmManager.getDefault().getHierarchy();
  	  IProgramElement pe = top.findElementForLabel(top.getRoot(),
  			  IProgramElement.Kind.CODE,"method-call(void pack.Test.someMethod())");  	 	 
  	  assertNotNull("Couldn't find 'method-call(void pack.Test.someMethod())' element in the tree",pe);
  }
  
  
    <ajc-test dir="bugs150/pr77269" title="advice in structure model with anonymous inner class">
        <compile files="pack/pr77269.aj" options="-emacssym">
        </compile>
    </ajc-test> 
    <ajc-test dir="bugs150" title="advice in structure model with named inner class">
        <compile files="pr77269b.aj" options="-emacssym">
        </compile>
    </ajc-test> 
    <ajc-test dir="bugs150/pr77269" title="declare warning in structure model with anonymous inner class">
        <compile files="pack/pr77269c.aj" options="-emacssym">
        	<message kind="warning" line="8" text="blah blah blah"/>
        </compile>
    </ajc-test> 
   <ajc-test dir="bugs150" title="ITD varargs problem">
     <compile files="pr110906.aj"/>
   </ajc-test>
   

  @org.aspectj.lang.annotation.SuppressAjWarnings("adviceDidNotMatch")
======= 81a0790:"tests/src/org/aspectj/systemtest/ajc150/SuppressedWarnings.java"

  
  public void testSuppressionOfMessagesIssuedDuringMatching() {
  }
   
   <ajc-test dir="java5/suppressedWarnings" title="SuppressAjWarnings raised during matching">
       <compile files="SuppressionDuringMatching.aj" options="-1.5">
       </compile>
   </ajc-test>
======= 81a0790:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= 81a0790:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= 81a0790:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= 81a0790:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

    	suppressLintWarnings(world);
======= 81a0790:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

    		if (signature instanceof BcelMethod) {
    			this.suppressedLintKinds = Utility.getSuppressedWarnings(signature.getAnnotations(), inWorld.getLint());
    		} else {
    			this.suppressedLintKinds = Collections.EMPTY_LIST;
    		}
    	}
    	inWorld.getLint().suppressKinds(suppressedLintKinds);
======= 81a0790:"weaver/src/org/aspectj/weaver/bcel/Utility.java"


======= 85a4b0a:"bcel-builder/src/org/aspectj/apache/bcel/generic/MethodGen.java"

 * @version $Id: MethodGen.java,v 1.5 2005/09/28 20:10:19 acolyer Exp $
======= 85a4b0a:"bcel-builder/src/org/aspectj/apache/bcel/generic/MethodGen.java"


======= 97520cf:"bcel-builder/src/org/aspectj/apache/bcel/generic/LocalVariableGen.java"

 * @version $Id: LocalVariableGen.java,v 1.4 2005/09/27 21:08:24 acolyer Exp $
======= 97520cf:"bcel-builder/src/org/aspectj/apache/bcel/generic/LocalVariableGen.java"

    if(length > 0) {
      // AMC - the above calculation is off by one. The spec says that the variable
      // must have a range from start pos to start pos + length INCLUSIVE.
      // but the calculation above puts start pos + length as the address of 
      // the first instruction outside of the range. 
      // So we need to subtract 1... which gives the very end of the last inst in the range
      length = length - 1; 
    }
======= 97520cf:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

                        LocalVariableTag lr = new LocalVariableTag(BcelWorld.fromBcel(lng.getType()), lng.getName(), lng.getIndex(), lng.getStart().getPosition());
======= 97520cf:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        Map map = copyAllInstructionsExceptRangeInstructionsInto(fresh);
        InstructionHandle oldInstructionHandle = getBody().getStart();
        InstructionHandle newInstructionHandle = fresh.getStart();
        LinkedList exceptionList = new LinkedList();   
======= 97520cf:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        while (oldInstructionHandle != null) {
            if (map.get(oldInstructionHandle) == null) {
            	// must be a range instruction since they're the only things we didn't copy across
                handleRangeInstruction(oldInstructionHandle, exceptionList);
                oldInstructionHandle = oldInstructionHandle.getNext();
                Instruction oldInstruction = oldInstructionHandle.getInstruction();
                Instruction newInstruction = newInstructionHandle.getInstruction();
        		if (oldInstruction instanceof BranchInstruction) {
        			handleBranchInstruction(map, oldInstruction, newInstruction);
        		}
                InstructionTargeter[] targeters = oldInstructionHandle.getTargeters();
                                gen.addLineNumber(newInstructionHandle, line + lineNumberOffset);
                            if (localVariableStarts.get(lvt) == null) {
                            	localVariableStarts.put(lvt, newInstructionHandle);
                            }
                            localVariableEnds.put(lvt, newInstructionHandle);
                
                oldInstructionHandle = oldInstructionHandle.getNext();
                newInstructionHandle = newInstructionHandle.getNext();
        addExceptionHandlers(gen, map, exceptionList);       
        addLocalVariables(gen, localVariableStarts, localVariableEnds);
        
        // JAVAC adds line number tables (with just one entry) to generated accessor methods - this
        // keeps some tools that rely on finding at least some form of linenumbertable happy.
        // Let's check if we have one - if we don't then let's add one.
        // TODO Could be made conditional on whether line debug info is being produced
        if (gen.getLineNumbers().length==0) { 
        	gen.addLineNumber(gen.getInstructionList().getStart(),1);
    }
======= 97520cf:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        for (Iterator iter = exnList.iterator(); iter.hasNext();) {
            ExceptionRange r = (ExceptionRange) iter.next();
            if (r.isEmpty()) continue;
            gen.addExceptionHandler(
                remap(r.getRealStart(), map), 
                remap(r.getRealEnd(), map),
                remap(r.getHandler(), map),
                (r.getCatchType() == null)
                ? null 
                : (ObjectType) BcelWorld.makeBcelType(r.getCatchType()));
   
   
   
    /* Make copies of all instructions, append them to the new list
     * and associate old instruction references with the new ones, i.e.,
     * a 1:1 mapping.
     */
   private Map copyAllInstructionsExceptRangeInstructionsInto(InstructionList intoList) {
    	HashMap map = new HashMap();
    	for (InstructionHandle ih = getBody().getStart(); ih != null; ih = ih.getNext()) {
            if (Range.isRangeHandle(ih)) {
                continue;
            }
            Instruction i = ih.getInstruction();
            Instruction c = Utility.copyInstruction(i);
            if (c instanceof BranchInstruction)
                map.put(ih, intoList.append((BranchInstruction) c));
            else
                map.put(ih, intoList.append(c));
        }
    	return map;
    }
    
======= 97520cf:"weaver/src/org/aspectj/weaver/bcel/LocalVariableTag.java"

    private final int startPos;
    // AMC - pr101047, two local vars with the same name can share the same slot, but must in that case
    // have different start positions.
    public LocalVariableTag(UnresolvedType type, String name, int slot, int startPosition) {
        this.startPos = startPosition;
======= 97520cf:"weaver/src/org/aspectj/weaver/bcel/LocalVariableTag.java"

        return o.type.equals(type) && o.name.equals(name) && o.slot == slot && o.startPos == startPos;
======= 97520cf:"weaver/src/org/aspectj/weaver/bcel/LocalVariableTag.java"

            ret = 37*ret + startPos;

    public void test() {
    	pr102933[] array = new pr102933[0];
    	pr102933[] arrayClone = (pr102933[])array.clone();
    }
    declare warning: call(* *(..)) :
======= fb428d0:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testArrayCloneCallJoinPoints() {
  }
  
     <ajc-test dir="bugs150" title="array clone call join points in 1.4 vs 1.3">
        <compile files="pr102933.aj" options="-1.3">
            <message kind="warning" line="7" text="a call within pr102933"/>
        </compile>
        <compile files="pr102933.aj" options="-1.4">
            <message kind="warning" line="7" text="a call within pr102933"/>
        </compile>     
        <compile files="pr102933.aj" options="-1.5">
            <message kind="warning" line="7" text="a call within pr102933"/>
        </compile>   
     </ajc-test> 
     

    @DefaultImplementation 
                // join point is found by pointcut here!  This is ok!
======= e76b370:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testCallJoinPointsInAnonymousInnerClasses() {
  }
  
  public void testNoRequirementForUnwovenTypesToBeExposedToWeaver() {
  }
  
    <ajc-test dir="bugs150" title="call join points in anonymous inner classes">
        <compile files="pr104229.aj" options="-1.5">
            <message kind="warning" line="54" text="bingo"/>
            <message kind="warning" line="115" text="bingo"/>
            <message kind="warning" line="130" text="bingo"/>
        </compile>
        <run class="pr104229">
            <stdout>
                <line text="call match class pr104229"/>
                <line text="OK it worked!"/>
            </stdout>
        </run>
    </ajc-test>
    <ajc-test dir="bugs150" title="default impl of Runnable">
        <compile files="pr88900.aj" options="-Xdev:Pinpoint">
        </compile>
    </ajc-test> 
    
======= e76b370:"weaver/src/org/aspectj/weaver/ResolvedTypeMunger.java"

   				// if the onType is an interface, and it already has the member we are about
   				// to munge, then this is ok...
   				boolean ok = (onType.isInterface() && (onType.lookupMemberWithSupersAndITDs(getSignature()) != null));
   				
   				if (!ok && onType.getWeaverState() == null) {

======= a4a9090:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= a4a9090:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= a4a9090:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/OutjarTest.java"

======= a4a9090:"weaver/src/org/aspectj/weaver/JoinPointSignature.java"

======= a4a9090:"weaver/src/org/aspectj/weaver/JoinPointSignature.java"

======= a4a9090:"weaver/src/org/aspectj/weaver/JoinPointSignature.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * Iterates over the signatures of a join point, calculating new signatures
 * lazily to minimize processing and to avoid unneccessary "can't find type"
 * errors. Iterator can be cached and reused by calling the "reset" method
 * between iterations.
 */
    	// first defining type
    	ResolvedType originalDeclaringType = signaturesOfMember.getDeclaringType().resolve(world);
    	firstDefiningMember = (ResolvedMemberImpl) signaturesOfMember.resolve(world);
    	if (firstDefiningMember == null) {
    		couldBeFurtherAsYetUndiscoveredSignatures = false;
    		return;
    	} 
    	
    	// declaringType can be unresolved if we matched a synthetic member generated by Aj...
    	// should be fixed elsewhere but add this resolve call on the end for now so that we can
    	// focus on one problem at a time...
    	firstDefiningType = firstDefiningMember.getDeclaringType().resolve(world);
    	if (firstDefiningType != originalDeclaringType) {
    		if (signaturesOfMember.getKind() == Member.CONSTRUCTOR) {
    			return;
    		} 
    	}
    	List declaringTypes = new ArrayList();
    	accumulateTypesInBetween(originalDeclaringType, 
    							 firstDefiningType,
    							 declaringTypes);
    	for (Iterator iter = declaringTypes.iterator(); iter.hasNext();) {
    /**
     * Build a list containing every type between subtype and supertype, inclusively. 
     */
    private void accumulateTypesInBetween(ResolvedType subType, ResolvedType superType, List types) {
    	types.add(subType);
    	if (subType == superType) {
    		return;
    	} else {
    		for (Iterator iter = subType.getDirectSupertypes(); iter.hasNext();) {
    	}
    }
    
    private boolean shouldWalkUpHierarchy() {
    	if (signaturesOfMember.getKind() == Member.CONSTRUCTOR) return false;
    	if (signaturesOfMember.getKind() == Member.FIELD) return false;
    	if (signaturesOfMember.isStatic()) return false;
    	return true;
    }
    
    private boolean findSignaturesFromSupertypes() {
    	iteratingOverDiscoveredSignatures = false;
    	if (superTypeIterator == null) {
    		superTypeIterator = firstDefiningType.getDirectSupertypes();
    	}
    	if (superTypeIterator.hasNext()) {
    		ResolvedType superType = (ResolvedType) superTypeIterator.next();
    		if (visitedSuperTypes.contains(superType)) {
    			return findSignaturesFromSupertypes();
    		} else {
    			// we haven't looked in this type yet
    			visitedSuperTypes.add(superType);
    			if (superType.isMissing()) {
    				// issue a warning, stop looking for join point signatures in this line
    				warnOnMissingType(superType);
    				return findSignaturesFromSupertypes();
    			}
    		}
    	}
    	if (!yetToBeProcessedSuperMembers.isEmpty()) {
    		SearchPair nextUp = (SearchPair) yetToBeProcessedSuperMembers.remove(0);
    		firstDefiningType = nextUp.type;
    		firstDefiningMember = nextUp.member;
    		superTypeIterator = null;
    		return findSignaturesFromSupertypes();
    	}
    	couldBeFurtherAsYetUndiscoveredSignatures = false;
    	return false;
    }
    
    /**
     * Returns true if the parent member is visible to the child member 
     * In the same declaring type this is always true, otherwise if parent is private
     * it is false.
     * @param childMember
     * @param parentMember
     * @return
     */
    private boolean isVisibleTo(ResolvedMember childMember, ResolvedMember parentMember) {
    	if (childMember.getDeclaringType().equals(parentMember.getDeclaringType())) return true;
    	if (Modifier.isPrivate(parentMember.getModifiers())) {
    		return false;
    	} else {
    		return true;
    	}
    }
    
    private void warnOnMissingType(ResolvedType missing) {
    	if (missing instanceof MissingResolvedTypeWithKnownSignature) {
    		// which it should be...
    		MissingResolvedTypeWithKnownSignature mrt = (MissingResolvedTypeWithKnownSignature) missing;
    		mrt.raiseWarningOnJoinPointSignature(signaturesOfMember.toString());
    	}
    }
    
    private static class SearchPair {
    	public ResolvedMember member;
    	public ResolvedType type;
    	public SearchPair(ResolvedMember member, ResolvedType type) {
    		this.member = member;
    		this.type = type;
    	}
    }
======= a4a9090:"weaver/src/org/aspectj/weaver/Member.java"

======= a4a9090:"weaver/src/org/aspectj/weaver/Member.java"

    public Iterator getJoinPointSignatures(World world);
======= a4a9090:"weaver/src/org/aspectj/weaver/MemberImpl.java"

    private JoinPointSignatureIterator joinPointSignatures = null;
======= a4a9090:"weaver/src/org/aspectj/weaver/MemberImpl.java"

======= a4a9090:"weaver/src/org/aspectj/weaver/MemberImpl.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * When we try to resolve a type in the world that we require to be present,
 * and then fail to find it, we return an instance of this class. This class 
 * defers the production of the "can't find type error" until the first time
 * that someone asks a question that can't be answered solely from the signature.
 * This enables the weaver to be more tolerant of missing types.
 *
 */
======= a4a9090:"weaver/src/org/aspectj/weaver/ReferenceType.java"

    	return isAssignableFrom(other,false);
    }
    
    // true iff the statement "this = other" would compile.
    public final boolean isAssignableFrom(ResolvedType other,boolean allowMissing) {
       	if (this.getSignature().equals(ResolvedType.OBJECT.getSignature())) return true;
======= a4a9090:"weaver/src/org/aspectj/weaver/ReferenceType.java"

       	if (allowMissing && other.isMissing()) return false;
       	
            if (this.isAssignableFrom((ResolvedType) i.next(),allowMissing)) return true;
======= a4a9090:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

======= a4a9090:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

======= a4a9090:"weaver/src/org/aspectj/weaver/ResolvedType.java"

    // return true if this resolved type couldn't be found (but we know it's name maybe)
    public boolean isMissing() { return false; }
    
======= a4a9090:"weaver/src/org/aspectj/weaver/ResolvedType.java"

    public List getMethodsWithoutIterator(boolean includeITDs, boolean allowMissing) {
        addAndRecurse(knowninterfaces,methods,this,includeITDs,allowMissing);
    private void addAndRecurse(Set knowninterfaces,List collector, ResolvedType rtx, boolean includeITDs, boolean allowMissing) {
======= a4a9090:"weaver/src/org/aspectj/weaver/ResolvedType.java"

    	  if (superType != null && !superType.isMissing()) {
    		  addAndRecurse(knowninterfaces,collector,superType,includeITDs,allowMissing); // Recurse if we aren't at the top
======= a4a9090:"weaver/src/org/aspectj/weaver/ResolvedType.java"

          if (allowMissing && iface.isMissing()) {
        	if (iface instanceof MissingResolvedTypeWithKnownSignature) {
        		((MissingResolvedTypeWithKnownSignature)iface).raiseWarningOnMissingInterfaceWhilstFindingMethods();
        	}
          } else {
        	  addAndRecurse(knowninterfaces,collector,iface,includeITDs,allowMissing);
          }
======= a4a9090:"weaver/src/org/aspectj/weaver/ResolvedType.java"

     public ResolvedMember lookupResolvedMember(ResolvedMember aMember,boolean allowMissing) {
    		toSearch = getMethodsWithoutIterator(true,allowMissing).iterator();
======= a4a9090:"weaver/src/org/aspectj/weaver/ResolvedType.java"

        
        public boolean isAssignableFrom(ResolvedType o, boolean allowMissing) {
        	return isAssignableFrom(o);
        }
        
======= a4a9090:"weaver/src/org/aspectj/weaver/ResolvedType.java"

        public final boolean isAssignableFrom(ResolvedType other, boolean allowMissing) {
        	return isAssignableFrom(other);
        }        
======= a4a9090:"weaver/src/org/aspectj/weaver/ResolvedType.java"

        
        public final boolean isMissing() { return true; }
        
======= a4a9090:"weaver/src/org/aspectj/weaver/ResolvedType.java"

        public final boolean isAssignableFrom(ResolvedType other, boolean allowMissing) {
            return false;
        }   
======= a4a9090:"weaver/src/org/aspectj/weaver/ResolvedType.java"

    protected void collectInterTypeMungers(List collector) {
======= a4a9090:"weaver/src/org/aspectj/weaver/ResolvedType.java"

======= a4a9090:"weaver/src/org/aspectj/weaver/ResolvedType.java"

======= a4a9090:"weaver/src/org/aspectj/weaver/ResolvedType.java"

======= a4a9090:"weaver/src/org/aspectj/weaver/WeaverMessages.java"

    public static final String CANT_FIND_PARENT_TYPE_NO_SUB = "cantFindParentTypeNoSub";
    public static final String CANT_FIND_TYPE_FIELDS = "cantFindTypeFields";
    public static final String CANT_FIND_TYPE_SUPERCLASS = "cantFindTypeSuperclass";
    public static final String CANT_FIND_TYPE_INTERFACES = "cantFindTypeInterfaces";
    public static final String CANT_FIND_TYPE_METHODS = "cantFindTypeMethods";
    public static final String CANT_FIND_TYPE_POINTCUTS = "cantFindTypePointcuts";
    public static final String CANT_FIND_TYPE_MODIFIERS = "cantFindTypeModifiers";
    public static final String CANT_FIND_TYPE_ANNOTATION = "cantFindTypeAnnotation";
    public static final String CANT_FIND_TYPE_ASSIGNABLE = "cantFindTypeAssignable";
    public static final String CANT_FIND_TYPE_COERCEABLE = "cantFindTypeCoerceable";
    public static final String CANT_FIND_TYPE_JOINPOINT = "cantFindTypeJoinPoint";
    public static final String CANT_FIND_TYPE_INTERFACE_METHODS = "cantFindTypeInterfaceMethods";
======= a4a9090:"weaver/src/org/aspectj/weaver/World.java"

                ret = handleRequiredMissingTypeDuringResolution(ty);
======= a4a9090:"weaver/src/org/aspectj/weaver/World.java"

======= a4a9090:"weaver/src/org/aspectj/weaver/bcel/BcelAccessForInlineMunger.java"

                List methods = callee.getMethodsWithoutIterator(false,true);
======= a4a9090:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

        List methods = newParent.getMethodsWithoutIterator(false,true);
======= a4a9090:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

            List methods = newParent.getMethodsWithoutIterator(false,true);
                    List newParentTargetMethods = newParentTarget.getType().getMethodsWithoutIterator(false,true);
======= a4a9090:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= a4a9090:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

    // only we don't do that because this forces us to find all the supertypes of the type,
======= a4a9090:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= a4a9090:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= a4a9090:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= a4a9090:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= a4a9090:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= a4a9090:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= a4a9090:"weaver/src/org/aspectj/weaver/patterns/TypePatternList.java"

    /*
     * return true iff this pattern could ever match a signature with the
     * given number of parameters
     */
    public boolean canMatchSignatureWithNParameters(int numParams) {
    	if (ellipsisCount == 0) {
    		return numParams == size();
    	} else {
    		return (size() -ellipsisCount) <= numParams;
    	}
    }
    
======= a4a9090:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"


======= 03b20bc:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

======= 03b20bc:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

            WeavingAdaptor weavingAdaptor = WeaverContainer.getWeaver(loader, weavingContext);
======= 03b20bc:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

        static WeavingAdaptor getWeaver(ClassLoader loader, IWeavingContext weavingContext) {
                        weavingAdaptor = new ClassLoaderWeavingAdaptor(loader, weavingContext);
======= 03b20bc:"loadtime/src/org/aspectj/weaver/loadtime/Aj.java"

    
    /*
     * Shared classes methods
     */
    /**
     * Returns a namespace based on the contest of the aspects available
     */
    public String getNamespace (ClassLoader loader) {
        ClassLoaderWeavingAdaptor weavingAdaptor = (ClassLoaderWeavingAdaptor)WeaverContainer.getWeaver(loader, weavingContext);
    	return weavingAdaptor.getNamespace();
    }
    
    /**
     * Check to see if any classes have been generated for a particular classes loader.
     * Calls ClassLoaderWeavingAdaptor.generatedClassesExist()
     * @param loader the class cloder
     * @return       true if classes have been generated.
     */
    public boolean generatedClassesExist(ClassLoader loader){
    	return ((ClassLoaderWeavingAdaptor)WeaverContainer.getWeaver(loader, weavingContext)).generatedClassesExist();
    }
    
    public void flushGeneratedClasses(ClassLoader loader){
    	((ClassLoaderWeavingAdaptor)WeaverContainer.getWeaver(loader, weavingContext)).flushGeneratedClasses();
    }
======= 03b20bc:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

 *   David Knibb		       weaving context enhancments
======= 03b20bc:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= 03b20bc:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

    
    private StringBuffer namespace;
    private IWeavingContext weavingContext;
    public ClassLoaderWeavingAdaptor(final ClassLoader loader, IWeavingContext wContext) {
======= 03b20bc:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

        
        if(wContext==null){
        	weavingContext = new DefaultWeavingContext(loader);
        }else{
        	weavingContext = wContext ;
        }
======= 03b20bc:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

======= 03b20bc:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

            
            String resourcePath = System.getProperty("org.aspectj.weaver.loadtime.configuration",AOP_XML);
    		StringTokenizer st = new StringTokenizer(resourcePath,";");
    		while(st.hasMoreTokens()){
    			Enumeration xmls = weavingContext.getResources(st.nextToken());
    			while (xmls.hasMoreElements()) {
    			    URL xml = (URL) xmls.nextElement();
    			    MessageUtil.info(messageHandler, "using " + xml.getFile());
    			    definitions.add(DocumentParser.parse(xml));
    			}
    		}
======= 03b20bc:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

                	
                	//generate key for SC
                	String aspectCode = readAspect(aspectClassName, loader);
                    if(namespace==null){
                    	namespace=new StringBuffer(aspectCode);
                    }else{
                    	namespace = namespace.append(";"+aspectCode);
                    }
======= 03b20bc:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

    
    /*
     *  shared classes methods
     */
    
    /**
    /**
     * Check to see if any classes are stored in the generated classes cache.
     * Then flush the cache if it is not empty
     * @return true if a class has been generated and is stored in the cache
     */
    public boolean generatedClassesExist(){
    	if(generatedClasses.size()>0) {
    		return true;
    	}
    	return false;
    }
    
    /**
     * Flush the generated classes cache
     */
    public void flushGeneratedClasses(){
    	generatedClasses = new HashMap();
    }
    
    /**
     * Read in an aspect from the disk and return its bytecode as a String
     * @param name	the name of the aspect to read in
     * @return the bytecode representation of the aspect
     */
    private String readAspect(String name, ClassLoader loader){
    	try {
    		String result = "";
        	InputStream is = loader.getResourceAsStream(name.replace('.','/')+".class");
    }
    
======= 03b20bc:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved.
 * This program and the accompanying materials are made available
 * under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution and is available at
 * http://eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   David Knibb         initial implementation
 *******************************************************************************/
 * Use in non-OSGi environment
 * 
 * @author David Knibb
 */
======= 03b20bc:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved.
 * This program and the accompanying materials are made available
 * under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution and is available at
 * http://eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *   David Knibb         initial implementation
 *******************************************************************************/
 * This class adds support to AspectJ for an OSGi environment
 * 
 * @author David Knibb
 */

======= 8a0f59a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= 8a0f59a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 8a0f59a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 8a0f59a:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testParameterizedGenericMethods() {
  }
  
    <ajc-test dir="bugs150" title="parameterized generic methods">
        <compile files="Pr109283.aj" options="-1.5 -warn:indirectStatic">
        </compile>
    </ajc-test> 
    
       <message kind="error" line="7" text="The method m(List&lt;Integer&gt;) in the type Base&lt;Integer&gt; is not applicable for the arguments (List&lt;String&gt;)"/>
       <message kind="error" line="23" text="The method m0(Integer) in the type GenericAspect&lt;A,B&gt;.SimpleI&lt;Integer&gt; is not applicable for the arguments (String)"/>
       <message kind="error" line="24" text="The method m1(List&lt;Integer&gt;) in the type GenericAspect&lt;A,B&gt;.SimpleI&lt;Integer&gt; is not applicable for the arguments (List&lt;String&gt;)"/>
       <message kind="error" line="26" text="The method add(Bottom) in the type List&lt;Bottom&gt; is not applicable for the arguments (Top)"/>
======= 8a0f59a:"weaver/src/org/aspectj/weaver/AjcMemberMaker.java"

======= 8a0f59a:"weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.java"

        LazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perTypeWithinAspectOfMethod(aspectType,classGen.getWorld().isInJava5Mode()));
======= 8a0f59a:"weaver/src/org/aspectj/weaver/bcel/BcelPerClauseAspectAdder.java"

        LazyMethodGen method = makeMethodGen(classGen, AjcMemberMaker.perTypeWithinHasAspectMethod(aspectType,classGen.getWorld().isInJava5Mode()));

======= ca9c1f7:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testUnableToBuildShadows_pr109728() { runTest("Unable to build shadows");}
  public void testMessageOnMissingTypeInDecP() {
  }
    
    <ajc-test dir="bugs150" title="declare parents on a missing type">
        <compile files="Pr76374.aj" options="-1.5">
            <message kind="warning" line="3" text="no match for this type name"/>
        </compile>
    </ajc-test>
    

======= 0e1bb19:"bcel-builder/src/org/aspectj/apache/bcel/generic/InstructionComparator.java"

 * @version $Id: InstructionComparator.java,v 1.3 2005/09/21 16:28:36 acolyer Exp $

======= a39f595:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/AjTypeImpl.java"

======= a39f595:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/PointcutImpl.java"

======= a39f595:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/PointcutImpl.java"

======= a39f595:"aspectj5rt/java5-src/org/aspectj/internal/lang/reflect/PointcutImpl.java"

======= a39f595:"aspectj5rt/java5-src/org/aspectj/lang/annotation/Pointcut.java"

    
    /**
     * When compiling without debug info, or when interpreting pointcuts at runtime,
     * the names of any arguments used in the pointcut are not available.
     * Under these circumstances only, it is necessary to provide the arg names in 
     * the annotation - these MUST duplicate the names used in the annotated method.
     * Format is a simple comma-separated list.
     */
    String argNames() default "";
======= a39f595:"aspectj5rt/java5-src/org/aspectj/lang/reflect/Pointcut.java"

======= a39f595:"bcel-builder/src/org/aspectj/apache/bcel/classfile/JavaClass.java"

 * @version $Id: JavaClass.java,v 1.7 2005/09/21 15:02:05 acolyer Exp $
======= a39f595:"bcel-builder/src/org/aspectj/apache/bcel/classfile/JavaClass.java"

  
  public Method getMethod(java.lang.reflect.Constructor c) {
  
  public Field getField(java.lang.reflect.Field field) {
  }
======= a39f595:"bcel-builder/src/org/aspectj/apache/bcel/generic/Type.java"

 * @version $Id: Type.java,v 1.6 2005/09/21 15:02:04 acolyer Exp $
======= a39f595:"bcel-builder/src/org/aspectj/apache/bcel/generic/Type.java"

  public static String getSignature(java.lang.reflect.Constructor cons) {
  
======= a39f595:"bcel-builder/src/org/aspectj/apache/bcel/generic/Type.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 *
 */
  private Repository bcelRepository;
  private JavaClass jc;
  public void testGetMethod() throws Exception {
  }
  
  public void testGetConstructor() throws Exception {
  }
  
  public void testGetField() throws Exception {
  }
  
  protected void setUp() throws Exception {
  }
  
  protected void tearDown() throws Exception {
  }
  
  private static class GetMe {
  }
======= a39f595:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AtAspectJAnnotationFactory.java"

======= a39f595:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"

======= a39f595:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"

======= a39f595:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDesignator.java"

    private PseudoTokens tokens; 
======= a39f595:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDesignator.java"

    public String getPointcutDeclarationText() {
    	StringBuffer sb = new StringBuffer();
    	PseudoToken[] toks = tokens.tokens;
    	for (int i = 0; i < (toks.length -1); i++) {
    	return sb.toString();
    }
    
======= a39f595:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDesignator.java"

======= a39f595:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testAtAnnotationBindingWithAround() {
  }
  
    public void testUnableToBuildShadows_pr109728() { runTest("Unable to build shadows");}
    
    <ajc-test dir="bugs150" title="@annotation binding with around advice">
        <compile files="AnnotationBinding.aj" options="-1.5"/>
        <run class="AnnotationBinding"/>
    </ajc-test>
======= a39f595:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjAnnotationGenTests.java"

   <ajc-test dir="java5/ataspectj/annotationGen" title="runtime pointcut resolution referencing compiled pointcuts">
        <compile files="PCLib.aj,RuntimePointcuts.java" options="-1.5">
        </compile>
        <run class="RuntimePointcuts"/>
    </ajc-test>          
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * Find the given annotation (if present) on the given object
 *
 */
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 * Provides Java 5 behaviour in reflection based delegates (overriding
 * 1.4 behaviour from superclass where appropriate)
 */
 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 *
 */
======= a39f595:"weaver/src/org/aspectj/weaver/Shadow.java"

======= a39f595:"weaver/src/org/aspectj/weaver/Shadow.java"

    public static final Set ALL_SHADOW_KINDS;   
    	HashSet aSet = new HashSet();
    	ALL_SHADOW_KINDS = Collections.unmodifiableSet(aSet);
======= a39f595:"weaver/src/org/aspectj/weaver/UnresolvedType.java"

    public static UnresolvedType forGenericTypeVariables(String sig, TypeVariable[] tVars) {
      	UnresolvedType ret = UnresolvedType.forSignature(sig);
    	ret.typeKind=TypeKind.GENERIC; 	
    	ret.typeVariables = tVars;
    	ret.signatureErasure = sig;
    	ret.signature = ret.signatureErasure;
    	return ret;
    }
    
======= a39f595:"weaver/src/org/aspectj/weaver/World.java"

======= a39f595:"weaver/src/org/aspectj/weaver/World.java"

    
    private ReferenceType makeGenericTypeFrom(ReferenceTypeDelegate delegate, ReferenceType rawType) {
    	String genericSig = delegate.getDeclaredGenericSignature();
    	if (genericSig != null) {
    		return new ReferenceType(
    	} else {
    		return new ReferenceType(
    				UnresolvedType.forGenericTypeVariables(rawType.getSignature(), delegate.getTypeVariables()),this);
    	}
    }
======= a39f595:"weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java"

======= a39f595:"weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java"

======= a39f595:"weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java"

======= a39f595:"weaver/src/org/aspectj/weaver/internal/tools/PointcutExpressionImpl.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/AndPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/AndPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/AndPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/AndTypePattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/AndTypePattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ConcreteCflowPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ConcreteCflowPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/HasMemberTypePattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/NotPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/NotPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/NotTypePattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/NotTypePattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/OrPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/OrPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/OrPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/OrPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/OrTypePattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/OrTypePattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/PerCflow.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/PerClause.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/PerObject.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/PerSingleton.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/PointcutExpressionMatching.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java"

       
======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/TypePatternList.java"

       
======= a39f595:"weaver/src/org/aspectj/weaver/patterns/TypePatternList.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/TypePatternList.java"

      
======= a39f595:"weaver/src/org/aspectj/weaver/patterns/TypePatternList.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 * Used in 1.4 code to access annotations safely
 */
======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 * Implementation of JoinPointMatch for reflection based worlds.
 */
======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 * A delegate for a resolved type that uses runtime type information (java.lang.reflect)
 * to answer questions. This class uses only Java 1.4 features to answer questions.
 * In a Java 1.5 environment use the Java5ReflectionBasedReferenceTypeDelegate subtype.
 */
======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 * Creates the appropriate ReflectionBasedReferenceTypeDelegate according to
 * the VM level we are running at. Uses reflection to avoid 1.5 dependencies in
 * 1.4 and 1.3 code base.
 */
======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * Subtype of ResolvedMemberImpl used in reflection world.
 * Knows how to get annotations from a java.lang.reflect.Member
 *
 */
======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 *
 */
    	if (getKind().isEnclosingKind()) {
    		return getSignature();
    	} else if (getKind() == Shadow.PreInitialization) {
          // PreInit doesn't enclose code but its signature
          // is correctly the signature of the ctor.
    	  return getSignature();
    	} else if (enclosingShadow == null) {
    		return this.enclosingMember;
    	} else {
    		return enclosingShadow.getSignature();
    	}
======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * A variable at a reflection shadow, used by the residual tests.
 */
======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * A ReflectionWorld is used solely for purposes of type resolution based on 
 * the runtime classpath (java.lang.reflect). It does not support weaving operations
 * (creation of mungers etc..).
 *
 */
======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 * Implementation of ShadowMatch for reflection based worlds.
 */
======= a39f595:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 * The result of asking a ShadowMatch to match at a given join point.
 */
======= a39f595:"weaver/src/org/aspectj/weaver/tools/PointcutExpression.java"

======= a39f595:"weaver/src/org/aspectj/weaver/tools/PointcutExpression.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 * Represents a parameter in a pointcut expression.
 * For example pointcut pc(String s) : .....; has a PointcutParameter of
 * name "s" and type String.
 */
======= a39f595:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

======= a39f595:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

======= a39f595:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

        primitives.add(PointcutPrimitive.AT_ANNOTATION);
        primitives.add(PointcutPrimitive.AT_THIS);
        primitives.add(PointcutPrimitive.AT_TARGET);
        primitives.add(PointcutPrimitive.AT_ARGS);
        primitives.add(PointcutPrimitive.AT_WITHIN);
        primitives.add(PointcutPrimitive.AT_WITHINCODE);
        primitives.add(PointcutPrimitive.REFERENCE);
        
======= a39f595:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    public PointcutParameter createPointcutParameter(String name, Class type) {
    	return new PointcutParameterImpl(name,type);
    }
     * A global scope is assumed for resolving any type references, and the pointcut
     * must contain no formals (variables to be bound).
======= a39f595:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

       return parsePointcutExpression(expression,null,new PointcutParameter[0]);
    }
    
    /**
     * Parse the given pointcut expression.
     * The pointcut is resolved as if it had been declared inside the inScope class
     * (this allows the pointcut to contain unqualified references to other pointcuts
     * declared in the same type for example).
     * The pointcut may contain zero or more formal parameters to be bound at matched
     * join points. 
     * @throws UnsupportedPointcutPrimitiveException if the parser encounters a 
     * primitive pointcut expression of a kind not supported by this PointcutParser.
     * @throws IllegalArgumentException if the expression is not a well-formed 
     * pointcut expression
     */
    public PointcutExpression parsePointcutExpression(
    		String expression, 
    		Class inScope,
    		PointcutParameter[] formalParameters) 
    throws UnsupportedPointcutPrimitiveException, IllegalArgumentException {
    	 PointcutExpressionImpl pcExpr = null;
         try {
             Pointcut pc = new PatternParser(expression).parsePointcut();
             validateAgainstSupportedPrimitives(pc,expression);
             IScope resolutionScope = buildResolutionScope((inScope == null ? Object.class : inScope),formalParameters);
             pc = pc.resolve(resolutionScope);
             ResolvedType declaringTypeForResolution = null;
             if (inScope != null) {
            	 declaringTypeForResolution = world.resolve(inScope.getName());
             } else {
            	 declaringTypeForResolution = ResolvedType.OBJECT.resolve(world);
             }
             IntMap arity = new IntMap(formalParameters.length);
             for (int i = 0; i < formalParameters.length; i++) {
            	 arity.put(i, i);
             }             
        	 pc = pc.concretize(declaringTypeForResolution, declaringTypeForResolution, arity);
             validateAgainstSupportedPrimitives(pc,expression); // again, because we have now followed any ref'd pcuts
             pcExpr = new PointcutExpressionImpl(pc,expression,formalParameters,world);
         } catch (ParserException pEx) {
             throw new IllegalArgumentException(buildUserMessageFromParserException(expression,pEx));
         } catch (ReflectionWorld.ReflectionWorldException rwEx) {
        	 throw new IllegalArgumentException(rwEx.getMessage());
         }
         return pcExpr;
======= a39f595:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

    /* for testing */
    IMessageHandler setCustomMessageHandler(IMessageHandler aHandler) {
    	IMessageHandler current = world.getMessageHandler();
    	world.setMessageHandler(aHandler);
    	return current;
    }
    
    private IScope buildResolutionScope(Class inScope, PointcutParameter[] formalParameters) {
    	if (formalParameters == null) formalParameters = new PointcutParameter[0];
    	FormalBinding[] formalBindings = new FormalBinding[formalParameters.length];
    	for (int i = 0; i < formalBindings.length; i++) {
    	if (inScope == null) {
    		return new SimpleScope(world,formalBindings);
    	} else {
    		ResolvedType inType = world.resolve(inScope.getName());
    		ISourceContext sourceContext = new ISourceContext() {
    			public ISourceLocation makeSourceLocation(IHasPosition position) {
    				return new SourceLocation(new File(""),0);
    			}
    			public ISourceLocation makeSourceLocation(int line, int offset) {
    				return new SourceLocation(new File(""),line);
    			}
    			public int getOffset() {
    				return 0;
    			}
    		};
    		return new AtAjAttributes.BindingScope(inType,sourceContext,formalBindings);
    	}
    }
    
======= a39f595:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

======= a39f595:"weaver/src/org/aspectj/weaver/tools/PointcutParser.java"

        	case Pointcut.ATTHIS_OR_TARGET:
           	    isThis = ((ThisOrTargetAnnotationPointcut)pc).isThis();
        		if (isThis && !supportedPrimitives.contains(PointcutPrimitive.AT_THIS)) {
        		    throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.AT_THIS);
        		} else if (!supportedPrimitives.contains(PointcutPrimitive.AT_TARGET)) {
        		    throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.AT_TARGET);
        		}
        	    break;       	
        	case Pointcut.ATARGS:
        	    if (!supportedPrimitives.contains(PointcutPrimitive.AT_ARGS))
        	        throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.AT_ARGS);
        	    break;
        	case Pointcut.ANNOTATION:
        		if (!supportedPrimitives.contains(PointcutPrimitive.AT_ANNOTATION))
        	        throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.AT_ANNOTATION);
        	    break;        			
        	case Pointcut.ATWITHIN:
        	    if (!supportedPrimitives.contains(PointcutPrimitive.AT_WITHIN))
        	        throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.AT_WITHIN);
        	    break;
        	case Pointcut.ATWITHINCODE:
        	    if (!supportedPrimitives.contains(PointcutPrimitive.AT_WITHINCODE))
        	        throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.AT_WITHINCODE);
        	    break;
        	case Pointcut.REFERENCE:
        	    if (!supportedPrimitives.contains(PointcutPrimitive.REFERENCE))
        	        throw new UnsupportedPointcutPrimitiveException(expression, PointcutPrimitive.REFERENCE);
        	    break;        		
======= a39f595:"weaver/src/org/aspectj/weaver/tools/PointcutPrimitive.java"

======= a39f595:"weaver/src/org/aspectj/weaver/tools/PointcutPrimitive.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * The result of asking a PointcutExpression to match at a shadow (method execution,
 * handler, constructor call, and so on).
 *
 */
======= a39f595:"weaver/testsrc/BcweaverModuleTests15.java"

======= a39f595:"weaver/testsrc/BcweaverModuleTests15.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/patterns/AndOrNotTestCase.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/patterns/AndOrNotTestCase.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/patterns/ArgsTestCase.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/patterns/HandlerTestCase.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/patterns/KindedTestCase.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/patterns/PatternsTests.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/patterns/PointcutTestCase.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

 *               2005 Contributors
======= a39f595:"weaver/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

 *     PARC     initial implementation
 *     Adrian Colyer, runtime reflection extensions 
======= a39f595:"weaver/testsrc/org/aspectj/weaver/patterns/ThisOrTargetTestCase.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/patterns/WithinCodeTestCase.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/patterns/WithinTestCase.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/patterns/WithinTestCase.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
======= a39f595:"weaver/testsrc/org/aspectj/weaver/patterns/WithinTestCase.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
======= a39f595:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/tools/PointcutExpressionTest.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java"

======= a39f595:"weaver/testsrc/org/aspectj/weaver/tools/PointcutParserTest.java"

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *  
 * Contributors: 
 *   Adrian Colyer			Initial implementation
 * ******************************************************************/
 * @author colyer
 * Part of the testdata for the org.aspectj.weaver.reflect tests
 */

======= 87e5c2e:"bcel-builder/src/org/aspectj/apache/bcel/classfile/ClassParser.java"

 * @version $Id: ClassParser.java,v 1.3 2005/09/14 11:10:57 aclement Exp $
======= 87e5c2e:"bcel-builder/src/org/aspectj/apache/bcel/classfile/ClassParser.java"

    // don't police it like this... leave higher level verification code to check it.
======= 87e5c2e:"bcel-builder/src/org/aspectj/apache/bcel/classfile/ClassParser.java"

======= 87e5c2e:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testFinalAbstractClass_pr109486() { runTest("Internal compiler error (ClassParser.java:242)");}
  
    <ajc-test dir="bugs150" pr="109486" title="Internal compiler error (ClassParser.java:242)">
        <compile files="PR109486.java" >
          <message kind="error" line="1" text="The class PR109486 can be either abstract or final, not both"/>
        </compile>
    </ajc-test>  
    

  before(): !@annotation(AroundAdvice) && execution(* C.*(..)) { }
  public static void m1() {}
  @AroundAdvice public static void m2() {}
  public void m3() {}
  @AroundAdvice public void m4() {}
======= 2ae4f53:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  
  
  public void testAtAnnotationBadTest_pr103740() {
  }
  
    <ajc-test dir="bugs150/pr103740" pr="103740" title="Compiler failure on at_annotation">
     <compile files="AroundAdvice.aj" options="-1.5,-showWeaveInfo">
       <message kind="weave" text="Join point 'method-execution(void C.m1())' in Type 'C' (AroundAdvice.aj:12) advised by before advice from 'ErrorHandling' (AroundAdvice.aj:8)"/>
    </ajc-test>
======= 2ae4f53:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= 2ae4f53:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"


======= 2942ca0:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 2942ca0:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 2942ca0:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

  class Inner { // works if static
    private Integer field;
    void bug() {
      field = new Integer(0);
    }
  }
  public static void main(String[] args) {
    new pr106874().new Inner().bug();
  }
  before(Object t) :
    // target(Object) && // works
    // this(t) && // works
    target(t) && // fails
    // set(* Bug.Inner.field) // works
    // set(Integer Bug.Inner.*) // works
    // get(* Bug.Inner.*) // works
    set(* pr106874.Inner.*) // fails
  {}
======= 2942ca0:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

    public <T> T[] method(T[] array) {
        return null;
    }
======= 2942ca0:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  
  public void testCantFindTypeErrorWithGenericReturnTypeOrParameter() {
  }
        <compile files="pr106874.aj" options="-1.5" >
        </compile>
        <run class="pr106874"/>    
    <ajc-test dir="bugs150" pr="108826" title="cant find type error with generic return type or parameter">
        <compile files="pr108826.aj" options="-1.5 -emacssym" >
        </compile>
    </ajc-test> 

       class Node {
               int value;
               Node(int v)
               {
                       value = v;
               }
       }
       public VerifyErrorOnSet()
       {
               new Node(1);
       }
       public static void main(String[] args) {
    	   VerifyErrorOnSet l = new VerifyErrorOnSet();
       }
 
       pointcut setField(Object t) : target(t) && set(* VerifyErrorOnSet.Node+.*);
       
       before(Object t) : setField(t) {
               System.out.println("WRITE");
               // Do something with t...
       }
       
======= a9ca915:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  
  public void testNoVerifyErrorWithSetOnInnerType() {
  }
    
    <ajc-test dir="bugs150" pr="109124" title="no verify error with set on inner type">
        <compile files="VerifyErrorOnSet.aj" options="-1.5" >
        </compile>
        <run class="test.VerifyErrorOnSet"/>
    </ajc-test>  
        
    
======= a9ca915:"weaver/src/org/aspectj/weaver/bcel/BcelField.java"

======= a9ca915:"weaver/src/org/aspectj/weaver/bcel/BcelField.java"


======= 5187437:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"


======= 2d21db0:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= 2d21db0:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= 2d21db0:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 2d21db0:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 2d21db0:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 2d21db0:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 2d21db0:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

======= 2d21db0:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

======= 2d21db0:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

======= 2d21db0:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

            <message kind="error" line="8" text="can't override final void A$TestInterface.m()"></message>
======= 2d21db0:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

======= 2d21db0:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

======= 2d21db0:"weaver/src/org/aspectj/weaver/ResolvedType.java"


======= 08d6a5d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= 08d6a5d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

    
    public void unusedArgument(LocalDeclaration localDecl) {
    	// don't warn if this is an aj synthetic arg
    	String argType = new String(localDecl.type.resolvedType.signature());
    	if (argType.startsWith("Lorg/aspectj/runtime/internal")) return;
    	super.unusedArgument(localDecl);
    }
======= 08d6a5d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

    private static PlayList instance;
    
    private List<Song> list;
    
    private PlayList() {
        list = new ArrayList<Song>();         
    }
    public static PlayList instance() {
        if(instance==null ) {
            instance = new PlayList();
        }
        return instance;
    }
    public void enqueue(Song song) {
        list.add(song);
        if(Player.instance().isIdle()) {
            new Thread() {
                public void run() {
                    System.out.println("Playing playlist...");
                    for (Song s : list) {
                        Player.instance().play(s.getName());
                    }
                }  
            }.start();            
        }
    }
    private String name; 
    public Song(String name) {
        this.name = name;
    }
    public String getName() {
        return name;
    }
    private static Player instance;
    
    private Player() {}
    public static Player instance() {
        if(instance==null ) {
            instance = new Player();
        }
        return instance;
    }
    public void play(String name) {
        System.out.println("Playing Song "+name+"...");
    }
    public boolean isIdle() {
        return true;
    }
    
    public static void main(String[] args) {
        Song song = new Song("Merry XMas");
        Jukebox jukebox = new Jukebox();
        
        jukebox.play(song);
    }
    
    
    void around(Song song) :
        call(public void Jukebox.play(Song))
        && args(song) {
        PlayList.instance().enqueue(song);
    }
    void around() : call(public void Jukebox.play(Song)) {
        if(Credits.instance().enoughCredits()) {
            System.out.println("Withdrawing credit.");
            Credits.instance().withDraw();
            proceed();
        } else {
            throw new InsufficientCreditsException();
        }
    }
    
    private static final int INITIAL_CREDITS = 10;
    private static Credits instance;
    
    private int credits;
    
    private Credits() {
        credits = INITIAL_CREDITS;        
    }
    
    public static Credits instance() {
        if(instance==null ) {
            instance = new Credits();
        }
        return instance;
    }
    public boolean enoughCredits() {
        return credits > 0;
    }
    
    public void withDraw() {
        credits--;
    }
    public InsufficientCreditsException() {
        super();
    }
    public InsufficientCreditsException(String message, Throwable cause) {
        super(message, cause);
    }
    public InsufficientCreditsException(String message) {
        super(message);
    }
    /**
     * @param cause
     */
    public InsufficientCreditsException(Throwable cause) {
        super(cause);
    }
======= 08d6a5d:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  
  public void testNoUnusedParameterWarningsForSyntheticAdviceArgs() {
  }
    <ajc-test dir="bugs150" pr="109042" title="no unused parameter warnings for synthetic advice args">
        <compile files="pr109042.aj" options="-warn:+unusedArgument -warn:+unusedPrivate -warn:+unusedImport -1.5">
        </compile>
    </ajc-test>  

======= 2505485:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

        // XXX AMC we need to do this, but I'm not 100% comfortable as I don't
        // know why the return type is wrong in this case. Also, we don't seem to need
        // to do it for args...
        if (munger.getSignature().getReturnType().isRawType()) {
        	if (!binding.returnType.isRawType()) {
        		binding.returnType = world.makeTypeBinding(munger.getSignature().getReturnType()); 
        	}
        }
======= 2505485:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

======= 2505485:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

 public void update();
======= 2505485:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

 
  public Collection aCollection;	
======= 2505485:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

 public void addObserver(Observer observer);
 public void removeObserver(Observer observer);
 public Collection getObservers();
======= 2505485:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

     
     public void print() {  }
   declare parents : SalesOrder extends Order;
   public void SalesOrder.print()
   {
      super.print();  //  Line 12
   }
   protected pointcut print(Order order) : target(order) && call(public void print());
======= 2505485:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testNoTypeMismatchOnSameGenericTypes() {
  }
  
  public void testSuperCallInITD() {
  }
    <ajc-test dir="bugs150/pr108902" pr="108902" title="no type mismatch on generic types in itds">
        <compile files="Subject.java,Observer.java,ObserverProtocol.aj" >
        </compile>
    </ajc-test>   
    <ajc-test dir="bugs150" pr="108903" title="super call in ITD">
        <compile files="pr108903.aj" >
            <message kind="error" line="14" text="The method print() is undefined for the type Object"/>
        </compile>
    </ajc-test>  

    after(Object controller) returning (Object foo): 
      cflow(adviceexecution() && args(controller, ..) && this(BadAdvice)) && 
      call(Bar+.new(..)) 
    {
    }    
    
    Object around(Object controller) : call(* whoKnows()) && target(controller) 
    {
        return new Bar();
    }
    
    public static void main(String args[]) {
        (new Bar()).whoKnows();
    }
    void whoKnows() {}
======= 71771ab:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testAdviceOnCflow() {
  }
 
    <ajc-test dir="bugs150" pr="108816" title="advising cflow advice execution">
        <compile files="pr108816.aj" >
        </compile>
    </ajc-test>   
======= 71771ab:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= 71771ab:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"


======= df46c6f:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testITDOnInterfaceWithExistingMember() {
  }
  
    
    <ajc-test dir="bugs150/pr99125" pr="99125" title="itd interface method already existing on interface">
        <compile files="p/pr99125.aj,p/I.java,p/J.java" options="-1.5">
        </compile>
        <compile files="Aspects.aj" options="-inpath p"/>
        <run class="p.pr99125"/>
        <compile files="p2/pr99125.aj,p/I.java,p/J.java"/> <!-- actually in package p, introduces incompatible change -->
        <compile files="Aspects.aj" options="-inpath p">
            <message kind="error" line="7" text="inter-type declaration from X conflicts with existing member"/>
        </compile>
    </ajc-test>
    
======= df46c6f:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= df46c6f:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"


======= 2c88c59:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

    public void unusedPrivateMethod(AbstractMethodDeclaration methodDecl) {
    	// don't output unused warnings for pointcuts...
    	if (!(methodDecl instanceof PointcutDeclaration))
    			super.unusedPrivateMethod(methodDecl);
    }
======= 2c88c59:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= 2c88c59:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testNoWarningOnUnusedPointcut() {
  }
  
    <ajc-test dir="bugs150" pr="101606" title="unused private pointcuts">
        <compile files="pr101606.aj" options="-warn:unusedPrivate">
        </compile>
    </ajc-test>
             

======= b17ff4e:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testSynchronizedITDInterfaceMethods() {
  }
  
    <ajc-test dir="bugs150" pr="102212" title="synchronized itd interface methods">
        <compile files="SynchronizedInterfaceMethods.aj" options="-1.5">
        </compile>
        <run class="SynchronizedInterfaceMethods"/>
    </ajc-test>
======= b17ff4e:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= b17ff4e:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= b17ff4e:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= b17ff4e:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    
    public void setAccessFlags(int newFlags) {
    	this.accessFlags = newFlags;
    }

  private interface Test {
    Object getId();
    int hashCode();
  }
 
  public int Test.hashCode() {
    return getId().hashCode();
  }
 
  declare parents : ReturnTypeTester implements Test;
  static Set<ReturnTypeTester> set = new HashSet<ReturnTypeTester>();
  static {
    ReturnTypeTester tester = new ReturnTypeTester();
    set.add(tester);
  }
 
  public String getId() {
    return "id";
  }
  private interface Test {
    Object getId();
    int hashCode();
  }
 
  public int Test.hashCode() {
    return getId().hashCode();
  }
 
  declare parents : ReturnTypeTester implements Test;
  static Set<ReturnTypeTester> set = new HashSet<ReturnTypeTester>();
  static {
    ReturnTypeTester tester = new ReturnTypeTester();
    set.add(tester);
  }
 
  public String getId() {
    return "id";
  }
======= 047173e:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testOverrideAndCovarianceWithDecPRuntime() {
  }
  
  public void testOverrideAndCovarianceWithDecPRuntimeMultiFiles() {
  }
    <ajc-test dir="bugs150" pr="105479" title="override and covariance with decp - runtime">
        <compile files="pr105479part2.aj" options="-1.5"/>
        <run class="pr105479part2">
            <stdout>
                <line text="in Test.hashCode()"/>
                <line text="in Test.hashCode()"/>
                <line text="id"/>
                <line text="in Test.hashCode()"/>
            </stdout>
        </run>
    </ajc-test>
    <ajc-test dir="bugs150/pr105479" pr="105479" title="override and covariance with decp - runtime separate files">
        <compile files="ReturnTypeTest.aj,ReturnTypeTester.java,Driver.java" options="-1.5"/>
        <run class="Driver">
            <stdout>
                <line text="in Test.hashCode()"/>
                <line text="in Test.hashCode()"/>
                <line text="id"/>
                <line text="in Test.hashCode()"/>
            </stdout>
        </run>
    </ajc-test>
         
======= 047173e:"tests/src/org/aspectj/systemtest/xlint/XLintTests.java"

  
  public void testBug99136(){
  }
    <ajc-test dir="harness" 
        title="Two Xlint warnings wth cflow?">
        <compile files="XLintcflow.java" options="-1.5">
        	<message kind="warning" line="4"  text="advice defined in A has not been applied [Xlint:adviceDidNotMatch]"/>
        </compile>
    </ajc-test>
======= 047173e:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

        requestor.weaveCompleted();
    	return wovenClassNames;
    }
    /**
     * In 1.5 mode and with XLint:adviceDidNotMatch enabled, put out messages for any
     * mungers that did not match anything.
     */
        	Set alreadyWarnedLocations = new HashSet();
        	
======= 047173e:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 047173e:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


======= ad753aa:"bcel-builder/src/org/aspectj/apache/bcel/classfile/GenericSignatureParser.java"

======= ad753aa:"bcel-builder/src/org/aspectj/apache/bcel/classfile/GenericSignatureParser.java"

 * GenericsError.java
 *
 * Created on September 1, 2005, 9:36 AM
 *
 */
  public Collection<String> test(
      boolean arg1,
      boolean arg2,
      Object arg3) ;
 * GenericsErrorImpl.java
 *
 * Created on September 1, 2005, 9:37 AM
 *
 */
  public Collection<String> test(
      boolean arg1,
      boolean arg2,
      Object arg3)  { return null; }
 
======= ad753aa:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testParsingOfGenericTypeSignature() {
  }
  
 
    <ajc-test dir="bugs150" pr="108602" title="parse generic type signature with parameterized type in interface">
        <compile files="pr108602.java" options="-1.5"/>
    </ajc-test>
     

======= 619f8bc:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 619f8bc:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    	if (hasDeclaredLineNumberInfo()) {
    		return memberView.getDeclarationOffset();
    	} else {
    		return 0;
    	}
    
======= 619f8bc:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"


======= c6bc7a2:"bridge/src/org/aspectj/bridge/WeaveMessage.java"

    // %7 is information like "[with runtime test]"
======= c6bc7a2:"tests/java5/ataspectj/ataspectj/ltwlog/MainVerboseAndShow.java"

                "weaveinfo Join point 'method-execution(void ataspectj.ltwlog.MainVerboseAndShow.target())' in Type 'ataspectj.ltwlog.MainVerboseAndShow' (MainVerboseAndShow.java:22) advised by before advice from 'ataspectj.ltwlog.Aspect1' (Aspect1.java)",
======= c6bc7a2:"weaver/src/org/aspectj/weaver/Shadow.java"


======= a5e645f:"runtime/src/org/aspectj/runtime/reflect/Factory.java"

======= a5e645f:"runtime/src/org/aspectj/runtime/reflect/Factory.java"

    static Hashtable prims = new Hashtable();
    static {
        prims.put("void", Void.TYPE);
        prims.put("boolean", Boolean.TYPE);
        prims.put("byte", Byte.TYPE);
        prims.put("char", Character.TYPE);
        prims.put("short", Short.TYPE);
        prims.put("int", Integer.TYPE);
        prims.put("long", Long.TYPE);
        prims.put("float", Float.TYPE);
        prims.put("double", Double.TYPE);
    }
        
    static Class makeClass(String s, ClassLoader loader) {
        if (s.equals("*")) return null;
        Class ret = (Class)prims.get(s);
        if (ret != null) return ret;
        try {
            /* The documentation of Class.forName explains why this is the right thing
             * better than I could here.
             */
            if (loader == null) {
                return Class.forName(s);
            } else {
            	// used to be 'return loader.loadClass(s)' but that didn't cause
            	// array types to be created and loaded correctly. (pr70404)
                return Class.forName(s,false,loader);
            }
        } catch (ClassNotFoundException e) {
            //System.out.println("null for: " + s);
            //XXX there should be a better return value for this
            return ClassNotFoundException.class;
        }
    }
    
======= a5e645f:"runtime/src/org/aspectj/runtime/reflect/Factory.java"

    
    
======= a5e645f:"runtime/src/org/aspectj/runtime/reflect/Factory.java"

    
   	public MethodSignature makeMethodSig(String modifiers, String methodName, String declaringType, String paramTypes, String paramNames, String exceptionTypes, String returnType) {
   		int modifiersAsInt = Integer.parseInt(modifiers, 16);
   
   		Class declaringTypeClass = makeClass(declaringType,lookupClassLoader);
   
   		StringTokenizer st = new StringTokenizer(paramTypes, ":");
   		int numParams = st.countTokens();
   		Class[] paramTypeClasses = new Class[numParams];
   		for(int i = 0; i < numParams; i++) paramTypeClasses[i] = makeClass(st.nextToken(),lookupClassLoader);
   
   		st = new StringTokenizer(paramNames, ":");
   		numParams = st.countTokens();
   		String[] paramNamesArray = new String[numParams];
   		for(int i = 0; i < numParams; i++) paramNamesArray[i] = st.nextToken();
   			
   		st = new StringTokenizer(exceptionTypes, ":");
   		numParams = st.countTokens();
   		Class[] exceptionTypeClasses = new Class[numParams];
   		for(int i = 0; i < numParams; i++) exceptionTypeClasses[i] = makeClass(st.nextToken(),lookupClassLoader);
   
   		Class returnTypeClass = makeClass(returnType,lookupClassLoader);
   
   		MethodSignatureImpl ret =
   			new MethodSignatureImpl(modifiersAsInt, methodName, declaringTypeClass, paramTypeClasses, paramNamesArray, exceptionTypeClasses, returnTypeClass);
   
   		return ret;
   	}
   	
======= a5e645f:"runtime/src/org/aspectj/runtime/reflect/Factory.java"

    public ConstructorSignature makeConstructorSig(String modifiers, String declaringType, String paramTypes, String paramNames, String exceptionTypes) {
    	
    	ConstructorSignatureImpl ret = new ConstructorSignatureImpl(modifiersAsInt, declaringTypeClass, paramTypeClasses, paramNamesArray, exceptionTypeClasses);
    	ret.setLookupClassLoader(lookupClassLoader);
    	return ret;
   }
     
    
======= a5e645f:"runtime/src/org/aspectj/runtime/reflect/Factory.java"

    
    public FieldSignature makeFieldSig(String modifiers, String name, String declaringType, String fieldType) {
    	int modifiersAsInt = Integer.parseInt(modifiers, 16);
    	Class declaringTypeClass = makeClass(declaringType,lookupClassLoader);
    	Class fieldTypeClass = makeClass(fieldType,lookupClassLoader);
    			
    	FieldSignatureImpl ret = new FieldSignatureImpl(modifiersAsInt, name, declaringTypeClass, fieldTypeClass);
    	ret.setLookupClassLoader(lookupClassLoader);
    	return ret;
    }
    
======= a5e645f:"runtime/src/org/aspectj/runtime/reflect/Factory.java"

    public AdviceSignature makeAdviceSig(String modifiers, String name, String declaringType, String paramTypes, String paramNames, String exceptionTypes, String returnType) {
    	int modifiersAsInt = Integer.parseInt(modifiers, 16);
    	
    	Class declaringTypeClass = makeClass(declaringType,lookupClassLoader);
    		
    	StringTokenizer st = new StringTokenizer(paramTypes, ":");
    	int numParams = st.countTokens();
    	Class[] paramTypeClasses = new Class[numParams];
    	for(int i = 0; i < numParams; i++) paramTypeClasses[i] = makeClass(st.nextToken(),lookupClassLoader);
    	
    	st = new StringTokenizer(paramNames, ":");
    	numParams = st.countTokens();
    	String[] paramNamesArray = new String[numParams];
    	for(int i = 0; i < numParams; i++) paramNamesArray[i] = st.nextToken();
    	
    	st = new StringTokenizer(exceptionTypes, ":");
    	numParams = st.countTokens();
    	Class[] exceptionTypeClasses = new Class[numParams];
    	for(int i = 0; i < numParams; i++) exceptionTypeClasses[i] = makeClass(st.nextToken(),lookupClassLoader);;
    	
    	Class returnTypeClass = makeClass(returnType,lookupClassLoader);
    			
    	AdviceSignatureImpl ret = new AdviceSignatureImpl(modifiersAsInt, name, declaringTypeClass, paramTypeClasses, paramNamesArray, exceptionTypeClasses, returnTypeClass);
    	ret.setLookupClassLoader(lookupClassLoader);
    	return ret;
    }
    
======= a5e645f:"runtime/src/org/aspectj/runtime/reflect/Factory.java"

    public InitializerSignature makeInitializerSig(String modifiers, String declaringType) {
    	int modifiersAsInt = Integer.parseInt(modifiers, 16);
    	Class declaringTypeClass = makeClass(declaringType,lookupClassLoader);
    		
    	InitializerSignatureImpl ret = new InitializerSignatureImpl(modifiersAsInt, declaringTypeClass);
    	ret.setLookupClassLoader(lookupClassLoader);
    	return ret;
    }
    
======= a5e645f:"runtime/src/org/aspectj/runtime/reflect/Factory.java"

 
    public CatchClauseSignature makeCatchClauseSig(String declaringType, String parameterType, String parameterName) {
    	Class declaringTypeClass = makeClass(declaringType,lookupClassLoader);
    		
    	StringTokenizer st = new StringTokenizer(parameterType, ":");
    	Class parameterTypeClass = makeClass(st.nextToken(),lookupClassLoader);
    
    	st = new StringTokenizer(parameterName, ":");
    	String parameterNameForReturn = st.nextToken();
    
       	CatchClauseSignatureImpl ret = new CatchClauseSignatureImpl(declaringTypeClass, parameterTypeClass, parameterNameForReturn);
       	ret.setLookupClassLoader(lookupClassLoader);
      	return ret;
    }
======= a5e645f:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

======= a5e645f:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

        return Factory.makeClass(s,getLookupClassLoader());
 
======= a5e645f:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

        for (int i = 0; i < N; i++) ret[i]= Factory.makeClass(st.nextToken(),getLookupClassLoader());
======= a5e645f:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

    	if (sig.getKind().equals(Member.METHOD)) {
    		BcelWorld w = shadow.getWorld();
    		// For methods, push the parts of the signature on.
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getModifiers(w))));
    		list.append(new PUSH(getConstantPoolGen(),sig.getName()));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getDeclaringType())));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getParameterTypes())));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getParameterNames(w))));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getExceptions(w))));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getReturnType())));
    		// And generate a call to the variant of makeMethodSig() that takes 7 strings
    		list.append(fact.createInvoke(factoryType.getClassName(), 
    				sig.getSignatureMakerName(),
    				new ObjectType(sig.getSignatureType()),
    				new Type[] { Type.STRING,Type.STRING,Type.STRING,Type.STRING,Type.STRING,Type.STRING,Type.STRING },
    				Constants.INVOKEVIRTUAL));
    	} else if (sig.getKind().equals(Member.HANDLER)) {
    		BcelWorld w = shadow.getWorld();
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getDeclaringType())));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getParameterTypes())));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getParameterNames(w))));
    		list.append(fact.createInvoke(factoryType.getClassName(),
    				sig.getSignatureMakerName(),
    				new ObjectType(sig.getSignatureType()),
    				new Type[] { Type.STRING, Type.STRING, Type.STRING },
    				Constants.INVOKEVIRTUAL));    	
    	} else if(sig.getKind().equals(Member.CONSTRUCTOR)) {
    		BcelWorld w = shadow.getWorld();
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getModifiers(w))));	
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getDeclaringType())));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getParameterTypes())));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getParameterNames(w))));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getExceptions(w))));
    		list.append(fact.createInvoke(factoryType.getClassName(),
    				sig.getSignatureMakerName(),
    				new ObjectType(sig.getSignatureType()),
    				new Type[] { Type.STRING, Type.STRING, Type.STRING, Type.STRING, Type.STRING },
    				Constants.INVOKEVIRTUAL));    	
    	} else if(sig.getKind().equals(Member.FIELD)) {
    		BcelWorld w = shadow.getWorld();
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getModifiers(w))));
    		list.append(new PUSH(getConstantPoolGen(),sig.getName()));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getDeclaringType())));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getReturnType())));
    		list.append(fact.createInvoke(factoryType.getClassName(),
    				sig.getSignatureMakerName(),
    				new ObjectType(sig.getSignatureType()),
    				new Type[] { Type.STRING, Type.STRING, Type.STRING, Type.STRING },
    				Constants.INVOKEVIRTUAL));    	
    	} else if(sig.getKind().equals(Member.ADVICE)) {
    		BcelWorld w = shadow.getWorld();
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getModifiers(w))));
    		list.append(new PUSH(getConstantPoolGen(),sig.getName()));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getDeclaringType())));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getParameterTypes())));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getParameterNames(w))));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getExceptions(w))));
    		list.append(new PUSH(getConstantPoolGen(),makeString((sig.getReturnType()))));    		
    		list.append(fact.createInvoke(factoryType.getClassName(),
    				sig.getSignatureMakerName(),
    				new ObjectType(sig.getSignatureType()),
    				new Type[] { Type.STRING, Type.STRING, Type.STRING, Type.STRING, Type.STRING, Type.STRING, Type.STRING },
    				Constants.INVOKEVIRTUAL));    	
    	} else if(sig.getKind().equals(Member.STATIC_INITIALIZATION)) {
    		BcelWorld w = shadow.getWorld();
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getModifiers(w))));
    		list.append(new PUSH(getConstantPoolGen(),makeString(sig.getDeclaringType())));
    		list.append(fact.createInvoke(factoryType.getClassName(),
    				sig.getSignatureMakerName(),
    				new ObjectType(sig.getSignatureType()),
    				new Type[] { Type.STRING, Type.STRING },
    				Constants.INVOKEVIRTUAL));
    	} else {
    	  list.append(new PUSH(getConstantPoolGen(), sig.getSignatureString(shadow.getWorld())));
    	  list.append(fact.createInvoke(factoryType.getClassName(), 
    	}   	
======= a5e645f:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

    
    protected String makeString(int i) {
    	return Integer.toString(i, 16);  //??? expensive
    }
    
    
    protected String makeString(UnresolvedType t) {
    	// this is the inverse of the odd behavior for Class.forName w/ arrays
    	if (t.isArray()) {
    		// this behavior matches the string used by the eclipse compiler for Foo.class literals
    		return t.getSignature().replace('/', '.');
    	} else {
    		return t.getName();
    	}
    }
          
    protected String makeString(UnresolvedType[] types) {
    	if (types == null) return "";
    	StringBuffer buf = new StringBuffer();
    	for (int i = 0, len=types.length; i < len; i++) {
    		buf.append(makeString(types[i]));
    		buf.append(':');
    	}
    	return buf.toString();
    }
       
    protected String makeString(String[] names) {
    	if (names == null) return "";
    	StringBuffer buf = new StringBuffer();
    	for (int i = 0, len=names.length; i < len; i++) {
    		buf.append(names[i]);
    		buf.append(':');
    	}
    	return buf.toString();
    } 
       
                    LDC "1"
                    LDC "HelloWorld"
                    LDC ""
                    LDC ""
                    LDC ""
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeConstructorSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/ConstructorSignature;
                    LDC "9"
                    LDC "main"
                    LDC "HelloWorld"
                    LDC "[Ljava.lang.String;:"
                    LDC "args:"
                    LDC ""
                    LDC "void"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeMethodSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/MethodSignature;
                    LDC "1"
                    LDC "HelloWorld"
                    LDC ""
                    LDC ""
                    LDC ""
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeConstructorSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/ConstructorSignature;
                    LDC "19"
                    LDC "out"
                    LDC "java.lang.System"
                    LDC "java.io.PrintStream"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeFieldSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/FieldSignature;
                    LDC "1"
                    LDC "println"
                    LDC "java.io.PrintStream"
                    LDC "java.lang.String:"
                    LDC "arg0:"
                    LDC ""
                    LDC "void"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeMethodSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/MethodSignature;
                    LDC "9"
                    LDC "main"
                    LDC "HelloWorld"
                    LDC "[Ljava.lang.String;:"
                    LDC "args:"
                    LDC ""
                    LDC "void"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeMethodSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/MethodSignature;
                    LDC "1"
                    LDC "HelloWorld"
                    LDC ""
                    LDC ""
                    LDC ""
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeConstructorSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/ConstructorSignature;
                    LDC "19"
                    LDC "out"
                    LDC "java.lang.System"
                    LDC "java.io.PrintStream"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeFieldSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/FieldSignature;
                    LDC "1"
                    LDC "println"
                    LDC "java.io.PrintStream"
                    LDC "java.lang.String:"
                    LDC "arg0:"
                    LDC ""
                    LDC "void"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeMethodSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/MethodSignature;
                    LDC "9"
                    LDC "main"
                    LDC "HelloWorld"
                    LDC "[Ljava.lang.String;:"
                    LDC "args:"
                    LDC ""
                    LDC "void"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeMethodSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/MethodSignature;
                    LDC "1"
                    LDC "HelloWorld"
                    LDC ""
                    LDC ""
                    LDC ""
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeConstructorSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/ConstructorSignature;
                    LDC "19"
                    LDC "out"
                    LDC "java.lang.System"
                    LDC "java.io.PrintStream"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeFieldSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/FieldSignature;
                    LDC "1"
                    LDC "println"
                    LDC "java.io.PrintStream"
                    LDC "java.lang.String:"
                    LDC "arg0:"
                    LDC ""
                    LDC "void"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeMethodSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/MethodSignature;
                    LDC "9"
                    LDC "main"
                    LDC "HelloWorld"
                    LDC "[Ljava.lang.String;:"
                    LDC "args:"
                    LDC ""
                    LDC "void"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeMethodSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/MethodSignature;
                    LDC "1"
                    LDC "HelloWorld"
                    LDC ""
                    LDC ""
                    LDC ""
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeConstructorSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/ConstructorSignature;
                    LDC "19"
                    LDC "out"
                    LDC "java.lang.System"
                    LDC "java.io.PrintStream"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeFieldSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/FieldSignature;
                    LDC "1"
                    LDC "println"
                    LDC "java.io.PrintStream"
                    LDC "java.lang.String:"
                    LDC "arg0:"
                    LDC ""
                    LDC "void"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeMethodSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/MethodSignature;
                    LDC "9"
                    LDC "main"
                    LDC "HelloWorld"
                    LDC "[Ljava.lang.String;:"
                    LDC "args:"
                    LDC ""
                    LDC "void"
                    INVOKEVIRTUAL org.aspectj.runtime.reflect.Factory.makeMethodSig (Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;Ljava/lang/String;)Lorg/aspectj/lang/reflect/MethodSignature;

======= 16512b2:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= 16512b2:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= 16512b2:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

    
    public void unusedPrivateType(TypeDeclaration typeDecl) {
    	// don't output unused type warnings for aspects!
    	if (!(typeDecl instanceof AspectDeclaration))
    		super.unusedPrivateType(typeDecl);
    }
======= 16512b2:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= 16512b2:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testNoUnusedWarningsOnAspectTypes() {
  }
  
    <ajc-test dir="bugs150" pr="74048" title="no unused warnings on aspect types">
        <compile files="pr74048.aj" options="-warn:unusedPrivate"/>
    </ajc-test>  
  

   pointcut call_m(int a, int b) : call(int *.m(..)) && args(a, b);
 
   int m(int p, int q) { return 2; }
   
   void foo() {
   }
   
   int around(int x, int y) : call_m(x, y) {  return 5; }
 
   before(int x, int y) : 
       adviceexecution() && within(some_aspect) &&  args(x, y) {
   }
======= a66e0a2:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testArgsGeneratedCorrectlyForAdviceExecution() {
  }
  
 
    <ajc-test dir="bugs150" pr="59196" title="args generated correctly for advice execution join point">
        <compile files="pr59196.aj" options="-XnoInline -1.5"/>
    </ajc-test>  
======= a66e0a2:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= a66e0a2:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= a66e0a2:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= a66e0a2:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"


======= 7e0c3cd:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testVisibiltyInSignatureMatchingWithOverridesPart1() {
  }
  public void testVisibiltyInSignatureMatchingWithOverridesPart2() {
  }
  public void testVisibiltyInSignatureMatchingWithOverridesPart3() {
  }
  
    <ajc-test dir="bugs150/pr71159" pr="71159" title="visibility in signature matching with overrides - 1">
        <compile files="pr71159.aj">
            <message kind="warning" line="26" text="should match"/>
        </compile>
    </ajc-test>  
    <ajc-test dir="bugs150/pr71159" pr="71159" title="visibility in signature matching with overrides - 2">
        <compile files="PrivateITD.aj">
            <message kind="warning" line="28" text="should match"/>
        </compile>
    </ajc-test>  
    <ajc-test dir="bugs150/pr71159" pr="71159" title="visibility in signature matching with overrides - 3">
        <compile files="pkg1/A.java,pkg1/B.java,pkg1/C.java,pkg2/ITDInDiffPackage.aj">
            <message kind="warning" line="10" text="should match"/>
        </compile>
    </ajc-test>  
  
======= 7e0c3cd:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

======= 7e0c3cd:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

    /**
     * Returns true if the parent member is visible to the child member 
     * In the same declaring type this is always true, otherwise if parent is private
     * it is false.
     * @param childMember
     * @param parentMember
     * @return
     */
    private static boolean isVisibleTo(ResolvedMember childMember, ResolvedMember parentMember) {
    	if (childMember.getDeclaringType().equals(parentMember.getDeclaringType())) return true;
    	if (Modifier.isPrivate(parentMember.getModifiers())) {
    		return false;
    	} else {
    		return true;
    	}
    }

======= 6c8747b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= 6c8747b:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

  Foo field;
  void test() {}
  void around() : call(void Foo.test()) {
    Foo foo = new Foo().field;
    proceed(foo); // caught at compile time
    proceed(new Foo().field); // crashes
  }
======= 6c8747b:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testInlinedFieldAccessInProceedCall() {
  }
  
    <ajc-test dir="bugs150" pr="107858" title="inlined field access in proceed call">
        <compile files="pr107858.aj" options="-1.5">
            <message kind="error" line="9" text="too many arguments to proceed, expected 0"></message>
            <message kind="error" line="10" text="too many arguments to proceed, expected 0"></message>
        </compile>
    </ajc-test>  
 

  public class Inner {}
  public void varargs(Object... varargs) {}
  public void test() {
    Outer.Inner inner = new Outer().new Inner();
    varargs(inner); // works
    varargs(new Outer().new Inner()); // crashes
  }
======= f2af562:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testInnerClassPassedToVarargs() {
  }
  
    <ajc-test dir="bugs150" pr="104024" title="inner class passed as argument to varargs method">
        <compile files="pr104024.aj" options="-1.5"/>
    </ajc-test>  
    

    static interface Inner {
    }
    static class InnerTest implements Inner {
    }
======= b953c03:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testInnerTypeOfGeneric() {
  }
  
 
    <ajc-test dir="bugs150" pr="95992" title="inner type of generic interface reference from parameterized type">
        <compile files="pr95992.aj" options="-1.5"/>
    </ajc-test>
                   

======= 2c9ea11:"weaver/src/org/aspectj/weaver/bcel/BcelField.java"

======= 2c9ea11:"weaver/src/org/aspectj/weaver/bcel/BcelField.java"

======= 2c9ea11:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= 2c9ea11:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= 2c9ea11:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= 2c9ea11:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= 2c9ea11:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= 2c9ea11:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= 2c9ea11:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= 2c9ea11:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= 2c9ea11:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= 2c9ea11:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= 2c9ea11:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= 2c9ea11:"weaver/src/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXConverter.java"

======= 2c9ea11:"weaver/src/org/aspectj/weaver/bcel/BcelMethod.java"

======= 2c9ea11:"weaver/src/org/aspectj/weaver/bcel/BcelMethod.java"

======= 2c9ea11:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= 2c9ea11:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= 2c9ea11:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= 2c9ea11:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= 2c9ea11:"weaver/testsrc/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXTestCase.java"

======= 2c9ea11:"weaver/testsrc/org/aspectj/weaver/bcel/BcelGenericSignatureToTypeXTestCase.java"


    public static void main(String[] args) {
    	System.out.println(new pr108377().foo());
    }
    public pr108377 pr108377.a;
    public String pr108377.value;
    public String pr108377.foo() {
    	if (a == null) a = this;
    	return a.value;
    }
======= be750d5:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testFieldAccessInsideITDM() {
  }
  
    <ajc-test dir="bugs150" pr="108377" title="itd field access inside itd method">
        <compile files="pr108377.aj"/>
        <run class="pr108377"/>
    </ajc-test>
    
    <!-- ============================================================================ -->
    <!-- ============================================================================ -->
    

    protected void doPost() {
    }    
    protected void doPost() {
    }
    
    private static aspect FindMatches {
    	  declare warning: execution(* HttpServlet.do*(..)): "servlet request";
    }
    private static final long serialVersionUID = 1; 
    protected void doPost()
    {
    } 
======= 27e68f3:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testSignatureMatchingInMultipleOverrideScenario() {
  }
  
    <ajc-test dir="bugs150" pr="108050" title="signature matching in override scenario">
        <compile files="pr108050.aj" options="-1.5">
            <message kind="warning" line = "2" text="servlet request"></message>
            <message kind="warning" line = "7" text="servlet request"></message>
            <message kind="warning" line = "21" text="servlet request"></message>
        </compile>
    </ajc-test>
           
======= 27e68f3:"weaver/src/org/aspectj/weaver/JoinPointSignature.java"

======= 27e68f3:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

    	Set memberSignatures = new HashSet();
======= 27e68f3:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"

    		Set foundMembers) {
======= 27e68f3:"weaver/src/org/aspectj/weaver/ResolvedMemberImpl.java"


======= 100d9e0:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 100d9e0:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 100d9e0:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

    /**
     * Retrieve a bcel delegate for an aspect - this will return NULL if the
     * delegate is an EclipseSourceType and not a BcelObjectType - this happens
     * quite often when incrementally compiling.
     */

======= bf767a9:"bcel-builder/src/org/aspectj/apache/bcel/generic/SWITCH.java"

 * @version $Id: SWITCH.java,v 1.3 2005/08/25 11:35:49 aclement Exp $
======= bf767a9:"bcel-builder/src/org/aspectj/apache/bcel/generic/SWITCH.java"

      if (match.length==0) {
    	  instruction = new LOOKUPSWITCH(match,targets,target);
      } else {
    	  instruction = new TABLESWITCH(match,targets,target);
      }
======= bf767a9:"bcel-builder/src/org/aspectj/apache/bcel/generic/TABLESWITCH.java"

 * @version $Id: TABLESWITCH.java,v 1.3 2005/08/25 11:35:49 aclement Exp $
======= bf767a9:"bcel-builder/src/org/aspectj/apache/bcel/generic/TABLESWITCH.java"

    
======= bf767a9:"bcel-builder/src/org/aspectj/apache/bcel/generic/TABLESWITCH.java"

    

======= cc6e681:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testPrivilegedMethodAccessorsGetRightExceptions_pr82989() {
  }
  
======= cc6e681:"tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java"

   <ajc-test dir="java5/generics/itds/bridgeMethods" title="abstract intertype methods and covariant returns - error">
   	   <compile files="pr91381_2.aj">
   	     <message kind="error" line="15" text="The return type is incompatible with A.foo()"/>
   	   </compile>
   </ajc-test>
   
   <ajc-test dir="bugs150" title="Compiler error due to a wrong exception check in try blocks">
     <compile files="pr82989.aj" options="-1.5"/>
   </ajc-test>
   
======= cc6e681:"weaver/src/org/aspectj/weaver/AjcMemberMaker.java"


======= 93fdce1:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testDEOWWithBindingPointcut() {
  }
  
    <ajc-test dir="bugs150" pr="79523" title="declare warning : foo(str) : ...;">
        <compile files="pr79523.aj">
            <message line="4" kind="warning" text="no match for this type name: str"/>
            <message line="4" kind="error" text="bad parameter"/>
            <message line="4" kind="error" text="args() pointcut designator cannot be used in declare statement"/>
        </compile>
    </ajc-test>
                        
======= 93fdce1:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"


     * me a type safety warning when I don't specify the type when declaring a generic 
     * even though I have the @SuppressWarnings( "unchecked" ) annotation specified.
======= 7b32570:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testAtSuppressWarnings() {
  }
  
    <ajc-test dir="bugs150" pr="104529" title="@SuppressWarnings should suppress">
        <compile files="pr104529.aj" options = "-1.5 -warn:+unchecked">
            <message line="11" kind="warning" text="needs unchecked conversion"/>
        </compile>
    </ajc-test>
            
            

======= 86ce1f7:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testPointcutOverriding() {
  }
  
    <ajc-test dir="bugs150" pr="86057" title="overriding final pointcut from super-aspect">
        <compile files="pr86057.aj">
            <message line="9" kind="error" text="can't override final pointcut Base.foo()"/>
        </compile>
    </ajc-test>
======= 86ce1f7:"weaver/src/org/aspectj/weaver/ResolvedType.java"

======= 86ce1f7:"weaver/src/org/aspectj/weaver/WeaverMessages.java"


======= 2b23e91:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testDetectVoidFieldType() {
  }
  
    <ajc-test dir="bugs150" pr="78621" title="void field type in pointcut expression">
        <compile files="pr78261.aj">
            <message line="3" kind="error" text="fields cannot have a void type"/>
        </compile>
    </ajc-test>
                                

======= 169a488:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testAjKeywordsAsIdentifiers2() {
  }
  
    <ajc-test dir="bugs150" pr="91114" title="before and after are valid identifiers in classes, part 2">
        <compile files="pr91114.aj">
        </compile>
    </ajc-test>
                

======= 5e9aca9:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testErrorMessageOnITDWithTypePatterns() {
  }
  
  public void testAjKeywordsAsIdentifiers() {
  }
  
    <ajc-test dir="bugs150" pr="64568" title="clear error message on itd with type pattern">
        <compile files="pr64568.aj">
            <message line="4" kind="error" text="Syntax error on token &quot;*&quot;, delete this token"/>
            <message line="4" kind="error" text="foo cannot be resolved to a type"/>
        </compile>
    </ajc-test>
    <ajc-test dir="bugs150" pr="74562" title="before and after are valid identifiers in classes">
        <compile files="pr74562.aj">
        </compile>
    </ajc-test>
            

======= 477c575:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testIllegalStateExceptionOnNestedParameterizedType_pr106634() { 
  }
  
    <ajc-test dir="bugs150" pr="10461" title="missing name pattern">
    
    <ajc-test dir="bugs150" pr="106634" title="IllegalStateException unpacking signature of nested parameterized type">
        <compile files="pr106634.aj" options="-1.5"/>
    </ajc-test>
     <compile files="GenericAspect1.aj" options="-1.5">
         <message kind="error" line="2" text="only abstract aspects can have type parameters"/>
     </compile>
       <message kind="error" line="9" text="a generic super-aspect must be fully parameterized in an extends clause"/>
   <ajc-test dir="java5/generics/genericaspects" title="generic aspect with declare warning using type vars">
     <compile files="DeclareWarningInGenericAspect.aj" options="-1.5">
         <message kind="warning" line="16" text="this method takes a T!"/>
     </compile>
   </ajc-test>
   <ajc-test dir="java5/generics/genericaspects" title="generic aspect with execution advice using type vars">
     <compile files="ExecutionAdviceInGenericAspect.aj" options="-1.5">
     </compile>
     <run class="ExecutionAdviceInGenericAspect">
         <stdout>
             <line text="I matched at execution(void C.foo(String))"/>
         </stdout>
     </run>
   </ajc-test>
  <ajc-test dir="java5/generics/genericaspects" title="generic aspect with anonymous pointcut">
     <compile files="AnonymousPointcutInGenericAspect.aj" options="-1.5">
     </compile>
     <run class="AnonymousPointcutInGenericAspect">
         <stdout>
             <line text="I matched at execution(void C.foo(String))"/>
         </stdout>
     </run>
   </ajc-test>
            

======= 5735e96:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testMissingNamePattern_pr106461() { runTest("missing name pattern"); }
  
    
    <ajc-test dir="bugs150" title="missing name pattern">
        <compile files="PR106461.aj">
            <message kind="error" line="3" text="Syntax error on token &quot;(&quot;, &quot;name pattern&quot; expected"/>
            <message kind="error" line="5" text="Syntax error on token &quot;)&quot;, &quot;name pattern&quot; expected"/>
            <message kind="error" line="7" text="Syntax error on token &quot;.&quot;, &quot;name pattern&quot; expected"/>
        </compile>
    </ajc-test>
======= 5735e96:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"

======= 5735e96:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"


 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 *   Alexandre Vasseur         initial implementation
 *******************************************************************************/
 * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
 */
    static int s_i = 0;
    public static void main(String[] args) {
        TestHelper.runAndThrowOnFailure(suite());
    }
    public static junit.framework.Test suite() {
        return new junit.framework.TestSuite(Bug104212.class);
    }
    public void testStaticMethodFromSuperClass() {
        Child.doSome();
        assertEquals(1, s_i);
    }
    static class Parent {
        static void foo() {}
    }
    static class Child extends Parent {
        static void doSome() {
            foo();// this is the bug
        }
    }
    @Aspect
    public static class TestAspect {
        @Before("call(* ataspectj.Bug104212.Parent.foo()) && within(ataspectj.Bug104212.Child)")
        public void before(JoinPoint jp) {
            // AJ bug was here since Java 1.4...
            // was: call(Bug104212.Child.foo())
            assertEquals("call(Bug104212.Parent.foo())", jp.toShortString());
            assertEquals(Parent.class, jp.getSignature().getDeclaringType());
            assertNotNull(((MethodSignature)jp.getSignature()).getMethod());
            s_i++;
        }
    }
======= 619a6ad:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjSyntaxTests.java"

    public void testBug104212() {
        runTest("Bug104212");
    }
    <ajc-test dir="java5/ataspectj" title="Bug104212">
        <compile files="ataspectj/Bug104212.java,ataspectj/TestHelper.java" options="-1.5"/>
        <run class="ataspectj.Bug104212"/>
    </ajc-test>
======= 619a6ad:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 619a6ad:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        Member sig = world.makeMethodSignature(
======= 619a6ad:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

                world.makeMethodSignature(
======= 619a6ad:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= 619a6ad:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

    public Member makeMethodSignature(LazyClassGen cg, InvokeInstruction ii) {
======= 619a6ad:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

        // in Java 1.4 and after, static method call of super class within subclass method appears
        // as declared by the subclass in the bytecode - but they are not
        // see #104212
        if (ii instanceof INVOKESTATIC) {
            ResolvedType appearsDeclaredBy = resolve(declaring);
            // look for the method there
            for (Iterator iterator = appearsDeclaredBy.getMethods(); iterator.hasNext();) {
                ResolvedMember method = (ResolvedMember) iterator.next();
                if (method.isStatic()) {
                    if (name.equals(method.getName()) && signature.equals(method.getSignature())) {
                        // we found it
                        declaring = method.getDeclaringType().getName();
                        break;
                    }
                }
            }
        }
        //FIXME if not found we ll end up again with the bug.. can this happen?

======= bba9c50:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/MakeDeclsPublicVisitor.java"

======= bba9c50:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/MakeDeclsPublicVisitor.java"

======= bba9c50:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/MakeDeclsPublicVisitor.java"

======= bba9c50:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/MakeDeclsPublicVisitor.java"

    after() returning (RequestContext newContext) : call(RequestContext+.new(..)) {        
        System.out.println("constructing "+newContext+" at "+thisJoinPoint.toLongString()+" from "+thisEnclosingJoinPointStaticPart+":");
    }
     abstract class RequestContext {
        public final Object execute() {
            return doExecute();
        }
        
        /** template method */
        public abstract Object doExecute();
    }
    public static void main(String args[]) {
        new Runnable() {
            public void run() {}
        }.run();
    };
    Object around(final Object runnable) : execution(void Runnable.run()) && this(runnable) {
        System.out.println("monitoring operation: "+runnable+" at "+thisJoinPoint+", for "+thisJoinPoint.getThis());
        RequestContext requestContext = new RequestContext() {
            public Object doExecute() {
                return proceed(runnable);
            }
            
        };
        return requestContext.execute();
    }
    
    
    Object around() : call(void awqeyuwqer()) {
        RequestContext requestContext = new ConnectionRequestContext() {
            public Object doExecute() {                
                return proceed();
            }
            
        };
        return requestContext.execute();
    }
    
======= bba9c50:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testSyntaxErrorNPE_pr103266() {runTest("NPE on syntax error");}
  
   
   <ajc-test dir="bugs150" pr="103266" title="NPE on syntax error">
     <compile files="pr103266.aj">
          <message kind="error" line="41" text="ConnectionRequestContext cannot be resolved to a type"/>
     </compile>
   </ajc-test>

 * Copyright (c) 2005 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 * 
 * Contributors:
 *   Alexandre Vasseur         initial implementation
 *******************************************************************************/
 * @author <a href="mailto:alex AT gnilux DOT com">Alexandre Vasseur</a>
 */
    static StringBuffer s_log = new StringBuffer();
    static void log(String s) {
        s_log.append(s).append(" ");
    }
    public static void main(String[] args) {
        TestHelper.runAndThrowOnFailure(suite());
    }
    public static junit.framework.Test suite() {
        return new junit.framework.TestSuite(MultipleBindingTest.class);
    }
    public void testMultipleJoinPoint() {
        s_log = new StringBuffer();
        Target.dump(new JoinPoint() {
            public String toShortString() {
                return "jpFromApp";
            }
            public String toLongString() {
                return null;
            }
            public Object getThis() {
                return null;
            }
            public Object getTarget() {
                return null;
            }
            public Object[] getArgs() {
                return new Object[0];
            }
            public Signature getSignature() {
                return null;
            }
            public SourceLocation getSourceLocation() {
                return null;
            }
            public String getKind() {
                return null;
            }
            public StaticPart getStaticPart() {
                return null;
            }
        });
        assertEquals("jpFromApp execution(MultipleBindingTest.Target.dump(..)) execution(MultipleBindingTest.Target.dump(..)) jpFromApp ", s_log.toString());
    }
    public void testMultipleProceedingJoinPoint() {
        s_log = new StringBuffer();
        Target.dump2(new ProceedingJoinPoint() {
            public void set$AroundClosure(AroundClosure arc) {
            }
            public Object proceed() throws Throwable {
                return null;
            }
            public Object proceed(Object[] args) throws Throwable {
                return null;
            }
            public String toShortString() {
                return "pjpFromApp";
            }
            public String toLongString() {
                return null;
            }
            public Object getThis() {
                return null;
            }
            public Object getTarget() {
                return null;
            }
            public Object[] getArgs() {
                return new Object[0];
            }
            public Signature getSignature() {
                return null;
            }
            public SourceLocation getSourceLocation() {
                return null;
            }
            public String getKind() {
                return null;
            }
            public StaticPart getStaticPart() {
                return null;
            }
        });
        assertEquals("pjpFromApp execution(MultipleBindingTest.Target.dump2(..)) execution(MultipleBindingTest.Target.dump2(..)) pjpFromApp ", s_log.toString());
    }
    static class Target {
        static void dump(JoinPoint jp) {
            log(jp.toShortString());
        }
        static void dump2(ProceedingJoinPoint pjp) {
            log(pjp.toShortString());
        }
    }
    @Aspect
    public static class TestAspect {
        @Before("execution(* ataspectj.MultipleBindingTest.Target.dump(..)) && args(ajp)")
        public void before(JoinPoint ajp, JoinPoint jp, JoinPoint jpbis) {
            log(ajp.toShortString());
            log(jp.toShortString());
            log(jpbis.toShortString());
        }
        @Around("execution(* ataspectj.MultipleBindingTest.Target.dump2(..)) && args(apjp)")
        public Object around(ProceedingJoinPoint apjp, ProceedingJoinPoint pjp, ProceedingJoinPoint pjpbis) throws Throwable {
            log(apjp.toShortString());
            log(pjp.toShortString());
            log(pjpbis.toShortString());
            return pjp.proceed();
        }
    }
======= 639b4fd:"tests/java5/ataspectj/ataspectj/SingletonAspectBindingsTest.java"

======= 639b4fd:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjSyntaxTests.java"

        //org.aspectj.asm.AsmManager.setReporting("debug.txt",true,true,true,true);
        runTest("singletonAspectBindings2");
======= 639b4fd:"tests/src/org/aspectj/systemtest/ajc150/ataspectj/AtAjSyntaxTests.java"

    public void testMultipleBinding() {
        runTest("MultipleBinding");
    }
        <compile files="ataspectj/PerClauseInheritanceTest.java,ataspectj/TestHelper.java" options="-1.5 -XnoInline"/>
        <run class="ataspectj.PerClauseInheritanceTest"/>
    <ajc-test dir="java5/ataspectj" title="MultipleBinding">
        <compile files="ataspectj/MultipleBindingTest.java,ataspectj/TestHelper.java" options="-1.5 -Xdev:NoAtAspectJProcessing -XnoInline"/>
        <run class="ataspectj.MultipleBindingTest"/>
        <compile files="ataspectj/MultipleBindingTest.java,ataspectj/TestHelper.java" options="-1.5 -Xdev:NoAtAspectJProcessing"/>
        <run class="ataspectj.MultipleBindingTest"/>
    </ajc-test>
======= 639b4fd:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

        final boolean isAnnotationStyleAspect = getConcreteAspect()!=null && getConcreteAspect().isAnnotationStyleAspect();
        boolean previousIsClosure = false;
            	if (!isAnnotationStyleAspect) {
                    //    previousIsClosure = true;
                    if ("Lorg/aspectj/lang/ProceedingJoinPoint;".equals(getSignature().getParameterTypes()[i].getSignature())) {
                        //make sure we are in an around, since we deal with the closure, not the arg here
                        if (getKind() != AdviceKind.Around) {
                            previousIsClosure = false;
                            getConcreteAspect().getWorld().getMessageHandler().handleMessage(
                                    new Message(
                                            "use of ProceedingJoinPoint is allowed only on around advice ("
                                            + "arg " + i + " in " + toString() + ")",
                                            this.getSourceLocation(),
                                            true
                                    )
                            );
                            // try to avoid verify error and pass in null
                            il.append(InstructionConstants.ACONST_NULL);
                        } else {
                            if (previousIsClosure) {
                                il.append(InstructionConstants.DUP);
                            } else {
                                previousIsClosure = true;
                                il.append(closureInstantiation.copy());
                            }
                        }
                        previousIsClosure = false;
                        previousIsClosure = false;
                        previousIsClosure = false;
                        previousIsClosure = false;
                        previousIsClosure = false;
======= 639b4fd:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

        if (!isAnnotationStyleAspect) {

  public void Generic_Parent.inherited_method() {}
  public int Generic_Parent.inherited_field;
  public static void test() {
    int inherited_field;
    inherited_field = new Generic_Child().inherited_field; // works
    inherited_field = new Generic_Child<Integer>().inherited_field; // works
    inherited_field = new Child().inherited_field; // works
    new Generic_Child().inherited_method(); // works
    new Generic_Child<Integer>().inherited_method(); // unresolved
    new Child().inherited_method(); // unresolved
  }
  public static void main(String []argv) {
    test();
  }
======= b54831f:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testItdGenerics_pr100260() {runTest("methods inherited from a generic parent");}
  
   <ajc-test dir="bugs150" pr="100260" title="methods inherited from a generic parent">
     <compile files="pr100260.aj" options="-1.5"/>
     <run class="pr100260"/>
   </ajc-test>
   

======= 7d5002a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 7d5002a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

  class Inner {public void p() {System.err.println("Outer.Inner.p() executing");} }
  public void m() { new Inner().p(); }
  class Inner {public void p() {System.err.println("Generic_Outer.Inner.p() executing");} }
  public void m() { new Inner().p(); }
  int Outer.outer = 1;
  int Outer.Inner.inner = 2;
  int Generic_Outer.outer = 3; 
  int Generic_Outer.Inner.inner = 4;
  before(Object o): execution(* p()) && this(o) {
    if (o instanceof Outer.Inner) {
      System.err.println("Outer.Inner.inner="+((Outer.Inner)o).inner);
    }
    if (o instanceof Generic_Outer.Inner) {
      System.err.println("Generic_Outer.Inner.inner="+((Generic_Outer.Inner)o).inner);
    }
  }
  public static void main(String []argv) {
    new Outer().m();
    new Generic_Outer<String>().m();
  }
======= 7d5002a:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testItdGenerics_pr99228()  {runTest("ITD of a field into a generic class");}
  public void testItdGenerics_pr98320()  {runTest("intertype with nested generic type");}
  public void testItdGenerics_pr100227() {runTest("inner class with generic enclosing class");}
   <ajc-test dir="bugs150" pr="100227" title="inner class with generic enclosing class">
     <compile files="pr100227.aj" options="-1.5"/>
     <run class="pr100227">
     </run>
   </ajc-test>
   
======= 7d5002a:"weaver/src/org/aspectj/weaver/TypeX.java"

======= 7d5002a:"weaver/src/org/aspectj/weaver/TypeX.java"

======= 7d5002a:"weaver/src/org/aspectj/weaver/TypeX.java"

======= 7d5002a:"weaver/src/org/aspectj/weaver/TypeX.java"

======= 7d5002a:"weaver/src/org/aspectj/weaver/TypeX.java"

    private final void setRawtype(boolean b) {
    }

======= 588023e:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeScope.java"

======= 588023e:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeScope.java"


  public static void m() {System.err.println("static method running");}
  public static void main(String []argv) {
    m();
  }
  public static void main(String []argv) {
    m();
  }
======= f747b82:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testStaticImports_pr84260() {
  } 
  
    <ajc-test dir="bugs150/pr84260" vm="1.5" title="static import failures">
        <compile files="A.java,I1.java,I2.java" options="-1.5"/>
        <run class="I1">
          <stderr>
            <line text="static method running"/>
          </stderr>
        </run>
        <run class="I2">
          <stderr>
            <line text="static method running"/>
          </stderr>
        </run>
    </ajc-test>
    

======= 743566f:"weaver/src/org/aspectj/weaver/patterns/BasicTokenSource.java"

======= 743566f:"weaver/src/org/aspectj/weaver/patterns/BasicTokenSource.java"

======= 743566f:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"

======= 743566f:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"

======= 743566f:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"

======= 743566f:"weaver/testsrc/org/aspectj/weaver/patterns/VisitorTestCase.java"

    public void testTemp() {
        Pointcut.fromString("call(* *(int, Integer...))");
    }

======= 3824b1c:"runtime/src/org/aspectj/runtime/reflect/AdviceSignatureImpl.java"

======= 3824b1c:"runtime/src/org/aspectj/runtime/reflect/MethodSignatureImpl.java"

======= 3824b1c:"runtime/src/org/aspectj/runtime/reflect/MethodSignatureImpl.java"

    before() : call(* *(..)) && !within(Test) {
       MethodSignature sig = (MethodSignature)thisJoinPoint.getSignature();
       //sig.getDeclaringType(); // uncomment to work-around
       Method method = sig.getMethod();
   }
    public static void main(String args[]) {
    }
    public static class Inner {
    }
======= 3824b1c:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testIfEvaluationExplosion_pr94086() {
  public void testReflectNPE_pr94167() {
  }
  
   
  <ajc-test dir="bugs150" title="NPE in reflect implementation" pr="94167">
     <compile files="PR94167.java"/>
     <run class="reflect.PR94167"/>
  </ajc-test>

======= a675b65:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"

        while (   (((c = extract[trimLeftIndex++]) == TAB) || (c == SPACE)) && trimLeftIndex<extract.length   ) { };

======= f14646f:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

    private final static String AOP_XML = "META-INF/aop.xml";
======= f14646f:"loadtime/src/org/aspectj/weaver/loadtime/ClassLoaderWeavingAdaptor.java"

            Enumeration xmls = loader.getResources(AOP_XML);
======= f14646f:"loadtime5/java5-src/org/aspectj/weaver/loadtime/ClassPreProcessorAgentAdapter.java"

            <!-- use META-INF/aop.xml style -->
            <classpath path="ataspectj/pathentry"/>
======= f14646f:"tests/java5/ataspectj/ataspectj/SingletonAspectBindingsTest.java"

    <weaver options="-XmessageHolderClass:ataspectj.TestHelper"/>
    <aspects>
        <!-- see here nested class with ".", "$" is accepted as well -->
        <aspect name="ataspectj.SingletonAspectBindingsTest.TestAspect"/>
        <aspect name="ataspectj.CflowTest.TestAspect"/>
        <aspect name="ataspectj.PointcutReferenceTest.TestAspect"/>
        <aspect name="ataspectj.AfterXTest.TestAspect"/>
        <aspect name="ataspectj.XXJoinPointTest.TestAspect"/>
        <aspect name="ataspectj.PrecedenceTest.TestAspect_2"/>
        <aspect name="ataspectj.PrecedenceTest.TestAspect_1"/>
        <aspect name="ataspectj.PrecedenceTest.TestAspect_3"/>
        <aspect name="ataspectj.PrecedenceTest.TestAspect_Order"/>
        <aspect name="ataspectj.BindingTest.TestAspect_1"/>
        <aspect name="ataspectj.PerClauseTestAspects.TestAspectPerSingleton"/>
        <aspect name="ataspectj.PerClauseTestAspects.TestAspectPerTarget"/>
        <aspect name="ataspectj.PerClauseTestAspects.TestAspectPerCflow"/>
        <aspect name="ataspectj.PerClauseTestAspects.TestAspectPTW"/>
        <aspect name="ataspectj.AroundInlineMungerTestAspects.Open"/>
    </aspects>

    private static final SimpleLogger sl
        = new SimpleLogger();
    pointcut PC() :
        (execution(* Test.a(..)) && if (sl.isEnabled()))
        || (execution(* Test.b(..)) && if (sl.isEnabled()))
        || (execution(* Test.c(..)) && if (sl.isEnabled()))
        || (execution(* Test.d(..)) && if (sl.isEnabled()))
        || (execution(* Test.e(..)) && if (sl.isEnabled()))
        || (execution(* Test.f(..)) && if (sl.isEnabled()))
        || (execution(* Test.g(..)) && if (sl.isEnabled()))
        || (execution(* Test.h(..)) && if (sl.isEnabled()))
        || (execution(* Test.i(..)) && if (sl.isEnabled()))
        || (execution(* Test.j(..)) && if (sl.isEnabled()))
        ;
    before() : PC() {
        sl.log("Before");
    }
    after() : PC() {
        sl.log("After");
    }
        public void a() {}
        public void b() {}
        public void c() {}
        public void d() {}
        public void e() {}
        public void f() {}
        public void g() {}
        public void h() {}
        public void i() {}
        public void j() {}
        public void k() {}
        public void l() {}
        public void m() {}
        public void n() {}
        public void o() {}
        public void p() {}
    private boolean enabled;
    public SimpleLogger() {
        enabled = false;
    }
    public void disable() {
        enabled = false;
    }
    public void enable() {
        enabled = true;
    }
    public boolean isEnabled() {
        return enabled;
    }
    public void log(String str) {
        if (enabled) {
            System.out.println("> Log: " + str);
        }
    }
======= 88d477d:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  /**
   * IfPointcut.findResidueInternal() was modified to make this test complete in a short amount
   * of time - if you see it hanging, someone has messed with the optimization.
   */
  public void testIfEvaluationExplosiion_PR94086() {
  }
   
   <ajc-test dir="bugs150" title="Exploding compile time with if() statements in pointcut">
     <compile files="PR94086.aj" options="-1.5"/>
   </ajc-test>
======= 88d477d:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

    private boolean findingResidue = false;
======= 88d477d:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"


======= f9eebd4:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

 @MyRuntimeAnnotation @MySourceAnnotation @MyClassAnnotation @MyAnnotation
 void a(){}
 before(MyRuntimeAnnotation a): execution(* *(..)) && @annotation(a) {} // no error
 before(MySourceAnnotation a): execution(* *(..)) && @annotation(a) {} // error expected
 before(MyClassAnnotation a): execution(* *(..)) && @annotation(a) {} // error expected
 before(MyAnnotation a): execution(* *(..)) && @annotation(a) {} // error expected
        <compile options="-1.5" files="NotRuntimeRetention.aj">
         <message kind="error" line="20" text="Annotation type MySourceAnnotation does not have runtime retention"/>
            <message kind="error" line="21" text="Annotation type MyClassAnnotation does not have runtime retention"/>
            <message kind="error" line="22" text="Annotation type MyAnnotation does not have runtime retention"/>
======= f9eebd4:"weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.java"

        if (!annotationType.isAnnotationWithRuntimeRetention(world)) { // default is class visibility

======= 0cb826c:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testInternalCompilerError_pr86832() {
  }
  
   
   <ajc-test dir="bugs150" title="Internal compiler error">
     <compile files="PR86832.aj" options="-1.5"/>
   </ajc-test>

======= 7b7c7b2:"ajdoc/src/org/aspectj/tools/ajdoc/Declaration.java"

======= 7b7c7b2:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

======= 7b7c7b2:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"


        pointcut a() : cflow( execution(* *(..)) );
        before() : a() {
                System.out.println("before a");
        }
 public static void main(String [] args){
  out.println("hello world");
 }
======= f603458:"tests/src/org/aspectj/systemtest/ajc150/AllTestsAspectJ150.java"

======= f603458:"tests/src/org/aspectj/systemtest/ajc150/AllTestsAspectJ150.java"

 * Copyright (c) 2005 Contributors 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *   Andrew Huff - initial implementation
 *******************************************************************************/
   public static Test suite() {
     return XMLBasedAjcTestCase.loadSuite(StaticImports.class);
   }
   protected File getSpecFile() {
     return new File("../tests/src/org/aspectj/systemtest/ajc150/ajc150.xml");
   }
   
  public void testImportStaticSystemDotOut() {
   runTest("import static java.lang.System.out");
  }
======= f603458:"tests/src/org/aspectj/systemtest/ajc150/SuppressedWarnings.java"

  
  public void testSuppressionWithCflow_pr93345() {
    runTest("XLint warning for advice not applied with cflow(execution)");
  }
    <ajc-test dir="java5/staticImports" title="import static java.lang.System.out">
        <compile files="StaticImport.aj" options="-1.5"/>
    </ajc-test>
   
   <ajc-test dir="bugs150" title="XLint warning for advice not applied with cflow(execution)" pr="93345">
     <compile options="-Xlint,-1.5" files="PR93345.aj" >
       <message kind="warning" line="7" text="advice defined in AnAspect has not been applied [Xlint:adviceDidNotMatch]"/>
     </compile>
  </ajc-test>
======= f603458:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= f603458:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

                  if (!ba.hasMatchedSomething()) { 
 				     // find that ba.getSignature() is not a BcelMethod - for example it might be a cflow entry munger.
                     }

 
  private ArrayList<B> PR87282.m_Array = new ArrayList<B>();  
  public void PR87282.addB(B tmp){
    m_Array.add(tmp);
  }
    private java.util.List<Foo> PR88606.list;
    
    private void bar() {
        java.util.List<Foo> li = new PR88606().list;
    }
======= 51c018d:"tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java"

   
   <ajc-test dir="java5/generics/bugs" title="Compilation error on generic member introduction" vm="1.5">
      <compile files="PR87282.aj" options="-1.5"/>
   </ajc-test>
   
   <ajc-test dir="java5/generics/bugs" title="Parameterized types on introduced fields not correctly recognized" vm="1.5">
      <compile files="PR88606.aj" options="-1.5"/>
   </ajc-test>

======= 952dda9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 952dda9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 952dda9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

    private Set PR91053.aSet = new HashSet();
    public void PR91053.add(String s) {
        aSet.add(s);
    }
  public static void main(String[]argv) {
    new PR91053().add("hello");
  }
======= 952dda9:"tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java"

    
    <ajc-test dir="java5/generics/bugs" title="Generics problem with Set" vm="1.5">
      <compile files="PR91053.aj" options="-1.5"/>
      <run class="PR91053"/>
   </ajc-test>
======= 952dda9:"weaver/src/org/aspectj/weaver/TypeX.java"

======= 952dda9:"weaver/src/org/aspectj/weaver/TypeX.java"

======= 952dda9:"weaver/src/org/aspectj/weaver/TypeX.java"

======= 952dda9:"weaver/src/org/aspectj/weaver/TypeX.java"

======= 952dda9:"weaver/src/org/aspectj/weaver/TypeX.java"

======= 952dda9:"weaver/src/org/aspectj/weaver/World.java"


======= 7389d9f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 7389d9f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 7389d9f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 7389d9f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

    static <T> void addToEnv(Map<String,T> env, String key, T value) {
    }
    public static void main(String[] argv) {
      Map<String,Integer> msi = new HashMap<String,Integer>();
      addToEnv(msi,"andy",new Integer(42));
      if (msi.get("andy")!=42) throw new RuntimeException("Failed to add");
    }
======= 7389d9f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

    static <T> T lookupEnv(Map<String,T> env, String key) {
    }
    public static void main(String[] argv) {
      Map<String,Integer> msi = new HashMap<String,Integer>();
      msi.put("andy",42);
      if (lookupEnv(msi,"andy")!=42) throw new RuntimeException("Failed to lookup");
    }
======= 7389d9f:"tests/src/org/aspectj/systemtest/ajc150/GenericsTests.java"

    
    <ajc-test dir="java5/generics/bugs/pr91267" title="NPE using generic methods in aspects 1" vm="1.5">
        <compile files="TestBug1.aj" options="-1.5"/>
        <run class="TestBug1"/>
    </ajc-test>
    
     <ajc-test dir="java5/generics/bugs/pr91267" title="NPE using generic methods in aspects 2" vm="1.5">
        <compile files="TestBug2.aj" options="-1.5"/>
        <run class="TestBug2"/>
    </ajc-test>
======= 7389d9f:"weaver/src/org/aspectj/weaver/TypeX.java"

======= 7389d9f:"weaver/src/org/aspectj/weaver/TypeX.java"


 * Copyright (c) 2005 Contributors
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Eclipse Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://eclipse.org/legal/epl-v10.html 
 *
 * Created on 25.03.2005
 * 
 * Contributors
 *  Oliver Boehm               initial implementation
 */
 * Test Aspect to check the different Xlint warnings
 */
    
    /*
     * examples for "invalidAbsoluteTypeName"
     */
 
    pointcut correctName() :
        call(String java.lang.Object.toString());
    
    pointcut wrongPackageName() :
        call(String java.xxx.Object.toString());
    
    pointcut wrongTypeName() :
        call(String java.lang.Xxx.toString());
    
    /** no warning!!! */
    pointcut wrongMethodName() :
        call(String java.lang.Object.xxx());
    
    @SuppressAjWarnings
    after() : call(String java.lang.Xxx.toString()) {
        System.out.println(thisJoinPoint);
    }
    
    
    
    /*
     * no example for "invalidWildcardTypeName"
     * 
     * Never signalled anywhere in the codebase
     * @see http://dev.eclipse.org/mhonarc/lists/aspectj-dev/msg01404.html
     */
    
    
    /*
     * example for "unresolvableMember"
     * 
     * hard to reproduce - I tried different things but at last I give up
     * @see https://bugs.eclipse.org/bugs/show_bug.cgi?id=59596#c2
     */
    
    
    
    /*
     * example for "typeNotExposedToWeaver"
     */
    
    public int Object.dummy = 0;
    
    
    
    /*
     * no example for "shadowNotInStructure"
     * 
     * Signalled if the structure model is broken, probably can't happen
     * @see http://dev.eclipse.org/mhonarc/lists/aspectj-dev/msg01404.html
     */
    
    /*
     * example for "unmatchedSuperTypeInCall"
     */
    pointcut unmatchedToStringCall() :
        call(String Car.toString());
    pointcut matchedToStringCall() :
        call(String Object.toString()) && target(Car);
    
    before() : unmatchedToStringCall() && !within(XlintTest) {
        System.out.println(thisJoinPoint);
    }
        
    @SuppressAjWarnings
    before() : call(String Car.toString()) {
        System.out.println(thisJoinPoint);
    }
    
    @SuppressAjWarnings({"adviceDidNotMatch"})
    before() : call(* java.lang.String.helloWorld()) {
        System.out.println(thisJoinPoint);
    }
    
        
    /*
     * example for "canNotImplementLazyTjp"
     * 
     * This example is from the README-12.html. To get the warning you must
     * compile it with "-XlazyTjp"
     * 
     * NOTE: The expected warnung does not appear. I don't know why.
     *       Here is the commandline:
     *       ajc -XlazyTjp -Xlint:warning -inpath src -d classes src
     */
    
    public static boolean enabled = false;
    
    pointcut toBeTraced() : execution(* *(..)) && !within(XlintTest);
    Object around() : toBeTraced() && if(enabled) {
        Object[] args = thisJoinPoint.getArgs();
        System.out.println(thisJoinPoint + ", arg's: " + args.length);
        return proceed();
    }
    
    
    /*
     * example for "needsSerialVersionUIDField"
     */
    
    declare parents : Main implements java.io.Serializable;
    
    
    
    /*
     * example for "brokeSerialVersionCompatibility"
     * 
     * NOTE: I don't see this warning inside Eclipse with 
     *      AJDT 1.2.0.20050308091611 although I activate the warning
     *      via the project properties.
     *      I see it only when I start the compiler from the commandline
     *      (ajc -XlazyTjp -Xlint:warning -inpath src -d classes src/x/...)
     */
    public int Car.breakSerial = 1;
    
    
    /*
     * example for "noInterfaceCtorJoinpoint"
     */
    
    pointcut interfaceConstructor() :
        execution(java.util.List.new());
    
    /**
     * @param args
     */
    public static void main(String[] args) {
        new Main().run();
        Long l = new Long(1);
        String s = l.toString();
    }
    
    public void run() {
        new Car().toString();
    }
======= 70b9ffd:"tests/src/org/aspectj/systemtest/xlint/XLintTests.java"

  
  public void test020(){
     runTest("7 lint warnings");
  }
   <ajc-test dir="bugs/seven/lint" title="7 lint warnings" pr="91719">
  <compile options="-1.5" files="Main.java">
   <message kind="warning" line="31"  text="no match for this type name: java.xxx.Object [Xlint:invalidAbsoluteTypeName]">
   </message> 
   <message kind="warning" line="34"  text="no match for this type name: java.lang.Xxx [Xlint:invalidAbsoluteTypeName]">
   </message>
   <message kind="warning" line="41"  text="no match for this type name: java.lang.Xxx [Xlint:invalidAbsoluteTypeName]">
   </message>
   <message kind="warning" line="69"  text="this affected type is not exposed to the weaver: java.lang.Object [Xlint:typeNotExposedToWeaver]">
   </message>
   <message kind="warning" line="87"  text="does not match because declaring type is java.lang.Object, if match desired use target(Car) [Xlint:unmatchedSuperTypeInCall]">
   </message>
   <message kind="warning" line="92"  text="advice defined in XlintTest has not been applied [Xlint:adviceDidNotMatch]">
   </message>
   <message kind="warning" line="157"  text="no interface constructor-execution join point - use java.util.List+ for implementing classes [Xlint:noInterfaceCtorJoinpoint]">
   </message>
  </compile>
  </ajc-test>

  declare @type : Test : @anInterface;
  declare @constructor : Test.new(String,int) : @anInterface;
  declare @method : int Test.fac(int) : @anInterface;
  declare @field : int Test.a : @anInterface;
  public Test(String say, int something){
    System.out.println(say + something);
  }
  public int fac(int n){
   return (n == 0)? 1 : n * fac(n-1);
  }
  public int a = 1;
======= abc9a58:"ajde/testsrc/org/aspectj/ajde/ShowWeaveMessagesTestCase.java"

======= abc9a58:"ajde/testsrc/org/aspectj/ajde/ShowWeaveMessagesTestCase.java"

======= abc9a58:"ajde/testsrc/org/aspectj/ajde/ShowWeaveMessagesTestCase.java"

======= abc9a58:"bridge/src/org/aspectj/bridge/WeaveMessage.java"

======= abc9a58:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= abc9a58:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

                    
======= abc9a58:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= abc9a58:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= abc9a58:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= abc9a58:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= abc9a58:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= abc9a58:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= abc9a58:"weaver/src/org/aspectj/weaver/bcel/Utility.java"

======= abc9a58:"weaver/src/org/aspectj/weaver/bcel/Utility.java"


======= 02f75ba:"weaver/src/org/aspectj/weaver/bcel/UnwovenClassFile.java"


======= 7a61380:"asm/src/org/aspectj/asm/IRelationship.java"

======= 7a61380:"asm/src/org/aspectj/asm/IRelationship.java"

        public static final Kind DECLARE_WARNING       = new Kind("declare warning");
        public static final Kind DECLARE_ERROR         = new Kind("declare error");
        public static final Kind DECLARE_SOFT          = new Kind("declare soft");
        public static final Kind DECLARE_INTER_TYPE    = new Kind("inter-type declaration");
======= 7a61380:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

    public static final String SOFTENS = "softens";
    public static final String SOFTENED_BY = "softened by"; 
    public static final String MATCHED_BY = "matched by";
======= 7a61380:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

                    String targetHandle = targetNode.getHandleIdentifier(); 
                    if (advice.getKind().equals(AdviceKind.Softener)) {
                        IRelationship foreward = mapper.get(adviceHandle, IRelationship.Kind.DECLARE_SOFT, SOFTENS,runtimeTest,true);
                        if (foreward != null) foreward.addTarget(targetHandle);//foreward.getTargets().add(targetHandle);
                        
                        IRelationship back = mapper.get(targetHandle, IRelationship.Kind.DECLARE, SOFTENED_BY,runtimeTest,true);
                        if (back != null)     back.addTarget(adviceHandle);//back.getTargets().add(adviceHandle);
                    } else {
    					IRelationship foreward = mapper.get(adviceHandle, IRelationship.Kind.ADVICE, ADVISES,runtimeTest,true);
    					if (foreward != null) foreward.addTarget(targetHandle);//foreward.getTargets().add(targetHandle);
    					
    					IRelationship back = mapper.get(targetHandle, IRelationship.Kind.ADVICE, ADVISED_BY,runtimeTest,true);
    					if (back != null)     back.addTarget(adviceHandle);//back.getTargets().add(adviceHandle);
                    }
                }

  public static void main(String[] args) {
    C a = new C();
    abc(a);
  }
  static void abc(C y) {}
  before(Ann ann) : call(* Test3.*(..)) && @args(ann) { }
======= 3f942a4:"tests/src/org/aspectj/systemtest/ajc150/AnnotationBinding.java"

  
  public void testAnnotationBindingArgsVerifyError_pr92053() {
  }  
    
    <ajc-test dir="java5/annotations/binding/bugs" title="AtArgs causes a VerifyError: Unable to pop operand off an empty stack" vm="1.5">
        <compile files="Test3.java" options="-1.5"/>
        <run class="Test3"/>
    </ajc-test>
======= 3f942a4:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"


======= 78abc76:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/DeclareAnnotationDeclaration.java"

======= 78abc76:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/DeclareAnnotationDeclaration.java"

  declare @Type: A : @myInterface;
======= 78abc76:"tests/src/org/aspectj/systemtest/ajc150/DeclareAnnotationTests.java"

  
  public void testDeclareTypeMisspelled() {
  }
    <ajc-test dir="java5/annotations/declare" pr="91858" title="declare @Type (should be @type)">
        <compile files="DeathByPoorSpelling.aj" options="-1.5">
            <message kind="error" line="6" text="Syntax error on token &quot;:&quot;, &quot;one of type, method, field, constructor&quot; expected"/>
        </compile>
    </ajc-test>
    
======= 78abc76:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"


======= df7fff4:"asm/src/org/aspectj/asm/AsmManager.java"

    private IElementHandleProvider handleProvider;
======= df7fff4:"asm/src/org/aspectj/asm/AsmManager.java"

======= df7fff4:"asm/src/org/aspectj/asm/AsmManager.java"

        handleProvider = new FullPathHandleProvider(); 
======= df7fff4:"asm/src/org/aspectj/asm/AsmManager.java"

    public IElementHandleProvider getHandleProvider() {
        return handleProvider;
    }
    
    public void setHandleProvider(IElementHandleProvider handleProvider) {
        this.handleProvider = handleProvider;
    }
    
======= df7fff4:"asm/src/org/aspectj/asm/AsmManager.java"

======= df7fff4:"asm/src/org/aspectj/asm/AsmManager.java"

 * Copyright (c) 2003 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Mik Kersten     initial implementation 
 * ******************************************************************/
 * Adapter used to uniquely identify program element handles.  Can be
 * implemented and overridden in @see{AsmManager} in order to provide
 * IDE-specific mechanisms of identifying elements.  For example, AJDT
 * uses workspace-relative paths that are understood by its JavaCore 
 * class.  
 * 
 * @author Mik Kersten
 */
    /**
     * @return  a String uniquely identifying this element
     */
    public String createHandleIdentifier(ISourceLocation location);
    /**
     * @return  a String uniquely identifying this element
     */
    public String createHandleIdentifier(File sourceFile, int line,int column,int offset);
    /**
     * NOTE: this is necessary for the current implementation to look up nodes, 
     * but we may want to consider removing it.
     * 
     * @return a String corresponding to the  
     */
    public String getFileForHandle(String handle);
    
    /**
     * NOTE: this is necessary for the current implementation to look up nodes, 
     * but we may want to consider removing it.
     * 
     * @return the line number corresponding to this handel
     */
    public int getLineNumberForHandle(String handle);
    
======= df7fff4:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

        // int col = new Integer(st.nextToken()).intValue(); TODO: use column number when available
        String file = AsmManager.getDefault().getHandleProvider().getFileForHandle(handle); // st.nextToken();
        int line = AsmManager.getDefault().getHandleProvider().getLineNumberForHandle(handle); // st.nextToken();
        
        String canonicalSFP = AsmManager.getDefault().getCanonicalFilePath(new File(file));
======= df7fff4:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

        String file = AsmManager.getDefault().getHandleProvider().getFileForHandle(handle); // st.nextToken();
        int line = AsmManager.getDefault().getHandleProvider().getLineNumberForHandle(handle); // st.nextToken();
        
======= df7fff4:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"

 * Copyright (c) 2003 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Mik Kersten     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
    static final String ID_DELIM = "|";
    
    public String createHandleIdentifier(ISourceLocation location) {
        StringBuffer sb = new StringBuffer();
        sb.append(AsmManager.getDefault()
                            .getCanonicalFilePath(location.getSourceFile()));
        sb.append(ID_DELIM);
        sb.append(location.getLine());
        sb.append(ID_DELIM);
        sb.append(location.getColumn());
        sb.append(ID_DELIM);
        sb.append(location.getOffset());
        return sb.toString();
    }
    
    public String createHandleIdentifier(File sourceFile, int line,int column,int offset) {
        StringBuffer sb = new StringBuffer();
        sb.append(AsmManager.getDefault().getCanonicalFilePath(sourceFile));
        sb.append(ID_DELIM);
        sb.append(line);
        sb.append(ID_DELIM);
        sb.append(column);
        sb.append(ID_DELIM);
        sb.append(offset);
        return sb.toString();       
    }
    public String getFileForHandle(String handle) {
        StringTokenizer st = new StringTokenizer(handle, ID_DELIM);
        String file = st.nextToken();
        return file;
    }
    public int getLineNumberForHandle(String handle) {
        StringTokenizer st = new StringTokenizer(handle, ID_DELIM);
        st.nextToken(); // skip over the file
        return new Integer(st.nextToken()).intValue();
    }
======= df7fff4:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= df7fff4:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

                return AsmManager.getDefault().getHandleProvider().createHandleIdentifier(sourceLocation);
======= df7fff4:"docs/sandbox/api-clients/org/aspectj/samples/AsmRelationshipMapExtensionTest.java"

    		String sourceHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
    		String superHandle = AsmManager.getDefault().getHandleProvider().createHandleIdentifier(
======= df7fff4:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AsmInterTypeRelationshipProvider.java"

======= df7fff4:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

                foreward.addTarget(AsmManager.getDefault().getHandleProvider().createHandleIdentifier(member.getSourceLocation()));            
                IRelationship back = AsmManager.getDefault().getRelationshipMap().get(AsmManager.getDefault().getHandleProvider().createHandleIdentifier(member.getSourceLocation()), IRelationship.Kind.USES_POINTCUT, "pointcut used by", false, true);
======= df7fff4:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

======= df7fff4:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

======= df7fff4:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

======= df7fff4:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

======= df7fff4:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

======= df7fff4:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

            AsmManager.getDefault().getHandleProvider().createHandleIdentifier(sourceLocation.getSourceFile(),sourceLocation.getLine(),
======= df7fff4:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"

            AsmManager.getDefault().getHandleProvider().createHandleIdentifier(sourceLocation.getSourceFile(),sourceLocation.getLine(),
======= df7fff4:"weaver/src/org/aspectj/weaver/ShadowMunger.java"

======= df7fff4:"weaver/src/org/aspectj/weaver/ShadowMunger.java"


 public static Test suite() {
   return XMLBasedAjcTestCase.loadSuite(KnownfailuresTests.class);
 }
 protected File getSpecFile() {
   return new File("../tests/src/org/aspectj/systemtest/knownfailures/knownfailures.xml");
 }
 public void test001(){
   runTest("NullPointerException in jdt when using generics and inpath");
   // the NPE goes away if you don't use generics
 }
    
    <ajc-test dir="bugs150/pr90588"
        <compile files="AbstractClass.java,ConcreteClass.java">
        </compile>
    </ajc-test>

======= e460b1e:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= e460b1e:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= e460b1e:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= e460b1e:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= e460b1e:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= e460b1e:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= e460b1e:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= e460b1e:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

 * Copyright (c) 2005 IBM and other contributors
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Andy Clement     initial implementation 
 * ******************************************************************/
 * Implementations of this interface get told interesting information about
 * decisions made in AjState objects.  Should help us improve incremental
 * compilation, and ease the testing of incremental compilation!
 *
 * Not yet complete, will expand as we determine what extra useful information
 * should be recorded.
 * 
 * @author AndyClement
 */
======= e460b1e:"tests/src/org/aspectj/systemtest/incremental/IncrementalTests.java"

======= e460b1e:"tests/src/org/aspectj/systemtest/incremental/IncrementalTests.java"

  
  /**
   * See bug report 85297.  We plugged a hole so that we check whether the contents of
   * directories on the classpath have changed when deciding whether we can do an
   * incremental build or not - the implementation didn't allow for the output location
   * being on the classpath.  This test verifies the fix is OK
   */
  public void testIncrementalOKWithOutputPathOnClasspath() throws Exception {
  	    public boolean pathChange = false;
  }

======= 0d14ccf:"tests/src/org/aspectj/systemtest/ajc150/AnnotationBinding.java"

  
  /////////////////////////////////////////////////////////////////////////////////
  // annotation binding with ITDs
  
  public void testAnnotationBindingAndITDs1() {
  	runTest("simple binding annotation values where itd method is annotated");
  }
  
  public void testAnnotationBindingAndITDs2() {
  	runTest("simple binding annotation values where itd field is annotated");
  }
 
  public void testAnnotationBindingAndITDs3() {
  	runTest("simple binding annotation values where itd ctor is annotated");
  }
  
  public void testAnnotationBindingAndITDs4() {
  	runTest("simple binding annotation values where itd method is annotated via declare");
  }  
  
  public void testAnnotationBindingAndITDs5() {
  	runTest("simple binding annotation values where itd field is annotated via declare");
  }  
  
  public void testAnnotationBindingAndITDs6() {
  	runTest("simple binding annotation values where itd field is annotated multiple times via declare");
  }  
  
  public void testAnnotationBindingAndITDs7() {
  	runTest("simple binding annotation values where itd ctor is annotated via declare");
  }  
  
======= 0d14ccf:"tests/src/org/aspectj/systemtest/ajc150/Annotations.java"

            <!-- first two are ITCs, second two are ITCs annotated via declare @ctor, third is default ctor -->
            <message kind="warning" line="180" text="execution(@SomeAnnotation ...new(..)"/>
            <message kind="warning" line="59" text="set(@SomeAnnotation...)"/>    
            <message kind="warning" line="60" text="set(@SomeAnnotation...)"/>    
            
            <message kind="warning" line="25" text="execution(@SomeAnnotation ...)"/>        
            <message kind="warning" line="28" text="execution(@SomeAnnotation ...)"/>        
            <message kind="warning" line="52" text="execution(@SomeAnnotation ...)"/>        
            <message kind="warning" line="53" text="execution(@SomeAnnotation ...)"/>    
            <!--message kind="warning" line="70" text="set(@SomeAnnotation...)"/>    
            <message kind="warning" line="71" text="set(@SomeAnnotation...)"/-->    
            <stderr>
                <line text="@type java.lang.System (AnnotationsAndITDs.aj:0)"/>
                <line text="hello AnnotationsAndITDs (AnnotationsAndITDs.aj:17)"/>
                <line text="goodbye java.lang.String (AnnotationsAndITDs.aj:20)"/>
                <line text="goodbye java.lang.String (AnnotationsAndITDs.aj:20)"/>
                <line text="y java.lang.Integer (AnnotationsAndITDs.aj:28)"/>
                <line text="d java.lang.Double (AnnotationsAndITDs.aj:70)"/>
                <line text="f java.lang.Double (AnnotationsAndITDs.aj:71)"/>
                <line text="@type java.lang.System (AnnotationsAndITDs.aj:0)"/>
                <line text="@field ITDMe2 (AnnotationsAndITDs.aj:59)"/>
                <line text="@field ITDMe2 (AnnotationsAndITDs.aj:60)"/>
                <line text="@cons java.lang.String (AnnotationsAndITDs.aj:45)"/>
                <line text="@field ITDMe2 (AnnotationsAndITDs.aj:59)"/>
                <line text="@field ITDMe2 (AnnotationsAndITDs.aj:60)"/>
                <line text="@cons java.lang.String (AnnotationsAndITDs.aj:46)"/>
                <line text="@cons java.lang.String (AnnotationsAndITDs.aj:46)"/>
                <line text="@method ITDMe2 (AnnotationsAndITDs.aj:53)"/>
                <line text="@field ITDMe2 (AnnotationsAndITDs.aj:76)"/>
                <line text="@field ITDMe2 (AnnotationsAndITDs.aj:77)"/>
                
                <!--
                -->
            </stderr>
            <message kind="warning" line="12" text="annotated field"/>
   
   <!-- ======================================================================================= -->
   <!--               annotation binding with ITDs                                              -->
   <!-- ======================================================================================= -->
   <ajc-test dir="java5/annotations/binding" title="simple binding annotation values where itd method is annotated">
      <compile files="BindingWithAnnotatedItds1.aj" options="-1.5"/>
      <run class="BindingWithAnnotatedItds1">
        <stderr>
          <line text="Found apple at jp execution(int A.m()) (BindingWithAnnotatedItds1.aj:8)"/>
        </stderr>
      </run>
   </ajc-test>
   
   <ajc-test dir="java5/annotations/binding" title="simple binding annotation values where itd field is annotated">
      <compile files="BindingWithAnnotatedItds2.aj" options="-1.5"/>
      <run class="BindingWithAnnotatedItds2">
        <stderr>
          <line text="Found banana at jp set(int A.i) (BindingWithAnnotatedItds2.aj:16)"/>
          <line text="Found apple at jp set(String A.j) (BindingWithAnnotatedItds2.aj:17)"/>
          <line text="Found orange at jp set(int[] A.k) (BindingWithAnnotatedItds2.aj:18)"/>
        </stderr>
      </run>
   </ajc-test>
   <ajc-test dir="java5/annotations/binding" title="simple binding annotation values where itd ctor is annotated">
      <compile files="BindingWithAnnotatedItds3.aj" options="-1.5"/>
      <run class="BindingWithAnnotatedItds3">
        <stderr>
          <line text="Found pear at jp execution(A(String)) (BindingWithAnnotatedItds3.aj:8)"/>
          <line text="Found orange at jp execution(A(int)) (BindingWithAnnotatedItds3.aj:10)"/>
          <line text="Found tomato at jp execution(A(boolean)) (BindingWithAnnotatedItds3.aj:12)"/>
        </stderr>
      </run>
   </ajc-test>
   
   <!-- ======================================================================================= -->
   <!--              declare annotation targetting ITDs                                         --> 
   <!-- ======================================================================================= -->
   
   
   <ajc-test dir="java5/annotations/binding" title="simple binding annotation values where itd method is annotated via declare">
      <compile files="BindingWithDeclaredAnnotationItds1.aj" options="-1.5"/>
      <run class="BindingWithDeclaredAnnotationItds1">
        <stderr>
          <line text="Found orange at jp call(int A.m()) (BindingWithDeclaredAnnotationItds1.aj:16)"/>
          <line text="Found orange at jp execution(int A.m()) (BindingWithDeclaredAnnotationItds1.aj:8)"/>
          <line text="Found banana at jp call(int A.n()) (BindingWithDeclaredAnnotationItds1.aj:17)"/>
          <line text="Found banana at jp execution(int A.n()) (BindingWithDeclaredAnnotationItds1.aj:10)"/>
          <line text="Found tomato at jp call(int A.o()) (BindingWithDeclaredAnnotationItds1.aj:18)"/>
          <line text="Found tomato at jp execution(int A.o()) (BindingWithDeclaredAnnotationItds1.aj:12)"/>
        </stderr>
      </run>
   </ajc-test>
   
   <ajc-test dir="java5/annotations/binding" title="simple binding annotation values where itd field is annotated via declare">
      <compile files="BindingWithDeclaredAnnotationItds2.aj" options="-1.5"/>
      <run class="BindingWithDeclaredAnnotationItds2">
        <stderr>
          <line text="Found orange at jp set(int A.i) (BindingWithDeclaredAnnotationItds2.aj:16)"/>
        </stderr>
      </run>
   </ajc-test>
   
    <ajc-test dir="java5/annotations/binding" title="simple binding annotation values where itd field is annotated multiple times via declare">
      <compile files="BindingWithDeclaredAnnotationItds3.aj" options="-1.5"/>
      <run class="BindingWithDeclaredAnnotationItds3">
        <stderr>
        </stderr>
      </run>
   </ajc-test>
   
   <ajc-test dir="java5/annotations/binding" title="simple binding annotation values where itd ctor is annotated via declare">
      <compile files="BindingWithDeclaredAnnotationItds4.aj" options="-1.5"/>
      <run class="BindingWithDeclaredAnnotationItds4">
        <stderr>
          <line text="Found pear at jp execution(A(String)) (BindingWithDeclaredAnnotationItds4.aj:8)"/>
        </stderr>
      </run>
   </ajc-test>
   <!-- ============================================================== -->
======= 0d14ccf:"weaver/src/org/aspectj/weaver/NewFieldTypeMunger.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/ResolvedMember.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/ResolvedMember.java"

    private Set annotationTypes = null;
======= 0d14ccf:"weaver/src/org/aspectj/weaver/ResolvedMember.java"

        if (annotationTypes==null) return false;
======= 0d14ccf:"weaver/src/org/aspectj/weaver/ResolvedMember.java"

    	if (annotationTypes == null) return null;
======= 0d14ccf:"weaver/src/org/aspectj/weaver/ResolvedMember.java"

        if (annotationTypes!=null) {
          Set r = new HashSet();
          for (Iterator iter = annotationTypes.iterator(); iter.hasNext();) {
======= 0d14ccf:"weaver/src/org/aspectj/weaver/ResolvedMember.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

 	        isChanged = weaveAtMethodOnITDSRepeatedly(allDecams,itdMethodsCtors,reportedProblems);
            
======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

    /**
     * Get a subset of all the type mungers defined on this aspect
     */
    /**
     * Applies some set of declare @field constructs (List<DeclareAnnotation>) to some bunch 
     * of ITDfields (List<BcelTypeMunger>.  It will iterate over the fields repeatedly until
     * everything has been applied.
     * 
     */
                List forRemoval = new ArrayList();
                for (Iterator iter2 = worthRetrying.iterator(); iter.hasNext();) {
                }
     * Applies some set of declare @method/@ctor constructs (List<DeclareAnnotation>) to some bunch 
     * of ITDmembers (List<BcelTypeMunger>.  It will iterate over the fields repeatedly until
     * everything has been applied.
     */
                List forRemoval = new ArrayList();
                for (Iterator iter2 = worthRetrying.iterator(); iter.hasNext();) {
                }
     * the interfieldinit method in the aspect, but the public field is placed in the target
     * type and then is processed in the 2nd pass over fields that occurs.  I think it would be
     * more expensive to avoid putting the annotation on that inserted public field than just to
     * have it put there as well as on the interfieldinit method.
======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        List decaFs = getMatchingSubset(allDecafs,clazz.getType());
======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

      		    new String[]{rm.toString(),deca.getAnnotationTypeX().toString()},
      		    rm.getSourceLocation(),new ISourceLocation[]{deca.getSourceLocation()});
======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    	// FIXME asc Refactor this code, there is duplication
    	ResolvedMember itdMember =null;
    	Member relevantMember = getSignature();
    	TypeX  relevantType   = null;
    	TypeX aspect = null;
    		
    	} else if (getKind() == Shadow.MethodCall  || getKind() == Shadow.ConstructorCall) {
            relevantMember = findMethod2(relevantType.getDeclaredMethods(world),getSignature());
    		
    		annotations = relevantMember.getAnnotationTypes();
    		
    	} else if (getKind() == Shadow.FieldSet || getKind() == Shadow.FieldGet) {
    		relevantMember = findField(relevantType.getDeclaredFields(world),getSignature());
    		
              // check the ITD'd dooberries
    		annotations = relevantMember.getAnnotationTypes();
    		
    	} else if (getKind() == Shadow.MethodExecution || getKind() == Shadow.ConstructorExecution || 
    		        getKind() == Shadow.AdviceExecution) {
    		relevantMember = findMethod2(relevantType.getDeclaredMethods(world),getSignature());
    		
    		annotations = relevantMember.getAnnotationTypes();
    		
    	} else if (getKind() == Shadow.ExceptionHandler) {
    		relevantType = getSignature().getParameterTypes()[0];
    		annotations  =  relevantType.resolve(world).getAnnotationTypes();
    		
    	} else if (getKind() == Shadow.PreInitialization || getKind() == Shadow.Initialization) {
    		ResolvedMember found = findMethod2(relevantType.getDeclaredMethods(world),getSignature());
    		throw new BCException("Couldn't discover annotations for shadow: "+getKind());
    		kindedAnnotationVars.put(aTX,kaav);
    
    
    private ResolvedMember findMethod(ResolvedTypeX aspectType, ResolvedMember ajcMethod) {
       ResolvedMember decMethods[] = aspectType.getDeclaredMethods();
       for (int i = 0; i < decMethods.length; i++) {
   
======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

   // private AnnotationGen[]  annotations;
======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    	if (returnType != null) return; 
======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        if (memberView!=null && memberView.getAnnotations()!=null && memberView.getAnnotations().length!=0) {
          for (int i = 0, len = ans.length; i < len; i++) {
            gen.addAnnotation(new AnnotationGen(a,gen.getConstantPool(),true));
======= 0d14ccf:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= 0d14ccf:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"


======= fb01cad:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fb01cad:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fb01cad:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= fb01cad:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testIntroSample() {
  }
  
======= fb01cad:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

    
    <ajc-test dir="../docs/dist/doc/examples/introduction" title="introduction sample" vm="1.5">
        <compile files="CloneablePoint.java,ComparablePoint.java,HashablePoint.java,Point.java" options="-1.5"/>
    </ajc-test>
    <!-- Generics tests -->
    <ajc-test dir="java5/generics" title="ITD with parameterized type" vm="1.5">
        <compile files="ITDReturningParameterizedType.aj" options="-1.5"/>
        <run class="ITDReturningParameterizedType"/>
    </ajc-test>
 

  
   <sect1>
      <title>Tools</title>
      
      <sect2>
          <title>Aspectpath</title>
          
          <para>AspectJ 5 allows the specification of directories (containing .class files) on the aspectpath in
              addition to jar/zip files.</para>
      </sect2>
      
    </sect1>
======= 68f6350:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

                        if (jarFile.exists() && (FileUtil.hasZipSuffix(filename) || jarFile.isDirectory())) {
======= 68f6350:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= 68f6350:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= 68f6350:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= 68f6350:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= 68f6350:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testAspectpathdirs() {
  }
  
        
    <!-- ============================================================== -->
    
    <ajc-test dir="options/aspectpath" title="dirs on aspectpath">
        <compile files="MyAspect.aj" options="-d out"/>
        <compile files="MyClass.java" options="-aspectpath out">
            <message kind="warning" line="3" text="a method"/>
        </compile>
    </ajc-test>
======= 68f6350:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 68f6350:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


======= b0f270e:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= b0f270e:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"


======= b5f4d09:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void testVarargsInConsBug() {
  }
  
    <ajc-test dir="java5/varargs" title="varargs in constructor sig" vm="1.5">
        <compile files="Pr88652.aj" options="-1.5">
            <message kind="warning" line="8" text="should match"/>
            <message kind="warning" line="9" text="should match"/>        
        </compile>
    </ajc-test>
======= b5f4d09:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= b5f4d09:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= b5f4d09:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= b5f4d09:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"


======= 85aa152:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= 85aa152:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= 85aa152:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

  
  pointcut ii(I i) : execution(* I.*(..)) && this(i);
  after(I i) returning : ii(i) {
      System.out.println(i);
  }
  
======= 85aa152:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void npeOnTypeNotFound() {
  }
  
    <ajc-test dir="bugs150/pr87376" title="structure model npe on type not found">
        <compile files="I.java,NPE.aj" options="-emacssym">
            <message kind="error" line="8" text="I cannot be resolved to a type"/>
            <message kind="error" line="10" text="I cannot be resolved to a type"/>
        </compile>
    </ajc-test>
    

======= f90186c:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= f90186c:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

    	if (isNamePatternStar()) {
======= f90186c:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"


    }
    
    public AST() { } 
    
    public AST(T element) {  }
======= 5765d53:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

======= 5765d53:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

 * Created on Jan 27, 2005
  */
 * @author Mik Kersten
 */
    
    private AsmManager manager = null;
 
    
======= 5765d53:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= 5765d53:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= 5765d53:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"


======= 7b4c7d7:"bcel-builder/src/org/aspectj/apache/bcel/generic/MethodGen.java"

 * @version $Id: MethodGen.java,v 1.3 2005/01/26 14:01:30 aclement Exp $
======= 7b4c7d7:"bcel-builder/src/org/aspectj/apache/bcel/generic/MethodGen.java"

  public String[] getArgumentNames()                   { 
  	if (arg_names!=null) return (String[])arg_names.clone(); 
  	else                 return new String[0];
  }

    public static void main(String[] args) {
        new NestedTest().run();
        int c = PertypewithinTest.aspectOf(PR83563_1.class).cnt;
        if (c!=2)
          throw new RuntimeException("Expected 2 advice executions: "+c);
    }
    static class NestedTest implements Runnable {
        public void run() {
            System.out.println("Running...");
        }
    }
 
    public static int cnt = 0;
    before() : execution(* *.*(..)) {
        cnt++;
        System.out.println(thisJoinPointStaticPart);
    }	
    public void bar() {
        new Runnable() {
            public void run() {
                System.out.println("Running...");
            }
        }.run();
    }
        
    public static void main(String[] args) {
        new PR83563_2().bar();
        int c = PertypewithinTest.aspectOf(PR83563_2.class).cnt;
        if (c!=3)
          throw new RuntimeException("Expected 3 advice executions but got:"+c);
    }
 
    public static int cnt = 0;
    before() : execution(* *.*(..)) {
        cnt++;
        System.out.println(thisJoinPoint);
    }    
======= 1b01255:"tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.java"

  
  public void testPerTypeWithinMissesNamedInnerTypes() {
  	CompilationResult cR = ajc(baseDir,new String[]{"PR83563_1.java"});
  	assertTrue("Should be no errors:"+cR,!cR.hasErrorMessages());
  	RunResult rR = run("PR83563_1");
  }
  
  public void testPerTypeWithinMissesAnonymousInnerTypes() {
  	CompilationResult cR = ajc(baseDir,new String[]{"PR83563_2.java"});
  	assertTrue("Should be no errors:"+cR,!cR.hasErrorMessages());
  	RunResult rR = run("PR83563_2");
  }
======= 1b01255:"weaver/src/org/aspectj/weaver/PerTypeWithinTargetTypeMunger.java"

======= 1b01255:"weaver/src/org/aspectj/weaver/PerTypeWithinTargetTypeMunger.java"

======= 1b01255:"weaver/src/org/aspectj/weaver/patterns/PerTypeWithin.java"


======= 5d281fd:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

            if (!Modifier.isAbstract(sig.getModifiers())) {
======= 5d281fd:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

  protected void m1 (){System.err.println("A.m1()");}
  public static void main(String []argv) {
    System.err.println("Hi");
    new PR83303().m1();
  }
  declare parents: PR83303 implements I;
  public void PR83303.m1(){System.err.println("ITD version of m1");}
  public void m1();
======= 5d281fd:"tests/src/org/aspectj/systemtest/ajc150/Ajc150TestsNoHarness.java"

  public void testCanOverrideProtectedMethodsViaITDandDecp_pr83303() {
  	CompilationResult cR = ajc(baseDir,new String[]{"PR83303.java"});
  	assertTrue("Should be no errors:"+cR,!cR.hasErrorMessages());
  }
  

======= b460597:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

    static String docVisibilityModifier;
======= b460597:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        docVisibilityModifier = docModifier;
======= b460597:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

            if (isAboveVisibility(decl.getNode())) {
======= b460597:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        // Change "Class" to "Aspect"
        // HACK: depends on matching presence of advice or pointcut summary
        int classStartIndex = fileContents.toString().indexOf("<BR>\nClass ");
        int pointcutSummaryIndex = fileContents.toString().indexOf("Pointcut Summary");
        int adviceSummaryIndex = fileContents.toString().indexOf("Advice Summary");
        	(adviceSummaryIndex != -1 || pointcutSummaryIndex != -1)) {
======= b460597:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

======= b460597:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        if (!declsAboveVisibilityExist(decls)) return;
        
======= b460597:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

            if (isAboveVisibility(decl)) {                
                // insert the table row accordingly
                String comment = generateSummaryComment(decl);
                String entry = "";
                if ( kind.equals( "Advice Summary" ) ) {
                    entry +=
                            "<TR><TD>" +
                            "<A HREF=\"#" + generateHREFName(decl) + "\">" +
                            "<TT>" + generateAdviceSignatures(decl) +
    						"</TT></A><BR>&nbsp;";
                    if (!comment.equals("")) {
                        entry += comment + "<P>";
                    }
                    entry +=
                            generateAffects(decl, false) + "</TD>" +
                            "</TR><TD>\n";
                else if ( kind.equals( "Pointcut Summary" ) ) {
                    entry +=
                            "<TR><TD WIDTH=\"1%\">" +
                            "<FONT SIZE=-1><TT>" + genAccessibility(decl) + "</TT></FONT>" +
                            "</TD>\n" +
                            "<TD>" +
                            "<TT><A HREF=\"#" + generateHREFName(decl) + "\">" +
                            decl.toLabelString() + "</A></TT><BR>&nbsp;";
                    if (!comment.equals("")) {
                        entry += comment + "<P>";
                    }
                    entry +=
                            "</TR></TD>\n";
                else if ( kind.equals( "Introduction Summary" ) ) {
                    entry +=
                            "<TR><TD WIDTH=\"1%\">" +
                            "<FONT SIZE=-1><TT>" + decl.getModifiers() + "</TT></FONT>" +
                            "</TD>" +
                            "<TD>" +
                            "<A HREF=\"#" + generateHREFName(decl) + "\">" +
                            "<TT>introduction " + decl.toLabelString() + "</TT></A><P>" +
                            generateIntroductionSignatures(decl, false) +
                            generateAffects(decl, true);
                }
    
                // insert the entry
                fileBuffer.insert(insertIndex, entry);
                insertIndex += entry.length();
======= b460597:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

    
    private static boolean declsAboveVisibilityExist(List decls) {
        boolean exist = false;
        for (Iterator it = decls.iterator(); it.hasNext();) {
            IProgramElement element = (IProgramElement) it.next();
            if (isAboveVisibility(element)) exist = true;
        }
        return exist;
    }
    private static boolean isAboveVisibility(IProgramElement element) {
        return 
            (docVisibilityModifier.equals("private")) || // everything
            (docVisibilityModifier.equals("package") && element.getAccessibility().equals(IProgramElement.Accessibility.PACKAGE)) || // package
            (docVisibilityModifier.equals("protected") && (element.getAccessibility().equals(IProgramElement.Accessibility.PROTECTED) ||
                    element.getAccessibility().equals(IProgramElement.Accessibility.PUBLIC))) ||
            (docVisibilityModifier.equals("public") && element.getAccessibility().equals(IProgramElement.Accessibility.PUBLIC));
    }
======= b460597:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        if (!declsAboveVisibilityExist(decls)) return;
======= b460597:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

            if (isAboveVisibility(decl)) {
                String entry = "";
    
                // insert the table row accordingly
                entry +=  "<A NAME=\"" + generateHREFName(decl) + "\"><!-- --></A>\n";
                if ( kind.equals( "Advice Detail" ) ) {
                    entry += "<H3>" + decl.getName() + "</H3><P>";
                    entry +=
                            "<TT>" +
                            generateAdviceSignatures(decl) + "</TT>\n" + "<P>" +
                            generateDetailsComment(decl) + "<P>" +
                            generateAffects(decl, false);
                }
                else if (kind.equals("Pointcut Detail")) {
                    entry +=
                            "<H3>" +
                            decl.toLabelString() +
                            "</H3><P>" +
                            generateDetailsComment(decl);
                }
                else if (kind.equals("Introduction Detail")) {
                	entry += "<H3>introduction " + decl.toLabelString() + "</H3><P>";
                    entry +=
                            generateIntroductionSignatures(decl, true) +
                            generateAffects(decl, true) +
                            generateDetailsComment(decl);
                }
    
                // insert the entry
                if (i != decls.size()-1) {
                    entry += "<P><HR>\n";
                }
                else {
                    entry += "<P>";
                }
                fileBuffer.insert(insertIndex, entry);
                insertIndex += entry.length();
======= b460597:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

                } 
======= b460597:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

======= b460597:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

 * Created on Jan 12, 2005
 */
 * @author Mik Kersten
 */
    private pointcut privatePointcut ();
    protected pointcut protectedPointcut ();
    public pointcut publicPointcut ();
    
    private void privateMethod () {
        
    }
    
    public void protectedMethod () {
        
    }
    
    public void publicMethod () {
        
    }
======= b460597:"ajdoc/testdata/coverage/foo/NoMembers.java"

======= b460597:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

======= b460597:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

 * Created on Jan 12, 2005
  */
 * @author Mik Kersten
 */
    protected File file1 = new File("testdata/bug82340/Pointcuts.java");
    protected File outdir = new File("testdata/bug82340/doc");
    
    public void testCoveragePublicMode() {
        outdir.delete();
        String[] args = { 
              "-XajdocDebug",
            "-protected",
            "-d", 
            outdir.getAbsolutePath(),
            file1.getAbsolutePath()
        };
        org.aspectj.tools.ajdoc.Main.main(args);
    }

======= f70b383:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        if (index1 < index2 && index1 != -1) {
        } else if (index2 != -1){
        } else {
            return index;
======= f70b383:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

        int index3 = fbs.indexOf(MARKER_3, index); 
        if (index1 != -1 && index1 < index2 && index1 < index3) {
        } else if (index2 != -1 && index2 < index1 && index2 < index3) {
        } else if (index3 != -1) {
        } else {
            return index;
======= f70b383:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

 * Created on Jan 12, 2005
  */
 * @author Mik Kersten
 */
    public static boolean isExecutingOnJava5() {
        String version = System.getProperty("java.class.version","44.0");
        return version.equals("49.0");
    }
    
======= f70b383:"ajdoc/testdata/coverage/foo/ModelCoverage.java"

======= f70b383:"ajdoc/testdata/coverage/foo/ModelCoverage.java"

 * Created on Jan 12, 2005
 */
 * @author Mik Kersten
 */
======= f70b383:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

    
======= f70b383:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

    public void testCoveragePublicMode() {
        outdir.delete();
        String[] args = { 
            "-public",
            "-source", 
            "1.4",
            "-d", 
            outdir.getAbsolutePath(),
            file3.getAbsolutePath(),
            file9.getAbsolutePath() 
        };
        org.aspectj.tools.ajdoc.Main.main(args);
    }
    
======= f70b383:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

            file10.getAbsolutePath()
======= f70b383:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

 * Created on Jan 12, 2005
  */
 * @author Mik Kersten
 */
    public void testIsUsing1point5() {
        assertTrue(Util.isExecutingOnJava5());
    }
    

       protected static Integer counter = new Integer(4);
       public static void main(String[] args) throws Exception {
         try {
           doSomething();
           System.err.println("TEST HAS PASSED");
         } catch (Exception e) {
           System.err.println("TEST HAS FAILED: Exception thrown by doSomething: " +e.getMessage());
           throw e;
         }
       }
       public static void doSomething() {
         int i = 0;
         while (i++<1) { 
           counter=null;
           try {
             counter = new Integer(4);
             // The inclusion of the next line changes the weaving !  If it is included the woven code is wrong and the exception escapes
              if (counter == null) { break; }
             commit();
           } catch (Throwable e) {
             System.err.println("Caught exception " + e);
           } finally {
             System.err.println("In finally block");
           }
         }
       }
       protected static void commit() throws MyException {
         System.err.println("Main.commit");
       }
   pointcut commitOperation() : call (* PR78021+.commit(..));
   before() throws MyException : commitOperation() {
        throw new MyException("Dummy My Exception", "55102");
   }
 * Created on 22.10.2004
 */
 * @author Thomas Knauth
 */
    public static void main(String[] args)
    {
        try
        {
        }
        catch ( Throwable e )
        {
            System.out.println( "exception caught!" );
            //e.printStackTrace();
        }
        finally
        {
        	System.out.println("finally block entered!");
        }
    }
  
======= 603b063:"tests/src/org/aspectj/systemtest/AllTests.java"

======= 603b063:"tests/src/org/aspectj/systemtest/AllTests.java"

======= 603b063:"tests/src/org/aspectj/systemtest/AllTests.java"

 * Copyright (c) 2005 IBM 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
 */
  protected void setUp() throws Exception {
  }
  
  public void testIncorrectExceptionTableWhenBreakInMethod_pr78021() {
  	RunResult rR = run("PR78021");
  	if (verbose) {System.err.println(rR.getStdErr());}
  }
  
  public void testIncorrectExceptionTableWhenReturnInMethod_pr79554() {
  	RunResult rR = run("PR79554");
  	if (verbose) {System.err.println(rR.getStdErr());}
  }
======= 603b063:"tests/src/org/aspectj/systemtest/AllTests.java"

 * Copyright (c) 2004 IBM 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
 * @author colyer
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
======= 603b063:"tests/src/org/aspectj/systemtest/ajc150/AllTestsJava5_binaryWeaving.java"

======= 603b063:"tests/src/org/aspectj/systemtest/ajc150/TestUtils.java"

======= 603b063:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= 603b063:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= 603b063:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    // Update to all these comments, ASC 11-01-2005
    // The right thing to do may be to do more with priorities as
    // we create new exception handlers, but that is a relatively
    // complex task.  In the meantime, just taking account of the
    // priority here enables a couple of bugs to be fixed to do
    // with using return or break in code that contains a finally
    // block (pr78021,pr79554).
    
======= 603b063:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    	// Old implementation, simply:   l.add(0,fresh);
    	for (ListIterator iter = l.listIterator(); iter.hasNext();) {
            ExceptionRange r = (ExceptionRange) iter.next();
            int freal = fresh.getRealStart().getPosition();
            int rreal = r.getRealStart().getPosition();
            if (fresh.getPriority() >= r.getPriority()) {
                iter.previous();
                iter.add(fresh);
                return;
            }
        }
    	
    	// we have reached the end
        l.add(fresh);        
    | | | catch java.lang.Throwable -> E3
    | | | catch java.lang.Throwable -> E3
    | | |       E3: ASTORE 5
    | | finally -> E5
    | | | catch java.lang.Exception -> E4
    | | | catch java.lang.Exception -> E4
    | | |       E4: ASTORE_2   (line 12)
    | | finally -> E5
    | |         E5: ASTORE 4   (line 14)
    | | | catch java.lang.Throwable -> E3
    | | | catch java.lang.Throwable -> E3
    | | |       E3: ASTORE 5
    | | finally -> E5
    | | | catch java.lang.Exception -> E4
    | | | catch java.lang.Exception -> E4
    | | |       E4: ASTORE_2   (line 12)
    | | finally -> E5
    | |         E5: ASTORE 4   (line 14)
    | | catch java.lang.Throwable -> E0
    | | catch java.lang.Throwable -> E0
    | |         E0: ASTORE 5
    | finally -> E2
    | | catch java.lang.Exception -> E1
    | | catch java.lang.Exception -> E1
    | |         E1: ASTORE_2   (line 12)
    | finally -> E2
    |           E2: ASTORE 4   (line 14)

======= 797b6a6:"tests/src/org/aspectj/systemtest/ajc150/AllTestsJava5_binaryWeaving.java"

======= 797b6a6:"tests/src/org/aspectj/systemtest/ajc150/AllTestsJava5_binaryWeaving.java"

 * Copyright (c) 2004 IBM 
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 *
 * Contributors:
 *    Andy Clement - initial API and implementation
 *******************************************************************************/
 * Checks if we are obeying migration rules. 
 */
  protected void setUp() throws Exception {
  }
  /**
   * Compile a simple java class with an aspect library built with aspectj 1.2.1 - this
   * checks that we can load in attributes (especially pointcuts) that were written out
   * in the 'old way'
   *
   */
  public void testMigrationFrom121_pointcutsAndAdvice() {
  	CompilationResult cR = ajc(baseDir,new String[]{"-aspectpath","aspects121.jar","Program.java"});
  	System.err.println(cR.getStandardError());
  	assertTrue("Should not coredump: "+cR.getStandardError(),cR.getStandardError().indexOf("Dumping to ajcore")==-1);
    assertTrue("Should be no error messages: \n"+cR.getErrorMessages(),cR.getErrorMessages().size()==0);
    File f = new File(ajc.getSandboxDirectory()+File.separator+"Program.class");
    assertTrue("Missing class file",f.exists());
  	run("Program");
  }
  
 
======= 797b6a6:"weaver/src/org/aspectj/weaver/AdviceKind.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/AdviceKind.java"

    public static AdviceKind read(VersionedDataInputStream s) throws IOException {
======= 797b6a6:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.java"

 * Copyright (c) 2005 IBM
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Andy Clement           initial implementation
 * ******************************************************************/
 * Lightweight subclass of DataInputStream that knows what version of the weaver was used to construct the data in it.
 */
======= 797b6a6:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/bcel/BcelField.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/bcel/BcelMethod.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/AndAnnotationTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/AndAnnotationTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/AndPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/AndPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/AndPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/AndTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/AndTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/AnnotationPatternList.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/AnnotationPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ArgsAnnotationPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/BindingAnnotationTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/BindingTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/BindingTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/Declare.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/Declare.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/DeclareErrorOrWarning.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/DeclareParents.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/DeclareParents.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/DeclareParents.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

    }
======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ModifiersPattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ModifiersPattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/NamePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/NamePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/NotAnnotationTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/NotAnnotationTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/NotPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/NotPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/NotPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/NotTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/NotTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/OrAnnotationTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/OrAnnotationTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/OrPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/OrPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/OrPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/OrTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/OrTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/PerCflow.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/PerCflow.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/PerCflow.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/PerClause.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/PerClause.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/PerClause.java"

        public static Kind read(VersionedDataInputStream s) throws IOException {
======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/PerObject.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/PerObject.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/PerObject.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/PerSingleton.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/PerSingleton.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/PerSingleton.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetAnnotationPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/TypePatternList.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/TypePatternList.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/TypePatternList.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/WildAnnotationTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

    }
    public static TypePattern readTypePattern150(VersionedDataInputStream s, ISourceContext context) throws IOException {
    
======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/WithinAnnotationPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/WithinCodeAnnotationPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

======= 797b6a6:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"

======= 797b6a6:"weaver/testsrc/org/aspectj/weaver/bcel/PatternWeaveTestCase.java"

======= 797b6a6:"weaver/testsrc/org/aspectj/weaver/bcel/PointcutResidueTestCase.java"

======= 797b6a6:"weaver/testsrc/org/aspectj/weaver/patterns/AndOrNotTestCase.java"

======= 797b6a6:"weaver/testsrc/org/aspectj/weaver/patterns/DeclareErrorOrWarningTestCase.java"

======= 797b6a6:"weaver/testsrc/org/aspectj/weaver/patterns/DeclareErrorOrWarningTestCase.java"

======= 797b6a6:"weaver/testsrc/org/aspectj/weaver/patterns/ModifiersPatternTestCase.java"

======= 797b6a6:"weaver/testsrc/org/aspectj/weaver/patterns/NamePatternTestCase.java"

======= 797b6a6:"weaver/testsrc/org/aspectj/weaver/patterns/NamePatternTestCase.java"

======= 797b6a6:"weaver/testsrc/org/aspectj/weaver/patterns/SignaturePatternTestCase.java"

======= 797b6a6:"weaver/testsrc/org/aspectj/weaver/patterns/TypePatternListTestCase.java"

======= 797b6a6:"weaver/testsrc/org/aspectj/weaver/patterns/TypePatternTestCase.java"

======= 797b6a6:"weaver/testsrc/org/aspectj/weaver/patterns/WithinTestCase.java"


======= 8a8930f:"tests/java5/annotations/within/PlainWithin.java"

======= 8a8930f:"tests/src/org/aspectj/systemtest/ajc150/AnnotationPointcutsTests.java"

  public void test003_Within_Code() {
  	baseDir = new File("../tests/java5/annotations/within_code");
      CompilationResult cR = binaryWeave("TestingAnnotations.jar","WithinAndWithinCodeTests.java",0,5);
      List warnings = new ArrayList();
      warnings.add(new Message(32,"@within match on non-inherited annotation"));
      warnings.add(new Message(39,"@within match on non-inherited annotation"));
      warnings.add(new Message(39,"@within match on inheritable annotation"));
      warnings.add(new Message(43,"@within match on inheritable annotation"));
      warnings.add(new Message(32,"@withincode match"));
      MessageSpec mSpec = new MessageSpec(warnings,new ArrayList());
      assertMessages(cR,mSpec); 	
  }
  
  public void test004_Within() {
    	baseDir = new File("../tests/java5/annotations/within");
        CompilationResult cR = binaryWeave("PlainWithin.jar","PlainWithinTests.java",0,2);
        List warnings = new ArrayList();
        warnings.add(new Message(21,"positive within match on annotation"));
        warnings.add(new Message(25,"negative within match on annotation"));
        MessageSpec mSpec = new MessageSpec(warnings,new ArrayList());
        assertMessages(cR,mSpec); 	
    }
======= 8a8930f:"tests/src/org/aspectj/systemtest/ajc150/AnnotationRuntimeTests.java"

======= 8a8930f:"weaver/src/org/aspectj/weaver/patterns/AnnotationTypePattern.java"

    public FuzzyBoolean fastMatches(AnnotatedElement annotated) {
        return FuzzyBoolean.YES;
    }
    
======= 8a8930f:"weaver/src/org/aspectj/weaver/patterns/ExactAnnotationTypePattern.java"

======= 8a8930f:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

======= 8a8930f:"weaver/src/org/aspectj/weaver/patterns/HandlerPointcut.java"

======= 8a8930f:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= 8a8930f:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= 8a8930f:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

    public void resolve(World world) {
        annotationPattern.resolve(world);
    }
    
======= 8a8930f:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= 8a8930f:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= 8a8930f:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= 8a8930f:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"


======= 9897659:"bridge/src/org/aspectj/bridge/WeaveMessage.java"

     * @return new weaving message
     */
    /**
     * Static helper method for constructing weaving messages.
     * @param kind what kind of message (e.g. declare parents)
     * @param inserts inserts for the message (inserts are marked %n in the message)
======= 9897659:"weaver/src/org/aspectj/weaver/Advice.java"

======= 9897659:"weaver/src/org/aspectj/weaver/Shadow.java"

======= 9897659:"weaver/src/org/aspectj/weaver/Shadow.java"

======= 9897659:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= 9897659:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

        					 fName+":'"+munger.getSignature()+"'"},
======= 9897659:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= 9897659:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"


======= 427c0d3:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"


======= 9052d5d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= 9052d5d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= 9052d5d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= 9052d5d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= 9052d5d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= 9052d5d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= 9052d5d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

  declare parents: A+ implements java.io.Serializable;
======= 9052d5d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= 9052d5d:"tests/src/org/aspectj/systemtest/ajc150/Ajc150Tests.java"

  public void test_typeProcessingOrderWhenDeclareParents() {
  		runTest("Order of types passed to compiler determines weaving behavior");
  		System.err.println(ajc.getLastCompilationResult().getStandardError());
   
    <ajc-test dir="decp" pr="80249" title="Order of types passed to compiler determines weaving behavior">
        <compile files="A.java,B.java,AspectX.java"/>
        <run class="B"/>
        <compile files="B.java,A.java,AspectX.java"/>
        <run class="B"/>
    </ajc-test>

       <!-- run application with LTW to add tracing -->
       	 <sysproperty key="org.aspectj.weaver.showWeaveInfo" value="True"/>
======= edd6539:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= edd6539:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= edd6539:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= edd6539:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= edd6539:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= edd6539:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= edd6539:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= edd6539:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= edd6539:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= edd6539:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= edd6539:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= edd6539:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= edd6539:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= edd6539:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= edd6539:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= edd6539:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= edd6539:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= edd6539:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= edd6539:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= edd6539:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= edd6539:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= edd6539:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"


======= aab9c2c:"ajde/src/org/aspectj/ajde/ui/StructureSearchManager.java"


======= 6aa7516:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= 6aa7516:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= 6aa7516:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= 6aa7516:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= 6aa7516:"weaver/src/org/aspectj/weaver/AjAttribute.java"

======= 6aa7516:"weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java"

======= 6aa7516:"weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java"

======= 6aa7516:"weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java"

======= 6aa7516:"weaver/src/org/aspectj/weaver/bcel/BcelField.java"

======= 6aa7516:"weaver/src/org/aspectj/weaver/bcel/BcelMethod.java"

======= 6aa7516:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= 6aa7516:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= 6aa7516:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= 6aa7516:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= 6aa7516:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

        
        // Add a weaver version attribute to the file being produced
        myGen.addAttribute(BcelAttributes.bcelAttribute(new AjAttribute.WeaverVersionInfo(),getConstantPoolGen()));
        if (myType != null && myType.getWeaverState() != null) {
======= 6aa7516:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"


======= 8a64fa2:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

            ResolvedMember[] b = other.getDeclaredMethods();  //??? is this cast always safe

    static public void main (String [] args) { }
    static private int level = 0;
    static private void offset() {
        for (int i = 0; i < level; ++i)  System.err.print("  ");
    }
    pointcut pc() : 
        !cflow(within(Trace*))
        ;
    before () : pc() {
        offset();
        System.err.println("-> " + thisJoinPoint);
        ++level;
    }
    after  () : pc() {
        --level;
        offset();
        System.err.println("<- " + thisJoinPoint);
    }
    static private int level = 0;
    static private void offset() {
        for (int i = 0; i < level; ++i)         System.err.print("  ");
    }
    
    pointcut pc() : within(TraceClass);
    before () : pc() {
        offset();
        System.err.println("=> " + thisJoinPoint);
        ++level;
    }
    after  () : pc() {
        --level;
        offset();
        System.err.println("<= " + thisJoinPoint);
    }
======= a303a09:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

======= a303a09:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
  private int countLines(String s) {
    int lines = 0;
    int idx = 0;
    while (s.indexOf("\n",idx)!=-1) {
    	lines++;
    	idx = s.indexOf("\n",idx)+1;
    }
    return lines;
  }
  
  public void test065() {
  	runTest("before,after not (cflow(within(Trace*))) prints nothing");
  	String s = getLastRunResult().getStdErr();
  	int lines = countLines(s);
  }
    
    <ajc-test dir="bugs" pr="74952" title="before,after not (cflow(within(Trace*))) prints nothing">
        <compile files="WhatsGoingOn.java"/>
        <run class="WhatsGoingOn"/>
    </ajc-test>
======= a303a09:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= a303a09:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        	/*
        	 * 
 27:  getstatic       #72; //Field ajc$cflowCounter$0:Lorg/aspectj/runtime/internal/CFlowCounter;
 30:  invokevirtual   #87; //Method org/aspectj/runtime/internal/CFlowCounter.dec:()V
 33:  aload   6
 35:  athrow
 36:  nop
 37:  getstatic       #72; //Field ajc$cflowCounter$0:Lorg/aspectj/runtime/internal/CFlowCounter;
 40:  invokevirtual   #87; //Method org/aspectj/runtime/internal/CFlowCounter.dec:()V
 43:  d2i
 44:  invokespecial   #23; //Method java/lang/Object."<init>":()V
        	 */
======= a303a09:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        } else {            
======= a303a09:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= a303a09:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"


======= 6beb43f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= 6beb43f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= 6beb43f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

 public void a1();
 public void a2();
  public void a1() {
    System.out.println("AbstractClassA.a()");
  }
  public void someMethod() {
    InterfaceA a = new AbstractClassA() {  };
    a.a2(); 
  }
  
  public static void main(String[]argv) {
  	new ConcreteClassA().someMethod();
  	new concCB().someMethod();
  }
  public void AbstractClassA.a2() {
    System.out.println("AbstractClassA.a2() from IntroAspectA");
  }
======= 6beb43f:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  public void test064() {
  	runTest("Anonymous classes unaware of introductions into abstract classes");
  }
    
    <ajc-test dir="bugs/pr76096" pr="76096" title="Anonymous classes unaware of introductions into abstract classes">
        <compile files="ConcreteClassA.java"/>
        <run class="ConcreteClassA"/>
    </ajc-test>

======= 0a77939:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

            } else if (arg.equals("-proceedOnError")) {
            	buildConfig.setProceedOnError(true);
======= 0a77939:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

                // -g:[...], -preserveAllLocals,
======= 0a77939:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= 0a77939:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= 0a77939:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= 0a77939:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= 0a77939:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= 0a77939:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 0a77939:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 0a77939:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= 0a77939:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AspectJBuilder.java"

======= 0a77939:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AspectJBuilder.java"

======= 0a77939:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AspectJBuilder.java"

======= 0a77939:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java"

        suite.addTestSuite(ProceedOnErrorTestCase.class);
======= 0a77939:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java"

 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     PARC     initial implementation 
 * ******************************************************************/
        // Without -proceedOnError supplied, we should *not* change the time stamp on the .class file
        // Without -proceedOnError supplied, we should *not* change the time stamp on the .class file

 * Created on 28-Sep-2004
 *
 * TODO To change the template for this generated file go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
 * @author websterm
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
 * Created on 28-Sep-2004
 *
 * TODO To change the template for this generated file go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
 * @author websterm
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
======= 6e155a6:"runtime/src/org/aspectj/runtime/internal/CFlowCounter.java"

======= 6e155a6:"runtime/src/org/aspectj/runtime/internal/CFlowCounter.java"

======= 6e155a6:"runtime/src/org/aspectj/runtime/internal/CFlowStack.java"

======= 6e155a6:"runtime/src/org/aspectj/runtime/internal/CFlowStack.java"


======= eca1429:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= eca1429:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= eca1429:"tests/bugs/ConvertToUnchecked.java"

======= eca1429:"tests/bugs/ConvertToUnchecked.java"

    public PR72157() throws Exception {
        throw new Exception();
    }
    public static void main(String[] args) {
        new SCE2();
    }
    public SCE2() {  
        super();    // CE L13?
    }
    
    
    public Foo() throws Exception {
        throw new Exception();
    }
    
    public Goo() {
        new Foo();
    }
    declare soft: Exception: within(SCE2);
    declare soft: Exception: within(Goo);
======= eca1429:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  public void test057_decSoftWithSuper() {
      runTest("declare soft can cause programs with invalid exception behaviour to be generated");
    }
    <ajc-test dir="bugs" pr="72157"
 	      <message kind="error" line="13" text="Unhandled"/>

======= 8e4d898:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"


======= b133299:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= b133299:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= b133299:"ajde/testsrc/org/aspectj/ajde/BuildConfigurationTests.java"

======= b133299:"ajde/testsrc/org/aspectj/ajde/ExtensionTests.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/compiler/IAjTerminalSymbols.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/core/AspectJCore.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjClassFile.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ClassFileBasedByteCodeProvider.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/IOutputClassFileNameProvider.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/InterimCompilationResult.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AdviceDeclaration.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AjConstructorDeclaration.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AjMethodDeclaration.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AstUtil.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/DeclareDeclaration.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/EclipseAttributeAdapter.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/IfMethodDeclaration.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/IfPseudoToken.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperFixerVisitor.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterSuperReference.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeConstructorDeclaration.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeDeclaration.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeFieldDeclaration.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/KnownFieldReference.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/KnownMessageSend.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/MakeDeclsPublicVisitor.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDesignator.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/Proceed.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ProceedVisitor.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PseudoToken.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PseudoTokens.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/SuperFixerVisitor.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjTypeConstants.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseScope.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceLocation.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseTypeMunger.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/HelperInterfaceBinding.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InlineAccessFieldBinding.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeFieldBinding.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMethodBinding.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeScope.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/PointcutBinding.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/PrivilegedFieldBinding.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/PrivilegedHandler.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/SimpleSyntheticAccessMethodBinding.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/parser/DeclarationFactory.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBatchImageBuilder.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildNotifier.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjCompilerOptions.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjIncrementalImageBuilder.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmElementFormatter.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AspectJBuilder.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseClassPathManager.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseSourceContext.java"

======= b133299:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/StatefulNameEnvironment.java"

======= b133299:"org.aspectj.ajdt.core/testsrc/WeaveTests.java"

======= b133299:"org.aspectj.ajdt.core/testsrc/WeaveTests.java"

======= b133299:"org.aspectj.ajdt.core/testsrc/WeaveTests.java"

======= b133299:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/AjdtCommandTestCase.java"

======= b133299:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

======= b133299:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjCompilerOptionsTest.java"

======= b133299:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AsmBuilderTest.java"


======= d1551bd:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= d1551bd:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

        String propcp = properties.getClasspath();
======= d1551bd:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

       
        // Handle boot classpath
        propcp = properties.getBootClasspath();
        if (!LangUtil.isEmpty(propcp)) {
            StringTokenizer st = new StringTokenizer(propcp, File.pathSeparator);
            List configClasspath = config.getBootclasspath();
            ArrayList toAdd = new ArrayList();
            while (st.hasMoreTokens()) {
                String entry = st.nextToken();
                if (!configClasspath.contains(entry)) {
                    toAdd.add(entry);
                }
            }
            if (0 < toAdd.size()) {
                ArrayList both = new ArrayList(configClasspath.size() + toAdd.size());
                both.addAll(configClasspath);
                both.addAll(toAdd);
                config.setBootclasspath(both);
                Ajde.getDefault().logEvent("building with boot classpath: " + both);
            }
        }
       
        
        
======= d1551bd:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= d1551bd:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

    	
    	if (parser.bootclasspath == null) {
    		addClasspath(System.getProperty("sun.boot.class.path", ""), ret);
    	} else {  
    		addClasspath(parser.bootclasspath, ret);
    	}
    	return ret;
======= d1551bd:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= d1551bd:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= d1551bd:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= d1551bd:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= d1551bd:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= d1551bd:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

     * @return List (String) classpath of bootclasspath, injars, inpath, aspectpath 
     *   entries, specified classpath (extdirs, and classpath), and output dir or jar
        full.addAll(getBootclasspath()); // XXX Is it OK that boot classpath overrides inpath/injars/aspectpath?
======= d1551bd:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

            full.add(((File)i.next()).getAbsolutePath());        
======= d1551bd:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d1551bd:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d1551bd:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= d1551bd:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

======= d1551bd:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"


    public static void main(String[] args) {
        ArrayCloning ArrayCloning = new ArrayCloning();
        Integer[] clonedStaticField = ArrayCloning.clone1();
        checkIdentical(clonedStaticField,ArrayCloning.staticField);
    
        Integer[] clonedField = ArrayCloning.clone2();
        checkIdentical(clonedField,ArrayCloning.nonStaticField);
        Integer[] clown = null;
        clown = ArrayCloning.clone3();
        clown = ArrayCloning.clone4();
        Integer[][] ArrayCloningArrayCloning = ArrayCloning.clone5();
    }
    public static void checkIdentical(Integer[] one, Integer[] two) {
      if (one[0]!=two[0]) throw new RuntimeException("Not the same (a)");
      if (one[1]!=two[1]) throw new RuntimeException("Not the same (b)");
    }
    private static Integer[] staticField = new Integer[2];
    private Integer[] nonStaticField = new Integer[2];
    public ArrayCloning() {
      nonStaticField[0] = new Integer(32);
      nonStaticField[1] = new Integer(64);
    }
    static {
      staticField[0] = new Integer(1);
      staticField[1] = new Integer(2);
    }
    
    public Integer[] clone1() {
      System.err.println("Clone call on a static field");
      return (Integer[])staticField.clone();
    }
    public Integer[] clone2() {
       System.err.println("Clone call on a non-static field");
       return (Integer[])nonStaticField.clone();
    }
    public Integer[] clone3() {
       System.err.println("Clone call on a local variable");
       Integer[] ArrayCloningArrayCloning = staticField;
       return (Integer[])ArrayCloningArrayCloning.clone();
    }
    // Clone call on anonymous 'thing' !
    public Integer[] clone4() {
      System.err.println("Clone call on a 1 dimensional anonymous integer array");
      return (Integer[])new Integer[5].clone();
    }
    // Sick
    public Integer[][] clone5() {
      System.err.println("Clone call on a 2 dimensional anonymous integer array");
      return (Integer[][])new Integer[5][3].clone();
    }
    Object[] around(): call(* java.lang.Object.clone()) && within(ArrayCloning) {
  	Object[] ret = proceed(); 
    }
======= 27d204c:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
  public void test056_arrayCloning() {
    runTest("around advice throws java.lang.VerifyError at runtime");
  }
    <ajc-test dir="bugs" pr="72528"
======= 27d204c:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

            // If it ever does, here is the code:
            //  ResolvedMember cloneMethod =
            //    new ResolvedMember(Member.METHOD,this,Modifier.PUBLIC,TypeX.OBJECT,"clone",new TypeX[]{});
            //  return new ResolvedMember[]{cloneMethod};
        	return ResolvedMember.NONE;
======= 27d204c:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 27d204c:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 27d204c:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

            type = ensureTargetTypeIsCorrect(type);
    
    /* PR 72528
     * This method double checks the target type under certain conditions.  The Java 1.4
     * compilers seem to take calls to clone methods on array types and create bytecode that
     * looks like clone is being called on Object.  If we advise a clone call with around
     * advice we extract the call into a helper method which we can then refer to.  Because the
     * type in the bytecode for the call to clone is Object we create a helper method with
     * an Object parameter - this is not correct as we have lost the fact that the actual
     * type is an array type.  If we don't do the check below we will create code that fails
     * java verification.  This method checks for the peculiar set of conditions and if they
     * are true, it has a sneak peek at the code before the call to see what is on the stack.
     */
    public TypeX ensureTargetTypeIsCorrect(TypeX tx) {
    	if (tx.equals(ResolvedTypeX.OBJECT) && getKind() == MethodCall && 
    	    getSignature().getReturnType().equals(ResolvedTypeX.OBJECT) && 
    		
    		// Lets go back through the code from the start of the shadow
            InstructionHandle searchPtr = range.getStart().getPrev();
            while (Range.isRangeHandle(searchPtr) || 
            	   searchPtr.getInstruction() instanceof StoreInstruction) { // ignore this instruction - it doesnt give us the info we want
            	searchPtr = searchPtr.getPrev();  
            }
            
            // A load instruction may tell us the real type of what the clone() call is on
            if (searchPtr.getInstruction() instanceof LoadInstruction) {
            	LoadInstruction li = (LoadInstruction)searchPtr.getInstruction();
            	li.getIndex();
            	LocalVariableTag lvt = LazyMethodGen.getLocalVariableTag(searchPtr,li.getIndex());
            	return lvt.getType();
            }
            // A field access instruction may tell us the real type of what the clone() call is on
            if (searchPtr.getInstruction() instanceof FieldInstruction) {
            	FieldInstruction si = (FieldInstruction)searchPtr.getInstruction();
            	Type t = si.getFieldType(getEnclosingClass().getConstantPoolGen());
            	return BcelWorld.fromBcel(t);
            } 
            // A new array instruction obviously tells us it is an array type !
            if (searchPtr.getInstruction() instanceof ANEWARRAY) {
            	//ANEWARRAY ana = (ANEWARRAY)searchPoint.getInstruction();
            	//Type t = ana.getType(getEnclosingClass().getConstantPoolGen());
            	// Just use a standard java.lang.object array - that will work fine
            	return BcelWorld.fromBcel(new ArrayType(Type.OBJECT,1));
            }
            // A multi new array instruction obviously tells us it is an array type !
            if (searchPtr.getInstruction() instanceof MULTIANEWARRAY) {
            	MULTIANEWARRAY ana = (MULTIANEWARRAY)searchPtr.getInstruction();
                // Type t = ana.getType(getEnclosingClass().getConstantPoolGen());
            	// t = new ArrayType(t,ana.getDimensions());
            	// Just use a standard java.lang.object array - that will work fine
            	return BcelWorld.fromBcel(new ArrayType(Type.OBJECT,ana.getDimensions()));
            }
            throw new BCException("Can't determine real target of clone() when processing instruction "+
              searchPtr.getInstruction());
    	}
    	return tx;
    }
    
    
======= 27d204c:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

            targetType = ensureTargetTypeIsCorrect(targetType);
            
            	!samePackage(targetType.getPackageName(), getEnclosingType().getPackageName()) &&

======= 4921f0c:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

 		
======= 4921f0c:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

            TypeX tx = getArgType(0);
            argVars[0] = genTempVar(tx, "ajc$arg0");
            InstructionHandle insertedInstruction = 
            	range.insert(argVars[0].createStore(getFactory()), Range.OutsideBefore);
            // Now the exception range starts just after our new instruction.
            // The next bit of code changes the exception range to point at
            // the store instruction
======= 4921f0c:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"


======= 438e61c:"runtime/src/org/aspectj/runtime/reflect/AdviceSignatureImpl.java"

    protected String createToString(StringMaker sm) {
======= 438e61c:"runtime/src/org/aspectj/runtime/reflect/CatchClauseSignatureImpl.java"

    protected String createToString(StringMaker sm) {
======= 438e61c:"runtime/src/org/aspectj/runtime/reflect/ConstructorSignatureImpl.java"

    protected String createToString(StringMaker sm) {
======= 438e61c:"runtime/src/org/aspectj/runtime/reflect/Factory.java"

        return new SourceLocationImpl(lexicalClass, this.filename, line);
======= 438e61c:"runtime/src/org/aspectj/runtime/reflect/FieldSignatureImpl.java"

    protected String createToString(StringMaker sm) {
======= 438e61c:"runtime/src/org/aspectj/runtime/reflect/InitializerSignatureImpl.java"

    protected String createToString(StringMaker sm) {
======= 438e61c:"runtime/src/org/aspectj/runtime/reflect/MethodSignatureImpl.java"

    protected String createToString(StringMaker sm) {
======= 438e61c:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

    SoftReference toStringCacheRef;
======= 438e61c:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

    protected abstract String createToString (StringMaker sm);
    
    /* Use a soft cache for the short, middle and long String representations */
======= 438e61c:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

    private String stringRep;
======= 438e61c:"runtime/src/org/aspectj/runtime/reflect/SignatureImpl.java"

======= 438e61c:"runtime/src/org/aspectj/runtime/reflect/SourceLocationImpl.java"

    SourceLocationImpl(Class withinType, String fileName, int line) {
    public int getColumn() { return -1; }
    	return getFileName() + ":" + getLine();
======= 438e61c:"runtime/src/org/aspectj/runtime/reflect/StringMaker.java"

    int cacheOffset;
======= 438e61c:"runtime/src/org/aspectj/runtime/reflect/StringMaker.java"

======= 438e61c:"runtime/src/org/aspectj/runtime/reflect/StringMaker.java"

======= 438e61c:"runtime/src/org/aspectj/runtime/reflect/StringMaker.java"

======= 438e61c:"runtime/testsrc/RuntimeModuleTests.java"

======= 438e61c:"runtime/testsrc/RuntimeModuleTests.java"

======= 438e61c:"runtime/testsrc/RuntimeModuleTests.java"

 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
======= 438e61c:"runtime/testsrc/org/aspectj/runtime/reflect/SignatureTest.java"


======= 5e08765:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"

======= 5e08765:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= 5e08765:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= 5e08765:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

    
    public void abstractMethodInAbstractClass(SourceTypeBinding type, AbstractMethodDeclaration methodDecl) {
    	String abstractMethodName = new String(methodDecl.selector);
    	if (abstractMethodName.startsWith("ajc$pointcut")) {
    		// This will already have been reported, see: PointcutDeclaration.postParse()
    		return;
    	}
    	String[] arguments = new String[] {new String(type.sourceName()), abstractMethodName};
    	super.handle(
    		IProblem.AbstractMethodInAbstractClass,
    		arguments,
    		arguments,
    		methodDecl.sourceStart,
    		methodDecl.sourceEnd,this.referenceContext, 
    }
======= 5e08765:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= 5e08765:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

======= 5e08765:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
  public void test052_bogusMessage1() {
    runTest("Bogus error message: The abstract method ajc$pointcut$$tracingScope$a2 in type Tracing can only be defined by an abstract class (1)");
  }
  
  public void test053_bogusMessage2() {
    runTest("Bogus error message: The abstract method ajc$pointcut$$tracingScope$a2 in type Tracing can only be defined by an abstract class (2)");
  }
    <ajc-test dir="bugs" pr="72699"
    </ajc-test>
    
    <ajc-test dir="bugs" pr="72699"
    </ajc-test>
    

  Object around(): call(* clone(..)) {
    return proceed();
  }
  public static B.D[] arr = new B.D[5];
  public static void main(String[]argv) {
    arr[0] = new B.D(42);
    arr[1] = new B.D(22);
    arr[2] = new B.D(46);
    arr[3] = new B.D(50);
    arr[4] = new B.D(54);
    B.D[] arr2 = arr.clone();
    // Check the clone is OK
    if (arr2[0].i!=42) throw new RuntimeException("Call that a clone 0");
    if (arr2[1].i!=22) throw new RuntimeException("Call that a clone 1");
    if (arr2[2].i!=46) throw new RuntimeException("Call that a clone 2");
    if (arr2[3].i!=50) throw new RuntimeException("Call that a clone 3");
    if (arr2[4].i!=54) throw new RuntimeException("Call that a clone 4");
    System.err.println("Clone OK - attempting value manipulation");
    // Change the clone, check the original is OK
    arr2[2] = new B.D(1);
    if (arr[2].i == 1)  throw new RuntimeException("Shouldnt have affected original");
    if (arr2[2].i != 1) throw new RuntimeException("Should have affected clone");
    System.err.println("Clone OK - finished");
  }
  public static class D {
    public int i;
    D(int x) { i=x;}
  }
======= b5e6307:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  public void test051_arrayCloningInJava5() {
    runTest("AJC possible bug with static nested classes");
  }
    </ajc-test>
======= b5e6307:"weaver/src/org/aspectj/weaver/TypeX.java"

        if (name.length() != 0) {
        	// lots more tests could be made here...
        	
        	// 1) If it is already an array type, do not mess with it.
        	if (name.charAt(0)=='[' && name.charAt(name.length()-1)==';') return name;
        	else return "L" + name.replace('.', '/') + ";";
        }

    public static void main(String[] args) {
        PrinterWorld p = new PrinterWorld();
        p.print(); 
        Integer i = p.returnInt();
        Integer[] intArray = p.returnArrayWithCloning();
        Integer[] array2 = p.returnArrayWithoutCloning();
    }
    
    public HelloWorldAspect() {
    }
    
    pointcut hello(): !within(HelloWorldAspect);
    
    pointcut method(): execution(public (*[]) de..*(..));
    
    pointcut cloning(): call(* java.lang.Object.clone());
    declare warning: method() && hello(): "*[] returning method called" ;
    
    Object[] around(): cflow(method()) && cloning() && hello() {
    	print("", thisEnclosingJoinPointStaticPart);
    	Object[] ret = proceed(); 
    	return (Object[])ret.clone();
    }
    private void print(String prefix, Object message) {
        for (int i = 0, spaces = callDepth * 2; i < spaces; i++) {
            System.out.print(" ");
        }
        System.out.println(prefix + message);
    }
    public void print() {
        System.out.println("Hello World!"); 
    }
    
    public Integer returnInt() {
    	return new Integer(3);
    }
    
    public Integer[] returnArrayWithCloning() {
    	for (int i = 0; i < intArray.length; i++) {
    	return (Integer[])intArray.clone();
    }
    
    public Integer[] returnArrayWithoutCloning() {
    	return intArray;
    }
======= 82eae55:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  public void test050_typePatternMatchingWithArrays() {
  	runTest("declare warning warns at wrong points");
  }
======= 82eae55:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= 82eae55:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

    		if (dim == 0) { // pr72531
    			return TypePattern.ANY;  //??? loses source location
    		} 
======= 82eae55:"weaver/testsrc/org/aspectj/weaver/patterns/TypePatternTestCase.java"

  	
  	public void testArrayMatch() {
  		world = new BcelWorld();
  		checkMatch("*[][]","java.lang.Object",false);
  		checkMatch("*[]","java.lang.Object[]",true);
  		checkMatch("*[][]","java.lang.Object[][]",true);
  		checkMatch("java.lang.Object[]","java.lang.Object",false);
  		checkMatch("java.lang.Object[]","java.lang.Object[]",true);
  		checkMatch("java.lang.Object[][]","java.lang.Object[][]",true);
  		checkMatch("java.lang.String[]","java.lang.Object",false);
  		checkMatch("java.lang.String[]","java.lang.Object[]",false);
  		checkMatch("java.lang.String[][]","java.lang.Object[][]",false);
  		checkMatch("java.lang.Object+[]","java.lang.String[]",true);
  	}

======= f503523:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"

======= f503523:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"

            boolean result = ((repeat 
                        		? buildManager.incrementalBuild(config, handler)
                        		: buildManager.batchBuild(config, handler))
                    		   && !counter.hasErrors());
======= f503523:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"

======= f503523:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= f503523:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= f503523:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= f503523:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= f503523:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"

======= f503523:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"

    	Dump.saveMessageHolder(holder);
======= f503523:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"

======= f503523:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"

======= f503523:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"

======= f503523:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"

======= f503523:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"

======= f503523:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java"

        suite.addTestSuite(CompilerDumpTestCase.class); 
======= f503523:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java"

 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
======= f503523:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java"

 * Copyright (c) 2004 IBM Corporation
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Matthew Webster 
 * ******************************************************************/
 * @author websterm
 *
 * To change the template for this generated type comment go to
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
            Object o = i.next();
            if (o instanceof Exception) {
                println((Exception)o);
            } else {
            	println(i.next().toString());
            }
======= f503523:"weaver/src/org/aspectj/weaver/World.java"

======= f503523:"weaver/src/org/aspectj/weaver/World.java"

======= f503523:"weaver/src/org/aspectj/weaver/World.java"

    
    private List dumpState_cantFindTypeExceptions = null;
        Dump.registerNode(this.getClass(),this);
======= f503523:"weaver/src/org/aspectj/weaver/World.java"

    
    public void accept (Dump.IVisitor visitor) {
        if (dumpState_cantFindTypeExceptions!=null) {
          visitor.visitString("Cant find type problems:");
          visitor.visitList(dumpState_cantFindTypeExceptions);
          dumpState_cantFindTypeExceptions = null;
        }
    }
======= f503523:"weaver/src/org/aspectj/weaver/World.java"

                if (dumpState_cantFindTypeExceptions==null) {
                  dumpState_cantFindTypeExceptions = new ArrayList();   
                }
                dumpState_cantFindTypeExceptions.add(new RuntimeException("Can't find type "+ty.getName()));
======= f503523:"weaver/src/org/aspectj/weaver/World.java"

======= f503523:"weaver/testsrc/org/aspectj/weaver/BcweaverTests.java"

======= f503523:"weaver/testsrc/org/aspectj/weaver/BcweaverTests.java"

 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster 
 *******************************************************************************/
 * @author websterm
 *
 * Test Dump facility. Ensure it can be configured and files contain expected contents. Testcase 
 * returns Dump configuration to orginal state.
 */

======= 5f80c8c:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            else if ( arg.equals( "-encoding" ) ) {
                addNextAsOption = true;
                addNextToAJCOptions = false;
                options.addElement( arg );
            }
            else if ( arg.equals( "-docencoding" ) ) {
                addNextAsOption = true;
                addNextToAJCOptions = false;
                options.addElement( arg );
            }
            else if ( arg.equals( "-charset" ) ) {
                addNextAsOption = true;
                addNextToAJCOptions = false;
                options.addElement( arg );
            }
======= 5f80c8c:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

======= 5f80c8c:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"


    int x;
    Base() {
    }
    abstract void foo();
    int y;
    public Derived() {
    }
    public void foo() {}
    public static void main(String args[]) {
    }
    public interface Traced {}
    declare parents: (sample.* && !Trace) extends Traced;
    before(Traced current) : 
    }
    public Logger Traced.getLogger() {
 //       if (logger == null) {
 //       }
    }
======= dbe1024:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java"

        suite.addTestSuite(PartiallyExposedHierarchyTestCase.class);
======= dbe1024:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java"

 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
 * If you need to rebuild the components for this test, I'm afraid you will have
 * to run build.cmd in the testdata/partialHierarchy directory which calls ajc and
 * does some jar manipulation.
 */
======= dbe1024:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

     for(Iterator i = other.getDirectSupertypes(); i.hasNext(); ) {
     	ResolvedTypeX rtx = (ResolvedTypeX)i.next();
     	boolean b = this.isAssignableFrom(rtx);
     	if (b) return rtx;
     }       
     return null;
======= dbe1024:"weaver/src/org/aspectj/weaver/WeaverMessages.java"

======= dbe1024:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= dbe1024:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= dbe1024:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

    		
    		if (!gen.getType().isTopmostImplementor(onType)) {
    			ResolvedTypeX rtx = gen.getType().getTopmostImplementor(onType);
    			if (!rtx.isExposedToWeaver()) {
    				ISourceLocation sLoc = munger.getSourceLocation();
    			    weaver.getWorld().getMessageHandler().handleMessage(MessageUtil.error(
    			    		WeaverMessages.format(WeaverMessages.ITD_NON_EXPOSED_IMPLEMENTOR,rtx,getAspectType().getName()),
    			} else {
    				// XXX what does this state mean?
    				// We have incorrectly identified what is the top most implementor and its not because
    				// a type wasn't exposed to the weaver
    			}
    		} else {
    		}

    public void Foo.doing() {
    System.out.println(i()); // CE L8
    System.out.println(ancientI()); // CE L9
    System.out.println(ancientJ()); // CE L10
    System.out.println(this.clone()); // CE L11
    System.out.println(clone()); // CE L12
    }
    before(Foo f) : call(* doStuff(..)) && target(f) {
        f.doing();
    }
    public void Foo.doingMore() {
    System.out.println(i());
    System.out.println(ancientI());
    System.out.println(ancientJ()); 
 }
    }
    before(Foo f) : call(* doStuff(..)) && target(f) {
        f.doing();
    }
    protected int i() { return 42; }
    public static void main(String[] args) {
        new Foo().doStuff();
    }
    public void doStuff() { }
    protected int ancientI() { return 42; }
    protected int ancientI() { return -42; }
    protected int ancientJ() { return 0; }
======= dfb15c1:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  public void test045_ITDprotectedVisibility() {
  	runTest("Inconsistency in scoping of protected members in ITDs");
  }
  

 * A comment
 * @see AspectJavadocComment
 */
    
    public void test0() {}
    
    /**
     * A comment
     * @see PointcutJavadocComment1
     */
    public void test1() {}
    
     * @see AfterReturningJavadocComment
    public void test2(){}
    
    /**
     * comment2
     * @see PointcutJavadocComment2
     */   
    public pointcut secondPC(): execution(* *(..));
    
    public void test3(){}
    
    /**
     * I am a comment attached to a warning
     * @see declarewarningJavadocComment
     */
    declare warning: call(* *elephant*(..)) : "I am a warning";
    
    public void test4() {}
    
    /**
     * comment attached to around advice
     * @see AroundAdviceJavadocComment
     */
    void around(): call(* *abc*(..)) {
    }
    public void test5() {}
   
    /**
     * ITD method attached comment
     * @see IntertypeMethodComment
     */
    public void X.method() {       }
    
    public void test6() {}
    
    /**
     * ITD field attached comment
     * @see IntertypeFieldComment
     */
    public int X.i;
    
    public int test7;
    
    static class X {
        
    }
   
======= 5b90224:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java"

        suite.addTestSuite(JavadocTest.class);
======= 5b90224:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java"

 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Andy Clement - initial implementation
 *******************************************************************************/
    public static final String PROJECT_DIR = "javadoc";
    private File baseDir;
    
    protected void setUp() throws Exception {
        super.setUp();
        baseDir = new File("../org.aspectj.ajdt.core/testdata",PROJECT_DIR);
    }
    
    /**
     * Aim: Check javadoc warning that appear are appropriate
     * 
     *   ajc -warn:allJavadoc World.java
     * 
     */
    public void testMissingJavadoc () {
        String[] args = new String[] {"World.java","-warn:allJavadoc"};
        
        List warningMessages = new ArrayList();
        // These warnings are against public textX() methods declared in the World.java
        // type.  These test methods are spread between AJ constructuts, meaning
        // if someone messes up and the javadoc is not associated with the aspectj
        // construct then it will associated by accident with one of the testX() methods.
        // By checking we get a warning against every testX() method, we are verifying
        // that the javadoc is being attached to the aspectj constructs.
        warningMessages.add(new Message(10,"Missing comment for public declaration"));
        warningMessages.add(new Message(18,"Missing comment for public declaration"));
        warningMessages.add(new Message(28,"Missing comment for public declaration"));
        warningMessages.add(new Message(36,"Missing comment for public declaration"));
        warningMessages.add(new Message(44,"Missing comment for public declaration"));
        warningMessages.add(new Message(53,"Missing comment for public declaration"));
        warningMessages.add(new Message(61,"Missing comment for public declaration"));
        warningMessages.add(new Message(69,"Missing comment for public declaration"));
        MessageSpec spec = new MessageSpec(warningMessages,null);
        
        CompilationResult result = ajc(baseDir,args);
        assertMessages(result,spec);
        
    }
    
    private void dump(List l) {
         for (Iterator iter = l.iterator(); iter.hasNext();) {
    }

        
        	C m = new C();
        	m.y = 3;
        	System.out.println("hi");
    public static void main(String[] args) {
        try {
         C.main(null);   
        } catch (ExceptionInInitializerError eiie) {
        	System.err.println("EIIE="+eiie.toString());
            System.err.println("CAUSE="+eiie.getCause().toString());
        }
    before () :  within(*) && !within(pr62642) { 
        System.out.println("BEFORE "+ thisJoinPointStaticPart.getKind() +
        System.out.println("AFTER " + thisJoinPointStaticPart.getKind() +
======= 84e4e53:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
  public void test043_pr62642_ExceptionInInitializerError() {
    runTest("proper handling of ExceptionInIntializer inside clinit in presence of after throwing advice");
    String s = getLastRunResult().getStdErr();
    assertTrue("Output should contain java.lang.ExceptionInInitializerError but is '"+s+"'",
            s.indexOf("java.lang.ExceptionInInitializerError")!=-1);
    assertTrue("Output should contain 'CAUSE=org.aspectj.lang.NoAspectBoundException' but is '"+s+"'",
            s.indexOf("CAUSE=org.aspectj.lang.NoAspectBoundException")!=-1);
  }
======= 84e4e53:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

        // pr62642
        // I will now jump through some firey BCEL hoops to generate a trivial bit of code:
        // if (exc instanceof ExceptionInInitializerError) 
        //    throw (ExceptionInInitializerError)exc;
        if (this.getEnclosingMethod().getName().equals("<clinit>")) {
            ResolvedTypeX eiieType = world.resolve("java.lang.ExceptionInInitializerError");
            ObjectType eiieBcelType = (ObjectType)BcelWorld.makeBcelType(eiieType);
        	InstructionList ih = new InstructionList(InstructionConstants.NOP);
        	handler.append(exceptionVar.createLoad(fact));
        	handler.append(fact.createInstanceOf(eiieBcelType));
        	BranchInstruction bi = 
                InstructionFactory.createBranchInstruction(Constants.IFEQ,ih.getStart());
        	handler.append(bi);
        	handler.append(exceptionVar.createLoad(fact));
        	handler.append(fact.createCheckCast(eiieBcelType));
        	handler.append(InstructionConstants.ATHROW);
        	handler.append(ih);
        }

======= a2469c7:"ajde/testsrc/org/aspectj/ajde/ExtensionTests.java"

======= a2469c7:"ajde/testsrc/org/aspectj/ajde/ExtensionTests.java"

  InnerClasses.java
    import declarations
    InnerClasses
      A							A
        method						method
        1								new Runnable() {..}
          run								run
      main						main
      2								new Runnable() {..}
      	  run							run
      3 							new Object() {..}
        toString						toString
      4								new Runnable
        run								run
======= a2469c7:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"

======= a2469c7:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmHierarchyBuilder.java"


    private void returnNothing(Object a) {
    }
  public void ITD.newFun() {
      returnNothing("a");
  }
  public static void main(String [] argv) {
    new ITD().newFun();
  }
  public void ITD.newFun() {
      returnNothing("a");
  }
  public static void main(String [] argv) {
    new ITD().newFun();
  }
  void blah(ITD x) { x.returnNothing("y"); }
  public static void main(String[]argv) {
    ITD a = new ITD();
    a.returnNothing("a");
    System.err.println("Call returned OK!");
  }
    private void returnNothing(Object a) {
    }
    private void returnNothing(Object a) {
    }
  void blah(ITD x) { x.returnNothing("y"); }
  public static void main(String[]argv) {
    ITD a = new ITD();
    a.returnNothing("a");
    System.err.println("Call returned OK!");
  }
======= 6b1ef0f:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  public void test039_privilegedAspectAccessingPrivateMethods_pr67579() {
  	runTest("NPE on privileged aspect error");
  }
  
  public void test040_privilegedAspectAccessingPrivateMethods_pr67579_2() {
  	runTest("NPE on privileged aspect error (2)");
  }
  
  public void test041_ITDaccessingPrivateMethod_pr67578() {
  	runTest("Privileged Aspect Access Problem Across Packages");
  }
  
  public void test042_ITDaccessingPrivateMethod_pr67578_2() {
  	runTest("Privileged Aspect Access Problem Across Packages (2)");
  }
    <ajc-test dir="bugs/privilegedAccess" pr="67578"

======= 2dfc738:"asm/src/org/aspectj/asm/internal/AspectJElementHierarchy.java"


  <target name="extractAndPatchAndJar" depends="extractAndPatch,jar,srcjar" />
  <target name="extractAndPatch" depends="unzipSource,createPatchedSource" />
  <target name="diff" depends="transformFromAJ,pack">
  <target name="createPatchedSource" depends="patch,unpack,transformToAJ" />
      <fileset dir="bcel/src/java" >
      </fileset>
  <li>ant extractAndPatchAndJar -- this is just the composition of the extract,
  patches it, renames the files to start org.aspectj.apache rather than org.apache then
  compiles the patched version into a jar and drops the new archives:
  <li>ant extractAndPatch -- this extracts the source from bcel-5.1-src.zip,
  patches it, renames the files to start org.aspectj.apache rather than org.apache then
  copies the patched source into the project src directory, 
  In order to create the patch, we transform the packages back to org.apache from 
  org.aspectj.apache.  To continue working on BCEL once you have done this, you might
  need to run the transformToAJ task to switch the packages back to the AJ prefix.
  <li>ant transformToAJ - this changes the packages for the BCEL classes to
  org.aspectj.apache from org.apache.  This is used by the extractAndPatch task above.
  </li>
  <li>ant transformFromAJ - this changes the packages for the BCEL classes to
  org.apache from org.aspectj.apache.  This is used by the diff task.
  </li>
======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/BcelAttributes.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/BcelCflowAccessVar.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/BcelCflowStackFieldAdder.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/BcelField.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/BcelFieldRef.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/BcelMethod.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/BcelRenderer.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/BcelVar.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/ExceptionRange.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

            org.aspectj.apache.bcel.classfile.Utility.accessToString(myGen.getAccessFlags(), true);
        s += org.aspectj.apache.bcel.classfile.Utility.classOrInterface(myGen.getAccessFlags());
======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

            org.aspectj.apache.bcel.classfile.Utility.compactClassName(
======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        String access = org.aspectj.apache.bcel.classfile.Utility.accessToString(getAccessFlags());
======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/Range.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/ShadowRange.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/Tag.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/UnwovenClassFile.java"

======= 228fc8d:"weaver/src/org/aspectj/weaver/bcel/Utility.java"

======= 228fc8d:"weaver/testsrc/org/aspectj/weaver/bcel/ArgsWeaveTestCase.java"

======= 228fc8d:"weaver/testsrc/org/aspectj/weaver/bcel/MoveInstructionsWeaveTestCase.java"

======= 228fc8d:"weaver/testsrc/org/aspectj/weaver/bcel/WeaveTestCase.java"


    
    static int static_c = 0;
    int c = 0;
    
    static int static_a = 0;
    int a = 0;
    
    private void C.itdFromA() {
        c = 1;  // ok
        static_c = 1; // not ok - use C.static_c;
        static_a = 1; // ok
        a = 1; // not ok
    }
 private static int y = 5;
 private class A { int x = 3; }
 
 private static class A2 {}
 private static void B.happy() {
 }
 private static void B.foo(A z) { 
 }
 
 private static void B.foo2(A2 z) {
     System.out.println(z);
 }
 public void B.bar() {
     B.foo(new A());        // CE L37 : no enclosing instance
 }
 
 public void B.bar2() {
     B.foo2(new A2());
 }
 public static void main(String[] args) { 
 } 
======= 8c5d743:"tests/bugs/oxford/PR62475.java"

 public int A.x = z; // okay, z is visible.
 
======= 8c5d743:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

======= 8c5d743:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  public void test028_itdsAndInitializers() {
    runTest("resolution of IT field inits");
  }
  public void test030_privateITDinitialisersBeingMatched() {
======= 8c5d743:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  public void test034_scopeForITDS_pr61768() {
      runTest("scope for inter-type methods");
    }
 
  	<ajc-test dir="bugs/PR68991" pr="68991"

 "def" + // def was here
 "ghijklmnopqrstuv" /* silly
 "wxyz";
======= d43a391:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
  public void test026_bindingThisAndTargetToTheSameFormal() {
======= d43a391:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

    public void test030_privateITDinitialisersBeingMatched() {
======= d43a391:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
  public void test032_stringConcatForDEOW() {
    runTest("Compile time declarations (warning and error) do not accept string concatenation (with +)");
  }
  public void test033_stringConcatForDEOWErrorCase() {
    runTest("Compile time declarations (warning and error) do not accept string concatenation (with +) (2)");
  }
   	</ajc-test>
        <compile files="decwStrings.java">
        	<message kind="warning" line="5"/>
        </compile>
    </ajc-test>
        <compile files="decwStringsErroneous.java">
        </compile>
    </ajc-test>
======= d43a391:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"

======= d43a391:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"


======= 64183c3:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeFieldDeclaration.java"

======= 64183c3:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeFieldDeclaration.java"

 private int C.n = 13;
 before() : get(* C.*) {
 }
 before() : set(* C.*)  {
 }
 public void C.foo() {
 }
 int m = 20;
 public static void main(String[] args) {
 }
======= 64183c3:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeFieldDeclaration.java"

    private int C.n = 13;
    before() : get(* C.*) {
    	tjps.add(thisJoinPointStaticPart.toString());
    	ejps.add(thisEnclosingJoinPointStaticPart.toString());
    	//System.out.println("get field "+thisJoinPointStaticPart);
    }
    before(int x) : set(* C.*) && args(x)  {
    	tjps.add(thisJoinPointStaticPart.toString());
    	ejps.add(thisEnclosingJoinPointStaticPart.toString());
    	values.add(new String(thisJoinPointStaticPart+"="+new Integer(x)));
    	//System.err.println("set field "+thisJoinPointStaticPart);
    }
    
    public void C.foo() {
    	m++;
    	n++;
    }
  //  int m = 20;
    public static void main(String[] args) {
    	C c = new C();
    	c.foo();
    	System.err.println("\nSummaryJPs:"+Aspect.tjps);
    	System.err.println("\nSummaryEJPs:"+Aspect.ejps);
    	System.err.println("\nSummaryVals:"+Aspect.values);
    	// Ought to have a nicer signature for the ejpsp in the case of an initializer ...
    	chkNext(Aspect.tjps,"set(int C.m)");chkNext(Aspect.values,"set(int C.m)=13");chkNext(Aspect.ejps,"execution(void Aspect.ajc$interFieldInit$Aspect$C$m(C))");
    	chkNext(Aspect.tjps,"set(int C.n)");chkNext(Aspect.values,"set(int C.n)=13");chkNext(Aspect.ejps,"execution(void Aspect.ajc$interFieldInit$Aspect$C$n(C))");
    	chkNext(Aspect.tjps,"get(int C.m)");                                         chkNext(Aspect.ejps,"execution(void C.foo())");
    	chkNext(Aspect.tjps,"set(int C.m)");chkNext(Aspect.values,"set(int C.m)=14");chkNext(Aspect.ejps,"execution(void C.foo())");
    	chkNext(Aspect.tjps,"get(int C.n)");                                         chkNext(Aspect.ejps,"execution(void C.foo())");
    	chkNext(Aspect.tjps,"set(int C.n)");chkNext(Aspect.values,"set(int C.n)=14");chkNext(Aspect.ejps,"execution(void C.foo())");
    }
    
    public static void chkNext(List l,String expected) {
    	String s = (String)l.remove(0);
    	if (!s.equals(expected)) throw new RuntimeException("Expected next thing on list to be '"+expected+"' but it was '"+s+"'");
    }
======= 64183c3:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

======= 64183c3:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

    public void test026_bindingThisAndTargetToTheSameFormal() {
======= 64183c3:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
  public void test030_privateITDinitialisersBeingMatched() {
    runTest("intertype initialisers should match field set pointcuts");
  }
  public void test031_privateITDinitialisersBeingMatched_OxfordTest() {
    runTest("intertype initialisers should match field set pointcuts (oxford testcase)");
    //System.err.println(">"+getLastRunResult().getStdErr());
    String exp = ":set field set(int C.n):set field set(int C.m):get field get(int C.n):set field set(int C.n)";
    assertTrue("Expected output '"+exp+"' but got "+getLastRunResult().getStdErr(),
    		getLastRunResult().getStdErr().equals(exp));
  }
   	<ajc-test dir="bugs/PR68991" pr="68991"
    	title="intertype initialisers should match field set pointcuts">
    	<compile files="Simple.java"/>
    	<run class="Simple"/>
   	</ajc-test>
   	 	
   	<ajc-test dir="bugs/PR68991" pr="68991"
    	title="intertype initialisers should match field set pointcuts (oxford testcase)">
    	<compile files="Oxford.java"/>
    	<run class="Oxford"/>
   	</ajc-test>

======= b75cd93:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

======= b75cd93:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
  public void test026_bindingThisAndTargetToTheSameFormal() {
  	runTest("ajc crashes when compiling the following program (binding this() and target())");
  }
   	</ajc-test>
    <ajc-test dir="bugs/oxford" pr="65319"
======= b75cd93:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

        	if (exposedState.isErroneousVar(i)) continue; // Erroneous vars have already had error msgs reported!
======= b75cd93:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

                    " using args(..) at this line - formal is already bound"+
                    ".  See secondary source location for location of args(..)",
======= b75cd93:"weaver/src/org/aspectj/weaver/patterns/ExposedState.java"

======= b75cd93:"weaver/src/org/aspectj/weaver/patterns/ExposedState.java"

======= b75cd93:"weaver/src/org/aspectj/weaver/patterns/ExposedState.java"

======= b75cd93:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= b75cd93:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"


  aspect A {
     Object around(ICanProceed canProceed) : execution(* *(..)) <![CDATA[&&]]> this(canProceed) {
        canProceed.proceed();         // a method call
        return proceed(canProceed);   // the special proceed form
     }
     
     private Object proceed(ICanProceed canProceed) {
        // this method cannot be called from inside the body of around advice in
        // the aspect
     }
  }	
======= 05dabd1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/Proceed.java"

 *               2004 contributors
======= 05dabd1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/Proceed.java"

 *     PARC     initial implementation
 *     IBM      ongoing maintenance 
======= 05dabd1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/Proceed.java"

 * of an <code>around</code> advice and has no receiver (must be a bare proceed call, 
 * see pr 53981), and if not this will be treated like any other
======= 05dabd1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/Proceed.java"

======= 05dabd1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/Proceed.java"

    public static void main(String[] args) { 
       Tester.checkAllEvents();
    }
    static aspect A {
        interface IProceed {
            void proceeds(Runnable next);
        }
        IProceed decorator = new IProceed() {
            public void proceeds(Runnable next) {
                Tester.event("IProceed.proceed()");
                next.run();
            }
        };
        void around() : execution(void main(String[])) {
            Tester.expectEvent("IProceed.proceed()");
            decorator.proceeds(new Runnable() {
                public void run() {
                    proceed();
                }
            });
        }
    }
======= 05dabd1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/Proceed.java"

    public static void main(String[] args) {
        Tester.checkFailed("Proceed with a receiver should be treated as a method call, not the special form");
    }
    static aspect A {
        void around() : execution(void main(String[])) {
            Proceeding2.proceed(null); // BUG: treated as proceed(Object);
        }
    }
    static void proceed(Object o) {}
======= 05dabd1:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/Proceed.java"

    public static void main(String[] args) {
    }
    static aspect A {
        void around() : execution(void main(String[])) {
            proceed(); // special form or Proceeding.proceed()?
        }
    }
    void proceed() {
        Tester.checkFailed("A bare call to proceed inside around advice should never refer to a method");
    }
======= 05dabd1:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
  public void test023_proceedInAround1() {
      runTest("proceed used as method name in around advice (1)");
  }
  public void test024_proceedInAround2() {
      runTest("proceed used as method name in around advice (2)");
  }
  public void test025_proceedInAround3() {
      runTest("proceed used as method name in around advice (3)");
  }
  	<ajc-test dir="bugs/pr53981" pr="538981"
    	title="proceed used as method name in around advice (1)">
    	<compile files="Proceeding1.aj"/>
    	<run class="Proceeding1"/>
   	</ajc-test>
  	<ajc-test dir="bugs/pr53981" pr="538981"
    	title="proceed used as method name in around advice (2)">
    	<compile files="Proceeding2.aj"/>
    	<run class="Proceeding2"/>
   	</ajc-test>
  	<ajc-test dir="bugs/pr53981" pr="538981"
    	title="proceed used as method name in around advice (3)">
    	<compile files="Proceeding3.aj"/>
    	<run class="Proceeding3"/>
   	</ajc-test>

    boolean around() : (target(java.util.HashSet) && call(boolean add(..) ) )
       {
         return false;
       }
   }
  public static final int N_METHODS = 50;
  public static final int N_STATEMENTS = Short.MAX_VALUE/(2*N_METHODS);  
  public static void main(String[] args) {
    System.out.println("public class Foo {");
    System.out.println("static java.util.Set hs = new java.util.HashSet();");
    for (int i = 0; i < N_METHODS; i++) {
      System.out.println("public void test" + i + "() {");
      for (int j=0; j < N_STATEMENTS; j++) {
        System.out.println("hs.add(new Object());");
      } 
      System.out.println("}");
    }
    System.out.println("}");
  }
======= 44a92e1:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
    	title="Weaver fails in BCEL for large classes">
        <compile files="Foo.java, A.aj">
    	title="Weaver fails in BCEL for large classes (binary)">
        <compile 
        	aspectpath="test.jar"
        	inpath="classes">
======= 44a92e1:"weaver/src/org/aspectj/weaver/WeaverMessages.java"

======= 44a92e1:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= 44a92e1:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

        if (getConstantPoolGen().getSize() > Short.MAX_VALUE) {
            // PR 59208
            // we've generated a class that is just toooooooooo big (you've been generating programs
            // again haven't you? come on, admit it, no-one writes classes this big by hand).
            // create an empty myGen so that we can give back a return value that doesn't upset the
            // rest of the process.
            myGen = new ClassGen(myGen.getClassName(), myGen.getSuperclassName(), 
                    myGen.getFileName(), myGen.getAccessFlags(), myGen.getInterfaceNames());
            // raise an error against this compilation unit.
       		getWorld().showMessage(
        			IMessage.ERROR, 
    				WeaverMessages.format(WeaverMessages.CLASS_TOO_BIG,
    						              this.getClassName()),
    			    new SourceLocation(new File(myGen.getFileName()),0), null
    			    );
        	return;
        }

======= f6436e3:"runtime/src/org/aspectj/runtime/reflect/JoinPointImpl.java"

    public Object[] getArgs() {
    	if (args == null) { args = new Object[0]; }
    	Object[] argsCopy = new Object[args.length];
    	System.arraycopy(args,0,argsCopy,0,args.length);
    	return argsCopy; 
    }
======= f6436e3:"runtime/testsrc/RuntimeModuleTests.java"

======= f6436e3:"runtime/testsrc/RuntimeModuleTests.java"

        suite.addTestSuite(JoinPointImplTest.class);
======= f6436e3:"runtime/testsrc/RuntimeModuleTests.java"

 * Created on 09-Aug-2004
 *
 * TODO To change the template for this generated file go to
 * Window - Preferences - Java - Code Style - Code Templates
 */
 * @author colyer
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Style - Code Templates
 */

======= 851da68:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= 851da68:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= 851da68:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= 851da68:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= 851da68:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

      System.out.println("? test()");
======= 851da68:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

      System.out.println("? test()");
======= 851da68:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

      System.out.println("? test()");
======= 851da68:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

    runTest("false ambiguous binding error (introduced in 1.2rc2)");
======= 851da68:"tests/src/org/aspectj/systemtest/ajc121/Ajc121Tests.java"

  
  public void test017_PrivateMethodCallsInAroundAdvice() {
    runTest("Cannot advise private method call in around advice");
    System.err.println(getLastRunResult().getStdErr());
  }
  
  public void test018_PrivateFieldSetsInAroundAdvice() {
    runTest("Cannot advise private field sets in around advice");
    System.err.println(getLastRunResult().getStdErr());
  }
  
  public void test019_PrivateFieldGetsInAroundAdvice() {
    runTest("Cannot advise private field gets in around advice");
    System.err.println(getLastRunResult().getStdErr());
  }
    <ajc-test dir="bugs/AroundAdviceJPs" pr="71377"
    	title="Cannot advise private method call in around advice">
    	<compile files="JoinPointInAroundAdvice.java"/>
    	<run class="JoinPointInAroundAdvice"/>
   	</ajc-test>
    
   <ajc-test dir="bugs/AroundAdviceJPs" pr="71377"
    	title="Cannot advise private field sets in around advice">
    	<compile files="FieldJoinPointsInAroundAdvice.java"/>
    	<run class="FieldJoinPointsInAroundAdvice"/>
   	</ajc-test>
   	
   	<ajc-test dir="bugs/AroundAdviceJPs" pr="71377"
    	title="Cannot advise private field gets in around advice">
    	<compile files="FieldGetJoinPointsInAroundAdvice.java"/>
    	<run class="FieldGetJoinPointsInAroundAdvice"/>
   	</ajc-test>
======= 851da68:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"


======= 061395c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= 061395c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseSourceType.java"

======= 061395c:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

                    world.getCoreType(CLONEABLE), 
                    world.getCoreType(SERIALIZABLE)
======= 061395c:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

            return world.getCoreType(OBJECT);
======= 061395c:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= 061395c:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

======= 061395c:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 061395c:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 061395c:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    				world.getCoreType(TypeX.forName("org.aspectj.lang.JoinPoint$StaticPart")),
======= 061395c:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 061395c:"weaver/src/org/aspectj/weaver/patterns/DeclareParents.java"

======= 061395c:"weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java"

    		if (!scope.getWorld().getCoreType(TypeX.THROWABLE).isAssignableFrom(excType)) {

======= 648c0f4:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= 648c0f4:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= 648c0f4:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

======= 648c0f4:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

    		List cp = config.getClasspath();
    		boolean jar1Found = false;
    		boolean jar2Found = false;
    		for (Iterator iter = cp.iterator(); iter.hasNext();) {
                String element = (String) iter.next();
                if (element.indexOf("1.jar") != -1) jar1Found = true;
                if (element.indexOf("2.jar") != -1) jar2Found = true;
            }
    			jar1Found);
    			jar2Found);
======= 648c0f4:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

======= 648c0f4:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

======= 648c0f4:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

======= 648c0f4:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

   		List cp = config.getClasspath();
            String element = (String) iter.next();
            if (element.indexOf("1.jar") != -1) jar1Found = true;
            if (element.indexOf("2.jar") != -1) jar2Found = true;
        }
======= 648c0f4:"util/src/org/aspectj/util/ConfigParser.java"

    protected File relativeDirectory = null;
======= 648c0f4:"util/src/org/aspectj/util/ConfigParser.java"

        File oldRelativeDirectory = relativeDirectory; // for nested arg files;
        relativeDirectory = configFile.getParentFile();
        relativeDirectory = oldRelativeDirectory;
======= 648c0f4:"util/src/org/aspectj/util/ConfigParser.java"

        if (relativeDirectory != null) {
            return makeFile(relativeDirectory,name);
        } else {
            return makeFile(getCurrentDir(), name);
        }

    
    <ajc-test dir="bugs" pr="60015"
      title="NPE, Incorrect XLint:unmatchedSuperTypeInCall warning">
      <compile files="IncorrectXlintOnInterface.java">
      </compile>
    </ajc-test>
======= ef7885f:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"


======= 2b8fa31:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

======= 2b8fa31:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     Matthew Webster - initial implementation
 *******************************************************************************/
======= 2b8fa31:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 2b8fa31:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 2b8fa31:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"

======= 2b8fa31:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"

======= 2b8fa31:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 2b8fa31:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 2b8fa31:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 2b8fa31:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 2b8fa31:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 2b8fa31:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


    <ajc-test dir="bugs"
        <compile files="WithincodeNPE01.java">
          <!-- there are 3 join points that result in decw match, but 2 are on the same line! -->
          <message kind="warning" line="2" text="In String ctor"/>
          <message kind="warning" line="11" text="In String ctor"/>
        </compile>
    </ajc-test>
  public A.new(String s) { }
  public void A.foo() { int i = 1; }
  
  declare warning: withincode(void main(..)): "X"; // Would NPE without the fix for PR67774
  
  declare warning: withincode(A.new(String)): "In String ctor";
  
  private final static String name = A.class.getName();
======= 7f19ab4:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    	} else if (getKind() == Shadow.PreInitialization) {
          // PreInit doesn't enclose code but its signature
          // is correctly the signature of the ctor.
    	  return getSignature();

======= 9aed31d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= 9aed31d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"


======= 4feb835:"weaver/src/org/aspectj/weaver/Advice.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/Advice.java"

    							WeaverMessages.format(WeaverMessages.NON_VOID_RETURN,shadow),	
======= 4feb835:"weaver/src/org/aspectj/weaver/Advice.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/Lint.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/Lint.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/Lint.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/NewConstructorTypeMunger.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/Shadow.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/Shadow.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/Shadow.java"

 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
======= 4feb835:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/World.java"

                MessageUtil.error(messageHandler, 
                		WeaverMessages.format(WeaverMessages.CANT_FIND_TYPE,ty.getName()));
======= 4feb835:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        		  WeaverMessages.format(WeaverMessages.ALREADY_WOVEN,clazz.getType().getName()),
======= 4feb835:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/bcel/ClassPathManager.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    			IMessage.ERROR, 
======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/DeclareParents.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/DeclareParents.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/DeclareParents.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/DeclareParents.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/DeclareParents.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

    						WeaverMessages.format(WeaverMessages.TWO_STARS_IN_PRECEDENCE),
======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

    					WeaverMessages.format(WeaverMessages.CLASSES_IN_PRECEDENCE,exactType.getName()),
======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

    						WeaverMessages.format(WeaverMessages.TWO_PATTERN_MATCHES_IN_PRECEDENCE,exactType.getName()), 
======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/DeclareSoft.java"

    					WeaverMessages.format(WeaverMessages.NOT_THROWABLE,excType.getName()),
======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/PerFromSuper.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= 4feb835:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= 4feb835:"weaver/testsrc/org/aspectj/weaver/BcweaverTests.java"

======= 4feb835:"weaver/testsrc/org/aspectj/weaver/BcweaverTests.java"

 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
 * @author colyer
 *
 * TODO To change the template for this generated type comment go to
 * Window - Preferences - Java - Code Generation - Code and Comments
 */

    <ajc-test dir="bugs"
        <compile files="EllipsesStar.java">
          <message kind="error" line="3" text="Syntax error on token"/>
          <message kind="error" line="4" text="Syntax error on token"/>
          <message kind="error" line="5" text="Syntax error on token"/>
          <message kind="error" line="6" text="Syntax error on token"/>
          <message kind="error" line="8" text="Syntax error on token"/>
          <message kind="error" line="10" text="Syntax error on token"/>
          <message kind="error" line="12" text="Syntax error on token"/>
        </compile>
    </ajc-test>
    
======= 45bce91:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"

======= 45bce91:"weaver/src/org/aspectj/weaver/patterns/PatternParser.java"


======= 10c6de6:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/IfPseudoToken.java"

======= 10c6de6:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/IfPseudoToken.java"

   
      <ajc-test dir="new"
      title="if(false) optimisation" pr="48990">
        <compile files="IfFalse.aj"/>
        <run class="IfFalse"/>
    </ajc-test>
   
    <ajc-test dir="new"
      title="if(true) optimisation" pr="48990">
        <compile files="IfTrue.aj"/>
        <run class="IfTrue"/>
    </ajc-test> 
======= 10c6de6:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= 10c6de6:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= 10c6de6:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= 10c6de6:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= 10c6de6:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

 

======= 573741c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java"

======= 573741c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java"

======= 573741c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverMessageHandler.java"

    <ajc-test dir="bugs/abstractITDs"
        <compile files="A.java,C.java" aspectpath="B.jar">
          <message kind="error" line="1" text="must implement abstract inter-type declaration: void A.foo()"/>
        </compile>
    </ajc-test>
    
======= 573741c:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

            	ISourceLocation xtraLocation = element.getSourceLocation();
            	if (xtraLocation == null) {
            		// Until intertype mungers remember where they came from, the source location
            		// for the element is null when binary weaving.  In these cases uses the
            		// source location for the aspect containing the ITD
     				xtraLocation = element.getAspectType().getSourceLocation();
            	}
                        new ISourceLocation[] { xtraLocation }));

======= 6ea8300:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"

        	if ("-X".equals(args[i])) {
            	 // should be info, but handler usually suppresses
                MessageUtil.abort(handler, BuildArgParser.getXOptionUsage());
======= 6ea8300:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

    public static String getXOptionUsage() {
    	return Main.bind("xoption.usage");
    }
    
======= 6ea8300:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= 6ea8300:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"

            args = new String[] { "-?" };
======= 6ea8300:"org.aspectj.ajdt.core/testsrc/EajcModuleTests.java"

======= 6ea8300:"org.aspectj.ajdt.core/testsrc/EajcModuleTests.java"

        suite.addTestSuite(org.aspectj.tools.ajc.MainTest.class);
======= 6ea8300:"org.aspectj.ajdt.core/testsrc/org/aspectj/tools/ajc/MainTest.java"

        Main.bareMain(new String[] {"-X"}, false, list, null, null, null);
        assertTrue(1 == list.size());        Object o = list.get(0);

    
    <ajc-test dir="bugs/intertypeOverrides"
        <compile files="IntertypeOverrides.java">
          <message kind="error" line="8" text="void Sub.m() cannot override void Super.m(); overriding method is static"/>
        </compile>
        <compile files="IntertypeOverrides2.java">
          <message kind="error" line="8" text="void Sub.m() cannot override void Super.m(); overridden method is static"/>
        </compile>
        <compile files="Superclass.java,Subclass.java,Aspect1.java">
          <message file="Aspect1.java" kind="error" line="2" 
             text="void Subclass.staticMethod() cannot override void Superclass.staticMethod(); overridden method is static"/>
        </compile>
        <compile files="Superclass.java,Subclass.java,Aspect2.java">
          <message file="Aspect2.java" kind="error" line="2"
             text="void Subclass.nonstaticMethod() cannot override void Superclass.nonstaticMethod(); overriding method is static"/>
        </compile>
    </ajc-test>
    
  public void Subclass.staticMethod() {};
  public static void Subclass.nonstaticMethod() {};
  public void m(){};
  public static void Sub.m(){}
  public static void m(){};
  public void Sub.m(){}
  public static void staticMethod(){} {}
  public void nonstaticMethod() {};
======= b184363:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= b184363:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"


    <ajc-test dir="bugs"
        <compile files="Cosmetic.java">
        <message kind="error" line="9" text="can't bind type name 'unknown.Error'"/>
        </compile>
    </ajc-test> 
 class Test {
======= 936459c:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"

======= 936459c:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"


    
    <ajc-test dir="bugs/bug70619"
        <compile files="Precedence.java">
          <message kind="error" line="0" text="conflicting declare precedence"/>
        </compile>
        <compile files="Conflict.java,Order2.aj,Order1.aj">        
          <message kind="error" line="0" text="conflicting declare precedence"/>
        </compile>
        <compile files="Conflict.java,Order1.aj,Order2.aj">
          <message kind="error" line="0" text="conflicting declare precedence"/>
        </compile>
    </ajc-test>
  
  
  
  declare precedence: Conflict1, Conflict2;
   before(): execution(* *(..)) { }
  declare precedence: Conflict2, Conflict1;
 
  declare precedence: Conflict1,Conflict2;
  before(): execution(* *(..)) { }
  declare precedence: Conflict2, Conflict1;
  after(): execution(* *(..)) { }
======= 75852d7:"weaver/src/org/aspectj/weaver/World.java"


======= 8dc0845:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

                    
======= 8dc0845:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

    /**
     * Skips files that are public in the model but not public in the source,
     * e.g. nested aspects.
     */
======= 8dc0845:"ajdoc/src/org/aspectj/tools/ajdoc/HtmlDecorator.java"

 * @author Mik Kersten
 */
    static class NestedClass { } 
    
    static aspect NestedAspect { } 
  
    private static aspect PrivateNestedAspect { } 
     
======= 8dc0845:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

======= 8dc0845:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

======= 8dc0845:"ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.java"

    
======= 8dc0845:"ajdoc/testsrc/org/aspectj/tools/ajdoc/SpacewarTestCase.java"


======= 2cc4826:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

            if (packageName != null && packageName != "") {
======= 2cc4826:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

 * Test class.  This is a comment.
 */  
======= 2cc4826:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

======= 2cc4826:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"


======= 3707411:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

                inputFiles[i]     = new File((String)filenames.elementAt(i));
======= 3707411:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

                    javadocargs[options.size() + k] = StructureUtil.translateAjPathName(signatureFiles[k].getCanonicalPath());
======= 3707411:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

======= 3707411:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

======= 3707411:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

            String arg = (String)vargs.get(i);  
======= 3707411:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

                if ((arg.endsWith(".java") && entryName.indexOf('.') == entryName.length()-5) 
                	|| (arg.endsWith(".aj") && entryName.indexOf('.') == entryName.length()-3) 	
                	|| arg.endsWith(".lst") 
======= 3707411:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

                                        (name.substring(index1, index2).equals( ".java" )
======= 3707411:"ajdoc/src/org/aspectj/tools/ajdoc/Main.java"

        }        
======= 3707411:"ajdoc/src/org/aspectj/tools/ajdoc/StructureUtil.java"

    	if (path.endsWith(".aj")) {
    		path = path.substring(0, path.lastIndexOf(".aj")) + ".java";
    	} 
    	return path;
======= 3707411:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

        	String path = StructureUtil.translateAjPathName(signatureFile.getCanonicalPath());
            PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(path)));
             
======= 3707411:"ajdoc/src/org/aspectj/tools/ajdoc/StubFileGenerator.java"

 
======= 3707411:"ajdoc/testdata/coverage/foo/UseThisAspectForLinkCheck.java"

======= 3707411:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

======= 3707411:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"

======= 3707411:"ajdoc/testsrc/org/aspectj/tools/ajdoc/CoverageTestCase.java"


======= 39c3a3b:"build/src/$installer$/org/aspectj/Main.java"


======= 9ebfc84:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"

======= 9ebfc84:"weaver/src/org/aspectj/weaver/WeavingURLClassLoader.java"

======= 9ebfc84:"weaver/src/org/aspectj/weaver/WeavingURLClassLoader.java"

======= 9ebfc84:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= 9ebfc84:"weaver/src/org/aspectj/weaver/tools/WeavingAdaptor.java"

======= 9ebfc84:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= 9ebfc84:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"


======= bd16033:"testing/src/org/aspectj/testing/harness/bridge/DirChanges.java"

    public static final String DELAY_NAME = "dir-changes.delay";
    private static final long DELAY;
    static {
        long delay = 10l;
        try {
            delay = Long.getLong(DELAY_NAME).longValue();
            if ((delay > 40000) || (delay < 0)) {
                delay = 10l;
            }
        } catch (Throwable t) {
            // ignore
        }
        DELAY = delay;
    }
======= bd16033:"testing/src/org/aspectj/testing/harness/bridge/DirChanges.java"

     * This sleeps before checking until at least DELAY milliseconds after start.
======= bd16033:"testing/src/org/aspectj/testing/harness/bridge/DirChanges.java"

        final long targetTime = startTime + DELAY;
        do {
            long curTime = System.currentTimeMillis();
            if (curTime >= targetTime) {
                break;
            }
            try {
                break;
            }
        } while (true);

======= 5f6b18b:"runtime/src/org/aspectj/runtime/internal/CFlowStack.java"

 * How we benefit from ThreadLocal when it is available at runtime:
 * 
 * When the CFlowStack class is loaded, we run its static initializer.  This checks the JVM
 * version number and loads an appropriate implementation of the ThreadStackFactory.
 * There are two possible implementations depending on whether this is a 1.1 or 1.2+ JVM.
 * Rather than doing a Class.forName for ThreadLocal and catching a ClassNotFoundEx in order
 * to determine the JVM version, we look at the java class version which I believe can help
 * us identify the Java level.
 * 
 * In the 1.1 JVM case we use a factory implementation that does not use ThreadLocal storage.
 * In the 1.2+ JVM case we use a factory implementation that does use ThreadLocal storage.
 * 
 * Once we have the factory set, whenever someone builds a CFlowStack object, we ask the 
 * factory for a new stack proxy - this is an object that can return us the right stack
 * that we should use on a particular thread.  The reason we create the proxy in the ctor and
 * not lazily in the getThreadStack() method is because it means the getThreadStack() method in
 * this class does not have to be synchronized.
 * 
 * When any of the methods in CFlowStack need to operate on the stack (peek/pop/etc), they 
 * all delegate to getThreadStack() which asks the proxy for the right stack.  Depending on the
 * factory loaded to build the proxy, the call to proxy.getThreadStack() will return a threadlocal
 * based stack or it will call the original implementation of getThreadStack() which manages
 * a Hashtable of threads->stacks.  
 * 
 */
    private Stack getThreadStack() {
    	return stackProxy.getThreadStack();
======= 5f6b18b:"runtime/src/org/aspectj/runtime/internal/CFlowStack.java"

        
    
======= 5f6b18b:"runtime/src/org/aspectj/runtime/internal/CFlowStack.java"

 * Copyright (c) 2004 IBM Corporation
 * 
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     initial implementation 
 * ******************************************************************/
======= 5f6b18b:"runtime/src/org/aspectj/runtime/internal/CFlowStack.java"

 * Copyright (c) 2004 IBM Corporation
 * 
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     initial implementation 
 * ******************************************************************/
  public ThreadStack getNewThreadStack();  
  
======= 5f6b18b:"runtime/src/org/aspectj/runtime/internal/CFlowStack.java"

 * Copyright (c) 2004 IBM Corporation
 * 
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     initial implementation 
 * ******************************************************************/
======= 5f6b18b:"runtime/src/org/aspectj/runtime/internal/CFlowStack.java"

 * Copyright (c) 2004 IBM Corporation
 * 
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     initial implementation 
 * ******************************************************************/
======= 5f6b18b:"runtime/src/org/aspectj/runtime/internal/CFlowStack.java"

 * Copyright (c) 2004 IBM Corporation
 * 
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     initial implementation 
 * 					   Copied from bits of original CFlowStack
 * ******************************************************************/

======= a17b51b:"ajbrowser/src/org/aspectj/tools/ajbrowser/BasicEditor.java"

    	try {
    		showSourceLine(sourceLocation.getSourceFile().getAbsolutePath(), sourceLocation.getLine(), highlight);
    	} catch (NullPointerException npe) {
    		Ajde.getDefault().getIdeUIAdapter().displayStatusInformation(" no corresponding source line to seek to");
    	}
    }
    	

======= a97f3b6:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EclipseAdapterUtils.java"

            || ((startPosition <= 0) && (endPosition <= 0))
            || compilationUnit==null)

======= b0d32ca:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= b0d32ca:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"


======= e7ac54f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"


======= 0521e79:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.java"

======= 0521e79:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"

======= 0521e79:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"

    <ajc-test dir="bugs/StringToString" pr="55341"
     		comment="make helloworld.jar with 'ajc -outjar helloworld.jar HW.java' or run BcweaverJarMaker"
     		keywords="">
        <compile files="X.java" classpath="helloworld.jar">
        	<message kind="warning" line="3"/>
        	<message kind="warning" line="7"/>
        </compile>
    </ajc-test>
  String message = "Hello World!";
  private int HW.intField = 999;
  public String HW.getMessage () {
    return message;
  }
======= 0521e79:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"

======= 0521e79:"weaver/testsrc/org/aspectj/weaver/WeavingURLClassLoaderTest.java"


       description="javadoc for AspectJ lang, lang.reflect and org.aspectj.weaver.tools">
        <javadoc sourcepath="${aspectj.modules.dir}/runtime/src;${aspectj.modules.dir}/weaver/src"
                       classpath="${aspectj.modules.dir}/asm/bin;${aspectj.modules.dir}/bridge/bin;${aspectj.modules.dir}/util/bin;${aspectj.modules.dir}/lib/bcel/bcel.jar"
               packagenames="org.aspectj.lang,org.aspectj.lang.reflect,org.aspectj.weaver.tools" />
    <!-- ============================================================= -->
    <!-- do tracing example with 1.2 load-time weaving                 -->
    <!-- (and use fork/forkclasspath to avoid Eclipse 2.x bug)         -->
    <!-- ============================================================= -->
    <target name="tracing-lt" depends="init"
     description="tracing example with load-time aspect weaving">
       <antcall target="clean" />
       <!-- build application classes -->
       <iajc outjar="${jar.dir}/tracingApp.jar"
          classpath="${aspectjrt.jar}"
          fork="true"
          forkclasspath="${aspectjtools.jar}"
            verbose="off">
         <src path="${example.dir}"/>
         <include name="tracing/*.java" />
       </iajc>
       <!-- Build a read-only tracing library -->
       <iajc outjar="${jar.dir}/tracingLib.jar"
          classpath="${aspectjrt.jar}:${jar.dir}/tracingApp.jar"
          fork="true"
          forkclasspath="${aspectjtools.jar}"
            verbose="off">
         <src path="${example.dir}"/>
         <include name="tracing/version2/Trace.java" />
         <include name="tracing/version2/TraceMyClasses.java" />
       </iajc>
       <!-- test standalone application by running without tracing -->
       <echo message="---------- running without tracing - START"/>
       <java classname="tracing.ExampleMain">
         <classpath>
            <pathelement path="${aspectjrt.jar}"/> 
            <pathelement path="${jar.dir}/tracingApp.jar"/> 
         </classpath>
       </java>
       <echo message="---------- running without tracing - FINISH "/>
       <!-- run appliaction with LTW to add tracing -->
       <echo message="---------- running with tracing - START"/>
       <java classname="tracing.ExampleMain"
         fork="true">
         <classpath>
            <pathelement path="${aspectjrt.jar}"/> 
            <pathelement path="${aspectjtools.jar}"/> 
            <pathelement path="d:/eclipse_aspectj/workspace/weaver/bin"/> 
         </classpath>
         <sysproperty key="aj.weaving.verbose" value="True"/>
         <sysproperty key="aj.class.path" path="${jar.dir}/tracingLib.jar:${jar.dir}/tracingApp.jar"/>
         <sysproperty key="aj.aspect.path" path="${jar.dir}/tracingLib.jar"/>
       </java>
       <echo message="---------- running with tracing - FINISH"/>
    </target>
 ant -f ../build.xml tracing-lt
 set CLASSPATH to include "../jars/tracingApp.jar"
 aj tracing.ExampleMain
 set ASPECTPATH=../jars/tracingLib.jar
 aj tracing.ExampleMain
======= 33d8ee9:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"

======= 33d8ee9:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BcweaverJarMaker.java"

======= 33d8ee9:"util/src/org/aspectj/util/FileUtil.java"

======= 33d8ee9:"util/src/org/aspectj/util/FileUtil.java"

 * Copyright (c) 2004 IBM Corporation
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Matthew Webster, Adrian Colyer, 
 *     Martin Lippert     initial implementation 
 * ******************************************************************/
======= 33d8ee9:"util/src/org/aspectj/util/FileUtil.java"

 * Copyright (c) 2004 IBM Corporation
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Matthew Webster, Adrian Colyer, 
 *     Martin Lippert     initial implementation 
 * ******************************************************************/
======= 33d8ee9:"util/src/org/aspectj/util/FileUtil.java"

 * Copyright (c) 2004 IBM Corporation
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Matthew Webster, Adrian Colyer, 
 *     Martin Lippert     initial implementation 
 * ******************************************************************/
 * Interface implemented by weaving class loaders to allow classes generated by
 * the weaving process to be defined.
 */
======= 33d8ee9:"util/src/org/aspectj/util/FileUtil.java"

 * Copyright (c) 2004 IBM Corporation
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Matthew Webster, Adrian Colyer, 
 *     Martin Lippert     initial implementation 
 * ******************************************************************/
 * This adaptor allows the AspectJ compiler to be embedded in an existing
 * system to facilitate load-time weaving. It provides an interface for a
 * weaving class loader to provide a classpath to be woven by a set of
 * aspects. A callback is supplied to allow a class loader to define classes
 * generated by the compiler during the weaving process.
 * <p>
 * A weaving class loader should create a <code>WeavingAdaptor</code> before
 * any classes are defined, typically during construction. The set of aspects 
 * passed to the adaptor is fixed for the lifetime of the adaptor although the
 * classpath can be augmented. A system property can be set to allow verbose
 * weaving messages to be written to the console.
 *
 */
     * @param loader instance of <code>ClassLoader</code>
     * @param classURLs the URLs from which to resolve classes
     * @param aspectURLs the aspects used to weave classes defined by this class loader
     * @exception IOException weave failed
======= 33d8ee9:"util/src/org/aspectj/util/FileUtil.java"

 * Copyright (c) 2004 IBM Corporation
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Matthew Webster, Adrian Colyer, 
 *     Martin Lippert     initial implementation 
 * ******************************************************************/
 * An interface for weaving class loaders to provide callbacks for a
 * WeavingAdaptor.
 */
======= 33d8ee9:"util/src/org/aspectj/util/FileUtil.java"

======= 33d8ee9:"weaver/testsrc/BcweaverModuleTests.java"

======= 33d8ee9:"weaver/testsrc/org/aspectj/weaver/BcweaverTests.java"

======= 33d8ee9:"weaver/testsrc/org/aspectj/weaver/BcweaverTests.java"

======= 33d8ee9:"weaver/testsrc/org/aspectj/weaver/BcweaverTests.java"

 * Copyright (c) 2004 IBM Corporation
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Matthew Webster     initial implementation 
 * ******************************************************************/
 * @author websterm
 *
 * To change the template for this generated type comment go to
 * Window>Preferences>Java>Code Generation>Code and Comments
 */

    <ajc-test dir="bugs/declarePrecedenceWithClasses" pr="53012"
   	 title="declare precedence on a class should be a compile-time error">
        <compile files="DeclarePrecedenceTestClass.java" >
          <message kind="error" line="10" text="Non-aspect types can only be specified"/>
        </compile>
    </ajc-test>
    
    <ajc-test dir="bugs/declarePrecedenceWithClasses" pr="53012"
   	 title="declare precedence on a class should be a compile-time error">
        <compile files="Priority.aj" />
    </ajc-test>
======= 0a01759:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

    		
    		// Cannot do a dec prec specifying a non-aspect types unless suffixed with a '+'
    		if (!exactType.isAspect() && !pi.isIncludeSubtypes()) {
    			scope.getWorld().showMessage(IMessage.ERROR,
    				"Non-aspect types can only be specified in a declare precedence statement when subtypes are included.  Non-aspect type is : "+exactType.getName(),
    				pi.getSourceLocation(),null);
    		}
    		

    <ajc-test dir="bugs"
            <message kind="error" line="13"/>
   public static void main(String[] args) {
   	  VisiblePrivateInterfaceITDs s = new VisiblePrivateInterfaceITDs();
      s.aMethod();
   }
   public void aMethod() {
      // x is introduced by the following aspect as private
      // so it should not be accessible here
      System.out.println("I have " + x);  // CE 13
   }
   private interface Tag {};
   
   private int Tag.x = 0;
   
   declare parents: VisiblePrivateInterfaceITDs implements Tag;

    
     
    <ajc-test dir="incremental/initialTests/classWAroundClosureRemoved"
      title="make sure additional classes generated during weave are deleted with src class file"
      keywords="incremental-test">
      <compile staging="true" 
        	options="-incremental"
        	sourceroots="."/>
        <inc-compile tag="20" >
            <dir-changes removed="AdviceOnIntroduced$AjcClosure1"/>
        </inc-compile>
    </ajc-test>
    
    public static void main(String[] args) { test(); }
    public static void test() {
    }
    
    int Foo.foo(int n) { return n; }
    Foo.new(int w) {}
        
    int around(int n):
        within(AdviceOnIntroduced) &&
        (args(n) && execution(int foo(int))) {
            int result = proceed(n);
            return result+1;
        }
    
    before(): within(Foo) && execution(new(..)) {
    }
    public static void main(String[] args) { test(); }
    public static void test() {
    }
    
    int Foo.foo(int n) { return n; }
    Foo.new(int w) {}
        
    int around(int n):
        within(AdviceOnIntroduced) &&
        (args(n) && execution(int foo(int))) {
            int result = proceed(n);
            return result+1;
        }
    
    before(): within(Foo) && execution(new(..)) {
    }
======= 7d6b500:"weaver/src/org/aspectj/weaver/bcel/UnwovenClassFile.java"

======= 7d6b500:"weaver/src/org/aspectj/weaver/bcel/UnwovenClassFile.java"


======= 183fc23:"ajde/src/org/aspectj/ajde/internal/BuildNotifierAdapter.java"

======= 183fc23:"ajde/src/org/aspectj/ajde/internal/BuildNotifierAdapter.java"

======= 183fc23:"ajde/src/org/aspectj/ajde/internal/BuildNotifierAdapter.java"

  pointcut m1(): execution(* main(..));
  
  before(): m1() {
    System.err.println("Before main runs");
  }
======= 183fc23:"ajde/src/org/aspectj/ajde/internal/BuildNotifierAdapter.java"

  pointcut m1(): execution(* main(..));
  
  after(): m1() {
    System.err.println("After main runs");
  }
======= 183fc23:"ajde/src/org/aspectj/ajde/internal/BuildNotifierAdapter.java"

  pointcut m1(): call(* *print*(..));
  
  before(): m1() {
    System.err.println("Calling print");
  }
======= 183fc23:"ajde/src/org/aspectj/ajde/internal/BuildNotifierAdapter.java"

  pointcut m1(): call(* *print*(..));
  
  after(): m1() {
    System.err.println("After call to print");
  }
======= 183fc23:"ajde/src/org/aspectj/ajde/internal/BuildNotifierAdapter.java"

======= 183fc23:"ajde/src/org/aspectj/ajde/internal/BuildNotifierAdapter.java"

======= 183fc23:"ajde/src/org/aspectj/ajde/internal/BuildNotifierAdapter.java"

======= 183fc23:"ajde/src/org/aspectj/ajde/internal/BuildNotifierAdapter.java"

======= 183fc23:"ajde/src/org/aspectj/ajde/internal/BuildNotifierAdapter.java"

======= 183fc23:"ajde/src/org/aspectj/ajde/internal/BuildNotifierAdapter.java"

======= 183fc23:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

======= 183fc23:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

 * Copyright (c) 2004 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     Initial version
 * ******************************************************************/
 * It is now possible to cancel the compiler during either the
 * compilation or weaving phases - this testcase verifies a few
 * cases, making sure the process stops when expected.  It can
 * check the disk contents, but it doesn't right now.
 * 
 * Two different .lst files are used during these tests: LoadsaCode.lst and 
 * EvenMoreCode.lst which contain mixes of aspects and classes
 * 
 * Here are some things to think about that will help you understand what is 
 * on the disk when we cancel the compiler.
 * 
 * There are 3 important phases worth remembering :
 * - Compile all the types 
 * - Weave all the aspects
 * - Weave all the classes
 * 
 * Each of those steps goes through all the types.  This
 * means during the 'weave all the aspects' step we are 
 * jumping over classes and during the 'weave all the
 * classes ' step we are jumping over aspects.  Why is this important?
 * 
 *  
 * We only write bytes out during the 'weave all the classes ' phase and it is even
 * during that phase that we write out the bytes for aspects.  This means if you cancel
 * during compilation or during the weaving of aspects - there will be nothing on the 
 * disk.  If you cancel whilst in the 'weave all the classes ' phase then the disk
 * will contain anything finished with by the cancellation point.
 */
        public int numWovenClassMessages = 0;
        public int numWovenAspectMessages = 0;
        public int numCompiledMessages = 0;
        
        
======= 183fc23:"bridge/src/org/aspectj/bridge/IProgressListener.java"

    /**
     * @param cancelRequested true if the caller wants the current compilation to stop asap
     */
======= 183fc23:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= 183fc23:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= 183fc23:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= 183fc23:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= 183fc23:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= 183fc23:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/AjCompilerAdapter.java"

======= 183fc23:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java"

======= 183fc23:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java"

======= 183fc23:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java"

======= 183fc23:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java"

======= 183fc23:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java"

======= 183fc23:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java"

======= 183fc23:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/WeaverAdapter.java"

======= 183fc23:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 183fc23:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 183fc23:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

                    if (handler.hasErrors() || (progressListener!=null && progressListener.isCancelledRequested())) {
======= 183fc23:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 183fc23:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 183fc23:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"


 * Created on 30-Jul-03
 *
 * To change this generated comment go to 
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
 * @author websterm
 *
 * To change this generated comment go to 
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
======= 34dbb0c:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

======= 34dbb0c:"ajde/testsrc/org/aspectj/ajde/InpathTestcase.java"

======= 34dbb0c:"ajde/testsrc/org/aspectj/ajde/InpathTestcase.java"

======= 34dbb0c:"ajde/testsrc/org/aspectj/ajde/InpathTestcase.java"

======= 34dbb0c:"ajde/testsrc/org/aspectj/ajde/InpathTestcase.java"

======= 34dbb0c:"ajde/testsrc/org/aspectj/ajde/InpathTestcase.java"

 * Copyright (c) 2004 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
 * Created on 16-Mar-2004
 *
 * To change the template for this generated file go to
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
 * @author websterm
 *
 * To change the template for this generated type comment go to
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
 
======= 34dbb0c:"ajde/testsrc/org/aspectj/ajde/ResourceCopyTestCase.java"

======= 34dbb0c:"ajde/testsrc/org/aspectj/ajde/ResourceCopyTestCase.java"

======= 34dbb0c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 34dbb0c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 34dbb0c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 34dbb0c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 34dbb0c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 34dbb0c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 34dbb0c:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 34dbb0c:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 34dbb0c:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 34dbb0c:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 34dbb0c:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 34dbb0c:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

    
    public Manifest getManifest (boolean shouldCreate) {
    }
    

======= 1a4c02c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"


======= 41c6f6d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= 41c6f6d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= 41c6f6d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= 41c6f6d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"

======= 41c6f6d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjState.java"


======= 5c67166:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

======= 5c67166:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

    
    <ajc-test dir="bugs"  pr="51322"
    	title="Introduce Unknown Type to class causes Null pointer exception"  >
        <compile files="Pr51322.java"> 
        	<message kind="error" line="5"/>
        </compile>
    </ajc-test>
  public void A.aMethod(Object x) {}
  public void A.someMethod(WCharType a) { }

    
      <ajc-test dir="bugs" pr="44272"
    		title="retitle warning to circular {advice} dependency at ...">
        <compile files="CircularAdvicePrecedence.java">
            <message kind="error" line="4"/> 
            <message kind="error" line="5"/> 
            <message kind="error" line="6"/> 
        </compile>
    </ajc-test>
    pointcut crun() : execution (void run()) ;
    before() : crun() {}
    after() returning : crun() {}
    void around() : crun() { proceed(); }
======= 0109534:"weaver/src/org/aspectj/weaver/Shadow.java"

======= 0109534:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

    					"circularity in declare precedence, '*' occurs more than once",
======= 0109534:"weaver/src/org/aspectj/weaver/patterns/DeclarePrecedence.java"

    					"circularity in declare precedence, '" + exactType.getName() + 

======= c798923:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.java"

======= c798923:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMemberFinder.java"

   	 title="fail in compiling aspect with overriding method introduction with different throws clause ">
        <compile files="IntertypeDifferentThrows.java" />
    </ajc-test>
  public A(){}
  public void m() throws Exception{}
  public B(){}
  public void some_code(){
  }
  public void B.m(){}

======= 5d73494:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java"

======= 5d73494:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"


    
    <ajc-test dir="bugs" pr="51320"
   	 title="ClasscastException on concretization of if(false)">
        <compile files="DecwClassCastException.java">
        
         <!-- These are the illegal PCDs against a deow -->
         <message kind="error" line="27" text="if() pointcut designator cannot be used"/>
         <message kind="error" line="29" text="if() pointcut designator cannot be used"/>
         
         <message kind="error" line="31" text="cflow() pointcut designator cannot be used"/>
         <message kind="error" line="33" text="cflow() pointcut designator cannot be used"/>
         
         <message kind="error" line="35" text="cflowbelow() pointcut designator cannot be used"/>
         <message kind="error" line="37" text="cflowbelow() pointcut designator cannot be used"/>
         
         <message kind="error" line="39" text="this() pointcut designator cannot be used"/>
         <message kind="error" line="41" text="this() pointcut designator cannot be used"/>
         
         <message kind="error" line="43" text="target() pointcut designator cannot be used"/>
         <message kind="error" line="45" text="target() pointcut designator cannot be used"/>
         
         <message kind="error" line="47" text="args() pointcut designator cannot be used"/>
         <message kind="error" line="49" text="args() pointcut designator cannot be used"/>
         
        </compile>
    </ajc-test>
 * From:
 * 
 * http://dev.eclipse.org/viewcvs/indextech.cgi/~checkout~/aspectj-home/doc/progguide/semantics-declare.html#d0e6499
 *
 * Pointcuts that appear inside of declare forms have certain restrictions. 
 * Like other pointcuts, these pick out join points, but they do so in a 
 * way that is statically determinable. 
 * 
 * Consequently, such pointcuts may not include, directly or indirectly 
 * (through user-defined pointcut declarations) pointcuts that discriminate 
 * based on dynamic (runtime) context. Therefore, such pointcuts may not be 
 * defined in terms of
 * 
 * cflow
 * cflowbelow
 * this
 * target
 * args
 * if
 * 
 * all of which can discriminate on runtime information. 
 */
    public static void main(String[] args) {
    }
    
======= fbc0aa3:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= fbc0aa3:"weaver/src/org/aspectj/weaver/patterns/ArgsPointcut.java"

======= fbc0aa3:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= fbc0aa3:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"

======= fbc0aa3:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fbc0aa3:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fbc0aa3:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= fbc0aa3:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"

======= fbc0aa3:"weaver/src/org/aspectj/weaver/patterns/ThisOrTargetPointcut.java"


  
  after(): call(* approximate(..)) {
  	if (CalculatePI.iteration%10000==0) 
  	  System.out.println("Approximation is now:"+
  	    (CalculatePI.inCircle/CalculatePI.inSquare)*4.0f);
  }
  
  declare parents: Logger implements java.io.Serializable;
   static final void println(String s){ System.out.println(s); }
   pointcut goCut(): cflow(this(Demo) && execution(void go()));
   pointcut demoExecs(): within(Demo) && execution(* *(..));
   Object around(): demoExecs() && !execution(* go()) && goCut() {
   }
   static private void printParameters(JoinPoint jp) {
   }
======= 16a0abd:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

======= 16a0abd:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

 * Copyright (c) 2004 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *    Andy Clement     Initial version
 * ******************************************************************/
      
      <varlistentry>
        <term>-Xreweavable[:compress]</term>
        <listitem><para>(Experimental) runs weaver in reweavable mode which causes
        it to create woven classes that can be rewoven, subject to the restriction that
        on attempting a reweave all the types that advised the woven type must be accessible.
        </para></listitem>
      </varlistentry>
======= 16a0abd:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

            } else if (arg.startsWith("-Xreweavable")) {
            	buildConfig.setXreweavable(true);
            	if (arg.endsWith(":compress")) {
            		buildConfig.setXreweavableCompressClasses(true);
            	}
======= 16a0abd:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= 16a0abd:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= 16a0abd:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= 16a0abd:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 16a0abd:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    
    public void setXReweavable(boolean reweavable) {
    	cmd.addFlag("-Xreweavable",reweavable);
    }
======= 16a0abd:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= 16a0abd:"testing/src/org/aspectj/testing/harness/bridge/CompilerRun.java"

                        factory.create("Xreweavable"),
======= 16a0abd:"weaver/src/org/aspectj/weaver/Advice.java"

    public static Advice makeCflowEntry(World world, Pointcut entry, boolean isBelow, Member stackField, int nFreeVars, List innerCflowEntries, ResolvedTypeX inAspect){
    	ret.concreteAspect = inAspect;
======= 16a0abd:"weaver/src/org/aspectj/weaver/Advice.java"

    public static Advice makeSoftener(World world, Pointcut entry, TypePattern exceptionType,ResolvedTypeX inAspect) {
    	ret.concreteAspect = inAspect;
    	// System.out.println("made ret: " + ret + " with " + exceptionType);
======= 16a0abd:"weaver/src/org/aspectj/weaver/CrosscuttingMembers.java"

======= 16a0abd:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

======= 16a0abd:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

======= 16a0abd:"weaver/src/org/aspectj/weaver/Shadow.java"

======= 16a0abd:"weaver/src/org/aspectj/weaver/Shadow.java"

======= 16a0abd:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

 * WeaverStateInfo represents how a type was processed.  It is used by the weaver to determine how a type 
 * was previously treated and whether reweaving is allowed.
 * The format in the data stream is:
 * 
 * Byte:  Kind.  UNTOUCHED|WOVEN|EXTENDED - If extended it can have two extra bits set 'REWEAVABLE' and 'REWEAVABLE_COMPRESSION_BIT'
 * Short: typeMungerCount - how many type mungers have affected this type
 * <TypeX & ResolvedTypeMunger>: The type mungers themselves
 * If we are reweavable then we also have:
 * Short: Number of aspects that touched this type in some way when it was previously woven
 * <String> The fully qualified name of each type
 * Int: Length of class file data (i.e. the unwovenclassfile)
 * Byte[]: The class file data, compressed if REWEAVABLE_COMPRESSION_BIT set.
 */
======= 16a0abd:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= 16a0abd:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= 16a0abd:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

======= 16a0abd:"weaver/src/org/aspectj/weaver/WeaverStateInfo.java"

    ////
    
======= 16a0abd:"weaver/src/org/aspectj/weaver/bcel/BcelCflowStackFieldAdder.java"

======= 16a0abd:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 16a0abd:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

    
======= 16a0abd:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        if (clazz.isWoven() && !clazz.isReweavable()) {
       
        Set aspectsAffectingType = null;
        if (inReweavableMode) aspectsAffectingType = new HashSet();
======= 16a0abd:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        	boolean typeMungerAffectedType = munger.munge(this);
        	if (typeMungerAffectedType) {
        		isChanged = true;
        		if (inReweavableMode) aspectsAffectingType.add(munger.getAspectType().getName());
        	}
======= 16a0abd:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

              isChanged = true;
======= 16a0abd:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        if (inReweavableMode) {
        	WeaverStateInfo wsi = clazz.getOrCreateWeaverStateInfo();
        	wsi.addAspectsAffectingType(aspectsAffectingType);
        	wsi.setUnwovenClassFileData(ty.getJavaClass().getBytes());
        	wsi.setReweavable(true,compressReweavableAttributes);
        } else {
        	clazz.getOrCreateWeaverStateInfo().setReweavable(false,false);
        }
        
======= 16a0abd:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 16a0abd:"weaver/src/org/aspectj/weaver/bcel/BcelObjectType.java"

    
    // repeat initialization
    public void setJavaClass(JavaClass newclass) {
    	this.javaClass = newclass;
    	resetState();
    }
    
======= 16a0abd:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 16a0abd:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 16a0abd:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

    
    private boolean inReweavableMode = false;
    private boolean compressReweavableAttributes = false;
    
======= 16a0abd:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

    	 	
    	
    	Set alreadyConfirmedOK = new HashSet();
            // If the class is marked reweavable, check any aspects around when it was built are in this world
        		Set aspectsPreviouslyInWorld = wsi.getAspectsAffectingType();
                                    " exists.  Originates from "+rtx.getSourceLocation().getSourceFile(),null,null);
            	classType.resetState();
======= 16a0abd:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 16a0abd:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 16a0abd:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"

======= 16a0abd:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= 16a0abd:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

======= 16a0abd:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"


======= 6ddae42:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= 6ddae42:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= 6ddae42:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= 6ddae42:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= 6ddae42:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= 6ddae42:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= 6ddae42:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= 6ddae42:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= 6ddae42:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 6ddae42:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= 6ddae42:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InlineAccessFieldBinding.java"

======= 6ddae42:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InlineAccessFieldBinding.java"

    
======= 6ddae42:"tests/bugs/protectedvf/main/Driver.java"


======= 669cd7c:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

======= 669cd7c:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Mik Kersten     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
        IHierarchy model = Ajde.getDefault().getStructureModelManager().getHierarchy();
        assertTrue("model exists", model != null);
        
        IHierarchy model = Ajde.getDefault().getStructureModelManager().getHierarchy();
        assertTrue("model exists", model != null);
        final List preBuildKinds = new ArrayList();
  		    public void preProcess(IProgramElement node) {
  		    	preBuildKinds.add(node.getKind());
  		    }
  		};
  		Ajde.getDefault().getStructureModelManager().getHierarchy().getRoot().walk(walker);
        final List postBuildKinds = new ArrayList();
  		    public void preProcess(IProgramElement node) {
  		    	postBuildKinds.add(node.getKind());
  		    }
  		};
  		Ajde.getDefault().getStructureModelManager().getHierarchy().getRoot().walk(walker2);
======= 669cd7c:"asm/src/org/aspectj/asm/IProgramElement.java"

======= 669cd7c:"asm/src/org/aspectj/asm/IProgramElement.java"

======= 669cd7c:"asm/src/org/aspectj/asm/IProgramElement.java"


    <ajc-test dir="bugs" pr="50570"
      title="CatchClauseSignature has broken operation">
        <compile files="HandlerSig.java"/>
        <run class="HandlerSig"/>
    </ajc-test>
======= 19bac86:"weaver/src/org/aspectj/weaver/Member.java"

======= 19bac86:"weaver/src/org/aspectj/weaver/Member.java"

        String[] names = getParameterNames(world);
        if (names != null) pName = names[0];
======= 19bac86:"weaver/src/org/aspectj/weaver/ResolvedMember.java"

    public String[] parameterNames = null;
======= 19bac86:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 19bac86:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

                sig,
======= 19bac86:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

 			}

======= 0c83343:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= 0c83343:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= 0c83343:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= 0c83343:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 0c83343:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= 0c83343:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/AjdtBatchTests.java"

======= 0c83343:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CommandTestCase.java"

======= 0c83343:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CommandTestCase.java"

======= 0c83343:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/CommandTestCase.java"

 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     PARC     initial implementation 
 * ******************************************************************/
======= 0c83343:"runtime/src/org/aspectj/runtime/reflect/Factory.java"

    private static Object[] NO_ARGS = new Object[0];
    
    
    
    
======= 0c83343:"weaver/src/org/aspectj/weaver/Lint.java"

======= 0c83343:"weaver/src/org/aspectj/weaver/World.java"

    protected boolean XlazyTjp;
======= 0c83343:"weaver/src/org/aspectj/weaver/World.java"

======= 0c83343:"weaver/src/org/aspectj/weaver/World.java"

======= 0c83343:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

        	((BcelShadow)shadow).requireThisJoinPoint(pointcutTest != Literal.TRUE && getKind() != AdviceKind.Around);
======= 0c83343:"weaver/src/org/aspectj/weaver/bcel/BcelAdvice.java"

        	il.append(shadow.loadThisJoinPoint());
======= 0c83343:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 0c83343:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 0c83343:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    private boolean isThisJoinPointLazy;
    private int lazyTjpConsumers = 0;
======= 0c83343:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    public void requireThisJoinPoint(boolean hasGuardTest) {
    	if (!hasGuardTest) {
    		isThisJoinPointLazy = false;
    	} else {
    		lazyTjpConsumers++;
    	}
    }
    
    
    public Var getThisJoinPointVar() {
    	requireThisJoinPoint(false);
    void initializeThisJoinPoint() {
    	if (thisJoinPointVar == null) return;
    	
    	if (isThisJoinPointLazy) {
    		isThisJoinPointLazy = checkLazyTjp();
    	}
    		
    }
    
    private boolean checkLazyTjp() {    	
    	// check for around advice
    	for (Iterator i = mungers.iterator(); i.hasNext();) {
    	
    	return true;
    }
    
    InstructionList loadThisJoinPoint() {
    	if (isThisJoinPointLazy) {
    		il.append(createThisJoinPoint());
    		
    		if (lazyTjpConsumers > 1) {
    		}
    	} else {			
    	}
    	
    }
    
                    INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
    |               ASTORE_3
    |               ALOAD_3
    |               ALOAD_3
    |               ALOAD_3
                    ASTORE 9
                    ALOAD 9
                    INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                    ASTORE 10
    |               ASTORE 12
    |               ALOAD 12
    |               ALOAD 9
    |               BIPUSH 1
    |               ALOAD 10
    |               INVOKESPECIAL HelloWorld$AjcClosure15.<init> ([Ljava/lang/Object;)V
    |               ALOAD 10
                    INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
    |               ASTORE 4
    |               BIPUSH 0
    |               ALOAD_2
    |               INVOKESPECIAL HelloWorld$AjcClosure7.<init> ([Ljava/lang/Object;)V
    |               ALOAD_2
                    ASTORE 6
                    ALOAD 6
                    INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                    ASTORE 10
    |               ASTORE 12
    |               ALOAD 12
    |               ALOAD 8
    |               ALOAD 12
    |               ALOAD 6
    |               ALOAD 12
    |               ALOAD 10
    |               ALOAD 12
    |               ALOAD 10
                    INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
    |               ASTORE_2
    |               ALOAD_2
    |               ALOAD_2
    |               ALOAD_2
                    ASTORE 7
                    ALOAD 7
                    INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                    ASTORE 8
    |               ASTORE 9
    |               BIPUSH 0
    |               ALOAD 7
    |               ALOAD 9
    |               ALOAD 8
    |               ALOAD 9
    |               ALOAD 8
                    INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
    |               ASTORE 4
    |               BIPUSH 0
    |               ALOAD_2
    |               INVOKESPECIAL HelloWorld$AjcClosure3.<init> ([Ljava/lang/Object;)V
    |               ALOAD_2
                    ASTORE 6
                    ALOAD 6
                    INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                    ASTORE 10
    |               ASTORE 12
    |               ALOAD 12
    |               ALOAD 8
    |               ALOAD 12
    |               ALOAD 6
    |               ALOAD 12
    |               ALOAD 10
    |               ALOAD 12
    |               ALOAD 10
                    INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                    ASTORE 6
                    ALOAD 6
                    INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
                    ASTORE 5
    |               ALOAD 5
    |               INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
    |               ASTORE_3
    |               ALOAD_3
    |               INVOKESTATIC org.aspectj.runtime.reflect.Factory.makeJP (Lorg/aspectj/lang/JoinPoint$StaticPart;Ljava/lang/Object;Ljava/lang/Object;Ljava/lang/Object;)Lorg/aspectj/lang/JoinPoint;
    |               ASTORE_2
    | |             ALOAD_2
    | |             ALOAD_3

======= f24286d:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= f24286d:"weaver/src/org/aspectj/weaver/Checker.java"

======= f24286d:"weaver/src/org/aspectj/weaver/Checker.java"

======= f24286d:"weaver/src/org/aspectj/weaver/Checker.java"

 * Copyright (c) 2000, 2003 IBM Corporation and others.
 * All rights reserved. This program and the accompanying materials 
 * are made available under the terms of the Common Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/cpl-v10.html
 * 
 * Contributors:
 *     IBM Corporation - initial API and implementation
 *******************************************************************************/
 * Clients can pass a single cross-reference handler to the weaver on construction
 * of a BcelWorld. Any cross-references detected during munging will be notified
 * to the handler.
 */
======= f24286d:"weaver/src/org/aspectj/weaver/Shadow.java"

======= f24286d:"weaver/src/org/aspectj/weaver/Shadow.java"

======= f24286d:"weaver/src/org/aspectj/weaver/World.java"

======= f24286d:"weaver/src/org/aspectj/weaver/World.java"

======= f24286d:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= f24286d:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"

======= f24286d:"weaver/src/org/aspectj/weaver/bcel/BcelWorld.java"


======= 6f099df:"build/src/org/aspectj/internal/tools/ant/taskdefs/AntBuilder.java"


  <ajc-test dir="bugs/caseSensitivity" pr="42515"
      title="NPE When compiling intertype declaration">
        <compile files="uniqueId/Numbered.java,uniqueId/Bug.aj">
        </compile>
  </ajc-test>   
        
  private long Numbered.objId;	

======= b3b1eec:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"

======= b3b1eec:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"

        
        // make sure we handle out of memory gracefully...
        try {
        	// byte[] b = new byte[100000000]; for testing OoME only!
        	run(args, holder);
        } catch (OutOfMemoryError outOfMemory) {
        	IMessage outOfMemoryMessage = new Message(OUT_OF_MEMORY_MSG,null,true);
        	holder.handleMessage(outOfMemoryMessage);
        	systemExit(holder);  // we can't reasonably continue from this point.
        }

======= ad2fb7a:"runtime/src/org/aspectj/lang/SoftException.java"

 *               2002 Palo Alto Research Center, Incorporated (PARC),
 *               2004 Contributors.
======= ad2fb7a:"runtime/src/org/aspectj/lang/SoftException.java"

======= ad2fb7a:"runtime/src/org/aspectj/lang/SoftException.java"

 * <code>getWrappedThrowable()</code> or
 * <code>getCause()</code>.
    private static final boolean HAVE_JAVA_14;
    static {
        boolean java14 = false;
        try {
            Class.forName("java.nio.Buffer");
            java14 = true;
        } catch (Throwable t) {
            // still false;
        }
        HAVE_JAVA_14 = java14;
    }
    // shouldn't field be private final, constructor default or private? 
    // but either would be a binary incompatible change.
    Throwable inner; 
======= ad2fb7a:"runtime/src/org/aspectj/lang/SoftException.java"

    public void printStackTrace() {
        printStackTrace(System.err);                
    }
    
    public void printStackTrace(PrintStream stream) {
        super.printStackTrace(stream);
        final Throwable _inner = this.inner;
        if (!HAVE_JAVA_14 && (null != _inner)) {
            stream.print("Caused by: ");
            _inner.printStackTrace(stream);
        }
    }
    
    public void printStackTrace(PrintWriter stream) {
        super.printStackTrace(stream);
        final Throwable _inner = this.inner;
        if (!HAVE_JAVA_14 && (null != _inner)) {
            stream.print("Caused by: ");
            _inner.printStackTrace(stream);
        }
    }
======= ad2fb7a:"runtime/testsrc/RuntimeModuleTests.java"

======= ad2fb7a:"runtime/testsrc/RuntimeModuleTests.java"

        RuntimeException fun = new RuntimeException("fun");
        NoAspectBoundException nab = new NoAspectBoundException("Foo", fun);
        assertEquals(fun,nab.getCause());
    }
    public void testSoftExceptionPrintStackTrace() {
        // let's see
        // save to specified PrintStream
        ByteArrayOutputStream sink = new ByteArrayOutputStream();
        PrintStream out = new PrintStream(sink);
        new SoftException(new Error("xyz")).printStackTrace(out);
        String s = new String(sink.toByteArray());
        out.flush();
        checkSoftExceptionString(s);
        // save to specified PrintWriter
        sink = new ByteArrayOutputStream();
        PrintWriter pout = new PrintWriter(sink);
        new SoftException(new Error("xyz")).printStackTrace(pout);
        pout.flush();
        s = new String(sink.toByteArray());
        checkSoftExceptionString(s);
        // check System.err redirect
        PrintStream systemErr = System.err;
        try {
            sink = new ByteArrayOutputStream();
            out = new PrintStream(sink);
            System.setErr(out);
            new SoftException(new Error("xyz")).printStackTrace();
            out.flush();
            s = new String(sink.toByteArray());
            checkSoftExceptionString(s);
        } finally {
            System.setErr(systemErr);
        }
    }
    static void checkSoftExceptionString(String s) {        
        assertTrue(-1 != s.indexOf("SoftException"));
        assertTrue(-1 != s.indexOf("Caused by: java.lang.Error"));
        assertTrue(-1 != s.indexOf("xyz"));
        assertTrue(-1 != s.indexOf("testSoftExceptionPrintStackTrace"));

======= 0071cb4:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

            if (!Modifier.isAbstract(sig.getModifiers())) {
======= 0071cb4:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

     public List getInterTypeMungersIncludingSupers() {

======= 5834de9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java"

======= 5834de9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java"

======= 5834de9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectClinit.java"

======= 5834de9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= 5834de9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= 5834de9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= 5834de9:"runtime/src/org/aspectj/lang/NoAspectBoundException.java"

======= 5834de9:"runtime/testsrc/RuntimeModuleTests.java"

======= 5834de9:"runtime/testsrc/RuntimeModuleTests.java"

    
    public void testNoAspectBoundException() {
    	RuntimeException fun = new RuntimeException("fun");
    	NoAspectBoundException nab = new NoAspectBoundException("Foo", fun);
    	assertEquals(fun,nab.getCause());
    }
    <ajc-test dir="bugs" pr="44587"
      title="Erroneous exception conversion">
        <compile files="ErroneousExceptionConversion.java">
        </compile>
        <run class="ErroneousExceptionConversion"/>
    </ajc-test>
    
  <ajc-test dir="bugs" pr="34206"
      title="before():execution(new(..)) does not throw NoAspectBoundException">
        <compile files="ErroneousExceptionConversion1.java">
        </compile>
        <run class="ErroneousExceptionConversion1"/>
    </ajc-test>
    
======= 5834de9:"tests/new/ConstructorExecInitFails.java"

======= 5834de9:"tests/new/ConstructorExecInitFails.java"

    	} catch (NoAspectBoundException e) {
    		
    		Tester.check(e.getCause() instanceof NoAspectBoundException,
    				"Expected NoAspectBoundException, found " + e.getCause());
======= 5834de9:"weaver/src/org/aspectj/weaver/AjcMemberMaker.java"

======= 5834de9:"weaver/src/org/aspectj/weaver/AjcMemberMaker.java"

======= 5834de9:"weaver/src/org/aspectj/weaver/AjcMemberMaker.java"

======= 5834de9:"weaver/src/org/aspectj/weaver/NameMangler.java"

======= 5834de9:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 5834de9:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 5834de9:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 5834de9:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"


======= 7bbd1f4:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/parser/AjParser.java"

    
    <ajc-test dir="bugs" 
        <compile files="PrivilegedParsing.java"/>
        <run class="PrivilegedParsing"/>
    </ajc-test>
   private int hidden;
   public int visible;
   public PrivilegedParsing(int priv, int pub) {
      hidden = priv;
      visible = pub;
   }
   public void doSomething() {
      System.out.println("" + hidden + ", " + visible + "");
   }
   public static void main(String[] args) {
      PrivilegedParsing capsule = new PrivilegedParsing(1, 1);
      capsule.doSomething();
   }
   static privileged //<== JUST TRY TO UNCOMMENT THIS!
   aspect Inner {
      pointcut call2doSomething(PrivilegedParsing capsule):
         call(void PrivilegedParsing.doSomething())
         && target(capsule);
      before(PrivilegedParsing capsule): call2doSomething(capsule) {
         capsule.visible++;
         capsule.hidden++;
      }
   }
   static privileged //<== JUST TRY TO UNCOMMENT THIS!
   aspect Inner {
      pointcut call2doSomething(PrivilegedParsing capsule):
         call(void PrivilegedParsing.doSomething())
         && target(capsule);
      before(PrivilegedParsing capsule): call2doSomething(capsule) {
         capsule.visible++;
         capsule.hidden++;
      }
   }

    <ajc-test dir="bugs" pr="44586"
      title="After throwing advice on ctors doesn't execute for inter-type decl field inits">
        <compile files="AfterThrowingCtor.java">
        </compile>
  		<run class="AfterThrowingCtor"/>
    </ajc-test>

======= a4a1234:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

======= a4a1234:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

======= a4a1234:"util/src/org/aspectj/util/ConfigParser.java"

        } else {
          File[] files = dir.listFiles(filter);
          if (files.length == 0) {
          }
          for (int i = 0; i < files.length; i++) {
          }

======= 7b081f2:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/parser/AjParser.java"

    

======= 97ab1e9:"bridge/src/org/aspectj/bridge/IMessage.java"

    
    public List getExtraSourceLocations();
======= 97ab1e9:"bridge/src/org/aspectj/bridge/Message.java"

======= 97ab1e9:"bridge/src/org/aspectj/bridge/Message.java"

    private final List/*SourceLocation*/ extraSourceLocations;
======= 97ab1e9:"bridge/src/org/aspectj/bridge/Message.java"

        
        else {
            this.extraSourceLocations = Collections.EMPTY_LIST;
        }
======= 97ab1e9:"bridge/src/org/aspectj/bridge/Message.java"

          this(message, "", kind, sourceLocation, thrown, null );              
======= 97ab1e9:"bridge/src/org/aspectj/bridge/Message.java"

        return MessageUtil.renderMessage(this,false);
======= 97ab1e9:"bridge/src/org/aspectj/bridge/Message.java"

    
======= 97ab1e9:"bridge/src/org/aspectj/bridge/MessageUtil.java"

       
        ISourceLocation loc = message.getSourceLocation();
        String locString = (null == loc ? "" : " at " + loc);
        String result = message.getKind() + locString + " " + message.getMessage();
      
        Throwable thrown = message.getThrown();
        if (thrown != null) {
            result += " -- " + LangUtil.renderExceptionShort(thrown);  
            result += "\n" + LangUtil.renderException(thrown, elide);         
        
        if (message.getExtraSourceLocations().isEmpty()) {
            return result;    
        else {
            return addExtraSourceLocations(message, result);    
    
    
    
    
    
======= 97ab1e9:"bridge/src/org/aspectj/bridge/SourceLocation.java"

        sb.append(startLine); //"" + startLine + "-" + endLine);
======= 97ab1e9:"org.aspectj.ajdt.core/src/org/aspectj/tools/ajc/Main.java"

            if (message.getExtraSourceLocations().isEmpty()) {
            } else {
            	return MessageUtil.addExtraSourceLocations(message, sb.toString());
            }
            
======= 97ab1e9:"testing/src/org/aspectj/testing/xml/SoftMessage.java"

======= 97ab1e9:"testing/src/org/aspectj/testing/xml/SoftMessage.java"

        <compile files="Simple.java" options="-Xlint:ignore"/>
        <compile files="MethodSignatures.java" options="-1.4,-Xlint:ignore"/>
        <compile files="CallTypes.java" options="-1.4,-Xlint:ignore"/>
        <compile files="CallTypesI.java" options="-1.4,-Xlint:ignore"/>
        <compile files="PR519.java" options="-Xlint:ignore"/>
        <compile files="IntroductionsOverriding.java" options="-Xlint:ignore" />
        <compile files="MultiAndAround.java" options="-Xlint:ignore"/>
        <compile files="NotAndDeclaringTypes.java" options="-Xlint:ignore"/>
        <compile files="Driver.java,p1/C1.java,p1/p2/C2.java" />
    before() : runB() { } // warn here
    pointcut runB(): call(void B.run());
    before() : call(int B.run()) {}
    public static void main(String[] args) {
        // ok with -1.4; otherwise, becomes A.run in bytecode
        new B().run();        
        // never works - compile-time type of reference is A, not B
        ((A) new B()).run();
    }
    declare error : call(void B.run()) : // warn here
        "This should be the only error";
    
    declare error : call(int B.run()) :
        "This error should not happen";
======= 97ab1e9:"tests/new/CallTypesI.java"

======= 97ab1e9:"tests/new/CallTypesI.java"

    
    
======= 97ab1e9:"tests/new/IndeterminateArg.java"

    pointcut safe()                                : (call(C+.new(..))) ||
                                                        (call(* *.*(..)) && target(C)); 
======= 97ab1e9:"tests/new/IndeterminateArgType.java"

    pointcut safe()                                : (call(Safe+.new(..))) ||
                                                        (call(* *.*(..)) && target(Safe)); 
======= 97ab1e9:"weaver/src/org/aspectj/weaver/Checker.java"

                null,
                new ISourceLocation[]{this.getSourceLocation()});
======= 97ab1e9:"weaver/src/org/aspectj/weaver/Lint.java"

    public final Kind unmatchedSuperTypeInCall = 
        new Kind("unmatchedSuperTypeInCall", "does not match because declaring type is {0}, if match desired use target({1})");
            
======= 97ab1e9:"weaver/src/org/aspectj/weaver/Lint.java"

            if (kind == null) return;
            
            String text = MessageFormat.format(message, infos );
            text += " [Xlint:" + name + "]";
            world.getMessageHandler().handleMessage(
                new Message(text, "", kind, location, null, extraLocations));
======= 97ab1e9:"weaver/src/org/aspectj/weaver/patterns/AndPointcut.java"

======= 97ab1e9:"weaver/src/org/aspectj/weaver/patterns/ExactTypePattern.java"

    	return type.toString() + (includeSubtypes ? "+" : "");
======= 97ab1e9:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

    
    private ShadowMunger munger = null; // only set after concretization
    public KindedPointcut(
        Shadow.Kind kind,
        SignaturePattern signature) {
        this.kind = kind;
        this.signature = signature;
    }
    public KindedPointcut(
        Shadow.Kind kind,
        SignaturePattern signature,
        ShadowMunger munger)
    {
        this(kind, signature);
        this.munger = munger;
    }
======= 97ab1e9:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

            if(kind == Shadow.MethodCall) {
                warnOnConfusingSig(shadow);
            }
            return  FuzzyBoolean.NO; 
        }
        // no warnings for declare error/warning
        if (munger instanceof Checker) return;
        
        World world = shadow.getIWorld();
        
        
        
        // warning not needed if match type couldn't ever be the declaring type
            return;
                shadow.getIWorld().getLint().unmatchedSuperTypeInCall.signal(
                    new String[] {
                        shadow.getSignature().getDeclaringType().toString(),
                        signature.getDeclaringType().toString()
                    },
                    this.getSourceLocation(),
                    new ISourceLocation[] {shadow.getSourceLocation()} );               
======= 97ab1e9:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

        ret.copyLocationFrom(this);
        return ret;
======= 97ab1e9:"weaver/src/org/aspectj/weaver/patterns/NotPointcut.java"

======= 97ab1e9:"weaver/src/org/aspectj/weaver/patterns/OrPointcut.java"

======= 97ab1e9:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

        if (shouldCopyLocationForConcretize()) ret.copyLocationFrom(this);
======= 97ab1e9:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= 97ab1e9:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

    
    // We want to keep the original source location, not the reference location
    protected boolean shouldCopyLocationForConcretize() {
        return false;
    }
======= 97ab1e9:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"


======= 7322131:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeMethodDeclaration.java"

    
    <ajc-test dir="bugs" pr="47754"
      title="static method introduction on interfaces, should not be allowed">
        <compile files="StaticInterfaceMethods.java">
        </compile>
    </ajc-test>

======= eac16ae:"runtime/src/org/aspectj/lang/SoftException.java"

    public Throwable getCause() { return inner; }

======= c517e85:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

======= c517e85:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

        boolean hasPointcuts = false;
                	hasPointcuts = true;
======= c517e85:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

        	ResolvedTypeX.Name name = (ResolvedTypeX.Name)factory.fromEclipse(sourceType);
        	EclipseSourceType eclipseSourceType = (EclipseSourceType)name.getDelegate();
        	eclipseSourceType.checkPointcutDeclarations();
    <ajc-test dir="bugs" pr="49457"
   	 title="No error on overloaded pointcuts in class">
        <compile files="OverloadedPointcutsInClass.java">
        	<message kind="error" line="3" text="duplicate pointcut name: pc1"/>
        	<message kind="error" line="4" text="duplicate pointcut name: pc1"/>
        	<message kind="error" line="6" text="duplicate pointcut name: pc2"/>
        	<message kind="error" line="7" text="duplicate pointcut name: pc2"/>
        </compile>
    </ajc-test>
    
    <ajc-test dir="bugs" pr="49457"
   	 title="No error on overloaded pointcuts unless binding variables">
        <compile files="OverloadedPointcutsInAspect.java">
        	<message kind="error" line="15" text="duplicate pointcut name: pc"/>
        	<message kind="error" line="16" text="duplicate pointcut name: pc"/>
        	<message kind="error" line="18" text="incompatible type"/>
        	<message kind="error" line="20" text="incompatible type"/>
        </compile>
    </ajc-test>
  pointcut pc1(): call(* *(..));
  pointcut pc1(): execution(* *(..));
  
  pointcut pc2(String s): call(* *(..)) && target(s);
  pointcut pc2(StringBuffer sb): call(* *(..)) && target(sb);

======= bdc79f1:"asm/src/org/aspectj/asm/IRelationship.java"


======= 3e4b59a:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= 3e4b59a:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= 3e4b59a:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= 3e4b59a:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

     * @param configFile	
======= 3e4b59a:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= 3e4b59a:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

        

======= 3117255:"weaver/src/org/aspectj/weaver/AsmRelationshipProvider.java"


======= 426d89b:"asm/src/org/aspectj/asm/internal/ProgramElement.java"

======= 426d89b:"asm/src/org/aspectj/asm/internal/ProgramElement.java"


    
  	<ajc-test dir="bugs/concretizeNpe" pr="43033"
    public abstract pointcut scope();
    declare soft: Exception: scope();
    public pointcut scope() : within(*);
    protected RuntimeException convertCheckedException(Throwable t) {
        return new RuntimeException(t.getMessage(),t
======= 5357086:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"

======= 5357086:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"


    
    <ajc-test dir="bugs" pr="43194"
   	 title="Non-functional concretezation of ReferencePointcut">
        <compile files="AdviceInteraction.java"/>
        <run class="AdviceInteraction"/>
    </ajc-test>
    public static void main(String [] args) {
        new C().m1();
    }
    public void m1() {}
    public void m2() {}
    pointcut exec1(C c): this(c) && execution(void m1());
    pointcut execs(C c): exec1(c); 
    
    before (): execs(*) {}
    before (C c):  execs(c) {}
    // This ordering works correctly
    pointcut exec2(C c): this(c) && execution(void m2());
    pointcut execs2(C c): exec2(c); 
    
    before (C c):  execs2(c) {}
    before (): execs2(*) {}
======= fc0d2af:"weaver/src/org/aspectj/weaver/patterns/ReferencePointcut.java"


======= b512738:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

        }        
======= b512738:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

        
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
                resolvePointcutDeclarations(b[j].scope);
            }
        }
        
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
                addAdviceLikeDeclares(b[j].scope);
            }
        }
        
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            units[i] = null; // release unnecessary reference to the parsed unit
        }
======= b512738:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

    
    private void addAdviceLikeDeclares(ClassScope s) {
        TypeDeclaration dec = s.referenceContext;
        
        if (dec instanceof AspectDeclaration) {
            ResolvedTypeX typeX = factory.fromEclipse(dec.binding);
            factory.getWorld().getCrosscuttingMembersSet().addAdviceLikeDeclares(typeX);
        }
        
        SourceTypeBinding sourceType = s.referenceContext.binding;
        ReferenceBinding[] memberTypes = sourceType.memberTypes;
        for (int i = 0, length = memberTypes.length; i < length; i++) {
            addCrosscuttingStructures(((SourceTypeBinding) memberTypes[i]).scope);
        }
    }
    <ajc-test dir="bugs" pr="42993"
   	    title="Interaction between pointcut binding and declare parents">
        <compile files="ParentsAndPointcuts.java"/>
        <run class="ParentsAndPointcuts"/>
    </ajc-test>
    public static void main(String[] args) {
        ContainerDescriptor d = new ContainerDescriptor();
        Tester.check(d instanceof AbstractCaching.Key, "instanceof");
    }
    declare parents: ContainerDescriptor implements AbstractCaching.Key;
    protected pointcut loadExecutions( Key key ):
        ContainerLoader.containerLoads( *, key );
    interface Key {}
    protected abstract pointcut loadExecutions(Key key);
    public ActiveContainer createContainer(ContainerDescriptor c) {
        return null;
    }
    public pointcut containerLoads(ContainerLoader loader,
                                   
        this(loader) && args(containerDesc)
        && execution(ActiveContainer ContainerLoader.createContainer
======= b512738:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

    
    public void addAdviceLikeDeclares(ResolvedTypeX aspectType) {
        CrosscuttingMembers xcut = (CrosscuttingMembers)members.get(aspectType);
        xcut.addDeclares(aspectType.collectDeclares(true));
    }
======= b512738:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

    
======= b512738:"weaver/src/org/aspectj/weaver/CrosscuttingMembersSet.java"

======= b512738:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= b512738:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

        
        if (!includeAdviceLike) return ret;
        

======= d78d9ed:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

        
        concreteName.getDeclaredPointcuts();
======= d78d9ed:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"

    
    private ResolvedPointcutDefinition resolvedPointcutDeclaration = null;
======= d78d9ed:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"

    
    public void resolve(ClassScope upperScope) {
        // this method should do nothing, use the entry point below...
    }
    public void resolvePointcut(ClassScope upperScope) {
        super.resolve(upperScope);
    }
======= d78d9ed:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/PointcutDeclaration.java"

        
        //System.out.println("resolved: " + getPointcut() + ", " + getPointcut().state);
        resolvedPointcutDeclaration.setPointcut(getPointcut());
        if (resolvedPointcutDeclaration != null) return resolvedPointcutDeclaration;
======= d78d9ed:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= d78d9ed:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
                buildInterTypeAndPerClause(b[j].scope);
            }
        }
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
                resolvePointcutDeclarations(b[j].scope);
            }
        }
        
        for (int i = lastCompletedUnitIndex + 1; i <= lastUnitIndex; i++) {
            SourceTypeBinding[] b = units[i].scope.topLevelTypes;
            for (int j = 0; j < b.length; j++) {
                addCrosscuttingStructures(b[j].scope);
            }
        }
======= d78d9ed:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

            units[i] = null; // release unnecessary reference to the parsed unit
                
======= d78d9ed:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

    private void addCrosscuttingStructures(ClassScope s) {
        TypeDeclaration dec = s.referenceContext;
        
        if (dec instanceof AspectDeclaration) {
            ResolvedTypeX typeX = factory.fromEclipse(dec.binding);
            factory.getWorld().getCrosscuttingMembersSet().addOrReplaceAspect(typeX);
        
            if (typeX.getSuperclass().isAspect() && !typeX.getSuperclass().isExposedToWeaver()) {
                factory.getWorld().getCrosscuttingMembersSet().addOrReplaceAspect(typeX.getSuperclass());
            }
        }
        
        SourceTypeBinding sourceType = s.referenceContext.binding;
        ReferenceBinding[] memberTypes = sourceType.memberTypes;
        for (int i = 0, length = memberTypes.length; i < length; i++) {
            addCrosscuttingStructures(((SourceTypeBinding) memberTypes[i]).scope);
        }
    }
    
    private void resolvePointcutDeclarations(ClassScope s) {
        TypeDeclaration dec = s.referenceContext;
        SourceTypeBinding sourceType = s.referenceContext.binding;
        
        AbstractMethodDeclaration[] methods = dec.methods;
        boolean initializedMethods = false;
        if (methods != null) {
            for (int i=0; i < methods.length; i++) {
                if (methods[i] instanceof PointcutDeclaration) {
                    if (!initializedMethods) {
                        sourceType.methods(); //force initialization
                        initializedMethods = true;
                    }
                    ((PointcutDeclaration)methods[i]).resolvePointcut(s);
                }
            }
        }
        
        ReferenceBinding[] memberTypes = sourceType.memberTypes;
        for (int i = 0, length = memberTypes.length; i < length; i++) {
            resolvePointcutDeclarations(((SourceTypeBinding) memberTypes[i]).scope);
        }
    }
    
    
    
    public void mumble() throws java.io.IOException { } // CE expected
    public pointcut executionsThrowingChecked() : 
        execution(* *(..) throws (Exception+ && !RuntimeException));
    public pointcut scope() : within(SampleExceptionHandling1);
    
    public pointcut executionsThrowingChecked() : 
        Library.executionsThrowingChecked() && scope();
    declare error : executionsThrowingChecked(): 
        "no checked exceptions";
 * @author Ron Bodkin
 * @author Jim Hugunin
 */
    public pointcut scope() : within(NoSoftener);
    abstract pointcut scope();
    public pointcut callsThrowingChecked() : call(* *(..)) && scope();
    declare soft: NoSuchMethodException: callsThrowingChecked();
 * @author Ron Bodkin
 * @author Jim Hugunin
 */
    public static void main(String[] args) {
        Throwable wrapped = null;
        try {
            new NoSoftener().foo(Integer.class);
        } catch (org.aspectj.lang.SoftException se) {
            wrapped = se.getWrappedThrowable();
        }
        Tester.checkNonNull(wrapped, "exception thrown");
        Tester.check(wrapped instanceof NoSuchMethodException,
                "must be NoSuchMethodException");
        
    }
    
    public void foo(Class clazz) {
        Class[] keyArgType = {};
        Constructor ctor = clazz.getConstructor(keyArgType);
    }
======= d78d9ed:"weaver/src/org/aspectj/weaver/ResolvedPointcutDefinition.java"


    pointcut exceptionThrower() :
        execution(public * ExceptionBugTest.*(..) throws Exception+);
    declare warning : exceptionThrower() : "throws both";
    
    declare error : execution(public * ExceptionBugTest.*(..) throws Exception) : 
        "throws Exception";
    int x;
    class MyException extends Exception {}
    public void method1() throws Exception { x = 1; } // warning here
    public void method2() throws MyException { x = 2; } // warning here
======= 8660cc1:"weaver/src/org/aspectj/weaver/patterns/ThrowsPattern.java"


======= 5a07dce:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

        PerClause perClause;
        if (binding instanceof BinaryTypeBinding) {
            ResolvedTypeX superTypeX = factory.fromEclipse(binding);
            perClause = superTypeX.getPerClause();
        } else if (binding instanceof SourceTypeBinding ) {
======= 5a07dce:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AspectDeclaration.java"

        if (perClause == null) {
            return lookupPerClauseKind(binding.superclass()); 
        } else {
            return perClause.getKind();
    }
    public static void main(String[] args) throws Exception {

    public static void main (String[] args) {
        // don't move these lines without changing expectEvents below
        new Sub().run();
        new SubSub().run();
        new SubSubSub().run();
        ((Super) new Sub()).run();
        ((Super) new SubSub()).run();
        ((Super) new SubSubSub()).run();
        ((Sub) new SubSub()).run();
        ((Sub) new SubSubSub()).run();
        ((SubSub) new SubSubSub()).run();
    } 
    static {
        // generated from System.out call below
        Tester.expectEvent("Super  1 10");
        Tester.expectEvent("Sub  2 10");
        Tester.expectEvent("Super  3 11");
        Tester.expectEvent("Sub  4 11");
        Tester.expectEvent("SubSub 5 11");
        Tester.expectEvent("Super  6 12");
        Tester.expectEvent("Sub  7 12");
        Tester.expectEvent("SubSub 8 12");
        Tester.expectEvent("SubSubSub 9 12");
        Tester.expectEvent("Super  10 13");
        Tester.expectEvent("Super  11 14");
        Tester.expectEvent("Super  12 15");
        Tester.expectEvent("Super  13 16");
        Tester.expectEvent("Sub  14 16");
        Tester.expectEvent("Super  15 17");
        Tester.expectEvent("Sub  16 17");
        Tester.expectEvent("Super  17 18");
        Tester.expectEvent("Sub  18 18");
        Tester.expectEvent("SubSub 19 18");
    }
    int count;
    void advice(String s, JoinPoint.StaticPart jp) {
        s = s 
            + " " 
            + ++count 
            + " " 
            + jp.getSourceLocation().getLine();
        Tester.event(s);
        // use after moving code lines above
        //System.out.println("Tester.expectEvent(\"" + s + "\");");
    }
    before() : call (void Super.run()) {
        advice("Super ", thisJoinPointStaticPart);
    }
    before() : call (void Sub.run()) {
        advice("Sub ", thisJoinPointStaticPart);
    }
    before() : call (void SubSub.run()) {
        advice("SubSub", thisJoinPointStaticPart);
    }
    before() : call (void SubSubSub.run()) {
        advice("SubSubSub", thisJoinPointStaticPart);
    }
    after() returning : execution(void CallReference.main(String[])) {
        Tester.checkAllEvents();
    }

======= d90acdc:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= d90acdc:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= d90acdc:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= d90acdc:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        // Reverse sort these keys
        keys.addAll(localVariableStarts.keySet());
        Collections.sort(keys, new Comparator() {
            public int compare(Object a, Object b) {
                LocalVariableTag taga = (LocalVariableTag) a;
                LocalVariableTag tagb = (LocalVariableTag) b;
                if (taga.getName().startsWith("arg")) {
                    if (tagb.getName().startsWith("arg")) {
                        return -taga.getName().compareTo(tagb.getName());
                    } else {
                        return 1; // Whatever tagb is, it must come out before 'arg'
                    }
                } else if (tagb.getName().startsWith("arg")) {
                    return -1; // Whatever taga is, it must come out before 'arg'
                } else {
                    return -taga.getName().compareTo(tagb.getName());
                }
            }
        });
        for (Iterator iter = keys.iterator(); iter.hasNext(); ) {

======= f1deb9c:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"

======= f1deb9c:"ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java"

======= f1deb9c:"ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java"

            this.setIconImage(((ImageIcon)AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(IProgramElement.Kind.ADVICE)).getImage());
======= f1deb9c:"ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java"

        editConfig_button.setIcon(AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(IProgramElement.Kind.FILE_LST));
======= f1deb9c:"ajde/src/org/aspectj/ajde/internal/LstBuildConfigManager.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/internal/LstBuildConfigManager.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/AbstractIconRegistry.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/BuildConfigModel.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/BuildConfigModel.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/BuildConfigNode.java"

 * 
 * TODO: clean-up after merging of org.aspectj.asm.StructureNode
    
    
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureSearchManager.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureSearchManager.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureView.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureView.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureView.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

    public final IStructureModelListener VIEW_LISTENER = new IStructureModelListener() {
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

        AVAILABLE_RELATIONS.add(IRelationship.Kind.ADVICE);
        AVAILABLE_RELATIONS.add(IRelationship.Kind.INHERITANCE);
        AVAILABLE_RELATIONS.add(IRelationship.Kind.DECLARE);
        AVAILABLE_RELATIONS.add(IRelationship.Kind.REFERENCE);
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureViewNode.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureViewNodeFactory.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureViewNodeFactory.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java"

    public void addRelation(IRelationship.Kind kind) {
        relations.add(kind);
    public void removeRelation(IRelationship.Kind kind) {
        relations.remove(kind);
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java"

    public void addFilteredMemberAccessibility(IProgramElement.Accessibility accessibility) {
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java"

    public void addFilteredMemberModifiers(IProgramElement.Modifiers modifiers) {
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/StructureViewProperties.java"

    public void addFilteredMemberKind(IProgramElement.Kind kind) {
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/internal/NavigationHistoryModel.java"

    private IProgramElement currNode = null;
    public void navigateToNode(IProgramElement toNode) {
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

        IProgramElement rootNode = model.getRoot();
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

                treeNode.add(getCrosscuttingChildren((IProgramElement)it.next()));
                	(IProgramElement)it.next(),
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

    private void getRoots(IProgramElement rootNode, List roots, StructureViewProperties.Hierarchy hierarchy) {
    public boolean acceptNodeAsRoot(IProgramElement node, StructureViewProperties.Hierarchy hierarchy) {
            return node.getKind().equals(IProgramElement.Kind.ADVICE)
                || node.getKind().equals(IProgramElement.Kind.POINTCUT);
            return node.getKind().equals(IProgramElement.Kind.CLASS);
    private StructureViewNode getInheritanceChildren(IProgramElement node, List associations) {
        List relations = ((IProgramElement)node).getRelations();
        throw new RuntimeException("unimplemented");
    private StructureViewNode getCrosscuttingChildren(IProgramElement node) {
        List relations = ((IProgramElement)node).getRelations();
        throw new RuntimeException("unimplemented");
    private StructureViewNode buildTree(IProgramElement node, List associations) {
                    IProgramElement child = (IProgramElement)itt.next();
                    if (child instanceof IProgramElement) {
                        IProgramElement progNode = (IProgramElement)child;
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

    private StructureViewNode getRelations(IRelationship node) {
        for (Iterator it = node.getTargets().iterator(); it.hasNext(); ) {
            	nodeFactory.createNode((IProgramElement)it.next())
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

        	IProgramElement sv1 = ((StructureViewNode)o1).getStructureNode();
        	IProgramElement sv2 = ((StructureViewNode)o2).getStructureNode();        
            if (sv1 instanceof IProgramElement && sv2 instanceof IProgramElement) {
            	IProgramElement p1 = (IProgramElement)sv1;
            	IProgramElement p2 = (IProgramElement)sv2;
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/internal/TreeStructureViewBuilder.java"

        	IProgramElement sv1 = ((StructureViewNode)o1).getStructureNode();
        	IProgramElement sv2 = ((StructureViewNode)o2).getStructureNode();        
            if (sv1 instanceof IProgramElement && sv2 instanceof IProgramElement) {
            	IProgramElement p1 = (IProgramElement)sv1;
            	IProgramElement p2 = (IProgramElement)sv2;
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/AjdeUIManager.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/AjdeUIManager.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/AjdeUIManager.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BrowserStructureViewToolPanel.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BrowserView.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BrowserView.java"

        joinpointProbe_button.setIcon(icons.getStructureSwingIcon(IProgramElement.Kind.POINTCUT));
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewManager.java"

    private IProgramElement currNode = null;
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewManager.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java"

            IProgramElement currNode = (IProgramElement)treeNode.getUserObject();
            if (currNode instanceof IProgramElement && !e.isControlDown()
            } 
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java"

                IProgramElement currNode = (IProgramElement)treeNode.getUserObject();
                if (currNode instanceof IProgramElement && !e.isControlDown() && !e.isShiftDown()
                } 
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java"

                IProgramElement currNode = (IProgramElement)((SwingTreeViewNode)selectionPaths[i].getLastPathComponent()).getUserObject();
            JMenuItem showSourcesItem = new JMenuItem("Display sources", AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(IProgramElement.Kind.CODE));
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java"

            JMenuItem generatePCD = new JMenuItem("Pointcut Wizard (alpha)...", AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(IProgramElement.Kind.POINTCUT));
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BuildConfigPopupMenu.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/BuildConfigPopupMenu.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/IconRegistry.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/IconRegistry.java"

    public Icon getAssociationSwingIcon(IRelationship.Kind relation) {
    public Icon getStructureSwingIcon(IProgramElement.Kind kind, IProgramElement.Accessibility accessibility) { 
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/PointcutWizard.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/PointcutWizard.java"

        INHERITANCE_VIEW.addRelation(IRelationship.Kind.INHERITANCE);
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/SimpleStructureViewToolPanel.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/SimpleStructureViewToolPanel.java"

    public final IStructureModelListener MODEL_LISTENER = new IStructureModelListener() {
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/SimpleStructureViewToolPanel.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java"

    public IProgramElement getSelectedIProgramElement() {
        return (IProgramElement)((SwingTreeViewNode)structureTree.getLastSelectedPathComponent()).getUserObject();
    private void highlightNode(SwingTreeViewNode parent, IProgramElement node) {
            IProgramElement sNode = (IProgramElement)currNode.getUserObject();
            if (sNode instanceof IProgramElement &&
                ((IProgramElement)sNode).equals(node)) {
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java"

            if (node.getUserObject() instanceof IProgramElement) {
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java"

            if (path.getPath().length-1 > depth || node.getUserObject() instanceof IRelationship) {
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/StructureTreeManager.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/StructureViewPanel.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/StructureViewPanel.java"

 		if (!(node.getStructureNode() instanceof IProgramElement)) return;
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/StructureViewPanel.java"

 		IProgramElement node = currentView.getActiveNode().getStructureNode();
 		if (node instanceof IProgramElement) {
 			treeManager.highlightNode((IProgramElement)node);
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNode.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNode.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNodeFactory.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNodeFactory.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNodeRenderer.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNodeRenderer.java"

        IProgramElement node = viewNode.getStructureNode();
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/SwingTreeViewNodeRenderer.java"

        if (node instanceof IProgramElement) {
        	IProgramElement pNode = (IProgramElement)node;
        	
        } else if (node instanceof IRelationship) {
        	this.setFont(new Font(this.getFont().getName(), Font.ITALIC, this.getFont().getSize()));
======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/TreeViewBuildConfigEditor.java"

======= f1deb9c:"ajde/src/org/aspectj/ajde/ui/swing/TreeViewBuildConfigEditor.java"

            	setIcon(AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(IProgramElement.Kind.FILE_ASPECTJ));	
            	setIcon(AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(IProgramElement.Kind.FILE_JAVA));	
            	setIcon(AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(IProgramElement.Kind.FILE_LST));	
            	setIcon(AjdeUIManager.getDefault().getIconRegistry().getStructureSwingIcon(IProgramElement.Kind.PACKAGE));	
            	setIcon((Icon)AjdeUIManager.getDefault().getIconRegistry().getStructureIcon(IProgramElement.Kind.ERROR).getIconResource());	
======= f1deb9c:"ajde/testdata/examples/coverage/ModelCoverage.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 * 
 * ******************************************************************/
======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/AsmDeclarationsTest.java"

 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 * ******************************************************************/
 * @author Mik Kersten
 */
======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/NullIdeManager.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/NullIdeManager.java"

 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 * ******************************************************************/
 * @author Mik Kersten
 */
======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/NullIdeTaskListManager.java"

    	System.out.println("NullIde> task: " + message.getMessage() + ", file: " + message.getSourceLocation().getSourceFile().getAbsolutePath()
======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/NullIdeTaskListManager.java"

    	System.out.println("NullIde> task: " + message + ", kind: " + kind);	
======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/NullIdeUIAdapter.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

  		HierarchyWalker walker = new HierarchyWalker() {
  		    public void preProcess(IProgramElement node) {
======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/ui/StructureModelUtilTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/ui/StructureModelUtilTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/ui/StructureModelUtilTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/ui/StructureSearchManagerTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/ui/StructureSearchManagerTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java"

======= f1deb9c:"ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java"

======= f1deb9c:"asm/src/org/aspectj/asm/AdviceAssociation.java"

======= f1deb9c:"asm/src/org/aspectj/asm/Association.java"

======= f1deb9c:"asm/src/org/aspectj/asm/Association.java"

 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
    }
    protected void preProcess(IProgramElement node) { }
    
    protected void postProcess(IProgramElement node) { }
    public IProgramElement process(IProgramElement node) {
        node.walk(this);
        postProcess(node);
        return node;
    }
======= f1deb9c:"asm/src/org/aspectj/asm/Association.java"

 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 * ******************************************************************/
 * Represents program elements in the AspectJ containment hierarchy.
 * 
 * @author Mik Kersten
 */
======= f1deb9c:"asm/src/org/aspectj/asm/Association.java"

 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
======= f1deb9c:"asm/src/org/aspectj/asm/Association.java"

 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * Compiler listeners get notified of structure model update events.
 *
 * @author Mik Kersten
 */
    public void modelUpdated(StructureModel rootNode);
======= f1deb9c:"asm/src/org/aspectj/asm/InheritanceAssociation.java"

======= f1deb9c:"asm/src/org/aspectj/asm/IntroductionAssociation.java"

======= f1deb9c:"asm/src/org/aspectj/asm/LinkNode.java"

======= f1deb9c:"asm/src/org/aspectj/asm/ModelWalker.java"

======= f1deb9c:"asm/src/org/aspectj/asm/ProgramElementNode.java"

======= f1deb9c:"asm/src/org/aspectj/asm/ReferenceAssociation.java"

======= f1deb9c:"asm/src/org/aspectj/asm/Relation.java"

======= f1deb9c:"asm/src/org/aspectj/asm/RelationNode.java"

======= f1deb9c:"asm/src/org/aspectj/asm/StructureModel.java"

======= f1deb9c:"asm/src/org/aspectj/asm/StructureModel.java"

    protected  IProgramElement root = null;
    public static final IProgramElement NO_STRUCTURE = new ProgramElement("<build to view structure>", IProgramElement.Kind.ERROR, null);
    public IProgramElement getRoot() {
    public void setRoot(IProgramElement root) {
======= f1deb9c:"asm/src/org/aspectj/asm/StructureModel.java"

======= f1deb9c:"asm/src/org/aspectj/asm/StructureModel.java"

======= f1deb9c:"asm/src/org/aspectj/asm/StructureModel.java"

======= f1deb9c:"asm/src/org/aspectj/asm/StructureModel.java"

======= f1deb9c:"asm/src/org/aspectj/asm/StructureModel.java"

======= f1deb9c:"asm/src/org/aspectj/asm/StructureModel.java"

======= f1deb9c:"asm/src/org/aspectj/asm/StructureModel.java"

======= f1deb9c:"asm/src/org/aspectj/asm/StructureModel.java"

======= f1deb9c:"asm/src/org/aspectj/asm/StructureModel.java"

======= f1deb9c:"asm/src/org/aspectj/asm/StructureModel.java"

======= f1deb9c:"asm/src/org/aspectj/asm/StructureModelListener.java"

======= f1deb9c:"asm/src/org/aspectj/asm/StructureModelManager.java"

======= f1deb9c:"asm/src/org/aspectj/asm/StructureModelManager.java"

        throw new RuntimeException("unimplemented");
        
    public void addListener(IStructureModelListener listener) {
    public void removeStructureListener(IStructureModelListener listener) {
            ((IStructureModelListener)it.next()).modelUpdated(model);
======= f1deb9c:"asm/src/org/aspectj/asm/StructureNode.java"

======= f1deb9c:"asm/src/org/aspectj/asm/StructureNodeFactory.java"

======= f1deb9c:"asm/src/org/aspectj/asm/StructureNodeFactory.java"

 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 * ******************************************************************/
 * @author Mik Kersten
 */
    
    
    
    
======= f1deb9c:"asm/src/org/aspectj/asm/StructureNodeFactory.java"

 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 * ******************************************************************/
 * @author Mik Kersten
 */
======= f1deb9c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

 
======= f1deb9c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

======= f1deb9c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= f1deb9c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

        IProgramElement.Kind kind = IProgramElement.Kind.FILE_JAVA;
            kind = IProgramElement.Kind.FILE_LST;  
        model.setRoot(new ProgramElement(rootLabel, kind, new ArrayList()));
======= f1deb9c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

======= f1deb9c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     PARC     initial implementation 
 * ******************************************************************/
    public static void build(    
        CompilationUnitDeclaration unit,
        StructureModel structureModel) {
        LangUtil.throwIaxIfNull(unit, "unit");
        new AsmHierarchyBuilder(unit.compilationResult()).internalBuild(unit, structureModel);
    }
    protected AsmHierarchyBuilder(CompilationResult result) {
        LangUtil.throwIaxIfNull(result, "result");
        currCompilationResult = result;
        stack = new Stack();
    }
    /** 
     * Called only by 
     * build(CompilationUnitDeclaration unit, StructureModel structureModel) 
     */
    private void internalBuild(
        CompilationUnitDeclaration unit, 
        StructureModel structureModel) {
        LangUtil.throwIaxIfNull(structureModel, "structureModel");        
        if (!currCompilationResult.equals(unit.compilationResult())) {
            throw new IllegalArgumentException("invalid unit: " + unit);
        }
        // ---- summary
        // add unit to package (or root if no package),
        // first removing any duplicate (XXX? removes children if 3 classes in same file?)
        // push the node on the stack
        // and traverse
        
        // -- create node to add
        final File file = new File(new String(unit.getFileName()));
        final IProgramElement cuNode;
        {
            // AMC - use the source start and end from the compilation unit decl
            int startLine = getStartLine(unit);
            int endLine = getEndLine(unit);     
            ISourceLocation sourceLocation 
                = new SourceLocation(file, startLine, endLine);
            cuNode = new ProgramElement(
                new String(file.getName()),
                IProgramElement.Kind.FILE_JAVA,
                sourceLocation,
                0,
                "",
                new ArrayList());
        }
        final IProgramElement addToNode = genAddToNode(unit, structureModel);
        
        // -- remove duplicates before adding (XXX use them instead?)
        for (ListIterator itt = addToNode.getChildren().listIterator(); itt.hasNext(); ) {
            IProgramElement child = (IProgramElement)itt.next();
            ISourceLocation childLoc = child.getSourceLocation();
            if (null == childLoc) {
                // XXX ok, packages have null source locations
                // signal others?
            } else if (childLoc.getSourceFile().equals(file)) {
                itt.remove();
            }
        }
        // -- add and traverse
        addToNode.addChild(cuNode);     
        stack.push(cuNode);
        unit.traverse(this, unit.scope);  
        
        // -- update file map (XXX do this before traversal?)
        try {
            structureModel.addToFileMap(file.getCanonicalPath(), cuNode);
        } catch (IOException e) { 
            System.err.println("IOException " + e.getMessage() 
                + " creating path for " + file );
            // XXX signal IOException when canonicalizing file path
        }
        
  
======= f1deb9c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java"

======= f1deb9c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java"

======= f1deb9c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java"

======= f1deb9c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java"

======= f1deb9c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmNodeFormatter.java"

======= f1deb9c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java"

======= f1deb9c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java"

                IProgramElement peNode = (IProgramElement)((Map.Entry)it.next()).getValue();
======= f1deb9c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java"

    private void dumpStructureToFile(IProgramElement node) throws IOException {
        String s = node.getKind().toString();
        if (!  (s.equals(IProgramElement.Kind.FILE_ASPECTJ.toString())
                || s.equals(IProgramElement.Kind.FILE_JAVA.toString()))) {
======= f1deb9c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java"

        private void printDecls(IProgramElement node) {
                    IProgramElement child = (IProgramElement)nodeObject;
        private void printDecls(IRelationship node) {
            for (Iterator it = node.getTargets().iterator(); it.hasNext(); ) {
                throw new RuntimeException("unimplemented");
        private void printDecl(IProgramElement node, boolean recurse) {
            String kind = node.getKind().toString().toLowerCase();
======= f1deb9c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java"

                if (node instanceof IProgramElement) {
                    java.util.List relations = ((IProgramElement)node).getRelations();
                            if (relNode.getKind() == IRelationship.Kind.ADVICE ||
======= f1deb9c:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/EmacsStructureModelManager.java"

                        if (nodeObject instanceof IProgramElement) {
                            IProgramElement currNode = (IProgramElement)nodeObject;
======= f1deb9c:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AsmBuilderTest.java"

======= f1deb9c:"testing/src/org/aspectj/testing/ajde/CompileCommand.java"

======= f1deb9c:"testing/src/org/aspectj/testing/ajde/CompileCommand.java"

======= f1deb9c:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= f1deb9c:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= f1deb9c:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= f1deb9c:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= f1deb9c:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"


======= 3e59745:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

======= 3e59745:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/AjLookupEnvironment.java"

    public interface MonitoredItem {}
    private void MonitoredItem.record(String eventType, String eventName) {}
======= 3e59745:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= 3e59745:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= 3e59745:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    private boolean isSynthetic = false;
    
======= 3e59745:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        
        if (isSynthetic) {
        }
        
======= 3e59745:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    
    public void makeSynthetic() {
    	isSynthetic = true;
    }    	

======= 684c9c1:"bridge/src/org/aspectj/bridge/IMessage.java"

======= 684c9c1:"bridge/src/org/aspectj/bridge/Message.java"

    private final String details;
======= 684c9c1:"bridge/src/org/aspectj/bridge/Message.java"

======= 684c9c1:"bridge/src/org/aspectj/bridge/Message.java"

        this.details = "";
======= 684c9c1:"bridge/src/org/aspectj/bridge/Message.java"

======= 684c9c1:"testing/src/org/aspectj/testing/xml/SoftMessage.java"

    private String details;
======= 684c9c1:"testing/src/org/aspectj/testing/xml/SoftMessage.java"

    
======= 684c9c1:"weaver/src/org/aspectj/weaver/Checker.java"

======= 684c9c1:"weaver/src/org/aspectj/weaver/Checker.java"


======= acdf688:"ajbrowser/testsrc/org/aspectj/tools/ajbrowser/BrowserManagerTest.java"

======= acdf688:"ajbrowser/testsrc/org/aspectj/tools/ajbrowser/BrowserManagerTest.java"

 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * @author Mik Kersten
 */
======= acdf688:"ajde/src/org/aspectj/ajde/ui/swing/CompilerMessagesCellRenderer.java"

                setIcon(AjdeUIManager.getDefault().getIconRegistry().getInfoIcon());
======= acdf688:"ajde/src/org/aspectj/ajde/ui/swing/CompilerMessagesCellRenderer.java"

======= acdf688:"ajde/src/org/aspectj/ajde/ui/swing/CompilerMessagesCellRenderer.java"

======= acdf688:"ajde/src/org/aspectj/ajde/ui/swing/CompilerMessagesCellRenderer.java"

======= acdf688:"ajde/src/org/aspectj/ajde/ui/swing/CompilerMessagesCellRenderer.java"

======= acdf688:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/AjdtAjcTests.java"

        return suite;  
======= acdf688:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"

======= acdf688:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"


    public static void main(String[] args) {
        lib.Library.method();
    }
    public static void method() {
    }

======= a26cac9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"

======= a26cac9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"

            IMessage m = new Message(message, kind, null, location);            
        }  
======= a26cac9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= a26cac9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= a26cac9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

     * @param configFile	can be null
            	|| buildConfig.isIncrementalFileMode();
======= a26cac9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= a26cac9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= a26cac9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= a26cac9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= a26cac9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

                            showError("bad injar: " + filename);  
======= a26cac9:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"


======= f5d31ba:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

======= f5d31ba:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

======= f5d31ba:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"


======= 7886970:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

    protected AsmBuilder(CompilationResult result) {
======= 7886970:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

======= 7886970:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

======= 7886970:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjdtBuilderTests.java"

======= 7886970:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/core/builder/AjdtBuilderTests.java"

 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     PARC     initial implementation 
 * ******************************************************************/
    public static Test suite() { 
        TestSuite suite = new TestSuite(AsmBuilderTest.class.getName());
        //$JUnit-BEGIN$
        suite.addTestSuite(AsmBuilderTest.class); 
        //$JUnit-END$
        return suite;
    }

  
    <ajc-test dir="bugs/bootstrapClasspath" pr="39959" 
            title="AJC Compiler generates invalid class files under certain circumstances."> 
        <compile files="UsesDOMParser.java" classpath="xerces.jar" /> 
        <run class="UsesDOMParser"/> 
    </ajc-test> 

======= 58e3cb2:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"


======= 2502ee5:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

======= 2502ee5:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

        if (DEFAULT_DESTDIR != destDir) {
            ajc.setDestdir(destDir);
        }        
======= 2502ee5:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    private static final File DEFAULT_DESTDIR = new File(".") {
        public String toString() {
            return "AjcTask.DEFAULT_DESTDIR";
        }
    };
======= 2502ee5:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    public static final String COMMAND_EDITOR_NAME
        = AjcTask.class.getName() + ".COMMAND_EDITOR";
    private static final ICommandEditor COMMAND_EDITOR;
            
======= 2502ee5:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    
        ICommandEditor editor = null;
        try {
            String editorClassName = System.getProperty(COMMAND_EDITOR_NAME);
            if (null != editorClassName) {
                ClassLoader cl = AjcTask.class.getClassLoader();
                Class editorClass = cl.loadClass(editorClassName);
                editor = (ICommandEditor) editorClass.newInstance();
            }
        } catch (Throwable t) {
            System.err.println("Warning: unable to load command editor");
            t.printStackTrace(System.err);
        }
        COMMAND_EDITOR = editor;
======= 2502ee5:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    private ICommandEditor commandEditor;
======= 2502ee5:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

    
    /** direct API for testing */
    public void setCommandEditor(ICommandEditor editor) {
        this.commandEditor = editor;
    }
    
    /**
     * Setup command-line filter.
     * To do this staticly, define the environment variable
     * <code>org.aspectj.tools.ant.taskdefs.AjcTask.COMMAND_EDITOR</code>
     * with the <code>className</code> parameter.
     * @param className the String fully-qualified-name of a class
     *          reachable from this object's class loader,
     *          implementing ICommandEditor, and 
     *          having a public no-argument constructor.
     * @throws BuildException if unable to create instance of className
     */
    public void setCommandEditorClass(String className) { // skip Ant interface?
        try {
            Class mclass = Class.forName(className);
            setCommandEditor((ICommandEditor) mclass.newInstance());
        } catch (Throwable t) {
            String m = "unable to instantiate command editor: " + className;
            throw new BuildException(m, t);
        }
    }
======= 2502ee5:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

        String[] command = (String[]) result.toArray(new String[0]);
        if (null != commandEditor) {
            command = commandEditor.editCommand(command);
        } else if (null != COMMAND_EDITOR) {
            command = COMMAND_EDITOR.editCommand(command);
        }
        return command;
        StringBuffer sb = new StringBuffer();
            sb.append("can fork incremental only using tag file.\n");
        }
        
        if ((null == outjar) && (DEFAULT_DESTDIR == destDir)) { 
            final String REQ = " requires dest dir or output jar.\n";            if (copyInjars) {
                sb.append("copyInjars");
                sb.append(REQ);
            }
            if (null != sourceRootCopyFilter) {
                sb.append("sourceRootCopyFilter");
                sb.append(REQ);
            }
        }
        if (0 < sb.length()) {
            throw new BuildException(sb.toString());
======= 2502ee5:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

        } else if ((destDir == DEFAULT_DESTDIR)
                    || !destDir.canWrite()) {
======= 2502ee5:"taskdefs/src/org/aspectj/tools/ant/taskdefs/AjcTask.java"

 * Copyright (c) 2003 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Wes Isberg     initial implementation 
 * ******************************************************************/
 * Preprocess command-lines
 * @author Wes Isberg
 */
    /**
     * Edit command being used.
     * @param command the String[] to edit
     * @return String[] input command if unchanged, 
     *         or new non-null array of non-null components otherwise
     */
    String[] editCommand(String[] command);
======= 2502ee5:"taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java"

    public void testNullDestDir() {
        AjcTask task = getTask(NOFILE, null);
        String[] cmd = task.makeCommand();
        
        for (int i = 0; i < cmd.length; i++) {
            assertTrue(!"-d".equals(cmd[i]));
        }
    }
    
    public void testOutputRequirement() {
        AjcTask task = getTask("default.lst");
        checkRun(task, null);
        task = getTask("default.lst", null);
        task.setCopyInjars(true);
        checkRun(task, "copyInjars");
        task = getTask("default.lst", null);
        task.setSourceRootCopyFilter("*.java");
        checkRun(task, "sourceRoot");
    }
    
    private void checkRun(AjcTask task, String exceptionString) {
        try {
            task.execute();
            assertTrue(null == exceptionString);
        } catch (BuildException e) {
            if(-1 == e.getMessage().indexOf(exceptionString)) {
                assertEquals(exceptionString, e.getMessage());
            }
        }
        
    }
    public void testCommandEditor() {
        String className = VerboseCommandEditor.class.getName();
        System.setProperty(AjcTask.COMMAND_EDITOR_NAME, className);
        assertEquals(className, 
            System.getProperty(AjcTask.COMMAND_EDITOR_NAME));
        AjcTask task = getTask(NOFILE);
        task.setCommandEditor(new VerboseCommandEditor());
        String[] cmd = task.makeCommand();
        assertEquals(VerboseCommandEditor.VERBOSE, cmd[0]);
        task = getTask(NOFILE);
        task.setCommandEditorClass(VerboseCommandEditor.class.getName());
        cmd = task.makeCommand();
        assertEquals(VerboseCommandEditor.VERBOSE, cmd[0]);
    }
======= 2502ee5:"taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java"

        return getTask(input, getTempDir());
    }
    
    protected AjcTask getTask(String input, File destDir) {
        if (null != destDir) {
            task.setDestdir(destDir);
        }
======= 2502ee5:"taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java"

        //task.setVerbose(true);   
======= 2502ee5:"taskdefs/testsrc/org/aspectj/tools/ant/taskdefs/AjcTaskTest.java"

    public static final String VERBOSE = "-verbose";
    public String[] editCommand(String[] command) {
        for (int i = 0; i < command.length; i++) {
            if (VERBOSE.equals(command[i])) {
                return command;
            }
        }
        
        String[] result = new String[1+command.length];
        result[0] = VERBOSE;
        System.arraycopy(result, 1, command, 0, command.length);
        return result;
    }
    private static String[] NONE = new String[0];
    public static ICommandEditor VERBOSE = 
        new AppendingCommandEditor(new String[] {"-verbose"}, NONE);
    public static ICommandEditor INVALID = 
        new AppendingCommandEditor(NONE, new String[] {"-invalidOption"});
    final String[] prefix;
    final String[] suffix;
    public AppendingCommandEditor(String[] prefix, String[] suffix) {
        this.prefix = prefix;
        this.suffix = suffix;
    }
    public String[] editCommand(String[] command) {
        int len = command.length + prefix.length + suffix.length;
        String[] result = new String[len];
        System.arraycopy(result, 0, prefix, 0, prefix.length);
        System.arraycopy(result, prefix.length, command, 0, command.length);
        System.arraycopy(result, prefix.length + command.length, suffix, 0, suffix.length);
        return result;
    }

 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * Bare-bones editor implementation used when the framework is being used
 * standalone.
 *
 * @author Mik Kersten
 */
    private String filePath = NO_FILE;
    private JPanel editor_panel = new JPanel();
    // @todo    get rid of these
    private int currHighlightStart = 0;
    private int currHighlightEnd = 0;
    private BorderLayout borderLayout1 = new BorderLayout();
    private JScrollPane jScrollPane1 = new JScrollPane();
    private JEditorPane editorPane = new JEditorPane();
    public BasicEditor() {
        try {
            editorPane.setEditable(true);
            editorPane.setContentType("text/plain");
            editorPane.setFont(new Font("Monospaced", 0, 11));
            editor_panel.add(editorPane);
            jbInit();
        }
        catch(Exception e) {
            Ajde.getDefault().getErrorHandler().handleError("Could not initialize GUI.", e);
        }
    }
    public String getCurrFile() {
    }
    public void showSourceLine(ISourceLocation sourceLocation, boolean highlight) {
    public void showSourceLine(int lineNumber, boolean highlight) {
        showSourceLine(filePath, lineNumber, highlight);
    }
    public void pasteToCaretPos(String text) {
        if (currHighlightEnd < 1) return;
        String contents = editorPane.getText();
        String pasted = contents.substring(0, currHighlightEnd) +
            text + contents.substring(currHighlightEnd, contents.length());
        editorPane.setText(pasted);
    }
    public void showSourceLine(String filePath, int lineNumber, boolean highlight) {
    	//AjdeUIManager.getDefault().getIdeUIAdapter().resetEditor();
        
        String oldPath = this.filePath;
        this.filePath = filePath;
        currHighlightStart = 0;
        currHighlightEnd = 0;
        editorPane.setText(readFile(filePath, lineNumber));
        try {
            editorPane.getHighlighter().addHighlight(currHighlightStart, currHighlightEnd, DefaultHighlighter.DefaultPainter);
            editorPane.setCaretPosition(currHighlightStart);
        } catch (BadLocationException ble) {
            Ajde.getDefault().getErrorHandler().handleError("Could not highlight location.", ble);
        }
        BrowserManager.getDefault().getEditorManager().notifyCurrentFileChanged(filePath);
    }
    /**
     * Not implemented.
     */
    public void showSourcelineAnnotation(String filePath, int lineNumber, java.util.List items) { }
    public void saveContents() throws IOException {
        if (filePath != NO_FILE && filePath != "" && editorPane.getText() != "") {
            BufferedWriter writer = new BufferedWriter(new FileWriter(filePath));
            writer.write(editorPane.getText());
            writer.flush();
        }
    }
    public JPanel getPanel() {
        return editor_panel;
    }
    public void showSourceForFile(String filePath) { }
    public void showSourceForLine(int lineNumber, boolean highlight) { }
    public void showSourceForSourceLine(String filePath, int lineNumber, boolean highlight) { }
    public String getCurrSourceFilePath() { return null; }
    public void setBreakpointRequest(String filePath, int lineNumber, boolean isDeferred) { }
    public void clearBreakpointRequest(String filePath, int lineNumber) { }
    private String readFile(String filePath, int lineNumber) {
        try {
            URL url = ClassLoader.getSystemResource(filePath);
            File file = new File(filePath);
            if (!file.exists()) {
                return "ERROR: file \"" + filePath + "\" does not exist.";
            }
            BufferedReader reader = new BufferedReader(new FileReader(file));
            StringBuffer contents = new StringBuffer();
            String line = reader.readLine();
            int numChars = 0;
            int numLines = 0;
            while (line != null) {
                numLines++;
                if (numLines < lineNumber) {
                    currHighlightStart += line.length()+1;
                }
                if (numLines == lineNumber) {
                    currHighlightEnd = currHighlightStart + line.length();
                }
                contents.append(line);
                contents.append('\n');
                line = reader.readLine();
            }
            return contents.toString();
        } catch (IOException ioe) {
            return "ERROR: could not read file \"" + filePath + "\", make sure that you have mounted /project/aop on X:\\";
        }
    }
    private void jbInit() throws Exception {
        editor_panel.setFont(new java.awt.Font("DialogInput", 1, 12));
        editor_panel.setLayout(borderLayout1);
        editor_panel.add(jScrollPane1, BorderLayout.CENTER);
        jScrollPane1.getViewport().add(editorPane, null);
    }
======= bbd832b:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"

======= bbd832b:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"

======= bbd832b:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"

    
======= bbd832b:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"

======= bbd832b:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"

======= bbd832b:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"

        editorManager.saveContents();
======= bbd832b:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"

======= bbd832b:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"

======= bbd832b:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserManager.java"

 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
                        if (EditorManager.isShiftDown(e.getModifiers())) {
                            Ajde.getDefault().getBuildManager().buildFresh();
                        } else {
                            Ajde.getDefault().getBuildManager().build();
                        }
======= bbd832b:"ajbrowser/src/org/aspectj/tools/ajbrowser/CompilerMessagesPanel.java"

======= bbd832b:"ajbrowser/src/org/aspectj/tools/ajbrowser/CompilerMessagesPanel.java"

 * Copyright (c) 1999-2001 Xerox Corporation, 
 *               2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC     initial implementation 
 * ******************************************************************/
 * Responsible for controlling the editor.
 *
 * @todo    remove coupling to <CODE>BasicEditor</CODE>
 * @author  Mik Kersten
 */
    /** @return true if input modifiers have shift down */
    public static boolean isShiftDown(int modifiers) {
        return (0 != (modifiers & KeyEvent.SHIFT_MASK));
    }
    private EditorAdapter editor = null;
    private BasicEditor basicEditor = null;
    private ArrayList editorListeners = new ArrayList();
    private Vector editors = new Vector();
    private JPanel editor_panel = null;
    private Box editors_box = Box.createVerticalBox();
    public EditorManager(EditorAdapter ajdeEditor) {
    	if (ajdeEditor instanceof BasicEditor) {
    	} else {
        	editors.add(ajdeEditor);
        	this.editor = ajdeEditor;   		
    	}
    }
    public void addListener(EditorListener editorListener) {
        editorListeners.add(editorListener);
    }
    public void removeListener(EditorListener editorListener) {
        editorListeners.remove(editorListener);
    }
    public void notifyCurrentFileChanged(String filePath) {
        for (Iterator it = editorListeners.iterator(); it.hasNext(); ) {
            ((EditorListener)it.next()).currentFileChanged(filePath);
        }
    }
    public void addViewForSourceLine(final String filePath, final int lineNumber) {
        if (basicEditor == null) return;
        editors_box.remove(basicEditor.getPanel());
        final BasicEditor newEditor = new BasicEditor();
        editors.add(newEditor);
        
        Runnable update = new Runnable() {
            public void run() {
                editors_box.add(newEditor.getPanel());
                newEditor.showSourceLine(filePath, lineNumber, true);
                //AjdeUIManager.getDefault().getIdeUIAdapter().resetGUI();
            }
        };
        if (SwingUtilities.isEventDispatchThread()) {
            update.run(); 
        } else {
            try {
                SwingUtilities.invokeAndWait(update);
            } catch (Exception e) {
                Ajde.getDefault().getErrorHandler().handleError("Could not add view for source line.", e);
            }
        }
    }
    public String getCurrFile() {
    	if (basicEditor != null) {
    		return basicEditor.getCurrFile();
    	} else {
    	}
    }
    /**
     * @todo    remove "instanceof AjdeManager" hack
     */
    public void showSourceLine(String filePath, int lineNumber, boolean highlight) {
        if (editors.size() > 1) {
            editors_box.removeAll();
            editors_box.add(basicEditor.getPanel());
            //AjdeUIManager.getDefault().getIdeUIAdapter().resetGUI();
            editors.removeAllElements();
            editors.add(basicEditor);
        } 
        
        if (basicEditor != null) {
        	basicEditor.showSourceLine(filePath, lineNumber, highlight);
        } else {
        	editor.showSourceLine(filePath, lineNumber, highlight);
        }
    }
    public void pasteToCaretPos(String text) {
        if (basicEditor != null) {
        	basicEditor.pasteToCaretPos(text);
        } else {
        	editor.pasteToCaretPos(text);
        }    	
    }
    public void showSourcelineAnnotation(String filePath, int lineNumber, java.util.List items) {
        editor.showSourcelineAnnotation(filePath, lineNumber, items);
    }
    public void saveContents() {
        try {
            for (Iterator it = editors.iterator(); it.hasNext(); ) {
                ((EditorAdapter)it.next()).saveContents();
            }
        } catch (IOException ioe) {
            Ajde.getDefault().getErrorHandler().handleError("Editor could not save the current file.", ioe);
        }
    }
    public JPanel getEditorPanel() {
        if (editor_panel != null) {
            return editor_panel;
        } else {
            return basicEditor.getPanel();
        }
    }
======= bbd832b:"ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java"

======= bbd832b:"ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java"

        BrowserManager.getDefault().getEditorManager().saveContents();
======= bbd832b:"ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java"

======= bbd832b:"ajbrowser/src/org/aspectj/tools/ajbrowser/TopFrame.java"

 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC),
 *               2003 Contributors.
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     Xerox/PARC      initial implementation 
 *     AMC 01.20.2003  extended to support new AspectJ 1.1 options,
 * 				       bugzilla #29769
 * ******************************************************************/
   
======= bbd832b:"ajde/src/org/aspectj/ajde/Ajde.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/Ajde.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/Ajde.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/Ajde.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/Ajde.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/Ajde.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/Ajde.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/ui/EditorManager.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/ui/StructureModelUtil.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/ui/StructureViewManager.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/ui/swing/AjdeUIManager.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/ui/swing/AjdeUIManager.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/ui/swing/AjdeUIManager.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/ui/swing/AjdeUIManager.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/ui/swing/AjdeUIManager.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/ui/swing/BasicEditor.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewManager.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewManager.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/ui/swing/BrowserViewTreeListener.java"

                    // USED THE FOLLOWING FROM: BrowserViewManager:
======= bbd832b:"ajde/src/org/aspectj/ajde/ui/swing/BuildConfigPopupMenu.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/ui/swing/PointcutWizard.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/ui/swing/PointcutWizard.java"

        
        throw new RuntimeException("unimplemented, can't get the current file");
        //typeTreeView.updateTree(Ajde.getDefault().getEditorManager().getCurrFile());
======= bbd832b:"ajde/src/org/aspectj/ajde/ui/swing/PointcutWizard.java"

======= bbd832b:"ajde/src/org/aspectj/ajde/ui/swing/StructureViewPanel.java"

======= bbd832b:"ajde/testsrc/AjdeModuleTests.java"

    public static TestSuite suite() { 
======= bbd832b:"ajde/testsrc/org/aspectj/ajde/CompilerMessagesTest.java"

======= bbd832b:"ajde/testsrc/org/aspectj/ajde/CompilerMessagesTest.java"

 * Created on Jul 25, 2003
 *
 * To change the template for this generated file go to
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
 * @author beatmik
 *
 * To change the template for this generated type comment go to
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
======= bbd832b:"ajde/testsrc/org/aspectj/ajde/NullIdeManager.java"

======= bbd832b:"ajde/testsrc/org/aspectj/ajde/NullIdeManager.java"


======= d5ea336:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= d5ea336:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= d5ea336:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

        AjBuildConfig local = parser.genBuildConfig(args, counter, false);  
             
        } 
        
======= d5ea336:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"

======= d5ea336:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/AjdtCommand.java"

        if (null != message) {  
======= d5ea336:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

      
     * @param setClasspath	determines if the classpath should be parsed and set on the build configuration
======= d5ea336:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"


 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     PARC     initial implementation 
 * ******************************************************************/
 * Walks the body of inter-type declarations and replaces SuperReference with InterSuperReference
 * 
 * @author Jim Hugunin
 */
 * Copyright (c) 2002 Palo Alto Research Center, Incorporated (PARC).
 * All rights reserved. 
 * This program and the accompanying materials are made available 
 * under the terms of the Common Public License v1.0 
 * which accompanies this distribution and is available at 
 * http://www.eclipse.org/legal/cpl-v10.html 
 *  
 * Contributors: 
 *     PARC     initial implementation 
 * ******************************************************************/
 * Used to represent super references inside of inter-type declarations.  Special mechanism
 * needed for handling in an interface context.
 * 
 * @author Jim Hugunin
 */
======= 026b272:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeDeclaration.java"

======= 026b272:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeDeclaration.java"

    
    <ajc-test dir="bugs" pr="39993"
   	 title="ajc stack trace on declaring hashcode() method in aspect">
        <compile files="OverridingInterfaceObjectMethod.java"/>
        <run class="OverridingInterfaceObjectMethod"/>
    </ajc-test>
    <ajc-test dir="bugs"
   	 title="using super in method introduced on interface with multiple supertypes">
        <compile files="MultipleSuperCf.java">
        	<message kind="error" line="14"/>
        </compile>
    </ajc-test>
 
       return this.id;
    }
 
======= 026b272:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= 026b272:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= 026b272:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"

======= 026b272:"weaver/src/org/aspectj/weaver/bcel/BcelTypeMunger.java"


======= ba41fae:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= ba41fae:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= ba41fae:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= ba41fae:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AccessForInlineVisitor.java"

======= ba41fae:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/AdviceDeclaration.java"

======= ba41fae:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/PrivilegedHandler.java"

======= ba41fae:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/PrivilegedHandler.java"

    
    <ajc-test dir="bugs" pr="39458"
   	 title="Compiler crash in ajc 1.1 - terrible error for inaccessible constructor">
        <compile files="NewVoid.java">
            <message kind="error" line="17"/>        
            <message kind="error" line="20"/>        
            <message kind="error" line="21"/>
                  
            <message kind="error" line="28"/>        
            <message kind="warning" line="29"/>        
            <message kind="warning" line="30"/>            
        </compile>
    </ajc-test>
    
    <ajc-test dir="bugs" pr="39460"
   	 title="Missing import crashes compiler">
        <compile files="MissingImport.java">
            <message kind="error" line="13"/>       
        </compile>
    </ajc-test>
    

======= c509c6f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= c509c6f:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

    public static void main(String[] args) {
    	Runnable r = new Runnable() {
    		public void run() {}
    	};
    	r.run();
    }
======= c509c6f:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BasicCommandTestCase.java"

======= c509c6f:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BasicCommandTestCase.java"


    
    <ajc-test dir="bugs" pr="37739"
   	 title="Unexpected Xlint:unresolvableMember warning with withincode">
        <compile files="CatchSig.java">
        </compile>
        <run class="CatchSig"/>
    </ajc-test>
 * Bugzilla Bug 37739  
   Unexpected Xlint:unresolvableMember warning with withincode 
 */
======= 2072ac1:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

    //??? need to better understand all the enclosing variants
    	if (getKind().isEnclosingKind()) {
    	} else if (enclosingShadow == null) {
    		return getEnclosingMethod().getMemberView();

    <ajc-test dir="new/binaryWarnings/src" pr="37020"
   	 title="declare warnings on main">
        <compile files="aspects/MainWarnings.java,app/Main.java">
        	<message kind="warning" file="app/Main.java"
        	  line="6" text="set(String Main.staticString)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="8" text="set(String Main.s)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="12" text="get(String Main.staticString)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="14" text="set(String Main.staticString)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="16" text="call(Main.new())"/>
        	<message kind="warning" file="app/Main.java"
        	  line="19" text="call(void Main.go(String))"/>
        	<message kind="warning" file="app/Main.java"
        	  line="23" text="execution(Main.new())"/>
        	<message kind="warning" file="app/Main.java"
        	  line="26" text="execution(void Main.go(String))"/>
        	<message kind="warning" file="app/Main.java"
        	  line="29" text="get(String Main.s)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="31" text="set(String Main.s)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="33" text="handler(RuntimeException)"/>        	  
        	<message kind="warning" file="app/Main.java"
        	  line="35" text="withincode(void Main.go(String))"/>
        	<message kind="warning" file="app/Main.java"
        	  line="42" text="withincode(void Main.stop())"/>
        	<message kind="warning" file="app/Main.java"
        	  line="50" text="preinitialization(app.C.new())"/>
        </compile>
        
        <run class="app.Main"/>
    </ajc-test>
    <ajc-test dir="new/binaryWarnings/src"  pr="37020"
   	title="declare warnings on binary javac 1.4 classes">
        <compile files="aspects/MainWarnings.java,../injars/app-javac-1.4.jar">
        	<message kind="warning" file="app/Main.java"
        	  line="6" text="set(String Main.staticString)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="8" text="set(String Main.s)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="12" text="get(String Main.staticString)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="14" text="set(String Main.staticString)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="16" text="call(Main.new())"/>
        	<message kind="warning" file="app/Main.java"
        	  line="19" text="call(void Main.go(String))"/>
        	<message kind="warning" file="app/Main.java"
        	  line="23" text="execution(Main.new())"/>
        	<message kind="warning" file="app/Main.java"
        	  line="26" text="execution(void Main.go(String))"/>
        	<message kind="warning" file="app/Main.java"
        	  line="29" text="get(String Main.s)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="31" text="set(String Main.s)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="33" text="handler(RuntimeException)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="35" text="withincode(void Main.go(String))"/>
        	<message kind="warning" file="app/Main.java"
        	  line="42" text="withincode(void Main.stop())"/>
        	<message kind="warning" file="app/Main.java"
        	  line="50" text="preinitialization(app.C.new())"/>
        </compile>
        <run class="app.Main"/>
    </ajc-test>
   <ajc-test dir="new/binaryWarnings/src" pr="37023"
   	title="declare warnings on binary ajc 1.1 classes">
        <compile files="aspects/MainWarnings.java,../injars/app-ajc-1.1.jar">
        	<message kind="warning" file="app/Main.java"
        	  line="6" text="set(String Main.staticString)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="8" text="set(String Main.s)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="12" text="get(String Main.staticString)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="14" text="set(String Main.staticString)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="16" text="call(Main.new())"/>
        	<message kind="warning" file="app/Main.java"
        	  line="19" text="call(void Main.go(String))"/>
        	<message kind="warning" file="app/Main.java"
        	  line="23" text="execution(Main.new())"/>
        	<message kind="warning" file="app/Main.java"
        	  line="26" text="execution(void Main.go(String))"/>
        	<message kind="warning" file="app/Main.java"
        	  line="29" text="get(String Main.s)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="31" text="set(String Main.s)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="33" text="handler(RuntimeException)"/>
        	<message kind="warning" file="app/Main.java"
        	  line="35" text="withincode(void Main.go(String))"/>
        	<message kind="warning" file="app/Main.java"
        	  line="42" text="withincode(void Main.stop())"/>
        	<message kind="warning" file="app/Main.java"
        	  line="50" text="preinitialization(app.C.new())"/>
        	  
        </compile>
        <run class="app.Main"/>
    </ajc-test>
  - source-only 
  - binary (javac) application, source aspect
  - binary (ajc) application, source aspect
  - binary (javac) application, binary aspect (todo)
  - binary (ajc) application, binary aspect   (todo)
  warning line values in the test specifications
  warning text values in the test specifications
  should resolve to unique lines 
  (until we verify based on more than line)
  
  as each other as as specified in MainWarnings.java
  mkdir classes
  javac -d  classes app/Main.java
  jar cfM ../injars/app-javac-1.4.jar -C classes .
  rm -rf classes
  ajc -classpath ../../../lib/test/aspectjrt.jar  \
    -outjar ../injars/app-ajc-1.1.jar app/Main.java
  {ajc} -classpath ../lib/test/aspectjrt.jar  
    -outjar ../tests/new/binaryWarnings/injars/app-ajc-1.1.jar  
    ../test/new/binnaryWarnings/src/app/Main.java
    static String staticString = "hello";
    
    String s = "me";
    
    public static void main(String[] args) {
        String temp = staticString;        // 12
        staticString = temp + " world!";   // 14
        Main main = new Main();            // 16
        for (int i = 0; i < args.length; i++) {
            main.go(args[i]);              // 19
        }
    }
    Main() {                // 23
    }
    void go(String s) {     // 26
        try {
            String temp = this.s;  // 29
            this.s = temp + ", " + s;  // 31
        } catch (RuntimeException e) {   // 33
            
            stop();                      // 35 
        }
    }
    void stop() {                        // 40
        new Main();                      // 42
    }
    C() {                               // 50
    }
    declare warning : staticinitialization(Main)
        : "staticinitializtion(Main)";
        
    declare warning : initialization(Main.new())
        : "initialization(Main.new())";
    declare warning : execution(Main.new())
        : "execution(Main.new())";
    declare warning : execution(void Main.go(String))
        : "execution(void Main.go(String))";
    declare warning : call(Main.new())
        : "call(Main.new())";
    declare warning : call(void Main.go(String))
        : "call(void Main.go(String))";
    declare warning : call(Main.new())
        && withincode(void Main.stop())
        : "call(Main.new()) && withincode(void Main.stop())";
    declare warning : call(void Main.stop())
    && withincode(void Main.go(String))
        : "call(void Main.stop()) && withincode(void Main.go(String))";
    declare warning : get(String Main.s)
        : "get(String Main.s)";
    declare warning : set(String Main.s)
        : "set(String Main.s)";
    declare warning : get(String Main.staticString)
        : "get(String Main.staticString)";
    declare warning : set(String Main.staticString)
        : "set(String Main.staticString)";
    declare warning : handler(RuntimeException)
        && within(Main)
        : "handler(RuntimeException) && within(Main)";
    declare warning : preinitialization(app.C.new())
        : "preinitialization(app.C.new())";
    

   <ajc-test dir="new/options11"  pr="36329"
   	  comment="the line number might change, we're really interested only in the files here"
      title="The compiler crashes when using aspect libraries created without using -noweave">
        <compile files="Main.java,injar.jar,Aspect.java,aspectlib1.jar,aspectlib2.jar">
            <message kind="error" line="0"/>
        </compile>
   </ajc-test>
   
    <ajc-test dir="bugs" title="lame error message: negation doesn't allow binding"
      pr="30663">
        <compile files="BadBindingError.java">
            <message kind="error" line="7"/>
        </compile>
    </ajc-test>
    
    <ajc-test dir="bugs/interSpecials" pr="36936"
      title="Error when introducing members of type Class">
        <compile files="Trg.java,Asp.java"/>
        <run class="Trg"/>
    </ajc-test>
  pointcut p(int i): call(void f(i));
    <ajc-test dir="options/injars/simple" 
      title="options -injars">
        <compile files="Simple.java,main.jar"
        	options="!eclipse"/>
        <run class="Main"/>
    </ajc-test>
======= 7d14432:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 7d14432:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

        	world.showMessage(IMessage.ERROR, 
        	return false;
======= 7d14432:"weaver/src/org/aspectj/weaver/patterns/TypePattern.java"

======= 7d14432:"weaver/src/org/aspectj/weaver/patterns/WildTypePattern.java"



======= f236927:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= f236927:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildManager.java"

======= f236927:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BasicCommandTestCase.java"

======= f236927:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/internal/compiler/batch/BasicCommandTestCase.java"


    <ajc-test dir="bugs" pr="36803"
      title="cflow concretization causing assertion failure">
        <compile files="CflowConcrete.java"/>
        <run class="CflowConcrete"/>
    </ajc-test>
    
    public static void main(String[] args) {
    }
   pointcut notMySelf(): !within(TestAjc) && !cflow(within(TestAjc));
======= 1e502f5:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

======= 1e502f5:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= 1e502f5:"weaver/src/org/aspectj/weaver/patterns/Pointcut.java"

======= 1e502f5:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= 1e502f5:"weaver/src/org/aspectj/weaver/patterns/WithincodePointcut.java"


    <ajc-test dir="bugs" pr="29665"
      title="Inconsistant stack height with around">
        <compile files="StackError.java"/>
        <run class="StackError"/>
    </ajc-test>
    
      title="Ajc 1.1 rc1 java.lang.VerifyError with messy arounds">
        <compile files="aspects/Trace.aj,cap/OptionList.java,DebugTrace.aj">
            <message kind="warning" line="102"/>
        	<message kind="warning" line="124"/>
        	<message kind="warning" line="138"/>
        </compile>
        <run class="cap.OptionList"/>
    </ajc-test>  
    
 
 */
                                 
    declare precedence: DebugTrace, *;
    
    //private static Logger _log = null;
    
    static
    {
        //String log4jPath = GlobalPaths.getPath("properties_dir")+"log4j.properties";
        //PropertyConfigurator.configure(log4jPath);
        //_log = Logger.getLogger(TestLog.class);    
    }
        
    /** define the pointcut for what we trace */
    protected pointcut lexicalScope() :within(cap.OptionList);
        
    protected void log(String data)
    {
        System.err.println("data: " + data);
        //_log.debug(data);        
    }  
    
 * 
 */
    // our internal instance
    private static Trace _trace;
    
    // Call depth on trace
    private static final ThreadLocal traceDepths = new ThreadLocal();
    // An object to synchronize on
    protected static final Object  lock = new Object();
    private static final String NL = System.getProperty("line.separator");
    
    // Space indentation increment
    private static final int INDENT = 4;
    // Used for indentation
    private static final byte[] SPACES = new byte[100];
    
    private static boolean traceActive = true;
    static
    {
        Arrays.fill(SPACES,(byte)' ');
    }
       
    /** Trace constructor. Since this aspect is a singleton, we can be
     * assured that only a single instance exists.  
     */
    protected Trace() {_trace = this;}
    
    /**
    * This abstract pointcut indicates what classes we should trace.  Typically
    * you will define this using a within() PCD. We leave that up to concrete aspects.
    */
    protected abstract pointcut lexicalScope();
    
    /**
     * Common scope for all traces - includes lexicalScope
     */
    final pointcut scope() : if(_trace != null && _trace.canTraceJoinpoint(thisJoinPoint)) && lexicalScope() && !within(Trace+);
    /**
     * This pointcut designates tracing constructors within lexicalScope()
     */
    protected final pointcut constructorTrace() : scope() && (call( new(..) ) || execution( new(..)));
    /**
     * This pointcut designates tracing method executions within lexicalScope()
     */
    protected final pointcut methodTrace() : scope() && (call(* *(..)) || execution(* *(..)));
    /**
     * This pointcut designates tracing exception handlers within lexicalScope()
     */
    protected final pointcut handlerTrace(Exception e) : scope() &&  args(e) && handler(Exception+);
    /**
     * This pointcut picks out joinpoints within this aspect that implement
     * the actual tracing.  Since parameters and return values are printed
     * out via implicit or explicit call to Object.toString(), there is the possibility
     * of an execution joinpoint on toString() causing the trace logic
     * to be re-entered. This is undesireable because it makes the trace output
     * difficult to read and adds unecessary overhead. <p>
     * This pointcut is used within a cflowbelow pointcut to prevent recursive
     * trace calls.
     */
    private pointcut internalMethods() : 
        execution( void Trace.trace*(..,(JoinPoint||JoinPoint.StaticPart),..) );
    /**
     * For methods, we use around() advice to capture calls/executions.
     */
    Object around() : methodTrace() && !cflowbelow(internalMethods())
    {
        traceEnter(thisJoinPoint); 
        try
        {
            Object result = proceed();
            traceResult(result,thisJoinPoint);
            return result;
        }
        finally
        {
            traceExit(thisJoinPoint);
        }
    }
    
    /**
     * For Constructors, we use around() advice to capture calls/executions.
     */
    Object around() : constructorTrace() && !cflowbelow(internalMethods())
    {
        traceEnter(thisJoinPoint); 
        try
        {
            return proceed();
        }
        finally
        {
            traceExit(thisJoinPoint);
        }
    }
    
    /**
     * Trace Exceptions that may occur with constructors or methods
     */
    after() throwing(Throwable e): (constructorTrace() || methodTrace()) && !cflowbelow(internalMethods())
    {   
        traceThrowable(e,thisJoinPoint);
    }
    /**
     * Trace Exception handlers entry
     */    
    before(Exception e) : handlerTrace(e) && !cflowbelow(internalMethods())
    {
        traceHandlerEntry(e,thisJoinPointStaticPart);
    }
    /**
     * Trace Exception handlers exit
     */
    after(Exception e) : handlerTrace(e) && !cflowbelow(internalMethods())
    {
        traceHandlerExit();
    }
    /**
     * Subaspects can override this method to log the data as needed. The default
     * mechanism is to log to System.out
     * 
     * Clients should be aware that this method is not synchronized.
     */
    protected void log(String data) {System.out.println(data);}
    
    /**
     * Can be overridden by subaspects to filter what constructors/methods should be 
     * traced at runtime.  This method is always called prior to the log()
     * method. The default always returns true.<p> Note that exceptions thrown
     * by constructors/methods are filtered through this method.
     * @param currentlyExecutingClass The Class that is currently executing.
     * @param signature The signature of the member being traced
     * @param traceType The type of trace entry (see AspectJ doc for the available types)
     */
    protected boolean isTraceable(Class currentlyExecutingClass, CodeSignature signature,String traceType) {return true;}
    /**
     * Can be overridden by subaspects to filter what exception handlers should be 
     * traced at runtime.  This method is always called prior to the log()
     * method. The default always returns false.<p>
     * Note that exception handlers are catch(...){} blocks and are filtered
     * independently from constructor/method calls and execution.
     * @param currentlyExecutingClass The Class that is currently executing.
     * @param signature The signature of the member being traced
     */
    protected boolean isTraceable(Class currentlyExecutingClass, CatchClauseSignature signature) {return false;}
    
    /**
     * Retrieves the signature of the joinpoint and asks if it can be traced
     */
    private boolean canTraceJoinpoint(JoinPoint jp)
    {
        if ( !traceActive ) return false;
        final Signature sig = jp.getSignature();
        final Object o = jp.getThis();  // current object
        Class currentType;
        if ( o == null ) // must be a static
            currentType = jp.getStaticPart().getSourceLocation().getWithinType();
        else
            currentType = o.getClass();
            
        // dispatch the correct filter method
        if ( sig instanceof CodeSignature )            
            return isTraceable(currentType,(CodeSignature)sig,jp.getKind());
        else
            return isTraceable(currentType,(CatchClauseSignature)sig);            
    }
    
    /**
     * This method creates a trace entry line based on information in the
     * supplied join point.
     */
    private void traceEnter(JoinPoint thisJoinPoint)
    { 
   
        // Get the indent level (call depth for current thread * 4).
        int depth = getTraceDepth(INDENT);
    
        Class[] parameterTypes = ((CodeSignature)thisJoinPoint.getSignature()).getParameterTypes();
        String[] parameterNames = ((CodeSignature)thisJoinPoint.getSignature()).getParameterNames();
    
        boolean isCall = thisJoinPoint.getKind().endsWith("call");
        StringBuffer enterPhrase = new StringBuffer(100);
        enterPhrase.append(getSpaces(depth));
        if ( isCall )
            enterPhrase.append("Call ");
        else
            enterPhrase.append("Entering ");
        enterPhrase.append(methodSignature(parameterNames,parameterTypes,thisJoinPoint));
        
        // Prepare the methods parameter list
        String parmStr = null;
        Object[] parameters = thisJoinPoint.getArgs();
        if (parameters.length > 0)
        {
            String spaces = getSpaces(depth + 6);
            StringBuffer parms = new StringBuffer();
            for (int i = 0; i < parameters.length; i++)
            {
                if (parameters[i] != null && parameters[i].getClass().isArray())
                {
                    // arrays can be huge...limit to first 100 elements
                    final int len = Math.min(Array.getLength(parameters[i]),100);
                    if ( len == 0 )
                    {
                        parms.append(spaces);
                        parms.append(parameterNames[i]);
                        parms.append(": 0 length array");
                        parms.append(NL);
                    }
                    else
                    {
                        Object o = null;
                        for ( int x = 0; x < len; x++ )
                        {
                            parms.append(spaces);
                            parms.append(parameterNames[i]);
                            parms.append("[");
                            parms.append(x);
                            parms.append("]:");
                            o = Array.get(parameters[i],x);
                            try{parms.append(" " + (o != null?o:"null"));}  // implicit toString()
                            catch(Throwable t) {parms.append(" " + parameters[i]);}
                            parms.append(NL);                            
                        }
                    }
                }
                else
                {
                    // Not an array.
                    parms.append(spaces);
                    parms.append(parameterNames[i]);
                    parms.append(": ");
                    try
                    {
                        parms.append("" + parameters[i]);
                    }
                    catch (Throwable t ) {parms.append("" + parameters[i].getClass().getName());}
                }
                parmStr = parms.toString();
            }
        }
        if (parmStr != null)
            enterPhrase.append(NL).append(parmStr);
        log(enterPhrase.toString());
    }
    /**
     * This method creates an exception handler trace entry based on a Throwable
     * and information contained in the join point.
     */
    private void traceHandlerEntry(Throwable t, JoinPoint.StaticPart thisJoinPoint)
    {
        int depth = getTraceDepth(INDENT);
        String phrase = getSpaces(depth) +
                        "Exception caught at: " +
                        thisJoinPoint;
        log(printStackTrace(phrase,t));
    }
    /**
     * This method simply adjusts the trace depth - no other information printed.
     */
    private void traceHandlerExit()
    {
        getTraceDepth(-INDENT);
    }
    /**
     * This method creates a stack trace entry based on a Throwable and
     * information contained in the join point.
     */
    private void traceThrowable(Throwable t, JoinPoint thisJoinPoint)
    {
        int depth = getTraceDepth(0);
        String phrase = getSpaces(depth+4) +
                                        "Throwing Exception at: " +
                                        thisJoinPoint;
        log(printStackTrace(phrase,t));
    }
    private String printStackTrace(String phrase, Throwable t)
      {
    try {
      StringWriter sw = new StringWriter(4096);
      PrintWriter  pw = new PrintWriter(sw,true);
      pw.println(phrase);
      pw.println();
      pw.println("Exception Stack Trace:");
      pw.println();
      t.printStackTrace(pw);
      pw.println();
      pw.flush();
      sw.flush();
      pw.close();
      sw.close();
      return sw.toString();
    }
    catch(IOException IOE) {
      log(IOE.toString());
      return IOE.getMessage();
    }
      }
    /**
     * This method creates a trace exit entry based on the join point
     * information.
     */
    private void traceExit(JoinPoint thisJoinPoint)
    {
        int depth = getTraceDepth(-INDENT);
        // Assemble the method's signature.
        Class[] parameterTypes = ((CodeSignature)thisJoinPoint.getSignature()).getParameterTypes();
        String[] parameterNames = ((CodeSignature)thisJoinPoint.getSignature()).getParameterNames();
        boolean isCall = thisJoinPoint.getKind().endsWith("call");
        StringBuffer exitPhrase = new StringBuffer(100);
        exitPhrase.append(getSpaces(depth));
        if ( isCall )
            exitPhrase.append("Return ");
        else
            exitPhrase.append("Exiting ");
        exitPhrase.append(methodSignature(parameterNames,parameterTypes,thisJoinPoint)).append(NL);
        
        log(exitPhrase.toString());
    }
    /**
     * This method creates a trace result entry based on a result and the
     * join point.
     */
    private void traceResult(Object thisResult, JoinPoint thisJoinPoint)
    {
        Class returnType = ((MethodSignature)thisJoinPoint.getSignature()).getReturnType();
        if ( returnType.toString().equals("void") )
            return;
        int depth = getTraceDepth(0);
        if ( thisResult == null )
            thisResult = "null";
        if ( thisResult.getClass().isArray() )
        {
            // arrays can be Oprah-sized - limit to 100 elements
            final int len = Math.min(Array.getLength(thisResult),100);
            StringBuffer buf = new StringBuffer();
            if ( len == 0 )
                buf.append(">>>zero-length array<<<");
            else
            {
                Object o;
                for ( int i = 0; i < len; i++ )
                {
                    o = Array.get(thisResult,i);
                    buf.append("data[").append(i).append("] ");
                    try{buf.append(o != null?o:"null");} // implicit toString() 
                    catch(Throwable t) {buf.append(thisResult);}
                    buf.append(NL);
                }
            }
            thisResult = buf.toString();                
        }
        thisResult = thisResult.toString();
        
        StringBuffer returnPhrase = new StringBuffer(100);
        returnPhrase.append(getSpaces(depth+2)).append(thisJoinPoint);
        returnPhrase.append(" returned >>>>>>> ").append(thisResult);
        log(returnPhrase.toString());
    }
    /**
     * This method returns the current trace line indentation for the
     * thread.
     */
    private int getTraceDepth(int incr)
    {
            int rc = 0;
            Integer depth = (Integer) traceDepths.get();
            if (depth == null)
            {
                if ( incr > 0 )
                {
                    traceDepths.set(new Integer(incr));
                    return incr;
                }
                else return rc;
            }    
            
            rc = depth.intValue();
                            
            if ( incr > 0 )
            {
                depth = new Integer(rc += incr);            
                traceDepths.set(depth);
            }
            else if ( incr < 0 )
            {
                depth = new Integer(rc + incr);            
                traceDepths.set(depth);
            }
            
            return rc;
    }
    /**
     * This method returns a String containing the number of spaces desired to
     * be used as padding for formatting trace log entries.
     */
    private String getSpaces(int num)
    {
        return new String(SPACES,0,Math.min(num,SPACES.length));
    }
    /**
     * Create a method signature
     */
    private String methodSignature(String[] parameterNames,
                    Class[] parameterTypes,
                    JoinPoint thisJoinPoint)
    {
        // Assemble the method's signature.
        StringBuffer signature = new StringBuffer("(");
        for (int i = 0; i < parameterTypes.length; i++)
        {
            signature.append(parameterTypes[i].getName());
            signature.append(" ");
            signature.append(parameterNames[i]);
            if (i < (parameterTypes.length-1))
                signature.append(", ");
        }
        signature.append(")");
        return thisJoinPoint.getSignature().getDeclaringType().getName() + "." +
            thisJoinPoint.getSignature().getName() +
            signature;
    }
    
 * This class builds a list of &lt;option&gt; HTML elements given a data object,
 * typically a GAPI output object, and a list of accessor method names.  
 * <p>
 * <b>Usage:</b><pre>
 *   // Create the bank account list select
 *   RBBankAcctList2Input acctIn = new RBBankAcctList2Input();
 *   initApiHeader(acctIn.getHeader(),sessInfo);
 *   ArrayList accts = new ArrayList();
 *   getBankAccounts(acctIn,accts);
 *   
 *   String ol = OptionList.createListHtmlFromApi(accts.toArray(),
 *                                   new String[]{"getBankAcctNbr","getBankRtgNbr","getBankAcctTyp"},
 *                                   new String[]{"getBankAcctNbr"},
 *                                   new MessageFormat("{0}"),
 *                                   Integer.parseInt(acctIndex));
 * 
 * </pre>
 * @author Rich Price
 */
    
    
                        
            
    
    
    <ajc-test dir="bugs" pr="29665"
      title="Inconsistant stack height with around">
        <compile files="StackError.java"/>
        <run class="StackError"/>
    </ajc-test>
    
      title="Ajc 1.1 rc1 java.lang.VerifyError with messy arounds">
        <compile files="aspects/Trace.aj,cap/OptionList.java,DebugTrace.aj">
            <message kind="warning" line="102"/>
        	<message kind="warning" line="124"/>
        	<message kind="warning" line="138"/>
        </compile>
        <run class="cap.OptionList"/>
    </ajc-test>  
  
======= 6c9118b:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"

======= 6c9118b:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    private boolean hasExceptionHandlers;
======= 6c9118b:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

            if (len > 0) hasExceptionHandlers = true;
======= 6c9118b:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"


======= 0a8dbde:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java"

    <ajc-test dir="bugs" pr="36564"
      title="Internal compiler error with thisJoinPoint.getStaticPart()">
        <compile files="tjpStaticPart/Test.java,tjpStaticPart/Exceptions.java"/>
        <run class="tjpStaticPart.Test"/>
    </ajc-test>
    

    <ajc-test dir="bugs/interInherit" pr="35725"
      title="Inter type declaration to base class not seen by derived class">
        <compile files="a_impl/AImpl.java,a_impl/Af.java,a_intf/A.java,b_impl/BImpl.java,b_intf/B.java"/>
        <run class="b_impl.BImpl"/>
    </ajc-test>
    
  implements A
  public A AImpl.f()
  {
  }
  A f();
  extends AImpl
  implements B
  public B g()
  {
  }
  
  public static void main(String[] args) {
  	new BImpl().g();
  	new BImpl().f();
  }
  extends A
  B g();

    <ajc-test dir="bugs/interAbstract"
      title="inter-type declaration bug with abstract classes"
      pr="36046">
        <compile files="Driver.java"/>
        <run class="Driver"/>
    </ajc-test>
    
======= 808bae8:"weaver/src/org/aspectj/weaver/bcel/BcelClassWeaver.java"

======= 808bae8:"weaver/src/org/aspectj/weaver/bcel/LazyClassGen.java"

        return methodGens; //???Collections.unmodifiableList(methodGens);
======= 808bae8:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    

======= 989aaf7:"ajde/testsrc/org/aspectj/ajde/AjdeTestCase.java"

======= 989aaf7:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

======= 989aaf7:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

 * Created on 27-Mar-2003
 *
 * To change this generated comment go to 
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
 * @author colyer
 *
 * To change this generated comment go to 
 * Window>Preferences>Java>Code Generation>Code and Comments
 */
======= 989aaf7:"ajde/testsrc/org/aspectj/ajde/NullIdeManager.java"

 *     Xerox/PARC       initial implementation 
 *     AMC  03.27.2003  changed to allow access to NullIdeManager
 * 						as a singleton - needed for verifying
 * 						compiler warning and error messages.
======= 989aaf7:"ajde/testsrc/org/aspectj/ajde/NullIdeManager.java"

======= 989aaf7:"ajde/testsrc/org/aspectj/ajde/NullIdeManager.java"

======= 989aaf7:"ajde/testsrc/org/aspectj/ajde/NullIdeTaskListManager.java"

======= 989aaf7:"ajde/testsrc/org/aspectj/ajde/NullIdeTaskListManager.java"

    	sourceLineTasks.add(new SourceLineTask(message,sourceLocation,kind));
======= 989aaf7:"ajde/testsrc/org/aspectj/ajde/NullIdeTaskListManager.java"

    	sourceLineTasks = new ArrayList();
    

======= 56cc4f2:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"

======= 56cc4f2:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"

======= 56cc4f2:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"

======= 56cc4f2:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"

======= 56cc4f2:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"

======= 56cc4f2:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"

======= 56cc4f2:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseShadow.java"

======= 56cc4f2:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/problem/AjProblemReporter.java"

    <ajc-test dir="bugs" pr="34925"
      title="declare soft and throw statements">
        <compile files="ConvertToUnchecked.java"/>
        <run class="ConvertToUnchecked"/>
    </ajc-test>
    
   compiler crash on yesterday's rc1 build 
 */
    // convert IOExceptions in Foo to PersistenceException
    pointcut module() : within(Foo);
  
    declare soft: (IOException): module();
  public PersistenceException(Throwable cause) {
    super(cause);
  }

    
    <ajc-test dir="bugs" pr="34858"
      title="cflow binding issues with ignoring state">
        <compile files="CflowBinding.java"/>
        <run class="CflowBinding"/>
    </ajc-test>
    <ajc-test dir="bugs" pr="34858"
      title="cflow binding -- original weaver crash">
        <compile files="CflowBindingOrig.java"/>
        <run class="CflowBindingOrig"/>
    </ajc-test>
 * Almost an exact duplicate of the reported issue
 */
    static aspect MockProcessing {
        pointcut testFlow(final Thread thread) : 
            cflow(execution(void run()) && this(thread) && within(Thread)); //  the within is an optimization
        Object around() :
                call(* DummyConfiguration.createRootApplicationModule(..)) &&  testFlow(Thread)
        {
            return null;
        }
    }
    void foo() {
        DummyConfiguration.createRootApplicationModule();
    }
    static Object createRootApplicationModule() {
        return null;
    }
    <ajc-test dir="errors"  
    		title="type not imported in around advice">
        <compile files="TypeNotImportedInAroundCE.java">
        	<message kind="error" line="10"/>
        </compile>
    <ajc-test dir="errors"  
    		title="type not imported in aspect">
        <compile files="TypeInAspectNotImportedCE.java">
        	<message kind="error" line="6"/>
        </compile>
======= 7746fcb:"weaver/src/org/aspectj/weaver/patterns/CflowPointcut.java"


======= db37189:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseAdvice.java"

======= db37189:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

 *     PARC     initial implementation
======= db37189:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseFactory.java"

    
    
    // added this to cover Bugzilla Bug 34820  
    //     ajc -aspectpath fails with NPE for cflow pointcuts 
    int counter = 0;
    before(): cflow(within(client..*)) && call(* println(..)) {
        counter ++;
    }

    
    <ajc-test dir="new" pr="29934"
      title="can't apply around advice to the execution of around advice"
      keywords="from-resolved_10x">
        <compile files="CflowCycles.java"/>
        <run class="CflowCycles"/>
    </ajc-test>
    <ajc-test dir="new" pr="29934"
      title="can't apply around advice to the execution of around advice"
      keywords="from-resolved_10x">
        <compile files="CflowCycles.java"/>
        <run class="CflowCycles"/>
    </ajc-test>
======= 0fb5f69:"weaver/src/org/aspectj/weaver/bcel/BcelShadow.java"


======= ae0ef30:"weaver/src/org/aspectj/weaver/bcel/BcelRenderer.java"

======= ae0ef30:"weaver/src/org/aspectj/weaver/bcel/BcelRenderer.java"

            Utility.createInstanceof(fact, (ReferenceType) world.makeBcelType(i.getType())));
======= ae0ef30:"weaver/src/org/aspectj/weaver/bcel/Utility.java"

======= ae0ef30:"weaver/src/org/aspectj/weaver/bcel/Utility.java"

    public static Instruction createInstanceof(InstructionFactory fact, ReferenceType t) {

======= 0a175d2:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseScope.java"

======= 0a175d2:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseScope.java"

======= 0a175d2:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/EclipseScope.java"

    <ajc-test dir="bugs" pr="32428" 
    		title="can't use pointcuts defined in inner aspects ">
        <compile files="InnerPointcut.java"/>
        <run class="InnerPointcut"/>
    </ajc-test>
    <ajc-test dir="bugs/interfaceNames" pr="32421" 
    		title="can't resolve nested public interfaces (also PR#32399)">
        <compile files="TransactionTest.java,sub/ExecutionMonitor.java,sub/ObserverProtocol.aj"/>
        <run class="TransactionTest"/>
    </ajc-test>
    static aspect TrackTestCase {
    	static String note = "not run yet";
        pointcut testcut() : execution(public void mai*(..));
        before() : testcut() && testcutOuter() {
        	note = "ran";
        }        
    }
    static Transaction theTransaction;
    private void assertCommitted() {
        theTransaction.getCount("method-execution", "commit");
    }
    static aspect MonitorTest {
        declare parents: Transaction implements ExecutionMonitor.MonitoredItem;
    }
    void begin() {
        CommitObserver.aspectOf().add(this);
    }
    static aspect CommitObserver extends ObserverProtocol {
        declare parents: TransactionControl implements Observer;
    }
    public interface MonitoredItem {
        int getCount(String eventType, String eventName);
    }
    public int MonitoredItem.getCount(String eventType, String eventName) {
            return 0;
    } 
    protected interface Observer { }
    public void add(Observer o) {}
======= 0a175d2:"tests/new/EachObjectInDeepPackage.java"

 * Modified this test case to reflect the fact that types in the default package
 * can only be used in named packages if they are imported.
 * 
 * I believe that according to the 1.1 interpretation of the JLS that this import
 * is also disallowed and there is no way to refer to types in the default package
 * from a named package.
 */
  	EachObjectTarget t = null;

    <ajc-test dir="bugs" pr="33948" 
    		title="default constructor inter-type declaration">
        <compile files="ConstructorDeclaration.java"/>
        <run class="ConstructorDeclaration"/>
    </ajc-test>
    public static void main(String[] args) {
        Tester.expectEvent("create");
        new ConstructorDeclaration();
        Tester.checkAllEvents();
    }
    ConstructorDeclaration.new() {
        Tester.event("create");
    }

    
    <ajc-test dir="bugs" pr="33635" 
    		title="Negation of if pointcut does not work">
        <compile files="NotIf.java"/>
        <run class="NotIf"/>
    </ajc-test>
    
    
    <ajc-test dir="bugs" pr="32463" 
    		title="ajc reports error when encountering static declaration of nested classes">
        <compile files="WeaveLocal.java"/>
        <run class="WeaveLocal"/>
    </ajc-test>
    
    // Commenting out the static declaration makes everything work OK
    static
    {
        class StaticNestedClass
        {
        }
    }
    
    public static void main(String[] args)
    {
      System.out.println(new WeaveLocal().handleOrder("test"));
    }
    private String handleOrder(String t)
    {
      return t;
    }
    pointcut withinTest(): within(WeaveLocal);
    pointcut callToHandleOrder() : (withinTest() &&
                             call(* handleOrder(..)));
    Object around(): callToHandleOrder() {
      return "DUMMY inserted by ASPECT" ;
   }
======= d1e5c0a:"weaver/src/org/aspectj/weaver/NameMangler.java"

======= d1e5c0a:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

    /**
     * Returns a ResolvedTypeX object representing the declaring type of this type, or
     * null if this type does not represent a non-package-level-type.
     * 
     * <strong>Warning</strong>:  This is guaranteed to work for all member types.
     * For anonymous/local types, the only guarantee is given in JLS 13.1, where
     * it guarantees that if you call getDeclaringType() repeatedly, you will eventually
     * get the top-level class, but it does not say anything about classes in between.
     *
     * @return the declaring TypeX object, or null.
     */
    public ResolvedTypeX getDeclaringType() {
    	if (isArray()) return null;
    }
======= d1e5c0a:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

======= d1e5c0a:"weaver/src/org/aspectj/weaver/TypeX.java"

    
     * Returns a TypeX object representing the effective outermost enclosing type
     * for a name type.  For all other types, this will return the type itself.
     * The only guarantee is given in JLS 13.1 where code generated according to
     * those rules will have type names that can be split apart in this way.
     * @return the outermost enclosing TypeX object or this.
    public TypeX getOutermostType() {
    	if (isArray() || isPrimitive()) return this;
======= d1e5c0a:"weaver/src/org/aspectj/weaver/patterns/WithinPointcut.java"

======= d1e5c0a:"weaver/testsrc/org/aspectj/weaver/TypeXTestCase.java"

    	assertEquals(t.getOutermostType(), TypeX.forName("java.util.Map"));
    	assertEquals(TypeX.forName("java.util.Map").getOutermostType(), TypeX.forName("java.util.Map"));

    public static void main(String[] args) {
    }
    <ajc-test dir="bugs" pr="33635" 
    		title="Negation of if pointcut does not work">
        <compile files="NotIf.java"/>
        <run class="NotIf"/>
    </ajc-test>
    
    
======= cb77524:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= cb77524:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= cb77524:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"

======= cb77524:"weaver/src/org/aspectj/weaver/patterns/IfPointcut.java"


    
    <ajc-test dir="bugs" pr="30026" 
    		title="problems with finalize call">
        <compile files="Finalizer.java">
            <message kind="error" line="22"/>
        </compile>
    </ajc-test>
    public static void main(String args[]) {
        Finalizer np = new Finalizer();
        np = null;
    }
    public void finalize() throws Throwable {
    }
    pointcut finalizeCall(Object o):
        this(Object+) &&
        this(o) &&
        execution(void finalize());
    void around(Object o) throws Throwable: finalizeCall(o) {
        o.finalize();               // error
        //((Finalizer) o).finalize();   // ok
        proceed(o);
    }

    <ajc-test dir="bugs" pr="31423" 
    		title="Pointcut adviceexecution() does not work">
        <compile files="AdviceExec.java"/>
        <run class="AdviceExec"/>
    </ajc-test>
    public static void main(String[] args) {
    	Tester.checkEqual(Aspect1.ran, 2, "Aspect1 ran");
    	Tester.checkEqual(Aspect2.ran, 2, "Aspect2 ran");
    }
    before() : execution(* AdviceExec.*(..)) {
    }
    
    void around(): execution(* AdviceExec.*(..)) {
    	ran++;
    	proceed();
    }
    before() : adviceexecution() && !within(Aspect2) {
    }
======= 19c3e16:"weaver/src/org/aspectj/weaver/patterns/KindedPointcut.java"

======= 19c3e16:"weaver/src/org/aspectj/weaver/patterns/SignaturePattern.java"


======= d15eb32:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java"

======= d15eb32:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java"

======= d15eb32:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/ThisJoinPointVisitor.java"

    
    <ajc-test dir="bugs/crashes" pr="30168" 
    		title="Error with certain combination of advice">
        <compile files="test/Test3.java"/>
        <run class="test.Test3"/>
    </ajc-test>
   public static void main(String[] args) throws Exception {
      Test3 a = new Test3();
      a.foo(-3);
   }
   public void foo(int i) {
      this.x=i;
   }
   int x;
   pointcut assign(Object newval, Object targ):
      set(* test..*)  && args(newval) && target(targ);
   before(Object newval, Object targ): assign(newval,targ) {
      Signature sign = thisJoinPoint.getSignature();
      System.out.println(targ.toString() + "." + sign.getName() + ":=" + newval);
   }
   /*
   */
   pointcut tracedCall():
      call(* test..*(..))/* && !within(Tracing)*/ && !within(Log);
   after() returning (Object o):  tracedCall() {
      // Works if you comment out either of these two lines
      thisJoinPoint.getSignature();
      System.out.println(thisJoinPoint);
   }

======= 3e2801a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeConstructorDeclaration.java"

======= 3e2801a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/InterTypeConstructorDeclaration.java"

======= 3e2801a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/SuperFixerVisitor.java"

======= 3e2801a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/ast/SuperFixerVisitor.java"

======= 3e2801a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMethodBinding.java"

======= 3e2801a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMethodBinding.java"

======= 3e2801a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/compiler/lookup/InterTypeMethodBinding.java"

======= 3e2801a:"org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/AllocationExpression.java"

======= 3e2801a:"org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/ExplicitConstructorCall.java"

======= 3e2801a:"org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/ast/MessageSend.java"

======= 3e2801a:"org.eclipse.jdt.core/compiler/org/eclipse/jdt/internal/compiler/lookup/MethodBinding.java"

    
    <ajc-test dir="bugs" pr="29959"
            title="super call in intertype method declaration body causes VerifyError">
        <compile files="SuperToIntro.java"/>
        <run class="SuperToIntro"/>
    </ajc-test>
    
    <ajc-test dir="bugs" pr="29959"
            title="super call in intertype method declaration body causes VerifyError">
        <compile files="SuperToIntro.java"/>
        <run class="SuperToIntro"/>
    </ajc-test>
    String A.onlyA() { return "onlyA"; }
    String A.foo() { return "Afoo"; }
    String B.foo() { return super.foo() + ":" + onlyA() + ":" + super.getName(); }
  public static void main(String[] args) {
  	B b = new B();
  	Tester.checkEqual(b.foo(), "Afoo:onlyA:A");
  	Tester.checkEqual(b.onB1(), "Afoo:onlyA:A:onlyA:B");
  	Tester.checkEqual(b.onB2(), "Afoo:onlyA:A");
  }

======= 85a827a:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserProperties.java"

 * 	   AMC 01.20.2003 extended for new AspectJ 1.1 project options
======= 85a827a:"ajbrowser/src/org/aspectj/tools/ajbrowser/BrowserProperties.java"

    
    // 1.1 options
    public Set getInJars( ) {
    	return null;
    }
    
    public String getOutJar( ) {
    	return null;
    }
    
======= 85a827a:"ajde/src/org/aspectj/ajde/BuildOptionsAdapter.java"

 *     Xerox/PARC     	initial implementation 
 *     AMC	01.20.2003  extended for AspectJ 1.1 compiler options
======= 85a827a:"ajde/src/org/aspectj/ajde/BuildOptionsAdapter.java"

======= 85a827a:"ajde/src/org/aspectj/ajde/ProjectPropertiesAdapter.java"

 *     Xerox/PARC       initial implementation 
 *     AMC  01.20.2003  extended for AspectJ 1.1 compiler options
======= 85a827a:"ajde/src/org/aspectj/ajde/ProjectPropertiesAdapter.java"

    
    // following methods added for AspectJ 1.1
======= 85a827a:"ajde/src/org/aspectj/ajde/internal/AspectJBuildManager.java"

  		// AMC - updated for AspectJ 1.1 options
======= 85a827a:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

 *     Xerox/PARC      initial implementation 
 *     AMC 01.20.2003  extended to support new AspectJ 1.1 options,
 * 				       bugzilla #29769
======= 85a827a:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= 85a827a:"ajde/src/org/aspectj/ajde/internal/CompilerAdapter.java"

======= 85a827a:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

 *     AMC 01.20.2003 extended to support AspectJ 1.1 options,
 * 					  bugzilla #29769
======= 85a827a:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

======= 85a827a:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

======= 85a827a:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

======= 85a827a:"ajde/src/org/aspectj/ajde/ui/internal/AjcBuildOptions.java"

======= 85a827a:"ajde/testdata/examples/figures-coverage/figures/Figure.java"

======= 85a827a:"ajde/testdata/examples/figures-coverage/figures/Figure.java"

    //declare soft: Point: call(* *(..));
======= 85a827a:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

        suite.addTestSuite(BuildConfigurationTests.class);
======= 85a827a:"ajde/testsrc/org/aspectj/ajde/AjdeTests.java"

 * Tests that a correctly populated AjBuildConfig object is created
 * in reponse to the setting in BuildOptionsAdapter and 
 * ProjectPropretiesAdapter
 */
======= 85a827a:"ajde/testsrc/org/aspectj/ajde/BuildOptionsTest.java"

 * 	   AMC 01.21.2003 extended to cover new AspectJ1.1 options
======= 85a827a:"ajde/testsrc/org/aspectj/ajde/BuildOptionsTest.java"

======= 85a827a:"ajde/testsrc/org/aspectj/ajde/NullIdeManager.java"

======= 85a827a:"ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java"

 * 	   AMC 01.20.2003 extended to support AspectJ 1.1 options
======= 85a827a:"ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java"

======= 85a827a:"ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java"

    	// AMC - added in path separator since absence was causing
    	// build failures with invalid classpath
    	return testProjectPath + File.pathSeparator +
    		System.getProperty("sun.boot.class.path") + File.pathSeparator +  "../runtime/bin";	
======= 85a827a:"ajde/testsrc/org/aspectj/ajde/NullIdeProperties.java"

    
    public void setInJars( Set jars ) { this.inJars = jars; }
    
    public Set getInJars( ) {
    	return inJars;
    }
    public String getOutJar() {
    	return outJar;
    }
    
    public void setSourceRoots( Set roots ) { this.sourceRoots = roots; }
    public Set getSourceRoots() {
    	return sourceRoots;
    }
    public Set getAspectPath() {
    	return aspectPath;
    }
======= 85a827a:"ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java"

======= 85a827a:"ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java"

======= 85a827a:"ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java"

======= 85a827a:"ajde/testsrc/org/aspectj/ajde/StructureModelRegressionTest.java"

======= 85a827a:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

 *     AMC 21.01.2003 fixed for new source location in eclipse.org
======= 85a827a:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= 85a827a:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= 85a827a:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= 85a827a:"ajde/testsrc/org/aspectj/ajde/StructureModelTest.java"

======= 85a827a:"ajde/testsrc/org/aspectj/ajde/ui/StructureViewManagerTest.java"

======= 85a827a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/ajc/BuildArgParser.java"

======= 85a827a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

 *     Adrian Colyer  added constructor to populate javaOptions with
 * 					  default settings - 01.20.2003
 * 					  Bugzilla #29768, 29769
======= 85a827a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= 85a827a:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AjBuildConfig.java"

======= 85a827a:"org.aspectj.ajdt.core/testsrc/org/aspectj/ajdt/ajc/BuildArgParserTestCase.java"


    
    <ajc-test dir="bugs" pr="29662"
    		title="VerifyError on accessing objects not accessible to the weaver">
        <compile files="AroundAccess.java">
        </compile>
        <run class="AroundAccess"/>
    </ajc-test>
   VerifyError on accessing objects not accessible to the weaver: Incompatible object argument for invokespecial 
 */
    public static void main(String args[]) throws Throwable {
        AroundAccess ve = new AroundAccess();
        ve.foo();
        Tester.checkEqual(FinalizeContract.fromAround, "s3:2,ME");
    }
    protected void foo() throws Throwable {}
    pointcut finalizeCall(Object o):
        this(Object+) &&
        this(o) &&
        execution(void foo());
    void around(Object o) throws Throwable: finalizeCall(o) {
    	String p = getS(3.14, 2); // + Foo.x;
    	fromAround = p + "," + toString();
    	Tester.checkNotEqual(super.toString(), toString());
        proceed(o);
        counter++;
    }

======= c1260e6:"asm/src/org/aspectj/asm/StructureModel.java"

======= c1260e6:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

======= c1260e6:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

======= c1260e6:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

======= c1260e6:"org.aspectj.ajdt.core/src/org/aspectj/ajdt/internal/core/builder/AsmBuilder.java"

======= c1260e6:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= c1260e6:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= c1260e6:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= c1260e6:"weaver/src/org/aspectj/weaver/AsmAdaptor.java"

======= c1260e6:"weaver/src/org/aspectj/weaver/Lint.java"

======= c1260e6:"weaver/src/org/aspectj/weaver/ResolvedTypeX.java"

    public boolean isSynthetic() {
    	return signature.indexOf("$ajc") != -1;
    }
    
======= c1260e6:"weaver/src/org/aspectj/weaver/Shadow.java"

======= c1260e6:"weaver/src/org/aspectj/weaver/bcel/BcelWeaver.java"


======= 2781720:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        if (!(m.isAbstract() || m.isNative()) && m.getCode() == null) {
======= 2781720:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

        	killNops();
======= 2781720:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

======= 2781720:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    	//killNops();
======= 2781720:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

         * a 1:1 mapping.
======= 2781720:"weaver/src/org/aspectj/weaver/bcel/LazyMethodGen.java"

    	InstructionHandle curr = body.getStart();
    	while (true) {
    		if (curr.getInstruction() instanceof NOP) {
    			InstructionTargeter[] targeters = curr.getTargeters();
    			if (targeters != null) {
    				for (int i = 0, len = targeters.length; i < len; i++) {
    				}
    			}
    		}
    	}

======= 99a873c:"weaver/src/org/aspectj/weaver/AjcMemberMaker.java"

======= 99a873c:"weaver/src/org/aspectj/weaver/AjcMemberMaker.java"

======= 99a873c:"weaver/src/org/aspectj/weaver/AjcMemberMaker.java"

======= 99a873c:"weaver/src/org/aspectj/weaver/AjcMemberMaker.java"

